{
    "tristanhimmelman": "Hi there, I'm not near a computer right now but I'm pretty sure you just need to override the init function to fix this error.\n. Thanks for pointing that out! I've updated the example.\n. Yes, that's correct. I guess I was thinking that new Transforms would be created within the project. This doesn't need to be the case though...\n. That is a very nice feature. \nI can add it quite easily for the parsing side of things, however, it is a bit trickier for writing to JSON.\nHow does Mantle handle this feature when creating JSON? Does is create the JSON like this:\n\"distance\" : {\n     \"value\" : 31\n}\n. I've just added this functionality to master.\nCheers,\nTristan\n. Hi guys, \nThanks for pointing this out, I hadn't noticed I was missing this feature. I went ahead and quickly added a new function to Mapper.swift to handle Collections. Moving forward you can map the above JSON like this: \nlet studentArray = Mapper().mapArray(string: studentArrayJSONString, toType: Student.self)\nor if you have a JSON object\nlet studentArray = Mapper().mapArray(JSONArray, toType: Student.self)\nCheers,\nTristan\n. There was no check in place, but I just added one in :).\nSo now, if you are using the mapArray() function, you can expect to be returned an array with one item in it if you pass in a JSON string that is not in the form of a collection. \nCheers,\nTristan\n. What does your Task class look like? I just added a test to ObjectMapper to test parsing Doubles using the above JSON string and all seems fine.\n. That looks like it should work to me. \nI've made quite a number of improvements to ObjectMapper recently so I would recommend you pull down the latest as the issue may only be present in an older version.\nYou will have to update your code to support an update that was made to the MapperProtocol however. It  is a simple change. Let me know if this doesn't resolve your issue.\nCheers\n. I was able to reproduce this issue as well but I have not come up with a fix yet. I'll keep looking into it\n. Great :+1: Thanks for the update\n. I added a test (in ObjectMapperTests.swift) to check this functionality and it is working.\nGiven the following classes:\n```\nclass Response: MapperProtocol {\n    var result: T?\nrequired init() {\n}\n\nfunc map(mapper: Mapper) {\n    result <= mapper[\"result\"]\n}\n\n}\nclass Status: MapperProtocol {\n    var status: Int?\nrequired init() {\n}\n\nfunc map(mapper: Mapper) {\n    status <= mapper[\"code\"]\n}\n\n}\n```\nI was able to map to the response object as follows:\n```\nlet JSON = \"{\\\"result\\\":{\\\"code\\\":0}}\"\nlet response = Mapper().map(string: JSON, toType: Response.self)\nif let status = response.result?.status {\n    println(\"response status: (status)\")\n} \n```\nI hope this helps you.\nTristan\n. Glad you figured it out :)\n. Hi there,\nI believe I know what the issue is. The return type of the transform function should be ObjectType? not NSSet?. Try the following code within your transformFromJSON func:\noverride public func transformFromJSON(value: AnyObject?) -> ObjectType? {\n    var set = NSMutableSet()\n    if let array = value as? [AnyObject] {\n        for object in array {\n            if let dict = object as? [String : AnyObject] {\n                set.addObject(self.mapper.map(dict, toType: EntityType.self))\n            }\n        }\n    }\n    return set as? ObjectType\n}\nWhen you use the operator, your code should look something like this:\nvar set: NSSet?\nset <= (mapper[\"key\"], SetTransform<NSSet, Array<AnyObject>>())\nHope this helps.\nTristan\n. Hi,\nAre the keys determined by parsing the JSON? If so, you could do something like the following:\n```\nlet JSONResponse: Dictionary = ...//this is the above JSON response in dictionary form\nvar users = Array()\nfor (key, value) in JSONResponse {\n    var user: User?\n    user = Mapper().map(value as [String : AnyObject], toType: User.self)\n    if let user = user {\n        users.append(user)\n    }\n}\n```\n. Yes, that's right. Implicitly unwrapped optionals are not currently supported. It's on my todo list!\n. Good idea. I just added a To Do section to the Readme.\nI'm glad you like the library :smile: . Please share and star it \n. Hi Sidney,\nThat approach actually looks good to me (as long as the ContactMap class also conforms to MapperProtocol). What part of the approach do you think is incorrect?\nI suppose it would be nice not to need to create the AddressBookMap class at all and just get an array of ContactMaps. At the moment ObjectMapper doesn't have any mapping methods to accomplish this directly. However, If your JSON is in Dictionary form (not a string) you could use the mapArray function passing in just the array of ContactMaps as JSON. \nvar contacts = Mapper().mapArray(JSON[\"contacts\"], toType: ContactMap.self)\nHope this helps,\nTristan\n. You simply need to cast the AnyObject to dictionary form. The code looks something like:\nlet JSON = data as? [String : AnyObject]\n. The following function already exists to map a JSON string onto an existing object\npublic func map<N: MapperProtocol>(string JSON: String, toObject object: N) -> N!\nIs this what you were looking for?\n. Hey there, \nThanks for bringing this up, I haven't actually run into this issue yet. I would love to support iOS 7 but I haven't had time to explore the best way to do this yet.\nAs a temporary solution, since the ObjectMapper source is quite small you could include the files directly (I know, not a fun solution :( ).\nIf you have suggestions, I'm open to suggestions!\nTristan\n. Hey there,\nI would do something like the following\n```\nfunc map(mapper: Mapper) {\n    var latitude: Double?\n    var longitude: Double?\n    latitude <= mapper[\"latitude\"]\n    longitude <= mapper[\"longitude\"]\nif latitude != nil && longitude != nil {\n    location = CLLocationCoordinate2D(latitude: latitude!, longitude: longitude!)\n}\n\n}\n```\n. Interesting idea. I will put some thought into how I could add this functionality to the library.\nCheers,\nTristan\n. Hey there,\nI've added a new release tag and updated the podspec.\nLet me know if you have any issues.\nTristan\n. Hey there,\nI've just added and pushed the podspec. Let me know if you have any issues\nTristan\n. Hey there, you right, that was missing. I just pushed some code with a new function for you (func toJSONArray). I think this should do the job for you. Let me know if you have any issues. I will update the podspec by end of day. \nCheers\n. I just pushed it to Cocoapods. Everything should be good to go.\n. Hey there,\nWeird issue indeed. It took me a little while to track down...\nThe custom operator that ObjectMapper uses is used for both Serialization and Deserialization of JSON. In deserialization the object on the left of the operator is being modified but not in serialization. Because of this the object being passed on the left side of the operator gets the flag \"inout\" in the operator function definition. This tells the compiler that the variable is modifiable within the scope of the function. This seems to be what Realm is unhappy about even though the object is not being modified during serialization. When I removed the flag and the deserialization code, the crash no longer happens... \nI can't think of a solution off the top of my head to solve this issue. I will put some more thought into it to see if I can come up with a solution.\nTristan\n. Hi @zocario, no unfortunately I have not come up with a solution to this problem yet. \n. No I have not contacted them.\nI believe the crash occurs because ObjectMapper defines the <- functions using the inout flag. For example:\npublic func <- <T>(inout left: T, right: Map)\nThis function is used both for parsing and writing JSON, yet the inout requirement is only necessary when parsing the JSON. Unfortunately I haven't come up with a nice way to split up the mapping functions so that inout isn't present when writing JSON. \n. Nice work, thanks for the addition :+1: \n. If you have instructions for adding ObjectMapper using Carthage that I could add to the Readme file that would be appreciated :)\n. Glad you sorted it out!\n. Another nice addition :)\n. Yeah I've been thinking about this too. I like Mappable. I will go ahead and refactor it. Thanks for the input.\n. All done! Created a new release and also pushed it to Cocoapods\n. @ikesyo is correct. ObjectMapper does work on iOS 7 but unfortunately iOS 7 does not support including dynamic frameworks in a project (It will run with a warning but Apple will reject it if you submit that way). @ikesyo suggestion of using git submodule and adding the files to you app directly is probably your best bet.\n. Yup @mahmed8003 that should work! Good idea, I hadn't thought of doing this.\n. Good find! thanks for the fix\n. @ikesyo I have been using tabs. Thanks for the contributions :+1: \n. @ikesyo One thing I noticed is you updated two functions with code that looks like this (line 46 Mapper.swift):\nlet JSON = parseJSONDictionary(JSONString)\nreturn JSON.map { self.map($0, toObject: object) }\nIt is very concise and I do like the use of the map function, but I think the following might be easier to read:\nif let JSON = parseJSONDictionary(JSONString){\n    return map(JSON, toObject: object)\n}\nreturn nil\nWhat do you think?\n. I believe you have a bug in the date mapping line. It should look like this:\ndob <= (mapper[\"dob\"], DateTransform<NSDate, Double>())\n. Hey Noah,\nThanks for pointing out this issue. I was able to reproduce it. The problem is caused by the generic type within the Mappable protocol (something I was never that fond of having).\nI just pushed some changes which remove the generic type within the Mappable protocol. This should remove the problem you are having.\nCheers,\nTristan\n. By the way, I have included a Test in the ObjectMapperTests.swift file to make sure this functionality doesn't break in the future\n. Hi @stephenyao, please see #40 \n. Hey there, please take a look at #40 \n. Nice update :+1:\nI was hoping to remove the Generic types from the transforms :smiley: \n. Hahaha oops :). Good to know\n. I am considering changing the map function definition in Mappable so that it doesn't conflict with the Swift map function. Do you have any suggestions on naming? I was thinking maybe one of the following:\nfunc mapping(map: Map)\nor\nfunc mappable(map: Map)\n. I hadn't made a plan for Swift 1.2 but a branch sounds like a good solution. I've merge your PR into a branch called swift-1.2.\nThanks for the fixes \n. This no longer seems necessary as of the latest release of iOS 8.2\n. Ah I see, my mistake. \n. Hi there,\nUnfortunately I'm not sure what is going on here. I haven't tried using ObjectMapper with any classes that are visible to Objective-C code.\nOne thing I do notice in the above code is that the Event class doesn't include the initializer. Hope this helps..\n. Please provide some more info so we can help. Your code and the JSON string you are trying to parse would help\n. Hi, you're models look properly formed but your JSON is not. You can test if JSON is properly formed using online tools like: http://jsonformatter.curiousconcept.com/\nI've reformatted your JSON properly below. \n{\n\"completed_in\" : 0.0919,\n\"message\" : \"Login Successful\",\n\"profile\" : {\n    \"current_coordinates\" : \"\",\n    \"email\" : \"juan@delacruz.com\",\n    \"fname\" : \"Juan\",\n    \"id\" : 83,\n    \"lname\" : \"Dela Cruz\",\n    \"mname\" : \"Gitna\",\n    \"mobile_no\" : \"09090909090\",\n    \"photo\" : \"\"\n},\n\"security_key\" : \"4DB585AD-F0D2-28AB-68A7-5F4C43A55051\",\n\"status\" : 1\n}\nThe other issue I see is that you need to pass in a type when you are creating a Mapper object.\nMapper<User>().map(string: JSONString)\nHope this helps\n. Hi there, something like this should work for you (this is using the Alamofire HTTP library): \n```\nfunc getPath(URL: NSURL, parameters: [String: AnyObject]?, completion: ((T!, NSError!) -> Void)!) {\nAlamofire.request(.GET, URL, parameters: parameters)\n    .responseJSON { (request: NSURLRequest, response: NSHTTPURLResponse?, data: AnyObject?, error: NSError?) in\n        if error == nil {\n            if let JSON = data as? [String : AnyObject]{\n                let parsedObject = Mapper<T>().map(JSON)\n                completion(parsedObject, nil)                   }\n            } else {\n                completion(nil, error)\n            }\n        }\n\n}\n```\n. Great, glad you got it working\n. I had a similar issue when using cocoapods beta on a project with multiple targets. It seems that cocoapods only properly configures the first target in the project and the others.\nHave you used Cocoapods to add any other libraries in your project? or is this the first?\n. When you did the installation manually did you follow steps 4-7? I believe this is where you're problem might be coming from. Specifically the last step\n. Hey there,\nThanks for pointing out the bug. \nI've fixed the issue and created some additional tests to make sure the issue doesn't arise again. Please pull the latest to get the fix.\nTristan\n. Hi there, \nThere we a couple issues with the code in your PR. I was able to get your test case working by doing the following:\n- The Generic type within the WithGenericArray needed to conform to Mappable\n- The JSON string passed into the testSubclassWithGenericArrayInSuperclass() function had a bug in the array format\n  I committed my changes and merged them into master if you want to take a look.\n  Tristan\n. Please see PR response #66 \n. Hi, I have not actually used ObjectMapper with an NSManagedObject as of yet. However perhaps @brandonroth can provide insight, as he is the one who contributed the above function.\n. The required init is necessary so that ObjectMapper can instantiate objects during the mapping process. I can't think of a way to remove it at the moment. I'll put some more thought into it.\n. The latest release has an update to the Mappable protocol. It no longer requires the default initializer function. This may resolve the issue you all have been having.\n. init? is part of Mappable but init is not anymore.\npublic protocol Mappable {\n    init?(_ map: Map)\n    mutating func mapping(map: Map)\n}\n. @GABHISEKBUNTY look into the StaticMappable protocol. You should be able to integrate more easily using StaticMappable as it does not require overriding init\n. Ah then I will leave that to @vincent-ch as I am not familiar with his implementation\n. Not a problem! thanks for the input and support :+1: \n. This is an interesting approach. However I think it is a bit more complex then it needs to be. I want to make sure to keep the implementation of Mappable or (ImmutableMappable) as simple as possible. I will think about it some more though...\nHow about this strategy as an alternative:\nWe add a bool member variable to the Map object which monitors whether any mappings were nil or failed to be assigned to their respective field. Checking for nil could easily be done in the subscript function. To check if the values were assigned properly, the Map object would need to be passed into the FromJSON operators (which should be simple) and could simply check if the field was set at the end of each function. Alternatively the check could be done at the end of each Operator function.\nFinally could add a new function to the Mapper class, or create a subclass which would handle immutable mappings by checking the state of the member variable in the Map object.\nWhat do you think of this approach?\n. It seems this https://github.com/thoughtbot/Argo has a similar approach for handling immutable types.\nI'm still debating whether this is something I would like to include. I like how simple the Mappable protocol is at the moment and I am hesitant to add support for immutable types if it means complicating the ObjectMapper interface.\n. Nice, I like this approach :+1: \nDo you want to add some documentation on supporting Immutable types?\n. I just realized there may be an issue with the updates to Mappable protocol. Given a class structure as follows:\n```\nclass Base: Mappable {\n    var base: String?\ninit() {}\nrequired init?(_ map: Map) {\n    mapping(map)\n}\nfunc mapping(map: Map) {\n    base <- map[\"base\"]\n}\n\n}\nclass Subclass: Base {\n    var sub: String?\noverride init() {\n    super.init()\n}\nrequired init?(_ map: Map) {\n    super.init(map)\n    mapping(map)\n}\noverride func mapping(map: Map) {\n    super.mapping(map)\n\n    sub <- map[\"sub\"]\n}\n\n}\n```\nIf we call \nlet object = Mapper<Subclass>().map(JSONObject)\nthe mapping function of the Base class will be called twice. Once when super.init? is called and once when super.mapping is called. Do you have any thoughts on how we can avoid this? \n. Hey there, I have been thinking about changing the operator as well (so that it doesn't override the native operator). I didn't realize that is what was causing the \"ambiguous operator\" error though. I haven't fully decided on which operator I want to use though. I will either use your PR as is or alter it with a different operator. Thanks for the contribution :+1: \n. Hi there, \nBeen thinking about this... you bring up a valid issue. \nI am considering just overloading the function instead. So we would end up with something like this:\n```\npublic func map(JSONString: String) -> N? \npublic func map(JSON: AnyObject?) -> N? \n```\n. I went ahead and made the update I mentioned above in #96 \n. Nice addition! \n. It is entirely possible that mapping is blocking the UI thread. ObjectMapper executes on the thread that it is called from so it is up to the developer make sure that it does not block the UI when executing. \nYou could do you mapping using Grand Central dispatch like this:\n```\n// Do Object mapping on a background queue\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)){\nlet parsedObject = Mapper<T>().map(JSONResponse)\n\ndispatch_async(dispatch_get_main_queue()){\n    // use parsedObject on main thread\n}\n\n}\n```\n. As @ikesyo mentioned you can use a custom transform to achieve what you want. Something like this should work for you:\n```\nlet transform = TransformOf(fromJSON: { (value: String?) -> Int? in\n    return value?.toInt()\n}, toJSON: { (value: Int?) -> String? in\n    if let value = value {\n        return String(value)\n    }\n    return nil\n})\nid <- (map[\"id\"], transform)\n```\nor a more condensed version:\nid <- (map[\"id\"], TransformOf<Int, String>(fromJSON: { $0?.toInt() }, toJSON: { $0.map { String($0) } }))\n. Let's go with Travis CI. I don't have any experience setting up CI with Travis so you can go ahead and take care of that if you want to. I've linked my Github to Travis so it should be ready to go once it is configured. Let me know if you need me to do anything. Thanks!\n. :+1: :+1: not a problem\n. When I added support for nested keys in ToJSON I knew I wanted to refactor it in a more elegant way, but I didn't have the time. Thanks for this :smile: \n. Hey there,\nIt's hard to say what may be the issue here. Can you send a sample of the JSON you are trying to parse?\n. If your domains variable is initialized as follows:\nvar domains: [String] = []\nor \nvar domains: [String]?\nEverything should be fine.\nIf you are still having issues, please include your complete class definition.\nHope this helps!\n. No problem! Glad it's all sorted out. Unfortunately Xcode still seems to struggles with Swift\n. Nice stuff! I've been wanting to add something like this\n. @ikesyo, Nimble looks like an cool library. \nI haven't used Carthage before, but from what I've read it can be used with or without submodules. I think it might be better if the Nimble framework was included (committed) directly to the ObjectMapper repository, that way it can be run immediately after checkout instead of requiring the developer to run carthage checkout. What do you think? \nI'm always a bit hesitant to include external frameworks in a project like this as I like to keep the complexity at a minimum. With that said, I think Nimble will be alright, as it only links to the Test target.\n. I don't mean including the Nimble source code directly.\nWhen using Cocoapods, for example, if you commit the Pods directory to your repository you do not need to run \"pod install\" when pulling the project for the first time. Cocoapods still manages the dependencies, but the project is runnable for new developers.\nIs it possible to commit just the frameworks that are built by Carthage so that new developers can run the project without running any extra scripts? \n. Thanks for the updates. \nI've updated the README doc with carthage instructions for getting the project ready to run tests. Please take a look to make sure I didn't miss anything.\n. I've released a new version today (v0.9). Please pull the latest. This should fix your issue\n. Hi there,\nWhen mapping an array of objects, you should use the following Mapper function:\npublic func mapArray(string JSONString: String) -> [N]\nIf that doesn't work, please paste your ProfileInfo object here so I can check if there are any issues there.\nTristan\n. Good catch! Thx for the fix :+1: \n. How do we update Xcode in Travis? I would prefer to merge this once CI tests are passing.\n. Hi @J-Sizzle, you should using version 0.10, if you are on Xcode 6.3. I will update the Read Me doc.\n. Hi @EvilClay,\nI'm glad you like the library :). \nI'm not convinced that it is better practice to combine all the transforms into one file. As a project grows, maintaining separation of code helps keep things organized. Other than reducing the number of files in the project, I don't really see a benefit to doing this. Thanks for your input though.\nCheers,\nTristan\n. Hi @RyomaKawajiri, this approach looks good to me :+1: \nPlease go ahead and add the missing tests. Thanks!\n. Thanks for the addition :+1:. Merged!\n. Hi there,\nThe main problem here is that you have created a sample project with the exact same name as ObjectMapper. This is causing the compiler to be confused when you write import ObjectMapper.\nYou should start with a fresh project that has a different name like ObjectMapperSample or something.\nHope this helps.\nTristan \n. Here is an example from the tests included in the framework. The key is that any nested objects also need to conform to the Mappable protocol. Also, by default ObjectMapper does not support immutable types (let) as member variables.\nHope this helps\n```\nclass Plan: Mappable {\n    var primaryTask: Task?\n    var tasks: [Task]?\nrequired init?(_ map: Map) {\n    mapping(map)\n}\n\nfunc mapping(map: Map) {\n    tasks <- map[\"tasks\"]\n}\n\n}\nclass Task: Mappable {\n    var taskId: Int?\n    var percentage: Double?\ninit() {}\n\nrequired init?(_ map: Map) {\n    mapping(map)\n}\n\nfunc mapping(map: Map) {\n    taskId <- map[\"taskId\"]\n    percentage <- map[\"percentage\"]\n}\n\n}\n```\n. Glad to help :+1: \n. Hey there, sorry for the inconvenience. I had actually noticed this issue recently as well. Thanks for the fix.\n. Hi there,\nI think the error is in the types you are setting when creating the TransformOf. I believe it should be:\nTransformOf<[Double], CLLocation> instead of TransformOf<[Double], String>\nSo the whole transform would look like this\nlet transform = TransformOf<[Double], CLLocation>(fromJSON: { (value: [Double]?) -> CLLocation? in\n        if let coordList = value as? [Double]\n            where coordList.count == 2 {\n                return CLLocation(latitude: coordList[1], longitude: coordList[0])\n        }\n        return nil\n        }, toJSON: { (value: CLLocation?) -> [Double]? in\n            if let location = value {\n                return [Double(location.coordinate.longitude), Double(location.coordinate.latitude)]\n            }\n            return nil\n    })\nHope this helps and glad you like the library :smile: \n. Hi there,\nI think the simplest solution is to not use an optional value for you image array. So you class would look like this instead:\nclass StyleSheet : Mappable\n{\n     var images: [StyleSheetImage] = []\n}\n. I read this question and responded too quickly. Disregard my last message.\nI believe @tobiasoleary is correct.\n. I believe you are getting this error because you are passing in an optional User object into the toJSONString function. \nI suppose my sample could be updated to the following:\n``` swift\nlet user = Mapper().map(JSONString)\nif let user = user {\n     let JSONString = Mapper().toJSONString(user, prettyPrint: true)\n}\n```\nor you can force unwrap the user object \nlet JSONString = Mapper().toJSONString(user!, prettyPrint: true)\nHope this helps\n. Hi there, happy you like the library :).\nYes I believe it would be possible to add support for Dictionaries with Arrays as values. Specifically what type of Dictionaries are you interested in? Dictionary  or Dictionary ?\nI will add this functionality to my to do list.\n. ahh github messed up my comment. it was supposed to say Dictionary<String, [T:Mappable]> or Dictionary<String, [AnyObject]>. \nThat clears it up!\n. Hey there, I've just released a new version with this functionality: \nhttps://github.com/Hearst-DD/ObjectMapper/releases/tag/0.12\nCheck it out and let me know if you have any issues.\n. No at the moment that functionality does not exist. You have to explicitly let ObjectMapper know how to map each variable.\n. Hi @vitkuzmenko, this looks good to me. It would be great if you could add a test function in CustomTransformTests.swift though. Thanks\n. I agree, I think this would be a good feature addition. \nI will add it when I have some free time. \nThanks\n. Closing this issue as it will be supported when swift-2.0 is merged into master.\n. Thank you!\n. For the time being I think the solution that @ikesyo proposed is adequate. \n. Hey there, I'm glad you like the library :).\nBelow is an example of how you could dynamically map based on a field returned in the JSON.\nHope this helps.\n```\nclass Response: Mappable {\n    var items: [AnyObject]?\nrequired init?(_ map: Map) {\n    mapping(map)\n}\n\nfunc mapping(map: Map) {\n\n    // map items to an array of json dictionaries\n    var itemsJSON: Array<Dictionary<String, AnyObject>>?\n    itemsJSON <- map[\"items\"]\n\n    if let itemsJSON = itemsJSON {\n        items = []\n\n        // loop through the array, checking the type and mapping it accordingly\n        for item in itemsJSON {\n            let type = item[\"type\"] as? String\n            if type == \"type 1\" {\n                if let mappedItem = Mapper<TypeA>().map(item){\n                    items?.append(mappedItem)\n                }\n            } else if type == \"type 2\" {\n                if let mappedItem = Mapper<TypeB>().map(item){\n                    items?.append(mappedItem)\n                }\n            }\n        }\n    }\n}\n\n}\n``\n. Thats right @muescha. My response above was beforeStaticMappable` was even added to the project!. I have created another branch with Swift-2.0 support. All the tests have been updated and are running as well. I have yet to look into added watchOS support though.\nhttps://github.com/Hearst-DD/ObjectMapper/tree/swift-2.0\n. @nrbrook, my new branch is the official one. I have added a watchOS target and scheme. Let me know if you have any issues. Thanks \n. Yes, I plan to make a branch to support swift 2.0 until it is fully released.\n. I have just pushed a branch with support for Swift 2.0:\nhttps://github.com/Hearst-DD/ObjectMapper/tree/swift-2.0\n. hey @cezheng, I just noticed this PR after I made pretty much all the same changes :disappointed:.\nI ended up merging your branch into mine as some of your changes were better. Thanks for the help :+1: \n. Hey there, \nUntil today this wasn't possible. I have just added updated the library to support this. If you pull the latest from master you can access the changes.\nCheers!\n. I don't intend on changing the custom operator at this time <-. Depending on which 3rd party libraries you are using there is always a risk that the operator could conflict. I would suggest making a fork of the library and changing the operator to something new as @cooliceman did.\n. Hey there,\nThis is an interesting idea/problem. Dynamic nested attributes would indeed be a nice addition to ObjectMapper but I can't think of a great solution at the moment (I will put some more thought into it though).\nI do have a suggestion to make your above code simpler. Instead of modifying the map class you can do something like this following (using your Contact class):\nvar contactDict = Mapper<Contact>().mapDictionary(apiResponse)\nif let contactDict = contactDict {\n     for (name, contact) in dict {\n           contact.name = name\n      }\n}\nHope this helps out\nTristan\n. Hi there,\nI am not able to reproduce the problem you are having. I just tested on a project using the iPhone 5 simulator and everything is fine. \nAre you using Cocoapods or Carthage to include ObjectMapper?\nAlso, do you have the latest version of ObjectMapper? MapperProtocol has been removed from the project for some time now.\nTristan\n. By popular demand I have changed the Mappable protocol to the following:\npublic protocol Mappable {\n    static func newInstance() -> Mappable\n    mutating func mapping(map: Map)\n}\nThanks @mladen107 for your fork :+1: , I used a similar approach but simplified a few things.\nLet me know if anybody has issues with the new release https://github.com/Hearst-DD/ObjectMapper/releases/tag/0.14\n. @mladen107 interesting use case. I will consider adding that functionality. Thanks for your feedback\nThe reason I didn't include the map variable in the newInstance() function is because it creates addition boilerplate code that each Mappable model will need to include. I have been making a concerted effort to keep the protocol as simple as possible so I will take some time to think about this change. Also I'll wait to see if anybody else would like this kind of functionality as well.\n. I have made another minor update to the protocol (including the map paramater to the newInstance function for validation purposes).\nHowever, a strategy for supporting Realm using the old protocol was brought to my attention in #168, so I am considering reverting to the old protocol.\n. Yes that's right, ObjectMapper does not support Realm's List type. What @cezheng suggested sounds like a good solution. It would look something like: \n```\nfunc mapping(map: Map) {\n     var destinations = Array()\n     destinations <- map[\"ligneDestinations\"]\n for conn in destinations {\n      connections.append(conn)\n }\n\n}\n```\n. Good idea! :+1: \nGlad to help\n. An official transform for the Realm List type is a great idea... the above example however, I think is too specific for most use cases.\n. Interesting idea. This could useful for many situations. \nI will consider adding this functionality\n. @hjhcn sorry but I haven't added this feature yet. I don't really have time at the moment to add this either. I will open the ticket to keep it visible though.\n. Closing this off.\nI don't think this functionality adds that much value to this project. Standard types are easy enough to map.\n. ObjectMapper doesn't support NSDecimalNumber. We are avoiding Objective-C types when possible. \nIf you need a NSDecimalNumber, you can consider using a CustomTransform to support it.\n. I've thought about this and although it is a neat idea I think it's best to keep the number of custom operators to a minimum to avoid conflicts with other libraries.\nYou can achieve exactly what you are doing above by using the following code however:\nfunc mapping(map: Map){\n    if map.mappingType == .FromJSON {\n        name <- map[\"username\"]\n    } else {\n        name <- map[\"name\"]\n    }\n}\n. At the moment ObjectMapper doesn't support creating JSON from Arrays of Basic types. \nI may add this functionality down the line as it would be a useful feature.\n. Thanks! Unfortunately this feature is still not supported.\n. It would be great if you could create a Pull Request with a fix and a test.\nThanks!\n. For dates that don't conform to the following format yyyy-MM-dd'T'HH:mm:ssZZZZZ, you will need to create your own subclass of DateFormatterTransform\n. Thanks @Torsph :+1: \n. I am working on adding this functionality to master based on @tomco's work. It should be in master soon\n. I have now merged my work back into master #207 . Mapping arrays of arrays should now be functional if you get the latest.\nI plan to tag a new release in the next few days.\n. :+1: \n. This seems like it should be fine to me. \nAnother option which would remove the boiler plate code needed for NSCoding would be to save JSON strings (generated by ObjectMapper) to disk. \nlet mapper = Mapper<User>()\nlet JSONString = mapper.toJSON(user)\n// save JSONString to disk\nYou can then retrieve the JSON string and again use ObjectMapper to build your user object.\n. Here are two functions I used in the past to save and read to disk using ObjectMapper (it may need a bit of tweaking):\n```\nfunc saveToFile(object: N){\n        println(\"PersistentStore: Saving \\'(self.fileName())\\' ((object)) to file...\")\n        let dict = Mapper().toJSON(object)\n        var err: NSError?\n        if NSJSONSerialization.isValidJSONObject(dict) {\n            var jsonData: NSData? = NSJSONSerialization.dataWithJSONObject(dict, options: NSJSONWritingOptions.PrettyPrinted, error: &err)\n            if let error = err {\n                println(error)\n            }\n            if let json = jsonData {\n                var string = NSString(data: json, encoding: NSUTF8StringEncoding)\n            // Create directory if necessary\n            if NSFileManager.defaultManager().fileExistsAtPath(self.filePath().stringByDeletingLastPathComponent) == false {\n                NSFileManager.defaultManager().createDirectoryAtPath(self.filePath().stringByDeletingLastPathComponent, withIntermediateDirectories: false,  attributes: nil, error: nil)\n            }\n\n            // write data\n            let path = self.filePath()\n            var error: NSError?\n            if let string = string {\n                string.writeToFile(path, atomically: true, encoding: NSUTF8StringEncoding, error: &error)\n            }\n\n            if let error = error {\n                println(\"PersistentStore: ERROR writing file: \\(error)\")\n            } else {\n                println(\"PersistentStore: Saved file successfully\")\n            }\n        }\n    } else {\n        println(\"PersistentStore: ERROR: couldn't save to file...\")\n    }\n}\n\nfunc loadFromFile<N: Mappable>() -> N?{\n    let path = self.filePath()\n    println(\"PersistentStore: Loading \\(fileName()) from file... \\(object)\")\n    var error: NSError?\n    let jsonString = NSString(contentsOfFile: path, encoding: NSUTF8StringEncoding, error: &error)\n    if let jsonString = jsonString as? String {\n        return Mapper().map(jsonString)\n    }\n    return nil\n}\n\n``\n. ObjectMapper does in fact supportlet` type variables, however it requires some extra code to accomplish. There is an example which you can check out in ObjectMapperTests.swift:\nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapperTests/ObjectMapperTests.swift#L685\nOtherwise there are other libraries that tackle this requirement more directly for example:\nHimotoki\n. Yes that is correct, you will need a custom transform to make this work.\n. @Busta117 thanks for the addition :+1: \nIt would be great if you could add a few tests as well to ensure everything keeps working well.\n. @IgorBelyayev it seems that sets of Mappable object function correctly, however, sets of primitive type are not currently working. I will try to add this functionality in the near future\n. You can still specify implicitly unwrapped optionals.\nSupport for let variables was never official and required quite a bit of extra code to achieve. This is what is no longer supported based on my latest change. \nBut as you see in #163 I am considering including a Map paramater in the newInstance func which would return the ability to validate based on the JSON.\n. @ldiqual please see this thread #156 \n. @ldiqual, no problem. The line number I referenced in that thread is actually no longer valid... See following link for let implementation:\nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapperTests/ObjectMapperTests.swift#L725\n. I removed the init? method due to popular demand to make the library more compatible with Realm. @mkoppanen I see your point about validation, @mladen107 actually brought up a similar point in the other thread #141 .\nIf it is a feature that many people want, I am not opposed to updating the protocol.\nPerhaps something like:\n```\npublic protocol Mappable {\n    static func newInstance(map: Map) -> Mappable?\n    mutating func mapping(map: Map)\n}\nclass User: Mappable {\n    var username: String?\nclass func newInstance(map: Map) -> Mappable? {\n    return User()\n}\n\nfunc mapping(map: Map) {\n    username    <- map[\"username\"]\n}\n\n}\n```\nWould this be adequate for validation purposes?\n. I just created a branch with my proposed change above. Let me know what you guys think:\nhttps://github.com/Hearst-DD/ObjectMapper/tree/protocol-update\n. @mladen107 is correct. See https://github.com/Hearst-DD/ObjectMapper#subclasses \n. @andrebraga thanks for the feedback. \nI like the idea but default values do not seem to be supported within protocols in the current version of Swift.\n. The protocol-update branch has been merged into master.\nBased on #168, however, I am considering reverting to the old protocol as it seems it was already possible to support realm before my change to the protocol. \n. It can be subclassed or used directly. But when I created it I did so to simplify two other transform classes that were duplicating functionality. \nI haven't personally used it directly but you could do something like this: \n```\nlet formatter = NSDateFormatter()\nformatter.locale = NSLocale(localeIdentifier: \"en_US_POSIX\")\nformatter.dateFormat = \"some format string\"\nlet transform = DateFormaterTransform(dateFormatter: formatter)\ndate <- (map[\"date\"], transform)\n```\n. It can go directly in the mapping function\n```\nfunc mapping(map: Map){\n    let formatter = NSDateFormatter()\n    formatter.locale = NSLocale(localeIdentifier: \"en_US_POSIX\")\n    formatter.dateFormat = \"some format string\"\nlet transform = DateFormaterTransform(dateFormatter: formatter)\n\ndate <- (map[\"date\"], transform)\n\n}\n```\n. no problem :+1: \n. Please see #130 \n. THanks for pointing this out, I have merged your PR.\n. Thanks for the feedback @cezheng. I wasn't aware of your solution for supporting Realm with the old protocol as I haven't used realm myself for iOS development. I will consider reverting to the old protocol based on what you have said. This will have to wait 2-3 weeks however as I am going away for some time. In the mean time, feel free to use a previous version of ObjectMapper as very little has changed other than the removal of init? in the protocol.\n@nrbrook, I will be merging a PR shortly that includes the map variable in the newInstance function to allow for validation prior to mapping.\n. Just a quick update: I have reverted the protocol in the swift-2.0 branch to init?(_ map: Map) instead of newInstance. Thanks for your input guys.\n. I just merged it.\n. At the moment there is no way to do this\n. @mirzadelic unfortunately I am short on time so I haven't had any time to work on ObjectMapper apart from supporting all the Xcode betas\n. After a long delay, we finally have this functionality. See release 2.2.2. Mapper now has a variable shouldIncludeNilValues which if set to true will include null values when generating JSON. . Sorry for the inconvenience, the protocol has been fluctuating in recent updates. I will try to limit changes to the Mappable protocol, however sometimes changes are necessary to add functionality or fix issues. \n. @fresswolf is correct. The swift-2.0 branch is a bit out of date. I will update it today so that it reflects the updated protocol in master.\n. I am using Xcode 7 B6 as well but I am not seeing the issue you are pointing out. See https://github.com/Hearst-DD/ObjectMapper/tree/swift-2.0#subclasses for the syntax to you need use when subclassing Mappable classes.\nI am, however, thinking of changing the protocol to pretty much what you are proposing. See branch protocol-update: https://github.com/Hearst-DD/ObjectMapper/tree/protocol-update. \n. I agree it is a bit strange, but it is a work around. This is one of the reasons I want to change the protocol back to how it used to be.\n. I just merged my protocol-update branch into the swift-2.0 branch. \nThanks for your input :+1: \n. I'm not sure what is happening here... have you resolved the problem?\nIf not, can you please post a full example so we can better understand what is happening.\n. Sorry for the slow response to this issue. I am currently working on a branch that changes the return types for all mapping functions to optionals.\nThanks for your feedback.\n. Key Value Observing is possible with Mappable model classes. This is outside the scope of this project however.\n. Hey there, \nI've made the Map init public. This is in the swift-2.0 branch which will be merged into master soon.\nNote: the Mappable protocol has been reverted to what it was before, so the newInstance equivalent function is now init?\npublic protocol Mappable {\n    init?(_ map: Map)\n    mutating func mapping(map: Map)\n}\n. Hey @gooner22, you bring up a good point :+1: . I went ahead and added the feature. It is currently on the swift-2.0 branch which will be merged into master quite soon.\nYou can now specify on a per mapping basis whether key nesting is enabled:\nswift\nidentifier <- map[\"non.nested.identifier\", nested: false]\nYou can see an example in the NestedKeysTests.swift file.\n. Oops, I forgot to push the code! You should be good to go now.\n. To map data to an object of type City, you must do so as follows:\nlet city = Mapper<City>().map(data)\n. ```\nclass City: Mappable {\n    var state: String?\n    var name: String?\n    var id: String?\nclass func newInstance(map: Map) -> Mappable? {\n    return City()\n}\n\nfunc mapping(map: Map) {\n    state   <- map[\"state\"]\n    name    <- map[\"name\"]\n    id      <- map[\"id\"]\n}\n\n}\n```\nThe above class definition works when I test it. Mapping is done with the following code:\nlet city = Mapper<City>().map(JSON)\nAre you including the Mappable protocol code within your class? If so, you should not. All you need to do is import ObjectMapper at the top of your class\nimport ObjectMapper\n. I apologize for multiple changes to the protocol, I understand that it is frustrating to have to update your models. The protocol should stay consistent moving forward.\nI originally made the change to the protocol to make ObjectMapper compatible with Realm (see #141) . However, it turns out that the change was not necessary for Realm compatibility (see #168).\nI evaluated both versions of the protocol and decided that the original protocol was better. Using init?(_ map: Map) follows typical platform conventions and thus is clearer and more developer friendly. Furthermore, using init? means we can remove the need for a static function in the protocol which could not be subclassed unless the static keyword was swapped with class (see #186).\n. @damienrambout, I have done something similar to what you are trying to do. Below is code that should handle your situation. It should go within the mapping function of whatever object contains your array of media.\nSide note: As far as I know, using your previous implementation with newInstance, only the Media specific mappings would be made (ie the variables within the Movie struct that are not within Media, would not get parsed). I may be wrong about this, but I don't think ObjectMapper can do this...\n```\n// map raw json data to mediaJSON variable (array of JSON objects)\nvar mediaJSON: Array>?\nmediaJSON <- map[\"media\"]\nvar media = Array()\n// loop through mediaJSON and map each item based on the 'type' key within the JSON\nif let mediaJSON = mediaJSON {\n    for JSON in mediaJSON {\n        let type = JSON[\"type\"] as? String\n        if let type = type {\n            var mediaItem: Media?\n        switch type {\n        case \"Movie\":\n            mediaItem = Mapper<Movie>().map(JSON)\n            break\n        case \"Series\":\n            mediaItem = Mapper<Series>().map(JSON)\n            break\n        case \"Episode\":\n            mediaItem = Mapper<Episode>().map(JSON)\n            break\n        default:\n            mediaItem = nil\n        }\n        if let mediaItem = mediaItem {\n            media?.append(mediaItem)\n        }\n    }\n}\n\n}\n```\n. @edias what do you mean by implicit mapping? Do you mean that mappings are automatically generated based on the member variables within a class?\n. @edias, as ObjectMapper is currently designed, this is not possible. ObjectMapper uses static compile time information to map JSON to objects. What you are requesting would require analyzing objects at runtime using reflection which is comparatively very slow (and not very well supported in Swift). So although it would be more developer friendly to not need to define mappings, it would slow down your app performance significantly. \n. @mladen107 @damienrambout I added Class cluster support in a branch as an experimental feature #211. Feedback appreciated\n. It looks to me like your code should work. Can you be more specific about the issue you are having?\nOne note:\nYou should be able to remove the toClass: T.Type section of the function definition. If you remove it, you will just have to define the type of the variable which this function assigns to so that the compiler can infer the type T. For example your code would look something like:\nlet answer: Answer = parse(data: someData)\ninstead of: \nlet answer = parse(data: someData, toClass: Answer.self)\nIf you are planning to use this code to parse HTTP calls into models, you might be interested in checking out https://github.com/tristanhimmelman/AlamofireObjectMapper. It is an extension to Alamofire which uses ObjectMapper to automatically convert your responses to objects. Hope this helps\n. I've created a tvOS branch and made the same change to the podspec there\n. Thanks, a fix has been merged into master #204 \n. The Swift 2.0 branch has actually already been merged into master. You can use the latest release or point directly at master.\n. Thanks for your PR. It has been merged via another PR which I created since I fixed a few other instances of the same problem :+1: \nhttps://github.com/Hearst-DD/ObjectMapper/pull/204\n. Yes ObjectMapper works with swift 2.0 and iOS 9. \nCan you post your JSON response? Otherwise its difficult to figure out what is going wrong.\n. Ahh I just spotted your error.\nObjectMapper has different functions which you can use for mapping. Currently you are getting a string response from Alamofire. Since the response is a string you need to unwrap the optional due to the map function definition:\npublic func map(JSONString: String) -> N?\nHowever, you can also use Alamofire to return a JSON object (I recommend this approach). Given the JSON object you would use this function:\npublic func map(JSON: AnyObject?) -> N?\nIf you choose to use my recommendation, your code would look like this:\nswift\nAlamofire.request(.POST, \"http://192.168.0.12:57336/Account/LogOnMobile\", parameters: loginParams)\n        .responseJSON { (request: NSURLRequest?, HTTPURLResponse: NSHTTPURLResponse?, result: Result<AnyObject>) -> Void in\n        let user = Mapper<Forecast>().map(result.value)\n}\nLastly, since you are using Alamofire and ObjectMapper together, I recommend you check out https://github.com/tristanhimmelman/AlamofireObjectMapper. It automatically converts your Alamofire responses into models using ObjectMapper.\n. By default, when there is a . in a key, ObjectMapper assumes the key is a nested key: https://github.com/Hearst-DD/ObjectMapper#easy-mapping-of-nested-objects\nHowever, I recently added the ability to turn off nesting. You can do so with the following code:\nfunc mapping(map: Map){\n    issuedDate <- (map[\".issued\", nested: false], LongDateTransform())\n}\n. A tvOS branch has been created: https://github.com/Hearst-DD/ObjectMapper/tree/tvOS\n. This has already been done. Feel free to switch to version 0.17 \n. I've just created an experimental branch with support for Class clusters:\nhttps://github.com/Hearst-DD/ObjectMapper/tree/class-clusters\nI created a Mappable sub protocol called MappableCluster:\npublic protocol MappableCluster: Mappable {\n    func newInstance(map: Map) -> Mappable?\n}\nThere is an example in the ClassClusterTests.swift file. Here it is:\n``` swift\nclass Vehicle: MappableCluster {\n    var type: String?\nrequired init?(_ map: Map){}\n\nfunc newInstance(map: Map) -> Mappable? {\n    if let type = map[\"type\"].currentValue as? String {\n        if type == \"car\" {\n            return Car(map)\n        } else {\n            return Bus(map)\n        }\n    }\n    return nil\n}\n\nfunc mapping(map: Map) {\n    type <- map[\"type\"]\n}\n\n}\nclass Car: Vehicle {\n    var name: String?\nrequired init?(_ map: Map){\n    super.init(map)\n}\n\noverride func mapping(map: Map) {\n    super.mapping(map)\n\n    name <- map[\"name\"]\n}\n\n}\nclass Bus: Vehicle {\n    required init?(_ map: Map){\n        super.init(map)\n    }\noverride func mapping(map: Map) {\n    super.mapping(map)\n}\n\n}\n```\nUsage: \nswift\nlet JSON = [[\"name\": \"Honda\", \"type\": \"car\"], [\"type\": \"bus\"]]  \nif let vehicles = Mapper<Vehicle>().mapArray(JSON){\n    print(vehicles)\n}\n@andrebraga @hankbao feedback is welcome\n. @damienrambout, I agree it is not that safe, but as you said I cannot think of another solution at the moment.\n@andrebraga why wouldn't this approach work for keyed cache system? It seems to me that the newInstance function could returned the cached/persisted object.\n. @andrebraga I agree that creating the dummy instance is not a great approach. However, I don't think there is an approach to checking is a generic type T is a subtype which creating the dummy variable. Any suggestions on that implementation would be appreciated\n. @andrebraga I didn't realize I had made the newInstance function an instance function. That was definitely an accident. I am updating the code.\n. @andrebraga thanks for the pointer. I've pushed my changes using your suggestion\n. @laxmisa, I am still evaluating whether I should update the protocol or merge this into master. Sorry for the delay. I will make sure to keep this branch up to date in the meantime \n. @mabril it seems to me that you don't need to use this custom transform at all...\nDoes the following not work?\nfilters <- map[\"Filters\"]\n. Closing as class cluster support has been added to master.\n. Please see #130 \n. I don't think Realm will change this requirement. I think your best bet is to add some logic prior to mapping the primary key. Something like this maybe:\n``` swift\nfunc mapping(map: Map){\nif primaryKey == nil {\n    primaryKey <- map[\"primaryKey\"]\n}\n\n}\n```\n. You can map the primary key value to a local variable if you need to inspect it. Or you could map it to another member variable that is not set as the primaryKey\nfunc mapping(map: Map){\n    var key: String?\n    key <- map[\"primaryKey\"]\n}\n. You cannot get the date into the TotalMapper object automatically but you can map the data into a dictionary of TotalMapper objects where the keys are the dates.\nI think something like this should work\n``` swift\nclass ReportMapper:Mappable{\n    var customerID:Int?\n    var totals:[String:TotalMapper]?\nfunc mapping(map: Map){\n     customerID <- map[\"customer_id\"]\n     totals <- map[\"totals\"]\n}\n\n}\n```\n. No problem! Thanks for the help :+1: \n. A simple loop after the items variable is mapped would be the easiest way to achieve this:\n``` swift\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    document_no <- map[\"document_no\"]\n    items <- map[\"items\"]\nfor item in items {\n    sum += item.price\n}\n\n}\n```\n. You can use a Custom transform to convert the String to a Double. Something like this:\nlet transform = TransformOf<Double, String>(fromJSON: {\n    $0 == nil ? nil : Double($0!)\n}, toJSON: {\n    $0.map { String($0) }\n})\nprice <- (map[\"price\"], transform)\n. ObjectMapper is a strongly typed compile time mapping library. This means that it cannot dynamically read variable name strings to use for mapping. I have considered adding this type of functionality, however, (for the moment) I have decided against it as the reflection APIs are quite slow which would result in worse mapping performance. I believe that maintaining fast mapping is preferable to reducing the amount of boilerplate code (which is pretty minimal in my opinion).\n. @lexrus I don't actually have any benchmarks... this is information that I have heard anecdotally from others and blogs. It's possible that it is incorrect...\nWith that said, I think it may be difficult to integrate reflection into this library due to it's static nature. If you have time to experiment, however, that would be great! Any help/feedback is much appreciated.\n. Your struct should look something like the following. If you want to map generic types, you need to ensure that the generic type conforms to Mappable as well.\n``` swift\nstruct Result: Mappable {\n    var code = 0\n    var msg = \"\"\n    var data: T?\nrequired init?(_ map: Map){\n\n}\n\nmutating func mapping(map: Map) {\n    code <- map[\"code\"]\n    msg <- map[\"msg\"]\n    data  <- map[\"data\"]\n}\n\n}\n```\n. ObjectMapper cannot handle a generic type that is sometimes Mappable and sometimes not. So you will have to structure your code differently to make things work in this case\n. At the moment this functionality does not exist.\n. Happy Friday fellas! Thanks for the appreciation :+1: \n. @fwielstra support for immutable properties is a relatively new feature and definitely has not been tested as throughly the standard mapping. \n. Good catch. No we definitely do not need two podspecs. I will remove this one. Thanks\n. I just cut a new release, 0.18. Cheers!\n. The tvOS branch should now build correctly. Make sure xcode 7.1 is selected on the command line and you are using the latest version of Carthage.\n. Hi @najiji, thanks for you feedback. You bring up a good point. Many people seem to get confused by this. I have a branch where I has added this which I hope to merge into master soon.\n. My recommendation would be to do something like the following:\n```\nextension Spot {\n  func mapping(map: Map) {\n    name <- map[\"name\"]\nvar lat: Double?\nvar lng: Double?\nlat <- map[\"lat\"]\nlng <- map[\"lng\"]\n\nlocation = Location(lat: lat, lng: lng)\n\n}\n}\n```\n. Hi @rajavikram, using AlamofireObjectMapper, I don't believe there is any way to do this yet (although it sounds like a good feature which I will consider adding).\nIf you use ObjectMapper separately to map your JSON, you can use the following function to map JSON to an existing object:\npublic func map(JSON: AnyObject?, toObject object: N) -> N\n. Immutable mappings in ObjectMapper are an experimental feature so unfortunately they do not support all data types or transformations\n. Immutable mappings in ObjectMapper are an experimental feature so unfortunately they do not support all data types or transformations.\n. As I mentioned here #232, immutable mappings in ObjectMapper are an experimental feature so unfortunately they do not support all data types or transformations.\n. @rokob at the moment, immutable mappings are an experimental feature of ObjectMapper so it is not guaranteed that most features will work. If you use optional types, mapping arrays will work without a problem.\n. Seems like this is an issue with Xcode. I tested it with a couple frameworks and they both had the problem you mentioned above. See the following for a potential solution:\nhttp://stackoverflow.com/questions/26073088/swift-frameworks-do-not-work-with-build-configurations-named-other-than-debug\n. The reason this is happening is that the function toJSONString returns String?. You need unwrap the string before mapping it to an object using \npublic func map(JSONString: String) -> N?\n. Hi @u10int, unfortunately, at the moment there is no way to do this.\n. Are you importing the library?\nYou should have the following line at the top of you file:\nimport ObjectMapper\n. No problem!\n. Hey @wieseljonas,\nThe reason this fails has to do with your transforToJSON function. It should return an array of JSON dictionaries and not Mappable objects.\nThis should work:\nfunc transformToJSON(value: List<T>?) -> Array<AnyObject>? {\n        if value?.count > 0 {\n            var result = Array<AnyObject>()\n            for entry in value! {\n                result.append(Mapper().toJSON(entry))\n            }\n            return result\n        }\n        return nil\n    }\n. Please post some code so we can try to help you.\n. I also don't really see a problem to using both SwiftyJSON and ObjectMapper in a project.\nI also have created an Alamofire extension... shameless plug:\nhttps://github.com/tristanhimmelman/AlamofireObjectMapper\nI'd be interested to see the extensions you guys have created.\n. @kaandedeoglu, interesting... I might add that. Thanks for sharing :+1: \n. Thank you sir\n. Hey @wenxin3262, pretty print is still working for me. However, I did notice that it doesnt work if you print() an optional value. You have to make sure the value is unwrapped.\nHope this helps\n. Yeah I believe @Glagnar is correct. I will make sure to update the same code.\n. ObjectMapper supports mapping arrays using the mapArray function. Setting the generic type of Mapper with an array type may work in certain circumstances, but is not actually supported.\n. Hi @kiliankoe, I'm not exactly sure why the date is parsed incorrectly. CustomDateFormatTransform simply uses the following NSDateFormatter to convert date strings\nlet formatter = NSDateFormatter()\nformatter.locale = NSLocale(localeIdentifier: \"en_US_POSIX\")\nformatter.dateFormat = formatString\nwhere formatString is the string you pass in above.\nIf you have a NSDateFormatter that object that handles your conversion properly, I recommend you use DateFormatterTransform instead, as it is initialized with a NSDateFormatter object.\n. Glad you sorted something up :+1:.  A custom transform is perfectly good approach.\n. Hi @ruben-samsonyan, nice idea! Thanks for the pull request. \nIt is important that new features, such as this one, are paired with a unit test to ensure functionality doesn't break down the line. Could you please add a test for this?\nThanks!\n. Thanks @ruben-samsonyan for the addition :+1: \n. At the moment, ObjectMapper doesn't officially support a better solution for this. \nI do however, have a branch class-clusters which has a potential solution.\nIt provides a Mappable sub protocol called MappableCluster. This subprotocol allows you to return a new instance used for mapping based on the passed Map variable. This would allow you to inspect the map for a specific key and return the correct type of object for mapping. \nstatic func newInstance(map: Map) -> Mappable?\nSee https://github.com/Hearst-DD/ObjectMapper/blob/class-clusters/ObjectMapperTests/ClassClusterTests.swift\nThis isn't a generic approach, but it does encapsulate the code used for selecting the type of object that is mapping. \nHope this helps\n. Hi @rikoschmidt, in your case, I think just making the currentKey value public would work using the class cluster branch. \nOtherwise using the latest version of ObjectMapper, you can do something like the following within your mapping function:\nvar animalsJSON: Array<Dictionary<String, AnyObject>>?\nanimalsJSON <- map[\"animals\"]\nif let animalsJSON = animalsJSON {\n    for JSON in animalsJSON {\n        // get JSON key and map object accordingly \n        if key == \"Dog\" {\n            let animal = Mapper<Dog>().map(JSON[\"dog\"])\n        }\n    }\n}\n. Hey @jrpdrummer, this is concerning. Off the top of my head I'm not sure what could be causing this slow down.\nIn your build settings, have you tried setting the \"Optimization Level\" to \"Fast, Whole Module Optimization\"?\n. I'm interested in more clarification as well... If have a minute could you post an example of what you are explaining to provide more insight. Thanks!\n. I committed a performance fix yesterday, please pull the latest. Hopefully this helps y'all\nhttps://github.com/Hearst-DD/ObjectMapper/commit/3656dc404baa66cbf46908af8f2cc68040ada5d8#commitcomment-14183661\n. @manojmahapatra, unfortunately no, I have not made any progress on this issue. I personally did not experience the change in performance as most of the JSON files that I parse are relatively small. If someone could post a JSON file and the corresponding swift models that would help me in recreating the issue and finding performance issues.\n. Thanks @maksTheAwesome \nInteresting @manojmahapatra. Are you calling func mapping from within your init function? I'm guessing you are since in your example the mapping function is no longer present. This would mean that all mappings were being triggered twice which would certainly decrease performance. The init? function is mainly intended for validation of the incoming map object, not to perform mapping.\nWhen I added MappableCluster support with the following snippet\nif let klass = N.self as? MappableCluster.Type {\n        if var object = klass.objectForMapping(map) as? N {\n            object.mapping(map)\n            return object\n        }\n    }\nI tested performance and I didn't see any significant changes. Also, I believe that this ticket was opened before I even added support for MappableCluster, so I'm not sure whether this is the culprit.\nI will do some more testing though to see if I can figure anything else out. \n. I have just pushed a fix to master which has given me a 40-50% speed increase.\nAfter some investigation, I found a major performance issue at the following line:\nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Core/Map.swift#L70\nFor every single mapping, we were creating an ArraySlice object with the results of key.componentsSeparatedByString(\".\"). This was evidently a big bottleneck and definitely an unnecessary operation.\nI have now added a simple check in the subscript function which greatly improved performance.\nFurthermore, I have another potential change in mind which could improve performance another ~10%. Instead of checking all mapping keys for a . to determine if they are nested, I may force developers to pass in a flag to let ObjectMapper know the mapping in question is nested.\nSo, \nname <- map[\"user.name\"]\nwould become\nname <- map[\"user.name\", nested: true]\nSince this is a breaking change, I will hold off on pushing this for the moment. \nPlease test and let me know if this helps in your situation.\n. @manojmahapatra thats great. Just to be clear, is there an improvement of ~1 second, or does the test which you performed above now take ~1 second? \n. @mathieudebrito I just released 1.1.3 with the fix mentioned above. Please let me know if you see an improvement\n. @mathieudebrito thanks a lot for the testing :+1: \n. Hi @scottrhoyt, thanks for the details of you're implementation. I haven't had to deal with anything like this but your approach is seems great :+1: . Off the top of my head I can't think of a better way to approach the problem.\nI haven't heard of anybody else dealing with this situation so at this point in time I don't think I will be incorporating this into the project. However, if others bring up the same issue, I will look to this for reference.\nCheers,\nTristan\n. JSON String generation is handled by NSJSONSerialization.dataWithJSONObject(). ObjectMapper simply passes it a dictionary of the mapped object. So the sorting of the generated JSON string is out of our control\n. ObjectMapper is not actually setting each property during JSON generation. This issue is happening due to the fact that ObjectMapper handles object creation and JSON creation via the same mapping operator <-. This mapping operator is defined with an inout flag which signals to the system that the passed in object may be modified. This is likely what is triggering the didSet call.\nSo unfortunately, there is no mechanism available for writing JSON which will not trigger the didSet closure.\n. Hi @alfonso-matos-financefox-ch,\nAs I mentioned in the AlamofireObjectMapper issues response, you should be able to find some CustomTransforms that handles Realm Lists if you search the closed issues here.\n. I am closing this PR at the moment. It has never passed the continuous integration tests which is the first criteria I look at before accepting a PR.\nSecondly, I don't really follow what you are adding here other than ToJSON for nested arrays\n. This is an interesting scenario that I have not really considered.\nI cannot think of a solution for this given the current code base.\nPerhaps the Map object, could carry some data that could be used to distinguish the type of mapping. I'll have to think about it some more. Any ideas or pull requests are welcomed\n. I've just added a new feature to ObjectMapper that should resolve this issue. You now have the ability to create a custom object which gets passed around during mapping. This object just needs to conform to the new MapContext protocol (an empty protocol). You can store any information you want in this object and subsequently use it to make decisions about how to map any given class/struct. The MapContext object will be passed around in the Map object. \nSee documentation:\nhttps://github.com/Hearst-DD/ObjectMapper#mapping-context\n. Hi @scottrhoyt, thanks a lot for the PR and the in depth discussion. Sorry about the slow response. \nI quite like your idea to extend the Mappable protocol to include init functions! I am currently in the midst of making some tweaks to your branch and will soon merge it into master.\nThanks a lot :+1: \n. Hey @scottrhoyt, yes I have actually. I think I will merge it very soon. PR https://github.com/Hearst-DD/ObjectMapper/pull/328 includes your changes and is up to date with master. My only real concern is that unfortunately Xcode doesn't seem smart enough to provide code completion suggestions for the Mappable extension. If it weren't for that I would have merge this a while back....\n. I agree this could be improved. I have marked as an enhancement to keep track. Pull requests are welcomed\n. This has been fixed on master thanks to @jdzak \n. ObjectMapper doesn't actually support arrays of optionals. When mapping arrays, it only adds objects that have been successfully mapped.\n. This would be a nice addition but I see no simple way to get rid of the init? function. I am marking this as an enhancement to keep track of the idea\n. I have just released v1.5.0 which now supports implementing ObjectMapper within an extension. If you wish to do this, please use the StaticMappable protocol. With this update StaticMappable no longer requires the init?(_ map: Map) function which was causing difficulties.\nHope this helps you all\n. Hi @dotmike, this is actually the expected output. ObjectMapper uses the keys passed into the map object to construct the JSON string.\n. @dotmike, you can check the mappingType property of Map to detect when the mapping is FromJSON or ToJSON. ex:\nfunc mapping(map: Map) {    \n    if map.mappingType == .FromJSON {\n         login <- map[\"email\"]      \n    } else {\n         login <- map[\"login\"]\n    }\n}\n. Thanks @jdzak \n. Sorry this is not currently a supported type. Perhaps you will need to create a custom transform to handle it.\n. I think you need to add Mappable to the function generic type definition. Something like this:\nlet s = \"{\\\"code\\\":200,\\\"data\\\":\\\"aa\\\"}\"\npublic func test<T: Mappable>(p1:T){\n       let m = Mapper<T>().map(s)\n       print(m)\n }\n. The majority of the time, and the way I designed the library to be used, is to put all your mappings within the mapping function.\nIf you are using immutable mappings (which again I will stress are experimental and don't support all functionality), you should put your mappings inside the init? function.\n. I would set it up the following way:\n```\nclass User: Mappable {\n    var userID: String?\n    var email: String?\nrequired init?(_ map: Map) {\n}\n\nfunc mapping(map: Map) {\n    userID    <- map[\"user_id\"]\n    email    <- map[\"email\"]\n}\n\n}\nclass Response1: Mappable {\n    var user: User?\nrequired init?(_ map: Map) {\n}\n\nfunc mapping(map: Map) {\n    user    <- map[\"data\"]\n}\n\n}\nclass Response2: Mappable {\n    var users: [User]?\nrequired init?(_ map: Map) {\n}\n\nfunc mapping(map: Map) {\n    users    <- map[\"data\"]\n}\n\n}\n```\n. Hi there, there is already an example of how to set up a Mappable model in the Read Me\n. Hi @yomajkel, as mentioned in the docs, mapping immutable properties is an experimental feature so we  do not guarantee functionality or provide support for issues with this feature currently.\nI have actually just removed it from the ReadMe as I don't recommend developers use this approach at the time being.\nIf you want to continue using ObjectMapper, I recommend you stick to the regular mappings described in the ReadMe.\nTristan\n. Hi @elpic, when I changed the protocol to init? I didn't realize that people were using the newInstance function as you described above. I am considering reverting to the old protocol, however it is a significant change that will affect many people so I am taking my time with the decision.\nYou can achieve polymorphic mapping in the current design, however, it requires a bit more code. Given the following JSON:\nJSON\n{\n    \"object1\" : {\n        \"type\": \"dog\",\n        \"name\": \"joey\"\n     },\n    \"object2\": {\n        \"type\": \"cat\",\n        \"name\": \"fluffy\" \n    }\n}\nYou can map the objects based on the type flag as follows:\n```\nclass Response: Mappable {\ninit?(_ map: Map){}\n\nfunc mapping(map: Map){\n\n    var object1JSON: Dictionary<String: AnyObject>?\n    object1JSON <- map[\"object1\"]\n    if let type = object1JSON?[\"type\"] where type == \"dog\" {\n         let dog = Mapper<Dog>().map(object1JSON)\n    } \n}\n\n}\n```\nHope this helps!\n. @elpic, unfortunately I haven't had the time to consider this any more. So for the time being I do not plan on changing this.\n. @mirzadelic are you asking how to convert the array into a JSON string that you can submit to a server?\n. I just realized ObjectMapper doesn't have a method for generating JSON strings for arrays. I will add that shortly.\nFor now you can do the following:\nvar JSONString = \"[\"\nfor object in array {\n    JSONString += Mapper().toJSONString(object) + \",\"\n}\nJSONString += \"]\"\nNow you can submit that JSONString to the server using Alamofire. If you have questions about Alamofire usage, please post those in the Alamofire Github issues.\n. I actually just pushed an update that includes the new toJSONString function that takes an array of objects. If you use latest on master you will have those changes.\n. Swift 2.0 is already supported.\n. It's hard to say, but it sounds to me like there may be an authentication issue when you make the first call to get events. \nCan you print out the response string when the call fails to give use more info. You can do that by appending the following after the responseArray closure\n.responseString { response in\n                print(\"Success: \\(response.result.isSuccess)\")\n                print(\"Response String: \\(response.result.value)\")\n        }\n. @nikita-leonov I removed it from the README because the feature is still experimental and not well tested. There were a lot of reported issues with it so I decided to hide it until it is ready\n. I've created an issue for discussing immutable types and how we may add support for them. Please continue the conversation here #383 if you have anything to add.\n. Hi there, you can do this by making your Result class look like the following and making sure your generic type also conforms to Mappable\n```\nclass Result: Mappable {\n    var result: T?\nrequired init?(_ map: Map){\n\n}\n\nfunc mapping(map: Map) {\n    result <- map[\"result\"]\n}\n\n}\n``\n. Hi @iandundas , that's right you can just add your owninit()for your own use. However, it does not need to be prefixed withrequiredand I don't need to make the classfinal` either (that is up to you).\n. Hmm that is strange. If you look at the ObjectMapperTests file you will see several examples where this isn't necessary.\n. I'm not sure exactly what is going on but I don't think this should compile as is.\nLanguageResponse has no super class so the mapping function shouldn't have a call to super in it and should not be mark as override. I've just tested this out with my suggested change and everything seems to work fine\n. No problem\n. You can use the following function: \n///Maps an object that conforms to Mappable to a JSON dictionary <String : AnyObject>\npublic func toJSON(var object: N) -> [String : AnyObject]\nlet dictionary = Mapper().toJSON(object)\n. Unfortunately, currently ObjectMapper doesn't support this type of generic argument. If you need to handle arrays, you will need to use the mapArray function.\n. You can do just like that. You just need to add you own init() function.\n. ```\nclass Article: Mappable {\n    var name: String?\n    init(){}\n///objectmapper stuff below\n\n}\nlet article = Article()\narticle.name = \"Name\"\n```\n. See the following function in the Mapper class\n/// Maps an array of Objects to a JSON string with option of pretty formatting  \npublic func toJSONString(array: [N], prettyPrint: Bool = false) -> String?\n. Sorry I have no timeline to merge this feature at the moment.\n. Thanks for the PR. \nBased on the actual changes in the code, I'm guessing you were only experiencing this issue when the mapping in question was using a Custom transform?\n. At the moment, there is no better solution to this problem.\n. As this functionality is not fully functional and properly tested I am not promoting it's use or showcasing how it works at this time.\n. Sorry but I have no idea what is happening here... is this still a problem for you?\n. Sorry to hear that. I'm really not sure why you were experiencing the problem\n. At the moment, unfortunately ObjectMapper doesn't support inserting a value for nil objects. You will need to do this manually after the toJSON call. There is another open issue marked with \"enhancement\" that mentions this as well. The feature may be added in the future.\n. Unfortunately I don't believe there is a more efficient way to write this. The Swift compiler seems requires this syntax to understand the code\n. Hi @esetnik, I'm glad you like the library :).\nI think an optional parameter would be fine in this situation. Thanks!\n. No at the moment there is no way to automatically delete the orphaned objects. You will have to process that and manually delete them\n. Sorry for the slow response... my initial guess is that there is a problem with the JSON as what you pasted above is not valid JSON.\nIs this the actual server response that you are receiving? \n. Can you please post the output using this:\n.responseString { response in\n    print(\"Response String: \\(response.result.value)\")\n}\n. So what I notice is that sometimes the value for current is \"0\" and sometimes it is 0. If it is surrounded by quotations, ObjectMapper will not be able to parse it as an Int?.\nThe same thing with the null value for color. Since it is null instead of \"null\" ObjectMapper cannot parse it as a String\n. I'm not sure I follow...\nThe User class is not part of the framework, it is only part of the tests for the framework. You do not need to include those in your project.\n. Closing this as solving #264 fix this as well.\n. Nested keys also support keys like this distance.0, where 0 is the index within the array. Hope this helps\n. I believe the mapping will just be nil in this situation\n. Hi @maksTheAwesome, unfortunately there is no functionality present to track progress. I cannot think of a simple way to incorporate that either. \nGlad you like the library :+1: \n. You're right, this is an issue that I never noticed. I'll think about how this could be addressed.\nI have a work in progress branch which may address this issue in another fashion. The branch is called class-clusters. It provides the following extension to the Mappable protocol:\npublic protocol MappableCluster: Mappable {\n    static func objectForMapping(map: Map) -> Mappable?\n}\nThe objectForMapping function can be used to return an existing instance of an object to be used for mapping. The function can also be used to return a subclass of the object which implements it to support class clusters.\nI may change the naming of this protocol as it supports more than just class clusters...\n. I should also note that I am considering simply replacing the init?(_ map: Map) requirement with the above function.\n. I just merged a fix that handles updating children objects when mapping using the toObject function:\nhttps://github.com/Hearst-DD/ObjectMapper/pull/310\nThis fix does not handle arrays or dictionaries of child objects though.\nBy the way, I made use of your test case :+1: \n. Yep I think you're right about that\n. I will be merging an update that handles sub dictionaries shortly. I will close this ticket up after that considering there is no safe way to handle Arrays and Sets\n. I'm not sure I like the idea of assigning currentValue on init... perhaps we can just make JSONDictionary public, to allow you to use it as follows:\nfunc mapping(map: Map) {\n        relationship = Mapper<OtherObject>().map(map.JSONDictionary)\n        field <- map[\"field\"]\n    }\n. I have also tried to do this, but unfortunately, given the current structure of the code, converting Map to a struct is not possible.\nLike I mentioned in your pull request, perhaps exposing the JSONDictionary would solve your problem. Let me know what you think\n. @baydet that is an interesting idea. I will put some thought into it. Thanks :+1: \n. Hey @tapi, I follow the example you are giving, but I'm not exactly sure what functionality you want to add. If you look here https://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Core/Operators.swift#L259 \nthere is an overload for <- where T is Mappable\n. Actually... it does exist:\nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Core/Operators.swift#L120\n. Ahh I see. In that case, feel free to add and make a pull request :+1: \n. Hmmm that is odd...\nI just copy pasted those functions into the Operators file and was able to build the project without a problem. \n. I'm on the same version.\nI do however get a seg fault with the following code due to the FromJSON line:\npublic func <- <T: Mappable, Transform: TransformType where Transform.Object == T>(inout left: T!, right: (Map, Transform)) {\n    let (map, transform) = right\n    if map.mappingType == MappingType.FromJSON {\n        let value: T? = transform.transformFromJSON(map.currentValue)\n        FromJSON.basicType(&left, object: value)\n    } else {\n        let value: Transform.JSON? = transform.transformToJSON(left)\n        ToJSON.optionalBasicType(value, map: map)\n    }\n}\nReplacing it with the following fixes the issue\nFromJSON.optionalBasicType(&left, object: value)\n. I actually get some errors when I run the above code in a playground... here is the output:\nPlayground execution failed: /var/folders/4b/0j46cqdj5mbf_gt2qbdmvnl40000gn/T/./lldb/69414/playground91.swift:14:1: error: cannot convert value of type 'String' to expected argument type '_?'\none <- two\n^~~\n/var/folders/4b/0j46cqdj5mbf_gt2qbdmvnl40000gn/T/./lldb/69414/playground91.swift:30:1: error: cannot convert value of type 'String' to expected argument type '_?'\none <- two <- three <- four <- five <- six\n^~~\nInterestingly, the implicitly unwrapped optional does work in the custom operator.\nHowever, if you bring the inout flag into the equation, the implicitly unwrapped optional will no longer work in the custom operator.\n. Ahh looks like you beat me to the punch! lol\n. I'm not 100% sure I follow the question... but I think the answer is the later. ObjectMapper in general assumes that map.currentValue will be of the expected JSON format \n. Closing this off as your PR is merged. Thanks again.\n. Yeah I've been seeing this too... sometimes it resolves itself by just restarting the build. I just did that, lets see if it fixes itself.\n. Thx, these changes definitely make the code easier to read\n. I have some basic performance tests on the class-cluster branch. I will be merging those into master soon.\nThere is definitely some room for improvement here however\n. Sorry I never got back you, but so far this all looks good to me. I'll check back after you add tests.\nWould you mind giving me an example use case of how you are planning to use this functionality\n. Gotcha, I see where this is going now. Thanks for the details. Off the top of my head it seems that most of this can be handled by objectForMapping, but I may be missing something.\n. Yeah I guess I hadn't considered the use case properly. I dont think objectForMapping would work for the url string as ObjectMapper does expect a dictionary for any Mappable object mappings\n. Yeah I think I prefer your use case. It is a bit more demonstrative of what you can do with this feature.\nJust thinking out loud here... here's another approach you might be able to use:\n```\nfunc mapping(map: Map){\n    let team1URL: String\n    team1URL <- map[\"team1_url\"]\nteam1 = Team.loadTeamUsingURL(team1URL) // load stub model which is later loaded\n\n}\n```\n. Yep those are good points. please proceed \n. Looks good to me. Thanks for the addition! :+1: \n. Thanks for the help but I've decided not to include this PR based on the above conversation.\n. Yes, this behaviour should already be working. As long as your enum strings match the strings in the resource-type array. \nex:\nenum EnumType: String {\n        case document = \"document\"\n        case media = \"media\"\n    }\nThen you can map just as you do regularly using \nresourceType <- map[\"resource-type\"]\n. I think this approach is fine. Otherwise you can look into implementing NSCopying, however that will likely create a lot more boilerplate code. I can't speak to the performance NSCopying vs ObjectMapper though...\nCheers,\nTristan\n. Can you paste the model you are trying to map here to give me a better idea of the problem?\nThanks\n. I've added a new case in the ToJSON file which should hopefully fix your problem. Please get the latest from master\n. This should work, however you have an error in your Subclass model:\nbaseMessage <- map[\"foo\"]\nshould be:\nfoo <- map[\"foo\"]\n. Hmm thats odd... because I recreated your scenario and didn't have any problem after fixing that typo\n. I'm not sure if this is another typo, but the subclass mapping function should also be prefixed with override\n. The following is what I tested successfully: \n```\nfunc testSubclass(){\n        let JSON = \"{ \\\"message\\\": \\\"This message is for the base class\\\", \\\"foo\\\" : { \\\"field1\\\": [ \\\"value1 for field1\\\", \\\"value2 for field1\\\" ], \\\"field2\\\": [ \\\"value1 for field2\\\" ] }}\"\n        let subclass = Mapper().map(JSON)\n        print(subclass?.foo[\"field1\"]?[0])\n    }\nclass BaseClass: Mappable {\n    var baseMessage: String!\n\n    required init?(_ map: Map) {\n        // noop\n    }\n\n    func mapping(map: Map) {\n        baseMessage <- map[\"message\"]\n    }\n}\n\nclass SubClass: BaseClass {\n    var foo: [String : [String]]!\n\n    required init?(_ map: Map) {\n        super.init(map)\n    }\n\n    override func mapping(map: Map) {\n        super.mapping(map)\n        foo <- map[\"foo\"]\n    }\n}\n\n```\n. Thanks for this. I pulled your branch and made a few modifications and then merged them into master. This should have been marked as closed automatically by github but it wasn't for some reason...\n. ObjectMapper should be able to handle this if you create an Enum like the following: \nenum Gender: String {\n    case Female = \"1\"\n    case Male = \"2\"\n}\n. You can do something like the following:\nfunc mapping(map: Map){\n    userPromotion = Promotion(map: map)\n    userPromotion.mapping(map: map)\n}\n. No it's not in the documentation at the moment...\n. No problem!\n. Since what you are doing above is not the standard usage of ObjectMapper the toJSON doesn't work as it should.\nYou can probably get it to work by doing the following\nfunc mapping(map: Map){\n    if map.mappingType == .FromJSON {\n        userPromotion = Promotion(map: map)\n        userPromotion.mapping(map: map)\n    } else {\n        userPromotion <- map[\"promotion\"]\n    }\n}\nHowever this won't produce the same formate as the JSON you are receiving originally... it will add the userPromotion JSON as a sub object of the User JSON \n. I'm okay with making those functions public. Would you have the time to create a Pull Request with the change? (I'm crazy busy at the moment)\n. @levieggert thanks. \n@sgermain06 you can search the Github issues as others have discussed this in the past. I personally have not used ObjectMapper with CoreData so I cannot help.\n. @gezman... I don't use CoreData much in general.\nHowever, I'm pretty sure you can use ObjectMapper along side CoreData\nTake a look at the objectForMapping function. This will allow you to create / or retrieve an existing object to use during mapping. \nAlso looking into the MapContext. You could use that to store you CoreData coordinator and have it passed around within the Map object during mapping. \nHope this helps\n. I'm not sure I want to make the JSONDictionary public. You can already access the data as follows:\nmap[\"key\"].currentValue\nFor an example of polymorphic classes see the https://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapperTests/ClassClusterTests.swift\n. If you look at the ClassClusterTests file that I linked above, you will see an example of how to handle this situation in a better way (when I answered your previous issue, the above functionality didn't exist). Look at the Vehicle class in that Test file. It implements MappableCluster and returns the correct subtype based on the data in map.\n. Thanks guys!\n. You can actually already check for the existence of a key as follows:\n```\nif map[\"tracks\"].currentValue != nil {\n}\n```\nA hasKey function could make this a bit clearer though. I will consider adding it\n. The easiest way I can think of would be to convert the object to a String using the toJSON function. Then save that String into the user defaults. When you retrieve the string you use ObjectMapper to convert it back to an object\n. Hi there,\nIf you use the master version of ObjectMapper there is new functionality that supports class clusters (essentially the situation you are describing above). See the test class below for an example:\nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapperTests/ClassClusterTests.swift\nHope this helps\n. I think this should work:\nfunc mapping(map: Map) {\n    created_at <- (map[\"created_at\"], TransformOf<Int, String>(fromJSON: { $0 == nil ? nil : Int($0!) }, toJSON: { $0.map { String($0) } }))\n    if created_at == nil {\n        created_at <- map[\"created_at\"]\n    }\n}\n. 1. If you use the Transform many times, then it is not a bad idea to define it using let, however it shouldn't make a big difference either way.\n2. There should be very little if any performance impact when using the TransformOf you included above. It could slow down depending on what you do in the Transform however.\n3. Glad to help :)\n. Unfortunately ObjectMapper cannot support automatic mappings based on variable names due to it's compile time nature\n. You can type po user to inspect the object. Or po user.name to see the name variable.\n. Hi @FrancisBaileyH, sorry for the slow response. I finally got a chance to test out your example project. It turns out that this issue has been fixed in subsequent releases of ObjectMapper. Please use anything after v1.1\n. I think you may need to put an if clause around the primary key so that it is only set once:\nif id == nil {\n    id <- map[\"id\"]\n}\nThe ObjectMapper operator <- has an inout flag on the left hand side variable. This is only necessary when mapping data from JSON. However since the <- operator is also used for writing JSON, Realm assumes that the values are being modified when toJSONString is called.\n. I think this might work:\nif map.mappingType == .ToJSON || id == nil {\n    id <- map[\"id\"]\n}\n. I think you may need to store the primaryKey in another variable that is not used directly in the mapping.\nid <- map[\"id\"]\nif primaryKey == nil {\n    primaryKey = id\n}\n. @ivanruizscm, I have never really used Realm with ObjectMapper so I'm not sure if there is a better solution. Perhaps you can just map the primary key to a different variable and set the real primary key variable once during the first mapping?\n. This should work if your user object implements the Mappable protocol. Please see the test classes in ObjectMapper if you need example code to help you out.\n. Thanks!\n. There is no reason to have it hidden other than keeping a simple interface. \nI've decided to go ahead and make the change you suggested. On master the toJSONString function is now public static\nThanks\n. You should be able to use map[\"address_components.0.long_name\"] however I think there is a bug. There is a PR that I hope to review soon that should fix the issue you are describing.\n. This should now be working on master\n. Thanks @yukiasai \n. Ok will do, thx\n. Cool idea. I don't think I will have time to build such a utility but I would welcome it if someone else built it.\n. Very cool @amolgupta. I haven't had a chance to test it out yet but I think this could be a pretty useful utility.\n. After some more thought, I don't think including model generation is in the scope of this project. \nBut I do agree with @tobiasoleary. I am happy to accept PRs with links to model generating projects in the Readme.\n. Thanks @paradoxally \n. No ObjectMapper is not designed to work this way. It does not ensure that all mappings are successful in order to return a mapped object.\nAlso, var pulley: String! is an optional value, it is just automatically unwrapped for you.\n. Which version of ObjectMapper are you using? Please trying using the master version as it has fixes for this.\n. No problem, glad I could help! \nI've been meaning to make a release for a while. I will try to get one out in the next few days\n. I ended up creating a new release just now. You can go ahead and use v 1.1 using cocoapods \n. The init method is necessary so that ObjectMapper can create an instance of the object it is trying to map. It also allows you to do some validation before mapping. If a certain key that you need doesn't exist you can return nil from init?(_ map: Map) and the mapping will not happen.\n. @eoinoconnell The mapping could technically occur within the init function, but if we took that approach we would lose the ability write JSON and to map JSON to an existing object.\n. The readme has now been updated with the information above\n. I think you may be able to use MappableCluster in this situation.\npublic protocol MappableCluster: Mappable {\n    static func objectForMapping(map: Map) -> Mappable?\n}\nMappableCluster is a sub protocol of Mappable which can be used to return an existing instance to use for mapping.\nIt was built to support returning a subclass of a given object but it can also be used to returned a cached object.\nSee the following example: https://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapperTests/ClassClusterTests.swift#L66\nI think you should be able to include the Realm query within the objectForMapping function in the Human class. \nHope this helps.\n. Sorry I do not use CoreData much so cannot be of much help with this... are you still having the problem?\n. See the following:\nhttps://github.com/Hearst-DD/ObjectMapper/issues/337\n. I think this issue may have to do with Alamofire more than ObjectMapper or AlamofireObjectMapper.\nDid you test this with the regular Alamofire .response function?\n. Please see this issue https://github.com/Hearst-DD/ObjectMapper/issues/143\n. Is this still a problem?\nIf so, how are you including ObjectMapper into your project?\n. Are you using Carthage or Cocoapods?\n. I'm not sure why y'all are having issues. I just successfully tested including ObjectMapper using both Cocoapods and Carthage.\n@Laban1, in your example you are missing the required init?(map: Map) function.\n. @younanjo can you please post the Mappable model (in the testModel.swift file) you are trying to use, there may be an issue there.\nAlso, make sure to include the following line: import ObjectMapper\n. For the sake of simplicity I have chosen to not support immutable types in ObjectMapper for the time being. I have some experimental code in the project that supports it, however it is not fully tested and I am not recommending it's use at the moment. If you need immutable types there are other projects such as Argo which support it.\n. @frankus I just created an issue for this #383 \n. Please see this issue #143 \n. Hi @ogezue, sorry for the slow response. \nThere are many examples of how you can test your mappings in the project already. Check out the tests directory: https://github.com/Hearst-DD/ObjectMapper/tree/master/ObjectMapperTests \n. Either of the last two ways is fine. I would probably go with map[\"id\"].value() though\n. Unfortunately, at the moment ObjectMapper doesn't support mapping arrays of Optionals the way you are describing.\n. Thanks @KevM, closing this. \n. It is not necessary to pass in the type information when using the toJSONString function as the type gets inferred by the passed in object.\n. If you look through the tests for this project you will see many instances of toJSONString. No warnings or errors are raised. I've also tested it in another project and I am not see the issue. \nAre you using the latest version of xcode/swift?\n. @nilswiersema  I believe your function will work if you change it to the following:\nfunc foo<T: Mappable>(bar: T)\n{\n    let string = Mapper().toJSONString(bar)\n}\n. Can you please paste the JSON you are receiving from the API\n. The reason your boolean values are not mapping correctly is because the JSON values are strings instead of booleans. A properly set boolean value in JSON is true not \"true\"\n. I am open to using the above imports instead of importing all of Foundation.\nCan you please create a pull request with the change?\n. 1. The init?(_ map: Map) function is required to ensure that ObjectMapper can create new instances of your classes during mapping. It also allows developers to perform validation on the JSON prior to mapping. For example you may want to check if a certain key exists in the JSON. If it doesn't exist, you can cancel the mapping by returning nil.\n2. Struct support is listed in the Features of ObjectMapper. It is also stated in the Basics section where there is an example of a struct mapping.\nHope this helps. I will add more information on the init? function in the README when I get a chance\n. I am not experiencing this issue. Also, I do not see the \"Enable Bitcode\" flag in the tvOS target. Let me know if this is still a problem for you.\n. Closing this as I accepted your PR #379 \n. Hi @zulkis, I think I would prefer to just make JSONDictionary a public variable in this situation.\n. Usually if you get a nil object returned from ObjectMapper it is because there is a problem with your JSON input. Either it is not valid JSON or it cannot be parsed and cast into type [String : AnyObject].\n\nNon numeric value from json is failing for numeric model's property\n\nThis is expected behaviour. ObjectMapper expects the JSON to be of the appropriate type to be parsed, otherwise it returns nil. You can always use a Transform (see README) if you need to map a non numeric value to a numeric model. For example \"grade\" : \"100\" contains a String value where you may really want an int. A transform can convert this during mapping.\n. Hi there, I just tested this code and I am not getting any errors. Are you still having this problem?\n. Are you using the following function for mapping Mapper<Type>().mapArray()?\n. Since you the type you are receiving is an Array you need to use the mapArray function. You will need to add some logic that handles responses with top level arrays differently.\n. Since your JSON is in the form of Dictionary you should use probably be using  the following function to perform your mapping:\nMapper<Schedule>().mapDictionary(JSONString) \nHope this helps.\n. @khunshan , you're right, I didnt notice the arrays. In that case you would probably need to make a model that represents the whole JSON.\nThis model could have a dictionary of arrays in it like this:\nvar schedules: Dictionary<String, Array<Schedule>>\n. Hi @zulkis, I just released v1.1.2 of ObjectMapper. The AlamofireObjectMapper podspec should get the latest automatically now.\n. Support for immutable variables has just been merged into master \ud83d\udc4d  #592 . Release 2.1.0 has the latest. Thanks again @devxoul \n. Hi @ldiqual, thanks for your work and sorry for the slow response.\nI think this is an interesting approach, specifically the change to init. I will spend some more time thinking about it as I have to be very careful when changing the protocol. But it seems from my initial observations that it wouldn't have too much impact on existing functionality.\nWith regards to the mapping() function and having a serializing operator only, I don't think I would move forward with this approach. I like the simplicity of having one place where all mapping information goes (unless you are using immutable types). Furthermore (and more importantly), this would remove the ability to map JSON to an existing object.\n. @ldiqual sorry for the slow response. I've been quite busy so I haven't had much time to consider making significant changes to this project. I do like your approach in the PR (and suggestions) but I haven't decided yet on whether to proceed. \nOne of the main reasons I am hesitant is that I am considering another change to the Mappable protocol. Something like this:\npublic protocol Mappable {\n    static func objectForMapping(map: Map) -> Mappable?\n    mutating func mapping(map: Map)\n}\nSwitching the init? function with objectForMapping would allow ObjectMapper to be used in an extension to a final class. It would also simplify integration with Realm. Both of these are issues that come up pretty frequently. \nIf I took that approach, I think we could still incorporate your work by creating a protocol extension like the following:\npublic protocol ImmutableMappable: Mappable {\n    init(_ map: Map) throws\n}\n. @ldiqual I've finally had some free time to put thought into this and I'd like to move forward with the init throws approach that you started here. I've created a new branch called immutable-mappings where I merged your code with the latest changes on master. If you are still up for it, I'd really appreciate your help with this (others are welcome to help out as well). \nI agree that for immutable variables, the current mapping operator is not that well suited. I'm considering creating a new operator that would be used just for the purposes of writing JSON. My only concern with this approach is that it will create a lot of duplicated code that may be tedious to maintain... \nAnyways, I think the protocol change is a good place to begin. \n. The immutable-mappings branch is up to date and running well. It is based on the work of @ldiqual . Not all types are supported but most are.\nIf anybody would like to contribute, that would be great.\n. @hebertialmeida unfortunately there is no documentation at the moment. However, you can check out ImmutableObjectTests.swift for working examples. Classes and Structs are likely handled the same way\n. Closing this. I have a PR coming soon with support for immutable variables\n. Thanks @cwalo \n. As far as I can tell, the ENABLE_BITCODE flag is only available on the iOS target. I cannot find the option to enable it for the tvOS or watchOS targets\n. In the link that @Tombio posted it states: \n\nNote: For iOS apps, bitcode is the default, but optional. For watchOS and tvOS apps, bitcode is required. If you provide bitcode, all apps and frameworks in the app bundle (all targets in the project) need to include bitcode.\n\nFrom this, I'm assuming that bitcode is enabled by default in the target (hence why I can't find the setting)\n. Thanks @honghaoz. I've enabled bitcode for watchOS and tvOS using your solution. I just released v1.1.4 with the fix.\n. The above example doesn't correctly implement Mappable. You are missing the init? function.\nOtherwise, I'm not sure what is causing the seg fault...\nI did just pushed an update which enables bitcode for tvOS and watchOS. Please make sure you are using that as having bitcode enabled is a requirement for tvOS.\nHope this helps\n. Hi @popaaaandrei,\nI'm pretty sure the reason the mappings are failing for the above large values is that those values are larger than the maximum Int value. You should probably be mapping those values into Int64 or NSNumber. Please note that I have not really tested ObjectMapper with Int64... it should work, but it's possible that it doesn't behave as expected...\nFor reference, here is the max Int value: 2147483647\n. As far as I know, there is no easy way to protect against integer overflow. \nI think it's probably best to just use a type that will be certain to work for all cases and all devices (ie Int64)\n. You should be able to build a Transform that handles this. This example below converts a String to an NSURL.\n```\npublic class URLTransform: TransformType {\n    public typealias Object = NSURL\n    public typealias JSON = String\npublic init() {}\n\npublic func transformFromJSON(value: AnyObject?) -> NSURL? {\n    if let URLString = value as? String {\n        return NSURL(string: URLString)\n    }\n    return nil\n}\n\npublic func transformToJSON(value: NSURL?) -> String? {\n    if let URL = value {\n        return URL.absoluteString\n    }\n    return nil\n}\n\n}\n```\nIn the transformFromJSON function you could check the type of the input value and convert it to an Int appropriately depending on its type.\n. Here is an example from the ObjectMapper tests to guide you:\n```\nclass Response: Mappable {\n    var result: T?\nrequired init?(_ map: Map){\n\n}\n\nfunc mapping(map: Map) {\n    result <- map[\"result\"]\n}\n\n}\nclass Status: Mappable {\n    var status: Int?\nrequired init?(_ map: Map){\n\n}\n\nfunc mapping(map: Map) {\n    status <- map[\"code\"]\n}\n\n}\n```\nlet response = Mapper<Response<Status>>().map(JSONString)\nIn your example above, the Data variable needs to conform to Mappable. This is declared in the class definition as you see in the Response class. Then when you are mapping the object you need to declare the type T that is being mapped. \n. You are not supposed to include the following in your code:\npublic protocol Mappable {\n    init?(_ map: Map)\n   mutating func mapping(map: Map)\n}\nOther than that, I believe your code is fine.\n. Unfortunately due to the structure of the code, I do not think this is possible.\n. It seems to me that the list JSON object is just a dictionary of Articles where the keys are Integers. So you should be able to do the following:\n```\nclass Articles: Mappable {\n    var complete: Int?\n    var error: String?\n    var list: [Int : Article]? \nrequired init?(_ map: Map) {}\n\n//  Mappable\nfunc mapping(map: Map) {\n    complete <- map[\"complete\"]\n    error <- map[\"error\"]\n    list <- map[\"list\"]\n}\n\n}\n``\n. Sorry I have never used or heard of Firebase so I do not have any samples to tutorials for you.\n. I agree that this function is a bit odd and can lead to confusion at times. I think the better solution would be to actually remove the function completely and only have two versions of the map function, one that takesStringand one that takes[String : AnyObject]. I am still debating whether I will do this because I don't want to break the API for people without good reason. Thanks for the heads up though\n. It is actually not necessary at all. This code came from a pull request and I believe thewhere falseis mainly there so that all the conditions line up nicely below. We could consider removing it as it serves no other purpose, but I don't think it does much harm either.\n.DateTransform` currently requires an input of seconds not milliseconds. \nIf you want to add functionality to DateTransform so that it can optionally support milliseconds, I would be happy to accept a Pull Request. You could add an optional parameter to the initializer that configures the transform to operate on milliseconds.\n. Hi @pixel4, thanks for your work. This looks good and I think I will merge. I'm curious though, why was it necessary to add the isKeyPresent check?\n. One other thing that would be great to have before I merge this is a simple unit test that checks this functionality so that we ensure it is not broken down line with other updates. Would you be able to add one?\n. @pixel4 thanks for the updates. Looks great!\nI agree about updating the minor version. I will take care of that when I release. \n. Since you're variables are not optional, they need to be given a default value. You could write your model as follows to avoid filling the init function:\n```\nstruct Plate: Mappable {\n    var id = \"\"\n    var number = \"\"\n    var country = \"\"\n    var state = \"\"\n    var active = false\ninit?(_ map: Map) {\n}\n\n}\n``\n. I believe this should work if you change your function definition to the following:private func postAuthInfo(url: NSURL, payload: T)`\n. Closing this for now, you can reopen if you are still having issues.\n. Is this still a problem for you?\nI think the issue may be that you are using the forced unwrapping operator ! on optional objects which may be nil. If would be better to use the if let syntax to avoid this.\n. They are converted to optional objects of the generic type. This is necessary because ObjectMapper needs to be able to handle nil values within JSON objects.\n. That's an interesting addition. ObjectMapper already includes a way to validate your JSON before mapping. In the failable initializer you can return nil if you are missing data that you need to perform the mapping. \nrequired init?(_ map: Map) {\n    // check if fields you need exist\n    return nil\n}\n. The JSON string generation is handled by NSJSONSerialization which is within the foundation framework. \nYou can get a Dictionary representation of your data using the map function. From here you could write your own JSON string generator, or perhaps find another one online\n. See the example here https://github.com/Hearst-DD/ObjectMapper#mappable-protocol\nPrior to mapping when the init? function is executed, you can make sure the JSON response has the correct data necessary for mapping, if it does not, return nil.\n. Hey there,\nSorry for the slow response. \nYou need to move the following code: \nif children != nil {\n    for child in children!{\n        child.parent = self\n    }\n}\nto the mapping function after the children assignment. I think this should do the trick\n. There is no built in way to do that. I would suggest moving the if statement from within the transfrom into a function and using that function to convert a State value to a color\n. @piresbruno ObjectMapper has not officially supported iOS 7 since iOS 9 was released. I do not plan on investigating iOS 7 bugs, however if you find a solution to the problem, I am happy to accept pull requests with fixes.\n. @piresbruno Thanks for looking into this. Closing this off\n. No at the moment this is not possible. \n. You're Product class looks good to me. Is there is a name space issue and the wrong Product class is being referred to in the API snippet ??\nAre you able to write Mapper<Product>().map(JSON) within your Product class? If so, that would indicate that something else is causing the issue where it is being used above...\n. I just tested out the Tag model you pasted out above and it compiles fine in my project. Perhaps the issue is with how you integrated ObjectMapper. Are you using Cocoapods or Carthage?\n. Closing this as I believe it is a project set up issue. \n. Hi @LeonardBonfils, please see #357 .\nI plan to add more documentation about the init? function in the README but I have not had a chance yet.\n. Sorry but I do not follow your question. Are you still having this problem?\n. If you use toJSONString on your object it will create a JSON string using \"description\" as the key. You could send that to the server. Otherwise I think you may need to replicate the naming convention from the server in your models\n. The last release of ObjectMapper requires Xcode 7.3. \nSo you can either update Xcode, or use the previous version of ObjectMapper\n. Have you tried using the toJSONString function?\n. Unless I'm missing something, what you describe above is what the nested value is used for in the subscript.\nIf you write map[\"error.message\", nested: true], the key that will be match will be error.message not error -> message\n. Thanks for your work @shu-ua. I've decided not to merge this code as I have added a slightly more flexible solution. The Map object now has a MapContext property which. MapContext protocol which developers can implement to hold whatever information they may need.\nSee https://github.com/Hearst-DD/ObjectMapper#mapping-context\n. Take a look at the MappableCluster protocol and the associated tests to get an idea how it's used. This protocol will allow you to return an existing object to use for mapping. I have not personally used ObjectMapper with CoreData but I believe this approach is what you are looking for \n. Yes, this protocol was designed to support inheritance, however, it can also be used to return a cached model to perform mapping on, instead of creating a new instance \n. Yep, exactly. I think that should do the trick\n. and note, if you need to subclass that object, you will need to switch the static keyword with class. \n. @waltermvp I'd be happy to accept a PR with a core data example :+1:. I'm assuming you mean including it as a new test as there isn't a demo project\n. Hi there, I believe the reason that mapping is called twice is because you include a call to mapping within the init? function. You should remove that call as it is handled by the library. Hope this helps\n. Hi there, yes it is safe to do what you are doing and the last mapping will always have priority.\nThis is not really an ideal implementation though. For that reason, I am working on a new feature. This feature will allow developers to create a mapping context object that will be passed around during mapping in the Map object. This object will store whatever information you want, so you could use it to decide how to perform your mapping. This work is currently in a branch (mappable) which I am hoping to merge soon. See documentation: \nhttps://github.com/Hearst-DD/ObjectMapper/tree/mappable#mapping-context\n. Hey there, check this issue out #430 \nYou can use the MappableCluster protocol to fetch an existing model during mapping.\n. Please see documentation for proper subclass definition https://github.com/Hearst-DD/ObjectMapper#subclasses\n. Hi there, you should be able to handle this as follows:\n```\nclass Item: Mappable {\n    var id: Int?\n    var name: String?\ninit?(_ map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    name <- map[\"name\"]\n}\n\n}\n```\nThen using the Item class, you can do\n```\nif let items = Mapper().mapArray(JSON){\n}\n``\n. Oops didnt realize you had already closed this...\n. @catach Is this the complete response or a sub object? If it is a sub object, I would just map it as aArray`\n. Thanks!\n. map.JSONDictionary also returns the current Dictionary. \nObjectMapper doesn't have any built in functionality for combining two keys. I would map the two values to two temporary variables and then combining them manually.\n. The latest version of ObjectMapper requires Xcode 7.3. Either update xcode or add the previous release of ObjectMapper to your project.\n. ObjectMapper provides several different functions which you can use for mapping. I think the following is probably what you are looking for:\npublic func mapDictionaryOfArrays(JSONDictionary: [String : [[String : AnyObject]]]) -> [String : [N]]?\nAlso available:\npublic func map(JSON: AnyObject?) -> N?\npublic func mapArray(JSONArray: [[String : AnyObject]]) -> [N]?\npublic func mapDictionary(JSONDictionary: [String : [String : AnyObject]]) -> [String : N]?\n. Unfortunately, not at the moment. Given a JSON string, you should be able use the functions just like you use Mapper<T>.map(JSON). So in your case, it would look something like:\n```\nlet JSONString = \"...\"\nif let dictionary = Mapper().mapDictionaryOfArrays(JSONString){\n}\n``\n. I'm don't follow your question... please clarify if you are still having an issue.\n. Due to inactivity I am closing this issue. Please comment if you are still seeing this leak and have more info to help debug.\n. Here is the documentation forinit?(_ map: Map)`\nhttps://github.com/Hearst-DD/ObjectMapper#mappable-protocol\nNon optional properties are only supported by ObjectMapper if they are initialized prior to serialization. This can happen when they are declared or within init?\n. Yes you can do that. The value() function will only work for basic types (String, Bool, Int etc) though. \nYou should know that when creating JSON, ObjectMapper only uses the mapping function. This means that in your example above, your name and id properties would not get written to the JSON output. You can always include the mapping twice if you need the none optional variables and the toJSON functionality\n. Hey there, sorry for such a delayed response to this.\nThe best approach to using one model class with two different APIs is to use the MapContext functionality within ObjectMapper https://github.com/Hearst-DD/ObjectMapper#mapping-context\nThis will allow you to define a MapContext object is passed around during mapping. You can define which API is being used within the MapContext and switch based on the info within your mapping function.\nHope this helps!\n. Hi @SimplGy, the init? requirement is in place so that ObjectMapper can create objects of your given model during mapping. It does not by default allow you to create a model simply by passing in a Map object.\nHowever, I believe the functionality you are trying to add already exists. See \nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Core/Mappable.swift#L32\nI have not added this to the documentation yet... and unfortunately Xcode autocompletion does not display these functions. \n. Hi @jsgoupil, I agree that this could be a useful addition. \nI have added this functionality on a branch I am working on https://github.com/Hearst-DD/ObjectMapper/tree/mappable\nHopefully I can merge it into master soon.\n. This has now been merged into master. Closing this. Thanks for the idea @jsgoupil \n. Sorry but I understand your question... are you still having this issue?\n. Hey there,\nYou should be able to use any version prior to 1.2\nhttps://github.com/Hearst-DD/ObjectMapper/releases\n. ToJSON functionality is dependent on your mappings being within the mapping function. For this reason, immutable mappings (which must be defined in the init function) will not be mapped in ToJSON calls.\nThis is one of the reasons that immutable mappings are not officially supported by ObjectMapper at this time. \n. I have added an option in the Map subscript to ignore nil values on this branch:\nhttps://github.com/Hearst-DD/ObjectMapper/tree/ignore-nil-option\nSo your mapping would look something like:\nname <- map[\"name\", ignoreNil: true]\nWhat do you all think of this solution?\n. Great. When I have a chance, I will add some tests and merge into master.\n. @LakhV potentially we could do that. I will think about it some more\n. @tarangpatel, I haven't had a chance to properly test the branch. I need to add unit tests before safely merging back to master. \nFor the mean time I recommend you use the branch directly.\n. The ignoreNil flag has been merged into master.\n. The code is in master, but I haven't created a new release yet.\n. You may be able to use a combination of the objectForMapping function and transforms to create that functionality. \nThere is no built in mechanism to achieve this though.\n. I have just released v1.5.0. This update now allows ObjectMapper to be implemented purely within an extension. Using the updated StaticMappable protocol, you will only need to implement the following two functions:\nmutating func mapping(map: Map)\nstatic func objectForMapping(map: Map) -> BaseMappable?\nThis should make working with Realm significantly easier. Hope this helps!\n. @robbiet480 they already have been :)\n. @robbiet480 I have updated AlamofireObjectMapper to work with the latest Alamofire using Xcode 8 GM. Let me know if you are still having problems\n. @robbiet480 StaticMappable and Realm are working fine for me. See the model I am testing for AlamofireObjectMapper\n```\nclass Forecast: Object, StaticMappable {\n    dynamic var day = \"\"\n    dynamic var temperature: Int = 0\n    dynamic var conditions = \"\"\nclass func objectForMapping(_ map: Map) -> BaseMappable? {\n    return Forecast()\n}\n\nfunc mapping(_ map: Map) {\n    day <- map[\"day\"]\n    temperature <- map[\"temperature\"]\n    conditions <- map[\"conditions\"]\n}\n\n}\n```\nI'm not sure why you are getting errors wrt the initializers. Perhaps you can post your class so we can help you out.\n. Closing this ticket as the issues should be resolved by using the updated StaticMappable protocol\n. @mitchtreece the other solution is to override the objectForMapping function in Child:\noverride class func objectForMapping(map: Map) -> BaseMappable? {\n        return Child()\n    }\nNote you will have to change static to class.\nYour original implementation wasn't working because Mapper was trying to cast the Parent object returned in objectForMapping to a Child. This would always evaluate to nil in this scenario. \n. You could potentially write a transform to handle this scenario, I have never done it though.\n. This is something I am thinking about improving as I update the project. Unfortunately for the time being the error messages are not as good as they could be.\n. Unfortunately, ObjectMapper has no functionality to sort arrays during mapping at the moment. \nI do not think that a Transform will work for this scenario because Transforms are performed on each element of an array instead of the whole array at once.\n. See https://github.com/Hearst-DD/ObjectMapper#mapping-context\nThis new feature that allows you to pass an object around during mapping\n. You can use the following function in the Mappable protocol:\nstatic func objectForMapping(map: Map) -> Mappable?\nSimply return a different a subclass of ResponseData the matches the given JSON response.\nYou can inspect map object as follows:\nstatic func objectForMapping(map: Map) -> Mappable? {\n    if map[\"type\"].value() == \"something\" {\n        return Subclass(map)\n    }\n    if map.JSONDictionary[\"type\"] == \"something\" {\n        return Subclass(map)\n    }\n    return nil\n}\nOr you can follow this example: https://github.com/Hearst-DD/ObjectMapper#generic-objects\n. This is not a bug. ObjectMapper does not validate whether an object was is fully mapped or not mapped at all. It simply tries to map any of the defined mappings in the mapping function. \nPerhaps in the future we can add some extra validation.\n. You should implement the following function: https://github.com/Hearst-DD/ObjectMapper#static-func-objectformappingmap-map---mappable\nIn the function you can query realm for an existing object to use in your mapping. \nHope this helps\n. The current solution is to use the static objectForMapping function. \nAlong with that you can create your own MapContext object which will be passed around during mapping. You can store your coreDataStack in there and you won't need a singleton to access it. See:\nhttps://github.com/Hearst-DD/ObjectMapper#mapping-context\n. Unfortunately ObjectMapper doesn't provide any functionality like this. Good luck finding a solution. \nI would maybe recommend versioning your API when new keys are added to the models.\n. Hey there,\nIn my test case in the ObjectMapper project this feature is working as expected. The objectForMapping function is just in the super class and it is still called. See the example below\n```\nclass Vehicle: Mappable {\nvar type: String?\n\nclass func objectForMapping(map: Map) -> Mappable? {\n    if let type: String = map[\"type\"].value() {\n        switch type {\n            case \"car\":\n                return Car(map)\n            case \"bus\":\n                return Bus(map)\n            default:\n                return nil\n        }\n    }\n    return nil\n}\n\nrequired init?(_ map: Map){\n\n}\n\nfunc mapping(map: Map) {\n    type <- map[\"type\"]\n}\n\n}\nclass Car: Vehicle {\nvar name: String?\n\noverride func mapping(map: Map) {\n    super.mapping(map)\n\n    name <- map[\"name\"]\n}\n\n}\nclass Bus: Vehicle {\noverride func mapping(map: Map) {\n    super.mapping(map)\n}\n\n}\n```\n```\nlet carName = \"Honda\"\nlet JSON = [[\"name\": carName, \"type\": \"car\"], [\"type\": \"bus\"], [\"type\": \"vehicle\"]]\nif let vehicles = Mapper().mapArray(JSON){\n    XCTAssertNotNil(vehicles)\n    XCTAssertTrue(vehicles.count == 3)\n    XCTAssertNotNil(vehicles[0] as? Car)\n    XCTAssertNotNil(vehicles[1] as? Bus)\n    XCTAssertNotNil(vehicles[2])\n    XCTAssertEqual((vehicles[0] as? Car)?.name, carName)\n}\n``\n. Right. You will need to include theobjectForMappingfunction directly in the entity or where ever you implementMappable.\n. The change was made to simplify the code base. TheobjectForMappingfunction allows more than just dynamic mappings, so I was not happy with the naming of its Protocol. Instead of renaming it, I integrated it as a core part ofMappable`. I will keep your feedback in mind and see if I get any other feedback about the change.\nAnyhow, you can still achieve exactly what you were describing in your first post with the code below. This allows your custom mapping  (objectForMapping) to be in an extension outside of your generated entity. \n```\nclass Base: Mappable {\n    // generated entity\n}\nextension BaseClass {\n    static func objectForMapping(map: Map) -> Mappable? {\n}\n\n}\n```\n. You're right, that solution does not work... I thought I had tested it successfully but I guess not...\nI would argue the objectForMapping still relates to specific Entities. For instance, if you are using it to return a cached object from a DB, you need to know what type of Entity you are returning. If we moved the function outside of the Entity, you would only know this if the type is specified directly in the JSON.\nAnother situation is the dynamic mapping. I think the most common use case of dynamic mapping would be subtypes of a base class. In this situation, the objectForMapping function only needs to know how to distinguish between its subtypes. If we move it outside the entity, it needs to be able to distinguish between all possible mappings, which could potentially case conflicts depending on the naming conventions.\nI will put some more thought into this issue. Perhaps moving the function back into it's own protocol is a more flexible solution. However, I would need to find a better name than MappableCluster as that does not really capture its functionality properly. \n. Hi all, I have just released a new version of ObjectMapper which separates objectForMapping into a new protocol named StaticMappable. \nCheers \n. Sorry, I forgot to push the podspec. It's now up\n. A new version (1.4) has been released. Please let me know if the issues persist. Thx\n. Hi there,\nYou could try the following:\n```\nStruct MyStruct: Mappeble {\n    var messages: Message?\n    var message: [Message]?\n... init and so one\nfunc mapping(map: Map) {\n    message <- map[\"messages\"]\n    messages <- map[\"messages\"]\n}\n\n}\n```\nWith this set up only message or messages should be assigned a value during mapping based on the response you get.\n. I think you are right, this is not necessary. Would you like to create a Pull Request for the fix? If not I will update this myself. Thanks for pointing this out \ud83d\udc4d \n. This change will be merged into master shortly\n. Unfortunately ObjectMapper cannot handle generic Arrays at this point.\nYou will probably need two response objects to satisfy this situation. One with var results: T? and one with var results: [T]?\nThe generic type must conform to Mappable to be used by ObjectMapper\n. This is a duplicate of #264 \n. Hi there,\nIn this situation I would recommend accessing the data directly from the Alamofire response. You should be able to simply cast it to [String].\nAlternatively, you may be able to subclass String and make the subclass Mappable, however I think that is more work than necessary for the your situation\n. Thanks for your suggestions \ud83d\udc4d . I like the idea of having a convenience function to simplify syntax and usage.\nI think I will go with the following to maintain consistency and clarity:\ntransform(fromJSON: { Int($0) }, toJSON: { String($0)})\n. I am actually having some issues with the above implementation. Not all my tests are succeeding. I do not have time to look into this more carefully, but I would welcome a pull request if you have the time.\nThanks\n. You do not need to create the Mappable protocol, it exists already in ObjectMapper. You just need to implement the functions it defines. Please see the Read me or one of the many examples in the ObjectMapperTests directory\npublic protocol Mappable {\nmutating func mapping(map: Map)\nstatic func objectForMapping(map: Map) -> Mappable?\n}\n. Please use the swift-3 branch if you are using xcode 8 beta\n. Hi there, I have created a swift-3 branch. @batschz can you please create a new PR with your work onto that branch?\n. Int32 is not supported by default. You need to create a Transform for this type. See this transform that pulled from the Test classes for int64Value\n(map[\"int64Value\"], TransformOf<Int64, NSNumber>(fromJSON: { $0?.longLongValue }, toJSON: { $0.map { NSNumber(longLong: $0) } }))\n. You can use the ignoreNil flag on individual mappings to get around this issue.\nname <- map[\"name\", ignoreNil: true]\nUnfortunately there is no global setting to change this for all mappings at the moment.\n. I'm not sure why you are not able to implement this... do you have any more details? I am closing this ticket until I receive more information. Thanks\n. I have just created a fresh brand (swift-3) which can be used until swift 3.0 is fully supported. I haven't done any work on it yet as I am a bit strapped for time at the moment. I welcome you all to make PRs on it\n. I have merged the first PR into the swift-3 branch. Everything seems to be functioning properly. Please post here if there are any issues.\n. The swift-3 branch is now up to date with Xcode beta 4.\n. The swift 3 branch has now been merged into master\n. That's correct. This happens because ObjectMapper cannot know with any certainty that an object in an array should map to a certain object in a JSON dictionary. I considered using the array index as a mechanism to implment toObject mappings however I don't think that is not a very robust solution as arrays may have their orders changed.\nOne solution to your situation is to use the objectForMapping(map: Map) -> Mappable function. This function is executed prior to mapping each object. It allows you to return an existing object reference to use during mapping. Hope this helps\n. Thanks for the fix. I updated the transform\n. A pull request with this update and some unit tests would be great! I appreciate the help \ud83d\udc4d \n. I have merged #900 to fix this. Thanks. @lambreto is correct, you need to specify the type being returned from .value(). I will update the docs\n. ObjectMapper does not officially support Objective C. It may work but I cannot guarantee any functionality as it is not something I have tested. Good luck\n. Sorry I do not understand your question\n. I did a bit of investigation and noticed a few things.\nGiven a Pet protocol conforming to Mappable and the following mapping pets <- map[\"pets\"], ObjectMapper has no way of knowing what type of object to instantiate during mapping. Pet(map: map) is not a valid call. \nIf Pet was a class, then you could use objectForMapping in StaticMappable to return the correct type of subclass during mapping. \nWith that said, I'm not sure how we can support serializing protocols\n. Unfortunately at the moment there is no error messaging available. This is a feature that I hope to add in the future.\n. In the Example class above you have not defined any mappings for time, seat_disable or seat_available.\nSomething like this should work\n```\nvar seatsDisable: Array?\nseatsDisable <- map[\"seats.seats_disable\"]\n```\n. Swift PM support has just been merged into master. I will create a release in the coming days.\n. NSNumbers are not explicitly supported by ObjectMapper but I believe they should map correctly. I'm not sure why this is not working for you. \nClosing this for now, if you are still having this problem feel free to elaborate.\n. I have no plans to add sorting during mapping at this time. Dictionaries are not sorted in swift so you would need to add a new OrderedDictionary type for this to work.\n. You can use the following funciton to help with this:\nhttps://github.com/Hearst-DD/ObjectMapper#static-func-objectformappingmap-map---mappable\nSee ClassClusterTests.swift for an example of how it is implemented\n. You will need to inspect the JSON to detect which type of class you are parsing in the objectForMapping function.\n. This is not supported out of the box, however, you can build a custom transform that returns an object from a local cache based on an ID. \nIssue #309 is where this functionality was added. Hopefully this helps.\n. I believe the order of arrays should be maintained when mapping. So you should be able to loop through your elements and assign an order value after the mapping is completed (this could be at the end of the mapping function). \n. The mapping function is called once per mapped object. I will leave it up to you whether you think this is safe or not, however IMO NSDateFormatter objects are light weight enough to be created on the fly\n. Hi there,\nObjects of type Dictionary<String, T: Mappable> are already supported by ObjectMapper.\nPerhaps I am missing something but I do not see what else your pull request is adding\n. Ahh sorry I didn't realize that when I glanced over the code. This looks good to me\n. Thanks for the answer @josejuanqm. Closing this\n. ObjectMapper is a library that handles conversion of JSON to model classes. \nAlamofire is an HTTP Request library\nAlamofireObjectMapper is an extension for Alamofire that uses ObjectMapper to automatically map requests that return JSON in models.\n. ObjectMapper uses Cocoa functions to validate any incoming JSON strings before mapping (JSONSerialization.isValidJSONObject(JSONObject)). I can't think of anything else that we can do to handle corrupt JSON. I am closing this for now. Please reply if you found a solution to your problem.. There are many conversations about ObjectMapper + Realm in the closed issues which I believe will answer your question. \nGood luck\n. This functionality is not supported out of the box, but can be achieved using something like the code below:\n```\n func mapping(map: Map) {\n        methodId <- map[\"methodId\"]\n        type <- (map[\"type\"], EnumTransform())\n    var metaJSON: Dictionary<String, AnyObject>?\n    metaJSON <- map[\"meta\"]\n    if type == .CreditCard {\n        meta = Mapper<CreditCard>().map(metaJSON)\n    }\n}\n\n```\nHope this helps!\n. You need to use the swift-3 branch if you are using Xcode 8.\n. Thanks for the PR, but I've merged another one that included these changes.\n. Thanks for the PR, but I've already merged another PR with the same changes.\n. ObjectMapper does not provide this exact functionality.\nBut you could achieve this by mapping street and address to local variables within the mapping function and then using them to create the Address object within the mapping function.\nHope this helps\n. Please provide a reason for your request\n. Oh ok. Feel free to create a pull request with your functionality. You can change the visibility of the currentKey variable within your Pull Request\n. Closing this as it is a duplicate of #501 \n. Hi there, unfortunately we don't have any support for PFObjects. If you are able to turn that object into a JSON string or a dictionary then that could work.\n. cat_id is a string in the JSON response so you cannot automatically convert it to an Int.\nYou need to use a transform to achieve this... something like this\ncatIds <- (map[\"cat_id\"], TransformOf<Int, String>(fromJSON: { $0 == nil ? nil : Int($0!) }, toJSON: { $0.map { String($0) } }))\nThere are examples in the test files\n. Thanks!\n. No you cannot. The mapping function is required by the Mappable protocol. You can only remove it if you remove the protocol.\n. Thanks for the contribution, but I don't want to modify the framework in this way for the sake of CoreData. \n. I do agree that ideally ObjectMapper should be usable in just an extension. \nOn second pass, I like your approach to the problem (sorry, I think i reviewed this too quickly the first time). I'm going to put a bit more thought into it and get back to you.\n. @andrebraga I made a few updates and fixed the tests on this branch. All that has now been merged into master. I'm sure why Github did not close this automatically...\nThanks for your addition! \ud83d\udc4d \n. After a few performance tests I've actually found that this branch performs slightly slower than master. I have a feeling this might be due to casting the JSONDictionary to an NSDictionary.\nI am going to close this for now. If you find a solution that doesn't require using Objective-C classes, I would be happy to consider merging it after doing some performance tests.\nThanks for you contribution\n. Please see release 1.4.0, it has swift 2.3 support.\n. Thanks @jpstern \n. @jakecraige my mistake, this change definitely warranted a major version number change. \n. Hi there, are you still having this issue? Unfortunately I have not worked with Realm and ObjectMapper together very much so I don't have much insight into what the issue might be\n. @kamarshad I am closing this for the time being. If you ware still having the problem, you can post here and I will reopen the issue. Thanks\n. Thanks for the contribution \ud83d\udc4d \n. Thanks but I used a earlier PR for this\n. There is an existing swift-3 branch which supports Xcode 8 Beta 6\n. Fixed. Thanks\n. \ud83d\udc4d thanks!\n. Hey guys, unless something is broken, absent JSON keys should not be nullifying your objects during mapping. See the isKeyPresent flag:\ncase .fromJSON where right.isKeyPresent:\n        FromJSON.basicType(&left, object: right.value())\nIf the key is not present mapping should not be happening.\nThere is a test for this in NullableKeysFromJSONTests.swift in the function testMapperAbsentValues()\nAre you using the latest version of ObjectMapper?\n. @eikebartels Arrays are not supported when mapping on to an object. This is because it is not safe to assume that an element is the same based on its position in an array.\nIf the products were stored in a dictionary instead this would not be a problem because ObjectMapper knows how each key in the dictionary maps to the JSON\n. @eikebartels glad you found the root of the issue!\n. This is something that is handled natively by Apple frameworks. See the following functions from Mapper.swift\n```\n    /// Converts an Object to a JSON string with option of pretty formatting\n    public static func toJSONString(JSONObject: AnyObject, prettyPrint: Bool) -> String? {\n        let options: NSJSONWritingOptions = prettyPrint ? .PrettyPrinted : []\n        if let JSON = Mapper.toJSONData(JSONObject, options: options) {\n            return String(data: JSON, encoding: NSUTF8StringEncoding)\n        }\n    return nil\n}\n\n/// Converts an Object to JSON data with options\npublic static func toJSONData(JSONObject: AnyObject, options: NSJSONWritingOptions) -> NSData? {\n    if NSJSONSerialization.isValidJSONObject(JSONObject) {\n        let JSONData: NSData?\n        do {\n            JSONData = try NSJSONSerialization.dataWithJSONObject(JSONObject, options: options)\n        } catch let error {\n            print(error)\n            JSONData = nil\n        }\n\n        return JSONData\n    }\n\n    return nil\n}\n\n``\n. Thanks @ivanbruel, great improvement \ud83d\udc4d \n. The<-is meant to be used with a variable on the left and aMap` object on the right. \nowner <- user is not a valid usage of the operator.\nI think you might want to simply assign the user object to owner in this case...\nowner = user\nHope this helps\n. I'm sorry, but I do not understand your problem. Closing this until you clarify...\n. When checking the existence of a value, either method works. I am going to leave as is for now. Thanks for your input\n. You can create a Map object as follows:\nlet map = Map(mappingType: .FromJSON, JSONDictionary: [:])\nOtherwise, you can just add the init(){} function to your model object and initialize it the standard way. \nHope this helps.\n. You should be able to create a custom transform to achieve this. Or alternatively you can do some post processing after you map to [String: AnyObject].\nSee the following transform as a starting place: https://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Transforms/DictionaryTransform.swift\nHope this helps\n. I think with the changes introduced in 1.5.0 we'll probably want to update this PR. I believe all those extra initializers won't be necessary anymore\n. Closing this as StaticMappable has changed the implementation approach. @robbiet480 feel free to create a new PR with more up to date instructions! Thx\n. Hey there, thanks for the addition \ud83d\udc4d . I merged this via command line and made a few changes. Not sure why Github didn't mark this as merged automatically...\n. toJSON returns a Dictionary<String, Any> not AnyObject. Try either of the following\nvar dataDict: Dictionary<String, Any> = Mapper().toJSON(data)\nvar dataDict = Mapper().toJSON(data)\n. @juliengdt I tried to push the cocoapod last night but the push utility was having trouble building the project. I haven't been able to sort out the issue yet. Hopefully I can figure out a fix soon\n. I just released v 2.0.0 on Cocoapods\n. @kristijanexads v2.0.0 is update and running for Carthage\n. I'm working on it. I attempted to push last night when I made the release, however the pod trunk utility was throwing errors when building the project. Hopefully I can resolve this asap\n. Problem solved. Had to include a .swift-version file for cocoapods to function correctly\nFor reference: https://github.com/CocoaPods/CocoaPods/pull/5841\nLet me know if you have any issues\n. Hi there, you will need to use v.1.3.0 or earlier for swift 2.2. With regards to including the project as a submodule, you should be able to do this like you would with any other submodule.\nHope this helps.\n. Sorry about that, I just pushed 1.5.0 to cocoapods. \n. Your attached example looks like it should work. \nPlease look through some of the Test classes to see more examples of transform.\n. Please use v2.0.0. I have already merged the swift-3 branch back into master.\nLet me know if you are still having issues when you use that\n. @alexsanderkhitev The swift3 branch has been merged into master and pushed to Cocoapods already. Thanks\n. Are you using Xcode 8?\nI would need a bit more information to understand your problem. The 2.0.0 release is running well for me with no compilation issues\n. Have you tried cleaning out the derived data folder? Option + Shift + CMD + K\n. @robbiet480 is correct. This is not a bug, but a change in the API. Mapper now uses named parameters in most of its functions.\nThere is a new API that you can use to map your objects. There is an extension on Mappable that provides initializer based mapping for your objects that conform to Mappable. Here is an example for your situation: \nlet branch = Branch(JSONString: obj.1.rawString()!)\n. The Mapper function now requires named parameters. You call to mapper should look like the following I believe:\nmapper.map(JSONObject: entry)\nYou may need to cast tempArr to Array<Any>? instead of AnyObject as the Mapper interface has changed to accept Any instead of AnyObject.\nHope this helps\n. I am closing this issue until further reply. \n. Hi @efc , sorry for the slow response.\nObjectMapper is not officially set up to handle this type of scenario. You could potentially store the model version number within the MapContext and use that version number within the mapping function. See the below example. Hope this helps\n```\nmapping(map: Map){\n    guard let (map.context as? Context)?.version else {\n        return\n    }\nif version == 1 {\n     // v1 mappings\n} else {\n\n}\n\n}\n```\n```\n    struct Context: MapContext {\n        let version: Int\n    init(version: Int){\n        self.version = version\n    }\n}\n\n``\n. Thanks for your contribution but I have merge another PR that does the same thing more conciselypublic internal(set) var currentKey: String?`\n. Thank you but I ended up making this change myself (I didn't notice this PR)\n. Hi @Sianay, We have unit tests for float in ObjectMapper and they are passing as in Swift 3.0\nI'm not sure what the problem is in your case? What do you mean by the float values are empty? They are mapped to 0?\n. {\"float\" : 0}\nI am able to map the above to a var of type Float. \nMaybe you can post your class so that I can have a better idea what is going on?\n. I was able to reproduce your issue. It seems that Swift 3 is not able cast a value of type Any to a Float. \nlet anyVal: Any = 11\nlet float = anyVal as? Float // This results in nil\nI'm not sure how I will address this yet, but thanks for bringing it up.\n. Oddly I am no longer able to reproduce this issue on v2.1.0. See my test below:\n```\n    func testMappingFloatFromJSON(){\n        let value: Float = 11\n        let JSON: [String: Any] = [\"float\": 11 as Float, \"floatOpt\": value, \"floatImp\" : value]\n    let mappedObject = BasicTypes(JSON: JSON)\n\n    XCTAssertNotNil(mappedObject)\n    XCTAssertEqual(mappedObject?.float, value)\n    XCTAssertEqual(mappedObject?.floatOptional, value)\n    XCTAssertEqual(mappedObject?.floatImplicityUnwrapped, value)\n}\n\n```\n. @devxoul sometimes I have to restart some of the tests in Travis for them to succeed... I have restarted the two that failed, I think they will probably resolve themselves.\nFrom a quick glance your work looks good, thanks for contributing \ud83d\udc4d. I will take some more time soon to look at it closely. Here are a couple things I'm considering:\n1) Should we make the mapping function optional?\n2) How could we improving the toJSON functionality for immutable variables\n3) Do we need a separate protocol form ImmutableMappable? I do like that this doesn't break any current functionality, but I wonder if it would just be simpler to have init(map: Map) throws as the main init protocol.\n. Hey there, sorry about that, I just pushed 1.5.0 to cocoapods. \n. @devxoul sounds good. I just created the branch\n. @econner this is a perfect approach \ud83d\udc4c\n. Hi @Montrazul, when you run pod install are you seeing v 2.0.0 of ObjectMapper getting installed? You may need to run pod update if you are upgrading versions.\nI cannot reproduce what you are describing. v2.0.0 of ObjectMapper is using Swift 3.0\n. That's odd, I'm not sure why this would crash.\nCan you try the following:\nCustomDateFormatTransform(formatString: \"yyyy-MM-dd\")\n. Closing this until further reply\n. @devxoul I added a new operator for toJSON only mappings. Do you have any suggestions on the operator definition >>>? (I'm still contemplating the choice...) Unfortunately -> is not available. \nI think eventually I might renamed the original operator <> to display the multi directionality of mapping. I am hesitant to change it as I like to limit the code changes required for developers upgrading between versions.\nIf we did rename the original operator, then we would have something like:\n<>: two way mapping\n>>>: toJSON only mapping\n. @devxoul I rebased for you.\nPicking a custom operator is tough... I'll think about it some more. I think I will maintain the same order of parameters though.\n. Hi @diogoguimaraes, thanks for the PR. Unfortunately after merging the work on Immutable mappings, this branch no longer is mergeable. \nI would like to support swift package manager, so if you are willing to resolve the conflicts that would be great\n. @diogoguimaraes thank you.\nA few comments:\n1) Can we maintain the current file structure within the Sources directory? I would prefer the files to be organized in folders that match the existing groups in Xcode.\n2) It seems that your PR has modified the spacing within all of the source files. I would prefer if the PR makes necessary changes to the repository. \n. Here is a simple alternative:\nfunc mapping(map: Map) {\n   id <- map[\"id\"]\n   myAttributes <- map[\"attributes\"]\n   for attribute in myAttributes {\n       if attribute.code == price {\n            myPrice = attribute.value\n            break\n       }\n    }\n}\n. false and 0 are both valid JSON. Object mapper uses the former when mapping bools\n. You could potentially use a custom transform if you need 0 and 1 in your JSON\n. @devxoul I am pretty much ready to merge this. Would you like to add some info to the README?\n. I am closing this until further reply\n. Thanks @devxoul, really appreciate your assistance!\n. Thanks! \ud83d\udc4d \n. Thanks for the contribution @nmccann \nI ended up adding throwing mapArray functions to ImmutableMappable.\n. Thank you for creating a clean PR \ud83d\udc4d \n. @borut-t, in the swift 3.0 version of ObjectMapper, the data parameter requires a name.\nobject = Mapper<T.self>().map(JSON: data, toObject: object)\nobject = Mapper<T.self>().map(JSONString: data, toObject: object)\n. @danipralea we do have the swift-version file in the project. \nWhich version of ObjectMapper are you using?\n. @devxoul \ud83d\udc4d \nAlternatively, you can create a container object. \n```\nclass Container: Mappable {\n  var objects: [MyObject]?\ninit?(map: Map){}\nfunc mapping(map: Map) {\n    objects <- map[\"1\"]\n  }\n}\n```\nlet container = Container(JSON: JSON)\nHope this helps\n. Using JSONLint.com the updated JSON is not valid. But what it looks like is a dictionary of arrays: [String: [MyObject]]\nSo in the Container example I posted above, you can change the type of objects to [String: [MyObject]] and that should do it.\n. Ahh sorry I missed that.\nWhat you want to do in this case is use :\npublic func mapDictionary(JSON: [String: [String: Any]]) -> [String: N]?\nSo the call should look like:\nlet dictionary = Mapper<MyObject>().mapDictionary(JSON: JSON)\n. Sorry, the type i posted is not correct based on your JSON. I missed an extra set of square brackets. It should be this I believe: [String: [[String: Any]]]\nSo in this case you should be able to use:\npublic func mapDictionaryOfArrays(JSON: [String: [[String: Any]]]) -> [String: [N]]?\nIf this doesn't work, I would loop through your dictionary, and call mapArray on each object.\n. The only mistake I see above is response.result.value as! [String : [Measurement]]\nYou cannot cast to Measurement. You should cast to:\nresponse.result.value as? [String : [[String: AnyObject]]]\nOn a side note, I would avoid using as! to cast. This isn't a safe operation.\n. Based on the JSON you posted above, the response is in the form of a Dictionary of Arrays, so you should be able to cast it properly.\nIf the response is actually an array, then casting it wont work. \n. I'm not sure what else I can do to help.\nPerhaps you can post a complete sample of the JSON string as received from Alamofire?\n. The JSON you posted from the browser is not valid. If you plug it into JSONLint.com you will see the errors.\nIt includes \u201c and \". The first type of quote cannot be used. \n. You bring up a good point. The introduction of BaseMappable provided a lot of flexibility to ObjectMapper with the trade off of a looser API. You are probably not the only one having these issues. At the very least, we should make the documentation clearly state that you should not implement BaseMappable. \nI will put some thought into how we can make the API stricter without a lot of code duplication. If you have any suggestions they would be great to hear. Perhaps we can take the approach that @devxoul used when creating ImmutableMappable as an extension to Mapper.\n. For the time being, I have included an assert in the map function that will stop developers from taking this approach. \nIdeally we would have a compile time warning, but I think this is better than nothing.\n. Thanks! ImmutableMappable is moving along nicely \ud83d\udc4d \n. Swift Package Manager has not been released yet. It will be released in 2.2.0 most likely early this week.\n. Thanks for the fix @RickPasveer , I have now merged it into master. \nI will make a release soon\n. Closing this as it should be resolved. Let me know if it is still an issue and we can reopen this ticket. Unfortunately I do not have a better solution. Suggestions are welcomed. Merged :)\n. I commented on #644. The idea is good but in the PR the tests were failing. THanks \n. @foldericon I just pushed some changes to master. Let me know if you still have these build issues. The linux PR has now been merged into master. I will close this for now, however if anybody has issues, please comment and we can reopen. Thanks. I think including Linux in the Travis CI test suite sounds like a great idea. I personally do not have the bandwidth to take this on at the moment, but would be really happy for someone else to do so :).. Sorry I cannot merge this because the tests are failing.\n. Closing this as it is a duplicate of #177 . Closing this as it has been merged in another PR. Thanks for the contribution. The <- operator requires the left hand side parameter to be of type inout. This is the reason that you are experiencing a crash as realm thinks we are modifying the object.\nTo work around this problem, you need to call toJSONString within a realm transaction block. Otherwise, we also have the following operator >>> that is used purely for defining mappings to JSON\n. Here you go: https://github.com/Hearst-DD/ObjectMapper/releases\n. Thanks for bringing this to my attention. Performance is obviously a important aspect of a JSON mapping library. I have just started digging in to see what can be improved.\nA couple things to note:\n1. The tests in JSONShootout are being run using ImmutableMappable which is a beta feature. After recreating the setup using Mappable, the execution time improved by 40% in my testing. \n2. The JSONShootout tests are only being run a large JSON file (7mb). Most real life use cases will be much smaller than this (20-50 root level objects). I believe ObjectMapper will perform significantly better on smaller JSON data sets as it won't be casting huge amounts of data. This actually came up a while back when Swift 2 was introduced. Something changed in swift 2 which significantly decreased mapping performance for large data sets (See https://github.com/Hearst-DD/ObjectMapper/issues/251). \n. I agree that there are likely some improvements that can be made in the core framework (with regards to casting large sets of JSON objects). \nHowever, there is significant room for improvement in the ImmutableMappable implementation as you discovered with your simple mappingType == .toJSON check. By skipping the execution of mapping, you allowed the parser to skip over repeated executions of map[\"key\"]. I believe if we make the map[\"key\"] function execute lazily we will see a decent improvement.\n. It seems that another aspect that is significantly impacting mapping performance is the usage of the nested keys. When I removed that aspect for the JSONShootout test, performance improved by another 30-40%\n. Thanks @ManWithBear \n. I just pushed a new tag\n. thanks @lacklock \ud83d\udc4d \n. Thanks\n. I just merged @devxoul PR which should address the issue here. . If you want to create a Pull request with the follow transform that would be great. Please make sure to include tests with the PR if you do so. Thanks!. Thanks @lukewar \ud83d\udc4d.\nFor some reason the travis builds fail regularly. All I had to do was restart them and it fixed the issue.\n. @KoCMoHaBTa I understand your need, but I would prefer to not extend the protocols anymore at this point. Keeping the project as simple as possible is very important.\nPerhaps allowing mapping to throw an error would be an alternative approach. I will put a bit more thought into this idea as I really try to minimize altering the protocols.. Closing this ticket as I do not plan to add post mapping validation at this time. Thank you for your suggestion @KoCMoHaBTa . I am closing this as I want avoid adding new functions to the protocols as I mentioned in #671. Thanks for your work.. Thanks @KoCMoHaBTa, thats what I would suggest as well.\n. You just need to create a model object that maps type, the image urls and the count. THen you can map the whole response with something like the following :\n``` swift\nclass Response: Mappable {\n    var data: [String: Model]?\n    init?(_ map: Map){}\nfunc mapping(){\n    data <- map[\"data\"]\n}\n\n}\n. I believe this is happening because in the mapping function you are mapping to your primary key directly using `<-`. This operator has an `inout` flag for the left hand parameter which makes Realm believe we are modifying it. Since Realm doesn't allow any modification of your primary key you may want to use the `>>>` to get around the issue. The `>>>` only handles writing to JSON and doesn't use the `inout` flag. So your solution could look something like the following:\nfunc mapping(map: Map){\n    if map.mappingType == .fromJSON {\n        primaryKey <- map[\"primaryKey\"]\n    } else {\n        primaryKey >>> map[\"primaryKey\"]\n    }\n}\n```. See Mapper.swift:\nThere is a mapDictionary function which should handle this situation. \nHope this helps. I'm not sure what is causing your specific crash but in this code snippet there are many unsafe ! operations.\nI do not have any issues with generics when running on my device at the moment. I am closing this until further response.. Thanks @devxoul . Another alternative would be to look into the StaticMappable protocol (see README). Agreed, this is a duplicate. ObjectMapper has no plans to support mapping via reflection.  . You should not pass the map without setting its key. Otherwise, the map will keep the key value from the previous mapping. An alternative would be to initialize your transform with the map:\nself.temperature <- (map[\"temperature\"], TimedValuesTransformer(map: Map)). Is this still a problem? If so please follow up. Closing this issue for now.. Hey @haritowa, good point. The MapContext should be forwarded for immutable mappings. \nIf you have the time, a PR would be appreciated for this functionality.\nThanks!. I believe it is already forwarded for the other protocols. At the moment ObjectMapper only supports Strings as the keys for dictionaries. Thanks @traylewin, I have made some changes and additions to your PR. See #697 \nI will be merging that soon so I am closing this.. Is this still a problem?\nI am closing this until further comment.. You can use the following:\nlet array = Mapper<Object>().mapArray(JSONString: json). Thanks @haritowa \ud83d\udc4d , looks good.\nFor some reason some tests fail occasionally on TravisCI. I just restarted them and everything was fine.. Thanks @KoCMoHaBTa, that is the best approach at the moment.. This project is a Swift library. I believe you are referring to Java libraries. Closing this issue. I will reopen if you follow up.. Is this still an issue for you?\nI am closing this until further comment.. I have just merged https://github.com/Hearst-DD/ObjectMapper/pull/700 which I believe will resolve your issue. Please test it out pulling directly from master until a new release is made.. Closing this until further clarification.. I agree that it this could be convenient but I think it is generally safer for transformations to be explicitly defined by the developer. . @liyanhuadev looks cool \ud83d\udc4d . \nI added a link to your repo in the ObjectMapper README: https://github.com/Hearst-DD/ObjectMapper#projects-using-objectmapper. Thanks again @KoCMoHaBTa \ud83d\ude04 . Thanks @devxoul, that is correct. Closing this ticket.. Good idea @devxoul. Sorry for the slow review.. You can turn the UserInformations object into a string and then save it in UserDefaults. When you retrieve it you will need to use ObjectMapper to generate your UserInformations object from the saved string.\nHope this helps. I believe your object should be defined as follows: DataResponse<GenericResponse<ActivityLogDTO>>\nYou do not need the [] in the definition. Hope this helps. Sorry I read too quickly. You will need to define a new class to handle arrays. Something like this:\n```\nGenericArrayResponse {\nvar data: [T]!\n\n....\n``. Please update toDataResponse>`\nT is of type ActivityLogDTO, not [ActivityLogDTO]. The array is defined when you write\nvar date:[T]!. Thanks @KoCMoHaBTa, that's correct.. Are you using this [String: [String: String]] as the type you pass in for the generic? \nThat will not work because [String: [String: String]] does not conform to Mappable. You will need to create a wrapper to hold this data that conforms to Mappable. I've just released an update which should resolve this issue. Please let me know if the problem persists.\nhttps://github.com/tristanhimmelman/AlamofireObjectMapper/releases/tag/4.0.2. @hariseldon78 please try deleting the carthage folder and running carthage update. @alum is correct.. Hi there, are still having this issue?\nCan you provide an example of the call to ObjectMapper and the JSON you are using. THanks. Please provide a clean easy to read example of your issue, otherwise I cannot help.. This is expected behaviour. See the extension definition that was used to add this functionality:\npublic extension Array where Element: BaseMappable\nOnly arrays where the Element conforms to BaseMappable match the extension. Arrays of Mappable or BaseMappable do not conform to it.\nYou should be able to create the function using a generic type that conforms to Mappable. For example:\nfunc map<T: Mappable>(array: [T]) -> String {\n    return array.toJSONString() ?? \"\"\n}. Unfortunately this is not a priority for me. JSON objects are un ordered by specification. If you need to maintain order I suggest including a order key in your model object.. Unfortunately, ObjectMapper does not store the JSON string representation of objects during mapping. You could use ObjectMapper to generate the JSON string you wish to store after the property has been mapped.\narray <- map[\"array\"]\nlet JSONString = Mapper<Type>().toJSONString(array). That's an interesting idea. I agree that it may not be optimal to create a transform objects, however I doubt the performance impacts are large if at all noticeable. \nMy bigger concern with this approach would be porting the existing Transforms. Many of then have an initializer that accepts parameters which are stored for usage during the transformation. See URLTransform for example.. I have decided not to move forward with this idea. Thank you for the suggestion. . Hey there, sorry but I never got a chance to complete that and to be honest, I'm not sure what state that branch is in. I haven't had much time to focus on ObjectMapper lately.\nFeel free to try to use the branch and update it if you please.. You can do something like this:\nvar keys: Array<String>?\nkeys <- map[\"keys\"]\nkey = keys.first. Ah I see. In that case you could write a custom transform if you want. My recommendation would be the above though.. Hi @kubatruhlar, this already works. I just tested it out to make sure. You can use it the same way as you would if your object conformed to Mappable. @kubatruhlar I see, I did not consider that use case. It seems to me that this is a Swift compiler limitation. . Closing this as the new version of AlamofireObjectMapper should take care of the problem. Feel free to comment and I can reopen the ticket if needed.. That's right, @devxoul. mapping() will be called by ObjectMapper. You should not call it in the initializer.. @devxoul is this PR ready to go? or are you making updates?. Sorry no I didn't see this! Thanks for the fix. @AnthonyOliveri I plan on releasing soon enough, however I would like to merge in a few more PRs before I do so.. I just created a new release with these changes 2.2.4. ```\nclass APIResult: NSObject, Mappable {\n    var data : Dictionary?\n    var msg : String?\n    var status : Int?\nrequired init?(map: Map) {\n}\n\nfunc mapping(map: Map) {\n    status <- map[\"status\"]\n    msg <- map[\"msg\"]\n    data <- map[\"data\"]\n}\n\n}\n```\nHi @iShawnWang, I believe the problem stems from this class. Specifically the definition of data:\nvar data : Dictionary<String, T>?\nThis object cannot be mapped by ObjectMapper as is because T does not conform to Mappable. In the subclass it does, however, the superclass does not know this and hence cannot perform the mapping.\nWhen defining your class you would need something like:\nclass APIResult<T: Mappable>: NSObject, Mappable {\nThis would not actually work in your specific case because Array<Classification> does not conform to Mappable, just Classification conforms to Mappable.\nYou may need multiple APIResult classes to handle your situation. APIArrayResult and APIResult where data would defined as follows:\nclass APIArrayResult<T: Mappable>: NSObject, Mappable {`\n  var data: Dictionary <String: Array<T>>?\nclass APIResult<T: Mappable>: NSObject, Mappable {`\n  var data: Dictionary <String: T>?\nHope this helps and provides some clarity. I would be happy to accept a Pull Request with a simple StringToIntTransform.. For the url to be mapped to a URL type, you need to use URLTransform:\nurl <- (map[\"URL\"], URLTransform()). @devxoul LOL ooops \ud83d\ude02\n. Thanks for your work @afonsograca. I merged this work into master via another branch where I made a few minor alterations. I'm not sure why Github did not automatically close this though.... It seems that the Apple Watch test is failing. Can you look into that?\nI restarted it a few times and each time it failed. Hmmm, I'm not sure whether this approach makes sense. My concern comes from the fact that we cannot rely on map without a subscript to always have the currentValue set as the passed JSON. For example, if there is another mapping before hand, I don't think your scenario will succeed because the currentValue will be set to the previous mapping...\n```\nstruct MyModel: Mappable {\n  var value: String!\n  var value2: String!\nmutating func mapping(map: Map) {\n    self.value <- map[\"key\"]\n    self.value2 <- (map, LastItemTransformer())\n  }\n}\n```\nI will think a bit more on this, but maybe something like map.root() would make more sense.... subnodes is not reassigned in the toJSON process. I believe, the issue that you are experiencing arises because the <- operator uses the inout flag for the left hand parameter. This is necessary when mapping from JSON to model. \nSo when toJSONString is called, KVO assumes that subnodes is modified due to the inout flag.\nOne solution which is not that elegant that should solve your issue is the following:\nif map.mappingType == .toJSON {\n  subnodes >>> map[\"subnodes\"]\n} else if map.mappingType == .fromJSON {\n  subnodes <- map[\"subnodes\"]\n}\nThe >>> is used only for generating JSON and does not use the inout flag.\nHope this helps.. Sorry for the slow response. You can simply create a new class for example MyDateTransfromClass and copy the code. Hope this helps. Just created a new release with this fix. See 2.2.5. Thanks for the contribution but I have decided not to include this as I want ObjectMapper to remain as simple as possible. MessagePack looks cool but I have no plans to add support at this time. . You can use a map the jobsByDate to a Dictionary type. That way you will have the key and the value. Note: dictionary keys only support strings at the moment in ObjectMapper so you will need to store the date as a String. I've just merged a fix for this issue. Thanks for pointing it out \ud83d\udc4d . There is a JSONString init function. I think what you are looking for is a the JSON init function however. You should be able to use it like this:\nlet user = WLYUser>(JSON: response.jsonResponse as! [String : Any]). This is an area where there is room for improvement in ObjectMapper. My current approach is to use two different models based on the response type (which I agree is not ideal). If we could have [T: Mappable] conform to Mappable it would solve the issue. If anybody wants to try to tackle adding this functionality I'm sure many people would be happy.. Thanks!. Thank you @devxoul. I think this decision makes sense. \nIdeally developers just use one protocol throughout their app, but I understand that its not always that simple.. @devxoul I don't have a strong preference with regards to indenting with spaces/tabs. Consistency is all that really matters to me. \nIf you want to clean the indentation, feel free \ud83d\udc4d . I believe @devxoul is correct. CLosing this for now. I think @azeff is correct. Closing this for now. Thanks @mwoollard this is an interesting contribution. I am going to put some more thought into it as I make a big effort to keep the code base as simple as possible. Either way, I definitely want to incorporate your travis fix :) . Unfortunately, nested keys do not work for arrays. You will need to create a wrapper object around TemplateType like this:\nstruct Obj: Mappable {\n  var type: TemplateType?\n}\n. @pauchan This looks good \ud83d\udc4d. Thanks completing the job.. @JuanitoFatas 2.2.6 just released!. You can use this function in Mapper.swift to create a dictionary. \npublic func toJSONDictionary(_ dictionary: [String: N]) -> [String: [String: Any]]\nThen you can convert that to a string using the following function:\npublic static func toJSONString(_ JSONObject: Any, prettyPrint: Bool) -> String?. Unfortunately I'm not sure what the issue is here. Closing this for now. If you still haven't resolved, feel free comment and I will reopen.. As @devxoul suggested, you could use a custom transform and inspect the value and then act accordingly. ObjectMapper doesn't provide any other techniques for handling this situation. Good luck!. Thanks!\n. Thanks @devxoul . Closing this ticket. The object will only be nil is the top level JSON dictionary is nil. ObjectMapper does not verify whether each mapping within an object succeeds or not. It simply processes all the mappings sequentially and returns the result.. Thanks @chenkefeng. Thats the correct approach \ud83d\udc4d . Sorry but I agree with @devxoul. I don't think this needs to be incorporated into ObjectMapper. Thanks for the contribution. Hi there, I just released a new version that included a PR addressing some overflow issues with ints. I testing mapping the above value to Int64 and it was successful:\nlet jsonString = \"{\\\"int64\\\": 1495208399999}\"\nlet obj = mapper.map(JSONString: jsonString)\nXCTAssertEqual(obj?.int64, 1495208399999). No not exactly. There is a method in Mapper that allows mapping JSON onto an object. However this will add nil values to object if they are in the passed JSON. \npublic func map(JSON: [String: Any], toObject object: N) -> N {\nHope this helps. Are you saying that the bool is correctly mapped when using responseJSON but not responseArray?\nModels are mapped the same way using both the methods so I'm not sure what your problem is. You can try appending the following so you can view the output that is not mapping correctly.\n.responseString(completionHandler: { (response: DataResponse<String>) in\n    print(response.value ?? \"\")\n});. Sorry I cannot help anymore but I cannot reproduce this issue. The code looks right to me looking at your screenshots.\nClosing this for now. Please feel free to post if you have more issues.. I agree with @devxoul. Thanks for your contribution @HassanEskandari . Oh my bad, I did not expect this release to have any breaking changes. Can you please let me know what the breaking change in your code was?. Ah I think I know. The mapArray function.... I was able to test your models and JSON and everything work as expected. If this is still an issue feel free to add more detail. Closing this for now. @azeff that was just a slip up on my part. ObjectMapper uses Semantic Version so future patches should continue working in your code as expected. . Hey there, I just pushed up a new branch called swift-4. Please let me know if you come across any issues. I had to add some special handling for Float types as it seems they can no longer be casted from Any as they could previously.. The swift 4 branch has now been merged and released. There is a level of JSON above your root object which you are not considering. The following should work:\nfunc mapping(map: Map) {\n        version  <- map[\"data.version\"]\n        data     <- map[\"data.data\"]\n    }. You can write a custom transform that inspects the type and if it is a String it converts it into an Int https://github.com/Hearst-DD/ObjectMapper#custom-transforms\nOtherwise you can map the string value to a local variable and then process it inline.\nvar idString: String?\nidString <- map[\"id\"]\nif let idString = idString {\n    // process idString into an int value\n} else {\n   id <- map[\"id\"]\n}. profession <- map This is not accepted ObjectMapper syntax. There is no automatic mechanism for mapping another object on the same JSON level. My recommendation would be to map company and designation to local variables within the init function and then create your Profession model manually.. Hi there, sorry but I don't have any insight into why that isn't working. The code looks good to me. Perhaps you can compare to the some of the tests. See CustomTransformTests.swift line 227.\nOtherwise, maybe it has something to do with the Member superclass?. I just merged a PR that included a fix for this issue. . Hi there, I'm not sure why this is the case but it seems that for Structs adding StaticMappable as an extension breaks the custom constructor functionality. If you define your struct in one block that conforms to StaticMappable you problem should go away. I will keep an eye on this but I believe it is a Swift issue.. Hi there, currently ObjectMapper doesn't support enum values as keys to dictionaries. As you said, a transformer is the best approach to this issue. The map function also accepts a JSONObject (Any) or a JSON dictionary ([String: Any]). Depending on the type of the response object, you should use the appropriate method.. Thanks for the addition @KIlleX00 \ud83d\udc4d \n. @cody1024d I just released a new version 2.2.8 with the above fix. . You can use nested keys to map everything easily into one model:\n```\nstruct Event: Mappable {\n  var name: String!\n  var posX: Float!\n  var posY: Float!\ninit(_ map: Map) {\n    name <- map[\"name\"]\n    posX <- map[\"data.posX\"]\n    posY <- map[\"data.posY\"]\n  }\n}\n``. To accessurlfrom Parent, Parent would need to be a subclass of Base. At the moment, it has no association to Base class.. Thanks for the fix!. ObjectMapper uses the swift classJSONSerializationto convert dictionary objects to JSON. If you want to handle the mapping to string yourself, you can usetoJSONto convert your object to a dictionary of primitives and then you can handle the conversion to string using another utility or perhaps other encoding settings inJSONSerialization`\n. You need to write a transform that converts the Int type to a string. See custom transforms part of the readme or look at some of the tests included in the project for reference.. Are you using the swift-4 branch of the project?\nAlso, URL type does not map automatically, you have to use URLTransform.. Hi there, we already have a swift4 branch for this project. It will be merged into master in the fall when swift 4 is officially released.. @devxoul I agree, i think it is in good enough shape to release officially. \n@ealymbaev the current version 2.2.8 has all the latest ImmutableMappable functionality so feel free to use that. I will update the ReadMe to remove the beta flag from the documentation.. Strings are not automatically converted to URL in ObjectMapper. The developer must define the mapping as follows:\nurl <- (map[\"url\"], URLTransform()). Unfortunately there is not validation errors on individual mappings. I think the best you can do is check you variables at the end of the mapping function. I think this would be possible but a significant development effort. I do not have time to take new additions to ObjectMapper at moment, but I am open to accepting this type of functionality in a Pull Request. Thanks for the contribution but I don't think I will integrate this extension into ObjectMapper. While this may be convenient I think it is better to use Mapper.mapArray directly to handle array mappings.. I have just tested a similar scenario locally and it is working just fine for me. Is this still an issue for you?. Using the standard map operator (<- ) this is not possible. You can only pass in a context when you explicitly use the Mapper.swift map function. With that said, you could use the Mapper.map function within an Mappable object to handle nested objects. Sorry for the slow response. I think this is a good improvement and am happy to merge. Thanks @AntonTheDev . ObjectMapper does not support this type of validation during mapping. You will have to handle this after mapping has completed. Thanks for the fix but I incorporated this myself before seeing your PR.. I have just merged the PR and created a new release. Thanks! . Please use the latest release with swift 4 support. Fixed. Sorry but I do not understand your problem. It seems to me this is not related to ObjectMapper. ObjectMapper does not interact with ViewControllers. It is up to you to manage passing data between ViewControllers. Please use the latest release, your problems should be resolved.. Are you still having this issue. I believe it has been resolved. Closing this issue for now. Please reply if otherwise.. Please use the latest release, your problems should be resolved.. Since you have resolved your issue I will close this. Thanks. @adamkuipers @falkobuttler, unfortunately I do not currently have time to look into this issue. If anybody has a PR with a fix I am happy to accept it.. Thanks!. Thanks!\n. I think you have posted this into the wrong repository. This is the Swift version of ObjectMapper for iOS and macOS. It does not support custom JSON factories at this time.. ObjectMapper does not provide a mechanism for handling this situation. You can easily check if a value was successfully mapped in the mapping function though. \nuserName <- map[\"userName\"]\nif userName == nil {\n    username <- map[\"user_name\"]\n}. I've just released a version with the 9.1 fixes in it. Here is an example of how you could solve this found in the ClassClusterTests.swift file:\n```\nclass Vehicle: StaticMappable {\nvar type: String?\n\nclass func objectForMapping(map: Map) -> BaseMappable? {\n    if let type: String = map[\"type\"].value() {\n        switch type {\n            case \"car\":\n                return Car()\n            case \"bus\":\n                return Bus()\n            default:\n                return Vehicle()\n        }\n    }\n    return nil\n}\n\ninit(){\n\n}\n\nfunc mapping(map: Map) {\n    type <- map[\"type\"]\n}\n\n}\nclass Car: Vehicle {\nvar name: String?\n\noverride class func objectForMapping(map: Map) -> BaseMappable? {\n    return nil\n}\n\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n\n    name <- map[\"name\"]\n}\n\n}\nclass Bus: Vehicle {\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n}\n\n}\n. This is not something ObjectMapper can do automatically. However you can simply set the userId on the DietaryRoutine object after it is mapped. See below:\nclass UserData: Object, Mappable {\n@objc dynamic var user_id: Int = Int(0)\n@objc dynamic var first_name: String? = nil\n@objc dynamic var last_name: String? = nil\n@objc dynamic var dietry_routine: DietaryRoutine?\nrequired convenience init?(map: Map) {\n    self.init()\n}\noverride class func primaryKey() -> String? {\n    return \"user_id\"\n}\n// Mappable\nfunc mapping(map: Map) {\n    user_id    <- map[\"user_id\"]\n    first_name    <- map[\"first_name\"]\n    last_name         <- map[\"last_name\"]\n    dietry_routine       <- map[\"dietry_routine\"]\n    sleep_time       <- map[\"sleep_time\"]\ndietryRoutine.userId = user_id\n\n}\n}\n``.let mapper = Mapper(shouldIncludeNilValues: true)`\nIf you instantiate Mapper as above the nil values should be included when you output your JSON string. Thanks for this, but I already merged another PR with the same functionality. @angelinec is correct. ALternatively you can use the URLTransform t handle the conversion:\nurl <- (map[\"url\"], URLTransform()). This should resolved. please let me know if not.. @pmusolino sorry no updates on this. I don't have time to dig into this issue at the moment.. Hi all, I have merged a PR which should address the Float issue. Please use version 3.2.0.\nI have not had a chance to look at the redeclaration warnings yet.. Closing this ticket as it is a duplicate of #967 . Hi, I just merged a PR which should address this issue. Please see v3.2.0. Very sorry for the delay on this. I have not had any time for maintenance on this project lately. Thanks for the PR. There is already some support for generics in this project. Please see the tests for examples. Sure. I have made the change. It will be live in the next release. Hi everyone, I have gone ahead and merged the Swift 4.1 float fix. \nTo be perfectly honest I have not had much time to spend maintaining this project this year. I will try carve out more time to make sure that any important PRs are handled. I have been maintaining this project alone since it was created in very early Swift days so needless to say it has consumed a lot of my time. With that said, I really appreciate any help with code fixes and issue handling as I cannot do it all myself.\nPlease see v3.2.0 for the latest. The README has been updated with v3.3.0.\nOn Jun 21, 2018, at 10:02 PM, wudijimao notifications@github.com<mailto:notifications@github.com> wrote:\nAny way, The document maybe need to update~ It still suggest us to use ver 3.2.0~\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_Hearst-2DDD_ObjectMapper_issues_975-23issuecomment-2D399297666&d=DwMCaQ&c=B73tqXN8Ec0ocRmZHMCntw&r=2QkXbmnfaONluJXStOFnv2m1bDnFjF5WXmFaGGMpAp4&m=tit9gLn9wm-l_6p1SBLqriI-JkZCP5Or26U15P8fyJE&s=PRkdu08HEV_WbmwySQGSGqUQ3T572b1Wz-DpFrQO78Q&e=, or mute the threadhttps://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ABfWFlESOcQGwXtQwdExTdzi-2DfoJNz-2DUks5t-5FFAfgaJpZM4UaMRr&d=DwMCaQ&c=B73tqXN8Ec0ocRmZHMCntw&r=2QkXbmnfaONluJXStOFnv2m1bDnFjF5WXmFaGGMpAp4&m=tit9gLn9wm-l_6p1SBLqriI-JkZCP5Or26U15P8fyJE&s=vz13dbf_bIE0EF0DkQussNU1NB046UemDSS_WBkgVdE&e=.\n. Thanks for the contribution but I already merged another swift 4.2 PR.. Thanks for you contribution but I already merged the other PR you mentioned. . Thanks for fix @gcharita ! \ud83d\udc4d . Thanks for this, but I already merged another PR with this functionality. Swift 4.2 support has now been released. You need to use the URLTransform to map to URL types.. Merged! sorry for the delay. Thanks @Mazyod . Closed as this is a duplicate. Would be happy to merge this, but can you please add a few simple tests so we can ensure its functionality moving forward?. Dont worry about the broken test, I fixed that in the master branch. Thanks for adding in the testing. Thanks for the feedback everyone. I will do my best to keep the project up and running smoothly. This should be resolved in v3.4.1. Please let me know if not. I'm not able to reproduce this behaviour. Let me know if you are still having the issue.. I was having an issue with the current version of Cocoapods cli that was preventing me from pushing a new version. I have resolved that now. v3.4.1 is now available on Cocoapods. Good catch! I have just pushed a fix. Please see the following function in the Mapper class https://github.com/tristanhimmelman/ObjectMapper/blob/master/Sources/Mapper.swift#L59. public func <- <Transform: TransformType where Transform.Object: Mappable>(inout left: Transform.Object, right: (Map, Transform))\nWhat do you think of this function definition instead? I recently updated the other transform operator function definitions to be more like this (using Transform.Object rather than T).\nI don't have much more time to look over this PR today, but from first glance, it looks pretty solid.\nOn another note, I think I might have to soon split up the Operators file into a few files... its getting a little large.\n. I have not measured the performance of reduce so I don't know if this is true. However I don't see a compelling reason to use it in this situation. I personally find the syntax is a bit clearer without it.\n. This check is important for performance reasons. We previously didn't include it and the valueFor function became a performance bottleneck because it was being called so often without any need.\nCan you please revert this\n. That's not quite accurate. Some of the JSON objects are [String: Any] and others are [[String: Any]]\n. Example of the file modification that should not be included in the PR.\n. I think I prefer approach number one. I think that if you define an model as ImmutableMappable you expect a error to be thrown if something was not correctly map.\nWith that said, I think it makes sense to add mapArray to the ImmutableMappable Mapper extension because I think this should be a throwing method. Yes, it will cause some code duplication, but I think it will provide a better interface for developers.\n. @jlyonsmith once you make the above change I am happy to merge this. I will wait until just before I create the next release tag. Thanks!\n. ",
    "safx": "Thanks!\n. ",
    "jacksonh": "Blah, sorry. Let me separate this out into two pull requests. Thats what I get for editing code on the web. \n. ",
    "eoinoconnell": "Hi,\nI had the same problem and ended up doing... \n```\nif let jsonArr = json as? [[String: AnyObject]]{\n                for innerJSON in jsonArr {\n                    let plot: StethoscopePlot = Mapper().map(innerJSON, to: StethoscopePlot.self)\n                    plots.append(plot)\n                }\n            }\n```\nWhere json is the standard [String:AnyObject] you get from Alamofire \n. Awesome, thanks\n. Cool I'm on it\n. Out of interest why is there an init and a mapping function? Can the failable initialiser not be used for both purposes?\n. OK cool, valid point. Thanks! \n. ",
    "funky-monkey": "Great stuff Tristan! Thanks for adding this!\n. Also don't forget to update the docs/README ;-)\n. Quick question though; If i pass in a string, not knowing if it has a collection, how will ObjectMapper handle this? As in; Can i assume that there is a check to see if what is passed in is a collection or not? And otherwise just return a collection with 1 result?\nThe reason i'm asking is because you said; \"Moving forward you can map the above JSON like this\". \nThanks, \nSidney\n. Hi Tristan, \nI've tested it and it works like a charm! \nGreat stuff!\nCheers, \nSidney\n. Sorry to respond so late; yes this works! (Still for people who are looking at this answer)\nMaybe also note in your documentation that nested collection do not allow you to use the dot syntax to get values, that is only if they are on the same level,\nThanks, \nSidney\n. YES! I'm having the same problem as well. \nCan there be done something about the required init in the Mappable protocol?\n. Great stuff!\nWhat i've seen so far, is that if i omit the init method, the compiler will complain. I think it is a failable initializer, not an optional initializer. But please prove me wrong ;-)\n. ",
    "Codeglee": "class TaskProgressMap : MapperProtocol {\n    var taskId: Int?\n    var percentage: Double?\n...standard mapping\n}\nThe parent mapping class is:\nclass PlanProgressMap : MapperProtocol {\n    var planId: Int?\n    var tasksWithProgress : [TaskProgressMap]?\n```\nrequired init() {}\nclass func map(mapper: Mapper, object: PlanProgressMap) {\n    object.planId <= mapper[\"PlanId\"]\n    object.tasksWithProgress <= mapper[\"Progress\"]\n}\n```\n. ",
    "mirion": "It looks that this issue was fixed by Xcode 6.1.1\n. ",
    "kentashoji": "Sorry, I misunderstood..\nThank you for adding test!\n. ",
    "oniikal3": "@tristanhimmelman  Should I do in func mapping(map: Map) ?. Really appreciate for quickest answer ever. That's work Thanks.. ",
    "brandonroth": "Will you consider putting your todo list on the main page?  I think it would be helpful for other folks so they don\u2019t re-invent the wheel when they discover the same problems.  Discovering this was especially difficult for me to understand because Xcode would crash several seconds after opening up the stack trace.  Hopefully things get better in later releases of Xcode.  Anyways thanks for putting this library together, in my opinion it\u2019s the best approach to swift object mapping I\u2019ve seen.\n\nOn Dec 15, 2014, at 2:50 PM, Tristan Himmelman notifications@github.com wrote:\nYes, that's right. Implicitly unwrapped optionals are not currently supported. It's on my todo list!\n\u2014\nReply to this email directly or view it on GitHub https://github.com/Hearst-DD/ObjectMapper/issues/18#issuecomment-67072703.\n. \n",
    "SSA111": "Thank you :+1: \n. ",
    "helllth": "Thank you :+1:\n. ",
    "vani2": "@tristanhimmelman that's workaround. I suppose it'll very convenient to call initializers for MapperProtocol inherited objects instead of create instance and then call map func. \n. ",
    "pizthewiz": "Any thoughts on this, is the project's intention to support iOS 7? In its current configuration, ObjectMapper cannot be used for apps submitted to the App Store. :cry:\n. Swift 1.2 is tied to Xcode 6.3/iOS 8.3 so I think this is still required as the master branch doesn't build with the Swift 1.2 compiler.\n. No worries, it was a bit odd to have two concurrent Xcode/iOS betas floating about.\n. I rebased to pick up the latest changes and added a couple of additional commits to address compile errors in the newer code.\nIn earlier commit comments, @ikesyo was thinking some tricky syntax could be used to avoid failable casts and in turn support both Swift 1.2 and earlier versions without supporting a separate branch - that should still be doable though now the code in question is more spread out.\n. Would it be helpful to rebase this again? I'm guessing with the release of Xcode 6.3 / Swift 1.2 today there will be more interest?\n. It would appear so - closing this out.\n. ",
    "robertoschwald": "Need that, too.\n. I get the following error while trying to compile your fork using Carthage 0.6.5 and 0.7.4, Xcode7 Beta command-line tools:\n* Building scheme \"ObjectMapper-watchOS\" in ObjectMapper.xcworkspace\n* Building scheme \"ObjectMapper-iOS\" in ObjectMapper.xcworkspace\n* Building scheme \"ObjectMapper-Mac\" in ObjectMapper.xcworkspace\n* Building scheme \"ObjectMapper-watchOS\" in ObjectMapper.xcworkspace\nParse error: unexpected SDK key \"(string)\"\nCarthage setup:\ngithub \"nrbrook/ObjectMapper\" \"swift-2\"\n. ",
    "ldiqual": "@tristanhimmelman Is there an open issue where you're tracking ideas & future developments for official support of non-optional mapping? I understand that it's not possible (or not very elegant) at the moment, but it'd be awesome to gather the current recommended way to do it and brainstorm on other solutions in a single place.\n. Installed the library successfully. Thanks for the quick fix!\n. @tristanhimmelman \n\nSupport for let variables was never official and required quite a bit of extra code to achieve.\n\nI'd be curious to know how to implement let support in my app, would you mind elaborating or linking to a code snippet?\n. Hmmm, I see. Thanks @tristanhimmelman !\n. @tristanhimmelman Any update on your review? I would love to start improving the PR by adding things like Set mapping and meaningful errors (eg: Couldn't convert key \"coordinates\" to type String), but I need to make sure you're ok with the interface change first.\nAnother point of discussion: I'm not sure it's technically possible, but how about renaming:\n- valueOrFail() to value(). There would be value() -> T? and value() throws -> T, which the compiler could choose according to the target type.\n- valueWithTransformOrFail() to value(transform:). This includes the point above and tries to comply with the Swift API guidelines: https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md\n. I've moved my main project to https://github.com/JohnSundell/Unbox to handle decoding. Encoding is done manually with SwiftyJSON. I don't really have anymore incentive to keep working on this PR so I'll have to pass. Feel free to use my code as you will!\n. ",
    "SimplGy": "I'm wondering the same thing, @ldiqual. Is there a discussion about pros, cons, and challenges of supporting failable initialization with non-optional model properties. Did you find anything? I'm imagining it must be difficult to do, and there may be some prior discussion of the challenges involved with implementing this.\nI tried a few light things, but can't figure a way to do a failable init with non-optional mapping in a symmetrical, DRY way.\nThis video expresses my critique succinctly--I don't want the transform layer to enforce optional or mutable state in my models:\n\nThis is a good option: https://github.com/Hearst-DD/ObjectMapper/pull/216/files\nAnd this was recommended:\nswift\nrequired init?(_ map: Map) {\n    if let id = map[\"id\"].value() {\n      self.id = id\n    } else { return nil }\n}\n...but this won't serialize back out the same way unless I add that to the mapping function, and enforced symmetricality (where foo == Foo(json: foo.toJSON())) is one of the things I love best about this library (along with extendable serializers and the mapping syntax).\n. Oh, so are these two equivalent?\nname = map[\"name\"].value()\nname <- map[\"name\"]\nIf so, I could implement required properties maybe like below. Would this fit your intention for how it should be used?\n``` swift\nclass StarWarsPerson: Mappable, CustomStringConvertible {\nvar id:   String\n  var name: String\n  var hairColor: String?\n  var eyeColor: String?\nvar description: String { return \"[(id)] (name)\" }\n// If a star wars person doesn't have a name and id in the JSON, fail the initialization of the object.\n  required init?(_ map: Map) {\n    if let id = map[\"id\"].value() {\n      self.id = id\n    } else { return nil }\n    if let name = map[\"name\"].value() {\n      self.name = name\n    } else { return nil }\n  }\n// ...The rest can map optionally\n  func mapping(map: Map) {\n    hairColor <- map[\"hair_color\"]\n    eyeColor  <- map[\"eye_color\"]\n  }\n}\n``\n. Noting this is similar in part to https://github.com/Hearst-DD/ObjectMapper/issues/260, feel free to close if it raises no new questions.\n. Look at that,init?(JSON)` sure does already exist and it's a beautiful implementation. I'll use that, thanks.\nI'm still unclear on why my implementation worked, (and what was wrong with it, because I'm sure something was). That has to do I think with the difference between Map and Mapper and will be my own private journey. Thanks Tristan!\n. ",
    "cadizjavier": "Just for further reference regarding this same issue:\nThe recommended way mentioned in the last comment fails (tested with v2.2.6) with the error Cannot invoke 'value' with no arguments.\nvalue() is generic function and returns a T type inferred from the the variable declaration.\nSo in order to fix this we should add a type like this (or the type that id belongs to):\nswift\nrequired init?(_ map: Map) {\n    if let id: Int = map[\"id\"].value() {\n      self.id = id\n    } else { return nil }\n}. @freak4pc Hey, what is you experience so far with ImmutableMappable to solve your original issue ?\nI have a very similar scenario for what you described initially.\nAny recommendations ?\nThanks in advance. ",
    "zocario": "Hi @tristanhimmelman, I am having the exactly same issue in my project.\nDuring serialization of my Realm objects the App crashes as Realm thinks I am modifying the object when the mapping function is called.\nAs the issue is closed I guess you've found a solution for this problem?\nI am using Xcode 6.3 beta with Swift 1.2, so I am on the \"swift-1.2\" branch, maybe the fix is not on it?\nEnzo\n. Did you try to talk with Realm guys to find a solution?\n@ldiqual Have you made an issue in the Realm-Cocoa repository about this?\n. Thanks for your precisions, I've just created and issue on the Realm repository to see if they have any suggestions that could be helpful to solve this problem.\n. As I said in the Realm issue, I'll go with Mantle because I need a full compatibility with Realm, and solving this inout flag issue would mean change the design of your library...\nThanks for your support.\n. ",
    "segiddins": "You're correct in the guess that the issue is the spurious inout flag.\n. ",
    "empty": "I'm also running into this issue. It would be great if ObjectMapper was compatible with Realm.\n. ",
    "schmidan": "[edit] Ha, just now saw this comment/solution https://github.com/Hearst-DD/ObjectMapper/issues/294 [/edit]\nIf anyone runs into this again. We adopted a quick work-around until we move to another solution:\n``` swift\nimport ObjectMapper\nclass Event: Object, Mappable {\n    dynamic var mappingIdentifier = \"EVENT_NO_ID\" {\n        didSet {\n            realmIdentifier = mappingIdentifier\n        }\n    }\n    dynamic var realmIdentifier = \"EVENT_NO_ID\"\nfunc mapping(map: Map) {\n   mappingIdentifier <- map[\"id\"]\n   ...\n}\n\noverride static func primaryKey() -> String? {\n    return \"realmIdentifier\"\n}\n\n}\n```\nWe just make sure, that the mapped property isnt the realms primary key.\nugly but in our case so far functional.\n. ",
    "felipowsky": "Workaround:\n``` swift\nfunc mapping(map: Map) {\n        var opened = false\n        if let realm = self.realm where !realm.inWriteTransaction {\n            realm.beginWrite()\n            opened = true\n        }\n        defer { if opened { map.mappingType == .FromJSON ? try! self.realm?.commitWrite() : self.realm?.cancelWrite() } }\n    self.name <- map[\"name\"]\n    // ...\n\n}\n```\nIt should be used with caution because it might commit implicit changes to your database.\n. ",
    "geodesicer": "the workaround I use is the following:\nclass RBase: Object, Mappable {\n    dynamic var id = NSUUID().UUIDString\n    dynamic var idz = \"\" {\n        didSet {\n            idz = id\n        }\n    }\n```\noverride class func primaryKey() -> String? {\n    return \"id\"\n}\nfunc mapping(map: Map) {\n    ....\n    idz <- map[\"id\"]\n    idz <- map[\"idz\"]\n}\n```\nAlso see the complete code in Subclassing and Realm #462\n. So far I have only seen that problem when when modifying the \"id\"-property, and we write a new JSON-file at most property changes due to specific requirements, i.e. using two different database engines and using the JSON-file as a \"secure\" transport mechanism between databases.\n. I use the following in my base class (called RBase), and in addition this solves AFAIK the update problem in writing a JSON from within a Realm write:\nclass RBase: Object, Mappable {\n```\ndynamic var filename = \"\"\ndynamic var id = NSUUID().UUIDString\ndynamic var idz = \"\" {\n    didSet {\n        idz = id\n    }\n}\ndynamic var rType: String = \"\"\ninternal override init(value: AnyObject)\n{\n    super.init(value: value)\n    rType = String(self.dynamicType)\n}\nrequired init() {\n    super.init()\n    rType = String(self.dynamicType)\n}\nrequired init?(_ map: Map) {\n    if let theType = map.JSONDictionary[\"rType\"] {\n        if let theString = theType as? String {\n            if theString == String(self.dynamicType) {\n                super.init()\n                return\n            }\n        }\n    }\nreturn nil\n\n}\nrequired init(value: AnyObject, schema: RLMSchema) {\n    super.init(value: value, schema: schema)\n    rType = String(self.dynamicType)\n}\nrequired init(realm: RLMRealm, schema: RLMObjectSchema) {\n    super.init(realm: realm, schema: schema)\n    rType = String(self.dynamicType)\n}\noverride class func primaryKey() -> String? {\n    return \"id\"\n}\nfunc mapping(map: Map) {\n    filename <- map[\"filename\"]\n    rType <- map[\"rType\"]\n    idz <- map[\"id\"]\n    idz <- map[\"idz\"]\n}\n```\n}\n. ",
    "morgz": "I get issues with any Realm backed attribute not just the primary key because the <- operator makes realm think we're modifying the underlying object. Shame, I like objectMapper DSL but for JSON serialising a Realm object it appears to be pretty incompatible without starting a write transaction.\n. ",
    "thacilima": "I also had this problem just when writing the id (realm object primary key) to json.\nMy solution bellow:\nif map.mappingType == .ToJSON {\n    var id = self.id\n    id <- map[\"id\"]\n}\nelse {\n    id <- map[\"id\"]\n}\nIn this solution you don't need an extra variable and the id will be in your json\n. @ivanruizscm I also need the primary key in the json and I did like this:\nif map.mappingType == .ToJSON {\n    var id = self.id\n    id <- map[\"id\"]\n}\nelse {\n    id <- map[\"id\"]\n}\n'id' is the realm object primary key. It worked!\n. ",
    "nabbestemmia": "Thank you guys, I thought to be alone in this situation!\n. Oh, I think I found how to do it. \nThanks again!\n. ",
    "alexanderkhitev": "@thacilima Hello! \nI use your code in Swift 3, but I get error libc++abi.dylib: terminating with uncaught exception of type NSException when I call the  let JSON = Mapper().toJSON(messageModel)\nMessageModel snippet code\n```\n  override static func primaryKey() -> String? {\n        return \"id\"\n    }\nfunc mapping(map: Map) {\n    if map.mappingType == .toJSON {\n        var id = self.id\n        id <- map[\"id\"]\n    } else {\n        id <- map[\"id\"]\n    }\n\n//        id <- map[\"id\"]\n        date <- map[\"date\"]\n        message <- map[\"message\"]\n        imageData <- map[\"imageData\"]\n        imageURL <- map[\"imageURL\"]\n        senderID <- map[\"senderID\"]\n        conversationID <- map[\"conversationID\"]\n        isIncoming <- map[\"isIncoming\"]\n        isNew <- map[\"isNew\"]\n        messageStatus <- map[\"messageStatus\"]\n    }\nrequired convenience init?(map: Map) {\n    self.init()\n}\n\n```\n. Hi @Sweefties ! Yes, I did. I show you my example \n```\nclass RealmUserInfo: Object, Mappable {\ndynamic var id = \"\"\ndynamic var firstName = \"\"\ndynamic var lastName = \"\"\ndynamic var photoPath: String?\n\noverride class func primaryKey() -> String? {\n    return \"id\"\n}\n\nconvenience required init?(map: Map) {\n    self.init()\n}\n\nfunc mapping(map: Map) {\n    if map.mappingType == .fromJSON {\n        id <- map[\"id\"]\n        firstName <- map[\"firstName\"]\n        lastName <- map[\"lastName\"]\n        photoPath <- map[\"photoPath\"]\n    } else {\n        id >>> map[\"id\"]\n        firstName >>> map[\"firstName\"]\n        lastName >>> map[\"lastName\"]\n        photoPath >>> map[\"photoPath\"]\n    }\n}\n\n}\n```\nTell whether this helped you or not.\n. I also checked each of the existing cards that they had id == \"\" not once the breakpoint did not work.\nif let id = cardDictionary[\"id\"] as? String {\n                if id == \"\" {\n                    debugPrint(\"id is nil\")\n                }\n            }. ",
    "dmorrow": "Using the clone functionality in Realm, you can make this work\nlet preferencesCopy: Preferences = Preferences(value: preferences)\npreferencesCopy.toJSON().\n",
    "juanrodriguezarc": "try using a realm transaction and don't use a primary key\nlet realm = try! Realm()\n            try! realm.write({\n                print(\"'HERE'\",Mapper().toJSONString(user!, prettyPrint: true))\n            }). ",
    "liangsay": "i try using this one,it's OK, you can try\nhttps://github.com/APUtils/ObjectMapperAdditions\n\n. ",
    "ikesyo": "You, too :smiley: \n. :wink:\n. :+1: for Mappable too.\n. AFAIK, the library itself supoorts iOS 7 (not using iOS 8 API). But Dynamic Framework (and also CocoaPods support) is only supported at iOS 8 and later.\nSo if you'd like to use this library in iOS 7, you can use by using git submodule and adding source files directly to your app project.\n. See also #23.\n. mapArray(string JSONString: String) now returns empty array when parsing failed.\n. Style question: Which do you prefer tab or space for this project? @tristanhimmelman \n. @tristanhimmelman Thank you, I got it. I'm going to change to using tabs for this PR.\n. Yep, the latter is more understandable and consistent with other codes. I've changed to that style.\nAdditionally Xcode project settings is changed for using tabs.\n. My pleasure! :sparkles:\n. FYI: Xcode can parse triple-slash comments as documentation. :wink:\n. I agree with it. \ud83d\udc4d\nI prefer the former of the two.\n. Added also mapDictionary overload.\n. Sorry, added map overload too.\n. By the changes in #89 and e271dc87b241176f958950158733c152d5e8417d, master branch is now compatible with Swift 1.2, I think.\n. I understand what you are describing, and it's much simpler way. But I think current Mappable definition can not handle the types which have some let properties:\nswift\nstruct Immutable {\n    let prop1: String\n    let prop2: Int\n    let prop3: Bool\n}\nMappable's init() requirement blocks that such types will be correctly initialized. At least, it seems to that changing init() to init?(map: Map) (Failable Initializer with Map) or something like that (factory method in this PR) is required.\nAnd also <= operator with inout parameter can not be used with let properties.\n. I changed the implementation to more simpler style. How about it? @tristanhimmelman \nTypes which doesn't need immutable mapping can merely call mapping(map) in their init?(_ map: Map) implementation. And also immutable types can support mapping function using temporary var, create a new value from them, then replace self with it (somehow like the test codes).\n. @tristanhimmelman Thank you for accepting this :sparkles: \nYes, I'd like to tackle it in another PR.\n. @tristanhimmelman Thanks for pointing out it.\nIn this case, I think Subclass's mapping(map) in init?(_ map: Map) is unnecessary. mapping(map) call in Base's init?(_ map: Map) correctly calls subclass's implementation. I'll fix the test code soon.\n. Number values in JSON dictionary is NSNumber in Objective-C nature, and Int, Double, Float, and Bool could be bridged from NSNumber. But because Int64 (and also Int32 and Int16) is not a subtype of NSNumber, it can not be bridged (casted).\nSo you might be able to parse to Int64 using TransformType explicitly, like:\nswift\nid <= (map[\"id\"], TransformOf<Int64, Int>(fromJSON: { $0.map { Int64($0) } }, toJSON: { $0.map { Int($0) } }))\nOf course you can create your own transform class for reusing.\n. Is that server-side thing? In that case, you should use UInt64 or String for the type of id?\n. Ah, are you referring to deserialization to JSON (toJSON conversion)? To take into account that, you could use this signature TransformOf<Int64, NSNumber>, but class ToJSON doesn't handle NSNumber as a JSON value type currently. I'll work on it.\n. @tianyuanzhonglu I just fixed NSNumber handling on #81, could you check the behavior on that branch with this transform?\nswift\nid <- (map[\"id\"], TransformOf<Int64, NSNumber>(fromJSON: { $0?.longLongValue }, toJSON: { $0.map { NSNumber(longLong: $0) } }))\n. @tianyuanzhonglu That's a good news! You're welcome :sparkles: \n. :+1: for this!\n. You can use custom transforms written in README. See also #73.\n. Thank you for preparing!\n. No problem! :grin:\n. @tristanhimmelman \n\nI haven't used Carthage before, but from what I've read it can be used with or without submodules.\n\nYes, that is true. carthage bootstrap or carthage bootstrap --use-submodules.\n\nI think it might be better if the Nimble framework was included (committed) directly to the ObjectMapper repository, that way it can be run immediately after checkout instead of requiring the developer to run carthage checkout. What do you think?\n\nIs this about for the developers who would like to contribute to the project? I prefer separating own dependencies handling to a manager like Carthage or CocoaPods, then use the frameworks built by them, not including the source codes directly.\nBut if you're not willing to do it, we can just use submodules managed by Carthage, and let's add the dependency's project to ObjectMapper's project or workspace as a subproject. In this case, dependencies are fetched automatically as submodules, and Xcode will automatically build dependent subprojects.\n. Sorry, I misunderstood what you said :sweat_smile: \nInstead of committing built framework binary, I've set up a Xcode workspace which contains both ObjectMapper and Nimble project. Opening ObjectMapper.xcworkspace, developers can build the library and also can run tests (Nimble would be built implicitly by Xcode). Is it an acceptable way?\n. @tristanhimmelman Thank you for accepting it and the README update. I've set up the project with git submodule, so I think carthage checkout --use-submodules might be more suitable.\n. TODO:\n- [x] Fix travis\n. This setting was merged in ObjectMapper in #87, and the commit is not contained in the latest release v0.8. So you should specify master branch or commit after 4322310 in your Cartfile. Is it not the case?\n. This is related to #74, I think you should use map(string JSONString:) like:\nswift\nlet catBack = Mapper<Categoria>().map(string: catJson)\n. The tests are passing in Xcode 6.2, but not in Travis (Xcode 6.1.1).\n. Travis currently does not support Xcode 6.2 yet. Once Travis support it, we might be able to update by rewriting to osx_image: xcode62 in .travis.yml.\n. The tests are passing in Xcode 6.2, but not in Travis (Xcode 6.1.1).\n. No problem! :ok_woman: \n. You can using TransformType for the purpose, like:\nswift\nsequence <- (map[\"sequence\"], TransformOf<Int64, NSNumber>(fromJSON: { $0?.longLongValue }, toJSON: { $0.map { NSNumber(longLong: $0) } }))\nCould you also check #73?\n. You should define the type as struct Message<T: Mappable> : Mappable.\n. Thanks! :sparkles: \n. Mapper.toJSON() takes a single N as its parameter. You should use to JSONArray() for that purpose instead.\n. The type of CurrentCustomer.getCustomer().addresses isn't [Address]?\n. The text you pasted above is a JSON dictionary and has additional values (e.g. \"lang\": \"en\"), so definitely it is not the original value returned from toJSONArray(addresses). Could you provide more detailed context or the correct JSON representation in your Swift code what you did send to the server?\n. That looks correct to me.\n. Or your server side? I'm sorry but I don't know why that does not work well anymore. :sweat: Anyway, it seems that there is no problem in the toJSONArray() implementation.\n. If the type cotained in an array is a Mappable, yes. No need to do that.\n. FYI: that would be handled by this.\n. What I said is about the type that conforms to Mappable, and NSURL isn't Mappable.\nThe functionality you want exists in its latest version, but does not in the version you are using currently (<= operator is a bit old.).\n. I think you should check the releases and the documentaion comments at first. :trollface: \n. That isn't related to the issue. ObjectMapper's enum support requires RawRepresentable enum, something like:\n``` swift\nenum Status: Int {\n    case Failure = 0\n    case Success = 1\n}\n// or\nenum Status: String {\n    case Failure = \"failure\"\n    case Success = \"success\"\n}\n```\nIf you'd like to have an enum which have some associated values (that is not a RawRepresentable conformant enum), you should define your own custom transform for that enum type.\n. I've already submitted a pull request #170.\n. Swift 2 support is still under development in swift-2.0 branch, so you should use:\nruby\npod 'ObjectMapper', :git => 'https://github.com/Hearst-DD/ObjectMapper.git', :branch => 'swift-2.0'\n. Dynamic frameworks can be used only on iOS 8 and later. That is a requirements Apple forces us to follow. You must include all the source files directly to your app target instead of embedding the dynamic framework.\n. That isn't related to the issue. File -> Add Files to \u201cYourProjectName\u201d, then select the files in ObjectMapper/Core and ObjectMapper/Transforms.\n. Those are not changed to public, so you can't use the methods outside the module.\n. This is because:\n- Mapper<User>().map(JSONString) returns User?\n- Mapper().toJSONString expects User, not User?\n- So the following should work:\nswift\n  let user = Mapper<User>().map(JSONString)\n  if let user = user {\n      let JSONString = Mapper().toJSONString(user, prettyPrint: true)\n  }\n. > Actually I prefer to modify property but in that case of setting private setter/public getter - we have setValue function in ToJSON.swift that uses JSONDictionary as internal property...\nJust writing public internal(set) var JSONDictionary would be fine.\n. Why don't you using another array value like join(\".\", Array(allKeys[1..<allKeys.count])), and you can remove allKeys.removeAtIndex(0) and use let for allKeys for more immutability.\n. I believe that Mappable must be Hashable is a bad decision. Instead, You can add methods below in generic extensions of Mapper:\nswift\nextension Mapper where N: Hasable {\n    public func mapSet(JSONString: String) -> Set<N> { ... }\n    ...\n}\n. These functions should constrain the generic parameter as <T: Mappable where T: Hashable>.\n. These methods should constrain the generic parameter as <N: Mappable where N: Hashable>.\n. ",
    "Dohko": "Hi,\nIt's fixed now. I forgot to add ObjectMapper into my dependencies.\nRegards,\nDohko\n. ",
    "stephenyao": "Added source files directly to project and now it's running on iOs7. Hope there will be a way in the future to resolve this \n. Hello is it possible to get this small change merged through? Our project depends on this to upgrade to xcode 8\n. ",
    "mahmed8003": "``` swift\nfunc map(mapper: Mapper) {\n\n    networkId <= mapper[\"_id\"]\n    partId <= mapper[\"part_id\"]\n\n    if(mapper.mappingType == MappingType.fromJSON) {\n\n        defaultColor <= mapper[\"default_color\"]\n        defaultMaterial <= mapper[\"default_material\"]\n        defaultShape <= mapper[\"default_shape\"]\n\n        desc <= mapper[\"description\"]\n        price <= mapper[\"price\"]\n        techNum <= mapper[\"tech_num\"]\n        path <= mapper[\"path\"]\n\n        materials <= mapper[\"materials\"]\n        colors <= mapper[\"colors\"]\n\n\n    }else if(mapper.mappingType == MappingType.toJSON){\n\n        selectedMaterial <= mapper[\"selected_material\"]\n        selectedColor <= mapper[\"selected_color\"]\n\n    }\n\n}\n\n```\nI think you can put a check on \"mapper.mappingType\" in map method.\n. ",
    "nmccann": "Awesome, thank you for the quick response and excellent mapping library :)\n. Thanks @Busta117!\n. @nikita-leonov I've been using valueOrFail and related methods for a while and haven't add many issues. The only downside is that you have to manually map the objects. An example:\n```\nextension InviteResponse: Mappable {\n  init?(_ map: Map) {\n    let rawOthers: [[String: AnyObject]] = map[\"others\"].valueOrFail()\n    guard let mappedOthers = InvitedPersonResponse else {\n      return nil\n    }\nothers = mappedOthers\n\nguard map.isValid else {\n  return nil\n}\n\n}\nfunc mapping(map: Map) {\n  }\n}\n```\nNot sure if there is a better workaround.\n. Thank you for the quick turn around on this @tristanhimmelman!\n. For consistency I should add a comment like // check if object is ImmutableMappable, although I would argue that the code is self-commenting.\n. I wanted to replicate the behaviour of the StaticMappable handling as closely as possible - if the initializer fails for some reason, execution will continue on to the \"fallback\" if statement below. Alternatively I could just return nil, which seems reasonable because I think ImmutableMappable and Mappable are mutually exclusive - you wouldn't have an object that conforms to both (and from my quick experiments, such a setup won't compile).\n. I tried this out, and while it does make sense, it also seems like there will be a lot of duplication. In additional to the Mapper methods, the Array and Set convenience methods would have to be duplicated as well (if I am correct).\nI also found that this alternative solution only works when the compile-time type of the object was ImmutableMappable - in my particular use case I have a manager class that took in request objects whose only generic constraint was BaseMappable. So it seems like I won't be able to interchange Mappable and ImmutableMappable classes easily. Not that I really needed to anyways, since all my mappable objects are immutable now.\n. ",
    "ReaddyEddy": "Hi\nThe initialiser is provided by the base class. I suspect myself that the problem is one of using Cocoapods with the frameworks option but I'm yet to confirm that.\nThanks for the speedy response \nEd\n\nOn 12 Feb 2015, at 05:26, Tristan Himmelman notifications@github.com wrote:\nHi there,\nUnfortunately I'm not sure what is going on here. I haven't tried using ObjectMapper with any classes that are visible to Objective-C code.\nOne thing I do notice in the above code is that the Event class doesn't include the initializer. Hope this helps..\n\u2014\nReply to this email directly or view it on GitHub.\n. Seems as though not using CocoaPods suse_frameworks directive allows a build I\u2019ve yet to exercise the mapper though\nHTH \nEd \nOn 15 Feb 2015, at 23:15, Teddy Dreyfus notifications@github.com wrote:\nAny news with that issue?\nThanks\n\u2014\nReply to this email directly or view it on GitHub https://github.com/Hearst-DD/ObjectMapper/issues/61#issuecomment-74442988.\n. \n",
    "hopiaw": "Any news with that issue?\nThanks\n. ",
    "andrebraga": "I have been easily able to use ObjectMapper with Core Data. https://github.com/Hearst-DD/ObjectMapper/issues/195 for details.\n. Also, given an arbitrary persistent store, I believe this is the only way to enforce uniqueness without resorting to really weird tricks. So that's +1 for me and I'm already tracking the protocol-update branch.\nMay I suggest a relaxation of the signature in order to remain (mostly) source compatible (returning an optional is probably still necessary for some use cases, I believe)? Make the map argument optional and defaulted to nil.\nstatic func newInstance(map: Map? = nil) -> Mappable?\n. True :)\n. My scenario involves Core Data. Unless I'm missing something or Realm already handles this somehow, without access to some unique key on the map I don't see a way to retrieve an existing entity from the persistent store when calling newInstance. I'm open for suggestions.\n. Below are some code snippets from the project I'm working on that should \"inspire\" the reasons I believe init? is not going to make it: class clusters (as mentioned above, for message types) and fetching existing objects from a persistent store (in my case, Core Data) by using an unique key. I am pretty much sure init? can't be coerced into returning anything other than nil, which makes it necessary to use newInstance, but I'm open for suggestions :)\n```\nextension Message: Cluster, ModelMappable {\n    class func modelKeyPathForType() -> String {\n        return \"type\"\n    }\nclass func clusterFromType(type: String) -> AnyClass {\n    switch type {\n    case \"text\":\n        return TextMessage.self\n\n    case \"image\":\n        return ImageMessage.self\n\n    case \"audio\":\n        return AudioMessage.self\n\n    case \"video\":\n        return AudioMessage.self\n\n    case \"location\":\n        return LocationMessage.self\n\n    case \"invitation\":\n        return InvitationMessage.self\n\n    default:\n        fatalError(\"Message type not implemented!\")\n    }\n}\n\npublic func mapping(map: Map) {\n    iD <- (map[\"id\"], UInt64Transform)\n    date <- (map[\"created_at\"], timestampTransform)\n    text <- map[\"data.message\"]\n\n    if let mmm = self as? MultimediaMessage {\n        mmm.attachmentURL <- (map[\"attachment_url\"], stringToURLTransform)\n        mmm.attachmentMIMEType <- (map[\"attachment_url\"], extensionToMIMETransform)\n    }\n\n    if let lm = self as? LocationMessage {\n        lm.location <- map[\"location\"]\n    }\n\n    if let im = self as? InvitationMessage {\n        im.reason <- (map[\"reason\"], reasonTransform)\n    }\n}\n\n}\n```\nBelow is the newInstance method that's added to BaseObject (which is the class my Core Data entities inherit from) via an extension:\n```\npublic class func newInstance(aMap: Map) -> Mappable? {\n    let keys = uniqueKeys()\n    var values = AnyObject\nfor kp in uniqueModelKeyPaths() {\n    if let value: AnyObject = aMap[kp].value() as AnyObject? {\n        values.append(value)\n    }\n    else {\n        values.append(NSNull())\n    }\n}\n\nvar mappable: BaseObject? = nil\n\nif let unique = unique(keys, values: values) {\n    mappable = unique\n}\nelse {\n    let moc = ModelMapper.privateMoc!\n\n    var FinalClass = self\n\n    if let cls = self as? Cluster.Type {\n        let modelKeyPath = cls.modelKeyPathForType()\n        FinalClass = cls.clusterFromType(aMap[modelKeyPath].value()!) as! BaseObject.Type\n    }\n\n    mappable = FinalClass.init(entity: FinalClass.entity(moc), insertIntoManagedObjectContext: moc)\n}\n\nreturn mappable as? Mappable\n\n}\n```\nunique works as follows:\n```\npublic class func unique(keyPaths: [String], values: [AnyObject]) -> Self? {\n    let format = String.joinWithSeparator(\" && \")\nlet argArray = zip(keyPaths, values).flatMap { (pair) -> [AnyObject] in\n    return [pair.0, pair.1]\n}\n\nlet predicate = NSPredicate(format: format, argumentArray: argArray)\n\nlet uniquePredicateFormat = predicate.predicateFormat\nlet klass: AnyClass = (self as Any.Type) as! AnyClass\nlet stringFromClass = NSStringFromClass(klass)\n\nlet cacheKey = String(format: \"%@ %@\", stringFromClass, uniquePredicateFormat)\n\nvar instance: BaseObject? = ModelMapper.objectCache.objectForKey(cacheKey) as? BaseObject\n\nif instance == nil {\n    let request = fetchRequest()\n    request.predicate = predicate\n    request.fetchLimit = 1\n\n    let moc = ModelMapper.privateMoc!\n\n    do {\n        let results = try moc.executeFetchRequest(request)\n\n        if results.count > 0 {\n            instance = unsafeBitCast(results.first!, BaseObject.self)\n            ModelMapper.objectCache.setObject(instance!, forKey: cacheKey)\n        }\n    }\n    catch let error as NSError {\n        print(error)\n    }\n}\n\nif let instance = instance {\n    return unsafeBitCast(instance, self)\n}\nelse {\n    return nil\n}\n\n}\n```\nBy the way, this is what the unadorned BaseObject looks like:\n```\nimport Foundation\nimport CoreData\npublic class BaseObject: NSManagedObject {\n    dynamic public class func uniqueKeys() -> [String] {\n        return [\"iD\"]\n    }\ndynamic public class func uniqueModelKeyPaths() -> [String] {\n    return [\"id\"]\n}\n\nclass func entityName() -> String {\n    preconditionFailure(\"MUST OVERRIDE!\")\n}\n\nrequired override public init(entity: NSEntityDescription, insertIntoManagedObjectContext context: NSManagedObjectContext?) {\n    super.init(entity: entity, insertIntoManagedObjectContext: context)\n}\n\npublic class func entity(managedObjectContext: NSManagedObjectContext!) -> NSEntityDescription! {\n    return NSEntityDescription.entityForName(self.entityName(), inManagedObjectContext: managedObjectContext);\n}\n\npublic class func fetchRequest() -> NSFetchRequest {\n    // Core Data + Swift bug workaround\n    let _entityName = entityName() as NSString\n    return NSFetchRequest(entityName: _entityName as String)\n}\n\npublic convenience init(managedObjectContext: NSManagedObjectContext) {\n    let entity = self.dynamicType.entity(managedObjectContext)\n    self.init(entity: entity, insertIntoManagedObjectContext: managedObjectContext)\n}\n\n}\n```\nAnd the protocols:\n```\npublic protocol UniquelyKeyed {\n    static func uniqueKeys() -> [String]\n    static func uniqueModelKeyPaths() -> [String]\n}\npublic protocol ModelMappable: Mappable, UniquelyKeyed {}\n@objc protocol Cluster {\n    static func clusterFromType(type: String) -> AnyClass\n    static func modelKeyPathForType() -> String\n}\n``\n. https://github.com/Hearst-DD/ObjectMapper/issues/195, check my last comment there. Class clusters are possible, only not withinit?` as the initialiser.\n. Should work, only not for Core Data, not for keyed cache systems, and not for anything that actually commits something to persistent storage (disk, network, whatever) and is retrieved back by a (combination of) unique key(s)... I simply cannot understand how Realm people aren't giving a damn about duplication, unless Realm itself deals with it transparently. I admit I was enticed by Realm but didn't really delve into it because back then it lacked something approaching the convenience of NSFetchedResultsController.\nI understand the conceptual beauty of using init?, but it's simply impossible to achieve with it the same power that a static/class method brings. To wit: the way I structured my code, I have only one implementation of newInstance, it applies to the base class only, it deals with both class clusters and uniquing, and individual models are as terse as they should be. Unfortunately having both initand newInstance is just confusing. There is way more power and simplicity to be achieved from using newInstance exclusively, especially because initialiser requirements are way more convoluted than a simple static/class method. To note: there are severe restrictions to implementing init on an extension.\nBut let's get to the bare basics here. Effectively, class clusters and unique model retrieval depend on the same mechanism: returning on initialisation something other than a freshly created instance.\nI would simply love if the language allowed returning a different init than the one that's allocated, like Objective-C did, but it is evident that Swift won't offer this capability by any means other than a class method. The moment they chose to collapse allocation and initialisation to be one and the same, we either bridge to Objective-C, or we use a static/class method as the instance provider.\n. @tristanhimmelman specifically in the Core Data case the fact that the proposed newInstance is an instance method forces you to create a dummy instance and discard it. This is somewhat troublesome because creating an init?(_ map: Map) that takes no arguments other than map forces many boring details: the use of a definite managed object context (currently I create child contexts on the fly to sync a batch of objects, possibly discarding the whole context if/when an error occurs); managing managed object context threading; dealing with the fact that if said m.o.c. ends up being a main thread one there is a possibility of database corruption if you're using UIManagedDocument with automatic saves.\nNot to mention the fact that there are strict requirements on the semantics of Swift initialisers that prevents one from implementing them on an extension, which screws up retroactive modelling.\nAll in all the old protocol worked perfectly fine :stuck_out_tongue:\n. @damienrambout I'm using generics and type inference to ensure the proper class (or struct) is instantiated depending on the web service called. There are more ways to ensure safety, having a protocol be the return type of a method isn't any less safe when you structure your code as a whole to prevent such errors :smiley:\n. If you check my implementation of newInstance there's a test if the class type itself conforms to the protocol, by checking the protocol type. It should be possible to test the generic type the same way.\nhttps://github.com/Hearst-DD/ObjectMapper/issues/195#issuecomment-140896718\nIt should be then possible to not run N(map) on a dummy instance like you did here:\nhttps://github.com/Hearst-DD/ObjectMapper/commit/5b803582bb31acb4f875f21eb1c9c90cf4b57412#diff-a9498ca83904e6eb2c05ea55fe3c5a1dR181\nby checking for the protocol conformance at the type level first. :smiley:\n. Just verified it here, it's definitely possible to test the generic type like that. :smiley:\n. Where did you get the idea that <- doesn't write? It certainly does when you're reading from JSON.\n. Notice, the exactly same problem will happen for each and every class that must derive from another class and has \"delicate\" initialisation requirements. It is similarly difficult to adopt OM for Realm objects. It is effectively impossible to  adopt OM unless you have control over the implementation. The proposed changes allow adopting it via an extension.\n. This is really appreciated. :smile:\n. Yay, thanks! With the class cluster work my score for PR acceptance is looking great :smile: :smile:\nGet the word out to Realm people, I think they'll love this!\n. ",
    "rjjohnpatrickcruz": "Hey,\nhere is the sample json string im trying to parse \n{\n    \"completed_in\" = \"0.0919\";\n    message = \"Login Successful\";\n    profile =     {\n        \"current_coordinates\" = \"\";\n        email = \"juan@delacruz.com\";\n        fname = Juan;\n        id = 83;\n        lname = \"Dela Cruz\";\n        mname = Gitna;\n        \"mobile_no\" = 09090909090;\n        photo = \"\";\n    };\n    \"security_key\" = \"4DB585AD-F0D2-28AB-68A7-5F4C43A55051\";\n    status = 1;\n}\n---- swift code (using object mapper)----\nlet user = Mapper().map(JSON!)\n---- swift code (my object mapper classes) ----\nclass User: Mappable {\n```\nvar completed_in: String?\nvar status: String?\nvar message: String?\nvar security_key: String?\nvar profile: Profile?\nrequired init(){}\n// MapperProtocol\nfunc mapping(mapper: Map) {\n    completed_in <= mapper[\"completed_in\"]\n    status <= mapper[\"username\"]\n    message <= mapper[\"message\"]\n    security_key <= mapper[\"security_key\"]\n    profile <= mapper[\"profile\"]\n}\n```\n}\nclass Profile : Mappable {\n```\nvar id : Int?\nvar email: String?\n//var salt: String?\nvar fname: String?\nvar lname: String?\nvar mname: String?\nvar mobile: String?\nvar address: String?\nvar photo: String?\nvar current_coordinates: String?\nrequired init(){}\n// MapperProtocol\nfunc mapping(mapper: Map) {\n    id <= mapper[\"id\"]\n    email <= mapper[\"email\"]\n    fname <= mapper[\"fname\"]\n    lname <= mapper[\"lname\"]\n    mname <= mapper[\"mname\"]\n    mobile <= mapper[\"mobile\"]\n    address <= mapper[\"address\"]\n    photo <= mapper[\"photo\"]\n    current_coordinates <= mapper[\"current_coordinates\"]\n}\n```\n}\n. Hi thanks , i think i see the issue.. im using alamofire to request the json and the json response is not a valid json format .. \nthanks!\n. ",
    "aehlke": "What I've tried is close to that, but I'm not using completion callbacks (I'm using ReactiveCocoa signals). So the type is specified by passing the class in to the function, rather than in the completion signature.\nThis is what my method looks like: func request<M: Mappable where M: APIObject>(token: T, method: Moya.Method, parameters: [String: AnyObject], model: M.Type, forKey key: String? = nil, showAuthOnAuthError: Bool = true) -> RACSignal { I have to use M.Type in order to pass in a class. APIObject is what my models inherit from, it is itself a Mappable.\nInside the function when I try to instantiate Mapper<M>() and set a breakpoint, the debugger shows no value for that, but if I do e.g. Mapper<Deck>() where Deck is an actual Mappable class, it shows the instantiated mapper... Not sure what I'm missing.\nEDIT: This appears to be some kind of bug in the debugger, it's actually working as intended AFAICT. Thanks for your answer - showed me that it must be something else wrong with my approach.\n. Lazy mapping sounds very promising!. ",
    "trickpirata": "I've used cocoapods before for projects coded in Obj-c. This is my first time using cocoapods for projects coded in Swift.\nThe odd thing is, even if I don't use cocoapods, I am still encountering this issue(When doing a manual import of this project as stated on your instructions). \n. Yes I did followed it carefully and repeatedly. I've read that this might be a certificate issue as referred to this link: https://www.airsignapp.com/ios-apps-using-swift-crash-when-signed-with-inhouse-certificate/\n. My certificate is new but I am still encountering errors. Any tips? :(\n. ",
    "hborders": "Thanks! I applied your suggested fix and my internal code works fine now.\n. ",
    "bonebox": "It is still required in 0.9. Am I missing something?\n. Since it still has to be declared, I get the compiler error:\n'Element.swift:20:12: Initializer requirement 'init' can only be satisfied by a `required` initializer in non-final class 'Element'\nAnd when I add required, it forces me to call the designated initializer for NSManagedObject.\n. Hi @vincent-ch , I actually didn't resolve it.  I ended up going with a different library, called Sync.  It is awesome if you're mapping into managed objects!\n. Yep, that's it.\n. ",
    "vincent-ch": "Hi @bonebox , I'm facing the same problem. How do you resolved it ?\n. Thanks for the hint. If anyone would be interested in this case, I don't know if this is the proper way to do it, but I resolved it this way: \n```\nclass AbstractModel: NSManagedObject, Mappable {\n@NSManaged var uuid: String?\n@NSManaged var updatedAt: String?\n@NSManaged var createdAt: String?\n\noverride init(entity: NSEntityDescription, insertIntoManagedObjectContext context: NSManagedObjectContext?) {\n     super.init(entity: entity, insertIntoManagedObjectContext: DBUtils().getManagedObjectContext())\n }\n\nrequired init?(_ map: Map) {\n    var ctx = NSManagedObjectContext.MR_defaultContext()\n    var entity = NSEntityDescription.entityForName(\"AbstractModel\", inManagedObjectContext: ctx)\n    super.init(entity: entity!, insertIntoManagedObjectContext: ctx)\n\n    mapping(map)\n }\n\nfunc mapping(map: Map) {\n    uuid        <- map[\"uuid\"]\n    updatedAt   <- map[\"updatedAt\"]\n    createdAt   <- map[\"createdAt\"]\n\n }\n\n}\n``\n. Hi @Wii2zO , I faced the same problem and solved it that way: I created a temp array (this will not be persisted) to let ObjectMapper do its magic and then initialized the NSSet with that array usingNSSet(array: elementsArray!)` .\nHope this helps! (:\nHere's a full exemple:\n```\n@objc(Gallery)\nclass Gallery: AbstractModel, Mappable {\n@NSManaged var title: String?\n@NSManaged var shootingDate: String?\n@NSManaged var elements: NSSet?\nprivate var elementsArray: [Image]?\noverride init(entity: NSEntityDescription, insertIntoManagedObjectContext context: NSManagedObjectContext?) {\n    super.init(entity: entity, insertIntoManagedObjectContext: DBUtils().getManagedObjectContext())\n}\nrequired init?(_ map: Map) {\n    var ctx = DBUtils().getManagedObjectContext()\n    var entity = NSEntityDescription.entityForName(\"Gallery\", inManagedObjectContext: ctx)\n    super.init(entity: entity!, insertIntoManagedObjectContext: ctx)\nmapping(map)\n\n}\noverride func mapping(map: Map) {\nsuper.mapping(map)\n\ntitle           <- map[\"title\"]\nshootingDate    <- map[\"shootingDate\"]\nelementsArray   <- map[\"elements\"]\n\nelements = NSSet(array: elementsArray!)\nelementsArray = nil\n\n}\n}\n```\n. Hi @HRiffiod ,\nI don't know if the difference between Set and NSSet could be the problem, but I always try to use only the types generated by XCode (from the .xcdatamodel file). Could you try with NSSet?\nAnd could you gave us the code line where you get the error?\n. I think you're almost there. I would change your function that way (I guessed the WS parameters' names, maybe you have to change them):\n```\nfunc mapping(map: Map) {\ncredentialBarCode <- map[\"barCode\"]\ncredentialIsHost  <- map[\"isHost\"]\ncredentialTypeId  <- map[\"typeId\"]\ncredentialRSVP    <- map[\"RSVP\"]\ncredentialComment <- map[\"comments\"]\ncredentialZoneId  <- map[\"zoneId\"]\ncredentialMember  <- map[\"member\"]\ncredentialIsCheckedIn   <- map[\"isCheckIn\"]\ncredentialIsCheckedOut  <- map[\"isCheckOut\"]\ncredentialCountCheckIn  <- map[\"countCheckin\"]\ncredentialCountCheckOut <- map[\"countCheckout\"]\ncredentialMemberControlled  <- map[\"memberControlled\"]\ncredentialDeltaFirstCheckIn <- map[\"deltafirstCheckin\"]\ncredentialDeltaFirstCheckOut <- map[\"deltaFirstCheckout\"]\ncredentialHostsArray <- map[\"credentialHosts\"]\ncredentialExtensionFieldsArray <- map[\"credentialExtensionFields\"]\ncredentialHosts = Set(credentialHostsArray!)\ncredentialHostsArray = nil\ncredentialExtensionFields = Set(credentialExtensionFieldsArray!)\ncredentialExtensionFieldsArray = nil\n}\n```\nObjectMapper will do the mapping of HostsArray and ExtensionFieldsArray for you. The (almost) only thing my code does is to save this mapping in a temporary array (i.e. credentialHostsArray) and then \"convert it\" into a NSSet/Set (i.e. credentialHosts). \n. Ok, I got it! Yes, my solution works only if the parameters are always set (mandatory fields). In your case your last answer sounds good, you could also check if the arrays are nil after the mapping and then set an empty array in that case. Let me know if your solution worked! \n. My solution works for a mapping from JSON and you're working to JSON. \nBut nevertheless, I don't understand why your hosts are empty, because you're filling the array used in the ObjectMapper's mapping process. If I understand the ObjectMapper's doc right, the <- operator works in both ways so it should work. If I have time I'll check further why it doesn't work. \nDid you try to debug your code and see what happens during the mapping process?\n. Hi guys,\nI'm sorry, I don't work on that mobile project anymore, so I'll do my best to help you without XCode.\n@f1nality : I set the context with the following line var ctx = DBUtils().getManagedObjectContext(). There you can define wich context you want to use. In my case, if I remembered well, the method just returns the default context.\n@marcospolanco : the EXC_BAD_ACCESS happens typically when you didn't initialize an object. Here a link to help you debugging it: http://www.touch-code-magazine.com/how-to-debug-exc_bad_access/\n. @GABHISEKBUNTY Hi, I'm sorry, I don't work on that mobile project anymore. I cannot remember how I come to this solution. And sorry for the late answer, I was on holidays.\nThe first one overrides the default constructor to call the super constructor including the default context (I get it with DBUtils().getManagedObjectContext()).\nThe second one get the entity \"Gallery\" from the default context (always by calling DBUtils().getManagedObjectContext()), call the super constructor and then call the mapping method.\nI hope it will help, just ask if you need some more precise informations.\n. @calvinsug Sorry, I know this part was a little bit confusing because the DBUtils was part of my project. If I remember well, this method simply returns the default context.. Hi @niks1990 ,\nI'm sorry, I don't work on mobile projects anymore. I don't have any wise hint to suggest... . ",
    "Wii2zO": "Hey,\nI use the method of @vincent-ch to map my JSON and store the POJO to the database, I succeed with one class, but how do that with a member which is an Array of another object ?\nObjectMapper use a simple Array to do this and it works perfectly, but CoreData use \"NSSet\" for relationships with another table...\nI don't know how to do...\n. Thank you for your response !\nIt seems to work... !\n. ",
    "HRiffiod": "Hi there, I've been trying @vincent-ch 's code but I'm having some troubles mapping custom NSManaged classes. Here's an example of my class : \nimport Foundation\nimport CoreData\nclass Credential: NSManagedObject, Mappable {\n@NSManaged var credentialArrivalDate: String?\n@NSManaged var credentialBarCode: String?\n@NSManaged var credentialComment: String?\n@NSManaged var credentialCountCheckIn: Int\n@NSManaged var credentialCountCheckOut: Int\n@NSManaged var credentialDepartureDate: String?\n@NSManaged var credentialId: String?\n@NSManaged var credentialIsArrived: Bool\n@NSManaged var credentialIsCheckedOut: Bool\n@NSManaged var credentialIsHost: Bool\n@NSManaged var credentialLastModificationDate: String?\n@NSManaged var credentialMemberControlled: String?\n@NSManaged var credentialNumberOfPeople: Int\n@NSManaged var credentialRSVP: Int\n@NSManaged var credentialTypeId: String?\n@NSManaged var credentialTypeName: String?\n@NSManaged var credentialZoneId: String?\n@NSManaged var credentialZoneName: String?\n@NSManaged var credentialHosts: Set<Host>?\n@NSManaged var credentialMember: Member\n@NSManaged var credentialExtensionFields: Set<ExtensionFields>?\n@NSManaged var credentialDeltaFirstCheckIn: String?\n@NSManaged var credentialDeltaFirstCheckOut: String?\n@NSManaged var credentialIsCheckedIn: Bool\n}\nI have a relationship to a Member NSManaged class, and to-many relationships to Host and ExtensionFields.\nMy goal is to build JSON data from the credential class (including the relationships). I did have some success with a custom parser ( see my post on stack-overflow : http://stackoverflow.com/questions/31672558/ios-swift-serialize-a-nsmanagedobject-to-json-with-relationships/31697576?noredirect=1#comment51347010_31697576)\nBUT to conform to the json data that the web service needs, I need to map my class because the variables don't have the same names etc.\nThat said, I'm getting error (found nil while unwrapping) with @vincent-ch' s code (the difference being I use Set and not NSSet, could it be the problem here ?) \nIs there a way to map my JSON string just to change variables name or can ObjectMapper do the magic for me ?\nThanks for your help,\nHugo\n. Hi @vincent-ch ,\nso I added this code to my class : \n// temporary array tos allow mapping\n    var credentialHostsArray: [Host]?\n    var credentialExtensionFieldsArray: [ExtensionFields]?\n```\nclass func newInstance() -> Mappable {\n    return Credential()\n}\nfunc mapping(map: Map) {\ncredentialBarCode <- map[\"barCode\"]\ncredentialIsHost  <- map[\"isHost\"]\ncredentialTypeId  <- map[\"typeId\"]\ncredentialRSVP    <- map[\"RSVP\"]\ncredentialComment <- map[\"comments\"]\ncredentialZoneId  <- map[\"zoneId\"]\ncredentialMember  <- map[\"member\"]\ncredentialIsCheckedIn   <- map[\"isCheckIn\"]\ncredentialIsCheckedOut  <- map[\"isCheckOut\"]\ncredentialCountCheckIn  <- map[\"countCheckin\"]\ncredentialCountCheckOut <- map[\"countCheckout\"]\ncredentialMemberControlled  <- map[\"memberControlled\"]\ncredentialDeltaFirstCheckIn <- map[\"deltafirstCheckin\"]\ncredentialDeltaFirstCheckOut <- map[\"deltaFirstCheckout\"]\n\ncredentialHosts = Set(credentialHostsArray!)\ncredentialHostsArray = nil\n\ncredentialExtensionFields = Set(credentialExtensionFieldsArray!)\ncredentialExtensionFieldsArray = nil\n\n}\n```\nand I'm getting the error on this line : credentialHosts = Set(credentialHostsArray!)\nWhich is not that surprising because my array is declared as optional and is never initialized/filled before this line is called. so my JSON string should contain something like \"credentialHosts\" : .\nMaybe I'm misunderstanding some initialization part (I'm kinda new to Swift). Should I add some code to my Host class for example ? At this time it looks like this : \nimport Foundation\nimport CoreData\nclass Host: NSManagedObject {\n@NSManaged var hostEmail: String\n@NSManaged var hostId: String\n@NSManaged var hostName: String\n@NSManaged var hostPhone: String\n@NSManaged var hostTitle: String\n@NSManaged var hostCredential: Credential\n}\nPS : I'd like to make sure that it does not come from an misunderstanding instead of NSSet because I'm trying to use as much as possible native types in my app...\n. Thank you for your answer, I updated my code, unfortunately, same error : \n\nI have a View Controller with a bunch of textfields where I get user input values, set them in a Credential object and then I want the corresponding JSON string.\nLet's say my User did not specify any Host, the credentialHosts array will then be nil, according to the declaration right ?\nSo where using forced unwrapping, it founds nil and crashes (I guess, not 100% sure).\nSo maybe my mistake is I should always : \n- Create a New Credential Entity (and insert it in my managed context)\n- Retrieve the values from the text fields and set them to my new Credential\n- Create a New Host Array (even if there is no Host, just to make an empty array an avoid crashing ?)\n- Set it like this : newCredential.credentialHostsArray = hostArray\n- Then map using Mapper().toJSONString ?\n. So I tried creating empty arrays, if prevents from crashing, first step :)\nHowever, event when hard-coding some value to a host, my Json output does not contain my Host array, any idea why it does not work ?\nHere is the code : \n// create a host Array to avoid crashing if nil\n        var hostsArray = Host\n        let newHost = NSEntityDescription.insertNewObjectForEntityForName(\"Host\", inManagedObjectContext: self.managedObjectContext!) as! Host\n        newHost.hostName = \"testHostName\"\n        hostsArray.append(newHost)\n        newCredential.credentialHostsArray = hostsArray\n```\n    // create a credentialExtensionFields Array to avoid crashing if nil\n    var extensionFieldsArray = ExtensionFields\n    newCredential.credentialExtensionFieldsArray = extensionFieldsArray\n// create a request to fetch the credential\nlet requestGuest = NSFetchRequest(entityName: \"Credential\")\n\n// set a predicate to retrieve the credential according to its Id\nrequestGuest.predicate = NSPredicate(format: \"credentialId = %@\", newCredential.credentialId!)\n\n/**********/\n\n// execute request\nlet testFetch = (managedObjectContext!.executeFetchRequest(requestGuest, error:nil) as! [Credential]).first!\n\nvar jsonTestGuest = Mapper().toJSONString(testFetch, prettyPrint: true)\nprintln(jsonTestGuest!)\n\n```\nand here is the json output : \n{\n  \"memberControlled\" : \"Hugo\",\n  \"RSVP\" : 1,\n  \"comments\" : \"a comment\",\n  \"isHost\" : false,\n  \"countCheckout\" : 0,\n  \"isCheckIn\" : false,\n  \"countCheckin\" : 0,\n  \"isCheckOut\" : false\n}\n. ",
    "f1nality": "Guys, what do you if you have multiple ManagedObjectContext? I don't see any options how to tell mapper which context is should create entites in..\n. ",
    "marcospolanco": "@vincent-ch, you might be the only person on Earth to get this working. I followed your example (thx!) yet my code crashes calling mapping(map) with EXC_BAD_ACCESS(code=1). Seen anything like this? \n. ",
    "iroller": "@bonebox how do you convert objects to JSON when using Sync? Are you still using ObjectMapper for it? Can't get them both to work together\nUPDATE: nevermind, I think I figured it out https://github.com/hyperoslo/Sync/pull/165\n. ",
    "jackalcooper": "What is the proper place to perform the function managedObjectContext.save() ? Or it is unnecessary? \n. ",
    "Steveybrown": "@f1nality I have this working with multi contexts, one way to achieve this is to use a custom mapping context object. The custom mapping context object can hold an NSManagedObjectContext in which you want to save the object. To extract this NSManagedObjectContext from the init function we can do something like map.context.myManagedObjectContext. This still works cleanly with @vincent-ch solution. \n. ",
    "GABHISEKBUNTY": "@vincent-ch Hi I am working on a project that uses objectMapper for its use. Please kindly explain what exactly is being done by this 2 functions:\n```\noverride init(entity: NSEntityDescription, insertIntoManagedObjectContext context: NSManagedObjectContext?) {\n    super.init(entity: entity, insertIntoManagedObjectContext: DBUtils().getManagedObjectContext())\n}\nrequired init?(_ map: Map) {\n    var ctx = DBUtils().getManagedObjectContext()\n    var entity = NSEntityDescription.entityForName(\"Gallery\", inManagedObjectContext: ctx)\n    super.init(entity: entity!, insertIntoManagedObjectContext: ctx)\nmapping(map)\n\n}\n```\n. @tristanhimmelman Actually I just wanted to know what exactly is going on these 2 methods. A small quick explannation will be quite helpful. And what is the need of these functions?\n. @tristanhimmelman But what exactly this implementation helps for?\n. ",
    "calvinsug": "Hi @vincent-ch , is this code still working on Swift3 on iOS 10 ? cause i cant use DButils, it says \"Use of unresolved identifier 'DBUtils'\"\nis DBUtils come from another library ?. ",
    "niks1990": "@vincent-ch i used your code and its working perfectly. But when i relaunch the app all the save datas in core data db get disappeared. \nI used the same code\n```\n@objc(Gallery)\nclass Gallery: AbstractModel, Mappable {\n@NSManaged var title: String?\n@NSManaged var shootingDate: String?\n@NSManaged var elements: NSSet?\nprivate var elementsArray: [Image]?\noverride init(entity: NSEntityDescription, insertIntoManagedObjectContext context: NSManagedObjectContext?) {\n    super.init(entity: entity, insertIntoManagedObjectContext: DBUtils().getManagedObjectContext())\n}\nrequired init?(_ map: Map) {\n    var ctx = DBUtils().getManagedObjectContext()\n    var entity = NSEntityDescription.entityForName(\"Gallery\", inManagedObjectContext: ctx)\n    super.init(entity: entity!, insertIntoManagedObjectContext: ctx)\nmapping(map)\n\n}\noverride func mapping(map: Map) {\nsuper.mapping(map)\n\ntitle           <- map[\"title\"]\nshootingDate    <- map[\"shootingDate\"]\nelementsArray   <- map[\"elements\"]\n\nelements = NSSet(array: elementsArray!)\nelementsArray = nil\n\n}\n}\n```\nAny  help will be appreciated.. ",
    "haroldogtf": "@niks1990 could you solve your problem? I am facing the same! After relaunch I losing the data.. ",
    "billsea": "Calling mapping(map) in required_init resulted in duplicates. Here's what is working for me:\nimport CoreData\nimport Foundation\nimport ObjectMapper\n@objc(Room)\npublic class Room: NSManagedObject, Mappable {\n  private var devicesArray: [Device]?\noverride init(entity: NSEntityDescription, insertInto context: NSManagedObjectContext?) {\n    super.init(entity: entity, insertInto: DataController.shared.persistentContainer.viewContext)\n  }\nrequired public init?(map: Map) {\n    let ctx = DataController.shared.persistentContainer.viewContext\n    let entity = NSEntityDescription.entity(forEntityName: \"Room\", in: ctx)\nif let dataEntity = entity {\n  super.init(entity: dataEntity, insertInto: ctx)\n} else {\n  super.init()\n}\n\n}\npublic func mapping(map: Map) {\n    id <- map[\"id\"]\n    unit <- map[\"unit\"]\n    name <- map[\"name\"]\n    roomDescription <- map[\"roomDescription\"]\n    devicesArray <- map[\"devices\"]\nif let devices = devicesArray {\n  device = NSSet(array: devices)\n}\n\ndevicesArray = nil\n\n}\n}\n. ",
    "ricardonho": "\n@vincent-ch, you might be the only person on Earth to get this working. I followed your example (thx!) yet my code crashes calling mapping(map) with EXC_BAD_ACCESS(code=1). Seen anything like this?\n\nSo many years for this answer... but for me the mapping(map) crash happened when:\n1 - the class prototype was missing @objc(class) declaration;\n2 - the entity on .xcdatamodeld was with codegen different that \"Manual/none\", resulting in a colateral effect after super.init is called, an instance of the autogenerated core data class being allocated instead of my current class... bizarre.. ",
    "tianyuanzhonglu": "the field id can't be mapped when type is Int64\n. @ikesyo it works, thank you\nbut, how about data overflow? when id = Int.MAX + N,  the transformed value is still wrong\n. Int is platform dependent, maybe 32bit or 64bit. Int64 is always 64bit.\niPhone4/4s (iOS 7.x) is 32bit.\nWhen server send 64bit number down, Int will overflow in client.\n. @ikesyo I make a test, the transform work correctly. Thank you!\n. sorry, my mistake.\nthe order is correct\n. ",
    "yuseinishiyama": "Thank you for pointing them out! :smile:\nI've fixed them.\n. ",
    "skywinder": "I update change log from 0.8 to 0.12 version. seems, that there is a lot of changes :wink: \n. ",
    "allaire": "That's cool and would be useful for project updates :+1: \n. @damienrambout I was able to use NSCoding myself with ObjectMapper. No idea if this is legit, but it seems to work, maybe you can advice @damienrambout @tristanhimmelman\nHere's my model:\n``` swift\nclass User: NSObject, NSCoding, Mappable {\n// MARK: Properties\n\nvar id: String!\nvar email: String!\nvar superAdmin: Bool!\nvar locale: String!\nvar highestRole: String!\nvar timeFormat: Int!\nvar confirmedAt: NSDate?\nvar createdAt: NSDate!\nvar unconfirmedEmail: String?\nvar profile: Profile!\nvar members: [Member]?\nvar weekDayStart: Int!\n\n// MARK: Initializers\n\noverride init() {}\n\nrequired init?(_ map: Map) {\n    super.init()\n\n    mapping(map)\n}\n\n// MARK: NSCoding\n\nrequired init(coder decoder: NSCoder) {\n    super.init()\n\n    id = decoder.decodeObjectForKey(\"id\") as! String\n    email = decoder.decodeObjectForKey(\"email\") as! String\n    superAdmin = decoder.decodeBoolForKey(\"superAdmin\")\n    locale = decoder.decodeObjectForKey(\"locale\") as! String\n    highestRole = decoder.decodeObjectForKey(\"highestRole\") as! String\n    timeFormat = decoder.decodeIntegerForKey(\"timeFormat\")\n    confirmedAt = decoder.decodeObjectForKey(\"confirmedAt\") as? NSDate\n    createdAt = decoder.decodeObjectForKey(\"createdAt\") as! NSDate\n    unconfirmedEmail = decoder.decodeObjectForKey(\"unconfirmedEmail\") as? String\n    profile = decoder.decodeObjectForKey(\"profile\") as? Profile\n    weekDayStart = decoder.decodeIntegerForKey(\"weekDayStart\")\n}\n\nfunc encodeWithCoder(coder: NSCoder) {\n    coder.encodeObject(id, forKey: \"id\")\n    coder.encodeObject(email, forKey: \"email\")\n    coder.encodeBool(superAdmin, forKey: \"superAdmin\")\n    coder.encodeObject(locale, forKey: \"locale\")\n    coder.encodeObject(highestRole, forKey: \"highestRole\")\n    coder.encodeInteger(timeFormat, forKey: \"timeFormat\")\n    coder.encodeObject(confirmedAt, forKey: \"confirmedAt\")\n    coder.encodeObject(createdAt, forKey: \"createdAt\")\n    coder.encodeObject(unconfirmedEmail, forKey: \"unconfirmedEmail\")\n    coder.encodeObject(profile, forKey: \"profile\")\n    coder.encodeInteger(weekDayStart, forKey: \"weekDayStart\")\n}\n\n// MARK: Mappable\n\nfunc mapping(map: Map) {\n    id                 <- map[\"id\"]\n    email              <- map[\"email\"]\n    highestRole        <- map[\"highest_role\"]\n    superAdmin         <- map[\"super_admin\"]\n    locale             <- map[\"locale\"]\n    timeFormat         <- map[\"time_format\"]\n    confirmedAt        <- (map[\"confirmed_at\"], ISO8601DateTransform())\n    createdAt          <- (map[\"created_at\"], ISO8601DateTransform())\n    unconfirmedEmail   <- map[\"unconfirmed_email\"]\n    profile            <- map[\"profile\"]\n    members            <- map[\"members\"]\n    weekDayStart       <- map[\"week_day_start\"]\n}\n\n```\n. @tristanhimmelman what would you use to save it on disk?\n. thanks for this @tristanhimmelman. Do you think https://github.com/Haneke/HanekeSwift would work to cache JSON here? Might save some code since I already have it for image caching!\n. Wondering too :)\n. @tristanhimmelman but where that formatter init would go so it's instantiated during the mapping?\n. @tristanhimmelman Super, thanks for the explanation!\n. :+1: \n. @kaandedeoglu Cool, we have a similar way of doing things then, thanks for taking the time to write this down!\n. ",
    "mergesort": "Oh, jeez, I forgot to include the error. It's actually happening at compile time, so the JSON isn't relevant.\nIf I do:\nself.domains <- map[\"domains\"]\nI get 'String' is not identical to 'AnyObject'.\nIf I do:\nself.domains = (map[\"domains\"], StringArrayTransform())\nI get '(Map, StringArrayTransform)' is not convertible to '[String]', which makes more sense to me.\n. Yep, I had it initialized as var domains: [String] = []\nLooks like this was just Xcode freaking out for a prolonged period of time. I wasn't able to get it to work by clearing derived data, cleaning, and the usual suspects, but eventually after restarting my computer it was fine. :cry: \nAll's well that ends well I suppose, thanks for the help!\n. Understatement of the century. :dizzy_face: \n. ",
    "kaandedeoglu": "This is an extension I've been using in my project to map from strings or ints into enum types in my model classes. I think it's pretty useful as a transform\n. I've been using both in a project without any problems, I have a custom Alamofire serializer for ObjectMapper similar to yours for my API calls.\nSwiftyJSON comes in handy for me when a response doesn't really deserve its own class/struct, usually when you're not planning to pass the data around, or you just need look a value up quickly.\nI actually created another Alamofire serializer just for SwiftyJSON usage as well, it looks something like this:\n``` swift\n    func responseSwiftyJSON(completionHandler: (NSURLRequest?, NSHTTPURLResponse?, SwiftyJSON.JSON?, NSError?) -> Void) -> Self {\n        return response(responseSerializer: Request.JSONResponseSerializer(options: .AllowFragments)) {\n            JSONResponse in\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {\n            var JSONResult: SwiftyJSON.JSON? = nil\n            if let obj = JSONResponse.result.value {\n                JSONResult = SwiftyJSON.JSON(obj)\n            }\n\n            dispatch_async(dispatch_get_main_queue()) {\n                completionHandler(JSONResponse.request, JSONResponse.response, JSONResult, JSONResponse.result.error)\n            }                \n        }\n    }\n}\n\nfunc responseSwiftyJSON(completionHandler: (SwiftyJSON.JSON?, NSError?) -> Void) -> Self {\n    return responseSwiftyJSON({ (_, _, json, error) -> Void in\n        completionHandler(json, error)\n    })\n}\n\n```\n. @tristanhimmelman Actually I checked AlamofireObjectMapper a while back to see we almost have identical implementations (I don't have a queue parameter)\nOne interesting thing I use is a serializer just for pretty printing the JSON response, it looks something like this:\nswift\nextension Alamofire.Request {\n    func responseDebugPrint() -> Self {\n        return responseJSON() {\n            response in\n            if let  JSON: AnyObject = response.result.value,\n                    JSONData = try? NSJSONSerialization.dataWithJSONObject(JSON, options: .PrettyPrinted),\n                    prettyString = NSString(data: JSONData, encoding: NSUTF8StringEncoding) {\n             print(prettyString)\n            } else if let error = response.result.error {\n                print(\"Error Debug Print: \\(error.localizedDescription)\")\n            }\n        }\n    }\n}\nWith this I can go \n``` swift\nAlamofire.request(...).responseObject {\n//Code here\n}.responseDebugPrint()\n```\nand have it print without touching my main response block\n. https://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapperTests/CustomTransformTests.swift#L196\nThere's an example in the tests.\n. ",
    "sticksen": "I\u00b4m using 0.9 now, but now the WatchKit Extension crashes:\n```\nDyld Error Message:\n  Library not loaded: @rpath/ObjectMapper.framework/ObjectMapper\n  Referenced from: /private/var/mobile/Containers/Bundle/Application/80C4D949-FF36-4ED7-B417-265E2B62D7BE/FOCUS.app/PlugIns/WatchKit Extension.appex/WatchKit Extension\n  Reason: no suitable image found.  Did find:\n    /private/var/mobile/Containers/Bundle/Application/80C4D949-FF36-4ED7-B417-265E2B62D7BE/MyApp.app/PlugIns/WatchKit Extension.appex/Frameworks/ObjectMapper.framework/ObjectMapper: mmap() error 1 at address=0x1001E0000, size=0x00030000 segment=__TEXT in Segment::map() mapping /private/var/mobile/Containers/Bundle/Application/80C4D949-FF36-4ED7-B417-265E2B62D7BE/MyApp.app/PlugIns/WatchKit Extension.appex/Frameworks/ObjectMapper.framework/ObjectMapper\n  Dyld Version: 353.10\nBinary Images:\n0x1200a0000 - 0x1200c7fff dyld arm64   /usr/lib/dyld\n0x19569c000 - 0x19578afff libxml2.2.dylib arm64  <4d23734e8cd6356bbbeb51968458abb6> /usr/lib/libxml2.2.dylib\n```\n. ",
    "Romixery": "Thanks. Work's great !!!!.....\n. ",
    "tmnd1991": "Right! thank you, it's ok to close the issue!\n. ",
    "tobiasoleary": "Closing Issues - Looked at Mapper.swift and found mapArray function.\n. The commented line is not an empty array. It's an array with an empty string. .\nYou probably want something like this:\ndictionary[key] = []\n. This sounds like a perfect case for using a Custom transform \n. That error means your string is not JSON it's a invalid format. \n. Maybe a new repository could be started for custom transforms. \n. You need to implement the Mappable protocol, there needs to be an init method that takes a map. \n. Why can't you make type of 'id' 'Int?'?\n. Oh never mind. I see what you asking. \n. Maybe just add a link to JSONExport in the README?\n. Is there a guide on the best way to support SwiftPM, Cocoapods, and Carthage in the same branch?\n. I couldn't find one on Google. \n. Does the SwiftDeferredNSArray type implement Mappable?\n. Nevermind. Being dumb. \n. ",
    "J-Sizzle": "Yep that was the problem.  You da man :+1: \n. ",
    "rkawajiri": "Hi @tristanhimmelman, I added missing tests and implementations. If it looks good, please merge it.\nAs you might know, travis-ci has problems with xcode version. My change does not cause the build errors. Please, run tests on your local machine.\nThanks :smile:\n. ",
    "hirohisa": "\n. Thanks! \n. ",
    "pfitz": "Ah ok. Did not believed it to be THAT easy. With Mantle you had to say which class is should map to. It is working. Thanks!!!\n. ",
    "teameh": ":+1: Thanks! \n. ",
    "SpacePossum": ":+1: \n. ",
    "perforator85": "Thanks! \u2026 here is the final working snippet (at least compileable - I'll try it soon)\nlet transform = TransformOf<CLLocation, [Double]>(fromJSON: { (value: [Double]?) -> CLLocation? in\n        if let coordList = value\n            where coordList.count == 2 {\n                return CLLocation(latitude: coordList[1], longitude: coordList[0])\n        }\n        return nil\n        }, toJSON: { (value: CLLocation?) -> [Double]? in\n            if let location = value {\n                return [Double(location.coordinate.longitude), Double(location.coordinate.latitude)]\n            }\n            return nil\n    })\n. ",
    "dinarajas": "@perforator85 How do you make sure that coordList[1] is always latitude and coordList[0] is always longitude?. @tristanhimmelman Thanks for an idea.\nBut, it is a valid scenario. We can have one root key to parse both child and parent object. If we manually create the object, won't that defeat the actual purpose of ObjectMapper?\nIf there is any plan to implement this feature, please direct me to see that. Thanks.. ",
    "Carpemeid": "It works fine with that corrected comment) thank you)\n. ",
    "jlouazel": "Thanks for your quick answer. Indeed my error was there, thanks for your time.\n. ",
    "bennichols": "Thanks! I'm not sure what you're asking though... I'm interested in [String: [N]].\n. This change breaks the library for my use case, I believe. I use a BaseObject: Mappable class with an \"id\" field that has its own custom transform. I then derive all my objects from that BaseObject. The newInstance method is static, which in Swift also means it's final, so I can no longer subclass my Mappable BaseObject.\n. Ok, that appears to work. Thanks Tristan!\n. ",
    "RishabhTayal": "Any update on this? Can we parse dictionary with uppercase and camel case keys for the same field?. Thanks. Here is the branch link for reference: swift-3\n. ",
    "SinghBabita": "i have pass the same string twice. first time it execute perfectly but in second time it show the error Error Domain=NSCocoaErrorDomain Code=3840 \"The operation couldn\u2019t be completed. (Cocoa error 3840.)\" (Garbage at end.) UserInfo=0x7f8730567000 {NSDebugDescription=Garbage at end.}. ",
    "Pinturaj": "But how to print that invalid json string formate so that I can check any extra tag or any thing in json. . ",
    "devxoul": "@vitkuzmenko opened a new PR with tests: #616 (this comment is just for issue linking)\n. Try this:\nISO8601ExtendedDateTransform.swift\n``` swift\n/// ISO 8601 extended date format transform which contains milliseconds.\nclass ISO8601ExtendedDateTransform: DateFormatterTransform {\ninit() {\n    let formatter = NSDateFormatter()\n    formatter.locale = NSLocale(localeIdentifier: \"en_US_POSIX\")\n    formatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n    super.init(dateFormatter: formatter)\n}\n\n}\n``\n. I hope to use this feature in ObjectMapper :)\n. @mapo80, I'm trying to make a new immutable implementation based onmaster`. I think I can make a PR in several hours.\n. Hey guys, I made another implementation for supporting immutables. Could you check for this(#592)? Thanks!\n@tristanhimmelman @mapo80 \n. @deepp, swift-3 branch is now merged into master. Use the version 2.0.0 instead.\n. @deepp AlamofireObjectMapper 4.0.0 has ObjectMapper ~> 2.0 dependency. Try using 4.0.0 instead 4.0.0-beta.\n. @diogorborges, how did you setup ObjectMapper in you project?\n. @tristanhimmelman, this problem occurs with enum.\nTry adding this line to testNestedKeys() function in NestedKeyTests.swift.\nswift\nXCTAssertEqual(value.floatEnum, FloatEnum.b) // this will fail because `value.floatEnum` is `nil`.\n. Why tests fail?\n. @tristanhimmelman, thanks for your review! These are my answer:\n1. Mappable should require func mapping(map:) because this is the only function which defines mapping relationship (init() is not designated for mapping). However, ImmutableMappable has an initializer for doing that. I thought it was OK to not implement the func mapping(map:) if you're not using toJSON functionality.\n2. Well, we could imagine something like map[\"key\"] <- self.property instead of self.property <- map[\"key\"] to get rid of declaring local mutable variables. But neither can this remove the code repetition :-(\n3. I really want to make the initializer of Mappable throwable. Why I made ImmutableMappable separately is because I thought you were worrying about the breaking API changes. How about using ImmutableMappable as an experimental feature? We can improve the detailed implementation in future release while giving users an opportunity to use immutables earlier.\n. @tristanhimmelman How about creating a new branch named immutable-mappable and merge #592 into that branch? This PR also could be re-targeted to that branch. The reason is to see diffs easily and make these PRs as small as possible. We can merge immutable-mappable into master when ready for beta release.\n. @mzeeshanid, which error message did you get?\n. @tristanhimmelman, Alternatively we can swap the left and right:\nswift\nmap[\"key\"] <- (prop1, MyTransform())\nor something like ~> or => or ->>? \ud83e\udd14 But I also like >>> too :+1:\n\nPS: Could you please rebase immutable-mappable branch to make this PR small? Commits of #592 and #594 are included in this PR.\nbash\n$ git checkout immutable-new-operator\n$ git pull --rebase origin immutable-mappable\n$ git push origin immutable-new-operator --force\n. I like this\n. You can use map[\"event_list.on_air_list\"] instead. This is documented at here.\n. I think you can use your own Transform. Something like TransformOf<[String: Any], Int> maybe :)\n. @leizard I didn't test this code but you may figure out how it works :)\n`` swift\nlet attributePriceTransform = TransformOf(\n  // fromJSON - convert attribute dictionary to Int value\n  //\n  // for example:\n  //   input: {\n  //      \"attribute_code\": \"price\",\n  //      \"value\": \"100\"\n  //   }\n  //   output:100//\n  //   input: {\n  //      \"attribute_code\": \"age\",\n  //     \"value\": \"5\"\n  //   }\n  //   output:nilfromJSON: { (attribute: [String: Any]?) -> Int? in\n    if attribute?[\"attribute_code\"] == \"price\" {\n      return attribute?[\"value\"] as? Int\n    }\n    return nil\n  },\n  // toJSON - convert Int value to attribute dictionary\n  //\n  // for example:\n  //   input:100//   output: {\n  //      \"attribute_code\": \"price\",\n  //      \"value\": \"100\"\n  //   }\n  //\n  //   input:nil//   output:nil`\n  toJSON: { (value: Int?) -> [String: Any]? in\n    if let value = value {\n      return [\n        \"attribute_code\": \"price\",\n        \"value\": \"(value)\",\n      ]\n    }\n    return nil\n  }\n)\nmyPrice <- map[\"attributes\", attributePriceTransform]\n```\nActually TransformOf is an inline(short) version of TransformType. You can check TransformType for more details.\n. Related issues: #592 #594 #598\n. @tristanhimmelman Sure! I'll make a new PR in several minutes :+1:\n. Duplicated with #580 and fixed in #605.\n. I'm not sure what you intend to do. If you'd like to...\n1. Make initializer fail when there's no result.address_components in the JSON.\n=> See https://github.com/Hearst-DD/ObjectMapper#init_-map-map\n2. Use default value instead when there's no result.address_components in the JSON.\n=> You might need to use Transform. See my answer in similar question: #606\n. Oh, I got it. In this case you should use your own Transform. I would do like this:\n``` swift\nstruct AddressComponent {\n  var route: String?\n  var streetNumber: String?\n}\nlet addressComponentRouteTransform = TransformOf<[[String: Any]], AddressComponent>(\n  // Input:\n  //     [\n  //       {\n  //         \"long_name\": \"36\",\n  //         \"short_name\": \"36\",\n  //         \"types\": [\n  //           \"street_number\"\n  //         ]\n  //       },\n  //       {\n  //         \"long_name\": \"Rue de Dunkerque\",\n  //         \"short_name\": \"Rue de Dunkerque\",\n  //         \"types\": [\n  //           \"route\"\n  //         ]\n  //       }\n  //     ]\n  //\n  // Output:\n  //     AddressComponent(route: \"36\", streetName: \"Rue de Dunkerque\")\n  fromJSON: { (componentDicts: [[String: Any]]?) -> AddressComponent?\n    let route = componentDicts?.lazy\n      .filter {\n        guard let types = $0[\"types\"] as? [String] else { return false }\n        return types.contains(\"route\")\n      }\n      .flatMap {\n        $0[\"long_name\"] as? String\n      }\n    let streetNumber = componentDicts?.lazy\n      .filter {\n        guard let types = $0[\"types\"] as? [String] else { return false }\n        return types.contains(\"street_number\")\n      }\n      .flatMap {\n        $0[\"long_name\"] as? String\n      }\n  },\n// Input:\n  //     AddressComponent(route: \"36\", streetName: \"Rue de Dunkerque\")\n  //\n  // Output:\n  //     [\n  //       {\n  //         \"long_name\": \"36\",\n  //         \"short_name\": \"36\",\n  //         \"types\": [\n  //           \"street_number\"\n  //         ]\n  //       },\n  //       {\n  //         \"long_name\": \"Rue de Dunkerque\",\n  //         \"short_name\": \"Rue de Dunkerque\",\n  //         \"types\": [\n  //           \"route\"\n  //         ]\n  //       }\n  //     ]\n  toJSON: { (component: AddressComponent?) -> [[String: Any]]?\n    var componentDicts: [[String: Any]] = []\n    if let route = component?.route {\n      componentDicts.append([\n        \"long_name\": route,\n        \"short_name\": route,\n        \"types\": [\n          \"route\",\n        ],\n      ])\n    }\n    if let streetNumber = component?.streetNumber {\n      componentDicts.append([\n        \"long_name\": streetNumber,\n        \"short_name\": streetNumber,\n        \"types\": [\n          \"street_number\",\n        ],\n      ])\n    }\n    return componentDicts\n  }\n)\nstruct Venue {\n  var address: AddressComponent\nmutating func mapping(map: Map) {\n    self.address <- (map[\"address_components\"], addressComponentRouteTransform)\n  }\n}\n```\nTip: Use 3 backticks(`) to make a code block in markdown.\n\n```swift\nfunc doSomething() {\n}\n```\n\nswift\nfunc doSomething() {\n}\nOr you can use <pre> tag if you want to make a bold text somewhere.\n<pre>\nfunc <strong>doSomething</strong>() {\n}\n</pre>\n\nfunc doSomething() {\n}\n\n. Could you provide us a compilable code to test deserializing?\n. @bdrelling, I mean the test code. Is this what you expected?\n``` swift\nfunc testDeserializeUser() {\n  let json: [String: Any] = [\"id\": 10]\n  assert(deserialize(json) == MyClass(data: User(id: 10)))\n}\nfunc testDeserializeString() {\n  let json: String = \"hello\"\n  assert(deserialize(json) == MyClass(data: \"hello\"))\n}\nfunc testDeserializeInt() {\n  let json: Int = 123\n  assert(deserialize(json) == MyClass(data: 123))\n}\n``\n. Replacerequired init?(_ map: Map)torequired init?(map: Map)`.\ndiff\n- required init?(_ map: Map)\n+ required init?(map: Map)\nREADME seems outdated :)\n. @tristanhimmelman No problem! I really love this project \ud83d\udc4d\n. @mahmoudnaja, how did you setup your Podfile?\n. Did you mean that your ObjectMapper 1.x is installed?\n. @mahmoudnaja have you tried $ pod update? If it doesn't work, try:\nconsole\n$ pod repo update\n$ pod install\n. By the way, I love this PR because this is much better than what I made in my project :+1:\n. I intended to leave a comment on cd824806f47cd4181f27c47155d343ebcb956909 :(\n. @borut-t, what do you mean 'fail'?\n. @borut-t Have you tried this?\ndiff\n- object = Mapper<T.self>().map(data, toObject: object!)\n+ object = Mapper<T>().map(data, toObject: object!)\n. @borut-t Could you please provide me how T is declared?\n. I intended it for internal usage, but there's no problem if it become a public :)\n. @zhanghongdou, please provide us how to reproduce the bug and what you expected.\n. @zhanghongdou Thank you for providing me a detail :smile:\n1. class_copyPropertyList only works with Objective-C compatible properties.\n2. Double? cannot be used in Objective-C. (But Double can be used in Objective-C)\n3. Use NSNumber? to do what you want.\n. @zhanghongdou have you tried this?\nswift\nclass InvestRecordListModel: NSObject, Mappable {\n  ...\n}\n. @zhanghongdou Sounds great! Could you please close this issue? :tada:\n. @brentpi, you can use property <- map[\"my.key\", nested: false] instead.\n. @brentpi That makes sense. How about this approach? It allows to pass delimiter parameter to map[] subscription.\nswift\nproperty <- map[\"_items -> 0 -> com.apple.corestorage.lv -> com.apple.corestorage.lv.encrypted\", delimiter: \" -> \"]\n. @brentpi, #629 is for you :tada:\n. @tristanhimmelman .swift-version file is for linting podspec. We need s.pod_target_xcconfig in podspec which is added in https://github.com/Hearst-DD/ObjectMapper/commit/e7408cab845c4204752ff20e2cce1d48cac962bc. (shipped with 2.1.0 release)\nSo @danipralea, you have two options:\n1. Use ObjectMapper 2.1.0\n2. Add this script at the end of the Podfile:\nruby\n   post_install do |installer|\n     installer.pods_project.targets.each do |target|\n       target.build_configurations.each do |config|\n         config.build_settings['SWIFT_VERSION'] = '3.0'\n       end\n     end\n   end\n. Can you provide expected output with that json?\n. @Dbigshooter try:\n``` swift\nclass MyObject: Mappable {\n  var id: Int!\n  var sId: Int!\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    sId <- map[\"sId\"]\n  }\n}\nfunc myObjects(from json: [String: [[String: Any]]]) -> [Int: [MyObject]] {\n  var objects: [Int: MyObject] = [:]\n  for (key, array) in dict {\n    guard let key = Int(key) else { continue }\n    guard let objects = Mapper().mapArray(JSONArray: array) else { continue }\n    objects[key] = objects\n  }\n  return objects\n}\nlet objects = myObjects(from: json)\nprint(objects)\n. swift\nclass MyObject: Mappable {\n  var id: Int!\n  var sId: Int?\n  var fieldId: Int?\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    sId <- map[\"sId\"]\n    fieldId <- map[\"fieldId\"]\n  }\n}\nlet dict: [String: [[String: Any]]] = [\n  \"2443\": [\n    [\"id\": 354299, \"sId\": 2443],\n    [\"id\": 354300, \"sId\": 2443],\n  ],\n  \"2448\": [\n    [\"id\": 354312, \"fieldId\": 2448],\n  ]\n]\nlet objectsByID = Mapper.mapDictionaryOfArrays(JSON: dict)\nprint(objectsByID)\n```\nThis code will convert your JSON dictionary into:\nswift\n[\n  \"2443\": [\n    MyObject(id: 354299, sId: 2443)\n    MyObject(id: 354300, sId: 2443)\n  ],\n  \"2448\": [\n    MyObject(id: 354312, fieldId: 2448)\n  ]\n]\n. @Dbigshooter I'm not sure this is what you expected. If not, please provide us the expecting output with your model classes.\n. @Dbigshooter, which output would you like to get?\n1. [Int: MeasurementsTransfer]\n2. [MeasurementsTransfer]\n3. MeasurementsTransfer\n. @Dbigshooter, I would wrap the dictionary:\nBefore\njson\n{ \n  \"2443\": [{\"id\": 354299, \"sId\": 2443}, {\"id\": 354300, \"sId\": 2443}], \n  \"2448\": [{\"id\": 354312, \"fieldId\": 2448}, {\"id\": 354300, \"sId\": 3728}] \n}\nAfter\njson\n{\n  \"measurements\": {\n    \"2443\": [{\"id\": 354299, \"sId\": 2443}, {\"id\": 354300, \"sId\": 2443}], \n    \"2448\": [{\"id\": 354312, \"fieldId\": 2448}, {\"id\": 354300, \"sId\": 3728}] \n  }\n}\n... and map it to MeasurementsTransfer:\n``` swift\nclass MeasurementsTransfer: EVObject, Mappable {\n  var measurements: [String : [Measurement]] = [:]\nfunc mapping(map: Map) {\n      measurements <- map[\"measurements\"]\n  }\n}\nAlamofire.request(url, method: .get, parameters: params, headers: headers()).responseJSON { response in\n  let measurementJSONs = response.result.value as! [String: [String: Any]]\n  let measurementsTransferJSON = [\"measurements\": measurementJSONs]\n  if let ms = Mapper().map(JSON: measurementsTransferJSON) {\n      print(ms)\n      completionHandler(ms, nil)\n  } else {\n      print(\"Failed\")\n      completionHandler(nil, false)\n  }\n}\n```\n. @Dbigshooter I didn't mean to change the JSON from the backend. Just wrap the dictionary in your Swift code.\nswift\nlet measurementsTransferJSON = [\"measurements\": measurementJSONs]\n. @Dbigshooter, when did you get that crash?\n. Try\nlet measurementJSONs = response.result.value as! [String: [String: Any]]\nfirst, then adding second line, then adding third line.\n. Then you can cast it or whatever you get from the server to dictionary :(\n. Try\ndiff\n- Mapper<MeasurementsTransfer>().mapDictionary(JSON: measurementJSONs as! [String : [String : Any]])\n+ Mapper<MeasurementsTransfer>().map(JSON: measurementJSONs as! [String : [String : Any]])\n. @Dbigshooter, if you're using Swift 3, you should use Date instead of NSDate.\n. @Dbigshooter please provide us the JSON dictionary\n. What is the type of response.result.value?\n. @mirzadelic, I think response.result.value is String on runtime but not in compile time. Try explicit type casting:\ndiff\n- let item = AdminTableGroup(JSONString: response.result.value!)\n+ let item = AdminTableGroup(JSONString: response.result.value as! String)\n. @Busta117, why do we need this? Could you provide us more detail use case?\n. @rbukovansky It was wrong comment \ud83d\ude05\n. Could you please provide us how to reproduce the bug?\n. @zemadara, which line did you get the error? There's no ObjectMapper related code.\nTip: you can format the code with 3 backticks(```). For example:\n\n```swift\nAlamofire.request(self.url, method: post, .......) {\n  .......\n}\n```\n\n. @Flar49, could you please write a test for this?\n. @tylerlong, I'm using custom Transform.\n`` swift\n/// A transform which converts JSON toString.\n///\n/// - warning: It doesn't gaurantee the original type when convertString` to JSON.\nstruct StringTransform: TransformType {\nfunc transformFromJSON(_ value: Any?) -> String? {\n    return value.flatMap(String.init(describing:))\n  }\nfunc transformToJSON(_ value: String?) -> Any? {\n    return value\n  }\n}\n```\nThen\nswift\nfunc mapping(map: Map) {\n  stringValue <- (map[\"key\"], StringTransform())\n}\n. You should use 1.x for Swift 2\n. Possibly duplicated with #631. Use Date, not NSDate.\n. ImmutableMappable is designed to throw exceptions on mapping failure. So every immutable mappings should be used with try or try? keyword. I think it would be better to let users know that they should have used try keyword on immutable mappings. Maybe we could use assert() or something.\n. @arctouch-marcelogobetti, I thought you were using something like:\nswift\nlet user = Mapper<ImmutableUser>().map(JSON: jsonDictionary) // this is wrong\nCould you please provide me some detail about what you expected? (or where you got that assertion message)\n. @arctouch-marcelogobetti, thank you for providing details. Moya-ObjectMapper is not currently  supporting ImmutableMappable mappings. https://github.com/ivanbruel/Moya-ObjectMapper/pull/28 is the patch for this issue :smile:\n. @arctouch-marcelogobetti, it's because users don't have to change their existing code to support ImmutableMappables.\n. @arctouch-marcelogobetti, I think I misunderstood your previous question:\n\nWhy creating a new set of mapObject and mapArray functions specifically typed to ImmutableMappable is a better solution?\n\nDid you mean why I created a separated function mapObject and mapArray rather than adding if-else statement in existing functions?\n. @arctouch-marcelogobetti, thanks for the detailed explanation.\nTotally agree with you. Of course we need an additional assertion message for ImmutableMappable (for whom mistakenly used map() without try). I could approve this PR if it was just about adding assertion message for ImmutableMappable. But this PR contains the initialization of ImmutableMappable in non-throwing function: map(). This is wrong way to use of ImmutableMappable.\nAs you can see in ImmutableMappable.swift#L153-L157, every map() functions are declared separately from the existing Mapper. Because map() on ImmutableMappable should be marked as throwable.\nSo I asked you the reason why you had faced wrong map() function, and it was because Moya-ObjectMapper didn't support ImmutableMappable. And this is why I did same in Moya-ObjectMapper.\nPlease feel free to ask anything you don't understand :smile::+1:\n. @ivanbruel, Thanks for asking about ImmutableMappable! Here are the reasons:\n1. I also had similar consideration when I was developing the ImmutableMappable. I concluded with myself, that users would not use ImmutableMappable with Mappable. (Why would they even do that?) However, we can discuss about this if you have different idea.\n2. According to @tristanhimmelman from #617:\n\nI think that if you define an model as ImmutableMappable you expect a error to be thrown if something was not correctly map.\n\nmap() function on BaseMappable cannot throw an error if ImmutableMappable is not correctly mapped. I think this is not a well-designed API.\n. @ivanbruel @tapi #780 is a patch for this issue. This PR makes it available to make an ImmutableMappable as a property of Mappable.. @lukewar, thanks for your work! How about using EnumTransform just like this? We can just return self.value(..., using: EnumTransform()).\n. @lukewar I mean, the function func value<T: RawRepresentable>(key, nested, ...) could be easily implemented if you used EnumTransform.\nswift\npublic func value<T: RawRepresentable>(_ key: String, nested: Bool? = nil, delimiter: String = \".\", file: StaticString = #file, function: StaticString = #function, line: UInt = #line) throws -> T {\n    return try self.value(key, nested: nested, delimiter: delimiter, using: EnumTransform(), file: file, function: function, line: line)\n}\n. @KoCMoHaBTa, thanks for your proposal. Could you provide us the example use case? I mean, why do we need a post validation. Transforms are well-tested, and we can write tests for models.\n. @KoCMoHaBTa, You could write a test of PaymentCard in the Test Target of your project. Isn't it enough? I'm not sure why these things should be validated in Application Target.\n. @mikkelam, do you want an array of MarketEstimate?. Is this what you want? I have no idea where price and mileage come from.\nInput\njson\n{\n    \"market_estimates\": {\n        \"2000\": {\n            \"0\": 12830, \n            \"10000\": 11041\n        },\n        \"2001\": {\n            \"0\": 12830, \n            \"10000\": 11041\n        }\n    }\n}\nOutput\nswift\n[\n  MarketEstimate(year: 2000, price: 12830, mileage: 11041),\n  MarketEstimate(year: 2001, price: 12830, mileage: 11041),\n]. You have to manipulate that json. Try:\n```swift\nlet dict: [String: Any] = [\n  \"market_estimates\": [\n    \"2000\": [\n      \"0\": 12830,\n      \"10000\": 11041\n    ],\n    \"2001\": [\n      \"0\": 12830,\n      \"10000\": 11041\n    ]\n  ]\n]\n// [\n//   {\n//     \"year\": 2000,\n//     \"mileage\": 0,\n//     \"price\": 12830\n//   },\n//   {\n//     \"year\": 2000,\n//     \"mileage\": 10000,\n//     \"price\": 11041\n//   },\n//   {\n//     \"year\": 2001,\n//     \"mileage\": 0,\n//     \"price\": 12830\n//   },\n//   {\n//     \"year\": 2001,\n//     \"mileage\": 10000,\n//     \"price\": 11041\n//   }\n// ]\nlet jsonArray = (dict[\"market_estimates\"] as? [String: [String: Int]] ?? [:])\n  .flatMap { yearString, mileageAndPrice in\n    return mileageAndPrice.flatMap { mileageString, price -> [String: Int]? in\n      guard let year = Int(yearString), let mileage = Int(mileageString) else { return nil }\n      return [\n        \"year\": year,\n        \"mileage\": mileage,\n        \"price\": price,\n      ]\n    }\n  }\nlet estimates = Mapper().mapArray(JSONArray: jsonArray)\nprint(estimates)\n``\n. Propertystatusandmsgshould have initial value. Or use optional to havenil` as default.. Possibly duplicated with #668.. Just add an initializer:\n```diff\nclass Car: Mappable {\nstatic let sharedInstance = Car()\n\nvar mode: String?\n\n\ninit() {\nself.mode = nil\n\n}\nrequired init?(map: Map) { }\nfunc mapping(map: Map) {\n    mode    <- map[\"info\"][\"mode\"]\n}\n}\n``. @anddygon what does that mean?. @anddygon what do you want?. Possibly duplicated with #179 and #662. How did you setup ObjectMapper?. That's what ObjectMapper does.. @bolee I could not understand what you mean. @EvilNOP could you provide me some example usage?. Wow it looks cool!. What does 'changeable model' mean?. Please provide a json.. What was your json?.devicesofUserInfois[UserDevice]but thedevicesof JSON is a dictionary which is more similar to[String: UserDevice]`. @macecchi could you please provide us a sample json data and your expected model?. I've tried many times but this was the most simple way:\n\n\n```swift\nclass Ride: Mappable {\n  dynamic var id: Int = 0\n  dynamic var place: String!\n  dynamic var notes: String!\n  dynamic var slots: Int = 0\n  dynamic var date: Date! = Date()\nprivate var _dateString: String? {\n    didSet {\n      updateDate()\n    }\n  }\n  private var _timeString: String? {\n    didSet {\n      updateDate()\n    }\n  }\nrequired convenience init?(map: Map) {\n    self.init()\n  }\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    place <- map[\"place\"]\n    notes <- map[\"description\"]\n    _dateString <- map[\"date\"]\n    _timeString <- map[\"time\"]\n    slots <- map[\"slots\"]\n  }\nprivate func updateDate() {\n    guard let dateString = _dateString, let timeString = _timeString else { return }\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    self.date = formatter.date(from: dateString + \" \" + timeString)\n  }\n}\n``\n. No problem!. I found a better solution! The key idea is to wrapMapwith anotherMap` and map it with a property. This is how I've done:\n```swift\nstruct IndividualType: Mappable {\n  var typeID: Int!\n  var typeName: String!\ninit?(map: Map) {\n  }\nmutating func mapping(map: Map) {\n    self.typeID <- map[\"typeID\"]\n    self.typeName <- map[\"typeName\"]\n  }\n}\nclass TestModel: Mappable {\n  var individualType : IndividualType?\nrequired init?(map: Map) {\n  }\nfunc mapping(map: Map) {\n    // This is the key point\n    let individualTypeJSON: [String: Any] = [\"individualType\": map.JSON]\n    let individualTypeMap = Map(mappingType: .fromJSON, JSON: individualTypeJSON)\n    self.individualType <- individualTypeMap[\"individualType\"]\n  }\n}\nlet json: [String: Any] = [\n  \"typeID\": 1,\n  \"typeName\": \"Participant\",\n  \"activityID\": 87955\n]\nlet model = TestModel(JSON: json)\nprint(model?.individualType) // Optional(IndividualType(typeID: 1, typeName: Participant))\n``\n.[String: Answer]is supported but[String: [String: Answer]]is not. I think you have to make your ownTransformto map dictionary of dictionary.. You have to usex <- map[\"A.B\"]`. Check the document: https://github.com/Hearst-DD/ObjectMapper#easy-mapping-of-nested-objects. How about using ImmutableMappable? It raises exceptions when failed mapping.. @freak4pc \ud83d\udc4b\n\nIf you'd like to keep using <- syntax, ImmutableMappable is not for you.\nErrors can be handled as Optionals using try? so there would be just few changes.\n\nBut personally I would recommend you to try ImmutableMappable because there are some advantages. For example, it provides strict mapping validation and the mapping errors can be used as RxSwift sequence's error event.. Are you using Alamofire+ObjectMapper?. Yeah. Alamofire+ObjectMapper currently does not support ImmutableMappable. But you could easily make an extension method on Alamofire to map ImmutableMappable.. Which version are you using? This code uses NSObject instead of Realm.Object for example and works properly. What did you mean 'not mapped correctly' is?\n```swift\nimport ObjectMapper\nclass FlightStatus: NSObject, Mappable {\n  dynamic var status: String = \"U\"\n  dynamic var departureGateDelayMinutes = Int()\n  dynamic var arrivalGateDelayMinutes = Int()\n  dynamic var flightId: String = \"-\"\nrequired convenience init?(map: Map) {\n    self.init()\n  }\nfunc mapping(map: Map) {\n    status <- map[\"status\"]\n    flightId <- map[\"flightId\"]\n    departureGateDelayMinutes <- map[\"delays.departureGateDelayMinutes\"]\n    arrivalGateDelayMinutes <- map[\"delays.arrivalGateDelayMinutes\"]\n  }\n}\nlet json: [String: Any] = [\n  \"status\": \"S\",\n  \"delays\": [\n    \"departureGateDelayMinutes\": 73,\n    \"arrivalGateDelayMinutes\": 68\n  ],\n  \"flightId\": \"841665398\",\n]\nlet status = FlightStatus(JSON: json)\nstatus?.departureGateDelayMinutes // 73\nstatus?.arrivalGateDelayMinutes   // 68\n```\n. I tested with the exactly same environment of yours and it worked properly. I used Playground to test code below:\n```swift\nimport RealmSwift\nimport ObjectMapper\nclass FlightStatus: Object, Mappable {\n  dynamic var status: String = \"U\"\n  dynamic var departureGateDelayMinutes = Int()\n  dynamic var arrivalGateDelayMinutes = Int()\n  dynamic var flightId: String = \"-\"\nrequired convenience init?(map: Map) {\n    self.init()\n  }\nfunc mapping(map: Map) {\n    status <- map[\"status\"]\n    flightId <- map[\"flightId\"]\n    departureGateDelayMinutes <- map[\"delays.departureGateDelayMinutes\"]\n    arrivalGateDelayMinutes <- map[\"delays.arrivalGateDelayMinutes\"]\n  }\n}\nlet json: [String: Any] = [\n  \"status\": \"S\",\n  \"delays\": [\n    \"departureGateDelayMinutes\": 73,\n    \"arrivalGateDelayMinutes\": 68\n  ],\n  \"flightId\": \"841665398\",\n]\nlet status = FlightStatus(JSON: json)\nstatus?.departureGateDelayMinutes // 73\nstatus?.arrivalGateDelayMinutes   // 68\n```. Thanks for reporting :). You don't have to use ArrayTransform stuff. Just do it as following:\nswift\ninit(map: Map) throws {\n  // ...\n  children = try map.value(\"children\")\n}\nPS: The reason of the build failure is because you didn't mark mapArray() with try.\n\nlet objects = try Mapper().mapArray(JSONObject: value)\n// do something\n\n. > ```\n\nCrashed by\nmapping(map: map)\n```\n\nDid you mean the mapping(map: map) in the ClientMap.init(map:)?. @endios-github What happens if you get rid or the mapping(map: map) from the initializer? I have never seen such like that. I'm not sure but I think calling mapping() in the initializer is not recommended.\n. @endios-github what happens if replacing city <- map[\"city\"] with city = \"Dummy\"? It is still crashing?. @oniikal3, thanks for reporting. I made a PR #752 to fix this issue. I would prefer you to make custom Transform to support UInt mapping at this time.. @oniikal3, Try 2.2.4 release :tada:. I have no idea why the tests are failing. Tests are succeeded in my machine \ud83e\udd14\ud83e\udd14\ud83e\udd14. It fails on Xcode 8.0 environment (https://travis-ci.org/Hearst-DD/ObjectMapper/builds/202295374) but passes in Xcode 8.2 environment (https://travis-ci.org/Hearst-DD/ObjectMapper/builds/204318738) :(. @tristanhimmelman No problem! It's ready to go :)\nNote: Commit 5af3c13 is from #760, which is now merged into master.. Try: \nswift\nclass File {\n  dynamic var name: String = \"\" {\n    didSet {\n      self.path = self.name + self.folder\n    }\n  }\n  dynamic var folder: String = \"\" {\n    didSet {\n      self.path = self.name + self.folder\n    }\n  }\n  dynamic var path: String = \"\"\n}. @geertbeskers What do you mean?. @tristanhimmelman this is an issue template \ud83e\udd23. @afonsograca, thanks for your work, but please don't change other things. Could you please update your PR to not include unrelated changes?. @afonsograca you can check unrelated diffs here: https://github.com/Hearst-DD/ObjectMapper/pull/759/files. @tristanhimmelman Fixed it :tada: I'll update #752 when this PR is merged into master :). @yuriy-tolstoguzov Thanks for correctly using our issue template!\nTry:\n```diff\nstruct UsefulClass: Mappable {\n  var usefulField1: String!\n  var usefulField2: String!\ninit(_ map: Map) {\n-    usefulField1 <- map[\"containers.container.usefulField1\"]\n-    usefulField2 <- map[\"containers.container.usefulField2\"]\n+    usefulField1 <- map[\"container.usefulField1\"]\n+    usefulField2 <- map[\"container.usefulField2\"]\n  }\n}\nstruct Response: Mappable {\n  var usefulObjects: [UsefulClass]!\n  var errorCode: Int\ninit(_ map: Map) {\n-    usefulObjects <- map[\"payload\"]\n+    usefulObjects <- map[\"payload.containers\"]\n    errorCode <- map[\"errorCode\"]\n  }\n}\n``. @yuriy-tolstoguzov, So you mean that you'd like to makeUsefulClass` respond to both:\nswift\nusefulField1 <- map[\"usefulField1\"]\nusefulField2 <- map[\"usefulField2\"]\nand\nswift\nusefulField1 <- map[\"container.usefulField1\"]\nusefulField2 <- map[\"container.usefulField2\"]\n?. Not sure but try something like:\nswift\nif map[\"usefulField1\"].currentValue != nil {\n  usefulField1 <- map[\"usefulField1\"]\n} else if map[\"container.usefulField1\"].currentValue != nil {\n  usefulField1 <- map[\"container.usefulField1\"]\n}. Oh god, this is my fault. I'll check this right now. I apologize for my mistake!. #766 is the patch for this issue. 1. Can you please share the example usage of this feature to us?\n2. Why not just implement on mapping()?. @adasoft-dev, you're doing in the opposite way. TransformOf is defined as TransformOf<Object, JSON> which corresponds to String and Int.\nswift\nlet transform = TransformOf<String, Int>(\n  fromJSON: { (value: Int?) -> String? in\n    if let value = value {\n      return String(value)\n    } else {\n      return nil\n    }\n  },\n  toJSON: { (value: String?) -> Int? in\n    if let value = value {\n      return Int(value)\n    } else {\n      return nil\n    }\n  }\n). Try:\nswift\nlet persons = Mapper<Person>().mapArray(JSONObject: JSONDic[\"data\"])\n. You can use mapping on existing object.\nswift\nvar person = Person(JSON: jsonA)\nperson?.mapping(map: Map(mappingType: .fromJSON, JSON: jsonB))\nprint(person). Possibly duplicated with #179, #662 and #685. ObjectMapper has no plans to support mapping via reflection.. I saw @tristanhimmelman recently uses 4-spaces over tabs on AlamofireObjectMapper. Should we re-indent whole source code someday? \ud83e\udd37\u200d\u2642\ufe0f. You should use ImmutableMappable for generic constraint to use throwable map() function.\ndiff\n- func search<Searchable: BaseMappable>(...) {\n+ func search<Searchable: ImmutableMappable>(...) {\n  ...\n  let context = MyContext()\n  let result = Mapper<Searchable>(context: context).map(JSON: hit)\n}. \ud83d\ude02\n\n. Can you provide some details? I don't think that is different from:\n```swift\nstruct Keys {\n  static let key1 = \"key1\"\n  static let key2 = \"key2\"\n}\nlet value: String = try map.value(Keys.key1)\nlet value: Int = try map.value(Keys.key2)\n```\n. This is not an ObjectMapper's responsibility. You don't need ObjectMapper for that.\nswift\nlet dates = yourJSONArray.flatMap { string -> Date? in\n  let formatter = DateFormatter()\n  formatter.dateFormat = ...\n  return formatter.date(from: string)\n}\n. You may want to make custom Transform. Check Custom Transforms section in the README.. Your code works properly without using MiniLock. I think there's something wrong with your MiniLock.\n```swift\nlet jsonString = \"{\\\"name\\\": \\\"John Smith\\\", \\\"id\\\": \\\"base58string\\\"}\"\nstruct Friend: ImmutableMappable {\n  let name: String?\n  let id: String\ninit(name: String?, id: String) {\n    self.name = name\n    self.id = id\n  }\ninit(map: Map) throws {\n    name = try? map.value(\"name\")\n// decode id from the base58 String\nlet b58Id: String = try map.value(\"id\")\nself.id = try map.value(\"id\")\n\n}\nfunc mapping(map: Map) {\n    name            >>> map[\"name\"]\n    id              >>> map[\"id\"]\n  }\n}\nlet friendsList = try Array(JSONString: jsonString)\nprint(friendsList)\n``\n. I think it's not an ObjectMapper's responsibility \ud83e\udd14. Use Transform to convert Int to String. https://github.com/Hearst-DD/ObjectMapper#custom-transforms. I think it's not a general purpose. It would be better to create a custom transform in your project.. Please share yourstringResponse`.. You should create your custom transform. https://github.com/Hearst-DD/ObjectMapper#custom-transforms. Possibly duplicated with #179, #662, #685 and #779. ObjectMapper has no plan to support mapping via reflection.. ObjectMapper still provides more detailed functionality.. How did you install ObjectMapper?. You should use transform to map URLs:\ndiff\n- url <- map[\"url\"]\n+ url <- (map[\"url\"], URLTransform())\n. You should create a temporary dictionary wrapping those array:\nlet json: [String: Any] = [\n  \"data\": yourArray\n]\nThen the json will be looked like:\njson\n{\n  \"data\": [\n    {\"a\": 123, \"b\": 123, \"c\": 123, \"d\": 123},\n    {\"a\": 123, \"b\": 123, \"c\": 123, \"d\": 123},\n    {\"a\": 123, \"b\": 123, \"c\": 123, \"d\": 123}\n  ]\n}\nYou can now map this json dictionary to your model.. ObjectMapper 1.5.0 doesn't support Swift 3. Use at least 2.0.0 for Swift 3. (https://github.com/Hearst-DD/ObjectMapper/releases/tag/2.0.0). It doesn't matter. The only thing you have to do is to make Object conform to ImmutableMappable.\n```swift\nstruct Object: ImmutableMappable {\n  var mutableInt: Int?\n  let immutableInt: Int\ninit(map: Map) throws {\n    mutableInt = try? map.value(\"mutableInt\")\n    immutableInt = try map.value(\"immutableInt\")\n  }\n}\n``. I think we can ship ImmutableMappable as an official release. I've been using it about 9 months in my company project and personal projects and there's no problem. How do you think @tristanhimmelman?. I think we need additional tests for:\n- 3, 4, 8-length hex strings such as#FF0,#FF00,#ABCDEF00- lower-cased hex strings\n. Could you please get rid of this line?\n. I think it should beHexColorTransformrather thanHEXColorTransform`.\nAccording to Swift API Design Guideline, acronyms which doesn't commonly appear as all upper case should be treated as camel case.\n\nAcronyms and initialisms that commonly appear as all upper case in American English should be uniformly up- or down-cased according to case conventions. Other acronyms should be treated as ordinary words.\n\n'Hex' doesn't commonly appear as all upper case because Wikipedia uses Hex as a title of document. How do you think of it?\n. How about creating methods in the same scope with https://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Core/ImmutableMappble.swift#L144-L158? You can easily add Mapper methods for ImmutableMappables. For example:\nswift\npublic func mapArray(JSONArray: [[String: Any]]) throws -> [N]? {\n  return try JSONArray.flatMap(mapOrFail)\n}\nThe reason I defined mapping methods as extensions(#592) is to separate ImmutableMappable implementations from existing code.\n. Hmmm. @nmccann @tristanhimmelman let's think about this:\n1. mapArray() should throw error when there's invalid JSON model\nswift\n   let array = [validJSON_1, invalidJSON_2, validJSON_3]\n   try mapArray(JSONArray: array) // should fail?\nWith this approach, mapArray() can only handle ImmutableMappables.\n2. mapArray() should ignore invalid JSON model\nswift\n   let array = [validJSON_1, invalidJSON_2, validJSON_3]\n   mapArray(JSONArray: array) // should return [model1, model3]?\nWith this approach, mapArray() can handle any BaseMappables.\nI'm not sure which is better.\n. How about using Swift Package Manager instead of SwiftPM? There's no usage of PM in the official document.\n. Why did you use ?? !context.isDeveloper here? If it was just for making Bool? to Bool, wouldn't it better using ?? false or person!.isDeveloper? (we have ensured that the person is not nil from the test above). That makes sense. Cool!. ",
    "Busta117": "i already sent a pull request with that \nhttps://github.com/Hearst-DD/ObjectMapper/pull/159\n. fixed with the changes suggested by @ikesyo \n. in my particular case i have to check different formats of the ISO8601 standard, so, i created a subclass of a DateFormatterTransform and in the method transformFromJSON i check if it is possible convert the string into one of those ISO formats and then return the Date, so, in that subclass i need to access to the dateFormatter to create the Date\n. ",
    "aviz": "Cool, it's working with this transform.\nIs it going to be permanently fixed in the future ?\n. ",
    "jaischeema": "Thank you, that exactly what I was looking for :smile: \n. ",
    "Urkman": "Isn't there a way to optimize this?\nSo if we have the correct classname in \"type\".\nIs there no way to get this line to work with the \"Classname String\"\nlet mappedItem = Mapper<\"type\">().map(item)\n. Would be great, if that could be merged soon...\n. ",
    "cezheng": "You can, by doing this with reflection but that is the old objc way of doing the job and it relies on runtime information which is slow compared to static compile time information and not what apple is recommending at the moment. You can do it by either implementing an @objc class or have a look into the documentation of 'MirrorType'. If you dig into the latter you will see there will be a whole lot of unnecessary string manipulation at runtime\n. Glad I could help:) I really like this library, saved me a lot of time.\nGuess I'm gonna close this PR then\n. The conflicting operator overload might be in one of the other Pods you use. Try checking other pods in your project\n. Thank you, I overlooked the mapDictionary method\n. I don't think objectmapper supports realm's List type. I am using objectmapper on a realm project, too. My workaround is to map the json to an ignored array property(by realm), then write a loop to add all the elements in the array to the realm list\n. If you just don't want the properties to be public mutable, I guess you can make it private(set) like this\npublic private(set) var propertyName: TypeName\n. This is basic swift syntax. Your json variable has type 'NSString?', and it only matches the function parameter 'AnyObject?', the JSONString parameter has type 'NSString' which is not an optional so you will need to unwrap it\n. I guess so. Think about what kinda object is this Mapper supposed to produce, you can't instantiate a protocol that has no mapping rules.\n. If you already have a bunch of instantiated DummyProtocol objects, and would like to do something related to json encode, I guess you can use a generic function\nfunc doSomethingRelatedToToJSON<T: DummyProtocol>(obj: T) {\n    let mapper = Mapper<T>()\n    //...\n}\nBut if you want the other way around, i.e. doing JSON decode, mapping a JSON string/dictionary to a object that confirms to DummyProtocol, that is not possible cuz you don't know the mapping rules.\n. I guess you just need to use NSJSONSerialization to do the job. Using ObjectMapper is just overkill\n. I see. Then I guess the only way to work around this is to wrap the \ntype \u2192 array-type | string-type | object-type\ninto a custom class that implements Mappable\n. Would you please paste the error messages after you switched to swift-2.0 branch?\n. @cfraz89 These errors were fixed in https://github.com/Hearst-DD/ObjectMapper/pull/170, so I guess your branch is not up to date. Try running pod update\n. Auto property name matching requires reflection which I guess is not recommended in swift. ObjectMapper is a strongly typed mapper. If you're trying do this you'd better use a objc framework with swift compatibility\n. There are 2 mistakes in you code.\n1. Mapper is a class, and map() is not a class method. So you need to create a Mapper instance\n2. Mapper is a Generic class. Specify the Object type(that conforms to Mappable protocol) you would like to map to, like this:\nlet user = Mapper<User>().map(data)\nThe README of the repo includes examples like this, so refer to the README before you create any issues\n. Because you are mapping \"response\" to response, T has to conform to mappable.\npublic class GenericResponse<T: Mappable> : Mappable{\nwill do the job\n. xcode 7 is in beta so the swift 2 version is still in theswift-2.0 branch.\n. ",
    "muescha": "FYI: https://github.com/Hearst-DD/ObjectMapper#staticmappable-protocol would also to the job. ",
    "marcioadr88": "Sorry the problem was not with your lib\n. ",
    "ogrenich": "@marcioadr88 What was a problem? Have the same issue. I've found a solution, but I expected it should work from the box.\nlatitud <- (map[\"latitud\"], TransformOf<Double, String>(fromJSON: { Double($0!) }, toJSON: { $0.map { String($0) } })). ",
    "crayment": "Same issue - it creates the framework but Xcode 7 fails to build with ld: framework not found ObjectMapper.\n. ",
    "nrbrook": "Should I look into fixing these issues or is @tristanhimmelman 's branch the official one? I need watchOS support, which is just a case of duplicating the iOS targets and scheme really.\n. I agree, intuitively I think people expect variables to be ready in init but with the new protocol format they are not ready until after mapping(). I think extra documentation would be useful and a transition guide when changes like this are made is essential.\n. And what happened to the validation of the object? I thought ObjectMapper should return a nil object if the mapping cannot map an element to an implicitly unwrapped optional?\n. ",
    "xajler": "Thank you @ikesyo , it breaks one with Message of String since it is not Mappable, but it works with all T that are Mappable. Too bad it can do for both, but I'm glad it works with T: Mappable.\n. @gkhnaydn It was a time ago, but at the end I've created three different Messages:\n```swift\n// For complex types, in my case  structs.\n// Sturcts used as T must inherit Mappable. \nstruct DataMessage : Mappable { }\n// For primitive types as String, Int,...\nstruct SimpleMessage : Mappable { }\n// For void or empty ones\nsturct EmptyMessage : Mappable { }\n``DataMessageandSimpleMessagewere having identical content inside of struct,  only difference wasvs.\nIt was a annoyance to have 3 of them nearly identical with content, but it worked for me, without any problems. \nIn most languages you could have this in same named class with inheritance, not sure is this fixed in later releases and is this a drawback ofObjectMapperorswift`.\nHope it helps.... ",
    "gkhnaydn": "@xajler did you solve this issue? Especially I mean that let \"mapper2 = Mapper>()\". Nowadays I try to use similar form of Message, but primitive types usage is not supported by ObjectMapper as well.. ",
    "aixinyunchou": "i hit the same problem.\n. ",
    "wenxin3262": "I don't have SQLite, but still got this error, I am sure I didn't define this operator myself somewhere. Any  thoughts?\n. Thanks you cezheng! Although I fixed it by just import ObjectMapper at top of swift class file. I don't know why, but it did the job...\n. ",
    "jpallenk": "I'm using Cocoapods , but I think the version was even wrong .\nI downloaded again and it worked.\nthank you very much\nJo\u00e3o Paulo\n. ",
    "robertjpayne": "yea I'll concur would be great if Mappable didn't require an initialiser for CoreData/Realm support.\n. ",
    "hwaxxer": ":+1: \n. ",
    "schickling": "+1\n. @staticdreams could you provide your implementation of TransformOf for the Realm.List type?\n. Thanks!\n@tristanhimmelman would this be interesting to add as an \"official\" Transform since Realm is picking up more and more traction? \n. Any ideas for a more general implementation? \n. +1\n. ",
    "mladen107": "+1\n. I forked branch and changed protocol Mappable. All tests are passing. Please check and give me your thoughts https://github.com/mladen107/ObjectMapper/commit/8ff25cfc87309215822639e2111239c8b2235a77\n. Well thank you very much for this great library, but still I would like to decide how to create newInstance based on JSON data or Map.\nFor example I want to implement some kind of cache layer that will reuse objects that represent the same entity (I think Realm does this already). \nAlso, for example we can have {\"fruits\": [{\"type\":\"apple\"...},{\"type\":\"lemon\"...}...]} and then we should be able to decide to create different Swift type (Abstract Factory Method Pattern).\n. After checking the changes you made, leaving only argument (map: Map) should be enough for my cases without any other modifications.\nI agree about boilerplate. Anyways I can always fork for my usage :+1: .\n. Check documentation again protocol Mappable has been changed\npublic protocol Mappable {\n    static func newInstance() -> Mappable\n    mutating func mapping(map: Map)\n}\n. Check this issue https://github.com/Hearst-DD/ObjectMapper/issues/141\n. @bennichols \nUse class method instead of static and it will work! Class methods match static methods from protocols too.\nhttp://stackoverflow.com/questions/29636633/static-vs-class-functions-variables-in-swift-classes\n. I agree that init? doesn't put a lot of freedom during the construction of objects. For our project. I'll recreate fork that uses newInstance. Based on JSON sometimes I have to create subtype, and sometimes I need to use existing object from cache. I don't see easy way to achieve this with init. \n. ",
    "alexbredy": "+1\n. +1. ",
    "u10int": "@engmohamedsalah Refer to this comment and code which works well for me: https://github.com/Hearst-DD/ObjectMapper/issues/68#issuecomment-105831195\n. ",
    "staticdreams": "Finally I went with TransformOf to make this work. Thanks for your help\n. @schickling , sure! It looks like this. \nlet transform = TransformOf<List<Connection>, [AnyObject]>(fromJSON: { (value: [AnyObject]?) -> List<Connection>? in\n    let connections = List<Connection>()\n    if let line:[AnyObject] = value {\n        for item in line {\n            var connection = Connection()\n            if let destination = item.valueForKey(\"destinationName\") as? String, let destinationCode = item.valueForKey(\"destinationCode\") as? String {\n                connection.destinationName = destination\n                connection.destinationCode = destinationCode\n                if let line = item.valueForKey(\"lineCode\") as? String {\n                    connection.lineCode = line\n                }\n                if let line = item.valueForKey(\"lineCode\") as? Int {\n                    connection.lineCode = String(line)\n                }\n            }\n            connections.append(connection)\n        }\n        return connections\n    }\n    return nil\n    }, toJSON: { (value: List<Connection>?) -> [AnyObject]? in\n        return nil\n})\n. @jeffsorr could you share your Swift 3 version?\n. @carobeta doesn't look like it. There are some major breaking changes and it wont compile with the new beta :(\n. ",
    "Jerrot": "I might be late to the party, but I solved this by creating a generic Transform class for ObjectMapper, find the code here: https://gist.github.com/Jerrot/fe233a94c5427a4ec29b\nThis avoids the need of ignoring properties, just transform them directly like this:\nswift\nproducts <- (map[\"products\"], ArrayTransform<ProductModel>())\n. ",
    "AndrewBarba": "@jpsim @Jerrot The problem I ran into last night is that Realm cannot detect when a List property has been set. This is why they say in their docs to always mark them as let and use the append function which calls down to the lists underlying realm. In the transform example, you are creating a new List which does NOT have a Realm associated with it and therefore those objects will not actually be saved correctly. I struggled with this for hours last night and finally got all my unit tests to pass after doing something like:\n```\n// Lists\npublic var items: List = List() {\n    willSet(newValue) { items.removeAll() }\n    didSet { items.forEach(oldValue.append) }\n}\npublic var fees: List = List() {\n    willSet(newValue) { fees.removeAll() }\n    didSet { fees.forEach(oldValue.append) }\n}\npublic var users: List = List() {\n    willSet(newValue) { users.removeAll() }\n    didSet { users.forEach(oldValue.append) }\n}\noverride public func mapping(map: Map) {\n    super.mapping(map)\nitems <- (map[\"items\"], ListTransform<BookingItem>())\nfees <- (map[\"fees\"], ListTransform<BookingFee>())\nusers <- (map[\"users\"], ListTransform<BookingUser>())\n\n}\n```\nThis is obviously not ideal (but believe it or not it actually works)... can anyone think of a better way of dealing with this?\n. Okay I slightly lied, for some reason if map[\"xyz\"] is nil, it resets the property to an empty list. No clue how it's doing that... Only seems to happen lists\n. Okay I figured it out... ObjectMapper will set the property to itself. So instead I made an extension:\n```\n// MARK: - List\nextension List {\npublic func replace(list: List, delete: Bool = false) {\n    if list === self { return }\n    removeAll()\n    appendContentsOf(list)\n}\n\n}\n```\nAnd then I can just use:\npublic var images: List<Image> = List() {\n    willSet { images.replace(newValue) }\n}\n. For reference this is the ListTransform struct:\n```\npublic struct ListTransform: TransformType {\npublic func transformFromJSON(value: AnyObject?) -> List<T>? {\n    switch value {\n    case let values as [AnyObject]:\n        let list = List<T>()\n        for value in values {\n            if let object = ObjectTransform<T>().transformFromJSON(value) {\n                list.append(object)\n            }\n        }\n        return list\n    default:\n        return nil\n    }\n}\n\npublic func transformToJSON(value: List<T>?) -> AnyObject? {\n    if let value = value {\n        return value.map { Mapper<T>().toJSON($0) }\n    }\n    return nil\n}\n\n}\n``\n. I'm guessing this has something to do with usinginout`. Trying this function:\npublic func eval<T, Transform: TransformType where Transform.Object == T>(map: Map, _ transform: Transform, block: (T) -> ()) {\n    if let value = transform.transformFromJSON(map.value()) { block(value) }\n}\nAnd then:\neval(map[\"tags\"], ListTransform<Tag>()) { self.tags = $0  }\nWorks as expected.\n. Figured it out. See my comment here: https://github.com/Hearst-DD/ObjectMapper/issues/143\n. ",
    "sudeep23": "Can Anyone Please help me to Map and Realm with following Classes. Main problem is I need List of Int but Realm doesn't support List of Int type so kind of stuck....\n```\n  class OfficeInformationData: Object, Mappable{\n      dynamic var id: String?\n      dynamic var officeName: String?\n      dynamic var titlePost: String?\n      dynamic var location: LocationData?\n      dynamic var jobType = 0\n      var officeTiming: OfficeTimingData?\n      dynamic var timestamp: Int = 0\n      dynamic var officeiLoop:Bool = false\n  required convenience init?(_ map: Map) {\n      self.init()\n  }\n\n  func mapping(map: Map) {\n      id <- map[\"id\"]\n      officeName <- map[\"officeName\"]\n      titlePost <- map[\"titlePost\"]\n      location <- map[\"location\"]\n      jobType <- map[\"jobType\"]\n      officeTiming <- map[\"officeTimings\"]\n      timestamp <- map[\"timestamp\"]\n      officeiLoop <- map[\"officeiLoop\"]\n\n\n  }\n\n}\nclass OfficeTimingData: Mappable{\n      var fromHour:String?\n      var toHour:String?\n      var days: [Int]?\n  required init?(_ map: Map) {\n\n  }\n\n  func mapping(map: Map) {\n      fromHour <- map[\"fromHour\"]\n      toHour <- map[\"toHour\"]\n      days <- map[\"days\"]\n  }\n\n}\n```\n. ",
    "danilValeev": "I've created an operator which properly fixes this issue. Please, check https://gist.github.com/danilValeev/ef29630b61eed510ca135034c444a98a\nUPDATE (thanks @gregkerzhner for the note):\nWith this operator you don't need any additional code or transforms.\nlist <- map[\"name\"]\nHere is Swift 3 version. To see the version for Swift 2 and an example of usage please check the gist.\n```swift\nimport Foundation\nimport RealmSwift\nimport ObjectMapper\ninfix operator <-\n/// Object of Realm's List type\npublic func <- (left: List, right: Map) {\n    var array: [T]?\nif right.mappingType == .toJSON {\n    array = Array(left)\n}\n\narray <- right\n\nif right.mappingType == .fromJSON {\n    if let theArray = array {\n        left.append(objectsIn: theArray)\n    }\n}\n\n}\n``\n. I've created an operator which properly fixes this issue. Please, check https://gist.github.com/danilValeev/ef29630b61eed510ca135034c444a98a\nWith this operator you don't need any additional code or transforms.list <- map[\"name\"]`\nHere is Swift 3 version. To see the version for Swift 2 and an example of usage please check the gist.\n```swift\nimport Foundation\nimport RealmSwift\nimport ObjectMapper\ninfix operator <-\n/// Object of Realm's List type\npublic func <- (left: List, right: Map) {\n    var array: [T]?\nif right.mappingType == .toJSON {\n    array = Array(left)\n}\n\narray <- right\n\nif right.mappingType == .fromJSON {\n    if let theArray = array {\n        left.append(objectsIn: theArray)\n    }\n}\n\n}\n```\n. ",
    "gregkerzhner": "@danilValeev thanks for this.  Just to clarify, because I wasted a bit of time on this, when using the operator above, you do not also use a list transform.   Here is the full usage example \n```\nimport Foundation\nimport RealmSwift\nimport ObjectMapper\ninfix operator <- {}\n/// Object of Realm's List type\npublic func <- (left: List, right: Map) {\n    var array: [T]?\nif right.mappingType == .ToJSON {\n    array = Array(left)\n}\n\narray <- right\n\nif right.mappingType == .FromJSON {\n    if let theArray = array {\n        left.appendContentsOf(theArray)\n    }\n}\n\n}\nclass MinionArmy: Object, Mappable {\n    //make sure the list is an immutable let constant per new Realm guidelines\n    let minions = List()\nfunc mapping(map: Map) {\n    //no transformation here, since the custom operator above takes care of the transforming to list \n    minions <- map[\"minions\"]\n}\n\n}\n```\n. ",
    "jeffsorr": "@gregkerzhner thanks for the example - I used a combination of this and @danilValeev's operator to make this work in Swift 3\n. Here's the pattern I use in Swift 3:\n```\nimport Foundation\nimport RealmSwift\nimport ObjectMapper\n/// Maps object of Realm's List type\nprivate func <- (left: List, right: Map)\n{\n    var array: [T]?\nif right.mappingType == .toJSON\n{\n    array = Array(left)\n}\n\narray <- right\n\nif right.mappingType == .fromJSON\n{\n    if let theArray = array\n    {\n        left.append(objectsIn: theArray)\n    }\n}\n\n}\nclass MinionArmy: Object, Mappable\n{\n    //make sure the list is an immutable let constant per new Realm guidelines\n    let minions = List()\nrequired convenience init?(map: Map) //required by Mappable protocol\n{\n    // This function can be used to validate JSON prior to mapping. Return nil to cancel mapping\n    self.init()\n}\n\nfunc mapping(map: Map) //mapping of JSON values to object variables\n{\n    //no transformation here, since the custom operator above takes care of the transforming to list\n    minions <- map[\"minions\"]\n}\n\n}\n```\n. ",
    "kenji21": "Mappable can be replaced by BaseMappable (to make it also works with StaticMappable)\n. ",
    "kubatruhlar": "@jeffsorr Maybe +- operator would be better since you are appending not assigning.. Thank you @tristanhimmelman for your response, consider this:\nclass Foo {\n}\nextension Foo: StaticMappable {\n}\nFoo(JSONString: \"\") produces Argument passed to call that takes no arguments. Moving StaticMappable behind the class will fix this, but that is the point of StaticMappable (to be able to implement ObjectMapper in an extension). Could we re-open this issue, maybe I'm missing something.. For now, you can select Swift 3.2 under Pods -> Targets -> ObjectMapper -> Swift language version option. Or use swift-4 branch. ",
    "NikKovIos": "I've created the pod, maybe it would help https://github.com/NikKovIos/ObjectMapper-RealmSwift. Found this https://gist.github.com/danilValeev/ef29630b61eed510ca135034c444a98a\nIt works, but i think it could be something better with CustomTransform. Like next:\nfunc mapping(map: Map) {\n    id                <- (map[\"id\"], CustomTransform<Int>())\n}\n```\nstruct CustomTransform: TransformType {\npublic typealias Object = RealmOptional<T>\npublic typealias JSON = Array<Any>\n\npublic func transformFromJSON(_ value: Any?) -> Object? {\n    return Object()\n}\n\npublic func transformToJSON(_ value: Object?) -> JSON? {\n    return Array()\n}\n\n}\n```\nBut i can't figure out what is a value in the transformFromJSON method to properly wrap it.. I've created the pod, maybe it would help https://github.com/NikKovIos/ObjectMapper-RealmSwift. ",
    "danleechina": "In Reaml 3.0 version in Swift, it seems there's no need for this extension. Just change the list from let to var. ",
    "nickygerritsen": "This would be really useful for me, as I have an API that can return \"just a string\" etc.\nI could create a PR if that would help?\n. To add to this: I think it would also make sense to let [Mappable] conform to Mappable. I now have to add an extra function just to be able to map an array of Mappable objects.\nI think for this, and also for letter String, etc. conform to Mappable we need to modify the Map structure, as it now always assumes a [String: AnyObject] structure, which is not the case for both of these ideas.\n. ",
    "hjhcn": "I'm just looking for the usage like Mapper<String>, and linked to this site from search engine. Anybody know how to implement it?\n. @tristanhimmelman have you added this functionality already? if so , how to use?  Thank you!\n. ",
    "jonasman": "NSDecimalNumber must be taken in consideration. There is no replacement for this type in Swift. This is the only type that can be used to represent money. Double or float is not an alternative.\n. That sounds good then. \n. One way i thought is to check for the valid data in the init. but that makes no sense?\n. i think the problem is that TransformOf<ObjectType, JSONType> is changing the generic types to optionals and that makes the problem of validation! \nThe protocol TransformType forces the use of optionals. i guess this shouldn't be forced, but instead be taken from the generic types.\n. But why converting the generics to optionals?\n. btw where did you get that badge from?\n. to support SPM we need to:\n- [ ] Change folder structure and add all files under Sources/\n- [ ] Create Package.swift describing the module\n. one of my libs supports cocoapods and SPM: https://github.com/jonasman/MulticastDelegate\nThe sources folder needs to contain all the files, unless you want to make many modules.\nThe cocoapods just points there\nmore complex example: https://github.com/jonasman/TeslaSwift branch: swift-3.0 (this one doesn't work as 1 dependency is not SPM ready)\n. Im also planning to replace ObjectMapper in all my projects (even professional ones) with Swift4's Codable. . I tried to convert from ObjectMapper to Codable and i must it is such a pain... OM is superior. . ",
    "rebe1one": "@jonasman While I agree with you, there is an included NSDecimalNumberTransform in ObjectMapper, so this is a minor inconvenience.\n. ",
    "angelolloqui": "This would be a nice addition! +1\n. ",
    "wieseljonas": "Great Library! Any workaround for this atm?\n. I did it like this:\n```\ndynamic var uniqueID = \"\"\ndynamic var id = \"\"\noverride static func primaryKey() -> String? {\nreturn \"uniqueID\"\n\n}\nfunc mapping(map: Map) {\n    if uniqueID == \"\" {\n        uniqueID <- map[\"_id.id\"]\n    }\n    id              <- map[\"_id.id\"]\n}\n``\n. Thanks works like a charm!\n. I'm experiencing something similar I think theArrayTransform` is taking up a lot of time.\n. So basically you have a transform for each model type? Thanks for the feedback\n. Hi sorry for the delay here is the array mapper I use.\n```\nclass ArrayTransform : TransformType {\n    typealias Object = List\n    typealias JSON = Array\nfunc transformFromJSON(value: AnyObject?) -> List<T>? {\n    let result = List<T>()\n    if let tempArr = value as! Array<AnyObject>? {\n        for entry in tempArr {\n            let mapper = Mapper<T>()\n            if let model = mapper.map(entry) {\n                result.append(model)\n            }\n        }\n    }\n    return result\n}\n\nfunc transformToJSON(value: List<T>?) -> Array<AnyObject>? {\n    if (value?.count > 0)\n    {\n        var result = Array<AnyObject>()\n        for entry in value! {\n            result.append(Mapper().toJSON(entry))\n        }\n        return result\n    }\n    return nil\n}\n\n}\n```\n. @tristanhimmelman gave it a few tries. Didn't seem to improve much. I will investigate\n. ",
    "adipascu": "Why was this closed ? I am still having issues with simple dates like 2015-10-24T06:30:00\n. ",
    "wcharysz": "For iOS 10\n`\nclass NativeISO8601DateTransform: TransformType {\npublic typealias Object = Date\npublic typealias JSON = String\n\npublic let dateFormatter: ISO8601DateFormatter\n\npublic init() {\n    self.dateFormatter = ISO8601DateFormatter()\n}\n\npublic init(dateFormatter: ISO8601DateFormatter) {\n    self.dateFormatter = dateFormatter\n}\n\nopen func transformFromJSON(_ value: Any?) -> Date? {\n    if let dateString = value as? String {\n        //remove milliseconds\n        let range = dateString.startIndex..<dateString.endIndex\n        let trimmedString = dateString.replacingOccurrences(of: \"\\\\.\\\\d+\", with: \"\", options: .regularExpression, range: range)\n\n        return dateFormatter.date(from: trimmedString)\n    }\n\n    return nil\n}\n\nopen func transformToJSON(_ value: Date?) -> String? {\n    if let date = value {\n        return dateFormatter.string(from: date)\n    }\n\n    return nil\n}\n\n}\n`. ",
    "Torsph": "Fixed in https://github.com/Hearst-DD/ObjectMapper/pull/151\n. Thanks for merging. Happy to help :)\n. @tristanhimmelman thanks :) Could you possibly merge it into the swift2.0 branch? Or will you merge swift2.0 into master soon? :)\n. Ahh my bad. :)\n. ",
    "jurvis": "using this fix temporarily until the PR is merged. Thanks @Torsph!\n. ",
    "t-unit": "Have a look at my fork. It adds exactly what you're looking for to ObjectMapper. \nHaven't been able to fully test it, but I hope to find time do to it soon and create a pull request.\n. cool! (sorry for not finding time to actually creating a pull request on my own)\n. ",
    "Trevor-L": "@tomco Thanks for the heads up.  Your fork works.\n. ",
    "pignataa": "@tomco I got your fork but I had errors on the Mapper.swift file. Is there something else I need to add or is this maybe a Podfile issue?\n. ",
    "ninjazoete": "@tomco what is the status on this? :) I have exact same situation and wondering what to do\n. ",
    "GRGBISHOW": "I got the latest one 1.3.0 not working.\n. My bad, I didnt realized the DataType.\n. ",
    "damienrambout": "I dont know what are the plans about NSCoding in swift, but it's only going to work with NSObject subclasses. Which automatically excludes Swift struct, enum and other value types.\nHowever, ObjectMapper lets you easily serialize your Mappable objects or values into a JSON representation. That might be a good start to persist them into NSData using NSJSONSerialization afterwards.\n. If this is for pure caching, this could be a good solution (even though Haneke was mainly created for image caching at first). If you want to persist your data, then don't use a cache-based solution.\nNote: I have to warn you that I used Haneke (Objective-C version) in one of my apps and it was a source of crash. I heard things about the Swift version as well... But you should definitely try it yourself ;)\n. @tristanhimmelman How is it possible to create a swift type based on a json value inside the json payload?\nLet me clarify. Let's say we receive a json array from an API, this array is composed of \"Media\" objects that can be a movie, a series or an episode. The type will be defined thanks to a type value set to movie / series / episode. \nWith the static function version of Mappable, it was possible to make a type Media mappable and check the type value at runtime to return a Movie / Series / Episode based on it.\n`` swift\nextension Media: Mappable {\n    static func newInstance(map: Map) -> Media? {\n        // Checktypeand returnMovieorSeriesorEpisode`.\n    }\n}\nstruct Movie: Media { ... }\nstruct Series: Media { ... }\nstruct Episode: Media { ... }\n```\nWith the init?(map:) version, I don't see a way to achieve something like that. I will have to stick to a Media type and its real type will be based on an enum type property.\n. About this func newInstance(map: Map) -> Mappable? function signature. Isn't it dangerous to simply return a Mappable? It does not ensure it will be the same type of the called class (e.g. a subclass of Vehicle). Any kind of object that conforms to Mappable and is not a Vehicle could be returned. In such a situation, mapping a [Vehicle] variable would probably produce a runtime exception since an non-vehicle object is being inserted into a [Vehicle] type.\nIt does not seem safe from a Swift point of view.\nThat being said, I don't see another way to achieve a class cluster, so it might be worth the risk \ud83d\ude0a.\n. ",
    "stenlee": "Hi @tristanhimmelman  ... please consider to make Mapper().parseJSONDictionary and Map constructor PUBLIC to enable do this\n// MARK: NSCoding\n    required convenience init?(coder decoder: NSCoder) {\n        if let jsonString:String = decoder.decodeObjectForKey(\"jsonString\") as! String? {\n            let jsonDict = Mapper().parseJSONDictionary(jsonString)\n            let map = Map(mappingType: MappingType.FromJSON, JSONDictionary: jsonDict!)\n            self.init()\n            self.mapping(map)\n        } else {\n            self.init()\n        }\n    }\nTHX!\n. ",
    "dev-xdyang": "```\nclass Topic: Mappable, NSCoding {\n    // Mappable\n    required init?(map: Map) {\n}\n\nfunc mapping(map: Map) {\n\n}\n\n// NSCoding\npublic func encode(with aCoder: NSCoder) {\n    let jsonString = self.toJSONString() ?? \"\"\n    aCoder.encode(jsonString, forKey: \"jsonString\")\n}\n\nrequired public convenience init?(coder aDecoder: NSCoder) {\n    let jsonString = aDecoder.decodeObject(forKey: \"jsonString\") as? String\n    self.init(JSONString: jsonString ?? \"\")\n}\n\n}\n```. ",
    "rickytribbia": "Here how to use ObjectMapper with NSCoding. \nWe use it with PINCache for cache\nBase class:\n```\nclass CodableObject: Mappable, NSCoding {\n  // MARK: - Properties\n  // MARK: Class\n// MARK: Public\n// MARK: Private\n  private static let nsCoderKey = \"coderKey\"\n// MARK: Lifecycle\n  override init() {}\n// MARK: NSCoding\n  required init?(coder aDecoder: NSCoder) {\n    guard let json = aDecoder.decodeObject(forKey: CodableObject.nsCoderKey) as? [String : Any] else {\n      return nil\n    }\n    super.init()\n    let map = Map(mappingType: .fromJSON, JSON: json)\n    mapping(map: map)\n  }\npublic func encode(with aCoder: NSCoder) {\n    aCoder.encode(toJSON(), forKey: CodableObject.nsCoderKey)\n  }\n// MARK: Mappable\nrequired init?(map: Map) {\n  }\npublic func mapping(map: Map) {\n  }\n}\n```\nAll children and nested classes: \n```\nclass User: CodableObject {\n// MARK: - Properties\nvar name: String?\n  var surname: String?\nvar nestedObjs: [NestedClass]?\n// MARK: Lifecycle\noverride init() {\n    super.init()\n  }\n// NSCoding\n  required init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n  }\n// Mappable\n  required init?(map: Map) {\n    super.init(map: map)\n  }\noverride func mapping(map: Map) {\n    super.mapping(map: map)\nname              <- map[\"Name\"]\nsurname         <- map[\"Surname\"]\nnestedObjs    <- map[\"Children\"]\n\n}\n}\n```\nSimply save with:\nPINCache.shared.setObjectAsync(user, forKey: \"key\", completion: { (cache, key, object) in\n  completion?()\n})\nGreat!\n. ",
    "alibasta": "Attached you can find my implementation of a custom transform:\n```\nclass URLListTransform: TransformType {\n    typealias Object = Array\n    typealias JSON = Array\ninit() {}\n\nfunc transformFromJSON(value: AnyObject?) -> Array<NSURL>? {\n    if let URLStrings = value as? [String] {\n        var listOfUrls = [NSURL]()\n        for item in URLStrings {\n            if let url = NSURL(string: item) {\n                listOfUrls.append(url)\n            }\n        }\n        return listOfUrls\n    }\n    return nil\n}\n\nfunc transformToJSON(value: [NSURL]?) -> JSON? {\n    if let urls = value {\n        var urlStrings = [String]()\n        for url in urls {\n            urlStrings.append(url.absoluteString)\n        }\n        return urlStrings\n    }\n\n    return nil\n}\n\n}\n```\n. ",
    "danyalaytekin": ":+1:\n. ",
    "IgorBelyayev": "I'm unable to successfully deserialize a Set. Has anyone verified this behavior?\n. ",
    "ivangodfather": "class Address: Equatable, Mappable {\n    var id: Int?\n    var address, addressName, phone, nonSelectableArea: String?\n    var idDeliveryArea: Int?\n```\nfunc mapping(map: Map) {\n    id <= map[\"id\"]\n    address <= map[\"address\"]\n    addressName <= map[\"addressName\"]\n    phone <= map[\"phone\"]\n    nonSelectableArea <= map[\"nonSelectableArea\"]\n    idDeliveryArea <= map[\"idDeliveryArea\"]\n}\nrequired init() { }\n```\n}\n\n. you mean like toJSONArray?\n        let addresses = Mapper().toJSONArray(CurrentCustomer.getCustomer().addresses)\n. This is what i get in the server using toJSONArray:\n[23-Jul-2015 15:26:52 Europe/Berlin] Array\n(\n    [customer] => Array\n        (\n            [0] => Array\n                (\n                    [nonSelectableArea] => Elda\n                )\n```\n        [1] => Array\n            (\n                [address] => c/ Juan Ricardo de Dios, Madrid\n            )\n    [2] => Array\n        (\n            [idDeliveryArea] => 1\n        )\n\n    [3] => Array\n        (\n            [id] => 1\n        )\n\n    [4] => Array\n        (\n            [addressName] => Mi primo Richard\n        )\n\n    [5] => Array\n        (\n            [phone] => 96543234\n        )\n\n    [6] => Array\n        (\n            [nonSelectableArea] => Petrer\n        )\n\n    [7] => Array\n        (\n            [address] => c/ Fernando Soria\n        )\n\n    [8] => Array\n        (\n            [idDeliveryArea] => 2\n        )\n\n    [9] => Array\n        (\n            [id] => 2\n        )\n\n    [10] => Array\n        (\n            [addressName] => Hermano Juan\n        )\n\n    [11] => Array\n        (\n            [phone] => 96542134\n        )\n\n)\n\n[lang] => en\n```\n)\n. Yes, they are [Address]\n    var addresses: [Address] = []\n. let address = Mapper().toJSONArray(CurrentCustomer.getCustomer().addresses)\n    let params: [String: AnyObject] = [\"lang\": getLang(), \"customer\": address]\n    request(.POST, PROFILE_URL, parameters: params, encoding: ParameterEncoding.URL).responseJSON(options: NSJSONReadingOptions.AllowFragments) { (request, response, json, error) -> Void in\n. By the way im trying to sent a \"Customer\" object, whichs contains an array of Address [Address]. So i'll not use that method, but if i send  a full customer i get the same problem with the addresses inside the customer.\n. If i set a breakpoint before sending de request, i get this:\n(lldb) po params\n[\"lang\": en, \"customer\": (\n        {\n        address = \"c/ Juan Ricardo de Dios, Madrid\";\n        addressName = \"Mi primo Richard\";\n        id = 1;\n        idDeliveryArea = 1;\n        nonSelectableArea = Elda;\n        phone = 96543234;\n    },\n        {\n        address = \"c/ Fernando Soria\";\n        addressName = \"Hermano Juan\";\n        id = 2;\n        idDeliveryArea = 2;\n        nonSelectableArea = Petrer;\n        phone = 96542134;\n    }\n)]\n(lldb)\n. @ikesyo so the problem is how i'm seding the params with alamofire?\n. I opened an issue in Alamofire github: https://github.com/Alamofire/Alamofire/issues/604\n. So theres no need to do custom transforms for arrays of objects that conforms the mapping protocol? isnt? Cause yesterday someone told me ( https://github.com/Hearst-DD/ObjectMapper/issues/157 ) that for mapping an array of NSURL like (Address) i need to do a custom transform for handling the array.\n. http://postimg.org/image/qsky93tlb/full/\n. @ikesyo i dunno where the problem is, i updated the library, isolated the problem with dummy datta, and everything, if you can have a lookt at it i'll apreciate: \nhttp://stackoverflow.com/questions/31607189/problems-retrieving-json-from-php-server-using-alamofire\n. ",
    "danhodos": "ObjectMapper is super useful; thanks for all your hard work!\nIf I'm reading this change correctly, it seems like we've lost the ability to define let variables as well as the ability to specify non-optional (or implicitly-unwrapped optional) properties.\nSeems like the former was useful for specifying proper immutability constraints (i.e. this data is read from the server, but code should not be allowed to change it) and the latter was useful for validating JSON (i.e. \"this JSON is invalid\", \"this JSON is valid, but with incorrect keys\", and \"this JSON is valid, with correct keys, but the keys have the wrong types\").\nBoth of those seem like useful and worthy things to me; I'm interested to know if the UnsafeMutablePointer technique that as being used was somehow bunk, or if there were other reasons for the change?\n. Oh! I just saw that others have been discussing the same question over in #163. Ha!\n. Just read through the code; makes sense to me! :+1: :fireworks: :smile_cat: \n. ",
    "mkoppanen": "https://github.com/Hearst-DD/ObjectMapper/tree/protocol-update makes sense to me\n. ",
    "waltermvp": "@andrebraga same here, not sure if objectmapper handles the  \"unique\" part of parsing\n. @tristanhimmelman thanks for the quick reply will take a look\n. @tristanhimmelman seems like this protocol is used to support inheritance with mapping subclasses. If you take a look at static func objectForMapping(map: Map) -> Mappable? it sues a switch statement to branch between types not sure this would work since I can't switch with a identifier attribute. \nIs my understanding correct?\n. So I would modify   static func objectForMapping(map: Map) -> Mappable? to return a unique model with a unique id?\n. Soemthing like this?\n``` swift\nstatic func objectForMapping(map: Map) -> Mappable? {\n    if let identifier: String = map[\"id\"].value() {\n        //Fetch uniqe model from core data here?\n        return uniqueManagedObject\n    }\n    return nil\n}\n\n```\n. @tristanhimmelman awesome thanks. i'll close this issue for now and reopen if anything. \n. @tristanhimmelman not sure if you get this question often, would you accept a PR that has a core data example for the demo project?\n. @tristanhimmelman good to know, expect one this weekend\n. ",
    "msfeldstein": "Hmm i guess it does work, i thought i had tried that.  Sorry for bothering you guys but thanks for confirming.\n. ",
    "Dr-Head": "Sorry, I was trying to do the opposite, Merge your changes in to our fork. \n. ",
    "vadim-fueled": "@ikesyo cool, but anybody merging it?\n. Thanks!\n. ",
    "SashaKrstev": "The ultimate goal I was trying to achieve is to work with objects that conform to a given protocol + Mappable, without knowing their actual class.\nWorking with a class that conforms to that protocol does solve the problem, but I'm forcing clients to subclass rather than just conform.\n. Right, so I guess its working as intended. Close the issue if this is the case.\n. ",
    "Toldy": "I looked your code and I understand why it doesn't work.\nFor a mapArray the JSON is convert 2 times:\nif let JSONArray = JSON as? [[String : AnyObject]] {\nif let JSON = JSON as? [String : AnyObject] {\nSo, it's obvious that my JSON cannot be cast in Array<String>.\nHope it helps ! \n. That is not a solution.. \nI am using ObjectMapper for ALL requests of my app and I would prefer not to use the NSJSONSerialization to keep my code well structured, portable.  \n@cezheng In reality, my example is simpler than my problem. I didn't want to add more problems to the existing one.\nBut, if you need my whole problem to understand why it is not \"overkill\", this is it:\nThe JSON I want to parse:\njson\n[\n   {\n     \"foo\": {\n        \"type\": \"type_a\",\n        \"id\":\"1\"\n      }\n   },\n   \"+\",\n   [\n      \"12\",\n      \"x\",\n      {\n         \"foo\": {\n            \"type\": \"type_b\",\n            \"id\": \"1\"\n         }\n      }\n   ]\n]\nSo basically the syntax of the array is :\narray-type \u2192\u00a0[ type ]\ntype \u2192 array-type | string-type | object-type\nYou should better understand my problem now;\nI can't map the main array like Mapper<AnyObject>().mapArray(JSONString) because AnyObject doesn't inherit from Mappable\nRegarding the code of ObjectMapper, my syntax can only be:\narray-type \u2192\u00a0[ key: type ]\n[...]\nI can ask to my API devs to change the JSON, but that means a really big workload.\nThanks in advance\n. ",
    "cfraz89": "These errors still occur for me with swift-2.0 branch.\n. ```\n/Users/crusher/Downloads/moonrock-ios/Pods/ObjectMapper/ObjectMapper/Core/Mapper.swift:76:15: error: 'dropFirst' is unavailable: Use the dropFirst() method instead.\n                        let tail = dropFirst(keyPathComponents)\n                                   ^~~~~~~~~\nSwift.dropFirst:1:80: note: 'dropFirst' has been explicitly marked unavailable here\n@available(*, unavailable, message=\"Use the dropFirst() method instead.\") func dropFirst(s: Seq) -> Seq.SubSequence\n/Users/crusher/Downloads/moonrock-ios/Pods/ObjectMapper/ObjectMapper/Core/ToJSON.swift:12:33: error: 'split(:maxSplit:allowEmptySlices:isSeparator:)' is unavailable: Use the split() method instead.\n        let keyComponents = ArraySlice(split(key.characters) { $0 == \".\" })\n                                       ^~~~~\nSwift.split:1:76: note: 'split(:maxSplit:allowEmptySlices:isSeparator:)' has been explicitly marked unavailable here\n@available(, unavailable, message=\"Use the split() method instead.\") func split(elements: S, maxSplit: Int = default, allowEmptySlices: Bool = default, @noescape isSeparator: (S.Generator.Element) -> R) -> [S.SubSequence]\n                                                                           ^\n/Users/crusher/Downloads/moonrock-ios/Pods/ObjectMapper/ObjectMapper/Core/ToJSON.swift:31:14: error: 'dropFirst' is unavailable: Use the dropFirst() method instead.\n                let tail = dropFirst(components)\n                           ^~~~~~~~~\nSwift.dropFirst:1:80: note: 'dropFirst' has been explicitly marked unavailable here\n@available(, unavailable, message=\"Use the dropFirst() method instead.\") func dropFirst(s: Seq) -> Seq.SubSequence\n```\n. Btw I noticed that thsi doesnt happen building the objectmapper project itself from git. These errors occur after importing it with cocoapods.\n. Ah mb mb\n. ",
    "mirzadelic": "+1\n. Any news for NULL value?\n. And one more thing, i get price from rest as string \"100.00\", how can i convert it to Double, i use this mapper model:\n```\nclass OrderItem: Mappable {\n    var id: Int!\n    var aid: Int!\n    var quantity: Double!\n    var price: Double!\nrequired init?(_ map: Map) {\n    mapping(map)\n}\n\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    aid <- map[\"aid\"]\n    quantity <- map[\"quantity\"]\n    price <- map[\"price\"]\n}\n\n}\n```\nquantity and price needs to be Double but they are String in json. \n. Thanks, it works.\n. Yes, and to send it to server with Alamofire.\n. Ohh, this is great. Thanks..\n. Any example?\n. Thanks, it works..\n. Its string.\n. This solution works, thanks.\n. ",
    "Tarpsvo": "Is there any solid \"solution\" or workaround to this request?\n. ",
    "cwalo": "+1\nStill trying to find a way around this. \n. Just had to do this myself. Here's a sample class. Note the additional init() method. Don't forget to add the NSCopying protocol.\n```\nimport Foundation\nimport ObjectMapper\nclass SomeClass: NSObject, NSCopying, Mappable {\n    var firstName: String?\n    var lastName: String?\nrequired init?(_ map: Map){\n\n}\n\nfunc mapping(map: Map) {\n    firstName <- map[\"first_name\"]\n    lastName <- map[\"last_name\"]\n}\n\ninit(firstName: String?, lastName: String?) {\n    self.firstName = firstName\n    self.lastName = lastName\n}\n\nfunc copyWithZone(zone: NSZone) -> AnyObject {\n    let copy = SomeClass(firstName: firstName, lastName: lastName)\n    return copy\n}\n\n}\n```\n. @X901 Do you want to store the array as a RealmObject or the objects in the array as a RealmObject, or both? What does your mapping function look like now?. ",
    "jpaas": "I've also been struggling to figure this out. Ideally I'd like to see the JSONDictionary use the type [String: Any?] instead of [String: AnyObject].\n. ",
    "cnsilvan": "+1\n. ",
    "KevM": "We ran into this and worked around it for an array of optionals per a suggestion in #263. I added a generic version. This should be adoptable for non array mappings.\n. Here is a swipe at a generic version that is working for us.\n``` swift\nfinal class MapHelper {\nlet map: Map\n\ninit(map: Map) {\n    self.map = map\n}\n\nfunc mapArrayOfOptionals(field: String) -> [T?] {\n    if let values = map[field].value() as [AnyObject]? {\n        var resultValues = [T?]()\n        for value in values {\n            if value is NSNull {\n                resultValues.append(nil)\n            } else {\n                resultValues.append(value as? T)\n            }\n        }\n\n        return resultValues\n    }\n    return []\n}\n\n}\n```\nUsage\n``` swift\nstruct SomeDTO: Mappable {\n    private(set) var optionalStrings: [String?]!\ninit?(_ map: Map) {}\n\nmutating func mapping(map: Map) {\n    optionalStrings = MapHelper<String>(map: map).mapArrayOfOptionals(\"items\")\n}\n\n}\n```\nIs something along these lines viable as a PR for the project. Happy to take suggestions and take a stab at it if desired. \n. Duplicate of #263 which has a workaround.\n. ",
    "Koranda": "+1 or add support for NSNull, then I can use custom transform\n. ",
    "mohitagrawal": "+1\n. ",
    "txaiwieser": "Just commenting here to endorse the feature! Currently im using the method described in this issue #263\n. Awesome! Thanks! \ud83d\udc4d. Awesome, thanks!!\n. Same case here, i have an array of transactions, and they are different objects, i made a protocol for transactions, but cannot make it to work. Any help?\n. This is how I solved my initial problem, its not ideal, but it works 100%.\ntransactions <- (map[\"transactions\"], TransactionSerializationTransform())\n```\nclass TransactionSerializationTransform: TransformType {\n    typealias Object = Transaction\n    typealias JSON = [String: AnyObject]\ninit() {}\n\npublic func transformFromJSON(_ value: Any?) -> Transaction? {\n    guard\n        let json = value as? JSON,\n        let typeString = json[\"type\"] as? String,\n        let transactionType = FinalTransactionType(rawValue: typeString)\n        else { return nil }\n\n    switch transactionType {\n    case .deposit:\n        return Mapper<Deposit>().map(JSON: json)\n    case .invoice:\n        return Mapper<Invoice>().map(JSON: json)\n    case .withdraw:\n        return Mapper<Withdraw>().map(JSON: json)\n    }\n}\n\nfunc transformToJSON(_ value: Object?) -> JSON? {\n    assertionFailure(\"Not implemented\")\n    return nil\n}\n\n}\n```. I just found out that @tristanhimmelman was working on this couple months ago, but the branch (sets-of-basic-type) seems outdated.\nAre you still working on this feature? Can I use you branch?\nThanks \ud83d\udc4d. ",
    "mortenbekditlevsen": "We have a working solution for this. It is an optional boolean parameter for the Mapper initializer.\nThe parameter is passed on to the Map instances and the value is checked in all the \nclass func optionalXXX() -methods in ToJSON.swift.\nCurrently we have called the parameter 'mapNilToNull' (defaulting to existing behaviour of course).\nCan anyone suggest a better name? Then we can make a pull request for the change.\n. ",
    "adozenlines": "But shouldn't the server be smart enough to know that it has to apply a null to the incoming field that's not in the payload?. Codable is the way to go w/swift 4.. ",
    "alexliubj": "But anyway, it's really useful.\n. public func map(JSON: AnyObject?) -> N? {\n        if let JSON = JSON as? [String : AnyObject] {\n            return map(JSON)\n        }\nreturn nil\n}\nhere return nil\n. Good thanks,\n. ",
    "krummler": "I'm guessing travis can't figure out the new syntax? It worked fine on my local build server (osx server beta)\n. In the example you subclass the entity, I use an extension on a base class to add the function like so:\n```\nextension Linkable: MappableCluster {\npublic static func objectForMapping(map: Map) -> Mappable? {\n    // implementation here\n}\n\n}\n```\nThis doesn't work anymore, the extension doesn't add any protocol conformance (since Linkable itself already conforms to Mappable). Adding this method won't actually let it be used.\n. I can understand you'd want to keep the codebase simple. In this case would say the purpose of objectForMapping is different from the other functions described in the protocol, therefor I'm not sure they really belong together?\nIdeally I would say objectForMapping belongs in neither Mappable nor MappableCluster, as it's more of a config thing, rather than being part of the entity (or it's specific mapping) itself.\nThe  solution you described doesn't work unfortunately, the extension doesn't provide any additional protocol conformance, therefor the function doesn't get called. \nSimply said:\nDoesn't work (function doesn't get called)\n```\nextension BaseClass {\n    static func objectForMapping(map: Map) -> Mappable? {\n}\n\n}\n```\nWorks:\n```\nextension BaseClass: MappableCluster {\n    static func objectForMapping(map: Map) -> Mappable? {\n}\n\n}\n```\n. Hello Tristan,\nI was wondering if you know what direction you would like to go yet? I'm still stuck on version 1.2.0 and I don't like falling behind ;).\n. The tag 1.4.0 exists, but the ObjectMapper.podspec still points to 1.3.0 :(.\nEdit: I fixed it for now by manually pointing to the repo, the changes do fix the problem and I was able to upgrade without any problems. Thanks a lot of the change!\n. ",
    "vova-matukh": "Ty\n. ",
    "fresswolf": "Your newInstance method shouldn't return an Optional and shouldn't take any parameters:\nclass func newInstance() -> Mappable {\n    return User()\n}\n. ",
    "benoit-pereira-da-silva": "@tristanhimmelman the new protocol you are proposing is matching mine and is perfect :+1: \nConcerning my previous issue, i have understood :  i was trying to override the \"static func newInstance(map: Map) -> Mappable?\" as declared in the protocol : \nswift\npublic protocol Mappable {\n    static func newInstance(map: Map) -> Mappable?\n    mutating func mapping(map: Map)\n}\nI should have used  \"override class func newInstance(map: Map) -> Mappable? \"\nIsn't it a little bit strange to declare a static func and override a class func ? M'i missing something ?\n. I feel you are 100% right. And think we should adopt common patterns as possible.\n``` swift\npublic protocol NSCoding {\npublic func encodeWithCoder(aCoder: NSCoder)\npublic init?(coder aDecoder: NSCoder) // NS_DESIGNATED_INITIALIZER\n\n}\n```\nAdopting the same approach will allow to convert seamlessly NSCoding compliant classes.\n. Wassim I  m not able to reproduce your problem. The fix works on any Targets on my side. It seems normal to import Foundations.. ",
    "gooner22": "@tristanhimmelman that's really great!\nHowever, I can't find it in your latest commit(only readme update):\nhttps://github.com/Hearst-DD/ObjectMapper/commit/c810f62d9cd9cde75aa214fb403752019629ad4b\n. @tristanhimmelman works like a charm.\ncheers!\n. ",
    "lmiguelvargasf": "Sorry it seems that < City > is considered as a comment by GitHub when you do not write spaces after or before the opening closing operator, so although it was written, it didn't appear.\n. Thanks it worked. I was including the Mappable protocol at the beginning of the file. Once again thank you so much.\n. ",
    "Shajeel-Afzal": "@tristanhimmelman I still see this problem. Following is my code: \n```\nimport Foundation\nimport ObjectMapper\nclass Thumb: Mappable {\n    var thumbnail_480_url : String?\n    var thumbnail_720_url : String?\n    var thumbnail_url : String?\nclass func newInstance(map: Map) -> Mappable? {\n    return Thumb()\n}\n\nfunc mapping(map: Map) {\n    thumbnail_url <- map[\"thumbnail_url\"]\n    thumbnail_480_url <- map[\"thumbnail_480_url\"]\n    thumbnail_720_url <- map[\"thumbnail_720_url\"]\n}\n\n}\n```\n. ",
    "coderShiv": "I have a class something like below:\n```\nclass City: Mappable {\n    var state: String?\n    var name: String?\n    var id: String?\nclass func newInstance(map: Map) -> Mappable? {\n    return City()\n}\n\nfunc mapping(map: Map) {\n    state   <- map[\"state\"]\n    name    <- map[\"name\"]\n    id      <- map[\"id\"]\n}\n\n}\n```\nand a variable:\nvar cityList: [City]?\nNow I want to map jsonString to cityList. How should I do this?. ",
    "AFcgi": "Why remove the \"Merge pull request #161 from Hearst-DD/remove-init-from-mappable\" in swift 2.0 branch?\nMappable-Protocoll in\nSwift 1.2:\n- static func newInstance(map: Map) -> Mappable?\n- mutating func mapping(map: Map)\nSwift 2.0:\n- init?(_ map: Map)\n- mutating func mapping(map: Map)\n. ",
    "edias": "Any chance you guys add implicit mapping? It would reduce a lot of extra work mapping large objects and it also would simplify the code.\n. @tristanhimmelman, exactly. Otherwise all we are doing is copying and pasting properties from a dictionary. Moreover it's absolutely non sense to configure manually large objects where properties don't change anything from its original source. It's very redundant and verbose. It would be really beneficial to have something more similar to a real serialisation.\n. ",
    "MoralAlberto": "Thanks! \n. thank you, worked with var list: [String : Article]?\n. ",
    "kota": "I was trying to pull request to myself. Please kindly ignore this.\n. ",
    "athalay": "Sorry, I'll paste my JSON here (more properties are coming back than which are present in my model class):\n{\"WodGeneratorSettings\":{\"FilterSettings\":{\"IsAllEquipmentSelected\":false,\"IgnoreRecentlyCompletedWorkouts\":true,\"IsOnlyFittingExercisesSelected\":false,\"SelectedTargetingOption\":0,\"IsAllExercisesSelected\":true,\"IsAllSchemesSelected\":true,\"IncludeCommunityWods\":false,\"IsAllDurationIntervalsSelected\":true,\"SelectedEquipment\":[1,19,4],\"Exercises\":null,\"Schemes\":null,\"DurationIntervals\":null},\"Exercises\":null,\"ExerciseEquipments\":[{\"EquipmentID\":6,\"ExerciseIDs\":[97,76,122,130,125,128,129,124,127,2170,94,28,2166,104,23,135,12,2167,70,58]},{\"EquipmentID\":16,\"ExerciseIDs\":[101,33,140,159,34]},{\"EquipmentID\":1,\"ExerciseIDs\":[10,68,83,162,2,32,47,5,6,100,111,60,62,109,3,92,93,9,121,146,37,36,49,24,107,1,38,148,25,11,90]},{\"EquipmentID\":19,\"ExerciseIDs\":[41]},{\"EquipmentID\":17,\"ExerciseIDs\":[40,2169]},{\"EquipmentID\":2,\"ExerciseIDs\":[125,123,124,134,131,132,151,7,14,116,80,42,120,103]},{\"EquipmentID\":7,\"ExerciseIDs\":[128,127,117,118,45]},{\"EquipmentID\":9,\"ExerciseIDs\":[18,71,158]},{\"EquipmentID\":4,\"ExerciseIDs\":[54,55,79,110,51,57,56,63,108,50,133,105,48,1163,86,87,53,147,84]},{\"EquipmentID\":3,\"ExerciseIDs\":[86,87,146,147,4,89,8,46]},{\"EquipmentID\":18,\"ExerciseIDs\":[140,93,142,96,145]},{\"EquipmentID\":5,\"ExerciseIDs\":[2173,67,44,61,161]},{\"EquipmentID\":12,\"ExerciseIDs\":[2174,138,20,1164]},{\"EquipmentID\":13,\"ExerciseIDs\":[2175,154,1165]},{\"EquipmentID\":11,\"ExerciseIDs\":[92,1166,26,141]},{\"EquipmentID\":8,\"ExerciseIDs\":[19]},{\"EquipmentID\":10,\"ExerciseIDs\":[17]}],\"ExerciseGroups\":[{\"ID\":2,\"Name\":\"Weightlifting\",\"ExerciseIDs\":[10,68,83,41,2,32,47,5,54,55,79,110,51,57,56,63,108,50,133,48,86,87,6,100,111,60,62,109,3,92,93,53,9,121,146,147,37,36,49,24,107,1,38,148,25,11,84,90]},{\"ID\":6,\"Name\":\"Kettlebell\",\"ExerciseIDs\":[162,105,1163,2173,2174,2175,67,138,44,20,154,61,161,1164,1165]},{\"ID\":3,\"Name\":\"Endurance\",\"ExerciseIDs\":[17,4]},{\"ID\":4,\"Name\":\"Bodyweight\",\"ExerciseIDs\":[27,97,101,76,40,65,30,122,2169,130,125,128,2168,123,129,124,127,134,131,132,2170,94,28,95,33,140,155,21,2166,151,159,34,157,156,104,23,43,135,74,106,7,31,73,2176,12,13,14,116,80,42,120,19,22,142,2171,2172,117,118,45,2167,70,1166,98,58,103,85,46,114]},{\"ID\":5,\"Name\":\"Coordination, Agility, Balance, Accuracy or Speed\",\"ExerciseIDs\":[150,18,113,115,89,71,8,158,26,96,141,145]},{\"ID\":1,\"Name\":\"Other\",\"ExerciseIDs\":[]}],\"WodSchemes\":[{\"ID\":0,\"Name\":\"Singlet\"},{\"ID\":1,\"Name\":\"Couplet\"},{\"ID\":2,\"Name\":\"Triplet\"},{\"ID\":3,\"Name\":\"Amrap\"},{\"ID\":4,\"Name\":\"Chipper\"},{\"ID\":5,\"Name\":\"Hybrid\"}],\"DurationIntervals\":[{\"Name\":\"\\\\u003c 10 mins\",\"MinDurationInSecondsInclusive\":-1,\"MaxDurationInSecondsInclusive\":600,\"ID\":1},{\"Name\":\"10-20 mins\",\"MinDurationInSecondsInclusive\":600,\"MaxDurationInSecondsInclusive\":1200,\"ID\":2},{\"Name\":\"20-30 mins\",\"MinDurationInSecondsInclusive\":1200,\"MaxDurationInSecondsInclusive\":1800,\"ID\":4},{\"Name\":\"30+ mins\",\"MinDurationInSecondsInclusive\":1800,\"MaxDurationInSecondsInclusive\":-1,\"ID\":8}],\"Wods\":[],\"TargetingOptions\":[{\"ID\":0,\"Name\":\"No targeting\"},{\"ID\":1,\"Name\":\"Endurance\"},{\"ID\":2,\"Name\":\"Strength\"}]},\"EquipmentSettings\":[{\"EquipmentId\":11,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"10kg/22lbs medicine ball\"},{\"EquipmentId\":18,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"5kg/11lbs medicine ball\"},{\"EquipmentId\":3,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Area to run\"},{\"EquipmentId\":1,\"IsOwnedBySportsman\":true,\"EquipmentName\":\"Barbell\"},{\"EquipmentId\":19,\"IsOwnedBySportsman\":true,\"EquipmentName\":\"Bench rack\"},{\"EquipmentId\":4,\"IsOwnedBySportsman\":true,\"EquipmentName\":\"Dumbbell\"},{\"EquipmentId\":16,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"GHD machine\"},{\"EquipmentId\":17,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Jump box (60cm) \"},{\"EquipmentId\":9,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Jump rope\"},{\"EquipmentId\":5,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Kettlebell (16kg)\"},{\"EquipmentId\":12,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Kettlebell (24kg)\"},{\"EquipmentId\":13,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Kettlebell (32kg)\"},{\"EquipmentId\":6,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Pull-up bar\"},{\"EquipmentId\":2,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Rings\"},{\"EquipmentId\":8,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Rope to climb\"},{\"EquipmentId\":10,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Rower\"},{\"EquipmentId\":7,\"IsOwnedBySportsman\":false,\"EquipmentName\":\"Static dip bar\"}],\"SportsmanCoreSettings\":{\"ProfileUrl\":\"http://192.168.0.12:57336/Content/themes/gray/gfx/avatar_nophoto_150x150.png\",\"FirstName\":\"110\",\"LastName\":\"110\"},\"HealthLevelSettings\":[{\"BodyPartId\":10,\"Value\":5,\"Name\":\"Shoulder - Frontal press (Bench press push-ups, ring dips etc.)\"},{\"BodyPartId\":9,\"Value\":10,\"Name\":\"Shoulder - Overhead Pressing (Jerk, Push Press, Press etc.)\"},{\"BodyPartId\":1,\"Value\":10,\"Name\":\"Shoulder - Pulling movements (Pull ups, Clean, Snatch etc.)\"},{\"BodyPartId\":7,\"Value\":10,\"Name\":\"Acromioclavicular (AC) joint\"},{\"BodyPartId\":11,\"Value\":10,\"Name\":\"Elbow - Movements involving pressure on the joint\"},{\"BodyPartId\":3,\"Value\":10,\"Name\":\"Elbow - Movements involving twisting of the joint\"},{\"BodyPartId\":13,\"Value\":10,\"Name\":\"Wrist - Movements involving pressure on the joint\"},{\"BodyPartId\":8,\"Value\":10,\"Name\":\"Wrist - Movements involving twisting of the joint\"},{\"BodyPartId\":6,\"Value\":10,\"Name\":\"Spine\"},{\"BodyPartId\":2,\"Value\":10,\"Name\":\"Hip\"},{\"BodyPartId\":12,\"Value\":10,\"Name\":\"Knee - Movements involving pressure on the joint\"},{\"BodyPartId\":4,\"Value\":10,\"Name\":\"Knee - Movements involving twisting of the joint\"},{\"BodyPartId\":5,\"Value\":10,\"Name\":\"Ankle\"}],\"IsLoadUnitMetric\":false,\"IsSuccessful\":true,\"ErrorMessage\":null,\"NotAuthorizedRedirectTo\":null,\"RedirectTo\":null,\"SuccessMessage\":null}\n. OK, got the problem.\nInstead of \nlet user = Mapper<ResponseResult>().map(json.value)\n, I have to use \nlet user = Mapper<ResponseResult>().map(json.value!)\n(using \"!\" for json.value, so it's not an optional).\nIs this a bug, or user-error? :)\n. Thanks a lot, Tristan, though maybe it could be a CR for consideration that inside you check whether the passed in string is optional or not, and if it is, then you handle this case inside. So others don't really have to mind what do they pass in.\n. ",
    "negry": "init(){\n}\ni forgot that jeje\n. ",
    "laxmisa": "@tristanhimmelman Do you know if this would be merged into master anytime soon?\n. ",
    "mabril": "With this branch I managed to deserialize an array of class cluser. \nBut... how to deserialize? This is my code\n```\nlet transform = TransformOf<[FilterBase], [[String:AnyObject]]>(fromJSON: { (value:  [[String:AnyObject]]?) -> [FilterBase]? in\n        // transform value from String? to Int?\n        return  Mapper().mapArray(value)\n        }, toJSON: { (value: [FilterBase]?) ->  [[String:AnyObject]]? in\n            // transform value from Int? to String?\n            if let value = value {\n                return Mapper().toJSONArray(value)\n            }\n            return nil\n    })\nfilters <- (map[\"Filters\"],transform)\n\n```\n. Exactly. I relalized of it minutes after posting. Now I only use the custom transform for deserialize. When I need to serialize I just use:\nfilters <- map[\"Filters\"]\nThanks!\n. \nIt seems that it needs the build scheme...\n. ",
    "hengchengfei": "thank you\n. I really appreciate\n. I really appreciate.\n. ",
    "hyouuu": "Ah sorry I got the idea from the explanation on realm integration. In that case I guess it has to be dealt with from realm's side?\n. The thing is that I want to read the primary key if it's not nil. Currently\nwhat I have to do is to make a copy of the object and do mapping on that,\nwhich is a performance waste although insignificant. Is there a way to\narbitrarily return a value for a mapping so that the primary key field is\nnot touched but I can still return its value?\nOn Fri, Sep 18, 2015 at 12:03 PM Tristan Himmelman notifications@github.com\nwrote:\n\nI don't think Realm will change this requirement. I think your best bet is\nto add some logic prior to mapping the primary key. Something like this\nmaybe:\nfunc mapping(map: Map){\nif primaryKey == nil {\n    primaryKey <- map[\"primaryKey\"]\n}\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Hearst-DD/ObjectMapper/issues/213#issuecomment-141536965\n.\n. Good idea - I'll just go with this :)\n. \n",
    "marksbren": "I now have to move away from ObjectMapper because of this issue. I want to be able to map to and from objects without Realm triggering an error\n. ",
    "Nathan187": "no longer an issue....added an initializer w/ parameters..please delete this posting if possible\n. ",
    "yoshinorisano": "@tristanhimmelman Thanks for merge and polish my writing!\n. ",
    "bassebaba": "I would like an option to take this one step even further.\nFor this json:\n{\n    \"name\": \"bassebaba\",\n    \"age\": 31337,\n    \"isAwesome\": true\n}\nIf I have:\nclass person : Mappable\n{\nvar name: String?\nvar age: Int?\n}\nI would like to automagically map this without the mutating func mapping(map: Map) function.\nJust like \"ah okay, I have 'name' in the json and I have a string in the class named \"name\", lets automap that. Same thing for age. The bool is missing in the class, no problem lets just skip that one\"\nBecause now, it's a total redundancy if I name my classes exactly as the json.\n. ",
    "lexrus": "@tristanhimmelman Is there any benchmark of reflection APIs?\n@bassebaba I just found another lib which use reflection to map keys automatically. https://github.com/johnlui/JSONNeverDie\n. ",
    "bjzhou": "@tristanhimmelman Somtimes the generic type not conforms to Mappable, like String or Array.\n. ",
    "zhengying": "the latest version is OK.\n. Great!,  thanks!!\n. ",
    "Siamaster": "Implement it bro\n. It was a joke. Thank you @tristanhimmelman for your efforts. \n@wrutkowski  I believe you mean \"WTF\" not \"FTW\". FTW stands for for the win, which doesn't make any sense here. \nHappy Friday.\n. ",
    "wrutkowski": "@Siamaster WTF? Implement yourself and make a pull request. @tristanhimmelman is doing great job here (and thank you for that), but it isn't his duty to do it.\n. @Siamaster you are right. I meant WTF. There are a lot of people requesting for new functionalities instead of suggesting or helping.\nHappy Friday too :)\n. ",
    "fwielstra": "Actually, nested objects and nested arrays of mappables don't seem to work properly when using the failable init method, similar errors. Is that one tested properly? I don't see it being used in the tests much. I'd rather not make large changes to my data model (i.e. make my fields mutable and explicitly unwrapped) to make this library work.\n. ",
    "diogoguimaraes": "Could you please make a release with this change? \nIt will prevent the double checkout being performed by pod spec lint and it will solve the errors when building a project that uses ObjectMapper using Xcode7 because v0.9 doesn't work with Xcode7.\nThanks!\n. My bad, I was missing the last Xcode update.\nAfter the update the issue was fixed.\n. Hey @tristanhimmelman, it's done \ud83d\udc4d \nCan you please take a look and see if everything is ok?\nThanks\n. Regarding the file structure, AFAIK any folder inside the the Sources folder is considered a different module, so if you add folders the swift buildwill fail with the following error: error: the package has an unsupported layout, unexpected source file(s) found. So in order to support SPM I would leave the structure as it is.\n. @tristanhimmelman I messed up a bit in git and had to do a new fork to make a clean PR. I'll be closing this one and moving it to #618. \nSorry about this mess \ud83d\ude1e\n. I'll revert all these changes.\n. ",
    "masterfego": "Sorry, this example works!\n. ",
    "aphex3k": "Thanks for clarification\n. ",
    "rokob": "It is not the transform that is the problem, that was a red herring:\n``` swift\nstruct OtherList: Mappable {\n    var things: [Other]\n    init(things: [Other]) {\n        self.things = things\n    }\n    init?(_ map: Map) {\n        things = map[\"things\"].valueOrFail()\n        guard map.isValid else { return nil }\n    }\n    mutating func mapping(map: Map) {\n        things <- map[\"things\"]\n    }\n}\nstruct Other: Mappable {\n    var x: Int?\n    init(x: Int?) {\n        self.x = x\n    }\n    init?(_ map: Map) {\n    }\n    mutating func mapping(map: Map) {\n        x <- map[\"x\"]\n    }\n}\nlet o1 = Other(x: 42)\nprint(Mapper<Other>().map(Mapper<Other>().toJSON(o1)))\nlet o2 = Other(x: 99)\nlet otherList = OtherList(things: [o1, o2])\nprint(Mapper<OtherList>().map(Mapper<OtherList>().toJSON(otherList)))\n\n```\nYou will see that the first roundtrip works, but the second one doesn't. The issue is with objects that have properties that are arrays of mappable types.\n. Huzzah the issue is with the valueOrFail call in the initializer. If you change the OtherList init? to\nswift\n    init?(_ map: Map) {\n        things = []\n        guard map.isValid else { return nil }\n    }\nThen the roundtrip works, BUT that leads to a bit of a problem if the key is missing.\n. ",
    "pcompassion": "Seriously?! \nEmbarassing!@\nThanks a bunch!\n. oh I followed instrunction at the git main.\n```\nOtherwise, ObjectMapper can be added as a submodule:\n\nAdd ObjectMapper as a submodule by opening the Terminal, cd-ing into your top-level project directory, and entering the command git submodule add https://github.com/Hearst-DD/ObjectMapper.git\nOpen the ObjectMapper folder, and drag ObjectMapper.xcodeproj into the file navigator of your app project.\nIn Xcode, navigate to the target configuration window by clicking on the blue project icon, and selecting the application target under the \"Targets\" heading in the sidebar.\nEnsure that the deployment target of ObjectMapper.framework matches that of the application target.\nIn the tab bar at the top of that window, open the \"Build Phases\" panel.\nExpand the \"Target Dependencies\" group, and add ObjectMapper.framework.\nClick on the + button at the top left of the panel and select \"New Copy Files Phase\". Rename this new phase to \"Copy Frameworks\", set the \"Destination\" to \"Frameworks\", and add ObjectMapper.framework.\n```\n\nI have the ObjectMapper.xcodeproj included under my project workspace\nHere are the screen shots. \n\n\n\n\n\n. Are you saying that, having the ObjectMapper project under my workspace isn't enough and I should add those files again?\nOh. I guess I shouldn't added it as a subproject.\nI should only add files directly. Let me try that..\n. You should add files directly as ikesyo suggested. I though Otherwise, ObjectMapper can be added as a submodule part was for 7.1 users. and it's not.\n. ",
    "Glagnar": "Try removing the required keyword ?\n. ",
    "kiliankoe": "Since I'm looking to decode a date that's not in the device's local timezone, it's probably my fault for not using the sensible default correctly. I failed to see that DateFormatterTransform even existed, that's a good idea, thanks!\nI worked around the issue by using my own transformer:\n``` swift\nlet UTCDateFormatter = NSDateFormatter(dateFormat: \"yyyy-MM-dd'T'HH:mm:ss\", timezone: NSTimeZone(name: \"UTC\")!)\nlet UTCTransform = TransformOf(fromJSON: {\n    return UTCDateFormatter.dateFromString($0!)\n}, toJSON: {\n    return UTCDateFormatter.stringFromDate($0!)\n})\n```\nIf you think I'm right about the fault here being mine, feel free to close this issue.\n. ",
    "ruben-samsonyan": "Hi Tristan,\nThank you for feedback. Of course I will do it.\nRegards,\nRuben Samsonyan\n\nOn Oct 20, 2015, at 7:56 PM, Tristan Himmelman notifications@github.com wrote:\nHi @ruben-samsonyan https://github.com/ruben-samsonyan, nice idea! Thanks for the pull request.\nIt is important that new features, such as this one, are paired with a unit test to ensure functionality doesn't break down the line. Could you please add a test for this?\nThanks!\n\u2014\nReply to this email directly or view it on GitHub https://github.com/Hearst-DD/ObjectMapper/pull/249#issuecomment-149614426.\n. Hi Tristan,\n\nI have added test for nested arrays.\nRegards,\nRuben Samsonyan\n. You are welcome\n\nOn Oct 26, 2015, at 1:51 AM, Tristan Himmelman notifications@github.com wrote:\nThanks @ruben-samsonyan https://github.com/ruben-samsonyan for the addition \n\u2014\nReply to this email directly or view it on GitHub https://github.com/Hearst-DD/ObjectMapper/pull/249#issuecomment-150977430.\n. \n",
    "rikoschmidt": "Hey,\nour webservice also returns an array of different types. However, the types are encoded in the key of the dictionaries inside the array:\n{\"animals\": [\n  {\"Cat\": {\"name\": \"foo\"}},\n  {\"Dog\":{\"name\": \"bar\", \"color\": \"brown\"}}\n ]}\nAs far as I can tell, with this JSON structure, one could only select the right type in the mapping process by inspecting the key property of the JSONDictionary variable of the Map Object. But as the JSONDictionary is an internal property we can not access it. \nIs there maybe any other way we can achieve polymorphic mapping with the JSON structure above?\nThanks,\nRiko\n. ",
    "WarDrummer": "Hi @tristanhimmelman, I have tried Whole Module Optimization. That reduced the time to ~35s, but it is still far from the 5s we were getting before.\n. @wieseljonas Our problems had to do with mapping arrays, too. Ultimately, we resorted to converting the NSDictionary directly to our models to get the performance we needed. Using [AnyObject?] is slower than [MyModel]. I wonder what changed between Swift 1.2 and Swift 2.0 that caused the performance issue. \n. @wieseljonas @tristanhimmelman No problem. We're not using ObjectMapper at the moment; we wrote our own mappers to deal with the performance issue. Perhaps seeing what we did will give you some ideas for improving performance and we can switch back.\nWe got the idea that the mapping to arrays of [AnyObject?] was a problem from the Instruments Time profiler. I would definitely give Time profiler a shot to try and locate any hotspots.\nHere is a stripped down version of two of our mappers (one containing an array of the other):\n```\nfinal class TocJSON {\n    private(set) var TocTree: [TocSectionJSON] = TocSectionJSON\n    private init() { / Force use of create() / }\nstatic func create(json: NSDictionary) -> TocJSON {\n    let tocJSON = TocJSON()\n    if let TocTree = json[\"TocTree\"] as? NSArray {\n        for tocTree in TocTree {\n            if let tocTreeJson = tocTree as? NSDictionary {\n                tocJSON.TocTree.append(TocSectionJSON.create(tocTreeJson))\n            }\n        }\n    }\n    return tocJSON\n}\n\n}\nfinal class TocSectionJSON {\n    private(set) var Title: String = \"\"\n    / ... /\n    private init() { / Force use of create() / }\n    static func create(json: NSDictionary) -> TocSectionJSON {\n        let tocSectionJSON = TocSectionJSON() \n        if let Title = json[\"Title\"] as? String {\n            tocSectionJSON.Title = Title\n        }\n        / ... /\n        return tocSectionJSON\n    } \n}\n```\n. ",
    "manojmahapatra": "@tristanhimmelman  Any update(s) on this issue? I'm also facing the similar perf issue when I'm upgraded to Swift 2.x . \n. @tristanhimmelman, I wish I could post the JSON which I'm retrieving but due to privacy I can't and to mock such a large (~1.5MB) JSON object will take time.\nIn the mean time, I did debug few classes and in Mapper.swift class, I found something interesting. \n```\npublic func map(JSONDictionary: [String : AnyObject]) -> N? {\n   let map = Map(mappingType: .FromJSON, JSONDictionary: JSONDictionary)\n    // check if N is of type MappableCluster\n    if let klass = N.self as? MappableCluster.Type {\n        if var object = klass.objectForMapping(map) as? N {\n            object.mapping(map)\n            return object\n        }\n    }\nif var object = N(map) {\n    object.mapping(map)\n    return object\n}\nreturn nil\n\n}\n```\nIf I change the above MappableCluster check with this,\npublic func map(JSONDictionary: [String : AnyObject]) -> N? {\n    let map = Map(mappingType: .FromJSON, JSONDictionary: JSONDictionary)\n    let object = N(map)\n    return object           \n}\nIt did the trick and started working as expected and this time map took only ~2-3 seconds as against >16seconds. I also tried w/ even larger JSON objects (>2MB) and the map function still clocks around ~2-3 seconds. \nThe changes what I did, seems to start woking again for large JSON objects(did some benchmarking on Swift 1.2 vs Swift 2.x and I'm seeing the same response time and performance). If you could shed some lights that'll be helpful.\nLet me know if it helps.\n. @tristanhimmelman, I can confirm there is a performance surge (~ 1 seconds) as per my benchmarks w/ the new version. Thank you for the changes.\nTo my original question, I was calling mapping function inside init? when my code was in Swift 1.2 and with Swift migration to 2.x and Pod update, I totally forgot to remove that function call in my model objects. My bad!!  Thank you again for pointing to that.\n. @tristanhimmelman I see an improvement of ~1 second. Sorry for any confusion :panda_face: \n. ",
    "maksTheAwesome": "I'll attach an object for 20 000 elements later today. I have to parse it one by one because client needs a progress bar. It takes about 20 minutes to complete mapping & save the object in Realm.\n. Here you go.\njson.txt\n. Thank you. worked for me too.\n. O-o-oh! That's so obvious! I should stop coding at night. Thank you, Tristan!\n. Is there any way to make ObjectMapper make a new connection if such object already exist?\n. I see now. It used to call init() in case if that method was returning nil. Thank you.\n. ",
    "mathieudebrito": "Hi there, I have the same issue. I have a huge Json object coming from my server, and it takes like 10 seconds to parse it.\nWhen will this fix be released ? (I'm on 1.1.2)\nBTW : Thanks for this lib, making my code pretty clean ;)\n. @tristanhimmelman Sorry for the delay, got a lot of work to do.\nSo here are the results of my tests : \nv1.1.2\nlarge : (7min 20sec)\nsemi-large (4min 20 sec)\nshort (40sec)\nv1.1.5\nlarge : (6min 36sec)\nsemi-large (3min 40 sec)\nshort (28sec)\nThis proves that the job you've done paid : each time has decreased.\nBut this is way not enough for me, I will be working on it from tomorrow.\nI will let you know my findings !\nPS : if you have a version ready with nested keyword, I would be happy to test !\nThank you again\n. @tristanhimmelman Ok, turns out the problem was not in ObjectMapper but with a third-part extension.\n The results are now : \nlarge : (4 sec)\nsemi-large : (2 sec)\nshort:  (0.7 sec)\nAs I tested with pretty about 1Mo of data for the large, it appears to me that the lib has no more efficiency issue, so I propose to close this issue. \n. @winkelsdorf it actually had nothing to do with ObjectMapper, it was a third-party extension I was using to decode some encoded strings sent by our server. The extension was calling a specific function way more than necessary : this was spending a lot of time initializing and was causing big memory consumption. I sent them a message to fix it and they did. So I don't want to name & blame anyone here : this is part of open-sources projects ;)\nBut FYI, I used XCode Developper Tools -> Instruments -> Time Profiler to track times spent in functions\n. Well, my bad, I should have shown the possible values of coordinates :p\nmy coordinates looks like this : \"[[[1,1], [2,2], [3,3]], [[1',1], [2',2'], [3',3']]]\"\nAnd I need to get all of these data. This is why Array<Array<Array<Double>>>\nI will definitely take a look at your fork !\nThx :)\n. ",
    "winkelsdorf": "@mathieudebrito I am curious, which third-party library caused this issue. Would you mind to name & blame? Before other developers have the same problem, good to know what combinations to avoid..\n. @mathieudebrito Thank you for the clarification! Good to see that this issue was resolved for you \ud83d\udc4d . ",
    "lmsmartins": "Isn't there really a way around this? The GSON library for Android allows to add custom JsonSerializers to define the order of the elements. There's got to be a way.. I've just tried the OrderedDictionary, but it doesn't work, since the top level object for JSON serialization must be NSDictionary or NSArray. Thanks.. Do you mean using this class to convert to JSON? \nhttp://www.cocoawithlove.com/2008/12/ordereddictionary-subclassing-cocoa.html\nIt's written in Objective-C, so I looked for a swift implementation, but when trying to serialize I got an exception since I would have to use a NSDictionary or NSArray as the top object in order to use JSONSerialization.\nSwift OrderedDictionary that I used:\nhttps://github.com/lithium3141/SwiftDataStructures/blob/master/SwiftDataStructures/OrderedDictionary.swift\nAs pointed in the SO question you've mentioned, this feature of maintaining the order of the attributes is really important \"if you serialize the json to NSData and you use an MD5 string to determine whether the data has changed, it's good to know that it hasn't.\"\n. ",
    "haritowa": "You have to implement OrderedDictionary to achieve ordered keys access. Not sure this feature will be so useful. In addition JSON is unordered by spec. Maybe you get me wrong: OrderedDictionary should be used in ObjectMapper implementation. It's relativitely easy to implement, i guess(users will receive possibility to return list of keys with proper order).\nYou can check out this SO question which contains several links to OrderedDictionary implementation. If you have time for experiments: please check if it fixes JSON serializing order and maybe ObjectMapper can receive new feature(with @tristanhimmelman approvement obviously). Should it be forwarded only for Immutable mappings? I believe any mappable type can benefit from Context forwarding. Ok, just double-check, pr will be available in a couple of hours. Create PR, but Travis check failed for strange reason. Maybe performance check failed, but i barely affect this.\nUPD: All checks have passed. Nice, love this repo :). If all your keys are the same type you can use these methods. Object mapper available for Java?. Hello. I use !context.isDeveloper case if anyone change context isDeveloper value test will fail, and i believe, that compare expected value with real context value make more sense.\nIn addition, Xcode will run whole test(and don't give up on first failed assert, so XCTAssertNotNil doesn't guarantees that person will be valid during whole test).\n\n. Looking forward for new ObjectMapper version \ud83d\ude04 . ",
    "jaumard": "Ok my bad it's on ReadMe just found it nothing special to do ^^ \nself.corp <- map[\"corp\"];\nself.entete <- map[\"entete\"];\n. Mapping are needed event if we use init method so everything is working if class become : \n```\nimport ObjectMapper\nimport Foundation\nclass LoginBean : NSObject, Mappable {\n    var identifiant : String\n    var motDePasse : String\ninit(identifiant : String, motDePasse : String){\n    self.identifiant = identifiant\n    self.motDePasse = motDePasse\n}\n\nrequired init?(_ map: Map) {\n    self.identifiant = map[\"identifiant\"].valueOrFail()\n    self.motDePasse = map[\"motDePasse\"].valueOrFail()\n}\n\nfunc mapping(map: Map) {\n    self.identifiant <- map[\"identifiant\"]\n    self.motDePasse <- map[\"motDePasse\"]\n}\n\n}\n```\n. ",
    "dabeck": "+1\n. ",
    "baydet": "+1\n. I like the idea of working with mapping only through subscript. I think with moving JSONDictionary to public ObjectMapper will lose integrity - I will be able to work with Dictionary without Map object at all.\nAnyway, I agree that my PR not solve the problem completely. It needs deeper analysis.\n. Well, I've understood that in this case we have problems with toJSON mapping...\n. Did you think about declaring Map as protocol and create different implementations, conforming to Map, for toJSON(class) and fromJSON(struct)? \nFor me it sounds like a good idea, because fromJSON mapping is good for structs, because it's just data. toJSON looks like a class because it has a lot of interactivity which requires saving a pointer to object. \nI've tried to replace class with struct roughly in my fork. All fromJSON tests are passed.\n. You can create your custom DateTransform kind of like that\n```\nclass MilisecondDateTransform: TransformType {\n    typealias Object = NSDate\n    typealias JSON = Int\ninit() {}\n\nfunc transformFromJSON(value: AnyObject?) -> NSDate? {\n    if let timeInt = value as? Int {\n        return NSDate(timeIntervalSince1970: NSTimeInterval(timeInt/1000))\n    }\n    return nil\n}\n\nfunc transformToJSON(value: NSDate?) -> Int? {\n    if let date = value {\n        return Int(date.timeIntervalSince1970 * 1000)\n    }\n    return nil\n}\n\n}\n```\n. ",
    "EliaCereda": "+1\n. Except those aren't my classes so I can't change them at all. I've edited ObjectMapper to use the old newInstance(map: Map) method, but it still doesn't work like I'd want it to.\nUsing newInstance I'm able to add Mappable conformance to the classes I need, but since Swift doesn't allow me to override methods in an extension I can't implement Mappable in class clusters.\n. ",
    "MPiccinato": "+1\nI used to use RestKit which had this decoupling available but that library was just too heavy. I am going to dig in and see if I can come up with any thoughts to help out. A bit new to swift so it might take a bit :)\nAny more thoughts on your end @tristanhimmelman ?\n. ",
    "brianhei": "Anyway to change the map key before calling the map function?\nI have a object with two JSON structure .\n. ",
    "valeriomazzeo": "The main difference between an object mapper like this and the one used in RestKit is that in Objective-C you have reflection both ways (thanks to KVC), that made that possible. In Swift reflection is read-only and it's not possible to use the same approach.\n. I think your issue can probably relate to #260\n. ",
    "PhilCai1993": "make everything optional.....\nfunc mapping(map: Map) {\n        detail <- map[\"detail\"]\n        name <- map[\"Name\"]\n        if let _ = name {\n            print(\"try another\")\n        } else {\n            name <- map[\"name\"]\n        }\n        projects <- map[\"projects\"]\n    }\nI don't know whether it's good.\n. I think using MappableCluster is good to deal with this.\n. how about this: https://gist.github.com/PhilCai1993/5821a168cd3ea11168f2 \nJust look at the bottom line.\n. I think this kind of JSON is a little weird...\n. Thanks a lot\n. Thanks, I was just confused.\n. Mapper().map(json)\n. ",
    "camina-apps": "+1\n. +1\n. +1\n. ",
    "Nodepad": "+1\n. ",
    "smztko": "Hi, \nThis subscript is convenience for me.\nextension Map {\n    public subscript(keys: [String]) -> Map {\n        for key in keys {\n            let nested = key.containsString(\".\")\n            self[key, nested: nested]\n            if currentValue != nil { break }\n        }\n        return self\n    }\n}\nUsage:\nfirstname <- map[[\"firstname\", \"first_name\"]]\nBut, I have a problem now.\nIn the case of Object -> JSON mapping, which key is adequate? (\"firstname\" or \"first_name\")\nP.S. I am a newcomer to this community, if this posting on this place is unsuitable, so sorry.\n. ",
    "vCrespoP": "+1 PLEASE, really useful.\nKeep it up man!\n. ",
    "scottrhoyt": "No problem! Let me know if you'd like any help.\n. @tristanhimmelman I was wondering if you had given more thought to this change?\n. Awesome. Yeah, I've run into similar Xcode issues. Let me know if there is any way I can help!\n. :+1:  So glad to see this make it in. Let me know if there is any other way I can help, and keep up the great work! I'm currently about to use ObjectMapper with SwiftYaml and some custom extensions to easily map Yaml to swift objects!\n. For posterity's sake, I wound up using map[\"id\"].currentValue to test.\n. ",
    "fscherer": "Same issue here.\nThe Mapper methods mapArray(...), mapDictionary(...), etc. should not return nil for an empty but existing JSON.\nThanks in advance\n. ",
    "ArsalanReal": "Please fix it. Same issue to me :(\n. eg:   let json : String = MapArray().toJsonString(users)\n. Thanks a lot guru\n. ",
    "Narayane": "Hi,\nI am really stuck on this limitation with a [Int?]? attribute which I get from a web service.\nIs there any workaround you could suggest me to deal with it: maybe a custom transform (which would transform nil values into 0) could work?\nThanks.\n. Ok, I have a workaround if someone has the same problem, I guess it should also work with a custom objects array.\nimport ObjectMapper\nclass MyDto: Mappable {\n```\nvar dangerLevels: [Int]? // in json, it is in fact a [Int?]? representation\nrequired init?(_ map: Map) {\n    let levels = map[\"dangers_levels\"].value() as [AnyObject]?\n    if let levels = levels {\n        dangerLevels = []\n        for level in levels {\n            if level is NSNull {\n                dangerLevels!.append(0)\n            } else {\n                dangerLevels!.append(level as! Int)\n            }\n        }\n    }\n}\nfunc mapping(map: Map) {\n    //dangerLevels <- map[\"dangers_levels\"]\n}\n```\n}\n. ",
    "austinzmchen": "Thanks for the solution! Kinda get caught off guard when knowing the following JSON validates. \n[\n    {\n        \"name\": \"a\",\n        \"type\": 1\n    },\n    null,\n    {\n        \"name\": \"b\",\n        \"type\": 2\n    }\n]. ",
    "amirsaifi77": "@KevM Having a hard time implementing the generic solution for my custom object. If my custom struct has nested custom structs that rely on Object Mapper to parse it, is this solution sill expected to work?. To add onto @KevM's solution above. This implementation allows nested mapping if your optional value is Mappable.\nSame usage as the solution by @KevM above.\n```swift\nfinal class MapHelper {\nlet map: Map\n\ninit(map: Map) {\n    self.map = map\n}\n\nfunc flatMapArrayOfOptionals(field: String) -> [T] {\n    if let values = map[field].value() as [AnyObject]? {\n        var resultValues = [T]()\n        for value in values {\n            if value is NSNull {\n                // do nothing\n            } else {\n                if let mappableValue = Mapper<T>().map(value) {\n                    resultValues.append(mappableValue)\n                } else if let nonMappableValue = value as? T {\n                    resultValues.append(nonMappableValue)\n                }\n            }\n        }\n\n        return resultValues\n    }\n    return []\n}\n\nfunc mapArrayOfOptionals(field: String) -> [T?] {\n    if let values = map[field].value() as [AnyObject]? {\n        var resultValues = [T?]()\n        for value in values {\n            if value is NSNull {\n                resultValues.append(nil)\n            } else {\n                if let mappableValue = Mapper<T>().map(value) {\n                    resultValues.append(mappableValue)\n                } else {\n                    resultValues.append(value as? T)\n                }\n            }\n        }\n\n        return resultValues\n    }\n    return []\n}\n\n}\n```. Doesn't look like it currently. The solutions in #263 might help point you in the right direction for a solution specific to you.. ",
    "RafaelPlantard": "Guys I have the following object:\n```\nstruct Repo: ImmutableMappable {\n    let name: String\n    let description: String?\n    let author: String\n    let profilePicture: URL\n    let stars: Int\n    let forks: Int\n    let fullName: String\n// MARK: Non-argument initializer\n\ninit() {\n    name = \"\"\n    description = nil\n    author = \"\"\n    profilePicture = EnvironmentVariable.profileURL.url\n    stars  = 0\n    forks = 0\n    fullName = \"\"\n}\n\n// MARK: ImmutableMappable conforms\n\ninit(map: Map) throws {\n    name = try map.value(\"name\")\n    description = try map.value(\"description\")\n    author = try map.value(\"owner.login\")\n    profilePicture = try map.value(\"owner.avatar_url\", using: URLTransform())\n    stars = try map.value(\"stargazers_count\")\n    forks = try map.value(\"forks_count\")\n    fullName = try map.value(\"full_name\")\n}\n\n}\n```\nAnd it's failing when description property is null, how can I handle it?\n/// Returns a value or throws an error.\n    public func value<T>(_ key: String, nested: Bool? = nil, delimiter: String = \".\", file: StaticString = #file, function: StaticString = #function, line: UInt = #line) throws -> T {\n        let currentValue = self.currentValue(for: key, nested: nested, delimiter: delimiter)\n        guard let value = currentValue as? T else {\n            throw MapError(key: key, currentValue: currentValue, reason: \"Cannot cast to '\\(T.self)'\", file: file, function: function, line: line)\n        }\n        return value\n    }. @alexsanderkhitev you saved me...\nThanks for your solution.. @tristanhimmelman I'm facing this same issue. Apparently the SPM is downloading a version without the fix from the merging, is it possible generate a new release tag with latest changes? Please.. ",
    "tosbaha": "Try to mark your class as final and use  convenience init? in the extension.\n. I also experienced same issue with other serializers like Cereal That is why I stopped using them. I currently use some kind of proxy class to get data from original class to proxy class and then use  swift-serializer to turn object to JSON or dictionary. It doesn't support structs or have all advanced properties of mentioned libraries but it works for me.\n. ",
    "antrix1989": "+1.\n. ",
    "sbhklr": "+1\n. ",
    "palusik86": "+1 and current protocol Mappable creates some issue with Realm. I need it on extension, so I've create another \"map\" from that copies models with Mappable protocol to Realm model and back to network object. \n. ",
    "dotmike": "I see. Thanks, @tristanhimmelman. Do you recommend any other method to have the values to be wrapped in double quotes like so: [\"email\": \"user@domain.com\", \"password\": \"pass\"]? Appreciate the help and \ud83c\udf7a for the library.\n. @tristanhimmelman - the issue turns out to be a logic error on my part. Nothing to do with ObjectMapper :-)\n:+1: for the quick response. Your suggestion to add the .responseString certainly helped resolve it.\nClosing issue.\n. ",
    "jdzak": ":+1: \n. ",
    "zuziakaxel": "Great, thanks \ud83d\udcaa\n. ",
    "ed-mejia": "I'm using AlamofireObjectMapper, and I think the problem is happening over there, lets check first \nhttps://github.com/tristanhimmelman/AlamofireObjectMapper/issues/46\n. ",
    "vherrin": "Thanks for the reply!\nYes you are correct.  I was able to use a custom transformation that worked perfectly\nBelow is the snippet of code that worked for me \nswift\n    /// Transforms AnyObject to Int\n    public static let anyObjectToInt = TransformOf<Int, AnyObject>(fromJSON: { (value: AnyObject?) -> Int? in\n        // transform value from AnyObject? to Int?\n        if let x = value {\n            return Int(x as! String)\n        }\n        return nil\n        }, toJSON: { (value: Int?) -> AnyObject? in\n            // transform value from Double? to String?\n            if let value = value {\n                let any:AnyObject = value\n                return any\n            }\n            return nil\n    })\n. ",
    "elpic": "Thanks\n. @tristanhimmelman any news on this?\n. Do you remember the staff you give me to make the polymorphic staff to work:\nhttps://github.com/Hearst-DD/ObjectMapper/issues/276\nIf I can't access that value I can't make the mapping work. Please let me know if there is somthing wrong. Take a look at the example on the issue\n. @tristanhimmelman please consider the following example:\n[\n  {type: 'a', property_a: 'a'},\n  {type: 'b', property_b: 'b'}\n]\n. Thank you\n. ",
    "iTSangar": "Referenced issue: #154\nIf you need encode the object just do:\n``` swift\nclass User: NSObject, NSCoding, Mappable {\n  var id: Int!\n  var name: String!\n  var email: String!\noverride init() {}\nrequired init?(_ map: Map) {\n    super.init()\n    mapping(map)\n  }\nrequired init(coder aDecoder: NSCoder) {\n    super.init()\n    id = aDecoder.decodeObjectForKey(\"id\") as! Int\n    name = aDecoder.decodeObjectForKey(\"name\") as! String\n    email = aDecoder.decodeObjectForKey(\"email\") as! String\n  }\nfunc encodeWithCoder(aCoder: NSCoder) {\n    aCoder.encodeObject(id, forKey: \"id\")\n    aCoder.encodeObject(name, forKey: \"name\")\n    aCoder.encodeObject(email, forKey: \"email\")\n  }\nfunc mapping(map: Map) {\n    id      <- map[\"id\"]\n    name    <- map[\"name\"]\n    email   <- map[\"email\"]\n  } \n}\n```\nThis allow me transform User in NSData:\nswift\nlet saveData = NSKeyedArchiver.archivedDataWithRootObject(anyUser)\n. ",
    "borut-t": "@iTSangar Thanks for example. I've decided to try RealM database instead.\n. Yep, I've just done this.\n. @devxoul \n\n. @devxoul \n\n. @devxoul \nclass MyClass<T: Object> : Operation where T: Mappable {}\n. @tristanhimmelman, actually this is the correct syntax:\nobject = Mapper<T>().map(JSONString: data, toObject: object)\nThanks!\n. ",
    "arorajatin": "Though the issue is closed, I would still like to comment on it. The solution described above is a solution that won't scale very well. I would prefer storing JSON on disk, and then parsing it after bringing it in-memory using object mapper.\n. ",
    "jacinzhang": "@iTSangar , I have a subclass that conform NSCoding, super class WLYModel has conform Mappable, like this \n```swift\nclass WLYUser: WLYModel, NSCoding {\nvar name: String?\nvar province: String?\nvar city: String?\nvar avatar: URL?\n\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n\n    name <- map[\"nickname\"]\n    province <- map[\"province\"]\n    city <- map[\"city\"]\n    avatar <- (map[\"figureurl_qq_2\"], URLTransform())\n}\n\n// Initialization\n\nrequired init?(map: Map) {\n    super.init(map: map)\n}\n\n//MARK: NSCoding\n\nfunc encode(with aCoder: NSCoder) {\n\n}\n\nrequired init?(coder aDecoder: NSCoder) {\n    // there is wrong, I can't invoke any super init func.\n}\n\n}\n```\nso, what should I do, make super class WLYModel conform NSCoding, not form subclass?. ",
    "justbaum30": "@tristanhimmelman  The project I am working on is struggling with this same issue. We want to be able to map our immutable properties to a JSON but aren't able to. We're considering forking, but we would prefer not to do this. Especially if you have a potential solution or are considering making changes in the near future. Could you weigh in on this issue, or do you have a particular recommendation?\n. ",
    "nikita-leonov": "There are hidden section in README.md that was add before but was hidden afterward. It is answering question regarding mapping of immutable properties. Checked raw source of it for a Mapping Immutable Properties. @tristanhimmelman, I am actually curious why it was commented out from documentation? I checked commits history and was not able to find an answer. \n. Ok, I just found that valueOrFail as mentioned in some other issues. Also causing crashes in my code, so I assume it is hidden from docs on purpose.\n. I see. But what if JSON: AnyObject is actually String, but not [String: AnyObject] in current implementation? It will return nil. Is there Mapper level function that take both [String: AnyObject] or String and return Object?\n. Yes, I do have String discussed as Object. Maya currently have such method in place:\nfunc mapJSON() throws -> AnyObject {\n        do {\n            return try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments)\n        } catch {\n            throw Error.Underlying(error)\n        }\n    }\nNSJSONSerialization.JSONObjectWithData may return both String & Dictionary. It unfortunately does not work well with mapping in ObjectMapper. Anyway there is much deeper problem in ObjectMapper, which is Mappable can be reconstructed only from JSON Objects, but not from other valid JSON objects. I will likely need to find other tooling to deal with situation that I have. Thanks. \n. ",
    "iandundas": "Strange - when I implement Mappable in a class I get: Initialiser requirement 'init' can only be satisfied by arequiredinitializer in non-final class 'CheeseResource'\n. (But doesn't matter much)\n. ",
    "yamifr07": "Sorry, I put Realm instead of RealmSwift in my Pod file\n. ",
    "saifuzzafar": "{\"results\":[{\"gender\":\"female\",\"name\":{\"title\":\"ms\",\"first\":\"leana\",\"last\":\"henry\"},\"location\":{\"street\":\"3060 rue paul-duvivier\",\"city\":\"n\u00eemes\",\"state\":\"indre\",\"postcode\":94802},\"email\":\"leana.henry@example.com\",\"login\":{\"username\":\"bluefish422\",\"password\":\"cameron\",\"salt\":\"87Vty9Rx\",\"md5\":\"50e4697bda5e14a5ab9cfa2b9ebcc920\",\"sha1\":\"4bb1f967086e107b2d54ab819b12a093414fd55e\",\"sha256\":\"fd93902b1bbe660a30ef39ccb07c3b42b88c35757a4f015da505596d7ce9cec7\"},\"dob\":\"1986-04-29 01:08:51\",\"registered\":\"2012-04-05 10:41:51\",\"phone\":\"03-14-56-37-67\",\"cell\":\"06-92-24-98-22\",\"id\":{\"name\":\"INSEE\",\"value\":\"286362533442 76\"},\"picture\":{\"large\":\"https://randomuser.me/api/portraits/women/70.jpg\",\"medium\":\"https://randomuser.me/api/portraits/med/women/70.jpg\",\"thumbnail\":\"https://randomuser.me/api/portraits/thumb/women/70.jpg\"},\"nat\":\"FR\"}],\"info\":{\"seed\":\"68eb2a060c65a7b1\",\"results\":1,\"page\":1,\"version\":\"1.1\"}}\nhow i create the mapper class for this response \nright no i can't access the name dictionary i.e nested dictionaries. ",
    "adamjweaver": "I'm also seeing this. Using an array of Mappable objects as the generic type parameter seems to yield a nil result.\n. ",
    "TJRoger": "I have also encountered this nil error\n. ",
    "anas10": "@ruben-samsonyan  Maybe you should say why you're closing this issue. It may not be obvious for everyone.\n. ",
    "RabugenTom": "It needs the second case, but I don't know if it's the most elegant way.\n. ",
    "ivanbruel": "Not really a Custom transform, the case here is any property which consists of an Optional Array will default to an empty Array instead of a nil value. This does not seem to be consistent with other optional values such as Int?, String?, etc. \nOnly happens when mapping Optional Arrays with JSON which does not provide the value or comes nil.\nWithout this change any Optional Array will default to [] instead of nil.\nThis is especially important for cases where empty arrays have different meaning than just plain old empty arrays.\n. Wouldn't it be better to distinguish between a top-level call and an inner call?\nWhere the top-level call would enforce the try for the ImmutableMappable class/struct.\nThis would eliminate any kind of library limitation, where if you use ImmutableMappable you cannot use a Mappable class in the hierarchy.\nThis is especially noticeable when migrating a project into the more compiler friendly ImmutableMappable where there are no ImplicitlyUnwrappedOptionals.\n. ",
    "mpclarkson": "I'm afraid that I had to remove the library, as I couldn't find a work around.\n. ",
    "tonyli508": "Why would you do, var coordinates:Array<Array<Array<Double>>>! instead of var coordinates:Array<Double>!.\nthen in the \nswift\nfunc mapping(map: Map)  {\n      coordinates     <- map[\"coordinates.0.0\"]\n}\nI know it's not supporting toJSON array mapping yet, I have a open PR for this: https://github.com/Hearst-DD/ObjectMapper/pull/259, I don't know if they will merge that. \nBut you can always try my fork here: https://github.com/tonyli508/ObjectMapperDeep\ncocoapods: pod 'ObjectMapperDeep', '= 0.20.1'\n. I updated my PR https://github.com/Hearst-DD/ObjectMapper/pull/259, should be fixed (check func testGenericArrayMapping), you can use following cocoapod:\npod 'ObjectMapperDeep', '= 0.20.2',\nActually I think in toJSON.swift basicType function, don't need to check type at all, just let AnyObject set dictionary[key] = value should be OK. I will check this later, I believe so.\n. ",
    "IlyaRakov": "+1\n. ",
    "naeemshaikh90": "@tristanhimmelman can you mention that \"enhancement\" issue number? Are you talking about this one #368?. ",
    "popaaaandrei": "Dear Tristan, \nThank you for responding, you are too kind.\nThis is indeed what I am receiving from the server.\nAlamofire\n.request(router)\n.responseJSON(completionHandler: {\n                    response in\n                    print(response.result.value)\n                    ...\nThis is the first part of the JSON. So do you think that this a malfunctioned response?\n{\n    focusactions =     (\n                {\n            amount = 5;\n            color = \"#ff0077\";\n            current = 0;\n            duedate = \"2015-11-30\";\n            focusactionID = 92;\n            \"manual_editing\" = 0;\n            name = \"Leads x 5\";\n            percent = 0;\n            \"related_objective\" = Prospecting;\n        },\n                {\n            amount = 2;\n            color = \"#ff00e6\";\n            current = 0;\n            duedate = \"2015-11-30\";\n            focusactionID = 93;\n            \"manual_editing\" = 0;\n            name = \"Approach x 2\";\n            percent = 0;\n            \"related_objective\" = Approach;\n        },\n                {\n            amount = 10;\n            color = \"<null>\";\n            current = 0;\n            duedate = \"2015-11-30\";\n            focusactionID = 97;\n            \"manual_editing\" = 1;\n            name = \"Test ON x 10\";\n            percent = 0;\n            \"related_objective\" = \"<null>\";\n        },\n                {\n            amount = 5;\n            color = \"<null>\";\n            current = 0;\n            duedate = \"2015-12-04\";\n            focusactionID = 94;\n            \"manual_editing\" = 1;\n            name = \"Drink Coffee x 5\";\n            percent = 0;\n            \"related_objective\" = \"<null>\";\n        }\n    );\n...\n}\nThank you!\nAndrei\n. Hmm... different... :(  Maybe I should try directly using this String response.\nStill, I need to use SwiftyJSON for some custom validation.\n\"focusactions\": [\n    {\n      \"focusactionID\": \"92\",\n      \"name\": \"Leads x 5\",\n      \"amount\": \"5\",\n      \"current\": 0,\n      \"percent\": \"0\",\n      \"duedate\": \"2015-11-30\",\n      \"manual_editing\": false,\n      \"related_objective\": \"Prospecting\",\n      \"color\": \"#ff0077\"\n    },\n    {\n      \"focusactionID\": \"93\",\n      \"name\": \"Approach x 2\",\n      \"amount\": \"2\",\n      \"current\": 0,\n      \"percent\": \"0\",\n      \"duedate\": \"2015-11-30\",\n      \"manual_editing\": false,\n      \"related_objective\": \"Approach\",\n      \"color\": \"#ff00e6\"\n    },\n    {\n      \"focusactionID\": \"97\",\n      \"name\": \"Test ON x 10\",\n      \"amount\": \"10\",\n      \"current\": \"0\",\n      \"percent\": \"0\",\n      \"duedate\": \"2015-11-30\",\n      \"manual_editing\": true,\n      \"related_objective\": null,\n      \"color\": null\n    },\n    {\n      \"focusactionID\": \"94\",\n      \"name\": \"Drink Coffee x 5\",\n      \"amount\": \"5\",\n      \"current\": \"0\",\n      \"percent\": \"0\",\n      \"duedate\": \"2015-12-04\",\n      \"manual_editing\": true,\n      \"related_objective\": null,\n      \"color\": null\n    }\n  ]\n. Thank you so much for your response, I didn't see that! :8ball: \n. I was reading that Int is always Int32 or Int64 depending on the device. Is there some way that we can protect against integer overflow ?\n- Int8 -128 |||| 127\n- Int16 -32,768 |||| 32,767\n- Int32 -2,147,483,648 |||| 2,147,483,647\n- Int64 -9,223,372,036,854,775,808 |||| 9,223,372,036,854,775,807\n- UInt8 0 255\n- UInt16 0 65,535\n- UInt32 0 4,294,967,295\n- UInt64 0 18,446,744,073,709,551,615\nThank you!\n. ",
    "liuxue0905": "I'm not saying It's a class part of the \"iOS\" framework, Please Just take the master-poin, AClass we cannot (modify/change/declare final)\nThe suggestion is: Please support some way handle it in future, maybe it's not like current way to map object, \nIt will make ObjectMapper stronger \n. ",
    "hilen": "I mean if the distance key has value ,the server response will be \n\"distance\" : {\n     \"text\" : \"102 ft\",\n     \"value\" : 31\n}\nBut if its value is null or nil.The server response will be \n\"distance\" : ( )\nMy class mapper is distance.text, so how to control the key with different value type ? Will it crash ?\n. ",
    "danielborges93": "And if I have this as a root element?\njson\n{\n    \"type\": \"Some string\",\n    \"data\": [\n        {\n            \"id\": 1,\n            \"title\": \"Title1\",\n            \"description\": \"Description1\"\n        },\n        {\n            \"id\": 2,\n            \"title\": \"Title2\",\n            \"description\": \"Description2\"\n        }\n    ]\n}\nI want only the array data, returning an array of:\n``` swift\nclass MyObject: Mappable {\nvar id: Int!\nvar title: String?\nvar description: String?\n\nrequired init?(_ map: Map) {}\n\nfunc mapping(map: Map) {\n    self.id          <- map[\"id\"]\n    self.title       <- map[\"title\"]\n    self.description <- map[\"description\"]\n}\n\n}\n```\nHow do it? Thanks!\nOBS: I am using AlamofireObjectMapper\n. Solved with this:\n``` swift\nAlamofire.request(.GET, url, parameters: params)\n    .responseArray(\"data\") { (response: Response<[MyObject], NSError>) in\n}\n\n```\nThanks :)\n. ",
    "tapi": "I was going to suggest adding an object source function. I was thinking about leaving the init and using it as a default implementation for objectForMapping()\nEither way, if your adding it then that saves me from filing my last issue ;) needed something that allowed me to check a db\n. Yeah, Not sure how you'd do it with collections, objectForMapping() will probably help there.\n. Dictionaries might still be okay as the keys for a value are likely sufficient to identify which object in a collection should be updated. Arrays, sets, etc that are no referenced collections are probably not something thats doable.\n. \ud83d\udc4c\n. Well crap, I completely missed the part that includes the transform.\nWhat I'm looking for is something like \npublic func <- <T: Mappable, Transform: TransformType where Transform.Object == T>(inout left: T, right: (Map, Transform))\nWhich currently does not exist\n. Except T does not conform to Mappable in that operator ;)\n. Interesting\npublic func <- <T: Mappable, Transform: TransformType where Transform.Object == T>(inout left: T, right: (Map, Transform))\nand\npublic func <- <T: Mappable, Transform: TransformType where Transform.Object == T>(inout left: T?, right: (Map, Transform))\nare both fine but\npublic func <- <T: Mappable, Transform: TransformType where Transform.Object == T>(inout left: T!, right: (Map, Transform))\nsegfaults the compiler\n. What version of Xcode? Im running on 7.1.1\n. huh, that seemed to do the trick. \nIts implicitly unwrapped so I wonder what kind of error that crash is obscuring.\n. There is a lot of boiler plate/repetition. It's kinda too bad non-optional values aren't automatically lifted into an Optional<T> type. That and the fact that Optional<T> and ImplicitlyUnwrappedOptional<T> are two different types.\n. Or maybe types are lifted automatically and something else is causing my compiler error when I try. Because the following totally works when I toss it in a playground.\n``` swift\ninfix operator <- { associativity left precedence 40 }\n// Note we only implement the optional case\nfunc <-(lhs: T?, rhs: T?) -> String {\n    return (lhs?.description ?? \"\") + (rhs?.description ?? \"\")\n}\n// Non-Optional\nlet one = \"one\"\nlet two = \"two\"\none <- two\n// Optional\nvar three: String? = \"three\"\nvar four: String? = \"four\"\nthree <- four\n// Implicitly Unwrapped Optional\nvar five: String! = \"five\"\nvar six: String! = \"six\"\nfive <- six\n// Altogether now!\none <- two <- three <- four <- five <- six\n``\n. Ahh, its because theinoutkeyword introduces side effects. When it lifts a non-optional value into an optional one it can't be sure that your not setting the lifted non-optional tonil`.\nCould still shed some weight in the operators file\nSorry for spamming you with a running commentary of my distractions @tristanhimmelman ;)\n. Crap yeah the  argument type error is because i forgot to add \nswift\nextension String: CustomStringConvertible {\n    public var description: String { return self }\n}\nTurns out String does not conform to CustomStringConvertible and I wanted a protocol to make it as close to the existing <- definition as possible\n. And with both defined it definitely uses the non optional overload which is not awesome.\n. So I'm looking at implementing <-(lhs: Mappable, rhs:(Map, Transform) for Dictionaries, Arrays & Sets.\nIt feels like theres some potential ambiguity. For example, for dictionaries, Does it take map.currentValue as is and expect a dictionary back? or does it assume map.currentValue is a dictionary of objects that the transform should run on.\n. Thats kind of what I thought. Just felt like maybe there was a use case it excluded.\n. \ud83d\udc4d\ud83c\udffb\n. exited with 65. \ud83d\ude02\nIm fighting exactly this issue with CircleCI\n. Passed on all but one configuration, Wish I could get that kind of success with Circle ;)\n. No, problem. Mostly scratching my own itch ;)\n. I saw the syntax change in the class clusters branch but wanted to wait so as to avoid conflicts.\nI was also thinking about splitting up the files and possibly reducing each operator to a single function (without inout) to skip some of the boiler plate. Figured this was probably out of scope of this PR ;)\n. I was thinking of something like JSONAPI, but that use case is turning out to be a bit contrived. \nNot sure if you recall but we don't inline our relationships in our JSON response, instead we have a URI reference for that relation ship. Later on in the payload we include all of the related objects identified by there URI.\nAn example payload would be something like \njson\n{\n    \"teams\": [{\n        \"api_uri\": \"/dota2/teams/8\",\n        \"full_name\": \"Team Secret\",\n        \"short_name\": \"Secret\",\n        \"country\": \"International\",\n    }, {\n        \"api_uri\": \"/dota2/teams/43\",\n        \"full_name\": \"Mineski\",\n        \"short_name\": \"Mski\",\n        \"country\": \"Philippines\",\n    }],\n    \"games\": [{\n        \"api_uri\": \"/dota2/games/2723\",\n        \"game_number\": 2,\n        \"game_time\": \"33:49\",\n        \"minutes\": 33,\n        \"seconds\": 49,\n        \"status\": \"post-game\",\n        \"roshan_respawn_timer\": 269,\n        \"max_gold_advantage\": 31245,\n        \"max_xp_advantage\": 28281,\n        \"match_url\": \"/dota2/matches/1418\",\n        \"dire_team_url\": \"/dota2/teams/8\",\n        \"radiant_team_url\": \"/dota2/teams/43\",\n        \"winning_team_url\": \"/dota2/teams/8\"\n    }],\n    \"matches\": [{\n        \"api_uri\": \"/dota2/matches/1418\",\n        \"competition_label\": \"The Frankfurt Major 2015\",\n        \"start_date\": \"2015-11-17T10:00:00.000Z\",\n        \"status\": \"post-match\",\n        \"tie_match\": false,\n        \"max_games\": 3,\n        \"round_label\": \"Playoffs Upper Bracket\",\n        \"team1_score\": 2,\n        \"team2_score\": 0,\n        \"competition_url\": \"/dota2/competitions/32\",\n        \"team1_url\": \"/dota2/teams/8\",\n        \"team2_url\": \"/dota2/teams/43\",\n        \"winning_team_url\": \"/dota2/teams/8\",\n        \"current_game_url\": \"/dota2/games/2723\"\n    }]\n}\n. JSONAPI turns out to be contrived since the relationships are still dictionaries which object mapper has no problem with. In both cases though the MappableCluster.objectForMapping() is needed so that stub objects can be fully hydrated when they are encountered later in the payload.\n. In our particular case we want \"/dota2/teams/8\" to map to a dehydrated team object even though its a string and not a dictionary. Does cluster handle this case? also how would it handle collections say a team has an array of player URIs?\n. Initial test does basic JSON API Testing using the transform. Its a little contrived but it works for direct relationships and for arrays\n. Like I said it'd work great for actually mapping those relationships in but I feel like thats an exercise best left up to the reader.\n. I think I'm gonna go with an actual use case instead of the JSONAPI example? less boilerplate to come up with testable examples\n. it would certainty work, I prefer the use of the transform though, its more expressive and the equivalent of loadTeamUsingURL() would need to be written for every model thats loaded in this way resulting in a lot of duplication. It would also require a lot of manual effort to process collections.\n. Alright, I changed up the use case and came up with examples for all the operator overloads, optional and otherwise. Let me know what you think.\nThe non optional and implicitly unwrapped test cases are kinda necessarily copy pasta so maybe keep an eye out for things I may have missed\n. @devxoul To answer your question\n\nWhy would they even do that?\n\nIm currently trying to incorporate ObjectMapper into an older code base. The entry point from our old parsing into the new is necessarily nullable and so mappable made sense to me. However within the new work I had hoped to use structs and immutable properties for the relationships.\nThere was nothing in the documentation of ImmutableMappable that suggested they shouldn't be used interchangeably. \nIn fact changing property <- map[\"property_value\"] to property = (try? map.value(\"property_value\")) ?? \"\" works just fine. \nI think documentation about this would be a good start. I was caught off guard by the fact that this is a runtime issue rather than a compile time one. I think I see why, but I wonder if there isn't someway of resurfacing  the fact that <- should throw for ImmutableMappable.\nA quick test shows that an ImmutableMappable specific override that throws is caught up correctly but thats a lot of operator overloads \ud83d\ude2c. ",
    "puttin": "+1 for renaming or object source\n. ",
    "leondobnik": "Guys just one thing: the code displayed above has a bug for old devices. While 64bit devices can represent timestamp as Int, 32bit devices cannot and date is not parsed correctly (applies to iPhone5 and iPhone4) and other similar devices. So more secure code may be:\ntypealias JSON = Double\n```\nfunc transformFromJSON(value: AnyObject?) -> NSDate? {\n    if let timeInt = value as? Double {\n        return NSDate(timeIntervalSince1970: NSTimeInterval(timeInt/1000.0))\n    }\n    return nil\n}\nfunc transformToJSON(value: NSDate?) -> Double? {\n    if let date = value {\n        return Double(date.timeIntervalSince1970 * 1000.0)\n    }\n    return nil\n}\n```\n. ",
    "hajducak": "Hi guys, for switf 4 and X-Code 9.0 new version:\n```\nimport ObjectMapper\nclass MilisecondDateTransform: TransformType {\n    typealias Object = NSDate\n    typealias JSON = Double\ninit() {}\n\nfunc transformFromJSON(_ value: Any?) -> NSDate? {\n    if let timeInt = value as? Double {\n        return NSDate(timeIntervalSince1970: TimeInterval(timeInt/1000.0))\n    }\n    return nil\n}\n\nfunc transformToJSON(_ value: NSDate?) -> Double? {\n    if let date = value {\n        return Double(date.timeIntervalSince1970 * 1000.0)\n    }\n    return nil\n}\n\n}\n```. ",
    "FrancisBaileyH": "Hi @tristanhimmelman, thanks for the quick reply and excellent library. However, I'm running into an issue using that implementation. I can map an object to JSON, with  enum array type set to nil, no problem. In the JSON the value doesn't show up, as expected. However if I map from JSON to the object, then the array of enum types are set to an empty array as opposed to nil. Despite the values being mapped from, not being present. \nI have an example project to show you what I mean:\nhttps://github.com/FrancisBaileyH/ObjectMapperTestApp\nI'm not sure if this is a bug or something that I'm doing wrong, but your help is appreciated either way.\n. Hi @tristanhimmelman thanks for the update!\n. ",
    "shiyizju": "I have a model which implement 'Mappable' protocol, while inside this mode, I have an array of objects whose type is, say A. which doesn't confirm to 'Mappable'. So I use 'TransformOf' to transform my array of A, to an array of Dictionary< String, AnyObject >.\nThe code in mapping func of the model looks like\n       ....\n       myArray <- ( map[\"myArray\"], MyTransform< [A], [ [String: AnyObject] ] > )\nThe issue is that above code does't work, I have to change it to\n       ....\n       myArray <- ( map[\"myArray\"], MyTransform< [A], [ AnyObject ] > )\nThanks.\n. With Codable, I guess the variable's name must be same as json key, and every variable will be coded into json?. ",
    "ngan": "Hey @tristanhimmelman thanks for responding.\nSorry, my example was just an abstraction of what my code... and that was a typo in my example code.  I'll edit the original issue description to fix the typo, but I'm still having the issue unfortunately.\n. Turns out this was a Optimization setting problem (because I had my classes in separate files).\nhttps://developer.apple.com/swift/blog/?id=27\n. ",
    "levieggert": "Solved it.  I had another class Map causing namespace issues.\n. Yep just created. Thanks!\n. Hey sgermain06, I just went through the same thing.  \nMapper.swift has some methods for mapping to an existing object.  You would have to use those.\nI created a class to handle this for me if you'd like to check it out.  Maybe the author can implement something similar.\nEntityMapper.txt\nEntity.txt\nYou can use EntityMapper.swift to map NSManagedObjects by providing the entity name and context.  I added a MappableEntity protocol that inherits from Mappable.  So your NSManagedObjects would use the MappableEntity protocol.  Because MappableEntity is Mappable, you'd still be able to take advantage of using other Mappable methods like converting your NSManagedObject to JSON.\n. Just fixed.  Thanks ikesyo!\n. Yeah that would be great.  I need to map values for keys that exist so I don't overwrite any values with nil.\n. Ok great!\nIs it possible to include a subscript that will only map if the key exists?\nThat way there is no need to add if conditionals.  \nThis may not be possible, I am unfamiliar with using subscripts. But, my thought would be something like this.\nname <- map[\"name\", mapFlag: Map.OnlyIfKeyExists]\nCould include other flags for mapping.\n. Ok I see.  Thanks for the update!\n. ",
    "piresbruno": "thanks @tristanhimmelman and @marceloqueiroz \n. Thanks @tristanhimmelman.\nDidn't saw that use case in the documentation, is it there?\n. Again, thanks for the help!\n. @tristanhimmelman regarding this issue, is this any way to serialize the User object with the userPromotions property?\nI've tried regular toJson() in the user object, but the userPromotions doesn't get serialized.\n. Thanks for your help @tristanhimmelman \n. Thanks @tristanhimmelman, this is really what i need.\n. +1\n. @Kofktu witch version of Xcode are you running?\nI can reproduce the issue running Xcode 7.3, Swift 2.2 and an iPhone 4 running iOS 7.1.2\n. I believe this is a Swift 2.2 compatibility issue with iOS 7, just tested with an version of Object mapper that i know for a fact was running well, and i got the same crash with XCode 7.3\n. @Kofktu just did a full rollback to Xcode 7.2.1 / Swift 2.1 in my project, updated ObjectMapper to v1.1.5 and have no problems with iOS 7 anymore\n. @tristanhimmelman is ObjectMapper dropping iOS 7 compatibility?\nWith the latest release, it's still crashing when executing transformations in devices running iOS 7 and Swift 2.2 / Xcode 7.3\n. Was going to take a few hours to check if i could fix the compatibility issue with iOS 7.1, and it seems @tristanhimmelman @Kofktu, that is was automagically fixed in Xcode 7.3.1\n. ",
    "gezman": "@tristanhimmelman \nCould you please advice what you use with CoreData?\n. ",
    "raulagrait": "Agreed, this would be fantastic.\n. ",
    "grnbeagle": "@levieggert: it turns out it's designed to map only if the key exists. However, a property of optional Mappable object array was not behaving that way, so the pull request above fixed that. \nThanks for merging so promptly, @tristanhimmelman.\n. ",
    "hoangtuanfithou": "@tristanhimmelman: It is super simple that I do not think about. Thanks. I think it will work.\nIn the fact I tried to make a custom transform of ( your protocol Tranform type -> and it worked, but your suggestion is much simple)\n- anyway, just small question: should I define TranformOf using let ( as constant ) for reuse later, because I have some others like create_at.\n- and if i use TranformOf many where when parse , how much It will slow down, can you get :) (2x time or 3x time...) ( just not important question)\n- thanks for your support.\n. Thanks, and have nice weekend.\nLast question :\nIt is great we can avoid mapping function for every model that Mappable.\n- If variable name is the same with json key. -> do have to write on mapping function a_name <- a_name\n- Or the it can auto mapping with Camel style support ( like Jsonmodel or something ) aName <- a_name\nMaybe it was mentioned by other people, on other issues, I just mention again:)\nThanks.\n. > Unfortunately ObjectMapper cannot support automatic mappings based on variable names due to it's compile time nature\n@tristanhimmelman yes, I think I read it somewhere before, (maybe others explain). But no problem. Using it in my current project, and still loving it.\nThanks you and have nice Sat, nice Christmas soon.:beers: \nBye bye.\n. ",
    "j2damax": "when checking below condition toJsonString omit the id in json string, any solution for that?\nif id == nil {\n    id <- map[\"id\"]\n}\n. Hi thanks for the reply, but when do this still same issue when trying to convert object into json, it says 'RLMException', reason: 'Primary key can't be changed after an object is inserted.'\nWhat i need is when trying to convert ToJson id should be included in json string.\n. Use CGFloat instead of Float. ",
    "ivanruizscm": "theres ir a better solution other than cheking if its not set?\n. Its weird, plus i need the primary key in the json\n. @tristanhimmelman \n. ",
    "pvsilvestrin": "It works like a charm, thanks @thacilima \n. ",
    "vitovalov": "Thanks for the workarounds,\nHowever on Swift 4 it gives me this compile error: \nBinary operator '==' cannot be applied to operands of type 'MappingType' and '_'\nAnd I'm using pod branch swift-4\ncc @thacilima . ",
    "rafaelkgobara": "@vitovalov \nFor Swift 4, use:\nif map.mappingType == .toJSON. ",
    "kkizlaitis": "For those also wondering, I have come up with a slightly more elegant solution:\nswitch map.mappingType {\n    case .fromJSON:\n        id <- map[\"id\"]\n    case .toJSON:\n        id >>> map[\"id\"]\n}\n\nHere id is the primaryKey in Realm.. ",
    "itsaboutcode": "It don't work on following case\nlet user = Mapper<User>().map(JSONString)\nlet JSONString = Mapper().toJSONString(user, prettyPrint: true)\nBut it work if I do this.\nlet user = Mapper<User>().map(JSONString)\nlet theUser = User()\ntheUser.name = user.name\nlet JSONString = Mapper().toJSONString(user, prettyPrint: true)\n. ",
    "chanonly123": "let jsonString = Mapper().toJSONString([\"id1\", \"id2\", \"id3\"]) not working!. ",
    "amolgupta": "I wrote a script for this and put some basic UI to it. see http://parse-amol.rhcloud.com/\nIf people find it useful, I can take up change requests and host properly.\n. [https://github.com/Ahmed-Ali/JSONExport] is a neat tool. I have added Swift-3 support in my branch and opened a pull request[https://github.com/amolgupta/JSONExport].\n. ",
    "karnakar": "Try JSONExport [https://github.com/Ahmed-Ali/JSONExport] which is available in different languages.\n. ",
    "Ashu": "Try SwiftyJSONAccelerator \n. ",
    "paradoxally": "Create your user like this instead:\nlet user : User? = userMapper.map(userJSONString)\nYou should never assume that JSON string will be valid, i.e. don't force it to create a User object. If it's not valid, user will be nil. \nA simple check like this will solve that issue (you can use if instead if you don't want to handle the case where user is nil):\n``` swift\nguard let _ = user else {\n    // handle invalid user here\n    return\n}\n// good to go\n```\nAlternatively, print out your userJSONString or set a breakpoint at that line and inspect the variables with the debugger.\nHope this helps.\n. ",
    "NiteshKumarPal": "Thanks for reply :)\nI will take care of it.\nbut still if i get nil user how to check where is the problem, which property type we need to change as per json response ?\nAs for single nil property, we cannot nullify the whole object. Except one property other should at least be populated. That exceptional property should get its default value in this case. \n. ",
    "mamouneyya": "P.S. im:image.0 also returns the full array. :confounded: \n. You're awesome. :smiley: \nJust tried it, and I can confirm that it's really fixed. So, when will you be releasing the next version to CocoaPods, cause I really don't prefer to directly embed the library. :grin: \nThanks man!\n. Awesome. Really thanks man!\n. ",
    "Jonovono": "hehe. Figured it out \nmapArray\n. ",
    "werediver": "This should definitely be noted in the documentation (README.md)!\n. ",
    "domasn": "Great suggestion on trying out MappableCluster.\nIt does work well. I've written this simple extension for mapping to RealmSwift.Object.primaryKey:\n```\nextension MappableCluster where Self: RealmSwift.Object {\n    static func objectForMapping(map: Map) -> Mappable? {\n        guard let\n            realm = try? Realm(),\n            value: AnyObject = map.value()\n            else { return nil }\n    return realm.objectForPrimaryKey(self, key: value)\n}\n\n}\n```\nBUT it only works when json is structured to have a dictionary for object:\n\"name\": \"Fido\",\n\"owner\": { \"social_id\" : \"123\" } // Instead of \"owner_social_id\": \"123\"\nIn my case (and I guess other cases) json is flat - no Map can be created to pass to objectForMapping. Therefor, I don't think it's possible to achieve this with MappableCluster.\nAnyhow, after few hours of fiddling arround I found a great solution using TransformOf and a generic function that infers the type:\n```\n/// Transform for RealmSwift.Object from its primaryKey()\nfunc RealmPrimaryKeyTransform() -> TransformOf {\n    return TransformOf(\n        fromJSON: { (json: AnyObject?) -> T? in\n            guard let\n                type = T.self as? RealmSwift.Object.Type,\n                realm = try? Realm(),\n                value = json\n                else { return nil }\n        return realm.objectForPrimaryKey(type, key: value) as? T\n\n    },\n    toJSON: { (object: T?) -> AnyObject? in\n        guard let\n            realmObject = object as? RealmSwift.Object,\n            primaryKey = realmObject.classForCoder.primaryKey()\n            else { return nil }\n\n        return realmObject.valueForKey(primaryKey)\n})\n\n}\n```\nWith this technique it's easy to write a NumericTransform that just works. Can check it out at updated gist: https://gist.github.com/mpdomas/857d8bca815281e0ab3f\n. We use a more straightforward method.\nFirst we introduce an extension for Map that adds typedValue() function:\n``` swift\nimport ObjectMapper\nextension Mappable {\n    mutating func mapping(map: Map) {}\n}\nextension Map {\n    func typedValue()          ->  T?  { var v: T?; v <- self; return v }\n    func typedValue()          -> [T]? { var v: T?; v <- self; return v }\n    func typedValue() ->  T?  { var v: T?; v <- self; return v }\n    func typedValue() -> [T]? { var v: T?; v <- self; return v }\n}\n```\nThen our imutable variable can be initialized like so:\n``` swift\nimport ObjectMapper\nstruct Human: Mappable {\n    init?(_ map: Map) {\n        guard let\n            _name: String = map[\"name\"].typedValue(),\n            _age:  Int =    map[\"age\"] .typedValue()\n            else { return nil }\n    name = _name\n    age  = _age\n}\n\nlet name: String\nlet age:  Int\n\n}\n```\nThe only problem with this approach is when you need to support toJSON() then we add a mapping function:\n``` swift\n// Variables have to be var, not let, or even more fiddling is required\nmutating func mapping(map: Map) {\n    guard map.mappingType == .ToJSON else { return }\nname <- map[\"name\"]\nage  <- map[\"age\"]\n\n}\n```\n. ",
    "sushiwu": "YES, but i will use realm instead CoreData, because CoreData has no porpule framework with swift\n. ",
    "oktapodi": "\ud83d\udc4d\n. I'm not able to include it \n. @tristanhimmelman \nI'm using cocoa pods \n. ",
    "Laban1": "I have the same issue.  I simply used Carthage to include the project and then tried to use it:\n```\nimport Foundation\nimport ObjectMapper\nclass AdFileInfo: Mappable {\nvar fileName = \"\"\nvar checksum = \"\"\n\n// Mappable\nfunc mapping(map: Map) {\n    fileName    <- map[\"filename\"]\n    checksum    <- map[\"checksum\"]\n}\n\n}\n```\nNow my project will not build (I get a segmentation fault).\n. @tristanhimmelman, that was the issue - thanks for pointing that out!  Works fine now!\n. ",
    "younanjo": "is there a fix or workaround for this? I just installed ObjectMapper using cocopod and having imported ObjectMapper in my class trying to build the projects fails with \"Command failed due to signal: Segmentation fault: 11\". \nCompileSwift normal arm64 /Users/me/Projects/testApp/testModel.swift\n    cd /Users/me/Projects/testApp\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file /Users/me/Projects/testApp/testModel.swift  /Users/me/Library/Developer/Xcode/DerivedData/testApp-divybbujevusiwciwouqtuukfiqm/Build/Intermediates/testApp.build/Debug-iphoneos/testApp.build/Objects-normal/arm64/testModel.o -embed-bitcode-marker\n0  swift                    0x0000000107543fbb llvm::sys::PrintStackTrace(__sFILE_) + 43\n1  swift                    0x00000001075446fb SignalHandler(int) + 379\n2  libsystem_platform.dylib 0x00007fff98770eaa sigtramp + 26\n3  swift                    0x0000000105801b80 swift::Lowering::SILGenFunction::emitClassConstructorAllocator(swift::ConstructorDecl) + 1296\n4  swift                    0x000000010580a6cc swift::SILWitnessVisitor<(anonymous namespace)::SILGenConformance>::visitProtocolDecl(swift::ProtocolDecl_) + 940\n5  swift                    0x0000000105807ee5 swift::Lowering::SILGenModule::getWitnessTable(swift::ProtocolConformance_) + 277\n6  swift                    0x00000001058575b0 (anonymous namespace)::SILGenType::emitType() + 1264\n7  swift                    0x000000010585704e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl_) + 30\n8  swift                    0x00000001057dfbdb swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile_, unsigned int) + 779\n9  swift                    0x00000001057e0790 swift::SILModule::constructSIL(swift::ModuleDecl_, swift::SILOptions&, swift::FileUnit_, llvm::Optional, bool, bool) + 928\n10 swift                    0x00000001057e0b3d swift::performSILGeneration(swift::FileUnit&, swift::SILOptions&, llvm::Optional, bool) + 109\n11 swift                    0x0000000105634992 performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef, int&) + 11442\n12 swift                    0x0000000105631ad3 frontend_main(llvm::ArrayRef, char const_, void_) + 2691\n13 swift                    0x000000010562e154 main + 2324\n14 libdyld.dylib            0x00007fff8e2345ad start + 1\n15 libdyld.dylib            0x0000000000000051 start + 1910291109 \n. my bad. needed to use:\nlet objectAsDict:[String : AnyObject] = Mapper<Foo>().toJSON(myFooModel)\n. ",
    "pkasson": "New to Swift ... so why did this cause a segmentation fault without the init (mine works now too after adding) ... seems like  harsh error for omitting a constructor, and why did not identify the missing constructor ?\n. ",
    "frankus": "I'd like to :+1: support for let properties. However there are a couple of workarounds:\n- Prefix your var declarations with private (set). \n- Use a type with value semantics (a struct) instead of reference semantics (class), and assign it to a let property. note that this has some side effects that may or may not be desirable. \n. ",
    "Au12th0psav": "ths\n. ",
    "kubajakowski": "How about failing after mapping? I.e having enum property that cannot be mapped properly.\nDo I need to do something like:\ninit?(_ map: Map)\n{\n    guard let typeString = map[\"Type\"].currentValue as? String,\n          let _ = SomeEnum(rawValue: typeString) else {\n                return nil\n          }\n}\n. @tristanhimmelman that's interesting - never thought about it in this way. I think it really should be in readme.md (I mean mapping to local variable)\nThanks, and btw - great job! \n. ",
    "lgrzywac": "I have to handle similar json arrays in my app. For an array of Ints = [null, 5, null, 10] index of an element does matter - I must get value '10' using array[3] instead of array[1]\n. ",
    "andheiberg": "Really I could swear that it didn't compile without it leading me to double check the docs, then make above change and then having it compile. I would have to double check some time and give you more information.\n. Yeah I get \"Ambiguous reference to member 'toJSONString'\" until I add the type.\n. XCode 7.2 (7C68)\nSwift version 2.1.1\n. @nilswiersema well the solution is to do Mapper as I showed in the pull request.\nAs for why it isn't working as intended I have no clue.\n. ",
    "nilswxa": "Same issue here. @AndreasHeiberg, did you get it working?\n. I ended up using something along the lines of:\nswift\nfunc foo(bar: Mappable)\n{\n    let string = bar.toJSONString()\n}\nEasy answers... :smile: \n. ",
    "AnnieNinaJoyceV": "[\n{\n\"id\":\"31\",\n\"added_by\":\"451\",\n\"treatment_Id\":\"1\",\n\"medication_id\":\"0\",\n\"name\":\"TR 1\",\n\"name_slug\":\"TR-1\",\n\"provider_id\":\"91\",\n\"start_date\":\"01-19-2016\",\n\"end_date\":\"01-23-2016\",\n\"isActive\":\"true\",\n\"isCompleted\":\"false\",\n\"date_created\":\"2016-01-20 08:31:29\",\n\"date_updated\":\"0000-00-00 00:00:00\",\n\"modified_by\":\"0\"\n}\n]\nSorry for the delay in response, here is the JSON.\n. ",
    "loretoparisi": "@tristanhimmelman so the idea actually was to make this Swift project to work in a non Cocoa environment, take a look at the discussion here: http://talk.remobjects.com/t/swift-libraries-with-silver/7853/11\nI'm not sure if all these dependencies could be completely removed in order to have no Cocoa's Foundation or Darwin dependency, so a cross-platform compiler could generate multi platform binaries from this, like let's say (just and example) use Swift.Dictionary rather than Foundation class NSDictionary, etc.\n. ",
    "VLEIX": "In your podfile add\nUncomment this line to define a global platform for your project\nplatform :ios, '8.0'\nUncomment this line if you're using Swift\nuse_frameworks!\n:)\n. ",
    "achirkof": "Hi!\nI have same issue. \nswift\nimport ObjectMapper\nCannot load underlying module for 'ObjectMapper'\nIs it possible because I use platform :ios, '9.0' ? I can't use 8.0 because of dependency for another pods.\n. Error disappear after machine restarted. Restart of Xcode didn't help.\n. ",
    "zulkis": "I want to achieve next behavior:\n```\npublic protocol Fetchable : Mappable {\n    func keyPathResponseValue() -> String // To map in the dataResponses\n}\nclass FetcherResponse : Mappable {\n    var error : Error?\n    var dataResponse : T?\ninternal required init?(_ map: Map) {\n\n}\n\ninternal func mapping(map: Map) {\n    if let _ = map[\"exception\"].currentValue as? String {\n        error = Error(map)\n    } else {\n        self.dataResponse <- map\n    }\n}\n\n}\n```\nSo idea about that to just map the map to the object. But I don't have an access to the JSONDictionary and I cannot map it straightforward because currentValue is nil by default\n. I just realized that currentValue resets every time we trying to get valueForKey through subscription.\nWhy implementation was made this way not the other?\nIs it possible to set JSONDictionary as public?\nBecause it is almost impossible to get real data backing Map...\n. I tried to explain everything in https://github.com/Hearst-DD/ObjectMapper/issues/375\n. Hi @tristanhimmelman, it is a good solution, but still it is not preventing the situation with setting this dictionary from the outside(weird situation but still possible).\nActually I prefer to modify property but in that case of setting private setter/public getter - we have setValue function in ToJSON.swift that uses JSONDictionary as internal property...\nFrom my side - it is not so important how to get it :) More important to obtain this possibility, because I don't really want to fork this project(or in case of using AlamofireObjectMapper fork both)\nThank you!\n. @ikesyo, you're absolutely correct!\n. ",
    "Andr3y-": "I have exactly the same problem:\n``` swift\nimport ObjectMapper\nimport RealmSwift\nclass WRUser: Object, Mappable {\ndynamic var ID: Int = 0\ndynamic var email: String = \"\"\n\n// MARK: - Init\n\nrequired convenience init?(_ map: Map) {\n    self.init()\n}\n\nfunc mapping(map: Map) {\n    ID <- map[\"user.id\"]\n    email <- map[\"user.email\"]\n}\n\n}\n```\nActually building a project gives an error: Must call a designated initializer of the superclass \"WRUser\"\nAny thoughts?\nUPDATE: \nThe problem occurs only if I create a subclass of WRUser, say WRUserClient. As long as WRUser is a class that has no subclasses, the project compiles.\n@nashirox did you subclass?\nAny idea why does this happen?\n. ",
    "kylebegeman": "Having same issue with a subclass of another mappable object. This issue says closed but there does not appear to be a solution? \n. As a quick side note, creating a new parent class and adding the mappable property \"games\" solves this issue; however, It is preferable to not require an additional class. \n. ",
    "adipurnama": "Hi,\nI also having same error when subclassing mappable object.\nThe working solution for me is by adding init method (same as parent class)\nSo, in above case :\n```\nclass WRUserSubclass: WRUser {\nrequired convenience init?(_ map: Map) {\n    self.init()\n}\n\nfunc mapping(map: Map) {\n    // extended mapping here\n}\n\n}\n```\nHope this help\n. ",
    "aler": "I am using Mapper<Type>().map(jsonStr) I have a common func that parse api responses from a backend. Some api calls returns JSON object and some JSON array and that func has no idea what to expect.\nIs there any solution for such problem?\n. ",
    "khunshan": "I dont know how this solution will solve the array in json.\n. ",
    "Sega-Zero": "384 tries to solve this, but I'm not sure if it is possible to add Mappable conformance via extension there. I solved the immutable mapping problem with a little bit hacky, but pretty much working code:\n``` swift\n//somewhere else in code\nstruct SampleStruct {\n    let avatar: String\n    let name: String\n}\n//another swift file that gathers all models that needs to be Mappable\nextension SampleStruct: ImmutableMappable {\n    static func map(map: Map) -> SampleStruct? {\n        var mapAvatar = \"\"; mapAvatar <- map[\"avatar\"]\n        var mapName = \"\"; mapName <- map[\"name\"]\n    return SampleStruct(avatar: mapAvatar, name: mapName)\n}\n\n}\n// MARK: private boilerplate code\nprotocol ImmutableMappable {\n    static func map(map: Map) -> Self?\n}\nprivate struct MappableStub: Mappable {\n    var map: Map?\ninit?(_ map: Map) {\n}\n\n// Mappable\nmutating func mapping(map: Map) {\n    self.map = map\n}\n\n}\nextension ImmutableMappable {\n    static func mappedInstance(json: String) -> Self? {\n        guard let stub: MappableStub? = Mapper().map(json), let map = stub?.map else { return nil }\n        return self.map(map)\n    }\n}\n```\nNow all I need is call let sample = SampleStruct.mappedInstance(json)\n. ",
    "mwawrusch": "We just do a\nprivate(set) var xx....\n. ",
    "davidlawson": "@ldiqual your changes are working well for me. I also added a valueOrFail for sets:\n/// Set of Mappable objects\npublic func valueOrFail<T: Mappable>() throws -> Set<T> {\n    guard let set = Mapper<T>().mapSet(currentValue) else {\n        throw MapperError.error\n    }\n    return set\n}\n. ",
    "pocket7878": "Any updates? I want to use valueWithTransform/valueWithTransformOrFail s!\n. I found valueOrFail cause a BAD_ACCESS_ERROR when key not found.\nAnd now I think better to throw error instead of hacking type system.\n. ",
    "scottdelly": "Really cool stuff here! Thanks for this PR :)\nThe init throws part here is really cool. I'm switching over from Decodable and having non-optional values and knowing when a JSON decoding error has occurred is mission critical.\nI like Decodable's approach to the value() and valueOrFail() question. Basically when you declare a property as optional, you can assign to it using try? and that is all you need to do.\n``` Swift\nclass Base: Mappable {\n    let base: String\n    let date: NSDate\n    let nextBase: String?\ninit(_ map: Map) throws {\n    base = try map[\"base\"] //fails if missing\n    date = try map[\"date\"].valueWithTransform(DateTransform())// fails if missing\n    nextBase = try? map[\"next_base\"] // won't fail if missing\n}\n\n}\n```\nThanks guys!\n. @tristanhimmelman Any idea when this might get merged in? I'd really like to switch to ObjectMapper for decoding but my team and I are not comfortable doing that until ObjectMapper throws errors and does not return unsafe dummy values. Also, please see my response above for additional suggestion on making the code look a bit cleaner too :)\n. ",
    "hebertialmeida": "Any updates? I'd really like to switch to ObjectMapper for decoding also.\n. @tristanhimmelman Is there a documentation for immutable structs? Also will this branch be merged?\n. @tristanhimmelman Thanks, moved to Unbox (https://github.com/JohnSundell/Unbox) and Wrap (https://github.com/JohnSundell/Wrap).\n. ",
    "mapo80": "Hi,\nI need to use Immutable Struct, I've seen there's a branch for this.\nCan I use master version and try to use immutable struct?\nThanks.\n. ",
    "Tombio": "I think it should be enabled for all targets by default. In fact Apple requires bitcode to be enabled for WatchOS and tvOS apps as stated here in the Bitcode section\nHaving bitcode enabled for all targets is open for debate, but it does enable Apple to optimize binaries without need to upload new archive. In my opinion there are more upsides than downsides having bitcode enabled by default.\n. ",
    "honghaoz": "Actually, by default, ENABLE_BITCODE is not enabled for tvOS and watchOS.\nIf you go to project build settings:\n\nSwitch Enable Bitcode to NO and then YES, this will add a flag to tvOS and watchOS targets:\n\nThis is git diff after my changes:\n\nI was able to resolve those test failures on my other projects. Any thoughts? \n. Btw, using Alamofire as a subproject has no problems with BITCODE, you can verify their target settings\n. great, thanks!\n. ",
    "MugunthKumar": "I too have this problem.\nhttps://github.com/Hearst-DD/ObjectMapper/issues/374\nI have another machine running Xcode 7.2.1 on the developer seed of El Capitan and I see no problems there. I'm pretty sure this is a compiler issue.\n. I solved the Bitcode issue by updating Carthage to 0.11. Seems like if ENABLE_BITCODE is missing (because Xcode treats bitcode mandatory for tvOS and watchOS), Carthage wasn't passing the bitcode flag as a compiler arg.\n0.9.1 is the version where this fix was implemented I guess\nhttps://github.com/Carthage/Carthage/releases/tag/0.9.1\n. You are right. Adding the init? function fixes the crash. Swift compiler still doesn't point out to the right error.\nThe tvOS/watchOS stuff is compiler specific I guess. I'm closing this issue\n. ",
    "srthakkar": "Here is My class...\nclass LoginModel: Mappable {\n```\nvar FirstName: String?\nvar LastName: String?\nrequired init?(_ map: Map) {\n}\nfunc mapping(map: Map) {\n    FirstName    <- map[\"FirstName\"]\n    LastName         <- map[\"LastName\"]\n}\n```\n}\nclass User: Mappable {\n    var IsSuccess: Bool?\n    var Code: String?\n    var Message: String?\n    var Data: T?\n```\nrequired init?(_ map: Map) {\n//print( Mirror(reflecting: Data).subjectType)\nprint( Mirror(reflecting: LoginModel.self).subjectType)\n\n}\n// Mappable\nfunc mapping(map: Map) {\n    IsSuccess    <- map[\"IsSuccess\"]\n    Code         <- map[\"Code\"]\n    Message      <- map[\"Message\"]\n    Data       <- map[\"Data\",nested: false]\n}\n```\n}\nand I am calling this...\net user1 = Mapper>().map(datastring)\nI am not getting Data as LoginModel class but getting undefined property.\nMy JsonString is following.\n\"{\\\"Code\\\":\\\"200\\\",\\\"IsSuccess\\\":true,\\\"Message\\\":\\\"User authenticated successfully.\\\",\\\"Data\\\":{\\\"UserID\\\":\\\"56b49e720a351d29b0daaee4\\\",\\\"Email\\\":\\\"nisarg@mailinator.com\\\",\\\"Token\\\":\\\"4b075a7b-0d41-40ed-ac97-d125032f54e2\\\",\\\"FirstName\\\":\\\"Nisarg\\\",\\\"LastName\\\":\\\"Shah\\\",\\\"IsPhoneVerified\\\":true,\\\"MobileNumber\\\":\\\"9510861645\\\"}}\"\n. ",
    "denisbetsi": "One more thing to add, doesn't work going from String to Object either.\nError:\nType 'User' does not conform to protocol 'Mappable'\nCode:\n```\n    var jsonString:String = \"{\\\"username\\\":\\\"myusername\\\",age:23}\"\n\n    let objuser = Mapper<User>().map(jsonString)\n\n```\n. ",
    "galvezz": "That worked for me! Thanks!\n. ",
    "mariovillamizar": "I have found a temporary solution. You can create an extension of Dictionary: \nextension Dictionary {\n    mutating func merge(with: Dictionary) {\n        for (k, v) in dict {\n            updateValue(v, forKey: k)\n        }\n    }\n}\nThen you can use your objects as JSONs to merge them, for example:\n```\nvar user1 = User()\nuser1.name = \"Mario\"\nvar user2 = User()\nuser2.name = \"Pedro\"\nuser2.email = \"pedro@test.com\"\nvar user1JSON = user1.toJSON()\nvar user2JSON = user2.toJSON()\nuser1JSON.merge(with: user2JSON)\nprint(user1JSON)\n```\nResult of print = [\"name\": \"Pedro\", \"email\": \"pedro@test.com\"]. @lujing666208 can you explain me a little more?\n. ",
    "Dodig": "@tristanhimmelman if you don't know Firebase you can check this: Firebase features :wink: \n\nFirebase Realtime Database\n Data in your Firebase database is stored as JSON and synchronized in realtime to every connected client. When you build cross-platform apps with our Android, iOS, and JavaScript SDKs, all of your clients share one Firebase database and automatically receive updates with the newest data.\n\nWith Firebase we manage NSDictionary and NSArray that I need to map to internal classes.\nCan I use ObjectMapper for that?\n. Thanks :smile: \n. ",
    "fractalzombie": "I'm interesting the same thing.\n. ",
    "TofPlay": "Found it! \ud83d\ude00\nExample with an Array of users\nJson\nImport this Json at https://<your db>.firebaseio.com/Users\nReplace <your db> by your database\njson\n{\n  \"Users\": [\n    {\n      \"firstName\": \"Paul\",\n      \"lastName\": \"Dumont\"\n    },\n    {\n      \"firstName\": \"Jacque\",\n      \"lastName\": \"Zero\"\n    },\n    {\n      \"firstName\": \"Marc\",\n      \"lastName\": \"Longshot\"\n    }\n  ]\n}\nObjectMapper class\n``` swift\nimport Foundation\nimport ObjectMapper\nclass User: Mappable {\nvar firstName:String? = nil\n  var lastName:String? = nil\nrequired init?(_ pMap: Map){\n  }\nfunc mapping(pMap: Map) {\n    self.firstName  <- pMap[\"firstName\"]\n    self.lastName   <- pMap[\"lastName\"]\n  }\n}\n```\nView Controller\nReplace <your db> by your database name\n``` swift\nimport UIKit\nimport Firebase\nimport ObjectMapper\nclass FirebaseViewController: UIViewController {\noverride func viewDidLoad() {\n      super.viewDidLoad()\n  let lUsers = Firebase(url: \"https://<your db>.firebaseio.com/Users\")\n\n  lUsers.observeEventType(.Value) {\n    (pSnapshot:FDataSnapshot!) -> Void in\n\n    if let lJsonArray = pSnapshot.value as? [[String : AnyObject]] {\n      let lUsers = Mapper<User>().mapArray(lJsonArray)\n      print(\"\\(lUsers)\")\n    }\n  }\n\n}\n}\n```\nDebug view\n\n. I used the version of Xcode 8.1 GM build 8T61a. With the final Xcode 8.1 Build 8B62 it works.\n. ",
    "omarzl": "Maybe this is helpful to someone, I ended up creating a mix of many resources on the Internet.\nThis is the base class:\n`\n    import UIKit\n    import Firebase\n```\nclass FIRDataObject: NSObject {\nvar snapshot: FIRDataSnapshot!\nvar key: String { return snapshot.key }\nvar ref: FIRDatabaseReference { return snapshot.ref }\nrequired init(_ snapshot: FIRDataSnapshot) {\n    super.init()\n    self.snapshot = snapshot\n    for child in snapshot.children {\n        if respondsToSelector(Selector(child.key)) {\n            setValue(child.value, forKey: child.key)\n        }\n    }\n    load()\n}\nfunc load(){\n// retrieve the properties via the class_copyPropertyList function\nvar count: UInt32 = 0;\nlet myClass: AnyClass = self.classForCoder;\nlet properties = class_copyPropertyList(myClass, &count)\n\n// iterate each objc_property_t struct\nfor i:UInt32 in 0..<count{\n    let property = properties[Int(i)]\n\n    // retrieve the property name by calling property_getName function\n    let cname = property_getName(property)\n\n    // covert the c string into a Swift string\n    if let name = String.fromCString(cname){\n        if let value=snapshot.value!.valueForKey(name){\n            self.setValue(value, forKey: name)\n        }\n    }\n}\n// release objc_property_t structs\nfree(properties);\n\n}\nfunc save(){\n    var dicc=String:AnyObject\n// retrieve the properties via the class_copyPropertyList function\nvar count: UInt32 = 0;\nlet myClass: AnyClass = self.classForCoder;\nlet properties = class_copyPropertyList(myClass, &count)\n\n// iterate each objc_property_t struct\nfor i:UInt32 in 0..<count{\n    let property = properties[Int(i)]\n\n    // retrieve the property name by calling property_getName function\n    let cname = property_getName(property)\n\n    // covert the c string into a Swift string\n    if let name = String.fromCString(cname){\n\n        let value=self.valueForKey(name)\n        dicc[name]=value\n    }\n}\nref.setValue(dicc)\n\n// release objc_property_t structs\nfree(properties);\n\n}\n```\n}\nprotocol FIRDatabaseReferenceable {\n    var ref: FIRDatabaseReference { get }\n}\nextension FIRDatabaseReferenceable {\n    var ref: FIRDatabaseReference {\n        return FIRDatabase.database().reference()\n    }\n}\n`\nyou only need to inherit from it:\n`\nclass User: FIRDataObject {\nvar name=\"\"\nvar username=\"\"\nvar amigos=[String:Bool]()\n}\n`\nand an example of use:\nref.child(\"users\").child(user.uid).observeSingleEventOfType(.Value, withBlock: { (snapshot) in\n                let user=User(snapshot)\n                user.username=\"Demo\"\n                user.amigos[user.key]=true\n                user.save()\n            })\n. ",
    "callam": "@omarzl nice code you got there\n. ",
    "Jasonchan91": "nice sharing. ",
    "choioi": "Very thanks ! . //data is result from Alamofire\nlet  dataJSON = data.value(forKeyPath: \"data\") as? [Dictionary] ?? []\nlet imageModelArray = Mapper().mapArray(JSONArray: dataJSON). Change model from class to struct will be fixed this leak . . ",
    "piv199": "@omarzl great way to deal with mapping. ",
    "Ankish": "Is there any way we can convert firebase snapshot object to raw json ? Then it could be easy to convert to this. Anythoughts ? Would like to if anyone has searlized snapshot object to JSON and using the mapper - are there any underlying implications of it ?. ",
    "fcerdeiral": "Hi @tristanhimmelman, I'm glad you like it,  thanks. We use this library all the time and this change is key for us.\nYou need the flag isKeyPresent in order to tell if the value was present in the JSON or if it was missing. When the value is present and it's nil you can't tell by just setting the value to nil because it's ambiguous.\nSo when're about to map the properties and you see a nil value, without this flag it's impossible to differentiate between both scenarios.\n. yes.. I can add unit tests as well, np\n. Hey @tristanhimmelman,\nI just reverted the change you asked and also added unit tests for this new functionality.\nI think we should also update the minor version of it since we added some considerable changes to its behavior on some edge cases, but I did not put the version change on this pull request because I figure you'd want to do this on a separate commit.\n. Thanks @tristanhimmelman \n. absolutely.. I'll revert it and check my tests tonight.\n. ",
    "jbmaxwell": "I don't understand this implementation; why would we set default values when the init is passed the Map as an argument? Wouldn't it make sense to just get the objects from map?\n[EDIT: Does it run \"mapping\" after the init? ]. Is this actually fixed? My partner (who does the backend stuff) tried building for Linux the other day and it failed with similar errors. I'd really love to know the state of this, because I've been trying to work with other JSON solutions and they're no where near as simple (but I need Linux support)!. ",
    "majorgilles": "Ok, thanks a lot, will try asap\n. ",
    "robertomg": "Okay, I have found that MappableCluster (which is not yet documented) implements this feature. I am closing this issue.\n. ",
    "pixelogik": "Hey, thanks! \nI try to understand the patterns here. This means if I have N fields that need to be there, I need N checks in the initializer and the N <- in the mapping() method right? \nIn our projects the JSON responses of APIs have two kind of fields: Optional and non-optional. And most fields are non-optional. That's why for us having this implicitly in there is really helpful, reduces the code of model classes about 40-50%. I just wonder, why the implicitly unwrapped optional should ever be allowed to be nil in the returned objects. Does this not force the user code to always check against nil? What if the API changes or has issues? In that case the app would crash if no nil checks are done. And if nil checks are mandatory, then everything could be optional. Am I missing something? \nThanks for the framework btw, it is freaking awesome! :D \n. Ok I looked more into this and realized that this is not possible. \nWhen you support non-optional properties, you have to have a default-value mechanism so that all properties get a value assigned in the constructor, which potentially also means that you have to specify the fromJSON mapping on the constructor and the toJSON mapping in an additional function. We do this in our APILayer framework. \nOR\nYou only support optionals, which gives you the freedom to NOT initialize properties in the constructor, thus enabling the one function that defines both toJSON and fromJSON mappings (like ObjectMapper is doing it).\nThere is unfortunately currently no perfect solution because in Swift all non-optional properties need to be defined in the constructor - which is what we expect and like of course. Even working with exceptions in the constructor does not help, the non-optional properties still need to be defined before the throw. So without default values being assigned this does not work either. \nWe will go with our existing model in APILayer because to us non-optionals are more important than the toJSON mapping. Most of our entities are not send back to the API so if we need that we just add a serialisation method to the entity, something like toDict(). \n. ",
    "rwichmann": "+1\n. ",
    "dillonykyang": "Closing the issue. This is supported in an undocumented class, ClusterMapper.\n. ",
    "bargar": "@tristanhimmelman big thanks for this tip! . @hsncr i had good results with the approach mentioned in #414 . ",
    "dac09": "Hi @ehuynh did you manage to resolve this issue? I'm seeing the same problem. ",
    "ehuynh": "yeah turns out i just forgot to import the framework in my test target. ",
    "Schaltfehler": "Sorry, I will wait till Xcode7.3 is released. \nThe Swift version on  Xcode 7.2 is using doesn't know associatedtype.\n. ",
    "Kofktu": "@piresbruno i got the same crash with XCode 7.3\n. ",
    "abstnc": "No other product class or namespace in my project folders. I cant set any Mappable class.\nLike this,\n`import Foundation\nimport ObjectMapper\nclass Tag:Mappable {\n```\nvar id:Int = 0\nvar name:String = \"\"\nvar url:String = \"\"\ninit(){\n}\nrequired init?(_ map: Map) {\n}\nfunc mapping(map: Map){\n    id                  <- map[\"id\"]\n    name                <- map[\"name\"]\n    url                 <- map[\"url\"]\n}\n```\n}`\n. I do not use Cocoapods or Carthage. \nI manually added to the project objectmapper-1.1.5.\n. ",
    "kunj369": "I have same issue. Please solve asap.\nThank you.\n. ",
    "caranf": "Me too\n. ",
    "HarriesChen": "yes , I still have this problem , I use \nself.desc <- map[\"description\"]\nin the map method\nwhen I use NSManagedObject changedValue, I get the dict \n```\n{\n'desc':'xxxxxxx'\n}\n```\nbut I should use the origin key description to tell the server  like this\n```\n{\n'description':'xxxxxxx'\n}\n```\nthis is my problem,can you understand what I meaning, O(\u2229_\u2229)O \n. ",
    "NALAWALAMURTUZA": "Thank For Reply....\n. ",
    "veeranjain04": "I am facing this issue despite of using toJSONString function. ",
    "dimala": "I faced the problem when error message could be at \"message\" or \"error.message\" keypath. \nAlso, don't ask me why :), error message could be at \"error\" keypath, which in my case shouldn't be mapped, but it will be because of \"error.message\". Mapper checks if value is a dictionary or an array and if it's not, it returns value at \"error\" keypath (in my situation it is String), but i expect nil from \"error.message\".\nSee the following code:\n```\n    var possibleMessage: String = \"\"\n    possibleMessage <- map[\"message\"]\nvar possibleMessage2: String? = \"\"\npossibleMessage2 <- map[\"error.message\"]\n\nmessage = [possibleMessage, possibleMessage2 ?? \"\"]\n    .filter { $0.length > 0 }\n    .joinWithSeparator(\"\\n\")\n\n```\nif json will be { error = \"some_text\" } then message will be equal \"some_text\", but as you can see in code above there is no \"error\" keypath defined in map. Thats why it would be good to have ability to force mapping to get value from full keypath but not from some part of it.\nmap[\"error.message\", nested: true] do the same as map[\"error.message\"].\n. ",
    "jperera84": "Disregard this issue, was my problem at the moment so create the object.\nThank you.\n. Thanks @cristiansimioni I appreciate your help, I installed but I got the following error when I compile the project:\n/Users/jperera/Documents/GitRepository/MySecurityAccount/MySecurityAccount/Contact.swift:10:8: Module file was created by an older version of the compiler; rebuild 'ObjectMapper' and try again: /Users/jperera/Library/Developer/Xcode/DerivedData/MySecurityAccount-cgpdohozsvhpevhjubironbdencq/Build/Products/Debug-iphonesimulator/ObjectMapper.framework/Modules/ObjectMapper.swiftmodule/x86_64.swiftmodule\nAny idea of this?\n. ",
    "daffodilistic": "Hello,\nI gave the latest version a whirl, and it's working fine on my project, resulting in cleaner code. Seems pretty nifty. \ud83d\ude03\n. ",
    "nitisha1": "@kylebegeman -i'm facing same issue with  json array of count 135000.i added generic class to map array but still there are so many memory leaks.would you please share a sample code of parent class. how did you map? . ",
    "hwpo": "@kylebegeman Er..finally,i have resolved the problem like this \u2b07\ufe0f\n`class getUserDetailResult:BaseResult{\n    var user:User?\n```\nrequired init?(_ map: Map) {\n    super.init(map)\n}\noverride func mapping(map: Map) {\n    super.mapping(map)\nuser <- map[\"data\"]\n\n}\n```\n}`\n. ",
    "catach": "Hi @tristanhimmelman !\nI think I've a real unnamed array :) \nHow should I map a variable array like [\"1\", \"2\", \"3\"]? Do I need to create a Mappable class to embed the String? If so, what's the field name?\n. @tristanhimmelman it's the complete response \ud83d\ude04 and you're completely right. I used responseJSON from Alamofire and just assigned the result to my String array, as you said. Sometimes we get too obsessed on \"serialize all the things\" hehehe. Thanks \ud83d\udc4d \n. ",
    "patchthecode": "Thank you!.\nClosing this.\n. The MyStruct structure var called twoCombinedVals which is a struct of the combination of 2 json values on the same level. Is there a way to combine those?\n. Of maybe i should say.\nIs there a way to pass the map unto a value like i did above?\ntwoCombinedVals <- map\nI want map here to refer to the same map \"level\" and not a subLevel\nOr is there a way to refer to the same map? without going to a sublevel\n. This is what i have done in the mean time, but i would still need help to tell me how it should really be done.\nI have modified the following private method to allow this let map[\"\"] return the current map:\n``` swift\n/// Fetch value from JSON dictionary, loop through keyPathComponents until we reach the desired object\nprivate func valueFor(keyPathComponents: ArraySlice, dictionary: [String: AnyObject]) -> AnyObject? {\n    // Implement it as a tail recursive function.\n    if keyPathComponents.isEmpty {\n        return nil\n    }\nif let keyPath = keyPathComponents.first {\n    let object: AnyObject?\n    // MODIFIED TEXT STARTS HERE\n    if keyPath == \"\" {\n        object = dictionary\n    } else {\n         object = dictionary[keyPath]\n    }\n // MODIFIED TEXT END HERE\n    if object is NSNull {\n        return nil\n    } else if let dict = object as? [String : AnyObject] where keyPathComponents.count > 1 {\n        let tail = keyPathComponents.dropFirst()\n        return valueFor(tail, dictionary: dict)\n    } else if let array = object as? [AnyObject] where keyPathComponents.count > 1 {\n        let tail = keyPathComponents.dropFirst()\n        return valueFor(tail, dictionary: array)\n    } else {\n        return object\n    }\n}\n\nreturn nil\n\n}\n```\n. yes. it is.\nThe struct that you want it to be mapped to, what does it look like?\n. What i mean is, can you show what you want the structure that you want the JSON be mapped to look like?\nstruct MyEventPlacesStruct {\n   ????\n}\n. @tristanhimmelman hi, is there any documentation giving an example of how those methods are used?\n. ",
    "dsrees": "For the future traveler, above is a dead link. Here is an updated one\nThe skinny of it is that you must pass an EnumTransform<T> to your map\nmimeType <- (map[\"mime_type\"], EnumTransform<MimeType>()). ",
    "namanhams": "You can do this : \nfunc mapping(map: Map) {\n        twoCombinedVals.val1 <- map[\"key1\"]\n        twoCombinedVals.val2 <- map[\"key2\"]\n        val3 <- map[\"key3\"]\n    }\n. Sorry i don't know how to format the code here\n. Can you post the line of code that you use ObjectMapper to parse ? \nThe Instruments shows where the leak object is created. It doesn't show that this leak is caused by ObjectMapper. It could be you keep a strong reference to the parsed result somewhere. \n. I think that looks very clean. Awesome !\n. May be you can post some code here ? \n. It's clearly the date format returned from your server is not \"yyyy-MM-dd\"\n. @gmansata6290 : what formats have you tried ? Clearly \"yyyy-MM-dd\" will not parse \"Fri May 13 2016\"\n. @gmansata6290 : you need to refer to this http://waracle.net/iphone-nsdateformatter-date-formatting-table/\nIn your case, Fri is EEE, May is MMM, 13 is dd, 2016 is YYYY, and so on\nSo the format string should be : \"EEE MMM dd YYYY .....\" \nMy suggestion for you, is to create a test function, try with a simple string first (Eg, \"Fri May 13 2016 18:30:05\", try until your date formatter works correctly, and then slowly make the string more complicated\n. ",
    "buscarini": "I have more or less the same problem, but with an associated enum. I can use map.JSON to parse what I need, but then I can't serialize the JSON back. Is there any way to do that? . ",
    "tomaszwojcik": "I would like to get a list of Places that contains a list of all events, something like this:\nPlaceList -> array of places\nPlace -> place_id, array of events\nEvent -> date (from the timestamp that is problematic for me), event_name, other_event_field\nThanks for the quick response.\n. Sure.\n```\nstruct PlaceEvents {\n    var placeId: Int\n    var events: [Event]\n}\nstruct Event {\n    var date: NSDate\n    var name: String\n    var otherField: String // for the sake of this example. I can handle all other fields except the date thing in the json format\n}\n```\nAny my API should return [PlaceEvents] (for multiple places).\n. ",
    "ajaybeniwal": "Sorry My Mistake Paging object was not array closing it\n. ",
    "JamesZeinzu": "+1, looks like at the moment you cant have non optional properties, or at least I cant figure out how to have them as optional. The examples all have optional or explicitly unwrapped(var id: String!) properties. If someone more experienced could shed some light on this it would be appreciated :)\n. ",
    "jsgoupil": "@tristanhimmelman That looks great! Awesome \ud83d\udc4d \n. I have found the same problem and opened the bug right here:\nhttps://github.com/Hearst-DD/ObjectMapper/issues/636\n. ",
    "hellohelloye": "The reason this issue happens is because subscript has been overloaded. \n. ",
    "ofirdagan": "+1\n. I upgraded my xcode and it solved the issue.\n. ",
    "guitcastro": "As workaround I used this, in case anyone need to serialize let properties:\n```\nfunc mapping(map: Map)  {\n        // force map\n        var id: = self.id\n        id <- map[\"id\"]\n    self.source <- map[\"source\"]\n    self.subgroup <- map[\"subgroup\"]\n    self.image_url <- map[\"image_url\"]\n    self.tags <- map[\"tags\"]\n    self.user_alternative_id <- map[\"user_alternative_id\"]\n}\n\n```\n. @jonasman Can you please elaborate why?. ",
    "at-daonguyen": "I think there are many users still need null value instead nil.\nOr please provide a option to check currentKey is exist in JSONDictionary.\n. ",
    "zendobk": "I have a workaround with Map.isKeyPresent flag, hope this help.\n. Hope this help. Sorry about the syntax because I write this with SublimeText.\n```\nclass Device: Mappable {\n    func mapping(map: Map) {\n        name <- map[\"name\"]\n        online <- map[\"online\"]\n    }\n}\nclass DeviceListTransform: TransformType {\n    typealias Object = [Device]\n    typealias JSON = [String: [String: AnyObject]]\nfunc transformFromJSON(value: AnyObject?) -> Object? {\n    guard let json = value as? JSON else { return nil }\n    var devices: Object = []\n    for key in json.allKeys {\n        let device = Device()\n        device.id = key\n        let info = json[key]\n        Mapper<Device>().map(info, toObject: device)\n        devices.append(device)\n    }\n    return devices\n}\n\nfunc transformToJSON(value: Object?) -> JSON? {\n    // TODO\n    return nil\n}\n\n}\n```\nImplement in other mapping:\nclass User: Mappable {\n    func mapping(map: Map) {\n        devices <- (map[\"devices\"], DeviceListTransform())\n    }\n}\nor get the devices only:\nlet devices = DeviceListTransform().transformFromJSON(jsonDevices)\n. - Did you try using <- operator?\n- After that, moving all binding to the mapping func, excect id.\n. Can you change let to var and set a default value for them?\nIf you want to protect setter, just change to private(set) var\n. Please check this release.\nThe attribute will be set to nil if JSON value is null.\n. @Stjng poor you, kaka\n. ",
    "LakhV": "Is it possible to have global option in the framework or on Mapper level?\n. ",
    "tarangpatel": "When will the ignore-nil-option available in master ? I need this feature but cant get it to work. Any work around until its available ? Thanks \n. Awesome. thank you. \n. I tried to pod update but the pod is not showing latest changes. \nAny idea ? \n. oh ok. I will have to wait for the new release then. \n. ",
    "gmansata6290": "Below is  my Model Class\nimport UIKit\nimport ObjectMapper\nclass Model: NSObject, Mappable\n{\n    var posted_on : NSDate!\n    override init()\n    {\n        super.init()\n    }\n    convenience required init?(_ map: Map) \n    {\n        self.init()\n    }\nfunc mapping(map: Map)\n{\n    let dateFormatter = NSDateFormatter()\n    dateFormatter.dateFormat = \"yyyy-MM-dd\"\n    dateFormatter.timeZone = NSTimeZone(name: \"UTC\")\n    posted_on <- (map[\"posted_on\"], DateFormatterTransform(dateFormatter: dateFormatter))\n}\n}\nwhile gettting the response from the server end \nlet allModel =  Mapper().map(responseJSON.rawString()!)\ni am using SwiftyJSON for JSON response and from JSON converting to raw string. and then mapping from raw string to my Model\nall the other data is getting mapped with my model but posted_on coming as nil\n. In the sample I have shown you that way. But I tried all other format also using the above technique. But It was not working as expected. even I tried below also.\nvar dateFormatter = NSDateFormatter()\n dateFormatter.locale = NSLocale(localeIdentifier: \"en_US_POSIX\")\n dateFormatter.timeZone = NSTimeZone(abbreviation: \"GMT\")\n dateFormatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" etc.\n. @namanhams: I was more playing around with \"yyyy-MM-dd'T'HH:mm:ss.SSZ\" and I also used ISO8601Datetransform but it didnt work for me. I not so expert in this. Is it possible for you to guide me how can I parse (Fri May 13 2016 18:30:05 GMT+0800 (SGT)) date format?\n. @namanhams : Thank you so much for your support. I will surely work on the guidelines that you have provided.\n. ",
    "jpmcglone": "Ok, so I figured out that every subclass (we have many) needs to have these requireds\nswift\n    // MARK: - Requireds\n    required init() { super.init() }\n    required init?(_ map: Map) { super.init() }\n    required init(value: AnyObject, schema: RLMSchema) { super.init(value: value, schema: schema) }\n    required init(realm: RLMRealm, schema: RLMObjectSchema) { super.init(realm: realm, schema: schema) }\nI get this is probably more a swift question now, and not a realm or objectmapper question, but can someone explain to me why I need to do this in every subclass? Or is there a way to get it from super?  Calling only super.init on everything makes little sense\n. Thanks! I will try this. If it works, you just made the code look 1000x cleaner.\n. Well damn.  Initializer requirement 'init' can only be satisfied by arequiredinitializer in non-final class 'Base'\n. Unrelated: it's nice to meet a fellow JP.\n. We're still just adding the required inits unfortunately. At least I can make it a copy paste solution that goes at the bottom (or top) of the file.  /shrug\n. I'll try it some time this week @tristanhimmelman \n. Bump. Can someone please work with me on this? I need these Transforms to work. They worked fine in past projects, but I can't get it to work now. I must be doing something really simple but stupid. . ",
    "jpsim": "This shouldn't be necessary if you remove the required from the required convenience init?(_ map: Map) declaration.\n. ",
    "liuxuleidota": "Should  subclass add an initializer? \neg. required convenience init?(_ map: Map) {\n        self.init()\n    }\nSince I got a build error without doing that. \nmust call a designated initializer of the superclass\n. ",
    "robbiet480": "Any updates on this? Hitting the same error that @jpmcglone was getting about Initializer requirement...\n. @maasim94 Just tried your code and got this error:\n<unknown>:0: error: must call a designated initializer of the superclass 'Entity'\n/Users/robbiet480/Repos/HomeAssistant/HomeAssistant/Entity.swift:77:26: note: convenience initializer is declared here\n    required convenience init?(_ map: Map) {\n. Can the 1.5.0 changes be merged into the Swift 3 branch?\n. Whoops, didn't notice, just saw the merge commit. Thanks @tristanhimmelman! I plan to test this out at some point today and will report back.\n. @tristanhimmelman Looks like this change may have broken AlamofireObjectMapper. \n\nIf you are going to go fix that, I'd suggest that https://github.com/tristanhimmelman/AlamofireObjectMapper/pull/137 gets merged beforehand to fix the Alamofire class renaming that occurred in the last few days. \n. @tristanhimmelman Had to make another change to get it working, see https://github.com/tristanhimmelman/AlamofireObjectMapper/pull/143\n. @tristanhimmelman I still need to keep the required inits in. Otherwise I get fixable errors that they are missing. So it appears StaticMappable didn't change anything :(\n. @tristanhimmelman I got it working! It's because I had a custom init function I wrote in my base Entity class. Once I removed that everything worked. Thanks!\n. swift\nstatic func objectForMapping(map: Map) -> BaseMappable? {\n    return Parent()\n}\nMy understanding is that objectForMapping should be inspecting the incoming map and determining what child class the object should be and then returning that class.\n. Assuming that you have a JSON string, you should be able to fix the issue by changing to this:\nswift\nlet branch = Mapper<Branch>().map(JSONString: obj.1.rawString()!)\n. ",
    "maasim94": "I have exact same error following help me to solve it, i'm not sure if it is correct way but it solves my problem\nbasically i don't call super.init in child class\n//Base class\nclass CookJson:Object, Mappable {\n    dynamic var cookID:Int = 0\n    dynamic var cuts_id:Int = 0\n    dynamic var doneness:String = \"\"\n    dynamic var duration:String = \"\"\n    dynamic var tempreature:String = \"\"\n    override class func primaryKey() -> String {\n        return \"cookID\"\n    }\n    required convenience init?( map: Map) {\n        self.init()\n    }\n    func mapping(map: Map) {\n        cookID <- map[\"id\"]\n        cuts_id <- map[\"cuts_id\"]\n        doneness <- map[\"doneness\"]\n        duration <- map[\"duration\"]\n        tempreature <- map[\"tempreature\"]\n    }\n}\n//Child class\nclass CookbyWeightJson:CookJson {\n    dynamic var high_weight:String = \"\"\n    dynamic var low_weight:String = \"\"\n    required convenience init?( map: Map) {\n        self.init()\n    }\n    override func mapping(map: Map) {\n        super.mapping(map)\n        high_weight <- (map[\"high_weight\"])\n        low_weight <- map[\"low_weight\"]\n    }\n}\n. @viral-etymon i think [MyItem] , becomes Array of My item and array don't confirm to Mappable, MyItem does, but there must be some way to get either object or array of objects\n@bdrelling  I'm using same thing but i feel it's redundant, let's hope something better comes out of our discussion here\n. ",
    "chrixrux": "Any updates on this topic? I'm getting the same error as @robbiet480 \n. ",
    "MadeByDouglas": "Anyone find a clean solution to this?\n. ok, looks like ill do that too then, cant find a better alternative\n. ",
    "mitchtreece": "@tristanhimmelman Still trying to get this working with Realm. I'm using StaticMappable like this:\n``` swift\nclass Parent: Object, StaticMappable {\ndynamic var uid: String = \"\"\n\nstatic func objectForMapping(map: Map) -> BaseMappable? {\n    return Parent()\n}\n\nfunc mapping(map: Map) {\n    uid <- map[\"uid\"]\n}\n\n}\nclass Child: Parent {\ndynamic var name: String = \"\"\n\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n    name <- map[\"name\"]\n}\n\n}\n```\nEverything compiles fine, but mapping these objects fails. After some stepping around, I found that when calling map(), this code in Mappable.swift cannot grab the object. It just returns nil.\n``` swift\n...\nif var object = klass.objectForMapping(map: map) as? N {\n    object.mapping(map: map)\n    return object\n}\n```\nAny ideas?\n. @robbiet480 Is that the only way? What if the JSON I'm getting is generic (no \"type\" property).\n. @tristanhimmelman Wow I can't believed I missed that. That's exactly what I needed. Thank you \ud83d\ude04 \n. ",
    "vincentSuwenliang": "```\nclass RegisteredService: Object, StaticMappable {\n    dynamic var service_id: Int = 0\n    dynamic var client_id: Int = 0\n    dynamic var expiry_date: Date?\nclass func objectForMapping(map: Map) -> BaseMappable? {\n    return TableShared_Time()\n}\n\nfunc mapping(map: Map) {\n\n    service_id <- map[\"service_id\"]\n    client_id <- map[\"client_id\"]\n    expiry_date <- (map[\"expiry_date\"], YMDDateTransform())\n\n}\n\n}\nclass TableShared_Time: Object, Mappable {\n    dynamic var creation_time: Date?\n    dynamic var last_update_time: Date?\n    dynamic var visible: Bool = true\nrequired convenience init?(map: Map) {\n    self.init()\n}\n\nfunc mapping(map: Map) {\n    creation_time <- (map[\"creation_time\"], YMDTimeDateTransform())\n    last_update_time <- (map[\"last_update_time\"], YMDTimeDateTransform())\n    visible <- (map[\"visible\"], BoolTransform())\n}\n\n}\n```\n\nhi, could you please help me to find out the solution of this error? Use StaticMapple solved the init problem, but can not access the son's property when get response. please give me some advice, anybody, appreciate. ",
    "pcwang0205": "slove\n. ",
    "mcblakeb": "Excellent, that's exactly what I needed. The updated and working code looks as follows: \n```\nclass MapManagedObjectContext : MapContext {\n    var ctx: NSManagedObjectContext\ninit(context ctx: NSManagedObjectContext) {\n    self.ctx = ctx\n}\n\n}\n```\nrequired init?(_ map: Map) {\n        var context: MapManagedObjectContext?\n        if let _context = map.context as? MapManagedObjectContext  {\n            context = _context\n        } else {\n            context = MapManagedObjectContext(context: NSManagedObjectContext.MR_defaultContext())\n        }\n        // This will throw an exception if context is null, that's ok, it should.\n        let entity = NSEntityDescription.entityForName(\"ReportTemplate\", inManagedObjectContext: context!.ctx)\n        super.init(entity: entity!, insertIntoManagedObjectContext: context!.ctx)\n        mapping(map)\n}\nAnd finally: \nfor (_, subJson) in response.data![\"Result\"] {    \n    let ctx = MapManagedObjectContext(context: context)\n    let tmp = Mapper<ReportTemplate>(context: ctx).map(subJson.dictionaryObject)\n    print(tmp)\n}\n. ",
    "sregg": "@tristanhimmelman can you use nested objects in objectForMapping?\nlike: map[\"parent.child\"].value(). ",
    "gbmksquare": "I have the same problem.\nCurrently I'm trying the following workaround. I wonder if you have any other ideas until the problem is fixed?\n``` Swift\nclass MyObject: Object, Mappable {\n    let tags = List()\nrequired convenience init?(_ map: Map) { self.init() }\n\nfunc mapping(map: Map) {\n    var tags: [Tag]?\n    tags <- map[\"tags\"]\n    if let tags = tags {\n        for tag in tags {\n            self.tags.append(tag)\n        }\n    }\n}\n\n}\n```\n. ",
    "eikebartels": "same for me \n. I guess this issue should be closed. @pawin s solution works perfectly \n. I just checked the implementation and from the current implementation it seems there is no way to avoid this. \n<- implementation \npublic func <- <T>(inout left: T?, right: Map) {\n        FromJSON.optionalBasicType(&left, object: right.value())\n}\n2nd step \nclass func optionalBasicType<FieldType>(inout field: FieldType?, object: FieldType?) {\n        field = object\n}\nI guess to solve this issue we have to implement something. \n@Hearst-DD any suggestion for this? \n. Ok what about we are creating an enum \npublic enum MappingOverwriteType {\n    case Overwrite\n    case OverwriteIfNotNil\n    case NotOverwrite\n}\nAnd a new operator function i.e. \n/// Optional object of basic type\npublic func <- <T>(inout left: T?, right: (Map , MappingOverwriteType)) {\n    switch right.0.mappingType {\n    case .FromJSON where right.0.isKeyPresent:\n        FromJSON.optionalBasicType(&left, object: right.0.value(), override: right.1)\n    case .ToJSON:\n        ToJSON.optionalBasicType(left, map: right.0)\n    default: ()\n    }\n}\nAnd extending the \"writing\" functions? i.e. \n```\nclass func optionalBasicType(inout field: FieldType?, object: FieldType?, override:MappingOverwriteType = .Overwrite) {\n    switch override {\n    case .Overwrite:\n        field = object\n        break\n    case .OverwriteIfNotNil:\n        if let object = object {\n        field = object\n        }\n        break\n    case .NotOverwrite:\n        guard let field = field else {\n            return\n        }\n         field = object\n        break\n    }\n}\n\n```\nI'm happy to do that but I would like to hear your thought before I do it.\n. @A1iAshoor  \nTo have a easy quick and dirty solution you could write a helper function like this \nfunc mapIt (inout object:String?, key:String, map:Map) {\n        if let _ = map[key].currentValue {\n            object <- map[key]\n        }\n    }\nExample:\nvar name:String?\nmapIt(&name, key: \"nameStr\", map: map)\n. Hey @tristanhimmelman \nthanks for pointing this out. \nThen it seems there is an issue. The vales get overwritten from the relations. \nie\nProduct \n{\n id=10\n name= \"awesome Product\"\n description = \"awesome Product description\"\n}\nLook \n{\n id=88\n name= \"awesome Look\"\n description = \"awesome Look description\"\n products [\n  {id = 10} /// at this stage all values get overwritten \n]\n}\n. Ok I had another deeper look into this and right.isKeyPresent works correct. \nThis issue comes not from ObjectMapper. The problem is realm. \nSorry for the trouble!\n. @A1iAshoor  I don't have one yet... Its tricky. especially if you have relations \n. ",
    "pawin": "You can use ArrayTransform\nitems <- (map[\"items\"],ArrayTransform<Item>())\n. ",
    "akovalov": "There is reference to simple extension that can be used https://github.com/Hearst-DD/ObjectMapper#objectmapper--realm\n. @ogezue please provide a description or a screenshot of an error. \nAlso take a look at https://github.com/Hearst-DD/ObjectMapper#objectmapper--realm and referenced ObjectMapper+Realm extension.\n. ",
    "georgi0petrov": "With mapArray it is just working  :-)\n. ",
    "tdekker": "The new structure is much weaker. You should be able to implement the custom mapping in an extension, especially if your entities are generated. It was a change without any solid arguments and should be reverted if you ask me.\n. ",
    "brunodlz": "Hey, you could give other example ?\n. ",
    "yvanda": "I got the issue:\nUndefined symbols for architecture x86_64:\n  \"static (extension in ObjectMapper):ObjectMapper.Mappable.objectForMapping (ObjectMapper.Map) -> ObjectMapper.Mappable?\", referenced from:\n      protocol witness for static ObjectMapper.Mappable.objectForMapping (ObjectMapper.Map) -> ObjectMapper.Mappable? in conformance TestSwift.BaseObject : ObjectMapper.Mappable in TestSwift in BaseObject.o\n      protocol witness for static ObjectMapper.Mappable.objectForMapping (ObjectMapper.Map) -> ObjectMapper.Mappable? in conformance TestSwift.Forecast : ObjectMapper.Mappable in TestSwift in Forecast.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. ",
    "seanLee": "@lyfeng478  Yep,it seems that the issue is coming with version 1.3.0\n. It seems that working well.Thanx so much!\n. ",
    "MoaazThahabee": "I got same issue, after two days the only fix I found is to go back to version 1.2.\n. ",
    "fcruzsbtv": "Nevermind I just find out you have a mapArray function, my bad :) \n. ",
    "lzhlewis2015": "@fcruzsbtv  what is your function to map it to an array of mappable objects?. ",
    "cp3hnu": "Thank you for your attention. This is a small question, there is no need to create a Pull Request. You can fix it in next version.\n. ",
    "lizhihui0215": "Any one help me please\n. ```\nclass ResponseObject : Mappable{\n    var errorCode: String?\nvar errorName: String?\n\nvar status: String?\n\nvar results: T?\n\nrequired init?(_ map: Map){\n\n}\n\nfunc mapping(map: Map) {\n    errorCode <- map[\"errorCode\"];\n    errorName <- map[\"errorName\"];\n    status <- map[\"status\"];\n    results <- map[\"results\"]\n\n\n\n    //        if results is Array {\n\n//            var a = results as! Array\n//            a <- map[\"results\"]\n//        }\n    }\n}\n```\nI\u2018am try to change the \u201cT\uff1aMappable\u201d to \u201cT\u201d. But if the T really is a Mappable this given me the result nil \uff0cI hope the \u201cobjectmapper\u201d can let us define the \u201cT\u201d not the \u201cT\uff1aMappable\u201d and inside the \u201cobjectmapper\u201d if the T not as \u201cArray\u201d or any one which can not mappable Object\uff0c which given the error should be nice.\nis there any one agree me\uff1f \n. ",
    "batschz": "I have a working branch over here\nYou can use it in your Podfile like that: \npod 'ObjectMapper', :git=> 'git@github.com:e-Sixt/ObjectMapper.git', :branch => 'master'\nI strongly recommend to not use that in production environment...\n. ",
    "deepp": "Hi, I am having the same issue with version 1.1.5 ,so i tried using swift-3 branch but as it does not exist ,which version should be used?\n. @devxoul  after updating version to 2.0.0 , i got this error while updating pod files.\n[!] Unable to satisfy the following requirements:\n- ObjectMapper (= 2.0.0) required by Podfile\n- ObjectMapper (~> 1.0) required by AlamofireObjectMapper (4.0.0-beta)\n. ",
    "Bersaelor": "I think it would be good to have an official Swift 3 branch here in the ObjectMapper repo.\nOpened an issue about this.\n. @puneetgoyal08 As @tristanhimmelman said earlier, it's just an empty branch.\nLet's give @batschz some time to make a PR for his changes.\n. ",
    "JakeLin": "I have tried 1.2.0, and it is also an issue as well. The change might be made in 1.2.0.\n. We found out where this change is https://github.com/Hearst-DD/ObjectMapper/commit/f72ad154d1f11b2833d4d3e35de68f41e7056d19#diff-5a346d3647f9e826c80411d006520d56R59\nWe only call Mapper().map(map.currentValue, toObject: field) when the map.currentValue != nil. Could you please advise how to fit our requirements? How can we apply a default value when the value is nil? Thanks.\n. ",
    "puneetgoyal08": "swift-3 branch is not compiling as of now\n. oh cool, I am also liking this library, I will try to contribute as well. \n. ",
    "itman85": "i got this error when built objectmapper swift-3 branch:\n\n/Pods/ObjectMapper/ObjectMapper/Core/Operators.swift:723:75: Expected '>' to complete generic parameter list\n. I using Xcode 8, whenever i install pod again, it asks me convert objectmapper to current swift 3.0 syntax. \n. \n",
    "carobeta": "Branch has been updated for beta 6?\n. Branch has been updated for beta 6?\n. ",
    "EvilClay": "I have created a pull request for the beta 6 swift 3.. until it gets pulled, you can use \"EvilClay/ObjectMapper\" \"swift-3\"\n. ",
    "rodrigo-lima": "Hi thanks for looking into this!\nMy bad that I didn't update this with a slightly better version (coincidentally, I just found the bug this morning....)\nSometimes, the server JSON returns:\n- https://blah.com/somepath?fileName=abce space -- this requires escaping\n- https://blah.com/somepath?someDate=2016-07-08T02%3A19%3A25.113-0700 -- this is good, already escaped on the server side\nyou might end up with double encoded %, if server returns something like\n- https://blah.com/somepath?fileName=abce space&someDate=2016-07-08T02%3A19%3A25.113-0700\n  In this case, I'd file the bug against the server :) \nThis is the code I have now, but I still need to run some more tests to make sure all cases are covered. \nIf you prefer, I could submit a pull-request after adding some more Unit Tests.\npublic func transformFromJSON(value: AnyObject?) -> NSURL? {\n        if let URLString = value as? String {\n            if let url = NSURL(string: URLString) {\n                return url\n            }\n            else if let escapedString = URLString.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet()) {\n                return NSURL(string: escapedString)\n            }\n        }\n        return nil\n    }\n. ",
    "aydegee": "I also experienced an issue with the encoding introduced in 9b8163a and created this PR which makes the encoding optional: https://github.com/Hearst-DD/ObjectMapper/pull/566\nNot sure if I should open a new issue or continue the discussion here? but I wondered if the default behaviour should be to encode the URL first or leave that up to the caller? As noted in this issue and comments on 9b8163a it's difficult for ObjectMapper to know the context of the URL it is transforming in order to make the correct decisions about encoding. For example the string might already be encoded. \nAs it stands it's not possible to take an NSURL which contains spaces, map it to a string and back to an NSURL and end up with the same value you started with because it gets double-encoded. \nHaving used RestKit previously I recall it opted to avoid any encoding and just passed the string directly to the NSURL initialiser. I also noticed the Apple docs state that stringByAddingPercentEncodingWithAllowedCharacters, which is used to do the encoding, is not suitable to encode entire URLs but just components of URLs. Perhaps ObjectMapper is taking on too much responsibility in this regard?\n. No worries. thanks a lot\n. ",
    "MasterCarl": "Having just spent a fair amount of time debugging failing Amazon S3 requests, I think that shouldEncodeURLString should default to false. The rationale behind this is that trying to transform Strings with spaces will fail, while double-encoding URLs results in valid yet unusable URLs. However, introducing this now would be a breaking change.. ",
    "iliaskarim": "Seconding @MasterCarl  and @aydegee's comments: shouldEncodeURLString ought to default to false because ObjectMapper should assume that the payloads it parses--including the contents of URL strings--are well-formed.\nThe current workaround that has been implemented is a regression and reason enough for a breaking update with the next minor version. Currently, a URL like https://itmeo.com/public/webgradients_png/030%20Happy%20Fisher.png is parsed into a broken URL: https://itmeo.com/public/webgradients_png/030%2520Happy%2520Fisher.png \ud83d\ude1e\n. ",
    "lambreto": "I have experienced the same problem\nThis works:\nswift\nlet temp: String? = map[\"Email\"].value()\nif temp == nil {\n  return nil\n}\nthis also:\nswift\nguard let _: String = map[\"Email\"].value() else {\n  return nil\n}\nThe rule is to explicitly specify the type you want value() function to return.\nMaybe it is related to the Swift version. I'm using the current latest version of Xcode 7.3.1 with Swift version 2.2\nPlease fix it or update your documentation \n. ",
    "simran-lbbd": "@chrismanderson were you able to find a workaround for this?\n. ",
    "SeongBrave": "\u767b\u9646\u6210\u529f\u540e\u8fd4\u56deuser \u5bf9\u8c61\uff0c\u6211\u60f3\u8bb2user \u5bf9\u8c61\u6539\u6210\u5355\u4f8b\u6a21\u5f0f\uff0c\u600e\u4e48\u7ed3\u5408ObjectMapper \u5b9e\u73b0user\u5bf9\u8c61\u7684\u5355\u4f8b\u6a21\u5f0f\u5462\n. ",
    "juangamnik": "I think it is crucial to support protocols. I would like to embrace protocol-oriented programming and value types, but I need polymorphy and to serialize the values to disk. Currently, I use classes and NSCoding and a self-made copy() method... \ud83d\ude12\n. Is there any progress to this issue? I do not want to push anyone who puts his spare time into this project I just am unsure whether this bug stays open because it is low priority, hard to solve, or not an issue for most users.\n. If someone points me to the right place (in code) I could try to solve this issue ...\n. First off: I checked the Readme.md of this project for StaticMappable. There is a link to an example which leads to a 404.\n\nIf Pet was a class, then you could use objectForMapping in StaticMappable to \nreturn the correct type of subclass during mapping.\n\nWhy is there a limitation to classes? You can have a struct implementing a protocol and a corresponding static function (at least my playground in Swift 3, Xcode 8 eats it).\nIf there is a deeper underlying problem, you could offer to add mapping and init functions to some kind of (public) API method like this:\nswift\nfunc addMapping(type: BaseMappable.Type, \n    objectRetriever: (Map) -> BaseMappable?, \n    mapper: (BaseMappable, Map) -> BaseMappable) { \n  /* register the mapping for the given type */ \n}\nClient code could call it like this (simplified example I know):\nswift\naddMapping(type: Dog.self,\n    objectRetriever: { map in Dog() },\n    mapper: {\n        var copy = $0\n        copy.mapping(map: $1)\n        return copy\n    }\n)\nEdit:\nI see, this is not the problem at all. The issue seems to be, that the information, which Pet subtype has been used is not available during mapping, right? Why don't you just add an additional @type entry to your JSON, that stores this information during serialization? A lot of mappers use @id and @ref for structures with cycles, so using is to get the correct type to map to, shouldn't be a problem, should it? Or do I miss here something?\n. As a small follow-up: Don't you have the same \"issue\" with classes with inheritance hierarchy? If you have a base class Pet and a concrete sub class Dog and you have a property of type Pet which is \"filled\" with a Dog, serialize it, and deserialize it later on, you should deserialise a Dog not a Pet. So, if you do this already correctly, then you need type information in the JSON output.\n. Anything new on this? Did my information help (@id/@ref/@type)?\n. > With a class, Swift has more type information with which it can work with. With a protocol, there is much less information to do so--it is unable to determine a single-type (even if generic T) at runtime.\nYou just need enough information to write out the concrete type during serialization and call the deserialization function for the correct type during load. So if the issue really is, to get the concrete type, adding a corresponding typeName-method to Mappable should do the trick. It willl be called polymorphically and used to write the corresponding information in a @type attribute (or something similar) in the JSON output, and use the same information to lookup the implementation (e.g. from some dictionary) in order to deserialize the correct type.\n\nThis means that even in this context, where it calls Pet.objectForMapping(_:), the type information says that a Dog could return a Cat--even though we know, as developers, that this is not the case.\n\nIf you have a property of type Pet, sure it might be a Dog or a Cat later on, this is why Pet is used. If I want to be sure, that I get a Dog, I will use a property typed with Dog. I don't get the point here.. You could even use the typename to control, which type is used later on by setting a concrete type in the registry/dictionary I mentioned.. Anything new on this?. ",
    "marioyohanes": "I have same issue with version 1.4.0, it simply skip protocol properties during mapping. I saw the issue being closed but couldn't found open ticket for this issue.\n. I got same issue on Swift 4.1 + Xcode 9.3. My workaround atm is to update our transformer to cast the object to NSNumber and get the .floatValue. There will be rounding issue, but it's not a problem at least for my project.. ",
    "chamander": "\nWhy is there a limitation to classes? You can have a struct implementing a protocol and a corresponding static function (at least my playground in Swift 3, Xcode 8 eats it).\n\nWith a class, Swift has more type information with which it can work with. With a protocol, there is much less information to do so--it is unable to determine a single-type (even if generic T) at runtime.\nThis means that even in this context, where it calls Pet.objectForMapping(_:), the type information says that a Dog could return a Cat--even though we know, as developers, that this is not the case. As soon as we \"expect\" this form of polymorphism, the work we need to do to declare compile-time safety increases. To work with this, we can provide more type information and write:\n```swift\npublic protocol GenericMappable: Mappable {\nassociatedtype Mapped: Mappable = Self\nstatic func mapped(from map: Map) -> Mapped?\nfunc serialized() -> JSON // For some ObjectMapper-defined JSON type.\n}\n// Elsewhere, in an application-specific namespace.\ninternal protocol Pet: class {\n  func makeSound() -> String?\n}\ninternal class Dog: GenericMappable, Pet { ... }\ninternal class Cat: GenericMappable, Pet { ... }\ninternal class PetWrapper where T: Pet {\nprivate(set) internal let wrapped: T\ninit(wrapping pet: T) { wrapped = pet }\nfunc makeSound() -> String? { return wrapped.makeSound() }\n}\n```\nThis still means that we aren't able to drill down on the runtime type of instances of the conforming type without further introspection (because of the new associatedtype), but provided there is some functionality in Pet that we would like access to, this is still useful. Given there is some other way to retrieve the type information to use for the construction of the instance, we are able to use this.\n@txaiwieser \n\nSame case here, i have an array of transactions, and they are different objects, i made a protocol for transactions, but cannot make it to work. Any help?\n\nThis issue is related to that. i.e. That with a array of heterogenous types, the compiler does not have enough information on the underlying concrete type(s).\nThis issue is not apparent with classes because they share some type information--it gets complicated as soon as you inherit from some abstract superclass, however.\nWith the implementation above, the compromise we're likely to make is:\n```swift\nlet collection: Array = ... // Some pre-defined collection.\nlet serialized: Array = collection.flatMap { ($0 as? GenericMappable)?.serialized() }\n```\n@tristanhimmelman , What do you think about this, having context of the implementation of ObjectMapper?. ",
    "anafinotti": "Same problem\n. ",
    "svetlyo": "The comment is outdated - take a look at the code when it was introduced -https://github.com/Hearst-DD/ObjectMapper/commit/741908cfc48225d646425faf5b9d58a03c84bfc1. Since then the handling of String was extracted in another overloaded version of map:\nhttps://github.com/Hearst-DD/ObjectMapper/blob/master/ObjectMapper/Core/Mapper.swift#L85\nswift\n    /// Map a JSON NSString to an object that conforms to Mappable\n    public func map(JSONString: NSString) -> N? {\n        return map(JSONString as String)\n    }\n. If you have a String disguised as AnyObject (a variable of type AnyObject which was assigned a String value) the overloading won't work and public func map(JSON: AnyObject?) -> N? would be called and you'll get nil - you're right about that.  As far as I see it there is no such function - it would be a giant switch with as? cases that tries different types. Currently the whole switching based on the type of the thing that you pass to map is done via function overloading which does not see the real, dynamic type - otherwise it would be polymorphic. Sadly swift does not support multiple dispatch (https://en.wikipedia.org/wiki/Multiple_dispatch)\n. ",
    "lujing666208": "You can easily create your own custom transforms by adopting and implementing the methods in the TransformType protocol:\n```\npublic protocol TransformType {\n    typealias Object\n    typealias JSON\nfunc transformFromJSON(value: AnyObject?) -> Object?\nfunc transformToJSON(value: Object?) -> JSON?\n\n}\n```\n. ",
    "GuyKahlon": "@tristanhimmelman Hey, I've tried this solution, it doesn't work.\nCan you provide, please \ud83e\udd12,  a specific example for the JSON above? \nThanks, \nGuy\n. I don't think it's the same problem.\nHere the data is the same.\nJust the prefix is changed dynamically.\n\"bpi\": { \n\"USD\": { \"code\":\"USD\",\"symbol\":\"$\",\"rate\":\"654.1700\",\"description\":\"United States Dollar\",\"rate_float\":654.17 },\n\"GBP\": { \"code\":\"GBP\",\"symbol\":\"\u00a3\",\"rate\":\"497.6095\",\"description\":\"British Pound Sterling\",\"rate_float\":497.6095 },\n\"EUR\": { \"code\":\"EUR\",\"symbol\":\"\u20ac\",\"rate\":\"589.8978\",\"description\":\"Euro\",\"rate_float\":589.8978 }\n}\nAnyway, For people finding this issue, I solved it like this:\n``` Swift\nimport Foundation\nimport ObjectMapper\nstruct Currecncy: Mappable {\nvar code: String?\n  var symbol: String?\n  var rate: String?\n  var description: String?\n// MARK: - Mappable\n  init?(_ map: Map) {\n}\nmutating func mapping(map: Map) {\n    code          <- map[\"code\"]\n    symbol        <- map[\"symbol\"]\n    rate          <- map[\"rate\"]\n    description   <- map[\"description\"]\n  }\n}\nstruct Rate: Mappable {\nvar date: String?\n  var disclaimer: String?\n  var currecncies: [String: Currecncy]?\ninit?(_ map: Map) {\n}\nmutating func mapping(map: Map) {\n    date        <- map[\"time.updated\"]\n    disclaimer  <- map[\"disclaimer\"]\n    currecncies <- map[\"bpi\"]\n  }\n}\n```\n@tristanhimmelman thanks for your quick response.\n. ",
    "o15a3d4l11s2": "Are there any options if I have the response like\n[\n   {\n      \"id\":3,\n      \"name\":\"Zzz\"\n   },\n   {\n      \"id\":10,\n      \"name\":\"Kkk\"\n   },\n   {\n      \"id\":2,\n      \"name\":\"Aaa\"\n   }\n]\n. ",
    "madhavajay": "Errors should resolve when Travis updates their image to Xcode 8 Beta 3\n. ",
    "KoCMoHaBTa": "Hi,\nThis adds the ability to easily transform JSON into dictionary which key is enum string and its value is a Mappable object.\nFor example consider the following JSON:\n{\n    \"travelTypes\": {\n        \"walking\": {\n            \"time\": \"5 days\",\n            \"distance\": \"500km\"\n        },\n        \"drving\": {\n            \"time\": \"1 days\",\n            \"distance\": \"550km\"\n        }\n    }\n}\nAnd the following models:\n```\n//This is used for the dictionary key\nenum TravelType: String {\ncase Walking = \"walking\"\ncase Driving = \"driving\"\n\n}\n//This is used for the dictionary value\nclass TravelInfo: Mappable {\nlet time: String\nlet distance: String\n\n}    \nclass Travel {\n//This is the dictionary\nvar travelTypes: [TravelType: TravelInfo]\n\npublic func mapping(map: Map) {\n\n     // Using DictionaryTransform for convenience, otherwise we have to write custom transofmr\n     self.travelTypes <- (map[\"travelTypes\"], DictionaryTransform<TravelType, TravelInfo>())\n}\n\n}\n```\nIn case this already exists, please point it out.\n. You must first initialize all of your stored properties before accessing them. This is required by the 2 step initialization process that is enforced by the compiler.\nSo your options are to either perform initialization in the init method or to have default values for all of your properties. \nIf you are using a class, you can declare the init?(map: Map) method as convenience initializer and call your designated one.\n. Well, I can give you a hint. Even i faced huge performance issues recently.\nThe example was parsing ~600 objects, which tooks ~30seconds. \nAfter discovering the issue and applying quick and dirty fix - i managed to reduce the time needed to ~2-3seconds. \nIt turns out the Mapper calls the mapping(map: Map) func after init?(map: Map). \nIn the past, in the docs, it was written that we should call the mapping(map: Map) within the implementation of init?(map: Map), so if we do it - the mapping is done twice which impacts the performance.\nFrom what i see in the implementation of JSONShootout - they are using ImmutableMappable, but it could be a similar case.\n. I guess that there is no point to have Set directly, because there is no direct representation of Set in the JSON format. I think that you probably have found the best approach to use Set. In addition to your transform, you could use overload of the >>> mapping operator and introduce the Set by using your SetTransform. I believe this should be fine if you submit a PR with these changes.\n. @devxoul I have added more detailed tests with description about use cases - https://github.com/Hearst-DD/ObjectMapper/pull/672/files#diff-5388011c7e59ca170360e3acc81c4719\nThe primary use case is the validation of required properties, although it can be used for things like date validations.\n. @devxoul Sorry, I did not get the point, but let me clarify - this use case for validating dynamic data coming from a server. It could change any time and the application must be sure that it throws away invalid data upon mapping. \n. Well it is, right now, but only limited to prior mapping.\nThe main problem that i'm trying to solve is to guarantee that required properties of Mappable objects will not get into inconsistent state and the object should accept them only if they are correct.\nIMO this should be done with validation after mapping, because trying to do it prior is inconvenient.\nIf you have better ideas - i'm open to suggestion.\n. Well, you could do the same - the IDs are actually strings, so you could represents the other types as [String: Group] for example.\n. The whole design can be done this way\n`          \n    class Response: Mappable {\n        var days: [String: Day]?\n\n        required init?(map: Map) {\n\n        }\n        func mapping(map: Map) {\n            days <- map[\"data.questions\"]\n        }\n    }\n\n    class Day: Mappable {\n\n        var groups: [String: Group]?\n\n        required init?(map: Map) {\n\n        }\n\n        func mapping(map: Map) {\n\n            groups = [:]\n            map.JSON.forEach { (key, value) in\n\n                groups?[key] = Mapper().map(JSONObject: value)\n            }\n        }\n    }\n\n    class Group: Mappable {\n        var groupName: String?\n        var questions: [String: Question]?\n\n        required init?(map: Map) {\n\n        }\n\n        func mapping(map: Map) {\n            groupName <- map[\"groupName\"]\n            questions <- map[\"questions\"]\n        }\n    }\n\n    class Question: Mappable {\n        var questionId: String?\n        var text: String?\n\n\n        required init?(map: Map) {\n\n        }\n        func mapping(map: Map) {\n            questionId <- map[\"questionId\"]\n            text <- map[\"text\"]\n        }\n    }\n\n    let result = Mapper<Response>().map(JSONString: json)`. You can have something like this:\n\n```\npublic struct ResponseValue: Mappable {\npublic var payload: P?\n\npublic mutating func mapping(map: Map) {\n\n    self.payload <- map[\"payload\"]\n}\n\n}\npublic struct ResponseObject: Mappable {\npublic var payload: P?\n\npublic mutating func mapping(map: Map) {\n\n    self.payload <- map[\"payload\"]\n}\n\n}\npublic struct ResponseArray: Mappable {\npublic var payload: [P]?\n\npublic mutating func mapping(map: Map) {\n\n    self.payload <- map[\"payload\"]\n}\n\n}\n```. You could define 2 properties - for both cases, map to both with the same key, and use the one you need based on your UI or business case. \nThe one that is wrong will just not map and can be considered safe. Then it will be up to you how to handle it.\n```\nclass List: Mappable {\nvar totalPages: Int?\nvar mode: String?\nvar titles: [Title]?\nvar tags: [Tag]?\n\nrequired init?(map: Map) {\n}\n\nfunc mapping(map: Map) {\n        totalPages <- map[\"pagination.total_pages\"]\n        mode    <- map[\"info.mode\"]\n        tags    <- map[\"titles\"]\n        titles  <- map[\"titles\"]\n    }\n}\n\n}\n```. Yeah, I know it is totally inconvenient, because if you want ot map directly an array of mappable object - you have to use explicitly a different function.\nThis is because Array of Mappable is not Mappable by itself. I believe this inconvenience will be fixed in swift 4.\nIf u understand you correctly - you want to have a wrapper object for all of your responses. Where T is its generic value. If that is the case, you can do the following:\nAs you are having ResponseModel<T> , you can define ResponseArray<T> that will define its result to be [T]. \nThis way - you will only have to explicitly use either ResponseModel or ResponseArray, depending on your result.. ",
    "josejuanqm": "Unrelated (maybe) but that should cause an error at mapping function because you are setting the getters, those variables are get only. you need to use the \"_\" prefixed variables\n. You could use this transformation ->\nswift\npublic let transformInt64 = TransformOf<Int64, Int>(fromJSON: { (value: Int?) -> Int64? in\n    guard let v = value else{\n        return nil\n    }\n    return Int64(v)\n    }, toJSON: { (value: Int64?) -> Int? in\n        // transform value from Int? to String?\n        if let value = value {\n            return Int(value)\n        }\n        return nil\n})\nand modify it to transform into an array.\nthen use it like this -> \nswift\nsomeVariable <- (map[\"someIntArray\"], transformInt64)\nHope it helps!\n. ",
    "abdbarjoud": "<- operator doesn't give me the ability to set default value, which i need it\n. in this case won't the value being overwritten with nil if it the JSON has null value for it ?\n. ",
    "shshalom": "I wanted to create a merge functionality and in my case i needed the current key so I could test against it. \n. I still trying to figuring out how to do this.\nThe way I'm doing it right now (without actually relaying on ObjectMapper existing functionality),\nis by having a Dictionary extension:  \n``` swift\nextension Dictionary  {\npublic func merge(dictionary: Dictionary) -> Dictionary {\n\n    var result = Dictionary()\n\n    self.forEach {(key,value) -> Void in\n        _ = result.updateValue(value, forKey: key)\n    }\n\n    dictionary.forEach { (key, value) -> Void in\n        if value is Dictionary, let v1 = result[key] where v1 is Dictionary {\n            let dicValue = (v1 as! Dictionary).merge(value as! Dictionary) as! Value\n            _ = result.updateValue(dicValue, forKey: key)\n        }else{\n            _ = result.updateValue(value, forKey: key)\n        }\n    }\n\n    return result\n}\n\n}\n```\nand then creating an extension for Mappable:\nswift\nextension Mappable {\n    mutating func merge<T:Mappable>(object:T) {\n        let json = self.toJSON().merge(object.toJSON())\n        mapping(Map(mappingType:.FromJSON, JSONDictionary: json))\n    }\n}\nThere's must be a way to create the merge functionality without going back and forth,  Mappable object -> JSON and merged JSON to Map object..\nYour thoughts?\n. ",
    "josercc": "Thanks\n. ",
    "jonmarimba": "@tristanhimmelman \nIn our project, the opposite is most definitely true, especially mapping JSON on a device like an old iPod touch. We have a number of deep (foo.bar.baz) keypaths to map, though so perhaps that's the reason that we overcome the NSDictionary cast performance hit to gain an overall improvement. \n. ",
    "cmbasnett": "Expanding on the answer by @josejuanqm , here is a class that can be reused if global class instances aren't your bag:\n```\nimport ObjectMapper\npublic class Int64Transform: TransformType {\n    public typealias Object = Int64\n    public typealias JSON = Int\npublic func transformFromJSON(value: AnyObject?) -> Int64? {\n    guard let value = value as? Int else {\n        return nil\n    }\n    return Int64(value)\n}\n\npublic func transformToJSON(value: Int64?) -> Int? {\n    if let data = value {\n        return Int(data)\n    }\n    return nil\n}\n\n}\n```. ",
    "leonard2014": "The int64 fields got nil value in ObjectMapper 2.2.5 with the above solution. I parsed Int64 value directly from a String object.\nimport Foundation\nimport ObjectMapper\nclass Int64Transformer : TransformType {\n    public typealias Object = Int64\n    public typealias JSON = String\npublic func transformFromJSON(_ value: Any?) -> Int64? {\n    guard let value = value as? String else {\n        return nil\n    }\n    return Int64(value)\n}\n\npublic func transformToJSON(_ value: Int64?) -> String? {\n    if let data = value {\n        return String(data)\n    }\n    return nil\n}\n\n}. ",
    "jpstern": "objectForMapping(map: Map) was moved into \nprotocol StaticMappable: Mappable {\n...\n}\nReplace Mappable with StaticMappable wherever you need to use objectForMapping\n. ",
    "jakecraige": "I also ran into this recently and it took some time to debug. \nI would have much preferred this to come with a version 2.0 ObjectMapper since this was a breaking change. Is there a particular reason it wasn't?\n. ",
    "kamarshad": "No right now I am not working on it. But for my curiosity will continue it after 1-2 days and will share  the information If I find the same issue again. Thanks for your gentle reply @tristanhimmelman \n. Thanks @tristanhimmelman \ud83d\udc4d \n. I am facing the same error while installing the ObjectMapper pod. Have you @shantanubharadwaj  fixed this issue? \nAny help will be much appreciated!\n. I got the solution, dependency can be resolved If we write the pod simply like this pod 'ObjectMapper'. No need to mention the version explicitly\n. ",
    "joshpc": "Should some/most of the classes be open instead of public? Right now with everything as just public there's no flexibility at all. I have a separate fork that opens up the transforms, specifically, but I don't know what other people's use cases are like.\n. You can avoid all of these casts if we change the declaration: https://github.com/Hearst-DD/ObjectMapper/compare/swift-3...joshpc:swift-3?expand=1#diff-a9498ca83904e6eb2c05ea55fe3c5a1dR348\n. ",
    "tulusheg": "@tristanhimmelman sure, thanks!\n. ",
    "A1iAshoor": "+1 same question\n. @eikebartels what should be a clean solution now?\n. @eikebartels the way I finally fixed it is by using this method in mapping function:\n```\nfunc mapping(map: Map) {\n    param = self.getValue(id: id) ?? \n}\nfunc getValue(id: Int) -> Bool? {\n    return Realm.object(ofType: Object.self, forPrimaryKey: id)?.param\n}\n```\nstill not convinced, and as you concluded this is not ObjectMapper issue but Realm.\n. ",
    "gsabran": "I see, nice. Thanks\n. ",
    "Flitskikker": "Thanks, @tristanhimmelman! I didn't figure it was that simple as just adding init(){}.\n. ",
    "happiehappie": "May I ask what's the reason for closing this? Cause I encounter this as well\n. ",
    "ManWithBear": "Cauz it's not framework issue.\nError saying: \"Your object don't have initializer without parameters, so object can't be created in this way\"\n. 1. Can you,please, provide full your code? \n\nXCode 8.1 shows error: self used before all stored properties are initialized\n\nYou can't call object methods (mapping(_:) in your case) before all properties are initialized\n. And Yes and No. ImmutableMappable call mapping(map: Map) after init(map: Map), but because ImmutableMappable use >>> operator, which support mapping only TO json, mapping happen only once.\n. Hm, after little research I found that you are right. \nI run same JSON like in this test. But 10 times. \nDespite of mapping from JSON, mapping(map: Map) take almost 39% time of initialization. \nAfter adding guard check in mapping:\npublic func mapping(map: Map) {\n    guard map.mappingType == .toJSON else { return }\n    ...\n}\nIt decrease parsing time from 17.33s to 10.68s.\nAnd biggest time consumer in mapping is swift_dynamicCast.\nFor this test biggest time take all casting to [String:Any]\n. 1. I think it's not problem of ImmutableMappable, but framework core itself. Because my fix from previous message dive same improvement.\n2. Sorry, but it's bad answer. Here many cases, when application need to download big amount on data, at least on first launch. And if you can improve user experience by decreasing this time, why will you not do it?\n. @tristanhimmelman can you please add 2.2.1 tag to actual master? So SPM can fetch updates?\n. Here already implementation for Set, so it make sense have mapping for basic Set.\n. If you dont want implement mapping functions, than you need to check some reflection mapping, like: https://github.com/evermeer/EVReflection\nOr you can use some code-generators / macros. I often use macros in Vim, when I need to create mapping function for big object.\n. It will be better, if you make fork, add your translation md file, and send pull request.\n. Next to README.md\n. Why you not translate full README?\n. You can find in README:\n\nStaticMappable is an alternative to Mappable. It provides developers with a static function that is used by ObjectMapper for object initialization instead of init?(map: Map).\n. I think, you trying to solve wrong problem. This is mapping framework with only 1 responsibility: mapping object from/to JSON.\nValidation is not part of this process.\nSo my opinion: validation shouldn't be part of ObjectMapper.\n. \n",
    "Taco55": "I just found that a SwiftDeferredNSArray results when the values in a Swift dictionary are defined with AnyObject. However, when Any is used, the output is correct.\n```\nvar fields = String: AnyObject\nfields[\"key1\"] = [1,2,3,4]\nprint(fields) // Output: [\"key\": <_TtCs21_SwiftDeferredNSArray 0x7fd9db516940>(\\n1,\\n2,\\n3,\\n4\\n)\\n]\nvar fields = String: Any\nfields[\"key1\"] = [1,2,3,4]\nprint(fields) // Output [\"key\": [1, 2, 3, 4]]\n```\nAny suggestions how to handle this with ObjectMapper? \n. Never mind. Thanks for the reply.\nWith Swift 3 the value type in the Swift dictionary is changed from AnyObject to Any and does not result in SwiftDeferredNSArrays anymore. Because my problem is solved after conversion to Swift 3.0 and new version of ObjectMapper I will close this issue.\n. ",
    "phatmann": "Xcode 8 is out, so this would be a good time to merge this PR.\n. ",
    "arilsonkarmo": "Is a good time to merge this! \ud83d\udc4d \n. ",
    "juliengdt": "You miss the name parameter to .toJson() function. Or make it optional with \"_\".\nSwift 3.0 refactoring stuff\nBTW, wait for 1.5 version, seems to be released soon\n. The syntax conversion is done, but tag/version has not been pushed to cocoapod, we are waiting some action from @tristanhimmelman \n. +1 need to update the repo version for cocoapod.\nFYI, the Moya/ObjectMapper dependency is waiting for it (no pressure :D )\n. clap clap !! \ud83d\udc4f \n. ",
    "csersurya": "try data.toJSON()\n. ",
    "minhnguyen1990": "I have the same problem. Can you convert the current code to Swift 3 syntax? Please!\n. ",
    "cherishloveyou": "version 1.5 miss\n. ",
    "kristijanexads": "@tristanhimmelman Sorry to comment on closed issue, can you tell me if its all sorted for Carthage? Tnx a lot\n. @tristanhimmelman I had a problem with Carthage v2.0.0 because it's meant to work with Swift3 and I can't update to Swift3 at the moment (because some other frameworks that I'm using aren't updated yet) so I ended up with this (ObjectMapper v1.5+Swift2.3)\ngithub \"Hearst-DD/ObjectMapper\" ~> 1.5\nand run this command \ncarthage update --platform iOS --toolchain com.apple.dt.toolchain.Swift_2_3 ObjectMapper\n. ",
    "esteluk": "1.5.0 doesn't seem to be available in the master spec repository at all.\n. ",
    "michelalbers": "I get lots of errors as well :( \nXCode Version:\n\nErrors:\n\n... and a lot more :'(\n. ",
    "eciftcioglu": "I had the same problem.I found out my pod was outdated and it was pulling the wrong version of objectmapper. Updating pods and installing worked for me.\n. ",
    "nicorsm": "I'm experiencing the same issue with Xcode 8.0 (8A218a). Tried to update and reinstall pods but with no result. Xcode reports 235 compile-time errors, same type of @michelalbers . Using cocoapods 1.0.1\n. Yes. Now I installed v1.4.0 and it works fine.\n. ",
    "Ssrana": "@tristanhimmelman I'm using v1.5.0 I'm getting the same multiple errors as asked above. I've cleaned the derived data folder and also cleaned project the tried building, no luck. Any suggestions?. ",
    "cristiansimioni": "You should use the 2.0.0 version.\npod 'ObjectMapper', '~> 2.0.0'\n. I was facing something similar this week. I solved it following the steps below:\n1) On Xcode, navigate to Product and hit Clean\n2) Close Xcode\n3) Open a console and delete DerivedData folder\n    cd ~/Library/Developer/Xcode/\nrm -rf DerivedData/\n4) Open Xcode and try again.\n. ",
    "snehasen1990": "Same issue trying clean build .....but no luck. ",
    "ardacetinkaya": "I have the same error.\n. ",
    "keyss-sachin-arora": "i have the same error with this .\nvar token = deviceToken.description.trimmingCharacters(in: CharacterSet(charactersInString:\"<>\" )). ",
    "HenrikOlssonEvry": "My first search wasn't good enough. Found that there already is an issue registered about Swift Package Manager. Sorry about that.\n. ",
    "ogezue": "I could not find help in the documentation, so I think a screenshot is a good way to describe my problem.\n\n. ",
    "efc": "In hunting around a bit more I am pretty convinced that MapContext was created to help with situations like this, but I am just not clear on how to apply it, the example is pretty sparse. In particular, I am not sure how to make the mapping asymmetric, in that I want to be able to read all old versions (making adjustments to bring their data up to date) but I only want to write out the most recent version.\n. ",
    "Sianay": "Yes they are mapped to 0 instead of 1 in the case of the manager var\n. I think in your unit test you assume that they are passed as float to float and this is working. \nHowever in my dict these numbers are of the type Any and i want them to become Float \nif I write my dict this way : \nlet dict: [String:Any] = [\"manager\":1  as Float , \"self_assessment\":0 as Float, \"average\":0 as Float, \"total_answers\":1]\nthen the values will be map correctly (manager = 1 ) but I can't force the type when i parse from real json \n. here a screenshot of unit test : \n\nmy class\n```\nclass AnswerOverview: Object, Mappable {\ndynamic var question: Question?\n\ndynamic var manager: Float = 0\ndynamic var selfAssessment: Float = 0\ndynamic var average: Float = 0\n\ndynamic var totalAnswers: Int = 0\ndynamic var totalComments: Int = 0\n\ndynamic var hiddenStrength: Bool = false\ndynamic var blindSpot: Bool = false\n\nvar answerPreviews: List<AnswerPreview> = List<AnswerPreview>()\n var scrolledPage = 0\n\noverride static func ignoredProperties() -> [String] {\n    return [\"scrolledPage\"]\n}\n\nrequired convenience init?(map: Map) {\n    self.init()\n}\n\nfunc mapping(map: Map) {\n    question <- map[Constants.JSONKey.question]\n    manager <-  map[Constants.JSONKey.manager]\n    selfAssessment <- map[Constants.JSONKey.selfAssessment]\n    average <- map[Constants.JSONKey.average]\n    totalAnswers <- map[Constants.JSONKey.totalAnswers]\n    totalComments <- map[Constants.JSONKey.totalComments]\n    hiddenStrength <- map[Constants.JSONKey.hiddenStrength]\n    blindSpot <- map[Constants.JSONKey.blindSpot]\n    answerPreviews <- (map[Constants.JSONKey.answerPreviews], RealmListTransform<AnswerPreview>())\n}\n\n```\n. Ok so if it can help you this is working with JSONString but not with a dict \n\n. ",
    "CaptainMack": "I might be having same problem using Double and Int. For some reason, mapping JSON to these types fail - String type maps correctly. \n. ",
    "hardeep": "~~I'm having this issue on swift 2.2 (ObjectMapper \"1.4.0\") as well.~~\n~~My current solution is to use map[\"someKey\"].currentValue?.floatValue~~\nUser error on my behalf. The API I was using was enclosing the float in quotes. I'll leave this comment in case anyone is running into the same issue on 2.2.\n. @tristanhimmelman I wonder if this has anything to do with your issue. http://stackoverflow.com/questions/32554357/is-float-double-int-an-anyobject\n. ",
    "sallyahmed": "\n1 here !\n. \n",
    "FerdiKT": "I have same problem on \u0130OS 11 (same version of app with no problem on ios 10). I used Double instead of Float and it's working now.. ",
    "conqueror": "If I have a Double? and I receive a value without decimals in the JSON such as 4, ObjectMapper does not map it.\nIn case I receive a value with decimals like 4.00 then ObjectMapper maps it properly.. It is not relevant anymore.. ",
    "oleghnidets": "Have the same issue as @conqueror. To solve the issue I have to use NSNumber but it is not what I expect from the library (still cool lib \ud83d\udc4d\ud83c\udffb).\n@tristanhimmelman Any updates on that?. ",
    "SebastianCrow": "Personally, I'm using a custom transformer like that to have it mapped correctly:\nTransformOf<Float, NSNumber>(\n    fromJSON: { (value: NSNumber?) -> Float? in\n        return value?.floatValue\n    },\n    toJSON: {\n        if let float = $0 {\n            return float as NSNumber\n        }\n        return nil\n    }\n)\nHowever, it would be nice if float mapping would work out of the box. ",
    "tisohjung": "I have two phones. iPhone6s running on 11.3, iPhone5 running on 10.3\niPhone6s parses when using CGFloat, but not using Float\niPhone5 parses when using Float, but not using CGFloat\nso just changing it to CGFloat means older versions of iOS will not be properly supported. ",
    "Adrift001": "same problem too.\n\n\n. #959 solved. cocoapods version is 3.2, can update fast?. you can print json see see.. you can use rxswift Observable.combine to get two json, then map to one json, then produce new one object.. I don't really like codable now because it's not flexible. For example, the null field problem. Maybe it's because I can't use it.. @kamirana4 positive solution!. ",
    "econner": "Answering my own question...\nI was able to achieve this using a generic type:\nModelListResponse.swift\n```\nimport ObjectMapper\nclass ModelListResponse: Mappable {\n    var status: String!\n    var data: ModelList?\n    var message: String?\nrequired init?(map: Map){}\n\nfunc mapping(map: Map) {\n    status <- map[\"status\"]\n    data <- map[\"data\"]\n    message <- map[\"message\"]\n}\n\n}\n```\nModelList.swift\n```\nimport ObjectMapper\nclass ModelList: Mappable {\nvar models: [T]?\n\nrequired init?(map: Map){}\n\nfunc mapping(map: Map) {\n    models <- map[\"models\"]\n}\n\n}\n```\nRequest\nAlamofire.request(\"/get/objects/endpoint\", method: .get, parameters: parameters).responseObject { (response: DataResponse<ModelListResponse<User> >) in\n...\n}\nI'll close this, but am curious if there are recommendations.\n. ",
    "mzeeshanid": "I am getting EXC_BAD without any other error message.\n. ",
    "roshanman": "thanks\n. ",
    "leizard": "I'm sorry but I'm still quite confuse about using TransformOf. Could you please tell me more about implementing it for my case ?\n. I think I get it a little bit more. So I tried to create a transform \nlet transform = TransformOf<Int,[CustomAttribute]>(fromJSON: { (value: [CustomAttribute]?) -> Int? in\n        return nil\n        }, toJSON: { (value: Int?) -> [CustomAttribute]? in\n            if let value = value {\n                return nil\n            }\n            return nil\n    })\nCustomAttribute is my Model for 'attributes' property. Then I debug into fromJSON but the value variable always nil.\nDo you have any idea ?\nThank you.\n. ",
    "keygx": "Thanks.\n. ",
    "loryhuz": "No in fact result.address_components contains an array where I want to retrieve different values. Sorry the JSON sample is badly formatted in my first post.\nI have these two properties client-side:\n\nvar route: String?\nvar streetNumber: String?\n\nThese two values are presents in address_components array, and depend on the property \"type\" in each objects of this array. So I'd need conditions to map them to corresponding properties\nroute should be mapped with value: Rue de Dunkerque & streetNumber should equal to 36\n. Ok that's what I thought, thanks for this clean solution man, very useful !\n. ",
    "bdrelling": "I mean, in the documentation there is already an example of how it should work: https://github.com/Hearst-DD/ObjectMapper#generic-objects\nYou could not, in this case, do Result<Float>. You'd have to make a separate class for each type you wanted entirely.\nIf you just copy the first snippet I wrote and try to do MyClass<Float>, it won't even compile. That's what I'm trying to explain.\nSo in what instance could we have a generic type that allows all types that are actually mappable from ObjectMapper but do not explicitly conform to the Mappable protocol?\n. Months and months later I still am not entirely sure how ObjectMapper intends for Mappable items to be used in generics like this. For nearly a year now I've had code similar to the above, just with alternate versions like MyResponseList<T: Mappable>: Mappable which has var data: [T]? when I need it, but I really hate doing this.. ",
    "luosky": "I think what he expected is to write code like Mapper<Float>().map(json[keyPath]). But Float doesn't conform to Mappable, so he has to wrap Float in a custom type like MyClassWithFloat\n. ",
    "mahmoudnaja": "Hi here is my podfile.\nsource 'https://github.com/CocoaPods/Specs.git'\nplatform :ios, \u20188.1\u2019\nuse_frameworks!\ntarget \u201cApp\u201d do\npod 'ObjectMapper', '~> 2.0'\nend\n. Yes it installs version 1.x\n. Will try the above and will let you know if it works\n. Thanks the above worked \n. ",
    "FlaviaBondJamesBondsHusband": "No longer happening with new Immutable protocol. Thanks :)\n. It's no biggie. Sorry if it sounded pretentious or ungrateful there I was just trying to let you know but github doesn't have dm lol.\nYou changed the optional status of the return value of the mapArray function.\npublic func mapArray(JSONArray: [[String: Any]]) -> [N] {\n    // map every element in JSON array to type N\n    let result = JSONArray.flatMap(map)\n    return result\n}\n\nThanks for all your hard work. ",
    "vitkuzmenko": "@devxoul I update it\n. ",
    "M0TRIX": "try class MyClass. ",
    "zhanghongdou": "\nObj is here I enclosed the inheritance in the model mapper, I meant to get obj\u2018s class by runtime , and then get all the attributes, but in the use of obj. ClassForCoder, returns nil\n. \nThis is the obj\u2019s class \n. My English is not very good, hope you can understand me, thank you\n. Thank you, I'll try it according to your opinion\n. \nWhen my Model  just like this picture, I use the method \uff1a\nvar outCount: UInt32 = 0\nLet the properties = class_copyPropertyList (obj. ClassForCoder, & outCount)\n is able to obtain the model of a class, at the same time can get all his property, but if my model is inherited from the Mapper can't achieve what I want\n. No, not yet. Let me try\n. I'm sorry, just a little thing, I tried once is available\nAccording to the following way\uff1a\nclass InvestRecordListModel: NSObject, Mappable {\n  ...\n}\n. Thank you for your help, should be the cause of my side, I again carefully look for the reason, thanks again\n. Try my best to solve it, ha ha\n. ",
    "brentpi": "My original data source is a bunch of OS X System Profiler Plist files that I'm reading into a dictionary.  The format for SPStorageDataType is something like the following, so you can see why I requested this:\n_items.0.\"com.apple.corestorage.lv\".\"com.apple.corestorage.lv.encrypted\"\nSo, for my use case, changing the '.' to a '/' or a '|' would be helpful, as I would like to maintain nesting, but ignore the \"com.apple.corestorage.lv\" keys as \"nested\" keys.\n. Yeah, that sounds like a better option perhaps.\n. ",
    "danipralea": "yeah, I ended up using 2.1.0\nI had the 1.1 version somehow (I copy pasted the pod from an old project).\nThank you very much for your help!\n. ",
    "Dbigshooter": "Apologies for not making that clear. I want the above JSON into a corresponding dictionary of this [Int : [MyObject]]. As mentioned earlier my problem is that the key don't have name.\n. Oh, will this due the trick? \nfunc mapping(map: Map) {\n    objects <- map[\"1\"] <---- \"1\" will be variable from call to call.\n  }\nThe key in the dictionary is id's I need, not just incremental. I've updated my first question with more details.\n. I'm just trying to understand it properly, please bare with me. I need the every key in the dictionary to be mapped to a list of MyObject, but I can't get a hold of it since it will vary, so the example you posted earlier with hardcoded \"1\" it it wouldn't work. Am I missing something? Am I making any sense? \nI've tried this:\n```\nvar objectDict = [String : [MyObject]]\nfunc mapping(map: Map) {\n    objects <- map\n  }\n```\nHowever that didn't work at all.\n. Let me show you my entire call using Alamofire:\nAlamofire.request(url, method: .get, parameters: params, headers: headers()).responseJSON {\n            response in\n            if let ms = Mapper<MeasurementsTransfer>().mapDictionary(JSON: response.result.value as! [String : [String : Any]]) {\n                    print(ms)\n                    completionHandler(ms, nil)\n                } else {\n                    print(\"Failed\")\n                    completionHandler(nil, false)\n                }\n        }\nIf I try this I get a very odd crash, showing me this, I got no breakpoints, nothing:\n\nWoops, I see that the type I'm casting it too is wrong, but it won't let me cast to the type you mentioned.\n. Hmm, isn't this [String: [[String: Any]]] an dictionary of an array of dictionaries? What I need is basically something like this: \nif let user = Mapper<MeasurementsTransfer>().mapDictionaryOfArrays(JSON: response.result.value as! [String : [Measurement]]) {\nMy MeasurementsTransfer contains the dictionary itself and the Measurement is the objects in the array.\n. But how am I able to cast an array to a dict? The compiler doesn't complain, but it doesn't work.\n. The JSON I get back is [String: [Measurement]], if I mistyped anything I apologize. \n. Sure, like this (I shortened it severely):\n{\n  \"2443\": [\n    {\n      \"id\": 354299,\n      \u201csId\": 2443,\n    },\n    {\n      \"id\": 354300,\n      \u201csId\": 2443\n    }\n],\n\"2448\": [\n    {\n      \"id\": 354312,\n      \"fieldId\": 2448\n    },\n   {\n      \"id\": 354300,\n      \u201csId\": 3728\n    }]\n}\n. I want my JSON mapped into object, does this do that as well?\n. @devxoul Sure, my models are as the following:\nThe real model class:\n```\nclass Measurement : EVObject, Mappable {\n    var id : Int = 0\n    var sId : Int = 0\nrequired init?(map: Map) {\n    super.init()\n    mapping(map: map)\n}\n\nrequired init() {\n    //super.init()\n}\n\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    sId <- map[\"sId\"]\n}\n\n```\nThe mapping model:\n```\nclass MeasurementsTransfer: EVObject, Mappable {\nvar measurement : [String : [Measurement]] = [:]\n\nrequired init?(map: Map) {\n\n}\n\nrequired init() {\n    //super.init()\n}\n\nfunc mapping(map: Map) {\n    measurement <- map\n}\n\n}\n```\nWhat I'm trying to accomplish is to map the following JSON into MeasurementTransfer objects:\n{ \n\"2443\": [ { \"id\": 354299, \u201csId\": 2443, }, { \"id\": 354300, \u201csId\": 2443 } ], \n\"2448\": [ { \"id\": 354312, \"fieldId\": 2448 }, { \"id\": 354300, \u201csId\": 3728 }] \n}\n. @devxoul  3, since I only need one MeasurementTransfer because it contains a dict of [String : [Measurement]], as in the JSON.\n. @devxoul I can't alter the JSON on the backend, is has to stay that way :-/ \n. @devxoul Hmm, I get this crash using your code:\n\n. @devxoul It doesn't tell me, but debugging I can see it is one of these lines:\nlet measurementJSONs = response.result.value as! [String: [String: Any]]\nlet measurementsTransferJSON = [\"measurements\": measurementJSONs]\nif let ms = Mapper<MeasurementsTransfer>().map(JSON: measurementsTransferJSON) {\nDo you know what kind crash the mentioned is? I haven't seen it before.\n. @devxoul It seems it is this one:\n`let measurementJSONs = response.result.value as! [String: [String: Any]]`\nIt makes sense, since it is not a [String: [String : Any]] I get from the JSON, but [String : [Any]]\n. @devxoul This works better:\nlet measurementJSONs = [\"measurements\" : response.result.value]\n            print(measurementJSONs)\n            if let ms = Mapper<MeasurementsTransfer>().mapDictionary(JSON: measurementJSONs as! [String : [String : Any]]) {\n                print(ms)\nHowever, my dictionary looks funny:\n```\n[\"measurements\": MeasurementsTransfer {\n   hash = 0\n   measurements = {\n}\n}\n]\n```\n. Same result :-/\n. @devxoul My output before I map looks like this:\n[\"measurements\": {\n    2396 = ( {\n            id = \"21313\";\n            sid = \"43847\";\n        },\n       {\n            id = \"21314\";\n            sid = \"43841\";\n        }\n    );\n2397 = ( {\n            id = \"43237\";\n           sid = \"37321\";\n        },\n                {\n           id = \"43231\";\n           sid = \"37342\";\n        }\n);\n}\n]\nIt looks like invalid JSON above? But it's just the output from Alamofire? @tristanhimmelman \nIn the browser it looks like this:\n{ \n\"2396\": [ { \"id\": 21313, \"sId\": 43847, }, { \"id\": 21314, \"sId\": 43841 } ], \n\"2397\": [ { \"id\": 43237, \"sId\": 37321 }, { \"id\": 43231, \"sId\": 37342 }] \n}\nBut the mapping still looks like this:\n[\"measurements\": MeasurementsTransfer {\n   hash = 0\n   measurements = {\n}\n}\n]\n. @tristanhimmelman Just my mistake, I alter the JSON a bit, but doesn't it seem that the JSON Alamofire outputs is invalid? The actual call JSON is valid, I've checked.\nI also tried to use AlamofireObjectMapper, but since my key ain't a name, but IDs, i get: \nThe class 'Optional(\"MeasurementsTransfer\")' is not key value coding-compliant for the key '2453'\n. @devxoul Just changed it, compiles now, but still leaves null in my object date property.\n. Got this solved, using Date() instead of NSDate did it, thanks!\n. ",
    "rjndra": "I faced similar issue but taken some approach to get my desired result.\nHere is json file:\nhttps://gist.github.com/rjndra/af568b276443b16204e61dfcb1ac2257\nAnd the mappable Object is:\n```\nstruct Category: Mappable {\n    var id:String?\n    var title: String?\n    var image:String?\n    var children:Dictionary?\ninit?(map: Map) { }\n\nmutating func mapping(map: Map) {\n    id <- map[\"id\"]\n    title <- map[\"title\"]\n    image <- map[\"image\"]\n    children <- map[\"children\"]\n}\n\n}\n```\nFinally the implementation:\n```\nimport SwiftyJSON\nimport Alamofire\nimport ObjectMapper\nclass ViewController: UIViewController {\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n\n\n    let url = \"apiurl\"\n\n    let request = Alamofire.SessionManager.default.request(url, method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil)\n\n    request.responseJSON { (response) in\n        if let value = response.result.value {\n\n            var returnData:[(key:String,value:Category?)] = []\n            if let val = value as? Dictionary<String,Any> {\n                print(val)\n\n                let data = val.map({ (value) -> (key: String, value:Category?) in\n                    if let newValue:Category = JSON(value.value).map() {\n                        return (key:value.key,value: newValue)\n                    }\n                    return (key: value.key, value: nil)\n                })\n                returnData = data\n            }\n            print(returnData) //here you get tuples of your dictionary so save this tuple anywhere\n        }\n    }\n\n// Now json from local directory for same json mentioned.\n/*\n        if let filePath = Bundle.main.url(forResource: \"response\", withExtension: \"json\") {\n        let data = try? Data(contentsOf: filePath)\n        let json = JSON(data!)\n\n        var returnData:[(key:String,value:Category?)] = []\n        if let val = json.rawValue as? Dictionary<String,Any> {\n            print(val)\n\n            let data = val.map({ (value) -> (key: String, value:Category?) in\n                if let newValue:Category = JSON(value.value).map() {\n                    return (key:value.key,value: newValue)\n                }\n                return (key: value.key, value: nil)\n            })\n            returnData = data\n        }\n        print(returnData)\n    }\n\n*/\n}\n\n}\n```\nOne more extension:\n```\nextension JSON {\n    func map() -> [T]? {\n        let json = self.array\n        let mapped: [T]? = json?.flatMap({$0.map()})\n        return mapped\n    }\nfunc map<T: Mappable>() -> T? {\n    let obj: T? = Mapper<T>().map(JSONObject: self.object)\n    return obj\n}\n\n}\n```. ",
    "RickPasveer": "in pod spec:\ns.source_files = 'ObjectMapper/**/*.swift'\nshould be:\ns.source_files = 'Sources/**/*.swift'\n634\n. ",
    "innocarpe": "+1\n. ",
    "Jake000": "777 should have resolved this. It now checks for NSNumber first which passes the check and pulls the decimal value out of it, so nil will no longer be returned but 1.0.. Unfortunately this is not caused by this library. After some investigation I have found that NSJSONSerialization will decode numbers as doubles before falling back on NSDecimalNumber when the value is too large to fit into the Double type, as described here: http://stackoverflow.com/a/39553617\nEssentially the first step from converting JSON data to a Swift Dictionary [String: Any] introduces the Double type, and this is then passed into this library to map. From there it is converting Double to NSDecimalNumber, but the precision is already lost.\nThe result is that if you require precision you should encode your numbers as Strings in JSON.\n```Swift\nlet jsonString = \"{\\\"quantity\\\": 0.691}\"\nlet data = jsonString.data(using: .utf8)!\nlet json = (try? JSONSerialization.jsonObject(with: data, options: [])) as? [String: Any]\nlet value = json![\"quantity\"]!\nprint(\"(type(of: value)) (value)\")\n// prints __NSCFNumber 0.6909999999999999\n```\nUsing a String to hold the JSON number, and using your example to map the model into an object instead yields:\n```Swift\nlet jsonString = \"{\\\"quantity\\\": \\\"0.691\\\"}\"\nlet repo = Mapper().map(JSONString: jsonString)\nlet value = repo!.quantity!\nprint(\"(type(of: value)) (value)\")\n// prints NSDecimalNumber 0.691\n```. The best solution would be to use Strings to hold numbers in JSON.\nUsing the previous example, the first option would be much more preferable to the second as it will be decoded as a String which can be converted lossless to a decimal number.\nJSON\n{ \"quantity\": \"0.691\" }\nJSON \n{ \"quantity\": 0.691 }\nIf you are not able to change the incoming JSON (eg. it is from a service you do not own) then you can always round the result to 3 decimal places.\n```Swift\nextension NSDecimalNumber {\n    func rounded(places: Int) -> NSDecimalNumber {\n        var decimalValue = self.decimalValue\n        var result: Decimal = 0\n        NSDecimalRound(&result, &decimalValue, places, .plain)\n        return NSDecimalNumber(decimal: result)\n    }\n}\nlet jsonString = \"{\\\"quantity\\\": 0.691}\"\nlet data = jsonString.data(using: .utf8)!\nlet json = (try? JSONSerialization.jsonObject(with: data, options: [])) as? [String: Any]\nlet value = json![\"quantity\"] as! Double\nlet decimal = NSDecimalNumber(value: value)\nlet rounded = decimal.rounded(places: 3)\nprint(\"(type(of: rounded)) (rounded)\")\n// prints NSDecimalNumber 0.691\n```\nYou can wrap this up in your own transform by subclassing the existing:\nSwift\nopen class RoundedDecimalNumberTransform: NSDecimalNumberTransform {\n    open override func transformFromJSON(_ value: Any?) -> NSDecimalNumber? {\n        return super.transformFromJSON(value)?.rounded(places: 3)\n    }\n}. ",
    "Sweefties": "@alexsanderkhitev did you find one solution? . ",
    "ilkerc": "This is so inconvenient.. I have 15 models in my project and on each it looks like I have duplicate code for just one simple operation switch. I know that the ref/val type must be declared in compile time. However, can we do better that ?\n@tristanhimmelman do we have a better solution ?. ",
    "rbukovansky": "@devxoul Could you please repost your reply? It disappeared from here. Thanks.\n. @wassimseif As I was mentioning, I had resolved issues with Cocoa, but those in build log don't seem to be related to Cocoa framework.. Yup, build is fine now, thanks @foldericon, but is there a plan to have full test suite for Linux as well?. ",
    "wassimseif": "I think the problem is that ObjectMapper uses Cocoa  which is not open source and it's not available on linux . Doesn't build on mac using swift 3.0 or 3.0.1. Use of  unresolved identifier 'NSNull'. ",
    "pournam": "Hello, is there any update on this? I'm having the same exact errors, it would be ideal to have this swift JSON mapper available where JSON is used the most, server side. \nThanks!. ",
    "foldericon": "I still have issues on Linux with newest 2.2.3\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/TransformOperators.swift:251:47: error: cannot convert value of type '[String : AnyObject]' to type 'AnyObject?' in coercion\n                let value = fromJSONDictionaryWithTransform(object as AnyObject?, transform: transform) ?? left\n                                                            ^~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/TransformOperators.swift:271:47: error: cannot convert value of type '[String : AnyObject]' to type 'AnyObject?' in coercion\n                let value = fromJSONDictionaryWithTransform(object as AnyObject?, transform: transform) ?? left\n                                                            ^~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/TransformOperators.swift:291:63: error: cannot convert value of type '[String : AnyObject]' to type 'AnyObject?' in coercion\n                let transformedDictionary = fromJSONDictionaryWithTransform(dictionary as AnyObject?, transform: transform) ?? left\n                                                                            ^~~~~~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/TransformOperators.swift:455:31: error: cannot convert value of type 'Array<AnyObject>' to type 'AnyObject?' in coercion\n                        fromJSONArrayWithTransform(values as AnyObject?, transform: transform)\n                                                   ^~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/TransformOperators.swift:479:31: error: cannot convert value of type 'Array<AnyObject>' to type 'AnyObject?' in coercion\n                        fromJSONArrayWithTransform(values as AnyObject?, transform: transform)\n                                                   ^~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/TransformOperators.swift:503:31: error: cannot convert value of type 'Array<AnyObject>' to type 'AnyObject?' in coercion\n                        fromJSONArrayWithTransform(values as AnyObject?, transform: transform)\n                                                   ^~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/NSDecimalNumberTransform.swift:42:20: error: argument labels '(value:)' do not match any available overloads\n            return NSDecimalNumber(value: double)\n                   ^              ~~~~~~~~~~~~~~~\n/root/Projects/Server/Packages/ObjectMapper-2.2.3/Sources/NSDecimalNumberTransform.swift:42:20: note: overloads for 'NSDecimalNumber' exist with these partially matching parameter lists: (decimal: Decimal), (string: String?), (coder: NSCoder), (floatLiteral: Double), (booleanLiteral: Bool), (integerLiteral: Int)\n            return NSDecimalNumber(value: double)\nswift --version is\nSwift version 3.0.2 (swift-3.0.2-RELEASE)\nTarget: x86_64-unknown-linux-gnu. @tristanhimmelman I created a pull request in case you didn't notice. It is not needed to use Any throughout, only for fromJSONArrayWithTransform and fromJSONDictionaryWithTransform.\nAlso NSDecimalNumber does not have the (value:) initialiser on Linux. It needs to be changed to (floatLiteral:) which works fine on all platforms.. @AnthonyOliveri cd Packages/ObjectMapper-2.2.3 && git pull. @AnthonyOliveri I am not a maintainer of this project, I just tried to provide a temporal workaround. Hopefully they will add some more flexibility to SPM soon.. ",
    "stefanhp": "Hi,\nUnfortunately I tried to isolate this in a test project, but it would not crash outside the original project...\nBut I found this radar bug: iOS 10 Beta 6 - Swift 3 - JSONSerialization EXC_BAD_ACCESS and the linked gist.\nThis could explain it: depending on what happened in the runtime before, the call may or may not crash. Prior to calling isValidJSONObject ObjectMapper transforms the object into a dictionary of String:Any and the object I'm transforming contains Strings.\nSince this seems to be a known Foundation issue, I guess you cannot do much about it. If so, I let you close the bug.\n. ",
    "zemadara": "this error come to the url, with Swift 3.0 we are some new Optional() that appears when we get Int value\n. ",
    "jd230912": "@devxoul Sure, i'll do it tomorrow.\n. ",
    "andre991": "+1\n. @gcharita Do you have any plans to merge this pull request?. Ok, thanks @gcharita.  @tristanhimmelman Do you have any plans to merge this pull request?. ",
    "TopalSergey": "I think this can be helpful to people, that come to related thread. To avoid separating toJson and fromJson mapping, you can use functions, like this:\n```\n   func from(_ obj: T) -> ((inout T) -> ())? {\n        switch mappingType {\n        case .toJSON:\n            obj >>> self\n            return nil\n    case .fromJSON:\n        return { (v: inout T) in\n            v <- self\n        }\n    }\n}\n\n/// Optional object of basic type\nfunc from<T>(_ obj: T?) -> ((inout T?) -> ())? {\n    switch mappingType {\n    case .toJSON:\n        obj >>> self\n        return nil\n\n    case .fromJSON:\n        return { (v: inout T?) in\n            v <- self\n        }\n    }\n}\n\n/// Object conforming to Mappable\nfunc from<T: BaseMappable>(_ obj: T) -> ((inout T) -> ())? {\n    switch mappingType {\n    case .toJSON:\n        obj >>> self\n        return nil\n\n    case .fromJSON:\n        return { (v: inout T) in\n            v <- self\n        }\n    }\n}\n\n/// Optional Mappable objects\nfunc from<T: BaseMappable>(_ obj: T?) -> ((inout T?) -> ())? {\n    switch mappingType {\n    case .toJSON:\n        obj >>> self\n        return nil\n\n    case .fromJSON:\n        return { (v: inout T?) in\n            v <- self\n        }\n    }\n}\n\n```\nand use it in mapping:\n```\n    override func mapping(map: Map) {\n        map[\"id\"].from(id)?(&id)\n        map[\"name\"].from(name)?(&name)\n    }\n```\nAlso, if you use operators to map Dictionaries, Arrays, operators with TransformType, you should write several similar functions.\n. ",
    "nadeemkhoury": "Thank you so much, can you help where I can find old versions ?\n. Thank you much my friend. \n. ",
    "jlyonsmith": "Damn.  After reading this I switched to Marshal.  It's more verbose and not as well documented, but that's a significant performance improvement.  Sorry chaps!\n. I'm working on a new icon.  I'll use the full name for now, although I think people are going to use SPM pretty commonly once it's get going.\n. ",
    "AviDutta": "@tristanhimmelman Is there any update about getting the lazy mapping sometime soon?. ",
    "sakkeerhussain": "This solved my issue, Thanks @devxoul.\n. ",
    "lacklock": "ok, i will do that tommorrow morning. it's midnight in China.\n. but where should I put the md file?\n. i have commit that PR.\n. i plan when ImmutableMappable release translte it.\nAnd Installation i think every developers can understand it ,  doesn't need to translate.\nIf you think it's would be better translate full content, i would finish it all.\nI am going to finish that. tks.\n. done!\n. ",
    "arctouch-marcelogobetti": "@devxoul Probably I didn't understand your point, but from what I got: ImmutableMappable's mapping comes from BaseMappable, where its signature is not marked with throws, so you'll get a warning if you add try on it. Anyway using try? on the init method would be a code improvement over what I've done here. I'll wait for your feedback to fix this further.\n. Hi @devxoul, by putting a breakpoint on this map method where the assertion failed, it seems that the problem is coming from this line in my code:\nreturn self.provider.request(type).mapObject(GenericResponse.self)\nwhere I'm using Moya/ObjectMapper to map an Observable<Response> into an Observable<GenericResponse> (GenericResponse is another struct of mine that also implements ImmutableMappable).\nThis is Moya/ObjectMapper's signature for mapObject:\npublic func mapObject<T : BaseMappable>(_ type: T.Type) -> RxSwift.Observable<T>\nSo it is just requiring that the base protocol is implemented, thus ImmutableMappable is accepted, but then ObjectMapper internally recognizes only StaticMappable and Mappable, failing the assertion otherwise.\nBy the way, notice that the assert message considers ImmutableMappable, but N.self is not tested against it in that method.\n. That's great, @devxoul , thank you!\nI'm closing this PR then. It still feels odd to me that the map method here has a message considering ImmutableMappable, but the code that comes right above it, does not. Why creating a new set of mapObject and mapArray functions specifically typed to ImmutableMappable is a better solution? I know it probably is, but wasn't able to find this information in the commit message so I'm asking here. Thanks once again!\n. Not sure if I understood. What kind of change do you mean? Applying your fix in Moya-ObjectMapper isn't a code change? What about other repositories that make use of ObjectMapper? Is Moya-ObjectMapper the only one that had a chance to access a method that fails an assertion whenever the class implementing BaseMappable does not implement either Mappable or StaticMappable? Thanks again!\n. No, I mean that you probably had 2 solutions for that problem:\n1) considering ImmutableMappable inside the asserting method that doesn't consider this protocol\n2) creating another set of map<T> method, specifically for ImmutableMappable, so that it (shouldn't) doesn't get into the generic BaseMappable existing one\nYou adopted number 2, which on a first look, seems a little more problematic to maintain than number 1. Number 1 would keep the map<T> methods generic and only internally handle the situation, which seemed to be previewed as per the assertion message, but wasn't really implemented (again, the message quotes Mappable, StaticMappable and ImmutableMappable, but the code does only account for the first two).\nWhat happens if a 4th variant from BaseMappable is created? Will we create again a new set of methods for it, or create a new else if to consider it without failing the assertion?\nAlso, the assertion is stating that I should not implement BaseMappable directly, but this is misleading, because I didn't do that. I did implement ImmutableMappable.\n. I get it now @devxoul , this is exactly the answer I was looking for. I felt it was something like that, so I immediately closed my PR, I just wanted a confirmation. This is great. So I'll move my focus to fixing Moya-ObjectMapper and if you'd like, I can open a PR for ObjectMapper adding a new assertion and changing the message on the existing one. Thank you!\n. ",
    "lukewar": "Hey, sure. Double checking if I understood you right. Do you propose to define operators for ImmutableMapper, that will throw?\n. Oh, ok. I misunderstood you then :). Sure, I will update this.\n. Implementation is updated. TBH I don't know why travis is failing. All tests passed for those builds.\n. ",
    "mvpscottjon": "Excuse me for asking the similiar problem,\nuse upon case for asking:\nclass Day: Mappable {\n    var groups: [String: Group]?\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    groups <- map[\"\"]\n}\n\n}\nin this code\nfunc mapping(map: Map) {\n        groups <- map[\"\"]\n    }\nwhat's the map[\"?\"]     <------------  //////what should  I fill in \"?\"\ndid I  fill \"questions.value\"? or what?\n. ",
    "vimalp015": "public class Data {\n    @SerializedName(\"questions\")\n    @Expose\n    private Map result;\n//....\n\n}. ",
    "iShawnWang": "What I want is define a basic model for a part of JSON data, no the whole JSON\n{\n    \"type\": 1,\n    \"portraitimgurl\": \"/upload/product/firstlevel/shushangzhuang.jpg\",\n    \"landscapeimgurl\": \"/upload/product/firstlevel/henshangzhuang.jpg\",\n    \"count\": 0\n}\nThe model like :\n```\nclass ImageModel: Mappable {\n    var type: Int?\n    var portraitimgurl: String?\n    var landscapeimgurl: String?\n    var count: Int?\ninit?(_ map: Map){}\n\nfunc mapping(){\n    type <- map[\"type\"]\n    portraitimgurl <- map[\"portraitimgurl\"]\n    landscapeimgurl <- map[\"landscapeimgurl\"]\n    count <- map[\"count\"]\n}\n\n}\n```\nSo, if i have a complicated JSON, i just need to define a simple model, not a lot of nested model.\nI think keyPath is a very common usage for JSONModel, i am looking forward to this new feature.. - I just found some build in transformer in Tests/CustomTransformTests.swift, this helps a lot\n- But I still hope some basic transform can be done automatically, such as String -> Int , instead of (map[ \"xxx\" ], StringToIntTransform()). ",
    "klevison": "+1. ",
    "yasirmturk": "+100. ",
    "mikkelam": "Yes, I am sorry i did not specify. Do you know how I could solve this?. Like this\n[\n  MarketEstimate(year: 2000, mileage: 0, price: 12830),\n  MarketEstimate(year: 2000, mileage: 10000, price: 11041),\n   MarketEstimate(year: 2001, mileage: 0, price: 12830),\n  MarketEstimate(year: 2001, mileage: 10000, price: 11041),\n]. @altagir The reason I did not use a dictionary is because it is not supported by Realm.. ",
    "jsslai": "Do you have any alternative solution which could work for every dictionary of dictionaries? I'm using Firebase where every array is stored as dictionaries like in @mikkelam 's example.. I ended up writing a custom mapping method which tries to map array or dictionary to array. In dictionary case key is passed by using Context.\n```swift\nextension Map {\n    func valueFromArrayOrDictionary(_ key: String, nested: Bool? = nil, delimiter: String = \".\", file: StaticString = #file, function: StaticString = #function, line: UInt = #line) throws -> [Element] {\n        let currentValue = self.currentValue(for: key, nested: nested, delimiter: delimiter)\n    guard let JSONObject = currentValue else {\n        throw MapError(key: key, currentValue: currentValue, reason: \"Found unexpected nil value\", file: file, function: function, line: line)\n    }\n\n    return try Mapper<Element>().mapArrayOrDictionary(JSONObject: JSONObject)\n}\n\nfileprivate func currentValue(for key: String, nested: Bool? = nil, delimiter: String = \".\") -> Any? {\n    let isNested = nested ?? key.contains(delimiter)\n    return self[key, nested: isNested, delimiter: delimiter].currentValue\n}\n\n}\nextension Mapper where N: ImmutableMappable {\n    func mapArrayOrDictionary(JSONObject: Any) throws -> [N] {\n        if let dictionary = JSONObject as? [String: Any] {\n            return try dictionary.map { try N(JSONObject: $0.value, context: FirebaseContext(key: $0.key)) }\n        } else if let array = JSONObject as? [Any] {\n            return try array.map { try N(JSONObject: $0) }\n        } else {\n            throw MapError(key: nil, currentValue: JSONObject, reason: \"Cannot cast to '[String: Any] or [Any]\")\n        }\n    }\n}\n```. Sorry this was my error. I've been updating my code from my custom mapper class to ObjectMapper and forgot I had implemented my protocol (which inherits from ImmutableMappable now) for String. \ud83d\ude04  . ",
    "altagir": "simple way:\nclass MarketEstimate {\n    var price: Int!\n    var mileage: Int!\n}\nclass MarketEstimates {\n   var market_estimates:Dictionary<String, MarketEstimate >!\n}\nthen you would have get your structure in market_estimates[\"2000\"], but without the year inside the struct...\n. ",
    "AashishSapkota": "Oh thank you so much. \ud83d\udc4d I dint even thought abt that... Oh! I'm really sorry for opening this as an issue.\nBy the way the solution would be to map the data using for in loop as below:-\n     var ReferralTblData = [Referral]()\n                for items in tblData{\n                    if let u = Mapper<Referral>().map(items) {\n                        ReferralTblData.append(u)\n                    }\n       }\n       print(ReferralTblData).\n",
    "jleach": "Consulted the docs again. Mistake is on me. . ",
    "ttuygun": "Thank you so much @tristanhimmelman and @devxoul . it means json data is chaning, so I want to model chanable data's model. e.g. from my code. titles come as Title model format or Tag model format. So I defined as Any for the changeable data type in JSON.. Please look at the titles arrays' of the JSON. First one is:\nJSON\n{\n    \"info\": {\n        \"mode\": \"today\"\n    },\n    \"last_modified\": \"2016-12-31T15:50:17+0200\",\n    \"pagination\": {\n        \"per_page\": 50,\n        \"total_objects\": 422,\n        \"current_page\": 1,\n        \"total_pages\": 9\n    },\n    \"titles\": [\n        {\n            \"id\": 12123112,\n            \"title\": \"this is title\",\n            \"share_count\": {\n                \"facebook\": 0,\n                \"twitter\": 0,\n                \"linkedin\": 0,\n                \"total\": 0\n            },\n            \"url\": \"https://asdad\",\n            \"today_count\": 4,\n            \"latest_entry\": 16642843\n        },\n        {\n            \"id\": 19887515,\n            \"title\": \"this is title 2\",\n            \"share_count\": {\n                \"facebook\": 0,\n                \"twitter\": 0,\n                \"linkedin\": 0,\n                \"total\": 0\n            },\n            \"url\": \"https://asdas\",\n            \"today_count\": 7,\n            \"latest_entry\": 342423553\n        }]\n}\nSecond one is.\nJSON\n{\n    \"info\": {\n        \"mode\": \"tags\"\n    },\n    \"last_modified\": \"2016-12-31T15:45:11+0200\",\n    \"pagination\": {\n        \"per_page\": 50,\n        \"total_objects\": 129,\n        \"current_page\": 1,\n        \"total_pages\": 3\n    },\n    \"titles\": [\n        {\n            \"id\": 29822,\n            \"value\": 29822,\n            \"score\": 0,\n            \"label\": \"abc\",\n            \"name\": \"abc\"\n        },\n        {\n            \"id\": 15,\n            \"value\": 15,\n            \"score\": 0,\n            \"label\": \"def\",\n            \"name\": \"def\"\n        }]\n}. ",
    "vinothvino42": "Adding an empty initializer solves the problem.\ninit() {\n\n }.\n",
    "kristopher8": "Why\u001b$B!$\u001b(Bif there are hundreds of thousands of attributes \u001b$B!$\u001b(Bthere is no shorthand way to map\u001b$B!)\u001b(B\nGet Outlook for iOShttps://aka.ms/o0ukef\nOn Tue, Nov 29, 2016 at 1:53 AM +0800, \"Tristan Himmelman\" notifications@github.com<mailto:notifications@github.com> wrote:\nClosed #685https://github.com/Hearst-DD/ObjectMapper/issues/685.\n-\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/Hearst-DD/ObjectMapper/issues/685#event-874024544, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AOP4sDrjrXxqJddNJzisUtOurBeg7bHLks5rCxT-gaJpZM4K9s8a.\n. Select the ObjectMapper.xcodeproj in the Project Navigator and verify the deployment target matches that of my application target.\nIn the tab bar at the top of that window, open the \"General\" panel.\nClick on the + button under the \"Embedded Binaries\" section. ",
    "Dharin-shah": "Casting value to Dictionary ([AnyHashable : Any]) worked. . ",
    "sazoum": "Also, I have updated to the latest ObjectMapper version, 2.2.1. Thank you for any assistance. . ",
    "liyanhuadev": "i thank, it should be \n`\nclass ResponseArrayModel: Mappable {\nvar data: [T]?\nvar code: Int = 0\n}\n. you need have two response model,one handler object, the other one handler array object.\nclass Response< T >: Mappable {\n    var data: T?\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    data <- map[\"data\"]\n}\n\n}\nmapping code:Mapper >().map(JSONObject: \"your json\")`. ",
    "frontier17": "thanks, \nif data just a string like;\n{\"code\":0,\"data\":\"XXX\"}\n. yes I understand for array, but what will I do for just string? one more response model?. ",
    "nearspears": "what is your final solution ? i have the same problem. ",
    "liltimtim": "So I believe I may have solved my own issue...\nI still do not know why the built in ISO date formatter doesn't work however I created my own\n```\nimport Foundation\nimport ObjectMapper\nopen class ISODateTransform: TransformType {\n    public typealias Object = Date\n    public typealias JSON = String\npublic init() {}\n\npublic func transformFromJSON(_ value: Any?) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n\n    guard let strValue = value as? String else { return nil }\n    return formatter.date(from: strValue)\n}\n\npublic func transformToJSON(_ value: Date?) -> String? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n    guard value != nil else { return nil }\n    return formatter.string(from: value!)\n}}\n\n```\nthis seems to work just fine, unit tests are passing with valid dates now. . ",
    "patrikqvarnstrom": "Just to add to this. I couldn't get the solution above to work but it did steer me into the right directions so much appreciated. I made some tweaks and this works for me. \n```\n//\n//  ISODateTransform.swift\n//\nimport Foundation\nimport ObjectMapper\nopen class ISODateTransform: TransformType {\n    public typealias Object = Date\n    public typealias JSON = String\npublic init() {}\n\npublic func transformFromJSON (_ value: Any?) -> Date? {\n    guard let datestring = value as? String else { return nil }\n    let isoFormatter = ISO8601DateFormatter()\n    let date = isoFormatter.date(from: datestring)!\n\n    return date\n}\n\npublic func transformToJSON(_ value: Date?) -> String? {\n    let isoFormatter = ISO8601DateFormatter()\n    let string = isoFormatter.string(from: value!)\n\n    return string\n}\n\n}\n```. ",
    "gperdomor": "I solved it, i can access to map.JSON xD. I wanna use ObjectMapper to handle post data. It's possible?. ",
    "douglasjunior": "I removed the JSON Boolean quotes and it worked.. ",
    "grifas": "Hi, \nI have the same issue. Have you fixed it ? . @marcusjwhelan I didn't close this issue. But I resolved my issue using ISO8601DateTransform or CustomDateFormatTransform.. Up. ",
    "marcusjwhelan": "@grifas why is this closed? I have the same issue. . ",
    "mayooresan": "You need to write your own Transform by conforming to the protocol TransformType. I got my dates in the following format \"10/13/2018 12:00:00 AM\". This is how I wrote the code. check this link for date formatters. \n```\nimport Foundation\nimport ObjectMapper\n//for custom date formatting in json parsing\nopen class NTDateTransform: TransformType {\n    public typealias Object = Date\n    public typealias JSON = String\npublic init() {}\n\nopen func transformFromJSON(_ value: Any?) -> Date? {\n    if let timeInt = value as? Double {\n        return Date(timeIntervalSince1970: TimeInterval(timeInt))\n    }\n\n    if let timeStr = value as? String {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"MM/dd/yyyy HH:mm:ss a\"\n        return formatter.date(from: timeStr)\n    }\n\n    return nil\n}\n\nopen func transformToJSON(_ value: Date?) -> String? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"MM/dd/yyyy HH:mm:ss a\"\n    if let date = value {\n        return formatter.string(from: date)\n    }\n    return nil\n}\n\n}\n```\n. ",
    "bolee": "@devxoul I had parsed it by Mapper, but I want Mappale, is it support?. ",
    "EvilNOP": "let transform = TransformOf(fromJSON: { (value: String?) -> Int? in \n    // transform value from String? to Int?\n    return Int(value!)\n}, toJSON: { (value: Int?) -> String? in\n    // transform value from Int? to String?\n    if let value = value {\n        return String(value)\n    }\n    return nil\n})\nid <- (map[\"id\"], transform)\nInt to String transform should be built in?. ",
    "santhoshs5": "{\n    username = santhosh;\n    \"identifier\" = \"IDJSDJSJS\";\n    configstatus = SET;\n    configtype = DEFAULT;\n    \"data_center\" = \"evs.idrive.com\";\n    devices =     {\n        \"Ankita\\LKKKK\" =         {\n            identifier = LJJDFDD;\n            name = \"Ankita iPAD\";\n            type = iPad;\n        };\n         \"ARUN\\LKKKHJH\" =         {\n            identifier = LJJDFDFFD;\n            name = \"ARUN iPhone\";\n            type = ipHone;\n        };\naccountStatus = 2;\nacctype = Test;\n\n}. Thanks guys , How can I declare if i want to use the same object with Realm.\nRealm does not support dictionaries\nclass UserInfo:Object,Mappable\n{\nvar name:String?\nvar identifier:String?\nvar accountType:String?\nvar devices:[UserDevice]?\nrequired init?(map: Map) {\n}\n// Mappable\nfunc mapping(map: Map) {\n    name    <- map[\"username\"]\n    identifier         <- map[\"identifier\"]\n    accountType       <- map[\"accountType\"]\n    devices  <- map[\"devices\"]\n}\n}\nclass UserDevice:Object,Mappable\n{\nvar deviceName:String?\nvar deviceType:String?\nvar deviceIdentifier:String?\nrequired init?(map: Map) {\n}\n// Mappable\nfunc mapping(map: Map) {\n    deviceName    <- map[\"name\"]\n    deviceType         <- map[\"type\"]\n    deviceIdentifier       <- map[\"identifier\"]\n}\n}\n. ObjectMapper is converting ' is converting to some other junk charater by default.\nPlease recommend me best approach to do removingPercentEncoding from my side. ",
    "macecchi": "Anyone? :(. @devxoul Sure. \nThe sample json of a Ride object:\n{\n    \"id\": 3059,\n    \"place\": \"asdasda\",\n    \"slots\": 6,\n    \"description\": \"dasdasd\",\n    \"date\": \"2016-11-29\",\n    \"time\": \"10:00:00\"\n}\nMy expected model would only have a single date: Date property, which maps the results from date and time to this one property.\n```\nclass Ride: Object, Mappable {\n    dynamic var id: Int = 0\n    dynamic var place: String!\n    dynamic var notes: String!\n    dynamic var slots: Int = 0\n    dynamic var date: Date! = Date()\nrequired convenience init?(map: Map) {\n    self.init()\n}\n\noverride static func primaryKey() -> String? {\n    return \"id\"\n}\n\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    place <- map[\"place\"]\n    notes <- map[\"description\"]\n    date <- map[\"date\"] // This should actually use map[\"date\"] and map[\"time\"]\n    slots <- map[\"slots\"]\n}\n\n}\n``. The reverse would also have to apply. When exporting the model to JSON, I expect those two properties again. I have tried building a customTransform` but I couldn't figure out how to handle multiple properties.. Thanks, @devxoul! \nIt kind of works for me. I had to add some further hacks to make it work when serializing the date/time to JSON and to make it work with Realm.\nBecause I did not want to store those two private properties in my Realm, I added them to my ignoredProperties. But, to serialize them back, I had to make _dateString and _timeString computed properties (which get the string from date) and convert the didSet and updateDate to set and two methods (updateDate, updateTime). \nHere's my solution:\n```swift\nclass Ride: Object, Mappable {\n    dynamic var id: Int = 0\n    dynamic var place: String!\n    dynamic var notes: String!\n    dynamic var slots: Int = 0\n    dynamic var date: Date! = Date()\nrequired convenience init?(map: Map) {\n    self.init()\n}\n\noverride static func primaryKey() -> String? {\n    return \"id\"\n}\n\noverride static func ignoredProperties() -> [String] {\n    return [\"_dateString\", \"_timeString\"]\n}\n\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n    place <- map[\"place\"]\n    notes <- map[\"description\"]\n    slots <- map[\"slots\"]\n\n    _dateString <- map[\"mydate\"]\n    _timeString <- map[\"mytime\"]\n}\n\nprivate var _dateString: String? {\n    get {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"yyyy-MM-dd\"\n        return formatter.string(for: date)\n    }\n    set {\n        updateDate(newValue)\n    }\n}\n\nprivate func updateDate(_ newDate: String?) {\n    guard let dateString = newDate, let timeString = _timeString else { return }\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    self.date = formatter.date(from: dateString + \" \" + timeString)\n}\n\nprivate var _timeString: String? {\n    get {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"HH:mm:ss\"\n        return formatter.string(for: date)\n    }\n    set {\n        updateTime(newValue)\n    }\n}\n\nprivate func updateTime(_ newTime: String?) {\n    guard let dateString = _dateString, let timeString = newTime else { return }\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    self.date = formatter.date(from: dateString + \" \" + timeString)\n}\n\n}\n```. ",
    "magolla": "But i receive an array of ActivityLogDTO.. Hi!\nI try this but get this error:\n\nGenericArrayResponse class:\n\n. It's work! You are a genius!\nThanks you! :). ",
    "kuyazee": "Hi I'm having the same problem now and the language I use is Swift 4\nIs there a shorter way to do this without creating more boilerplate? . ",
    "nasserkhosravi": "I have same problem too.. ",
    "Schumi2k10": "yeah it is: s.tvos.deployment_target = '9.0'. ",
    "edouardlib": "No idea?. ",
    "hariseldon78": "i confirm the same problem with the same error messages. i'm using the last versions of Alamofire and AlamofireObjectMapper. Yes, I still have the problem with the 2.2.3 release: \n```\ndyld: lazy symbol binding failed: Symbol not found: __TFC12ObjectMapper6MapperCfT7contextGSqPS_10MapContext___GS0_x_\n  Referenced from: /Users/robertoprevidi/Library/Developer/CoreSimulator/Devices/3AA91D00-8D2B-40C0-93AE-2C2BD6822BB3/data/Containers/Bundle/Application/E08687C3-4F6F-4428-8BBC-AAF411FD0F07/Municipium.app/Frameworks/AlamofireObjectMapper.framework/AlamofireObjectMapper\n  Expected in: /Users/robertoprevidi/Library/Developer/CoreSimulator/Devices/3AA91D00-8D2B-40C0-93AE-2C2BD6822BB3/data/Containers/Bundle/Application/E08687C3-4F6F-4428-8BBC-AAF411FD0F07/Municipium.app/Frameworks/ObjectMapper.framework/ObjectMapper\ndyld: Symbol not found: __TFC12ObjectMapper6MapperCfT7contextGSqPS_10MapContext___GS0_x_\n  Referenced from: /Users/robertoprevidi/Library/Developer/CoreSimulator/Devices/3AA91D00-8D2B-40C0-93AE-2C2BD6822BB3/data/Containers/Bundle/Application/E08687C3-4F6F-4428-8BBC-AAF411FD0F07/Municipium.app/Frameworks/AlamofireObjectMapper.framework/AlamofireObjectMapper\n  Expected in: /Users/robertoprevidi/Library/Developer/CoreSimulator/Devices/3AA91D00-8D2B-40C0-93AE-2C2BD6822BB3/data/Containers/Bundle/Application/E08687C3-4F6F-4428-8BBC-AAF411FD0F07/Municipium.app/Frameworks/ObjectMapper.framework/ObjectMapper\n```\n\nNow I'll try recompiling AlamofireObjectMapper, which I didn't yet.... ok.. it will take all the night, i'll let you know tomorrow\nIl giorno gio 16 feb 2017 alle 03:40 Tristan Himmelman \nnotifications@github.com ha scritto:\n\n@hariseldon78 https://github.com/hariseldon78 please try deleting the\ncarthage folder and running carthage update\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Hearst-DD/ObjectMapper/issues/722#issuecomment-280213343,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAIJ-ZTcIJrAIurDziLWC8MwWDYdtOqUks5rc7cWgaJpZM4LgaWF\n.\n. @tristanhimmelman  yes, it works! thanks. \n",
    "qgliu": "I also have issue with v2.2.2\nThe Xcode reported errors happens in AlamofireObjectMapper/ObjectMapperSerializer; particularly this line\n            } else if let parsedObject = Mapper(context: context).map(JSONObject: JSONToMap){\n                return .success(parsedObject)\n            }\n. The List is introduced in realm 3.0.x. Before that I had to create an IntObject as a realm Object and do some tricky mapping. Now upgrading to 3.0.x, the List is cleaner, but I have issue to do the mapping with ObjectMapper. Anyone can help?. ",
    "bidadh": "I confirm the same issue\ngithub \"Alamofire/Alamofire\" \"4.3.0\"\ngithub \"Hearst-DD/ObjectMapper\" \"2.2.2\"\ngithub \"tristanhimmelman/AlamofireObjectMapper\" \"4.0.1\"\nadding github \"Hearst-DD/ObjectMapper\" == 2.2.1 to the Cartfile explicitly will fix the issue!. ",
    "falcon283": "Same identical issue here using ObjectMapper 2.2.2. ",
    "maniyarpayal": "Here is the solution to your problem\n```\n var  cartItems : CartItems = CartItems.init(product_Id: \"7043\", product_title: \"NUTELA\", product_Image_Url: \"www.google.com\", product_price: \"50\", variationDetail: [ProductVariation.init(variation_id: \"2\", attr_name: \"dskjs\", display_price: \"150\", display_regular_price: \"150\")], quantity: 2)\n        let JSONString = cartItems.toJSONString(prettyPrint: true)\n        print(\"JSONString: (JSONString)\")\n    let cart = Mapper<CartItems>().map(JSONString:JSONString!)\n    print(\"cart:\\(cart)\")\n\n```\nUse above lines of and your issue will be solved.\nHappy Coding.....\ud83d\ude00\n. For get Array,use below lines  of code :\n  ```\nvar  cartItems : [CartItems] = []\n       let  cartItem : CartItems = CartItems.init(product_Id: \"7043\", product_title: \"NUTELA\", product_Image_Url: \"www.google.com\", product_price: \"50\", variationDetail: [ProductVariation.init(variation_id: \"2\", attr_name: \"dskjs\", display_price: \"150\", display_regular_price: \"150\")], quantity: 2)\n    cartItems.append(cartItem)\n    let JSONString = cartItems.toJSONString(prettyPrint: true)\n    print(\"JSONString: \\(JSONString)\")\n\n//        let cart = Mapper().map(JSONString:JSONString!)\n        let cart = Mapper().mapArray(JSONString: JSONString!)\n        print(\"cart:(cart)\")\n```. ",
    "ibhavin": "@maniyarpayal  I have array of struct. So, this line is giving error as:\nlet  cartItem : CartItems  = cartItems\nCannot convert value of type '[CartItems]' to specified type 'CartItems'\nIf I made array of CartItems that line then cart is printing null.\n```\nlet  cartItem : [CartItems]  = cartItems\nlet JSONString = cartItem.toJSONString(prettyPrint: true)\nprint(\"JSONString: (JSONString)\")\nlet cart = Mapper().map(JSONString:JSONString!)\nprint(\"cart:(cart)\")\n```\n. @maniyarpayal \nDeclaration: var cartItems = [CartItems]()\ncartItems:-\n[(product_Id:\"7043\", product_title:\"NUTELA\", product_Image_Url:\"http://h-delivery.com/wp-content/uploads/2016/12/File_003-1.png\", product_price:\"3\", variationDetail:[(variation_id:\"\", attr_name:\"\", display_price:\"\", display_regular_price:\"\"]), quantity:1),\n(product_Id:\"7047\", product_title:\"FRUITS\", product_Image_Url:\"http://h-delivery.com/wp-content/uploads/2016/12/File_002.png\", product_price:\"5\", variationDetail:[(variation_id:\"7052\", attr_name:\"strawberry\", display_price:\"5\", display_regular_price:\"5\"], quantity:2)]\n. ",
    "alum": "You can manually set the Mapper to include null values like so:\nlet json = Mapper<T>(context: nil, shouldIncludeNilValues: true).toJSON(object)\nwhere T is your Mappable type.\nEdit: Available from version 2.2.2 https://github.com/Hearst-DD/ObjectMapper/releases/tag/2.2.2. ",
    "Dev-": "Use mapArray() instead of map() when mapping an Array. . ",
    "AUsachov": "Sorry) My mistake). ",
    "JALsnipe": "That's an array of objects, not a single object.. I'm aware, I was just hoping there was a way to do this in a single line.  Thanks.. ",
    "tolgayildirim": "Yes, this is a JsonArray. But I get an error when I try to access it. Luckily I found the solution. Thank you. See  http://stackoverflow.com/questions/32353026/ios-map-a-root-json-array-with-objectmapper-in-swift/32353501#32353501. ",
    "Wooder": "I also got this kind of crash:\nThread 0 Crashed:\n0   ObjectMapper                    0xe26c6c            Mapper.toJSON(A) -> [String : Any]\n1   ObjectMapper                    0xe279e8            Mapper.toJSONString(A, prettyPrint : Bool) -> String?\n2   ObjectMapper                    0xe231e8            BaseMappable.toJSONString(prettyPrint : Bool) -> String?\nAnyone already working on this issue?. I found a solution for this issue (the crash only happened in the release build):\nTurn off \"Whole Module Optimization\" for the release build:\nGo to Build Settings -> Optimization Level -> Select \"none\" for the \"Release\"-Target\nHope that helps.\n. ",
    "borkuslav": "I have very similar issue, in my case changing optimization level from \"Whole module\" to \"Single-File\" fixed this crash. . ",
    "Otbivnoe": "I have the same problem ... . ",
    "tethridge": "I've been experiencing this issue as well.  When I look under build settings for optimization level, I don't see options like \"whole module\" or \"single-file\".  I only see options like \"optimize for speed\", \"optimize for size\", or \"none\".  Is this the same setting referenced in previous comments?  Also, this sounds like a pretty big compromise.  \nHas this issue been fixed in the most recent versions?  I had been using version 2.2.  I upgraded to version 3.2 today. . ",
    "drekka": "My bad. Just realised I was calling things statically. :-(. ",
    "cody1024d": "@devxoul  Thanks for that!  In my case, I am further constrained because the property name for the typeId and the typeName are different depending on the end point (don't ask...that API contract was not my doing lol) so your proposed solution won't work as cleanly for me.  BUT, in the future that definitely seems to be the best option we have!. @oddysee That would definitely work as well.  I ended up doing something that's a bit uglier, but works for now, and isn't too bad.  This is what my model looks like right now:\n```swift\n....\n    private var individualTypeId: Int?\n    private var individualTypeName: String?\nvar individualType: IndividualType? {\n    get {\n        guard let id = individualTypeId, let name = individualTypeName else {\n            return nil\n        }\n        return IndividualTypeFactory.build(id: id, name: name)\n    } set {\n        individualTypeId = newValue?.id\n        individualTypeName = newValue?.name\n    }\n}\n\n```\nI kept them flattened, and private to facilitate deserialization/serialization, but then exposed a computed variable of the model that I actually wanted.  Again, it's not the greatest piece of code I've ever written, but it gets the job done lol. This is effecting my project right now as well.  Any ETA?  Is there anything I can do to help?. I have gotten around this with a custom EnumArrayTransform, but this is obviously less than ideal. Yep that was my exact idea for a solution, as well, thanks ya'll!. ",
    "oddysee": "@cody1024d Would sub-classing and mapping to the new names for typeId and typeName be an option? I'm the same boat as you and am considering how to handle these API endpoints, which return the same type, using different property names:\n```\n/api/qualifications : { typeId, typeName }\n/api/candidate/qualifications: {candidateQualificationTypeId, candidateQualificationTypeName}\n```\n. ",
    "asyl": "@devxoul Thank you Suyeol. ",
    "freak4pc": "@devxoul Hey! Good seeing you here :) \nA few issues with that. \n\nI'm losing the nice syntax (having to map.value everything if im not mistaken)\nSometimes an exception might be overkill, but perhaps i could just catch and handle the error which would also be fine. \n\nIs there any way to still get the arrow-styled syntax with that kind of approach ? . Alright, ImmutableMappable seems like a good solution for now. I'll migrate my mappable's to it. Thanks @devxoul ! . Hey @cadizjavier \nOther work got in the way and eventually I didn't migrate to ObjectMapper, so haven't used this since. . ",
    "LemonRuss": "Yes. It s all works with Mappable protocol. But not with Immutable. Okey, i'll work on it. Thank you for ur answer! If someone already done it - u r welcome). ",
    "pptennekes": "Using ObjectMapper (2.2.2)\nUsing ObjectMapper+Realm (0.2)\nUsing Realm (2.1.2)\nUsing RealmSwift (2.1.2)\nWith not mapped correctly I meant that the value of both departureGateDelayMinutes  and arrivalGateDelayMinutes  after mapping is 0\n. Thanks for your quick response. Error was on my side. Used \nrealm.create(FlightStatus.self, value:json, update: true) as opposed to          \nswift\n if let status = FlightStatus(JSON: json){\n                realm.add(status, update: true)\n            }\nSorry to have troubled you.. ",
    "Sajjon": "@devxoul Hey thanks for you reply! Hehe yeah that was easier than I thought! \ud83d\ude05\nRegarding your P.S. answer - I still can't get it working! Now I am trying to implement and Alamofire + ObjectMapper extension analogously to AlamofireObjectMapper, but for ImmutableMappable\nI still get compilation error Ambigious use of map...., look for the two comments \"// Compilation Error\" in code below.\nWhat am I doing wrong?\n```swift\nimport Foundation\nimport Alamofire\nimport ObjectMapper\nextension DataRequest {\nenum ErrorCode: Int {\n    case noData = 1\n    case dataSerializationFailed = 2\n}\n\ninternal static func newError(_ code: ErrorCode, failureReason: String) -> NSError {\n    let errorDomain = \"com.alamofireobjectmapper.error\"\n\n    let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]\n    let returnError = NSError(domain: errorDomain, code: code.rawValue, userInfo: userInfo)\n\n    return returnError\n}\n\npublic static func ObjectMapperSerializer<T: ImmutableMappable>(_ keyPath: String?, mapToObject object: T? = nil, context: MapContext? = nil) -> DataResponseSerializer<T> {\n    return DataResponseSerializer { request, response, data, error in\n        guard error == nil else {\n            return .failure(error!)\n        }\n\n        guard let _ = data else {\n            let failureReason = \"Data could not be serialized. Input data was nil.\"\n            let error = newError(.noData, failureReason: failureReason)\n            return .failure(error)\n        }\n\n        let jsonResponseSerializer = DataRequest.jsonResponseSerializer(options: .allowFragments)\n        let result = jsonResponseSerializer.serializeResponse(request, response, data, error)\n\n        let JSONToMap: Any?\n        if let keyPath = keyPath , keyPath.isEmpty == false {\n            JSONToMap = (result.value as AnyObject?)?.value(forKeyPath: keyPath)\n        } else {\n            JSONToMap = result.value\n        }\n\n        if let object = object {\n            _ = Mapper<T>().map(JSONObject: JSONToMap, toObject: object)\n            return .success(object)\n        } else {\n            do {\n                // Compilation Error: \"Amigious user of 'map(JSONObject:)'\"\n                let parsedObject = try Mapper<T>(context: context).map(JSONObject: JSONToMap)\n                return .success(parsedObject)\n            } catch let error {\n                fatalError(\"Mapping error: \\(error)\")\n            }\n        }\n\n        let failureReason = \"ObjectMapper failed to serialize response.\"\n        let error = newError(.dataSerializationFailed, failureReason: failureReason)\n        return .failure(error)\n    }\n}\n\n@discardableResult\npublic func responseObject<T: ImmutableMappable>(queue: DispatchQueue? = nil, keyPath: String? = nil, mapToObject object: T? = nil, context: MapContext? = nil, completionHandler: @escaping (DataResponse<T>) -> Void) -> Self {\n    return response(queue: queue, responseSerializer: DataRequest.ObjectMapperSerializer(keyPath, mapToObject: object, context: context), completionHandler: completionHandler)\n}\n\npublic static func ObjectMapperArraySerializer<T: ImmutableMappable>(_ keyPath: String?, context: MapContext? = nil) -> DataResponseSerializer<[T]> {\n    return DataResponseSerializer { request, response, data, error in\n        guard error == nil else {\n            return .failure(error!)\n        }\n\n        guard let _ = data else {\n            let failureReason = \"Data could not be serialized. Input data was nil.\"\n            let error = newError(.dataSerializationFailed, failureReason: failureReason)\n            return .failure(error)\n        }\n\n        let jsonResponseSerializer = DataRequest.jsonResponseSerializer(options: .allowFragments)\n        let result = jsonResponseSerializer.serializeResponse(request, response, data, error)\n\n        let JSONToMap: Any?\n        if let keyPath = keyPath, keyPath.isEmpty == false {\n            JSONToMap = (result.value as AnyObject?)?.value(forKeyPath: keyPath)\n        } else {\n            JSONToMap = result.value\n        }\n\n        do {\n            // Compilation Error: \"Amigious user of 'map(JSONObject:)'\"\n            let parsedObject = try Mapper<T>(context: context).mapArray(JSONObject: JSONToMap)\n            return .success(parsedObject)\n        } catch let error {\n            fatalError(\"Failed to map, error: \\(error)\")\n        }\n\n        let failureReason = \"ObjectMapper failed to serialize response.\"\n        let error = newError(.dataSerializationFailed, failureReason: failureReason)\n        return .failure(error)\n    }\n}\n\n@discardableResult\npublic func responseArray<T: ImmutableMappable>(queue: DispatchQueue? = nil, keyPath: String? = nil, context: MapContext? = nil, completionHandler: @escaping (DataResponse<[T]>) -> Void) -> Self {\n    return response(queue: queue, responseSerializer: DataRequest.ObjectMapperArraySerializer(keyPath, context: context), completionHandler: completionHandler)\n}\n\n}\n```. ",
    "louisdh": "@Sajjon Btw, AlamofireObjectMapper now supports ImmutableMappable in v4.1. ",
    "endios-github": "Yes right !. @tristanhimmelman @devxoul \nOK! But if I remove mapping(map: map) in required init?(map: Map){... from class ClientMap:...\nAnd when I print clientData.city than I receive alway \"nil\" :\nif let clientData = uploadResponse.clientData { print(clientData.city) }\nnil\nSomewhere is still a problem?\n. have somebody an idea?. ",
    "aelam": "Is there a way to make the  ManageObject inheritance and the Mappable implementation separately \nCurrently. the Mappable has  required init?(map: Map) which must be written in the class CAN'T in extensions \n. ",
    "amirpervaiz086": "Hi @NikKovIos I read it from Realm doc you cant use RealmOptional and List as var and dynamic. But for json parsing and any mappable you used, it has to be var. can you explain it how did it work for you using var? any downside? thanks . I saw in your github you also used double and Int as var Optional. . ",
    "AnthonyOliveri": "@tristanhimmelman Is there a time frame for the next version release? I'm using Swift Package Manager, so I can't incorporate this fix into my project until a new version is released. . @foldericon That's fine for testing, but I'm creating libraries. I can specify the dependencies but can't include the downloaded Packages/.. It works now. Thanks @foldericon and @tristanhimmelman!. ",
    "afonsograca": "@devxoul are you referring to the whitespace formatting? Sorry about that, already updated. . already removed the unused code. should be okay now.. ",
    "ethanjdiamond": "Thanks Tristan. Maybe there's another way to solve my problem. Basically what I'm trying to do is that I have a bunch of structs that follow a protocol that I'm trying to parse into an array. So something like this:\n```swift\nstruct City: StaticMappable {\n  var zoo: Zoo!\nstatic func objectForMapping(map: ObjectMapper.Map) -> BaseMappable? {\n        return City()\n    }\nmutating func mapping(map: Map) {\n        noise <- map[\"zoo\"]\n    }\n}\nstruct Zoo: StaticMappable {\n   var animals: [Animal]!\nstatic func objectForMapping(map: ObjectMapper.Map) -> BaseMappable? {\n        return Zoo()\n    }\nmutating func mapping(map: Map) {\n    animals <- (map[\"animals\"], AnimalTransfomer())\n}\n\n}\nprotocol Animal: StaticMappable {\n    static func canParse(value: Any?) -> Bool\n}\nstruct Cow: Animal {\n    var noise: String!\nstatic func canParse(value: Any?) {\n   return value[\"type\"] == \"Cow\"\n\n}\nstatic func objectForMapping(map: ObjectMapper.Map) -> BaseMappable? {\n    return Cow()\n}\n\nmutating func mapping(map: Map) {\n    noise <- map[\"noise\"]\n}\n\n}\nstruct Lion: Animal {\n    var hasMane: Int!\nstatic func canParse(value: Any?) {\n   return value[\"type\"] == \"Lion\"\n\n}\nstatic func objectForMapping(map: ObjectMapper.Map) -> BaseMappable? {\n    return Lion()\n}\n\nmutating func mapping(map: Map) {\n    noise <- map[\"hasMane\"]\n}\n\n}\nclass AnimalTransformer: TransformType {\n   func transformFromJSON(_ value: Any?) -> Animal? {\n      if Cow.canParse(value) {\n           return Cow.init(JSON: value)\n      }\n  if Lion.canParse(value) {\n      return Lion.init(JSON: value)\n }\n\n}\n}\nCity.init(JSONString: \"{city: {zoo: {animals: [{type: \"Cow\", noise: \"Moo\"}, {type: \"Lion\", hasMane: 1}]}}\")\n```\nThat didn't work without my bugfix though. To be fair though, I guess it is kind of sidestepping the problem that I'm reparsing the object every time. Maybe I could pass map directly into transformFromJSON instead of the value it's holding? I don't think this would be a problem if I was using classes, since I could just subclass animal, but I need to use structs and you can't subclass those.\n. ",
    "mathieutozer": "Worked! Thank you!. ",
    "yuriy-tolstoguzov": "@devxoul Thanks for quick reply! As soon as I saw your answer I understood that I asked not what I meant to ask. Please clarify one more moment if possible.\nI use UsefulClass model class in different responses and ideally would like to continue to do that. I have next code there:\n```swift\nstruct UsefulClass: Mappable {\n  var usefulField1: String!\n  var usefulField2: String!\ninit(_ map: Map) {\n    usefulField1 <- map[\"usefulField1\"]\n    usefulField2 <- map[\"usefulField2\"]\n  }\n}\n```\nIn answer you suggested I need to have different mappings for these responses (\"usefulField1\" -> \"container.usefulField1\"). So if I change existing class, it won't work for responses implemented before; if I made another class for this new response, I will have some duplication of model classes.\nI know NSDictionary/NSArray Objective-C KVC implementation allows to prepare values I need like that: \"payload.containers.container\". An as result it returns simple array of UsefulClass as NSDictionary, but there are no pure Swift way to do that and as I see ObjectMapper's Map implementation also does not support it.\nWhat you could suggest me?. That is one option :)\nAnother option as I see it is to prepare map that will be passed there so it will point on proper places.. @devxoul Any ideas how I could implement something like that?. The bad part is that I have to do that for each field, because map[\"usefulField1\"].currentValue != nil is not guarantee that you just need to use second set of mappings for each field.\nIt would be cool feature if it would be possible to separate mapping and model somehow.\nAnyway, thanks for your help @devxoul. I think this issue is solved for me.. ",
    "mvandervelden": "Thanks!! Awesome this quick response @devxoul and @tristanhimmelman. You're the best!. ",
    "croyneaus4u": "Yes, we can implement stuff in the function mapping(map: Map) after we define the maps. But I believe the functions should be separated as per their usage. And as such I proposed this.\nPlease consider these:\n- Sometime, we need to do more than just mapping of data after we have received response from API. We might need to implement some operations such as sorting or filtering of the data based on other parameters. So in my opinion, we should implement a way where user can do after mapping operations specifically rather than doing it in the mapping(map: Map) function.\n\nUser may want to instantiate or save data to some other entity which is an instance of a class other than the one being mapped. So they can do it in the function that I have define.\n\nMore or less, this function will define a proper segregated space to perform whatever after-mapping operations the user wants in a better readable and defined way.. @nevyhostenyv I am facing the same issue ... \n. When I tried to remove the T! & [T]! overloads. I get error saying:\n\nBinary operator '<<-' cannot be applied to operands of type 'TopTitleHeader!' and '[String : Any]?' where class TopTitleHeader: Codable\n\nNot working even in X-Code 9.3.1. I can see a PR pending for the above issue:\n976\n. ",
    "Aranoledur": "I've just looked at a fix. Didn't even think it was that simple! Now I can make my entities structs again, thanks!. ",
    "ezar": "+1. ",
    "viral-etymon": "I am facing similar issue. where T can be object or array. While I am trying to pass array of any class then it is giving error \n\nType '[MyItem]' does not conform to protocol 'Mappable'\n\n```\nclass MyResponse: Mappable {\n    var status:Bool = false\n    var message:String = \"\"\n    var data:T?\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map:Map) {\n    status <- map[\"status\"]\n    message <- map[\"message\"]\n    data <- map[\"data\"]\n}\n\n}\n```\nWorking code for single object MyResponse<MyDetail>\nNot working for array MyResponse<[MyItem]>. ",
    "chrisdhaan": "@tristanhimmelman would this be something that a custom transform class could solve? I'm currently looking for the same desired functionality and trying to figure out how best to solve it besides just having two different model properties.. @tristanhimmelman more specifically. opposed to trying to differentiate between an array or object; could I just map the type [NSObject] and use a transform to wrap a response of type object inside of an array? That way an array is always returned with the model?. ",
    "joeymok": "Hi @Jake00 , Please take a look at issue #799. Any idea? Thanks.. Thanks @Jake000 . Wonderful explanation! The limitation is actually in the JSON data type definition. Number in JSON is defined as double-precision floating-point.\nIf I want to code a workaround for my case, and the decimal number is always 3-decimal place or less. How can I add the 3-decimal place rounding from Double to NSDecimalNumber in my own NSDecimalNumberTransform()?\nMyNSDecimalNumberTransform.swift\nswift\n     open func transformFromJSON(_ value: Any?) -> NSDecimalNumber? {\n          if let string = value as? String {\n              return NSDecimalNumber(string: string)\n          }\n          if let double = value as? Double {\n        } else if let number = value as? NSNumber {\n            return NSDecimalNumber(decimal: number.decimalValue)\n        } else if let double = value as? Double {\n              return NSDecimalNumber(floatLiteral: double)\n          }\n          return nil. Thanks @Jake000 !!. I made my own DecimalNumbertransform function like this. I'm not good at Swift. Just to share what I did to workaround my own problem.\n``` Swift\nimport Foundation\nimport ObjectMapper\nopen class MyDecimalNumberTransform: TransformType {\n    public typealias Object = NSDecimalNumber\n    public typealias JSON = String\npublic init() {}\n\npublic func transformFromJSON(_ value: Any?) -> NSDecimalNumber? {\n    if let string = value as? String {\n        return NSDecimalNumber(string: string)\n    } else if let number = value as? NSNumber {\n        let handler = NSDecimalNumberHandler(roundingMode: .plain, scale: 3, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: false)\n        return NSDecimalNumber(decimal: number.decimalValue).rounding(accordingToBehavior: handler)\n    } else if let double = value as? Double {\n        return NSDecimalNumber(floatLiteral: double)\n    }\n    return nil\n}\n\npublic func transformToJSON(_ value: NSDecimalNumber?) -> String? {\n    guard let value = value else { return nil }\n    return value.description\n}\n\n}\n```\nMapping in the model like\n``` Swift\nstruct Repo: Mappable {\n  var quantity: NSDecimalNumber?\ninit(_ map: Map) {\n    quantity <- (map[\"quantity\"], MyDecimalNumberTransform())\n  }\n}\n```\n. ",
    "tengfoung": "Yup thats what I get once updated to Xcode 8.3.. Found the solution. Command below shall do the job. \ncarthage update ObjectMapper --platform ios --no-use-binaries. ",
    "Davidleeeeee": "Actually, $0 is String Type.So when I define it as Float Type, the Assert work\n\n\n. ",
    "thibauddavid": "I handled this that way:\nswift\nclass CustomValueTransformer<T> {\n    static func transform() -> TransformOf<T, Any> {\n        return TransformOf<T, Any>(fromJSON: { (value: Any?) -> T? in\n            if T.self == Date.self {\n                return ISO8601DateTransform().transformFromJSON(value) as! T?\n            } else {\n                return value as! T?\n            }\n        }, toJSON: { (value: T?) -> Any? in\n            if T.self == Date.self {\n                return ISO8601DateTransform().transformToJSON(value as! Date? )\n            } else {\n                return value as Any?\n            }\n        })\n    }\n}\nUsage:\nvalue <- (map[\"value\"], CustomValueTransformer<T>.transform())\nIf someone is interested someday, I could add a configurator were a Transform could be registered to a Type, which'd avoir updating CustomValueTransformer.transform each time a new type is added.\nClosing the issue. ",
    "vminc": "My bad, it works after I made the generic type extend ImmutableMappable.. ",
    "azeff": "I think you have to filter out NSNull's from listImages array.. @tristanhimmelman awesome, thanks for clarification.. ",
    "mwoollard": "Personally prefer enum approach to struct although agree it achieves the same. However by abstracting to protocol adds flexibility so that other implementations could be used if anyone wanted.\n```\nextension Int: MapKeyConvertible {\n     public func asMapKey() -> String {\n        return \"value(self)\"\n    }\n}\n//...\nvar array = Int\n(0..<10).forEach {\n    array.append(try map.value($0))\n}\n```\nIt doesn't break existing code nor add any overhead in the performance unit tests when run locally (travis seems to vary run to run) and adds flexibility for anyone who wants it :-). I did encounter travis random failure with unit testing (simulator startup issue it seems) and so also just added a potential work around to the travis config.\nAnyway let me know your thoughts and whether you want to include this feature...\nThanks\nMark. ",
    "JuanitoFatas": "@tristanhimmelman Could you ship a release for this feature \ud83d\ude4f  Need to use it in one of my apps, thanks!. ",
    "mohakshah": "Sorry for failing to follow up. Turned out, the problem was caused due to an old version of ObjectMapper. Thanks!. ",
    "vinamelody": "Update... the reason is an old block of code that creates an object from json string. error is gone after removing the code.. @ppamorim I somehow just removed that line lol ... glad you found the solution!. ouch i wanted to be better at handling nil but it sort of backfire \ud83d\ude14 thanks @gcharita. ",
    "ppamorim": "@vinamelody How to test the create of objects from json string? I need this.... @vinamelody Wrapping it into a function solved the problem. :). ",
    "nspassov": "I ended up mapping the dictionary, and then transforming it into the array that I want.. ",
    "gunhansancar": "Can anyone confirm the issue? Or Do I do something wrong?\nThanks.. @chenkefeng Thanks for your response.\nI discovered my issue. Sometimes we overlook the situation and miss simple stuff.\nIn my actual implementation I have 10 or more fields. And I missed the mapping for the dictionary\ndict <- map[\"dict\"]\nThat is why it doesn't convert that field to JSON string.\nThank you.. I second that bug. Need a solution for that as well.. ",
    "chenkefeng": "I tried, and this is good\uff01\nExample:\n```\nstruct User: Mappable {\nvar name = \"\"\nvar dict = [String:Any]()\n\ninit() {}\n\ninit?(map: Map) {\n\n}\n\nmutating func mapping(map: Map) {\n    name <- map[\"name\"]\n    dict <- map[\"dict\"]\n}\n\n}\n    var u = User()\n    u.name = \"test\"\n    u.dict = [\"key1\":\"value1\", \"key2\": \"value2\"]\n\n    guard let jsonString = u.toJSONString() else {return}\n    print(jsonString)\n\n/////{\"dict\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"name\":\"test\"}\n```. You can do it\uff01\nExample\n```\nstruct User: Mappable {\nvar name = \"\"\nvar dict = [String:Any]()\n\nvar flag = false\n\ninit() {}\n\ninit?(map: Map) {\n\n}\n\nmutating func mapping(map: Map) {\n    name <- map[\"name\"]\n    dict <- map[\"dict\"]\n    flag <- (map[\"flag\"], TransformOf(fromJSON: { (intVal: Int?) -> Bool? in\n        return Bool(NSNumber(value: intVal ?? 0))\n    }, toJSON: { (boolVal: Bool?) -> Int? in\n        return (boolVal ?? false) ? 1 : 0\n    }))\n}\n\n}\n    let newJsonString = \"{\\\"dict\\\":{\\\"key2\\\":\\\"value2\\\",\\\"key1\\\":\\\"value1\\\"},\\\"name\\\":\\\"test\\\",\\\"flag\\\":1}\"\n\n    guard let newU = User(JSONString: newJsonString) else {return}\n\n    print(newU)\n    ////  User(name: \"test\", dict: [\"key2\": value2, \"key1\": value1], flag: true)\n\n. The JSON format is wrong and provides the correct JSON format. Your JSON format should be like this, right?\n{\n  \"rows\": [\n    {\n      \"elements\": [\n        {\n          \"distance\": {\n            \"text\": \"0.3 km\",\n            \"value\": 311\n          },\n          \"duration\": {\n            \"text\": \"1 min\",\n            \"value\": 66\n          },\n          \"status\": \"OK\"\n        },\n        {\n          \"distance\": {\n            \"text\": \"0.7 km\",\n            \"value\": 666\n          },\n          \"duration\": {\n            \"text\": \"2 mins\",\n            \"value\": 139\n          },\n          \"status\": \"OK\"\n        }\n      ]\n    }\n  ]\n}\n```. I was writing the code, I tried it, and I was successful. I don't know if you need it\nEx:\n```\nimport ObjectMapper\nclass DistanceMatrixForGasModel: Mappable {\nvar status: String?\nvar rows: [Elements]?\n\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    status <- map[\"status\"]\n    rows <- map[\"rows\"]\n}\n\n}\nclass Elements: Mappable {\n    var elements: [DistanceMatrix]?\n    required init?(map: Map) {\n}\n\nfunc mapping(map: Map) {\n    elements <- map[\"elements\"]\n}\n\n}\nclass DistanceMatrix: Mappable {\nvar distance : Distance?\nvar duration : String?\n\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    distance <- map[\"distance\"]\n    duration <- map[\"duration.text\"]\n}\n\n}\nclass Distance: Mappable {\nvar distance :String?\n\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    distance <- map[\"text\"]\n}\n\n}\nclass ViewController: UIViewController {\nlet data = \"{\\\"destination_addresses\\\":[\\\"Pashupati Rd, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Bhagawati Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Shivani Kunja, Shruti Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Bhagawati Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Bhagawati Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Rudramati Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Rudramati Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Rudramati Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Ram Mandir Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Kutu Bahal Galli, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Kutu Bahal Galli, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Surya Bikram Gyawali Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Kutu Bahal Galli, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Sama Marga, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Ring Road, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Jamuna Galli, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Trishakti Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Subarna Shamsher Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Subarna Shamsher Marg, Kathmandu 44600\u5c3c\u6cca\u5c14\\\",\\\"Sinamangal Rd, Kathmandu 44600\u5c3c\u6cca\u5c14\\\"],\\\"origin_addresses\\\":[\\\"Pashupati Rd, Kathmandu 44600\u5c3c\u6cca\u5c14\\\"],\\\"rows\\\":[{\\\"elements\\\":[{\\\"distance\\\":{\\\"text\\\":\\\"0.3 \u516c\u91cc\\\",\\\"value\\\":311},\\\"duration\\\":{\\\"text\\\":\\\"1\u5206\u949f\\\",\\\"value\\\":66},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.7 \u516c\u91cc\\\",\\\"value\\\":666},\\\"duration\\\":{\\\"text\\\":\\\"2\u5206\u949f\\\",\\\"value\\\":139},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.5 \u516c\u91cc\\\",\\\"value\\\":470},\\\"duration\\\":{\\\"text\\\":\\\"2\u5206\u949f\\\",\\\"value\\\":98},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.9 \u516c\u91cc\\\",\\\"value\\\":908},\\\"duration\\\":{\\\"text\\\":\\\"3\u5206\u949f\\\",\\\"value\\\":186},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.7 \u516c\u91cc\\\",\\\"value\\\":718},\\\"duration\\\":{\\\"text\\\":\\\"3\u5206\u949f\\\",\\\"value\\\":157},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.8 \u516c\u91cc\\\",\\\"value\\\":834},\\\"duration\\\":{\\\"text\\\":\\\"4\u5206\u949f\\\",\\\"value\\\":210},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.8 \u516c\u91cc\\\",\\\"value\\\":841},\\\"duration\\\":{\\\"text\\\":\\\"4\u5206\u949f\\\",\\\"value\\\":211},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"0.8 \u516c\u91cc\\\",\\\"value\\\":850},\\\"duration\\\":{\\\"text\\\":\\\"4\u5206\u949f\\\",\\\"value\\\":213},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.3 \u516c\u91cc\\\",\\\"value\\\":1317},\\\"duration\\\":{\\\"text\\\":\\\"6\u5206\u949f\\\",\\\"value\\\":336},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.2 \u516c\u91cc\\\",\\\"value\\\":1160},\\\"duration\\\":{\\\"text\\\":\\\"4\u5206\u949f\\\",\\\"value\\\":233},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.2 \u516c\u91cc\\\",\\\"value\\\":1179},\\\"duration\\\":{\\\"text\\\":\\\"4\u5206\u949f\\\",\\\"value\\\":235},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.5 \u516c\u91cc\\\",\\\"value\\\":1483},\\\"duration\\\":{\\\"text\\\":\\\"6\u5206\u949f\\\",\\\"value\\\":334},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.2 \u516c\u91cc\\\",\\\"value\\\":1208},\\\"duration\\\":{\\\"text\\\":\\\"4\u5206\u949f\\\",\\\"value\\\":240},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.4 \u516c\u91cc\\\",\\\"value\\\":1377},\\\"duration\\\":{\\\"text\\\":\\\"5\u5206\u949f\\\",\\\"value\\\":302},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.4 \u516c\u91cc\\\",\\\"value\\\":1376},\\\"duration\\\":{\\\"text\\\":\\\"6\u5206\u949f\\\",\\\"value\\\":334},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"1.8 \u516c\u91cc\\\",\\\"value\\\":1846},\\\"duration\\\":{\\\"text\\\":\\\"8\u5206\u949f\\\",\\\"value\\\":468},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"2.7 \u516c\u91cc\\\",\\\"value\\\":2708},\\\"duration\\\":{\\\"text\\\":\\\"10\u5206\u949f\\\",\\\"value\\\":608},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"2.2 \u516c\u91cc\\\",\\\"value\\\":2243},\\\"duration\\\":{\\\"text\\\":\\\"7\u5206\u949f\\\",\\\"value\\\":442},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"2.3 \u516c\u91cc\\\",\\\"value\\\":2251},\\\"duration\\\":{\\\"text\\\":\\\"7\u5206\u949f\\\",\\\"value\\\":443},\\\"status\\\":\\\"OK\\\"},{\\\"distance\\\":{\\\"text\\\":\\\"2.1 \u516c\u91cc\\\",\\\"value\\\":2061},\\\"duration\\\":{\\\"text\\\":\\\"8\u5206\u949f\\\",\\\"value\\\":501},\\\"status\\\":\\\"OK\\\"}]}],\\\"status\\\":\\\"OK\\\"}\"\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    let obj = DistanceMatrixForGasModel(JSONString: data)\n    print(obj?.status ?? \"\")\n    print(obj?.rows?.count ?? -1)\n    obj?.rows?.forEach({ (row) in\n        row.elements?.forEach({ (distanceMatrix) in\n            print(distanceMatrix.duration ?? \"unknow\", distanceMatrix.distance?.distance ?? \"error.\")\n        })\n    })\n\n}\n\noverride func didReceiveMemoryWarning() {\n    super.didReceiveMemoryWarning()\n    // Dispose of any resources that can be recreated.\n}\n\n}\n```\nresult:\nOK\n1\n1\u5206\u949f 0.3 \u516c\u91cc\n2\u5206\u949f 0.7 \u516c\u91cc\n2\u5206\u949f 0.5 \u516c\u91cc\n3\u5206\u949f 0.9 \u516c\u91cc\n3\u5206\u949f 0.7 \u516c\u91cc\n4\u5206\u949f 0.8 \u516c\u91cc\n4\u5206\u949f 0.8 \u516c\u91cc\n4\u5206\u949f 0.8 \u516c\u91cc\n6\u5206\u949f 1.3 \u516c\u91cc\n4\u5206\u949f 1.2 \u516c\u91cc\n4\u5206\u949f 1.2 \u516c\u91cc\n6\u5206\u949f 1.5 \u516c\u91cc\n4\u5206\u949f 1.2 \u516c\u91cc\n5\u5206\u949f 1.4 \u516c\u91cc\n6\u5206\u949f 1.4 \u516c\u91cc\n8\u5206\u949f 1.8 \u516c\u91cc\n10\u5206\u949f 2.7 \u516c\u91cc\n7\u5206\u949f 2.2 \u516c\u91cc\n7\u5206\u949f 2.3 \u516c\u91cc\n8\u5206\u949f 2.1 \u516c\u91cc. ",
    "tiwariammit": "my map class\nclass DistanceMatrixForGasModel: Mappable{\nvar status : String?\n\n//    var nextPageToken : String?\n    var rows:  [Elements]?\nrequired init?(map: Map) {\n\n}\n\n\nfunc mapping(map: Map) {\n    status <- map[\"status\"]\n    rows <- map[\"rows\"]\n}\n\n}\nclass Elements: Mappable{\n    var elements : [DistanceMatrix]?\nrequired init?(map: Map) {\n\n}\n\n\nfunc mapping(map: Map) {\n    elements <- map[\"elements\"]\n\n}\n\n}\nclass DistanceMatrix: Mappable{\nvar distance : Distance?\nvar duration : String?\nrequired init?(map: Map) {\n\n}\n\n\nfunc mapping(map: Map) {\n    distance <- map[\"distance\"]\n    duration <- map[\"duration.text\"]\n\n}\n\n}\nclass Distance : Mappable{\n    var distance :String?\n    required init?(map: Map) {\n}\nfunc mapping(map: Map) {\n    distance <- map[\"text\"]\n}\n\n}. You can check my json formate\nhttps://maps.googleapis.com/maps/api/distancematrix/json?origins=27.70805%2c85.33446&destinations=27.707891%2c85.337169%7c27.711646%2c85.334026%7c27.708997%2c85.329827%7c27.712238%2c85.3358339%7c27.7121865%2c85.3361436%7c27.70285%2c85.335605%7c27.7028507%2c85.3356814%7c27.7028062%2c85.3357306%7c27.704829%2c85.341729%7c27.7128278%2c85.3417335%7c27.712883%2c85.3419469%7c27.7024708%2c85.3414027%7c27.7131118%2c85.3421197%7c27.7147614%2c85.328261%7c27.7117023%2c85.3446219%7c27.701034%2c85.3461459%7c27.7172453%2c85.3239605%7c27.7213968%2c85.3278349%7c27.721425%2c85.327833%7c27.6986218%2c85.3476635&key=AIzaSyC0uO2JtBQDpuc4AmanaFSB46Ck_WUMnHc. can you please do that using alamofire???. ",
    "dskibin": "Hello! Thank you for replay!\nOn the fisrt screenshot you can see json i getting\n\nOn second -- current implementation, so only responseJson and accessing NSDictionary allows me to get CanWrite value\n\nHere you can see responseArray usage and CanWrite as nil in watch\n\n. ",
    "omarmasriRO": "I have the same issue !. ",
    "VinayagamD": "{\n  \"message\": \"login succesful\",\n  \"output\": {\n    \"user_id\": \"74df9401-537b-4d8d-b7e6-7fc58941ef5d\",\n    \"name\": \"Arshad\",\n    \"date_of_birth\": \"1993-04-12\",\n    \"gender\": \"Male\",\n    \"email\": null,\n    \"mobile\": \"9740535475\",\n    \"mobile_verified\": \"1\",\n    \"email_verified\": null,\n    \"auth_key\": \"1f3afde8-2f33-4905-bf14-2bf2a18cf00e\",\n    \"profile_picture\": null,\n    \"thumb_url\": null,\n    \"profile_status\": \"1\",\n    \"login_type\": \"mobile\"\n  }\n}\nAll the JSON  API response will be the message and output format.. ",
    "softdevstory": "My solution is following...\n```\n//: Playground - noun: a place where people can play\nimport ObjectMapper\nenum Data {\n    case value(String)\n    case cat(MainCatModel)\n}\nclass MainCatModel: Mappable {\n    var id: String!\n    var name: String!\nrequired init?(map: Map) {}\n\nfunc mapping(map : Map){\n    id <- map[\"id\"]\n    name <- map[\"name\"]\n}\n\n}\nclass ResponseModel: Mappable {\n    var data: Data?\n    var code: Int = 0\nrequired init?(map: Map) {}\n\nfunc mapping(map: Map) {\n    code <- map[\"code\"]\n\n    let transform = TransformOf<Data, Any>(fromJSON: { (value: Any?) -> Data? in\n\n        var data: Data? = nil\n\n        if let string = value as? String {\n            data = Data.value(string)\n        } else if let dict = value as? [String: Any] {\n            if let cat = MainCatModel(JSON: dict) {\n                data = Data.cat(cat)\n            }\n        }\n        return data\n    }, toJSON: { (value: Data?) -> Any? in\n        guard let value = value else { return nil }\n\n        switch value {\n        case .value(let text):\n            return text\n        case .cat(let cat):\n            let dict: [String: Any] = [\"id\": cat.id!, \"name\": cat.name!]\n            return dict\n        }\n    })\n\n    data <- (map[\"data\"], transform)\n}\n\n}\nfunc printModel(model: ResponseModel) {\n    print(\"code: (model.code)\")\n    switch model.data! {\n    case .value(let text):\n        print(\"data: (text)\")\n    case .cat(let cat):\n        print(\"data: {id: (cat.id!), name: (cat.name!)}\")\n    }\n}\nlet a = ResponseModel(JSONString: \"{\\\"code\\\":0,\\\"data\\\":{\\\"id\\\":\\\"1\\\",\\\"name\\\":\\\"Pop\\\"} }\")\nprintModel(model: a!)\nprint(\"----\")\nlet b = ResponseModel(JSONString: \"{\\\"code\\\":0,\\\"data\\\":\\\"fdasf\\\"}\")\nprintModel(model: b!)\nprint(a!.toJSONString()!)\nprint(b!.toJSONString()!)\n```\nresult is following\n```\ncode: 0\ndata: {id: 1, name: Pop}\n\ncode: 0\ndata: fdasf\n{\"code\":0,\"data\":{\"id\":\"1\",\"name\":\"Pop\"}}\n{\"code\":0,\"data\":\"fdasf\"}\n```\n. ",
    "hrscy": "Thanks!. ",
    "jassadakorn": "We don't need to use objectMapper anymore\n. @dcortes22 Because objectMapper have to check Json key for each property in mapping function but Codable don't have to check ( See also ) . It's mean the key can be invalid by human error if we use objectMapper. ",
    "dcortes22": "@jassadakorn why not?. Very interesting thanks for the clarification!. ",
    "skydivedan": "With Codable, the property name does not need to be the same as the JSON key, you can easily map to a different name.\n\nThis does change things for me, though. I pour JSON into Realm objects. The main reason I use ObjectMapper is for mapping ISO8601 Strings into Date objects, since Realm has no mechanism to do this. I don't know what the folks at Realm think about Codable, (and I haven't thought this through yet myself!), but if Codable could be adopted in Realm, then all those DateTransforms could drop away... which might mean that I could drop ObjectMapper. \nI don't know if this is truly feasible, but something to think about.. ",
    "yariksmirnov": "I use ObjectMapper in cause of really useful support of custom transformations. In case of Realm I created my custom transformers to create-or-update objects which are referenced by ids in REST APIs. . ",
    "loudmouth": "I think the nested keypath options of ObjectMapper provide functionality that make it more adaptable to a wide variety of JSON API's. Being able to do things things like:\ncontentTypeId   <- map[\"contentType.sys.id\"]\nRather than having additional nested structs is a big advantage of ObjectMapper for interfacing with certain APIs.. @Codeido here is the WWDC video describing \"What's New in Swift\". @tristanhimmelman What do you think about merging this improvement?. ",
    "aksswami": "But the same can be achieved via Codable and as this is the language feature, so it will be more widely used and also we will have consistent parsing across most of the projects.. Yes, Codable have Encoder and Decoder which we can use for toJSON and fromJSON.. The best guide for Codable I came across:- http://benscheirman.com/2017/06/ultimate-guide-to-json-parsing-with-swift-4/. ",
    "pmusolino": "Codable has the .toJSON() feature? . OK, but the encoder is automatic like ObjectMapper, or you have to explicit how to encode the variables?\n. Same problems here . @tristanhimmelman any news for us?\n. News?. News?\n. ",
    "emoryalimam": "here\u2019s a great guide on using Codable in Swift 4: http://swiftjson.guide. ",
    "tomaskraina": "For anyone still interested in the pros and cons between decodable vs ObjectMapper, I've found a nice writeup: https://medium.com/bbc-design-engineering/codable-vs-objectmapper-af5fe8e8efd5. ",
    "ro6lyo": "I'm also interesting about that, any info about Swift 4 support would be great. Thanks. ",
    "milesalex": "Any idea?. ",
    "asilavistaVeesto": "Hey, how do i get this swift 4 update?. ",
    "chrisvanbuskirk": "...but that's not an answer to the swift 4 question.. ",
    "ripventura": "@tristanhimmelman I appreciate the swift-4 branch, but I have pods using ObjectMapper as dependency, and since .podspec doesn't allow \":git\" / \":branch\" tags, I can't reference the new branch.\nIs there any ETA when the swift-4 branch gets released on cocoa pods?\n. ",
    "pschneider": "I've seen similar things with an object mapper model of ours, with not reproducible crash reports as the line is no actual code. Will post something if it happens again.. ",
    "mrobert": "I am also seeing similar memory leaks, specifically where I'm mapping an optional array of custom objects, much like in the README example:\n```\nclass User: Mappable {\n    var friends: [User]?    // Array of Users\nrequired init?(map: Map) {\n\n}\n\n// Mappable\nfunc mapping(map: Map) {\n    friends     <- map[\"friends\"]\n}\n\n}\n```\nMy 'User' object is also Mappable.  The mappings have been working, just not sure how long they have been leaking memory. . ",
    "rajanbalana1mg": "Any update for this? I am also seeing similar memory leak.. ",
    "rpatoni": "Is there any update on this issue? . ",
    "AntonTheDev": "Is this still being looked at? I'm getting the same error of and on, can't reproduce it, but it definitely has something to do with an array of custom objects. I believe the failure on those tests is server side, seems like Travis times out trying to start the simulator? Might just need to be re-run. ",
    "ThuggishNuggets": "Definitely still an issue in 2.2.9. I'm seeing this when mapping custom objects with an optional array property containing more custom objects using Mappable protocol conformance.\nTrying to track down a workaround.. Tried enabling Zombies, but none are ever messaged for us even with optimizations enabled.. The leaks disappear when optimizations are disabled so it may just be a compiler bug.. ",
    "phoney": "A few comments.\nThe stack trace shows an over-released object being released from an autorelease pool and causing a crash. The stack in main isn't useful. All it tells you is that this is on thread-1. All code in thread-1 starts from the entry point of your app. You can see it in all the stack traces that are above and you can always see it in the debugger when you hit a breakpoint.\nThis is likely to be a compiler bug. Tracking it down would probably be helped by running a Release build with Zombies turned on. The over-released objects will become Zombie and the debugger will stop when a zombie is messaged.\nI reported a compiler bug like this about a year ago and it was fixed early in 2017. The over-release was caused by having whole-module-optimization turned on. . This works for me\npod 'AlamofireObjectMapper', :git => 'https://github.com/tristanhimmelman/AlamofireObjectMapper.git', :branch => 'swift-4'\n    pod 'ObjectMapper', '~> 3.0'\n. This works for me\npod 'ObjectMapper', '~> 3.0'\n . I believe that the implicitly unwrapped optional methods that are getting the warnings can be simply removed. They seem to all be identical to the plain unwrapped optional methods and as long as the compiler is going to use the plain unwrapped optional methods even for implicitly unwrapped parameters everything should 'just work' without the implicitly unwrapped optional methods.. @zeusent Couple questions: \nAre you using the latest Xcode compiler? \nWhen you say you have a similar problem are you referring to your use of ObjectMapper or something else?. There's some discussion of this issue https://bugs.swift.org/browse/SR-6690 and https://bugs.swift.org/browse/SR-637 \nI think your case may be related to the return type of the functions (but I'm not sure).. Doesn't seem fixed to me. I'm using Xcode 9.4.1 and pod version 3.3 and I see the warnings. Looking at the code I see checks for swift >= 4.1.5 and the swift version in this Xcode is 4.1.2.\nI guess what was done was to prevent the compiler errors on swift 4.2 but leave the warnings in 4.1. \nI would have preferred removing the warnings in swift 4.1. While this is a potentially breaking change users could choose to stay on an older version of the pod until they fix their code, which they'll have to do for swift 4.2 anyway.\nWhen I change all those checks to swift >= 4.1 my code compiles without warnings and runs normally.. This is a duplicate issue of https://github.com/Hearst-DD/ObjectMapper/issues/961. ",
    "phaddius": "A couple of notes. I've converted my objects to ImmutableMappable and have noticed the crashes diminishing. I've also noticed the crashes NOT happening in iOS 11, so maybe they've fixed the underlying issue.. ",
    "chadwilson": "I'm seeing this behavior as well. ",
    "lucaArchidiacono": "Change your local xcode build to the latest version.\nGo to XCode -> Preferences... -> Locations -> Command Line Tools.\nThere you should take the latest version of xcode. After that close xcode and restart it.\nOpen Terminal, navigate to your project and insert: rm -rf ~/Library/Developer/Xcode/DerivedData/ && carthage build.. ",
    "tylerlong": "@lucaArchidiacono Other swift libraries work without problem, so I don't think it is xcode's issue.\n\u2757\ufe0f  To others:  ~/Library/Developer/Xcode/DerivedData/ contains quite a lot of data from all the projects that built with XCode. Please rethink before rm -rf it.. ",
    "jmanalang03": "i got same problem. ",
    "gunnartorfis": "Here's my approach: https://stackoverflow.com/questions/44806608/objectmapper-nested-dynamic-keys/44848499#44848499. ",
    "JaleelNazir": "The JSON you are mapping is \"Not Correct\". Use string replace function to remove the slashes('\\'), do your map.. ",
    "dirtyhenry": "I just updated my model to make it Mappable instead of ImmutableMappable and I get a similar error:\nUndefined symbols for architecture x86_64:\n  \"__TIFE12ObjectMapperPS_12BaseMappablecFT4JSONGVs10DictionarySSP__7contextGSqPS_10MapContext___GSqx_A0_\", referenced from:\n      __TFFFC12TripperTests20FeedItemEnvelopeSpec4specFT_T_U_FT_T_U_FT_T_ in FeedItemEnvelopeSpec.o\n  \"__TFE12ObjectMapperPS_12BaseMappableCfT4JSONGVs10DictionarySSP__7contextGSqPS_10MapContext___GSqx_\", referenced from:\n      __TFFFC12TripperTests20FeedItemEnvelopeSpec4specFT_T_U_FT_T_U_FT_T_ in FeedItemEnvelopeSpec.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation). Via Cocoapods.. @tomtcl Unfortunately this was more than a year ago and I don't have the code base at my disposal anymore. Sorry.. ",
    "jeremiasdsa": "I got same error when trying to initiate a local object like that:\nvar team = Team(JSON : [\"\" : \"\"])\n```import Foundation\n    import RealmSwift\n    import ObjectMapper\nclass Team: Object ,Mappable  {\n    dynamic var id = 0\n\noverride static func primaryKey() -> String? {\n    return \"id\"\n}\n\nrequired convenience init?(map: Map) {\n    self.init()\n}\n\nfunc mapping(map: Map) {\n    id <- map[\"id\"]\n  }\n\n}\n```\nUndefined symbols for architecture x86_64:\n  \"__TIFE12ObjectMapperPS_12BaseMappablecFT4JSONGVs10DictionarySSP__7contextGSqPS_10MapContext___GSqx_A0_\", referenced from:\n      __TFC18CampeonatoBrzTests11ServiceMock8getGamesfT3urlSS9completedFGSaC13CampeonatoBrz9GameModel_T__T_ in CampeonatoBrzPresenterTest.o\n      __TFC18CampeonatoBrzTests11ServiceMock8getTeamsfT3urlSS9completedFGSaC13CampeonatoBrz9TeamModel_T__T_ in CampeonatoBrzPresenterTest.o\n  \"__TFE12ObjectMapperPS_12BaseMappableCfT4JSONGVs10DictionarySSP__7contextGSqPS_10MapContext___GSqx_\", referenced from:\n      __TFC18CampeonatoBrzTests11ServiceMock8getGamesfT3urlSS9completedFGSaC13CampeonatoBrz9GameModel_T__T_ in CampeonatoBrzPresenterTest.o\n      __TFC18CampeonatoBrzTests11ServiceMock8getTeamsfT3urlSS9completedFGSaC13CampeonatoBrz9TeamModel_T__T_ in CampeonatoBrzPresenterTest.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation). ",
    "tomtcl": "@dirtyhenry  Hi,  I got the same issue,  have you solved it ? . ",
    "edjiang": "It's hard for me to understand if this is intended behavior or not. However, as a workaround you can do:\nswift\nnum <- map[\"num\", ignoreNil: true]. ",
    "iOSUser110": "i m also looking for same thing\nI want to modfiy string date into another date format String.\nwaiting for your responce. ",
    "MattiasBurstrom": "No idea where the above came from. Trying to report the issue with toIntMax() in IntegerOperators.swift causing a compiler error using Xcode 9/Swift 4 since it's been removed... Didn't see a previous report but maybe it's a known issue.. I totally missed the swift 4 branch but it works fine with that, thanks!. ",
    "jpunz": "Oh thank you, haven\u2019t seen that.\nI will use it for my project in future ;)\n\nOn 24 Jul 2017, at 16:01, Tristan Himmelman notifications@github.com wrote:\nHi there, we already have a swift4 branch for this project. It will be merged into master in the fall when swift 4 is officially released.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/Hearst-DD/ObjectMapper/pull/857#issuecomment-317431797, or mute the thread https://github.com/notifications/unsubscribe-auth/ALkzBP-eaqEX-wVFP9t7MVDNko0wadMYks5sRKO5gaJpZM4OhH9P.\n\n\n. ",
    "Iambecomeroot": "My bad. That's what I tried first but some the instance was immutable because I was trying to change it in a map.. ",
    "ealymbaev": "Thanks!. ",
    "JanzTam": "How to solve it \ud83d\ude2d\uff1f. ",
    "forceunwrap": "Looks like this is the intended functionality of converting values from JSON to Float (and Double):\nhttps://openradar.appspot.com/34032848\nThis is not an issue of ObjectMapper.. ",
    "qin9smile": "\n. same question. ",
    "steelzeh": "I was also about to post this.\nDid a leak check and i can sometimes get up to 925 leaks.\n\n. ",
    "cv711": "PR #877 is trying to fix some of those. ",
    "Servus7": "What was your mistake? Im running into the same issue.. ",
    "arnauddorgans": "882 . I removed test testIgnoreNilField()\nThe test pass because the JSONString isn't valid\nswift\nMapper<User>.parseJSONStringIntoDictionary(JSONString: JSON) == nil\nand not \nswift\nfirstName <- map[\"first_name\", ignoreNil: false]\n. ",
    "SvenTiigi": "I run in the same situation using ObjectMapper with Perfect Framework on Linux. See PR https://github.com/Hearst-DD/ObjectMapper/pull/877 especially https://github.com/redsift/ObjectMapper/commit/5f372d0ff7dc3b7210e1000373077f535557d7ea. I ended up by transforming on client side Integer and Double values to Strings and added an Custom TransformType to automatically map the Strings to an Int or Double via Generics. Sample Code below:\n```swift\nimport ObjectMapper\n/*\n    StringTransformType custom Transform for ObjectMapper Library\n    To transform an String into a generic TargetType during Deserialization.\n    And during Serialization transform generic TargetType into String\n    TODO: Remove File when PR is merged (https://github.com/Hearst-DD/ObjectMapper/pull/877)\n /\npublic class StringTransformType: TransformType {\n/// The object type\npublic typealias Object = TargetType\n\n/// The JSON type\npublic typealias JSON = String\n\n/// Default initializer\npublic init() {}\n\npublic func transformFromJSON(_ value: Any?) -> TargetType? {\n    // Unwrap value as String\n    guard let value = value as? String else {\n        // Value is nil\n        return nil\n    }\n    // Switch on TargetType\n    switch TargetType.self {\n        // Check if TargetType is Int\n    case is Int.Type:\n        // Return Int\n        return Int(value) as? TargetType\n        // Check if TargetType is Double\n    case is Double.Type:\n        // Return Double\n        return Double(value) as? TargetType\n    default:\n        // Unable to map return nil\n        return nil\n    }\n}\n\npublic func transformToJSON(_ value: TargetType?) -> String? {\n    // Unwrap value\n    guard let value = value else {\n        // value is nil\n        return nil\n    }\n    // Return String representation of TargetType\n    return String(describing: value)\n}\n\n}\n```\nYour mapping would look like this\nswift\nfunc mapping(map: Map) {\n    integer <- (map[\"integer\"], StringTransformType<Int>())\n    number <- (map[\"number\"], StringTransformType<Double>())\n}\nNote: Double values shouldn't fail during mapping if they doesn't end with a zero so 19.5 should be mapped on Linux but 19.0 will be mapped to nil. So you should use StringTransformType<Double>() if your Double values can end with a zero like 19.0.. ",
    "yunzixun": "I encountered with the same issue, but no solution yet. . ",
    "jcooperation0137": "I've found out myself what the issue is.. ",
    "nalexander50": "After looking at  a couple examples of custom transforms inside the project, I learned that i just needed to cast value to [String : Any]. From there, I have been able to extract my data. This was just really unclear because the debug description of value was misleading. For example, it replaced square brackets with parentheses so I did not immediately realize that it was a Swift dictionary.. ",
    "dclelland": "PR author here - in the same boat as arnopoulos - I'd love to see this merged and released before the Swift 4.0 work goes in, in order to support Xcode 9/Swift 3.2 projects.. ",
    "arnopoulos": "Thanks @tristanhimmelman!. I believe that this a duplicate of #975 . ",
    "SummerOO": "how to solve this problem......... ",
    "Vuong-Dao": "if you used xcode 9, please choose convert (swift 4) later, it will help you can build success right now.. ",
    "qingKaiWang": "\u600e\u4e48\u89e3\u51b3. ",
    "pilot34": "Add this to the bottom of your Podfile, until ObjectMapper won't be updated:\nruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n        target.build_configurations.each do |configuration|\n            # these libs work now only with Swift3.2 in Xcode9\n            if ['ObjectMapper'].include? target.name\n                configuration.build_settings['SWIFT_VERSION'] = \"3.2\"\n            end\n        end\n    end\nend. ",
    "mehulparmar4ever": "Replace with this file\nPlease replace file with this file, it will solve all the errors related to that. \nHappy coding. ",
    "ewanmellor": "Closing in favor of #899.  (I should not have PR'd my master branch.)\n. ",
    "mdilaveroglu": "+1. ",
    "falkobuttler": "Use the swift-4 branch. @tristanhimmelman I haven't resolved the issue, I have worked around it. This is still a problem that need to be solved. By default, Xcode will set this compiler setting. So inside of ObjectMapper something happens that is now considered dangerous. . Looks like regular updates are being made to the repo. @tristanhimmelman any ETA on this issue since it seems to be impacting quite a large group of people. . @marchy The option is called \"Exclusive Access to Memory\" (see screenshot):\n\n. ",
    "tbechtum": "Swift 4 pre-downloading fails\npod 'ObjectMapper', :git => 'https://github.com/Hearst-DD/ObjectMapper.git', :branch => 'swift-4' when using also AlamofireObjectMapper:\n[!] Unable to satisfy the following requirements:\n\nObjectMapper (fromhttps://github.com/Hearst-DD/ObjectMapper.git, branchswift-4) required by Podfile\nObjectMapper (fromhttps://github.com/Hearst-DD/ObjectMapper.git, branchswift-4) required by Podfile\nObjectMapper (fromhttps://github.com/Hearst-DD/ObjectMapper.git, branchswift-4) required by Podfile\nObjectMapper (~> 0.10) required by AlamofireObjectMapper (0.1)\n\n. For me too:\nInstalling AlamofireObjectMapper 5.0.0 (was 4.1.0)\nInstalling ObjectMapper 3.0.0 (was 2.2.9)\nThanks a lot.. ",
    "Sunspension": "+1. ",
    "tahirSmartboy": "@phoney Thank You ... its working \ud83d\udc4d . ",
    "MuhammadHarisRafique": "if T.self ==   Int.self, let x = Int(exactly: number.int64Value)?.toIntMax() {\n    return T.init(x)\n}\n\ntoIntMax is Unavailable. ",
    "malkouz": "Thank you for your co-operation. ",
    "mignick": "+1. ",
    "mrfer": "+1. ",
    "DIVEINBLUE": "+1. ",
    "SpoonTheGreater": "+1. ",
    "adamkuipers": "Is there any update you can provide for this? Or is the project no longer maintained?. ",
    "marchy": "@falkobuttler dont'see SWIFT_ENFORCE_EXCLUSIVE_ACCESS anywhere in our build settings. Do you just add this to 'Other Swift Flags'? Does it need a dash prepended? (ie: '-SWIFT_ENFORCE_EXCLUSIVE_ACCESS'). @falkobuttler Ahh wonderful, found it!\nYou're a lifesaver  =)\n(And I guess it seems they only crash the app in debug builds \u2013 so life is still sane phhew!!). ",
    "dvlprliu": "@tristanhimmelman can this PR be merged?. ",
    "Chetanyg": "Yes, In Swift 4 (Xcode 9) getting the same error.. ",
    "francodriansetti": "@joelorenz20  Try to use swift-4 branch . ",
    "krishnameena": "It is working. ",
    "joelorenz20": "Yeah, :branch => 'swift-4' fixed the issue.\nThanks =). ",
    "stensmir": "Swift\n let realm = try! Realm()\n try! realm.write {\n        if let JSON = realm.object(ofType:  Object.self, forPrimaryKey: id)?.toJSON() {\n               debugPrint(JSON)\n        }\n }\nWork for me. But, I not sure for this way.. ",
    "Vietnd34": "Sorry, i found problem, tags is string, not array, so it's not mapping.. ",
    "imzyf": "+1. ",
    "YannickSteph": "UP ?. UP ?. ",
    "gcharita": "Try using the following code to map the JSON:\n```swift\n// MARK: - Settings\npublic class Settings: NSObject {\n// MARK: DamageReportMode\n\npublic enum DamageReportMode: String {\n    case none = \"none\"\n}\n\n}\n// MARK: - SettingsAPI\ninternal class SettingsAPI {\n// MARK: Required properties\n\nvar rentalsDamageReportMode: Settings.DamageReportMode?\n\n// MARK: Initializers\n\ninit() {}\n\nrequired init?(map: Map) {\n    mapping(map: map)\n}\n\n}\n// MARK: - Mappable implementation\nextension SettingsAPI: Mappable {\nfunc mapping(map: Map) {\n    rentalsDamageReportMode <- map[\"rentals.damage_report_mode\", nested: false]\n}\n\n}\n. Just remove the nil check in `mapping(map:)` function and use the `map` object directlyswift\nclass Book: StaticMappable {\n    internal var data: BookData?\nclass func objectForMapping(map: Map) -> BaseMappable? {\n    return Book()\n}\n\ninternal func mapping(map: Map) {\n\n//        super.mapping(map: map)\n        self.data <- map[\"data\"]\n    }\ninternal struct BookData: StaticMappable {\n    internal var name: String?\n    internal var isbn: String?\n    internal var isbn13: String?\n\n    static func objectForMapping(map: Map) -> BaseMappable? {\n        return BookData()\n    }\n\n    internal mutating func mapping(map: Map) {\n        self.name <- map[\"name\"]\n        self.isbn <- map[\"isbn\"]\n        self.isbn13 <- map[\"isbn13\"]\n    }\n}\n\n}\n``\nHope this helps.. The most elegant solution that I found in a similar case was to map thetype_vehicle, in your case, in anenum` like that:\n```swift\nenum DataType: String {\n    case car = \"Car\"\n    case truck = \"Truck\"\nvar dataObject: Vehicle {\n    switch self {\n    case .car:\n        return Car()\n    case .truck:\n        return Truck()\n    }\n}\n\n}\n```\nand use a custom TransformType like:\n```swift\nclass VehicleTransformType: TransformType {\npublic typealias Object = Vehicle\npublic typealias JSON = [String: Any]\n\nprivate var templateObject: T\n\npublic init(templateObject: T) {\n    self.templateObject = templateObject\n}\n\nfunc transformFromJSON(_ value: Any?) -> Object? {\n    if let dictionaryValue = value as? [String: Any] {\n        return Mapper().map(JSON: dictionaryValue, toObject: templateObject)\n    }\n    return nil\n}\n\nfunc transformToJSON(_ value: Object?) -> JSON? {\n    return value?.toJSON()\n}\n\n}\n```\nOf course the model objects will be like:\n```swift\nclass MyResponse: Mappable {\n    var vehicles: [MetadataVehicle]!\n    var vehicle: MetadataVehicle!\nrequired init?(map: Map) { }\n\nfunc mapping(map: Map) {\n    vehicles <- map[\"vehicles\"]\n    vehicle <- map[\"vehicle\"]\n}\n\n}\nclass MetadataVehicle: Mappable {\n    var dataType: DataType!\n    var data: Vehicle!\nrequired init?(map: Map) { }\n\nfunc mapping(map: Map) {\n    dataType <- map[\"data#type\"]\n    data <- (map[\"data\"], VehicleTransformType(templateObject: dataType.dataObject))\n}\n\n}\nclass Vehicle: Mappable {\n    private var make: String!\n    private var model: String!\ninit() { }\n\nrequired init?(map: Map) { }\n\nfunc mapping(map: Map) {\n    make <- map[\"make\"]\n    model <- map[\"model\"]\n}\n\n}\nclass Car: Vehicle {\n    private var seatingCapacity: Int!\n    private var topSpeed: Double!\noverride init() {\n    super.init()\n}\n\nrequired init?(map: Map) {\n    super.init(map: map)\n}\n\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n    seatingCapacity <- map[\"seatingCapacity\"]\n    topSpeed <- map[\"topSpeed\"]\n}\n\n}\nclass Truck: Vehicle {\n    private var payloadCapacity: Double!\noverride init() {\n    super.init()\n}\n\nrequired init?(map: Map) {\n    super.init(map: map)\n}\n\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n    payloadCapacity <- map[\"payloadCapacity\"]\n}\n\n}\n```\nTo add another data type, the only thing you have to do is add another case in the DataType enum.. Try using URLTransform, for mapping url property, like:\nswift\nurl <- (map[\"url\"], URLTransform()). @phoney The new release did not fix those warnings because IUO does not have the same behavior in Swift 4.1 compiler. This causes compilation errors in test targets of the library. #980 . #980 fixed this in Xcode 10.\nWarnings in Xcode Xcode 9.3 and 9.4 will remain due to the fact that the behavior of IUO is not the same as Xcode 10 and as a result compilation fails in test targets.. I tried my best to support both Xcode 9 and 10 beta in pull request #980 .\nInvalid redeclarations removed from swift 4.2 and above. This means that the warnings in Xcode 9.3 and 9.4 will remain. (invalid redeclarations when removed in swift 4.1 causes some tests to fail)\nI even added support for Xcode 9.2 (compactMap)\nHope this helps.. @anilabsinc-ajay this issue has already been fixed in version 3.3.0. Just download the latest version.. @staz1000 I am not getting any error in an Xcode 10 project with version 3.3.0.\nMaybe you should run a clean or delete DerivedData.. There are already three PRs pending for this issue (#976, #978, #980), one of which have passed all tests.. #980 solved. Well, after creating this PR I realized the meaning of the conversation discussed in #976 about Swift 3 (and obviously Swift 4.1) in Xcode 10. So, this is not a perfect solution, unless we somehow specify the compiler to always use the latest version that supports.\nEdit:\nAfter some tests, it looks like setting the value 4.2 in s.swift_version property in .podspec file solves this issue. (every Xcode version compiles this target with the latest Swift version that can support). After taking a closer look to the Compiler Version Directive, I realized that there is a solution to this issue that doesn't need to change the swift_version in .podspec file.\nThis includes to change the compiler directives to:\n```swift\nif !(swift(>=4.1.50) || (swift(>=3.4) && !swift(>=4.0)))\n// Code targeting the Swift 4.1 compiler and below.\nendif\n```\nOf course this will add to the complexity of the directive check.. @andre991 I am not the maintainor of this repository. The only thing I can do is to apply the latest suggestion that I mentioned in the previous comment. (I believe it is the best solution so far). @MortMerr I already done this in https://github.com/Hearst-DD/ObjectMapper/pull/980/commits/bed2ff971f64f3aa1aa31a3448155f96a31afecd with backward compatibility.\nThere was 1 case in Mapper.swift file and 2 in TransformOperators.swift file.\nThe rest of this was already fixed in https://github.com/Hearst-DD/ObjectMapper/commit/9fd123c5981027bfd73dcdddd7c465b4a67390fe by @tristanhimmelman. (I just added backward compatibility). @aaparth I am testing it in:\n- Xcode 10 beta (swift 4.2, 4 and 3)\n- Xcode 9.4.1 (swift 3.3 and 4.1)\n- Xcode 9.2 (swift 3.2 and 4.0)\nAnd everything looks ok.\nCan you describe what exactly did you did and got the error?. @zhouhao27 this is not the right commit.\nJust install the latest version (which currently is 3.3.0) or change the commit, in your Podfile, to \n5985794. Just update to the latest version (this fixed in version 3.3.0). @zhouhao27 just install the latest version.. @zhouhao27 since Xcode 9 you can have different swift versions per target.\nSo, you can have swift 4 pods in a swift 3 project.\nHaving said that, just install the latest version of AlamofireObjectMapper and you are good to go.\nKeep in mind though, that, as Apple mentioned in WWDC 2018, Xcode 10 is tha last Xcode version that support swift 3.. @zhouhao27 in this screenshot you can see the target of the project (you can keep this in swift 3)\n\nAnd in this screenshot is the target of the ObjectMapper (swift 4)\n\n. @zhouhao27 if the installation of the latest version fixed the compiler errors, please close this issue.. @TCNexmo your JSON in invalid. Please, update your issue and check if the data property is indeed a JSON array. If it is, the InspectionResult class will probably need to be something like this:\n```swift\nclass InspectionResult: BaseResult {\nvar inspection: [Inspection]?\noverride func mapping(map: Map) {\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002super.mapping(map: map)\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002inspection <- map[\"data\"]\n\u2002\u2002\u2002\u2002}\n}\n```\notherwise the value of inspection will be always nil.. @TCNexmo sorry, but it still does not pass the validation check.. @TCNexmo please check again. Any online JSON validator or JSON formatter will do the job. (for example https://jsonformatter.org/). @TCNexmo the structure of your JSON is not optimal for the sections to be dynamic, however you can achieve this by creating a custom TransformType.\nAssuming that every section in your data array has one key and that this key is the name of your section you can try the following custom TransformType:\n```swift\nclass SectionsTransform: TransformType {\n    typealias Object = [Section]\n    typealias JSON = [[String: Any]]\nfunc transformFromJSON(_ value: Any?) -> Object? {\n    guard let array = value as? [[String: Any]] else {\n        return nil\n    }\n    return array.reduce(into: [Section](), { (result: inout [Section], dictionary: [String: Any]) in\n        if let sectionName = dictionary.keys.first {\n            let section = Mapper().map(JSON: dictionary, toObject: Section(sectionName: sectionName))\n            result.append(section)\n        }\n    })\n}\n\nfunc transformToJSON(_ value: Object?) -> JSON? {\n    return value?.toJSON()\n}\n\n}\n```\nand you can modify your data structure like:\n```swift\nclass InspectionResult: BaseResult {\n    var sections: Array?\noverride func mapping(map: Map) {\n    super.mapping(map: map)\n    sections <- (map[\"data\"], SectionsTransform())\n}\n\n}\nclass Section: Mappable {\n    var sectionName: String!\n    var fields: Array?\ninit(sectionName: String) {\n    self.sectionName = sectionName\n}\n\nrequired init?(map: Map) { }\n\nfunc mapping(map: Map) {\n    fields <- map[sectionName]\n}\n\n}\nclass Field: Mappable {\n    var fieldId: String?\n    var serverOperation: String?\n    var value: String?\nrequired init?(map: Map) { }\n\nfunc mapping(map: Map) {\n    fieldId <- map[\"fieldId\"]\n    serverOperation <- map[\"serverOperation\"]\n    value <- map[\"value\"]\n}\n\n}\n```\nHope this helps.. @TCNexmo I can't reproduce your issue. \nIs BaseResult also conforming to the Mappable protocol?\nCould you please share the code that you use to map this JSON to your model?. @TCNexmo mapping your JSON using map(JSONString:) function of Mapper class seems to work fine:\nswift\nlet categoryResult = Mapper<CategoryResult>().map(JSONString: json)\nprint(categoryResult?.category.count) // 5 elements. As mentioned in #980, we are getting compilation error Binary operator '<-' cannot be applied to operands of type when building Test targets with Xcode 9.4.1\n\nThis is the reason that I didn't used #if !swift(>=4.1) directive but  #if !(swift(>=4.1.50) || (swift(>=3.4) && !swift(>=4.0))). @CrazySugar unfortunately, you cannot achieve this unless you map the property two times if is nil.\nUse for example the following custom TransformType:\n```swift\nclass IntToStringTransform: TransformType {\n    typealias Object = String\n    typealias JSON = Int\nfunc transformFromJSON(_ value: Any?) -> Object? {\n    return (value as? Int)?.description\n}\n\nfunc transformToJSON(_ value: Object?) -> JSON? {\n    guard let stringValue = value else { return nil }\n    return Int(stringValue)\n}\n\n}\n```\nAnd map uid like:\n```swift\nclass Object: Mappable {\n    var uid: String?\nrequired init?(map: Map){ }\n\nfunc mapping(map: Map) {\n    uid <- map[\"uid\"]\n    if count == nil {\n        uid <- (map[\"uid\"], IntToStringTransform())\n    }\n}\n\n}\n``. @TotaX you can achieve this by creating you own customTransformType` like:\n```swift\nopen class TrimmingStringEnumTransform: TransformType where T.RawValue == String {\n    public typealias Object = T\n    public typealias JSON = String\nprivate let charactersToTrimm: CharacterSet\n\npublic init(charactersToTrimm: CharacterSet) {\n    self.charactersToTrimm = charactersToTrimm\n}\n\nopen func transformFromJSON(_ value: Any?) -> Object? {\n    guard var raw = value as? String else {\n        return nil\n    }\n    raw = raw.trimmingCharacters(in: charactersToTrimm)\n    return T(rawValue: raw)\n}\n\nopen func transformToJSON(_ value: T?) -> JSON? {\n    guard let obj = value else {\n        return nil\n    }\n    return obj.rawValue\n}\n\n}\n```\nand use it in mapping(map:) function like:\nswift\noperation <- (map[\"operation\"], TrimmingStringEnumTransform(charactersToTrimm: .whitespaces))\n. @techmehra support for swift 4.2 and Xcode 10 added since version 3.3.0. For everyone who want to make sure that they have the latest version\n- Check if your Podfile.lock have something like this:\n- ObjectMapper (3.3.0)\n- If not, update your regular Podfile to have this:\nruby\npod 'ObjectMapper', '3.3'\n\nThen run pod repo update\nAnd then run pod install. @Kanika-Sharma just update to the latest version (this fixed in version 3.3.0). @chika-kasymov yes swift 3 is also supported. @osiellima you need to update ObjectMapper to the latest version.\n\n@rharikrishnan84 @rahul-inspired-iosdeveloper \nPlease refer to this comment: https://github.com/tristanhimmelman/ObjectMapper/issues/1001#issuecomment-424267483\n\nFor everyone who want to make sure that they have the latest version\n- Check if your Podfile.lock have something like this:\n- ObjectMapper (3.3.0)\n- If not, update your regular Podfile to have this:\nruby\npod 'ObjectMapper', '3.3'\n\nThen run pod repo update\nAnd then run pod install\n. @shenwawa just run pod repo update before pod install. @KompoD you should be able map your JSON to the following model class:\n\n\n```swift\nclass Result: Mappable {\n    var type: String?\n    var lastUpdated: Int64?\n    var list: [[Any]]?\nrequired init?(map: Map) { }\n\nfunc mapping(map: Map) {\n    type <- map[\"type\"]\n    lastUpdated <- map[\"lastUpdated\"]\n    list <- map[\"list\"]\n}\n\n}\n```\nusing map(JSONString:) function of Mapper class like:\nswift\nlet result = Mapper<Result>().map(JSONString: jsonString). This is probably a Swift issue.\nIf we change the value() function to:\nswift\npublic func value<T>(_ value: Any?) throws -> T {\n    print(T.self as? Optional<Int>.Type) // Cast type as Int?\n    guard let value: T = value as? T else {\n        throw MachError(.aborted)\n    }\n    return value\n}\nin the debugger we will see this:\nOptional(Swift.Optional<Swift.Int>)\nWhich means that the cast succeed.\nBut if we change the function to:\nswift\npublic func value<T>(_ value: Any?) throws -> T {\n    print(T.self as? Int.Type) // Cast type as Int\n    guard let value: T = value as? T else {\n        throw MachError(.aborted)\n    }\n    return value\n}\nin the debugger we will see nil.\nSo, the T type is not Int but Int? (since IUO are Optionals in swift 4.1+)\nProbably the \"optionality\" of a Type is inside the actual type (T in this case) in swift 4.2\nBut this behaviour defeats the purpose of guard let statement.\nThis is interesting.. Seems to work just fine (tested in Xcode 9.4.1 and 10.1)\n\n. @466148590 just update to the latest version (fixed since version 3.3.0). ",
    "iampkhan": "+1. @uc43 I used 3.0.0 its working. ",
    "michaeldong": "i found a not perfact solution.\nhttps://github.com/Hearst-DD/ObjectMapper/issues/890\n. @uc43 temp change swift3.2 for the objectMapper framework.. ",
    "uc43": "@michaeldong Thanks\uff01\nIn reading, didn't see here\ud83d\ude13. ",
    "SheikhZayed": "updating the pod to 3.0.0 working for me !. ",
    "Ran-hub": "'toUIntMax()' is unavailabl. ",
    "loicgriffie": "Face the same. Any idea beside the workaround or a custom transform?\n[EDIT]\n@grzegorzkrukowski I end up with a generic Transform\n```\npublic struct ProtocolTransform: TransformType {\n    public init() { }\npublic typealias Object = Protocol\npublic typealias JSON = Any\n\npublic func transformFromJSON(_ value: JSON?) -> Object? {\n    return Mapper<Class>().map(JSONObject: value) as? Object\n}\n\npublic func transformToJSON(_ value: Object?) -> JSON? { return nil }\n\n}\npublic struct ProtocolArrayTransform: TransformType {\n    public init() { }\npublic typealias Object = [Protocol]\npublic typealias JSON = Any\n\npublic func transformFromJSON(_ value: JSON?) -> Object? {\n    return Mapper<Class>().mapArray(JSONObject: value) as? Object\n}\n\npublic func transformToJSON(_ value: Object?) -> JSON? { return nil }\n\n}\npublic func mapping(map: Map) {\n        identifier <- map[\"identifier\"]\n        email <- map[\"email\"]\n        profile <- (map[\"profile\"], ProtocolTransform())\n        cars <- (map[\"cars\"], ProtocolTransform())\n    }\n```. Ok found the problem. It's because i use category = RLBCategory(map: mapper) each time instead of category?.mapping(map: mapper). ",
    "joebenton": "+1 :). ",
    "LieonShelly": "+1:). ",
    "tarzon": "+1 :). ",
    "Shiju86": "Any luck to solve your problem. I am facing same problem. How to map the array?\n coordinates =         (\n            \"76.2710833\",\n            \"10.8505159\"\n        );\nAny help?. ",
    "GrishaGevorkyan": "Any update on this? List of Ints is introduced but still not working with ObjectMapper. ",
    "bptstmlgt": "Solved this issue with:\nhttps://github.com/APUtils/ObjectMapperAdditions. ",
    "vasadulin": "It works for  List < Int >\nfunc mapping(map: Map)  {\n     related_ids <- (map[\"related_ids\"], RealmTypeCastTransform())\n}\nfrom https://github.com/APUtils/ObjectMapperAdditions. ",
    "uditb": "Thanks. This worked for me.\nIs there a way having a parameterized init() function.. ",
    "paulmelnikow": "This was resolved via 883a6f1d53e59b2b8bccf0fa49fa07d8b0a6b6e2.. ",
    "ruddfawcett": "I am using the current version \u2014 2.2, per the README \u2014 with Swift 3.. Sorry, @GaneshShetty951, what's your question exactly?. Are you trying to map the entire super_child_attributes into a struct or class? Or just grab the ids field?. Can you share some more code?. ",
    "AalokParikh": "Same issues with me too.\nI got 10 errors all are pointing to the same issue.\n\nSwift.BinaryInteger:4:17: 'toIntMax()' was obsoleted in Swift 4\n\nPlease provide some update about this. \ud83d\ude00. There is error in the read me file need to update that file \nThe real latest version for this pod is 3.1 not 2.2 \nAfter setting it to 3.1 all works fine.\nPlease close this issue. . ",
    "YunyueLin": "Thanks. ",
    "GaneshShetty951": "@ruddfawcett  I am new to iOS development, I wanted to map this JSON  using ObjectMapper ?, any suggestion would be very helpful..\nI tried using Dictionary but it is not working may be I'm missing something ?. @ruddfawcett I am mapping it into a class..\n. @ruddfawcett \nimport Foundation\nimport ObjectMapper\nclass ProductScreenData : Mappable {\nvar superChildAttributes : [String: Ids]?\nrequired init(map : Map) {\n}\nfunc mapping(map: Map) {\nsuperChildAttributes <- map[\"super_child_attributes\"]\n}\n}\nclass Ids : Mappable {\nvar map_attribute : [ String : [String] ]?\nvar isColor : BooleanLiteralType?\nvar label : String?\nrequired init?(map: Map) {\n}\nfunc mapping(map: Map) {\nmap_attribute <- map[\"ids\"]\nisColor <- map [\"is_color\"]\nlabel <- map [\"label\"]\n}\n}. ",
    "maxgaurav": "Description\nI just install ObjectMapper on a fresh project and I too got the same error\nXcode Settings\n\nSwift Version: 3\n\nPod file\nFollowing are the content of pod file\ntarget 'SampleApp' do\n    pod 'Alamofire', '~> 4.5'\n    pod 'ObjectMapper', '~> 3.1'\nend\nErrors\n\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:101:17: Cannot convert value of type 'Int' to expected argument type 'IntMax' (aka 'Int64')\n-/Users/maxgaurav/Documents/projects/ios/todo/NewTodoApp/Pods/ObjectMapper/Sources/IntegerOperators.swift:104:17: Cannot convert value of type 'Int8' to expected argument type 'IntMax' (aka 'Int64')\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:107:17: Cannot convert value of type 'Int16' to expected argument type 'IntMax' (aka 'Int64')\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:110:17: Cannot convert value of type 'Int32' to expected argument type 'IntMax' (aka 'Int64')\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:129:17: Cannot convert value of type 'UInt' to expected argument type 'UIntMax' (aka 'UInt64')\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:132:17: Cannot convert value of type 'UInt8' to expected argument type 'UIntMax' (aka 'UInt64')\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:135:17: Cannot convert value of type 'UInt16' to expected argument type 'UIntMax' (aka 'UInt64')\nProject/Pods/ObjectMapper/Sources/IntegerOperators.swift:138:17: Cannot convert value of type 'UInt32' to expected argument type 'UIntMax' (aka 'UInt64')\n\n. ",
    "anwuna": "Just change your Pod Version to 3.1. That's the latest version and it has support for swift 4. Unfortunately the docs are not being updated.. ",
    "RajIET": "Thanks\nOn Fri, 8 Dec 2017 at 4:36 PM, anwuna notifications@github.com wrote:\n\nJust change your Pod Version to 3.1.0. That's the latest version and it\nhas support for swift 4. Unfortunately the docs are not being updated.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/Hearst-DD/ObjectMapper/issues/927#issuecomment-350237365,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AMaYXSeuoYeZRyk9UAxYx3ROlIqa0UYhks5s-RhIgaJpZM4Q6m1N\n.\n-- \nThanks\nRaj Kumar Agrawal\n+91 8446603586\n. \n",
    "vicorente": "I encountered the same problem, here it is my solution:\n```swift\n mutating func mapping(map: Map) {\n    map.shouldIncludeNilValues = true\n    value >>> map[\"Item\"]\n    // Rest of values \n    // ...\n  }\n```. ",
    "Y2JChamp": "i have solved by iterating data object in alamofire completion handler. ",
    "angelinec": "You expect the return type for url to be URL but from your JSON, its type is a String. You may want to grab it as a String first and then convert it to URL type.. ",
    "rainedAllNight": "\n. ",
    "Mazyod": "I noticed that valueFor recursion stops as soon as it finds a value, without asserting that the array should have reached the end. Can I post a PR solving this, or is it intentional?. I might need to properly return nil if isTail is false. LMK if you are interested in merging.. @tristanhimmelman It has tests, and I've also integrated it with our app, and seems to be working fine.\nPlease LMK if there are any changes on your mind, and I can accommodate.. My 2\u00a2 here would be to switch on the number of components instead. It will better convey the purpose of the branching logic and how it is handled:\nlet r: Int\nlet g: Int\nlet b: Int\nlet a: Int\nswitch compsCount {\ncase 2: // Grayscale\n    r = ..\n    ...\ncase 4: // rgba\n   r = ...\n}. ",
    "Sol88": "As I see there was a discussion at swift.org about redeclaration warnings. And as I understood they were going to ask ObjectMapper's maintainers to fix this issue.\nAbout Float it seems that for some reason NSNumber cannot be casted to Float. I got such error \"Unable to bridge NSNumber to Float\" and at this point I don't know what to do with it.\n. ",
    "AmirDaliri": "Does anyone have solution?\n. ",
    "mylemans": "We're worried about these warnings: so far everything looks like its working, but since we use it to transfer data to a backend we do not manage, it is very hard for us to confirm everything still works as it used to. Any idea when the warnings will be fixed?. ",
    "sandeepo2o": "I am facing the same issue.\nso I installed 9.2 with swift 4.0. Now it is working charmingly.\nWe have to use 9.2 and swift 4.0 until It is fixed. I didn't try Xcode 9.3 + Swift 4.0.. ",
    "ecomGit": "We are seeing the same warnings, Xcode 9.3 + Swift 4.0.. ",
    "quetool": "@sandeepo2o the problem is you need Xcode 9.3 with iOS 11.3 and many of us updated to iOS 11.3. I have similar issue here https://github.com/Hearst-DD/ObjectMapper/issues/955. ",
    "EduardoViegas": "I have the same problem.\nThe workaround that had less impact for me was to use a Custom Transform:\n```swift\nclass CustomFloatTransform: TransformType {\n    public typealias Object = Float\n    public typealias JSON = NSNumber\nfunc transformFromJSON(_ value: Any?) -> Float? {\n    if let number = value as? NSNumber {\n        return number.floatValue\n    }\n\n    if let numberString = value as? String {\n        return Float(numberString)\n    }\n\n    return nil\n}\n\nfunc transformToJSON(_ value: Float?) -> NSNumber? {\n    if let float = value {\n        return NSNumber(value: float)\n    }\n    return nil\n}\n\n}\n```. ",
    "cordechasse": "I've got the same issue on my projet.\n@EduardoViegas's workaround works well until the bug is fixed. . ",
    "TimchenKKBOX": "Same Problem here. ",
    "scott4arrows": "we just changed Floats to Double in our models\n. we just changed our Floats to Doubles. ",
    "leojkwan": "Does anyone have any information as to whether this is a bug or a legitimate API change with NSNumber and Floats in Swift 4.1?. ",
    "XiaoChenYung": "i have same trouble, hope this can be solved as soon as possible.. ",
    "itruf": "Same trouble, I converted all floats to doubles. ",
    "bes": "This was quite a suprising bug! Also on Swift 4.1/XCode 9.3 here, and the app just completely stopped working because of this o_O\nWe also have a large number of Mappable objects and now I am sitting here and wondering are there more things that are broken? Did I find all the floats?. ",
    "savage7": "Changing it to this works:\nclass func optionalObject<N: BaseMappable>(_ field: N?, map: Map) {\n        if let field = field {\n            object(field, map: map)\n        } else if map.shouldIncludeNilValues {\n            basicType(NSNull(), map: map) \n        }\n}. ",
    "alexpersian": "Deleting your derived data should address this issue.. ",
    "nevyhostenyv": "But there is a lot of warnings of type \".../EnumOperators.swift:35:13: Invalid redeclaration of '<-' which differs only by the kind of optional passed as an inout argument ('T!' vs. 'T?')\"\nHow can we solve it?. ",
    "zeusent": "Any idea how to fix these warnings?. Have you guys managed to fix these warnings? I have a similar problem. Hm... I've tried this but for some reason the compiler chooses the T overload instead of T? for my T! arguments :( This breaks things for me :(. To be more explicit if I have these methods:\nfunc <-(param: T) -> T { }\nfunc <-(param: T?) -> T? { }\nfunc <-(param: T!) -> T! { }\nRemoving func <-(param: T!) -> T! { } seems to have the compiler use func <-(param: T) -> T { } for T! parameters instead of func <-(param: T?) -> T? { } :(. Yes, I have the latest Xcode version. And I\u2019ve been looking all over the swift docs to find an explanation of this new warning that\u2019s being triggered in Swift 4.1 and a recommended way of fixing it but couldn\u2019t find any. My problem was not related to this project but some code of mine and this was the only place where I could find a similar problem. I\u2019m sorry for \u201chijacking\u201d the thread I guess just thought that sharing some info might help us all :-/. ",
    "samvanderhyden": "This is a critical issue for us. Any update would be appreciated!. ",
    "bilalbhutta": "I'm using this branch for temporary fix.\n\npod 'ObjectMapper', :git => 'https://github.com/bilalbhutta/ObjectMapper.git'\n\nAnd I'll replace ObjectMapper with swift 4 Codable soon . ",
    "ashtiani": "This issue hasn't resolve yet, I updated my pod to latest version but I still see this issue. \n\u25bf 3 elements\n  \u25bf 0 : 2 elements\n    - key : \"ratingPercentage\"\n    - value : 89\n  \u25bf 1 : 2 elements\n    - key : \"rating\"\n    - value : 4.4444\n  \u25bf 2 : 2 elements\n    - key : \"count\"\n    - value : 9\nthis is what I get when I print the data, but after mapping the value of rating would be 0, however when I change it from Float to Double it works fine.. ",
    "TotaX": "Hello @gcharita , quick question... is there any way to compound two Transform into one. \nfunc |><T: Any, V: Any>(left: TransformOf<T, String>, right: TransformOf<V, String>) -> TransformOf<V, String>\nI'd like to be able to compound two transform like this: Transform_1() |> URLTransform()\nand then have something like this\nurl <- (map[\"url\"], Transform_1() |> URLTransform()) \n. the thing is, api response is\n{ \n\"operation\" = \"                   S                \"\n} \nand i want to trim before transform to enum\n. yeah. i did that. but i wanted to know if there was something to combine two transform.\nanyway, thanks so much!. ",
    "chrisblessing": "Hey all, came here to post this after I resolved all the warnings.\nFor me, removing all of the explicit unwrapping conflicts (e.g. param is T! version, not the optional T?) was the solution. This ObjectMapper project should be updated accordingly for Swift 4.1 as we can no longer build against 4.0 in Xcode 9.3.  Leaving the methods with the optional params seemed the safest way to go, and sure enough the entire project runs just fine.\nedit: really just reiterating what phoney said above.\nYou'll also need to update from flatMap -> compactMap.\nYou won't see these warnings against the Swift 4.0 toolchain fwiw, but that's not app-store compat.. ",
    "firattemel": "Looks like this issue is resolved in Xcode 9.3.1. ",
    "trmquang": "This is issue is not resolved in Xcode 9.3.1. ",
    "anudaweerasinghe": "Updating to the latest version of ObjectMapper(3.2) and purging the Xcode derived data through the following command fixes the problem. \nrm -rf ~/Library/Developer/Xcode/DerivedData/*\n. ",
    "ParthMangi": "For me this issue is still not resolved. I am using Xcode 9.4.1 and Swift 4.1 for my project. After applying for solution given from @chrisblessing  it doesn't seem to work. Also as @phoney  said there are some checks for >=4.1 In my project its not there.\nMy Xocde is 9.4.1\nProject Swift Version 4.1\nPod ObjectMapper Target Version -> 3.3 \nObjectMapper Version -> 5.0\nStill warnings are coming up.\nIt would be great if fellow developers can help me I have been stuck at this issue for weeks.\n. ",
    "Gerst20051": "Same here looks like this project isn't being maintained anymore.. Typo has Flaot instead of Float. ",
    "hvge": "I've fixed this in our fork, but unfortunately, my change is basically removing a whole support for serialization of implicitly unwrapped members. I think that this is the only possible solution how to fix that warnings.  It's quick and dirty change, but we're already going to remove ObjectMapper from our projects, so it doesn't bother us so much.. ",
    "DevPravin": "Thank you, this helps \ud83d\udc4d . ",
    "liamnichols": "FYI this a compile error in Xcode 10 beta 1 (and it's new build system)\n\n. ",
    "joshwoods": "Is there any timeline to be getting a fix in for this? I would like to be moving forward using Xcode 10 to prep for iOS 12, however, this is making it so I cannot even compile our main app. Thanks in advance!. Is there any timeline to be getting a fix in for this? I would like to be moving forward using Xcode 10 to prep for iOS 12, however, this is making it so I cannot even compile our main app. Thanks in advance!. Is there any timeline to be getting a fix in for this? I would like to be moving forward using Xcode 10 to prep for iOS 12, however, this is making it so I cannot even compile our main app. Thanks in advance!. ",
    "duyduong": "You have to create a transform class to transform your property, for example:\npublic enum StageStatus: String {\n    case completed = \"Completed\", skipped = \"Skipped\"\n}\n```\npublic class StageStatusTransform: TransformType {\n    public typealias Object = StageStatus\n    public typealias JSON = String\npublic func transformFromJSON(_ value: Any?) -> Object? {\n    if let value = value as? JSON {\n        return Object(rawValue: value)\n    }\n    return nil\n}\n\npublic func transformToJSON(_ value: Object?) -> JSON? {\n    return value?.rawValue\n}\n\n}\n```\nAfter that, in your mapping function, you can apply the transform class:\nstageStatus <- (map[\"status\"], StageStatusTransform())\n. Then create an array of that mappable, for example:\n```\nclass Accessory: Mappable {\n   var name = \"\"\n   var price = 0\nrequired init?(map: Map) {\n      name <- map[\"name\"]\n      price <- map[\"price\"]\n   }\n}\n```\n```\nclass Response: Mappable {\n   var accessories = Accessory // default is empty\nrequired init?(map: Map) {\n      accessories <- map[\"accessories\"]\n   }\n}\n```\n. ",
    "nithin25": "I have array of dictionaries as above. But the Mappable class accepts dictionaries while initialising. How can pass these array of dictionaries?. ",
    "tomozip": "I didn't know about initilizer of swift language.\nI resolved like something...\n```swift\nimport RealmSwift\nimport ObjectMapper\nclass Area : Object, ImmutableMappable {\n@objc dynamic var id: Int = 1\n@objc dynamic var name: String = \"\"\n\nrequired convenience init(map: Map) throws {\n    self.init()\n    id   = try map.value(\"id\")\n    name = try map.value(\"name\")\n}\n\noverride static func primaryKey() -> String {\n    return \"id\"\n}\n\nfunc mapping(map: Map) {\n    id   >>> map[\"id\"]\n    name >>> map[\"name\"]\n}\n\n}\n```\nThank you...\nI expected to define properties in  model\uff08RealmSwift & ObjectMapper\uff09without initial value.\nBut this is RealmSwift's issue. So I posted new issue to realm-cocoa.. ",
    "flowchip": "I have the same problem. Found this inside the Readme of the repository:\nImmutableMappable uses Map.value(_:using:) method to get values from the Map. This method should be used with the try keyword as it is throwable. Optional properties can easily be handled using try?.\nIt worked for me!. ",
    "bawn": "let people = Mapper<Person>().mapArray(JSONObject: json[\"list\"]). ",
    "Ad1991": "Changing Swift version to 3 does not make it compile either; neither does changing back to legacy build system. It fails in all conditions.. ",
    "anilabsinc-ajay": "Any Plan to resolve this issue or I have to move back to Xcode 9.4 . @alecdoconnor Need a solution that should work on both xcode 9 and 10. @alecdoconnor Are you planning any timeline for this.. @tristanhimmelman Any Plans to update This awesome mapping library for iOS. ",
    "alecdoconnor": "I have created a PR at https://github.com/Hearst-DD/ObjectMapper/pull/978 to hopefully fix this issue. I noticed, after creating it, that another PR exists which has failed tests. Hopefully this produces the right results!. Hi @harisworld21 \nthat is a working solution, the PR has removed these lines of code to conform to Swift Evolution's SE-0054 Abolish ImplicitlyUnwrappedOptionals. Hi Josh! Feel free to contribute to the PRs to help us get closer to a working build. I believe there were two (the last time that I checked) that technically work, so you would be able to check the branch out directly into your project.. No, because I am not the maintainor of this repository.\nOn Mon, Jun 11, 2018 at 12:45 AM anilabsinc-ajay notifications@github.com\nwrote:\n\n@alecdoconnor https://github.com/alecdoconnor Are you planning any\ntimeline for this.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Hearst-DD/ObjectMapper/issues/975#issuecomment-396120856,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ATgs3vJkE-gUXCZE-0E1SzGYnK-wm2_iks5t7fXpgaJpZM4UaMRr\n.\n. I have created a PR at https://github.com/Hearst-DD/ObjectMapper/pull/978 to hopefully fix this issue. I noticed, after creating it, that another PR exists which has failed tests. Hopefully this produces the right results!. Hi Josh! Feel free to contribute to the PR to help us get closer to a working build. I believe this PR technically works, so you would be able to check the branch out directly into your project.. I noticed, after creating this PR, that another PR exists. This was a mistake, but hopefully this one is organized a bit better.\n\nIn regards to comments on that PR, the goal here was not simply to \"delete anything that generates an error,\" but to fix the issue as documented in the first comment here. \nUnfortunately, tests via the Travis CI build are failing since they are compiled against Xcode 9.0 Build version 9A235, as proven in the contents of the failing tests. \nAll tests in Xcode succeed, besides for the Mac tests for CustomTransformTests > testHexColorTransform. I believe this has to do with Swift 4.2's allowance of comparing two optionals if their types are Equatable. . Thanks Tristan!. ",
    "harisworld21": "Try commenting out duplicate declarations and compile.  It worked for me. And in implementation, use only one type of method call. It is a temporary solution. We need to wait anyways, till we get a fix.. ",
    "LeoSnek": "Aren't these warnings simply because one implementation of the function is marked for specific versions of Swift and the other is not? \ni.e. just add the following to the other implementation and the warning goes away:\n#if (swift(>=4.1.50)). I'm using 3.3.0 and I'm getting these warnings.. ",
    "wudijimao": "Update to 3.3.0 is OK!!!!!\npod update ObjectMapper\n. Any way, The document maybe need to update~   It still suggest us to use ver 3.2.0~. ",
    "XutongGithub": "you can update your Profile.\npod 'ObjectMapper', '~> 3.3'\nand run pod install,this probrom is ok.. ",
    "sunshinejr": "Thanks @manuqiao, wanted to do it myself and I saw that you already have done it \ud83d\ude09 Didn't have time to test it, but removing duplicated operators seems like a good fix. \nSo what happened in Swift 4.2 is a change in Implicitely Unwrapped Optional (IUO). An overview on the changes in Swift 4.1 (where this issue was a warning) and in 4.2 (where this issue is now an error) is in this blog post.\nAnd @JacobKingDev, please don't judge just by the code, sometimes there are different reason for a change and this seems like a good one (at least in my POV).. @JacobKingDev sure, it just seemed a bit rude, if you'd write it the way you explained it now I wouldn't say anything. But no worries, it's all good \ud83d\udc4d\nAbout the removals, I think it seems okayish, because these are just redundant (after the changes the method will accept optional either way, no need for unforced unwrapped optional as an argument). I'm not sure for 100%, but it seems reasonable.\nEdit: OH, and I'm just saying this about the general concept for the PR, didn't do a full CR thus there might be some quirks.. @talesp Unfortunately this won't work as this is also changed in 3.* version that Xcode 10 ships with. Thus, it won't compile as well. \nWe would need the compiler directive, but that was just merged yesterday so we would need to wait for next beta probably.. New to me as well. I've heard the news about 4.2 but not 3.*. But it kinda makes sense as they wanted to remove the IUO implementation from the codebase, so. \nTried it yesterday and today just to be sure and it won't compile when you use Swift 3 for the target - still throws an error.. ",
    "JacobKingDev": "@sunshinejr My point was more a case of simply removing code will cause issues for users of the library that utilised such code, not to mention potentially causing compiler errors where such methods are used within the library. Also, I noticed builds are failing but on closer inspection I think this is because CI is configured to use an outdated Swift version. If this fix is good, can someone merge it? I'm champing at the bit to use dark mode! \ud83d\ude1b . ",
    "talesp": "Maybe a better/safer solution would be something like\n```swift\nif swift(>=4.1)\nelse\n/// Implicitly Unwrapped Optional Object of Raw Representable type\npublic func <- (left: inout T!, right: Map) {\n    left <- (right, EnumTransform())\n}\nendif\n``\n(Sadly swift version check doesn't work fot less than checks). You mean Xcode 10 compiling Swift 3 source code also use the new IUO implementation? Well, this is new to me, so you are right :(. yeah, but breaks compatibility to an already released version :(\nSo, maybe axcode-10branch for now, breaking compatibility with Xcode 9 (that does not have thecompiler` directive)?. ",
    "asowers1": "seeing the same here. ",
    "Vadimkomis": "seeing the same issue. ",
    "madaoCN": "seeing the same issue. ",
    "batuhangobekli": "When the update will come.I will transfer if not?. ",
    "kaspermunck": "The compile errors are caused by a change in Swift 4.2 described in Abolish ImplicitlyUnwrappedOptional type Swift Evolution. \nI have forked the repo and fixed the compile errors, but I don't think it should be merged into master yet. @tristanhimmelman would you accept a PR into master, or could you perhaps create a swift4.2 branch that we can submit PR's against?. Saw that moments after posting my comment. Great to have options to choose from ;-). ",
    "Seonift": "sorry. it was my fault.. it's ok!\ni have an error in Xcode 10...\nin EnumOperatior.swift : '<-' previously declared here. ",
    "ozgur": "For those who are building their apps using Xcode 10, can add the following statement into their Podfile:\nswift \npod 'ObjectMapper', :git => 'https://github.com/alecdoconnor/ObjectMapper.git', :branch => 'Swift-4.2'. ",
    "MortyMerr": "@gcharita what do u think about fix warnings about deprecated flatMap in this pr?. ",
    "aaparth": "@gcharita  I tried it but still getting the error.. @gcharita Thanks for your contribution \nI got the 4.2 release from https://github.com/Hearst-DD/ObjectMapper/releases and everything works perfectly fine now.. ",
    "zhouhao27": "@gcharita I'm using swift 3 for Xcode 10 beta. Still got the same error message when I tried to use your commit bed2ff9. Here is what inside my pod file:\npod 'ObjectMapper', :git => 'https://github.com/Hearst-DD/ObjectMapper', :commit => 'bed2ff9'\nDo you know what could be the reason? Thanks.. @gcharita The latest version is for Swift 4, right? I'm still using Swift 3 in my project.. Actually there is another reason I still need to use 2.2.9. The AlamofireObjectMapper is depends on this for Swift 3.. @gcharita Here is the screenshots for my demo project using AlamofireObjectMapper. \n\nI can't find any target for Swift 3.. @gcharita So that means I can use library in Pods in Swift 4 and still keep my project in swift 3? Thanks.. ",
    "mrdavidrees": "Yeah there is.\n```\noverride open func mapping(map: Map) {\n   super.mapping(map: map)\n  propertyA <- map[\"propertyA\"]\n\n  switch map.mappingType {\n     case .fromJSON:\n       list <- map[\"list\"]\n       propertyB <- map[\"propertyC\"]\n\n     case .toJSON:\n       list <- map[\"newList\"]\n       propertyC <- map[\"propertyB\"]\n  }\n\n}\n}\n```\nIt's a good library, very extensible. Served me well over the last 2 years.. ",
    "Arvoreniad": "Exactly what we need, thanks!. ",
    "Maru-zhang": "@michael-mckenna \nMaybe you should try let organizations = Mapper<User.Organization>().mapArray(JSONfile: \"organization.json\").\nLook at the source code:\n/// JSON file to Mappable object array\n/// - parameter JSONfile: Filename\n/// - Returns: Mappable object array\npublic func mapArray(JSONfile: String) -> [N]? {\n    if let path = Bundle.main.path(forResource: JSONfile, ofType: nil) {\n        do {\n            let JSONString = try String(contentsOfFile: path)\n            do {\n                return self.mapArray(JSONString: JSONString)\n            }\n        } catch {\n            return nil\n        }\n    }\n    return nil\n}\nIf you don't add .json as extension for this method, it can't find correct URL for your resource, because the ofType is nil.. ",
    "michael-mckenna": "Thanks! Did the trick\nSent from my iPhone\n\nOn Jun 27, 2018, at 4:54 AM, Maru notifications@github.com wrote:\n@michael-mckenna\nMaybe you should try let organizations = Mapper().mapArray(JSONfile: \"organization.json\").\nLook at the source code:\n/// JSON file to Mappable object array\n/// - parameter JSONfile: Filename\n/// - Returns: Mappable object array\npublic func mapArray(JSONfile: String) -> [N]? {\n    if let path = Bundle.main.path(forResource: JSONfile, ofType: nil) {\n        do {\n            let JSONString = try String(contentsOfFile: path)\n            do {\n                return self.mapArray(JSONString: JSONString)\n            }\n        } catch {\n            return nil\n        }\n    }\n    return nil\n}\nIf you don't add .json as extension for this method, it can't find correct URL for your resource, because the ofType is nil.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "hsncr": "@bargar there is no other way then. alright.. ",
    "richimf": "Have you solved it?. ",
    "fatevase": "i have same issue. ",
    "medisean": "Great!. ",
    "nawinkhatiwada": "I am having the same issue. . ",
    "SoufianHossam": "any luck with this issue ?. ",
    "TCNexmo": "@gcharita You were correct the JSON was invalid, I have corrected it. it was missing a couple of brackets in the example.. @gcharita corrected again, may I ask what do you use to validate it?. Thank you for the tip, it should be correct now @gcharita . I have not yet tried this solution, I will give some feedback once I have done it.. This implementation seems to work perfectly, thanks @gcharita . @gcharita \n```swift\nclass BaseResult: Mappable {\nvar success: Bool?\nvar message: String?\nvar error: String?\nvar currentPage: Int?\nvar pageSize: Int?\nvar pageNumber: Int?\nvar totalCount: Int?\nvar version: Int?\n\nrequired init?(map: Map) {\n\n}\n\nfunc mapping(map: Map) {\n    success             <- map[\"success\"]\n    message             <- map[\"message\"]\n    pageNumber          <- map[\"pageNumber\"]\n    totalCount          <- map[\"totalCount\"]\n    version             <- map[\"version\"]\n}\n\n}\n```. ",
    "nicopuri": "@wagng Any update? I want to do exactly what you need.. ",
    "pandapancake": "I actually figured it out! . ",
    "johnpool3": "Updating to the latest version resolved this issue for me.. ",
    "techmehra": "@johnpool3 What version currently you are using, What can I see form pod spec It still point to 4.0. @gcharita I am also using the version 3.3.0 but still getting this \n\n. Any Update on the merge\n. ",
    "shenwawa": "How can I upgrade to 3.3, \npod 'ObjectMapper', '~> 3.3'\npod install\nAnalyzing dependencies\n[!] CocoaPods could not find compatible versions for pod \"ObjectMapper\":\n  In Podfile:\n    ObjectMapper (~> 3.3)\nmy xcode version is 10. Thanks, buddy. It's cool.. ",
    "kajensen": "This is not working for me. I still have a \"Convert to Swift 4.2\" for only ObjectMapper. I am using 3.3, many pod update/installs/resets/etc. Seems to be an issue with this library in particular.. #1012. @tristanhimmelman. Dupe #1012. Dupe #1012. ",
    "KeimyPlaza": "Maybe this error is only for Xcode10 but this library must be to supported Xcode 9.X\nYou can change the podfile:\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['WATCHOS_DEPLOYMENT_TARGET'] = '3.0'\n    end\n  end\nend\nReference: https://forums.developer.apple.com/thread/108408. ",
    "callo90": "Having the same issue with carthage, any updates about this?. ",
    "Kanika-Sharma": "\n@Kanika-Sharma just update to the latest version (this fixed in version 3.3.0)\n\nWorking fine.... Thanks. ",
    "HelioVieiraSilvaJr": "Tks.. its working for me also.. ",
    "rahul-inspired-iosdeveloper": "\n\n@Kanika-Sharma just update to the latest version (this fixed in version 3.3.0)\n\nWorking fine.... Thanks\n\nHi which library you updated to fix this issue. > Hi i am using Xcode 10.1 && swift 3.0 but still i am facing the same error.can you say which library you updated to fix this issue.Thanks in advance.\n\n\n\nIn my case I have updated cocoapods in my system and updated pods in the project\n$ [sudo] gem install cocoapods\n$ pod install - on projects . ",
    "chika-kasymov": "@gcharita is there a fix for Swift 3 version?. ",
    "umair151": "Yes, it fixed for swift 3.0. Thanks. ",
    "osiellima": "\n\n@Kanika-Sharma just update to the latest version (this fixed in version 3.3.0)\n\nWorking fine.... Thanks\n\nCan you say what do I need to update, please be more specific. Ok I think is ObjectMapper.. ",
    "rharikrishnan84": "Hi i am using Xcode 10.1 && swift 3.0 but still i am  facing the same error.can you say which library you updated to fix this issue.Thanks in advance.\n\n. ",
    "Ivan411": "\nWhat you did:\nmap JSON , create one object from JSON data\nWhat you expected:\nI want to MAP 2 JSONs , create one Object instead\nWhat you got:\n\nCant find a way to Map 2nd JSON to existing object which created from 1st JSON\nCant find a way to Map 1st + 2nd JSON = and produce new one object\n\n\ntry this \nstruct monster : Mappable {\n  var name: String?\n  var skill : String?\nvar ability: [String]?\n init?(map: Map) {\n        mapping(map: map)\n    }\nmutating func mapping(map: Map) {\nname <- map[\"name\"]\n    skill <- map[\"skill\"]\nability <- map[\"ability\"]\n    }\n}. ",
    "iOSGeekster": "According to the documentation URL isn't supported as a mappable type.. ",
    "jvk75": "Use URLTransform\ninit(_ map: Map) {\n    name <- map[\"name\"]\n    url <- (map[\"url\"], using: URLTransform())\n  }. Sounds good, will do :). ",
    "KompoD": "@gcharita Thank you, it works!. ",
    "kamirana4": "There are a lot of applications using ObjectMapper and many developers prefer it over Codable. ObjectMapper is still better for applying custom transforms. Getting the json from the Mappable object is another plus. Not failing the whole object when there is one key missing in the response whether the property is Optional or Non-optional is still not possible with Codable, it will fail the whole thing if you don't write your own encoders which is extremely painful to write for every model.\nIt is a huge effort to replace ObjectMapper with Codable in larger projects so it should be supported even if we have to introduce major changes in ObjectMapper to support the latest Swift syntax. . > > Not failing the whole object when there is one key missing in the response whether the property is Optional or Non-optional is still not possible with Codable, it will fail the whole thing if you don't write your own encoders which is extremely painful to write for every model.\n\n@kamirana4 I've just migrated my models to Codable some days ago and as far I could not see this issue. If a property has Optional type it's not necessary to write custom init(from decoder: Decoder) method. JSONDecoder will use automatically decodeIfPresent for it.\n\nYeah! It will fail if the property is declared Non-Optional. For Optional it won't fail, my mistake.. ",
    "dusiema": "I can't say anything about Codable (haven't used it yet) but wanted to say thx for objectmapper and that I would love to see continuous support. . ",
    "dstranz": "\nNot failing the whole object when there is one key missing in the response whether the property is Optional or Non-optional is still not possible with Codable, it will fail the whole thing if you don't write your own encoders which is extremely painful to write for every model.\n\n@kamirana4 I've just migrated my models to Codable some days ago and as far I could not see this issue. If a property has Optional type it's not necessary to write custom init(from decoder: Decoder) method. JSONDecoder will use automatically decodeIfPresent for it.. @tristanhimmelman I think that ObjectMapper still has some advantages:\n- it's said to be faster than Codable (or more precisely than JSONEncoder/Decoder)\n- it has type transformers support (but for Codable we have the external library for that https://github.com/jamesruston/CodableExtensions)\nWhat's better in Codable?\n- less code (in most cases it's enough to declare properties, without json - property mapping)\n- builtin support for snake case <> camel case names conversion (JSONDecoder.keyDecodingStrategy)\nThere are probably plenty of apps based on ObjectMapper, so it may be better to keep at least some support for it. But IMO it's not worth to add new features now.\nBTW: Object Mapper was the best model mapper before Codable! Thank you for your hard work :). ",
    "ashkanpower": "One of the advantages of Codable is that basic types (Int, String, Array...) are also Codable, so when working with generic types you dont have to worry about multiple type format.\nPut that aside I think Objectmapper makes cleaner code and error handeling is much more easier.\nAlso with Objectmapper you can easily define default values for properties that are not present in the Json.\nThanks for your hardwork, Apple, Swift and almost every ios developer owe you big time.. ",
    "sisufo": "+1. ",
    "Bruno-Furtado": "+1. ",
    "JackIrish": "@wdavies973 Did you end up getting this to work? Running into a similar issue.. ",
    "wdavies973": "@JackIrish no, haven't been able to get it to work.. ",
    "YiYiZheng": "Yes, I have the same problem.. ",
    "jbaez": "Same problem here. Had to point directly to master branch in git repo.\npod 'ObjectMapper', :git => 'https://github.com/tristanhimmelman/ObjectMapper.git', :branch => 'master'. ",
    "muhrifqii": "I found a workaround for it by map it into json dictionary instead of transforming the json object into json string inside mapping function. Because json dictionary can be encoded into json string\nBy changing this\n```Swift\npublic class MyModel: BaseModel {\n    var atx: Bool = false\n    var items: [String] = []\npublic override init() {\n    super.init()\n}\n\npublic convenience required init?(map: Map) {\n    self.init()\n}\n\npublic override func mapping(map: Map) {\n    super.mapping(map: map)\n    if map.mappingType == .fromJSON {\n        atx <- map[\"data.atx\"]\n        items <- (map[\"data.items\"], rawJsonTransformer)\n    }\n}\n\n}\ninto thisSwift\npublic class MyModel: BaseModel {\n    var atx: Bool = false\n    var items: [[String: Any]] = []\npublic override init() {\n    super.init()\n}\n\npublic convenience required init?(map: Map) {\n    self.init()\n}\n\npublic override func mapping(map: Map) {\n    super.mapping(map: map)\n    if map.mappingType == .fromJSON {\n        atx <- map[\"data.atx\"]\n        items <- map[\"data.items\"]\n    }\n}\n\n}\n```\n. This one comes up in my mind, haven't tested it. Let's say you have exactly same mapping key for property\n```Swift\nimport ObjectMapper\nlet testObject = TestObject(JSON: sampleObject.toJSON())\n```. ",
    "wakaryry": "I think I have got my answer. \nWhat I need is to map the json twice, one for AlbumModel, and the other for UserModel. \nIn AlbumModel, I map the userID in json into UserModel-type property owner.\n. ",
    "chainone": "For such a low layer of abstraction, I don't think applying \"reduce\" everywhere is a good idea. Performance hurts.\n. Let me know if I am wrong.\n. Take look at this blog:\nhttp://airspeedvelocity.net/\n\"Your reminder that building arrays with reduce, while fun, is accidentally quadratic.\"\n. "
}