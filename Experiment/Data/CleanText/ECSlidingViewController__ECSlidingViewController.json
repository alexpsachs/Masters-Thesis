{
    "enriquez": "Fixed the example here: 952ea470bc6690a25b7aaf7f9d1b051ffec48ed3\nI forgot to implement shouldAutorotateToInterfaceOrientation:interfaceOrientation in the view controller that we go back to.\n. 27116f71109a8181e2a420753305e798152e54d5\n. Also made topViewIsOffScreen public\nb0bb27c3c0a3b9022532dc75e8f73a42c21e25f0\n. Looks like you might have found a bug. After taking a quick look, I can't see what is causing the orientation to be portrait initially. It may have to do with the calculations for the width of the screen and the status bar, but I'll have to take a closer look when I have more time.\n. Sorry I didn't get back to you sooner, I'll look at it today. Were you able to find anything?\n. I was able to get it to start in landscape, but I had to remove support for portrait.  This was with and without ECSlidingViewController.  I haven't had to deal with starting in landscape before, so I might be missing something.  It seems like if the initial view controller supports portrait, it'll start in that orientation... even if you set the status bar orientation to something else.\n. Are you seeing it in the example app when switching from the first view to another view?  The first top view in the example app is the only one that has a shadow applied to it.  I just wanted to demonstrate that it is up to you to implement a shadow if you want it on your top view.\n. I've been planning to do this.  I just wanted to make sure the API was stable enough for me to pick a version number.\nI might do this today... I'll keep this issue open until I do a push to CocoaPods.\nThanks for bringing this up.\n. The current master branch is now tagged at 0.9.0.  Here is the new CocoaPod spec: https://github.com/CocoaPods/Specs/commit/b9c7c8059b1b236220bcd298abba011863b925d6\n. I haven't tried it but, ECSlidingViewController should work just like any other view container. So, in theory you could set a any view controller to be an ECSlidingViewController.\n. I would eventually like to setup view controller relationships in storyboards (similar to UITabViewController and UINavigationController), but there is no way of doing this right now for custom view containers.\n. Assuming you are using storyboards you can set an identifier on the UITabBarController and instantiate it using [storyboard instantiateViewControllerWithIdentifier]. With that instance, you can set the delegate.\n. ECSlidingViewController will try to layout all of its subviews to leave space for the status bar, so you'll need to present the fullscreen subview outside of ECSlidingViewController.  You can do this by adding another view controller as ECSlidingViewController's parent and then presenting it from that.\n. The presenting view controller will not always be the slidingViewController.\nWhat are you trying to achieve with the reference from a modal?\n. Hi, is this still an issue?\nIs your modal receiving touches properly? Did you add the panning gesture to it?\n. ECSlidingViewController doesn't care how or when its view controllers are instantiated.\n@reejosamuel you can can add a storyboardId to the initial sliding view controller and instantiate it with instantiateViewControllerWithIdentifier.\n. Thanks for the patch, but I wasn't able to get this to build.\n. You're instantiating a new NewsDetailViewController.  You need to get a reference to the existing one like this:\nNewsDetailViewController *detail = (NewsDetailViewController *)self.slidingViewController.topViewController;\n. The bouncing is done by calling anchorTopViewOffScreenTo:animations:onComplete with a  call to resetTopView in the onComplete callback.  Just call resetTopView directly to remove the bounce.\n. I like the API you have come up with for the shadows.\nI'm not sure the refactoring of the pan gestures buys us anything. The gesture can be added to any view and it can be disabled if it is not needed.\nCould you extract the shadow API out into another pull request? I need to be convinced more on the pan gesture changes.\n. Thanks for the example.\nI think the loading the view controllers is outside the responsibility of ECSlidingViewController.  For my application, I want my view controllers to be released when they're not in use to save memory. Although, it is nice to see that they can be cached if needed.\n. I have not needed to use a navigation controller as an underLeftViewController. Have you or anyone figured this out?\n. c29ec931f759a5a8f8a81fd3b0ee5aa3e1bc9d0a\n. I haven't done this, but I would try creating my own pan gesture that detects a sideways dragging.  When that drag goes past a threshold, then it can activate slidingViewController's pan gesture.\n. Did you figure this out? Can you provide sample code demonstrating the problem? Thanks!\n. This is fixed in the latest version\n. I'm not sure what would cause this.  I present modals from the slidingViewController like this without any problems:\n[self.slidingViewController presentModalViewController:[self.storyboard instantiateViewControllerWithIdentifier:@\"Modal\"] animated:YES];\nGive it a try maybe?\n. I agree, this is the way I do it in my apps.\nUpdated here: 594f68c44b0114f882ed6529e0dd6bc9e316e7b0\n. You can disable revealing the under right with the following:\nself.slidingViewController.underRightViewController = nil;\n self.slidingViewController.anchorLeftPeekAmount     = 0;\n self.slidingViewController.anchorLeftRevealAmount   = 0;\nSee the SecondTopViewController example.\n. I don't understand what you mean by static cell data. Do you mean the table on the left side for a menu? That is up to you to implement.\n. You can call selectRowAtIndexPath on your UITableView instance on first launch.\n. It wasn't designed to be used this way.\n. This is fixed on master.\n. You're right, those should be \"assign\". Would you like to submit a patch?\n. I feel like this code is more app-specific than general purpose for a library. The configuration for the sliding view controller is hidden in the custom segue. It also doesn't allow for sliding in both directions for a single top view controller.\n. Make sure you are not setting anchorLeftRevealAmount or anchorLeftPeekAmount anywhere else. If called multiple times, the last call wins.\n. I worked around this problem by not moving the top view off the screen while starting a search. This eliminates the need to resize the underRightViewController.\nI would prefer to have the full width of the screen while doing a search, but you're right. The animations do not look right.\n. This is expected behavior.  I think it feels more natural to be able to pan past that anchor point.  It does look weird, but only if your under view is not full width.\nI can see why you would want to prevent it, but it should be enabled as an option. Perhaps a allowPanningPastAnchor BOOL property that is YES by default.\n. 3d02df0d3ee11c029cf51b00b45f138601c3c094\n. I haven't found a good solution or workaround for this either. That search bar wasn't meant to be animated like that.\n. See https://github.com/edgecase/ECSlidingViewController/pull/70#issuecomment-12161109\n. Thanks for your work on this @MrBendel \nc29ec931f759a5a8f8a81fd3b0ee5aa3e1bc9d0a\n. Are you still having this problem? Can you provide a sample project demonstrating the problem? Thanks!\n. The view should be loaded right before it appears, but if you want it loaded earlier then you can add it as a subview.\nMyViewController *viewController = [[MyViewController alloc] initWithNibName:@\"MyViewController\" bundle:nil];\nself.slidingViewController.underLeftViewController = viewController;\n[self.slidingViewController.view insertSubview:viewController.view belowSubview:self.slidingViewController.topViewController.view];\n// view with it's subviews are loaded now\n. Does this still happen? Can you provide a sample project?\n. Is there a reason why an anchor amount would be set without a view controller?\nThe current way to disable panning is to do the following (from the SecondTopViewController example):\nself.slidingViewController.underRightViewController = nil;\nself.slidingViewController.anchorLeftPeekAmount     = 0;\nself.slidingViewController.anchorLeftRevealAmount   = 0;\n. 59f2f12ef9d86861985f41ba6af6b5bd90c27e67\nI haven't used CocoaPods, so please test this.\n. This might be the same as https://github.com/edgecase/ECSlidingViewController/pull/55. See https://github.com/edgecase/ECSlidingViewController/pull/55#issuecomment-12067499\n. 3d02df0d3ee11c029cf51b00b45f138601c3c094\n. f3b3220079d56207a6cefa6de8b37f6e7f3779be\n. The pan gesture is public, so you can enable/disable it like this:\nslidingViewController.panGesture.enabled = NO;\nI'm not convinced we need the convenience methods.\n. There are a couple of notifications you can hook into. See https://github.com/edgecase/ECSlidingViewController/blob/master/ECSlidingViewController/Vendor/ECSlidingViewController/ECSlidingViewController.m#L11\n. 8afea1db99c60ddc01a28bec1f0eda5fc5076ad2\n. 343ba14f06e9a6c2f1999cb3f5cad4ac496aa3a4\n. Boom 80506fe2bd2e515eca664b0d5d32eedcef971df0\n. iOS 6 will try to automatically match the status bar color with your navigation controller's color. The example app does this as well.\nI would explicitly set the tint color instead of letting it happen automatically.\n. You're right about viewWillAppear being called twice. fixed here: ef3574b8654614545e8827cac1fc206ae5333a30 (note: we only support iOS 5 and up)\nI don't understand the issue with the order of the calls. The frame is set relative to container view, so it shouldn't matter.\nanchorTopViewOffScreenTo will not automatically adjust the under view to fill the screen. This is expected behavior.\n. I see, you want to modify the frame of the under view in its viewWillAppear.  The current state of the code clobbers any modifications made to the frame.\n. ECSlidingViewController wasn't meant to be used this way, but I guess it should work in theory. Anyways, looks like you figured it out.\n. NavigationTopViewController is a UINavigationController. See here https://github.com/edgecase/ECSlidingViewController/blob/master/ECSlidingViewController/NavigationTopViewController.m\n. I'm not sure I understand. Do you mean panning over the buttons in the navigation bar? I wasn't able to reproduce this.\n. Instead of\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n  CGRect frame = self.slidingViewController.topViewController.view.frame;\n  self.slidingViewController.topViewController = newTopViewController;\n  self.slidingViewController.topViewController.view.frame = frame;\n  [self.slidingViewController resetTopView];\n}];\nDo this\nCGRect frame = self.slidingViewController.topViewController.view.frame;\nself.slidingViewController.topViewController = newTopViewController;\nself.slidingViewController.topViewController.view.frame = frame;\n[self.slidingViewController resetTopView];\nRemoving the call to anchorTopViewOffScreenTo:animations:onComplete: will prevent the top view from sliding off the screen. It will now replace the top view controller, then reset.\n. Look into resetTopView\n. You can access the sliding view controller from the UIViewController category and set the topViewController to something else.\nself.slidingViewController.topViewController = newChildViewController\n. Thanks. Fixed here: b2a1d16f72ea50b0521871bf238c75db664ba4a7\n. I wasn't able to reproduce this. Did you get this to work? See https://github.com/edgecase/ECSlidingViewController/tree/gh-91\n. What is the motivation behind this? What is wrong with panning the full view? I just want to understand before merging.\n. The conflicting gestures can be solved with UIGestureRecognizerDelegate, or just disabling the pan gesture and relying on a button.\nWith this patch, I was able to swipe to reveal both left and right under views by grabbing the left side. Also, this feels unnatural to me because it essential disables the panning in the middle on the top view.\n. Duplicate of #98 \n. I was able to do this by adding a pan gesture to the menu view controller and setting it's target/action to the sliding view controller's pan gesture. See https://github.com/edgecase/ECSlidingViewController/tree/gh-98\n. It is up to you on how you want data passed between view controllers. Typically you will expose a property on the top view controller that can be set from the menu view controller.\n. Thanks for reporting. This was fixed.\n. The gesture should be added to whichever view you want to be pannable.\n. This is addressed in #153 and #186\n. This is neat!\nThe problem is that it is only called while panning. It doesn't get called when tapping buttons that cause an anchor or reset.\n. Merged e6fed4983cfce89ee56d17f50481ca0c5c11570c\n. It is hard to say without seeing the code. Can you provide a sample?\n. Do you mean tapping the home button when you say \"leave the screen\"? I wasn't able to reproduce this.\n. Is this still an issue? Try this example: https://github.com/edgecase/ECSlidingViewController/tree/gh-109\n. I am able to add a modal without any problems. See here: https://github.com/edgecase/ECSlidingViewController/tree/gh-110\n. I'm not exactly sure what you mean, but if ECSlidingViewController's panGesture is conflicting, remember that it is simply a UIPanGesture instance. You may enable/disable it as needed.\n. This PR #141 does what you want to do, but I wouldn't modify ECSlidingViewController to do it.\n. What is the resetStrategy set to? It should include ECPanning. shouldAddPanGestureRecognizerToTopViewSnapshot should be enabled as well.\nIt would be more helpful if someone provided sample code that demonstrates the problem.\n. Is the UISplitView a topViewController? What happens in portrait mode? A code sample would help me answer this for you.\n. Sorry for the late response, but what you all came up with is the right direction... Keep the instances of your view controllers in the menu if you don't want them to be loaded every time.\nI did not want to build caching the instances of the view controllers into ECSlidingViewController because I wanted to leave that up to the user of the library. Sometimes you want to keep the instances around for better switching performance, but at the same time you want to get rid of them to save memory.\nIn my apps, I keep a reference to each view controller in my menu (creating them as needed). Then in didReceiveMemoryWarning I set the view controllers to nil to release them.\n. This may have been fixed by 7963fe9db46e23769477510ffc0d514f33063418 on master. Let me know if it doesn't\n. You want to know when the top view moves? Try this: e6fed4983cfce89ee56d17f50481ca0c5c11570c\n. If I remember correctly, it was on purpose. Did it break something for you?\n. By setting self.slidingViewController.underLeftWidthLayout = ECFixedRevealWidth; in the example, I was able to get the under views to size correctly (notice the disclosure indicators):\n\n\n. Thanks e6fed4983cfce89ee56d17f50481ca0c5c11570c\n. There's probably an issue with accessing the slidingViewController category from a modal view controller.\nI'll investigate more later.\n. This can be implemented outside of ECSlidingViewController by using the notifications.\n. Good point, I guess this is a bug. I'll need some time to learn how the accessibility stuff works before merging this in, or I'll leave it up to @jeffarena to merge this if he wants.\n. Is this a good solution for VoiceOver users to reset? 2dccb4a7b14b5108f1d817d759012860b686ee0f. They should be able to touch explore the top view while it is anchored, then it can be reset that way.\n. Moving the discussion about Voice Over resetting to #185 \n. Thanks for reporting. I confirmed this in the example by anchoring the top view, then quickly resetting and rotating. The under views disappear, but they come back after re-anchoring the top view. Might just be an issue with figuring the layout during rotation.\nI'll come up with a patch later.\n. Try this again on master. If it is still happening, can you post a fork with the problem and create another issue? Thanks!\n. You'll have better luck getting an answer about this on StackOverflow. The issues here are for problems/enhancements specific to ECSlidingViewController.\n. Thanks @airdrummingfool \nAlso see UIGestureRecognizerDelegate for handling multiple gestures.\n. Thanks @appfected, that's the right approach.\n. You might have some issues with the animations if you change the topViewController's width. This isn't the intended use for ECSlidingViewController.\n. There's a lot going on here. I've responded to #114 about caching view controllers, but is there something else happening with the shadow?\n. Thanks for sharing that tutorial @adrummond7\n@digitera you'll have a better chance at getting your question answers on StackOverflow. You can post GitHub issues here for problems/enhancements specific to ECSlidingViewController.\n. Try this branch and let me know how it works #177 \n. I'd prefer not to take over the panGesture's  delegate. I want to leave that open for users of ECSlidingViewController (especially for cases like this).\n. There were recently some changes related to the snapshot. Does this problem still exist on master?\nWhat conditions would cause the top view to get stuck with shouldAllowPanningPastAnchor set to NO? The top view should just stop at the anchor point, but it can still be panned back to the reset position.\n. Please reopen if this is still a problem.\n. Thanks. I like where this is going, but in order to keep things simple I want to leave this out. A future version may take advantage of the new iOS 7 APIs.\n. The animations block is actually just called during the existing sliding animation. This is for animating other elements along with the reset... not for modifying the reset animation. We don't have a way to modify the animations in ECSlidingViewController.\n. Do you mean \"rather than the side\"? Sorry, no I think you'll need a different solution than ECSlidingViewController.\n. Try this again with the latest\n. I don't understand. Take a look at the example code on how to switch between view controllers with a menu.\nYou'll have better luck getting an answer by posting on StackOverflow than here. This place is better suited for problems/enhancements specific to ECSlidingViewController.\n. There's probably something in the view controller you're trying to present that is causing it to crash. It is hard to tell without any details.\n. You might be able to get away with adding the panGesture to the menu. Haven't tried that, but that's not what it's intended for. ECSlidingViewController doesn't handle panning on the under views.\n. I'm not sure why that would be nil there. Might be something specific to your setup. You might have better luck asking about this on StackOverflow, unless the problem is with ECSlidingViewController... then try reproducing the problem so that I can better debug it.\n. Thanks, this is a great change. It doesn't apply cleanly anymore though, can you merge master in?\n. Hmm, not sure this is an issue with ECSlidingViewController. Try asking on StackOverflow or related place for questions specific to your setup. Or if you can provide sample code that shows the problem with ECSlidingViewController I may be able to help.\n. I'm not sure if it is possible to slide the keyboard with the top view. I'd be all for it, if it could be done easily.\nThere are a couple callbacks and notifications available to help you resign first responders already.\n. Sorry for the late response, but this may have been fixed in the latest version 1.0.1\n. Thanks for contributing.\nI think these changes address needs for a specific use case. Trying to keep things general and simple.\n. See #114 \n. I'm currently responsible for the state of this project. The app I used ECSlidingViewController in is no longer around, therefore I don't use it anymore. I haven't been giving it the attention it needs, so I've decided to look for someone else to maintain it.\nIs anyone interested in taking on this responsibility? Preferably someone who is using it in a production application and has a vested interest in making ECSlidingViewController awesome.\nSorry for letting it get to this point. Hopefully we can find someone that will do a better job than I did.\n. @jeffarena has volunteered to take over the repo. Yay! He's made some great contributions to ECSlidingViewController in the past, so it'll be in good hands.\nCan someone at @edgecase/@neo (@mdoel, @kEND) give @jeffarena write access to this repo?\n. Unfortunately, I don't think there's a way around that warning message in Storyboards. There's no good way for us to implement a custom view controller container with storyboards and have all the benefits that the built in view controller containers have.\n. Not sure I understand. You can set the underRightViewController once and cache it somewhere.\n. Thanks b5fe1bbdc94dbbc68ac915a8309b21b1076c2d37\n. Not that I know of. We only support the advertised usage.\n. This looks like it might be specific to your app. Try asking about this on StackOverflow or a similar place.\n. Thanks for reporting. Try the ios7 branch again, I put a fix that should get the right size now. a18a825f3d1aacf7a142d74342b593bb1ecb26ed\n. There's no mention in the docs about calling super here, and I haven't seen any issues related to rotation.\n. Sorry, you're right. I just double checked the docs and found the mention to calling super.\n. I made a branch that adds an option to shrink the child views down here: #177. Please try it out and let me know if it helps.\n. The status bar can't be moved. I've tried faking it by taking screenshots of it before, but then theres issues with it not updating the time or anything else in there.\nI made some changes to help with iOS 7 here: #177 . I suggest using a combination of the statusBarBackgroundView and topViewCenterMoved APIs to transition the color of the status bar background while the top view is sliding.\n. Can you give more details on the crash and how to reproduce it?\n. There may be something specific with your app. ECSlidingViewController seems to run fine on iOS 7. Try the branch on #177, or better yet try reproducing the problem off that branch. I'll be able to help more if I can reproduce the problem.\n. Weird... There's probably something else going on outside of ECSlidingViewController.  My guess is that you are setting the underRightViewController to something that may have been released.\n. @ValCapri @nullproduction there's a bug on this branch and master related to gestures and snapshots. I'll take a look at it when I get the chance.\n. @ValCapri @nullproduction This last commit should fix the problem.\n. @ValCapri I don't understand. Which table? I'm able to scroll the menu, navigation example, and under right tables up and down just fine. The navigation pop gesture takes precedence over ECSlidingViewController's panGesture, but only on the left edge of the screen.\n. @farfromrefug the first time you set the topViewController it should use [self fullViewBounds]. Maybe some things are getting called out of order on your side? Send a PR if you think its still an issue, and we can discuss it there.\n. @farfromrefug the frame needs to be set to the previous topViewcontroller's frame in case the top view is in the anchored position. Otherwise, setting the top view controller would set it to the fullViewBounds (therefore, causing it to reset).\n. @farfromrefug I haven't updated the README on this branch, but this is meant for iOS 7 only.\n. Look into the UIGestureRecognizerDelegate. You'll be able to control how the gestures work together.\n. Thanks for the pull request.\nI want to keep the API simple for now. I'll keep this in mind though when working on another version.\n. ECSlidingViewController treats them the same, so there shouldn't be any difference. What is happening when the collection view loads?\n. Sorry, the semantics of shouldAddPanGestureRecognizerToTopViewSnapshot are confusing (even to me). That should do exactly what it says, so I made this change b2c8f654172095ba537737022c90dd0d87135113.\nThanks for reporting.\n. Does resetting the top view controller after hiding the navigation bar fix the problem? Something like this\n[self.navigationController setNavigationBarHidden:YES];\nself.slidingViewController.topViewController = self;\nThis'll force the frame to be recalculated.\n. What happens if the navigation bar is always hidden when the page view controller is pushed? Does it get the right size that time? Can you fork the example and reproduce the problem there? It'll be easier for me to debug.\n. Take a look into UIGestureRecognizerDelegate. You'll be able to have more control between the interactions of multiple gestures.\n. No response from #127. I'll reopen if this is actually needed.\n. This great @DanLite, Thanks.\n. @DanLite great work. Thanks again!\n. I don't understand, but it sounds like you might be asking about a problem specific to your app. Try asking StackOverflow, you'll have better luck getting responses there.\n. No, not without modifications.\n. Thanks for reporting. This is now fixed in 1.3.1.\n. The pan gesture can be disabled like this: slidingViewController.panGesture.isEnabled = NO\n. Thanks for reporting.\nCan you give the master branch version a try?\n. You can place the pan gesture on a different area of the top view or remove it completely.\n. You can create a transparent subview on top of your scroll view to accept the pan gesture. That might be the easiest approach without modifying the sliding view internals.\n. Thanks!\n. This isn't supported, but you may be able to modify the ECSlidingViewController internals to do this.\n. Hi, thanks :)\nNo, this isn't possible without a lot of modification.\n. The sliding view controller's container view is expected to be empty.\nI would move all the stuff you have from the container view into a new view controller.  Then the state of your app can decide on which topViewController to show.\n. :thumbsup:\nI've been updating the README as well where it specifies how to install the CocoaPod with the specific version. I think it is safe to just say...\nruby\npod \"ECSlidingViewController\", :tag => \"~> 1.3\"\n...without the patch number\n. Updated ECSlidingViewController CocoaPod to 1.3.2 CocoaPods/Specs@4932876770691202a9a8939292ad1a34b544954e. Thanks @jeffarena!\n. Is the original problem with the navigation bar's height? Hiding and showing the status bar changes where the top layout guide is. So when you change the topViewController, its view will be positioned to wherever the top layout guide is at that time. UINavigationController uses the top layout guide to figure out if the navigation bar should be \"tall\" or \"short\".\nUnfortunately, that behavior is out of ECSlidingViewController's hands. I'm not sure what the desired effect @xfyre is going for, but I would try making ECSlidingViewController's frame shorter (by setting its edgesForExtendedLayout). This will force the navigation bar to always be short. Or there might be some tricks with hiding/showing the status bar before/after setting the topViewController... just fast enough for the navigation bar to get laid out with the expected top layout guide.\nTaking a snapshot of the top view before anchoring might not be the best way to go about this. We still need to keep the ability to interact with the top view while it is anchored (more useful on iPad).\n. I see, you want to move the status bar with the top view. This might be too specific for your app, and all ECSlidingViewController users might not want it.\nThis might be easier to solve outside of ECSlidingViewController. In theory you could do this:\n1. Take a snapshot of the status bar area.\n2. Hide the status bar.\n3. Add the snapshot to your top view. At this point, the status bar will \"be a part\" of the top view so it will go along for the ride during any kind of animation. Also, the time/battery/signal/etc... won't be updated of course.\n4. anchor/reset/animate however you like.\n5. When the top view is centered, you can remove the status bar snapshot and replace it with the real status bar.\nYou might have issues with the navigation bar changing heights in response to the status bar showing/hiding if you're using UINavigationController. The only workaround I can think of is to just use a plain UINavigationBar while implementing  the UIBarPositioningDelegate to keep the navigation bar height fixed.\nI'm not sure how custom transitions would help, but let me know what you find. In the meantime, I'm closing this PR because it may break backwards compatibility.\n@xfyre If you're using iOS 7 only I'd recommend using v2. You'll be able to do this with a custom animation.\n. @xfyre here's a quick proof of concept using ECSlidingViewController 2 with a custom animation: enriquez/ECSlidingViewController@6e454ddf82e744cf3832e2ee506381d2e4c8ea90\n. Great work @jeffarena! merged and updated CocoaPods/Specs@209796a59c36bd4459da5eab9e3945bc2df12f1d\n. @eldaniel7 not sure what you're asking, but self.slidingViewController.view is the container view. You shouldn't be adding subviews for your menu to it. Add your subviews to your own view controller and set that view controller as a underLeftViewController or underRightViewController.\n. You could set the frame of the under left view yourself inside the animation block. Something similar to this is in the example: https://github.com/ECSlidingViewController/ECSlidingViewController/blob/master/ECSlidingViewController/UnderRightViewController.m#L26\nWe might be able to support this by just calling updateUnderLeftLayout in setUnderLeftWidthLayout. I haven't tried it though, it's just a thought.\n. Thanks for reporting.\nFixed here: 74320bc93143b3dc58bc0098e058277ee441e748\n. Thanks for the PR, but running a pod install will create another Pods project in the workspace. This might be confusing for someone trying to contribute. As for people trying to run the example, I'd prefer to just tell them to run the workspace instead of the project. We should add a note in the README about this.\n. @kbegeman does it work when you open the workspace?\n. Cool, just making sure. Thanks!\n. Hello,\nI'm aware of the iOS simulator having issues with performance/artifacts. I think this is a rare case where the device performs better than the simulator. This may be because of the OpenGL ES limitations of the simulator: https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/TestingontheiOSSimulator/TestingontheiOSSimulator.html#//apple_ref/doc/uid/TP40012848-CH4-SW14.\nI've tested on an iPhone 5s and 4s and it performs very well there.\nHave you tried the examples on an older device? Is there a difference of performance between swiping or tapping to trigger a transition? I'll try to do some testing on an older device when I can get my hands on one.\n. I tested the examples on an iPad 2. The animations are smooth, the only problem I noticed is some sub pixel rendering on the non-retina screen when using the \"UIKit Dyanmics\" transition in TransitionFun. I'll address this with #222.\nThe iPhone 4 does use an older GPU than the iPad 2 (in fact, the oldest GPU that iOS 7 runs on). I'll ask around, but I may not be able to try it for myself.\n. Hmm, I wouldn't call it severe (re: simulator vs. device). There might be something else going on with your setup if it is terribly slow. The known problem with the simulator is an artifact when canceling an interactive transition (begin swiping to reset, but cancel by anchoring instead).\nGive the examples a try on the iPhone 4 and let me know what you find. Thanks!\n. I see, 1.x sets the shadowPath for you and 2.x doesn't. This was intentional because I felt that shadows were the responsibility of the view controllers themselves, and it was weird having ECSlidingViewController do part of the work.\nYou can set it like this:\nobjc\nself.view.layer.shadowPath = [UIBezierPath bezierPathWithRect:self.view.bounds].CGPath\nYou'll need to update the shadowPath when your view changes bounds, so the best place to do this might be viewWillLayoutSubviews or viewDidLayoutSubviews.\nI'll make make a note of this in the docs. Thanks for investigating :thumbsup:\n. Added instructions on how to add a shadow to the wiki.\n. Hello,\nI'm not sure I understand. Can you provide more context? Sample code or screen shots of your setup would be helpful. Also, which version of ECSlidingViewController are you using?\n. I'm still not sure I understand how you have ECSlidingViewController setup, but my guess is that you're creating an instance of the \"Web View Controller\" and setting it as a underLeftViewController or underRightViewController. That instance of \"Web View Controller\" wouldn't be inside  a navigation controller, therefore it wouldn't have a navigation bar.\nPut it in a navigation controller\nobjc\nUINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:webViewController]\nself.slidingViewController.underLeftViewController = navigationController;\n. Your menu can stay the same.\nJust set ECSlidingViewController's delegate to an instance of MEFoldAnimationController\nobjc\nself.foldAnimationController = [[MEFoldAnimationController alloc] init];\nself.slidingViewController.delegate = self.foldAnimationController;\nCheck out the custom transition guide on the wiki:\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/wiki/Custom-Transitions-Guide\nAnd the README for TransitionFun:\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/tree/master/Examples/TransitionFun\n. I'm not sure I understand what you're doing to upgrade. ECSlidingViewController 2 does things differently, so it is not a drop-in replacement (version 2 means the API is not compatible with version 1).\nanchorTopViewTo: was changed to anchorTopViewToRightAnimated: or anchorTopViewToRightAnimated:onComplete:. See the header documentation for details on the available methods http://cocoadocs.org/docsets/ECSlidingViewController/2.0.0-beta1/Classes/ECSlidingViewController.html.\n. Yes, that seems like it should work.\n. There's a problem with TransitionFun when another menu item is added. I plan on fixing this and adding another menu item to TransitionFun.\n. > Will there be a notification on the update on adding the other menu item to TransitionFun?\nCheck the latest version. It has another menu item now.\n\nAlso, is there no page on here anymore to talk about ECSlidingViewController (the one before 2)?\n\nVersion 1.x is available here\nFeel free to open another issue about the problem you're having with 1.x.\n. Hmm, looks like the status bar shrinks. I'm guessing you're using a navigation controller there.\nThis is a problem with the ZoomTransition. A navigation controller's navigation bar is only \"tall\" when its frame is full screen and there is a status bar present. The ZoomTransition needs to add the top view to the container while it is full screen and take a snapshot of it before changing its frame.\nThanks for reporting, I think I'll need to add another menu item to TransitionFun.\n. This is fixed in 869d49b71cddeaabf1166988c7a592dd4f7e3a4b. I updated the TransitionFun example to have another menu item.\n. This can be done with a custom animation. I have an example here that modifies TransitionFun's Zoom transition to move the status bar with the top view: enriquez/ECSlidingViewController@6e454ddf82e744cf3832e2ee506381d2e4c8ea90.\nIt's not included in ECSlidingViewController because it can't handle rotation or bounds changes. The snapshot of the status bar wouldn't know how to resize correctly.\nI'll implement a transition that is for a single orientation and size that mimics Mailbox. It seems to be a highly requested feature.\n. Added a FAQ to the wiki with this question. I plan on doing a better example, but this'll do for now.\n. Thanks,\nIgnore Travis CI, I need to turn it off for the 1.x branch.\nInteresting approach... It looks like you're using a private API to access the status bar. We want to App Store friendly, so we can't implement it this way.\n. It might get past app review because of the obfuscated string, but it's still a private API. I'd rather err on the side of caution. Can't have ECSlidingViewController be responsible for app rejections.\nI'll make a note of your fork for people that really want a way to do this. It's a clever implementation... I just wish the status bar API was public.\n. What's the crash?\n. I'm not able to reproduce, but let me know if you can provide any more detail/context.\n. Here's the new way to do it\nobjc\nself.slidingViewController.topViewAnchoredGesture = ECSlidingViewControllerAnchoredGestureTapping\nThis'll add the resetTapGesture and block all other interactions while anchored.\n. I think I fixed this a few hours ago. Pull down the latest version.\n. This happens when the navigation controller's frame is not the same as the window when it is added.\nI made some changes today on the master branch. Have you tried it yet? I think the way to do it with Cocoapods is\nruby\npod \"ECSlidingViewController\", :head\nAlso, is this with the default transition?\n. The flickering only happens in the simulator. The cause is most likely due to a limitation of the simulator: https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/TestingontheiOSSimulator/TestingontheiOSSimulator.html#//apple_ref/doc/uid/TP40012848-CH4-SW14\nIt should run smoothly on a device.\n. Open the .xcworkspace file instead of the .xcodeproj.\n. Might be something with your CocoaPods setup, I'm able to use ECSlidingViewController in storyboards with CocoaPods.\nTry asking the CocoaPods people about this: https://github.com/CocoaPods/CocoaPods#links\n. It took a bunch of tries, but I was able to reproduce this. I had to click like crazy, and I'm not sure if I double tapped the menu button to trigger it.\nThere are guards against running two transitions at the same time, so the race condition must be before that. Tapping the menu button calls animateOperation: which has the guard and not much else happening before that. Are you sure it's the menu button that causes the freeze?\nDouble tapping a menu item causes the top view to immediately end the transition. This might be caused by the segue setting the topViewController multiple times. Also, tapping a menu item while panning triggers the topViewController to be set and ends up putting everything in an inconsistent state.\nThanks for reporting. Let me know if you have any more info on this. I'll see what I can do about the issues that are easily reproducible.\n. Hey @adamk77, try the latest version.\nI found that swiping to the left in TransitionFun will cause the state of the sliding view controller to get messed up. Tapping the menu button after swiping left will cause the animation to freeze. Maybe this is what was happening when we thought we were double tapping the menu button. We were actually doing a tap and swipe, with the swipe ending last.\nI fixed that along with any other problems that might occur when tapping all over the place. Please give it a try when you get the chance, and let me know if it is still a problem.\n. Thanks! Glad you like it.\nI plan on extracting the transitions into their own projects so that you can install them with CocoaPods. I'd like to have a list of these along with user contributed transitions in the wiki at some point.\nFor now, I'm focused on getting 2.0.0 out of beta.\n. I'm not sure I understand the problem completely, but it sounds like a usage problem. Try asking this on StackOverflow with the \"ECSlidingViewController\" tag with as much detail/code as possible. You'll have a better chance at getting an answer there. I'll answer the question myself if I get the chance.\n. That's expected. Since the gesture isn't handled by the top view, it is handled by whatever passes the hit-test (which would be the view underneath).\nOne way to work around it is to use ECSlidingViewControllerAnchoredGestureCustom with a tap gesture that does nothing.\nobjc\nself.slidingViewController.topViewAnchoredGesture = ECSlidingViewControllerAnchoredGestureCustom;\nself.slidingViewController.customAnchoredGestures = @[doNothingTapGesture];\nA bit of a hack, but that would give the doNothingTapGesture priority over your under view's tap gesture.\n. Thanks @zhen9ao. :thumbsup: \n. Awesome, thanks for the PR. Some feedback:\n- I'd like to keep what you did for 1 and 3. Giving ECSlidingViewControllerLayout the ability to change the under view frames is great. I think a bug is introduced when getting the finalFrameForViewController: for the under view. It should return CGRectZero when the top view is resetting. You'll see this bug by running rake test.\n- PR #243 beat you to fixing the bug for 2. It should be a clean merge with master.\n- The default sliding animation's ending frames for the under views should be the same as the initial frame. So, I think 4 is not needed.\n- I ran TransitionFun with MEParallaxAnimationController, but it looks like the default transition. I'm probably not seeing something?\nI'd like to focus this PR on the changes you have for improving ECSlidingViewControllerLayout with underLeftViewCalculatedFrameForPosition: and underRightViewCalculatedFrameForPosition:. Could you remove everything else from this PR?\nI want to see where you're going with the parallax transition, but I'd like to see it as a fork or separate project. Adding it to TransitionFun is going to be difficult to maintain (it already is with the 4 transitions already there). I plan on making each of the transitions from TransitionFun into their own projects. Eventually, there'll be a list of user contributed transitions on the Wiki.\n. > Can you explain why finalFrameForViewController: should return CGRectZero when the top view is resetting? In my code, I use the finalFrameForViewController: of the under views to achieve the parallax effect: my under-views move, even when resetting. If I change the finalFrame to CGRectZero, my transition will animate the under views to CGRectZero.\nThis is the behavior for iOS 7 custom transitions. CGRectZero signifies the view is being removed or is not on the screen. The parallax transition could've also been accomplished with a custom animation that sets the appropriate frames (and ignoring the frames returned from finalFrameForViewController:). There's nothing wrong with the custom layout you did, that works too.\nI now realize there's a bug with initialFrameForViewController:. For anchoring transitions, it should return CGRectZero for both under views.\n\nWhat you say may be our mis-understanding. If I want the under views to move while revealing and resetting, shouldn't the initial frame and final frame be different? That's how I implemented the parallax effect at least. If change ECSlidingAnimationController back to it's original implementation, I don't get any animations for free.\n\nThe default animation specifically does not move the under view. Considering the bug I mentioned above, it should just set the final frame for the under view from the beginning.\nI see what you did now with the parallax transition. That's fantastic! The intent for TransitionFun was to demonstrate how to implement custom transitions. Separating them as their own projects will make them easily installable and usable for other users when packaged as a CocoaPod. Having different repos will make maintenance easier, since this repo won't be polluted with transition issues. As for versioning, your transition can be tied to a specific version of ECSlidingViewController. CocoaPods makes this easy with dependencies.\nGreat work by the way, I really like the parallax transition.\n. Fixed the issue with initialFrameForViewController: returning a frame for views not on screen d3c45c3796571b478065ab4853fedb503e29f44d\n. The custom layout you used for the parallax transition happens to work with the default animation. The default animation simply animates from the starting frame to the ending frame, and since you customized the layout of the frames you were able to achieve the effect you wanted.\nAfter thinking about this more, I think the parallax transition would be better implemented with a custom animation instead of a custom layout. This removes its dependency from the default animation.\nYour custom animation is free to set the frames to whatever it wants to if the UIViewControllerContextTransitioning methods return CGRectZero. It should set the view's frames to any non-zero rect as defined by the UIViewControllerContextTransitioning methods. Not doing so may break bound changes and rotation, and may cause general layout issues. The iOS 7 custom transitions have problems with this. This is why I came up with custom layout.\nCustom layouts should return CGRectZero when the frame is unknown or doesn't matter. It gives a hint to the animation to add/remove the view, but it depends on how the animation is implemented.\nThere's a lot of flexibility with customizing the transitions, so you're free to do whatever as long as it works for you. If your app is a single orientation and screen size, then you'll be able to get away with breaking more of these rules. What you did with the parallax transition is good, and it should work on iPad as well. The only caveat I can think of is that you are now responsible for handling any view controllers that have their edgesForExtendedLayout set in a custom layout (if you want to!).\nYou bring up some good points, I'll add some more notes to the docs about this.\n. Cool, I look forward to it.\nJust keep the changes related to underLeftViewCalculatedFrameForPosition: and underRightViewCalculatedFrameForPosition: for this pull request. Thanks again.\n. Hi @zhen9ao, thanks again for the pull request.\nThe transition coordinator stuff is a bit odd. It was intentionally made to only work for the default animation and interaction. Custom transitions are out of luck. The reasoning is mainly because of the coordinator animations must be ran inside the animation block (https://github.com/ECSlidingViewController/ECSlidingViewController/blob/master/ECSlidingViewController/ECSlidingAnimationController.m#L58). Because of this limitation, I decided to only let the default transition use this feature.\n. Hey good question.\nNo, there are no notifications in 2.0. The view appearance methods cover most of the notifications that were in 1.0 and the transition methods now have completion blocks:\n- anchorTopViewToRightAnimated:onComplete:\n- anchorTopViewToLeftAnimated:onComplete:\n- resetTopViewAnimated:onComplete\n. Hey @vinny1575, good catch.\nOne thing: Can you use the containerView's frame instead of the screen's frame? The container view is not always the same size as the screen.\n. I merged this in and made the change. Thanks!\n. Thanks for reporting.\nI'm not familiar with how the scroll to top works on the status bar. I'll need to investigate further, but let me know if you have any hints.\n. I think what is happening is that there are multiple view controllers on the screen with scrollsToTop set to YES. According to the docs:\n\nOn iPhone, the scroll-to-top gesture has no effect if there is more than one scroll view on-screen that has scrollsToTop set to YES.\n\nI don't think ECSlidingViewController can do anything to make this automatic for you because it doesn't have any knowledge about the view controller's views. You'll have to make sure you turn off/on scrollsToTop for the appropriate scroll views yourself.\nI've found while testing this that I wanted to be notified when the top view was anchored or reset from the top view controller. This is so that I could set scrollsToTop to YES when it is centered and NO when anchored. I'll open another issue for an enhancement that adds a notification or informal protocol of some kind.\n. Thanks @theShay \n@zhen9ao is right. The child views should already be receiving all of the appearance methods already (viewWillAppear:, viewDidAppear:, viewWillDisappear:, viewDidDisappear:). These are triggered by calls to beginAppearanceTransition:animated: and endAppearanceTransition.\n. Thanks for the detailed report @RichardSimko.\nI'll need to take a closer look into this, but I think the problem is with the percent driven animation. The way it works is that it pauses the layer so that it can be driven by the gesture. Looks like there are negative side effects to this if the top view is animating.\nSome things to try\n- The UIKit Dynamics transition is not percent driven. My guess is that it works fine there.\n- Cancel any animations before the percent driven transition pauses the layer. The under view controller's viewWillAppear: should be early enough to do a [self.slidingViewController.view.layer removeAllAnimations].\nAnyways, I'll try to see if I can come up with a longer term fix.\n. This may be related: http://stackoverflow.com/questions/20408818/ecslidingviewcontroller-freezes-uirefreshcontrol\n. @RichardSimko give the latest master branch a try. If it's good, I think I'll release another beta with this fix.\n. Sounds like something unrelated to ECSlidingViewController.\nTry asking this on StackOverflow, there's more people there that may be able to help you. I may take a stab at it myself if I get the chance. Thanks.\n. Yup, @zhen9ao is right.\n. That was my mistake @RichardSimko, I thought this was 1.x for some reason.\n. I was able to get this to work in the TransitionFun example: enriquez/ECSlidingViewController@67807287b01ccbffede62a845310c05591ea4fb6.\nI'm not sure what is going on in the example you have, but maybe you can spot the differences in what I did.\n. I'll close this for now, but let me know if you find something in ECSlidingViewController that would cause this.\n. Cool, I'll take a look when I get the chance.\n. Thanks for the detailed report.\nThis is because of the percent driven transition which is used by the Default, Fold, and Zoom transitions. An implicit animation is initiated and then immediately controlled with a gesture. The implicit animation sets the final frame of the top view to where it should end. The problem is that the gesture can end the transition to where the animation started. You end up seeing where the implicit animation should've ended.\nI haven't been able to find a good way to do percent driven transitions without this artifact on the simulator. I haven't been able to reproduce it on the device.\nThe purpose of the percent driven transition is for a nice API. It is optional and custom transitions can do without it (but it takes more work). See the UIKit Dyanmics transition.\nAre you able to observe the artifact on the device without the breakpoint?\n. Which device are you using?\n. I can't see this on the device. Either way, the workaround would be to not use a percent driven transition (including the default). It sucks, but I can't come up with a way to have the nice API without having to do those tricks.\n. Try posting this question on Stack Overflow. It'll be easier for you to get help there on how to use ECSlidingViewController with your specific setup.\n. Thanks! :smiley:\nSliding up and down should be possible with a custom transition. It kinda breaks the semantics of the API since theres a lot of left/right references, so it isn't officially supported. Maybe in a future version will be more flexible for this, but not for v2.\n. Looks good @RichardSimko. Cleaned up some whitespace and merged 6c7fdf82154f4084041a23625d14085edc3014e3.\nThanks!\n. @no-computer The status bar style (and hidden property) is decided by the currently \"active\" child view controller. Overriding preferredStatusBarStyle should work as expected, but remember that the topViewController might be a navigation controller. You'll need to subclass the navigation controller and override preferredStatusBarStyle there.\n. Thanks for sharing, that's a pretty cool transition.\nIt should be possible to implement that with ECSlidingViewController. I don't think I'll do it on my own any time soon, but if somebody does please let me know.\n. I can't think of what could be wrong off the top of my head. It might be something specific to your app.\nIf you narrow the problem down to somewhere in ECSlidingViewController, and maybe even reproduce it in one of the example apps I can take a closer look at what is wrong.\n. I tried this out and it looks like Cocoapods doesn't link the test target for some reason. I was able to fix it by telling Cocoapods to link with the test target along with the regular target:\nruby\nlink_with ['MyApp', 'MyAppTests']\n. I plan on dropping the \"beta\" and releasing 2.0.0 soon! Keep an eye out.\n. I would do this by attaching an IBAction to the button and have it call anchorTopViewToRightAnimated or resetTopViewAnimated based on the currentTopViewPosition.\n. You can also implement the delegate methods to cancel ECSlidingViewController's pan gesture with other gestures.\n. Good point, I'll put something up on the FAQ. Thanks!\n. I'm pretty sure it is possible with a custom transition/layout. Haven't tried it though.\n. Is the menu part of the view hierarchy when you try to dismiss the modal? Is there any reason why the unwind segue is on the menu and not on the view controller that presents it?\nI have an example with a modal setup here (see the BasicMenu example https://github.com/enriquez/ECSlidingViewController/tree/modal-example-276). It doesn't work as you describe because the menu view controller is not in the hierarchy when the modal is presented. Let me know if I didn't set this up correctly.\n. You're right, it does not work like a navigation controller. The under top/left/right view controllers are actually siblings of each other in terms of the view hierarchy. They are not presented on top of each other, even though it may seem like it visually.\nIf the end result you are trying to achieve is to dismiss a modal and have the left view controller showing, then you can call anchorTopViewToRightAnimated: somewhere before dismissing the modal.\n. I think I set this up how you describe, but please give this branch a try: https://github.com/enriquez/ECSlidingViewController/tree/split-view-277. It seems to work as expected.\n. That was intentional to make LayoutDemo simple.\nIf you wanted to make the \"Left\" button act as a toggle, you can update the anchorRight method like this:\nobjc\n- (void)anchorRight {\n    if (self.slidingViewController.currentTopViewPosition == ECSlidingViewControllerTopViewPositionCentered) {\n        [self.slidingViewController anchorTopViewToRightAnimated:YES];\n    } else {\n        [self.slidingViewController resetTopViewAnimated:YES];\n    }\n}\n. Yep, that would be the way to do it.\nGood idea, I'll add a note to the FAQ. Thanks!\n. I haven't worked on version 1 in a while, but I don't think it had any configurable easing effects. Version 2 would let you do this with a custom transition: https://github.com/ECSlidingViewController/ECSlidingViewController/wiki/Custom-Transitions-Guide\n. Thanks @jeffbailey \n. Does this happen on the 2.0.0 tag version? I can't get it to happen. There was some work that should've fixed this.\n. I'm not clear on what your setup is. Could you provide some sample code that reproduces the problems?\n. TransitionFun works/builds\nI don't know what is going on here. Can you explain again in English?\n. It would be the same as accessing any other view controller from the AppDelegate. It'll be somewhere in the view controller hierarchy with self.window.rootViewController at the top.\n. Broken how? Folding and unfolding look the same to me.\n. Thanks @stevemoser \nI'm considering removing the storyboard feature since it will cause problems with modals.\nRebased and merged e317374b2fbe5c73cecac405cd32973b248d7622\n. Thanks @NatashaTheRobot \nI have a weird naming convention where \"reset\" means moving the top view to the middle and \"anchor\" means moving the top view to the side. I renamed resetViewAnimated: toPosition:onComplete: to moveTopViewToPosition:animated:onComplete: in this commit da46cbe2f1f9d143a4091517062706f4787e8cfd\nI'll push another release soon.\nRebased and merged: db7100d25309837804e22adf929165ce5b9ac0d6\n. I manually merged the default transition duration commit here 4b8073b1a0d4bd738299e81aac56ce0723f071d0\nAs for the notifications, I think they duplicate the same behavior as the view appearance callbacks.\n. Thanks for the PR @pitiphong-p\nThis is the same type of issue with #290. The storyboard feature is causing more problems than it is worth, so I'll just remove the custom Segue entirely.\n. Thanks!\n74b55f84291bc1868171888a3a7de282fff39021\n. Awesome. I get asked about this feature a lot, but this breaks the semantics of the method names. In version 3 the API can be updated to be more general to support this.\nWon't include for now, but I'm glad I have something to show people who ask for this.\n. The flashing only happens in the simulator, so this isn't a big priority. https://github.com/ECSlidingViewController/ECSlidingViewController/wiki/Frequently-Asked-Questions#why-does-the-animation-flicker-when-cancelling-a-gesture\nAlso, setting the top view's frame in cancelInteractiveTransition will make it jump since it happens outside the animation loop.\n. Can you provide the steps to demonstrate the problem? The default transition is already setup and ready to go on viewDidLoad.\n. Sorry for the delay. I'm happy to see a solution was found.\nA fix for this is now available in version 2.0.3\n. Great work! Thank you!\n. The self.presentingViewController is supposed to be viewController.presentingViewController as well.\nUpdate the PR and it'll be good to merge. Thanks!\n. ",
    "mgerdt": "Thanks in advance! Since I would like to use the controller in an important project, do you have any estimation when you could find time? Don't wanna be needy or bother you, just for my planning  :)\nI'm gonna look at the calculations myself in the meantime. Thank you!\n. Thanks, I'll try it out!\n. ",
    "zorn": "Ok. Yeah my expectation would be see it on all views. Something I probably would notice implementing myself but isn't obvious on the demo.\nThanks for the explanation.\n. ",
    "dhennessy": "Thanks.  By the way, I've just been trying it in a new project - I definitely think it's stable enough to use...\n/dh\nOn 4 Apr 2012, at 15:13, Mike Enriquez wrote:\n\nI've been planning to do this.  I just wanted to make sure the API was stable enough for me to pick a version number.\nI might do this today... I'll keep this issue open until I do a push to CocoaPods.\nThanks for bringing this up.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/edgecase/ECSlidingViewController/issues/9#issuecomment-4954164\n. Thanks - works great!\n. \n",
    "alextrob": "I'm working on a project that sets everything up programatically (no IB or storyboards) and setting a top view controller from my under left table view controller just like in the demo app animates fine for me.\nCan you post your code that sets up and pushes the top view controller (probably didSelectRowAtIndexPath:)?\n. I'm experiencing this issue as well. It's because only one scroll view should have scrollsToTop set to YES. See this question on Stack Overflow.\nInterestingly, when you have both the under-left and top views showing in Facebook on the iPhone, tapping the status bar above each of them scrolls to the top of the scroll view that's beneath it. As in, if you tap the status bar on the left side it scrolls the menu to the top and if you tap the right side it scrolls your timeline/whatever to the top. It's easier to see what I'm describing when you've got the phone in landscape. This makes me think that Facebook manually intercepts touches on the status bar.\nI haven't worked out how I want to handle this yet.\n. ",
    "sigmundc": "I'm also experiencing some lagging on the animation when my topViewController is a UINavigationController. I did everything programmatically without any nib or storyboard files.\nHere's how I do it:\nI have a UIViewController like the FirstTopViewController in the demo app. Then I create a UINavigationController, set root view controller to my UIViewController and set ECSlidingViewController.topViewController to this UINavigationController. \nAm I doing something wrong? \n```\n_dashboardViewController = [[DashboardViewController alloc] init];\n_dashboardNavigationController = [[UINavigationController alloc] initWithRootViewController:_dashboardViewController];\n_initialSlidingViewController = [[InitialSlidingViewController alloc] init];\n[_window setRootViewController:_initialSlidingViewController];\n_slidingViewController = (ECSlidingViewController*)[_window rootViewController];\n[_slidingViewController setTopViewController:_dashboardNavigationController];\n```\nAny help would be appreciated.\n. I figured it out. I actually declared the shadow twice, one in the navigationcontroller and another in the initialviewcontroller. That 3 lines of shadow code actually slows down everything a lot. I don't have that in mind, but it's in viewDidAppear I believe. \n. ",
    "huanxisha": "i got the same trouble , ,somebody help would be appreciated\n. god damn!!  i take the same mistake ,thank you sooo much,  i am dying with it. thx alot. thx\n. this is come from  sigmundc\n. somebody give  me some ideas\n. we all take a mistake ,,,,,,,add shadow twice\n. thx sigmundc \n. about wath? send to 1841382kun@163.com ,,i will check it\n\u5728 2013-06-04 06:44:16\uff0c\"Andrew A. Barber\" notifications@github.com \u5199\u9053\uff1a\nI'm sorry to ask on this thread, but I think sigmundc has removed comments or something?\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "wuqian": "i am dying with it. thx alot. thx \n. ",
    "cmlenz": "Thanks for the link to the question on SO.\nDisabling scrollsToTop for all but the one scroll view that should respond works well for my case.\nYou can even switch the view that should be scrolled by toggling scrollsToTop when handling the notifications ECSlidingViewUnderXxxDidAppear and ECSlidingViewTopDidReset. Then the sidebar is scrolled when it's being shown, and when it's hidden the scroll view in the top view controller is scrolled to the top.\n. +1\n. ",
    "geraldWilliam": "sorry, i've been confused about this. All I'm trying to do is present a modal view controller that I can slide to the side and present a multiselection table as the underneath view controller. but when I try to do this, the modal's presenting view controller (which is of course not visible) is the one that slides. \n. ",
    "justjimmy": "+1\nany ideas to fix this?\n. Hmm you pointed me in the right direction, but I did something else.\nUsing\nobjectivec\nslidingViewController.shouldAllowUserInteractionsWhenAnchored = YES;\nobviously makes the top view interactable, but tapping the menu button does nothing now.\ninstead added gesture recognition to the top view snapshot:\n``` objectivec\n- (void)addTopViewSnapshot\n{\n    if (!self.topViewSnapshot.superview && !self.shouldAllowUserInteractionsWhenAnchored) {\n        topViewSnapshot.layer.contents = (id)[UIImage imageWithUIView:self.topView].CGImage;\n        UIPanGestureRecognizer *_gesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(updateTopViewHorizontalCenterWithRecognizer:)];\n        [topViewSnapshot addGestureRecognizer:_gesture];\n        [self.topView addSubview:self.topViewSnapshot];\n}\n\n}\n```\n. @lightforce cool, will do\n. I can't remember but I don't think it was ever merged in?\n\u2014\nSent from Mailbox for iPhone\nOn Thu, Feb 28, 2013 at 7:24 PM, Manuel Alabor notifications@github.com\nwrote:\n\nam i wrong or is this modification not yet available via cocoapods version 0.9.0?\nReply to this email directly or view it on GitHub:\nhttps://github.com/edgecase/ECSlidingViewController/issues/17#issuecomment-14222236\n. If there are multiple scroll views you might have to manage which one should be the one that scrolls to top based on which table view is 'active'?\n\nhttp://stackoverflow.com/questions/4809925/setscrollstotop-with-multiple-uiscrollview-classes-and-or-subclassesuitableview\n. ",
    "sbhklr": "I figured it out. You have to set the shouldAllowUserInteractionsWhenAnchored property of the ECSlidingViewController to YES.\nslidingViewController.shouldAllowUserInteractionsWhenAnchored = YES;\n. @justjimmy Nice solution. I propose you do a pull request so it can be merged into the master branch.\n. @justjimmy Just one little improvement, I think we can store the gesture recognizer in a local variable so that it can be reused instead of creating a new one each time. E.g.:\n```\n@implementation ECSlidingViewController\n{\n    UIPanGestureRecognizer* topViewSnapshotGestureRecognizer;\n}\n\n\n(void)addTopViewSnapshot\n{\n  if (!self.topViewSnapshot.superview && !self.shouldAllowUserInteractionsWhenAnchored) {\n    topViewSnapshot.layer.contents = (id)[UIImage imageWithUIView:self.topView].CGImage;\nif(!topViewSnapshotGestureRecognizer)\n    topViewSnapshotGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(updateTopViewHorizontalCenterWithRecognizer:)];\n[topViewSnapshot addGestureRecognizer:topViewSnapshotGestureRecognizer];\ntopViewSnapshotGestureRecognizer.enabled = _resetStrategy & ECPanning;\n[self.topView addSubview:self.topViewSnapshot];\n  }\n}\n```\n. Thank you @justjimmy that solves this problem.\n. \n\n",
    "swissmanu": "am i wrong or is this modification not yet available via cocoapods version 0.9.0?\n. referencing to https://github.com/edgecase/ECSlidingViewController/issues/17#commit-ref-53de473, it was.\nbut it seems that no new version tag was created since then nor that the cocoapod spec was updated.\nare there any plans to release a new version, @enriquez?\n. @lyair1 you have to add the shadow to the UINavigationViewController instead to your actual UIViewController. its actually quite obvious, but had the same problem some time ago.\nin a generic way, this would like the following:\n``` objective-c\n-(void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\nif(self.navigationController != nil) {\n    [self applyMenuShadowOnView:self.navigationController.view];\n} else {\n    [self applyMenuShadowOnView:self.view];\n}\n\n}\n-(void)applyMenuShadowOnView:(UIView*)view {\n    view.layer.shadowOpacity = 0.75f;\n    view.layer.shadowRadius = 10.0f;\n    view.layer.shadowColor = [UIColor blackColor].CGColor;\n}\n```\nto pan in your topViewController again, make sure you set the shouldAddPanGestureRecognizerToTopViewSnapshot property of your ECSlidingViewController to YES\n. ",
    "reejosamuel": "Ya same problem, I have other views before the initial view controller of ECSlidingViewController. \nHow to change the code \nECSlidingViewController slidingViewController = (ECSlidingViewController )self.window.rootViewController;\nto accommodate this.\n. ",
    "Mpak87": "OH MY GOD!!!!! THANKX THANKX!!!!!!!!\n. ",
    "ryancstack": "solved, just had to set the main underLeftViewController as the navigation controller instead of the UITableViewController\n. Here is my viewDidLoad method for my nav controller connected to the menu: \n    - (void)viewDidLoad {\n    [super viewDidLoad];\n    [self.slidingViewController setAnchorRightRevealAmount:280.0f];\n    self.slidingViewController.underLeftWidthLayout = ECFullWidth;\n    }\nSo I moved this from the menu controller to the nav controller\nand from other view controllers, I made it open my specified nav controller like this:\nif (![self.slidingViewController.underLeftViewController isKindOfClass:[NavBottomViewController class]]) {\n    self.slidingViewController.underLeftViewController  = [self.storyboard instantiateViewControllerWithIdentifier:@\"navController\"];\n  }\nNavBottomViewController being my nav controller and @\"navController\" being the identifier given in storyboard\n. ",
    "artOfWarBut": "is that  navigation's animation  worked\uff1f   i add a navigationController to underRightView ,but the back animation do not work ,can you give me some Suggestions\n. ",
    "leongersing": "Makes sense to me. Merging in. Sorry for the delay. \n. Sorry for the delay, Thomas. Great add, I'm merging as is. Thanks! \n. kinadian is right on this one. Simply present your login view controller from any view controller you like and it should not invalidate the view hierarchy's consistency (at least up to 5.1, I'm behind on 6.0 study) unless you're doing something off the wall in your presentation/destruction of the login VC.\n. ",
    "simonbs": "This turned out to be rather simple to implement. Say, your view controller beneath the top view controller is a menu and you want to reuse top view controllers to save load time. Then you can simply do the following:\n```\n// Animate top view controller\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^\n{\n    UIViewController *newViewController = nil;\n    if ([self.viewControllerMap.allKeys containsObject:identifier])\n    {\n        // Reuse view controller\n        newViewController = [self.viewControllerMap objectForKey:identifier];\n    }\n    else\n    {\n        // New view controller\n        newViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];\n        [self.viewControllerMap setValue:newViewController forKey:identifier];\n    }\n// Get new top view controller (with navigation controllers taken into account)\nUIViewController *newTopViewController = newViewController;\nif ([newViewController isKindOfClass:[UINavigationController class]])\n    newTopViewController = ((UINavigationController *) newTopViewController).topViewController;\n\n// Get current top view controllre (with navigation controllers taken into account)\nUIViewController *curTopViewController = self.slidingViewController.topViewController;\nif ([curTopViewController isKindOfClass:[UINavigationController class]])\n    curTopViewController = ((UINavigationController *) curTopViewController).topViewController;\n\n// Change if the new and the current controller is not of the same class\nif (![newTopViewController isKindOfClass:[curTopViewController class]])\n{\n    CGRect frame = self.slidingViewController.topViewController.view.frame;\n    self.slidingViewController.topViewController = newViewController;\n    self.slidingViewController.topViewController.view.frame = frame;\n}\n\n// Reset top view\n[self.slidingViewController resetTopView];\n\n}];\n```\nself.viewControllerMap is a dictionary which holds the identifier of the view controller as key and the view controller as value. I also check if the classes of the current top view controller and the new should be the same and thereby if it is necessary to change the top view controller at all. Be aware, whether or not you can do this depends on how you use your view controllers. If you use the sliding view controller for a simple menu, you should be fine.\n. ",
    "cannyboy": "How is the self.viewControllerMap populated?\n. ",
    "keithyeoh-mediacraft": "@simonbs it's not working fine when the flows are as follows,\n1) Scroll the first init TOP VIEW which to make the view different after view loaded. (e.g: Profile VC Scroll to offset y 300)\n2) Show left panel, and choose other item from the list to change to other TOP VIEW and scroll it again. (e.g: Recommended VC scroll to offset y 500)\n3) Show left panel again, and choose back the first init TOP VIEW (Profile VC). The TOP VIEW goes back to top instead of load to offset y 300.\n4) But for the following actions, it works fine. Which means if I change back to TOP VIEW to Recommended VC, it goes back to offset y 500, and change back to Profile VC, it goes back to whenever I scroll to on step 3.\n- (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath\n{\n```\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\nNSString *topViewIdentifier = nil;\n\n\n\nswitch( indexPath.row ){\n\n\n\n    case 0:\n\n        topViewIdentifier = @\"ProfileVC\";\n\n        break;\n\n\n\n    default:\n\n        topViewIdentifier = @\"RecommendedVC\";\n\n        break;\n\n}\n\n\n\nif ( ![self.viewControllerMap.allKeys containsObject:topViewIdentifier] ) {\n\n    [self.viewControllerMap setValue:[self.storyboard instantiateViewControllerWithIdentifier:topViewIdentifier] forKey:topViewIdentifier];\n\n}\n\n\n\nUIViewController *activeTopVC = nil;\n\nactiveTopVC = [self.viewControllerMap objectForKey:topViewIdentifier];\n\n\n\n// Get new top view controller (with navigation controllers taken into account)\n\nUIViewController *newTopViewController = activeTopVC;\n\nif ([activeTopVC isKindOfClass:[UINavigationController class]]){\n\n    newTopViewController = ((UINavigationController *) newTopViewController).topViewController;\n\n}\n\n\n\n// Get current top view controller (with navigation controllers taken into account)\n\nUIViewController *curTopViewController = self.slidingViewController.topViewController;\n\nif ([curTopViewController isKindOfClass:[UINavigationController class]]){\n\n    curTopViewController = ((UINavigationController *) curTopViewController).topViewController;\n\n}\n\n\n\n// Change if the new and the current controller is not of the same class\n\nif ( ![newTopViewController isKindOfClass:[curTopViewController class]] ) {\n\n    CGRect frame = self.slidingViewController.topViewController.view.frame;\n\n    self.slidingViewController.topViewController = activeTopVC;\n\n    self.slidingViewController.topViewController.view.frame = frame;\n\n}\n\n[self.slidingViewController resetTopView];\n\n}];\n```\n}\nIs there any solution for this? I've ever tried to put it on viewWillAppear event which to set the first load TOP VIEW into the dictionary, it also not working fine.\n. Same here, I am dealing with the same problem which I've just downloaded it on today.\n. ",
    "DrBeak1": "One solution I've found is to present modally and just mimic the push transition. I found this code somewhere, I cannot find the source, it's been a while -- otherwise I'd credit the person who originally wrote it:\nimport \n@interface UIViewController(Transitions)\n- (void) presentModalViewController:(UIViewController )modalViewController withPushDirection: (NSString ) direction;\n- (void) dismissModalViewControllerWithPushDirection:(NSString *) direction;\n@end\nimport \"UIViewController+Transitions.h\"\nimport \n@implementation UIViewController(Transitions)\n- (void) presentModalViewController:(UIViewController )modalViewController withPushDirection: (NSString ) direction {\n[CATransaction begin];\nCATransition *transition = [CATransition animation];\n  transition.type = kCATransitionPush;\n  transition.subtype = direction;\n  transition.duration = 0.25f;\n  transition.fillMode = kCAFillModeForwards;\n  transition.removedOnCompletion = YES;\n[[UIApplication sharedApplication].keyWindow.layer addAnimation:transition forKey:@\"transition\"];\n  [[UIApplication sharedApplication] beginIgnoringInteractionEvents];\n  [CATransaction setCompletionBlock: ^ {\n      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(transition.duration * NSEC_PER_SEC)), dispatch_get_main_queue(), ^ {\n          [[UIApplication sharedApplication] endIgnoringInteractionEvents];\n      });\n  }];\n[self presentModalViewController:modalViewController animated:NO];\n[CATransaction commit];\n}\n- (void) dismissModalViewControllerWithPushDirection:(NSString *) direction {\n[CATransaction begin];\nCATransition *transition = [CATransition animation];\n  transition.type = kCATransitionPush;\n  transition.subtype = direction;\n  transition.duration = 0.25f;\n  transition.fillMode = kCAFillModeForwards;\n  transition.removedOnCompletion = YES;\n[[UIApplication sharedApplication].keyWindow.layer addAnimation:transition forKey:@\"transition\"];\n  [[UIApplication sharedApplication] beginIgnoringInteractionEvents];\n  [CATransaction setCompletionBlock: ^ {\n      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(transition.duration * NSEC_PER_SEC)), dispatch_get_main_queue(), ^ {\n          [[UIApplication sharedApplication] endIgnoringInteractionEvents];\n      });\n  }];\n[self dismissModalViewControllerAnimated:NO];\n[CATransaction commit];\n}\n@end\n. ",
    "MrBendel": "See issue #59 \n. I did a series of tests and was able to get the UINavigationController's to function properly by modifying the code.\n``` objective-c\n- (void)underLeftWillAppear\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:ECSlidingViewUnderLeftWillAppear object:self userInfo:nil];\n    });\n    [self.underRightView removeFromSuperview];//self.underRightView.hidden = YES;\n[self.underLeftViewController viewWillAppear:NO];\n[self.view insertSubview:self.underLeftView atIndex:0];// self.underLeftView.hidden = NO;\n[self updateUnderLeftLayout];\n_underLeftShowing  = YES;\n_underRightShowing = NO;\n\n}\n\n(void)underRightWillAppear\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:ECSlidingViewUnderRightWillAppear object:self userInfo:nil];\n    });\n    [self.underLeftView removeFromSuperview]; //self.underLeftView.hidden = YES;\n    [self.underRightViewController viewWillAppear:NO];\n    [self.view insertSubview:self.underRightView atIndex:0];//self.underRightView.hidden = NO;\n    [self updateUnderRightLayout];\n    _underLeftShowing  = NO;\n    _underRightShowing = YES;\n}\n```\n\nim not sure yet how this affects performance or intended behavior but it appears to be working!\n. Also no need to add the view controllers in the setup with this method\n``` objective-c\n\n\n(void)setUnderLeftViewController:(UIViewController *)theUnderLeftViewController\n{\n    [_underLeftViewController.view removeFromSuperview];\n    [_underLeftViewController willMoveToParentViewController:nil];\n    [_underLeftViewController removeFromParentViewController];\n_underLeftViewController = theUnderLeftViewController;\nif (_underLeftViewController) {\n    [self addChildViewController:self.underLeftViewController];\n    [self.underLeftViewController didMoveToParentViewController:self];\n[self updateUnderLeftLayout];\n\n\n\n//        [self.view insertSubview:_underLeftViewController.view atIndex:0];\n    }\n}\n\n\n(void)setUnderRightViewController:(UIViewController *)theUnderRightViewController\n{\n    [_underRightViewController.view removeFromSuperview];\n    [_underRightViewController willMoveToParentViewController:nil];\n    [_underRightViewController removeFromParentViewController];\n_underRightViewController = theUnderRightViewController;\nif (_underRightViewController) {\n    [self addChildViewController:self.underRightViewController];\n    [self.underRightViewController didMoveToParentViewController:self];\n[self updateUnderRightLayout];\n\n\n\n//        [self.view insertSubview:_underRightViewController.view atIndex:0];\n    }\n}\n```\n. Just to further add to bug fixes for this project, should also adjust resetTopView as follows:\nobjective-c\n- (void)resetTopView\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:ECSlidingViewTopWillReset object:self userInfo:nil];\n    });\n    [self resetTopViewWithAnimations:nil onComplete:^() {\n        [self.underLeftView removeFromSuperview];\n        [self.underRightView removeFromSuperview];\n    }];\n}\n. Oh and for anyone interested in using this class and wanting to know why these adjustments make the class work properly: \nThe viewWillAppear/viewDidAppear methods only ever get called once, when the side views are added to the stack. In order for the navigation controller to function properly, these need to be called every time the view appears or disappears. By adding and removing the views manually, essentially the system is making these calls for you. This ensures your views will function as intended. \n. ",
    "mutablestudio": "You can easily do this in updateTopViewHorizontalCenterWithRecognizer which is the selector for ECSlidingViewController panGesture property.  Inside updateTopViewHorizontalCenterWithRecognizer check the CGFloat panAmount, and disable the the code block beneath it when the pan exceeds your threshold.  \nNote the pan amount starts at 0.0 and goes negative  as the user swipes right (revealing left side menu).\nYou also can add a check for initialHoizontalCenter to disable further swiping while the left menu is revealed, so the user could only drag left:\n```\n  if (panAmount>-96.0 && self.initialHoizontalCenter<190) {\n      if ((newCenterPosition < self.resettedCenter && (self.anchorLeftTopViewCenter == NSNotFound || self.underRightViewController == nil)) ||\n          (newCenterPosition > self.resettedCenter && (self.anchorRightTopViewCenter == NSNotFound || self.underLeftViewController == nil))) {\n          newCenterPosition = self.resettedCenter;\n      }\n  BOOL newCenterPositionIsOutsideAnchor = newCenterPosition < self.anchorLeftTopViewCenter || self.anchorRightTopViewCenter < newCenterPosition;\n\n  if ((newCenterPositionIsOutsideAnchor && self.shouldAllowPanningPastAnchor) || !newCenterPositionIsOutsideAnchor) {\n      [self topViewHorizontalCenterWillChange:newCenterPosition];\n      [self updateTopViewHorizontalCenter:newCenterPosition];\n      [self topViewHorizontalCenterDidChange:newCenterPosition];\n  }\n\n}\n```\n. ",
    "mattbezark": "i was looking at the AppDelegate which of course is not a UIViewController subclass.  never mind!\n. yes.  the sizes were wrong when it didn't take the orientation into account.\nmatt.\nOn Sep 12, 2013, at 3:23 PM, Mike Enriquez notifications@github.com wrote:\n\nIf I remember correctly, it was on purpose. Did it break something for you?\n\u2014\nReply to this email directly or view it on GitHub.\n. thanks.  i'll try to duplicate the issue and get back to you.\n\nmatt.\nOn Sep 12, 2013, at 3:38 PM, Mike Enriquez notifications@github.com wrote:\n\nBy setting self.slidingViewController.underLeftWidthLayout = ECFixedRevealWidth; in the example, I was able to get the under views to size correctly (notice the disclosure indicators):\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "balabs": "Have you fixed it? Now I am facing the same problem.\n. Can share with me your way of sliding?\nThanks for fast response any way.\nOn Fri, Sep 28, 2012 at 3:03 AM, Steven Tseng notifications@github.comwrote:\n\nNope. I switched to another \"sliding\" method. Hope someone could fix this\nthough.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/edgecase/ECSlidingViewController/issues/34#issuecomment-8960272.\n\n\nDejan Balaban\n+387 65 863 615\n. ",
    "Anachid": "Nope. I switched to another \"sliding\" method. Hope someone could fix this though.\n. ",
    "adamszeptycki": "Hey,\nI still have this problem. I downloaded your's code today, so i have newest version. Any idea what can i do?\n. ",
    "sailajaSaritha": "I have also same problem , please someone can help me\n. ",
    "javalnanda": "Make sure the view to which gesture is added is already added to the screen , it will resolve the problem.\n. ",
    "danpe": "I'm calling it in viewDidLoad and it still happends.. how can i verify that the view is already added to the screen?\n. ",
    "leo-martin": "Hello, I'm also having this problem tried fixin it by adding the 3 views to the slidingviewcontroller but the only response I get (because of the gestureRecognizer) is : \"-[__NSArrayM insertObject:atIndex:]: object cannot be nil' \"\nI tried logging the self.slidingviewcontroller, and after my initView where i set the topViewController for ECSlider, i always get null on self.slidingViewController.\nplease answer, or advise another slider framework\nLeo Martin\n. hey,\nI actually fixed my problem, I created a view just before my main view where i set to topviewcontroller (which is my main view controller), and then I created an xib just for the left view (only needed that one) adjusted to its size (eg, if you want your left slider to cover 280px of the screen, make your width 280), and after that in the menu file, did the usual initialization with \n[self.slidingViewController setAnchorRightRevealAmount:280.0f];\nself.slidingViewController.underLeftWidthLayout = ECFullWidth;\nas for the general funcs (dismiss, show left view controller, etc..), I took the ones in the example project\nand it did the trick!\nhope it helps\n. any news on this? currently working with ECSlidingViewController, and the unwind segue doesn't work either.\n. ",
    "itsaboutcode": "Facing the same issue. Anyone know the fix?\n. I have the same question - asked about the same time you asked and will really appreciate if someone can answer us this #97\n. ",
    "mmarino3": "The above doesn't help me out at all, unless it's supposed to go into an area other than the MenuViewController. I've opened up a stack overflow about it here: http://stackoverflow.com/questions/18089977/ios-adding-menu-causes-crash-when-not-first-view?noredirect=1#comment26541419_18089977\n. ",
    "energo": "All this Problem, is connected with one moment which all of you missed, answer to solve:\nYou forget add a slidingviewcontroller object of esclidingviewcontroller to you storyboard, and make it initial controller, and setup in storyboard inner slidingviewcontroller: topViewContoller and menuController storyboardIDs.\n. ",
    "iosbrunix": "Energo I describe you my situation hope you can help me.\nThe menu working great for all of my views except for one.\nFor the whole views I include in the .m files the following code:\n// Menu import\nimport \"ECSlidingViewController.h\"\nimport \"MenuViewController.h\"\n// menu first block just after  [super viewDidLoad];\n    self.view.layer.shadowOpacity=0.75f;\n    self.view.layer.shadowRadius= 40.0f;\n    self.view.layer.shadowColor=[UIColor greenColor].CGColor;\nif (![self.slidingViewController.underLeftViewController isKindOfClass:[MenuViewController class]]) {\n    self.slidingViewController.underLeftViewController  = [self.storyboard instantiateViewControllerWithIdentifier:@\"MenuProvaVC\"];\n}\n// Menu second block just before vievDidLoad }\n        [self.view addGestureRecognizer:self.slidingViewController.panGesture];\n// Button  menu\n- (IBAction)OpenMenu:(id)sender {\n  [self.slidingViewController anchorTopViewTo:ECRight];\n  }\nok As I tell before every views with these lines work great except for one that go to \"'NSInvalidArgumentException', reason: '*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil'\" in the second menu block.\nFollowing the complete incriminated view implementation:\nimport \"RNBlurModalView.h\"\nimport \"InfotrafficoVC.h\"\nimport \"ManagerNetwork.h\"\nimport \"ManagerData.h\"\nimport \"StreetDetail.h\"\n// Menu import\nimport \"ECSlidingViewController.h\"\nimport \"MenuViewController.h\"\n@implementation InfotrafficoVC\n@synthesize streetObj;\n@synthesize luogoNord;\n@synthesize luogoSud;\n@synthesize allTableData;\n@synthesize svincolo;\n- (void)viewDidLoad{\n  [super viewDidLoad];\nCGRect screenRect = [[UIScreen mainScreen] bounds];\n  CGFloat screenWidth = screenRect.size.width;\n  CGFloat screenHeight = screenRect.size.height;\n  NSLog(@\"larghezza %f\", screenWidth );\n  NSLog(@\"altezza %f\", screenHeight);\nif (screenHeight > 490){\n      NSLog(@\"High Resolution Device %f\", [[UIScreen mainScreen] scale] );\n      //cellDati.hidden=YES;\n      //view1.frame = CGRectMake(0, 0, screenWidth, screenHeight+88);\n      scroll.frame = CGRectMake(12, 145, 300, 340+40);\nimmfooter.frame = CGRectMake(0, 438+85, 318, 34);\n  luogoSud.frame = CGRectMake(12, 438+93, 104, 21);\n}\n// menu primo blocco\nself.view.layer.shadowOpacity=0.75f;\n  self.view.layer.shadowRadius= 40.0f;\n  self.view.layer.shadowColor=[UIColor greenColor].CGColor;\nif (![self.slidingViewController.underLeftViewController isKindOfClass:[MenuViewController class]]) {\n      self.slidingViewController.underLeftViewController  = [self.storyboard instantiateViewControllerWithIdentifier:@\"MenuProvaVC\"];\n  }\nluogoNord.text = streetObj.from;\n  luogoSud.text = streetObj.to;\n  ManagerNetwork *mn=[[ManagerNetwork alloc]init];\n  [mn callServer:@\"TRAFFICO\" param1:streetObj.lcd  param2:nil param3:YES param4:nil];\n  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(trafficoList) name:@\"traffico\" object:nil];\n// Menu secondo blocco\n  [self.view addGestureRecognizer:self.slidingViewController.slidingViewController.panGesture];\n}\n- (void)trafficoList{\n  NSLog(@\"Chiamo trafficoList\");\n  ManagerData con = [[ManagerData alloc] init];\n  managedObjectContext= [con managedObjectContext];\n  NSFetchRequest fetchRequest = [[NSFetchRequest alloc] init];\n  NSEntityDescription entityPosition = [NSEntityDescription entityForName:@\"StreetDetail\" inManagedObjectContext:managedObjectContext];\n  NSPredicate predicate = [NSPredicate predicateWithFormat:[NSString stringWithFormat:@\"streetDetail_street.lcd = '%@'\",streetObj.lcd]];\n  [fetchRequest setEntity:entityPosition];\n  [fetchRequest setPredicate:predicate];\n  NSSortDescriptor sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"order\" ascending:YES selector:@selector(localizedStandardCompare:)];\n  [fetchRequest setSortDescriptors:@[sortDescriptor]];\n  NSError error;\n  NSArray arrayContract = [managedObjectContext executeFetchRequest:fetchRequest error:&error];\n  StreetDetail streetDetailObj = nil;\n  if ([arrayContract count]==0) {\n      //dati non coerenti\n  }else{\nallTableData = [[NSMutableArray alloc] initWithCapacity: [arrayContract count]];\n  for (int i=0; i<[arrayContract count]; i++) {\n      streetDetailObj=[arrayContract objectAtIndex:i];\n      [allTableData addObject:streetDetailObj];\n  }\n}\n  [cellDati reloadData];\n}\n-(IBAction)legenda{\n    UIView view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 237, 241)];\n    view.backgroundColor = [UIColor whiteColor];\n    UIImage img = [UIImage imageNamed:@\"legenda\"];\n    UIImageView  imageView = [[UIImageView alloc] initWithImage:img];\n    [view addSubview:imageView];\n    RNBlurModalView  modal = [[RNBlurModalView alloc] initWithViewController:self view:view];\n    [modal show];\n}\npragma mark -\npragma mark Table view data source\n\n(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n  return 1;\n  }\n(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n  return [allTableData count];\n  }\n(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath {\n  UITableViewCell cell = [tableView dequeueReusableCellWithIdentifier:@\"CellInfoTraffico\"]; \n  StreetDetail sd = [allTableData objectAtIndex:indexPath.row];\n  NSLog(@\"order: %@\",sd.order);\n  UIImageView imgS=(UIImageView )[cell viewWithTag:101];\n  NSString nome_imgS=[NSString stringWithFormat:@\"FrecciaGiu_%@.png\",sd.conditionN];\n  [imgS setImage:[UIImage imageNamed: nome_imgS]];\n  UILabel recipeNameLabel = (UILabel )[cell viewWithTag:100];\n  recipeNameLabel.text = sd.start;\n  UIImageView imgE=(UIImageView )[cell viewWithTag:102];\n  NSString *nome_imgE=[NSString stringWithFormat:@\"FrecciaSu_%@.png\",sd.conditionS];\n  [imgE setImage:[UIImage imageNamed: nome_imgE]];\n  return cell;    \n\n}\n- (IBAction)ApriMenu:(id)sender {\n  [self.slidingViewController anchorTopViewTo:ECRight];\n  NSLog(@\"Entro in apri menu\");\n}\n- (void)didReceiveMemoryWarning{\n  [super didReceiveMemoryWarning];\n}\n@end\nPlease I need to solve this issue ASAP I hope was a simple solution due to the fact that I'm new in iOS coding.\nThank's in advance,\nBrunix\n. ",
    "kanerozz": "When I received memory warning, the main view did redraw itself, but the left view didn't.\n. My solution is set underLeftViewController = nil  in didReceiveMemoryWarning\n. ",
    "vishl": "Hmm, for me it is the main view.  I can't see the left view after that because the button to show the left view is gone.  Please see: https://github.com/vishl/ECSlidingViewController/tree/broken-modal\nIn any case it seems to be a bug (possibly in iOS).  I have had limited success by setting the controller to nil and then back to the original controller.  This worked in another project, but it causes an exception here.  Note that in iOS 6, this appears to fixed.  It is only broken in 5.1\n. ",
    "kinadian": "I'm doing something similar.  I left the ECSlidingViewController as it was and I just use a modal view to display my login form.  If the login is successful, I dismiss the modal view and you're left with the FirstTop view\n. Did you try calling the revealMenu method in the view controller of your first view?  If it works, I'd use a flag so that it only does it on the first time.\n. I've been able to accomplish it with this code:\nUIViewController *newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"NewVC\"];\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n        CGRect frame = self.slidingViewController.topViewController.view.frame;\n        self.slidingViewController.topViewController = newTopViewController;\n        self.slidingViewController.topViewController.view.frame = frame;\n        [self.slidingViewController resetTopView];\n}];\nHowever, it's not very smooth.  It slides the old top VC away nicely then the new top VC jumps in place.  There's also an issue of \"focus\".  I can't interact with any of the controls in the new VC until I tap on it somewhere (almost like I'm selecting it).\n. ",
    "rubyist": "Hi,\nThe license for this code is the MIT license. You are free to include this code in your project and there should be no problems with putting it on the App Store.\nThanks\n-Scott\n. ",
    "3rdFunkyBot": "I'm seeing this issue. Did you ever find a fix? It's driving me nuts.\n. ",
    "jeanregisser": "Seeing the same issue here.\n. ",
    "cherpake": "Same here... anybody found a way to fix it?\n. adding this:\n- (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil\n  {\n  if ( self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil] ) {\n      self.wantsFullScreenLayout = YES;\n  }\n  return self;\n  }\nsolved this for me.\n. +1. ",
    "syropian": "Is there a fix for this yet? @cherpake's method didn't work for me. Just like @jessbowers, for me there is a gap at launch but once you open and close it, it fixes itself. Would love a fix for this.\n. ",
    "smakman": "I had to call slidingViewController.wantsFullScreenLayout = YES; after initializing it in my AppDelegate to fix this.\n. ",
    "alexsaidani": "This does not seem to have an effect?\n. Everything runs exactly the same, just using the initialslidingviewcontroller instead of the appdelegate to set the first top view controller?\n. Yeah, i'm still having trouble getting it to work as required. Even after attempting this, it would seem you can get the menu to show on its own and then slide in a view when selecting a cell.\n. Where have you got this code? Your first view controller, appdelegate or initial sliding view controller?\n. Okay I see what you mean, you'll probably have to detect the orientation of the device then apply a different reveal amount according to the orientation. Something along those lines?\n. ",
    "shmidt": "It has. Probably you did something wrong\n. Yes, exactly.\nSorry, I misunderstood your question first time.\nI believe that the changes I wrote will help others to implement your controller easier, because no change in AppDelegate is needed and SlidingViewController can be used not only as root View Controller.\n. ",
    "phedlund": "I am using this:\n[self.slidingViewController setAnchorRightRevealAmount:320.0f];\nself.slidingViewController.underLeftWidthLayout = ECFullWidth;\n[self.slidingViewController anchorTopViewTo:ECRight];\nIt works great when starting in portrait (iPad, iOS 6), but when starting in landscape the top view slides too far to the right. If I reset the view once and then pan, it stops at the expected anchor point.\n. I have tried it in several locations including viewDidLoad and viewWillAppear for both top and lower view. Always the same result.\n. I started a new issue about this specific problem, https://github.com/edgecase/ECSlidingViewController/issues/46.\nChanging the reveal amount is not a solution because once you slide the top view closed and open it again it stops at the expected position. I guess as a workaround you could have some sort of startup flag, but that is not very elegant.\n. ",
    "darinkrauss": "Sure, I'll do that in the next couple of days.\nThanks,\n-Darin\nOn Nov 9, 2012, at 5:12 PM, Mike Enriquez notifications@github.com wrote:\n\nYou're right, those should be \"assign\". Would you like to submit a patch?\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "zhen9ao": "ECSlidingViewController don't support iOS4, because it uses view controller containment methods that can't be used in iOS4.\n. :+1:\n. OK, got it!\n\u2014\nYours Jack\nOn Wed, Dec 4, 2013 at 8:35 AM, Mike Enriquez notifications@github.com\nwrote:\n\nHi @zhen9ao, thanks again for the pull request.\nThe transition coordinator stuff is a bit odd. It was intentionally made to only work for the default animation and interaction. Custom transitions are out of luck. The reasoning is mainly because of the coordinator animations must be ran inside the animation block (https://github.com/ECSlidingViewController/ECSlidingViewController/blob/master/ECSlidingViewController/ECSlidingAnimationController.m#L58). Because of this limitation, I decided to only let the default transition use this feature.\nReply to this email directly or view it on GitHub:\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/pull/245#issuecomment-29766809\n. As ECSlidingViewController is a kind of container controller just like UINavigationController, and navigation controllers can be added to tab bar controller, so it should be possible to add ECSlidingViewController as one of the viewcontrollers to UITabBarController.\n. \n",
    "raskchanky": "@jbennett Just wanted to say thanks for the custom segue.  I'm using it in my app and it's working great.\n. ",
    "MacMannes": "I also experienced this problem today. I did't find a solution yet.\nAndr\u00e9\n. It has something to do with the topViewSnapshot. I still didn't find out why this doesn't work with iOS 5.1.1, but I solved this problem in my app by setting the shouldAllowUserInteractionsWhenAnchored property of my ECSlidingViewController instance to YES.\n. ",
    "mooseDev": "Hi, \nmake sure that you havent't set clipToBounds = YES in storyboard or code for your topviewcontroller since shadow view is drawn outside view frame...\n. ",
    "boztalay": "Well, that was it! Thanks for the help.\n. Try setting it in the interface builder. Go to your view controller and make sure the TableView is selected. Then, in the utilities bar on the right, find \"clip subviews\" and make sure it's unchecked.\n. ",
    "odincov": "I have same issue using Tab Bar Controller. Tried clipToBouns = NO; in viewWillAppear in ViewController and it didn't help. Could you show me direction? Thank you.\nSergei\n. ",
    "azelaya6": "im having the same problem! i have tried setting self.view.clipsToBounds = NO; and \n    self.view.layer.masksToBounds = NO; i also tried unchecking the clip subview in the interface builder and nothing. i dont have this problem when on a uiviewcontroller. its only on a uitableviewcontroller. any thoughts ??\nany help is appreciated.\n. ",
    "OMGHaveFun": "try do it at NC\n. ",
    "VladislavSenyukov": "After hours of digging I finally figured it out. To make shadow appear the actual code self.view.layer.shadowRadius = 10.0f; and so on should be set in your UINavigationController instance because it is topViewController of the sliding view controller with its shadowy view and not the root view controller of UINavigationController where I tried to set the shadow.\n. ",
    "YGeorge": "This doesn't work for me also.\n. Great project, thank you!\n. ",
    "pfbns": "Hi Enriquez. Thank you for your reply.\nYes, I've tried not moving the top view off the screen while starting the search. And yes, it solves the problem. But still, I would like to find a way to have the full width of the screen while doing a search. Do you have a suggestion of where should I look to try to solve the problem? Maybe trying to do the search with a UISearchBar inside of UINavigationBar and then control those animations individually... I don't know.. I just feel that being the project so awesome, I would like to make the effort to help tune it this little bit more. Thank you.\n. ",
    "bbedwell": "Can we pull this in? It fixed the issue for me.\n. ",
    "kylebegeman": "Setting this property to NO makes the pan gesture not work and it still reveals past the peak amount. Am I missing something?\n. Setting this property to NO makes the pan gesture not work and it still reveals past the peak amount. Am I missing something?\n. I agree, I am unable to run the sample code because I getting linker errors\n. Yes, I read this post before seeing the resolved issues stating to run the workspace. \n. ",
    "boraturant": "I couldn't do it.I wonder if you can share with us how you resolved this issue.\n. ",
    "john-brunelle": "Just got it and it can be reproduced easily. In the target's summary screen lock yourself to Landscape only. You can see that the right side doesn't have a shadow and the right nav bar button doesn't work. I haven't figured out the problem yet thou.\n. ",
    "seanrogs": "Thanks, I've been struggling with this for a while.\n. ",
    "jeffarena": "Here are steps to reproduce this issue with the sample project:\n1. In FirstTopViewController, viewWillAppear:, comment out the lazy initialization of the underRightViewController.\n2. Move configuration of anchorLeftPeakAmount and underRightWidthLayout properties from UnderRightViewController viewDidLoad into viewWillAppear: in FirstTopViewController.\n3. Run the app and pan to the right side.\n4. Observe that the non-existant underRightViewController is revealed via the panning gesture.\nSo, this is most definitely a bug, but one that only manifests itself when the under controller is nil AND a peak/reveal amount has been configured for that side.\n. Here's the diff of my changes to the sample project, as outlined in the above steps to reproduce.\n```\ndiff --git i/ECSlidingViewController/FirstTopViewController.m w/ECSlidingViewController/FirstTopViewController.m\nindex 7c31e6a..6b34d86 100644\n--- i/ECSlidingViewController/FirstTopViewController.m\n+++ w/ECSlidingViewController/FirstTopViewController.m\n@@ -24,10 +24,12 @@\n     self.slidingViewController.underLeftViewController  = [self.storyboard instantiateViewControllerWithIdentifier:@\"Menu\"];\n   }\n\nif (![self.slidingViewController.underRightViewController isKindOfClass:[UnderRightViewController class]]) {\nself.slidingViewController.underRightViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"UnderRight\"];\n}\n+//  if (![self.slidingViewController.underRightViewController isKindOfClass:[UnderRightViewController class]]) {\n+//    self.slidingViewController.underRightViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"UnderRight\"];\n+//  }\n[self.slidingViewController setAnchorLeftPeekAmount:40.0f];\nself.slidingViewController.underRightWidthLayout = ECVariableRevealWidth;\n+\n   [self.view addGestureRecognizer:self.slidingViewController.panGesture];\n }\n```\n. In our app, there are a number of cases where we nil out the underRightViewController due to changing context in the center. However, when the underRightViewController is available, we always want the anchorLeftPeekAmount to be the same. So, I currently set the anchorLeftPeekAmount when I load the app, and then conditionally nil out or assign the underRightViewController as appropriate.\n\nA quick look through our code base shows 27 times where I am either nil-ing out or assigning the underRightViewController. It seems silly for me to have to zero-out or re-set the anchorLeftPeek amount 27 times, spreading this one line of configuration throughout my app, when the attached commit handles the situation without issue.\n. Closing this pull request in favor of pull request 73\n. Details to reproduce the issue are available in the details for #64.\n. @SFPink I'm not sure if this would address your issue when calling anchorTopViewTo: in response to button touches. The specific race condition I've observed was only occurring during panning.\n. Will do! On vacation with the Mrs this week but will get my hands around the open issues and PRs once we're back. A huge thanks to Mike for all the work this week to clear the issue and PR backlog!!\nJeff\nOn Mon, Sep 9, 2013 at 9:43 PM, nicoschtein notifications@github.com\nwrote:\n\nGreat to hear this!\n    You should start by checking if the PRs are fine to merge, there are some nice fixes and features added!\nN I C O\nOn Mon, Sep 9, 2013 at 5:47 PM, kEND notifications@github.com wrote:\n\nDone.\nOn Mon, Sep 9, 2013 at 4:24 PM, Mike Enriquez notifications@github.comwrote:\n\n@jeffarena https://github.com/jeffarena has volunteered to take over\nthe repo. Yay! He's made some great contributions to\nECSlidingViewController in the past, so it'll be in good hands.\nCan someone at @edgecase/@neo https://github.com/neo (@mdoelhttps://github.com/mdoel,\n@kEND https://github.com/kEND) give @jeffarenahttps://github.com/jeffarenawrite access to this repo?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/edgecase/ECSlidingViewController/issues/163#issuecomment-24111522\n.\n\nKen Barker\n614.403.7044\nReply to this email directly or view it on GitHub:\nhttps://github.com/edgecase/ECSlidingViewController/issues/163#issuecomment-24112504\nReply to this email directly or view it on GitHub:\nhttps://github.com/edgecase/ECSlidingViewController/issues/163#issuecomment-24128288\n. @cherpake can you provide some additional detail about your view controller setup? it would be helpful to understand where you are presenting the modal viewController from relative to the slidingViewController in order to attempt to reproduce the issue you are reporting. thanks!\n. @davidbitton you're not going to be able to simply animate the set of the topViewController property during your logout. i'd probably make your colored view controller the topViewController at all times, and then conditionally add the split view controller to it as a child view controller when a user is logged in. you can then animate the adding/removing of the split view controller's view as a child, as needed. how you handle that animation will depend greatly on the desired visual effect.\n. @airdrummingfool can you take a look at the feature/issue-204 branch and confirm the changes work for you?\n. I believe you're correct. Updated.\n. @jaydee3 are you able to demonstrate the problem with the sample app? i checked things out yesterday before cutting the release branch and everything looked happy on iOS 6.\n. I'll take a look and get a fix pushed later today.\n. @xfyre if you make changes on your existing branch and just push the new commits when you're done, the pull request should update automatically. no need to submit a new one. thanks!\n. @xfyre I think we're going to want to get that event sequence right before merging this. Also, after looking at the code a bit more closely, I can't find anywhere currently where we're actually filling that tapViewSnapshot with anything that actually resembles a snapshot of the underlying topView. If that's the case, adding this code may be completely unnecessary. @enriquez any thoughts here?\n. This should be fixed on the develop branch.\n. Awaiting merge to master as part of a 1.3.3 release.\n. @enriquez for your review, this release fixes a view resizing bug I introduced in the previous 1.3.2 release.\n. self.slidingViewController\n. I would need more information about your controller setup in order to answer the question or, ideally, a sample project. Regardless, this isn't a bug, so closing.\n. @marchv your best best is to subclass ECSlidingViewController and override shouldAutorotate and supportedInterfaceOrientations as appropriate for your app.\n. I'm sorry, I don't have sample code to help you out here.\n. If you can provide a sample project that demonstrates the issue, I'd be happy to take a deeper look.\n. Not a bug.\n. If you can provide a sample project demonstrating the issue, I'd be happy to take a closer look.\n. @enriquez hook me up with a ticket and i'll get the README updated Cocoapods details. seems like there has been some churn around Cocoapods over the last few days, so would like to get the documentation sorted out.\n. Let's remove the property. If the user has iOS7, let's use the new snapshot API, which is supposed to be faster than the current approach.\n. Please don't use a version check like this. Instead, just check: [[UIScreen mainScreen] respondsToSelector:@selector(snapshotViewAfterScreenUpdates:)].\n. Same as above, please don't use a version check like this. Instead, just check: [[UIScreen mainScreen] respondsToSelector:@selector(snapshotViewAfterScreenUpdates:)].\n. \n\n\n",
    "camdenfullmer": "Shouldn't issue #58 be closed then under issues?\n. ",
    "n1mda": "Is this the correct way to handle panning in subcontrollers? This means that\nslidingViewController.panGesture.enabled = YES/NO;\nneeds to be implemented in EVERY view's viewDidAppear: in order to enable or disable the pangesture from views that should have it, and views that shouldn't.\nWhy aren't viewcontrollers that were pushed by topViewController not automatically disabled for displaying the menu?\n. ",
    "iBenjamin": "i think should remove pan gesture when push subcontrollers.\n. ",
    "voznesenskym": "Hey - I came here to say this is a very inconvenient way of having this done. Would it be possible to remove pan gestures from subcontrollers on push? I can even make the pull request if you like.\n. ",
    "iwasrobbed": "I would love to see more basic examples and usage.  For whatever reason, this isn't working for me \"out of the box\" whether with storyboards or with XIBs.  It should be as simple as treating the view controller as a subclass of ECSlidingViewController and inheriting the behavior, but the ECSlidingViewController anchorTopViewTo method isn't being called even though my code is verbatim what the example app code is.\nIt looks like a great project, but implementation has been a real headache so far compared to other libraries I've used before.\n. Thanks for the response @vaiism!  How are you accessing the layer component for the UITabBarController?  Any relevant sample code is greatly appreciated!\n. Ah, I'm an idiot.  I forgot to add #import <QuartzCore/QuartzCore.h> so I was originally getting an error saying Property 'shadowOpacity' cannot be found in forward class object 'CALayer' since it didn't know what type of object the layer property was.\nThanks for the help!\n. +1 I believe the same behavior exists for triggering the in-call status bar in the simulator since the code isn't catching the UIApplicationWillChangeStatusBarFrameNotification notification\n. Thanks Mike!  We just needed the notifications since the delegation callbacks caused a lot of coupling.  Since we're using this pod for a notifications panel, there were too many views that could be launched from the panel and it made knowing when the panel was closed very messy (duplicate / unnecessary code in unrelated VCs).  If there is a better way to have optional notifications for open/close/reset events, please let me know\n. +1 The best thing is for everyone to submit bugs to Apple, even if one already exists, so they know the scale of the issue and ensure it's fixed. \n. One idea is to just use an older version of this library (such as 1.3.3), since it doesn't appear to be broken on iOS 8. \n. For all those curious, the latest iOS 8 GM seed fixes this issue without the fix needed above (so old code started working again)\n. ",
    "markkrenek": "Even if you set a custom tint color, the status bar still changes to black the first time you change the top view controller.\n. ",
    "shawkinaw": "This should be reopened, setting a custom tint does not work. Is there a workaround?\n. ",
    "ppeelen": "This problem still exists. Even when setting the tint color. Any solution?\n. ",
    "alexburkhay": "\"I don't understand the issue with the order of the calls. The frame is set relative to container view, so it shouldn't matter.\" - on viewWillAppear method (inside our custom left or right controller) we always expect that our view has the most recent version of frame. That's why frame resizing [self updateUnderLeftLayout]; should go before [self.view insertSubview:leftView belowSubview:self.topView];  (this will call viewwillappear in our custom controller)\n. Nope) In method viewWillAppear in some cases we need to update frames for some subviews of this under view according to latest version of underview frame. (if im not wrong all geometry tansformations with subviews of controller.view should be in viewwillappear method ) \nthanks:)\n. In other implementations of sliding menu mask is (UIViewAutoresizingFlexibleWidth |\nUIViewAutoresizingFlexibleHeight) or UIViewAutoresizingNone.\nSWRevealViewController :\n   _frontView.autoresizingMask = UIViewAutoresizingNone;\n  [_contentView setAutoresizingMask:UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight];\nPPRevealSideViewController :\n  self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\nViewDeck :\n  _wrappedController.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n  self.centerView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\nJust for example:)\n. Make subclass of UINavigationController and in viewWillAppear method add pangesture on self.view:\n    [self.view removeGestureRecognizer:self.slidingViewController.panGesture];\n    [self.view addGestureRecognizer:self.slidingViewController.panGesture];\nas described in readme\nSo pangesture will be added at navigationcontroller view: navigationBar + inside views\n. ",
    "nCore": "I have the same issue. Namely:\nwhen I try to add gestureRecognizer with [self addGestureRecognizer:self.slidingViewController.panGesture] I got this:\nframe #1: 0x34ed4c6c CoreFoundation`-[__NSArrayM insertObject:atIndex:] + 776\nframe #2: 0x3384447e UIKit`-[UIView(UIViewGestures) addGestureRecognizer:] + 178\nA big thrown exception because of that the self.slidingViewController.panGesture is null. \nWhat am I missing?\n. ",
    "manojthomas88": "Found solution myself. \nIn this case, self.slidingViewController in underViewControllers represents its own view controller and if we need to give pan gesture, we really need to give it to upper Controller. So self.slideViewController.slideViewController addGestureRecognizer done it for me... \n. ",
    "hackin247": "Check your slidingViewController in the debugger and make sure it is not nil by the time you get to adding the gesture recognizer.   If it is, your slidingViewController is not properly defined and initialized.\n. ",
    "vaiism": "I am actually doing this with a UINavigationController inside of a UITabBarController instead, with the UITabBarController being my topViewController. I then add the shadow information to the TabBarController viewDidLoad so that when it is being dragged, the shadow is for the entire top. It is working well.\n. Well - at first I was using the UIViewController from inside the UINavController to access it view the parentViewController (such as [[[self parentViewController] parentViewController] view]) and setting the shadow manually - but ended up just creating a custom UITabBarController class and in the viewDidLoad of the TabBarController:\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n// On the loading of this controller - set the shadow TabBarController is the \n// base of the child views that will be used in the sliding, and is the topViewController.\n// ECSlidingViewController takes care of the rest.\nUIColor *shadowColor = [UIColor blackColor];\nself.view.layer.shadowOpacity = 0.9f;\nself.view.layer.shadowRadius = 5.0f;\nself.view.layer.shadowColor = shadowColor.CGColor;\n\n}\n```\nThis way - the encompassing container view is the one that gets the shadow.\nHTH.\n. ",
    "ruddfawcett": "@iwasrobbed How were you able to accomplish this with a UITabBarController?  I would like to have a menu item that shows a UITabBarController, but am struggling.  Any suggestions?\n. bump\n. ",
    "SFPink": "This can happen when calling  [self.slidingViewController anchorTopViewTo:ECRight]; on a button touch. When its spammed the under controller can be a blank white screen. Would this be a similar fix?\n. ",
    "kostiadombrovsky": "Use shouldAllowPanningPastAnchor property. Although it didn't quite work for me without tweaking.\n. ",
    "nickgs": "I am in the same boat here. In scour mode looking for a solution. Any updates? \n. ",
    "bulut": "Is there a way to animate the transition to the newChildViewController? Thanks so much for your help.\n. Kinadian,\nThanks so much for your quick response. Really appreciate the code snippet too. Because the action is initiated from the toolbar on the bottom of the screen, the user would expect a segue instead of a sliding view. It would be awesome, if I can use the segue to animate to the target VC in addition to using the left menu to slide view to the target VC.  Any thoughts?\n. Thanks Alex. This is great. Exactly what I was looking for.\n. Anyone has any solutions to this problem? I am also having this issue.\n. ",
    "web-differently": "hello i have a problem with a tabbarcontroller \nTerminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UINavigationController\n. ",
    "marcadams": "This should be merged A.S.A.P :+1: \n. ",
    "airdrummingfool": "I'm not sure whether or not this helps the conflict with swipe gestures, but it's useful when using both left AND right under view controllers together. With this, you can't grab the left side of the screen (intending to swipe right and open open the left under view) and accidentally open the right side under view instead (which in our case was undesirable). We're not using both under left and under right view controllers anymore, but we still don't want the entire top view to be pannable - cutting the grabbable area down reduces the amount of accidental pans when users try and interact with other things in our app.\n. make sure you're attaching the pan gesture recognizer to the right place... if your tableview controller is in a navigation controller, for example, make sure you put the pan gesture recognizer on navigationController.view.\n. I went up against this exact thing - and got it to work - just a few days ago.\nIn my subclass of ECSlidingViewController:\n1. in viewDidLoad, set self.panGesture.delegate = self; (make sure you declare that your subclass conforms to UIGestureRecognizerDelegate)\n2. Implemented gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: and set it to return YES when otherGestureRecognizer is a UISwipeGestureRecognizer.\nOn my UITableViewController:\n3. Looped through tableView.gestureRecognizers to find the SwipeGestureRecognizer (the one you find is the one that controls swipe-to-delete)\n- set the pan gesture recognizer to require the swipeGestureRecognizer to fail ([self.slidingViewController.panGesture requireGestureRecognizerToFail:swipeGR];)\n- set the swipe gesture recognizer's direction to be the direction opposite the panning motion to open the sliding view controller (if you don't do this, swipes will often block the pan).\n. It's the SwipeGestureRecognizer I found in step 3 (I just created a pointer to it to make it easier to reference).\n. @rawanOmari: to set the swipe gesture recognizer's direction left (since my pan GR was to the right), I had to loop through all of the gesture recognizers on the tableview and find the swipe GR, then modify it. Note that this isn't necessary for iOS 7 or 8 (I think... this code is old) since newer tableviews use a pan gesture recognizer to delete.\nobjc\n    /*\n     * Set swipe to delete to only work in one direction, and make sure\n     *  swipe to delete fails before triggering the pan gr.\n     * NOTE: This doesn't affect iOS 7+ (iOS 7+ tableView uses a panGR,\n     *  not swipeGR for editing)\n     */\n    NSLog(@\"Configuring swipe-to-delete GR\");\n    for (UIGestureRecognizer *existingGR in self.tableView.gestureRecognizers) {\n        if ([existingGR isKindOfClass:[UISwipeGestureRecognizer class]]) {\n            NSLog(@\"Found swipe-to-delete GR: %@\", existingGR);\n            [(UISwipeGestureRecognizer *)existingGR setDirection:UISwipeGestureRecognizerDirectionLeft];\n            [self.slidingViewController.panGesture requireGestureRecognizerToFail:existingGR];\n            break;\n        }\n    }\n. check out my instructions here: https://github.com/edgecase/ECSlidingViewController/issues/129#issuecomment-18045424 to get swipe-to-delete working. You should be able to use it (or something similar) to get other swipes and gestures to work.\n. ",
    "hightech": "I figured it out. Everything is good. \n. Same here. I have this problem without segues, too.\n. I sent a bug report to Apple about this issue.\n. Now it is working! Thanks @SpruceGoose429! \n. @kambizn Awesome! It is working! No more warning messages.\n. @eldaniel7 and @sampayo you need to add few methods in your files. Here is what somebody said https://github.com/ECSlidingViewController/ECSlidingViewController/issues/367#issuecomment-66736268\nIt fixed my warnings. \n. ",
    "ektayogesh": "Use the following method \n[self.slidingViewController anchorTopViewTo:ECLeftanimations:nilonComplete:^{\n}];\ninstead of this \n[self.slidingViewController anchorTopViewOffScreenTo:ECLeftanimations:nilonComplete:^{\n}];\n. It doesn't work for me, one thing that I would like to understand should I create a new instance of view controller every time you click on a menu item, can I create a singleton instance for each menu item view controller and every time user clicks on a menu item set the singleton instance of that view controller as the topViewController.\n. Hello utiko, Yes that's what I am doing, but when I assign each of the viewController to topViewController first time they are ok but as soon as I assign them the second time I loose the panning gesture. One each of my controller viewDidLoad I am doing\n[self.view addGestureRecognizer:self.slidingViewController.panGesture];    \nSome how I am suspecting that when I am re assigning one of the viewController to the topViewController, this panGesture is gtting messed up.\n. I found that you have already addressed this in #55 \n. Hello kbegeman, I am not sure why it is not working for you. But if I do this self.shouldAllowPanningPastAnchor = NO, in the ECSlidingViewController viewDidLoad, I am able to get this work.\n. ",
    "Mamonaku": "Fantastic, it's working ! thanks !\n. ok, found out why.\ncase closed.\n. ",
    "rromanchuk": ":+1:  just tag a new version, and we'll update the podspec\n. ",
    "dev-mush": "ok this worked like a charm! thank you.\n. ",
    "lyair1": "im sorry for being a \"begginer\" but can you plz give me a quick explanation about what it means to make a subclass? thank you. im experiencing the same problem\n. Not yet... Really hope someone will reply soon...\n. Thanks @NSDSrinivas it really looks like its better... i think this library is more simple to use but i guess there is no other option but use the other one you've suggested...\ndid you find a way to implement the solution they suggested in this project?\n. ",
    "andrew-soltan": "In my MenuViewController, I added this line and it did the trick:\nself.slidingViewController.shouldAllowUserInteractionsWhenAnchored = YES;\n. On my MenuViewController I added this line and it did the trick:\nself.slidingViewController.shouldAllowUserInteractionsWhenAnchored = YES;\n. ",
    "utiko": "You can save all viewControllers to array or dictionary on first call. And then only assign topViewVontroller to one of them on menu item click.\n. ",
    "Claus79": "I have tried the code suggested above by andrew-soltan\nnow I can pan the top view back but there are 2 new problems:\n1) tap gestures not working on the topview (so if I click the top right menu button it doesn't slide back)\n2) it's still not possible to swipe on the underLeftController.\nhere the StackOverFlow question: http://stackoverflow.com/questions/17453345/activate-pan-gesture-on-menucontroller-using-ecslidingviewcontroller\n. I tried the approaches you suggested,but inserting the gesture recogniser inside a subclass of UINavigationController didn't work. Strangely,placing the theoretically equivalent\njavascript\n[self.navigationController.view addGestureRecognizer:self.slidingViewController.panGesture];\nin the TableviewController viewWillAppear: method does the trick instead.\n. Ok, maybe found a work around for the tap recogniser problem, instead of the previous line insert this one in your side menu view controller\nself.slidingViewController.shouldAddPanGestureRecognizerToTopViewSnapshot = YES;\nstill it's not possible to swipe on the menu view.\n. ",
    "rrroni": "Try adding this:\nself.slidingViewController.shouldAddPanGestureRecognizerToTopViewSnapshot = YES;\nTo viewDidLoad of one of the view controllers you're presenting from MenuViewController, in your case, I'm thinking FirstTopViewController.\n. ",
    "shaharyaranjum": "How did you resolve your issue? I'm interested since I have the same problem.\n. Yeah I figured it out. I just initialized the view controller in my app delegate and passed the managedObject down directly. \n. ",
    "gmarm": "Well, in the end, I didn't end up using CoreData due to other reasons.\nAnyway, one simple solution I can think of right now might be creating a reference to your initialSlidingViewController in your AppDelegate and then pass the managedObject all the way down to the view controllers you need it. I haven't worked with ECSlidingViewController in quite some time now so I don't know if this is possible or not. \n. ",
    "kamikazebr": "Use [self.slidingViewController anchorTopViewTo:ECRight] in viewWillAppear\n. ",
    "kimar": "+1\n. That's what I've thought at first. But I''ve got an App using this code in the App Store with no problems... https://itunes.apple.com/us/app/geofancy/id725198453?l=de&ls=1&mt=8\nIf you'd like to have a look at the App just tell me, I could create a Promo Code for you.\n. I clearly agree with you! Thanks a bunch.\n. ",
    "sreuter": "+1 /cc @edgecase\n. ",
    "lmcgs": "And i solve that issue with my way;\nLike that:\n//[self presentModalViewController:self.twViewController animated:YES];\n[self.slidingViewController.topViewController.view addSubview:twViewController.view];\nDismiss modal view.\nHave a nice day.\n. UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"StoryBoard-iPhone4\" bundle:nil];\n[self.slidingViewController setTopViewController:[obj.storyboard instantiateViewControllerWithIdentifier:@\"TaskNavigation\"]];\nThat's right way for assign a ViewController for ECSliding. \n@\"StoryBoard-iPhone4\" = Your storyboard name\n@\"TaskNavigation\" = Your View name in storyboard. Select your view in storyboard and assign Storyboard ID at right side.\nHave a nice day.\n. ",
    "wennyben": "I have another issue which similar. When I instantiated the right view controller, everything goes well. Even if i present another view controller on the top of the right view controller, still fine.\nBut if I dismissModal it, all things on the right side turn white. any solution ? \n. ",
    "NSDSrinivas": "Hi, \nHave you found solution for this. I am facing the same problem when using a navigation controller. \nRegards,\nSrinivas\n. https://github.com/mikefrederick/MFSideMenu/pull/10\nCheck this out. \n. ",
    "MarkJar": "This might be related.  I found the same behavior (can't drag the view closed once it's open, just click to close).  In my case, I was adding the panGesture to an arbitrary UIView, instead of self.View.  This cased the view not be able to drag closed.\nTo work around, I added Notifications for ECSlidingViewTopDidAnchorRight, and when the view anchored open, I then add the panGesture to self.view instead of my original UIView.\nThis allowed me to drag the view open with my UIView, but drag it closed with the entire top level view.  This worked around the bug where you can only click to close the top view.\n. ",
    "lewis-smith": "I find the same issue where I can use the pan to open the menu, but can only use the tap to close it.\nI can see this working in the demo so it must be something I'm doing differently but I can't figure it out.\nI tried enabling shouldAddPanGestureRecognizerToTopViewSnapshot and this works for controllers where there is nothing to interact with on the snapshot, but it is not viable for table views or anything where interacting looks weird.\nI added a pan gesture recogniser to the menu and that lets me swipe on the menu but not the snapshot view.\nI'm sure it's something simple, but I've compared everything I can think of and I'm at a brick wall.  Any advice hugely appreciated.\n. ",
    "justdan0227": "Ok so I'm a huge fan of this control.  I did some profile analysis and I see that the view controllers are destroyed and instantiated every time a sliding menu is selected.  My question is, how can we change this to persist.  I do basic window setup during viewDidLoad that does not need to be done each time the view is displayed.  I'm coming from a model where views are pushed on top of the main view and the main view holds all of the detailed stuff.  Has anyone made changes to allow a window to persist and then be re-shown rather than instantiated?\n. So guys I've been thinking about this, where you could do this with Notifications are described above, I took it upon myself to implement the following Class Methods to keep track of ViewControllers that have been instantiated - (not yet complete but its a start).  Let me know what you think.\nECSlidingViewController.h\n/* Master Array of View Controller */\n+(void) addViewController:(NSString )viewControllerIdentifier viewController:(UIViewController )avc;\n+(UIViewController ) queryViewController:(NSString )viewControllerIdentifier;\nECSlidingViewController.m\n// -----------------------------------------------------------------------\n//\n// -----------------------------------------------------------------------\n+(void) addViewController:(NSString )viewControllerIdentifier viewController:(UIViewController )avc {\n```\nif (!arrayOfViewControllers){\n    arrayOfViewControllers = [[NSMutableDictionary alloc]initWithCapacity:0];\n}\nif ([arrayOfViewControllers count]) {\n    UIViewController existingViewController =(UIViewController )[arrayOfViewControllers objectForKey:viewControllerIdentifier];\n    if (existingViewController) {\n        NSLog(@\"%s ViewController exists %@\", func, viewControllerIdentifier);\n        return;\n    }\n}\n[arrayOfViewControllers setObject:avc forKey:viewControllerIdentifier];\n```\n}\n// -----------------------------------------------------------------------\n//\n// -----------------------------------------------------------------------\n+(UIViewController ) queryViewController:(NSString )viewControllerIdentifier {\n```\nif (!arrayOfViewControllers)\n    return nil;\nif ([arrayOfViewControllers count]) {\n    UIViewController existingViewController =(UIViewController )[arrayOfViewControllers objectForKey:viewControllerIdentifier];\n    if (existingViewController) {\n    return existingViewController;\n}\n\n}\nreturn nil;\n```\n}\nAnd then in your MenuViewController.m\n// -----------------------------------------------------------------------\n//\n// -----------------------------------------------------------------------\n- (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath\n  {\nNSString *identifier = [[self.menuArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row];\nUIViewController *newTopViewController = [ECSlidingViewController queryViewController:identifier];\nif (!newTopViewController) {\n      newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];\n      [ECSlidingViewController addViewController:identifier viewController:newTopViewController];\n  }\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n      CGRect frame = self.slidingViewController.topViewController.view.frame;\n      self.slidingViewController.topViewController = newTopViewController;\n      self.slidingViewController.topViewController.view.frame = frame;\n      [self.slidingViewController resetTopView];\n  }\n   ];\n  }\n. Thanks.. I'm going to update the add to replace the view controller if the identifier is sent in that already exists, and then obviously it needs a delete to move them from the dictionary.  I'll submit that tomorrow\n. Hey all sorry it's taken so long to get back here.  Did we ever update the code to have these new methods along with a delete?  If not I'll update.  (also looking at what IOS7 is doing to this code)\n. Hmmm I just tried mine in IOS7 Beta 2 and the heading of the menu is showing under the status bar (this whole under the status bar is just wrong and I so wish Apple would recall it from IOS7.  It should be an option, not a mandate as it's breaking my apps.\nAnyway, off my soap box back to here.  So your tested apps show under the status bar just fine?\n. Hey Frank, if you look over https://github.com/ECSlidingViewController/ECSlidingViewController/tree/master/Examples/BasicMenu you will see that doing this in storyboard is very easy.  Are you starting an app from scratch or looking to add the controller to an existing project?  I'm using storyboards in all of my projects.\n. Hey Frank, make sure that your version of MenuViewController has\n- (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath\nthe following code:\n```\nUIViewController *newTopViewController = [ECSlidingViewController queryViewController:identifier];\nif (!newTopViewController) {\n    newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];\n    [ECSlidingViewController addViewController:identifier viewController:newTopViewController];\n}\n```\nThis is what checks to see that you already have the viewController instantiated.\nDan\n. Anyone get this to work.  I've tried everything on the set EdgesForExtendedLayout and still no luck :(  Why Apple went with this new design I'll never understand.  Most of my apps are now broken.\n. no but I think I know how to fix it.. stay tuned...\n. How do you pull that branch to try it out?\nOn Sep 24, 2013, at 1:59 AM, Mike Enriquez notifications@github.com wrote:\n\nTry this branch and let me know how it works #177\n\u2014\nReply to this email directly or view it on GitHub.\n. So I think I've finally solved the iOS6/iOS7 useage.  I just pulled the iOS7 fork and ran it and it works perfectly on iOS7.  However on iOS6 we have the infamous 20 pixels low view controller on everything.  I was able to fix this in 2 of my apps by changing the iOS6/7 Deltas in the size property in interface builder of Storyboard.\n\nThis is what I did:\n- First remove the - (UIView *)statusBarBackgroundView creation inside of ECSlidingViewController.m  The original purpose of this was to show the status bar in iOS7 as white on black.  However if you want black on white you had to change the code and in iOS6 this creates a problem as everything in iOS7 is shifted down by 20.  So just remove this.\n- Next in your STORYBOARD change the background color of the main INITIAL SLIDING VIEW CONTROLLER  controller to be black (or white).  All of the descendants then will use DEFAULT or clear and get its status bar background color from the main NAVIGATION controller so you don't need the startusBarBackgroundView.\nNext (and here is the hard work for iOS6).  On EVERY control in your view controllers you must go to the size inspector and add -20 to the iOS6/7  Y delta value.  This is ignored in iOS7 but since the view is \"shifted\" in iOS6 up by 20 you have to use the -20 in the delta Y to make it work.\nAlso change the TABLEVIEW in the Menu View Controller to be -20 delta Y in the iOS6/7 size inspector.\nRecompile and it should work in iOS6 and in iOS7\n. So I think I've finally solved the iOS6/iOS7 useage.  I just pulled the iOS7 fork and ran it and it works perfectly on iOS7.  However on iOS6 we have the infamous 20 pixels low view controller on everything.  I was able to fix this in 2 of my apps by changing the iOS6/7 Deltas in the size property in interface builder of Storyboard.\nThis is what I did:\n- First remove the - (UIView *)statusBarBackgroundView creation inside of ECSlidingViewController.m  The original purpose of this was to show the status bar in iOS7 as white on black.  However if you want black on white you had to change the code and in iOS6 this creates a problem as everything in iOS7 is shifted down by 20.  So just remove this.\n- Next in your STORYBOARD change the background color of the main INITIAL SLIDING VIEW CONTROLLER  controller to be black (or white).  All of the descendants then will use DEFAULT or clear and get its status bar background color from the main NAVIGATION controller so you don't need the startusBarBackgroundView.\nNext (and here is the hard work for iOS6).  On EVERY control in your view controllers you must go to the size inspector and add -20 to the iOS6/7  Y delta value.  This is ignored in iOS7 but since the view is \"shifted\" in iOS6 up by 20 you have to use the -20 in the delta Y to make it work.\nAlso change the TABLEVIEW in the Menu View Controller to be -20 delta Y in the iOS6/7 size inspector.\nRecompile and it should work in iOS6 and in iOS7\n. So I think I've finally solved the iOS6/iOS7 useage.  I just pulled the iOS7 fork and ran it and it works perfectly on iOS7.  However on iOS6 we have the infamous 20 pixels low view controller on everything.  I was able to fix this in 2 of my apps by changing the iOS6/7 Deltas in the size property in interface builder of Storyboard.\nThis is what I did:\n- First remove the - (UIView *)statusBarBackgroundView creation inside of ECSlidingViewController.m  The original purpose of this was to show the status bar in iOS7 as white on black.  However if you want black on white you had to change the code and in iOS6 this creates a problem as everything in iOS7 is shifted down by 20.  So just remove this.\n- Next in your STORYBOARD change the background color of the main INITIAL SLIDING VIEW CONTROLLER  controller to be black (or white).  All of the descendants then will use DEFAULT or clear and get its status bar background color from the main NAVIGATION controller so you don't need the startusBarBackgroundView.\nNext (and here is the hard work for iOS6).  On EVERY control in your view controllers you must go to the size inspector and add -20 to the iOS6/7  Y delta value.  This is ignored in iOS7 but since the view is \"shifted\" in iOS6 up by 20 you have to use the -20 in the delta Y to make it work.\nAlso change the TABLEVIEW in the Menu View Controller to be -20 delta Y in the iOS6/7 size inspector.\nRecompile and it should work in iOS6 and in iOS7\n. Hmmm I set [self.navigationController.navigationBar setHidden:YES]; in the viewDidAppear of my firstTopViewController along with what I described above and everything works great.  Now I am not using autolayout if that makes any difference.\n. Ahh... so why would you setHidden:NO ?  you are using the ECSliderViewController to do navigationbar stuff.  Why would you want to show the navigationController and have the ECSliderViewController both running? (I understand it may be your design but don't know that the two work together)\n. So.. I think you want to just hide the ECSliderViewController and not do anything with the navigationController.  If you hide the navigationController in your ViewDidLoad and then set [self.slidingViewController setHidden:YES]; and then redisplay it with [self.slidingViewController setHidden:NO]; does that help ?\n. ok there is no navigation bar (at least there is not in my view controller).  I hide it on viewDidLoad with [self.navigationController setNavigationBarHidden:YES]; \nNow you just have the ECSliderViewController acting like a NavigationBar.\nYou can then hide it with [self.slidingViewController.view setHidden:YES]; and unhide it with [self.slidingViewController.view setHidden:NO];\nYou don't use address the self.navigationController when using the ECSliderViewController.\n. Ahhh.. yes.. I see where we are working on different sets.  I don't use the UINavigationController.  I just use the ECSlidingViewController and then a ViewController for Menu and one for each of of my 3 screens.  I suspect because you're using a UINavigationControler, iOS7 in its insistence on thinking it knows what you are wanting and changing up coordinates on your rather than the way we did it in pre iOS7 is giving you the issues you are seeing.\nI don't think there is another setting that you can include in your plist like View controller-based status bar appearance but I had all kinds of problems with my status bar until I used that one. Keep us posted if you come up with anything.\n. I took a step back today created a simple test program where I embedded my login viewcontroller in a navigation controller and all appears to be working (using the ios7 fork)\nNow if I set the [self.navigationController.navigationBar setHidden:YES]; in viewDidLoad everything looks fine.\nHowever if I just move it to viewWillAppear or viewDidAppear and not do anything else, I do see your same issue. \nWith that being said,  I wonder if we need to do something in a Draw method or Layout method of the ViewController , as moving the call to the viewWillAppear or viewDidAppear generated the same symptoms as your call to a picker and then dismissing it.\n. In what method did you set that?\n. ",
    "wkberg": "You can avoid this by declaring your other ViewControllers in the MenuViewController.\nI've done it like this:\nin MenuViewController.h \nUIViewController *aController;\n@property (nonatomic, strong)UIViewController *aController;\nin MenuViewController.m \nin viewDidLoad:\naController = self.slidingViewController.topViewController; //sets the first loaded view as \"aController\"\nin didSelectRowAtIndexPath:\nif ([identifier isEqualToString:@\"THE IDENTIFIER OF YOUR aController\"]) {\nself.slidingViewController.topViewController = aController;\n[self.slidingViewController resetTopView\n// set any futher animations:\n}\nelse {\nthe normal piece of code you use to set the new topViewController\n}\nThis way the first loaded view controller is used again and not created again.\nHaven't tried it for the other viewcontrollers, because I don't need that, but if you need to, you have to declare them in another way. \nHope that helps ;-)\n. If I understand your question correctly:\nYou're having the menu with a few viewcontrollers: A, B and C.\nWhen you use the menu from A to B all is fine.\nThen in viewcontroller B you have a segue to viewcontroller C. (So not via the menu)\nThen when you are at C you use the menu to go to B, it keeps displaying C?\nSeems that you're creating C as a modalviewcontroller using a seque. Then you also should dismiss that modalviewcontroller.\nSo when your user hits the button to go to C. Make sure when the Menu is used that C is also dismissed from the view.\n[self dismissModalViewControllerAnimated:NO];\n. OK ;-)\nJust a thought:\nHow about calling a method from the Menu using the notification center?\nI have a button doing the following:\n[self.slidingViewController anchorTopViewTo:ECRight]; // leave this out if you don't want the screen animation\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"backToA\" object:nil];\nthen in my MenuViewController:\nin viewDidLoad:\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backToA:) name:@\"backToA\" object:nil];\nand then:\n- (void) backToA:(NSNotification*)n {\nNSLog(@\"backToAcalled\");\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n```\n              NSLog(@\"Going back to aController\");\nself.slidingViewController.topViewController = aController;\n[self.slidingViewController resetTopView];\n  ```\n}];\n}\nIn that way you can also go to another. Be aware that this still is only changing the slidingViewcontroller.topViewController to aController.\nI can't see how your code is build up but it still might be necessary to use:\nself dismissViewControllerAnimated:<#(BOOL)#> completion:<#^(void)completion#>\nor\nself dismissModalViewControllerAnimated:<#(BOOL)#>\n. Great to hear it did work out. Good luck with your project! ;-)\n. It indeed is far better to not instantiate again on each viewcontroller \"switch\".\nUsed the other approach by using notifications because only 1 view uses large amounts of memory.\nBut since memory management in iOS is something you can't ignore... and since my other views are increasing their memory usage as we'll (Adding new functions and stuff), I'll be implementing this too!\nI'll keep you posted!\n. Seems to be working mighty fine!\nThe nicest thing about this is that, I had a tableview with search option, now searched data keeps being displayed even when the users comes back from switching.\nMemory footprint remains unknown for now. Will need some more testing for that (using instruments etc). Although It should reduce it since there is no new instantiating!\n. I've posted a submit but think it never got handled... Btw tested my app in iOS7 Beta 2 and it still doing ok.\n. No same here. I was talking about my \"active-version\" and worked ok. iOS7 Beta 2 just puts a 20px black bar under the statusbar.\nBut I tested my \"current\"-version on the XCode 5 beta and iOS7. Indeed the problem with the status bar comes up. The whole interface is now off by 20px and thus screwed... They indeed should make it an option...!\nStill being a bit cautious with converting to 7 though because how will the change (e.g. the statusbar and new interface) revert back when using iOS 6 and 5? We'll see in later tests but to maintain support for all users, I'll keep the projects in iOS 6 for the moment.\nSame here, testing testing testing...\n. Btw, forgot to mention that with this new implementation I also changed my InitialSlidingViewController.m\nIn viewDidLoad change:\nself.topViewController = [storyboard instantiateViewControllerWithIdentifier:@\"FirstTop\"];\nTo:\nNSString identifier = @\"FirstTop\"; //This is the storyboard ident for the first top viewcontroller\n    UIViewController initViewController = [ECSlidingViewController queryViewController:identifier];\n    if (!initViewController) {\n        initViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];\n        [ECSlidingViewController addViewController:identifier viewController:initViewController];\n    }\n    self.topViewController = initViewController;\nIn this way also your first viewcontroller is directly added to the list. So the first vc is also never recreated by instantiating again...\nOh and with the statusbar I'll be checking out this when I've got time:\nAs by Apple Release Notes:\n\"Starting with Seed 2, apps default to using the new view controller-based status bar management system. To opt out of this, add a value of NO for the UIViewControllerBasedStatusBarAppearance key to your info.plist\"\n. By the way I've updated a fork from ECSlidingViewController containing the code we discussed:\nhttps://github.com/wkberg/ECSlidingViewController\n. Hi Frank,\nPlease check out the previous posts on #114 and see the code snippets we posted.\nOtherwise check out my fork of the ECSlidingviewcontroller project to solve the viewDidLoad problem.\nKind Regards\nwkberg\n\nOp 18 dec. 2013 om 20:00 heeft frank611 notifications@github.com het volgende geschreven:\nHey there!\nThanks for the quick response. I have already implemented my app exactly how the BasicMenu demo is setup; that is, using the custom segues to link my menu cells to my navigation controllers. However, using this exact setup, my views get flushed everytime (I also tried nslogging in the viewDidLoad of BasicMenu's viewcontrollers and it is displayed everytime). How would I prevent this behavior and keep my ViewController instances alive, while using the storyboard?\nThank you very much for helping me!\n\u2014\nReply to this email directly or view it on GitHub.\n. You're welcome, glad it worked out!\n\nHappy holidays to you as well.\nKind Regards,\nwkberg\n\nOp 27 dec. 2013 om 06:26 heeft frank611 notifications@github.com het volgende geschreven:\nAh! I had somehow overlooked the example you provided with your fork, wkberg. With that in hand, and thanks to Dan's snippet (which I wasn't using before), I was able to create a fully working sliding menu app that reuses ViewController instances. Thanks a lot to you both for your help, and happy holidays!\n\u2014\nReply to this email directly or view it on GitHub.\n. Dear vivekMA,\n\nWhat did you try and where are you stuck? I would suggest putting your problem at a site like stackoverflow.com\nNow your just asking someone to write code for you...\n\nOp 12 jun. 2014 om 15:20 heeft vivekMA notifications@github.com het volgende geschreven:\nhi,\ni am new to iOS, can someone please write code i am struck. http://stackoverflow.com/questions/24180964/implementing-ecslidingviewcontroller-with-storyboard\n\u2014\nReply to this email directly or view it on GitHub.\n. Check if you perhaps create more than one MKMapView by instantiating a viewcontroller more than once. One MKMapView itself uses enough memory!\n\nIf that's not your problem we might need to dig into the code a bit further as I'm using the ECSlide with MKMapView full with overlays and annotations and no problems. ;)\n. Hmm strange but maybe this might help then:\nSome time ago I added this pull-request but this project isn't that actively maintained it seems.\nTo increase performance when using shadows I've added to:\nself.view.layer.shadowOpacity = 0.75f;\nself.view.layer.shadowRadius = 10.0f;\nself.view.layer.shadowColor = [UIColor blackColor].CGColor;\nself.view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:self.view.bounds] CGPath]; //Set Predefined Shadow path for performance reasons\nThis way the shadow path is set to the view bounds and doesn't need off-screen calculation to produce the shadow. Only thing is that when you change your view size in any case, you might want to set this again... ;-)\n. Your welcome!\nHmm yeah cause leaving the shadow out is a sad loss in my opinion!\nBtw: while talking about performance... you might want to check out this issue: https://github.com/edgecase/ECSlidingViewController/issues/114\n. Your welcome! ;-) The other issue is easily solvable if you read through the comments there. ;-)\n. ",
    "u2fan": "I've done (pretty much) what wkberg suggests in that I have an array that holds pointers to all the view controllers that have been created and they are used instead of creating another new controller, when a page is being re-visited that has already been loaded previously.\nHowever, I'm still having an issue in that (and maybe this isn't the right place to ask... sorry!) I have push segues on some view controllers that, of course, take the user to other view controllers.\nMy problem is thus:\nAssume I'm on page A.  I then hit a button that pushes me to page B.  From page B, I swipe to reveal my menu of views.  If I ever tap on the button/tableCell that SHOULD take me to page A, I am forwarded to page B instead.\nI understand that this is because the same view is reloaded from my array, but for the life of me, I can't figure out how to force it back to page A.  UINavigationController popTo____ methods don't seem to do the trick because ECSlidingViewController doesn't appear to update the Nav Controller's view controller stack. \nAny suggestions?\nThanks!\n. You understood the problem perfectly! And thanks for the reply!\nProblem is, they are push segues that I'm using to go between screens. I was considering, however, changing them to modals so I could dismiss them, or disallow the user to use the Sliding View controller when the modal is open. \nMy problem is that the Menu page's navigation controller only ever has two view controllers: the initial, and the menu. No matter where I go in the app, that's all it ever has, so I can't pop to a navigation controller that needs to be displayed. \nAny ideas? I am sure that part of my problem is that I have multiple UINavigationControllers in my app, otherwise, I can't perform a Push segue from a view loaded by ECSliding. So  what I actually load as the newTopViewController, when the sliding controller is loading a new view, is actually a Nav Controller whose root view controller is the view controller I want to display. \nSo, maybe I just need to go to modal segues and remove the extra Nav Controllers. \nThoughts?\nSent from my iPhone\nOn May 15, 2013, at 2:51 AM, Wouter notifications@github.com wrote:\n\nIf I understand your question correctly:\nYou're having the menu with a few viewcontrollers: A, B and C.\nWhen you use the menu from A to B all is fine.\nThen in viewcontroller B you have a segue to viewcontroller C. (So not via the menu)\nThen when you are at C you use the menu to go to B, it keeps displaying C?\nSeems that you're creating C as a modalviewcontroller using a seque. Then you also should dismiss that modalviewcontroller.\nSo when your user hits the button to go to see. Make sure when the Menu is used that C is also dismissed from the view.\n[self dismissModalViewControllerAnimated:NO];\n\u2014\nReply to this email directly or view it on GitHub.\n. You read my mind! Yesterday afternoon, shortly after I sent that email to you, NSNotificationCenter popped into my mind, and I think that would be a very viable way to make this happen. In fact, I'm using Notifications and custom delegates all over my app, so I can't believe I didn't think of it before! I'll give it a shot and let you know how it turns out!\nThanks again!\n\nSent from my iPhone\nOn May 16, 2013, at 3:26 AM, Wouter notifications@github.com wrote:\n\nOK ;-)\nJust a thought:\nHow about calling a method from the Menu using the notification center?\nI have a button doing the following:\n[self.slidingViewController anchorTopViewTo:ECRight]; // leave this out if you don't want the screen animation\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"backToA\" object:nil];\nthen in my MenuViewController:\nin viewDidLoad:\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backToA:) name:@\"backToA\" object:nil];\nand then:\n(void) backToA:(NSNotification*)n { NSLog(@\"backToAcalled\"); [self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{ NSLog(@\"Going back to aController\"); self.slidingViewController.topViewController = aController; [self.slidingViewController resetTopView]; }]; }\nIn that way you can also go to another. Be aware that this still is only changing the slidingViewcontroller.topViewController to aController.\nI can't see how your code is build up but it still might be necessary to use:\nself dismissViewControllerAnimated:<#(BOOL)#> completion:<#^(void)completion#>\nor\nself dismissModalViewControllerAnimated:<#(BOOL)#>\n\u2014\nReply to this email directly or view it on GitHub.\n. To let everyone who cares know, NSNotificationCenter was totally the way to go.  I fire a notification when the user selects a view to load from the SlidingView's menu (I'm using buttons laid out like a menu instead of a tableViewController and table cells).  Then, the views that need to pop to their root view controller pick up the notification, pop, and voila!!  ...next time that page loads, I get the correct view controller (see the post by wkberg above in which he better explains my scenario)\n\nThanks, wkberg, for helping me think through my own stupid mental block!  ;-)\nAnd amazing work, EC team!  This control is phenomenal.\n. Fantastic! This is helpful on so many levels! I already modified my project such that I'm doing this already (as I previously mentioned), but next time I use this in an app, I already know its going to save my butt!\nThanks!\nSent from my iPhone\nOn Jun 2, 2013, at 4:34 PM, Dan notifications@github.com wrote:\n\nSo guys I've been thinking about this, where you could do this with Notifications are described above, I took it upon myself to implement the following Class Methods to keep track of ViewControllers that have been instantiated - (not yet complete but its a start). Let me know what you think.\nECSlidingViewController.h\n/* Master Array of View Controller */\n+(void) addViewController:(NSString )viewControllerIdentifier viewController:(UIViewController )avc;\n+(UIViewController ) queryViewController:(NSString )viewControllerIdentifier;\nECSlidingViewController.m\n// -----------------------------------------------------------------------\n//\n// -----------------------------------------------------------------------\n+(void) addViewController:(NSString )viewControllerIdentifier viewController:(UIViewController )avc {\nif (!arrayOfViewControllers){\n    arrayOfViewControllers = [[NSMutableDictionary alloc]initWithCapacity:0];\n}\nif ([arrayOfViewControllers count]) {\n    UIViewController existingViewController =(UIViewController )[arrayOfViewControllers objectForKey:viewControllerIdentifier];\n    if (existingViewController) {\n        NSLog(@\"%s ViewController exists %@\", func, viewControllerIdentifier);\n        return;\n    }\n}\n[arrayOfViewControllers setObject:avc forKey:viewControllerIdentifier];\n}\n// -----------------------------------------------------------------------\n//\n// -----------------------------------------------------------------------\n+(UIViewController ) queryViewController:(NSString )viewControllerIdentifier {\nif (!arrayOfViewControllers)\n    return nil;\nif ([arrayOfViewControllers count]) {\n    UIViewController existingViewController =(UIViewController )[arrayOfViewControllers objectForKey:viewControllerIdentifier];\n    if (existingViewController) {\nreturn existingViewController;\n}\n}\nreturn nil;\n}\nAnd then in your MenuViewController.m\n// -----------------------------------------------------------------------\n//\n// -----------------------------------------------------------------------\n(void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath\n{\nNSString *identifier = [[self.menuArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row];\nUIViewController *newTopViewController = [ECSlidingViewController queryViewController:identifier];\nif (!newTopViewController) {\nnewTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];\n[ECSlidingViewController addViewController:identifier viewController:newTopViewController];\n}\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\nCGRect frame = self.slidingViewController.topViewController.view.frame;\nself.slidingViewController.topViewController = newTopViewController;\nself.slidingViewController.topViewController.view.frame = frame;\n[self.slidingViewController resetTopView];\n}\n];\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. Awesome! Once people begin (or those that are already) using this with views that require large chunks of memory, they'll kiss the ground you walk on!\nFor example, my app had a view controller which downloaded social media feeds containing text, video, and/or images. If I'd reload that view several times, I'd get memory warnings and eventual crashes. Maybe a conversation should be had to discuss situations like that and how to avoid retain cycles in those situations (that's what was happening in my scenario), but this update should keep others from experiencing the same problem.\nRight-freaking-on!\n\nSent from my iPhone\nOn Jun 2, 2013, at 6:40 PM, Dan notifications@github.com wrote:\n\nThanks.. I'm going to update the add to replace the view controller if the identifier is sent in that already exists, and then obviously it needs a delete to move them from the dictionary. I'll submit that tomorrow\n\u2014\nReply to this email directly or view it on GitHub.\n. Right on! Let us know. It made huge improvements in my app. \n\nSent from my iPhone\nOn Jun 9, 2013, at 8:12 AM, Wouter notifications@github.com wrote:\n\nIt indeed is far better to not instantiate again on each viewcontroller \"switch\".\nUsed the other approach by using notifications because only 1 view uses large amounts of memory.\nBut since memory management in iOS is something you can't ignore... I'll implement this approach too.\nI'll keep you posted! ;-)\n\u2014\nReply to this email directly or view it on GitHub.\n. Yay!!\n\nSent from my iPhone\nOn Jun 9, 2013, at 10:44 AM, Wouter notifications@github.com wrote:\n\nSeems to be working mighty fine!\nThe nicest thing about this is that I had a tableview with search option. Now searched data keeps being displayed even when the users comes back from switching.\nMemory footprint remains unknown for now. Will need some more testing for that (using instruments etc). Although It should reduce it since there is no new instantiating!\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "frankmarineau": "Hi there! I'm very new to iOS coding, and I was wondering if there was an easy way to implement this if I'm creating my UIViewControllers and UINavigationControllers in the storyboard? Doing so, I don't see how I can get reference them from/create them in my MenuViewController. Should I just drop the idea of using the storyboard altogether? Seems like I'm constantly needing references to my controllers and since I haven't created them in the code, I feel very limited.\n. Hey there!\nThanks for the quick response. I have already implemented my app exactly how the BasicMenu demo is setup; that is, using the custom segues to link my menu cells to my navigation controllers. However, using this exact setup, my views get flushed everytime (I also tried nslogging in the viewDidLoad of BasicMenu's viewcontrollers and it is displayed everytime). How would I prevent this behavior and keep my ViewController instances alive, while using the storyboard? I am starting my app from scratch, so I'm open to any big structural change that would be required.\nThank you very much for helping me!\n. Ah! I had somehow overlooked the example you provided with your fork, wkberg. With that in hand, and thanks to Dan's snippet (which I wasn't using before), I was able to create a fully working sliding menu app that reuses ViewController instances. Thanks a lot to you both for your help, and happy holidays!\n. ",
    "mirceamironenco": "Hello,\nReading this issue i implemented what you guys suggested and created a strong pointer to my controller in the menu's viewDidLoad function , the problem is, the menu is only instantiated when i initially click the button. So the starting controller is instantiated before it . This makes my application call viewDidLoad TWICE. Once initially before the first controller is destroyed , and once when it is shown normally but retained in my menu , and thus never shown again. \nSuggestions?\nSolved it : I was using mycontroller = [self.storyboard instantiateviewcontrollerwithidentifier] instead of mycontroller = self.slidingviewcontroller.topviewcontroller;\n. ",
    "vivekMA": "hi,\ni am new to iOS, can someone. i have asked question SO. http://stackoverflow.com/questions/24180964/implementing-ecslidingviewcontroller-with-storyboard\n. Thanks for quick response.I already asked question on SO. you can see my previous comment. \nI tried the basic demo. In which i added one new third view controlled. But dont understand how to hook the action of menu button to unwind functio.\nIn transction fun demo. I tried but dnt understood how can i cache the view controller that it don't call viewdid load again and again. \n. ",
    "EmreAras": "All sorted.. \n. ",
    "felipeflorencio": "i saw my mistake i forget put self.slidingViewController.underRightViewController = nil;\n. Yep just create your self tab bar u will need create programatically, so u can put only que buttons or other thinks\n. ",
    "jmschonfeld": "I have fixed this issue.\nSolution: For the EC slider to work, you need 3 view controllers (one \"manager\", one top, and one under). You get this error when you only use 2 view controllers and the manager and top view controller are the same. The manager should instantiate the top, which should instantiate the one under it. (not the manager initiate the top (itself) and then initiate the one under).\n. If it is not a bug could somebody explain why I am having this issue?\n. First, will a table view controller not work with the Pan Gesture? Whenever I try to pan it just acts like I clicked on a row in the table and acts upon the row like I clicked it.\n. ",
    "tushar666": "how you had solved this one\n. Guys try below line\nself.view?.addGestureRecognizer(self.slidingViewController().panGesture);\n. ",
    "mmarszal": "Sorry, this was wrong. The problem has to do with the UpdateTopViewHOrizontalCenterWithRecognizer method.\nIf you only have a underLeftView, the panning gesture doesn't work. removed the condition \"self.underRightViewController == nil\" and \"self.underLeftViewController == nil\" fixed the problem with panning, however this leads to another problem when using shouldAllowPanningPastAnchor. When shouldAllowPanningPastAnchor is set to true, panning is again broken. Im not exactly sure what to fix here at this point.\n. ",
    "danlite": "It sounds similar to a problem I had. Here are the changes I made to fix it: https://github.com/DanLite/ECSlidingViewController/commit/b2aff038776375d837319a902441b950be45efb0\n. Glad to contribute!\n. ",
    "dusek": "I am sorry but I don't get your reason. Yes, this bug can be fixed outside of ECSlidingViewController. But I don't get why that should be the reason this bug fix should not be an integral part of ECSlidingViewController. In the end, we could say ECSlidingViewController itself can be implemented outside of ECSlidingViewController :-) (and then delete this project).\nCould you please elaborate why this bug should be fixed by every user of ECSlidingViewController, instead of being fixed in one place in ECSlidingViewController itself? Thanks.\n(Yes, I consider the current ECSlidingViewController behavior in this accessibility aspect to be a bug in its accessibility.)\n. Thanks for reopening and please let me know when you have any questions.\n. ",
    "dennisreimann": "Just to chime in: I'm using this in my fork and it works without problems. It's a very good enhancement to the library.\n. whoohoo! Thanks @jeffarena :+1: \n. ",
    "Kyroapps": "Fixed it! THANK YOU!\n. Any idea how how to get the swipe to delete back? it disables it.\n. Where did you find the swipeGR. ?\n. ",
    "karimhossenbux": "Hi,\nI've got the same error, but I can't fix it even by trying to make a customNavigationController.\nHere's my storyboard : https://www.dropbox.com/s/nfzh2yqg3xvoqco/storyboard.png\nMy tableView controller stoped scrolling with this code in my MasterViewController.m : \nif (![self.slidingViewController.underRightViewController isKindOfClass:[MapViewController class]]) {\n     self.slidingViewController.underRightViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"Map\"];\n}\n[self.view addGestureRecognizer:self.slidingViewController.panGesture];\nThen I tried this solution to create a customNavigationController : http://stackoverflow.com/questions/14433971/using-ecslidingviewcontroller-with-tableview\nBut can't get it to work. I followed the 2 first part of this too : http://www.youtube.com/watch?v=tJJMyzdB9uI\nI build the demo from scratch, and it works. So there is a conflict somewhere I can't find.\nI need to say that it's my first project.\nThanks for the help!\n. ",
    "matterickson7": "Thanks to Claus79!   I just ran into this issue and that one line solved it!  I was pulling out my hair ... \n. ",
    "rawanOmari": "@airdrummingfool  hi :) \nthanks for your answer. i faced the same problem that you've talked about it. \ni have menu side, and i used panGesture to slide it  in - out \nand i have tableview, so the swipe to delete is disable by the pan. \ni saw your answer, but i didn't know how to make the direction of swipGesture opposite PanGesture\nso i'll be so thankful for any help :)\n. ",
    "alexnauda": "http://stackoverflow.com/questions/16658539/ecslidingviewcontroller-problems-with-topview-animation/17203292#17203292\n. ",
    "dunarri": "It took me a while to figure this out, but in your viewDidLoad or something, set your view controller to be the delegate of the sliding pan gesture:\n    self.slidingViewController.panGesture.delegate = self;\nNow add this method to your view controller:\n- (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer\n  {\n  return YES;\n  }\n. ",
    "adrum": "Here is a tutorial that will teach you how to completely implement the ECSlidingViewController into your project. Within in it is a section on how to add menu items: http://kingscocoa.com/tutorials/slide-out-navigation/\nFor adding items to the menu, it's as simple as creating an array of objects and then setting the cells label in the cellForRowAtIndexPath: method in the data source. You would do this in your menu view controller. The tutorial above uses and NSDictionary instead of a NSArry. You may want to start with looking into table views and then move on to implementing the ECSlidingViewController once you understand table views.\n. ",
    "krzd": "What a very detailed bug report.\nAnyway, I cannot confirm that it does not work. The only thing I could notice is that the content appears behind the status bar instead of below, unless the navigation bar is shown for the sliding view itself.\n. How we solved it:\nChange Storyboard to 'open in Xcode 5'.\nPress control and drag from the navigation controller to the view (can be done in the sidebar).\nSelect 'Top Space to Layout Guide' or something along those lines.\nNow change the constraint it creates from -24 to -64.\nIf you also want to support iOS 6, you need to programatically detect iOS 6 and change the constraint to -64. For some weird reason the topLayoutGuide is 0 instead of 20, despite a status bar being displayed. I believe that is the reason why the correct constraint (-44) does produce wrong results and why edgesForExtendedContent does not work either.\nIf you ask why it should be -44, it is because it creates a constraint from the bottom edge to the top layout guide and the navigation controller is 44 points high. It will look good with -44 in Interface builder, but due to said bug, you will need -64.\nThis approach works at least if you hide the navigation bar programatically and manually add a UINavigationBar in Interface Builder.\nIn fact we are just dropping iOS 6 support, so I cannot tell wether detecting iOS 6 and changing the constraint actually works, but in theory it should.\nI hope this helps those of you, who still did not find a fix or workaround.\nEdit: Certain content (depending on constraints) might need to be moved down by 20 points. If you also want to support iOS 6 and you encounter that, I suggest simply changing the constraints to be based on the navigation bar or the bottom of the view or something like that.\n. It does run, see #140 \n. ",
    "penaeric": "A detailed bug report indeed!\nI was able to get it working on iOS 7 without having to change anything. The issue with the status bar has nothing to do with ECSlidngViewController, but with the iOS that iOS 7 brings. I won't comment about them for obvious reasons.\n. @Stefan51278 Again, I believe this is due to changes brought in iOS 7 (tint & status bar), I'd suggest going to devforums.apple.com for some help on this.\n. ",
    "oscarbc96": "But I can't make it work on ios 7 directly.\n. It would be great\n. ",
    "digitera": "I've heard a rumor that Apple is going to include some sort of UI feature to make this kind of sliding menu easy to implement.\n. ",
    "Stefan51278": "I tried to convert my app to iOS7 with the new XCode and my worst problem is, that i have some NavigationControllers with a TableViewController as their root controller and in landscape they are slipping up and down as soon as the menu is opened or closed. It even shows some background that never should be seen. (i just changed drawing in the menu and gave it a little header, nothing else is changed.)\n\n\n. ",
    "lukaszmargielewski": "I struggle the same issue (iOS iPhone 5). It is visible also in demo project of this repo.\n\n\nHave you found a solution?\n. It seems you were right. Behaves much better since beta 3\n. ",
    "sirvine": "These look like problems with autolayout under the new iOS rules for extending views under navigation, status and top/bottom bars.  \nThere is a new anchor (topLayoutGuide, or something like that) that will allow you to pin your view elements to the baseline of the top or navigation bar.  I'm not sure if there is something similar for status bar.  You can also set new properties on view controllers to prevent them from extending below the top/navigation (but then you lose the OS7 semi-opaque native look-and-feel).\nWithout going into NDA territory, it's safe to say that: (1) this is an area that seems to present the lots of trouble for OS6 -> OS7 migrations at the moment, and (2) Apple seems to be working hard on ironing out the kinks in this area.\n. ",
    "lorenzoPrimi": "It still has the same problems on iOS7 GM.\nAny update?\n. ",
    "appcodec": "Just hide status bar for now \n. ",
    "bobi33": "Hiding the status bar does not work.\n. If you click on one of the menu items in iOS 7 the program continues to crash, but only works 2 times out of every 100 builds. \nI can't figure out how to fix this issue.\nPlease Help.\n. I'm having the exact same problem\n. Having same problem.\n. Hi Mike,\nThe left Slide Menu does not send users to a specific UIView.  For example, when clicking on any option in the Slide Menu the App crashes and gives \"EXC_BAD_ACCESS (code=1, address=0x8000000c)\" for the line of code: \"[_underRightViewController removeFromParentViewController];\" in \"ECSlidingViewController.m\".\nIt is strange however, since I thought the issue was an AutoLayout issue, whereby \"Use AutoLayout\" would need to be turned off.  After turning the Auto-Layout off and recoding the Slide Menu I thought the issue had been resolved, since running the code for the first time on an iPhone 4 running iOS 7 appeared to work.  However, after another test the App crashed.  The App seems to crash more often than it functions (NOTE: it has only functioned 2 times out of many builds). \nTurning AutoLayout off has not helped and has only made things worse, since the app does not fill the screen when rotated in landscape.\n\nOn Sep 24, 2013, at 2:54, \"Mike Enriquez\" notifications@github.com wrote:\nCan you give more details on the crash and how to reproduce it?\n\u2014\nReply to this email directly or view it on GitHub.\n. Hi,\n\nI can't seem to reproduce the error off that branch.  I know there is an error with my app for memory allocations.  The app has over 12 rows in three different sections in the left menu - I'm not sure if this is why I have had problems in iOS 7.  It was working fine in iOS 6.\n. Hi, I am still confused as to how to do this. Am I replacing the whole of ECSlidingViewController with the new one (ECSlidingViewController2)? And if so, doesn't this make problems for the UnderRightViewController, as well problems for the previous revealMenu buttons, which contained:\n[self.slidingViewController anchorTopViewTo:ECRight]; --> this does not exist anymore with the new ECSlidingViewController\nThanks in advance, I'm new to objective-c, so not very confident or knowledgeable as to how to do this, but would like to.\n. So if I am only using the foldAnimation transition along with the underLeftViewController AND the underRightViewController would this be the correct way to do this in the METransitionsViewController:\nimport \"METransitionsViewController.h\"\nimport \"UIViewController+ECSlidingViewController.h\"\nimport \"MEFoldAnimationController.h\"\n@interface METransitionsViewController ()\n@property (nonatomic, strong) MEFoldAnimationController *foldAnimationController;\n@end\n@implementation METransitionsViewController\n- (void)viewWillAppear:(BOOL)animated\n  {\n  [super viewWillAppear:animated];\nif (![self.slidingViewController.underLeftViewController isKindOfClass:[MenuViewController class]]) {\n      self.foldAnimationController = [[MEFoldAnimationController alloc] init];\n      self.slidingViewController.delegate = self.foldAnimationController;\n      self.slidingViewController.underLeftViewController  = [self.storyboard instantiateViewControllerWithIdentifier:@\"Menu\"];\n  }\nif (![self.slidingViewController.underRightViewController isKindOfClass:[UnderRightViewController class]]) {\n      self.foldAnimationController = [[MEFoldAnimationController alloc] init];\n      self.slidingViewController.delegate = self.foldAnimationController;\n      self.slidingViewController.underRightViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"UnderRight\"];\n  }\n[self.view addGestureRecognizer:self.slidingViewController.panGesture];\n  }\n- (IBAction)revealMenu:(id)sender\n  {\n  [self.slidingViewController anchorTopViewToRightAnimated:YES];\n  }\n- (IBAction)revealUnderRight:(id)sender\n  {\n  [self.slidingViewController anchorTopViewToLeftAnimated:YES];}\n@end\n. Yes, that does seem to work.  However, I keep getting an error when trying to slide to the menu: \"CUICatalog: Invalid asset name supplied: , or invalid scale factor: 2.000000\", *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'UITableView dataSource must return a cell from tableView:cellForRowAtIndexPath:'\nWill there be any upcoming examples where the MenuViewController has more than 1 cell? (i.e. Instead of segueing to the METransitionsViewController, it pushes to a new view controller)\n. Thanks for your response. I thought it was something I was doing.\n. Will there be a notification on the update on adding the other menu item to TransitionFun?  Also, is there no page on here anymore to talk about ECSlidingViewController (the one before 2)?  I am finding an issue with that one.  Adding any search bar display and search display controller to the StoryBoard does not function correctly.  Because of the code in ECSlidingViewController:\nif (!legacyScreenHeightEnabled) {\n    // In iOS <= 6.1 the container view is already offset below the status bar.\n    // so no need to offset it if we use shouldAdjustChildViewHeightForStatusBar in iOS 7+.\n    bounds.origin.y += statusBarHeight;\n}\nand in InitialViewController:\nif (floor(NSFoundationVersionNumber) > NSFoundationVersionNumber_iOS_6_1) {\n       self.shouldAdjustChildViewHeightForStatusBar = YES;\n}\nthis causes issues for any search bars added to the views in StoryBoard, whereby the search bar does not move to top of the view right under the status bar.  Instead, the search bar leaves a gap between the top of the view and the status bar.  \nSince InitialViewController is a full screen layout the MainViewController (or HomeScreen, whatever it is called) and the corresponding MEMenuViewController and MEUnderRightViewController are all covered by the status bar.\nThere is a way to fix it without using the logic above, but instead using auto-layout, so that you use the documentation from Apple to fix the issue of the status bar covering your view.\nAlso, the MEUnderRightViewController and MEMenuViewController must be UIViewControllers and not UITableViewControllers to function correctly, since topLayoutGuide is not available for UITableViewControllers.\n. I figured out that now that I'm using a UINavigationController to host my HomeViewController, any gesture recognizers added to that view controller do not get included with the navigation bar.  That navigation bar now belongs to UINavigationController and not the HomeNewsViewController.  So if I want the nav bar to be included as part of the swipe/pan, I should add that same gesture recognized to the navigation bar as well.\nSo, I think I figured it out. Tell me if there's a better way to do it, but I did this:\nif (![self.slidingViewController.underLeftViewController isKindOfClass:[MenuViewController class]]) {\n        self.slidingViewController.underLeftViewController  = [self.storyboard instantiateViewControllerWithIdentifier:@\"Menu\"];\n    }\n```\nif (![self.slidingViewController.underRightViewController isKindOfClass:[UnderRightViewController class]]) {\n    self.slidingViewController.underRightViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"UnderRight\"];\n}\n[self.navigationController.view addGestureRecognizer:self.slidingViewController.panGesture];\n```\n-->basically, I changed the last line here: \nFROM:\n[self.view addGestureRecognizer:self.slidingViewController.panGesture] \nTO THIS:\n[self.navigationController.view addGestureRecognizer:self.slidingViewController.panGesture];\nVoila.\n. ",
    "salihy": "I tried almost everything with no luck. I don't want to change slider because I built my app top on ECSlidingViewController, if anyone has found a solution, we would be more than grateful t hear it.\n. This is how I solved it:\nI was working navigation controller for the left menu and left menu navigationbar background was going behind to my tableview.\nI modified viewWillAppear function and did this after checking for iOS7\nself.navigationController.navigationBar.backgroundColor = [UIColor darkGrayColor];\nthat line updates navigationbar color everytime I open left menu. I don't normally do that kind of hacks but this time, i had to. If anyone needs this kind of hack, i hope that hack help them.\n. Same here\n. ",
    "iMemon": "How can I do this in ECSlidingViewController 2.0. Please help me. I am stuck here\n. ",
    "bablu-joshi": "\n(void)anchorTopViewToRightAnimated:(BOOL)animated {\n\n[UIView animateWithDuration:1.0 delay:0 usingSpringWithDamping:0.5 initialSpringVelocity:1.0 options:UIViewAnimationOptionCurveLinear animations:^{\n      [self anchorTopViewToRightAnimated:NO onComplete:nil];\n} completion:^(BOOL finished) {\n}];\n}\n. Me too facing the same issue :(\n. ",
    "gergy008": "I fixed by own issue, the reason being was I was trying to change the view with the top view. Half way through the process I have to remove the top view and replace it with the new one, and because I'm replacing the top view, the one trying to do the work, it failed because self.slidingviewcontroller doesn't exist anymore.\nBasically I call on the Menu controller to do the segue for me, with the following function. I'm not sure if one exists already it wasn't made clear enough in the documentation.\n-(void)replaceTopViewWithView:(id)view {\n    @try {\n        UIViewController *newTopViewController = view;\n        [self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n            CGRect frame = self.slidingViewController.topViewController.view.frame;\n            self.slidingViewController.topViewController = newTopViewController;\n            self.slidingViewController.topViewController.view.frame = frame;\n            [self.slidingViewController resetTopView];\n        }];\n    }\n    @catch (NSException *exception) {\n        NSLog(@\"Failed to load view. Does it exist?\");\n    }\n}\nAnd then I'm using the following code to get the menu and call the function on it:\n@try {\n    UIViewController *newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"ProfileView\"];\n    JJMenuViewController *menu = (JJMenuViewController *)self.slidingViewController.underLeftViewController;\n    [menu replaceTopViewWithView:newTopViewController];\n}\n@catch (NSException *exception) {\n    NSLog(@\"Failed to locate requested view.\");\n}\n. ",
    "SjoerdPerfors": "I double checked and I don't load the VC twice (or the map).\nThen I downloaded the sample application added a MapView to the first ViewController and ran it. No performance issues when scrolling the map. But then I switched the launch image so it uses a 5\" version and ran it again and the map was full screen on my iPhone5. And there it was: performance issues when scrolling on the map.\nEDIT: \nI had it wrong. After some tests I saw that the performance on my app is much more worser. The performance I saw above seems to be normal.\nI will be working on a sample.\n. Hmm found something. Ater removing the following three lines the performance is okay again:\n// shadowPath, shadowOffset, and rotation is handled by ECSlidingViewController.\n// You just need to set the opacity, radius, and color.\nself.view.layer.shadowOpacity = 0.75f;\nself.view.layer.shadowRadius = 10.0f;\nself.view.layer.shadowColor = [UIColor blackColor].CGColor;\n. Thanks!\nWell another thing:\nAll my VC are in a UINavigationController so setting the shadow doesn't even work on my TopViewController. That's also the reason why sliding on the navigationbar didnt work either. So I'm now working to set these values on a UINavigationController.\n. I moved stuff to the UINavigationController including the shadow and all performs great now including the old shadow code. \nSo the problem was that I setup the menu in the TopViewController but initiate a UINavigationController as TopViewController.\nIn code. My menuVC:\n// methode show VCForMenu with parameter theViewController ( (theViewController is a UINavigationController with VC1 in it):\n[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n    CGRect frame = self.slidingViewController.topViewController.view.frame;\n    self.slidingViewController.topViewController = theViewController;\n    self.slidingViewController.topViewController.view.frame = frame;\n    [self.slidingViewController resetTopView];\n}];\nThen in VC1 i did:\n```\n// shadowPath, shadowOffset, and rotation is handled by ECSlidingViewController.\n// You just need to set the opacity, radius, and color.\nself.view.layer.shadowOpacity = 0.75f;\nself.view.layer.shadowRadius = 10.0f;\nself.view.layer.shadowColor = [UIColor blackColor].CGColor;\nif (![self.slidingViewController.underLeftViewController isKindOfClass:[MenuViewController class]]) {\n    self.slidingViewController.underLeftViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"Menu\"];\n}\n[self.view addGestureRecognizer:self.slidingViewController.panGesture];\n```\nAnd the fix was to move that stuff from VC1 to my UINavigationController :-)\nI actually didn't noticed that the shadow was gone till today. This was because it still needs to be designed so I didn't bother the layout yet.\nMany thanks for your help !\n. Also thanks for pointing me to that issue which is now the same issue I have after this fix :-)\n. ",
    "nynohu": "@enriquez \nI want to swipe on underLeftViewController. But ECSlidingViewController maybe not support it? How do  I swipe on underLeftViewController to topViewController?\n. ",
    "damienklinnert": "You need to set the shadow on the navigation controller, so use:\nself.parentViewController.view.layer.shadowOpacity = 0.75f;\nself.parentViewController.view.layer.shadowRadius = 10.0f;\nself.parentViewController.view.layer.shadowColor = [UIColor blackColor].CGColor;\n. ",
    "hengchu": "Thank you! That really helps!\n. ",
    "emadhegab": "my guess is that because self.slidingViewController is becoming nil .. but i don't know why\n. ",
    "nicoschtein": "@edgecase @dennisreimann -> I think we should use another fork and ask for all pull requests to be redirected to this new fork, and use it as a Main fork for collaboration. What do you think?\n. Great to hear this!\nYou should start by checking if the PRs are fine to merge, there are some nice fixes and features added!\nN I C O\nOn Mon, Sep 9, 2013 at 5:47 PM, kEND notifications@github.com wrote:\n\nDone.\nOn Mon, Sep 9, 2013 at 4:24 PM, Mike Enriquez notifications@github.comwrote:\n\n@jeffarena https://github.com/jeffarena has volunteered to take over\nthe repo. Yay! He's made some great contributions to\nECSlidingViewController in the past, so it'll be in good hands.\nCan someone at @edgecase/@neo https://github.com/neo (@mdoelhttps://github.com/mdoel,\n@kEND https://github.com/kEND) give @jeffarenahttps://github.com/jeffarenawrite access to this repo?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/edgecase/ECSlidingViewController/issues/163#issuecomment-24111522\n.\n\nKen Barker\n614.403.7044\nReply to this email directly or view it on GitHub:\nhttps://github.com/edgecase/ECSlidingViewController/issues/163#issuecomment-24112504\n. \n\n",
    "kEND": "Done.\nOn Mon, Sep 9, 2013 at 4:24 PM, Mike Enriquez notifications@github.comwrote:\n\n@jeffarena https://github.com/jeffarena has volunteered to take over\nthe repo. Yay! He's made some great contributions to\nECSlidingViewController in the past, so it'll be in good hands.\nCan someone at @edgecase/@neo https://github.com/neo (@mdoelhttps://github.com/mdoel,\n@kEND https://github.com/kEND) give @jeffarenahttps://github.com/jeffarenawrite access to this repo?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/edgecase/ECSlidingViewController/issues/163#issuecomment-24111522\n.\n\n\nKen Barker\n614.403.7044\n. ",
    "fuxlud": "The problem was with the iCarousel. It wasn't clipped to bounds. \n. ",
    "Coeur": "I got the same issue with iOS7 only. So, far, no luck in how to fix it.\n. You don't have issues with it because your app don't use willAnimateRotationToInterfaceOrientation:duration: or didRotateFromInterfaceOrientation:\nMy app does use those methods, so a call to super is needed.\n. ",
    "kefon": "Apparently the problem is only on iPhone5 long screen. So I tried the example project provided with the classes. It appear that the problem is here too. (to find this, I just add a default picture to authorize the iPhone5 screen size). \nThe gap is still there, but only when displaying a navigation controller in the topViewController. As explained, the navigation controller frame in topViewController is ok. But the root view controller of the navigation controller got a wrong frame height... \nStill can't understand why... :(\n. After more investigations, it seems that the problem is that the height of the uitabbar is removed twice\n- ECSlidingViewController remove the uitabbar height to calculate its own height\n- ECSlidingViewController load navigation controller as topViewController with its frame\n- Navigation controller load its root view controller\n- Root view controller remove the uitabbar height again to calculate its height\nSo the Root view controller get \"window size - uitabbar height - uitabbar height\".\nThis is why there is a gap of the size of the uitabbar...\nNow I need to find out why such behavior, and how to get rid of it...\n. @parhammajd Yes I know, this is great for the underLeftViewController (I already solved this), but the problem explained here is not about that. We are talking about the wrong size of the root view controller of the navigation controller defined as the topViewController (see the red arrows on my screenshots)\n. Branch #177 is great (for status bar fix) ! But still got this problem when combining UINavigationController over a UITabBar... :( @Coeur Did you manage to find a solution ? \n. @enriquez Hi ! To reproduce the problem, it's very simple, just use the \"ECSlidingViewController\" or the \"ECSlidingViewController-ios7\" project, then : \n- select the iphone storyboard\n- select the \"Initial Sliding View Controller\"\n- top menu > Editor > Embed In > Tab Bar Controller\n  --> run the project\nYou will see that the First, Second and Third Top View Controller are ok, but that the Navigation Top View Controller has a huge gap at the bottom... If you look closer, you will find that\n--> Navigation Top View Controller view frame is totally ok\n--> Sample Table View Controller as a wrong frame height... (like if the height of the tabbar is removed twice to calculate its height...)\nThank you if you can have a look, I'm a bit desperate as you can see ;)\n. Thank you ! That kind of solve the problem ;)\nI managed to adapt your code to my specific case.\nThank you for your help @enriquez !\n. Nice ! Well done !\n. ",
    "parhammajd": "Just add this to your menuViewController (if using table view)\n- (void)viewWillAppear:(BOOL)animated {\n  [super viewWillAppear:YES];\nself.tableView.frame = CGRectMake(0, 20, self.tableView.frame.size.width, self.tableView.frame.size.height-20);\n  }\n. ",
    "ValCapri": "On iOS 7, all windows are full screen and the status bar because she is transparent his not considered.\nThe best way to correct that is to use the topLayoutGuide with Auto Layout or you can simply create a table view inside a view and place it 20px below from the top origin.\n. I'll try, thanks in advance.\nI don't if you too have the problem, when I use the new gesture to return back in iOS 7 UINavigationController, the panGesture not work anymore until I reopen the same controller.\nDo you have a fixed for that?\n. @enriquez @nullproduction Not working good for me at latest commit of ios7 branch.\nWhen I slide a table view from down to up, the table view slide doesn't work but the pan gesture work.\nWhen I tap the table view cell and make the back gesture, the sliding pan gesture disappear and I can slide the table view.\n. @enriquez Thanks, yes, it work good in the example. I just moved my lines of code from viewdidload to viewWillAppear and it seems to work better.\nI don't know why.\n. ",
    "clr4e": "Is the menu view controller a TableViewController? If so, all of the view controllers allow for the Top Layout Guide to be able to move the view down the extra 20 pixels (like ValCapri stated earlier), however that is not available in the TableViewController for some reason at the moment. I had to go and change my TableViewController into a ViewController and place a UITableView within it to be able to have the page display properly. I think this is a bug with iOS 7 / Xcode 5, or there was just something that I overlooked...\n. ",
    "skeeet": "It is not really a good news, but you cannot change the way iOS 7 dealing with status bar.\nYou can hide it, or show it, or change it from default to light appearance. that's it. \nFrom app point of view, ECSlidingViewController is the only app controller, and that's why you have just few options. \nOverlapping menu - use contentInset with 20px top on your menu table (do iOS version check before).\nOtherwise just change app design like Facebook just did :)\n. ",
    "nullproduction": "javascript\nI'll try, thanks in advance.\nI don't if you too have the problem, when I use the new gesture to return back in iOS 7 UINavigationController, the panGesture not work anymore until I reopen the same controller.\nDo you have a fixed for that?\nI have the same problem\n. @enriquez COOL :) FNX\n. Fix in last commit\n. It is a pity that the 1.x branch is no longer supported\n. ",
    "farfromrefug": "There is a problem with the that line\nYou have to set the topController frame to [self fullViewBounds] from the start. At least for me it was a bug where the menu were ok with shouldAdjustChildViewHeightForStatusBar but the top controller was still under the status bar.\nThanks for your work!\nEDIT: fixed it here. Tell me if you want a PR\n. oh i see what you mean! you are right something must be wrong on my side.\nOne question though. why not use [self fullViewBounds] every time? Ami issing something\nThanks\n. @enriquez i see. My bad! You can forget my comment then :s Thanks a lot for the explanation!\n. After a lot of playing i think there is a problem with fullViewBounds on ios < 7.\nin fullViewBounds you use [[UIScreen mainScreen] bounds] which means in the bounds you get the height of the statusbar. Consequently you get a view too \"big\".\nI saw because my view inside where 20px too high after rotating the device.\nI will investigate that more to be sure this is not something else. But i am not sure you should use [[UIScreen mainScreen] bounds] in ios < 6\n. @enriquez ok i didnt know that :s thanks for the update\n. ",
    "RockLobster": "Have you tried profiling it to see where it takes that long?\n. ",
    "netliner": "Thanks for pointing out. I've figured out the problem. I'm loading full-resolution image on my collectionView.\nclosing issue.\n. ",
    "denistsai": "Dan, thanks for the reply. I don't think it's an issue with the 20 pixels of the status bar. I've already accounted for that. This is occurring when I hide the navigation bar coupled with using a UIPageViewController. It's shifting up 44 pixels when that happens - size of the navigation bar. \nThis only happens when I hide the nav bar, if I only hide the toolbar it works fine. If I do this on a normal UIViewController, it works fine. \n. You're right Dan, but here's what's interesting, if I setHidden:YES after the viewDidAppear (e.g. through user tap gesture), the view shifts UP 44 pixels. If I setHidden:YES in viewDidAppear, the view does look fine, until I change setHidden:NO (through user tap), which now pushes the view DOWN 44 pixels.\n. On the main page I use ECSlidingViewController to navigate between the main screen and another screen. From the main screen I use UINavigationController to navigate to a detail screen, where I am displaying photos using a UIPageViewController, overlaid with other information. I want to let the user clear the overlay and the navigation bar / too bar / status bar when they tap the view to get an unobstructed view of the image\n. Pardon, but when you say \"hide the ECSliderViewController\" what did you mean?\nI want to show the navigation bar at first. Then, when a user taps on the view, I want to hide the navigation bar. \n. I may be missing something but self.slidingViewController doesn't understand setHidden. I'm trying to hide the navigation bar by using:\n[self.navigationController setNavigationBarHidden:YES];\nNot trying to hide the UINavigationController nor the ECSlidingViewController.\n. Dan, I'm not sure if I'm on the same page as you. \n1. I don't think ECSlidingViewController has a navigation bar on its own, are you adding that to your own VC?\n2. I'm using a UINavigationController as my topViewController.\n3. I get this issue when I push a UIPageViewController to my navigation (showing another VC), when I try to hide the navigation bar (of the UINavigationController) in response to a tap gesture.\n4. Setting self.slidingViewController.view.hidden = YES will hide my whole view, that's not what I'm trying to do. \nI just want to hide the Navigation Bar of the UINavigationController, however when I do that (after viewDidAppear), it pushes the view up 44 pixels.\n. Hi Mike! I tried resetting it but it didn't work, however self in this case is a different VC, so I'm doing it this way:\nself.slidingViewController.topViewController = self.slidingViewController.topViewController;\nI checked the frame size in setTopViewController: and they're showing (0,0,588,320) each time.\nThis is driving me crazy, your help is much appreciated. Thank you.\n. If the navigation bar was hidden to begin with, it will get the right size initially. But when a tap gesture event triggers the navigation bar hidden = NO, it will be pushed DOWN 44 pixels.\nI will fork the example and reproduce the problem, thank you!\n. Mike, I've pushed my changes to the forked example which demonstrates the issue.\nhttps://github.com/denistsai/ECSlidingViewController/tree/ios7/ECSlidingViewController\nIn the sample, I added a UIPageViewController to the Navigation Menu.\nI noticed also that the problem only occurs when the UIPageViewController is set to \"Scroll\" transition style. It works fine when it is set to \"Page Curl\".\n. Mike, I went back to double check my other test sample without ECSlidingViewController and noticed UIPageViewController transition style was set to Page Curl. After changing it to Scroll, I am noticing a similar shift occurring in the VC.\nVery sorry about the mix up and thanks for your time. I will close this issue, but If you do have any suggestions for a work around I would appreciate it. \n. Johannes - that worked for me! Thanks so much for sharing! :D\nDan - you can change that in the Interface Builder, under Attribute Inspector, uncheck \"Adjust Scroll View Insets\".\n. ",
    "jfahrenkrug": "For me, setting automaticallyAdjustsScrollViewInsets = NO; on the UIPageViewController fixed the issue.\n. ",
    "ifanchu": "Actually, ECSlidingViewController will make the following not working if you have a tableview in it\n1. TableView scrolling is not working\n2. Reordering is not working\nThis costs me a lot of time to find the cause, removing the panGesture then everything back on business.\nI really want to use ECSlidingViewController but this issue is a show-killer.\nBTW, I am using iOS7\n. ",
    "Nekbeth": "Thanks,  I notice that too. \nMy solution was not to add the panGesture to the table's view navigation controller (only the upper left button allowing the sliding) * while adding the panGesture to the rest of the navigation controllers that don't use the swipe to delete feature.  \nThat way the App still uses the ECSlidingViewController without interfering with the default tableview behavior.\n- This required two navigation subclasses (1 with the panGesture and 1 without it).\n. ",
    "wzs": ":+1: \n. ",
    "Ilya-Pak": "It works! Great thanks!\n. ",
    "jtomasrl": "same issue here\n. ",
    "eldaniel7": "Thank you! I will and I'll report you back in this same thread!\n. Dear Jeff, it was the first thing I tried, but it doesn't work. I tried with self.slidingViewController.view and it didn't work too. self.slidingViewController.view is the view of the menu, which is underneath the topView.\n. @enriquez I'm using ECSlidingViewController correctly, just as you described. When you add UIAlertView, it adds itself on top of everything else. I need to add a subview (some sort of popup) on top of everything, not only on top of the underLeftViewController. \n. Those warnings show on the Objective-C Version as well. Any clues?\n. ",
    "davidbitton": "OK, I moved some things around. Now, the colored background is a ViewController of its own of which I set as the top view controller in my viewWillAppear. When the user logs in, I change the top view to my split view controller. Logout now works because I can set the top view controller back to the colored background. However, is there any way to animate that transition? Thanks.\n\n. @jeffarena I had that setup several iterations ago. I'll leave it like this for the time being while I build up the app. I'll come back for polish later. Thanks!\n. ",
    "calimarkus": "Anyone else has the problem, that the view height is wrong on ios6 (built with ios7 SDK)?? It's 20pt too high.\nI fixed it in my subclass like this:\n```\n- (CGRect)fullViewBounds\n{\n  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {\n       return [super fullViewBounds];\n  }\nreturn (CGRect){CGPointZero, [[UIScreen mainScreen] applicationFrame].size};\n}\n```\n. jep perfectly visible in the example app, just add more rows to the tableview example. @jeffarena \n. That's how I'd like to use it:\n__weak typeof(self) blockSelf = self;\n[slidingViewController anchorTopViewOffScreenTo:ECRight animations:^{\n    slidingViewController.underLeftWidthLayout = ECFullWidth;\n} onComplete:nil];\nand then:\n__weak typeof(self) blockSelf = self;\n[slidingViewController anchorTopViewTo:ECRight animations:^{\n    slidingViewController.underLeftWidthLayout = ECVariableRevealWidth;\n} onComplete:nil];\n. ",
    "elektrojunge": "@jeffarena I just ran into this when I updated to 1.3.2. It happens when you run the sample app on iOS 6.1. Just add  a couple of more items to SampleTableViewController and you can see for yourself. I just played around a bit and it works correctly in 1.3.0, seems like the bug was introduced in 1.3.1\n. ",
    "xfyre": "Done. I have corrected and committed my code.\nOn Wed, Nov 13, 2013 at 12:50 PM, Jeff Arena notifications@github.comwrote:\n\n@xfyre https://github.com/xfyre if you make changes on your existing\nbranch and just push the new commits when you're done, the pull request\nshould update automatically. no need to submit a new one. thanks!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/edgecase/ECSlidingViewController/pull/207#issuecomment-28355066\n.\n\n\nIlya Obshadko\n. Unfortunately there are other issues with status bar if you are replacing topViewController before calling resetTopView.\nCommon workflow for sliding controller is:\n- opening left menu and selecting an item\n- setting topViewController to relevant navigation controller\n- resetting top view to close left menu, displaying new top view controller\nI can snapshot current top view before sliding it out and it works fine: I'm changing return value of prefersStatusBarHidden and call setNeedsStatusBarAppearanceUpdate right after snapshotting top view but before it slides away. So I'm getting the desired transition effect, by observing ECSlidingViewUnderLeftWillAppear notification.\nBut new top view controller that replaces current one is getting incorrect frame parameters (because at the time of replacement status bar is hidden) and being displayed incorrectly after resetTopView.\nCurrently I think that the best and most accurate way to work around this problem is iOS 7 custom view controller transitions.\n. The problem I was trying to address is a separate status bar management for topViewController and underLeft/underRight controllers. \nOn iOS 7 I would like to keep status bar in the top view and do not show status bar in underLeft/underRight - just like it's implemented in MailBox.app. Using new iOS 7 snapshot API really helps to achieve the desired effect, though maybe it's not very accurate solution to the problem itself.\nI think that probably most consistent way to do that is using new custom UIViewController transitions instead of child view controllers, because separate status bar management does not conflict with iOS controller presentation logic when implemented using this approach. I didn't have time to try it yet, but I'll let you know whenever I figure it out.\n. I have tested it and it works fine, thank you!\nThe biggest issue with ECSlidingViewController 2 is that it's not backwards\ncompatible with iOS 6 (which IS a problem because we have to support both\nversions 6 and 7).\nOn Fri, Nov 22, 2013 at 6:03 AM, Mike Enriquez notifications@github.comwrote:\n\n@xfyre https://github.com/xfyre here's a quick proof of concept using\nECSlidingViewController 2 with a custom animation:\nenriquez/ECSlidingViewController@6e454ddhttps://github.com/enriquez/ECSlidingViewController/commit/6e454ddf82e744cf3832e2ee506381d2e4c8ea90\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ECSlidingViewController/ECSlidingViewController/pull/207#issuecomment-29013131\n.\n\n\nIlya Obshadko\n. Should I correct my code and submit a new pull request?\nOn Wed, Nov 13, 2013 at 12:42 PM, Jeff Arena notifications@github.comwrote:\n\nIn\nECSlidingViewController/Vendor/ECSlidingViewController/ECSlidingViewController.m:\n\n@@ -378,6 +384,13 @@ - (void)anchorTopViewOffScreenTo:(ECSide)side\n- (void)anchorTopViewOffScreenTo:(ECSide)side animations:(void(^)())animations onComplete:(void(^)())complete\n  {\n  -    if (self.shouldUseNativeSnapshotFeature && ([[UIDevice currentDevice].systemVersion floatValue] >= 7.0f)) {\n\nSame as above, please don't use a version check like this. Instead, just\ncheck: [[UIScreen mainScreen] respondsToSelector:@selector\n(snapshotViewAfterScreenUpdates:)].\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/edgecase/ECSlidingViewController/pull/207/files#r7614694\n.\n\n\nIlya Obshadko\n. ",
    "adrian-schnell": "I've the same problem. I added the HUD with: [self.slidingViewController.view addSubview:HUD];\nBut it's only shown on the underLeftViewController.\nAnother problem for me is to add the HUD to the topViewController. When I try to add the HUD on self.view the app crashs:\n*** Terminating app due to uncaught exception 'UIViewControllerHierarchyInconsistency', reason: 'child view controller: should have parent view controller:(null) but actual parent is:'\nEDIT: the problem seems to be the call [HUD setMaskType:M13ProgressHUDMaskTypeIOS7Blur];\n. ",
    "marchv": "Hi Jeff and thanks for your quick answer,\nI have already tried to have my InitViewController to subclass ECSlidingViewController and I also did override those two methods. I.e., based on the topViewController the supportedInterfaceOrientations return either landscape or portrait.\nDo you have some code e.g., with one landscape only view controller and one portrait view controller that I can have a look at? I'm puzzled how to get that to work...\nDoes the old landscape-topviewcontroller slide out to the left and then a new portrait-topviewcontroller slide in portrait mode?\nThanks :)\n. Hi Jeff and thanks,\nOK I understand. \nTo me it seems like this is not possible to EC at the moment. I have looked at little bit in the code and for example the frame of portrait is different that frame of landscape. But when the topviewcontroller is replaced the old frame is just applied to the new topviewcontroller.\nThis is not a problem when all view controllers supports the same modes. But if some are limited compared to others then entering one of those gives wrong presentation.\nThis was why I created the issue :)\n. Wauw Jeff! Thanks :)\nI will try to wrap something together :)\n. dmdolpire, I intended to provide some code to jeffarena but unfortunately I haven't done that. And now it has become irrelevant for me sorry :S I didn't even have time to look at version 2.0 of ECSliding... Cheers :)\n. OK, please let me know if you find a solution :) And as you can see jeffarena seems willing to help if you/I provide him a starting point... :)\n. ",
    "dmdolpire": "marchv, did you manage to fix the issue?? I am wanting to do the same as well.\n. Okay marchv. Thanks anyway. I am trying what I can to get this too work.\n. ",
    "Eke": "was able to manage this using snippet bellow: \n- (BOOL)shouldAutorotate {\n  return [self.topViewController shouldAutorotate];\n  }\n. ",
    "tomaskraina": ":+1: \n. Of course, see LayoutDemo for more info.\n. Any change to get a feedback on the pull request? I would like to see it merged closed together with the issue it fixes so I don't have to maintain my own for.\n@enriquez Please let me know if there's anything I can do.\n. ",
    "hartbit": "I'll try to do some more testing tomorrow at work. The real shocker for me was the performance delta between ECSldingViewController 1 and 2. I've also tried quite a few sliding sidebar frameworks, and this is the first time I'm experienced so severe a performance impact on the Simulator and device. I hope either I or you can find a solution, because apart from that, I really like your implementation of the sidebar :)\n. Found the problem: it's the shadow I'm adding to the top view:\nobjc\nself.view.layer.shadowOpacity = 0.75f;\nself.view.layer.shadowRadius = 10.0f;\nself.view.layer.shadowColor = [UIColor blackColor].CGColor;\nBut this ran fine in ECSlidingViewController 1.x. Any ideas why it's causing problems now?\n. Thanks for figuring this out, and thanks for the best sliding view controller on GitHub :-)\n. > I'd like to keep what you did for 1 and 3. Giving ECSlidingViewControllerLayout the ability to change the under view frames is great. I think a bug is introduced when getting the finalFrameForViewController: for the under view. It should return CGRectZero when the top view is resetting. You'll see this bug by running rake test.\nCan you explain why finalFrameForViewController: should return CGRectZero when the top view is resetting? In my code, I use the finalFrameForViewController: of the under views to achieve the parallax effect: my under-views move, even when resetting. If I change the finalFrame to CGRectZero, my transition will animate the under views to CGRectZero.\n\nThe default sliding animation's ending frames for the under views should be the same as the initial frame. So, I think 4 is not needed.\n\nWhat you say may be our mis-understanding. If I want the under views to move while revealing and resetting, shouldn't the initial frame and final frame be different? That's how I implemented the parallax effect at least. If change ECSlidingAnimationController back to it's original implementation, I don't get any animations for free.\n\nI ran TransitionFun with MEParallaxAnimationController, but it looks like the default transition. I'm probably not seeing something?\n\nI had forgotten to implement the delegate method to point to the layout :) Fixed now. Check it out, perhaps you can better understand the effect I wanted to achieve.\n\nI want to see where you're going with the parallax transition, but I'd like to see it as a fork or separate project. Adding it to TransitionFun is going to be difficult to maintain (it already is with the 4 transitions already there). I plan on making each of the transitions from TransitionFun into their own projects. Eventually, there'll be a list of user contributed transitions on the Wiki.\n\nIf you don't want to integrate it into the project, that's fine. I'll just keep it in my fork. But personally, I think it's a pitty not to grow the list of transitions in the TransitionFun project. First of all, the current transitions helped me quickly test that the modifications I made to the project did not break a transition. The more there is there, the more \"testing\" can be done. Secondly, if you keep the transitions with the project, it is a bit more work to maintain them. But I think that's better than having links in the wiki to transitions that may be outdated and not build with the latest version of ECSlidingViewController.\n. > This is the behavior for iOS 7 custom transitions. CGRectZero signifies the view is being removed or is not on the screen. The parallax transition could've also been accomplished with a custom animation that sets the appropriate frames (and ignoring the frames returned from finalFrameForViewController:). There's nothing wrong with the custom layout you did, that works too.\nThanks for explanation, I was not aware of that! But there's something I still don't understand. If the finalFrameForViewController: method of UIViewControllerContextTransitioning needs to return CGRectZero for views which are not visible at the end of the transition, then my custom layout can't be correct. I return a non zero final position for the under views on resetting even if they end up being hidden. Or I am getting something wrong again?\n. Thanks for the length explanation! I have a much better understanding of everything now. I think I'll reimplement the parallax effect using an animation instead of a layout as soon as I get some time. Meanwhile, can you recap what you'd like me to keep in the PR?\n. ",
    "kehoe": "Hello,\nHere is a screenshot from my storyboard.\n\nIn first view I have a TableView generated by parsing a json file that contains URLs with SubMenu URLs to load in a WebView with SlideMenu (first of the URLs load in WebView). In the SlideMenu I load a TableView with the SubMenu URLs.\nBUT if I select a Item (SubMenu URL) in SlideMenu loads the WebView without the NavigationBar.\n. That didn't work.\nHere is the code how I switch from SlideMenu to WebView\n-(void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath\n{\n    WebViewController *newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"WebViewController\"];\n    newTopViewController.url = [subMenuItemURLs objectAtIndex:indexPath.row];\n    [self.slidingViewController anchorTopViewOffScreenTo:ECLeft animations:nil onComplete:^{\n        CGRect frame = self.slidingViewController.topViewController.view.frame;\n        self.slidingViewController.topViewController = newTopViewController;\n        self.slidingViewController.topViewController.view.frame = frame;\n        [self.slidingViewController resetTopView];\n    }];\n}\nI use version 1\n. OK, I tryed some things and now my Problem is solved.\n. ",
    "muyexi": "oh,the above issue only happen in iOS5 and iOS6,it's ok in iOS7.\n. ",
    "danielsalare": "Yes, I was using Navigation Controller. \nThanks in advance. \n. ",
    "anthonycastelli": "Oh okay, perfect. Will check it out now! Thanks for the heads up. \n. I'll take a look soon as I get home. It's with all the custom transitions that can be found in the example project, transition fun. \nSent from my iPhone\n\nOn Nov 27, 2013, at 2:30 PM, Mike Enriquez notifications@github.com wrote:\nThis happens when the navigation controller's frame is not the same as the window when it is added.\nI made some changes today on the master branch. Have you tried it yet? I think the way to do it with Cocoapods is\npod \"ECSlidingViewController\", :head\nAlso, is this with the default transition?\n\u2014\nReply to this email directly or view it on GitHub.\n. This seems to fix the issue, although, there appears to be a flickr when the new topViewController is sliding back.\n\nEdit: Using your example here: https://github.com/enriquez/ECSlidingViewController/commit/6e454ddf82e744cf3832e2ee506381d2e4c8ea90 causes the flickering issue. \n. Ahh, you are right. Thanks!\n. ",
    "claesjacobsson": "I got it working by dragging the files into my project and dropped the pod. Would prefer using the pod, though.\n. I get this too.\n. Great, thanks!\n. ",
    "mafellows": "@enriquez & @claesjacobsson I'm having the same problem with the pod. Works when I drop the files directly into the project. Only pod I'm having trouble with at the moment. Any updates on this issue? \n. ",
    "joamafer": "I think the solution should be to add -ObjC flag to \"Other Linker Flags\" section in your Build Settings. If you can't do this, e.g. you are using Parse Framework that doesn't allow you to set this flag, you will probably have to set in your AppDelegate the following:\n[YOURCLASSNAME class];\n. ",
    "adamk77": "Right.  I am not sure it is the menu button that is causing the freeze.  If you make a peace sign, and then touch the menu button with your index finger and then immediately touch the navigation bar with the middle finger, you can reproduce the issue fairly easily. \nI am able to reproduce it the easiest on the zoom transition in the sample app.  Also, when the screen freezes and you hit the home button to place the app in the bg and then bring it back to the fg, the screen is already in the transitioned state.\n. ",
    "akashkamboj": "I managed it with ViewDidDisappear for now, but still wants to know that are there any notifications, delegates, completion block.\n. Well Honestly I don't have any clue. Only thing i know that it resets the ContentOffset to CGPointZero. First I thought that since there are 2 views visible, and it's getting confused which one to reset. But strangely on iPad simulator it's working fine. I also thought that there are less rows in right view on iPad, maybe that's the issue. I tried adding more rows in right TableView and TopView but it was still working fine. So I am 99% sure that this is only happening on iPhone (both device and simulator)\n. ",
    "biznickman": "@enriquez it turns out this is definitely an issue. If you call \nself.slidingViewController.topViewAnchoredGesture = ECSlidingViewControllerAnchoredGesturePanning | ECSlidingViewControllerAnchoredGestureTapping;\nthe completion block won't be called.\n. ",
    "GantMan": "@enriquez that's all fine and dandy, but there's a ton of ways to close!   So if I'm not explicitly calling resetTopViewAnimated then how am I supposed to know?\nMaybe I'm missing the logic that lead notifications to be removed...\n. ",
    "richardsimko": "Gottcha, I'll give it a try. Seems to be an issue with swipe to delete on UITableViews as well but I haven't verified that yet.\n. Yep, fixed this issue but not the table view one. Created a new issue (#254)\n. I'm sorry, I really have no idea of how to fix it. It might be related to #250 since the symptoms ar similar but animations in iOS is really not my thing.\nI also don't know why it was labeled 1.x since the issue appears in 2.0 as well, haven't tried 1.x though.\n. Allright. Might affect 1.x also though, I'm not sure.\n. Yup, same here. My guess is it might be related to the UINavigationController subclass that I have, as I use a custom one in my project.\n. @mergesort Did you make any progress on finding the issue by the way?\n. Looking into it a bit more, it's related to the gesture recognizers not cooperating with each other. If I don't set my ECSliding subclass as the delegate the swipe to delete gesture won't even work. If I do however, this issue happens, regardless of the return values from the two delegate methods. I have pushed an update to my example, please advise on how you're supposed to configure the panGestureRecognizer to work with a navigation controller.\nAnother thing I found, isInteractive will return YES after the delete action has been made, causing ECSlidingViewController to try and perform an interactive animation after the button press. This is not the case if one presses the button right away so seems to be some kind of inconsistency there (Break on the method - (void)animateOperation:(ECSlidingViewControllerOperation)operation to debug).\nLooking into it a bit more, the method is called when swiping to delete. When this happens isInteractive is set to YES, something which is never reset. I would suggest trying to follow this variable, @enriquez as you are much more familiar with how ECSlidingViewController works internally than I am you should be able to figure it out a lot faster than me.\n. Ok. Maybe my recent findings can help? Although preferably @enriquez should take a look, I think that by now it's pretty clear that the bug is in ECSliding. \n. I've found the issue.\n- (void)detectPanGestureRecognizer:(UIPanGestureRecognizer *)recognizer is setting _isInteractive way to aggressively. It setts is even though it doesn't know if the view controller should be able to slide in the direction specified.\nFrom what I can see, adding _isInteracive = NO; to - (void)animateOperation:(ECSlidingViewControllerOperation)operation when the operation is invalid seems to have fixed it. Have a look at this to see what I did: https://github.com/RichardSimko/ECSlidingViewControllerTest/commit/c2c5ac8b3cf7bf71c825fc5bf1b945e62c5815fa\n. @mergesort Feel free to verify this with your setup to see if it works there as well :)\n. Sweet! :+1: \n. Same here.\n@maddoggy1979 Your workaround did the trick for me. Will roll with that for now, thanks!\nEDIT: This seems to affect all calls to pushViewController:animated and friends from within the app. It would seem as though there is some animation which isn't completed, judging by the error message.\nAnother easy way to replicate this is to add a new VC to the Basic Menu example and put the following code in an IBAction and tie an action to the code:\n-(IBAction)pressButton:(id)sender{\n    [self.navigationController pushViewController:[[UIViewController alloc] init] animated:YES];\n}\n. @enriquez Any ideas on what could be the problem?\n. I'm starting to wonder that too. The amazing lack of replies from debs is really making me lean towards looking for some other lib.\n. @eoinmcc's solution is working perfectly if the menu is the root, which it was in my case. In order to make it work with the right menu I had to remove the first line in UIViewController+ECSlidingViewController.m:\nUIViewController *viewController = self.parentViewController ? self.parentViewController : self.presentingViewController;\nSo instead it looks like this:\n- (ECSlidingViewController *)slidingViewController {\n    //assuming the slidingVC is the root.\n    UIViewController *viewController = [UIApplication sharedApplication].delegate.window.rootViewController;\n    while (!(viewController == nil || [viewController isKindOfClass:[ECSlidingViewController class]])) {\n        viewController = viewController.parentViewController ? viewController.parentViewController : viewController.presentingViewController;\n    }\n    return (ECSlidingViewController *)viewController;\n}\nOf course, as @eoinmcc mentioned it won't work unless you have the ECSliding as root view but it's probably a workaround that will help a few people for the time being.\nEDIT: This completely broke rotation callbacks so on second thought I'm not using this at all but instead reverting to the old ECSliding. If you're not using rotation however this might work but YMMV.\nEDIT again: Screw this, I'm out. Going with @maddoggy1979's advice and switching to SWRevealViewController. So far it's a dream.\n. ",
    "jackdewhurst": "How would I go about fixing this issue on the v1.x branch? I need to support iOS 6 and this is still a problem for pre v2.\n. ",
    "pierrephi": "I think it is great I need this as well, I need the  will variant to resignFirstResponder on some control that is active (and remove the keyboard) when the user wants to navigate to the side menu. I have found no other to detect this an solve this use case.\n. ",
    "Dalein": "@enriquez, can detail please. I have tabBar - NavController - VC1 - detailVC, how can I do zoom transaction VC1 to detailVC?\n. ",
    "mergesort": "If no one is on this, I can take a look into this over the weekend, since I'm using it in a project and it's starting to become a blocker. Though if @RichardSimko or @enriquez can point me in the right direction, or knows of a quick fix, that would be ideal. \n. @RichardSimko I decided to punt on it, debugging it proved to be messier than I had expected. Sorry :\\\n. ",
    "laurent74": "For those like me who need this fixed in the v1.3 for iOS 6, just make ECSlidingViewController implement UIGestureRecognizerDelegate, set the delegate for all the gestures you can find in ECSlidingViewController then add:\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer\n{\n    return YES;\n}\n. ",
    "ghost": "Still have troubles with swipe to delete. Any new solutions???\n. Me also have the same problem on iOS 8. Any ideas?\n. I have the same problem on device and simulator with iOS 8.0\nProject written in Swift, using storyboards, ECSlidingVC connected via objc-briging\nIf in - (void)reversePausedAnimation:(CADisplayLink *)displayLink remove line with layer.speed = 1.0 than flashing does not happen, but sliding won't work after one open/closing\nAny solutions? Flashing on closing is not good\n. In swift project with -Briging-Header I see warnings:\nMethod 'viewForKey:' in protocol 'UIViewControllerContextTransitioning' not implemented\nMethod 'targetTransform:' in protocol 'UIViewControllerContextTransitioning' not implemented\nHow can I fix it?\n. self.view.addGestureRecognizer(self.slidingViewController().panGesture) works good for me\n. No, I need in landscape mode fully showed topViewController and fully showed left menu, without sliding.\n. thanks, but it doesn't work, still flashing on my device\n. ",
    "aperechnev": "I have the same issue on iOS 8.\n. Any ideas how fix this?\n. ",
    "dcacenabes": "Up. Happening again in iOS8\n. ",
    "MihaelIsaev": "Yeah, the same issue in iOS8\n. Hello everyone!\nYesterday I rewrote the whole library into Swift, but I think there are some mistakes because it doesn't work properly. This is the link to repository https://github.com/MihaelIsaev/ECSwiftSlidingViewController\nI don't know if the author of the library is woking on the same issue, I just want to use this library in Swift without obj-c bridging.\nAny help is welcome!\n. I've fixed critical bugs, but I still need help. Now the most nasty problem is not smoothly opening menu with slide gesture..\n. ",
    "0xPr0xy": "Up\n. ",
    "devangmundhra": "Thanks for the explanation Mike.\nI can see the artifact on the device even without the breakpoint, though\nless often.\nOne sure way I was able to reproduce it was to cancel the transition and\ndrag the topViewController at the same location where it started which\ncauses the screen to flicker.\nOn Thu, Dec 12, 2013 at 4:41 PM, Mike Enriquez notifications@github.comwrote:\n\nThanks for the detailed report.\nThis is because of the percent driven transition which is used by the\nDefault, Fold, and Zoom transitions. An implicit animation is initiated and\nthen immediately controlled with a gesture. The implicit animation sets the\nfinal frame of the top view to where it should end. The problem is that the\ngesture can end the transition to where the animation started. You end up\nseeing where the implicit animation should've ended.\nI haven't been able to find a good way to do percent driven transitions\nwithout this artifact on the simulator. I haven't been able to reproduce it\non the devicehttps://github.com/ECSlidingViewController/ECSlidingViewController/wiki/Frequently-Asked-Questions#why-does-the-animation-flicker-when-cancelling-a-gesture\n.\nThe purpose of the percent driven transition is for a nice API. It is\noptional and custom transitions can do without it (but it takes more work).\nSee the UIKit Dyanmics transition.\nAre you able to observe the artifact on the device without the breakpoint?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ECSlidingViewController/ECSlidingViewController/issues/256#issuecomment-30477080\n.\n. I am using iPhone 5\n\nOn Thu, Dec 12, 2013 at 8:43 PM, Mike Enriquez notifications@github.comwrote:\n\nWhich device are you using?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ECSlidingViewController/ECSlidingViewController/issues/256#issuecomment-30486807\n.\n. \n",
    "danielsaidi": "I completely agree - ECSVC is great! I am using a rather old version in a project of mine, and actually added support for sliding up/down yesterday. I went through the source code and created up/down additions everywhere where I found left/right references. I treated top as left, bottom as right, flipped width to height, x to y and also added a new fullscreen flag to support iOS7 where the UI blends with the status bar. If you would want to, I could send you the code.\n. It is really nothing more than code-duplication of an old version of ECSVC, but it works just fine, so I'd be happy if you would like to try it out. I haven't tried all possible scenarios either, so there are most probably bugs that I haven't discovered yet. Drop me an e-mail (daniel.saidi@gmail.com) and I'll send you the rewritten code.\n@enriquez , would you like me to grab the latest version, add my stuff to it then send you a pull request?\n. ",
    "timgcarlson": "@danielsaidi - I would love to see the to see what you did!  I was actually about to begin doing exactly this, just swapping left and right with up and down.  Looking forward to trying it out!\n. ",
    "DanMorganiOS": "My designer also wanted this feature, except a little different he wanted to hide the status bar when the menu was opened.  Did you set the statusBarStyle in viewDidLoad? It should work [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault].  \nSomething you may also want to look into is how Foursquare and Facebook handled presenting their menus in iOS 7 fading into the menu color/black.  It is what we ultimately ended up doing.  You just add a UIView of 20px height at the top of your view and set the alpha of the view to be the percentage across the screen and it'll slowly fade into the color you desire.  It did require some tweaking of the ECSlidingViewController, but it wasn't too bad.  If you're interested in that implementation and are having trouble with it I don't mind sharing my code.\n. ",
    "penggu89": "I want to use the light status bar style instead of the default dark. But I also need to use View controller-based status bar appearance, so [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent] will not work in this case, it only works when View controller-based status bar appearance is set to NO in the plist.\n. I think this is a bug, ECSlidingViewController changes the status bar style to dark somewhere. \n. ",
    "lucasmedeirosleite": "I had the same problem. I solved this by implementing the method -(UIStatusBarStyle)preferredStatusBarStyle\nmaking it return UIStatusBarStyleLightContent on the \"menu view controller\"\n. ",
    "Macbiont": "I experience the same issue!\n. ",
    "eljago": "I've had this problem for a long time. It has happened with other side menu libraries also.\nIt always random, one of the cells is undraggable. If the cell is reused it still can't be dragged.\n(I'm using version 2.0)\n. The problem is not the cell being reused, because the other reused cells respond correctly to the dragging. What I meant is that when a cell presents this problem it won't work after it is reused since it's the same view object. This was clear for me today when I had a table where the 5th, 10th, 15th cells didn't respond.\nIt also happens for view objects inside a cell instead of the whole cell.\nFor example i have a tableview with cell that has an imageview and a label. Sometimes the drag of the table wont work if I start the gesture on the imageview, but it will work if the gesture starts on another part of the cell.\nIt's always random, so weird.\n. I said before that the this problem still happens with other side menu libraries, so today just to recheck, I implemented PKRevealViewController and the problem remains, so it's definitely not a problem with ECSlidingViewController.\n. Just realized this happened because I set the Gesture Recognizer to the NavigationController instead of it's View Controller.\n. ",
    "ioflong": "@eljago Is is the problem that the cell is reused? Do you try not to reused the cell?\nAnd I notice that it always happen on the first cell or the last visible cell.\nWith your tips, I realize that may be the reused cell.\n. ",
    "Bluezen": "I am experiencing the same issue in version 2.01. @ioflong @eljago did you find a solution? \n. Hum, re-setting userInteractionEnabled to YES for reused cell seems to do the trick for me, thanks for your tips. I am testing right now but the strange behavior doesn't seem to happen anymore.\n. Hey! \nCould you describe your issue a bit more? It seems related to the problem I encountered with inline HTML5 videos not playing correctly after a pan gesture to open the menu.\nI describe the issue and how to easily reproduce it on the following repo:\nhttps://github.com/Bluezen/ECSlidingViewController-issue\nThat would be cool if you could check it out and tell us if it's similar and if you found a solution to your issue!\n. ",
    "swernerus": "We have exactly the same problem with a tableview. Most of the time vertical scrolling work but from time to time it seems blocked.\n. ",
    "goose2460": "Nevermind, same as #182\n. ",
    "kexoth": "I was trying to reproduce it, with another example app, and while doing it I figure it out where my mistake was. I'm so sorry, it was totally my fault. Such a stupid mistake. Tnx anyway.\n. This was a overlook in my implementation, it has nothing to do with the library.\n. ",
    "ronaldojssilva": "can show how to do? no idea how to do\n. ",
    "backofthecup": "This still doesn't work. I've tried everything to get this to work:\nAdded the link_with:\nlink_with 'PatientMobile', 'PatientMobileTests'\npod 'AFNetworking', '~> 2.4'\npod 'ECSlidingViewController', '~> 2.0.3'\nVerified that there are no source files in my test target build phase:\n\nMy tests are crashing on this line of code because self.slidingViewController is nil:\n[self.navigationController.view addGestureRecognizer:self.slidingViewController.panGesture];\nBTW, I can use the AFNetworking library (also a POD) without any issues in my Tests.\nI really like this control, but if it breaks my unit tests, I'll have to use something else.\nDo you have any suggestions?\n. @enriquez \nThis looks like a Test/POD issue returning nil for isKindOfClass method. I finally got this working when I changed my Profile to read:\n```\ntarget 'PatientMobile' do\n    pod 'AFNetworking', '~> 2.4'\n    pod 'ECSlidingViewController', '~> 2.0.3'\nend\ntarget 'PatientMobileTests'  do\n    # this pod is not used by PatientMobileTests, but we need something here to ensure we properly link cocoapods to the PatientMobileTests target\n    pod 'OCMock', :head\nend\nlink_with 'PatientMobile', 'PatientMobileTests'\n```\n. ",
    "alexanderkent": "Perfect. Thanks. Yes.\nif(self.slidingViewController.currentTopViewPosition == ECSlidingViewControllerTopViewPositionCentered){\n    [self.slidingViewController anchorTopViewToRightAnimated:YES];\n}\nelse{\n     [self.slidingViewController resetTopViewAnimated:YES];\n}\nworks well.\n. ",
    "mariusw": "Seems logical, but how is this done in the TransitionFun example? Tapping the Menu button there closes the menu, and I can see that the resetTopViewAnimated action is called, but from where?\n. ",
    "betzerra": "+1 to @mariusw \nI'm trying to implement UI dynamics on my project and my screen gets unresponsive after clicking Menu. I can show / hide the sidebar every time I want by dragging it but not using the Menu button.\n. ",
    "valeriyvan": "Brilliant! Wasted tow hours guessing how to implement this behaviour.\n. ",
    "anuraagdjain": "Swift version \nimport ECSlidingViewController\nif self.slidingViewController().currentTopViewPosition == ECSlidingViewControllerTopViewPosition.Centered{\n            self.slidingViewController().anchorTopViewToRightAnimated(true)\n        }else{\n        self.slidingViewController().resetTopViewAnimated(true)\n        }\n. You should add the above code in viewDidAppear. Copy the below code and paste it into your existing code. \noverride func viewDidAppear(animated: Bool) {\n        self.view.addGestureRecognizer(self.slidingViewController().panGesture)\n    }\n. You can add Pan Gesture which will help you to close the slider menu.\noverride func viewDidAppear(animated: Bool) {\n        self.view.addGestureRecognizer(self.slidingViewController().panGesture)\n    }\nThis should do the work. Just slide from right to left to close the menu. \n. ",
    "ajsharp": "A workaround I found was to implement the UIGestureRecognizerDelegate protocol on the pan gesture and restrict it to the very left of the screen:\nobjective-c\n-(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {\n    if ([gestureRecognizer locationInView:gestureRecognizer.view].x < 50.0) {\n        return YES;\n    }\n    return NO;\n}\n. It might be worth noting that in the readme or on the wiki or docs. My hunch is that people are using swipe gestures with table view cells quite a bit, so this might be somewhat common.\nThanks for the quick response :)\n- alex\n\nOn Jan 8, 2014, at 9:10 AM, Mike Enriquez notifications@github.com wrote:\nYou can also implement the delegate methods to cancel ECSlidingViewController's pan gesture with other gestures.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "ishwardhanuka": "Can you please elaborate a bit? I have tried to modify all possible animations, and just cant get it to work. Any help will be greatly appreciated.\nThank you.\n. ",
    "stevemoser": "I guess the issue is that I expect this to work like a navigation controller where if the left view controller were actually the bottom most vc in a nav vc stack then I could unwind back to it but since it is not unwinding to the left vc isn't possible. Could there be some workaround to treat the left view controller like the bottom most vc on a nav controller stack. Or an option to set the left or right view controller as the root.\nI'm personally not a fan of hamburger nav on the iPhone (Facebook doesn't even do it anymore) but it is a requirement out of my control on a project I'm working on. I really like this implementation of hamburger nav but I might shop around for something where behind the covers it acts like a nav stack except the second most bottom vc hovers over the bottom most vc. Thanks!\n. ",
    "nobre84": "Is it expected for Modal unwinds not work on iOS 8 ?\n. I set up a delegate to the panGestureRecognizer that only let it function when bezel swiping (close to the screen edge)\n. Hi, sorry for the long delay in the response... What I did was\nin viewDidAppear:\nself.slidingViewController.panGesture.cancelsTouchesInView = NO;\n[self.view addGestureRecognizer:self.slidingViewController.panGesture];\nself.slidingViewController.panGesture.delegate = self;\nin viewDidDisappear:\nself.slidingViewController.panGesture.delegate = nil;\nThe delegate methods implementation:\n```\n- (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer {\n    return YES;\n}\n\n(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {\n    // With the menu open, let any gesture pass.\n    if (self.slidingViewController.currentTopViewPosition == ECSlidingViewControllerTopViewPositionAnchoredRight) return YES;\n   // With a closed Menu, only let the bordermost gestures pass.\n    return [gestureRecognizer locationInView:gestureRecognizer.view].x < PAN_GESTURE_SENSITIVITY);\n}\n```\n\nThe gesture sensitivity I used was around 30 for iPhone and 60 for iPad, your mileage may vary.\n. ",
    "deckyfx": "I also encounter this problem, cannot unwind, it does nothing\nECSSliding show navigation Controller, and then from a view controller, show modal view controller\nUPDATED!\nI fond a work arround,\nfrom presented VC, call this to return to previous VC\n[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];\n. ",
    "jeffbailey": "Thanks Mike! Appreciate it.\n. ",
    "perrypelletier": "I was on 2.0.0-beta2.  I'll try on 2.0.1.  I got to the point of being able to reproduce easily on the beta.  If I can on 2.0.1, I'll give you better guidance on reproducing and will try to fix since the guy who can reproduce it has best chance of fixing it:-(\n. ",
    "turgutoztunc": "it happens to me with the last version. sometimes it becomes unresponsive and the window freeze. \n. ",
    "pavankris": "\nLooking into this , ran on ios7 iPad . Instead of folding in , the animation is more like flickering , folding out looks fine. \n. ",
    "Ricardo1980": "After reading Layout demo I see it fixes this problem using:\n    //underLeftViewController.edgesForExtendedLayout     = UIRectEdgeTop | UIRectEdgeBottom | UIRectEdgeLeft; // don't go under the top view\nThe problem I see is that my side views, are actually navigation controllers in the storyboard that don't have classes. So, unless I create classes for them (and call edgesForExtendedLayout in their viewDidLoad), I don't how to do it.\nAny idea?\n. It seems the solution is here:\nhttp://adrianhoe.com/adrianhoe/2014/04/11/changing-the-uistatusbarstyle-per-view-basis/\n. ",
    "andwhy": "Have some problem too\n. ",
    "Leverin": "Doh. Hadn't set the Key Paths in the Storyboard.\n. Here are the key paths on my ECSlidingViewController:\nKey Path: topViewControllerStoryboardId\nType: String\nValue: HomeNavigationController\nKey Path:  underLeftViewControllerStoryboardId\nType: String\nValue: MenuViewController\nHomeNavigationController is the Storyboard ID of the navigation controller that is opened when the app is launched and MenuViewController is the Storyboard ID of the menu view controller.\nHope it helps.\n. ",
    "KPDragadine": "What did you set your key paths too?\n. ",
    "zenghaojim33": "That works.Thanks\n. ",
    "sharathvatti": "Can't we do with out setting those key paths ? I want to set the topviewcontroller based on condition. Can u please help me.\nThanks in advance.\n. ",
    "magnett": "I am having the same issue using also auto layout. Besides the bottom of the view disappearing, i am having another problem! I am getting a transparent 20px line which lets the menu below the current view to be visible. To trigger that situation you have to (while the in-call status bar is visible) open the menu, select another item and then open again and select another. I fooled around a little bit and found out that this transparency problem has to do with the \"Under top bars\" option of the IB. If you disable it, no more transparent line however this is not a solution in my case.\n\n. @erikandersen-pariveda I am not using this menu anymore. It's not supported anymore. My personal opinion is to look for something else...\n. +1\n. ",
    "anasb": "Has anyone found a solution to this issue?\n. +1\n. Any chance this could be merged soon ?\n. +1\n. I've had the same issue on simulator, but not on device (although I only tested on one device so far).\n. Ok, can confirm on device as well, and your solution works. Thanks!\n. ",
    "erikandersen-pariveda": "@magnett Have you resolved your issue with the 20px transparency between your navigation bar and view? I'm seeing the same thing now.\n. @magnett @carlcarter I'm actually not using this control at all, but I was seeing that 20px transparent view at the top of one of my screens. I was hoping any fixes in this library would help me fix the same issue in my code.\nThe good news is that I found the answer here (http://stackoverflow.com/questions/30525403/why-the-20px-gap-at-the-top-of-my-uiviewcontroller/30614342#30614342). Thanks for y'alls quick responses though!\n. ",
    "zhukov-ever": "@erikandersen-pariveda my solution for this problem:\n[self.navigationController setNavigationBarHidden:YES];\n[self.navigationController setNavigationBarHidden:NO];\n. ",
    "carlcarter": "completely agree with @magnett - I migrated from this recently and started using MMDrawerController instead - was a fairly easy switch over and has the benefit of being well supported.\nhttps://github.com/mutualmobile/MMDrawerController\n. ",
    "maxperry": "I was able to fix the issue by following another answer from the same linked by @erikandersen-pariveda http://stackoverflow.com/a/30603747\nI just had to override - (void)setTopViewController:(UIViewController *)topViewController and add _topViewController.view.frame = self.view.bounds; right after [self addChildViewController:_topViewController];\n. ",
    "tpang13": "found the solution myslef:\n- (IBAction)menuButtonTapped:(id)sender {\nif (self.slidingViewController.currentTopViewPosition == ECSlidingViewControllerTopViewPositionAnchoredRight)\n  {\n      [self.slidingViewController resetTopViewAnimated:YES];\n  }\n  else\n  {\n      [self.slidingViewController anchorTopViewToRightAnimated:YES];\n  }\n  }\n. ",
    "DKalachniuk": "Had the same issue! Your solution is very good!\n. I have the same issue! Your fix didn't help(\n. @codepushr still can see the splash(\n. ",
    "ignotusverum": "same problem\n. ",
    "alpascual": "Sorry, found it\n. ",
    "lemonkey": "On second thought, the cancellation of the transition is correct in this case.  For some reason the left view's color is bleeding through the top view's navigation bar when the cancelation occurs and when the left view is in focus.  Not sure if this is a bug with iOS 7 or not.\nI verified that this isn't happening with the sample project that uses storyboards, but it is happening when you use normal NIBs.\n. Hmm, I still see some flashing with this patch and when the top view resets after a cancellation of swipe from right to left, keeping the top view pinned to the right, the top view has an incorrect frame (appears vertically compressed).\nI should add that I'm using a custom version of the interactive zoom animation transition that was included in the project.  However, your approach gave me some ideas and I think it's working.  Thanks.\n. +1\n. c'mon 14 days? that on top of no iOS 8 beta 6 SDK today puts me in a bind...\n. FYI, we're seeing this bug on the latest version of our app that is in the App Store, built under the iOS 7 SDK but when running on devices with iOS 8 beta 5.  This leads me to think it's something Apple introduced with a change in UIKit possibly (things were fine between betas 1-4) and why the maintainers of this repo may be hoping for beta 6 to fix it...\n. This fixes it for me as well, at least until beta 6 comes out :)\n. :+1: \n. Thanks :+1: \n. ",
    "Elshad": "anchorTopViewToRightAnimated:onComplete\nanchorTopViewToLeftAnimated:onComplete:\nresetTopViewAnimated:onComplete\n. How you fix this problem?\n. Thank you for answer\n. Add below code to \"(BOOL)application:didFinishLaunchingWithOptions:\" function in appDelegate\nECSlidingViewController *slider = [[ECSlidingViewController alloc] init];\nslider.underLeftViewController  = [[ELMenuViewController alloc] init];\nslider.anchorRightRevealAmount = 44.0;\nslider.topViewController = [[ELMyTopViewController alloc] init];\nself.window.rootViewController = slider;\n. 1. In my app navigation bar is not missing, no idea why this happen\n2. Add this code\n   [self.navigationController.view addGestureRecognizer:self.slidingViewController.panGesture];\n   to viewDidLoad in FirstViewController and then you can swipe and see menu\n3. It is true, there is no animation, may be you must do your own animations\n. In ECSlidingViewController.m file replace  setTopViewController function (row number 117) with code shown below and it will replace controllers with fadeIn fadeOut scale animation\n- (void)setTopViewController:(UIViewController *)theTopViewController\n{    \n    CGRect topViewFrame = _topViewController ? _topViewController.view.frame : [self fullViewBounds];\n    [UIView animateWithDuration:0.5 animations:^{\n        CGAffineTransform transform = CGAffineTransformMakeScale(0.1f, 0.1f);\n        self.view.transform = transform;\n        self.view.alpha = 0;\n    } completion:^(BOOL finished) {\n        [self removeTopViewSnapshot];\n        [_topViewController.view removeFromSuperview];\n        [_topViewController willMoveToParentViewController:nil];\n        [_topViewController removeFromParentViewController];\n        _topViewController = theTopViewController;\n        [self addChildViewController:self.topViewController];\n        [self.topViewController didMoveToParentViewController:self];\n        [_topViewController.view setAutoresizingMask:self.autoResizeToFillScreen];\n        [_topViewController.view setFrame:topViewFrame];\n        _topViewController.view.layer.shadowOffset = CGSizeZero;\n        _topViewController.view.layer.shadowPath = [UIBezierPath bezierPathWithRect:[self fullViewBounds]].CGPath;\n        [self.view insertSubview:_topViewController.view belowSubview:self.statusBarBackgroundView];\n        self.topViewSnapshot.frame = self.topView.bounds;\n        [UIView animateWithDuration:0.5 animations:^{\n            CGAffineTransform transform = CGAffineTransformMakeScale(1.0f, 1.0f);\n            self.view.transform = transform;\n            self.view.alpha = 1;\n        }];\n    }];\n}\n. ",
    "simontaen": "Is there an update on this issue? I think I have the same problem when using this https://github.com/MrAlek/AWPercentDrivenInteractiveTransition\n. ",
    "dbachrach": "Check out my fork: https://github.com/dbachrach/ECSlidingViewController/commit/15f759f1aaa815e002ae0c15e7adc97785321edf\nI've managed to work around the issue by invoking a special cancel handler that commits the view changes. \n. Shoot! I still need to clean this up and hopefully trace down the exact issue. I just pushed another commit that should hopefully not crash your app. https://github.com/dbachrach/ECSlidingViewController/commit/42f57cda6b9019e384f4a39958c0ccbed724f644\nIf you have a custom animation controller, you'll need to add this:\nobjc\n@property (nonatomic, copy) void (^coordinatorCancelation)(id<UIViewControllerTransitionCoordinatorContext>context);\nLet me know if that works.\n. Flashing definitely occurs on the device. Does anyone have any ideas on how to fix this? I've been playing around with things and can't get it yet. It looks like in https://github.com/ECSlidingViewController/ECSlidingViewController/blob/cabce50e8ff9e4a46ec8c5c48473ac30a880e483/ECSlidingViewController/ECPercentDrivenInteractiveTransition.m#L107\n``` objc\n- (void)reversePausedAnimation:(CADisplayLink *)displayLink {\n    double percentInterval = displayLink.duration / [self.animationController transitionDuration:self.transitionContext];\n_percentComplete -= percentInterval;\n\nif (_percentComplete <= 0.0) {\n    _percentComplete = 0.0;\n    [displayLink invalidate];\n}\n\n[self updateInteractiveTransition:self.percentComplete];\n\nif (_percentComplete == 0.0) {\n    self.isActive = NO;\n    CALayer *layer = [self.transitionContext containerView].layer;\n    [layer removeAllAnimations];\n    layer.speed = 1.0;\n}\n\n}\n```\nthat when after we've removed the animation, setting the layer's speed to 1.0 immediately moves all the layers to their final position of the animation. I think this is by design, and I'm not sure of the best way to reset view positions.\n. For those interested, take a  look at https://github.com/dbachrach/ECSlidingViewController/commit/15f759f1aaa815e002ae0c15e7adc97785321edf\nI've added a cancelation complete method that is invoked directly by the interactive transition when the cancel animation completes. In this callback, I set the cancelled position of all views. This fixes the flashing for me.\n. :thumbsup:\n. Take a look at my comment on https://github.com/ECSlidingViewController/ECSlidingViewController/issues/307#issuecomment-64523650\nDoes that fix your issue?\n. @mediachicken replied back on original thread: https://github.com/ECSlidingViewController/ECSlidingViewController/issues/307#issuecomment-69272327\n. Can you take a look at https://github.com/ECSlidingViewController/ECSlidingViewController/issues/307 and see if the solution there helps?\n. Along with the fix in #307 you also need to add an implementation of cancelationComplete: to your animation controller.\nFor example, ours adds this:\n``` objc\n- (void)cancelationComplete:(id)transitionContext\n{\n    UIViewController topViewController = [transitionContext viewControllerForKey:ECTransitionContextTopViewControllerKey];\n    UIViewController underRightViewController  = [transitionContext viewControllerForKey:ECTransitionContextUnderRightControllerKey];\n    UIView topView = topViewController.view;\n    UIView containerView = [transitionContext containerView];\nif (self.operation == ECSlidingViewControllerOperationAnchorLeft) {\n    [self topViewStartingState:topView containerFrame:containerView.bounds];\n    [self underRightViewStartingState:underRightViewController.view containerFrame:containerView.bounds];\n}\nelse {\n    [self underRightViewEndStateBack:underRightViewController.view];\n    [self topViewAnchorLeftEndState:topView anchoredFrame:[transitionContext initialFrameForViewController:topViewController]];\n}\n\nif (self.coordinatorCancelation) {\n    self.coordinatorCancelation((id<UIViewControllerTransitionCoordinatorContext>)transitionContext);\n}\n\n}\n```\n. ",
    "anton-matosov": "I have fixed the flickering issue in #425\n. I have fixed the flickering issue in #425\n. ",
    "Gaidesignit": "it still doesn't work. \n. ",
    "LeoNatan": "If you push a sliding view controller, in the other view controllers, you need to access self.slidingViewController.navigationController and self.slidingViewController.navigationItem.\n. ",
    "aemengo": "I've just now noticed it the README. I apologize.\n. The truth is that I never fixed it. In the ReadMe, they addressed the issue by saying\nNote: There is a problem with the simulator flashing the animation when cancelling an interactive transition. This does NOT happen on the device.\nI've noticed it at times on a real device, but I (and my users) never considered it bothersome enough.\n. ",
    "truemetal": "After implementing my own simple version of sliding control I realised the issue was not related to ECSlidingController but rather to UIKit. \nI had a navigation controller with table view linked to it as root controller; I instantiated navigation VC by storyboard ID and in that case to make beginRefreshing work you need to call the following before and after that: \nself.tableView.contentOffsetY -= self.refreshControl.height; \nAnother option - not instantiate navigation controller, but root view controller by storyboard id; then just create a navigation with:\n[[UINavigationController alloc] initWithRootViewController:newRootVc]\nIn this case beginRefreshing would work just fine.\n. ",
    "DisconnectedPravin": "Can you add steps on - how to integrate ECSlidingViewController with out storyboard? \nIn appDelgate how to reference/ initiate ECSlidingViewController class object?\n. Below code added to \"(BOOL)application:didFinishLaunchingWithOptions:\" function in appDelegate\n```\nRootViewController * rootview =[[RootViewController alloc]initWithNibName:@\"RootViewController\" bundle:nil];\nSideMenuViewController * menu =[[SideMenuViewController alloc]initWithNibName:@\"SideMenuViewController\" bundle:nil];\nUINavigationController * navigationController = [[UINavigationController alloc]initWithRootViewController:rootview];\nself.slidingViewController = [ECSlidingViewController slidingWithTopViewController:navigationController];\nself.slidingViewController.underLeftViewController = menu;\nself.window.rootViewController = self.slidingViewController;\n```\nNow this is showing side menu options.\nHere, SideMenuViewController this is UIViewController class which includes table.\nHow to show or push new view controller when user selects any option from side menu?\nFor now I am doing like this way but this is not working correctly. Issue with code is that \n1. Navigation bar is missing.\n2. Not able to see side menu option on this FirstViewController.\n3. There is no animation while push/showing the FirstViewController.\n// Open or close side menu option:\nif(self.slidingViewController.currentTopViewPosition == ECSlidingViewControllerTopViewPositionCentered){\n    [self.slidingViewController anchorTopViewToRightAnimated:YES];\n} else {\n    [self.slidingViewController resetTopViewAnimated:YES];\n}\n// View controller to push on selecting any side menu option.\nFirstViewController * firstVC = [[FirstViewController alloc]initWithNibName:@\"FirstViewController\" bundle:nil];\nself.slidingViewController.topViewController = firstVC;\n[self.slidingViewController resetTopViewAnimated:YES];\nCould you please correct me if any thing missed out here?\n. Thank you Elshad for your support.\nAs per your suggestion I did the changes but still there are three above issue as I mentioned. \nHere I don't understand - how to push and pop view controllers like we do using navigation controller.\n. ",
    "andresbrun": "I am afraid this flashing is in iOS8 even in devices.\n. ",
    "amcastror": "Hi @ghost, were you able to do this?? Thanks!\n. ",
    "ftonello": "I have the same issue. This also happens with anchorTopViewTo*Animated:. I am using 2.0.3 pod.\n. ",
    "AndrewSB": "would love to see this merged too, this is a feature that I need in a side bar controller\n. ",
    "ebgraham": "74b55f8 breaks expected behavior -- should revert ASAP\n. +1, works great on iOS 8.  Please merge!\n. Actually on further testing, this introduces unintended behavior where scrolling in a table view can open the sliding menu.\n. ",
    "WVan": "I can confirm this problem.\n. ",
    "pcolton": "I had another view controller in front that I couldn't figure out how to have it pass orientation changes forward (even though I overrode all the required methods). I just deleted that class for now and am working around it.\n. +1\n. ",
    "fenlandersoftware": "Also have the same problem\n. Actually after a pile of digging it simple, here is what I did\ntopViewAnchoredGesture = ECSlidingViewControllerAnchoredGesturePanning | ECSlidingViewControllerAnchoredGestureTapping;\n. ",
    "lordkev": "+1 - that change created a worse user experience. Maybe there was an underlying reason for it, but hopefully there's another way it could be fixed.\n. ",
    "Cform": "+1 There is also another PR that dupes this fix with 2 supporters.\n. Seems to be a dupe PR of https://github.com/ECSlidingViewController/ECSlidingViewController/pull/338\n. ",
    "bmezhibovskiy": "+1 on here too. We should probably get rid of one of these duplicate pull requests.\n. This revert fixes the bug. +1\n. ",
    "dillan": "I hope to see this change integrated soon.\n. ",
    "skensell": "I also was considering doing this same PR. Please merge when possible!\n. ",
    "dev4dev": "I think it's dead, it's easier to fork and use own repo. thanks god, we removed this out of project\n. it's redundant condition, isKindOf: already checks that\n. ",
    "JaegyuC": "\u314c\u314d\u314d\u3132 \uc915\u314a\u314c\u314a\u314b \u3147\u314c\n\u3161\u3161\nSent from \n\u3137my iPhone\n\nOn 2014. 6. 1., at \uc624\ud6c4 6:09, Tomoyuki Ishibashi notifications@github.com wrote:\nModified to return to the top tap of the status bar.\nissue\n248 (comment)\nref\nhttp://qiita.com/shobyshoby/items/17925fd488eb3abd63ac\nYou can merge this Pull Request by running\ngit pull https://github.com/basi/ECSlidingViewController fix_scrolltotop_on_statusbar\nOr view, comment on, or merge it at:\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/pull/341\nCommit Summary\nfix scrolltotop on statusbar\nFile Changes\nM Examples/TransitionFun/TransitionFun/MEMenuViewController.m (11)\nPatch Links:\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/pull/341.patch\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/pull/341.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "carlj": "can you please check out the failing test?\n. ",
    "mikaelbartlett": "I'll try to fix the failing test.\n. ",
    "marcelosalloum": "Could you explain that better or paste some lines of code here?\nThanks\n. ",
    "samiramin": "You mean instead of changing ViewControllers from menu you want to do it from Button or any other even in View controller?\nthan you can use Notification\nAdd Notification observer in MenuView controller\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(viewControllerShouldChange:) name:@\"MENU_SHOULD_CHANGE_NOTIFICATION\" object:nil];\nAdd method to handle it\n- (void) viewControllerShouldChange:(NSNotification *)notification {\n  // Get Index of Viewcontroller to which you want to switch\n  int selIndex = [[notification.userInfo objectForKey:@\"selectedIndex\"] intValue];\n  self.selectedStoryBoardID = selIndex;\n// Get Name of story board for that Index\n    NSString identifier = [[self.menuItemsList objectAtIndex:selIndex] objectForKey:@\"storyboard\"];\n    UIViewController newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];\n// Navigate to View with animation.\n    [self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{\n        CGRect frame = self.slidingViewController.topViewController.view.frame;\n        self.slidingViewController.topViewController = newTopViewController;\n        self.slidingViewController.topViewController.view.frame = frame;\n        [self.slidingViewController resetTopView];\n        [self.menuTableView reloadData];\n    }];\n}\n. ",
    "abdulmannanbutt": "Sorry my mistake. I have inherited my UIViewController from another Class.\n. ",
    "MatejBalantic": "First of all, thanks for this great library.\nWhat Ricardo1980 is suggesting is exactly what I would need and for now didn't find a way to do it.\n. ",
    "bernikowich": "You have to implement it yourself. Create ViewController with which will have view controllers cache and some methods to switch controllers. ECSVC implementing another task.\n. ",
    "swizzlr": "Bump!\n. Ready to review/merge! https://github.com/ECSlidingViewController/ECSlidingViewController/pull/368\n. ",
    "ldantona": "Hi @abrahamchez, have you been able to solve this issue?\n. ",
    "samus": "It's easy to replicate with a quick modification to the basic menu sample project.  Add a button to the home scene and a blank view controller to the storyboard.  Then create a push segue between the button and the new view controller.  The error message is:\nBasicMenu[22843:538069] pushViewController:animated: called on <UINavigationController 0x7fd50b913c70> while an existing transition or presentation is occurring; the navigation stack will not be updated.\n. ",
    "senatorsfc": "Came here to report the same thing. Looks like there might be some changes to unwind segues?\n. ",
    "maddoggy1979": "Same here - my menu won't present any new viewcontrollers - just closes the menu and shows the same original view.\nWill stick with running XCODE BETA 4 simulator for the time being - it still works there.\n. I have part of a solution - though someone else may be able to shed light on whether it is technically the best solution. This fixed my menu structure, however I still get the error when trying to perform a segue from the topviewcontroller's tableview.\nAnyway... originally, the process was basically this:\n- Set the new topViewController\n- Slide the top view back in to the main position, ie: menu closed\n  For example:\nOBJECTIVE-C\n [(UINavigationController *)self.slidingViewController.topViewController setViewControllers: [NSArray arrayWithObject: [self.storyboard instantiateViewControllerWithIdentifier:@\"FirstView\"]]];\n [self.slidingViewController resetTopViewAnimated:YES];\nBut, if you swap that process around, it now works ok, ie:\nOBJECTIVE-C\n [self.slidingViewController resetTopViewAnimated:YES];\n [(UINavigationController *)self.slidingViewController.topViewController setViewControllers: [NSArray arrayWithObject: [self.storyboard instantiateViewControllerWithIdentifier:@\"FirstView\"]]];\nAs I said - this may just be a workaround and not the best/final solution.... \nMy complete method which now works for the menu system, is below.\nRemember... this hasn't fixed my tableview segues.\n``` OBJECTIVE-C\n- (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath {\nself.slidingViewController.topViewController.view.layer.transform = CATransform3DMakeScale(1, 1, 1);\nUINavigationController *currentNav = (UINavigationController *)self.slidingViewController.topViewController;\nUIViewController *theControllerYouWant = [currentNav.viewControllers objectAtIndex:([currentNav.viewControllers count]-1)];\nNSString *CurrentSelectedCViewController = NSStringFromClass(theControllerYouWant.class);\n\n///////// moved resetTopViewAnimated to here /////////\n    [self.slidingViewController resetTopViewAnimated:YES];\n////////////////////////////////////////////////////////////////////////////////\n    if (indexPath.row == 1 && ![CurrentSelectedCViewController isEqualToString:@\"FirstViewController\"]) {\n        [(UINavigationController )self.slidingViewController.topViewController setViewControllers: [NSArray arrayWithObject: [self.storyboard instantiateViewControllerWithIdentifier:@\"FirstView\"]]];\n    } else if (indexPath.row == 2 && ![CurrentSelectedCViewController isEqualToString:@\"SecondViewController\"]) {\n        [(UINavigationController )self.slidingViewController.topViewController setViewControllers: [NSArray arrayWithObject: [self.storyboard instantiateViewControllerWithIdentifier:@\"SecondView\"]]];\n    } else if (indexPath.row == 5 && ![CurrentSelectedCViewController isEqualToString:@\"ThirdViewController\"]) {\n        [(UINavigationController *)self.slidingViewController.topViewController setViewControllers: [NSArray arrayWithObject: [self.storyboard instantiateViewControllerWithIdentifier:@\"ThirdView\"]]];\n    }\n/////// IT WAS HERE ///////////\n}\n```\n. @dhanaprakashm\nI have moved on to swrevealviewcontroller.\nhttps://github.com/John-Lluch/SWRevealViewController\nIt works a treat on ios8, is easier to implement and use, and his responses to issues are quick and thorough (I also use the same guy's swrevealtableviewcell). \nI haven't tried using it for a right-side menu though, only a left menu. \n. ",
    "fcy": "I have this problem even without segues. Just use a UINavigationController as ECSlidingViewController's top view controller and try to push something, same error message as @samus posted with or without segues.\n. I haven't filled a bug with Apple because I couldn't find a way to reproduce the problem without using ECSlidingViewController. This is the minimum code that I could find to reproduce the problem:\n```\nUINavigationController *navigationController = [[UIStoryboard storyboardWithName:@\"Main\" bundle:nil] instantiateInitialViewController];\nself.containerController = [[ECSlidingViewController alloc] initWithTopViewController:navigationController];\n// the keyWindow\nself.window.rootViewController = self.containerController;\n```\nAny pushViewController:animated: sent to the navigationController will cause the error:\n\npushViewController:animated: called on  while an existing transition or presentation is occurring; the navigation stack will not be updated.\n. Did anyone find the exact culprit? I'd like to make the smallest sample code possible to report this as a beta 5 bug.\n. @SpruceGoose429 according to the docs (for both iOS 7 and 8) that is the correct approach, return the coordinator only when a transition is happening:\nYour override should typically first check if there is an appropriate transition coordinator to return, and, if there is, return it. If there is no appropriate coordinator to return, call super.\n\nBut seems like we should call super instead of returning nil.\n. :+1: \n. ",
    "jamescmartinez": "+1\n. ",
    "hackfrag": "+1\n. ",
    "zhangxibei": "+1. Have the same problem...\n. ",
    "jon419": "+1 same issue\n. ",
    "tashiro-wni": "+1\n. ",
    "StriderHND": "+1\n. Apple has just released Xcode 6 Beta 6\n. Hi thanks for your response. i already tried in that way but still same issue\n. ",
    "dhanaprakashm": "+1\n. Are we waiting for next Beta version to see this issue is fixed OR expecting an update to ECSlidingViewController library?\n. +1\n. As it seems Apple is very near to release the GM build, I feel we can't wait for an update to ECSlidingViewController to pick iOS8 changes. Do we have a good alternative to ECSlidingViewController that works seamlessly on iOS8 as well?\n. ",
    "almassapargali": "I'm getting this too. also presentViewController:animated:completion: with custom transition doesn't work neither.\n. ",
    "jamesharnett-zz": "+1. Problem with (UISwitch) UIKit: 17545849:_UIScreenEdgePanRecognizerEdgeSettings.edgeRegionSize=13.000000.\n. Agreed - unless it's marked as a known issue in the iOS 8 beta 6 release\nnotes.\nOn Wed, Aug 13, 2014 at 3:34 PM, Thomas Einwaller notifications@github.com\nwrote:\n\nguess we are waiting for Beta 6 to drop next week, if the issue still\nexists it needs to be fixed in ECSlidingViewController library\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ECSlidingViewController/ECSlidingViewController/issues/363#issuecomment-52098723\n.\n. Rejoyce! - Please end the issue.\n. \n",
    "dvmymixtapez": "the same problem, any solution?\n. ",
    "ttruga": "+1\n. ",
    "tompson": "guess we are waiting for Beta 6 to drop next week, if the issue still exists it needs to be fixed in ECSlidingViewController library\n. ",
    "isoya": "+1\n. ",
    "msedlmeier123": "Seems like there will be no iOS beta 6 today. Looks like we'll have to fix this :(\n. ",
    "griffin-stewie": "+1\n. It works for me, Thanks !\n. ",
    "chrizzchrizz": "More and more people think, that the beta 5 could be the last beta before GM. So, what's the plan now? Is there any hope to find the problem or should I look for an other library and change the app to be prepared for iOS 8?\n. ",
    "balord": "The included SDK in Xcode 6 Beta 6 is still iOS 8 beta 5 tho.\n. ",
    "garetmckinley": "I don't know why, but I have a feeling they changed something with UIKit and it's not a bug. I think someone is going to have to find a fix or a new library. It greatly saddens me as I just adopted this library into a project of mine. I may start looking through the changelogs and see if I can make sense of anything, if I find a fix I'll create a pull request.\n\nOn Aug 19, 2014, at 5:19 PM, Brent Lord notifications@github.com wrote:\nThe included SDK in Xcode 6 Beta 6 is still iOS 8 beta 5 tho.\n\u2014\nReply to this email directly or view it on GitHub.\n. But is that workaround working with a UITableView, unlike @maddoggy1979's solution? I'll do some testing with these ideas when I get back to my computer in a bit.\n. @dbachrach your fork crashed my app when trying to perform a dynamic transition, causing an uncaught exception (SIGABRT).\n. @dbachrach I actually realized my mistake immediately after posting, I moved the comment back over here.\n. @dbachrach, my app crashes as soon as I initiate a drag.\n\n2015-01-25 18:35:49.660 FlyBot[14155:722493] *** Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[<MEDynamicTransition 0x7fdb40639690> setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key coordinatorInteractionEnded.'\n*** First throw call stack:\n(\n    0   CoreFoundation                      0x00000001051a1f35 __exceptionPreprocess + 165\n    1   libobjc.A.dylib                     0x0000000104e3abb7 objc_exception_throw + 45\n    2   CoreFoundation                      0x00000001051a1b79 -[NSException raise] + 9\n    3   Foundation                          0x00000001049d77b3 -[NSObject(NSKeyValueCoding) setValue:forKey:] + 259\n    4   FlyBot                              0x0000000102234f2e -[ECSlidingViewController animateOperation:] + 2206\n    5   FlyBot                              0x0000000102233654 -[ECSlidingViewController moveTopViewToPosition:animated:onComplete:] + 276\n    6   FlyBot                              0x0000000102233411 -[ECSlidingViewController anchorTopViewToRightAnimated:onComplete:] + 113\n    7   FlyBot                              0x00000001022332f4 -[ECSlidingViewController anchorTopViewToRightAnimated:] + 68\n    8   FlyBot                              0x00000001021ca3ee -[MEDynamicTransition handlePanGesture:] + 1470\n    9   UIKit                               0x0000000103a962e6 _UIGestureRecognizerSendActions + 262\n    10  UIKit                               0x0000000103a94f89 -[UIGestureRecognizer _updateGestureWithEvent:buttonEvent:] + 532\n    11  UIKit                               0x0000000103a99ba6 ___UIGestureRecognizerUpdate_block_invoke662 + 51\n    12  UIKit                               0x0000000103a99aa2 _UIGestureRecognizerRemoveObjectsFromArrayAndApplyBlocks + 254\n    13  UIKit                               0x0000000103a8fb1d _UIGestureRecognizerUpdate + 2796\n    14  UIKit                               0x0000000103729ff6 -[UIWindow _sendGesturesForEvent:] + 1041\n    15  UIKit                               0x000000010372ac23 -[UIWindow sendEvent:] + 667\n    16  UIKit                               0x00000001036f79b1 -[UIApplication sendEvent:] + 246\n    17  UIKit                               0x0000000103704a7d _UIApplicationHandleEventFromQueueEvent + 17370\n    18  UIKit                               0x00000001036e0103 _UIApplicationHandleEventQueue + 1961\n    19  CoreFoundation                      0x00000001050d7551 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17\n    20  CoreFoundation                      0x00000001050cd41d __CFRunLoopDoSources0 + 269\n    21  CoreFoundation                      0x00000001050cca54 __CFRunLoopRun + 868\n    22  CoreFoundation                      0x00000001050cc486 CFRunLoopRunSpecific + 470\n    23  GraphicsServices                    0x0000000106c029f0 GSEventRunModal + 161\n    24  UIKit                               0x00000001036e3420 UIApplicationMain + 1282\n    25  FlyBot                              0x000000010210ab0e top_level_code + 78\n    26  FlyBot                              0x000000010210ab4a main + 42\n    27  libdyld.dylib                       0x000000010784d145 start + 1\n    28  ???                                 0x0000000000000001 0x0 + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n. Go ahead and try running the TransitionFun example project and select the UIKit Dynamic transition. That will give you the exact same error as displayed here.\n. ",
    "kimhunter": "I've been looking into this problem, ive tracked it down to commenting out one line which should give someone else a head start.\n[self addChildViewContoller:_topViewController]\nThis breaks the menu, but doesn't break the navigation controller.\nBefore the navigation tries to push it gets a conflict which calls back to ec's viewControllerForKey: \nIdeas anyone ?\n. Everything working as normal with this fix, thank you. \n. ",
    "eoinmcc": "@kimhunter's idea combined with hacking the rootVC in \"UIViewController+ECSlidingViewController.m\"\nif(!viewController) {\n   //assuming the slidingVC is the root.\n    viewController = [UIApplication sharedApplication].delegate.window.rootViewController;\n}\nat least allows us to test the rest of our app on 8.\n. ",
    "JosephBacanskas": "I was able to get my apps menus working again by commenting out the line mentioned by @kimhunter and by replacing all \"self\" sends of  dismissViewControllerAnimated: with \"self.presentingViewController\".\n. ",
    "BrunoVillanova": "Thinking in migrate as well.\n. ",
    "SpruceGoose429": "I think I found a solution.  Put this in the .m file that is extending ECSlidingViewController.\n- (id)transitionCoordinator {\n  return nil;\n  }\nApparently this method gets called in the parent when children transition in iOS 8 but not in iOS 7.  So by overriding it and returning nil you bypass the call to it in the ECSlidingViewController class.  Since they have these two methods.\n- (BOOL)shouldAutomaticallyForwardAppearanceMethods;\n- (BOOL)shouldAutomaticallyForwardRotationMethods;\nMaybe they should have a third\n- (BOOL)shouldAutomaticallyForwardTransitionMethods;\nI'm no expert at this stuff so if anyone can give more insight, it would be appreciated.\nedit: apparently i don't know how to format on here.  First post :)\n. Well the way I said you would override it in the subclass.  That way you make no functional changes to ECSlidingViewController.  But glad you like it :)\nedit:  I was wrong.  Overriding it in the subclass is the same as what you had.  Check my comment a few comments down.\n. I think I have a better solution.  The old solution gets rid of the transition coordinator for the ECSlidingViewController.  I'm not sure exactly what that does, but we probably want to keep the logic in there.  So now just go to ECSlidingViewController.m and replace\n- (id<UIViewControllerTransitionCoordinator>)transitionCoordinator {\n    return self;\n}\nwith\n- (id<UIViewControllerTransitionCoordinator>)transitionCoordinator {\n    if (!_transitionInProgress){\n        return nil;\n    }\n    return self;\n}\nI noticed that when doing a menu transition _transitionInProgress was true.  During any other transition it was false.  Still strange that this is getting called on child view controller transitions in iOS 8.  At least this way the logical flow of the class should be the same.  Hope this helps!\n. ",
    "fkoji": "@SpruceGoose429, good solution for me! (Xcode 6 beta 6)\nin ECSlidingViewController.m\n\n- (id)transitionCoordinator {\n    return nil;\n    //return self;\n}\n\n. ",
    "dhersey": "I think the correct approach is:\nc\n- (id<UIViewControllerTransitionCoordinator>)transitionCoordinator\n{\n    // Return self if a transition is in progress (we're the transition coordinator).\n    // Otherwise, defer to super.\n    return ((_transitionInProgress)? self: [super transitionCoordinator]);\n}\nThis is working for me here, and it makes sense based on typical override design (and the docs).\n. ",
    "tonimaxx": "It works great, Thanks :)\n. ",
    "beachbeamer": "Thank you everyone, it works for me too.  I was stuck on this for a whole day.\n. ",
    "eliasturbay": "+1\n@keeshux Did you find a solution to this issue?\n. ",
    "pschneider": "+1\n. Thanks @fjginermontagud \n. ",
    "kschutt": "+1\n. ",
    "andr-ggn": "+1\n. ",
    "fjginermontagud": "I'm using ECSlidingViewController in a Swift project. You only need de -Bridging-Header file to use it with swift:\nHere you can find more info:\nhttps://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html\n. ",
    "blw": "i implemented unwindToMenuViewController but it looks like it can only slide out but not slide back in. so the menu only works one way. anyone else see that happening? \n. ",
    "manchan": "I have the same problem...\n. ",
    "cnrblm": "+1\n. ",
    "kambizn": "\nFollow the warning message by either clicking on the given message or from Navigation Issue.\nRight after @implementation enter the following code :\n\n- (CGAffineTransform)targetTransform  {return self.targetTransform;}\nDo the same thing for every \"in protocol .... not implemented\" warning message and return the appropriate data type.\nI hope this helps.\n~ Kami\n. ",
    "jagajithmk": "I am using a logout option in the side menubar. When i click it logout action occurs, but when a login again the side menubar is visible instead of hidden.\nSwift  code to hide side bar menu on click on tablecell. \n. ",
    "djaygit": "it doesn't work on xcode 7 and swift 2.0\n. ",
    "wojtekcz": "mee too :(\n. ",
    "vittoriom": "I'm afraid there's no simple way, at least that I know of. We had the same problem and ended with creating our own Interactive Transition and forking the repo because of the lack of out-of-the-box support. \nI would be happy to hear from the maintainer that there's an easier and better way\n. ",
    "kevinagu": "Hi @slhodson969 , u can implement the delegate method of ECSlidingViewController from controller where need get the action:\n`- (id)slidingViewController:(ECSlidingViewController )slidingViewController\n                                   animationControllerForOperation:(ECSlidingViewControllerOperation)operation\n                                                 topViewController:(UIViewController )topViewController{\nswitch (operation) {\n    case ECSlidingViewControllerOperationResetFromRight:\n        NSLog(@\"Menu Closed\");\n        break;\n    case ECSlidingViewControllerOperationAnchorRight:\n        NSLog(@\"Menu Opened\");\n        break;\n    default:\n        break;\n}\nreturn nil;\n}`\nI hope it helps.\n. ",
    "madhikarma": "Screenshots\nActual result \n\n\n\n. // Update code - on tap in the underLeftViewController\n\nRedViewController *redViewController = [RedViewController redViewController];\nUINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:redViewController];\nself.slidingViewController.topViewController = navigationController;\n[self.slidingViewController resetTopViewAnimated:NO];\n\n// Setup code in application:didFinishLaunchingWithOptions:\n\n    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    TopViewController *topViewController        = [[UIStoryboard storyboardWithName:@\"Main\" bundle:nil] instantiateViewControllerWithIdentifier:NSStringFromClass([TopViewController class])];\n    UIViewController *underLeftViewController  = [[UIViewController alloc] init];\n    UIViewController *underRightViewController = [[UIViewController alloc] init];\n\n    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapOnLeftViewGestureRecognizer:)];\n    [underLeftViewController.view addGestureRecognizer:gestureRecognizer];\n\n    // configure top view controller\n    UIBarButtonItem *anchorRightButton = [[UIBarButtonItem alloc] initWithTitle:@\"Left\" style:UIBarButtonItemStylePlain target:self action:@selector(anchorRight)];\n    UIBarButtonItem *anchorLeftButton  = [[UIBarButtonItem alloc] initWithTitle:@\"Right\" style:UIBarButtonItemStylePlain target:self action:@selector(anchorLeft)];\n    topViewController.navigationItem.title = @\"Layout Demo\";\n    topViewController.navigationItem.leftBarButtonItem  = anchorRightButton;\n    topViewController.navigationItem.rightBarButtonItem = anchorLeftButton;\n    topViewController.view.backgroundColor = [UIColor whiteColor];\n\n    UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:topViewController];\n\n    // configure under left view controller\n    underLeftViewController.view.layer.borderWidth     = 20;\n    underLeftViewController.view.layer.backgroundColor = [UIColor colorWithWhite:0.9 alpha:1.0].CGColor;\n    underLeftViewController.view.layer.borderColor     = [UIColor colorWithWhite:0.8 alpha:1.0].CGColor;\n    underLeftViewController.edgesForExtendedLayout     = UIRectEdgeTop | UIRectEdgeBottom | UIRectEdgeLeft; // don't go under the top view\n\n    // configure under right view controller\n    underRightViewController.view.layer.borderWidth     = 20;\n    underRightViewController.view.layer.backgroundColor = [UIColor colorWithWhite:0.9 alpha:1.0].CGColor;\n    underRightViewController.view.layer.borderColor     = [UIColor colorWithWhite:0.8 alpha:1.0].CGColor;\n    underRightViewController.edgesForExtendedLayout     = UIRectEdgeTop | UIRectEdgeBottom | UIRectEdgeRight; // don't go under the top view\n\n    self.slidingViewController = [ECSlidingViewController slidingWithTopViewController:navigationController];\n    self.slidingViewController.underLeftViewController  = underLeftViewController;\n    self.slidingViewController.underRightViewController = underRightViewController;\n\n    // enable swiping on the top view\n    [navigationController.view addGestureRecognizer:self.slidingViewController.panGesture];\n\n    // configure anchored layout\n    self.slidingViewController.anchorRightPeekAmount  = 100.0;\n    self.slidingViewController.anchorLeftRevealAmount = 250.0;\n\n    self.window.rootViewController = self.slidingViewController;\n    [self.window makeKeyAndVisible];\n\n    return YES;\n\n. ",
    "eytanbiala": "@madhikarma  Did you find a solution for this?\n. ",
    "yume190": "@enriquez \nMy solution\nself.slidingViewController.underLeftViewController  = menuViewController\nself.slidingViewController.topViewController  = mainViewController\nMenuController(viewDidLoad)\nself.edgesForExtendedLayout = UIRectEdge.None\nMainController(viewDidLoad)\nself.edgesForExtendedLayout = .None\nself.navigationController?.edgesForExtendedLayout = .None\n. ",
    "simonlinj": "@yume190\nthanks for sharing, but how to you handle when in call status bar is toggled? I'm seeing a status bar with grey background instead of the extension of the navigation bar\n. @patdnk \nthanks man!  it worked for me\n. just for reference, this is the commit to fix the problem: 356f6994ce594e9ac40f7af443823300fe5e0e1f\n. ",
    "patdnk": "This is how I applied fix for the topViewController:\nAdded this:\nobjective-c\nif ((self.topViewController.edgesForExtendedLayout & UIRectEdgeAll) && [UIApplication sharedApplication].statusBarFrame.size.height > 20.f) {\n        CGFloat topLayoutGuideLength = [self.topLayoutGuide length];\n        containerViewFrame.origin.y     = topLayoutGuideLength;\n        containerViewFrame.size.height -= topLayoutGuideLength;\n    }\nin \nobjective-c\n- (CGRect)topViewCalculatedFrameForPosition:(MenuSlidingViewControllerTopViewPosition)position\nbefore \nobjective-c\nswitch(position) {\nI reckon it will be similar on the underRight and underLeft VCs. To make things more complex you can always apply notification observer for \nUIApplicationWillChangeStatusBarFrameNotification\nUIApplicationDidChangeStatusBarFrameNotification\n. ",
    "rsenerol": "I actually need the same feature. I tried to implement something but there is always something wrong at some point... \nThat would be very nice to have a method for hiding completely the topViewController in order to have the right/left viewcontroller view full screen.\n. ",
    "mdeliraAETV": "I ran into the same issue when updating from a much older version of ECSlidingViewController.  I believe it was previously possible to do this using ECVariableRevealWidth.\n. ",
    "JSilverstein": "I have run into this same issue and I'm wondering if anyone has found a workaround. Thanks. ",
    "g0re": "Got it.\nI just modified the fullViewBounds method:\n``` objective-c\ndefine SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)\n\n\n(CGRect)fullViewBounds\n{\n    CGFloat statusBarHeight = 0.0f;\n     BOOL isIOS8 =  SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@\"8.0\");\n/\n Enable legacy screen height support if we are running on an SDK prior to iOS 7\n and thus does not support the backgroundRefreshStatus selector on\n UIApplication, which was introduced in iOS 7\n /\nUIApplication sharedApplication = [UIApplication sharedApplication];\nBOOL legacyScreenHeightEnabled = ![sharedApplication respondsToSelector:@selector(backgroundRefreshStatus)];\nif (self.shouldAdjustChildViewHeightForStatusBar || legacyScreenHeightEnabled) {\n    statusBarHeight = sharedApplication.statusBarFrame.size.height;\n    if (UIInterfaceOrientationIsLandscape(sharedApplication.statusBarOrientation) && !isIOS8) {\n        statusBarHeight = sharedApplication.statusBarFrame.size.width;\n    }\n}\nCGRect bounds = [UIScreen mainScreen].bounds;\nif (UIInterfaceOrientationIsLandscape(sharedApplication.statusBarOrientation)) {\n    CGFloat height = CGRectGetWidth(bounds);\n    CGFloat width  = CGRectGetHeight(bounds);\n    bounds.size.height = (isIOS8)?width:height;\n    bounds.size.width  = (isIOS8)?height:width;\n}\nif (! legacyScreenHeightEnabled) {\n    // In iOS <= 6.1 the container view is already offset below the status bar.\n    // so no need to offset it if we use shouldAdjustChildViewHeightForStatusBar in iOS 7+.\n    bounds.origin.y += statusBarHeight;\n}\nbounds.size.height -= statusBarHeight;\nreturn bounds;\n}\n```\n\n\nCheck it out, please :)\n. Another change...\n``` objective-c\ndefine SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)\n\n(UIView *)statusBarBackgroundView\n{\n    if (! _statusBarBackgroundView) {\n        BOOL isIOS8 =  SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@\"8.0\");\n        CGRect statusBarFrame = [UIApplication sharedApplication].statusBarFrame;if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation)) {\n    CGFloat width = CGRectGetHeight(statusBarFrame);\n    CGFloat height = CGRectGetWidth(statusBarFrame);\n    statusBarFrame.size.width = (isIOS8)?height:width;\n    statusBarFrame.size.height = (isIOS8)?width:height;\n}\n\n_statusBarBackgroundView = [[UIView alloc] initWithFrame:statusBarFrame];\n_statusBarBackgroundView.autoresizingMask = UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth;\n_statusBarBackgroundView.userInteractionEnabled = NO;\n[self.view addSubview:_statusBarBackgroundView];\n\n}\nreturn _statusBarBackgroundView;\n}\n```\n. Ok. So, everything's ok for a PR?\n. \n\n",
    "antoinebis": "Thanks a lot for this :+1: \n. ",
    "gespona": "I've the same issue but I can not found any fullViewBounds method to change ... What I'm missing?\n. I found the reason of the bug. Just for anyone with the same issue:\nIf you don't setup launch image for iPhone6/iPhone6 Plus the app will run in special scaled mode (like zoomed) and there is a bug in landscape mode.\nJust setup the launch image.\nRegards,\nGerard Espona\n. ",
    "danloughney": "I've implemented both of these changes with success.  Thanks!\n. ",
    "weien": "@gespona I used this solution. Just add the iOS7StyleScreenBounds method. Then, look for instances of \"[UIScreen mainScreen].bounds\" and replace them with [self iOS7StyleScreenBounds].\n. Lovely, thanks!\n. ",
    "jamiebullock": "If I understand the question correctly, you need to set anchorRightRevealAmount or anchorLeftRevealAmount. See http://cocoadocs.org/docsets/ECSlidingViewController/2.0.2/Classes/ECSlidingViewController.html#//api/name/anchorLeftRevealAmount\n. ",
    "nnorris7": "If I am following your question, I believe the property currentTopViewPosition is what you are looking for. It equals 1 when the top view is anchored to the left/right and equals 2 when it is not. So I have code that looks like:\nif (self.slidingViewController.currentTopViewPosition == 1) {\n...\n}\n. ",
    "louenas": "the problem was caused by inadvertently using a background thread to manipulate the UI\n. ",
    "tonklon": "+1\nalso look here for more in depth information: http://stackoverflow.com/questions/24150359/is-uiscreen-mainscreen-bounds-size-becoming-orientation-dependent-in-ios8\n. ",
    "fabb": "oops, wrong branch\n. ",
    "allenlinli": "It seems works only on static tableView.\n. ",
    "sampayo": "Someone know how fix these warnings??? \n. ",
    "paulofierro": "As @biznickman and @GantMan pointed out in https://github.com/ECSlidingViewController/ECSlidingViewController/issues/246 there are ways of closing the menu which don't let you pass a completion block.\nI found that the easiest way to go was to subclass EFSlidingViewController and post my own notification at the end of completeTransition: like so:\n``` objc\n- (void)completeTransition:(BOOL)didComplete\n{\n    [super completeTransition:didComplete];\nif (self.currentTopViewPosition == ECSlidingViewControllerTopViewPositionCentered)\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationMenuClosed object:nil];\n}\n\n}\n```\n. @Monserg: glad to hear it :+1: :)\n. ",
    "Monserg": "Hi, paulofierro.\nThanks for you solution.\nI use it in my project to notify event \"swipe complete - left position\".\n. ",
    "dms90": "Great @paulofierro :). I can't understand how this is not implemented by default\n. ",
    "bitomule": "I'm having the same issue, did you find a fix for it?\n. I'm not having the issue on real device, seems like it's only on simulator.\n. ",
    "joshoconnor89": "https://github.com/MichiganLabs/ECSlidingViewController/commit/8477a7c7a82991e442db9227451b0a901d15c40c. This was the solution to my issue. I have no problem posting a video of this or exact code if it helps.. Been a pain in my ass for 5 days.  Can you please look at this?  http://stackoverflow.com/questions/42126073/interactive-pop-gesture-creating-black-screen-ios?noredirect=1#comment71420914_42126073. https://github.com/ECSlidingViewController/ECSlidingViewController/pull/447 <-- Solution. ",
    "cooler333": "or move status bar, like in mailbox?)\n. ",
    "jhanzo": "Hi, any idea for this issue ? \n. ",
    "codepushr": "Having the same issue. Where can I change this?\n. Oh, turnes out it's quite simple!\nself.slidingViewController.topViewAnchoredGesture = ECSlidingViewControllerAnchoredGestureTapping | ECSlidingViewControllerAnchoredGesturePanning;\n. ",
    "xxjh": "I have the same question.how to solve.any body can help?Thank you.\n. ",
    "chris284": "Not a true solution, but may work in some circumstances. \nSearch for \"UITabBarController+ShowHideBar.m\", you need to use it's \"setHidden\" method. It's a simple category class. Find the code and use it.\nIf you are pushing A -> B, then in A's viewWillAppear you will want to do [self.tabBarController setHidden:NO]; //setHidden is from the +ShowHideBar category.\nIn B's viewWillAppear, you'll want something like this...\nif (CGRectGetMaxY(self.tabBarController.tabBar.frame) - (CGRectGetMaxY(self.view.frame)) == CGRectGetHeight(self.tabBarController.tabBar.frame)) {\n    [self.tabBarController setHidden:YES];\n    self.constraintTableViewBottomToSuperViewBottom.constant -= CGRectGetHeight(self.tabBarController.tabBar.frame);\n}\n. ",
    "phongleq": "You would need to tweak the library a bit to include the edge pan. Currently the interactive transition is tied to panning. \n. ",
    "batschz": "Same for me - its happening randomly\n. ",
    "raymondkam": "Working for me on iOS 8 and iOS 9.\n. ",
    "KazuyoshiUeno": "Thanks a lot. works for me!\nWhy don't you merge this pull request ?. ",
    "gurtejsingh": "hi, I am getting the same error even when using a storyboard. Were you able to fix this at your end? Any help would be really appreciated! Thanks.\n. Any luck with this issue any one??? Please do help!\n. ",
    "macgeekpro": "Refer to How do I dispatch_sync, dispatch_async, dispatch_after, etc in Swift 3?\n. ",
    "offfffz": "I'm sorry :'(\n. ",
    "DisruptiveMind": "@jamiebullock I had ran into this requirement and needed to wrap the ECSlidingViewController's detectPanGestureRecognizer\n``` objective-c\n- (void) panGestureHandler:(UIPanGestureRecognizer *)recognizer {\n    [self.slidingViewController performSelector:@selector(detectPanGestureRecognizer:) withObject:recognizer];\nif (recognizer.state == UIGestureRecognizerStateEnded) {\n    DLog(@\"Ended\");\n}\n\n}\n```\n. ",
    "astub": "I've confirmed this same issue. Resolved here pull request #425. \n. Please note that this is the same issue as ticket #438.\nResolved here pull request #425. \n. No, I have not seen this. Test with the demo.\n. ",
    "ReFiRnE": "Same for me on iPhone 5s, on my another iPhone 5, works okay also another iPhone 5s.\n. ",
    "sasojadrovski": "I have the same problem with the flicker. Everything is fine on iPhone 5, running iOS 9.1, but on iPhone 5S and 6, running iOS 9.2, the problem exists. @enriquez please have a look asap. Many thanks!\n. ",
    "cbarbera80": "HI. Is there a fix for this issue? Thanks. ",
    "awadhawan": "@aaronwardle - Did you ever figure out how to do this?\n. ",
    "mamaral": "It appears as though there is no support for RLT languages, but I was able to override the left/right layouts myself programmatically. Using User Defined Runtime Attributes won't work as I don't believe there's a way to set these dynamically on launch.\n. ",
    "iDevelopper": "No. ",
    "DaveCole": "never mind I think there's something weird going on with the chain of navigation leading up to that call....  I need to dig deeper to understand what's really leading up to the crash.... ",
    "inzinga": "Turns out I needed to supply an iPhone X Portrait iOS 11+ LaunchImage to get this working.. "
}