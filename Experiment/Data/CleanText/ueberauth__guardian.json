{
    "hassox": "Thanks! There's a merge conflict, but in the updated README this typo is no longer there.\n. I'm not sure what the done thing is in elixir yet so I'm totally open to suggestions. I wanted a way to differentiate between Plug and Channel. I have a branch on my local that has channel support which, unsurprisingly is namespaced under Guardian.Channel.\nIf you think Conn is more appropriate I'm down.\n. Yes. I can push the in-progress stuff up to a branch if you want to take a look.\n. https://github.com/hassox/guardian/tree/add-channel-integration\n. Not sure that I understand the difference between String.to_existing_atom + on failure String.to_atom and just calling String.to_atom in the first place.\n. Thanks!\n. Hey @zmoshansky. I'm not sure yet if strategies are a good fit for Phoenix/guardian. Strategies were always problematic in warden. Omniauth presented a different way to achieve a similar result that often felt cleaner. Strategies require a lot of generalization for what is essentially a pretty simple setup. At this stage, I'm thinking that a strategy would be essentially a plug. It would take a lot of care to make sure it was general enough and I think by that point, it's probably more concise and less confusing to just write a plug for your scenario.\nLog story short, I don't think they belong yet. I could be convinced, but it feels like elixir/Phoenix is different enough from rack/ruby that I'm just not sure they're a good fit.\n. Not specifically an omniauth equivalent but there is https://github.com/scrogson/oauth2 for oauth2. I've been thinking about something like this too. Still letting it percolate.\n. Thanks @doomspork!\n. Thank you. I do need to add :pems to that list, I overlooked that one. \nThe reason I chose atoms! Is because joken currently requires atoms, but since they're not garbage collected I don't just want to instantiate any old input. \nAs a work around when I'm adding custom claims, I put a list of expected claims into the guardian config to pre-load them.\nconfig :guardian, Guardian\n     atoms: [:one, :two]\nI agree that it's less than ideal, but without quite a few changes to joken (and maybe even key lists) it's atoms at the moment.\n. I'd love to use strings as keys with joken. Way less issues and craziness to worry about. Joken had a pretty major change recently so it could work out of the box with strings where I only have to change Guardian. \n. Thanks @bryanjos. I'm going to try and move over to string keys shortly since atom keys are problematic when accepting keys generated by others\n. I have just updated Guardian to 0.5.0 to use string keys rather than atom keys. \nPlease note that claims are provided now using strings rather than atoms where you're using them.\n. Hey @erneestoc I'm not quite sure what you're asking. Keeping a session for longer than a browser session is related to how the cookies are setup for the session. \nThe tokens that Guardian generates should work just fine across app-restarts. \n. ok so there's no phoenix session being involved here. How are you making your call?\nCan you add a plug in-between the VerifyAuthorization and EnsureSession and dump the headers to see what's making it there?\n. oh. Sorry I misunderstood the problem. This is due to the current setup of using atoms as keys https://github.com/hassox/guardian/issues/13\nTo sort this please ensure to include a list of atoms in your config that your app uses in its claims. Guardian sets up a few for you  [:iat, :aud, :sub, :exp, :iss, :pems].\nconfig :guardian, Guardian,\n           atoms: [:pem, :something_else]\n           ....\nIn guardian Poison is currently setup to use existing atoms (:erlang.binary_to_existing_atom) so these must be declared prior to trying to verify a token. By declaring these atoms early in your config, they're available. \nThere is an outstanding issue to transition to string keys rather than atom keys for claims.\n. This has been updated in 0.5.0. Guardian now uses string keys rather than atom keys.\n. Hey @keichan34 I've just updated this in another set of work. Thanks for the PR!\n. Hey @amarsahinovic I've just updated most of these (excluding ex_doc). I can either update that one, or if you want to update your PR I'll bring it in.\n. This would be a breaking change. See the Guardian.Plug.LoadResource plug. \nCan you give an example of when the full claims would be useful? I'm pretty open if there's a good use case. We'd need to work out a way to move forward with such a change.\n. The current fom_token method doesn't expect the claims, only the entry in the sub field. If you look at the load resource plug:\ncase Guardian.serializer.from_token(Dict.get(claims, \"sub\")) do\nThe sub field is the only one that is passed along. The example in the readme is correct for how the library works at the moment.\n. Doh! I totally read this in reverse. Thanks for the patience explaining it!\n. @bbhoss this was part of a joken thing which I'm now removing. Making it so that keys are strings not atoms. I will at the same time remove that print\n. This has been removed in Guardian 0.5.0\n. There was a choice to make for permissions that are introduced in the future, so that you have a generated token, then introduce a new set of permissions it still works.\nThinking about this in the cold light of day though, that does seem ass backwards ;) \nWould you feel comfortable pushing up a PR? I'm working on another part atm so I can add it to my list, but it will be a while before I get to it.\n. That sounds great :)\nIf you can put a PR together it will get in faster, otherwise I'll add it to my list.\n. @bbhoss can you elaborate a bit. I'm not sure what you're thinking of.\n. Hi @oscarduignan. I think this is because in the SessionController#new function, when you call render you'll need to supply it with the view.\nrender conn, Session.View, 'new.html', stuff: 'and things'\nUnfortunately by the time we get to the view the connection has already cached what view it's going to use by default so you'll need to be explicit.\nHTH\nDaniel\n. Great to hear :) I always love help with Guardian. Good luck with Phoenix.\n. Thinking this should be a simple equality check. \n. Hi, You're adding your permissions to the 'admin' set, but when you're checking them you're seeing 0 because it's looking in the default set.\nGaurdian.Permissions.to_value([:users], :admin)\nHow are you setting your permissions on token generation?\n. No not the serializer. The point where you generate your token. It's either:\nGuardian.Plug.sign_in\nor\nGuardian.encode_and_sign\n. I think I may have found it. \niex(1)> Guardian.Permissions.to_value([:users], :admin) \n1\niex(2)> Guardian.Permissions.to_value([:users], \"admin\")  \n0\nThis is likely a problem since the string keys came in. Will get a fix out asap\n. LGTM. Just a couple of places where there could be either a map or KW list.\n. The stringify keys could be getting a keyword list from arguments. If we make sure that those places are all good I think we should be ok. We'll just have to Enum.into a map before calling stringify keys.\n. This is aging. I've been cleaning the Dict calls up as I come across them. Please update this PR if you want me to bring it in. :+1: \n. sorted in https://github.com/ueberauth/guardian/pull/77\n. Hey @lexmag do you have an example of where in the code you mean?\n. Hi @efries I decided to move away from Joken. Their API changes are too drastic considering that I'm only using it for encoding and decoding. I've put a PR together at https://github.com/hassox/guardian/pull/62 if you'd like to take a look :D\n. Hi @Pjino. What version are you currently using? Can I see your config for guardian?\n. Thanks. Just an FYI you have two hooks declared. \nThe reason you're seeing the -1 is because you're setting the default permissions to Guardian.Permissions.max in sign in. If you had this instead do you still see -1?\nGuardian.Plug.sign_in(user, :token, perms: %{ default: [:write_profile] })\n. I haven't been able to repeat this locally :( I'm guessing that you're running Guardian 0.6.1 which was a bit buggy. GuardianDb was requiring this version. I've updated GuardianDb to rely on 0.6.2 in v 0.1.2. Can you please update guardian db and guardian and see if you still have the same issue?\n. Phew! Thanks so much for looking into it :)\n. He @DeodorantMan \nYou don't need to create a phoenix session to use it. The first step is to create the token:\nGuardian.encode_and_sign(user, :api)\nThis will give you the token, then in your pipeline somewhere use the Guardian.Plug.VerifyHeader plug. This will check for a present token. You can also use the Guardian.Plug.LoadResource plug after that to fetch your user.\nCan you provide code for you router and controller?\n. Hi,\nHow are you putting the header in on your client? It should be\nAuthorization: Bearer <jwt>\n. Great! Glad it worked out for you :)\n. I've added a new function to Guardian.Plug to help with signing into api endpoints. \nThis new function does the same as the Guardian.Plug.sign_in function with the exception that it doesn't try and put things in the session.\nGuardian.Plug.api_sign_in(<same as sign_in)\nThis sets the JWT, claims and resource into the connections assigns. The decision of if you should use the session variant or not should fall within the pipeline that you're expecting to use for the request.\n. Hi @vernomcrp. When you're logging out of a session it depends on if you're using something like GuardianDb to keep track of tokens you have out in the wild.\nIf you're not using GuardianDb or something similar, then on your client just forget the token. If you have a token and it checks out then it is valid. If you want something more robust, that's what GuardianDb was developed for.\nWhen using GuardianDb, to logout a session you should use the Guardian.revoke! function which will cause the token to be deleted from the db. This will make that token invalid in the future if someone tries to use it again.\n. Whoa thankyou! \n. eep I don't want to force push to master :\\ I'm happy to start them moving foward though. Is there a good way to backfill? I'm not sure which point in code the revisions were cut.\n. I'm actually in the process of updating phoenix_guardian atm! I can push up to a branch what I have so far if you want to hack on it too :)\nIf you think we can get to releases from where we are then cool but please don't break anything :|\nHow can I help?\n. @joelfperion I agree. I'd love some other way to pas up the error. Perhaps a call to a logger or just pass it back?\n. sounds good. Merged the PR\n. Thanks. Not sure what's going on but I'll look into it \n. This is working now :) Thanks for the heads up\n. Hi @joshwlewis. Perhaps we could pass an option into load resource where when it can't find one it calls the handler? Perhaps even the presence of a handler option would tell it to call some action?\n. @joshwlewis just checking in on this. Did you need some help?\n. No problem @joshwlewis I was just going through issues and wanted to touch base.\n. Perhaps allow reading an unverified header so that an identifier can be put in the header to look up the secret. The secret could then be found and the token can be verified\n. oh this one is done!\n. I'm not sure if they're available in the template but private is a much better place for it. I wrote guardian as a noob and didn't know any better. Do you think you could put a or together? I'd totally merge a move to private\n. Hey. What do you have in your view? Its pretty good practice to pass the token in, but you can look it up from the conn object in views. \nI'm assuming that you normally comment out the current_token and inspect calls in your screen grab\n. @ramstein74 the conn struct is immutable. You need to save off the new one after you sign in.\n``` elixir\nconn = Guardian.Plug.sign_in(conn, user, :csrf)\nrender conn, \"index.html\", token: Guardian.Plug.current_token(conn)\n```\n. oh that's a good point. The GuardianPermissions module is dynamically generated. I'm not sure how to watch for changes in the config and re-generate. That's an interesting challenge though.\n. Quick update on this. I've looked into getting some code reloading happening, and while it's very possible, it still doesn't help with partial compilations like tests. Only in dev. I'm going to take a stab at refactoring the permissions module to be a more run-time set of functions rather than compile time definitions.\n. You can apply your hooks in prod, staging and dev if you want and leave it out of test. Would that work for you?\n. You can use a combination of setup and on_exit to remove the hooks.\nelixir\nsetup_all do\n  hooks = Application.get_env(:guardian, :hooks)\n  Application.put_env(:guardian, :hooks, nil)\n  on_exit(make_ref, fn -> Application.put_env(:guardian, :hooks, hooks) end)\n  {:ok, []}\nend\nI think something like that would do what you're looking for.\n. so many typos :( I'm the king of them I'm afraid. Thanks so much for going over this. \n. Hey @victorlcampos I'm happy for a project that works similarly to devise. It's not really my thing right now though but please feel free to use the code you find on my blog or in example apps to get you going.\n. This is nice! thankyou. I'm not sure about the with call. I've been wondering that myself but the bump to 1.2. I think it's probably ok to require an upgrade to 1.2. I don't imagine there's much left that is on 1.1 at this point. I'd be down for the bump to 1.2 on a different PR which we can then bump as a definitive version number.\n. Putting the value into the session is a bit of a pain. A backdoor would be awesome :D\n. cool \n. @aphillipo Down the bottom of http://blog.overstuffedgorilla.com/simple-guardian/ there's a way to work with session stored tokens. The backdoor middleware will make this dance much simpler.\n. Hey @simonh1000 you can see some walkthroughs on the overstuffed gorilla blog. For example: http://blog.overstuffedgorilla.com/simple-guardian-api-authentication/\n. @aaronrenner @doomspork updated with your feedback. Thanks :D\n. I'm going to wait for the dogma branch to land before I merge this. Thanks for the feedback! \n. Rebased on the dogma changes. Merging\n. It seems like there might be quite a few people still on 1.1. I've asked ericmj for the stats but he needs to go to the CDN logs to find out. I'll come back to this when I have more information.\n. Eric got back to me. The stats for 26 Jan 2016 are here: https://gist.github.com/ericmj/71a37168e761cb7bbf63\nEric said to ignore the 0.13, that's from one IP that is now banned. Also, he said to bear in mind that lots of these are probably CI environments. \nGiven that this is only one days worth, it seems that there is still significant < 1.2 usage going on :(\n. @aaronrenner I don't think we can do this yet after the data that we saw from eric. Thoughts?\n. I'd love to setup travis. I don't know squat about setting it up though. I'm going to defer to @doomspork on this one. super +1 from me though.\n. Worked through this. Seems the fetch polyfil does not allow the session cookie to be sent. \n. I'm down for this! are there any outstanding style issues that I should fix as part of this?\n. Sounds great. Let me know if you want me to try and tackle them.\n. This is awesome :D I just saw that missing default the other day too, great timing!\nAlso, it needs a rebase.\n. :metal:\n. :+1:\n. Nice catch! \nTwo quick things. Can you run dogma to remove the dogma warnings.\nmix dogma\nTBH I'm flexible on the 80/120 limit, @scrogson and @doomspork really control that. I'll chat with them and see where we can get to.\nand could you also please update the Changelog \nThanks for all the great PRs!\n. This all LGTM. I'm going to merge. Happy to have the changelog be 'Master' for now. We can always change it if we want later.\n. Good idea. This seems like a great add. What would you do in the case where someone is logged in?\n. :+1: sounds good. are you comfortable putting up a PR @victorlcampos?\n. This has been merged. Thanks @victorlcampos!\n. I love the idea of generators, but I think of guardian as a core style lib. I don't think it's appropriate to guide people in a particular direction in the core lib, but stoked to see that generators are being built on top of it. I think (at least in the near term) that a separate repo like gen guardian is great to have.\n. I think sentinel is doing something similar. You might want to pool your time with them (or not)\nhttps://github.com/britton-jb/sentinel\n. LGTM. Only one thing left. Please add an entry to the changelog that explains the change.\nOnce that's in, lets merge :D\n. Sure, something like:\n* Adds an EnsureNotAuthenticated plug to handle times when you want to make sure someone is _not_ authenticated. See Guardian.Plug.EnsureNotAuthenticated\n. What you have is fine :D\n. <3 this is great!\n. LGTM\n. Hey @Hanspagh. Guardian provides a refresh! function. Checkout Guardian.refresh!\n. Refresh tokens are tricky. There's a couple of ways to do them that spring to mind.\n1. Create a non-expiring token containing/mapping the 'claims' and store it in the db. When issuing a JWT from it, use the claims from the refresh token and encode them into an access token. This requires that you have a database and lookup the refresh token. This method would be outside the scope of Guardian since you'd have to maintain some state on your server.\n2. Create a token with Guardian of type 'refresh' that has a long expiry (years) containing all claims required. You can then use this token to exchange for a type of 'access' containing the same claims with a much shorter exp. This does not require you to store the token in a db - although you should probably use something like GuardianDb so that it can be revoked. This would require the addition of an 'exchange' function in guardian so that you could exchange one type of token for another. \nI'd be down for adding an exchange function I think. It's been on my todo list for a while I just haven't had the motivation to actually write it.\nThoughts?\n. @Hanspagh I'd be happy to review something for #1 but I don't think it should go into the Guardian lib. \n. I think it should be a separate lib like guardian db \n. Sounds great. I'd love to see it when you have something.\n. Thanks folks. Merging. I'm going to cut a release at 0.10.1\n. I just pushed up this change inside https://github.com/ueberauth/guardian/pull/115\n. @aaronrenner do you happen to know the Magic Config to get it to lint the tests? I think we should probably include those\n. Thanks for the pointer. I'll pick it up on the train into work in the am\n. hey @gaynetdinov \nLocal storage definitely seems like the thing you want to use here. I think there's a couple of ways I'd handle this. \n1. Make the client use Header based (API style) authentication always. This is great if you're using a single page app and all your requests are done over ajax. Not so good if you have normal server generated pages with straight up HTTP\n2. Provide your client with a \"re-login\" method, which it looks like you have. This would look like\n   1. open the app\n   2. If there's a token in local storage\n   3. Shoot a request using the token in the header to the 'relogin' endpoint\n   4. The relogin endpoint would log the user into the session\n   5. In your router pipeline allow both session and header verification\nThe challenge with the 2nd is you have to do it on each page re-fresh. How do you know if you're already logged into the session. \nI'd tend to lean towards the first option because it minimizes the weirdness. Option 2 is had to keep in sync and you'll need a bunch of extra stuff to try and keep on top of it.\n. @aaronrenner nice. \nCouple of thoughts. Do you think we should just be passing the sub field in to create a full token? It seems like this would not allow us to include things like permissions or other claims to be included in the bypassed token. \nWhat would you think of either passing in the full token via the url or header and using that to sign in? The Verify* plugs are really just for locating and verifying a token from somewhere. I was thinking that this might be similar. A bypass plug would locate the token from X location and load it into the current connection/session.\nThoughts?\n. I think that sounds reasonable mate. I was a bit torn with putting it in the url but I think it makes sense if someone's using hound or similar.\nOne of the issues with using Guardian.Plug.encode_and_sign in this plug is that it would change the jti, iat and exp which would probably be bad. \nI think this needs to:\n1. Decode and verify the token\n2. Put all the relevant assings onto the conn object\n3. Store the token on the session\n4. Remove the jwt from the params\nI think if we just use encode_and_sign in the bypass plug we'll end up with a different token than the one passed in.\n. Thanks for the report!\n. Unfortunately I don't think this will quite address the bug. I've pushed up another PR at https://github.com/ueberauth/guardian/pull/127 Can you please take a look and let me know what you think.\n. @potatosalad this looks great! Any chance you could update the README with some words on it?\n. This is so much awesome :D I'm sorry I forgot just one thing. We need an entry in the CHANGELOG then I think we're good to go :D \nThankyou so much!\n. Thanks @bgentry! Updated README is here https://github.com/ueberauth/guardian/pull/128\n. The key in the permissions allows you to have multiple sets of permissions. Usually these sets would be for different purposes.\nWhen you generate your permissions into your JWT you need to include the permissions that you'll need in your actions. key is unrelated to permissions and provides a mechanism to have multiple logins on the same connection named by key. The key doesn't make it into the token it only tells Guardian where to look for it and where to store it.\nSo for the example where admin can update but users can update_self - when you generate your admin token you'd use something like:\nelixir\nGuardian.Plug.sign_in(user, :token, perms: %{ admin: [:update], default: [:update_self] })\nFor your normal user you'd use:\n```\nGuardian.Plug.sign_in(user, :token, perms: %{ default: [:update_self] })\nOR\nGuardian.Plug.sign_in(user, :token, perms: %{default: Guardian.Permissions.max})\n```\nThe map of permissions provides different sets of permissions. When you EnsureAuthenticated it makes sure that you have all permissions before you're able to complete the request.\n. If there's nothing else required on this one I'm going to close it out. Please re-open if there's more you need.\n. When the README talks about 'locations' it's talking about:\na. Where guardian will look for the token in the session\nb. Where it will store it in the connection\nThis allows you to have multiple logins on the same connection for purposes like impersonation or 'more secure' logins at the same time as your normal login.\nFor example:\nGuardian.Plug.claims(conn) will fetch the claims from the conn in guardian_default_claims while Guardian.Plug.claims(conn, :secret) will fetch the claims from conn in guardian_secret_claims. \nThis is just a mechanism to allow multiple token/claims/resource on the one connection simultaneously. \nDoes that make sense?\n. Pretty much. Both in the session, and on the conn object.\n. @manukall sorry for the delay. The reason it needs to go into a tuple is because it's completely unknown where it's coming from. Api, memory, db. The tuple provides a way to find out what happened in the case that something when wrong. I think the better option would be to make sure that set_current_resource wraps it in a tuple when it puts it in there..\n. @ospaarmann The new secret key stuff in the readme is not yet released which is why you'll be having some trouble with it. I'll try and get a release cut soon to update the released guardian to match the readme.\n. Guardian 0.11.1 has been released with all the new JWT goodness.\n. @ospaarmann The README shows what's currently in master which is not yet released. I'll try and get a release out shortly.\n. Guardian 0.11.1 has been released with all the new JWT signing goodness!\n. Thanks for the bug report!\n. It is possible. The approach I'd use is to store a specific type of token with a long ttl that can't be used elsewhere (think refresh token). Then write a plug to look this up and create a new access token for the session. \nelixir\n{:ok, token, claims } = Guardian.encode_and_sign(user, :remember)\nconn = Plug.put_resp_cookie(\"remember_me\", token)\n...\nThat's on the way out. On the way in, check your session first with Guardian.Plug.VerifySession, then use a different plug that if verify session resulted in a session being loaded does nothing, but if not, check the remember_me cookie for a token and create a new token based on it for the session.\nDoes that make sense?\n. Lgtm\n. Correct it's a tuple. The reason is that when decoding the token we can have an error.\n. If we don't specify one_of we should still honor current behaviour. I think should do it but I haven't tested.\nelixir\nif Map.get(opts, :one_of) do\n  perm_sets = Map.get(opts, :one_of)\nelse\n  single_set = Map.drop(opts, [:handler, :on_failure, :key, :one_of])\n  if Enum.empty?(single_set) do\n    perm_sets = []\n  else\n    perm_sets = [single_set]\n  end\nend\n. @ashrafhasson looks good mate :D After you rebase, could you please add an entry to the changelog?\n. @simonh1000 You'll need to make the call to Guardian.Plug.sign_in with a map for the permissions.\nnew_conn = Guardian.Plug.api_sign_in(conn, user, %{perms: perms})\n. This looks pretty good, just the q about revoking a refresh token. I could be wrong but my understanding is that they should stick around.\nAlso can you please add some words to the readme and changelog?\nThanks :D\n. @Hanspagh correct you could use it. Once you start using different types of tokens EnsureAuthenticated should check the typ field. I use access tokens for normal calls and other types as appropriate.\n. As an example, here's my plug for one of my apps\n``` elixir\n  pipeline :api_auth do\n    plug Guardian.Plug.VerifyHeader, realm: \"bearer\"\n    plug Guardian.Plug.EnsureAuthenticated, typ: \"access\", handler: MyAwesomeApp.Api.V1.ApiAuthErrorHandler\n    plug Guardian.Plug.LoadResource\n  end\n``\n. I'm not sure if that would be good or not. I'm thinking about pipelines and setting the token type there. It _might_ be ok. Let me percolate on it a bit. Also I think we should change the default type to 'access' rather than 'token'. Token doesn't really mean anything.\n. Hey @Hanspagh thanks for pinging on this one. I think we definitely need anexchangefunction but I don't think we should limit it to onlyrefresh` tokens. You could exchange any kind. I do like the refresh TTL of the token  too and would love to see it come in.\nI think what would be great is:\n1. we add an exchange function that can handle whatever type of token and exchange it for another. This should take the existing token, the new type, the old type and any options to modify\n2. We should change the existing default from token to access.\n3. Update the README to define the implications of using different token types\n4. add a configuration entry for token_ttl where you can specify the defaults of each type of token.\nThoughts?\n. Hmm true facts. I guess there's a couple of ways I can think of that we could deal with that. \n1. Add a config option that provides a mapping from -> to\n2. Add into the exchange function signature the expected from -> to. If the from doesn't match it doesn't work\nI think 2 seems more natural to me. That way the calling code would be responsible:\nelixir\nGuardian.exchange(jwt, \"refresh\", \"access\")\nOr in the case where it's many:\nelixir\nGuardian.exchange(jwt, [\"refresh\", \"rememberMe\"], \"access\")\nThoughts?\n. @thbar I'm going to ask @potatosalad to jump in. I personally use HS512 which is just a simple sha signing. This means that the JWT can be read but not tampered with. I'm hoping @potatosalad can provide more information on the more exotic key types. \n. @vheathen not sure I'm following your example. When you use the ttl function you're effectively asking for  '30 minutes after the issue time'. If you want to set the ttl manually I believe you can just set the exp and iat in your encode_and_sign call.\nelixir\nGuardian.encode_and_sign(device, :token, %{\"exp\" => 123456432, \"iat\" => 124343534})\n. Hmm... sorry I can't pull up the code right now but if you pass it the ttl in the encode and sign it will work. It should work with a specified exp and iat so I think that's a bug.\nelixir\n ttl = {old_exp_at - :os.system_time(:seconds) - 1, :seconds}\n{:ok, token, _full_claims} = Guardian.encode_and_sign(device, :token, %{ttl: ttl})\n. I'm not sure that this will fix the issue. Looking at lib/guardian/claims.ex this is exactly what the def ttl function does right now. I think the ttl function needs to pattern match on the \"exp\" key.\n. I took a look at this on my local machine. What do you think of https://github.com/ueberauth/guardian/compare/ttl-exp-fix\n. Ok I've just made a PR for the other branch. If the tests all go green I'll merge.\n. Unfortunately you can't have two configurations for guardian at the moment. However you can manually specify the secrets in the calls to encode_and_sign and decode_and_verify. The same goes for the ttl settings.\n. I think this could be a great addition but would be a pretty hefty breaking change :\\\n. I wouldn't try to use the bitmask directly. Guardian.Permissions.all?/2 is likely what you're after here.\nelixir\ncan_access? = socket\n|> current_claims()\n|> Guardian.Permissions.from_claims(:admin)\n|> Guardian.Permissions.all?([:your_permission_name], :admin)\n. Hi. Can you please use some more words. The Guardian.Plug.EnsureAuthenticated plug is probably what you want but without anything to go on I can't really be sure ;)\n. Thanks!\n. I use Guardian without a model many times when I just want to know that someone is authenticated but without providing a mapping to the resource that is authenticated. There's nothing stopping you from putting just a straight up string or integer in that place. For example:\n``` elixir\n@behaviour Guardian.Serializer\ndef for_token(id), do: {:ok, id}\ndef from_token(id), do: {:ok, id}\n```\nYou could then generate your token like this:\nelixir\nGuardian.encode_and_sign(15, :access)\nThe serializer in this case will just pass through whatever you pass through both on serialize and deserialize and the integer 15 will be stored in the 'sub' field of your token.\n. The 'token' type is pretty useless. Whenever we talk about token types (taking a nod from OAuth) we usually talk about access vs refresh tokens etc. I thought it'd be better to use 'access' as the typ so it means something.\n. Thanks!\n. Hey. Sorry I've been travelling. No objections :D Happy to be forward compatible :D\n. @hollow it seems like you might be missing a secret in your configuration\n. @doomspork is correct. EnsurePermissions is what you want here. Also just a quick comment on the code you posted.\n```\nclaims = Guardian.Claims.app_claims\n         |> Map.put(:perms, %{ admin: [:all] })\nEncode JWT\n{ :ok, jwt, full_claims} = Guardian.encode_and_sign(user, :token, claims)\nconn\n|> json(%{access_token: jwt})\n```\nYou don't need the call to app_claims. You can pass in perms directly - the encode_and_sign will populate the rest of the claims starting with app claims.\n{ :ok, jwt, full_claims} = Guardian.encode_and_sign(user, :token, perms: %{ admin: [:all]})\n. Hi @qgadrian. I usually use Bearer as the realm. If you don't declare a realm on your verify header plug it will assume\nAUTHORIZATION: <jwt>\nWith the relam\nAUTHORIZATION: <realm name> <jwt>\nIt's up  to the client to use the correct form that the server is expecting.\n. @GildedHonour did you get it sorted?\n. Hey @manuelsteiner. Rather than using the ttl from the config, it's probably better if you read the exp field from the token and then subtract the current time from it.\n. I think you want to run it after VerifySession, since the session should be used before the remember me version. \nIn general the idea is to find a token and verify it, or pass to the next plug to try and do the same.\nSomething like  \n``` elixir\ndefmodule Guardian.Plug.VerifyRememberMe do\n  @moduledoc \"\"\"\n  Use this plug to load a remember me cookie and convert it into an access token\n## Example\n  plug Guardian.Plug.VerifyRememberMe\n\nYou can also specify a location to look for the token\n## Example\n  plug Guardian.Plug.VerifyRememberMe, key: :secret\n\nThis should be run after Guardian.Plug.VerifySession\nIt assumes that there is a cookie called 'remember_me' and that it has a\n  refresh type token\n  \"\"\"\n  import Guardian.Keys\n@doc false\n  def init(opts \\ %{}), do: Enum.into(opts, %{})\n@doc false\n  def call(conn, opts) do\n    key = Map.get(opts, :key, :default)\nif Guardian.Plug.authenticated?(conn, key) do\n  # we're already authenticated somehow either from the session or header\n  conn\nelse\n  # do we find a cookie\n  jwt = conn.req_cookies[\"remember_me\"]  # options could specify this\n  case exchange!(jwt, \"refresh\", \"access\") do # options could specify these too \n    {:ok, access_jwt, new_claims} ->\n      conn\n      |> Guardian.Plug.set_claims({:ok, new_claims}, key)\n      |> Guardian.Plug.set_current_token(access_jwt, key)\n    _error -> conn\n  end\nend\n\nend\ndefp exchange!(nil, , ), do: {:error, :not_found}\n# this function could go into guardian itself\n  defp exchange!(jwt, from, to) do\n    case Guardian.decode_and_verify(jwt, typ: from) do # only accept remember me tokens of typ \"refresh\"\n      { :ok, claims } ->\n        new_claims = claims\n          |> Map.drop([\"jti\", \"iat\", \"exp\", \"nbf\"])\n          |> Guardian.Claims.jti\n          |> Guardian.Claims.nbf\n          |> Guardian.Claims.iat\n          |> Guardian.Claims.ttl\n    {:ok, resource} = Guardian.serializer.from_token(new_claims[\"sub\"])\n\n    Guardian.encode_and_sign(resource, to, new_claims)\n  error -> error\nend\n\nend\nend\n```\nI'm making some assumptions about your token types and ttls and stuff here but I think it shows what I think the general approach should be. \nI'd ultimately want to bring something like this into Guardian but it'll take a bit more than this since it has to take into account the ability to handle specific secrets etc.\n(Also I haven't tested this code, just typed it for demonstration)\n. We should probably just catch all errors there rather than just an invalid token one. Did you want to get a PR together?\n. not sure what you're trying to achieve. Also, why use your client secret as a key in the verify header? That is not the secret that will be used, it's just a location in the assigns (allowing multiple sign ins at the same time). Whatever 'key' you use on your verify header module you use, you need to use that always - EnsureAuthenticated and LoadResource - need the same key. Usually the 'key' you'd use there would be something like 'default', 'admin'. It's just a label to tell guardian which login you're talking about. It's good for things like impersonation or temporary heightened security\n. In order to use the auth0 as a token that you're going to trust as your applications token, I think you'd have to set your secret key to be the same signing secret that the auth0 token was signed with. At that point, when you receive the auth0 token you put it into the session/conn assigns the same way that the sign_in function does and it should all just work. \nJust work might be a bit of a stretch though. Your token serializer will need to match whatever they put into the token, permissions likely won't work because I don't think that auto0 would have access to your bitmask and I'm not sure GuardianDb would work out of the box. For that to work it would need to have a jti specified in the JWT.\nPersonally I like to put a boundary between my system and another. If I were using auth0 I would treat that like a login action where I received that token and then generated one of my own based on it. That's probably just me though ;)\nYou can use Guardian to decode the token from auth0 provided you know the signing secret.\nGuardian.decode_and_verify(jwt, %{secret: auth0_secret})\n. @alduro is your project public? I don't actually use auth0 but if I could see some code it might help me identify what you're trying to do.\n. I haven't but it sounds like something that we should fix!\n. The code looks just fine to me. Travis is erroring though.\n. Ohh I like it! This is great. Thanks for contributing. Could you please update the Changelog to include this new addition?\n. Hey @ericsullivan \nThanks for taking the time to put this together. We did indeed used to have it but I removed it. I talked to eric and jose about this quite a bit and they convinced me that it was potentially problematic.\nJust to prompt the start of a debate, the reasons was that allowing multiple hook modules can lead to complexity and implicitness. Where does the hook come from? Are there dependencies between the hooks? Should they always run? Is it explicit such that you can determine the behaviour that you're getting?\nIt was felt at the time that to support multi-hooks, the most explicit and straight forward way to do it would be to have the developer create a module that delegates to other hook modules. This would provide explicitness and allow the behaviour to match the requirements exactly. \nI'm not entirely against this idea at all, but the discussion with jose and eric were pretty convincing. I more intend this response to start a bit of a debate so we can all get a better understanding of what a good way forward is. (I'm hoping that it feels that way). I don't think I'd suggest wrapping sign in. I feel like a hooks module would likely be probably what you're after. \nAs the current lib stands I would suggest writing a hook module that did exactly what you're looking for.\n```elixir\ndefmodule MyHooks do\n  ...\ndef after_sign_in(conn) do\n    with conn <- Timeoutable.after_sign_in\n            conn <- AnotherThing.after_sign_in\n    do\n       conn\n    end\n  end\n```\nI'd also see the hooks module that you've built as a meta-hook with known behaviour. TBH I'm not close enough to what you're trying to do to give anything specific but I am wondering if this is not enough.. @smoes this was the reason we developed guardian db. By tracking all the issued valid tokens sign out will revoke them. Part of the challenge of using JWT is that they are essentially untracked unless you do it in your app and will stay valid until they reach expiry.. Something like this is what we've been thinking for  1.0\nThe global config is too limiting. Hey @odarriba \nWork is progressing on V1 which includes the ability to have multiple configurations in a single app. There are three remaining items left.\n1: the Phoenix helpers\n2: permissions\n3: updating guardian db\nI expect that these will be finished and an rc will be released later next week.. Hi @artukrap, \nIf you're using GuardianDb to track the token in your logout function you need to revoke the token. If you're not tracking the token with something like GuardainDb then just throw the token away.. @artukrap if you're using GuardianDb then revoking will cause the system to revoke it (Guardian db keeps a record of all issued tokens). If you're not using Guardian Db or something similar to track all issued tokens then there is no way to revoke them. A JWT is valid until it expires. The only way to revoke a still active token is to keep a record of it and when it's revoked, mark it as no longer valid. \nIf you're not using Guardian Db (or simliar) then when you logout calling revoke it's just a noop. In that case you just dereference the token in your client and 'forget' it. . This is taken care of int he v_1 branch.. Hi @Grafikart \nGuardian comes with the ability for you to specify your own module to check claims. In the configuration it is: \nelixir\nverify_module: Guardian.JWT\nThis is a simple implementation of the Guardian.ClaimValidation behaviour. If you require different or more stringent checks on claim validation you can use Guardian.ClaimValidation and overwrite the validate_claim function to do what you need. https://github.com/ueberauth/guardian/blob/master/lib/guardian/claim_validation.ex has all the default implementations.\nhttps://github.com/ueberauth/guardian/blob/master/lib/guardian/jwt.ex. Hey. I believe what you're describing is session auth. In your browser pipeline if you use the verify session plug it should pick it up. You'll also need to use the Guardian.sign_in function to make sure your token goes into the session.\nPlease let me know if that is unclear.. Are you using an spa using fetch, maybe even over CORS? You may need to tell the call to fetch to include the credentials. Can you show the chrome/safari request/response headers you're seeing on your client? (from the dev environment) in the network headers tab? I'd like to see if it's getting to the client. From memory sessions are flushed just before the response is sent in plug.. Thanks so much. So looking at the cookie that you've provided that actually made it back from the sign in response I pulled it apart to see what was there.\n```ruby\nirb(main):001:0> str = \"g3QAAAABbQAAABBndWFyZGlhbl9kZWZhdWx0bQAAAUNleUpoYkdjaU9pSklVelV4TWlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKaGRXUWlPaUpWYzJWeU9qSWlMQ0psZUhBaU9qRTBPVEl4TXpJNE16Y3NJbWxoZENJNk1UUTRPVFUwTURnek55d2lhWE56SWpvaVFYTndhWEpsSWl3aWFuUnBJam9pTlRBMU1tRXdZamd0TmpBeE1DMDBOV015TFdKa1pEVXRaVE15TnpZMFlqSTFaRGN3SWl3aWNHVnRJanA3ZlN3aWMzVmlJam9pVlhObGNqb3lJaXdpZEhsd0lqb2lZV05qWlhOekluMC4xSkRrQzBhN2RkT2F6TTNKRnJ3bGVQdkFPczM5U0paQWZwdHFaSVlNSGNBUm5peDBybWZPaDBjdlhYOEtpRjR5all0M0VHUExFTnZDZHBuMFpqSEVPQQ\"\n=> \"g3QAAAABbQAAABBndWFyZGlhbl9kZWZhdWx0bQAAAUNleUpoYkdjaU9pSklVelV4TWlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKaGRXUWlPaUpWYzJWeU9qSWlMQ0psZUhBaU9qRTBPVEl4TXpJNE16Y3NJbWxoZENJNk1UUTRPVFUwTURnek55d2lhWE56SWpvaVFYTndhWEpsSWl3aWFuUnBJam9pTlRBMU1tRXdZamd0TmpBeE1DMDBOV015TFdKa1pEVXRaVE15TnpZMFlqSTFaRGN3SWl3aWNHVnRJanA3ZlN3aWMzVmlJam9pVlhObGNqb3lJaXdpZEhsd0lqb2lZV05qWlhOekluMC4xSkRrQzBhN2RkT2F6TTNKRnJ3bGVQdkFPczM5U0paQWZwdHFaSVlNSGNBUm5peDBybWZPaDBjdlhYOEtpRjR5all0M0VHUExFTnZDZHBuMFpqSEVPQQ\"\nirb(main):009:0> Base64.decode64(str)\n=> \"\\x83t\\x00\\x00\\x00\\x01m\\x00\\x00\\x00\\x10guardian_defaultm\\x00\\x00\\x01CeyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJVc2VyOjIiLCJleHAiOjE0OTIxMzI4MzcsImlhdCI6MTQ4OTU0MDgzNywiaXNzIjoiQXNwaXJlIiwianRpIjoiNTA1MmEwYjgtNjAxMC00NWMyLWJkZDUtZTMyNzY0YjI1ZDcwIiwicGVtIjp7fSwic3ViIjoiVXNlcjoyIiwidHlwIjoiYWNjZXNzIn0.1JDkC0a7ddOazM3JFrwlePvAOs39SJZAfptqZIYMHcARnix0rmfOh0cvXX8KiF4yjYt3EGPLENvCdpn0ZjHEOA\"\nirb(main):010:0> payload = \"eyJhdWQiOiJVc2VyOjIiLCJleHAiOjE0OTIxMzI4MzcsImlhdCI6MTQ4OTU0MDgzNywiaXNzIjoiQXNwaXJlIiwianRpIjoiNTA1MmEwYjgtNjAxMC00NWMyLWJkZDUtZTMyNzY0YjI1ZDcwIiwicGVtIjp7fSwic3ViIjoiVXNlcjoyIiwidHlwIjoiYWNjZXNzIn0\"\nirb(main):011:0> Base64.decode64(payload)\n=> \"{\\\"aud\\\":\\\"User:2\\\",\\\"exp\\\":1492132837,\\\"iat\\\":1489540837,\\\"iss\\\":\\\"Aspire\\\",\\\"jti\\\":\\\"5052a0b8-6010-45c2-bdd5-e32764b25d70\\\",\\\"pem\\\":{},\\\"sub\\\":\\\"User:2\\\",\\\"typ\\\":\\\"access\\\"}\"\n```\nI don't believe you have a problem getting the session from the server to the client. It seems to be the other way.\nWhen using fetch and you want to use the session with cors I've always found that I need to explicitly instruct fetch to include the credentials.\nhttps://fetch.spec.whatwg.org/#cors-protocol-and-credentials\njavascript\nfetch(\"./\", { credentials:\"include\" }).then(/* \u2026 */)\nCan you please try this in your client and let me know how you go?. ok agreed that this is strange :\\ \nCan you add a debugger plug into your pipeline just after the fetch session and dump out the parsed session? It'd be helpful to know if it's getting back on the way in before we get to the guardian plugs.\nSorry that you're having trouble :(. Oh sorry... Just a simple one to splat things out. Something like:\n```elixir\ndefmodule DebugMe do\n  def init(_), do: :ok\ndef call(conn, _) do\n     Logger.debug inspect conn.req_headers\n     Logger.debug inspect conn.req_cookies\n     Logger.debug inspect Map.get(conn.private, :plug_session)\n conn\n\nend\nend\n```\nThen throw that in your pipeline\nelixir\npipeline :api do\n    plug :accepts, [\"json\"]\n    plug :fetch_session\n    plug DebugMe\n    plug Guardian.Plug.VerifySession\n    plug Guardian.Plug.EnsureAuthenticated\n    plug Guardian.Plug.LoadResource\n  end. Thanks. That looks very strange. At the point you've dumped guardian sign in has already run. You can see it in the session with the flag to write.\nAfter that request, what is the debug information? i.e. the next request that you're expecting to be logged in.. Thanks for the update.\nI see there that there is no cookie header or request cookies. I went back and had a look at the request log again. There is no cookie being sent to the server in the request :(\nIf you looks at a request from this page for ex, you can see that there is a cookie included in the request headers. I'm not seeing any evidence that the client is sending cookies back up to the server :. Maybe... I'm not sure how to deal with that :. Np. Good luck!. If you're using a cookie that is not the storage you should write your own Verify style middleware. Those middlewares just find a token from some location, validate them and add them to the Conn struct. It should be fairly straightforward to implement one for your usecase. Provided the client actually sends it ;). Yeah good call it didn't come out too well. So if you're using cookies, they're not one of the out of the box supported ways to get a token into the system. In this case you need your own middleware to locate the token and call verify on it. If it's valid put it in the Conn struct like the Verify modules do. You can refer to the header or session Verify modules for an example of an implementation.. @connorjacobsen not much to go on mate. Are you using cors?. Hey there. Without any more information I'm wondering if setting it to 10 years is perhaps too long. Have you tried shortening the token life to maybe a month?. If you could, what is the error reason from decide and verify?. Published as v0.14.3. These are the options I've got so far: \n```elixir\n  # easiest to create programatically\n  plug MyApp.Tokens.Plug, handler: MyApp.AuthErrorHandler, plugs: [\n    {Guardian.Plug.VerifySession, [claims: %{\"typ\" => \"access\"}]},\n    {Guardian.Plug.VerifyHeader, [realm: \"Bearer\", claims: %{\"typ\" => \"access\"}]}\n    {Guardian.Plug.EnsureAuthenticated, []}\n    {Guardian.Plug.LoadResource, [allow_blank: false]}\n  ]\n# maybe a pain if phx does something weird with the plug function\n  plug MyApp.Tokens.Plug.pipeline handler: MyApp.AuthErrorHandler, do\n    plug Guardian.Plug.VerifySession, claims: %{\"typ\" =>\"access\"}\n    plug Guardian.Plug.VerifyHeader, realm: \"Bearer\", claims: %{\"typ\" => \"access\"}\n    plug Guardian.Plug.EnsureAuthenticated\n    plug Guardian.Plug.LoadResource, allow_blank: false\n  end\n# pretty simple but verbose\n  plug MyApp.Tokens.Plug, plug: Guardian.Plug.VerifySession,\n                          claims: %{\"typ\" => \"access\"},\n                          handler: MyApp.AuthErrorHandler\n# Very verbose\n  plug Guardian.Plug.Executor, impl: MyApp.Tokens,\n                               plug: Guardian.Plug.VerifySession,\n                               claims: %{\"typ\" => \"access\"},\n                               handler: MyApp.AuthErrorHandler\n# simple but verbose\n  plug Guardian.Plug.VerifySession, impl: MyApp.Tokens,\n                                    claims: %{\"type\" => \"access\"},\n                                    handler: MyApp.AuthErrorHandler\n```\nI think it'd be cool to allow the fallback controller in phx but not require it.. A possible alternative:\n```elixir\nBefore anything else\nplug Guardian.Plug, module: MyApp.Tokens, error_handler: MyApp.ErrorHandler\nThen continue with the rest of your life as normal\nplug Guardian.Plug.VerifySession, claims: %{\"typ\" => \"access\"}\nplug Guardian.Plug.VerifyHeader, claims: %{\"typ\" => \"access\"}, realm: \"Bearer\"\nplug Guardian.Plug.EnsureAuthenticated\nplug Guardian.Plug.LoadResource, allow_blank: false\n```. We could also setup the error handler module that way too:\nelixir\nplug Guardian.Plug, module: MyApp.Tokens, error_handler: MyApp.ErrorHandler. Another alternative from @scrogson \n```elixir\nBefore anything else\nplug MyApp.Tokens.Plug, error_handler: MyApp.AuthErrorHandler # error_handler is optional\nthen continue to build your pipeline\nplug Guardian.Plug.VerifySession, claims: %{\"typ\" => \"access\"}\nplug Guardian.Plug.VerifyHeader, claims: %{\"typ\" => \"access\"}, realm: \"Bearer\"\nplug Guardian.Plug.EnsureAuthenticated\nplug Guardian.Plug.LoadResource, allow_blank: false\n``\n. With v1 load resource this plug is no longer needed. Use theallow_blank: true` option to gain previous behaviour. By default this will fail if no resource was found.. I'm going to leave this in Guardian but in order to use it it'll need to go into the build_claims hook. PR for this up at https://github.com/ueberauth/guardian/pull/342. https://github.com/ueberauth/guardian_db/pull/52\nThere didn't actually need to be an update to GuardianDb for 1.0. It just gets setup slightly differently. Yay for functions!. Explain exchange and tokeb types better . Hey @licenser can you please show the raw perms from your example? At first glance I'd say it's becausewhen you're checking the permissions you're using \"update\" but in your config you're using edit.. Going to assume it was the mis-named permission name. Please let me know if that wasn't it.. I was going to create a separate repo for this but @scrogson pointed me to optional dependencies. Going to use that feature. Thanks for the fix :)\n. Hi @ltenzil \nThe closest library in Ruby to guardian is Warden (devise is built on top of Warden). I haven't been tracking it closely but the closest lib I can think of to devise is sentinal. https://hex.pm/packages/sentinel. The slack for elixir-lang is good. Lots of folks in there that are willing to help. \nphoenix or #general are good all round channels. There is also an #ueberauth channel for things related to Guardian and Ueberauth.\nThe programming Phoenix book by Chris is a great resource to get up and running especially if you're coming from a rails background. https://pragprog.com/book/phoenix/programming-phoenix\nWelcome to Elixir!. Hey @quytang\nSorry about the issue :( this will be resolved in the next release. For now you can add the \"override: true\" option to your phoenix deps to get you going.. I've put up a PR for this at https://github.com/ueberauth/guardian/pull/343. @scrogson @doomspork this is updated. Would love another run through. Merging this into v1 to continue working on it. . Is this related to the token flow for google OAuth? if it is you'd be better off asking on Ueberauth google. Guardian itself doesn't deal with these issues.\nThat being said there is an open issue on Ueberauth google to deal with client token flows better.. I'm not sure. I've never tried to paste my. Secret I to an online decoder :/. Thankyou!. This is great! Thank you.. It will but that's ok. \nI'm not sure that trying to construct all the different parts of a token via the URL is a great way to go though. There are lots of different variations that will be possible in V1 and I'm concerned that trying to construct a token from url params will become tricky at best but impossible in some cases. What about cases where a different secret is used depending on the request etc. I'm also a little concerned about setting the new_claims when the plug is initialized since depending on how you do it it might not be appropriate for all tests but could be set once.\nWhat would you folks think of putting a token into the URL rather than the components? This would let the token contain exactly what you need, be signed by the correct secret (for those using custom secrets) and in V1 allow you to specify exactly which token type you're intending on using.\nelixir\n{:ok, token, _} = Guardin.encode_and_sign(user, :access, new_claims)\nnavitage_to \"/?access_token=#{token}\". Cool... Another thought is that this is really not good to let escape by accident into environments other than dev and test.  Can you put a guard on the call so that we don't do this unless it's the correct environment?\nTBH this plug makes me a little nervous :. @jayjun I've been thinking about this behaviour a lot over the last couple of weeks.\nI'm not sure that this belongs in Guardian itself. The challenge I have is that it's very focused on a particular use case that - whilst valid - also provides a way to severely compromise security if it's used incorrectly.\nI'm hearing the need and like that there is a solution being developed but I'm thinking that a community library would probably be more appropriate.\n@jayjun @scrogson @doomspork thoughts?\n. @doomspork I don't have a strong opinion on a name. I think it should be focused on testing though ;). @scrogson updated. @doomspork got you covered https://github.com/ueberauth/guardian/tree/v0.14.x\n. Agreed. I get the feeling that the socket/channel part of the upgrade has had the least love. \nDid you have other specific magic callbacks in mind?. Not sure... The V1 branch is a full replacement of master so I don't think we want to rebase it\n Maybe we could cherry pick the parts that should come over.\nChanges LGTM!. @plamb I'm on my phone so cannot say for sure but I believe that plug functions are put onto a nested Plug module. I.e. SearchSite.Web.Auth.Guardian.Plug. Glad you got it sorted :). Thanks mate! LGTM. Thanks @alxgnon . Sorry for the delay @scrogson @doomspork. I've been out as well :). @scrogson @doomspork can I get an lgtm on this one?. @scrogson @doomspork  updated\n. hey @lukaszsamson \nWhat you describe is the behaviour in the new 1.0 branch. There's a couple of options for us on the 0.14.x branch.\n\nAdd a function that wraps and raises\nWe add it to Guardian 0.14.x\n\nI'm partial to option 1 at the moment since I believe that v1 is strictly better than 0.14.x and would like to focus our energies there. Having said that if you wanted to add a function that is a raise version I wouldn't be against adding it to the 0.14.x branch.\n. @scrogson updated. Ensure resource is no longer a plug. Use the ensure: true option with the load resource plug instead. @steveops good catch. Can you please put up a PR with edits. Verify header has nothing to do with the session and this was likely a copy pasta error.. I've added a guide to my PR for some docs covering pipelines. Love some feedback on it. https://github.com/ueberauth/guardian/pull/474/files#diff-95ceda80a9f5416db3388ae5eeb5e747. This file should not exist in Guardian 1.0. The callbacks are for 0.14.x and are not appropriate anymore. If we want to update it to Guardian 1.0 it should implement only the auth_errror callback.\nI'm down for either updating it to the auth_error callback or just removing it all together.. Agreed this should be at least. @oskar1233 do you have an example setup that shows this behaviour?. I found the issue I believe. @oskar1233 can you confirm that this fixes the issue for you?\nhttps://github.com/ueberauth/guardian/pull/394. Great! It's merged. We'll cur a release soon. @KronicDeth hey thanks for highlighting a confusing issue. I can see how this would be a bit of a head scratcher without explanation of some kind in the README.\nUnfortunately what you've got in this PR for the README is not required and could in fact work against you. \nWhen you use Guardian if Plug is available in your project, a nested module will be created for you with all the right functions so you can use them like MyApp.Guardian.Plug.encode_and_sign(user). @KronicDeth did you want to update this to reflect that this is generated for you or should we close it out?. You can still use a function in the controller to handle errors. Keep the pipeline you have in place and in your controller set a different error handler.\n```elixir\ndefmodule ZoinksWeb.SomeController do\n   # snip\nplug Guardian.Plug.Pipeline, error_handler: MODULE\n# snip\ndef auth_error(conn, {type, reason}, _opts) do\n    do_stuff(conn)\n  end\nend\n```\nThe error handler can be set upstream in your pipeline module. The error handler module is at that point put into the conn struct. If you use the Guardian.Plug.Pipeline plug you can change it for downstream plugs. . Yes you could do it that way. When you use the pipeline plug you setting the error handler for all downstream plugs. You can change it out as often as you need to. . LGTM Nice catch! :). To be honest I'd rather not have a separate plug if we can. . Actually yeah that looks cool. . Hey @mitkins For the TTL question, you can specify the TTL of different token types in your config or as options to use Guardian.\n\ntoken_ttl a map of token_type to ttl. Set specific ttls for specific types of tokens\n\nThe option for this would be:\nelixir\n  token_ttl: %{\n    \"refresh\" => {14, :days},\n    \"access\" => {7, :days},\n  }\nOr you can set a default with the ttl option and just overwrite it.\nelixir\n  ttl: {7, :days},\n  token_ttl: %{\n    \"refresh\" => {14, :days}\n  }\nFor the remember me cookie... Pretty sure that's a bug. They're all getting the same key which is not the intention :(\nThankyou for raising that!. I'm wondering if we should pull this for now. This seems to be a little buggy atm and I don't really want to hold up 1.0 anymore.\n@mitkins @doomspork @scrogson thoughts?. There are many examples of functions in the Plug.Conn module that do not take and return a conn. read_body, get_session, get_req_header, send_chunked. \nassign and put_private do return a conn struct but to access the data on them you access via assigns or private attributes. Guardian stores it's data in the connection in the private attribute, namespaced so as not to collide (as suggested by core members). It also provides accessors for how to get at this data. I don't believe this is an unusual pattern and tbh I'm not sure how else you'd do it.. This was addressed in https://github.com/ueberauth/guardian/pull/404 but has not yet been released.\nI've built against the master branch without plug and without running into this issue.\nCan you please confirm that this is still an issue on master?\n. Thanks for the PR and confirmation. I will try and get an updated release out tomorrow.. Unfortunately we don't have a solid way of doing this atm. We know when folks are working on a fix when a PR comes up - but unfortunately this PR didn't close out the bug. \nI'd love to chat about ways we might handle this moving forward in slack #ueberauth. @doomspork will likely have some solid ideas on it also.. I think I'd like to hold this cookie / remember me functionality back fro 1.0 so we can get it out the door then bring it back shortly after once we've had a good chance to kick the tires. What do you think?. I originally had it in it's own package but put up a q on #ueberauth which came back as put it in core. \nDoes it assume postgres? It's my understanding of ecto that it's just going to use whatever your backing DB is, so long as it's an ecto repo. The OneTimeToken requires that you provide a repo to use with it.. Thanks for picking this one up!\nCan you please change this to allow_blank or at least mention it so that folks know it there?. Can you paste your guardian module please? . In Bark.Web.Context are you able to get the token with MyApp.Auth.Guardian.Plug.current_token(conn)? or the resource with MyApp.Guardian.Plug.current_resource(conn)?. Hi. Not sure if the code you pasted is the code you're running. You're logging test_jwt but it should be new_jwt. Is that accurate?. Refresh has a slightly different signature than encode and sign. It returns\n{:ok, {old_token, old_claims}, {new_token, new_claims}}\nSo your pattern match in your case would need to be\n{:ok, , {new_jwt, }}. Hey @pedrovieira. At first glance it looks like you have the \"key\" option set to your secret key for your pipeline. This should not be your secret key. Unless you're doing something like impersonation you should leave that key unset. That key refers to the namespace that will be used on the connection to store the tokens and stuff. Can you remove that key and let us know how that goes?\nI'm assuming the verify token in your code listing is you manually doing it. What does your Conn look like after it goes through the pipeline without the manual verify?\nCan you please paste your router pipelines and the relevant routes and a stripped down version. Of your controller?. @pedromvieira where does the \"perms\" key in your claims come from? It should be \"pem\". How are you creating your token?. From the docs, you should use the build_claims callback in your implementation module\nelixir\n    def build_claims(claims, _resource, opts) do\n      claims =\n        claims\n        |> encode_permissions_into_claims!(Keyword.get(opts, :permissions))\n      {:ok, claims}\n    end\nWhere the :permissions key for the options is chosen by you. To use it you'd do something like:\nelixir\nPhishx.Guardian.encode_and_sign(user, %{}, permissions: %{default: [:mgmt], user_actions: [:dashboard]})\nThe same is true for sign_in. Hey sorry I didn't see this in time.\nWith pipelines you can set either the module or error handler upstream. The last set one will be in effect when your pipeline executes. So for your case you could do:\nelixir\npipeline :authenticate do\n  plug Guardian.Plug.Pipeline, error_handler: MyApp.AuthErrorHandler\n  plug Auth.Pipeline\nend. Hi @denvaar,\nNot sure how encode_and_sign would put anything on the conn. It doesn't have access to it. Can you show the code that is resulting in this behaviour please?. Thanks @tarzan!. @tsurupin from what I can see, you just need to add some custom claims to the token... is that correct?\nIf that is correct you can implement this using the build_claims callback in your implementation module.\nI believe this would be equivalent assuming you're using distillery. \n\nconfig.ex\n\nelixir\n  config :api, Api.Guardian,\n    issuer: \"${FIREBASE_SERVICE_ACCOUNT_EMAIL}\",\n    subject: \"${FIREBASE_SERVICE_ACCOUNT_EMAIL}\",\n    verify_module: Api.Guardian.JWT,\n    allowed_algos: [\"RS256\"],\n    ttl: {1, :hours},\n    secret_key: {Api.GuardianSecretKey, :get_key, []}\n\nguardian.ex\n\n```elixir\ndefmodule Api.Guardian do\nuse Guardian, otp_app: :api\n  @aud \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\"\ndef subject_for_token(, ) do\n    config(:subject)\n  end\ndef resource_from_claims(%{\"uid\" => uid} = _claims) do\n    case Repo.get_by(User, %{uid: uid}) do\n      nil -> {:error, :user_not_found}\n      user -> {:ok, user}\n    end\n  end\ndef fetch_secret() do\n    JOSE.JWK.from_pem_file(System.get_env(\"SECRET_PEM_FILE_PATH\"))\n  end\ndef build_claims(claims, %{uid: uid}, opts) do\n    claims \n    |> Map.put(\"aud\", @aud)\n    |> Map.put(\"uid\", uid)\n  end\nend\n```. Lets merge this one. @mumughal. Thanks for raising this issue. I've been thinking about it for a few days and finally it clicked for me today how to let this happen. Can you please take a look at #473 and let me know what you think?. @mumughal the PR has merged. Just waiting to get the guides PR in before pushing a release - however we could cut a release and release the docs later. I don't want to get in the way of your dev for some guides.. Hey @jgashe \nThanks for the thought. If love to see an option to encode as string front is one, but I don't think it should be an option on the bitwise module. I was thinking if we want a different kind we should make a different module (hence the btwise in it's name). On the other hand we could pull out the encoding/decoding part into a behaviour interface and have a bitstring, text, JSON encoders.\nThoughts . @yordis if we leave it blank it would be a broken implementation. I think we either give it an implementation or leave it as a callback. I think  for convenience we should have an implementation but what we could do instead is just delegate out to the default fetcher for each one rather than duplicate the code.. @yordis updated. @yordis ping. @apognu I don't believe this has been released yet. I'd be interested to see what modifications you would put in place to make this feature more useful.. @scrogson updated\n. @scrogson ping. The two issues that are causing Guardian not to work for you are:\nIn your pipeline you're setting the module to ApiTrangell.Tokens but this module does not exist. You should change this to: ApiTrangell.Guardian\nIn ApiTrangell you do not have the function you're trying to call in ApiTrangell.Guardian You'll need to implement that.\nFor your application it would be as simple as:\nelixir\ndefmodule ApiTrangell do\n  def get_resource_by_id(id) do\n    %{id: id, user: \"shahryar\"}\n  end\nend\nA couple of other things though that are just general good practices. You should have a .gitignore and include at least _build and deps in it. That repo has them checked in :(\nNested routes in your router are not something that is encouraged. It makes it very difficult to work out what's going on when your application grows a bit.\n. Can you please update the changelog before I merge this.. Thank you :). Hey @shahryarjb \n\n\nYou'll need to put your permissions plug after your verify ones (I'd put it after ensure authenticated also) so that it has something to work with.\n\n\nYou'll need to add a build_claims hook like: https://github.com/ueberauth/guardian/blob/master/lib/guardian/permissions/bitwise.ex#L41\n\n\nYou wouldn't set the permissions directly in the claims like you have above and in your controller. Permissions are generally set via options that are picked up in your build_claims function.\n\n\n. Did you add the build claims hook? You're still directly setting the pem in the claim but you're setting it to a list. Check the link in my last comment for how to set it up.. I've gone through you code and put together a gist of it. You're missing a lot of the setup for basic guardian, I suggest you get basic guardian working before you move onto permissions. It can take a while for everything to click into place. Perhaps follow a tutorial for getting setup so you can explore phoenix a little more.\nThere's a few tutorials online for getting everything wired together from a standing start. The top one when I googled it was https://medium.com/@zacharykuhn/setting-up-a-phoenix-app-with-guardian-1-0-411ff3195adb\nThat said, here is a gist with the relevant parts from your application.\nhttps://gist.github.com/hassox/c731067efc1ca748e2eabbff19ccd27c. @gmile what @yordis said. This is the function where you load it. If you can't find it then you should return an error.\nIf you're wanting to make sure that the resource was found in your plug pipeline, you should use the \"LoadResource\" with the \"allow_blank\" option omitted or set to false.. This is cool @davepersing! Can we chat on #ueberauth slack?\n. Awesome! Fwiw guardian only default provides JWT. This is exactly an example of why guardian uses tokens and not JWT! \nYour repo and token implementation makes me so happy! \n@expelledboy which changes are you referring to?. If your user is deleted, how would they be able to access the show page for that deleted user?. I see. Sorry I missed the nuance there. It's returning 401 because it's treating it as a \"you're not authorized to make this request\". It hasn't even got into the action to determine if a user is available because this is a protected resource (if it's there or not) and the current token was deemed to be invalid.. So you're using a different user in the token than you're using to fetch? It may be that the conn is recycled by the phx test env. If you want to start with the same conditions for each request (i.e. a header has been set) rather than storing the conn into the conn variable which could be recycling it would probably be better to store the results off in a different conn struct.\ni.e.\n```elixir\n  setup %{conn: conn} do\n    user = insert(:user)\n    {:ok, token, _claims} = KidseeApiWeb.Guardian.encode_and_sign(user)\n    conn = put_req_header(conn, \"authorization\", \"Bearer #{token}\")\n    {:ok, conn: conn }\n  end\ndescribe \"delete user\" do\n    test \"deletes chosen user\", %{conn: conn} do\n      user = insert(:user)\n      resp_conn = delete conn, user_path(conn, :delete, user)\n      assert response(resp_conn, 204)\n  resp_conn = get conn, user_path(conn, :show, user)\n  assert response(resp_conn, 404)\n\nend\n\nend\n``. Always down for dropping old versions personally ;). There's a bit more information in the guides. We haven't pushed the release so it's not available on hex yet but you can access it on github: https://github.com/ueberauth/guardian/blob/master/guides/plug/pipelines.md. Just wondering if you generated the documentation locally to try out these changes?. If you runmix docsthenopen docs/index.html` and make sure that those links are still functioning then you should know if it's working properly.. Is this part of a really long web request or part of a socket configuration?. Are you running this inside a docker container? Sometimes the docker container can get it's clock all screwed up and needs to be restarted. \nIf not can you pls verify your workflow? Are you generating it on the same machine and hitting it immediately expecting it to be expired? How are you generating an expired token etc?. I want to click on hell yes, do you think there might be any issue with folks using uuid as the data type in postgres? . Looks like in GuardianDb we're using a string rather than a UUID. I'd say that's probably enough. We might want to wrap it in a backwards incompatible version?. Thanks for the ping. 1.1.1 is published. Hey there. An can you please point me at the implementation for MyProject.Guardian. @dubert if you want to omit some keys from your token you can. Use the build_claims callback on your guardian impl module.\n```elixir\ndefmodule MyApp.Guardian do\n  use Guardian, otp_app: :my_app\n# snip ...\ndef build_claims(claims_so_far, resource, options) do\n  claims =\n    claims_so_far\n    |> Map.drop([\"aud\", \"iss\", \"jti\", \"nbf\", \"sub\", \"typ\"])\n{:ok, claims}\nend\nsnip ...\nend\n```\nI don't believe exp is required (I've dropped it before in some circumstances). If you find that you want different validation from what is found in Guardian.Token.Jwt.Verify you should set your config option token_verify_module. \nIf you do find the default implementation of Guardians JWT completely unworkable for you, you can always implement a custom token type. https://github.com/ueberauth/guardian/blob/master/lib/guardian/token.ex\n. Yeah we're not going to backport this by default... If folks really need it we can.. I'm down to pull out Phoenix but I think pulling out plug will decrease the usefulness of the lib and increase maintenance. Not in favour of extracting plug. This may not be a map. This should stay a Dict or be Enum.into'd a map\n. This first one may not be a map. The one inside the anon function is for sure, but the other... not so sure.\n. ergh.. thanks. One day my fingers will remember how to spell :|\n. Why the change to Keyword from map? I think this will impact other areas of the code. \n. Nm\n. I'm not very experienced with it. What do you think is best?\n. already_authenticated sounds like a pretty reasonable thing to call this I think. I don't know what the default would do though. maybe redirect to \"/\" ? That could possibly cause an infinite redirect though if \"/\" was EnsureNotAuthenticated. Perhaps a required config option for redirection?\n. :+1: \n. there were so many :|\n. eep... Thanks\n. So long as it's above 2 I'm pretty sure we're good. So long as we can smash JSON we're good. I don't think there is even a real requirement from Guardians side other than it be there since we're just doing string keys. I'd be happy to merge this but maybe we can just say >= 1.3.0?\n. I think this one would be better written to have the same shape. Something like\n``` elixir\nif Map.get(opts, :one_of) do\n  perm_sets = Map.get(opts, :one_of)\nelse\n  single_set = Map.drop(opts, [:handler, :on_failure, :key, :one_of])\n  if Enum.empty?(single_set) do\n    perm_sets = []\n  else\n    perm_sets = [single_set]\n  end\nend\n```\nThen the keys down below would be:\nelixir\n%{\n  handler: handler,\n  key: key,\n  perm_sets: perm_sets\n}\n. If you have a list of permission sets from the initializer we can just check all the sets. I'm thinking something along the lines of:\n``` elixir\nresult = matches_permissions?(conn, key, Map.get(opts, :perm_sets))\nif result, do: conn, else: handle_error(conn, opts)\n```\n``` elixir\ndef matches_permissions?(, , []), do: true\ndef matches_permissions?(conn, key, sets) do\n  case Guardian.Plug.claims(conn, key) do\n    {:ok, claims} -> \n      Enum.any?(sets, &matches_permission_set?(claims, &1))\n    _ -> false\n  end\nend\ndefp matches_permission_set?(claims, set) do\n  Enum.all?(set, fn({key, required_perms}) -> \n    Guardian.Permissions.from_claims(claims, key)\n    |> Guardian.Permissions.all?(required_perms, key)\n  end)\nend\n``\n. You're right it should be private. It would be matched when no sets/permissions were declared. An unlikely case but possible.\n. Is this the normal proceedure to revoke the refresh token? I thought these stayed valid and could be used multiple times.\n. I think we want to drop some of the claims here and use the remaining claims. If we just use an empty map we'll lose any custom claims that were embedded in the 'refresh' token.\n. I think we need another clause here to deal with the case of an atom.\n. ooh nice... will update\n. Missing () on a lot of these piplined functions.. I believe this should be&clear_key(&1, &2, impl, opts). This is not guaranteed to return the elements in this order :(. this changes the behaviour significantly. If those things aren't set they will override the values to nil rather than leaving them alone.. Can we update this to be a little more explanatory?{module, atom}` maybe?\nThanks for catching this!. Agreed... The whole thing makes me a bit nervous but I understand the need.\n@jayjun Could I also ask that we improve the naming of this so the it's abundantly clear that it's only for testing? Something like Guardian.Test.Plug.Backdoor or something?. I'm not intending it to be public outside of guardian, but I do use it in many places inside guardian. @scrogson do you have a suggestion for how to achieve that?. Yeah it probably should. Bad implementations should break things \ud83d\udc4d . I would feel a bit weird to be honest. Requiring an ok/error tuple provides a more robust API both internally and externally by being able to rely on the shape of the return. It also provides for the developer to determine what an error is/is not. By making the return type ambiguous we move the requirement to determine the ok/error status of the return to all callsites.\nThe example above is one of the more simple ones but I've used many that deal with straight up strings as well as calling out to an external service. I don't feel like requiring an ok/error tuple is a burden. I'm feeling like ambiguous returntypes would make dealing with this return type propagate to all callsites rather than keeping it focused.. Should we have a specific exception for this? I always appreciate specific exceptions when I'm trying to debug.. The malformed one jumps out :). * distilleries env injection is unavailable on heroku I believe. Forcing folks to use distillery seems like a bad idea to me\n* Pretty sure anonymous functions are required because the value given at runtime with a call is resolved the same way. Can remove it from the config area though since agree we should not say include anon functions in your config\n. To get the max age here you can extract the expiry from the claims (allow for expiry not being there). It might look something like:\n```elixir\n@default_cookie_options [secure: true, max_age: 60 * 60 * 24 * 7 * 4]\ndef remember_me(conn, mod, resource, claims, opts) do\n  # snip\n  {:ok, token, full_claims} <- Guardian.encode_and_sign(mod, resource, claims, opts)\ncookie_opts = cookie_options(mod, full_claims)\n  put_resp_cookie(conn, key, token, cookie_opts)\n  # snip\nend\ndefp cookie_options(mod, %{\"exp\" => timestamp}) do\n  max_age = timestamp - Guardian.timestamp()\n  [max_age: max_age] ++ cookie_options(mod, %{})\nend\ndefp cookie_options(mod, claims) do\n  mod.config(:cookie_options, []) ++ @default_cookie_options\nend\n```\nThis would give an opportunity to set cookie options in config.. This should use impl.revoke(token, opts). ",
    "scrogson": "Channel as in Phoenix channels?\n. :+1: \n. Tracking this in https://github.com/ueberauth/guardian/pull/354. Fixed by https://github.com/ueberauth/guardian/pull/164. Adding a guard clause would definitely be the right way to do this in Phoenix. \n. @Dtatoo this error is due to including use Guardian.Phoenix.Controller in your test file. This module is only intended to be included in your controller module as it simply overrides the default action/2 function which is injected by Phoenix.\nRemoving this line should get you passed the error.\nYou will also need to add the additional user and claims arguments to the remaining controller actions in your controller as well.. @madshargreave sounds like you are looking for the domain option on Plug.Session: https://hexdocs.pm/plug/Plug.Session.html#module-options. \ud83d\udc4d . @madshargreave is this question directed at Phoenix Channel socket authentication?\nIf so, there are a couple of options for this:\n\nCreate a normal HTTP API endpoint on the server that a client can use to fetch a token based on the value in the cookie.\nRender a token into the DOM and query it with JS.\n\nBecause Phoenix Channels were designed to not be coupled to browsers, cookie-based authentication is not supported.. This appears to have been fixed in #256. Definitely agree here. The current configuration for Guardian is subpar as it is only available globally. This is something we are planning to change for a 1.0 milestone.. Starting work on this.. Now available on master and will be published to Hex very soon\u2122.. I think I would prefer to see api_sign_in removed in favor of a single sign_in with a session: false option. api_sign_out doesn't seem to make any sense to me.. Closing for now.. \ud83d\udc4d . @asummers thank you for your feedback. We will be pushing towards 1.0 soon and have been in discussion about making things better in many areas. Simplifying the API is a huge priority for us.. @jonathanraes do you have hooks defined? Guardian.Plug.sign_in calls hooks_module.after_sign_in last:\nhttps://github.com/ueberauth/guardian/blob/master/lib/guardian/plug.ex#L125 \nThe default functionality is to just return the conn:\nhttps://github.com/ueberauth/guardian/blob/master/lib/guardian/hooks.ex#L14\nIf you have it set to to send a response in a hook, you will probably need to define a separate hook module for use in test and configure in config/test.exs.\nI'd love to hear if this is the case.. @bryanjos this sounds like a good idea to me. PR welcome.. Hi @ghoshnirmalya,\nYes, GuardianDB is recommended for preventing replaying of tokens. You can read a bit more about that here. The very last section of that post has a good explanation of why it's necessary.\nHope that helps.. @mikeni that is a typo. The claims, token, and current_resource are set using Plug.Conn.put_private/3.\nHowever, you should not generally rely on those implementation details. Each of those fields has a public API:\nex\nGuardian.Plug.current_token(conn)\nGuardian.Plug.claims(conn)\nGuardian.Plug.current_resource(conn). @mikeni I've pushed this commit https://github.com/ueberauth/guardian/commit/68412b72fc5b1f9bd4203729debdd02ac4ffec9a to hopefully remove the confusion about assigns vs. private.. @mikebaldry some examples of your current usage would be helpful.. @agusguerra10,\nCan you give some more details why you would want to do this? That seems like a major security vulnerability.. That is not something I recommend and is definitely not in scope for Guardian.\nIf you really \"need\" that, you can define your own claim validation module and configure Guardian to use that:\nex\nconfig :guardian, Guardian,\n  ...\n  verify_module: MyApp.ClaimValidator\nHave a look at Guardian.JWT and Guardian.ClaimValidation.. Hi @hopewise,\nThanks for submitting this issue. This is a duplicate of https://github.com/ueberauth/guardian/issues/258 so I will close. Feel free to join in the conversation there.. @hopewise,\nIt looks like the problem is that you have Bearer prefixed to the token. That should only be the value when used as an Authorization header.. Tackling something like this will be much easier with v1.0.\nSomething like this should do the trick:\nex\nconfig :my_app, MyApp.Guardian.Auth0,\n  # ...\n  secret_key: {MyApp.Guardian.Auth0, :fetch_secret, []}\n```ex\ndefmodule MyApp.Guardian.Auth0 do\n  use Guardian, otp_app: :my_app\ndef fetch_secret do\n    System.get_env(\"AUTH0_PUBLIC_KEY\")\n    |> Kernel.||(\"\")\n    |> String.replace(\"\\n\", \"\\n\")\n    |> JOSE.JWK.from_pem()\n  end\nend\n```. Excellent!. Hi @johannesE,\nPlease see https://github.com/ueberauth/guardian/issues/273 for proper resolution. . Please see #273 for proper resolution.. Hi @deepfryed,\nWelcome to the Elixir community! Thank you for your interest in contributing to Guardian!\nI've discussed this PR with the rest of the core team and we have decided that this PR does not fit into the current roadmap.\nHowever, we are working on ideas that would enable this sort of verification method via hooks (which is currently not supported).\nSome tips for the future:\n\nPlease make use of the [#ueberauth] Slack channel or the #elixir-lang IRC channels to discuss potential PRs before opening. This will allow us to evaluate the idea and avoid unnecessary work on your part.\nThe ignore for the .tool-versions should go in your global ~/.gitignore rather than each individual repo.\nAllow the maintainers to manage the CHANGELOG. This will cut down on merge conflicts.\nIn the Elixir community we avoid mocking as much as possible. Jos\u00e9 Valim has an excellent blog post on the subject: http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/\n\nThanks again for your interest. Sorry we couldn't merge this.\n[#ueberauth]: https://elixir-lang.slack.com/messages/C0ETJ9081. Hi @Licenser, can you provide the configuration you're using?. Looking at the value you included in this issue, it appears that the payload looks like this:\ntm\u000b_csrf_tokenm\u0018LJmsD6yNe53d+mwMhjBYxg==m\u0010guardian_defaultm\u0001\\eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJVc2VyOjEiLCJleHAiOjE0OTcwODk3NzQsImlhdCI6MTQ5NDQ5Nzc3NCwiaXNzIjoiT3JndG9vbERiLmRldiIsImp0aSI6ImY4ZTRmYmYzLTczOTUtNDA2Mi1hYjBjLTE3MGQxZTEwODg4MCIsInBlbSI6eyJkZWZhdWx0IjotMX0sInN1YiI6IlVzZXI6MSIsInR5cCI6ImFjY2VzcyJ9.CFQZ8KQyzMRerQysDEHax_VJLYg_zytk1gnNTbjIvPTLpdngDKr4nHyVuEGtVxCNpUvzHbAXXV2FQgb8vGDRCgm\nphoenix_flasht\u0001m\u0004infom\u0012Signed in as heinz\nIt looks like the JWT is being encoded inside the payload.\neyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJVc2VyOjEiLCJleHAiOjE0OTcwODk3NzQsImlhdCI6MTQ5NDQ5Nzc3NCwiaXNzIjoiT3JndG9vbERiLmRldiIsImp0aSI6ImY4ZTRmYmYzLTczOTUtNDA2Mi1hYjBjLTE3MGQxZTEwODg4MCIsInBlbSI6eyJkZWZhdWx0IjotMX0sInN1YiI6IlVzZXI6MSIsInR5cCI6ImFjY2VzcyJ9.CFQZ8KQyzMRerQysDEHax_VJLYg_zytk1gnNTbjIvPTLpdngDKr4nHyVuEGtVxCNpUvzHbAXXV2FQgb8vGDRCgm\nPutting that into jwt.io shows this:\nHeader:\njson\n{\n  \"alg\": \"HS512\",\n  \"typ\": \"JWT\"\n}\nPayload:\njson\n{\n  \"aud\": \"User:1\",\n  \"exp\": 1497089774,\n  \"iat\": 1494497774,\n  \"iss\": \"OrgtoolDb.dev\",\n  \"jti\": \"f8e4fbf3-7395-4062-ab0c-170d1e108880\",\n  \"pem\": {\n    \"default\": -1\n  },\n  \"sub\": \"User:1\",\n  \"typ\": \"access\"\n}. We could also allow configuration to be read from config...\n```ex\ndefmodule MyApp.Pipeline do\n  use Guardian.Pipeline, otp_app: :my_app\n...\nend\n```\nex\nconfig :my_app, MyApp.Pipeline,\n  module: MyApp.Guardian, \n  error_handler: MyApp.ErrorHandler. I'm confused...isn't this change already in master? #347 \nAm I blind? I don't see any difference.. Just so I understand...the point of this is to make it easier to build integration tests with things like Hound and Wallaby? I actually haven't used either of those testing libraries, so I need to educate myself there.. Cool.\nSo I'm just thinking of some options here...\nI think because this functionality needs to be plugged into the user-land code we can't really rely on mix only including the code in :dev and :test as suggested above.\nI would suggest that this code be conditionally included directly by the user-land code. Probably the best place would be in the user's guardian pipeline (v1).\n```ex\ndefmodule MyApp.AuthPipeline do\n  use Guardian.Plug.Pipeline, otp_app: :my_app\nif Application.get_env(:my_app, :guardian_backdoor) do\n    plug Guardian.Plug.Backdoor\n  end\nplug Guardian.Plug.VerifySession, claims: ...\n  plug Guardian.Plug.VerifyHeader, claims: ...\n  plug Guardian.Plug.EnsureAuthenticated\n  plug Guardian.Plug.LoadResource, ensure: true\nend\n```\nThen in config/test.exs:\nex\nconfig :my_app, :guardian_backdoor, true\nThe config option could be anything really. What do you think?\nI realize that this still has the potential for mis-use as the backdoor can just be plugged without the wrapped conditional.. Maybe instead of the wrapped conditional, we could require the otp_app option to be passed? The plug can check if Application.get_env(:my_app, :guardian_backdoor) returns true. If not, it won't be plugged.\nIf the otp_app option isn't provided, we blow up at compile time. We could also print a warning when the backdoor is plugged and we're not in the test environment. These should all be determined at compile time.. @jayjun yep, you are right about that. I like it!\nMy main concern now is maintaining yet another package.. Closing in favor of #379 . @plamb thanks for reporting this. We'll take a look today and make sure it's working as expected.. @plamb, I've created a new app and attempted to replicate you issue but I was not able to. I know it's been awhile since you've reported this issue, but do you think you might be able to produce the  stack trace you encountered?. @plamb feel free to re-open if you are able to reproduce.. This bug has been addressed in v1.0.0. We will be releasing v1.0.0-beta.0 to hex very soon. Please follow the upgrade guide and please be sure to let us know if you have any trouble.\nThank you!. Whoops...sorry @hassox, I merged the other PR into master. Can you redo this against master?. \u2764\ufe0f . Based on the example code above (Voter.Guardian.Plug.sign_in), it looks like @Euklidian-Space is using 1.0. @hassox it was my understanding that MySQL didn't support JSON columns? Or does the MySQL adapter handle that automatically as a text column and handles casting and dumping automatically?. > @scrogson MySQL as of 5.7.x supports a JSON datatype.\nGood to know. Thanks @hassan . Looks like this was merged recently: https://github.com/xerions/mariaex/pull/201\nHowever, it's not yet released on hex.\nI think we have decided to put this into its own package so that we don't block progress on Guardian 1.0.. @delameko I don't think that is possible at the moment. Probably an oversight on our part. I think what you seek is definitely doable. Thanks for bringing it to our attention.. @sebastialonso is there a reason you can't use {1, :year} or {365, :days}?. @sebastialonso I think what you may have seen is that v1.0 supports :week and :weeks but v0.14.x does not.. Looks like you copy/pasted the whole example without changing your otp_app option to your app name. . :heart: . Great stuff @fredwu! I've often thought that realm was not the best name for this myself. Unfortunately, this looks like it would be a breaking change. So we might need to put this off until we're ready for 2.0.\nI'll try to find some time to read through the links you've provided and talk it over with the rest of the @ueberauth/core team.. @apognu in general, I agree with you. If you are doing public/private key signing/verifying and rotating keys then what you are saying makes perfect sense.\nThe default JWT token module that ships with Guardian is more naive and doesn't really go to great lengths to support multiple secret keys.\nThe great news is that you can easily create your own token strategy and use that instead of the default one provided by Guardian.\nLet me know if we're missing something.. @apognu I see. Excellent points! I think it would be great to support these things. Perhaps we can extend what's in master before the next release.. @hassox I'll have a look a bit later this afternoon. Looking good mate!. Apparently the uuid package is now elixir_uuid: https://github.com/zyro/elixir-uuid/blob/master/CHANGELOG.md#v120-24-jun-2018-elixir--10. > do you think there might be any issue with folks using uuid as the data type in postgres?\n@hassox that's a great question. I haven't given that any thought...let's get some input first and make sure it's not going to cause any trouble.. The 3rd argument to encode_and_sign/3 is a Keyword list of options that can be used to override any defaults set in your configuration.\nhttps://github.com/ueberauth/guardian/blob/73b0c3d96985a553c97167ec0757d8885030b1ee/lib/guardian.ex#L84\nYou might find the documentation for the Jwt token module to be useful: https://github.com/ueberauth/guardian/blob/master/lib/guardian/token/jwt.ex. Map.put(\"some_claim\", some_value)\n. Maybe a better name for this might be allowed_drift ?. I'm not sure if it makes a difference...but maybe put this after the call to put_session ?. > Doing override: true on this dependency did nothing, but adjusting version string made it install.\nCan you be more specific of your usage of the override: true option?\nYou would need to use override: true on your application's dependency on phoenix.\nWe may be able to loosen our dependency on phoenix to ~> 1.2 which should include anything in between 1.2 to < 2.0.. \ud83d\udc4d . Can you move these to multiple lines?\nex\nclaims\n|> Map.get(resource_claim)\n|> serializer.from_token(). Let's clean this up to just this:\nex\ndefp deps do\n  [{:guardian, \"~> 1.0\"}]\nend. Let's use MyApp.Guardian for the example module.. Let's just copy the secret generator from phoenix and provide mix guardian.gen.secret.\nhttps://github.com/phoenixframework/phoenix/blob/master/lib/mix/tasks/phx.gen.secret.ex. Maybe we should provide more practical examples instead of X and Y.. JWT. Replace with mix guardian.gen.secret. I think we should show and promote using configuration for the module and error_handler for this instead.. Let's remove these aliases and just put the full paths...easier to copy/paste for users.. This seems to be duplicated multiple times in the README.... This bit is redundant.. I accepts => It accepts. I need to see this used in context of userland code to understand why it's needed to be public. If it's necessary to export then maybe a new name would fit better?. Given mod = Test and func = test, this would result in Testtest, eh?\nMaybe we want #{mod}.#{func}/#{length(args)}. If this function is not intended to be public, we should @doc false.. I think it should be capitalized. The header keys are lowercased but the values are not. So this could be funky if we leave it lowercased.. agreed. not a blocker though.. correct. Should be able to access it via Impl.max. There's camelCasing going on here.... I think I'd like to see this doc'd using:\nex\ncase Guardian.Socket.sign_in(socket, MyApp.Guardian, token) do\n  {:ok, socket} ->\n    {:ok, socket}\n  {:error, _} ->\n    :error\nend. Since the params (token, resource, and claims) are already assigned in the socket, I don't think it's necessary to return a 3-tuple here.. Also, maybe authenticate would be a more appropriate name here instead of sign_in?. This needs to be updated to call authenticate. I don't know for sure. It certainly would be too negligible to make a difference. From a code style perspective, I prefer:\nex\ndef connect(%{\"token\" => token}, socket) do\n  case authenticate(socket, Impl, token) do\n    {:ok, socket} ->\n      {:ok, socket}\n    _ ->\n      :error\n  end\nend. or\nex\ncase authenticate(socket, Impl, token) do\n  {:ok, socket} -> {:ok, socket}\n  {:error, _error} -> :error\nend. otp_app. Missing MyApp prefix. This sentence needs to be reworded.. I think we should slim down this number of configuration options.\n\n\n{:system, \"FOO\"} seems unnecessary to me now-a-days. People running releases with distillery should just use \"${FOO}\" and REPLACE_OS_VARS=true\n\n\nWe should drop the {module, function} version and just support {module, function, args}. We can support zero arity functions with: {module, function, []}\n\n\nAnonymous functions should be dropped altogether as they don't work with releases.. I'm not suggesting that we force any deployment strategy. I'm simply saying that the {:system, \"FOO\"} pattern was created for people using releases (System.get_env/1 doesn't work in the config files for releases).\n\n\nFor those using Heroku or similar, they can simply use System.get_env/1 in the config file and it will work correctly (unless I'm missing something).\n\nPretty sure anonymous functions are required because the value given at runtime with a call is resolved the same way.\n\nI'm not following here, sorry. Can you expand on what you mean? This section is talking about configuration, right?. @bitwalker I thought about init/2 as well...it makes sense for a process...but Guardian is all just functions.. to that => for that ?. I'm not sure this is a good use-case for with.\nThis would be better written (IMO) as:\n```ex\ndef remember_me(conn, mod, resource, claims \\ %{}, opts \\ []) do\n  opts = Keyword.put_new(opts, :token_type, \"refresh\")\n  key = key(conn, opts)\ncase Guardian.encode_and_sign(mod, resource, claims, opts) do\n    {:ok, token, new_claims} ->\n      put_resp_cookie(conn, key, token, cookie_options(mod, new_claims))\n    {:error, _} = err ->\n      handle_unauthenticated(conn, err, opts)\n  end \nend\ndefp key(conn, opts) do\n  conn\n  |> Pipeline.fetch_key(opts)\n  |> token_key()\n  |> Atom.to_string()\nend\n```. Same feedback as above.. Maybe this should be:\nex\nif Mix.env() in [:test, :dev, :docs], do: import_config(\"#{Mix.env()}.exs\"). This should probably just be changed to use the block syntax to avoid this change.. comeonin. I think we should use changeset in full just to make it clearer.. These bullets are not all that clear...what does \"Setting up the basics\" mean?\n\"HTTP based setup\" is also confusing to me. The word \"setup\" seems to be what we did in the first bullet point?. comeonin. Maybe... Create a user manager. mix phx.gen.context UserManager User users username:string password:string. Yep, good point.. @ericmj is this sufficient?. For such little and simple code...I definitely prefer copying from Ecto than pulling in a package.. ",
    "jhosteny": "As you pointed out, the keys will be pre-configured, and small in number. So, an easy solution would be to call String.to_existing_atom, and if the exception is thrown, create it with the call to String.to_atom. The exception should be thrown only once for each of this small number of keys.\n. FYI:\nelixir\niex(5)> fn -> for n <- 1..1_000_000, do: String.to_atom \"foo\" end |> :timer.tc |> elem(0) |> Kernel./(1_000_000)\n2.727668\niex(6)> fn -> for n <- 1..1_000_000, do: String.to_existing_atom \"foo\" end |> :timer.tc |> elem(0) |> Kernel./(1_000_000)\n2.912363\n. My original understanding was that even if the input binary was the same, calling String.to_atom would generate a new atom in the global atom array in the VM, whose entries are not GC'ed. But I now believe that this is incorrect. So, this should be safe to close. Sorry for the noise!\n. ",
    "zmoshansky": "I've created Aeacus as a potential authentication strategy to use with Guardian. If there was some behaviour for authenticators to abide by, I'd be happy to implement it and have it be the first of the auth strategies.\n. @hassox Thanks for the background information, I brought it up as I was looking at the TODO's for guardian and noticed it on there. I have worked with Omniauth as well and it worked well to get 4+ auth solutions up quickly. Do you know of any elixir equivalent?\n. Good to know, thanks\n. I would suggest Guardian.sign & Guardian.verify for the functions, as it's fairly common terminology as far as cryptography goes, and mirrors Phoenix.Token. encode_and_sign is a bit tedious, although it is incredibly descriptive; so a bit of a trade-off.\nEnsureSession -> EnsureAuthorized or EnsureAuthorization\nVerifyAuthorization -> VerifyHeader (Aligns well with VerifySession)\nMy $0.02, hope it helps.\n. ",
    "werbitzky": "I overlooked, that using atoms was probably intended because of the function that is executed on load:\nelixir\n  @doc false\n  def load_required_atoms do\n    IO.puts(\"Loading required atoms #{inspect([:iat, :aud, :sub, :exp, :iss, :s_csrf])}\")\n    :ok\n  end\nif you decide to stick with atoms, I suggest adding :pems to the list as this caused my problem in the first place\n. The creator of Joken is now attempting to document a Joken.Config to work without atoms:\nhttps://github.com/bryanjos/joken/pull/43\nDo you see any problem with this I'm maybe not aware of?\n. ",
    "bryanjos": "The latest version of Joken may work better with strings since more is placed on the user as far as validation, etc. If there are any other changes to Joken that could help or anywhere in Guardian where I may be able to help out with this, I'm happy to help out.\n. @scrogson sorry for the delayed response, I can put a PR in as soon I get a chance.. ",
    "erneestoc": "Other use case would be using Phoenix, inside amazons elasticbeanstalk (docker), and multiple availability zones.\n. Hmm.. I might be doing something wrong..   Every time I close and open the app, the unauthenticated method gets called...\nelixir\nplug Guardian.Plug.EnsureSession, on_failure: { Atena.SessionController, :unauthenticated }\nmy pipeline looks like this.. \nelixir\n  pipeline :authenticated do\n    plug Guardian.Plug.VerifyAuthorization\n    plug Guardian.Plug.EnsureSession, on_failure: { Atena.SessionController, :unauthenticated }\n  end\nand this to authenticate my users..\nelixir\n{:ok, token, _} = Guardian.mint(%{id: account.user.id}, :api)\n. I'm storing the token using iOS keychain, and sending the param as \"Authorization\", \"$token\"..    The app restart I'm talking about is the phoenix process...   if I type cntl+c, and quit the app, turn it on again, the following requests wont be authenticated...    and it executes the on_failure: of EnsureSession...\n. ",
    "misaelpc": "Hi, I'm experimenting the same issue, after restart the phoenix application, I Get the following error:\nLoading required atoms [:iat, :aud, :sub, :exp, :iss, :pems]\n    :erlang.binary_to_existing_atom(\"pem\", :utf8)\n    (poison) lib/poison/parser.ex:97: Poison.Parser.object_name/2\n    (poison) lib/poison/parser.ex:82: Poison.Parser.object_pairs/3\n    (poison) lib/poison/parser.ex:36: Poison.Parser.parse/2\n    (poison) lib/poison/parser.ex:50: Poison.Parser.parse!/2\n    (poison) lib/poison.ex:83: Poison.decode!/2\n    lib/joken/token.ex:116: Joken.Token.get_data/2\n    lib/joken/token.ex:71: Joken.Token.decode/3\nAuth Token  => eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJVc2VyOjEiLCJwZW0iOnt9LCJpc3MiOiJBdGVuYSIsImlhdCI6MTQzNzc5NTY5MSwiZXhwIjoxNDQwMzg3NjkxLCJhdWQiOiJhcGkifQ.f4FGRf4rcMo5Lm85f4rGBaMX95hmvWuXslp7F2a58z4\nThe token Generation it's made with the following serializer =>\ndef for_token(%{:id => id}), do: {:ok, \"User:#{id}\" }\n\"User:1\"\n. ",
    "keichan34": ":tada: Thanks!\n. ",
    "amarsahinovic": "Hi, I've rebased my fork on your latest changes, so now only ex_doc and plug are updated.\n. ",
    "bbhoss": "I'm not sure what you think I'm proposing we change. I was just correcting what I thought was a documentation issue. Your example serializer depends on only the sub being passed in instead of the full claim. \n. I think the better solution is maybe have your own failure protocol, then have the default implementation to reraise. That way, you can do more than just set the status code, but by default it just bubbles up to Plug.Exception.\n. ",
    "adamesque": "Super happy about these changes. Thanks!\n. ",
    "lexmag": "There will be PR soon. :smile: \n. @andreaazzini will take care of it. :smile: \n. One more thing about dependencies definition, with current definition ex_doc, earmark and plug considered as mandatory package dependencies (see on Hex).\nIt might be solved with:\nelixir\n[{:joken, \"~> 0.15.0\"},\n {:poison, \"~> 1.5\"},\n {:earmark, \"~> 0.1\", only: :docs},\n {:ex_doc, \"~> 0.8\", only: :docs},\n {:plug, \"~> 1.0\", only: :test}]\n. Yes, there is an example https://github.com/hassox/guardian/blob/master/lib/guardian/plug.ex#L161.\nAnd other starts_with?/2 .. && .. places in that module.\n. I think for this case Enum.reduce(map, %{}, fn({key, val},acc) -> Map.put(acc, to_string(key), val) end) would be way better. This will work with Keyword as well.\n. ",
    "oscarduignan": "Thank you Daniel that did it! Still getting my head around Phoenix so I'm very greatful for your help solving that and thank you for all the work you've put into Guardian, it's proving really useful :+1: hopefully I'll be able to contribute something back soon as I get to know it and Phoenix better\n. ",
    "ryanswapp": "Are you referring to the Serializer? I just have the default setup that is in the README. Do I need to add more to it in order to support permissions?\n. ",
    "andreaazzini": "I think the problem with those two places reside in the nature of stringify_keys itself. If we handled its input data so that it is not nil in the first place, we'd be completely fine using Map. What do you think about this?\n. This looks good to me. @hassox any thought on this?\n. ",
    "doomspork": "@hassox if you haven't already started on this I'd be glad to give it a whirl.\n. @viniciusmkm this is what did the trick for me:\nelixir\nconn = conn()\n       |> sign_conn\n       |> Guardian.Plug.sign_in(resource, :token, perms: %{default: Guardian.Permissions.max})\n       |> Guardian.Plug.VerifySession.call([])\nThere is a sample Phoenix + Guardian app here.  I recently took a stab at updating the dependencies and submitted a PR, you can check out those changes here.\n. The error suggests Guardian.Plug.sign_in(resource, :token, perms: %{default: perms}) is failing (plug.ex#L83) but I'm not entirely sure why.  Have you double checked your setup and configuration are correct?\n. @viniciusmkm there should be some configuration in config/config.exs like your permissions and serializer.  Without seeing more of the code it's hard for me to discern the cause, perhaps someone else will have more insight.\n. @Lbatson I'm using Plug 1.0.2 and Guardian 0.6.2 together without issue.  \nAs for the tuple, I'm pretty sure Guardian assigns that value.  See plug.ex#L139 & plug_test.exs#L13\n. Hey @Lbatson I'm also on Erlang 18 and Elixir 1.1.1.  Unless I'm reading the @spec wrong the claims are always a tuple.  If you look at the method you linked to in Plug you'll see the spec define the claims parameter as being a tuple:  \n@spec set_claims(Plug.Conn.t, { :ok, Map }, atom) :: Plug.Conn.t\nI suspect there might be some other configuration you're missing.  Is your project on GitHub?  I recently updated the Guardian sample project to the latest dependencies, have you looked at that?  My changes are in a PR here: phoenix_guardian/pull/5\n. @Lbatson looks like you're right.  I've been using Guardian.decode_and_verify(jwt) which the Guardian tests use and that seems to work.  Once I updated my code to use Guardian.Plug.claims I was able to repo your issue.  While I was looking into the api_sign_in I found another issue so I'll open a PR for both.\n. Thank you for Guardian! \n. @bartekupartek it looks like you didn't configure your secret key:\nelixir\n    config :guardian, Guardian,\n        allowed_algos: [\"HS512\", \"HS384\"],\n        issuer: \"MyApp\",\n        ttl: { 30, :days },\n        serializer: MyApp.GuardianSerializer,\n       secret_key: \"lksjdlkjsdflkjsdf\"\n. This is a great change @hassox :+1:\n. Howdy @joshwlewis, any updates here? \ud83d\ude00 \n. @hassox / @joshwlewis any updates here?  If there's no movement how about we close?\n. @coryodaniel I say go for it!\n. @steffenix we haven't added anything to the library to handle this, others have found their own solutions.  If you or @coryodaniel want to open a PR, we can discuss the implementation \ud83d\udc4d . This has been handled via #238 . Thanks @michaelforrest, could you please squash? :+1: \n. @aaronrenner / @hassox \u2014 any updates on this functionality and PR #120?\n. What do you plan to put together @nicholaswyoung?  I think that might better dictate where it lives.\n@hassox already has a pretty solid example, so I'm not sure there's much need for more of those: https://github.com/hassox/phoenix_guardian\n. @nicholaswyoung is this something you're still working on or can we close this issue?\n. No worries @nicholaswyoung, congrats on the new kid!  I just wanted to check in.\n. Looks good @hassox :+1:\nNice job!\n. I'm not sure everyone is on 1.2 (I'm not 100%) and this would exclude them from updates, wouldn't it? Aside from some clean up, what are the advantages?  \nI'll defer to @hassox on this one\n. Very resourceful, thanks @hassox.  :+1: \n. We should probably consider adding sudo: false for faster builds and including an after block for docs, what do you think?\nMimicking what other Elixir projects have would give us something like this:\nyaml\nlanguage: elixir\nelixir:\n  - 1.0.5\n  - 1.1.1\n  - 1.2.0\nsudo: false\notp_release:\n  - 17.3\n  - 18.1\nafter_script:\n  - mix deps.get --only docs\n  - MIX_ENV=docs mix inch.report\n@hassox / @scrogson \u2014 what do you want to do about Elixir and OTP versions?  Should we move to 1.2 & 18.1 or continue to support 1.1 & 17.3?\n. Oh I just noticed inch included in there, my bad!  I just quickly grabbed the config from Plug,  I meant mix hex.docs.\n. You're right @aaronrenner, I was just thinking about master.\nWe can probably continue to push the docs manually but it looks like it is possible to automate with TravisCI:\nelixir\nafter_success:\n  - if [ \"$TRAVIS_REPO_SLUG\" == \"ueberauth/guardian\" ] \n      && [ \"$TRAVIS_BRANCH\" == \"master\" ] \n      && [ \"$TRAVIS_PULL_REQUEST\" == \"false\" ]; then\n      mix deps.get --only docs && MIX_ENV=docs mix hex.docs\n    fi\nTwo references I found:\n- Automatically publish JavaDocs\n- Conditional after_success\n. If we merge this before #94 we can add dogma as a check.\n. @hassox there's still 63 dogma errors, I didn't want to go crazy fixing them all until I made sure everyone was on board.\nMost of the remaining issue are with LineLength > 120.  If we stick with 80 there will be a lot more :grinning: \nThere's other small issues I can knock out as part of this PR.\n. Make that 56 remaining.  I missed a few pipe chains and corrected a few other issues.\nThe remaining issues:\n- Missing @moduledoc\n- Line Length > 120\n- Comparison to boolean in assertions; assert Permissions.any?(val, val, :other) == true can be replaced with assert Permissions.any?(val, val, :other)\nIf we change the line length to 80 there's 240 violations\n. Totally!  Let's sort out the line length, merge this, and then we can both work at cleaning it up.\n. @aaronrenner you're right, the test descriptions can be particularly tough to squeeze in under 80.  Truth be told I typically use 120 so I'm learning too :grinning:  \nI don't know if this is ideal but what I did was shorten the desc and use single letter variables:\n``` elixir\nBefore\ntest \"fetches the serialized sub from the token for current_resource\", %{socket: socket, claims: claims} do\nAfter\ntest \"fetch serialized sub for current_resource\", %{socket: s, claims: c} do\n```\nIn your example I might try something like:\n``` elixir\ntest \"not unauthenticated when session has specific key\", %{conn: conn} do\ntest \"doesn't call unauthenticated with session\", %{conn: conn} do\n```\nLet's see what @scrogson and @hassox have to say.\n. Thanks @mitchellhenke :+1: \n. This looks good to me :+1: \n. @aaronrenner we're going to stick with 80 for the time being and see if we can't make it work.  I can help you come up with shortened descriptions if you'd like.\n. I'm :+1: this but let's see what @hassox thinks.\n. I imagine it would work just like Guardian.Plug.EnsureAuthenticated only the handler function would be something like authenticated/2.\n``` elixir\nsome_controller.ex\nalias Guardian.Plug.EnsureNotAuthenticated\nplug EnsureNotAuthenticated, [handler: MyApp.MyAuthErrorHandler] when action in [:signin, :signup]\nmy_auth_error_handler.ex\ndefmodule MyApp.MyAuthErrorHandler  do\n  def unauthenticated(conn, _params) do\n  end\ndef authenticated(conn, _params) do\n  end\nend\n```\n. Sounds good @victorlcampos :+1: \nLet us know if you need a hand with anything :grinning: \n. Hi @victorlcampos, this is great thank you!  \nFor tuples and maps please do not use extra padding: {:ok, result} vs{ :ok, result }`.  I commented on a couple instances, could you look through your changes for others?\n. This is great @aaronrenner, I think it cleans the tests up quite nicely.\n. @aaronrenner out of curiosity, is that a result of the feedback you got on Plug?\n. I'm all seeing @aaronrenner, obviously! :stuck_out_tongue_closed_eyes: \nThere's a few repos I keep up-to-date on and Plug is one of them.  When you popped up I popped in to see what your changes were. :neckbeard: \nRegarding the feedback, I think within the scope of Plug it was warranted but doesn't necessarily apply here.  It makes sense for Plug not to obfuscate the lifecycle or misrepresent the flow in tests but for us the init/1 and call/2 lifecycle isn't as relevant.\nThat's my $0.02 :moneybag: \n. LGTM :+1: \n@hassox any additional thoughts?\n. Thanks @KushalP :+1: \n. This looks good @hassox :+1: \n. Looks good to me @hassox :+1:\n. Thanks @ricn :+1: \n. Nice work @aaronrenner :+1: \n. Whatever happened to this @aaronrenner and @hassox? \n. @aaronrenner any interest in finishing this?\n. Awesome \ud83c\udf89 \nThank you @aaronrenner \ud83d\udc4d \n. @hassox do you know what is left to finish here?  I can take this over to get it merged in.. @jayjun I'd be happy to lend a hand if you need any assistance getting this finished up and ready to merge \ud83d\ude00 . Closing in favor of #354 . Thanks @sasa1977 :+1: \n. @wende it shouldn't be necessary to duplicate permissions between default into admin, you can assign both to a user.  To work with your original plug, this is what I might do:\n``` elixir\ndefp user_claims(%User{admin: true}) do\n  %{default: [:see_page], admin: [:do_admin_stuff]}\nend\ndefp user_claims(_) do\n  %{default: [:see_page]}\nend\nPlug.sign_in(user, :token, perms: user_claims(user))\n```\nAs to why we need the key?  It allows for granular permissions.  You probably don't want users accessing your admin panel so you could do something like this:\nelixir\nplug EnsurePermissions, [handler: __MODULE__, admin: [:see_page]]\nDoes that help?\n. Looks good @hassox :+1: \n. Looks good @hassox :+1: \n. @hassox I went back over this and found a few pieces of feedback, then we can get this one merged \ud83d\udc4d \n. @martinos would you mind taking a shot at expanding on the documentation?\n. Looks good to me @manukall.  @hassox any thoughts or can we merge this?\n. @hassox any thoughts on this change?\n. @madshargreave did you add the hooks to your configuration?\nelixir\nconfig :guardian, Guardian,\n       hooks: Resend.GuardianHooks,\n       ...\n. No worries @madshargreave!  If you're on Slack, we have a Ueberauth/Guardian channel you can visit for support too: #ueberauth\nCan we close this issue now?\n. You're welcome @madshargreave, thank you \ud83d\udc4d \n. I believe this has to do with how and when configuration files are evaluated and compiled.  @ospaarmann can you try putting it in an anonymous function?\nelixir\nconfig :guardian, Guardian,\n  ...\n  secret_key:  fn -> System.get_env(\"GUARDIAN_KEY_PASSPHRASE\") |> JOSE.JWK.from_file(System.get_env(\"GUARDIAN_KEY_FILE\")) end,\n  serializer: MyApp.GuardianSerializer\n. @ospaarmann what about  Guardian.config(:secret_key).()?\n. @ospaarmann JOSE accepts functions: https://github.com/ueberauth/guardian#secret-key.  \nHave you tried using the configuration?\n. Thank you @nscyclone!  Fixing all the typos I leave in my wake \ud83d\ude1d \n. Thanks @nickgal \ud83d\udc4d \n. Fixed thanks to @danielfarrell \ud83d\udc4d \n. Thanks @danielfarrell, this looks good to me \ud83d\udc4d \n. Thank you @Hanspagh! @hassox any additional feedback?\n. @hassox any final feedback?  @Hanspagh do you mind rebasing?\n. Thank you @Hanspagh \n. Sorry for the delays @Hanspagh, I've not been following this thread.  Let me review the changes and see about merging.. Closing this for the time being.  If this comes back up we can create a new issue for the enhancement.\n. Thank you @yoshdog \ud83d\udc4d \n. Thanks @gusaiani \ud83d\udc4d \n. @srh-work can we close this issue?\n. @hassox this looks good, what's the rationale behind this change?\n. Sounds good @hassox, thanks! \ud83d\udc4d \n. @hassox do you want to merge this before we release a new version for #169?\n. @dustinfarris this is not yet used\n. @hassox can I merge this guy in for the new release?\n. Hi @victorsolis, this does not appear to be a typo.  JWT's type field is referred to as typ: https://jwt.io/introduction\n. @milmazz did you mean Elixir 1.3?\n. I don't think we need to worry about supporting 1.4-dev just yet.  I'm \ud83d\udc4e on this for now.  Dev and Release Candidate just make for more Guardian releases.\n@hassox any thoughts?\n. Because it is 1.4-dev which means between now and the release of stable 1.4 they may change many of these things requiring another Guardian release.  Chasing changes like this does a disservice to the community, we're forced to keep releasing versions to keep up with changes in a non-stable build.  \nWe haven't even incorporated with yet because we're still supporting people on 1.1.\nJust my $0.02.\n. Looking good to me @milmazz, thank you \ud83d\udc4d \n@hassox any objections?\n. Yes, sorry for the delays.\n. This was fixed by #169, we'll release a new version shortly.\n. @nimish-mehta could you rebase?\n. Yup \ud83d\udc4d \n. Thank you @iamjarvo \ud83d\udc4d \n. I believe this is fixed via #173, could you confirm @sanrodari?\n. This was actually fixed by #169, we'll release a new version shortly.\n. @chrisalley I've opened a PR to resolve this \ud83d\udc4d \n. Thank you @Voronchuk!  @hassox any thoughts?\n. Thanks for bringing this to our attention @christiansakai.  I personally don't have much experience with the debugger so maybe @hassox or @scrogson can chime in.\nIf not, I'd be happy to take a peek at this later in the week.\n. @christiansakai is this still an issue for you?\n. @AlejandroHuerta that's a good point.  That is almost certainly a more Elixir way of doing it.\n. @AlejandroHuerta right \ud83d\ude00  I've been working in Ruby too much lately and spaced on guards, thank you for saying something!  Guard is the more appropriate way to do this.\n. @hassox / @scrogson care to take a peek at this?  Looks good to me. \ud83d\udc4d \n. @AlejandroHuerta makes a good point in #180 that this could be accomplished with a guard  which is more of the Elixir way of doing it.\nelixir\nplug Guardian.Plug.EnsureAuthenticated, [handler: MyApp.SessionController] when not action in [:create, :new]\nWhat do you think @ospaarmann?  @hassox or @scrogson any thoughts?\n. @ospaarmann I am going to close this PR but please feel free to open a PR with README updates \ud83d\ude00 \n. Sorry @Neku, we'll be resolving this this week! \n. @douglascorrea there may have been a change to Phoenix Sockets that warrants a Guardian change, do you have a project we could look at that demonstrates this error?\n. @douglascorrea any updates or can I close this ticket?. Howdy @peuh!  Thanks for taking the time to report this.   Would you be open to implementing this functionality and updating the README? \n. @peuh that's okay!  We're more than happy to help with feedback.\n. @SLOBYYYY interesting point, have you raised this issue over at exrm or distillery? \n. Thank you @SLOBYYYY!!\n. This is awesome @aaronrenner!  I'll take a peek today and let you know if I have any feedback.\n. Thank you @aaronrenner \ud83d\udc4d \n. Hi @GildedHonour, have you looked at Guardian.Plug.EnsureAuthenticated? \nhttps://github.com/ueberauth/guardian#guardianplugensureauthenticated\n. @GildedHonour that functionality isn't provided by Guardian.  If you're familiar with the Ruby ecosystem Guardian is akin to Warden upon which Devise (and others) are built.\n. @GildedHonour as far I as know no one has built something like Devise for Elixir.  For my use-cases I roll my own functionality.\n. @jaybrueder you should be using Guardian.Plug.EnsurePermissions to check permissions.  It sounds like there may be something misconfigured with your application with regards to how Guardian.Plug.EnsureAuthenticated is working.\nDo you have an example project we could look at?\n. Thank you @ZJvandeWeg \n. Thank you @aaronjensen!  @hassox any thoughts?\n. Thank you @aaronjensen \ud83d\udc4d \n. @denisw could you create a sample project that reproduces your issue for us to look at?\n. Thank you @mkaszubowski \ud83d\udc4d \n. @aaronjensen doesn't look like Jose was updated in your changes.\n. We should also consider bumping the Elixir version to 1.2: https://github.com/ueberauth/guardian/blob/master/mix.exs#L18\n. Looks like we'll need to update the TravisCI configuration for this too.  Sorry for the back-and-forth @aaronjensen, would you be willing to make a change to .travis.yml?\nThis will drop testing for Elixir 1.1 and OTP 17.\nyml\nlanguage: elixir\nelixir:\n  - 1.2.5\n  - 1.3.4\notp_release:\n  - 18.3\n  - 19.0 \nenv: MIX_ENV=test\nsudo: false # faster builds\nnotifications:\n  email: false\nscript:\n  - mix compile --warnings-as-errors\n  - mix test\n  - mix credo\n. @aaronjensen after playing with it a bit tonight, I believe this is what we need:\nyml\nlanguage: elixir\nmatrix:\n  include:\n    - otp_release: 18.3\n      elixir: 1.3.2\n    - otp_release: 19.0\n      elixir: 1.3.2\nsudo: false\nscript:\n  - mix test\n. @aaronjensen I think we can safely drop 1.2 in favor of 1.3 now that 1.4 is preparing to ship.  I've gone ahead and updated the rest of the projects within the Ueberauth organization.\n. @aaronjensen I pulled your branch, updated the .travis.yml and targeted 1.3, and pushed to master.  Thanks again \ud83d\udc4d \nI've released a new version as well.\n. @manuelsteiner this isn't something I've personally run into, your suggestion of working back from ttl sounds reasonable.  @hassox have you done anything like this?\n. Thanks @victorsolis \n. @pcewing some changes have been merged into Guardian that should improve how this works.  If you'd like to submit a PR to further clarify in the README that would be welcomed \ud83d\udc4d . Thank you @jeisenberg \ud83d\udc4d \n. Thanks for the heads up @kbredemeier, we'll have to look into this!  @hassox have you run into this yourself yet?\n. @kbredemeier do you want to take a stab at a PR?  If not either @hassox or myself can make the change.\n. Thank you @kbredemeier, I'll cut a release this evening.\n. @vic while I agree a warning is not pretty but I'm not sure if it warrants a wholly separate library.  @hassox do you have any thoughts?. Hi @OpakAlex!  There are some links in the README for resources plus a few blog post floating around.  We're working on some more in-depth lessons now \ud83d\ude00 \n- https://github.com/ueberauth/guardian#useful-articles\n- http://hassox.github.io/\n. @michalmuskala all for this!  @hassox created a package to support this and we just never got around to incorporating it: https://github.com/hassox/config_values\n. Thank you @michalmuskala!  @hassox any thoughts on this before I merge?\n. @michalmuskala could you bump the credo version so the build passes?\n. Thank you @michalmuskala!\n. Thank you for the report @coryodaniel, I'll take a peek at your PR today \ud83d\udc4d \n. Thank you @coryodaniel!\n. @hassox I'm all for this change, any thoughts or concerns before I merge and cut a new version?  This will be a breaking change.\n. @coryodaniel he was referring to you about the changelog but I can do that if you'd rather \ud83d\ude00 \n. Thank you @coryodaniel \ud83d\udc4d \n. Hi @Dtatoo, do you have a project on GitHub I could look at?\n. Howdy @roehst!  This does work as intended for the reason you outlined.  Have you taken a peek at @hassox's other project GuardianDB?  It may provide some answers https://github.com/hassox/guardian_db\n. @hassox / @scrogson \u2014 do you have any thoughts on a release schedule?  I think they're useful but with volunteer open source I think it can be tricky.\n. We're not going to worry about release schedules for the time being.  When we get to 1.0.0 we can reconsider them.. @bobbypriambodo as-is Guardian will not work with Phoenix.Token.  While the verify_module allows you to configure the verification step, it is still relying on a JWT being decoded: https://github.com/ueberauth/guardian/blob/5f9488ab253a0ef6c7e97bb8184d8c7320dbbfd3/lib/guardian.ex#L227-L229\nI'm not sure Guardian is the right place for this functionality seeing as we've built the library around JWTs.  If it's not too late I'd ditch Phoenix.Token in favor of JWT.  JWT will be supported across any platform you work with (even if you were to migrate away from Phoenix) whereas the same cannot be said for a Phoenix.Token (AFAIK).\n. Thanks @secretworry!  It looks like Credo is failing, could you take a look at that?. Thank you @secretworry \ud83d\udc4d . Thank you @alexandrubagu . Thank you @twinn \ud83d\udc4d . Thank you @vic \ud83d\udc4d . This is fantastic @ericsullivan, thank you!! \ud83d\udc4d \n@hassox / @scrogson any thoughts before I merge this?. Thank you @ericsullivan \ud83d\udc4d . Thank you @ericsullivan, I'll go through this later today and leave feedback.\n@hassox / @scrogson \u2014 thoughts?. Closing this since we won't be adding mutli-hook support to Guardian at this time.. Howdy @ericsullivan!  As of now there is no plans to expand the scope of Guardian but I have no objections to your using that package name.  We can create a section in the README/Wiki for Guardian plugins, does that seem reasonable to you?\nAny thoughts @hassox?. This seems reasonable to me @ericsullivan \ud83d\udc4d . Thank you @ericsullivan, I'll review this today and leave feedback \ud83d\udc4d . Thank you again @ericsullivan \ud83d\udc4d . @kenips / @mariusbutuc \u2014 I'm going to cut 0.14 this weekend with a bunch of changes and bumping the Elixir version to 1.3.. Thank you @mariusbutuc \ud83d\udc4d . Thanks for the report @yuchunc \ud83d\udc4d   I'll take a peek at your PR today.. @jamesvl I intend to cut a new release today but in the meantime you can use master:\nelixir\n{:guardian, github: \"ueberauth/guardian\"}. 0.14.1 has been released.. @larryweya / @collegeimprovements / @NilsLattek \u2014 a fix has been merged into master, before I cut a new release could one of you please verify that master is working for you?  I'm currently traveling and don't have everything I need to smoke test it.. Thank you @Ch4s3 and @larryweya \ud83d\udc4d . I've released 0.14.2, hopefully this resolves everyone's issues.  The ueberauth org is taking over GuardianDB maintenance so I'll be putting some time into clean-up in the coming weeks.. Thank you @yuchunc, @faywong I'll be releasing a new version this week.  For the time being you can use:\nruby\n{:guardian, github: \"ueberauth/guardian\"}`. Thanks for the report @collegeimprovements \ud83d\udc4d . Thank you @koriroys \ud83d\udc4d . Howdy @koriroys, the :serializer was introduced in an earlier PR for the purpose of making testing easier: https://github.com/ueberauth/guardian/pull/188#issue-172057601\nIn my applications I rely on a single serializer for all of my resources because it keeps things in one place and there's rarely much logic to them.. 0.14.2 has been released.  I'll retire 0.14.1 later today.. Thank you @NilsLattek . Thank you @smythey21 \ud83d\udc4d . Thank you @larryweya.  I'm closing this, another PR contains this exact solution: #248 . Hi @smoes, have you taken a look at the GuardianDB project?  With GuardianDB you can track tokens and prevent playback. You're welcome @smoes! \ud83d\udc4d . Thanks for the report @hykw, I'll take a look \ud83d\udc4d . Thank you @ericsullivan!  While we're updating the typespecs we don't we fix after_sign_in/2?  Based on the code here it does not return a connection:\nhttps://github.com/ueberauth/guardian/blob/9720eb6fc5278a9945f4235b0488f7480aeaa086/lib/guardian/plug.ex#L179-L184. @ericsullivan if you can rebase this to resolve the conflict I'd be happy to merge \ud83d\udc4d . That's a good point @asummers, @ericsullivan would you mind incorporating that change?. Thank you @ericsullivan! \ud83d\udc4d . Thank you @asummers \ud83d\udc4d . @asummers I do not believe that was left out intentionally (@hassox?), if you'd like to open a PR with that addition that'd be stellar \ud83d\udc4d . Good catch @asabil!  This will be a major breaking change so we'll need to think about how to approach this.. @asummers thanks for opening this!  @hassox and I have been discussing what v1.0 would look like lately and this is certainly something to take into consideration.. Thank you @alexandrubagu!  I'll look over this later this evening and we get it merged if we're all good to go \ud83d\udc4d \n@hassox feel free to take a peek at this.. @snewcomer I still need to look through this PR but we are not making changes for 1.3rc, please see the previous threads on the topic: https://github.com/ueberauth/guardian/issues/276. Thank you @alexandrubagu! . @hassox / @scrogson any final comments before I merge?. Thank you again @alexandrubagu and apologizes for the delays.. Thank you @Moxide \ud83d\udc4d . Hi @jonathanraes, isn't the get(\"/\") performing a request?  This is the code I use in my test helper for sign in:\n```elixir\n@secret String.duplicate(\"abcdef0123456789\", 8)\n@signing_opts Plug.Session.init(Keyword.put(@default_opts, :encrypt, false))\ndef conn_with_fetched_session(the_conn) do\n  put_in(the_conn.secret_key_base, @secret)\n  |> Plug.Session.call(@signing_opts)\n  |> Plug.Conn.fetch_session\nend\ndef sign_in(conn, resource, perms \\ %{default: Guardian.Permissions.max}) do\n  conn\n  |> conn_with_fetched_session\n  |> Guardian.Plug.sign_in(resource, :token, perms: perms)\n  |> Guardian.Plug.VerifySession.call(%{})\nend\n```. Thanks @bryanjos!  I don't see any issues with this being customizable so long as we retain a san default.  @hassox any thoughts?. Thank you @jaysoifer! \ud83d\udc4d . Thank you @t4t5.  Since 1.3 is still a ways off, I don't believe we'll be making any changes here just yet. Please try @DisruptiveMind solution.. This has been addressed in a prior issue: https://github.com/ueberauth/guardian/issues/273\n. @EvertYipYip this is the third issue created for 1.3, please check the previous issues: https://github.com/ueberauth/guardian/issues/274. Please see the other issues on 1.3 compatibility: https://github.com/ueberauth/guardian/issues/273. @josephan I'm not 100% sure this is the easiest method to generate a secret key.  I imagine most Guardian users will be using Phoenix in which case mix phoenix.gen.secret is the easiest:\nelixir\n$ mix phoenix.gen.secret\nRej/IfETpAhNvueAL/SxQ/G9qnFtwAtSg7rBPFnga6wk7nP6qgkdZFc9vsU3XfhJ. @casio / @josephan \u2014 if either of you thinks the README could be improved feel free to open a PR we can review \ud83d\ude01 . @josephan if you want to update this to use @casio's suggestion that would be great \ud83d\udc4d . No worries @josephan, thanks again for the contribution \ud83d\ude01 . At first glance it looks like Fernet would require a bit of work but it doesn't look impossible.  How would you propose using Fernet @Hostert?  If you generate a JWT and then apply Fernet to that, it doesn't look like much work at all.. @Hostert Guardian is closely tied to JWT, it's more than just verifying the token.\nWhat would you use Fernet to hash?  How would hashing that generic value differ from hashing a JWT with Fernet?. We'll keep and eye on this and we can revisit in the future @Hostert \ud83d\udc4d . Thank you and welcome @yogipatel!. @asummers / @xadhoom I will work on that this week, sorry for the delays \ud83d\udc4d . @maxnordlund please see one of the many issues on Phoenix 1.3 where this has been discussed: https://github.com/ueberauth/guardian/issues/288. There's no plan to do that @maxnordlund but thank you.  Issues like this come up when using Elixir all the time, it's important to handle it the proper way (as mentioned in those issues) and not force packages to loosen their dependencies.. Thanks @maxnordlund \ud83d\udc4d . Howdy @ericsullivan!  Thank you for your interest in contributing to Guardian!\nIn the future please open issues for discussions around new features.  This is not something we\u2019re looking to support at the time and it adds in additional dependencies that are outside the scope of this library.. Thanks @ericsullivan, please see my comment on #297 . @ericsullivan there are quite a few authentication libraries already for Elixir, Guardian just happens to be the JWT solution.\nhttps://github.com/h4cc/awesome-elixir#authentication. Hi @ericsullivan, thank you for your continued interest in contributing to Guardian!\nWe are not looking to change variable names at this time as this may introduce unnecessary conflicts in a large number of changes we are currently undertaking.\nIf you're interested in contributing I would encourage you to look for existing issues or to create your own so we can discuss the proposed change.\nThanks!. I should add while not as active as we'd like, we are available to discuss proposals on Elixir Slack in the #ueberauth channel.. Another discussed option:\n```elixir\ndefmodule MyApp.AuthPipeline do\n  use Guardian.Pipeline, \n    module: MyApp.Tokens, \n    error_handler: MyApp.ErrorHandler\nplug Guardian.Plug.VerifySession, claims: %{\"typ\" =>\"access\"}\n  plug Guardian.Plug.VerifyHeader, realm: \"Bearer\", claims: %{\"typ\" => \"access\"}\n  plug Guardian.Plug.EnsureAuthenticated\n  plug Guardian.Plug.LoadResource, allow_blank: false\nend\n``. Here's an example implementation of theGuardian.Pipeline`:\n```elixir\ndefmodule Guardian.Pipeline do\n  use Plug.Builder\ndefmacro using(opts) do\n    quote do\n      use Plug.Builder\n  import Guardian.Pipeline\n\n  plug :put_module, module: Keyword.get(unquote(opts), :module)\n  plug :put_error_handler, module: Keyword.get(unquote(opts), :error_handler)\nend\n\nend\ndef put_module(conn, opts) do\n    module = config_value(opts, :module)\n    Plug.Conn.put_private(conn, :guardian_module, module)\n  end\ndef put_error_handler(conn, opts) do\n    module = config_value(opts, :error_handler)\n    Plug.Conn.put_private(conn, :guardian_error_handler, module)\n  end\ndefp app_config(opts) do\n    case Keyword.get(opts, :otp_app) do\n      nil -> opts\n      otp_app -> Application.get_env(otp_app, MODULE) ++ opts\n    end\n  end\ndefp app_config(opts, key) do\n    value =\n      opts\n      |> app_config\n      |> Keyword.get(key) \nvalue || raise \"#{key} is required!\"\n\nend\nend\n```. @atom-r this has been covered numerous times already.  Please look at the many existing issues concerning 1.3 compatibility:\nhttps://github.com/ueberauth/guardian/issues/273\nhttps://github.com/ueberauth/guardian/issues/274\nhttps://github.com/ueberauth/guardian/issues/276\nhttps://github.com/ueberauth/guardian/issues/277\nhttps://github.com/ueberauth/guardian/issues/279\nhttps://github.com/ueberauth/guardian/issues/288. Thanks and welcome @samhamilton!. I have a project at work currently using an earlier version of Guardian.  I'll try to set aside some time to upgrade to v1 and document the process.. Thank you @samhamilton \ud83d\udc4d . @phtrivier could you share more of your configuration?  I took the key you provided above, threw it into an old project of mine (https://github.com/doomspork/watercooler), generated a JWT, and was able to verify it via jwt.io:\nelixir\niex> {:ok, jwt, full_claims} = Guardian.encode_and_sign(%Watercooler.User{id: 1}, :access) \n{:ok,\n \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJVc2VyOjEiLCJleHAiOjE1MDEyODg1MDUsImlhdCI6MTQ5ODY5NjUwNSwiaXNzIjoiV2F0ZXJjb29sZXIiLCJqdGkiOiI2YTYxY2RhNC01NDRiLTQ3YTMtYTRhMS0yMDRkYzVhMjk2YmQiLCJwZW0iOnt9LCJzdWIiOiJVc2VyOjEiLCJ0eXAiOiJhY2Nlc3MifQ.V0ZWIJdisREd9kB5g1GahwVZ4S9RdglucCz7b31sd87MGkhz-i7-X-MdXn2cWxxFw9I2v1AKNgx-07LJUYCvVg\",\n %{\"aud\" => \"User:1\", \"exp\" => 1501288505, \"iat\" => 1498696505,\n   \"iss\" => \"Watercooler\", \"jti\" => \"6a61cda4-544b-47a3-a4a1-204dc5a296bd\",\n   \"pem\" => %{}, \"sub\" => \"User:1\", \"typ\" => \"access\"}}\n\nDouble check that you're not adding whitespace to the secret by mistake.. Thanks @samhamilton!  Do we want to allow failures on OTP 20 via the allow_failures option?  As I understand it there's not complete support for it as-of yet with Elixir.. Great, thanks for the heads up @odarriba!  @hassox do you have any problems with merging this?. This is fantastic @jayjun!  @hassox will these changes impact your v1 changes?. @hassox I think that's a very valid concern.  We could put this code in the org under a Guardian.Test package and look to include some additional test helpers.  Then you could take security a step further by ensuring the dependency is limited to test.. @jayjun / @hassox \u2014 if we can agree on a package name I'll get the repo put up and the initial project kicked off.. @scrogson the original PR (and this one) are based on the ideas shared in this ThoughtBot article: \nhttps://github.com/thoughtbot/clearance#fast-feature-specs\nhttps://robots.thoughtbot.com/faster-tests-sign-in-through-the-back-door. You're right, it can't be conditionally included at the mix level.  Good catch @scrogson!  . @jayjun we have decided to move this out of guardian and into it's own package.  I will create the basic project structure in https://github.com/ueberauth/guardian_backdoor if you'd like to move these changes to there  \ud83d\ude01 . @hassox if we merge this to master we should make a branch for 0.14 so we can continue to patch it and maintain it until v1 is ready to go.. You da \ud83d\udca3  @hassox!. ~~@tmock12 I merged in your branch to master so we'll have that fix on 0.14, we can rebase this to pick up those changes \ud83d\udc4d~~\n@tmock12 I noticed that this is already fixed in this branch by an earlier commit so we're good \ud83d\ude01 . Thank you @nekath!  I corrected the ones you pointed out in addition to a few other occurrences I found \ud83d\udc4d . Howdy @TheAncientGoat, this is the intended functionality.  If you wish to use the bearer realm you need to update your VerifyHeader plug to pass in opts:\nelixir\nplug Guardian.Plug.VerifyHeader, realm: \"Bearer\"\nIn the upcoming version of Guardian (v1), this will be the default. \ud83d\udc4d . @TheAncientGoat sure!  We're hoping to release v1 soon and that will make this a default but in the mean time a comment in the README is a good idea \ud83d\udc4d . Looks good @tmock12, thanks \ud83d\udc4d . Thank you @jayjun but this was addressed by #360. That sounds good @hassox \ud83d\udc4d . Thanks for the report @plamb!  I'll take a peek this week but in the mean time we'll see if @hassox has any thoughts.. Updated @hassox \ud83d\udc4d . I'll take a peek this weekend @hassox, just returning from vacation \ud83d\ude00 . Great, thank you @asummers!. @sebastiandelaroche a PR is welcomed to make the change \ud83d\udc4d . Welcome and thank you @david-wilson \ud83d\udc4d . Sounds good @hassox \u2014 good chat \ud83d\ude00 . Good catch @hassox, we can close this.\n@waiting-for-dev if you're looking for pre v1.0, the documentation is here: https://github.com/ueberauth/guardian/tree/v0.14.x#guardianplugensureresource. Thank you @praveenperera \ud83d\ude00 . @praveenperera we're going to be working on an updated example application for Guardian and Ueberauth to better illustrate the features and implementations \ud83d\udc4d \nIn the mean time, do you have specific questions?. Thank you @maartenvanvliet \ud83d\udc4d . Thank you and welcome @vickris \ud83d\udc4d . @oskar1233 do you have some example code we could look at?. Go for it @hassox \ud83d\udc4d . @KronicDeth I'm not 100% sure this PR really adds much value to the README.  For one not everyone is using Phoenix (I don't) and secondly without more explanation the two almost identical code examples are actually confusing.\n@hassox or @scrogson, any thoughts?. Thank you for correcting this @oskar1233 \ud83d\udc4d . Thank you and welcome @roperzh \ud83d\ude01 . Howdy @drowzy!  Thanks for the report but this is functioning as intended.  \nThis was discussed quite a bit when we were working on v1 (see discussion here: https://github.com/ueberauth/guardian/pull/377#discussion_r135806789) and the decision was made to remove {MySecretKey, :fetch} since {{MySecretKey, :fetch, []} accomplishes the same goal while reducing the amount of code to maintain.. Thank you for the report @rbino!  We'll look into this \ud83d\udc4d . @rbino looks like we've already got a PR staged for this ( #397 ) so I'm going to close and cut a new release today \ud83d\udc4d . @hassox any objections before I merge?. @uzarubin let's fix that as part of this too \ud83d\udc4d . This looks good to me @rbino thank you for doing this!  @hassox any final thoughts?  It would be good to get this in.. Thank you @janpieper \ud83d\udc4d . Thank you @jfornoff \ud83d\udc4d . @Euklidian-Space which version of Guardian are you currently using?. @Euklidian-Space if you're using Guardian 1.0 you'll need to change up the params to sign_in.  Try something like this:\nelixir\nVoter.Guardian.Plug.sign_in(conn, user, %{}, token_type: \"access\"). Sounds like a bug in 1.0, thanks for the report!  It looks like we drop the entire session here: https://github.com/ueberauth/guardian/blob/master/lib/guardian/plug.ex#L254. @vjorjo I will release a new version later today or tomorrow, time permitting \ud83d\udc4d . @yordis is correct, you're referencing a function that does not exist.  Thanks for helping out @yordis \u2764\ufe0f . @yordis if you'd like to open a PR to update the docs with that snippet go for it \ud83d\udc4d . @julien-leclercq it sounds like the module name might be confusing?  The Guardian.Plug module isn't a plug, it's a collection of helpers for working with a connection.. @Hanspagh I'm open to letting Plug.EnsureAuthenticated handle it, I think that keeps everything in one place.  @ueberauth/core any objections to this?. @Hanspagh is this good to review now?  It appears all the items have been addressed \ud83d\ude00 . @yordis I think elixir-lang enforces the formatter has been run by CI?  We should do that if possible \ud83d\ude01 . @hassox can you give this another look over before we merge and release?. Thank you @Hanspagh!  @ueberauth/developers any final thoughts before we merge?. @hassox / @scrogson any final feedback?  You both spent more time reviewing this PR than I did.. That's awesome to hear @robmadole.  I'm merging this so we can cut a release this week \ud83d\udc4d . Thank you @rosswilson \ud83d\ude00 . remember_me will be added back in via #419 and released as 1.1.0. Thank you @yordis \ud83d\udc4d . @yordis there is a conflict with the README apparently. @Hanspagh agreed, thank you \ud83d\udc4d . @willsoto / @Yamilquery are you still experiencing this issue or can this be closed?. @yordis and @SofaKing18 v1.0.1 has been released \ud83d\udc4d . @edouardmenayde thanks for getting involved!  I agree with @edouardmenayde that this doesn't really belong in the code documentation, especially not without more context.\nPerhaps we should look into adding a section to the README for now on testing best practices?\nThoughts @ueberauth/developers?. Thank you @edouardmenayde! \ud83d\udc4d . @pedromvieira this sounds like you may have discovered a bug (or a needed feature).  Have you had a chance to peek at the Guardian plug?  I'll try to set aside some time this week to look into this more for you.. Thank you @axelson!  If there's any other changes you can think of that would help make the transition better, let us know \ud83d\udc4d . Thank you @robmadole!. Thank you @lukaszsamson . @tarzan please do open a PR \ud83d\udc4d . @mirago we wanted to package up some other changes but we can cut a release with these changes \ud83d\udc4d \nIn the meantime you can do: {:guardian, github: \"ueberauth/guardian\"}\n. Thank you @svileng \ud83d\udc4d . Thank you @mhanberg and @yordis \ud83d\udc4d . Thank you @davepersing \ud83d\udc4d . Thank you @tarzan!  We'll look at this and get back to you \ud83d\udc4d . @hassox / @scrogson any final thoughts or can we merge this?. Thank you @svileng, good catch \ud83d\udc4d . @zapient a PR to correct the documentation is welcome \ud83d\udc4d . Thank you @zapient \ud83d\udc4d . @davepersing if you're open to helping with the on-going maintenance we'd love to have you join the Ueberauth team to help with those efforts.  Is this something you'd be open to?. @davepersing if you want to transfer the repo to ueberauth I will accept it and add you to the org \ud83d\ude01 . @davepersing I've invited you to our freshly created @ueberauth/jwe team \ud83d\ude01 \n@davepersing do you have a twitter handle btw? . Welcome aboard @davepersing \ud83c\udf89 . Thank you @janpieper \ud83d\udc4d . Thank you @hlhr \ud83d\ude01\nAny other documentation enhancements you can think of \ud83d\udc4d . Thank you and welcome @alex88!  Any other improvements to the documentation you can think of would be welcomed \ud83d\udc4d . @yordis I'm open to dropping the other versions for Travis.  @hassox thoughts?. Thank you @san650!. Agreed. We'll nuke the extra branches. There's no reason for us to keep an older version around and worry about backporting. That's not something that's been done for many, if any, Elixir packages. I think things are moving fast enough to expect folks to upgrade.. Thanks for the heads up @rafamedina / @NeoAlchemist \u2014 we'll try to make time to look into this. In the mean time, PRs are welcome if you're already investigated \ud83d\ude01 . Great idea @yordis \ud83d\udc4d . @alexferreira since there is no description or context on this PR, I must ask:  Why?. @scrogson awesome!  If you're happy, merge away \ud83d\udcaa . Thank you @ckhrysze \ud83d\ude01 . Thank you @pera!  Any improvements to the documentation is welcomed \ud83d\udc4d . We welcome any improvements you can think of!  Documentation could use much love.. Thank you @pdgonzalez872!  Hope you're having a wonderful day \ud83d\ude01 . @yordis are you satisfied with this change now?  If so let's merge. Thank you @scooter-dangle \ud83d\udc4d . @egeersoz a PR is welcomed \ud83d\udc4d . Howdy @asummers, thank you for getting involved!  I think this is a good idea we should explore further.  I've added the other contributors so they too can take a peek \ud83d\udc4d \nAs for documentation:  We always welcome more.. @yordis I'm pretty sure we can release with a rc package, we just don't want to do that for things like Phoenix where people will expect a new release with every rc.  It's quickly a slippery slop with some dependencies.. @asummers are you on Elixir Slack?  We all lurk on #ueberauth if you ever want to come through and discuss potential changes.  \nWe're always looking to add motivated folks to the team \ud83d\ude01 . Thank you @asummers!. Thank you @sneako \ud83d\udc4d . @yordis / @toraritte should we add a note to the README about generating the documentation for future users?. I'm definitely onboard with pulling out Phoenix because it includes far more than needed for Guardian to function. I'm not entirely sure the same can be said for Plug.  \nSo my first question is by pulling out Plug what we do hope to gain?\nMy concern remains: if 99% of Guardian users are using it with Plug in some fashion (including Phoenix) pulling it out of guardian just makes using the library involve that many additional steps. I'm also not convinced Plug so large a dependency that even if you weren't using Guardian for that, you're not pulling in dozens of sub-dependencies resulting in some insane dependency tree.\nAlso let's keep in mind this just makes even more packages to manage. That's not our strong suit right now \ud83d\ude01 \n@hassox / @scrogson any thoughts on pulling out Plug vs keeping it?\n. Thank you @hassox \ud83d\udc4c\n@yordis we can focus on v2 without the inclusion of Phoenix. There may be opportunities to refactor some of the code we hoped to target by pulling Plug out. It would be a good start to document them in issues and start a conversation around them. Collectively we can probably come up with a good solution that provides clear boundaries while keeping the library usage for the vast majority of the users.. @Hanspagh I'm not familiar with using sockets outside of Phoenix, when/why would you need that?. @Hanspagh all of the Phoenix functionality is moving into guardian_phoenix, so folks will still have access to them. We'll update the guides to reflect the new package.\n. No worries @Hanspagh! Glad we're on the same page \ud83d\ude01 . @shanmugharajk what version of Guardian are you using?. Removed. @yordis for my own edification can you explain how you figured that out? Reading the Travis logs it looks like Dialyzer took too long. Each of the apps built just fine.\n```shell\n==> guardian\nCompiling 20 files (.ex)\nGenerated guardian app\nmix format --check-formatted\nmix credo --strict\nChecking 20 source files ...\nPlease report incorrect results: https://github.com/rrrene/credo/issues\nAnalysis took 2.6 seconds (0.05s to load, 2.6s running checks)\n309 mods/funs, found no issues.\n....\nGenerated phoenix app\n==> guardian\nCompiling 23 files (.ex)\nwarning: no configuration found for otp_app :guardian and module Guardian.Phoenix.SocketTest.Endpoint\nGenerated guardian app\n..........................................................................................................................................................\nFinished in 2.2 seconds\n154 tests, 0 failures\n```\nThe failure:\n```shell\nAdding 929 modules to dialyzer.plt\nNo output has been received in the last 10m0s, this potentially indicates a stalled build or something wrong with the build itself.\nCheck the details on how to adjust your build configuration on: https://docs.travis-ci.com/user/common-build-problems/#Build-times-out-because-no-output-was-received\nThe build has been terminated\n``. Thank you @bortloff!. @garretttaco thanks for bringing this to our attention. A PR to fix these would be greatly appreciated \ud83d\ude01 . Sorry @barthez, I missed your PR and fixed this via another merge.. Thank you @Hanspagh! If you're interesting to helping with the documentation we've got a Guardian lesson over on https://github.com/elixirschool/elixirschool that is out of date.. Tests are failing @yordis . @yordis would we want this PR and #584 as part of V2?. I see no point in returning a tuple as a string. We should probably just be sending thereason`.. @Hanspagh I will look through this later today or tomorrow but I'm loving the refactoring so far! I'm all for improving the maintainability of the code. \ud83c\udf89 . @Hanspagh now would be the time to change the module name. While V2 is merged, it has not been released, and this could be included as V2 is a breaking change.\nThoughts?\ncc @yordis . We should probably capitalize Phoenix.\n. Thanks :+1: \n. I think you should use pipes here:\nelixir\ntype\n|> String.to_existing_atom\n|> available\n. ping @michaelforrest \u2014 If you could update \"Phoenix\" this should be good to merge. :grinning: \n. \"shoule\" -> \"should\"\n. What do you think about adding parenthesis and removing the extra whitespace in %{} for consistency?\nelixir\nbroadcast(socket, \"pong\", %{message: \"pong\", from: user.email})\n. Extra space in map: %{ error: reason}\n. Spaces padding map\n. Extra whitespace after jwt\n. Remove padding at the start and end of the map for consistency.\n. @scrogson do you want to change this back to 80?\n. @hassox once we decide on this, the PR should be good to go.\n. Warning: \nshell\nlib/guardian/permissions.ex:174: warning: this clause cannot match because a \nprevious clause at line 168 always matches\n. Warning: \nshell\nlib/guardian/plug/verify_header.ex:38: warning: unused import Guardian.Keys\n. Warning: \nshell\nlib/guardian/claims.ex:113: warning: variable iat is unused\n. Warning:\nshell\nlib/guardian/channel.ex:41: warning: variable key is unused\n@hassox this was probably a bug, key wasn't being unquoted.  Can you review this change?\n. @hassox I made this change because, at first glance, it didn't look like opts was being used other than retrieving key and converting to a map seemed like overkill.\n. These could be shortened like such: \n``` elixir\ntest \"sends a 401 response when text/html\", %{conn: conn} do\n...\nend\ntest \"send a 401 response when application/json\", %{conn: conn} do\n...\nend\n``\n. @hassox what's your plan with the changelog, did you want this to bev0.10.1?\n. This should be{:error, _reason}`.  \nCould you also remove the padding in the tuples? {:ok, claims} vs { :ok, claims } \n. Please remove the extra padding in this map.\n. This plug ensures there isn't a valid JWT, right? :grinning:\n. Please remove extra padding.\n. Good catch! \n. Hey @victorlcampos, for consistency sake could you remove the extra whitespace in your Maps and Tuples?  There's a couple instances in this file.\n%{ \"aud\" => \"token\", \"sub\" => \"user1\" } -> %{\"aud\" => \"token\", \"sub\" => \"user1\"}\n{ :ok, claims } -> {:ok, claims}\nThanks :+1: \n. @aaronrenner could you remove the whitespace padding in tuples and maps as you change them?\n. @aaronrenner no, I don't think that's necessary.  We can update them as we go through and change code.\n. Credo catches these?  Awesome!\n. \"looking\"\n. \"and makes it available\"\n. Maybe we can rewrite this to be a little clearer, something like: \n\"Note:  This does not ensure a resource will be loaded.  If there is no available resource, current_resource/1 will return nil.\"\n. @hassox do you know which version of Poison we require?\n. I think >= 1.3.0 is a good option.\n. \"The first set\"\n. Do we want to support :refresh?  We use atoms elsewhere.\n. Could you add a space after # and capitalize Issue?  Same feedback for the comment below.\n. Why did you include Phoenix?  I don't think we want to support release candidates, we'll end up having to release new versions frequently to keep up.\n. allowed_actions feels strange to me here.  Could we rename this to something akin to exempted_actions?\n. Could we use a pipe here?\nelixir\nclaims\n|> Map.get(\"sub\")\n|> serializer.from_token\n. Thank you @aaronrenner!  With that change this is good to merge.\n. After conferring with @hassox and @scrogson, we're going to bump this to 1.3 and drop 1.2\n. @coryodaniel it's nitpicky but could you fix this and rename the parameter?\n. I was wondering about this myself but I didn't see anything in the docs, I can swap it up.. This doesn't appear to matter and I think it reads a bit clearer this way so I'm going to leave it unless @scrogson or @hassox feels strongly about it.. @alexandrubagu do we need to include the patch version?  1.8 should cover 1.8.x. Please remove extra whitespace.. What this change necessary?. What is the reasoning behind this change?  Seems unnecessary.. Why did you remove the pattern matching?. Let's go back to using pattern matching here, it's not clear to me why it was removed in the first place.  In fact the resulting code is worse without it, we're now reliant on using pipe chains within function calls to get the values we want.. We do not want to use pipes inside function calls, this is messy.. Should this be 1.3-rc and will this require us updating the package for each release candidate?. @alexandrubagu could we update this to: {:phoenix, \"~> 1.2\", optional: true}?  I believe it'll address most of the 1.3rc1 concerns at the same time \ud83d\udc4d . This requires you provide an :otp_app but if you configure via the plug that is unnecessary.. This is an incomplete sentence, how about:\n\"By default JSON Web Tokens are supported out of the box but any token can be used with Guardian as long as it meets these requirements:\". What is \"TokenModule\"?  It's capitalization and naming suggest it's a module that exists, but I believe that is not the case?  If it does exist, should it be within backticks with the full module name (Guardian.TokenModule)?. Should you include the arity for things like decode_and_verify?. I concur with @hassox's suggestion, how about we add something like this to the init function:\nelixir\nunless Mix.env == :test, do: raise \"Guardian.Plug.Backdoor should only be used in test!\". @hassox I don't even see a need for this in :dev, do you?  I can see someone mistakenly deploying their code without setting MIX_ENV=prod and this would leak.  Thoughts?. To be consistent with your other functions you could do this as:\nelixir\napply(f, [])\nIt's the tiniest bit faster too.. We could refactor this to DRY-up the error handling and remove the nested if/case:\n```elixir\ndef call(conn, opts) do\n  conn\n  |> GPlug.current_token(opts)\n  |> verify\n  |> respond\nend\ndefp verify(nil, _opts), do: {:error, :unauthenticated}\ndefp verify(_token, opts) do\n  conn\n  |> GPlug.current_claims(opts)\n  |> verify_claims(opts)\nend\ndef respond({:ok, _}, conn, _opts), do: conn\ndef respond({:error, reason}, conn, opts) do\n  conn\n  |> Pipeline.fetch_error_handler!(opts)\n  |> apply(:auth_error, [conn, {:unauthenticated, reason}, opts])\n  |> halt()\nend\n``. Do you need{ }` here since it's a singular alias?. This can be refactored a bit if you'd like; in general I like to keep the functions that represent my public API really clean:\n```elixir\n    def call(conn, opts) do\n      allow_blank = Keyword.get(opts, :allow_blank)\n  conn\n  |> GPlug.current_claims(opts)\n  |> resource(conn, opts)\n  |> respond(allow_blank)\nend\n\ndefp resource(nil, conn, opts), do: {:error, :blank, conn, opts}\ndefp resource(claims, conn, opts) do\n  module = Pipeline.fetch_module!(conn, opts)\n  case apply(module, :resource_from_claims, [claims]) do\n    {:ok, resource} -> {:ok, resource, conn, opts}\n    {:error, reason} -> {:error, reason, conn, opts}\n    _ -> {:error, :blank, conn, opts}\n  end\nend\n\ndefp respond({:error, :blank, conn, _opts}, true), do: conn\ndefp respond({:error, :blank, conn, opts}, false), do: return_error(conn, :no_resource_found, opts) \ndefp respond({:error, reason, conn, opts}, _), do: return_error(conn, reason, opts) \ndefp respond({:ok, resource, conn, opts}, _), do: GPlug.put_current_resource(conn, resource, opts)\n\ndefp return_error(conn, reason, opts) do\n  handler = Pipeline.fetch_error_handler!(conn, opts)\n  conn = apply(handler, :auth_error, [conn, {:no_resource_found, reason}, opts])\n  halt(conn)\nend\n\n``. You could always forgo the||` and just use the current mod as the default param:\nelixir\nKeyword.get(opts, :module, current_module(conn)). Defaulting to \"Bearer\" \ud83d\udc4d  (does it need to be capitalized?). This pipe shows up in a number of files, have you thought about pulling it out into a helper method?\nelixir\ndef handle_error(conn, {type, reason}, opts) do\n  conn\n  |> Pipeline.fetch_error_handler!(opts)\n  |> apply(:auth_error, [conn, {:type, reason}, opts])\nend. Since these are deprecated in Credo, should we go ahead and remove them?. Are these __MODULE__ portions here necessary?  I don't believe it is.. We don't need to use pipes for single values or functions: https://github.com/christopheradams/elixir_style_guide#avoid-single-pipelines. I don't believe these __MODULE__ are necessary either. async: true is the default, you can leave this off for future reference.. These { } are unnecessary for 1 import.. Reduce the number of aliases and unnecessary { } around singulars. . I found this pipe to be very difficult to follow especially since it pipes into a case.  I think breaking this out makes the code easier to grok. . Made these inline functions to be consistent with the rest of the file's single line function definitions.. Refactored out the nested if, I feel the cond reads better.. Use pattern matching to handle the nil values and avoid an if.. @hassox / @scrogson \u2014 what about allowing folks to return the result directly?  It seems that a common implementation would be:\n```elixir\ndef resource_from_claims(%{\"sub\" => sub}), do: Repo.get(User, String.to_integer(sub))\ndef subject_for_token(resource, _claims), do: to_string(resource.id)\n```\nBut as it is now, this is what we need:\n```elixir\ndef resource_from_claims(%{\"sub\" => sub}) do\n  case Repo.get(User, String.to_integer(sub)) do\n    nil -> {:error, \"not found\"}\n    resource -> {:ok, resource}\n  end\nend\ndef subject_for_token(resource, _claims), do: {:ok, to_string(resource.id)}\n```. Incorporated @michalmuskala's feedback and tweaked the message to inform the user what the function expects.  Thoughts?. Sure, what would you call the exception?  MalformedReturnValue?  IncorrectReturnValue?. Sounds good \ud83d\udc4d . @scrogson do you happen to know if there is any extra overhead to one of these vs the other:\nMaking a new tuple:\nelixir\n  def connect(%{\"guardian_token\" => token}, socket) do\n    case authenticate(socket, Impl, token) do\n      {:ok, authed_socket} -> {:ok, authed_socket}\n      _ -> :error\n    end\n  end\nCapturing and returning the capture:\nelixir\n  def connect(%{\"guardian_token\" => token}, socket) do\n    case authenticate(socket, Impl, token) do\n      {:ok, authed_socket} = result -> result\n      _ -> :error\n    end\n  end. Coolio!  I'm a fan of fewer newlines myself.  I was just curious about the capture vs create, seen both around \ud83d\ude01 . 100% this \ud83d\udc4d . Thanks @bitwalker \ud83d\udc4d . This needs to be worded better.. Should this read: \"Make sure the current resource has been set\" instead of \"that?\". Can we reword this a little differently?  How about:\n\nYou can use any value for the subject of your token but it should be useful in retrieving the resource later.  A unique id is a good subject, a non-unique email address is a poor subject.. How about:\nHere we'll look our resource from the claims, the subject can be found in the \"sub\" key.  In above subject_for_token/2 we returned the resource id so here we'll rely on that to look it up.. Let's remove this comment.  I think this is applied in the previous comments.. Sorry @yordis, I had a typo in my previous suggestion.  It should be \"look up\". This needs to be # See https://github.com/thoughtbot/ex_machina. This change is fine \ud83d\udc4d . This change isn't necessary.  We're not referencing a specific TokenModule rather a Token Module that they will create.  Probably doesn't need to be capitalized? . Could we update this to credo --strict please and thank you \ud83d\ude01 . Holy moly, I did not know this was a thing.  I am going to have to bring this over to other projects.. @jsangilve could you remove this G that slipped in? Otherwise this is good IMO.. We need to add 1.9 now, right?. I'm confused, you're right \ud83d\udc4d . Don't we want to return just \"Insufficient permission\" here?. The including the tuple seems unnecessary don't you think? Tuples nor atoms are valid JSON so this isn't anything, right? It's not real sentence and it's not valid JSON.. @yordis I understand but we should improve the code anytime we make changes to it \ud83d\ude01In addition to testing the code, the tests can/should serve as a type of documentation. Never would you really return a tuple like this, so let's change it, even if you didn't write it.\n\nIf you come to Guardian to either use the library or contribute, find your way to these tests, and see them returning something that you'd never see in an application it could be a source of confusion \u2014 hell it's confused me and I'm one of the maintainers \ud83d\ude06\nLet's update the test handler to return something like valid JSON so these tests can look remotely like they would in a real scenario.\nDoes that sounds good?\n```elixir\n  defmodule Handler do\n    @moduledoc false\nimport Plug.Conn\n@behaviour Guardian.Plug.ErrorHandler\n\n@impl Guardian.Plug.ErrorHandler\ndef auth_error(conn, {type, reason}, _opts) do\n  send_resp(conn, 403, Poison.encode!(%{type => reason}))\nend\n\nend\n```. @yordis I'm only talking about updating this test. I'm not sure I follow all these other changes?. https://github.com/ueberauth/guardian/blob/77c7acdba384563160b935bf75d233bf71f495b7/test/guardian/permissions/bitwise_test.exs#L27. ",
    "e-fu": "Hi,\nCan you check if this is the right direction?\nhttps://github.com/hassox/guardian/compare/master...efries:master\nBeside 4 fails the tests are green. Validation is still missing.\n1) test fails if the expiry has passed (GuardianTest)\n     test/guardian_test.exs:58\n2) test it is invalid if the aud is incorrect (GuardianTest)\n     test/guardian_test.exs:65\n3) test fails if the issuer is not correct (GuardianTest)\n     test/guardian_test.exs:51\n4) test verify! with a bad token (GuardianTest)\n     test/guardian_test.exs:73\nPlease check careful. I'm new to Elixir. :-)\n. ",
    "Pjino": "Hi @hassox. I'm using the latest version of everything (Guardian, Phoenix,...) and I (think) I made all the necessary changes.\nMy config.exs looks like this:\n\nand my controller is:\n\n. I changed it to:\nGuardian.Plug.sign_in(user, :token, perms: %{ default: [:write_profile] })\n\nand:\nGuardian.Plug.sign_in(user, :token, perms: %{ default: [:read_profile, :write_profile] })\n\nAnd it still's the same. I even created new users for each case but nothing changed.\n\n\nMy hooks are:\n\n. @yuyabee Yes, Guardian.Permissions.to_value [:read_profile, :write_profile], :default returns 0 and Guardian.Permissions.availble returns an error: UndefinedFunctionError\n. @yuyabee Yes, it returns []. Sorry for testing it in such a rush that I didn't even try to see why it returned undefined...It was obvious:) \n. ",
    "yuyabee": "I think I'm seeing the same issue. \nIn IEx, Guardian.Permissions.to_value [:read_profile, :write_profile], :default returns 0, and Guardian.Permissions.availble returns [] where it's supposed to return list of permissions.\nI have exact the same configuration as the permission example in the document.\n@Pjino please try these functions and see if we are talking about the same problem.\n. @Pjino Sorry, that was a typo, it's Guardian.Permissions.available\n. @hassox Yes that was it. Upgrading to 0.6.2 solved it. Thank you so much.\n. ",
    "ddcech": "My router looks like this.\n```\ndefmodule App.Router do\n  use App.Web, :router\n  pipeline :api do\n    plug :accepts, [\"json\"]\n    plug Guardian.Plug.VerifyHeader, realm: \"Bearer\"\n    plug Guardian.Plug.LoadResource\n  end\nscope \"/api/v1\", App.Api.V1 do\n    post \"/auth\", AuthController, :create\n    pipe_through [:api]\n    resources \"/users\", UserController\n    resources \"/cities\", CityController\n    resources \"/countries\", CountryController\n  end\nend\n```\nthen my auth controller looks like this (not checking password yet for simplicity) and it is returning a token as I wanted:\n```\ndefmodule App.Api.V1.AuthController do\n  use App.Web, :controller\nalias App.User\n  alias App.UserQuery\ndef create(conn, params = %{}) do\n    user = Repo.one(UserQuery.by_email(params[\"user\"][\"email\"] || \"\"))\n    { :ok, jwt, _ } = Guardian.encode_and_sign(user, :api)\n    json(conn, %{ jwt: jwt })\n  end\ndef unauthenticated_api(conn, _params) do\n    the_conn = put_status(conn, 401)\n    case Guardian.Plug.claims(conn) do\n      { :error, reason } -> json(the_conn, %{ error: reason })\n      _ -> json(the_conn, %{ error: \"Login required\" })\n    end\n  end\nend\n```\nAnd then my city controller looks like this (the resource that I'm trying to authenticate):\n```\ndefmodule App.Api.V1.CityController do\n  use App.Web, :controller\nalias App.City\n  alias App.Api.V1.AuthController\nplug Guardian.Plug.EnsureAuthenticated, on_failure: { AuthController, :unauthenticated_api }\ndef index(conn, _params) do\n    cities = Repo.preload(Repo.all(City), :country)\n    render(conn, \"index.json\", cities: cities)\n  end\nend\n```\nWhat seems to be happening is the EnsureAuthenticated in my city controller is looking for a session. because the error I'm getting from the on_failure is {\"error\":\"no_session\"}.\nWhen I comment that line out, it responds with the resource as It should.\nOk cool, so that's fine, at least I'm getting something back. But when I don't pass in a token in the header it still goes though and loads the resource. What?\nThat shouldn't happen, right? because in my router I have plug Guardian.Plug.VerifyHeader, realm: \"Bearer\", and it should look for a token, No?\nI must be doing something wrong, and I can't figure it out. It's been bugging me for a week now and I really like this library.\nAny help would be great thanks.\n. I figured out my problem.\nIn my request header I was putting Authorization: MYTOKEN, when I needed to put Authorization: Bearer MYTOKEN\nI found it after looking through the verify_header_test file.\nThank you for all your help, and great work on the library.\n. @alduro I don't have that specific project anymore (it was 1 year ago), but I was using this example phoenix_guardian project.\n. ",
    "alduro": "@ddcech can you please share your Guardian config part in config.ex ? I'm getting the same issue. Thanks !\n. @enilsen16 yeah you are right. The token was created by Auth0 and I do need to use their secret key to decode it, get the sub, split it and loading the resource from Token. I cannot make it work yet.\n@hassox yeah, key in VerifyHeader was an attempt to make it work with no luck. Just added my own verify_module but didn't work either.\n. @enilsen16 ah no. Any sample to check ?\n. I just checked it out. The problem is I'm also interested in some other Guardian features like LoadResource based on sub payload. Well I dunno, maybe I can implement my own Plug.\n. Thanks guys ! I will check this out and let you know how it went before closing it I guess.\n. No luck. I'd really appreciate any code sample applying directions above.\n. @hassox no. I will create an small gist for sharing.\nUpdate: https://gist.github.com/alduro/bffc1f03a890b025f4abe66b1e27450f\n. Sorry, any clue ? @hassox\n. It was solved !\nconfig.ex\nconfig :guardian, Guardian,\n 11   allowed_algos: [\"HS256\"],\n 10   verify_module: Guardian.JWT,\n  9   issuer: System.get_env(\"AUTH0_DOMAIN\"),\n  8   verify_issuer: false,\n  7   secret_key: System.get_env(\"AUTH0_CLIENT_SECRET\") |> Base.url_decode64 |> elem(1),\n  6   serializer: App.GuardianSerializer\nSerializer\ndef from_token(\"auth0|\" <> id), do: {:ok, Repo.get(User, id)}\nrouter.ex\npipeline :graphql do\n  2     plug GraphqlLogger\n  1     plug Guardian.Plug.VerifyHeader, realm: \"Bearer\"\n18      plug Guardian.Plug.EnsureAuthenticated\n  1     plug Guardian.Plug.LoadResource\n  2     plug App.Context\n  3   end\n. ",
    "aislanmaia": "Hey guys, I'm authenticating in my client and trying to logout putting the Authorization: Bearer ${localStorage.token} but the server is returning:  \n(KeyError) key :plug_session not found in: %{Api.Router => {[], %{}}, :guardian_default_claims => {:ok, %{\"aud\" => \"User:1\", .... etc } \nAny ideas ?? Thanks in advance.. Forgive me, I've achieved my goal just following what Daniel Neighman suggested in your blog post on the last post comment.. ",
    "vkmagalhaes": "Hey @doomspork, thanks for the fast reply!\nAdding the VerirfySession plug is raising the following error:\n** (CaseClauseError) no case clause matching: {:error, \"argument error\"}\n     stacktrace:\n       lib/guardian/plug/verify_session.ex:28: Guardian.Plug.VerifySession.call/2\n       (blog) web/router.ex:12: Blog.Router.browser_session/2\n       (blog) web/router.ex:2: Blog.Router.match/4\n       (blog) web/router.ex:1: Blog.Router.do_call/2\n       (blog) lib/blog/endpoint.ex:1: Blog.Endpoint.phoenix_pipeline/1\n       (blog) lib/phoenix/endpoint/render_errors.ex:34: Blog.Endpoint.call/2\n       (phoenix) lib/phoenix/test/conn_test.ex:193: Phoenix.ConnTest.dispatch/5\nI changed the sign_in function to match the one you sent me:\n``` elixir\n      @default_opts [\n        store: :cookie,\n        key: \"foobar\",\n        encryption_salt: \"encrypted cookie salt\",\n        signing_salt: \"signing salt\"\n      ]\n      @secret String.duplicate(\"abcdef0123456789\", 8)\n      @signing_opts Plug.Session.init(Keyword.put(@default_opts, :encrypt, false))\n  def conn_with_fetched_session(the_conn) do\n    put_in(the_conn.secret_key_base, @secret)\n    |> Plug.Session.call(@signing_opts)\n    |> Plug.Conn.fetch_session\n  end\n\n  def sign_in(conn, resource, perms \\\\ Guardian.Permissions.max) do\n    conn\n    |> conn_with_fetched_session\n    |> Guardian.Plug.sign_in(resource, :token, perms: %{default: perms})\n    |> Guardian.Plug.VerifySession.call([])\n  end\n\n```\nAnd the guardian and phoenix versions in mix.lock are:\nelixir\n%{\"comeonin\": {:hex, :comeonin, \"1.1.4\"},\n  \"cowboy\": {:hex, :cowboy, \"1.0.3\"},\n  \"cowlib\": {:hex, :cowlib, \"1.0.1\"},\n  \"decimal\": {:hex, :decimal, \"1.1.0\"},\n  \"ecto\": {:hex, :ecto, \"1.0.2\"},\n  \"fs\": {:hex, :fs, \"0.9.2\"},\n  \"guardian\": {:hex, :guardian, \"0.6.2\"},\n  \"joken\": {:hex, :joken, \"0.15.0\"},\n  \"phoenix\": {:hex, :phoenix, \"1.0.3\"},\n  \"phoenix_ecto\": {:hex, :phoenix_ecto, \"1.2.0\"},\n  \"phoenix_html\": {:hex, :phoenix_html, \"2.2.0\"},\n  \"phoenix_live_reload\": {:hex, :phoenix_live_reload, \"1.0.0\"},\n  \"plug\": {:hex, :plug, \"1.0.2\"},\n  \"poison\": {:hex, :poison, \"1.5.0\"},\n  \"poolboy\": {:hex, :poolboy, \"1.5.1\"},\n  \"postgrex\": {:hex, :postgrex, \"0.9.1\"},\n  \"ranch\": {:hex, :ranch, \"1.1.0\"},\n  \"uuid\": {:hex, :uuid, \"1.0.1\"}}\nAny ideia about this?\n. Well, they are exactly as I pasted above :confused: \n. @doomspork, I have found the problem!\nAt my test setup I was doing:\nelixir\nuser = Repo.insert(%Blog.User{})\nJust changed to:\nelixir\nuser = Repo.insert!(%Blog.User{})\nAnd now it works!\nThanks for your help!\n. ",
    "nolman": "Thanks dude, you rock\n. ",
    "Lbatson": "@doomspork it still fails for me. are you using Guardian.Plug.claims anywhere? I always end up getting the :no_session error even though i can see the claims in then conn itself. I did fix the issue with it failing on EnsureAuthenticated which had an issue with my on_verify hook failing, however I've noticed that Guardian.Plug.VerifyHeader also always fails with :no_session as well but then verifies the token and adds it. https://github.com/hassox/guardian/blob/master/lib/guardian/plug/verify_header.ex#L49\nAlso, not sure if it's relevant or not but i'm using Erlang 18 and Elixir 1.1.1\n. Ok, think i've found the issue. The way VerifyHeader and api_sign_in set claims is different. VerifyHeader attaches a tuple, https://github.com/hassox/guardian/blob/master/lib/guardian/plug/verify_header.ex#L63, where api_sign_in simply adds the claims, https://github.com/hassox/guardian/blob/master/lib/guardian/plug.ex#L171. This means if you call Guardian.Plug.claims on the conn after api_sign_in, for instance in the after_sign_in hook,  it will fail as Guardian.Plug.claims looks for the tuple, doesn't get it and gives the :no_session error. I think to fix this it should just be one or the other wins out, setting as a tuple or just the claims. Not sure what approach is wanted or what else it might affect yet but fixing the inconsistency would solve this.\n. The @spec does shows the tuple, however the parameter passed to set_claims from api_sign_in is just the Map. Maybe it should be changed to |> set_claims({:ok, full_claims}, the_key) or instead of setting a tuple to the claims just set the claims themselves and modify the other portions that use it with the tuple?\n. ",
    "chriserik": "I had a similar issue in a phoenix-based project and fixed it by deleting the project's _build - folder and then recompiling the entire app. Maybe this helps in your case as well.\n. ",
    "mylanconnolly": "@chriserik Thanks for the suggestion! It looks like that was it. Bizarre. I probably should have checked that first. Still not used to compiled languages. Thanks again\n. ",
    "mrluc": "Ah, I see. The problem here is that I can't read ... headers can have multiple values, so gotta extract it from [binary]. Closing.\n. ",
    "bartekupartek": "Ok, I see https://github.com/hassox/guardian/blob/master/lib/guardian.ex#L231, I haven't exported GUARDIAN_SECRET env in running phoenix server terminal session.\n. ",
    "b-murphy": "I guessed not!!! :-) The only way i can see is adjusting the commits (aka force push) which is a no go!\nThe only pointer really is that most of the docs (your blog & example phoenix_guardian) are relating to 0.6\nPerhaps i could help updating the phoenix_guardian to be 0.8.0 ?\n. Hey again!\nI just discovered it can be done via releases in github. Only that is done via branches not commits. So could backfill with rollbacked branches on the repo. I'll get on this if it helps.\n. @Linbubin have you explored using a Struct in place of the Ecto example? will post example shortly if not.. @Linbubin here is a possible example ~\nFirstly if you use a basic struct to define your user\ndefmodule MyApp.User do\n  defstruct id: \"1\"\nend\nWith this you can pass it into the serializer through the Guardian.Plug.sign_in\ndefmodule MyApp.SessionController do\n  def create(conn, params = %{}) do\n    case params[\"password\"] == Application.get_env(:my_app, :master_password) do # don't do exactly this to validate your password\n        true ->\n           user = %MyApp.User{id: \"1\"}\n           conn\n           |> Guardian.Plug.sign_in(user) # pipe the conn & user into the session\n           |> redirect(to: \"/dashboard)\n        false ->\n          # do fail redirect\n     end\n  end\nend\nThen within your serializer you will need to define a way to serialize the user struct\n```\ndefmodule MyApp.GuardianSerializer do\n  @behaviour Guardian.Serializer\nalias MyApp.User\ndef for_token(user = %User{}), do: { :ok, \"User:#{user.id}\" }\n  def for_token(_), do: { :error, \"Unknown resource type\" }\ndef from_token(\"User:\" <> id), do: { :ok, %User{id: id} }\n  def from_token(_), do: { :error, \"Unknown resource type\" }\nend\n``\nThis is an imperfect solution & i feel that perhaps you are more looking for basicAuth on your application. Also i spotted that you useusername` with your examples, i would say that if you need to check different usernames into the session, perhaps consider using Ecto for your user storage.\nhope this helps.\n. @Linbubin think perhaps you are best to start from the beginning and follow this guide perhaps ~ http://blog.overstuffedgorilla.com/simple-guardian/. ",
    "joeyfironsrc": "It seems to me that most libraries in elixir don't log (httpoison, phoenix, dynamo, etc..) so maybe to conform to their best practice just pass it back?\n. ",
    "fnimick": "+1 this would be very helpful!\n. ",
    "joshwlewis": "Sorry, looks like I let this slide. Let me see if I can get something together later tonight.\n. Sorry for going dark on this. I'm not doing much Elixir lately, and never really got a good start on this. Y'all are certainly welcome to take this over. Thanks for the great library.\n. ",
    "coryodaniel": "I came across this same issue/assumption last night? Any progress? If someone isn't actively on this, I wouldn't mind working on a solution tomorrow evening. LMK :D\n. @doomspork  should load resource have its own auth error handler like ensure authenticated?\nAlso regarding ensure authenticated ... is that the best name for the module since it's technically ensuring the token is verified?\n. So I haven't created a PR, I solved it in my application first, curious how you guys see this integrated... Maybe its just another plug to be added?\n``` elixir\ndefmodule MyApp.Plug.RequireUser do\n  import Plug.Conn\ndef init(opts), do: opts\ndef call(conn, _opts) do\n    case conn.private[:guardian_default_resource] do\n      nil ->\n        conn\n        |> MyApp.AuthErrorHandler.unauthenticated(%{})\n        |> halt\n      _ -> conn\n    end\n  end\nend\n```\n. PR: https://github.com/ueberauth/guardian/pull/222\n. @doomspork I added another test case for something I missed ^\n. @hassox Want me to add that to the changelog or was that a note for @doomspork when a new release is made... I wasn't sure where to add it\n. Heyoooo, I didn't cover a test cast that had an issue. Just fixed it. When providing a two elem tuple to secret_key I wasn't passing 3 args to apply/3\nSorry!\n. @doomspork done!\n. Yep!\n. ",
    "steffenix": "Did you guys found a way to do it?. ",
    "aaronrenner": "Awesome. I'll get started on it!\n. On a side note, I did notice that the 3 levels of nested case statements is pretty rough to read. What would you think if I made another pull request that reworks encode_and_sign to use a with statement like this?\nelixir\ndef encode_and_sign(object, type, claims) do\n  with {:ok, claims} <- build_claims(object, type, claims),\n       {:ok, {object, type, claims}} <- call_before_encode_and_sign_hook(object, type, claims),\n       {:ok, jwt} <- encode_claims(claims),\n       call_after_encode_and_sign_hook(object, type, claims, jwt),\n       do: { :ok, jwt, claims }\nend\nThe only drawback is it would require that the Elixir dependency be bumped to 1.2.\n. I've got a proof of concept done for this and will be submitting a PR in the next couple of days.\n. Looks great :+1: \n. That's fine. I can submit a separate PR with the changes that don't depend on elixir 1.2.\n. @doomspork I'd be happy to add sudo: false and the after_script for inch. I submitted #93 which bumps the Elixir dependency to 1.2 and refactors some nested case statements to use the new with syntax. Once it's decided if you want to upgrade to Elixir 1.2 or not, I'll update this pull request with the appropriate Elixir versions.\n. I think mix hex.docs uploads the documentation to hexdocs.pm. Do we want this to happen automatically for every pull request/commit? I wonder if that should be more of a manual process when a new version is released.\n. Good find, @doomspork. Let's see what @hassox wants to do.\n. @doomspork I'm totally a fan of this change, but I'm finding the 80 character line length is a little rough in test descriptions, especially if you want to pass in arguments from the setup block. What are your thoughts on a test like this?\nelixir\ntest \"doesn't call unauthenticated when theres a session with specific key\", %{conn: conn} do\n  claims = %{ \"aud\" => \"token\", \"sub\" => \"user1\" }\n  #...\nend\nShould I break the test definition onto 2 lines so it meets the character limit?\nelixir\ntest \"doesn't call unauthenticated when theres a session with specific key\", \n  %{conn: conn} do\n  claims = %{ \"aud\" => \"token\", \"sub\" => \"user1\" }\n  #...\nend\nI like the 80 character line length for application code, but I'm not sure what the best answer is to do here.\n. @hassox Just rebased, and the build is green.\n. Looks great to me. :+1: This will be super helpful so my tests will pass.\n. I'll rebase once #103 is merged so the build passes.\n. @hassox Rebased and green.\n. @hassox @doomspork Just shortened the test descriptions and updated the changelog.\n. @bbugh You're right, that abbreviation was never expanded. Would you want to submit a pull request for this?\n. @victorlcampos Thanks for the great work! Here are a couple of comments I have.\n1. What do you think about changing the callback on the handler to already_authenticated instead of just authenticated? I am thinking if I'm looking at an error handler module, I'd understand why unauthenticated and unauthorized are errors, but I would wonder why authenticated is there. already_authenticated seems like it might give the developer an idea that maybe the user wasn't supposed to be authenticated for a given route. Also, if you have a better name than already_authenticated that would be great too.\n2. Would you mind adding a simple test to ensure everything works when the developer doesn't pass a handler: option? It looks like things will break at the moment because Guardian.Plug.ErrorHandler doesn't implement the expected callback. Maybe @hassox or @doomspork can give their two cents on if Guardian.Plug.ErrorHandler should provide some sort of default behavior, or if the handler: option should just be required.\nThanks for all of the work you've done so far.\n. @victorlcampos Nice work. Looks good to me. :+1: \n. Glad you like it, @doomspork. I'll get to work on the rest of the tests.\n. @hassox and @doomspork,  I just pushed my refactoring work for the rest of the plug tests. I also added a 2nd commit where I created Guardian.PlugCase in test/support to share the new run_plug function and automatically use Plug.Test. It's very similar to MyApp.ConnCase in a Phoenix app and maybe I should have named it Guardian.ConnCase.\nLet me know what you think. If you like it, I can squash the changes and have it merged in a single commit.\n. After a little more thinking, I'm not quite sold on the PlugCase code I wrote. Let's hold off on merging this for right now.\n. @doomspork How did you know about that PR? Actually, I want to tackle #90 in my next PR and write an integration test that runs the following plugs\nelixir\nGuardian.Plug.Backdoor\nGuardian.Plug.VerifySession\nGuardian.Plug.LoadResource\nto make sure that the backdoor sign in flow works correctly. I am still a fan of the run_plug helper, regardless of the feedback to the PR. I'm thinking maybe I should have put that helper in a separate module that's imported into the test case, instead of combining that function and additional imports into a single Guardian.PlugCase. Also, if I'm writing an integration test, it might be weird to have to add use Guardian.PlugCase in my test just to use that helper. I think this might have been a premature refactoring on my part.\nI would be curious to hear your feedback on the run_plug helper, as well as Guardian.PlugCase. I'll try to get to finishing off this PR later today.\n. @doomspork @hassox I think this is ready to merge.\n. Looks great! :+1: \n. Good find @hassox. It looks like the default config doesn't lint any of the tests. I'm fine with not linting the tests, but I just wanted to point that out.\n. It looks like you create a .credo.exs file in either config/ or the root folder, and then change the files: > included: array. https://github.com/rrrene/credo/blob/master/.credo.exs#L20. I'm not sure if you have to copy the entire config file into your project or if it merges with the default settings. I'd be happy to take a look at it in the morning if you want, but right now I'm off to bed.\n. @hassox That's a great point that this doesn't allow the token to include permissions or claims. I do like the simplicity of this approach since it doesn't require a new developer to know the all of the details of generating a JWT.\nHowever, I think you're right that it might be a good idea to pass in the token via the URL. That would make the backdoor sign in code look something like this.\nelixir\n{:ok, jwt, _} = Guardian.encode_and_sign(user, :token)\nnavigate_to \"/?jwt=#{jwt}\"\nI will have to make sure the backdoor code still calls the Guardian.Plug.sign_in function to trigger the callbacks and set the current resource, claims and token. I'll probably decode the token in the Backdoor Plug and then pass along the appropriate params to sign_in.\nI guess really the only time you'd need this backdoor is if you using the VerifySession plug. You wouldn't need this if you are using the VerifyHeader plug, since the token is just passed in over the Authorization header.\nLet me know if this approach sounds right.\n. @doomspork Yeah, I think it would be good if I finish this up. I'll start looking at it in the evenings again.\n. @jayjun Unfortunately I don't have the time to work on this. Feel free to adapt what I'm submitted if it's useful and submit a PR.. @doomspork Just updated to use a pipe and rebased on top of master. It should be ready to merge.\n. Spelling\n. What do you think about making set_current_token and set_current_claims helpers? These could be especially helpful from the tests, so you could do\nelixir\nsocket = Guardian.Phoenix.Socket.set_current_token(socket, \"THE JWT\")\ninstead of \nelixir\nkey = Guardian.Keys.jwt_key\nassigns = %{key => \"THE JWT\"}\nsocket = Map.put(socket, :assigns, assigns)\nThis would also more closely follow how it's currently being done in Guardian.Plug, and would allow for easier refactoring of where the value is being stored on the socket (like how we moved from using Plug.Conn.assign to Plug.Conn.put_private).\nThat said, I'm not sure if writing setters is \"The Elixir Way\", so I'm interested to hear your what you think.\n. These examples should probably mention Guardian.Plug.EnsureNotAuthenticated\n. @hassox @doomspork Do we want to default the error handler to the same error handler that Guardian.Plug.EnsureAuthenticated uses? It seems like it might get confusing using the same error handler handling when the user is unauthenticated and authenticated. Also, if we go this route, Guardian.Plug.ErrorHandler will need a new authenticated/2 method.\n. I think you might have meant \"calls handler's authenticated/2 with no session for specific key\"? There are a couple more references to unauthenticated that need to be changed to authenticated.\n. What about if the callback was already_authenticated/2? Would that might make more sense as a callback in the error handler. Also, what would the default Guardian.Plug.ErrorHandler do when this callback was called?\n. Since this module ensures the user is not authenticated, what would you think about renaming this helper method to already_authenticated? Then your assertions would read like\nelixir\nassert already_authenticated?(conn)\n. This is a new plug so we don't have to handle the deprecated on_failure: option.\n. Just fixed the whitespace padding for tuples on the lines I changed. Do you want me to go through and change all of them in these files?\n. Sure. That would be much prettier. \ud83d\ude04 \n. ",
    "ramstein74": "coding this\n\ngives me this in my view\n%Plug.Conn{adapter: {Plug.Adapters.Cowboy.Conn, :...}, assigns: %{guardian_default_resource: nil, layout: {G1.LayoutView, \"app.html\"}, token: nil}, before_send: [#Function<1.117304339/1 in Plug.CSRFProtection.call/2>, #Function<2.92260701/1 in Phoenix.Controller.fetch_flash/2>, #Function<1.37606151/1 in Plug.Session.before_send/2>, #Function<1.21054194/1 in Plug.Logger.call/2>, #Function<0.53071751/1 in Phoenix.LiveReloader.before_send_inject_reloader/1>], body_params: %{}, cookies: %{\"fileManager\" => \"760d8929-4618-d40c78709a76\"}, halted: false, host: \"127.0.0.1\", method: \"GET\", owner: #PID<0.554.0>, params: %{}, path_info: [], peer: {{127, 0, 0, 1}, 26429}, port: 4000, private: %{G1.Router => {[], %{}}, :phoenix_action => :index, :phoenix_controller => G1.PageController, :phoenix_endpoint => G1.Endpoint, :phoenix_flash => %{}, :phoenix_format => \"html\", :phoenix_layout => {G1.LayoutView, :app}, :phoenix_pipelines => [:browser, :browser_session], :phoenix_route => #Function<1.108914464/1 in G1.Router.match_route/4>, :phoenix_router => G1.Router, :phoenix_template => \"index.html\", :phoenix_view => G1.PageView, :plug_session => %{}, :plug_session_fetch => :done}, query_params: %{}, query_string: \"\", remote_ip: {127, 0, 0, 1}, req_cookies: %{\"fileManager\" => \"760d8929-4618-d40c78709a76\"}, req_headers: [{\"host\", \"127.0.0.1:4000\"}, {\"connection\", \"keep-alive\"}, {\"cache-control\", \"max-age=0\"}, {\"accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\"}, {\"upgrade-insecure-requests\", \"1\"}, {\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36\"}, {\"accept-encoding\", \"gzip, deflate, sdch\"}, {\"accept-language\", \"pt-PT,pt;q=0.8,en-US;q=0.6,en;q=0.4\"}, {\"cookie\", \"fileManager=760d8929-4618-d40c78709a76\"}], request_path: \"/\", resp_body: nil, resp_cookies: %{}, resp_headers: [{\"cache-control\", \"max-age=0, private, must-revalidate\"}, {\"x-request-id\", \"c5misd7pr05q6f22npbprl0tch84a8l0\"}, {\"x-frame-options\", \"SAMEORIGIN\"}, {\"x-xss-protection\", \"1; mode=block\"}, {\"x-content-type-options\", \"nosniff\"}], scheme: :http, script_name: [], secret_key_base: \"Qm9nsRw7p+//i2LLhojCxJU8uE1DVblY1KDl+DQnIURX2yvT2FgLfonK/fb2cmg3\", state: :unset, status: nil}\n. Solved\nthank you\n2016-01-11 18:30 GMT+00:00 Daniel Neighman notifications@github.com:\n\n@ramstein74 https://github.com/ramstein74 the conn struct is immutable.\nYou need to save off the new one after you sign in.\nconn = Guardian.Plug.sign_in(conn, user, :csrf)\nrender conn, \"index.html\", token: Guardian.Plug.current_token(conn)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ueberauth/guardian/issues/82#issuecomment-170643767.\n. Forget it. solved. .. DELETE this issue...pls\n. \n",
    "skosch": "Hm. I guess it's not that big of a deal in practice, but maybe a note in the docs would be helpful to save the next guy a few hours :)\n. Sweet, thank you! Looking forward to what you'll come up with. I'll keep the issue open until then.\n. ",
    "sschneider1207": "It would be nice to have a notice about this in the section of the readme on permissions, I just had this same problem and couldn't figure out what was wrong for the life of me.\n. ",
    "terakilobyte": "I think there's value in being able to use hooks in testing to create a valid user. This might be specialized purely towards guardiandb, but having access to both in testing allows a user like myself to make the assertion that all is well and the \"user\" must have a valid JWT issued by my application.\nI don't see a way to do this, though if it's inbuilt I apologize and would ask for reference.\n. Yep, that worked perfectly, thanks!\n. ",
    "michaelforrest": "Ok @doomspork  sorry for the lapse - here it is!\n. I'm editing this up on Github, not on a local copy - I don't think I can do a squash from here.\n. True.\n. ",
    "victorlcampos": "Can u make a generator for: https://hassox.github.io/elixir/guardian/2015/06/29/simple-email-password-authentication.html\n. I opened a new project called gen_guardian(https://github.com/victorlcampos/gen_guardian), in the future, when I finish, if you agree we merge both\n. Call a handler ?\nIn my case I will redirect to home\n. exactly\n. I will try, tomorrow, are you ok with this date?\n. @doomspork and @hassox PR opened #109 \n. Thank you for this anwsome lib\n. Thx for reply. I happy you by stoked =)\nIf you have some sugest to generators?\nNext weekend I will try to write some tests\n. Thx @hassox, Yes, I will send PR\n. https://github.com/britton-jb/sentinel/issues/1\n. My English is not so good, I will try to write doc tomorrow, but could you help me with this?\nAnd Could you review my code? I'm very new in Elixir. =-)\nThx for awesome project\n. Yes, I'm going to work now, when I come back i finish this. Thx a lot for code review\n. @aaronrenner, thx for reply...\nYes, I still need change doc(https://github.com/ueberauth/guardian/pull/109#issuecomment-182661234), about handler, I agree with @doomspork at this comment(https://github.com/ueberauth/guardian/issues/106#issuecomment-181179337)\n. Hi guys,\nsory for did not fix this gaps yesterday. I worked 12 hours and when I went home I was very very tired.\n. Hi guys,\nI did some changes. What do you think?\n. Hi @aaronrenner,\nfor now I just halt the conn as default behavior.\n. @hassox, could you help me with English?\n. Thx.\nThis weekend I will add this to gen_guardian generator\n. (y)\n. ",
    "aphillipo": "I'm looking for something like this too.  Not sure of the correct way to do this without the Backdoor Middleware... What do people do in the mean time?\nEDIT: https://github.com/ueberauth/guardian/issues/53\n. ",
    "jamesvl": "The example in the blog mentioned above is what I was looking for - would you consider adding that snippet to the docs or readme file?\nAnd although it's slower, I like that method better than the backdoor middleware which uses GET params to setup a fake user - for purposes of testing various routes, you are now no longer testing the exact route (since it has a query string), and there's a chance it conflicts with expected parameters (unlikely, but possible).\n. Any plans to merge this is in, or at least make a new minor release soon?\nWith Ecto 2.0 in rc stage, much of the Phoenix stack is ready for Poison ~> 2.0, but the 0.10.1 release of Guardian is still back on ~> 1.5.\n. I think what was already in there should have been fine - it's more about the tagged release (0.10.1) being back on 1.5 still. Or would you recommend just setting up mix to pull in from the Git repo head?\n. Yep, I'm getting the same thing. Applying PR #243 fixed it locally. (Until it's merged I can't use it in my CI system, of course.). Any idea on when you'll cut a new release for hex.pm? This will remain broken for anyone until then.. ",
    "Oxyyx": "I would be really interested in this, sounds great.\n. ",
    "secretfader": "I have a working example, I just need to write the prose portion. Soon...\n. @somlor @hassox Okay, I finally have some time to work on these, maybe during the coming weekend. Any input on how they should be structured in the repo? docs/ / examples/? Or should they go in a separate guides repo?\n. @doomspork Still on it. But you can close the issue if doing so is helpful. \nI've been busy with a new child, so I haven't had copious amounts of time to dedicate to this project, so progress is slow. \n. This should be a blog entry first. I'll get to that shortly, but for now, I'll close the issue.\n. ",
    "somlor": "@nicholaswyoung let me know if you'd like any kind of help with this guide. Would be a great resource.\n. ",
    "simonh1000": "I would certainly welcome some instructions or a blog, and ideally for a json api. What I can't see at all from the docs is where the username and password are sent and matched with the database. That must be done before a token can be issued I would expect.\n. Is the code up to date? Key generation is not at all clear in the docs, as the link to Examples: Key Generation has 8 different methods. Which one do I use?\n. Thanks, I've had to hard code the passphrase in as I don't know about env variables yet, but it seemed to compile\n. Ok, so I had copied allowed_algos: [\"ES512\"] into my config at some stage, and it should now be allowed_algos: [\"HS512\"]\n. ",
    "AlexKovalevych": "@JHKennedy4 I guess this one is related: https://github.com/github/fetch#sending-cookies\nUnfortunately i still not able to sign in user with session and token in the same action for some reason\n. ",
    "ChrisYammine": "@msanterre as this was a misuse of the Plug.Conn module I'm not sure how useful a test would be\n. ",
    "aristotelesbr2014": "Nice! +1\n. ",
    "Hanspagh": "Yes, I know but that only allows us to make a new token from an valid existing one. The feature I am requesting is to create a new token without having a valid token, but from a refresh token. Like described here https://auth0.com/docs/refresh-token\n. My first thought was to implement it like you described in 1. and then add it as dependency like GuardianDb.\nBut 2. seems to integrate much better into the existing code and being able to reuse GuardianDb instead of writing a db integration again seems to be a big win.\nI am still a bit new to Elixir but I would be happy to help with implementing this :) \n. When you say it should not go in the Guardian lib, do you then mean it should be a lib like GuardianDb or should it be part of the core.\n. Awesome, Will start working on something\n. I made a VERY simple initial commit on the Refresh Token project, and I thought you might wanted to take a quick look at it, just to see if I am on the right track.\nhttps://github.com/Hanspagh/guardian_refresh_token\n. We are currently working on it.\nBut you can use encode_and_sign to create tokens with a 'refresh type' and a longer expire time.\nclaims = Guardian.Claims.app_claims\n|> Guardian.Claims.ttl({60, :days})\n{:ok, jwt, claims} = Guardian.encode_and_sign(resource, \"refresh\", claims)\nLater you can verify that a token is a 'refresh token' and issue a shorter living access token.\ncase Guardian.decode_and_verify(jwt) do\n{ :ok, claims } -> #verify that the type is refresh and issue a new access token\nend\nHope this helps\n. I guess we could make it up to the user to revoke it, or create two different methods exchangeAndRevoke and exchange. What do you think?\nI am updating the readme as we speak. \n. I just realized that you can use the refresh token as a normal token. Is this the case or did I miss something?\nEdit\nI guess it can be solved by setting the typ in EnsureAutenticated, but this should properly be mention in the Readme\n. Makes sense, my only concern is that if someone isn't aware of this, you could authenticate your self with a refresh token, which defeats the whole purpose of this. So we might consider having EnsureAuthenticated check for the typ \"token\" per default. What do you think?\n. I think you are right 'access' makes much more sense then token. If we don't make it a default in EnsureAuthenticated as well,  I think we should at least inform the user about the implications.\n. Any progress on this?\n. I think the overall idea sounds really solid.\nThis allows to define your own token type and still benefit from the exchange functionality. The only downside I see is that someone could potentially exchange a \"access\" token for a \"refresh\" token. \nWe could predefine these two types and enforce some behavior to prevent that. What do you think?\n. Seems good, I will start working on it\n. Here is first shot at the proposed solutions. Still missing docs and being able to modify the token created\nSome questions:\n- Should we keep the ttl config, so we wont break existing projects, and just use it as a fallback if the token_ttl does not exists.\n- We might consider lowering the fallback ttl from 1000.000.000s to something more sense able or throw and error if there is no config\n. I will have a look. I have a very busy work week coming up, but I will be back in action the 27.\n. I am sorry for the huge delay on this, but I have fixed the two issues you mentioned namely; to handle atom types and not drop all claims when doing the exchange\n. If you don't have anymore feedback, I will update the docs and we can finish this.\n. I will update the docs and rebase it this weekend\n. Okay, I did the rebase, and added some docs.\nOne thing we didn't talk about is the ability to have more than one token defined the the the config file.\nWhere should document this?\n. I am sorry for reviving this again, but I am pretty sure that we could just merge this?. I just tested both \nclaims = Guardian.Claims.app_claims\n             |> Guardian.Claims.ttl({5, :days})\nand \n{:ok, jwt, _} = Guardian.encode_and_sign(\n      \"thinger\",\n      \"my_type\",\n      %{\"exp\" => exp, \"iat\" => iat})\nand both are them are not working, the exp for both of them are getting overwritten here  \nI am not entirely sure how to fix, we might need to rethink the way we set the ttl\n. It works for the test I wrote.\nThe problem is that\n|> Guardian.Claims.ttl\nwill hit  which resets the exp to the default value\nSo by only calling \n|> Guardian.Claims.ttl\nwhen we actually have a new ttl, we fix that\n. Makes sense. Seems like a good idea to keep the claims logic out of guardian.ex \nThe only problem I see is if someone does something like this\nclaims = %{\"exp\" => exp, \"iat\" => iat} \n |> Guardian.Claims.ttl({5, :days})\nBut that is highly unlikely, sense the statements are contradicting each other.\nA third way to fix this is actually to remove this  line and make claims.ex handle everything related to ttl and exp\nEdit: Never mind, it can actually handle that as well\n. Maybe you should merge your changes and I can close this?\n. @praveenperera Currently the remember_me and verify_cookie, does not look for/store the token under the same key. So even though the above is correct it wont work. Its getting fixed in #419 \nAnd you right about the docs, I will put that into the PR. . @iacobson the remember_me functionality was removed temporarily, but we in the process of adding it back. See #419    . Hi, I started working on this, any suggesting to the lifespan of the cookie?. #fixed by #419 . So its seems likeCode.ensure_loaded only work on module level. I propose to move the permission plug to Guardian.Plug.Permission, this however is a breaking change. What do you think about this?\nFirst draft here: https://github.com/Hanspagh/guardian/tree/fix-ensure-loaded  . Fixed by #404 . It works, I build from 1.0-beta before but that didn't include #404. . Do you track who is working on fixing what issues, so I wouldn't end up trying to fix something that is already fixed :)    . I am totally fine with delaying it or even closing this PR. Just wanted to notify that I actually started working on this, and get a possible solutions to the max age. Okay, I fixed all the things on my to do, expect for \n\nDecide if we should ignore the token expired error and let Plug.EnsureAuthenticated handle it #405  \n\nDo you have any opinions on this? . I would love to finish this, but I would love a clear decisions on the token expired error . Should we just ignore it and assumePlug.EnsureAuthenticated will handle it later in the pipeline or does it actually make sense to have Guardian.Plug.VerifyCookie throw the error. I changed the verify cookie plug to not handle the expired token and for now I will skip this sign_out should also clear the remeber_me cookie. @doomspork all done.\n@yordis isnt mix format only part of the v1.6.0-dev elixir version? . Requested changes.\nEnglish isn't my first language so any feedback on the comments and docs is very welcome.. @robmadole To be honest, I dont know. . Sure, I can add it to the plug macro and remove the secure default. I guess its on the users if they save token in a cookie on a http connection.  . Hi, any status on when is could be accepted?. Awesome, thank you.   . Sounds like your are missing setting a module for your pipeline, take a look at this https://github.com/ueberauth/guardian#create-a-custom-pipeline, if you have already done this, could you provide a code sample or a more detailed error message?\n. Should be good to go now. Sorry for the wait on this, I will try to reproduce this today. Okay @NeoAlchemist. The reason for your error is this line.\nBasically if there is already a token in the current plug session, the VerifySession is ignored, and I think its just wrong use of the library. Could you explain the the reason behind this and then maybe we can come up with a solution to your problem.  \nIf you really need your own plug then you can ensure the token type like this\nplug Guardian.Plug.EnsureAuthenticated, claims: %{\"typ\" => \"admin\"}\nPS. had nothing to do with the Bitwise or Ensure. I have not been able to recreate the exmaple of @rafamedina, Do you by any chance have a code example with this problem?. Closing due to inactivity. I would think it would be possible to use https://hexdocs.pm/plug/Plug.Conn.html#delete_resp_cookie/3 to remove it when you sign out. . @yordis Are you working on this?. I guess its a matter of how you understand the verify part of VerifySession, some might argue that an expired token is not valid and there for should not get past the Plug, but since its handled otherwise the VerifyCookie plug, it would make sense to align the two. \nCould potentially be a breaking change since VerifySession would stop to throw errors for some people.   . Since typ is also part of the jwt claims you can also use the claims to set the token type. \nAs I understood it, both options are available because sometimes you have some claims and you want to sign a new token with those claims  but a new token type. The options type makes this easy and you don't have to add typ to your already existing claims.    . I have just had a look at this, guardian doesn't seem to use render anywhere, the warning you are referring to looks like is coming from your own implementation of the error_handler, could that be the case?. I assume this is fixed, so we should close this. Seems like pulling out phoenix is reasonable, but I still think there is some value in the helper functions in socket. Would it somehow make sense to keep these to avoid having people using the sockets, implement this them self? I am not sure how this would be achieved though :confused:     . @doomspork I was still thinking sockets within phoenix, but my thought was that everybody would need the helper functions when working with the phoenix sockets, so it would be nice to have them somewhere, maybe in a guide or a utility library.   . @doomspork I completely missed that, my apologies. The above can just be ignored \ud83d\ude0a. Thank you for the heads up and very clear instructions. Maybe we should add this to the upgrade guide?. Wrong branch sorry. I guess we can do that, but the odd thing is that it is already 0.19.2 in the lock file. I only updating the deps I was able to get the docs generated. Hi @freqn could you provide the url of the broken links?. Thank you. This is actually because the guides are being generated to be viewed on hexdoc. We will find a way to make this more obvious or fix the links on github. Hi, would you mind telling what kind of trouble you had? The changes are fine, but {:bcrypt_elixir, \"~> 2.0\"} requires Erlang 20, which should be okay, but I would still be happy to know what was not working. . I have now renamed the base permission module and added text and atom encoding modules. Fell free to have a look.. yes, but this ensures that we can set a default living time for the refresh tokens\nEdit:\nI read your comment wrong, the reason I used \"refresh\" is because guardian currently use \"token\" as default\n. I guess that would make sense. But should properly be in a new PR. Any reason to remove these two lines of documentation?. I used it when I was debugging a bitwise error. What I thought could be cool was to write the input permission and the required permission, but maybe this is a little bit out of scope for now? . ",
    "nambrot": "Has there been any progress on providing a solution for refresh tokens, or at least a recommended way of doing it yourself?\n. ",
    "gaynetdinov": "I think I'd go with second option. All my requests are done via ajax, so once I get a response from the 'relogin' endpoint, the client side has a proper session and all ajax requests work just fine. \nThank you again, @hassox!\n. ",
    "neezer": "Apologies, now that I've played around with this some more, I realize it's not a Guardian specific question. Came up with the below solution.\n\nI added a map to my user record... and defaulted it to %{}. Since I'm using PostgreSQL, I have the field type set to :json.\nelixir\ndefmodule Mpapi.User do\n  schema \"users\" do\n    field :permissions, :map\n    # ...\n  end\n  # ...\nend\nThen I can save my permissions per-user by passing in the same declaration I was using to generate the token previously:\nelixir\nRepo.update!(User.changeset(user, %{ permissions: %{ default: [:read, :write] }})\nFinally, when I'm creating the token, I now do this:\nelixir\n{ :ok, jwt, full_claims } = Guardian.encode_and_sign(user, :token, %{\n  name: user.name,\n  perms: user.permissions\n})\n. ",
    "nathanbuchar": "This was very helpful, thank you for outlining your solution :). ",
    "avocade": "\ud83d\udc4d . \ud83d\udc4d . ",
    "jayjun": "@aaronrenner Bumping this, because it'll be super handy. Happy to assist. \ud83d\ude42. @doomspork I'll have to grok Guardian before attempting this. If I (ever) get time to revisit tests, I'll take a crack, otherwise I'm currently swamped too.. I like it, for all the reasons you mentioned. Though I also like modifying User:X directly in the browser when debugging.\nI don\u2019t know what token variations are possible in v1, but even passing token components through the URL should still result in calling Guardian.encode_and_sign/3 anyway.\nI suggest we go ahead with your suggestion first. If and when we implement constructing a token via URL, it will be a layer added on this work.. @odarriba It\u2019s inspired by Clearance\u2018s backdoor for faster tests, and Mislav\u2018s backdoor hack for faster edit-compile-run cycles.\nIf I\u2018m not wrong, a test session can be added in just one call to Guardian.Plug.sign_in/4 without a test helper. That is what this backdoor essentially wraps.\nGuardian.Plug.Backdoor is a plug so tests or users can bypass authentication plugs by appending \u201dmagic parameters\u201d to URLs. Alternative tokens can be tested really quickly.\nelixir\nnavigate_to \"/?as=User:5\"        # assert success\nnavigate_to \"/admin/?as=User:5\"  # assert failure\nnavigate_to \"/admin/?as=Admin:1\" # assert success\nAs for raising, we\u2019re not supposed to use Mix.env/0 during runtime. Maybe we swap the backdoor for no-op outside test environments?\nI\u2019m also happy to scrap this whole idea if risks outweigh benefits.. @codesparkle Excellent point! Changed to whitelist :dev and :test rather than blacklist :prod.. @hassox @doomspork In hindsight, I absolutely agree that this should be a separate community package, either in Guardian.Test or by itself. That way, it can be excluded from production like so,\nelixir\n{:guardian_backdoor, \">= 0.0.0\", only: [:test, :dev]}\nAs for restricting it to tests, I must add that backdoors have been invaluable for rapid development. In fact, not providing a community-vetted package may encourage others to write their own, which could cause more harm.\nHaving the backdoor in its own package has the benefit of allowing anyone to use it in tests only, or in development too.. How about :guardian_backdoor with Guardian.Plug.Backdoor as the module name?. Conditional packages typically aren\u2019t controlled at mix.exs alone. It\u2019s idiomatic to add Code.ensure_loaded?/1 in userland.\n```elixir\nmix.exs\n{:guardian_backdoor, ..., only: [:test]}\nrouter.ex\nif Code.ensure_loaded?(Guardian.Plug.Backdoor) do\n  plug Guardian.Plug.Backdoor\nend\nYes, it\u2019s still dangerous without the conditional, but at leastelixir\nplug Guardian.Plug.Backdoor\n``\ncan\u2019t even compile outside:test.. @jsteiner You\u2019re right!asis changed totoken`. Examples updated.. ",
    "potatosalad": "@hassox Done.\nOn a partially related note, I made some changes last week to jose which added better support for determining the JWS algorithm based on the key alone.\nSo, for example, you can generate a key like this (using JOSE.JWS instead of JOSE.JWK):\nelixir\niex> jwk = JOSE.JWS.generate_key(%{\"alg\" => \"HS256\"}) |> JOSE.JWK.to_map |> elem(1)\n%{\"alg\" => \"HS256\", \"k\" => \"UuP3Tw2xbGV5N3BGh34cJNzzC2R1zU7i4rOnF9A8nqY\", \"kty\" => \"oct\", \"use\" => \"sig\"}\nNotice the \"use\" and \"alg\" keys are embedded in the key now.  A JWS map can be returned by calling JOSE.JWK.signer/1:\nelixir\niex> jws = JOSE.JWK.signer(jwk)\n%{\"alg\" => \"HS256\"}\nI'm not sure if that provides any benefit over what guardian is doing (grabbing the first value of allowed_algos), but I thought it might be worth mentioning.\n. I added a brief entry to the CHANGELOG.  Let me know if there's anything else that needs to be done.\n. ### Short Answer\nA cryptographically secure randomly generated 16 byte (or 128 bit) symmetric oct key for use with signature algorithm HS256 should be sufficient for many HTTP bearer authentication use cases.\n``` elixir\nGenerate a 128-bit oct JWK\nJOSE.JWK.generate_key({:oct, 16}) |> JOSE.JWK.to_map |> elem(1)\n%{\"k\" => \"5Fn8i7r5cRWZW_yyr9Flkg\", \"kty\" => \"oct\"}\nConfigure Guardian to use HS256 and our generated JWK\nconfig :guardian, Guardian,\n  allowed_algos: [\"HS256\"],\n  secret_key: %{\"k\" => \"5Fn8i7r5cRWZW_yyr9Flkg\", \"kty\" => \"oct\"}\n```\nAnything larger than that (like using HS512 that @hassox mentioned with a 64 byte key), is also perfectly acceptable and could potentially change the time required for a brute force attack from decades to centuries.\nIf you want public-key cryptography, I provide my personal opinion at the very bottom of this comment, but it's much more difficult to recommend one as the \"sane default\".\nLong Answer\nThere are really only two major types of keys to choose from for the signature operations: symmetric and asymmetric.\nIn simpler terms:\n- symmetric - you have a secret key.\n- asymmetric - you have a secret key and public key comprising a key pair.\nThe main difference in behavior between the two is:\n- symmetric - the signer is also the verifier.  This means that a client will not be able to verify whether a token was signed by a specific signer or not.  The signed token is essentially opaque to the client.\n- asymmetric - the verifier may have access to the public key of the signer.  This means that a client can verify that a token has been signed by a specific signer.\nRelating the above to SSL/TLS, certificates are signed using an asymmetric secret key and distributed to clients with the embedded public key.  This means (for example) your browser can verify that a certificate has been signed by Google.  A symmetric key would be useless in this case because anyone who had the key would be able to sign a certificate as if they were Google.\nSymmetric cryptography\nThe following algorithms use a symmetric key (or an oct key type), which is really just a sequence of bytes.\n- HS256 - HMAC using SHA-256\n- HS384 - HMAC using SHA-384\n- HS512 - HMAC using SHA-512\nThe number at the end of the signature algorithm specifies the output length of the signature in bits.  The signature is always the same for the same given secret key and message.\nThe recommended key length is mentioned in RFC 2104:\n\nThe key for HMAC can be of any length (keys longer than B bytes are first hashed using H).  However, less than L bytes is strongly discouraged as it would decrease the security strength of the function.  Keys longer than L bytes are acceptable but the extra length would not significantly increase the function strength. (A longer key may be advisable if the randomness of the key is considered weak.)\n\nSo for HS256 the B is 64 bytes and the L is 32 bytes, which means any key between 32 and 64 bytes would be recommended.  For HS384, any key between 48 and 128 bytes.  For HS512, any key between 64 and 128 bytes.\nThat said, any key 16 bytes (or 128 bits) or greater should be sufficient for most general purpose use.  A 128-bit key would currently take a very long time to brute force (many years or decades on current technology).  The HMAC group is the only group of signature algorithms in jose that are likely quantum computer resistant.\nAsymmetric cryptography (or public-key cryptography)\nThere are three major types of asymmetric key types for signature algorithm use.\n1. ECDSA - Elliptic Curve Digital Signature Algorithm\n2. EdDSA - Edwards-curve Digital Signature Algorithm\n3. RSA - RSA signature padding schemes for PKCS#1.5 and PSS\nNote: EdDSA in jose is still in draft form and the exact specification may change.\nFor ECDSA, there are three algorithms which are tied to a specific curve for the EC key type:\n1. ES256 - ECDSA using P-256 and SHA-256\n2. ES384 - ECDSA using P-384 and SHA-384\n3. ES512 - ECDSA using P-521 and SHA-512\nFor EdDSA, there are two algorithms which are tied to a specific curve for the OKP key type:\n1. Ed25519 - EdDSA using Ed25519\n2. Ed448 - EdDSA using Ed448\nFor RSA, there are six algorithms which use different padding schemes (PKCS#1.5 versus PSS) for the RSA key type:\n1. RS256 - RSASSA-PKCS1-v1_5 using SHA-256\n2. RS384 - RSASSA-PKCS1-v1_5 using SHA-384\n3. RS512 - RSASSA-PKCS1-v1_5 using SHA-512\n4. PS256 - RSASSA-PSS using SHA-256 and MGF1 with SHA-256\n5. PS384 - RSASSA-PSS using SHA-384 and MGF1 with SHA-384\n6. PS512 - RSASSA-PSS using SHA-512 and MGF1 with SHA-512\nMy Opinion\nAs of today (2016-05-19), my recommendation for asymmetric cryptography would be ES512.\n- RSA is slow.  Really slow.  When you are using it for HTTP bearer authentication, a slow verify operation for each request can become unwelcome overhead.  ECDSA, on the other hand, is much faster, but not quite as fast as the HMAC algorithms.\n- NIST originally recommended the P-256 and P-384 elliptic curves, but both curves were later found to have potential weaknesses and are no longer considered safe.  NIST operates very closely with the NSA, which has come under increased scrutiny lately and the safety of their recommendations have come into question.  The P-521 elliptic curve was developed independently and is still considered to be safe.\n- While not as widespread as the RSA algorithms, the ECDSA algorithms are built into OpenSSL and fairly well supported at this point.\nMy near future recommendations are Ed25519 and Ed448.  They are still in draft algorithms, but in my opinion, they are near perfect asymmetric key types for HTTP bearer authentication.\n- Fastest signature algorithm yet, faster than ECDSA and almost as fast as the HMAC algorithms.\n- Developed independently from NIST, so they don't suffer from the same stigma as the ECDSA curves.\n- Not very widespread yet.  Ed25519 support is present in OpenSSH and Google's boringssl (which is used by Android, Chrome, etc), but not present in OpenSSL yet.  Ed448 is really only present in libdecaf which is still under development.\nSome of the cryptography community is working on public-key cryptography algorithms which are more quantum computer resistant, such as XMSS and Hash-based signatures which may finally provide a \"sane default\" for asymmetric keys.\nIf you want to use RSA, I would recommend the PS256, PS384, and PS512 algorithms over the other RSA algorithms.  The PKCS#1.5 padding scheme (RS256, RS384, and RS512) does not provide a high enough level of security generally should be replaced by the PSS padding scheme.\nOpinionated Examples\n``` elixir\n\nES512\n\nGenerate a JWK for use with ES512\nJOSE.JWS.generate_key(%{\"alg\" => \"ES512\"}) |> JOSE.JWK.to_map |> elem(1)\n%{\"alg\" => \"ES512\", \"crv\" => \"P-521\", \"d\" => \"AVDuOBokicU-yXj4zNwrK-29vmUvmOBNxHB-7_PgRO6e3VKTl-wuUmPEQnHtG_GYoC0cUHAJtpGlaeGF1mIRpeSk\", \"kty\" => \"EC\", \"use\" => \"sig\", \"x\" => \"ANT4yNLVHCeYtQOpjbhuXnoB69C4VoWLESxxbnEKt8W8BTL_7kdqUcCMBxxQvPhrf3fmliosAxb1BcspPtV4aofP\", \"y\" => \"AAPlYHP2qGpubv_qzYbNvMOxJUOuypaVeEYV6NnEtWpW2jHupr5xMaINDXgpN1CDwddZxQ-WpE4jQEl8onXD9_su\"}\nConfigure Guardian to use ES512 and our generated JWK\nconfig :guardian, Guardian,\n  allowed_algos: [\"ES512\"],\n  secret_key: %{\n    \"alg\" => \"ES512\",\n    \"crv\" => \"P-521\",\n    \"d\" => \"AVDuOBokicU-yXj4zNwrK-29vmUvmOBNxHB-7_PgRO6e3VKTl-wuUmPEQnHtG_GYoC0cUHAJtpGlaeGF1mIRpeSk\",\n    \"kty\" => \"EC\",\n    \"use\" => \"sig\",\n    \"x\" => \"ANT4yNLVHCeYtQOpjbhuXnoB69C4VoWLESxxbnEKt8W8BTL_7kdqUcCMBxxQvPhrf3fmliosAxb1BcspPtV4aofP\",\n    \"y\" => \"AAPlYHP2qGpubv_qzYbNvMOxJUOuypaVeEYV6NnEtWpW2jHupr5xMaINDXgpN1CDwddZxQ-WpE4jQEl8onXD9_su\"\n  }\n\nEd448\n\nGenerate a JWK for use with Ed448\nNote: you will need to run JOSE.crypto_fallback(true) or have erlang-libdecaf installed\nJOSE.JWS.generate_key(%{\"alg\" => \"Ed448\"}) |> JOSE.JWK.to_map |> elem(1)\n%{\"alg\" => \"Ed448\", \"crv\" => \"Ed448\", \"d\" => \"ArlWJD8C8B4yyBhDDSSpjjJgC9ASFSiPACajGpJFd1wLdfWNQdwvUdHUN-ZnRBBGUfebZgvb-ZTe\", \"kty\" => \"OKP\", \"use\" => \"sig\", \"x\" => \"OabW8I7n2qidiuShu_LlW7ntrG99_Q7d4Vps4tnxBF-ROnRZ4IQn2diPdMrX8vi0xCtDhGeUq-6A\"}\nConfigure Guardian to use Ed448 and our generated JWK\nconfig :guardian, Guardian,\n  allowed_algos: [\"Ed448\"],\n  secret_key: %{\n    \"alg\" => \"Ed448\",\n    \"crv\" => \"Ed448\",\n    \"d\" => \"ArlWJD8C8B4yyBhDDSSpjjJgC9ASFSiPACajGpJFd1wLdfWNQdwvUdHUN-ZnRBBGUfebZgvb-ZTe\",\n    \"kty\" => \"OKP\",\n    \"use\" => \"sig\",\n    \"x\" => \"OabW8I7n2qidiuShu_LlW7ntrG99_Q7d4Vps4tnxBF-ROnRZ4IQn2diPdMrX8vi0xCtDhGeUq-6A\"\n  }\n\nPS256\n\nGenerate a JWK for use with PS256\nNote: you will need to run JOSE.crypto_fallback(true) since RSA PSS is not natively supported as of OTP 18\nJOSE.JWS.generate_key(%{\"alg\" => \"PS256\"}) |> JOSE.JWK.to_map |> elem(1)\n%{\"alg\" => \"PS256\", \"d\" => \"jDoVruE_9ilASyMyBqk-9EXTjnoaJwL6ruK0iOaftJw0i7AQC841jFuAbNpRIIfKfNqq7GKYWC9KDriRS0hbicUUwUoN__PmiSxMD6pthCGyjSL-_Sa5BkuhHkUnP5jtcsK86UJrVkLWf96m-R0Ks-Bm0xCEVww5kZH_uPw-JiTJpxVuwF9dSbjFEbNz_kxn0efD1toGGJ-GJXVlkt-n84buUzUmEhvQwq9j34a9ZEG_mNQ3NZoq2jZ3OUF_z7BQeYawKuuSWxlJ3sRVuVU75uQ-QGyUR__K-EmIFSGFhp3n9iFe2u7pGXpihlR27BdVVj8HJCb8QqbfbvUYfcDDxQ\", \"dp\" => \"l9as4VlICMtCImS0oBqNKjpDI1-34OFqsI0UWfmGSE0e9FTz-sVpNt6Yd97Y2SKCbJZu7DPqnh3C3LrdoTqYTrUao5s5MxzasMT1kT6xpcYbQEq5FeXl_eXClec_19SToBsRUa5Cp35T3k4jpX3io8SQ0kLdNrPvCDw4X_kjuEU\", \"dq\" => \"SY_FtN75qEl1MMbfdzTBnoKokk6lc1gkGt9K3BhSrB83sFuujswVc4GaKdSmzHrncC0PbRpcnl8DhLDl9xxkECC0V1gkWyXOHnUqyNpqyFIZNHTOE-WPwrLJ1o26JoVA3fLY_YEirqOcIGP5OvjdCRE_vE9Wtf2OZ9DmYowPasU\", \"e\" => \"AQAB\", \"kty\" => \"RSA\", \"n\" => \"zzsAdivyQfcixV06tn4YfxJ9JDLHqNbkInWQBQ1POayRlfW2Kr4CT_UVKKk-HOc5TxMilBm6J8WAVP0YsFRdyIdBoagIO1qX1q8jUpqQXaaqk0T3do0nbWbBc-M843d-h3Brq-xUiejm99OoyQzX1ViweoPbB4Zoh7N8MV4YVvu6DDlofd0xrDpPlmmqAocDLvRRyv7wshqT08FKJoJj9MQNnzu-RHN9bHbDFRECvYEL_sxcO_dOHEfVW9U2TmaiAUa9B1p_QkzvWtQO8ttzLz_o7ujZMxfbnJzZi2aOg6_4Zftc_1HhxEqKI6GmsGFvUI4yuFN8NfQ6laUMAn2qJQ\", \"p\" => \"-7VhtutTjz69dMVC7CQW4FTWS7q1PQu-YLCT_xsHt7RPbJeuxTL2LA7CfIFbpzsDqMS4fUd-gR9phuUDQFQWSLCA1wXEszpAdD6r5fht9LssN4Uuy6ivOVuazLalA52zBj8vAOqyroGo-WUlYwT2BoxJqDDmLFNJDpc-ioGphe8\", \"q\" => \"0sN9Piqlfsrmh7v090AjUB0WmIMqICkXBYWgXvEOcTyif9jzeHmieiiT2-eQdA4ZxoZXXVY31SdkyiCqNET6B4eJjA8VR1xBrRVj4Bg3ASbDTVuCezHYHZMh-ITgVINt061wE_1n1aGeDMJ8ZUlOV2kk7YX0STJvN2-mrwWBhSs\", \"qi\" => \"LownZt59Rjp8vpH9rzkXLLvJchc46mBeGVSKmfcortkh4PTkpv0pFU83RsVuLjjWAIwTVncMqXebLraxPI4m-Eo4ysQGFq6fLHYKHJGdUOZc15O4iZHz7A11PixHoD_DPQvjD3_Nu71dTY18-FNKUwcYErgnPessP2JcE1SgEzA\", \"use\" => \"sig\"}\nConfigure Guardian to use PS256 and our generated JWK\nconfig :guardian, Guardian,\n  allowed_algos: [\"PS256\"],\n  secret_key: %{\n    \"alg\" => \"PS256\",\n    \"d\" => \"jDoVruE_9ilASyMyBqk-9EXTjnoaJwL6ruK0iOaftJw0i7AQC841jFuAbNpRIIfKfNqq7GKYWC9KDriRS0hbicUUwUoN__PmiSxMD6pthCGyjSL-_Sa5BkuhHkUnP5jtcsK86UJrVkLWf96m-R0Ks-Bm0xCEVww5kZH_uPw-JiTJpxVuwF9dSbjFEbNz_kxn0efD1toGGJ-GJXVlkt-n84buUzUmEhvQwq9j34a9ZEG_mNQ3NZoq2jZ3OUF_z7BQeYawKuuSWxlJ3sRVuVU75uQ-QGyUR__K-EmIFSGFhp3n9iFe2u7pGXpihlR27BdVVj8HJCb8QqbfbvUYfcDDxQ\",\n    \"dp\" => \"l9as4VlICMtCImS0oBqNKjpDI1-34OFqsI0UWfmGSE0e9FTz-sVpNt6Yd97Y2SKCbJZu7DPqnh3C3LrdoTqYTrUao5s5MxzasMT1kT6xpcYbQEq5FeXl_eXClec_19SToBsRUa5Cp35T3k4jpX3io8SQ0kLdNrPvCDw4X_kjuEU\",\n    \"dq\" => \"SY_FtN75qEl1MMbfdzTBnoKokk6lc1gkGt9K3BhSrB83sFuujswVc4GaKdSmzHrncC0PbRpcnl8DhLDl9xxkECC0V1gkWyXOHnUqyNpqyFIZNHTOE-WPwrLJ1o26JoVA3fLY_YEirqOcIGP5OvjdCRE_vE9Wtf2OZ9DmYowPasU\",\n    \"e\" => \"AQAB\",\n    \"kty\" => \"RSA\",\n    \"n\" => \"zzsAdivyQfcixV06tn4YfxJ9JDLHqNbkInWQBQ1POayRlfW2Kr4CT_UVKKk-HOc5TxMilBm6J8WAVP0YsFRdyIdBoagIO1qX1q8jUpqQXaaqk0T3do0nbWbBc-M843d-h3Brq-xUiejm99OoyQzX1ViweoPbB4Zoh7N8MV4YVvu6DDlofd0xrDpPlmmqAocDLvRRyv7wshqT08FKJoJj9MQNnzu-RHN9bHbDFRECvYEL_sxcO_dOHEfVW9U2TmaiAUa9B1p_QkzvWtQO8ttzLz_o7ujZMxfbnJzZi2aOg6_4Zftc_1HhxEqKI6GmsGFvUI4yuFN8NfQ6laUMAn2qJQ\",\n    \"p\" => \"-7VhtutTjz69dMVC7CQW4FTWS7q1PQu-YLCT_xsHt7RPbJeuxTL2LA7CfIFbpzsDqMS4fUd-gR9phuUDQFQWSLCA1wXEszpAdD6r5fht9LssN4Uuy6ivOVuazLalA52zBj8vAOqyroGo-WUlYwT2BoxJqDDmLFNJDpc-ioGphe8\",\n    \"q\" => \"0sN9Piqlfsrmh7v090AjUB0WmIMqICkXBYWgXvEOcTyif9jzeHmieiiT2-eQdA4ZxoZXXVY31SdkyiCqNET6B4eJjA8VR1xBrRVj4Bg3ASbDTVuCezHYHZMh-ITgVINt061wE_1n1aGeDMJ8ZUlOV2kk7YX0STJvN2-mrwWBhSs\",\n    \"qi\" => \"LownZt59Rjp8vpH9rzkXLLvJchc46mBeGVSKmfcortkh4PTkpv0pFU83RsVuLjjWAIwTVncMqXebLraxPI4m-Eo4ysQGFq6fLHYKHJGdUOZc15O4iZHz7A11PixHoD_DPQvjD3_Nu71dTY18-FNKUwcYErgnPessP2JcE1SgEzA\",\n    \"use\" => \"sig\"\n  }\n``\n. @StevenNunez Which version of guardian are you using?  Support for key types other thanoct` was added in version 0.11.1.\nI put together an example project potatosalad/guardian-example-app using the same config you provided with the dependency version set to guardian 0.11.1.\nHere is a sign and verify example from the project while running iex -S mix:\n``` elixir\nSign\n{:ok, signed_binary, jwt_map} = Guardian.encode_and_sign(\"test\")\n{:ok,\n\"eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJ0ZXN0IiwiZXhwIjoxNDY2Njg3Mzg0LCJpYXQiOjE0NjQwOTUzODQsImlzcyI6IkJsb2dCYWNrZW5kIiwianRpIjoiMWU4OTg2M2YtZGI2My00MmJmLWE5YjYtOTY1MTU1NDk2ODA1IiwicGVtIjp7fSwic3ViIjoidGVzdCIsInR5cCI6InRva2VuIn0.AYMPeB1lgx90_79xBoKRJbKXGcIo5w8sS4ArJ3A0gZFzHf1cNlME1JHqbhzShcHsb6qH94n6gvqswgQgnLGKd2stAY8IIokRVcD8DTFwcyf6gf7Y-CO3LTOxWEsE6p2DbMaenTBdJsTe8Qhx41wRta8DOunXs33mAtApdwBIZzS9yxiJ\",\n%{\"aud\" => \"test\", \"exp\" => 1466687384, \"iat\" => 1464095384,\n\"iss\" => \"BlogBackend\", \"jti\" => \"1e89863f-db63-42bf-a9b6-965155496805\",\n\"pem\" => %{}, \"sub\" => \"test\", \"typ\" => \"token\"}}\nVerify\n{:ok, ^jwt_map} = Guardian.decode_and_verify(signed_binary)\n{:ok,\n%{\"aud\" => \"test\", \"exp\" => 1466687384, \"iat\" => 1464095384,\n\"iss\" => \"BlogBackend\", \"jti\" => \"1e89863f-db63-42bf-a9b6-965155496805\",\n\"pem\" => %{}, \"sub\" => \"test\", \"typ\" => \"token\"}}\n```\nNote: With ES512, the signature value will change each time a message is signed.  So even with the the exact same message and key, your signed_binary may not match the one provided in the example above.\n\nIs there any reason to not just use the result of mix phoenix.gen.secret? I got it working that way.\n\nThat's probably a POLA violation (or bug) that you have uncovered in jose.  You are no longer using ES512, but actually HS512 due to the key type being oct.  Since both key types use SHA-512, the sign and verify functions related to the ECDSA algorithms are allowing the oct key type to pass through.\nI will post an update here once the jose library has been fixed.\n. Hey @RomarioLopezC,\nThis is due to the release of jose 1.8.0 which is more strict about which algorithms are allowed to be used with specific keys as mentioned in potatosalad/erlang-jose#24.\nIt should be resolved if you add the following line to your guardian configuration:\nelixir\nallowed_algos: [\"ES512\"]\nLet me know if you have any other issues.  Also, it may go without saying, but you may need to change your secret key if that was your actual secret key you posted and not just an example.\n. ",
    "fajarmf": "nvm, I just found it after quick googling https://github.com/hassox/phoenix_guardian\n. ",
    "ashrafhasson": "I'm facing a similar issue where normal user should have \"update_self\" permission and admin user should have \"update\" permission, both of which apply to the same action. \nWith @doomspork 's setup it still doesn't authorize the request when tested. Only the specified profile on the action gets allowed, so if I specify \"admin\" which has the \"update\" permission for the action, a normal user signed with %{default: ~w(update)} will not be able to request that path.\n. Thanks for the feedback @hassox really appreciate it.\nHmmm, I thought if we don't specify a one_of to the initializer we should still honour allowing multiple sets checked but instead of OR'ing them, they'd be logically AND'ed, or so I thought the default (current) behaviour is. I've tested with multiple permission sets without the one_of and it seems as if all sets must match.\n. I found that these two test cases would fail if we don't check all permission sets when one_of is not present.\n. @hassox I've applied your changes to the pull request, please let me know if you'll need a rebase and a squash before accepting this PR.\nThanks,\n. I like this approach :) but when does matches_permissions?(_, _, []) get its pattern matched? Also, should it not be private?\nAnother note is below regarding the use of Enum.any.\n. @doomspork lol, yes and sorry about the typo, I'll fix that when I get to it. Thank you :)\n. ",
    "gagalago": "Sorry, I did not see the pull request #122 before making my issue.\nSo I will use this implementation ;)\nThanks @potatosalad\n. ",
    "martinos": "At many place in the README.md file they talk about a location.\nExample:\nGuardian.Plug.claims(conn) # Access the claims in the default location\nGuardian.Plug.claims(conn, :secret) # Access the claims in the secret location\nWhat does it mean ? Is it where claims is stored ? It's not clear to me.   \nI would gladly write some documentation about it, however I don't understand what it is.\n. Thanks for the explanation, I think I understand. Am I right if I say that the location is the key where the claim is stored in the session ?\n. Makes a lot of sense, thanks for your response. I have never thought of storing the JWT in a different cookie that the session's one. \nI'll try it this next week-end.\n. ",
    "manukall": "Hey, could I get some input on this. I'm currently depending on my form from my projects, but would like to depend on the hex package again. I thought this was a bugfix, but I'm not completely sure :-)\n. @hassox thanks for your reply. i'll reset the LoadResource plug and change set_current_resource. Would you want Plug.current_resource to still return just the resource or {:ok, resource} then? (the latter would obviously break the existing api.)\n. ping @hassox \n. i pushed another commit allowing poison >= 1.3.0. is this ok?\n. ",
    "madshargreave": "I totally missed that, my bad\n. Perfect, much appreciated\nAnd yes, works now \n. ",
    "ospaarmann": "This compiles. But now the config value is the function itself and not what it returns:\n```\niex(2)> Guardian.config\n[allowed_algos: [\"HS512\"], verify_module: Guardian.JWT, issuer: \"MyApp\",\n ttl: {30, :days}, verify_issuer: true,\n secret_key: #Function<20.50752066/0 in :erl_eval.expr/5>,\n serializer: MyApp.GuardianSerializer]\niex(3)> Guardian.config(:secret_key)\nFunction<20.50752066/0 in :erl_eval.expr/5>\n```\n. This returns the correct value but I believe the Guardian configuration itself is still not correct. No?\n. No. I have to check some other things since I'm not using Ecto but will report back. Thanks for the help\n. I tried this in another Phoenix App that uses Ecto and is less custom-made. It does not work. The error I'm getting is\n[error] #PID<0.379.0> running MyApp.Endpoint terminated\nServer: localhost:4000 (http)\nRequest: POST /api/v1/sessions\n** (exit) an exception was raised:\n    ** (FunctionClauseError) no function clause matching in :base64url.encode/1\n        src/base64url.erl:22: :base64url.encode(#Function<20.50752066/0 in :erl_eval.expr/5>)\n        lib/guardian.ex:291: Guardian.jose_jwk/1\n        lib/guardian.ex:298: Guardian.encode_claims/1\n        lib/guardian.ex:89: Guardian.encode_and_sign/3\n        (data_bucket) web/controllers/session_controller.ex:15: MyApp.SessionController.create/2\n        (data_bucket) web/controllers/session_controller.ex:1: MyApp.SessionController.action/2\n        (data_bucket) web/controllers/session_controller.ex:1: MyApp.SessionController.phoenix_controller_pipeline/2\n        (data_bucket) lib/phoenix/router.ex:261: MyApp.Router.dispatch/2\n        (data_bucket) web/router.ex:1: MyApp.Router.do_call/2\n        (data_bucket) lib/data_bucket/endpoint.ex:1: MyApp.Endpoint.phoenix_pipeline/1\n        (data_bucket) lib/plug/debugger.ex:93: MyApp.Endpoint.\"call (overridable 3)\"/2\n        (data_bucket) lib/phoenix/endpoint/render_errors.ex:34: MyApp.Endpoint.call/2\n        (plug) lib/plug/adapters/cowboy/handler.ex:15: Plug.Adapters.Cowboy.Handler.upgrade/4\n        (cowboy) src/cowboy_protocol.erl:442: :cowboy_protocol.execute/4\nSo encoding the claims with the JWK fails and there again we find the reference to the anonymous function.\n. So I found the problem. The Readme claims that functions can be passed as Guardian.config(:secret_key) but the necessary changes are only present in the master branch and not in the latest release. They were introduced with this pull request. \nI suggest to either create a release with these changes or mention this in the Readme to save other people some time :)\n. This is what I did to generate a password protected JWK file (which contains the generated key):\nmix phoenix.gen.secret\ntouch .jwk_file\nThe first line just generates a secret I'm using as a password. And .jwk_file is the file to store the jwk in. You can name it whatever you want.\n```\niex -S mix phoenix.server\niex(1)> jwk = JOSE.JWK.generate_key({:ec, :secp521r1})\niex(2)> password = \"The Secret we just generated\"\niex(3)> file = \".jwk_file\"\niex(4)> JOSE.JWK.to_file(password, file, jwk)\n```\nThen in your config.exs\nconfig :guardian, Guardian,\n  allowed_algos: [\"HS512\"], # optional\n  verify_module: Guardian.JWT,  # optional\n  issuer: \"MyApp\",\n  ttl: { 30, :days },\n  verify_issuer: true, # optional\n  secret_key: fn ->\n    {jwe, jwk} = System.get_env(\"GUARDIAN_JWK_PASSPHRASE\") |> JOSE.JWK.from_file(System.get_env(\"GUARDIAN_JWK_FILE\"))\n    jwk\n  end,\n  serializer: MyApp.GuardianSerializer\nOf course you have to pass in your environment variables. So GUARDIAN_JWK_PASSPHRASE should be the password (secret generated earlier) and GUARDIAN_JWK_FILE should be '.jwk_file' in this example. \nThe pattern matching is used because JOSE.JWK.from_file/2 returns the jwk plus the standard jwe and we have to fish out the jwk. And we have to wrap it in an anonymous function because of the way the configuration is parsed (before everything else, so JOSE.JWK would not be available otherwise).\n. @doomspork I agree with that. It seems to be more flexible and doesn't introduce more complexity into the plug itself. \nIt would be nice to add an example to the Readme though, so that less experienced users are made aware of this option. I could create a PR for that, if this helps.\n. ",
    "bsidoruk": "It seems to be here, https://github.com/ueberauth/guardian/blob/master/lib/guardian/channel.ex#L46\n. ",
    "nathany": "Thanks!\n. ",
    "leandroalemao": "@simonh1000 I'm still learning and playing with Phoenix.. but I think you should do.. shouldn't you?\n{:ok, claims} = Guardian.Plug.claims(new_conn)\n. ",
    "Moussenger": "When this pull request will be merged?\n. ",
    "thbar": "Thank you so much for the detailed answer!\n. ",
    "StevenNunez": "Thanks for such a detailed response. Is there a sample app somewhere? I tried to set up an app using ES512 like in the example and am getting \n** (FunctionClauseError) no function clause matching in :base64url.encode/1\n        src/base64url.erl:22: :base64url.encode(%{\"alg\" => \"ES512\", \"crv\" => \"P-521\", \"d\" => \"mhEZkkY6eUJKEVl4Qnjfnik3GZmvPsiQEJC3-9f-jiM2OSHPTTYkOzPfjWbOqhb5JARUaJzXL9YyqHJBDxM_VB8\", \"kty\" => \"EC\", \"use\" => \"sig\", \"x\" => \"AALDyto5SKJ73a7uqLjKLwoCjUvn6Ldpcade5FCOt1zsl9hJGIHVGlXN9ApEsAMo5QmmOlQ5s4C4Fhi2PvvHb9bc\", \"y\" => \"AUZGWn4yuFxXKuqYEds0cm31A0LxY5v7Bmur3LoJaykQrXxd-GdcX4ZH6_hot6VnVWBlsDcHjCBXjxLg0_uJLNM6\"})\nI'm guessing it's trying to pass that whole hash to base encode it.\nRest of config for reference \nconfig :guardian, Guardian,\n  allowed_algos: [\"ES512\"],\n  issuer: \"BlogBackend\",\n  ttl: { 30, :days },\n  secret_key: %{\n    \"alg\" => \"ES512\",\n    \"crv\" => \"P-521\",\n    \"d\" => \"mhEZkkY6eUJKEVl4Qnjfnik3GZmvPsiQEJC3-9f-jiM2OSHPTTYkOzPfjWbOqhb5JARUaJzXL9YyqHJBDxM_VB8\",\n    \"kty\" => \"EC\", \"use\" => \"sig\",\n    \"x\" => \"AALDyto5SKJ73a7uqLjKLwoCjUvn6Ldpcade5FCOt1zsl9hJGIHVGlXN9ApEsAMo5QmmOlQ5s4C4Fhi2PvvHb9bc\",\n    \"y\" => \"AUZGWn4yuFxXKuqYEds0cm31A0LxY5v7Bmur3LoJaykQrXxd-GdcX4ZH6_hot6VnVWBlsDcHjCBXjxLg0_uJLNM6\"\n  },\n  serializer: BlogBackend.GuardianSerializer\n. @potatosalad Thank you!\n. ",
    "romariolopezc": "@potatosalad Hello, i have been using ES512 as you recommended, and my guardian set up was working until i updated jose from 1.7.9 to 1.8.0 my key is like this:\n%{\"alg\" => \"ES512\", \"crv\" => \"P-521\",\n  \"d\" => \"AZ-WCoPA2Kt-Jio-DFuOChf0SBinAYgklUFIdVLmlZwjHmRUntVVatkBGnGyjyUWC0aAqwPdwf5s1ubXtRWT5st3\",\n  \"kty\" => \"EC\", \"use\" => \"sig\",\n  \"x\" => \"AUgiiCT_ycsyZXpHXoYA4s-VpObDQZ99Sqi3vXXDH3lOoSNWg9QiusZ_p-z3OqQ-6wLFZJWORu6COWOF7ROCAEtQ\",\n  \"y\" => \"APmuazEPeBWB_C8xrY0xZSoawsYcL8CycvaOHwiYVh_lHUCVAltLzofi-jM-TxsFzmjUofnwI-gfQCYiZQz1b9lB\"}\nAnd the error from the console when i try to log in:\n2016-08-31T23:57:17.281619+00:00 app[web.1]: Request: POST /sessions\n2016-08-31T23:57:17.281620+00:00 app[web.1]: ** (exit) an exception was raised:\n2016-08-31T23:57:17.281620+00:00 app[web.1]:     ** (ErlangError) erlang error: {:not_supported, [\"P-521\", :HS512]}\n2016-08-31T23:57:17.281628+00:00 app[web.1]:         (jose) src/jose_jwk_kty_ec.erl:355: :jose_jwk_kty_ec.jws_alg_to_digest_type/2\n2016-08-31T23:57:17.281629+00:00 app[web.1]:         (jose) src/jose_jwk_kty_ec.erl:186: :jose_jwk_kty_ec.sign/3\n2016-08-31T23:57:17.281630+00:00 app[web.1]:         (jose) src/jose_jws.erl:311: :jose_jws.sign/4\n2016-08-31T23:57:17.281631+00:00 app[web.1]:         (jose) src/jose_jwt.erl:171: :jose_jwt.sign/3\n2016-08-31T23:57:17.281631+00:00 app[web.1]:         lib/guardian.ex:303: Guardian.encode_claims/1\n2016-08-31T23:57:17.281632+00:00 app[web.1]:         lib/guardian.ex:94: Guardian.encode_from_hooked/1\n2016-08-31T23:57:17.281632+00:00 app[web.1]:         lib/guardian/plug.ex:118: Guardian.Plug.sign_in/4\n. ",
    "vheathen": "@hasson, thanks a lot for the answer!\n\nWhen you use the ttl function you're effectively asking for '30 minutes after the issue time'.\n\nYes, you are absolutelly correct. But if you check result token fields you find that token's TTL is default 3 days and not 30 minutes as I believe it supposed to be:\n1464026216 - 1463767016 = 259200 / 60 / 60 / 24 = 3 (days)\nEven in the following case TTL doesn't change:\nelixir\niex(21)> Guardian.encode_and_sign(device, :token, %{\"exp\" => 1100, \"iat\" => 1000})            \n{:ok,\n \"eyJ...<skipped>...1Tg\",\n %{\"aud\" => \"Device:db749ee8-1e9f-11e6-9d47-4b5e65de4b92\", \"exp\" => 260200,\n   \"iat\" => 1000, \"iss\" => \"App\",\n   \"jti\" => \"c1e911ce-732f-467f-b569-97f5e26be066\", \"pem\" => %{},\n   \"sub\" => \"Device:db749ee8-1e9f-11e6-9d47-4b5e65de4b92\", \"typ\" => \"token\"}}\nToken's time fields:  %{ ... \"exp\" => 260200, \"iat\" => 1000 ... }\nStill default 3 days from Guardian config.\nThanks!\n. Thank you very much! I just saw an example in Readme\nelixir\nclaims = Guardian.Claims.app_claims\n         |> Map.put(\"some_claim\", some_value)\n         |> Guardian.Claims.ttl({3, :days})\nand tried to do the same, but it doesn't work (in the TTL part). I also tried to set exp manually, but also without success. I believe that this doesn't work because as I can see claims = Guardian.Claims.ttl(claims, {3, :days}) is doing the same - changing exp and iat according to ttl map.\nThe way with adding :ttl key/value directly to the claims map works!\nAnyway, thank you very much for your help! I'm a newbee in the Elixir world so my tries to dig into the sources hadn't given me a lot about this topic yet. :)\n. It works with\nelixir\nclaims = Guardian.Claims.app_claims\n         |> Map.put(:ttl, {5, :days})\n{:ok, jwt, _} = Guardian.encode_and_sign(resource, :token, claims)\nSo may be as a temporary workaround it's possible to put ttl key\\value to the claims map on Guardian.Claims.ttl(ttl) in addition to iat and exp (which I'm using at the moment to not reinvent exp time calculation)?\nUpdate\nActually, it's not a problem to use Map.put() but looks a little ugly.\n. ",
    "nubunto": "Sorry.\nActually what I meant was how to show a page to everyone who isn't authenticated.\nBut I managed to solve it anyway.\nThanks and sorry again!\n. ",
    "dustinfarris": "Is this actually used anywhere?\n. ",
    "Gacnt": "My mistake, didn't realize Ueberauth was a separate entity, thought it was all under Guardian. Opened issue over there.\n. ",
    "milmazz": "@doomspork No, I'm referring to Elixir 1.4.0-dev, which right now points to the master branch.\n. @doomspork At least for me is annoying to see all those warnings when I use Guardian as a dependency. Also, at some point, we'll need to take care of these issues. Why not take care of this sooner than later?\n. @doomspork @hassox With the latest changes I think we fix all warnings. Also, we keep compatibility with older Elixir versions. Please let me know what do you think.\n. @hassox Any feedback about this?\n. @doomspork Right now I don't have access to the machine where I did the changes, but, if I recall well mix compile was failing because there is a dependency in guardian/phoenix/socket.ex that requires Phoenix.Socket.assign/3. wdyt?\n. ",
    "slashmili": "Are you going bump the version in hex? \ud83d\ude2c \nBTW can you also update credo? They fixed the warnings in 0.4.5\nThanks!\n. ",
    "ylankgz": "Tests failing with erlang 17\n. ",
    "nimish-mehta": "@doomspork #169 seems to fix the issues. Can we close the PR ?\n. ",
    "sanrodari": "Effectively @doomspork! \ud83d\ude03 \nmix.exs\nelixir\n...\n{:guardian, github: \"nimish-mehta/guardian\", ref: \"fix-assign-exp\"},\n...\niex\nelixir\nclaims = Guardian.Claims.app_claims |> Map.put(\"iat\", nil)\nGuardian.encode_and_sign(account, :token, claims)\n{:ok,\n \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJBY2NvdW50OjEiLCJleHAiOjI0NjgwMTUwODUsImlhdCI6bnVsbCwiaXNzIjoiUG90aW9uIiwianRpIjoiZWIyYmMzNDEtNDI0Mi00N2MxLTk5OTQtNDQ0N2I4ZDQ2NjBiIiwicGVtIjp7fSwic3ViIjoiQWNjb3VudDoxIiwidHlwIjoidG9rZW4ifQ.j-kGU82tmoG9HyaLToNUWVb-ER8IvtsOeiIV_2eBFy70mYosCTz1vp7Xb3b4Z5CRum5m7vyvwN--oFOdU82LTA\",\n %{\"aud\" => \"Account:1\", \"exp\" => 2468015085, \"iat\" => nil, \"iss\" => \"Potion\",\n   \"jti\" => \"eb2bc341-4242-47c1-9994-4447b8d4660b\", \"pem\" => %{},\n   \"sub\" => \"Account:1\", \"typ\" => \"token\"}}\n. ",
    "joshsmith": "\ud83d\udc4d \n. ",
    "christiansakai": "@doomspork not really, I figured out how to use Guardian with just printing out stuff to inspect. In terms of whether the erlang debugger still not able to inspect Guardian, yes.\n. ",
    "AlejandroHuerta": "This took me a while to figure out myself but you can write it this way:\nplug Guardian.Plug.EnsureAuthenticated, [handler: MyApp.SessionController] when not action in [:create, :new]\n. I should also add that what I posted works right now. @doomspork \n. I'd just like to mention that if you all decide to implement the :except it would be reasonable to also allow :only. This would be similar to how phoenix does it.\n. ",
    "hopewise": "Writing in this way:\nplug Guardian.Plug.EnsureAuthenticated, [handler: MyApp.SessionController] when not action in [:create, :new]\n\nI got error:\n== Compilation error on file web/router.ex ==\n** (CompileError) web/router.ex:16: undefined function when/2\n    (elixir) expanding macro: Kernel.@/1\n    web/router.ex:16: Trackware.Router (module)\n    (elixir) expanding macro: Kernel.if/2\n    web/router.ex:16: Trackware.Router (module)\n    (phoenix) expanding macro: Phoenix.Router.plug/2\n    web/router.ex:16: Trackware.Router (module)\n    (phoenix) expanding macro: Phoenix.Router.pipeline/2\n    web/router.ex:12: Trackware.Router (module)\n    (elixir) lib/kernel/parallel_compiler.ex:117: anonymous fn/4 in Kernel.ParallelCompiler.spawn_compilers/1\n. In my case, it's not an umbrella app, but one app with multiple endpoints.\nHow would I have multiple configurations for Guardian in one app?. I tried shortening it to 2 months, I still get Unauthenticated error.\nThen, I found that the issuer in settings does not match the issuer in token! So, that was the problem, and I have fixed it, thanks.. ",
    "anildigital": "\ud83d\udc4d . It was my bad.. I had duplicate router where I was not piping through plug filter.. ",
    "lATAl": "hi @doomspork, I don't see any update on this issue. Do I miss something?. ",
    "sntran": "I think I figure it out. Guardian does use the secret key in config to verify. Closing this.\n. ",
    "douglascorrea": "@doomspork sorry about late answer I will setup a project to reproduce and ping you here.\n. Hi @doomspork sorry, I really forgot this. Please go ahead and close it, as soon I get time to create a project to reproduce it I ping this issue and we re-open it if necessary.. ",
    "raarts": "Please disregard. Problem was between chair and keyboard.\n. ",
    "peuh": "I can give it a try but I'm afraid I won't have time before the end of next week. Also, I've only been using elixir for a month, so my PR might be a bit rough around the edge and need some polishing. Would it work for you?\n. ",
    "SLOBYYYY": "I have the same issue. IMO this issue is related to release task than to guardian since release creates the sys.config file and therefore fails (due to negligence or on purpose) to evaluate the function in config.exs.\nI was trying it with exrm, did not have time to take a shot at https://github.com/bitwalker/distillery (this is the official successor of exrm)\nWhat plugin do you use for release? \nEDIT: Tried it with distillery, same error.\n. As you can see I did. You can close this since it comes up with all anonymous functions when you use a release plugin (exrm or distillery)\n. ",
    "adsteel": "Derp. Still learning to read the messages. This is not a bug it seems.\n. This part of the error message was where the issue was:\n** (RuntimeError) Guardian is not configured\n    lib/guardian.ex:26: (module)\nI configured Guardian according to the docs and everything worked fine.. ",
    "Faolain": "how did you solve this?. ",
    "Angarsk8": "I'm experiencing the same issue and I'm sure I configured Guardian according to the docs. This is happening after running mix docker.build to build a docker image using the mix_docker package.\nThis is the error I'm getting:\n```\n== Compilation error on file lib/guardian.ex ==\n** (RuntimeError) Guardian is not configured\n    lib/guardian.ex:26: (module)\n    (stdlib) erl_eval.erl:670: :erl_eval.do_apply/6\ncould not compile dependency :guardian, \"mix compile\" failed. You can recompile this dependency with \"mix deps\n.compile guardian\", update it with \"mix deps.update guardian\" or clean it with \"mix deps.clean guardian\"\nThe command '/bin/sh -c mix do deps.get, deps.compile' returned a non-zero code: 1\n** (MatchError) no match of right hand side value: {%IO.Stream{device: :standard_io, line_or_bytes: :line, raw\n: false}, 1}\n    lib/mix_docker.ex:153: MixDocker.system!/2\n    lib/mix_docker.ex:123: MixDocker.with_dockerfile/2\n    lib/mix_docker.ex:18: MixDocker.build/1\n    (mix) lib/mix/task.ex:300: Mix.Task.run_task/3\n    (mix) lib/mix/cli.ex:58: Mix.CLI.run_task/2\n```\nDoes anyone has experienced this problem using mix_docker for building docker images and generating releases?\nThanks,. ",
    "keithalpichi": "@hollow What does your session controller look like? Mind posting it?\n. @qgadrian I usually set the realm to \"Bearer\" like so: plug Guardian.Plug.VerifyHeader, realm: \"Bearer\".\nHow are you testing your controllers and sending requests? Are you sending valid JWT tokens through the \"authorization\" header?\n@GildedHonour you can create a current_user helper function in a module then import it in the web/web.ex file under the view function like so:\n```\n  def view do\n    quote do\n  #...\n\n  import YourApp.Router.Helpers\n  import YourApp.ErrorHelpers\n  import YourApp.Gettext\n  import YourApp.YourViewHelpers #<-------------------------------------- HERE\n\nend\n```\nThat way the helper functions are imported in all views. In that helper module you can define helper functions like so:\n```\n  def current_user(conn) do\n    Guardian.Plug.current_resource(conn)\n  end\ndef logged_in?(conn) do\n    Guardian.Plug.authenticated?(conn)\n  end\n```\nWhere in a view you'd access the resources like so current_user(@conn) and logged_in?(@conn).\n. You're passing exp as an integer and not a string. \nFix it from this:\nPlug.Conn.put_resp_header(new_conn,\"x-expires\", exp)\nto this:\nPlug.Conn.put_resp_header(new_conn, \"x-expires\", \"#{exp}\")\nI'd also recommend to take advantage of the pipe operator like so:\nnew_conn\n  |> put_status(200)\n  |> put_resp_header(\"authorization\", \"Bearer #{jwt}\")\n  |> put_resp_header(\"x-expires\", \"#{exp}\")\n  |> render(\"loggedIn.json\", %{user: user, jwt: jwt, exp: exp})\nI'm sure this this function is in a controller and is __using__ the :controller behavior. So you don't have to prefix put_resp_header with Plug.Conn as it's already imported. So just using put_resp_header will do like the example I gave above.\n. @kevin-DL you're welcome. I agree with you. Hopefully the authors of the article see this issue and fix it. \n. ",
    "hollow": "@keithalpichi the controller is just a copy of https://gist.github.com/mike-north/efb910d4eca4909fe0dcbc054bc6043e#file-session_controller-ex with Peepchat replaced by Api. the stack trace above does not match 100% since I've played aroun with using api_sign_in and other methods, but the error is always the same in jose_jwk.\nFWIW I've switched to auth0 and Joken for verification meanwhile ...\n. ",
    "AbdullahDahmash": "I had this problem I believe you followed the tutorial like this\nelixir\nconfig :guardian, Guardian,\n  allowed_algos: [\"HS512\"], # optional\n  verify_module: Guardian.JWT,  # optional\n  issuer: \"Peepchat\",\n  ttl: { 30, :days },\n  verify_issuer: true, # optional\n  secret_key: System.get_env(\"GUARDIAN_SECRET\") || \"anUG...A4qfP5\",\n  serializer: Peepchat.GuardianSerializer\nI don't know why but this is producing some problems.\nYou need to separate it. In dev.exs and test.exs, type the dev secret key as following\nelixir\nconfig :guardian, Guardian,\n  allowed_algos: [\"HS512\"], # optional\n  verify_module: Guardian.JWT,  # optional\n  issuer: \"Peepchat\",\n  ttl: { 30, :days },\n  verify_issuer: true, # optional\n  secret_key: \"anUG...A4qfP5\",\n  serializer: Peepchat.GuardianSerializer\nin prod.exs, use the system environment \nelixir\nconfig :guardian, Guardian,\n  allowed_algos: [\"HS512\"], # optional\n  verify_module: Guardian.JWT,  # optional\n  issuer: \"Peepchat\",\n  ttl: { 30, :days },\n  verify_issuer: true, # optional\n  secret_key: System.get_env(\"GUARDIAN_SECRET\"),\n  serializer: Peepchat.GuardianSerializer\n. ",
    "migore": "O just found this, it helped me. Hope it helps.\nhttps://hexdocs.pm/guardian/Guardian.Plug.html#authenticated?/1\n. ",
    "GildedHonour": "Thanks. It doesn't support  password recovering, email confirmations, locking users and so on?\n. @doomspork what do you recommend to use as alternive of devise gem from Rails?\n. Thanks.\n. I want to create a helper method \"current_user\" and be able to use it in all templates, much like in Devise in Rails. There's a function \"guardianplugensureauthenticated\" Could anyone give me a pointer how to utilize it for that? There's no base controller in Phoenix where I can define current_user by calling \"guardianplugensureauthenticated\"\n. @qgadrian that would work. But I also want to do that on a module level. Suppose, I want to restrict access to the whole controller UserDashboard for non authenticated users. It can be done via router.ex file? \nAlso I want to use \"current_user\" helper function in the main layout for which I'll need to create it somehow in a SharedView or LayoutView. How can I get access to user and claims from a View?\n. Yes.\n. ",
    "qgadrian": "I could make it work adding the realm to the plug in the router.ex\nplug Guardian.Plug.VerifyHeader, realm: \"TestApp\"\nWithout explicitly declaring the realm, it just didn't work at all.\n. @hassox Using the realm name it works fine. I'll check why without declaring a real it just don't work (maybe there is a default real name?).\n@GildedHonour you can use at your controller methods the current user and the claims for an authenticated session. Check the readme, there you can see that you can use this\ndef index(conn, params, user, claims) do\n    # do stuff in here\n  end\n. @GildedHonour You can use the plug Guardian.Plug.EnsureAuthenticated in your router.ex or in a controller, that's up to you.\nI don\u00b4t know anything about views yet, I just started learning Elixir/Phoenix 5 days ago. You can ask at Stackoverflow that.\n. ",
    "mjsisley": "Nevermind...\nIt looks like decode_and_verify takes a Params map where the Secret Key can be passed so a Secret Key can be specified outside of Config. Didn't see this in any of the examples, should have looked at the source code first.\n. ",
    "kevin-DL": "@keithalpichi Thank you that fixed it.\nIt might be necessary to update the blog post though  i am probably the only one who would not notice.\nClosing the issue\n. It works for me.\nhttps://github.com/kevin-DL/phoenix_vue_template\n. ",
    "charleshan": "I'll move this over to https://github.com/hassox/phoenix_guardian\n. #182 duplicate.\n. It was my configuration. I was missing hooks: GuardianDb\n. I was missing max_age in the endpoint...\nplug Plug.Session,\n  store: :cookie,\n  key: \"xxxx\",\n  signing_salt: \"xxx\",\n  max_age: 36000\n. ",
    "denisw": "This seems to have been fixed by commit bfb31b4695383b883746a457f0bfead354c3f9c1. I am going to close the issue.\n. ",
    "aaronjensen": "@doomspork I had only updated in the mix.Iock. I updated it in the mix.exs as well and bumped phoenix.\n. @doomspork sure thing, how's that?\n. It looks like Elixir 1.2.5 and OTP 19 don't work well together. Want me to remove the old elixir? I think there's a travis syntax for more specific matrixing but I don't know it off the top of my head.\n. I added elixir 1.2 in there as well, let's see how it goes.\n. Sounds good, updated.\n. ",
    "whitepaperclip": "Never mind! Anyone else who encounters this:\n@primary_key {:id, :binary_id, []} should go on top of\nschema \"users\" do\n. ",
    "manuelsteiner": "Thank you for the comment :)\n. Oh ok, thank you :) Will do it that way\n. ",
    "nmqanh": "@mitkins I guess the code could be like this:\n``` elixir\ndefmodule MyApp.Plug.RememberMe do\n  import Plug.Conn\n  import Guardian.Plug\ndef init(opts \\ %{}), do: Enum.into(opts, %{})\ndef call(conn, _) do\n    current_user = current_resource(conn)\nif ( current_user == nil ) do\n  jwt = conn.req_cookies[\"remember_me\"]\n  case Guardian.decode_and_verify(jwt) do\n    { :ok, claims } ->\n      the_key = Map.get(claims, :key, :default)\n      put_session(conn, Guardian.Keys.base_key(the_key), jwt)\n  end\nend\n\nend\nend\n```\nAnd in your pipeline, put your MyApp.Plug.RememberMe before VerifySession\nPlease try and see how it works \ud83d\udc4d \n. ",
    "mitkins": "Thanks @hassox. The above code works. The \"typ\" parameter in decode_and_verify just needed to be a map. @nmqanh based on @hassox's advice, I tried his solution first - thanks for taking the time though.\n. So I could create an AuthErrorController like @oskar1233 suggests and set that in my controller (as pointed out by @hassox) while still having Zoinks.Guardian.AuthErrorHandler as the global handler?. Cool. Thanks!. After doing some digging, I found out the following additional information:\n\nWith the default configuration Guardian.Plug.VerifyCookie expects to find the refresh token in a cookie called \"guardian_default_token\". So it doesn't end up finding it in the cookie it was put in (\"default\")\nIn the case that the refresh token is no longer valid, the error handler is executed and halt() is called. This prevents the pipeline from continuing and the Guardian.Plug.EnsureAuthenticated plug is never called\n\nIn the auth_error call, I redirect to my login page - but only for :unauthenticated. Redirecting for another type/reason (in addition to :unauthenticated) ends up causing a circular redirect loop. So I think it would be nice (in the case of Guardian.Plug.VerifyCookie) if it didn't consider :token_expired to be an error.\nI made a copy of Guardian.Plug.VerifyCookie and tested this theory by added the following match in the else part of the with clause:\n``` elixir\nelse\n  :no_token_found ->\n    conn\n{:error, :token_expired} ->\n    conn\n{:error, reason} ->\n    conn\n    |> Pipeline.fetch_error_handler!(opts)\n    |> apply(:auth_error, [conn, {:invalid_token, reason}, opts])\n    |> halt()\n_ ->\n    conn\nend\n```\nWhen the refresh token expires, my redirect now works as expected. The other thing that I just noticed, is that the cookie does not have a lifespan and is not persistent over browser sessions. I say pull it out, release 1.0, then give it the treatment it deserves. I'm happy to workaround for now.. I've been giving it the same lifespan as the ttl for the refresh token. I think this applies to the latter part of #504. Looking at VerifyCookie @Hanspagh opted to include the following code:\n``` Elixir\ndef call(conn, opts) do\n  with ...\n  else\n    :no_token_found ->\n      conn\n# Let the ensure_authenticated plug handle the token expired later in the pipeline\n{:error, :token_expired} ->\n  conn\n\n{:error, reason} ->\n  conn\n  |> Pipeline.fetch_error_handler!(opts)\n  |> apply(:auth_error, [conn, {:invalid_token, reason}, opts])\n  |> halt()\n\n_ ->\n  conn\n\nend\nend\n```\nIn the case of :token_expired, calling the error handler is optional - depending on whether EnsureAuthenticated is in the pipeline.\nI've made a copy of the VerifySession plug and added the {:error, :token_expired} match. So far it seems to be doing what I expect.. I can definitely see that point of view (in terms of not allowing the pipeline to continue when the token is not valid and the fact that this would introduce a breaking change). Though I quite like the idea that the EnsureAuthenticated plug is where the error is actually raised, to me it's an intuitive way of saying \"this page must be protected\".\nI'm assuming that the alternative is to create my own plug with the desired behaviour. If this is the case, then maybe it's just a matter of mentioning the scenario in the documentation somewhere (e.g. https://github.com/ueberauth/guardian/blob/master/guides/plug/pipelines.md#good-practices). It's a little bit of a gotcha for an inexperienced elixir/web developer like me.\nNow that I think about it, how does the refresh token mechanism work? If a session token expires, doesn't it just throw the :invalid_token error (and break the pipeline before VerifyCookie is called)?\n. I suspect that there isn't either. I realised what I'm after is a best practice. That is, in the case where:\n\nA page does not require authentication; and\nI would like to conditionally show user info (if it's available); and\nThe token has expired; and\nI don't want to disrupt the page from loading\n\nWhat's the best practice? Any advice is appreciated, but if you would like me to close the issue, then I'm happy to.. ",
    "ckruse": "So, how do I set a remember_me cookie with this code?. Nevermind, got it working, thanks :). ",
    "enilsen16": "I might be wrong but I think the idea is to use the token from auth0, rather than have guardian create it. Either way I am interested in this as well. \nRight now I verify a correct response from auth0 and then have guardian create a separate token.\nI added Auth0 login to the phoenix_guardian repo as an example. https://github.com/enilsen16/phoenix_guardian/tree/auth0\n. @alduro are you using @sntran's uberauth_auth0 package?\n. Here's the repo for the package: https://github.com/sntran/ueberauth_auth0\nThe last two commits in my auth0 branch here are adding it to phoenix guardian.\n. I am using both(uberauth/guardian) and it seems to work just fine...\n. Looks like I may have configured this incorrectly. \ud83d\ude48\n. ",
    "vic": "Yep I know, just was used to having nicely clean builds, but now with elixir 1.4 almost any dep I have has some warning (regarding the ()) hopefully some day I'll have my eyes clean of warnings. :D cheers !. ",
    "michalmuskala": "The failure seems to be cause by credo bug, that refuses to accept code such as:\nelixir\nfoo() |> bar()\nThe update of credo fixes the issue according to my tests.\n. @hassox yes, travis errors, because credo doesn't like that line https://github.com/ueberauth/guardian/pull/220/files#diff-98bc41bc6745bf48898940055a7dfb7aR276\nIt looks like a bug, in the credo version that guardian currently uses. Upgrading it fixes this.\n. @doomspork updated\nThe new credo complained about the numerals, so I changed them too.\n. Have you considered a more functional approach for things like Guardian.Phoenix.Channel? This means that instead of having a macro inject a function and export an OO-like function-callback to override, a regular function for the user to call would be provided. \nWhat if instead of having a single \"magical\" use Guardian.Phoenix.Channel, module: MyApp.Guardian a user could call in their join function, MyApp.Guardian.channel_join/3? Immediately we gain a very easy way to follow what is going on and to debug in case of errors. Injecting huge functions through use means the stacktraces will be poor and all pointing to the line where use was called. Additionally, the function is exactly the same as the user defined join/3 and only pattern matches on the arguments - reasoning about this is going to be very hard. It took me quite some time to understand what this code is actually doing. It's also quite hard to properly document functions that are injected through macros like this.\nA similar approach could be employed in more \"magic callback\" situations.. According to the documentation of the Version module, the requirement ~> 1.0 is exactly the same as >= 2.0.0 and < 3.0.0. So ~> 1.0 or >= 1.2.0 is effectively exactly the same as ~> 1.0 alone.. Shouldn't erroneous implementation raise?. ",
    "Philpax": "FYI, I just spent some time wracking my head over why the example in the repo's readme (i.e. the tuple format) wouldn't work. As I'm using the latest available public release (i.e. not master), I discovered I had to use the old anonymous function syntax (i.e. secret_key: fn -> keyGenerationHere end).\nTo this end, I suggest adding a note to the readme about this change and removing it when it's time for a new release; might prevent others from getting stuck in the quagmire that I did \ud83d\ude05 . ",
    "Dtatoo": "The project is still under active development and marked as private. However I did create a copy and pasted version of controller and test I am using uploaded to Gist.\nhttps://gist.github.com/Dtatoo/6d58933681a790bad43d5adbe8c76309\nLet me know for whatever reason you would like to view the whole project. I am using basic Phoenix stack setup.\n. ",
    "proProbe": "this came suddenly quite urgent. anyone who knows a solution to this?. I solved this. Error from my side. ",
    "marinho10": "@proProbe can you share your error ? I'm having the same issue.. ",
    "bobbypriambodo": "Thank you for the answer, @doomspork. You are right that JWT will be more cross-platform compatible than Phoenix.Token, but sometimes (like in my use case) we only need basic token signing and verifying mechanisms without extra deps, and Phoenix.Token fits the bill nicely. I was wondering if all the niceties of Guardian (VerifyHeader, EnsureAuthenticated, etc.) will work with it. I end up writing my own library for it (mostly for my learning too).\nThanks again, by the way! I'm closing this if you don't mind.. ",
    "secretworry": "@doomspork My fault. Removed an underscore by mistake. It works now:). @doomspork :). ",
    "ericsullivan": "Thank you :). That makes a lot of sense. As I was implementing this I noticed areas of uncertainty, where I felt I was making an arbitrary decision. For instance, why not run all hooks and return a list of errors. I think it might be easier to discuss the use cases I was working on that lead me here. I posted two more issues, but my guess is the discussion here will close them.\nI'm building a new application and I need some features that exist in devise:\nTimeoutable: I was going to hook into after_sign_in to set a last_accessed_at key in the session and a plug that would clear the claims if it was expired otherwise update the last_access_at key.\nConfirmable/Approvable: Hook into encode_and_sign and return an error, and a plug that'd call the error handler if they're not confirmed/approved.\nI'm guessing you're going to suggest I create my own wrapper around Guardian.Plug.sign_in, but I wanted to verify that :) I was hoping guardian (through its hooks) could provide a standard interface to build on in the same way that Devise provides active_for_authentication, inactive_message, and such. With this multihook module, other extensions could include instruction like, \"add it to the hooks list\" and you'd be done. Without the glue it'll be up to a developer (or another mix project) to wire them together. I do think thats a better approach though. I'll get started on it :). I put additional updates to the typespec in a different PR because dialyzer failed without this change, but wasn't complaining about the other code. Should \"mix dialyzer\" be added to travis.yml?\nI think after_sign_in does return a conn. The default hook implementation returns conn and the api_sign_in also has a method signature that returns conn.\n  . https://github.com/ueberauth/guardian/pull/256 actually included this fix. Since that was merged first this is no longer needed.. I added {:error, any}. Then for the methods that returned the results of calling the hooks I updated them. Then some methods that called them... I'm not confident I got them all, but dialyzer passed. This seems like a larger change than I intended. Would it be best to fix the original issue in this PR, then open another one to support any?. I kind of figured it might be too different, thanks again for taking a look.. Ok, thanks for taking a look. I figured Guardian wasn't the place for it but I wanted to check before creating another authentication solution. Sure, I was just trying to get the variables to align like in the below case:\n```\ndef authenticated?(conn, type) do\n   case claims(conn, type) do\n...\ndef claims(conn, the_key \\ :default) do\n```\ntype is actually a key. Similarly the spec said \ntest \"encode_and_sign(object, aud) with ttl\" do\nbut the method is\ndef encode_and_sign(object, type), do: encode_and_sign(object, type, %{})\nIt makes sense it won't be helpful if you're refactoring though. Thanks again for reviewing these PRs today.\n. ",
    "mariusbutuc": "0.13.1 is the one currently declared, but there is no tag/release for it. \nIf #222 is the working fix for #221, releasing 0.13.1 would be amazing! \ud83d\ude38 \nThanks @hassox, @doomspork, @scrogson & Co. \u270c\ufe0f . With v0.14.0 released, we might be good to close this.. ",
    "yuchunc": "Apologies if I didn't do the pull request right, I am not familiar to the proper way of contributing to a project. \nPlease let me know if I'm missing anything, I will patch it.. #242 . I would suggest you rolling back to an earlier version of Guardian. Since I am not the maintainer, I have no ETA on when this might get merged.\nAlso, if you are just trying to run development, you could just go into /deps change Guardian's code, then removed the Guardian directory under /_build. It will recompile your change, this was how I was sure this was a library issue.\nHope that helps. :). ",
    "collegeimprovements": "Hi, I got this error even after the upgrade. I got the same error with 0.14.1.. I'm getting the same error with the new version also.. ",
    "larryweya": "Same issue as @collegeimprovements after upgrade to 0.14.1. Found the issue and opened a pull request #250. @doomspork works for me too.. ",
    "Ch4s3": "@doomspork I was having the same problem and using {:guardian, github: \"ueberauth/guardian\"} fixes it for me.\nIs this the fix?. Can confirm, 0.14.2 works. ",
    "jacktang": "I am facing the same problem and 0.14.2 works fine. ",
    "faywong": "This issue has blocked me(freshman to elixir) for two days before i almost give up the guardian db solution.\nAnyway, thanks for google & all your efforts. \nWhen will the next release will be published so as this bugfix will be included?. ",
    "geofflane": "+1 Seeing this as well.. ",
    "blatyo": "Could you also retire this version or release a new version? Right now, if you don't fix the version to 0.14.0, you'll hit the issue.\nhttps://hex.pm/docs/tasks#hex_retire. ",
    "smoes": "Oh actually we have not!\nLooks good, thank you for the advice @doomspork . We will have a look at it, but at a first glance it seems to be exactly what we needed!. ",
    "hykw": "The warning I pasted was run in Erlang 18.2.1\nIn an Erlang 19.2/Elixir 1.3.4 environment, the warning differed like below\nweb/controllers/page_controller.ex:4: Function index/2 has no local return\nweb/controllers/page_controller.ex:14: The call 'Elixir.Guardian.Plug':sign_in(conn@1::#{'__struct__':='Elixir.Plug.Conn', 'adapter':={atom(),_}, 'assigns':=#{atom()=>_}, 'before_send':=[fun((#{'__struct__':='Elixir.Plug.Conn', 'adapter':={_,_}, 'assigns':=map(), 'before_send':=[fun((_) -> any())], _=>_}) -> #{'__struct__':='Elixir.Plug.Conn', 'adapter':={_,_}, 'assigns':=map(), 'before_send':=[fun((_) -> any())], _=>_})], 'body_params':=#{'__struct__'=>'Elixir.Plug.Conn.Unfetched', 'aspect'=>atom(), binary()=>binary() | [binary() | [any()] | #{binary()=>_}] | #{binary()=>binary() | [any()] | #{binary()=>_}}}, 'cookies':=#{'__struct__'=>'Elixir.Plug.Conn.Unfetched', 'aspect'=>atom(), binary()=>binary()}, 'halted':=_, 'host':=binary(), 'method':=binary(), 'owner':=pid(), 'params':=#{'__struct__'=>'Elixir.Plug.Conn.Unfetched', 'aspect'=>atom(), binary()=>binary() | [binary() | [any()] | #{binary()=>_}] | #{binary()=>binary() | [any()] | #{binary()=>_}}}, 'path_info':=[binary()], 'path_params':=#{binary()=>binary() | [binary() | [any()] | #{binary()=>_}] | #{binary()=>binary() | [any()] | #{binary()=>_}}}, 'peer':={{byte(),byte(),byte(),byte()} | {char(),char(),char(),char(),char(),char(),char(),char()},char()}, 'port':=char(), 'private':=#{atom()=>_}, 'query_params':=#{'__struct__'=>'Elixir.Plug.Conn.Unfetched', 'aspect'=>atom(), binary()=>binary() | [binary() | [any()] | #{binary()=>_}] | #{binary()=>binary() | [any()] | #{binary()=>_}}}, 'query_string':=binary(), 'remote_ip':={byte(),byte(),byte(),byte()} | {char(),char(),char(),char(),char(),char(),char(),char()}, 'req_cookies':=#{'__struct__'=>'Elixir.Plug.Conn.Unfetched', 'aspect'=>atom(), binary()=>binary()}, 'req_headers':=[{binary(),binary()}], 'request_path':=binary(), 'resp_body':='nil' | binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | []), 'resp_cookies':=#{binary()=>#{}}, 'resp_headers':=[{binary(),binary()}], 'scheme':='http' | 'https', 'script_name':=[binary()], 'secret_key_base':='nil' | binary(), 'state':='chunked' | 'file' | 'sent' | 'set' | 'unset', 'status':='nil' | non_neg_integer()},user@1::#{'__struct__':='Elixir.Specimen.User', 'id':=1},'token',[]) breaks the contract ('Elixir.Plug.Conn':t(),any(),atom() | 'Elixir.String':t(),map()) -> 'Elixir.Plug.Conn':t()\nI tried it with Elixir 1.4.0, but so was it, the same warning.\n. ",
    "asummers": "This is now closed after having #256 merged into master \ud83d\udc4d . Thank you for addressing my issue @ericsullivan! . Thinking about this for a bit, even if Guardian only supports atom, it should probably allow any. If you're trying to use a hook to return some custom error, say an Error struct, having this be any would allow the most future flexibility. . I don't see any value in splitting that work, personally. Those changes are all of the \"boring\" variety, so it's unlikely to break something. I think it looks great as is :). The {:error, reason} bubbles up because it doesn't match the with, but I can match it explicitly in a with/do/else since the compilation target is 1.3.\nwith {:ok, claims} <- decode_token(jwt, secret),\n     {:ok, verified_claims} <- verify_claims(claims, params),\n     {:ok, {claims, _}} <- Guardian.hooks_module.on_verify(verified_claims, jwt) do\n  {:ok, claims}\nelse\n  {:error, reason} -> {:error, reason}\nend. I would also say I anticipate there being a few more behaviours that exist that are currently not concrete, so I'm not sure if there should be some folder naming with that thought in mind (e.g. the likely suboptimal subfolder name of /behaviours/). . Re: discussion from offline, the discussion was to add a toggle between Poison and Jason.... But taking a look through the code, this is all just a test dependency, so there's absolutely no reason to add that =) Instead, removing Jason AND Poison from runtime dependencies is the way to go here. \n{:jason, \"~> 1.1\", only: [:dev, :test], runtume: [:false]},. Just a quick bump on these and my other open ones, seeing if there's anything preventing them from bring merged. . Had to change the cache slightly. Now it's super fast.  11-13m down to 1.5m. . I have a branch locally branched off this that bumps Credo and fixes the issues, so I can open that pursuant to this being merged. . Note that simply re-adding implementation() does not work for some reason. There's a deeper issue here somewhere. . I did some minor debugging into this. You can get it working if any of: \n1) available_permissions type relaxed to map\n2) available_permissions type inlined to %{optional(atom) => [atom]}\n3) available_permissions spec removed\n4) Call to  Guardian.Permissions.Bitwise.available_from_normalized(@normalized_perms) inlined into available_permissions.\nThese all have pretty self evident flaws. \nAdding | [atom] to the type of permission_set did not work as expected.  I'm very confused why this is failing. . Done.. This is a local dependency, which would not be published in consumer mix.lock files.  Anyone who includes guardian in their mix.exs would not see reference to it at any point. . Hex is smart enough! \nFor example I require rc3 in erlex here\nand hex accepts 0.1.6 as the version without issue. . Seems like Credo is upset about nested modules in about 10 spots. I can ignore that warning in those places, I can fix, or we can do that in a separate PR. Up to you. . Fine by me. I'll rebase this and get it up to date with master then I think this should be good to go!. ",
    "zachdaniel": ":+1:. ",
    "lukerollans": "That's fantastic news. I solved the above by moving everything to the one app which is less than perfectly ideal, but it's also OK.\nLooking forward to refactoring once 1.0 hits \ud83d\udc4d . ",
    "kuffel": "I had a similiar issue. It can be solved by updating your umbrella configuration files in this way:\nFor example you have an umbrella app with two websites using guardian and other apps that are being used by them, e.g.\nwebsite_a (using guardian)\nwebsite_b (using guardian)\ncommon_app_a\ncommon_app_b\nIn config.exs of your umbrella, remove this line:\nimport_config \"../apps/*/config/config.exs\"\n\nAnd replace with these\nimport_config \"../apps/common_app_a/config/config.exs\"\nimport_config \"../apps/common_app_b/config/config.exs\"\n\nNow change the mix files of the to website apps to just import their own configs:\nconfig_path: \"config/config.exs\"\n\nThen in the config.exs of the two website apps add this line \nimport_config \"../../../config/config.exs\"\n\nIt would be much easier if guardian would try to figure out in which module it is being used. Application.get_all_env :guardian returns a list with two guardian configurations, so i think it should be possible to pick the correct config.\n. ",
    "odarriba": "Hi!\nI've been with this issue (I'm developing an umbrella app with multiple Endpoints that use Guardian in a different way).\nWhat do you think about making some parts of the Guardian lib (the ones that read and directly use the config) as part of a macro, (which can read the config using a parameter and MODULE, as Ecto does).\nThen it can be used in a module like:\nelixir\ndefmodule WadusApp.Guardian do\n  use Guardian, otp_app: :wadus_app\nend\nand call that class from plugs by passing it as parameters, execute things like WadusApp.Guardian.sign_in(conn, object) , etc.\nWhat do you think about that point of view to solve this?. any ETA? so you accept PR in case I can dedicate some time to this?. Any updates on this?. Thanks for the update @hassox !\nLooking forward to see the RC and start using it for our multi-app umbrella project \ud83d\ude04 . Just created a PR #293 about this.. hey!\nThere is support for it on 1.4.5 and 1.5.0-rc0 (which I don't know if are being tested).\nAlso, I think it should work pretty well with 1.4 versions for most software \ud83e\udd14 . I'm not sure where this approach come from, so maybe what I'm going to propose doesn't fit for the needs.\nIf it's only purpose is testing, what about just creating a test helper to add the session needed for authentication? I've seen this pattern before in other libs and seems less intrusive (you don't have to include a if in your plug pipeline) and you authenticate the user clearly in the test.\nWhat do you think about it?\nPS. You are doing a great job in this release mates!. If there is protection against using it in prod environments, I don't see any issues then!. Good one! PR Updated. ",
    "artukrap": "@hassox I am using postgres and your package. What you mean throw away? For example, when I revoke token, I am able still use it and access system.. @hassox For now I have postgres database. So it means, this package https://github.com/ueberauth/guardian_db goes on top of all that and then I will be able to revoke normaly tokens?. @hassox Yes, not revoke works as expected.. @asummers Agree with you and would love to see this functionality. @Moxide Yes, it's same. I guess here we talk more about convention and helper function.. ",
    "egeersoz": "@hassox Sorry to comment on a closed issue, but regarding your response on Jan 18th, did I understand it correctly, i.e. in vanilla Guardian, calling revoke! doesn't actually revoke the token?\nReading the source code, this seems to be the case. Guardian.revoke! calls Guardian.hooks_module.on_revoke, which is just:\ndef on_revoke(claims, jwt), do: {:ok, {claims, jwt}}\nAs in, it doesn't actually do anything, BUT can be overridden with something like GuardianDb. Am I right?. I tried doing that. Here's my create function in SessionController:\ndef create(conn, params) do\n    case authenticate(params) do\n      {:ok, user} ->\n        conn\n        |> Guardian.Plug.sign_in(user)\n        |> render(\"show.json\", user: user)\n      :error ->\n        conn\n        |> put_status(:unauthorized)\n        |> render(\"error.json\")\n    end\n  end\nHere's my router pipeline:\npipeline :api do\n    plug :accepts, [\"json\"]\n    plug :fetch_session\n    plug Guardian.Plug.VerifySession\n    plug Guardian.Plug.EnsureAuthenticated\n    plug Guardian.Plug.LoadResource\n  end\nI can log in fine - SessionController sends a 200 status response and renders the user resource. However, the very next request I send to the :api pipeline results in 401 - Unauthenticated. When I check Chrome's settings there are no cookies from localhost. (There are no cookies on the incoming conn either.). Yes, using an SPA, with CORSPlug configured on the endpoint to accept the SPA's origin.\nI included the credentials in the http call, but still getting 401 - Unauthenticated. Maybe there are no credentials to include? I mean the browser doesn't have any cookies from the server, so I'm not sure where it would get the credentials from.\nI don't think we're going in the right track. Here's the conn at the time of the server's response. The jwt gets inserted into the session, but note that the cookies map is empty.\n. Login response from the server:\nHTTP/1.1 200 OK\nserver: Cowboy\ndate: Wed, 15 Mar 2017 01:20:37 GMT\ncontent-length: 59\nset-cookie: _myapp_key=SFMyNTY.g3QAAAABbQAAABBndWFyZGlhbl9kZWZhdWx0bQAAAUNleUpoYkdjaU9pSklVelV4TWlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKaGRXUWlPaUpWYzJWeU9qSWlMQ0psZUhBaU9qRTBPVEl4TXpJNE16Y3NJbWxoZENJNk1UUTRPVFUwTURnek55d2lhWE56SWpvaVFYTndhWEpsSWl3aWFuUnBJam9pTlRBMU1tRXdZamd0TmpBeE1DMDBOV015TFdKa1pEVXRaVE15TnpZMFlqSTFaRGN3SWl3aWNHVnRJanA3ZlN3aWMzVmlJam9pVlhObGNqb3lJaXdpZEhsd0lqb2lZV05qWlhOekluMC4xSkRrQzBhN2RkT2F6TTNKRnJ3bGVQdkFPczM5U0paQWZwdHFaSVlNSGNBUm5peDBybWZPaDBjdlhYOEtpRjR5all0M0VHUExFTnZDZHBuMFpqSEVPQQ.aGLE3Lf_7NJfmtE7y5tH31CMZTlckL37UEf9iOFmIag; path=/; HttpOnly\ncontent-type: application/json; charset=utf-8\ncache-control: max-age=0, private, must-revalidate\nx-request-id: f4r7sard8i472555gsfgckf2p4fg3uvn\naccess-control-allow-origin: http://localhost:8080\naccess-control-expose-headers: \naccess-control-allow-credentials: true\nvary: Origin\nFollowing request to /api/account:\nGET /api/account/ HTTP/1.1\nHost: localhost:4000\nConnection: keep-alive\nAccept: application/json\nOrigin: http://localhost:8080\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\nReferer: http://localhost:8080/\nAccept-Encoding: gzip, deflate, sdch, br\nAccept-Language: en-US,en;q=0.8,tr;q=0.6\nHeaders of the 401 Response from the server:\nHTTP/1.1 401 Unauthorized\nserver: Cowboy\ndate: Wed, 15 Mar 2017 01:27:31 GMT\ncontent-length: 30\ncache-control: max-age=0, private, must-revalidate\nx-request-id: 83js05m5qillugq961dd1qt35efpvofc\naccess-control-allow-origin: http://localhost:8080\naccess-control-expose-headers: \naccess-control-allow-credentials: true\nvary: Origin\ncontent-type: application/json; charset=utf-8. Yes, I'm already doing that (not with Fetch, but rather Vue Resource):\nthis.$http.get(\"http://localhost:4000/api/account/\", {credentials: true}).then(/* ... */)\nThat's getting me 401 unauthorized.. If I remove Plug.Guardian.EnsureAuthenticated from the route pipeline, I don't get any errors, but the resulting response has empty data, and the user I'm trying to extract from the conn using Guardian.Plug.current_resource(conn) is empty.\ndef show(conn, _) do\n  user = Guardian.Plug.current_resource(conn)\n  Logger.debug inspect user\n  render(conn, \"show.json\", user: user)\nend\nIf I inspect that conn, this is what I see:\n%Plug.Conn{ assigns: %{}, body_params: %{}, cookies: %{}, halted: false, host: \"localhost\", method: \"GET\", owner: #PID<0.794.0>, params: %{}, path_info: [\"api\", \"account\"], path_params: %{}, peer: {{127, 0, 0, 1}, 50827}, port: 4000, private: %{MyApp.Router => {[], %{}}, :guardian_default_resource => nil, :phoenix_action => :show, :phoenix_controller => MyApp.UserController, :phoenix_endpoint => MyApp.Endpoint, :phoenix_format => \"json\", :phoenix_layout => {MyApp.LayoutView, :app}, :phoenix_pipelines => [:api], :phoenix_route => #Function<15.122516726/1 in MyApp.Router.match_route/4>, :phoenix_router => MyApp.Router, :phoenix_view => MyApp.UserView, :plug_session => %{}, :plug_session_fetch => :done}, query_params: %{}, query_string: \"\", remote_ip: {127, 0, 0, 1}, req_cookies: %{}, req_headers: [{\"host\", \"localhost:4000\"}, {\"connection\", \"keep-alive\"}, {\"accept\", \"application/json\"}, {\"origin\", \"http://localhost:8080\"}, {\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"}, {\"referer\", \"http://localhost:8080/\"}, {\"accept-encoding\", \"gzip, deflate, sdch, br\"}, {\"accept-language\", \"en-US,en;q=0.8,tr;q=0.6\"}], request_path: \"/api/account/\", resp_body: nil, resp_cookies: %{}, resp_headers: [{\"cache-control\", \"max-age=0, private, must-revalidate\"}, {\"x-request-id\", \"n0rvkkiuu4bka34cts9enjh4p52nhlit\"}, {\"access-control-allow-origin\", \"http://localhost:8080\"}, {\"access-control-expose-headers\", \"\"}, {\"access-control-allow-credentials\", \"true\"}, {\"vary\", \"Origin\"}], scheme: :http, script_name: [], secret_key_base: \"bla\", state: :unset, status: nil}. How do I add a debugger plug into the pipeline? :). Alright, debug data immediately after :fetch_session - here you go.. Whoops, sorry. I think I provided the wrong debug log. I restarted the server and re-ran the steps. This is what I got.. Yeah, hmm. Might it be because the cookie has the HttpOnly option set?. No worries. I think I'm going to go back to the regular approach. Thanks a lot for your help! :). Any news on this?. @Hanspagh Yes, that did indeed turn out to be the case. It wasn't immediately obvious from the stack trace. Thanks for looking into it!. ",
    "fpalluel": "In my apps, I use Guardian.revoke!, isn't it what you're looking for ?. Oh ok, I read the initial post too quickly ;-). ",
    "Grafikart": "Thanks . ",
    "alexandrubagu": "After I've updated credo, I  run mix credo this is the output:\n\nSo, I try to fix them. If you want to update deps to have the latest ones, I'm glad to make a new commit with required changes\nPlease let me know what are your intentions\nThanks. I've revert changes and set some credo checking rules to false. No problem. That's right. I'm ok with this. Done :+1: . ",
    "snewcomer": "@doomspork Any updates on this?  What about upgrading to phoenix 1.3.0-rc.0 as well?. ",
    "jonathanraes": "Im not sure how, but now it seems to work, I was playing around with the claims and pulling the user directly from the Serializer. I got that to work and then I realized that my user parameter got populated also (current_resource also works).\n. ",
    "ghoshnirmalya": "Okay. So, I made the login to work and now, I can only see my authenticated routes after I provide the Authorization: Bearer <jwt> in the header. But, I can't make the sign out to work. I know that I can just forget the token from the client itself but how can I remove the user from the session in the API itself.\nAlso, do you suggest using guardian_db to handle sessions?. Thanks for the quick reply. I'll take this discussion over there.. ",
    "mikeni": "@scrogson thanks for clearing that up. ",
    "mikebaldry": "I've just found set_current_resource which looks like just the ticket, it sets the assigns correctly, but when I actually get inside my handle_in, the assigns is empty again?. ",
    "jstr": "@mikebaldry the implementation example here worked for me: https://github.com/hassox/phoenix_guardian/blob/ueberauth-guardian/test/channels/authorized_channel_test.exs. ",
    "jaysoifer": ". ",
    "DisruptiveMind": "you can try to just override the phoenix dependency with override: true so inside your mix.exs:\n```elixir\n...\ndefp deps do\n    [{:phoenix, \"~> 1.3.0-rc\", override: true},\nend\n...\n````. ",
    "gregstula": "I too ran into this issue on a new 1.3 project. I was surprised to see it not work. ",
    "illyas3": "Was addressed by others already in #273. ",
    "ghost": "Hey, I am having a similar problem to @egeersoz 's original problem. I was wondering if anyone resolved being able to pass httponly tokens through an api pipeline? . Apologies but I'm not 100% what you mean in your first message. . @hassox thanks, will dig a little further :) . Hi @hassox \nThanks for replying ASAP. I am at 0th level in phoenix. I have just started reading the book. Is there any tutorial series, which you recommend. Slack for beginners, forum i can join specific to phoenix. \nAnything will be helpful. Once again thank you. programming-phoenix is the book i am reading. Thank You So Much spending time and answering all my queries. Will join you guys. Bye Have a great day! :)\n. ",
    "connorjacobsen": "Running into a similar problem, but I think this is a client-side problem rather than Guardian/Phoenix related. The set-cookie header is being sent just fine on my login request, but the client isn't sending it back ever (and Chrome doesn't seem to be storing it either).\nSo if anyone else runs into this, probably try checking your client instead of trying to do something on the Phoenix side of things.. ",
    "sphinxc0re": "Oh, snap! I did issues wrong again \ud83d\ude05 Thanks for your quick help @doomspork . ",
    "josephan": "@doomspork Oh I didn't know about that. Thanks!. @doomspork I can reopen this PR then! @casio do you think the addition was helpful?\n. @doomspork sorry it took a while. Updated and squashed!. ",
    "casio": "\nI imagine most Guardian users will be using Phoenix in which case mix phoenix.gen.secret\n\nHm, that at least wasnt obvious to me : )\nSo, setting secret_key to the string output of mix phoenix.gen.secret is sufficient, right?\nI was under the impression I'd at least have to put it into some(?) key of some map : )\nA little mention of that in the README would indeed help for a quick test / first go with guardian, imho. I think both are helpful! The JOSE generated map, but also the even simpler one for phoenix users.\nSomething along these lines maybe?\n``\nTo get off the ground quickly, simply replace` above with the output of either:\n$ mix phoenix.gen.secret\nor\niex(1)> JOSE.JWS.generate_key(%{\"alg\" => \"HS512\"}) |> JOSE.JWK.to_map |> elem(1)\n ```\n. ",
    "Hostert": "Hey @doomspork, I'm still new to Elixir and guardian, so I can't do any valid suggestion, I think. But, as guardian documentation says, \"The core currency of authentication in Guardian is JSON Web Tokens (JWT).\" \nSo, in config.exs instead of using the optional verify_module: Guardian.JWT, we could use something like verify_module: Guardian.Fernet, or just verify_module: Fernet.\nBut, as I said, I don't have enough knowledge to point this as a valid suggestion.\nAnd as you say in \n\nIf you generate a JWT and then apply Fernet to that...\n\nIf we do this, we still have, hypothetically, a JWT insecure token?. @doomspork \n\nit's more than just verifying the token.\n\nI see. Unfortunatelly, I did not understand exactly why JWT is insecure or the ways it could be a problem to us. I'm using guardian the way it is. I just asked this because I wanted to understand why, or in which way Fernet could be used in replacement of JWT.\nI would like to help you with any suggestion, but if you don't know exactly how to answer this issue, we can close this for now. No hard feelings :smile:\nMaybe in future someone can make usefull sugestions. . ",
    "agusguerra10": "I know it's not the best thing considering security but it's something I am willing to leave aside in this particular case.\nI have lots and lots of users with an expired token, resulting with them being logged out of the app. I need this users to get a new token without having them to enter their credentials again, so ignoring the token expiration date or being able to refresh a token with an old (not valid anymore) one would help me accomplish that. Does it make sense?\nThanks.\nAgus.. ",
    "awwong1": "Just did more reading and realized that GuardianDb solves my problem here. . ",
    "thomasdola": "@hopewise how did you fix it?. ",
    "johannesE": "I am having the same Problem. @ponty96 Why did you close this?\nEDIT: If I got this right, https://github.com/dfcarpenter/guardian has already fixed it in his fork.\n@dfcarpenter is that correct?. @dfcarpenter Okay, thanks for your explanation. I'll create a small PR for guardian in this case.. Oh no. Now we have #292 and #293. Two rejected PR's.\nFor any future visitors: The resolution is to use override: true:\n[{:phoenix, \"~> 1.3.0-rc\", override: true} until the new phx version comes out.. @sergiotapia it overrides the version of the dependencies. So if guardian has phoenix ~> 1.2 defined (which does not include rc's and betas, but 1.3.0 would be used), then we are telling mix that it's okay to use phoenix 1.3.0-rcx for guardian and all the other packages that depend on phoenix. That's how I understood this.. I'm fairly new to elixir, so if I misunderstood something, just tell me :). Oops, I didn't see that.. ",
    "dfcarpenter": "@johannesE I did but I also made another change to uuid because I was using cqex which is a cassandra client for elixir. It relies on cqerl which in turn uses an erlang lib called :uuid which causes problems on compile. Thus I had to for the elixir uuid  ( the one on hex.pm ) and rename it. . ",
    "sergiotapia": "@johannesE Can you explain what override true does in this case?. Thank you. ",
    "Linbubin": "@b-murphy  sorry, I dont find  example, can you help me find some similar examples ?. I just write when someone is authenticated.\nconn\n      |> Guardian.Plug.sign_in(%{ok: \"username\"})\n      |> redirect(to: page_path(conn, :index))\nand when people log out \nconn\n    |> Guardian.Plug.sign_out \n    |> put_layout(false)\n    |> render(\"login.html\")\nroutes:\n```\ndefmodule Zerg.Router do\n  use Zerg.Web, :router\npipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\npipeline :with_session do\n    plug Guardian.Plug.VerifySession\n    plug Guardian.Plug.LoadResource\n  end\npipeline :login_required do\n    plug Guardian.Plug.EnsureAuthenticated, handler: Zerg.GuardianErrorHandler\n  end\nscope \"/\", Zerg do\n    pipe_through [:browser, :with_session] # Use the default browser stack\nget \"/login\", SessionController, :index\npost \"/login\", SessionController, :login\nget \"/trading_systems/:trading_system_id/subscribe\", TradingSystemController, :subscribe\n\nscope \"/\" do\n  pipe_through :login_required\n\n  get \"/\", PageController, :index\nend\n\nend\nend\n```\nIt achieve what I expected, but I don't think it's the right way to write, even I don't use Guardian.Plug.current_resource( This is not necessary\uff1f).\nwho can give me some advice ? . @b-murphy Thanks very much.\nif I create a user table just store username, it's ok?\ndefmodule MyApp.SessionController do\n  def create(conn, %{\"username\" => username } = params) do\n    case  API.return do\n        true ->\n           case Repo.insert(MyApp.User.changeset(%{username: username})) do\n             {:ok, user} ->\n                conn\n                |> Guardian.Plug.sign_in(user) # pipe the conn & user into the session\n                |> redirect(to: \"/dashboard)\n             {:error, _} ->\n                # do fail redirect\n        false ->\n          # do fail redirect\n     end\n  end\nend\nbut Guardian.Plug.current_resource use where? (automatic call when loading page?). @b-murphy  ok\uff0c thanks. ",
    "psteininger": "I got my setup to work in a round-about way, which is suggested in: https://github.com/ueberauth/guardian/issues/187\n```elixir\n/my_app/lib/myapp.ex\ndef start(_type, _args) do\n    unless Mix.env == :prod do\n      Envy.auto_load\n      Mix.Config.read!(\"config/config.exs\") |> Mix.Config.persist\nend\nguardian_env = Application.get_env(:guardian, Guardian)\npem = System.get_env(\"AUTH0_PUBLIC_KEY\") |> Kernel.||(\"\") |> String.replace(\"\\\\n\", \"\\n\") |> JOSE.JWK.from_pem\nnew_guardian_env = guardian_env |> Keyword.put(:secret_key, pem)\nApplication.put_env(:guardian, Guardian, new_guardian_env)\n\nimport Supervisor.Spec\n\n...\nend\n```\nI hope this helps anyone trying to get things working with envy and auth0. I will try to blog about it next week and add a link here.  I also wanted to add a note that with Auth0 the certificate for each account is publicly accessible, so committing the whole cert or even just the extracted public key would be quite OK. . great to know @scrogson.\nBTW, as I mentioned earlier. For Auth0 specifically, using RS256 algorithm, one can just use a certificate from file (in PEM format), and JOSE automatically extracts and uses the public key.\nSo if could be even better:\n```elixir\ndef fetch_secret do\n   JOSE.JWK.from_pem_file(\"hard/coded/path/to/cert.pem\")\nend. ",
    "xadhoom": "+1 for this, in my case to make dialyzer happy :). ",
    "maxnordlund": "Ah, thanks.. All though, considering the amount of issues I found, it might be good to relax the constraint anyways.. True, but from what I could tell by reading through those issues, there seem to be no issue with using Guardian with 1.3. Anyway, sooner or later it will be released and then this can be properly dealt with.. ",
    "deepfryed": "Thanks for the feedback, appreciate it! \u2764\ufe0f \u2764\ufe0f \u2764\ufe0f  \nDidn't know about the slack channel \ud83d\udc4d . ",
    "Licenser": "Ohhhh! you are right it's a JWT inside a EWT? The outside seems to be an erlang term, I suspose that's not a guardian thing but something phoenix adds around it. I guess  I'll close this and dig around in phoenix :) sorry for the wrong place for the bug, I thought the outer wrapper is the guardian one.\nPS: thanks for the great library!. Oh damn sorry for getting back so late, GH only told me there was a reply today. Yea you're right it's a typo -.- damn me.\nThat said, I wonder if would be better to error/crash on unknown permissions. Given it's security it feels to like like airing on the side of caution. would be better? I mean 'unknown permission == always true' seems odd.. ",
    "jcomellas": "This is happening because within the Guardian.Phoenix.Socket__using__/1 function the params variable is used as an argument to sign_in/4 without it being bound to anything. The commit mentioned in the issue removed the binding.\nPR #338 fixes the problem.. You might want to retire the v0.4.13 package from hex.pm, as your project won't compile if you are using the Guardian.Phoenix.Socket module.. ",
    "quytang": "tks @hassox . ",
    "milkcocoa": "Hi @hassox\nDo you have any plan when this fix is released?. ",
    "samhamilton": "sorry! I didn't spot that. . ",
    "g33kidd": "You can just add override: true to your phoenix dependency. \n{:phoenix, \"~> 1.3.0-rc\", override: true}\nYou may also want to look at #317 for a list of issues regarding 1.3.. ",
    "cybrox": "@odarriba With 7f07ab8, any chance of this bleeding into production is eliminated at compile time.\nReally looking forward to seeing this merged \ud83d\udc4d . ",
    "ocisly": "Hello folks, I am in no way involved with this project and came across this PR purely by chance.\nHowever, I couldn't help but notice that you are blacklisting Mix.env() == :prod rather than whitelisting dev and test. So what happens if someone has a custom MIX_ENV, e.g. MIX_ENV=staging or, more worryingly, MIX_ENV=production?. ",
    "tmock12": "I currently have a PR open to merge against the V1 branch #359 , would it be better to fix the deprecation on master and then fix it here on the merge?. ",
    "TheAncientGoat": "Thanks for the quick reply - would it be helpful if I made a pull request mentioning that in the Readme? Took me a while to figure out. ",
    "plamb": "@hassox you are right, I really should have noticed that. It's right there in the v1 read me too.. Thanks for looking at it. I'm already on the road heading to ElixircConf. There's also been a large amount of churn in my app since then too. If it comes back up, I'll let you know.\n. ",
    "waiting-for-dev": "Oops, ok, it seems I have an old version in my project ;). ",
    "praveenperera": "@doomspork Sounds good! Nothing specific right now, I got the upgrade done yesterday and it went pretty smoothly. I guess the only thing is, does the AuthPipeline above look okay?\nOne other thing yesterday I stupidly put the LoadResource plug before VerifySession and I was wondering why logging in wasn't working. I eventually realized my mistake. But I'm wondering if it makes sense to add a warning, message, or maybe just a note in the docs. Not sure if this is a common mistake people might make or just me. \n. @doomspork I actually have another question. This is about the remember_me function. I want to remember the user on login, so I do the following.\n```elixir\n  alias MyApp.Guardian.Plug, as: GuardianPlug\ndef login(conn, user) do\n    conn\n    |> GuardianPlug.sign_in(user)\n    |> remember_me(user)\n  end\ndef remember_me(conn, user) do\n    GuardianPlug.remember_me(conn, user, GuardianPlug.current_claims(conn), [])\n  end\n```\nAnd I have this in my pipeline\nelixir\n  plug Guardian.Plug.VerifySession\n  plug Guardian.Plug.VerifyCookie\n  plug Guardian.Plug.LoadResource, ensure: true, allow_blank: true\nIs this correct way to implement it, or am I missing something? Thanks again.\nAlso a note on the docs:\n```elixir\nSet a \"refresh\" token directly on a cookie.\nCan be used in conjunction with Guardian.Plug.VerifyCookie\nconn = MyApp.Guardian.Plug.remember_me(conn, resource)\n```\nBut I don't think there is a  MyApp.Guardian.Plug.remember_me/2 function. . ",
    "oskar1233": "Hi, I have already created something like walkthrough for beginners with Guardian 1.0; for now it lies here. I would appreciate every help with improving the article or sample app (uses Phoenix and lies in the same repo). I plan to publish this on my not-yet-existing blog, but wanted someone to review it. Let me know if it looks good for you.\nEDIT\nUploaded this to my brand new blog (click).. @hassox It does - thank you very much.. Few things:\n1. I'm not sure if the Guardian module should go to MyAppWeb or to MyApp. I think it's project dependent and up to the developers.\n2. Look into the lib/guardian.ex. I think you should use the Guardian itself, not Guardian.Plug.\nif Code.ensure_loaded?(Plug) do\n        __MODULE__\n        |> Module.concat(:Plug)\n        |> Module.create(\n          quote do\n            use Guardian.Plug, unquote(__MODULE__)\n          end,\n          Macro.Env.location(__ENV__)\n        )\n      end. There is nice piece of examples and explanation in Guardian behaviour doc - maybe you can inspire with it.\nI totally agree, it is web related, but for example I for my recent project use Web module just for Phoenix-related things, not overally web-related. That's why I've said it's up to developer.. I think you can create module likeAuthErrorController`, which will be either Phoenix's controller and error handler in terms of Guardian.\nI would add use ZoinksWeb, :controller to the module, then think about naming and adding it into Web namespace.. I suggest pasting your configuration as well.\nAnswering you question: halt shouldn't be needed here, docs aren't wrong on this.. IMHO the stuff you covered is more about understanding  building HTTP request with authorization header than about verify_header module itself. Maybe readme or even some separate  guide would be better place to write about it?. Maybe some subheading in the basics section? Just because that's what you usually do in the beginning and boosts your API understanding :). ",
    "zhulinpinyu": "@TylerPachal  I think this blog is very well. \nhttps://medium.com/@tylerpachal/session-authentication-example-for-phoenix-1-3-using-guardian-1-0-beta-a228c78478e6\nhttps://github.com/TylerPachal/auth_ex. ```\n\u279c  demoJWT mix phx.server\nCompiling 17 files (.ex)\n== Compilation error in file lib/demoJWT/guardian.ex ==\n** (CompileError) lib/demoJWT/guardian.ex:13: undefined function find_me_a_resource/1\n    (stdlib) lists.erl:1338: :lists.foreach/2\n    (stdlib) erl_eval.erl:670: :erl_eval.do_apply/6\n    (elixir) lib/kernel/parallel_compiler.ex:121: anonymous fn/4 in Kernel.ParallelCompiler.spawn_compilers/1\n```. @yordis  thanks you much. \u2764\ufe0f\nelixir\ndef resource_from_claims(claims) do\n  user = Accounts.get_user!(claims[\"sub\"])\n  {:ok, user}\nend. ",
    "steveops": "Hi all, could someone clarify to me this part of the documentation, the part where it says the plug does nothing if session is not loaded. I thought this should not depend on the session?\n\n. ",
    "iacobson": "I see that the remember_me function was removed.\n```\nSet a \"refresh\" token directly on a cookie.\nCan be used in conjunction with Guardian.Plug.VerifyCookie\nconn = MyApp.Guardian.Plug.remember_me(conn, resource)\n```\nIs there another way to use the Guardian.Plug.VerifyCookie ?\nThank you. Perfect. Thanks. I will keep an eye on that. Hope will be merged soon. ",
    "MartinElvar": "Fixed this by supplying 2x config maps, as such.\n```elixir\nconfig :splish, SplishWeb.Guardian,\n  issuer: \"splish\",\n  secret_key: \"secret\"\nconfig :splish, SplishWeb.AuthPipeline,\n  module: SplishWeb.Guardian,\n  error_handler: SplishWeb.AuthErrorHandler\n```\nDon't know if this is the right approach, but it seem to work.\n. ",
    "yordis": "Removed file, not needed it. @hassox nevermind then, guardian_db is failing because of this but should be fine after you release 1.0. @hassox actually maybe take it for 0.14.x if you want. @zhulinpinyu could you put the stack trace? With that people outside of guardian team could take a look faster because we do not know the code base but reading the stack trace we can figure out faster.. @zhulinpinyu ahhhhhh I see what is the problem\nfind_me_a_resource is not a function from Guardian, the point is that you replaced find_me_a_resource with some function from your logic, which could take what comes from claims[\"sub\"] and return the resource back. You could do the business logic in that function as well but I wouldn't.\nelixir\n def resource_from_claims(claims) do\n    resource = MyApp.get_resource_from_claims(claims[\"sub\"])\n    # Do whatever you want but you have to return `{:ok, resource}`\n    {:ok,  resource}\n  end. @doomspork I would use this snippet\nelixir\ndef resource_from_claims(claims) do\n    resource = MyApp.get_resource_from_claims(claims[\"sub\"])\n    # Do whatever you want but you have to return `{:ok, resource}`\n    {:ok,  resource}\n  end\nAt least they can relate MyApp and the breaking down of {:ok, resource}. @doomspork done. @julien-leclercq that is interesting question.\nI would say that if you think from domain of the application.\nPlug is a module that deals with Plug.Conn. Don't forget that this is functional programming, modules are just for encapsulation of the functions together.\nBy design, I would say that is all about grouping functionalities rather than OOP where you group by objects.\nSo Plug module will be all about Plug functionalities.\nBut that is my opinion.. Don't forget to run mix format (just remembering you about it \ud83d\ude05). @Hanspagh yes (this is the first programming language that I have no fair for using dev version \ud83d\ude04). @ueberauth/core  are good to go?. https://github.com/ueberauth/guardian/blob/c94a71179bd49975a01c8da984c42265b671f953/lib/guardian.ex#L393\nFor some reason config(:token_module) is giving nil back. @rafbgarcia could you please check your config and see what you have on token_module key. token_module comes from the config and it is giving you nil so probably either you missed it or you put nil\nPlease confirm that because should be token_module: Guardian.Token.Jwt by default. I found the issue. We are not falling back to the default\ntoken_mod = apply(mod, :config, [:token_module, @default_token_module]) This is normally how we should read the token_mod. @rafbgarcia do me a favor please, change this function\nhttps://github.com/ueberauth/guardian/blob/f2b130f89c01cdc06e60ce63c410653d1b6d4e18/lib/guardian.ex#L393\nelixir\ndef peek(token) do\n  config(:token_module).peek(__MODULE__, token)\nend\nto\nelixir\ndef peek(token) do\n  config(:token_module, @default_token_module).peek(__MODULE__, token)\nend\nIn your local deps/guardian file and recompile and check \nThat is the actual fix. @rafbgarcia I am doing more than just changing that line. I will handle it, I just wanna you to confirmed because you had the environment for it. @mattdevelops post the error trace so I can try to help you out. It makes it easier to easy path of the execution. yeah no clue why I am fixing it. @doomspork Green light. @Yamilquery LoadResource plug is the one that is failing, make sure that your resource_from_claims/1 function from your Guardian module is actually returning {:ok, resource}\nBut I need more context of your application for be able to help you out.. @willsoto could you elaborate on what was the workaround so we could understand what you did and learn about it? Do reverse engineering.\nI am curious of what you call workaround because it means we need fix something.. Folks, \nfeel free to reopen it if you are having this issue.. @hisapy yes please, make a PR with some documentation updates . Fixed by https://github.com/ueberauth/guardian/pull/430 \n@ueberauth/core could somebody release it if it nos released yet.. @hassox Do you think is possible to have some patch release so people dont keep getting into this error?. @SofaKing18 this was fixed by https://github.com/ueberauth/guardian/pull/430. @SofaKing18 could you use the master branch and verify the error please? This line https://github.com/ueberauth/guardian/blob/2b486689c4605b982951ae56f5a09db1d94b422c/lib/guardian.ex#L393 should fix your issue because you shouldn't be calling directly .peek from the module but from Guardian module and then Guardian module will call your module .peek function\nAnd if the error continues, then could you add unit testing as well so it covers this issue.. @ueberauth/core @hassox do you think is possible to get a release for this? Many people that will no setup the module will get this error .... @joshuataylor thank you for pointing it out.\n@atomkirk if you have any feedback from the migration let us know.. Guardian do not show any example right now because how you do it is really up to your needs and your application. Specially that Guardian allow you to create your own tokens and stuff like that so I will explain a little bit about JWT tokens (if you change your token then your strategy will change wit it)\nFor invalidate JWT tokens you will need to change your encryption keys or wait until the expiration time of the JWT makes the token invalid or you could use Guardian.DB which pretty much do some database look up for your token.\nIf you are not familiar with JWT details I would suggest you to add Guardian.DB until it becomes a problem (probably you will have enough money for do the changes to be honest \ud83d\ude04 ) but this will defeat the reason why you use JWT (statelessness tokens).\nJWT security model is based on encryption mechanism where you trust that there is no way for somebody to know how to properly encrypt the token without using your application (it is the one that knows about it). The encryption uses your private secret_key for be able to encode and decode the token.\nActual answer\n\nChange your secret_key \ud83d\udd34 \ud83d\udd34 \ud83d\udd34 This will invalidate all the tokens in your application because the decoding will fail (the secret key used for the encoding is not longer the same). So restart the server with new keys or whatever mechanism you used for the secret key.\nUse Guardian.DB, pretty much it does a database look up for make sure that your token is there, so you will need to clean your database table information for invalidate the tokens.\n\nLet me know if you need any help, from your example, just change the secret key it will make all the tokens invalid.. @bjunc to be honest it doesn't really matter.\nThat details is something that belongs to your application design. If you will have the same Guardian module for multiple resources, for example: User and Admin you would probably do something like that so in your resource_from_claims/1 you could pattern matching for use the correct Ecto schema or whatever you are using for knowing which model you should load.\nBut that is an application specific business rule in how you do it.\nI would keep doing it to be honest, it makes your code easier to know and people will understand the model that is being used.\n```elixir\ndef resource_from_claims(%{ \"sub\" => \"User:\" <> id }) do\n    resource = MyApp.User.get_user(id)\n    {:ok,  resource}\n  end\ndef resource_from_claims(%{ \"sub\" => \"Admin:\" <> id }) do\n    resource = MyApp.Admin.get_admin(id)\n    {:ok,  resource}\n  end\ndef resource_from_claims(_claims) do\n    {:error, :reason_for_error}\n  end\n```\nmake sure you do the same in the serialization of the sub of your claim for sure.\nBut, everything ends of on application design and Guardian shouldn't dictate that. @tsurupin could you just create your own token https://hexdocs.pm/guardian/Guardian.Token.html\nYou can follow the implementation of the current JWT one\n@ueberauth/core what are your thoughts on this one?. @tsurupin sorry I reopen this but this is a really nice documentation to have. Could you write about it please?\n@ueberauth/core do you think is worth to add some section in the Guardian documentation so people could benefits of this?\nIf not, I will close it again. @pedroassumpcao I think this https://github.com/ueberauth/guardian/pull/454 is doing the same. @ueberauth/core ^\n@pedroassumpcao no sure, leave it open and we close it if we do not use it.\nIn any case, thanks a lot for your support!. > using multiple public keys\n@mumughal what do you mean, could you elaborate a little bit about what Guardian needs to do for you please.\nI dont know if this would help you but https://github.com/ueberauth/guardian/issues/459 check that thread. . @mumughal I would recommend to follow #459 solution and create your own token for now.\n@ueberauth/core any other suggestion here?. @zapient fix the documentation, he meant.. @gmile the problem is that, this is related to your business use case.\nWhat happened if I am not using Ecto and the function that verify my user send me back {:ok, user}|{:error, :not_found}?\nI don't believe Guardian should handle anything related to specific business rule (your case, Ecto).. \ud83c\udf89 . @pauldoerwald thanks a lot for the research, I am happy that you figured it out.\n@MeterSoft feel free to reopen it if you think this still an issue for you but please follow @pauldoerwald instructions first.. @jsangilve the second function is optional. https://github.com/ueberauth/guardian/blob/72df24d7e27e0a13ee7538c9d9537ae19ab60aff/lib/guardian.ex#L259\nYou don't need to pass define a verify_claims callback on your MyGuardian module.\nDid you define that callback?. @jsangilve if you need to do some custom verification as the documentation describe then you add the callback. That is the propose of that callback.. @jsangilve it should call once per module. One in the Token module and the other your Guardian module.\n. Feel free to open it again.\nverify_claims is called twice.\n  - On the Token module\n  - On your Guardian module so you can customize verification\n. @MeterSoft could you double check that you are sending {:ok, resource} or {:error, \"whatever here\"}\nAlso check that your module is using the correct OTP app, some folks already made this mistake.\nIf it doesn't work then add some IO.inspect here https://github.com/ueberauth/guardian/blob/c3f9c57015eb827cecde6c32cd1c128102aae616/lib/guardian/plug/ensure_authenticated.ex#L44 by modifying your deps/guardian/lib/guardian/plug/ensure_authenticated.ex file for see what the verify function is giving you.. Which route is failing?. @MeterSoft could you update the readme or put a comment of what the issue is now? I noticed that you changed the title and I want to understand what results did you get and what do you expect.. You can\u2019t swap the order of the plugs.\nYou already said the answer, EnsureAuthenticated will make sure that you had an authenticated user.\nIt works as intend.. @MeterSoft because you are using plug Guardian.Plug.EnsureAuthenticated so you must have an authenticated user.\nBecause you used allow_blank: true you don't need to actually find a resource but this conflicts with that plug.\nRemove plug Guardian.Plug.EnsureAuthenticated when you have allow_blank: true they can't leave together.. @MeterSoft who is sending {error: resource_not_loaded}?\nIf that is the case, then your LoadResource it is failing by sending an error tuple back. Verify that your are loading the resource correctly (even when it is nil value)\nNormally it is on resource_from_claims on your Guardian module.. This seems to be that you are using LoadResource plug with allow_blank: true which the resource could be nil because of that Guardian.Plug.EnsureAuthenticated will fail when the resource is nil\nFeel free to open the issue again. @ueberauth/core because mix format doesn't exists on old version of Elixir I need your help figuring out how we could run that command only for >1.6 or just drop the other versions which I would prefer.\n. @ueberauth/core yeah I wouldn't train the folks that it is fine for them to do not do their job upgrading their platform and by so we carry on their responsibilities . @ueberauth/core done!. Are you sure that secret_key: System.get_env(\"API_AUTH0_SECRET\") is actually doing what you expect to do?\nThe error message is really descriptive and I just want to make sure that it is your setup issues.. @williamweckl What is the issue of doing System.get_env(\"GUARDIAN_SECRET\") ?. I didn't finish to read by so far\nFrom the posted link\n\nNOTE: It is no longer recommended to use the {:system, \"VAR\"} convention, as it has inconsitent use in the community, and instead we\u2019d rather push people towards an approach which works every time, rather than only sometimes.\n\nSo why are you trying to use that way?. From Distillery official documentation this method is not recommended.. @williamweckl could be this what you are looking for?\nsecret_key: {MyModule, :function_name, [:some, :args]}\nFrom the readme: https://github.com/ueberauth/guardian#more-advanced-secrets. @angelo-moreira for general knowledge on Elixir.\nAs @hassox said, when you have ex_doc in the dependency you will have a task available called: mix docs\nThat task will generate the documentation and it will create a folder called docs where you can see an static website.\nAll the links in the docs are related on how ex_doc handles the documentation generation.\nhttps://github.com/elixir-lang/ex_doc. @grounded-warrior you could use the same pattern with the claims[\"sub\"] indeed.\n```elixir\n  def resource_from_claims(%{\"sub\" => \"User:\" <> id} = _claims) do\n    # ...\n  end\ndef resource_from_claims(%{\"sub\" => \"Admin:\" <> id} = _claims) do\n    # ...\n  end\n``. What is the value ofTest.Guardian.Plug.current_token(conn)after sign_out ?. @loustak whichconn` are you passing down?\nCould you please post the full test code so I can see what you are doing it.. Where is the link to the test where you are trying to make it pass? Which code should I look at?\n\n@loustak which conn are you passing down?\nI'm not really sure about what you mean there.\n\nI am trying to see how you are using the package and make sure that you are using the write connection.\nPlease do not merge one thing with the other one, keep it clean and better ask those questions on Slack channel where people could help you with it.\n\nI have also another question. I read somewhere that the jwt is stored in \"connections\". But I don't understand what are connections when speaking about Phoenix. Is this something in memory? My concern here is the scalabitility of this storage.\n\nJWT are stored on your cookie and/or your clients storage and send it every request on the header. JWT are stateless which means you don't store them on the server but your clients.. Feel free to open the issue if the problem persists.. What does Guardian.Plug.current_resource(conn) give you back after you made sure that the token expired?. Could you share your pipeline configuration so I can see which functions you are using for load the resource.\nDid you use plug Guardian.Plug.EnsureAuthenticated?. @MeterSoft is this still an issue?. Feel free to open the issue if the problem persists.. @shahryarjb this is nothing to do with security but how Elixir works.\nBasically means that your first function declaration always match so the second function will never be called.\nThat code snippet is a guideline no necessarily the final code, so modify as your needs change.\nRelated: https://github.com/elixir-lang/elixir/issues/3612. @ueberauth/core we can't control that from happening. I would suggest to only leave the Guardian DB package and create a Wiki that we can point to from the readme about related projects so we do not need to commit these changes.\nWhat do you think?. I am not sure if cleaning up the cookie is what we should do since remember me is for memorizing the who the user was.\nLogging off doesn't mean the computer can't memorize who you were.\nFor example,\nGoogle shows you a list of accounts that you signed up or logged in in your computer.\nSo I don't believe that we should remove the cookie because this is based on the use cases.\nThat being said, maybe add some flag that cleans up the cookie for you, maybe?!. @obrok fair enough, we could add some function for clean up remember_me and you decide to clean it up or not in the callbacks.. @Hanspagh until the next month and I am off the computer.\nIf you want to take the task, by all means, go ahead and do it.. @aditya7iyengar thanks lot of the contribution.\nI think the fix for this is adding the sigil ~S at the beginning of the module docs, like\nelixir\n @moduledoc ~S\"\"\"\n....\n\"\"\"\nDon't quote me on it, but could you add that change and try it out and see if the issue persist?! (without your changes). Worst case, let a config that allow you to put the id generator which could be UUID.\nIn my particular case, I am moving all the infrastructure to use UUIDs everywhere.. @ueberauth/core missing release v1.1.0 on Github.. @ueberauth/core can we merge this please?. We need to push, 1.1.1. Because we didnt create a release I had to do it for fix this https://github.com/ueberauth/guardian/issues/513\n@hassox @doomspork @scrogson could somebody create a release for Hex and also here on Github?. @mitkins I don't believe that there is an issue, to be honest.\nEverything depends on the order and the plugs that you use in your business and all of them depends on the app.\nBut please if you think otherwise I would love to see a descriptive message with your doubt and suggestions on what we need to do; either in terms of documentation issues or code.. @borodark thanks a lot for the contribution!. I would be helpful if you post some code snippet and the error output so we can see the stack trace of it.. How are you setting up the secret key?. @ueberauth/core I would like one of your to give some review as well.. Hey @nicolkill \nThis project does not need any database. JWT tokens are stateless so you do not need any database for it.\nIn some cases, you would use a database and for those cases, Guardian itself does not need to do anything about it. You can check https://github.com/ueberauth/guardian_db for understanding how you could use the API for safe, read and so on the token from databases.\nAlso, one thing I notice is that you mentioned every database that is commonly used in other stacks where you don't have tools like :ets https://elixir-lang.org/getting-started/mix-otp/ets.html \nI would suggest reading about ETS since it could replace those tools (unless you definitely need to use those databases for technical reasons)\nFrom your GitHub account, it seems that you are fairly new into Elixir (don't quote me on it) so I suggest to use the Slack channel to discuss issues before you open it.. I believe that until 1.4 is released we can't take ownership of the issues that could potentially happen.\nThe reason, as a release candidate, things could change and break over and over so it is better to wait until the finale release of it, unless @ueberauth/core think otherwise.\nIn the mid-time, you could add fork the repo and change this deps to include 1.4 https://github.com/ueberauth/guardian/blob/b19f2c96824279e231f7da82471245a090b524d1/mix.exs#L162 and use your fork as the dependency of guardian.\nAfter 1.4 is release, please open a PR updating the configuration if you dont mind.\n. @johannestroeger open a new issue with your suggestion so I can circle back to this.\nWhen we use Poison or Jason shouldn't matter and it shouldn't break anything. @pdgonzalez872 thanks a lot for the contribution. @fuelen is this still an issue for you?. Hey @paulZzhang thanks a lot for the PR but this is the rc version, not an official version of the package.. @paulZzhang test is failing.\nCould you change to be just >= 1.3.0?. @paulZzhang sorry maybe I wasn't clear about it, I meant to change to just >=1.3.\n{:phoenix, \">= 1.3.0\", optional: true},\nBut, @ueberauth/core are talking about this and we will move this dependency outside of guardian into guardian_phoenix package.. @doomspork that is Phoenix 1.3 that does not include 1.4 .... @AspenJames good observation, we shouldn't add those links since they are not finished yet. . Can't confirm. @evadne thanks a lot for the contribution \ud83d\udc9f . @asummers thanks a lot for the contribution!. @asummers thanks a lot \ud83d\udc93 . @asummers \ud83d\udc9f . @doomspork meh, I would do it since major packages are using Jason by default. @asummers \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 . > N.B: I could probably write this code n a better way.\nPR welcome \ud83d\udc93 try to do not introduce breaking changes and the default behavior is the current one.. Thank you \ud83d\udc9f . @jsangilve amazing \u2764\ufe0f I left some comments, also the CI is failing.. @mc962 your config looks fine except that I don't know if this is happening on production. This definitely seems to be something on your side.. Check the name of your OTP, the name of your module and so on. The links are not broken, they work when you use ex_doc (official documentation tool for Elixir).\nThey are not meant to work as how Github links markdown files together.\nEither go to the online documentation or do mix docs from this repo which will generate the documentation for you.. @doomspork I would, I can't count how many times I have to explain this \ud83d\ude04 , but I would say that maybe Elixir itself should invest a little bit more in clarifying these things, but we do not have control of it.. @asummers how this didn't fail ... thanks a  lot.. @doomspork don't we agree on be responsible only for the last 2 versions of Elixir and OTP?\nIn this case, 1.7 and 1.8. It seems that there is a mismatch betwen Elixir version and supported OTP version. I would say remove the matrix and do the following config\n```\nelixir:\n  - 1.7\n  - 1.8\notp_release:\n  - 21.1\n  - 21.2\n``. @sparta-developers hey, would you mind to fix the issues from the Travis? You need to runmix format. @Hanspagh do you need to update the version itself or can we just update themix.lock` with the latest version instead?\nWe can avoid having to maintain this versioning if so.. Do you have plug and guardian in your dependencies? . Could you post the stack trace of the error, I can't see anything wrong. At this point, are you sure you added the dependency to the correct package?\nI am not sure what is the issue other than having issues with the dependencies.. @shahryarjb your dependencies can't be under the umbrella but the individual packages under the umbrella, which may be what you called an issue since it is not well documented (people keep making the same mistakes)\nI am happy that you figured it out. @doomspork it seems to be Phoenix deps, probably I will hold this PR until #564 is merged. yeah much better actually. @doomspork actually we call auth_error from AuthErrorHandler module so, should I send an atom instead of a string?. @doomspork @Hanspagh let's do this on #585 . Definitely, prefer to do the changes that would introduce breaking change as V2. @doomspork at this point I am commenting for kids (no offenses but people don't like to read and study anymore, they just want to copy + paste). Misspelling, change practises to practices. I would recommend to add a full example of the Controller so newbies do not get lost in the context.\nFor example, where encode_and_sign/2  come from?\nWhere should I add this code?\n. Probably is better to add a jump line here so we keep consistency. . @scrogson we do not need to do this. Just do import_config(...) without checking\nNobody will use prod on this package and when you use it in another project the config/config.exs will be ignore from this package anyway.\nRight?!. @hassox I would keep the macros lean as possible and do only the function declaration \nelixir\ndef fetch_signing_secret(mod, opts) do\n  SecretFetcher.fetch_signing_secret(mod, opts)\nend. Same here. We dont need this anymore.\nUse extra_applications: [:logger]. Seems good to me, but why we dont use UUID package again?. I believe that the comma goes there.\nDon't quote me on it because I am not a native English speaker.\nBut I learned from Grammarly that it is good to add that comma there so you know it is part of the listing rather than grouping.\nFor example A and B,  C, and D\nReplace A, B, C, and D with something that makes sense.. I don't believe this shouldn't be referring to any naming in your code.\nPeople will try to find TokenModule in their code for this change for sure and then open issues because they can't find the module.. Same here about TokenModule. Same here about the TokenModule. @k-cross yes it is possible to use >= 1.3.0.. Since this is related to Plug I would change the scope to be under Guardian.Plug like Guardian.Plug. ErrorHandler. We can't publish any package that depends of a rc version.. Hex is not aware of that (correct me if I am wrong) so when we try to publish the package it will detect a rc package as a dependency so we will be forced to publish our package as rc as well.\n. @doomspork same \ud83d\ude04 . @asummers there you go, I learned something today \ud83c\udf89 \ud83c\udf82 . @doomspork I would prefer to review the credo --strict rules fixed in a separate PR.\n@asummers probably better to finish with this PR and then make another PR with --strict rule turn on and probably will require the fixes to keep the CI happy.\nAre you OK with that?. Never used for on Elixir after 2 years \ud83d\ude04 \nCan we use map or reduce or something similar like that instead of for?\n. I would prefer to use do end over here.. Could you change it to do end block instead of inlining, please?. Don't use pipe operator when there is only one function call. Try to extract the block before the case into a function so this reduce block is pretty much the case statement.. @doomspork is there a version 1.9 released? I wasn't aware of it.. There are two reasons.\n\n\nThis is a misleading message for many new programmers in Elixir land; this does not configure your application if you use this package as a dependency, has been multiple (no on this package) cases where they assume they need to add some default values to these configs.\n\n\nHaving those messages add no value to the source code, this is well documented in Elixir for us to have these messages all around the repositories.\n\n\nIn any case, feel free to block the merging, and I will roll the changes back if you think this is not a good idea.. I am not sure what would people prefer to get here \ud83e\udd37\u200d\u2642\ufe0f . > The including the tuple seems unnecessary don't you think? Tuples nor atoms are valid JSON so this isn't anything, right?\nDidn't write this so I am not sure, never used bitwise module before and the reason I asked for help.\nBut from what I understand this is being passed to the auth_error callback where you decide to respond with a valid JSON, text, or whatever you decide to do.. @doomspork since users will handle what to do with the error tuple anyway I will put as many details as possible on what happened (like @Hanspagh wants it), in any case, the user could decide if they want to send a generic error or not (this is why I put a generic error, I wasn't sure about it).\nNow, if that is the case, maybe instead of returning a string back I will return an atom since the user can always decide to convert the atom to the proper string message.\nOr triple tuple with the last value being the human-readable message (I would simply work with atoms).. ",
    "KronicDeth": "For (1), yes because of (2), it could go in either MyApp or MyAppWeb when using use Guardian, otp: :my_app since it will contain both Guardian, which isn't web-specific and Guardian.Plug, which is web-specific.  I suppose it depends on whether the non-Guardian.Plug functions are called directly.  If they are, then it can be outside of MyAppWeb,  maybe that should be explained somewhere to help newer developers.\nFor (2), :man_facepalming:, my bad for not reading the __using__ for Guardian and jumping straight to Guardian.Plug.\nI think then all that's needed is to show \nelixir\ndefmodule MyApp.Guardian.Plug do\n  use Guardian, otp_app: :my_app\nend\nin the Plug section and to same that it will also include the MyApp.Guardian functions.\nI'll do that change and rebase.. @doomspork ok, the PR is confusing, but so is introducing MyApp.Guardian.Plug usage in the README without explaining how it was defined.\nDo you agree that the README should somehow explain how MyApp.Guardian.Plug gets defined?  That was the original thing that tripped us up, so  MyApp.Guardian.Plug didn't work (with MyApp substituted for my mentee's namespace, of course).  I want something in the README that explains how MyApp.Guardian.Plug gets defined.. I'll close it for now.  We haven't revisited it on my mentee's project.  We did try <APP>.Guardian.<TAB> in iex and it didn't complete as <APP>.Guardian.Plug, so I can't confirm the automatic nested module name.. ",
    "uzarubin": "@oskar1233 I was actually following your example on some of these things.  Here is the config from my project:\n``` elixir\ndefmodule Wire.Guardian.Pipelines.JsonAuth do\n   use Guardian.Plug.Pipeline, otp_app: :wire,\n                              module: Wire.Guardian,\n                              error_handler: Wire.Guardian.ErrorHandler\nplug Guardian.Plug.VerifyHeader\n  plug Guardian.Plug.LoadResource, allow_blank: false\nend\n```\nAnd here is my router file:\n```elixir\npipeline :api do\n    plug Wire.Guardian.Pipelines.JsonAuth\n  end\nscope \"/api\", WireWeb do\n    pipe_through :api\nget \"/invite-tokens/:token_value\", BusinessAdmin.InvitesController, :show, param: :token_value\n\nend\n```\nHere is a stack trace with a uuid token\n[info] Sent 401 in 240\u00b5s\n[debug] Processing with WireWeb.BusinessAdmin.InvitesController.show/2\n  Parameters: %{\"token_value\" => \"00b18e1f-bfa0-49f3-972d-24d6b0e7ef34\"}\n  Pipelines: [:api]\n[error] #PID<0.806.0> running WireWeb.Endpoint terminated\nServer: localhost:4000 (http)\nRequest: GET /api/invite-tokens/00b18e1f-bfa0-49f3-972d-24d6b0e7ef34\n** (exit) an exception was raised:\n    ** (Plug.Conn.AlreadySentError) the response was already sent\n        (phoenix) lib/phoenix/controller.ex:529: Phoenix.Controller.put_new_layout/2\n        (wire) lib/wire_web/controllers/business_admin/invites_controller.ex:1: WireWeb.BusinessAdmin.InvitesController.phoenix_controller_pipeline/2\n        (wire) lib/wire_web/endpoint.ex:1: WireWeb.Endpoint.instrument/4\n        (phoenix) lib/phoenix/router.ex:278: Phoenix.Router.__call__/1\n        (wire) lib/wire_web/endpoint.ex:1: WireWeb.Endpoint.plug_builder_call/2\n        (wire) lib/plug/debugger.ex:99: WireWeb.Endpoint.\"call (overridable 3)\"/2\n        (wire) lib/wire_web/endpoint.ex:1: WireWeb.Endpoint.call/2\n        (plug) lib/plug/adapters/cowboy/handler.ex:15: Plug.Adapters.Cowboy.Handler.upgrade/4\n        (cowboy)/wire/deps/cowboy/src/cowboy_protocol.erl:442: :cowboy_protocol.execute/4\nEdit: I believe I have found the problem that is causing the error. \n```elixir\nverify_header.ex\n@spec call(Plug.Conn.t, Keyword.t) :: Plug.Conn.t\n    def call(conn, opts) do\n      with nil <- GPlug.current_token(conn, opts),\n           {:ok, token} <- fetch_token_from_header(conn, opts),\n           module <- Pipeline.fetch_module!(conn, opts),\n           claims_to_check <- Keyword.get(opts, :claims, %{}),\n           key <- storage_key(conn, opts),\n           {:ok, claims} <- Guardian.decode_and_verify(module, token, claims_to_check, opts) do\n    conn\n    |> GPlug.put_current_token(token, key: key)\n    |> GPlug.put_current_claims(claims, key: key)\n  else\n    :no_token_found -> conn\n    {:error, reason} ->\n      conn\n      |> Pipeline.fetch_error_handler!(opts)\n      |> apply(:auth_error, [conn, {:invalid_token, reason}, opts])\n      # There needs to be a |> halt here otherwise the connection will continue.\n\n    _ -> conn\n  end\nend\n\n```. Going to go ahead and close this. . I don't use session auth, but I noticed that that file also had the same issue? I can fix that if it's actually a problem. . @doomspork done. . ",
    "hauptbenutzer": "I'm sorry to say, this does prevent me from using guardian 1.x with absinthe (or any such API-framework, I would imagine). The problem here is, that in a GraphQL Query some requested fields might require authentication/authorization before resolving, while some don't. To make the distinction, the plug pipeline has to first reach the Absinthe plug. This, due to the halt in the Guardian plugs, cannot happen at the moment. \nIn fact, there is no way (as far as I can tell) to use the here-mentioned Guardian plugs, and still reach the app logic (absinthe or anything else, really) without manually calling it in the ErrorHandler module.\nMaking the halt a configurable behaviour, would probably alleviate this issue.. @Apelsinka223 We simply built a wrapper module that would unhalt the connection: https://gist.github.com/hauptbenutzer/bcc528c622317aabf0b8c5ee1890c536 Not pretty, but it does the job.. ",
    "ratbag98": "I've reached this thread probably for the same reason as @hauptbenutzer - in the middle of upgrading my Absinthe-powered API to use Guardian 1.x and I'm crashing out of my auth error handler if the user isn't logged in.. Sorry @Apelsinka223 , I dropped Guardian the day after posting my \u201cme too\u201d and coded my own very simple system that does what we need and no more. . ",
    "mpoeter": "Same problem here! Please let the user decide whether to halt or not.. @Apelsinka223 I simply created my own VerifyHeader module by copying the code from the Guarding module and removing the halt call.. ",
    "Apelsinka223": "@hauptbenutzer @ratbag98 @mpoeter have you solved this problem somehow?. @doomspork is there any chance that halt would become configurable?. @hauptbenutzer looks like best solution, thank you!. You still need to update docs with mix hex.publish docs, it's still broken version of guides on hexdocs.pm. ",
    "rbino": "That PR didn't fix the issue, I've just tried it by using the github version and the compilation still fails without Plug. I've opened #404 that should fix the issue.. The alternative for the scoped imports would be using the full function name for halt (that is the only function that is currently used from Plug.Conn) or using an alias and doing something like PC.halt().\nLet me know if you prefer this or one of the two alternatives above and I will fix the PR.. If I alias Plug.Conn the compiler warns me\n```\nwarning: unused alias Conn\n  lib/guardian/permissions/bitwise.ex:364\nwarning: unused alias Pipeline\n  lib/guardian/permissions/bitwise.ex:366\n``\n(the warning is also already there forGPlug.Pipeline`).\nIf the warning it's not a problem I will proceed by using an alias.\nAnother possible solution I came up with could be  moving the Plug related functions in a separate (possibly nested) module, so that they can be entirely wrapped in a conditional (like all the other Plug dependent modules) and do a conditional defdelegate from the top module, e.g.\n```\n  if Code.ensure_loaded?(Plug) do                                              \n    defdelegate init(opts), to: Guardian.Permissions.Bitwise.PlugImpl          \n    defdelegate call(conn, opts), to: Guardian.Permissions.Bitwise.PlugImpl      \ndefmodule PlugImpl do                                                        \n  @moduledoc false\n\n  import Plug.Conn                                                           \n  alias Guardian.Permissions.Bitwise, as: GBits                              \n  alias Guardian.Plug, as: GPlug                                             \n  alias GPlug.Pipeline\n\n\n  @doc false                                                                 \n  @spec init([GBits.plug_option]) :: [GBits.plug_option]                     \n  def init(opts) do                                                          \n    ensure = Keyword.get(opts, :ensure)                                      \n    one_of = Keyword.get(opts, :one_of)\n   ...\n\n```\nLet me know which of the two approaches you prefer and I will update the PR.. @hassox would the nested module + defimpl be an OK solution (it would not change the current API)?. @hassox I've changed the PR to the nested module implementation, let me know if it's ok. ",
    "vjorjo": "@doomspork this branch works as expected. Issue fixed!! Thank you.. ",
    "alec-c4": "Lads, could you add it to documentation?. ",
    "julien-leclercq": "yep I got it now thanks for your answers mates ! . ",
    "robmadole": "@Hanspagh do we need a remember_me added to the __using__ macro so this will get mixed in when defining the Guardian module?. @Hanspagh to enable this from the README:\n```\nSet a \"refresh\" token directly on a cookie.\nCan be used in conjunction with Guardian.Plug.VerifyCookie\nconn = MyApp.Guardian.Plug.remember_me(conn, resource)\n```\nI'm 97% sure that it needs to be added to the Guardian.Plug __using__ macro.. Also line 45 where the default cookie stuff is defined:\n@default_cookie_options [secure: true, max_age: 60 * 60 * 24 * 7 * 4]\nProbably should remove the secure: true because this will break local developement that isn't running on https. Plug.Conn.put_resp_cookie will handle setting this correctly according to the documentation.. We've basically got this running in production for fontawesome.com. So it's had a bit of testing. I'd love to switch over to it once it's released (to get off my local Plugs). Oh one more thing, if you want to release a pre-release version I'll upgrade our app and give it a test.. Kill that test if you like :) And my pleasure.. ",
    "beno": "It turns out I needed to add \nplug Guardian.Plug.Pipeline, module: App.Guardian, error_handler: App.Web.SessionController\n\nto my 0.14 pipelines.\n. ",
    "hassan": "@scrogson MySQL as of 5.7.x supports a JSON datatype. . ",
    "rosswilson": "Thanks @hassox, I've updated the PR with a note to the allow_blank option.. ",
    "sjoconnor": "Sorry for the report. This was a config issue on my end. I had my otp_app set to something different that what was in my config file.. I just ran into this as well, but it looks like this has already been fixed here https://github.com/ueberauth/guardian/pull/557 and is available in v1.2.1.. ",
    "rafbgarcia": "@yordis nothing..\n```ex\nconfig :api, Api.Guardian,\n  issuer: \"api\",\n  secret_key: \"SL6xJHKeZRRr/2YOJpLW2KvWTjh3h0IZ4UPUjPqGXX9J3fXrfSUxhgw2zXeoaXvt\"\n```. @yordis I saw your PR, do you still want me to do that?. Just tested it, I can confirm it works @yordis, thanks. ",
    "mattdevelops": "Found the issue, typo @ use Guardian, opt_app: :crypto_tracker. It was supposted to be use Guardian, otp_app: :crypto_tracker. ",
    "willsoto": "I am having the same issue. \nAs best as I can tell, resource_from_claims/1 is not being called despite it being defined in MyApp.Auth.Guardian module.\nhere is my pipeline:\n```elixir\ndefmodule MyApp.Auth.Pipeline do\n  @claims %{typ: \"access\"}\nuse Guardian.Plug.Pipeline,\n    otp_app: :my_app,\n    module: MyApp.Auth.Guardian,\n    error_handler: MyApp.Auth.ErrorHandler\nplug(Guardian.Plug.VerifySession, claims: @claims)\n  plug(Guardian.Plug.VerifyHeader, claims: @claims)\nplug(Guardian.Plug.LoadResource)\n  plug(Guardian.Plug.EnsureAuthenticated)\nend\n```\nThe MyApp.Auth.Guardian module is exactly what is on the README (with slight tweaks to actually get my resource). FWIW, I know subject_for_token/2 is being correctly called and returning the appropriate tuple.\nI'm still debugging since I figure it is something I am missing, but it's hard to know what.\nEDIT: So I finally got it working using plug(Guardian.Plug.VerifyHeader, claims: @claims, realm: \"Bearer\") But I couldn't get it working with Guardian.Plug.VerifySession. Not sure why or what I was missing, but hopefully #386 resolves some of the documentation issues with examples.. ```elixir\ndefmodule MyApp.Auth.Guardian do\n  require Logger\n  use Guardian, otp_app: :my_app\nalias MyApp.Accounts\ndef subject_for_token(user, _claims) do\n    # You can use any value for the subject of your token but\n    # it should be useful in retrieving the resource later, see\n    # how it being used on resource_from_claims/1 function.\n    # A unique id is a good subject, a non-unique email address\n    # is a poor subject.\n    sub = to_string(user.membership_id)\n    {:ok, sub}\n  end\ndef resource_from_claims(claims) do\n    # Here we'll look up our resource from the claims, the subject can be\n    # found in the \"sub\" key. In above subject_for_token/2 we returned\n    # the resource id so here we'll rely on that to look it up.\n    membership_id = claims[\"sub\"]\nuser = Accounts.get_user!(membership_id)\n{:ok, user}\n\nend\nend\n```\nThis is basically taken verbatim from the README with the extra functions removed (the compiler was saying that they would never be hit)\n  . I \"fixed\" mine by working around it but I don't understand the root cause.\nIt's fine to close and if I ever figure something out I can reopen. Thanks.\nOn Fri, Jan 19, 2018, 5:07 PM Sean Callan notifications@github.com wrote:\n\n@willsoto https://github.com/willsoto / @Yamilquery\nhttps://github.com/yamilquery are you still experiencing this issue or\ncan this be closed?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ueberauth/guardian/issues/434#issuecomment-359102936,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACqZMry9XetqtHeCwbcsWj7nXCXxzkIBks5tMRI-gaJpZM4RCyLU\n.\n. Originally I was trying to use session based or cookie based auth, but no\nmatter what I tried it didn't seem to work. Even if the cookie was issued\n(it could have been the default Phoenix cookie, I don't know) Guardian\ncouldn't seem to pick it up.\n\nFWIW, the only issue here might be a lack of documentation. I am new to\nPhoenix and Elixir (but have used many other frameworks and languages) and\nit just felt like I had a knowledge gap when I was reading the docs. Even\nwhen I followed the readme to the letter, I couldn't get it to work.\nThe workaround was to switch to header based auth and just put the token on\nthere.\nIt is honestly probably the case that my expectations around what session\nbased auth or cookie based were supposed to do is wrong, and so I felt the\nbehavior I was seeing was \"broken\" when it's just my understanding of it\nthat is wrong.\nAs far as I could tell, my code looked exactly like so many examples I\nfound on the web and this issue tracker, but still didn't work.\nI appreciate the follow up but I'm so far past it at this point (and I'm\nhonestly fine with the way it works) that I really don't mind if this issue\ngets closed.\nOn Fri, Jan 19, 2018, 5:17 PM Yordis Prieto notifications@github.com\nwrote:\n\n@willsoto https://github.com/willsoto could you elaborate on what was\nthe workaround so we could understand what you did and learn about it? Do\nreverse engineering.\nI am curious of what you call workaround because it means we need fix\nsomething.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ueberauth/guardian/issues/434#issuecomment-359105075,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACqZMuvl9MORRnrxhFeT_iKox1Rq5-Wbks5tMRSVgaJpZM4RCyLU\n.\n. \n",
    "hisapy": "Hello ladies and gentlemen. \nI'm having this same issue after upgrading from  0.14 to 1.0.1  but it was my fault.\nI have a GraphQL API built with Absinthe and to get a JWT I query a login mutation. In the upgrade I just copied the pipeline implementation and updated my router.  Basically the error was caused because in the new version you have to explicitly allow blank resource.\n```elixir\nWe need to allow blank is needed to accept a login mutation request to get the token.\nFuture requests with a valid token will load the resource correctly.\nplug(Guardian.Plug.LoadResource, allow_blank: true)\nIn the old version I was calling this plug without ensure: true\n```\nIn might be worth to add this caveat in the upgrading guides\n. I'll do it ASAP, probably tomorrow. ",
    "silverp1": "Sorry to necro this, but I seem to be having a similar issue here and I can't seem to figure out what exactly I am doing wrong.\nconfig.exs \nconfig :foo, Foo.Guardian,\n  issue: \"foo\",\n  secret_key: \"supersekrit\"\nFoo.Guardian\n```\ndefmodule Foo.Guardian do\n  use Guardian, otp_app: :foo\ndef subject_for_token(resource, _claims) do\n    { :ok, \"foo\"}\n    {:ok, to_string(resource.id)}\n  end\ndef resource_from_claims(claims) do\n    IO.inspect claims\n    user = %{}\n    IO.puts \"foo\"\n    { :error, :foobar_error }\n    case user do\n      nil ->\n        { :error }\n      _ ->\n      { :ok, %{id: user.id }}\n    end\n  end\nend\n```\n^ random junk added to confirm whether or not this is running at all\npipeline\npipeline :authorized do\n    plug :fetch_session\n    plug Guardian.Plug.Pipeline, module: Foo.Guardian,\n      error_handler: Foo.AuthErrorHandler\n    plug Guardian.Plug.VerifySession\n    plug Guardian.Plug.LoadResource\n  end\nAdding allow_blank: true to the LoadResource call does work, without it I am getting the same error the OP mentioned as I am using a temporary auth error handler from the tutorial. \nAny help would be super appreciated here. . ",
    "SofaKing18": "@yordis \nwhen variable mod is not set => nil.peek(token) raises error\nhttps://github.com/ueberauth/guardian/blob/21622bf30328ef92750dcc5459829016ea4cb93d/lib/guardian.ex#L664. Error is not actual for master branch, waiting for new release, please :). ",
    "joshuataylor": "https://github.com/ueberauth/guardian/blob/master/upgrade_guides/0.14.to.1.0.md\nAnd the CHANGELOG as well, though it's missing removed functions.. I'm in the middle of a migration from 0.14 to 1.0, and the guide seems great so far :+1:. ",
    "johnnyji": "@yordis Thank you for the amazingly detailed explanation! I can't believe I didn't think of just resetting the secret key haha. ",
    "jstoeffler": "Yes, sorry for the confusion I updated the code.. Thanks, I'm not very confident with signatures in elixirs and pattern matching.\nHowever I still get the same token after it has been refreshed, is that expected?. Oh my bad, it's just the beginning of the token which is the same. The reste is different.\nThanks for your help!. ",
    "pedrovieira": "hey @hassox, thanks for the mention, but I think you were trying to say @pedromvieira \ud83d\ude1b . ",
    "pedromvieira": "@hassox thanks.\nI removed key from Auth Pipeline and it's working. :)\nI will try now the new bitwise permissions.\nPIPELINE\n```\ndefmodule Phishx.Guardian.AuthPipeline do\n  @moduledoc \"\"\"\n  Guardian Auth Pipeline Settings.\n  \"\"\"\nuse Guardian.Plug.Pipeline,\n      otp_app: :phishx,\n      module: Phishx.Guardian,\n      error_handler: Phishx.Guardian.ErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.LoadResource, ensure: true\n  plug Guardian.Plug.EnsureAuthenticated\nend\n```\nROUTER\n```\n...\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\npipeline :app do\n    plug Plugs.Subdomain\n    plug NavigationHistory.Tracker\n    plug SetLocale, gettext: PhishxWeb.Gettext, default_locale: \"en-US\"\n    plug Plugs.Audit\n  end\npipeline :browser_session do\n    plug Phishx.Guardian.AuthPipeline\n    plug Plugs.AuthenticateUser\n  end\n...\n```. With a simpler permission model, same thing occurs, manually works but plug dont.\nDo we need to write our plug?\nTOKEN_MODULE\nuse Guardian, otp_app: :phishx,\n                secret_key: @key,\n                permissions: %{\n                  default: [:account, :group, :mgmt],\n                  account: [:read, :export, :write, :delete, :dashboard],\n                  group: [:read, :export, :write, :delete, :dashboard],\n                  mgmt: [:read, :export, :write, :delete, :dashboard],\n                }\nCLAIM\n%{\"aud\" => \"phishx\", \"exp\" => 1517416805,\n  \"extra\" => %{\"id\" => 1, \"subdomain\" => \"aaa\", \"type\" => \"user\"},\n  \"iat\" => 1514997605, \"iss\" => \"phishx\",\n  \"jti\" => \"729af38d-8251-4523-af24-8e5611b990f6\", \"nbf\" => 1514997604,\n  \"perms\" => %{\"mgmt\" => 31}, \"sub\" => \"user|aaa|1\", \"typ\" => \"user\"}\nDECODE\nall = Phishx.Guardian.decode_permissions(claims)\n%{mgmt: [:dashboard, :delete, :export, :read, :write]}\ntest = %{mgmt: [:write]}\n%{mgmt: [:write]}\nPhishx.Guardian.any_permissions?(all, test)\ntrue\n. Just to make it clear, with this simple custom plug works.\nIs there a way to do it with vanilla guardian?\nPLUG EXAMPLE\n```\ndefmodule Phishx.Guardian.Plug.Auth do\n  @moduledoc \"\"\"\n  Guardian Auth Plug.\n  \"\"\"\nimport Plug.Conn\nalias Phishx.Guardian\n  alias Phishx.Guardian.ErrorHandler\ndef init(options), do: options\ndef call(conn, {cmd, test} = options) do\n    permissions =\n      conn.private.guardian_default_claims[\"perms\"]\n      |> Guardian.decode_permissions()\n    result =\n      case cmd do\n        :one_of ->\n          Guardian.any_permissions?(permissions, test)\n        :ensure ->\n          Guardian.all_permissions?(permissions, test)\n      end\n    auth(conn, result)\n  end\ndefp auth(conn, true = result), do: conn\n  defp auth(conn, _), do: ErrorHandler.auth_error(conn, {:unauthorized, MODULE}, [])\nend\n```\nCONTROLLER CALL\n```\n  plug Phishx.Guardian.Plug.Auth,\n    {:one_of, %{ account: [:super], group: [:super], mgmt: [:read]} }\n    when action in ~w(index)a\ndef index(conn, _params) do\n    render(conn, \"index.html\")\n  end\n```. @doomspork Yes. No luck with Guardian.Plug.. ",
    "edouardmenayde": "@oskar1233 I agree it might be best in the readme. Do I create a new PR or do I amend the existing commit ?\n  . Hi!\nIt's been some days since the last comment thus I think if there's any strong insight against adding that to the readme It would have been raised by now. I took the initiative to amend my last commit and move the documentation to the readme.. @yordis I fixed the typo and gave some more context to the test. I tried giving much more context with the controller etc. but It becomes quickly more of a blog post than a little hint to test guardian.. @Moggers really happy my headache saved you from having one :). @doomspork I fixed my mistake, this should be ok to merge :-). Oh I will correct that :). ",
    "Moggers": "This just saved me from hours of headache. I hadn't used the Authorization header before and didn't realize that it had to look like authorization: <type>: <token>. Was digging through the suggested documentation and saw an example with a put_req_header call. ",
    "axelson": "Cool, thanks!. ",
    "denvaar": "From what I understand, revoke only works if you are storing the tokens somewhere, such as with GuardianDB. ",
    "tarzan": "I think I'm having similar issues. \nFrom the README:\n```ex\nremove from session (if fetched) and revoke the token\nconn = MyApp.Guardian.Plug.sign_out(conn)\n```\nHowever, revoke is indeed never called. So, that seems to be an error in the documentation.\nI am trying to hook up GuardianDB and follow the instructions there. It instructs to just put the GuardianDB interface on the on_revoke-hook like this:\nex\n  def on_revoke(claims, token, _options) do\n    with {:ok, _} <- Guardian.DB.on_revoke(claims, token) do\n      {:ok, claims}\n    end\n  end\nIn my app I just call the MyApp.Guardian.Plug.sign_out(conn) and the on_revoke is never triggered, therefore never deleting a persisted token in the database...\n@doomspork would a PR fixing this be appreciated? Or is this wanted behaviour?. Should be solved by #458.. @hassox I applied the changes you requested :). Rebased and updated the changelog (added my previous PR to the changelog as well, hope you don't mind).. ",
    "mirago": "Hey guys, didn't want to open a new issue for this, but even after reading PR by @tarzan and installing guardian 1.01, the revoke callback is never called for me. I'm wondering what am I missing. Can you guys confirm it's actually being called? thanks\nEdit: I think I got confused, looks like that stuff was not released yet.. When can we expect a release?. thanks for your reply, I will wait for the release, until then I am calling revoke manually and all works perfectly. \ud83d\udc4d . ",
    "bjunc": "Yeah, I realize this isn't a technical limitation, or security issue, etc..  Rather, since the documentation changed, maybe there was a \"best practice\" I wasn't aware of \u2013 especially because I would have though User:1 would be the best practice.  Anyway, thanks for the response.  I had ultimately come to the same conclusion, and stuck with the User:1 convention:\n```elixir\nsummarized for brevity\ndef subject_for_token(%User{} = resource, _claims) do\n  {:ok, \"User:\" <> to_string(resource.id)}\nend\ndef resource_from_claims(%{\"sub\" => \"User:\" <> id}) do\n  {:ok, Repo.get(User, id)}\nend\n```\n. ",
    "delameko": "Thanks for the response.  I've got a workaround in place for the moment, so its not a big issue.\nYou folks have done a fantastic job with version 1.0.  I've just updated from 0.14 and moved all my authentication code to a separate app in my umbrella, and this has been the only issue I had.  And its only an issue for me because of the code separation, as I want my api app and web app to pass in their own respective error_handlers, but I don't want to reference Guardian directly in those apps.  . Yeah, I've sort of got that now.  Because I've got an umbrella, and auth as a separate app, I was hoping I could do:\nElixir\npipeline :authenticate do\n  plug AuthApp.Pipeline, error_handler: MyApp.AuthErrorHandler\nend\nAs I didn't want to add Guardian as a dependency of MyApp.  At the moment, as a workaround, I've got:\n```Elixir\npipeline :authenticate do\n  plug AuthApp.plug_pipeline(), error_handler: MyApp.AuthErrorHandler\n  plug AuthApp.Pipeline\nend\nauthapp.ex\ndef plug_pipeline() do\n  Guardian.Plug.Pipeline\nend\n```\nIt's not ideal, it'll do for now.. ",
    "sebastialonso": "Absolutely not. I can use them. :)\nIt just happened that I took a look at the code and there seems to be code\nfor managing both the week and weeks symbol, so it was a situation I felt I\nhad to report. But yeah, just use the days symbol.\nOn 31 Jan 2018 1:39 pm, \"Sonny Scroggin\" notifications@github.com wrote:\n@sebastialonso https://github.com/sebastialonso is there a reason you\ncan't use {1, :year} or {365, :days}?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ueberauth/guardian/issues/452#issuecomment-361991413,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADVOTflSIBCokrpt6h5-AW9fVCjP8MA_ks5tQJcigaJpZM4Ryc5G\n.\n. That may be it. Thanks.\nOn 31 Jan 2018 1:48 pm, \"Sonny Scroggin\" notifications@github.com wrote:\n\n@sebastialonso https://github.com/sebastialonso I think what you may\nhave seen is that v1.0 supports :week and :weeks but v0.14.x does not.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ueberauth/guardian/issues/452#issuecomment-361994483,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADVOTaSV8ses3HThup0ijYdK2cAhBRI5ks5tQJlFgaJpZM4Ryc5G\n.\n. \n",
    "tsurupin": "@yordis Thanks.\nI could create the custom token. I paste code snippets.\n```\n  @aud \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\"\n  @one_hour_in_unix 60 * 60\n  def create_token(user) do\n    current_time = DateTime.to_unix(DateTime.utc_now)\n    one_hour_later = current_time + @one_hour_in_unix\ncustom_claims = %{\n  iss: System.get_env(\"FIREBASE_SERVICE_ACCOUNT_EMAIL\"),\n  sub: System.get_env(\"FIREBASE_SERVICE_ACCOUNT_EMAIL\"),\n  aud: @aud,\n  iat: current_time,\n  exp: one_hour_later,\n  uid: user.uid\n}\n\nwith {:ok, jwt, full_claims} <- Api.Guardian.encode_and_sign(user, custom_claims)\ndo\n  {:ok, user.uid, jwt}\nelse\n  {:error, reason} -> {:error, reason}\n  _ -> {:error, \"unknown\"}\nend\n\nend\n-confix.ex\nconfig :api, Api.Guardian,\n  allowed_algos: [\"RS256\"],\n  verify_module: Api.Guardian.JWT,\n  issuer: System.get_env(\"FIREBASE_SERVICE_ACCOUNT_EMAIL\"),\n  ttl: {1, :hours},\n  secret_key: {Api.GuardianSecretKey, :get_key, []}\n\n\nguardian_secret_key.ex\ndefmodule Api.GuardianSecretKey do\n  def get_key() do\n    JOSE.JWK.from_pem_file(System.get_env(\"SECRET_PEM_FILE_PATH\"))\n  end\nend\n\n\nguardian.ex\ndefmodule Api.Guardian do\n  use Guardian, otp_app: :api\n\n\ndef subject_for_token(resource, claims) do\n    {:ok, claims[\"sub\"]}\n  end\ndef subject_for_token(, ) do\n    {:error, :reason_for_error}\n  end\ndef resource_from_claims(_claims) do\n    {:error, :reason_for_error}\n  end\nend\n```. ",
    "arunvelsriram": "Oops, my bad. Thanks!. ",
    "pedroassumpcao": "@yordis yes, I saw it later, mine has the mix format config that maybe can be added to #454. I can close this, let me know.. ",
    "nicolasblanco": "Basically I was advised on the Elixir slack channel to put the name of the resource in claims[sub] and use pattern-matching, like:\ndef resource_from_claims(%{\"sub\" => \"User:\" <> user_id}) do # .... Oh crap, basically I needed to write :\nconn = Guardian.Plug.sign_in(conn, user, %{}, key: :user)\notherwise the key was added to the claims instead of the options. My god that was complicated to debug...\n. ",
    "mumughal": "Yeah, sure! I get a list of public keys from Auth0 to decode their Rs256 signed JWT. Public keys look something like this:\n{\"keys\":\n[{\"alg\":\"RS256\",\n\"kty\":\"RSA\"\n\"use\":\"sig\",\n\"x5c\":[\"___cert___\"],\n\"n\":\"______\",\n\"e\":\"AQAB\",\n\"kid\":\"keyid1\",\n\"x5t\":\"_______\"},\n{\"alg\":\"RS256\",\n\"kty\":\"RSA\"\n\"use\":\"sig\",\n\"x5c\":[\"___cert___\"],\n\"n\":\"______\",\n\"e\":\"AQAB\",\n\"kid\":\"keyid2\",\n\"x5t\":\"_______\"}]}\nNow the JWT header has the kid for the public signing key of the JWT that should be used for this verifying JWT. For example it looks like this:\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"kid\": \"keyid1\"\n}\nNow I have to make sure that guardian module is given the right key, right? Is there any support for this in Guardian?\nOtherwise the solution I have to consider is that every JWT received should be decoded first just to get the kid explicitly, which is not a clean solution :/ What would you recommend?. This issue is referring to a similar problem. But my issue is a bit different. I am talking about decoding a token from a third party service where I have access only to the asymmetric public keys. Please check out the steps for validating RS256 JWT. @hassox Thank you for addressing the issue. It looks like this PR should be able to fix my problem.  :). Perfect! I have already started working with it. Looks perfect! :). ",
    "mikemorris": "\nOn the other hand we could pull out the encoding/decoding part into a behaviour interface and have a bitstring, text, JSON encoders.\n\nThis sounds like a great proposal, I'd love to see an interface similar to https://www.npmjs.com/package/express-jwt-permissions supported (space-delimited string and/or array of strings).. ",
    "fdbeirao": "Never mind. I managed to get this to work by using Joken and writing my own small plug. \nKudos Guardianeers, keep up the great work!. ",
    "apognu": "Does fetch_signing_secret only returns the secret? Signing tokens with different secrets, but not being able to identify which one from the token defeats the purpose, somewhat.\nfetch_signing_secret should return the secret and a key id that would appear in the generated token header as a kid claim.\nRight now, there is no way, from the token headers passed to fetch_verifying_secret, to fetch the key used to sign a token.. Thanks for replying on a closed issue.\nI agree that the default behavior should be a naive one, and while Guardian does allow me to specify custom secret_fetcher and token_verify_module (if there is another plugging point, maybe I missed it), I believe they lack specific features that would be useful:\n\nfetch_verifying_secret passes in the JWT headers, so we are able to look for the proper key\nfetch_signing_secret has nothing to do with the JWT headers, so we cannot set, for instance, the kid\n\nMy specific use-case aside, I believe there is a symmetry issue between those two functions, where one can use the values in the headers and the second cannot set those values.\nOn the same note (but not directly related to this issue), in custom token_verify_modules, the token header is not passed to the verify_claim methods, so we still cannot map any verification rules to the key that is used (for example, \"a token signed by a specific key can only include the sub to which the key belongs to\").. @hassox @scrogson I could give it a go, but by the time I familiarize myself with the structure of the project, it could be some time. When is the next release scheduled?\nWithout having looked too closely at the code, this would require:\n\npassing the token headers left and right, so some or all headers are available at different steps of the processing (including in token_verify_module;\nallowing the secret_fetcher to modify the header claims (or a subset thereof; should we allow this to dynamically determine the alg, on top of the kid and secret key?).\n\nThose are my thoughts right now, but I have not spent a lot of time working on it. And I'll be frank, I have no idea how much work that would represent on Guardian's code base.\n. ",
    "shahryarjb": "Hi @hassox and Thank you,\nI want to set plug Guardian.Permissions.Bitwise, ensure: %{default: [:public_profile], user_actions: [:books]} after plug Guardian.Plug.EnsureAuthenticated , but I have had an error 500 when I put this . \nMy code is like this : \nelixir\n  plug Guardian.Plug.VerifySession, claims: @claims\n  plug Guardian.Plug.VerifyHeader, claims: @claims, realm: \"Bearer\"\n  plug Guardian.Plug.EnsureAuthenticated\n  plug Guardian.Permissions.Bitwise, ensure: %{default: [:public_profile], user_actions: [:books]}\n  plug Guardian.Plug.LoadResource, ensure: true\nerror : \n```\nHTTP/1.1 500 Internal Server Error\nServer: Cowboy\nDate: Tue, 06 Mar 2018 18:04:45 GMT\nContent-Length: 57966\nContent-Type: text/html; charset=utf-8\nCache-Control: max-age=0, private, must-revalidate\nx-request-id: qnke9pr2it5km31ih7gn1b7b2m9jnbje\n```\nIs this a problem with the direct of code in this section? like this ? or ?\nelixir\n{:ok, token, claims} = ApiTrangell.Guardian.encode_and_sign(user, %{some: \"claim\", userid: 2, admin: 2, pem: %{default: [:public_profile], user_actions: [:books]}}, token_type: \"access\",ttl: {99, :weeks})\n. Hi @hassox ,\nI added build_claims but I don't know how to create ACL . pleas see the link  : \nhttps://github.com/shahryarjb/ESOGIP/blob/master/lib/api_trangell/auth/token.ex#L17\nhow do I create the token permissions in build claims hook ? \nsorry for this and thank you for helping me ! \ud83c\udf39 . Hi @hassox ,  Thank you so much.\nI have seen https://medium.com/@zacharykuhn/setting-up-a-phoenix-app-with-guardian-1-0-411ff3195adb before, but it didn't speak about permissions. so I was traying with your document.\n\nI've solved the problems which you said and thank you again. after fix it , I tried to get a token , then I sent request to api/users/sign-in and I succeeded to get a token, but now,  how do I test which token is true or not? Is this {perms = %{default: [:public_profile], user_actions: [:books]}} available in my token or not?  because I get nothing when write these code in `iex -S mix phx.server: \n```elixir\ntoken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6MTIsImF1ZCI6ImFwaV90cmFuZ2VsbCIsImV4cCI6MTU4MDM2MzE3OCwiaWF0IjoxNTIwNDg3OTc4LCJpc3MiOiJhcGlfdHJhbmdlbGwiLCJqdGkiOiIzM2NmNTE4MS0xYzFjLTQzMDktODNiOS02M2Y0ZmQwMmQ1ZjkiLCJuYmYiOjE1MjA0ODc5NzcsInNvbWUiOiJjbGFpbSIsInN1YiI6IjEiLCJ0eXAiOiJhY2Nlc3MifQ.3BQxVZoFWyr_-pYSF1r5IO44SSp7q2zhtW8Bdg1611o\"\n{:ok, claims} = ApiTrangell.Guardian.decode_and_verify(token)\nOr\nclaims |> ApiTrangell.Auth.Token.decode_permissions_from_claims |> ApiTrangell.Auth.Token.all_permissions?(%{default: [:public_profile], user_actions: [:books]})\nOr\niex(6)> claims |> ApiTrangell.Auth.Token.decode_permissions_from_claims \n%{}    \n```\nI think the access is not in Token. my project's source was updated.\nit's my pleasure to talk with you, Thanks.. @yordis it's my elixir project under umbrella\ndefp deps do\n    [\n      {:ecto, \"3.0.7\"}, #1\n      {:ecto_sql, \"~> 3.0\"}, #2\n      {:postgrex, \">= 0.0.0\"}, #3\n      {:comeonin, \"~> 5.0\"}, #4\n      {:bcrypt_elixir, \"~> 2.0\"}, #5\n      {:scrivener_ecto, \"~> 2.0\"}, #6\n      {:guardian, \"~> 1.2\"}, #7\n      {:httpoison, \"~> 1.5\"}, #8\n      {:jose, \"~> 1.9\"}, #9\n      {:plug, \"~> 1.7\"}\n    ]\nHave I mistaken anything?. @yordis I didn't understand what you told me, sorry, but you need the error?\nsee the pic plz\n\n. It's umbrella project issue again,\nI delete my build and delete all of sup project deps and this was fixed. after 8 hours :( \nThank you @yordis . ",
    "zapient": "Sure. Would you like the documentation to match the implementation or the other way around? . ",
    "davepersing": "@hassox - Yep, can do.  Will jump on and ping you there.  Thanks!. @expelledboy - Guardian doesn't support JWE directly, so I wrote the extension to implement JWE with Guardian.  Repo is here:  https://github.com/davepersing/guardian_jwe\nNo doubt there are improvements to be made to the lib. :)  It's using the JOSE JWE functions to implement a JWE module for usage within Guardian.  \nLet me know if I can answer questions about it.  \nCheers, \nDave. @doomspork - I am absolutely open to it.\nI can't dedicate to full-time assistance (full-time job and a side-gig), but I'm absolutely happy to help out wherever I can!  . Will do directly after lunch! . @doomspork - Re: Twitter - it's @llamaindustries. \nRepository is transferred.  Added all the teams to the repo.  \nThank you, sir!. ",
    "expelledboy": "Hey guys, I want to use JWE to pass around sensitive user profile information. Based off this thread, can I assume guardian doesnt support JWE? Does the underlying JOSE library not support JWE?\nOtherwise @hassox can your changes not be merged into guardian?. Sorry I understood that it was a fork of guardian, read through README now \ud83e\udd23  @davepersing thank you for efforts!. ",
    "InteNs": "well, it's a test that checks if after deleting the  user the show page returns a 404.\nI created a workaround by not using the same conn data\n```ex\ntest \"deletes chosen user\", %{conn: conn} do\n      user = insert(:user)\n      delete_conn = delete conn, user_path(conn, :delete, user)\n      assert response(delete_conn, 204)\n  get_conn = get conn, user_path(conn, :show, user)\n  assert response(get_conn, 404)\nend\n\n```\nnot sure if this is the best way to fix this but it works.. yeah, although the same conn object was valid before (in the delete request) so something must have changed when that request was sent (not suprised by that to be honest.\nthe only reason why i even posted this was because this convention (using the same conn right after the request to check if it really is deleted) was generated with the standard mix generator.\n. yes that's basically what I ended up doing, thanks for thinking with me, I'll close the issue.. ",
    "hlhr": "Just to help out, the option is used to define a ErrorHandler-Module. There is not predefined module in guardian but you can find an example here or a definition under ### Error handler in the same file.. Maybe I can help you out (I'm not sure if this is 100% correct). You don't have to put use Guardian.Plug on top if the file. Replace that line with alias Rumble.Auth.Guardian and call sign_in with Guardian.Plug.sign_in(user).\nThat worked in my case: https://github.com/hlhr/phoenix_authentication/blob/master/lib/phoenix_authentication_web/controllers/auth_controller.ex .. Maybe I can help you out. I guess get_user! is generated by phoenix in the context? If so, the function will use Repo.one! which raise a Ecto.NoResultsError which get catched by phoenix.\nIf you want to return unauthorized you have to check if the user exists and if not, return the tuple {:error, :unauthorized}. You can find sample code for that in guardian.ex and accounts.ex.. Is plug Olist.Guardian.AuthPipeline.Browser the pipeline? If so, please try out to remove the plug ensure_auth and add the line plug Guardian.Plug.EnsureAuthenticated into the pipeline (sample).. case Users.get_user!(id) do\n      nil -> {:error, :unauthorized}\n      resource -> {:ok,  resource}\nend\nreturns a tuple\n``\ndef resource_from_claims(claims) do\n    # Here we'll look up our resource from the claims, the subject can be\n    # found in the\"sub\"key. Inabove subject_for_token/2` we returned\n    # the resource id so here we'll rely on that to look it up.\n    id = claims[\"sub\"]\n    resource = Users.get_user!(id)\n{:ok,  resource}\n\nend\n``\nGets the return value (in that case a tuple) and returns the tuple{:ok, resource}(could be{:ok, {:error, :unauthorized}}or{:ok,  resource}). Try to change the return{:ok,  resource}to justresource`.. Did you define a guardian pipeline and configure it correctly in the config? You can find an example for an API with Guardian on my github account or additional infos in the documentation.. ",
    "voger": "Thanks. I thought there was indeed somewhere a module with that name and I couldn't find it.. ",
    "pauldoerwald": "I too am getting token errors. I have an RS256 token (generated by Auth0) which is happily accepted by https://jwt.io but that Guardian refuses to process. When I tried generating an RS256 key (by setting allowed_algos: [\"RS256\"] as @MeterSoft did above, Guardian responded with:\nInteractive Elixir (1.6.4) - press Ctrl+C to exit (type h() ENTER for help)\niex(1)> {:ok, t, fc} = Clockk.Guardian.encode_and_sign(%{name: \"Paul\", id: 1})                                                   \n** (ErlangError) Erlang error: {:not_supported, [:RS256]}                                                                            \n    (jose) src/jose_jwk_kty_oct.erl:191: :jose_jwk_kty_oct.jws_alg_to_digest_type/1                                                  \n    (jose) src/jose_jwk_kty_oct.erl:122: :jose_jwk_kty_oct.sign/3\n    (jose) src/jose_jws.erl:311: :jose_jws.sign/4\n    (jose) src/jose_jwt.erl:171: :jose_jwt.sign/3\n    (guardian) lib/guardian/token/jwt.ex:168: Guardian.Token.Jwt.create_token/3\n    (guardian) lib/guardian.ex:754: Guardian.returning_tuple/1\n    (guardian) lib/guardian.ex:581: Guardian.encode_and_sign/4\n\nCould there be a bug here? Auth0 recommends using RS256 keys, but maybe I should use HS512, which Guardian accepts without complaint?\n. I just realized something: RS256 uses public keys, which explains why the secret key I have doesn't work... I need to use my Auth0 public key... I think. Maybe HS256/HS512 is the right approach.... As always happens, as soon as I start asking for help, I figure it out.\nThe problem above was how I was specifying the secret_key. It should be something more like:\nconfig :clockk, Clockk.Guardian,\n      allowed_algos: [\"HS512\"],\n      issuer: \"clockk.auth0.com\",\n      secret_key: fn ->\n        \"-----BEGIN CERTIFICATE-----\n    certificate goes here. Ordinarily you would keep this in a file which you would load, but I'm putting it inline for simplicity.\n    -----END CERTIFICATE-----\n    \"\n        |> Kernel.||(\"\")\n        |> String.replace(\"\\n\", \"\\n\")\n        |> JOSE.JWT.from_pem\n      end\nWith this secret_key, things start to work. However, because of the argument in https://github.com/ueberauth/guardian/issues/152 which points out that RSA keys are VERY slow and thus inappropriate for Bearer authorization, I'm switching to HS256 which works much more like what @MeterSoft above did.\nSo with that, I'm dropping my part of this issue, and I suggest that this is not an issue at all and should be closed.. ",
    "jsangilve": "Thanks for your reply @yordis.\nYes, as I mentioned in the original post, I'm implementing this callback in MyGuardian module.\nSorry, I still don't understand what's the purpose of calling it twice in the code. By default, this callback just return {:ok, claims}. So, even if I don't implement it in MyGuardian module, it's still called twice.\nWouldn't be enough ONLY to call this function at guardian/lib/guardian.ex?\nhttps://github.com/ueberauth/guardian/blob/72df24d7e27e0a13ee7538c9d9537ae19ab60aff/lib/guardian.ex#L619\n. @yordis yes, I understand that. I'm implementing the callback because I need to do some custom verification. The problem is that this custom verify_claims callback is called twice while running the app. \nSo, my question is: the reason why a custom verify_claims callback gets called twice seems to be because Guardian do it by itself (as I explained in the first post). Is this a bug or intended behavior?\nThis is not a question about my code, but about Guardian's behavior.. Thx @yordis. I improved verify_literal_claims removing the filtering step and putting everything within a reduce.\nCI was failing because of formatting on verify_test. Shouldn't happen anymore.. @yordis done.  @yordis, Do you guys want something else here or is it ready to be merged? Thx. ",
    "flomaster9": "This work !! thanks ) I will close issue. ",
    "MeterSoft": "made to this\ncase Users.get_user!(id) do\n      nil -> {:error, :unauthorized}\n      resource -> {:ok,  resource}\nend\nbut very strange. It not return any errors and render my page\n```\nuse Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.LoadResource, ensure: true, allow_blank: true\n```\npipeline :browser_session do\n    plug Olist.Guardian.AuthPipeline.Browser\nend\npipeline :ensure_auth do\n    plug Guardian.Plug.EnsureAuthenticated\nend\n```\nscope \"/user\", OappWeb do\n    pipe_through [:browser, :browser_session, :ensure_auth]\nresources \"/postings\", PostingsController\n\nend\nwhen i go to /user/postings it should return unauthorized if user not found in database.\ndefmodule Olist.Guardian.AuthPipeline.Browser do\n  use Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.EnsureAuthenticated\n  plug Guardian.Plug.LoadResource, ensure: true, allow_blank: true\nend\n```\nDoes not work.\ni logged in then remove user from database and after reload page. So in this case\nplug Guardian.Plug.EnsureAuthenticated\nnot works and page try to load but can not find resource. @yordis \n```\n%Plug.Conn{adapter: {Plug.Adapters.Cowboy.Conn, :...}, assigns: %{},\n before_send: [#Function<4.98464331/1 in Phoenix.Controller.fetch_flash/2>,\n  #Function<0.112984571/1 in Plug.Session.before_send/2>,\n  #Function<1.26648146/1 in Plug.Logger.call/2>,\n  #Function<0.83265233/1 in Phoenix.LiveReloader.before_send_inject_reloader/2>],\n body_params: %{},\n cookies: %{\"__stripe_mid\" => \"0d8030ed-d159-483d-a8e4-41d728edc734\",\n   \"_olist_key\" => \"xxx\",\n   \"browser.timezone\" => \"Europe/Helsinki\"}, halted: false, host: \"localhost\",\n method: \"GET\", owner: #PID<0.5268.0>, params: %{},\n path_info: [\"user\", \"postings\", \"new\"], path_params: %{},\n peer: {{127, 0, 0, 1}, 59478}, port: 4000,\n private: %{OlistWeb.Router => {[], %{}},\n   :guardian_default_claims => %{\"aud\" => \"olist\", \"exp\" => 1525289954,\n     \"iat\" => 1522870754, \"iss\" => \"olist\",\n     \"jti\" => \"186cb55e-f0cd-4528-8fcf-a2613b7655ea\", \"nbf\" => 1522870753,\n     \"sub\" => \"1\", \"typ\" => \"access\"},\n   :guardian_default_token => \"xxx\",\n   :guardian_error_handler => Olist.AuthErrorHandler,\n   :guardian_module => Olist.Guardian, :phoenix_endpoint => OlistWeb.Endpoint,\n   :phoenix_flash => %{}, :phoenix_format => \"html\",\n   :phoenix_pipelines => [:browser, :browser_session, :ensure_auth],\n   :phoenix_router => OlistWeb.Router,\n   :plug_session => %{\"guardian_default_token\" => \"xxx\"},\n   :plug_session_fetch => :done}, query_params: %{}, query_string: \"\",\n remote_ip: {127, 0, 0, 1},\n req_cookies: %{\"__stripe_mid\" => \"0d8030ed-d159-483d-a8e4-41d728edc734\",\n   \"_olist_key\" => \"xxx\",\n   \"browser.timezone\" => \"Europe/Helsinki\"},\n req_headers: [{\"host\", \"localhost:4000\"},\n  {\"user-agent\",\n   \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0\"},\n  {\"accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8\"},\n  {\"accept-language\", \"en-US,en;q=0.5\"}, {\"accept-encoding\", \"gzip, deflate\"},\n  {\"referer\", \"http://localhost:4000/user/postings\"},\n  {\"cookie\",\n   \"browser.timezone=Europe/Helsinki; __stripe_mid=0d8030ed-d159-483d-a8e4-41d728edc734; _olist_key=xxx\"},\n  {\"connection\", \"keep-alive\"}, {\"upgrade-insecure-requests\", \"1\"},\n  {\"cache-control\", \"max-age=0\"}], request_path: \"/user/postings/new\",\n resp_body: nil, resp_cookies: %{},\n resp_headers: [{\"cache-control\", \"max-age=0, private, must-revalidate\"},\n  {\"x-request-id\", \"xxx\"},\n  {\"x-frame-options\", \"SAMEORIGIN\"}, {\"x-xss-protection\", \"1; mode=block\"},\n  {\"x-content-type-options\", \"nosniff\"}, {\"x-download-options\", \"noopen\"},\n  {\"x-permitted-cross-domain-policies\", \"none\"}], scheme: :http,\n script_name: [],\n secret_key_base: \"xxx\",\n state: :unset, status: nil}\n. ensure_authenticated is check only session is present. But it should also try load resource and if it not loaded should return not authorized. If i remove allow_blank option it will be return user not found. But some page need to allow blank resource so i think ensure_authenticated should provide work with load resource to. if i do\ndefmodule Olist.Guardian.AuthPipeline.Browser do\n  use Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.LoadResource, ensure: true, allow_blank: true\nend\n\npipeline :browser_session do\n    plug Olist.Guardian.AuthPipeline.Browser\n  end\npipeline :ensure_auth do\n    plug Guardian.Plug.LoadResource, ensure: true\n    plug Guardian.Plug.EnsureAuthenticated\n  end\n\nscope \"/user\", OlistWeb do\n    pipe_through [:browser, :browser_session, :ensure_auth]\nresources \"/postings\", PostingsController\n\nend\n\nscope \"/\", OlistWeb do\n    pipe_through [:browser, :browser_session] # Use the default browser stack\nget \"/\", PageController, :index\n\nend\n```\nin this case if remove user from database it return \n{\"message\":\"no_resource_found\"}\nbut i double include plug Guardian.Plug.LoadResource, ensure: true\nAny way i think 'ensure_authenticated' should do this\n. as you can see i should have ability to visit root path without auth. But if user present it should load it.\nWhen i visit /user it should check auth and always load user. If user not logged in or not found it should return error.. i rewrite my code to this\n```\ndefmodule Olist.Guardian.AuthPipeline.Browser do\n  use Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.LoadResource, allow_blank: true\nend\ndefmodule Olist.Guardian.AuthPipeline.BrowserAuth do\n  use Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.EnsureAuthenticated\n  plug Guardian.Plug.LoadResource\nend\n```\nrouter\n```\npipeline :browser_session do\n    plug Olist.Guardian.AuthPipeline.Browser\n  end\npipeline :browser_auth_session do\n    plug Olist.Guardian.AuthPipeline.BrowserAuth\n  end\nscope \"/\", OlistWeb do\n    pipe_through [:browser, :browser_session] # Use the default browser stack\nget \"/\", PageController, :index\n\nend\nscope \"/user\", OlistWeb do\n    pipe_through [:browser, :browser_auth_session]\nresources \"/postings\", PostingsController, except: [:show]\n\nend\n```\nand now if user not logged in it return auth error\nand if user not found in database it return resource_not_found error\nso it good for me\nso we should configure different guardian pipeline for each routes. EnsureAuthenticated should be use only with LoadResource without options allow_blank: true because EnsureAuthenticated do not know anything about user in database. When we check that user is logget in we should make sure that it is stil exist in database and if is not than should return error authentificate. For my example this works. We added for not security section plug Guardian.Plug.LoadResource, allow_blank: true so it just try load user if it logged in. And added to security section\nplug Guardian.Plug.EnsureAuthenticated\nplug Guardian.Plug.LoadResource\nto make sure that user stil valid. \nAlso we should include use Guardian.Plug.Pipeline, otp_app: :app to all pipeline scopes.\nBut now i have very strange issue.\nWhen i deploy app to production it works well but when it do another developer for own machine when we visit root path app return error {error: resource_not_loaded} and it is strange because root path has only plug Guardian.Plug.LoadResource, allow_blank: true. Any think?. @yordis but what about this?\nWhen i deploy app to production it works well but when it do another developer for own machine when we visit root path app return error {error: resource_not_loaded} and it is strange because root path has only plug Guardian.Plug.LoadResource, allow_blank: true. Any think?. @yordis i do not have plug Guardian.Plug.EnsureAuthenticated for root path\nmy pipeline\n```\ndefmodule Olist.Guardian.AuthPipeline.Browser do\n  use Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.LoadResource, allow_blank: true\nend\n```\n. %Olist.Users.User{__meta__: #Ecto.Schema.Metadata<:loaded, \"users\">,\n favorites: #Ecto.Association.NotLoaded<association :favorites is not loaded>,\n global_id: \"111\", id: 1,\n inserted_at: ~N[2018-06-08 12:28:45.935702],\n postings: #Ecto.Association.NotLoaded<association :postings is not loaded>,\n refresh_token: nil,\n remote_favorites: #Ecto.Association.NotLoaded<association :remote_favorites is not loaded>,\n updated_at: ~N[2018-06-08 12:28:45.939106], username: \"name\"}\n``\ndef resource_from_claims(claims) do\n    # Here we'll look up our resource from the claims, the subject can be\n    # found in the\"sub\"key. Inabove subject_for_token/2` we returned\n    # the resource id so here we'll rely on that to look it up.\n    id = claims[\"sub\"]\ncase Olist.Users.get_user(id) do\n  nil -> {:error, :unauthorized}\n  resource -> {:ok,  resource}\nend\n\nend\n. @yordis\ndefmodule Olist.Guardian.AuthPipeline.BrowserAuth do\n  import Olist.Auth, only: [load_current_resource: 2]\nuse Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.EnsureAuthenticated\n  plug Guardian.Plug.LoadResource\n  plug(:load_current_resource)\nend\npipeline :browser_session do\n    plug Olist.Guardian.AuthPipeline.Browser\nend\n. looks like that expires token not works on local host. On production mode it works. I dont know why but now now i have another issue.\ndefmodule Olist.Guardian.AuthPipeline.Browser do\n  use Guardian.Plug.Pipeline, otp_app: :olist,\n                              module: Olist.Guardian,\n                              error_handler: Olist.AuthErrorHandler\nplug Guardian.Plug.VerifySession\n  plug Guardian.Plug.LoadResource, allow_blank: true\nend\nwhen i trying visit root path with this pipeline i got error\ninvalid_token, token_expired\nwhy it trigger this error if i do not have EnsureAuthenticated for root path?\nAlso haw i can check if token expired and it should redirect me to root path. @hassox i did not use docker. session generate with\nOlist.Guardian.Plug.sign_in(resource, %{}, ttl: {15, :minute})\n``\nPlease forget about expiration. It works on production and it is enought for me.\ni found that plug Guardian.Plug.VerifySession` use for check that token is expired so i just removed it for my root pipiline and now i get invalid token error only for auth paths. So now i have one problem. How i can redirect user to login path if his session is expired?. ",
    "codecov-io": "Codecov Report\n\n:exclamation: No coverage uploaded for pull request base (master@8df179e). Click here to learn what that means.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #494   +/-\n========================================\n  Coverage          ?   85.4%         \n========================================\n  Files             ?      17         \n  Lines             ?     418         \n  Branches          ?       0         \n========================================\n  Hits              ?     357         \n  Misses            ?      61         \n  Partials          ?       0\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt.ex | 85.36% <\u00f8> (\u00f8) | |\n| lib/guardian/plug/keys.ex | 83.33% <\u00f8> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8df179e...44ba7d6. Read the comment docs.\n. # Codecov Report\nMerging #506 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #506   +/-\n=======================================\n  Coverage   84.97%   84.97%         \n=======================================\n  Files          17       17         \n  Lines         406      406         \n=======================================\n  Hits          345      345         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update bed4961...21b9c0e. Read the comment docs.\n. # Codecov Report\nMerging #508 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #508   +/-\n=======================================\n  Coverage   84.97%   84.97%         \n=======================================\n  Files          17       17         \n  Lines         406      406         \n=======================================\n  Hits          345      345         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 38aa025...1b4a3af. Read the comment docs.\n. # Codecov Report\nMerging #509 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #509   +/-\n=======================================\n  Coverage   84.97%   84.97%         \n=======================================\n  Files          17       17         \n  Lines         406      406         \n=======================================\n  Hits          345      345         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 82.6% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 38aa025...f162f5c. Read the comment docs.\n. # Codecov Report\nMerging #510 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #510   +/-\n=======================================\n  Coverage   84.97%   84.97%         \n=======================================\n  Files          17       17         \n  Lines         406      406         \n=======================================\n  Hits          345      345         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 38aa025...493a203. Read the comment docs.\n. # Codecov Report\nMerging #511 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #511   +/-\n=======================================\n  Coverage   84.97%   84.97%         \n=======================================\n  Files          17       17         \n  Lines         406      406         \n=======================================\n  Hits          345      345         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 38aa025...1a9b2f7. Read the comment docs.\n. # Codecov Report\nMerging #512 into master will increase coverage by 0.21%.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #512      +/-\n==========================================\n+ Coverage   84.97%   85.19%   +0.21%   \n==========================================\n  Files          17       18       +1   \n  Lines         406      412       +6   \n==========================================\n+ Hits          345      351       +6   \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt.ex | 85.36% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/uuid.ex | 100% <100%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3e6fb32...a8c3a76. Read the comment docs.\n. # Codecov Report\nMerging #518 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #518   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian.ex | 90% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 64f16a6...c45d7fc. Read the comment docs.\n. # Codecov Report\nMerging #519 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #519   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a567a3e...4270475. Read the comment docs.\n. # Codecov Report\nMerging #522 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #522   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7d01b4e...4010605. Read the comment docs.\n. # Codecov Report\nMerging #524 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #524   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian.ex | 90% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_cookie.ex | 91.3% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7d01b4e...c66d8ee. Read the comment docs.\n. # Codecov Report\nMerging #525 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #525   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian.ex | 90% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 56bfee1...2ea0918. Read the comment docs.\n. # Codecov Report\nMerging #528 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #528   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ee30bf1...b9797ef. Read the comment docs.\n. # Codecov Report\nMerging #531 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #531   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b19f2c9...5da96af. Read the comment docs.\n. # Codecov Report\nMerging #533 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #533   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 73b0c3d...e0223d8. Read the comment docs.\n. # Codecov Report\nMerging #537 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #537   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a9f4115...c3a0764. Read the comment docs.\n. # Codecov Report\nMerging #540 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #540   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update dc81f26...b1d5f4c. Read the comment docs.\n. # Codecov Report\nMerging #541 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #541   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt.ex | 85.36% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update dc81f26...d61a128. Read the comment docs.\n. # Codecov Report\nMerging #542 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #542   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug/pipeline.ex | 86.36% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3aa9533...8809c91. Read the comment docs.\n. # Codecov Report\nMerging #543 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #543   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3c91f9f...bbe03e3. Read the comment docs.\n. # Codecov Report\nMerging #544 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #544   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/phoenix/socket.ex | 93.33% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/permissions/bitwise.ex | 90.9% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug.ex | 82.6% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a271ea5...526c553. Read the comment docs.\n. # Codecov Report\nMerging #545 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #545   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt/verify.ex | 100% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3aa9533...cd16531. Read the comment docs.\n. # Codecov Report\nMerging #546 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #546   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug/load_resource.ex | 86.66% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/pipeline.ex | 86.36% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/permissions/bitwise.ex | 90.9% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_header.ex | 69.56% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_cookie.ex | 91.3% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_session.ex | 94.44% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/ensure_authenticated.ex | 88.88% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/ensure_not_authenticated.ex | 80% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3aa9533...3ab20f1. Read the comment docs.\n. # Codecov Report\nMerging #547 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #547   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian.ex | 90% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3aa9533...8fba714. Read the comment docs.\n. # Codecov Report\nMerging #550 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #550   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt.ex | 85.36% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/permissions/bitwise.ex | 90.9% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug.ex | 82.6% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_header.ex | 69.56% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_cookie.ex | 91.3% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_session.ex | 94.44% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5b20d99...aa42c10. Read the comment docs.\n. # Codecov Report\nMerging #551 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #551   +/-\n=======================================\n  Coverage   85.19%   85.19%         \n=======================================\n  Files          18       18         \n  Lines         412      412         \n=======================================\n  Hits          351      351         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt.ex | 85.36% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian.ex | 90% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/permissions/bitwise.ex | 90.9% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug.ex | 82.6% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/load_resource.ex | 86.66% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/pipeline.ex | 86.36% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_header.ex | 69.56% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_cookie.ex | 91.3% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/plug/verify_session.ex | 94.44% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/phoenix/socket.ex | 93.33% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1fb14fb...9fc6770. Read the comment docs.\n. # Codecov Report\nMerging #552 into master will increase coverage by 0.14%.\nThe diff coverage is 83.33%.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #552      +/-\n==========================================\n+ Coverage   85.19%   85.33%   +0.14%   \n==========================================\n  Files          18       18            \n  Lines         412      416       +4   \n==========================================\n+ Hits          351      355       +4   \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 83.56% <83.33%> (+0.95%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b6c6dee...8f32aac. Read the comment docs.\n. # Codecov Report\nMerging #556 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #556   +/-\n=======================================\n  Coverage   85.37%   85.37%         \n=======================================\n  Files          18       18         \n  Lines         417      417         \n=======================================\n  Hits          356      356         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5d13afc...1a68d36. Read the comment docs.\n. # Codecov Report\nMerging #557 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #557   +/-\n=======================================\n  Coverage   85.37%   85.37%         \n=======================================\n  Files          18       18         \n  Lines         417      417         \n=======================================\n  Hits          356      356         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/permissions/bitwise.ex | 90.9% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/guardian.ex | 90% <100%> (\u00f8) | :arrow_up: |\n| lib/guardian/plug.ex | 83.78% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0c3e8ee...2bc0e17. Read the comment docs.\n. # Codecov Report\nMerging #558 into master will increase coverage by 0.2%.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster     #558     +/-\n=========================================\n+ Coverage   85.37%   85.57%   +0.2%   \n=========================================\n  Files          18       18           \n  Lines         417      423      +6   \n=========================================\n+ Hits          356      362      +6   \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/verify.ex | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0c3e8ee...e4cfff0. Read the comment docs.\n. # Codecov Report\nMerging #560 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #560   +/-\n=======================================\n  Coverage   85.37%   85.37%         \n=======================================\n  Files          18       18         \n  Lines         417      417         \n=======================================\n  Hits          356      356         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 442b6f5...da39cff. Read the comment docs.\n. # Codecov Report\nMerging #561 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #561   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 83.78% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 97720b6...74e973d. Read the comment docs.\n. # Codecov Report\nMerging #563 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #563   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 83.78% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c79acad...78abe0a. Read the comment docs.\n. # Codecov Report\nMerging #564 into master will decrease coverage by 0.53%.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #564      +/-\n==========================================\n- Coverage   85.51%   84.97%   -0.54%   \n==========================================\n  Files          18       17       -1   \n  Lines         421      406      -15   \n==========================================\n- Hits          360      345      -15   \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/token/jwt/verify.ex | 87.5% <0%> (-12.5%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 65eb6d3...60b8c3e. Read the comment docs.\n. # Codecov Report\nMerging #566 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #566   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/permissions/bitwise.ex | 90.9% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ac79691...c337c15. Read the comment docs.\n. # Codecov Report\nMerging #567 into master will decrease coverage by 0.06%.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #567      +/-\n==========================================\n- Coverage   85.57%   85.51%   -0.07%   \n==========================================\n  Files          18       18            \n  Lines         423      421       -2   \n==========================================\n- Hits          362      360       -2   \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/permissions/bitwise.ex | 90.47% <0%> (-0.44%) | :arrow_down: |\n| lib/guardian/plug.ex | 83.56% <0%> (-0.23%) | :arrow_down: |\n| lib/guardian/token/jwt/verify.ex | 100% <0%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 599fa12...c5940a2. Read the comment docs.\n. # Codecov Report\nMerging #568 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #568   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9ed23ac...7e684e6. Read the comment docs.\n. # Codecov Report\nMerging #570 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #570   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 83.78% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8930f7b...d625c7d. Read the comment docs.\n. # Codecov Report\nMerging #571 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #571   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 83.78% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8930f7b...4644e14. Read the comment docs.\n. # Codecov Report\nMerging #572 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #572   +/-\n=======================================\n  Coverage   85.57%   85.57%         \n=======================================\n  Files          18       18         \n  Lines         423      423         \n=======================================\n  Hits          362      362         \n  Misses         61       61\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/guardian/plug.ex | 83.78% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8930f7b...95b3452. Read the comment docs.\n. # Codecov Report\nMerging #576 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #576   +/-\n=======================================\n  Coverage   85.51%   85.51%         \n=======================================\n  Files          18       18         \n  Lines         421      421         \n=======================================\n  Hits          360      360         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ce842f7...1b8b808. Read the comment docs.\n. # Codecov Report\nMerging #579 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #579   +/-\n=======================================\n  Coverage   85.51%   85.51%         \n=======================================\n  Files          18       18         \n  Lines         421      421         \n=======================================\n  Hits          360      360         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ce842f7...16c73ba. Read the comment docs.\n. # Codecov Report\nMerging #580 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #580   +/-\n=======================================\n  Coverage   85.51%   85.51%         \n=======================================\n  Files          18       18         \n  Lines         421      421         \n=======================================\n  Hits          360      360         \n  Misses         61       61\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 715e9a9...a31f547. Read the comment docs.\n. \n",
    "bdensmore": "@hlhr Thanks for the link to the example, that was extremely beneficial for me. I was still setting things up pre 1.0 which caused the issues I was having. Using your example app helped me to get things working.\n@hassox Thank you for the added info in the guide as well.\nThank you both!\nBen. ",
    "andreapavoni": "thank you @yordis, it was a matter of wrong certificate. solved with different package.. @randolphpark I've removed guardian and installed joken package (to handle JWTs), then I wrote the rest of the glue code (plugs & co).. ",
    "randolphpark": "I am having a similar problem. \nWould be great if @andreapavoni can clarify what is the \"different package\"? Thanks. ",
    "williamweckl": "When I do it at config it will compile as a string, so if I build my application in a different environment that I run it the configuration value will be different...\nBetter explained at: https://hexdocs.pm/distillery/runtime-configuration.html. @yordis \nAnswering your question I'm using it because almost all my other libraries accepts this format, even phoenix uses it... If I can't use it at least I need a way to set it at runtime.... @yordis yes! this will work for me! thank you!. +1. ",
    "angelo-moreira": "Sorry I am new to Phoenix and Elixir so I am not really sure what you mean I follow the original documentation step by step and it was incorrect, so check step by step and changed it in my branch.\nI have not generated documentation, do you want me to generate the documentation with https://brainlid.org/elixir/2016/09/01/phoenix-project-documentation.html and see if the output matches the changes I have done to the starter-tutorial?. No, they are not working correctly, I have checked the starter tutorial in github just browsing the web interface.\nI obviously had no idea that I had to clone the project and then run mix on it :)\nWell I have learnt something today..... ",
    "loustak": "It's the token itself. @loustak which conn are you passing down?\nI'm not really sure about what you mean there. \nLink to my project.\nI have also another question. I read somewhere that the jwt is stored in \"connections\". But I don't understand what are connections when speaking about Phoenix. Is this something in memory? My concern here is the scalabitility of this storage.\nThanks for help !\n. ",
    "NeoAlchemist": "Hi, I got the same issue.\nI implemented 3 different pipelines for 3 different user types, but once you login with one of them, you can have access to all areas. You can check github repo: https://github.com/NeoAlchemist/bureau\n. Yeah,  I kinda solve this by placing user id inside session and using guardian token just only for loading and checking data. \nAlso I have checked test and code of guardian and to me everything seems right, that mean we are just don't using it in right way.\nI got another example much simpler, I will upload it later when I come back at home. \nThank you. Ok, here is my simple example\nI tried explain whats going on inside readme. But my english very bad! So pardon me. ",
    "obrok": "\nThat being said, maybe add some flag that cleans up the cookie for you, maybe?!\n\nFrom my perspective the easiest thing would be to have a function that reverses the effect of remember_me. Currently the interface allows me to remember_me easily, but there is no obvious, same-level way to reverse that. For example, if I just wanted to stop \"remembering\" the user, but not destroy the session entirely it seems like I have to dig around the implementation to figure out where the remember_me information is stored.. ",
    "aditya7iyengar": "@yordis You were right! Just made that change. :). ",
    "alexferreira": "Sorry, I opened the pull request and forgot to put the description.. ",
    "joshchernoff": "Let it be known that if you have a typo in your module name for your given Pipeline config. ie\nuse Guardian.Plug.Pipeline,\n    otp_app: :polymorphic_productions,\n    module: MY_TYPO_HERE.Auth.Guardian,\nYou will find your self going down this same rabbit hole. . ",
    "zacksiri": "Yep, someone, please update this hex.. ",
    "mpugach": "Thank you @yordis for the quick response\nAttached some code, but it is more a configuration issue\nI need some help to convert my public key payload (the first link) to the format accepted by secret_key config parameter. the valid format is\n```elixir\n%{\n  \"alg\" => \"RS256\",\n  \"kty\" => \"RSA\",\n  \"use\" => \"sig\",\n  \"x5c\" => [ \n\"MIIDGTCCAgGgAwIBAgIJSgNeCzv/721VMA0GCSqGSIb3DQEBCwUAMCoxKDAmBgNVBAMTH2tyaXNobmEtYWNhZGVteS11YS5ldS5hdXRoMC5jb20wHhcNMTgwNzExMTgwNTE2WhcNMzIwMzE5MTgwNTE2WjAqMSgwJgYDVQQDEx9rcmlzaG5hLWFjYWRlbXktdWEuZXUuYXV0aDAuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6XmZxnobQD1yKLTCT1LMCVCEQ3uVA5sP7szF6UPQTDauZLD4JPy5MQzZ0Qm7GL/4VU/RGp1eIP3SHvvGZtfZqEud7QbKevUmeB63FKzchdzVfZtTNiGqcdJ8k7ozlYAzmPU+KmpRKfeFv4YldyHE6cEOk6P61vKTrZRXQN+6WL7Wlkv0V2NV94mlWvWVI/KsU16amieYXlsg145iIc7nBcoOdsoU7AEthz/jQbuVnGdWWSL4hq8K0ykAH7MdXp2smDPGhXUO+TUIQBTYw1Hd1jjywCebUZuJYPns7UtbP8ikHfsWJWXe3pi23iS0qv/NT7wsMRXYvJWdz30PokuO1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSk2w1Eo+1JoZGgS36S8iHq6fjQ4zAOBgNVHQ8BAf8EBAMCAoQwDQYJKoZIhvcNAQELBQADggEBALEUbhgWGyz7+/v1FsTaBwZUXkW4JVkpttgBS768nMP6Jerd1jRFbR+ffET+pPHm7+r9kNfdQmbJnlJH07s3Wex4MPUxAPmjPoE4d76xhJLLU+yc+T4d6p+PbatK34+HsXARi07xVCHd8xo7geHsvaud0X0tCzTT+TnxyVO6J7PQGMV8U/EO2OZmwhPbRWrYwTq0iKyFgBv76Ksd9UfAL9wO3LCMls2alIx20a/0iRj34S95hgJXMlVm8JsojJPtYJju3wzz3i/ZP0n3easoNKUZIZabxAs6V5MSSxPeY0Z6G5OdNPxJfinfWZ4qv4ApDDZNNTLhY/+xqaSeNArpj3M=\"\n  ],\n  \"n\" => \"6XmZxnobQD1yKLTCT1LMCVCEQ3uVA5sP7szF6UPQTDauZLD4JPy5MQzZ0Qm7GL_4VU_RGp1eIP3SHvvGZtfZqEud7QbKevUmeB63FKzchdzVfZtTNiGqcdJ8k7ozlYAzmPU-KmpRKfeFv4YldyHE6cEOk6P61vKTrZRXQN-6WL7Wlkv0V2NV94mlWvWVI_KsU16amieYXlsg145iIc7nBcoOdsoU7AEthz_jQbuVnGdWWSL4hq8K0ykAH7MdXp2smDPGhXUO-TUIQBTYw1Hd1jjywCebUZuJYPns7UtbP8ikHfsWJWXe3pi23iS0qv_NT7wsMRXYvJWdz30PokuO1w\",\n  \"e\" => \"AQAB\",\n  \"kid\" => \"MzI5QzgzOTNBREY4NkFFNDY1NTY3ODVBQjlBOTk1MkZCQzVFMTBGNA\",\n  \"x5t\" => \"MzI5QzgzOTNBREY4NkFFNDY1NTY3ODVBQjlBOTk1MkZCQzVFMTBGNA\"\n}\n```\nI tried atom keys first, which did not worked. ",
    "MarkPare": "Sorry for not replying to this.  This was an issue with our client application not sending correct authentication data.  This was not an issue with Guardian or Elixir.. ",
    "pera": "Please let me know if there is any issue with this PR.. ",
    "AlexRiedler": "OMG I just realized I did the same error as https://github.com/ueberauth/guardian/issues/429 typed opt instead of otp ... ; weird that the error changed though? should I keep this open?. ",
    "ckhrysze": "I did another pass through, changing the plain text \"TokenModule\" uses to \"token module\", but leaving the \\<TokenModule>.some_function references.. ",
    "paulZzhang": "@yordis The Phoenix 1.4 is out.. @yordis Please publish a rc version.Thanks.. @yordis  the branch c692ff4 is >=1.3. ",
    "johannestroeger": "isn't this a good opportunity to replace Poison with Jason? or make it at least configurable like ecto does it?. ",
    "garretttaco": "I was able to install this on a Phoenix 1.4 project, should we close this out? . @doomspork I will get to it as soon as I can! Things are swamped at work but I figured I would at least bring it to others' attention.. @sjoconnor Awesome, I did not see that. I upgraded and it appears to have fixed the issue. Thanks for pointing that minor version update. Since this is solved, I am closing this issue.. ",
    "pdgonzalez872": "Thank you for the awesome lib!. ",
    "fuelen": "But using \"typ\" key I can override default value too. ",
    "taiansu": "\n@yordis the branch c692ff4 is >=1.3\n\nAccording to my understanding and experiments, >= 1.3 is an invalid syntax. We have to specify the patch version number, e.g. >= 1.3.0 while using the >= operator.\nIn short, {:phoenix, \"~> 1.0 or >= 1.2.0\", optional: true}, works on my machine (elixir 1.7.4, phoenix 1.4.0, erlang 21.1.1).\n. @yordis Actually this change does include phoenix 1.3 and 1.4. According to version module that @michalmuskala mentioned,  the current change ~> 1.3 means all version >= 1.3.0 and < 2.0.0. \nDespite the fact that previous change ~> 1.0 is the one which makes better backward compatibility, my two cents on this is fix this in whatever way you like asap, instead of being a phoenix upgrade roadblock for no observable feature impact, 3+ characters. \ud83d\ude04 . ",
    "jrissler": "It would be nice to have this merged - I'm in the middle of upgrading to 1.4 now and this is a blocker :). Thanks!. ",
    "xenophilicibex": "Thanks! I believe this solves my issue. . ",
    "gustavowt": "Since nobody could help with this, I'm closing the issue.\nTks anyways. ",
    "mc962": "It's on a dev environment.\nDo you know what theoretically could be causing it to happen? Unfortunately I don't have as much experience with this package's codebase/elixir in general, so I'm not positive where to look aside from what I've already mentioned.\nMy understanding is that it's not picking up some secret somewhere, such as my secret_key in dev.exs, but I'm not quite sure where it's getting lost/why.. \ud83e\udd26\u200d\u2642\ufe0f \ud83e\udd26\u200d\u2642\ufe0f \ud83e\udd26\u200d\u2642\ufe0f \nFound it, it was the name of the module after all.\nI had been using a context called Authentication, where the Guardian module was namespaced behind that module.\nBut my dev.exs config was asking for MyAppName.Guardian, instead of what I had,  which was MyAppName.Authentication.Guardian. That's what I get for trying to be organized \ud83d\ude06 \nThanks for the advice.. ",
    "shanmugharajk": "Mix config info\n{:guardian, \"~> 1.0\"}\n. Is it possible to suppress these warnings in my code?. ",
    "sparta-developers": "@yordis fixed. Thanks. ",
    "darrenklein": "Great, thanks for giving this your attention.  Keep up the great work!. ",
    "freqn": "Certainly (My apologies for not doing so yesterday)!\nBroken Tutorial Links\nToken Documentation:\nhttps://github.com/ueberauth/guardian/blob/master/guides/tutorial/tokens-start.html\nImplementation Module Docs:\nhttps://github.com/ueberauth/guardian/blob/master/guides/tutorial/introduction-implementation.html\nCallbacks Link:\nhttps://github.com/ueberauth/guardian/blob/master/guides/tutorial/Guardian.html#callbacks\nPipeline Guide:\nhttps://github.com/ueberauth/guardian/blob/master/guides/tutorial/plug-pipeline.html\nGuardian.Plug.EnsureAuthenticated:\nhttps://github.com/ueberauth/guardian/blob/master/guides/tutorial/Guardian.Plug.EnsureAuthenticated.html\n. Ah, that makes sense. Glad to help!. ",
    "mithereal": "this issue has reoccurred again, it is related to docker in my case, as i can compile and everything works fine if i dont use docker. ",
    "chrismccord": "This is global, so I am :-1:  on it. The user can define their own handler module, then plug that anywhere they want.\n``` elixir\ndefmodule MyApp.EnsureAuthenticated do\n  use Plug.Builder\n  plug Guardian.Plug.EnsureAuthenticated, handler: MODULE\ndef unauthenticated(conn) do\n    ...\n  end\nend\ndefmodule MyApp.MyController do\n  plug MyApp.EnsureAuthenticated\nend\n```\n. So to be clear, explicit handler like this is fine, it's the global config I am against. Otherwise looks good!\n. ",
    "shantiii": "The third parameter of the tuple is the argument list, not the arity.\n. ",
    "GBH": "Oh you know what. override: true works when I put on the phoenix dependency. Sorry, I'm kinda new to this. But yeah, you'd think that ~> 1.2 would include 1.3-rc, but it needs to be explicit. I used this as an example to make it work: https://github.com/phoenixframework/phoenix_live_reload/blob/master/mix.exs#L33\nI guess this PR can be closed as override: true does work when you plug it in the proper place.. ",
    "nekath": "Implmentation -> Implementation. implmentation -> implementation\n. Missing dots? It looks like some of the sentences end with dot and some do not - across all Modules.. ",
    "jsteiner": "It looks like there's some spots referencing as (here and in a test below). Is this outdated? I don't see any code to support it.. ",
    "bitwalker": "The {:system, \"FOO\"} pattern at this point is an anti-pattern. I would use the init/2 strategy Phoenix has taken, where the Phoenix endpoint module will have it's init/2 callback invoked before it starts allowing it to do configuration of the application. If that's not viable, having users provide a tuple of {module, atom, [args]} in their configuration which will be invoked as a callback when the application starts to do dynamic config is another option. Anonymous functions in the config is another anti-pattern, so use MFA tuples instead.. @scrogson Yeah, true, though if you need configuration in order to take some action in a function, invoking a function to get that configuration each time may actually be a nice feature, since it naturally supports runtime reconfiguration of the system (and testing too for that matter). Doing so as a callback may not make sense, but supplying an MFA to invoke each time seems like it would be a sane option. That said, I'm not familiar enough with ueberauth to make any specific recommendations, just wanted to throw in my two cents on what I've seen work elsewhere, and what works well with releases.. ",
    "mhanberg": "done. ",
    "gcauchon": "How come are remember_me/5 and remember_me_from_token/5 not leveraging the implementation/1 fonction to inject the Guardian implementation module like the other function do?. ",
    "ps-feng": "I think it's possible to get rid of the macro altogether, but please excuse me if this makes no sense as I've just started learning Elixir and using Guardian to verify Firebase tokens...\nIsn't it enough with @behaviour Guardian.Token.Jwt.SecretFetcher? After all fetch_secret_fetcher is already referencing SecretFetcherDefaultImpl by default. This way we can get rid of the macro, which also resembles OO inheritance.. ",
    "ericmj": "\ud83d\udc4d . ",
    "k-cross": "I've never done this, but is it possible to give maximum flexibility by just changing ... or ~> 1.3 to ... or >= 1.3?. Might as well make it >= 1.0 unless you're expecting to make breaking changes.. "
}