{
    "jeffh": "Thanks! That was my sloppy renaming of files on my part.\n. Agreed. Thanks @endersstocker!\n. Agreed. How would failure reporting work with the other matchers? I'd prefer that they all be consistent?\n. Oops, I close this by accident. My bad.\n. Thanks for bug report! I don't know how that got through.\n. Hey @blindsey, bridging headers don't seem supported for frameworks anymore, but due to the way Swift classes are generated -- they aren't normal Objective-C classes, you cannot forward declare them without the proper swift attributes. This might be a bug to file to Apple, but more investigation is required first.\nI'm currently limited in time right now, but I'll try to check it out this weekend.\n. Great work everyone!\nI've been getting some weird test crash when the exercising beCloseTo(within:) on both swift and ObjC variants of Nimble.\n@drmohundro, could you try running ./test.sh full and see if you get any errors?\n. @drmohundro, I think it might be related to the simulator variant. iPhone 5s and iPad Air sims seem to be fine, but all the other ones are broken.\nI'm tempted to write this one up as a swift compiler bug.\n. I've merged #10, which includes these changes too. I'll open new issues for this problem (it might be filed to apple). Also, I prefer to not have operator overrides and have them specified in the matchers instead.\n. Thanks @tonyd256!\n. Xcode 6 Beta 5 seems to have fixed this issue for older sims. Closing.\n. @joemasilotti, I merged https://github.com/Quick/Nimble/pull/14, which should fix this.\n. Thanks @lazerwalker\n. hasValue sounds good to me. Use it :)\u2014\nSent from my iPhone\nOn Thu, Aug 7, 2014 at 8:32 AM, David Mohundro notifications@github.com\nwrote:\n\nQuick question on my changes thus far... I'm not really a fan of all of the nil checking that I added as a result of Optionals no longer conform to BooleanType (formerly LogicValue).\nI hadn't spotted it yet, but there is a hasValue method on Optionals now, so all of the nil checking code that I added could be rewritten. See the below example:\nBefore:\nswift\nreturn instance != nil && instance!.isMemberOfClass(expectedClass)\nAfter:\nswift\nreturn instance.hasValue && instance!.isMemberOfClass(expectedClass)\nAny thoughts on which one is better? I personally like checking hasValue better, but I'd rather get input first before I go changing more.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/pull/15#issuecomment-51488453\n. I'm not sure what should be the intended behavior of beTruthy and beFalsy. They still match with nil in Objective-C.\n\nBut for the sake of getting Xcode 6 Beta 5 support. I'll merge it in soon.\n. Rebased in to master. Thanks @drmohundro!\n. Thanks @AshFurrow!\n. Sounds good. I added another issue for beTrue and beFalse matchers (#24)\n. Fixed in https://github.com/Quick/Nimble/pull/43\n. Is this redundant to https://github.com/Quick/Nimble#writing-your-own-matchers ? I'm guessing that raising to right below the list of provided matchers (aka, where you put it) might be better. It's just hard to express the fact that more code is needed for matchers to support Objective-C.\n. Thanks @akashivskyy!\n. Thanks @sync!\n. I merged #20. But thanks! Sorry for the slow turn-around.\n. Hey @modocache. Most of it is great! I'm personally not a big fan of 1st-person tense. I generally pull from the python community for technical writing guidance (e.g. zope and django).\nWhile first-person style is not 100% discouraged, they usually to lead to:\n- less assertive/more passive tone. A less assertive tone is weaker at conveying a message (e.g. - \"I can use\" can be easily misinterpreted as a question by a reader to \"should I be doing this the writer is recommending?\"\n- more conversational fluff. People usually don't like reading wordy pieces. Sadly, I'm one of them.\nFor example:\nI don't mind XCTest assertions, but I think they're hard to use for several reasons:\nCould be written as:\nXCTest assertions are harder to use because:\nThe tone of voice is stronger while conveying the meaning with less words.\nThat doesn't mean using \"I\" or \"we\" is banned. I like to imagine standing over the shoulder of the reader trying to explain something. This tends to drive my writing style to use \"we\" to imply the author and the reader.\nAlso, that doesn't excuse the fact that the README isn't poorly written right now. I frequently use passive voice and filler words. Besides that, I think the changes you made are a definite improvement :)\nEnglish is way more difficult than any programming language. As a famous quote goes:\nI'm sorry that this was such a long letter, but I didn't have time to write you a short one.\n. @modocache, other than some minor tweaks. Looks great! :+1:. Feel free to merge it after those minor tweaks.\n. Indeed!\n\u2014\nSent from my iPhone\nOn Sat, Aug 30, 2014 at 11:54 PM, Brian Gesiak notifications@github.com\nwrote:\n\nHow do I write the following in Objective-C?\nswift\n// Swift\n// Waits three seconds for ocean to contain \"starfish\":\nexpect(ocean).toEventually(contain(\"starfish\"), timeout: 3)\nPoking around at ObjCMatcher.swift, it seems like Nimble doesn't support custom timeouts in Objective-C. I think it should. Thoughts?\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/25\n. For syntax support here are some ideas:\n- expect(ocean).toEventuallyWithTimeout(contain(@\"starfish\"), 3)\n- expect(ocean).withTimeout(3).toEventually(contain(@\"starfish\"))\n. Actually, this feature is already available as the latter form:\n\nexpect(ocean).withTimeout(3).toEventually(contain(@\"starfish\"))\nLeaving this issue open to remember to document this.\n. :+1: Maybe without the articles, so reason() and userInfo() is better, but either works for me.\n. For any of these matchers supporting multiple arguments, they need to be converted into a macro that implicitly wraps the arguments into arrays.\n. Last time I checked those methods work only if you're directly inside the test case, that would mean you would need to pass self (the test case instance) through nimble explicitly.\n. That would require strange syntax to achieve properly in Nimble like:\nexpect(1).toEventually(equal(2), self)\nWithout some hackery or coordination with Quick (esp with shared examples).\nI see using a implementation under the hood when appropriate. It can be a negative since it's tightly coupling to an external dependency. See Kiwi, Specta, and Cedar - which Xcode 6 test bundle support is in flux because of internal changes Apple has made. Using private APIs is a requirement if you want to do anything beyond what Apple conservatively exposes. I rather have something that doesn't support the latest wizbang feature from Apple instead of not working at all. But maybe my risk-factor is different from yours.\n. I'm going to close this issue for now unless something changes in APIs or someone comes up with a good solution that doesn't require a major change in the general syntax. Using the public stuff would be great if possible.\n. Hey @modocache, is this a stale derived data cache? I'm not using Yosemite, so I can't verify this.\n. I do agree that beIdenticalTo is more of a smell than anything else. We could support it by defining custom overloaded operators like SwiftHamcrest does. I'm not sure if that's better or more surprising to users though.\n. Thanks @rbeeger looks great! Could you expand the test case to cover:\n- testing === operator\n- testing !== operator\n- testing through toNot\n- testing failure messages\nI also don't have OS X 10.10 right now. @modocache, could you verify if Nimble works there?\n. Thanks @rbeeger!\n. @rbeeger, this seems to be caused from the implicit returns of Swift. I'm not really sure of a good solution  to tell the compiler otherwise.\n. @nerdyc, is there a way to check for optionality like Double is done? I'm thinking something like:\nswift\nfunc stringify<T>(value: T?) -> String {\n    if value is Optional<T> && value == nil {\n        return \"nil\"\n    }\n    if value is Double {\n        return NSString(format: \"%.4f\", (value as Double))\n    }\n    return toString(value)\n}\nI don't have Yosemite installed, so I can't verify any of that. Also, I'm guessing the above code probably doesn't work?\n. The problem is that Nimble is using an optional T through the matches, which will probably implicitly optionally box the type for stringify. It seems like it's harder to have generics where one generic function calls through to another generic function.\n. Thanks again @rbeeger! I didn't know that you can remove the return for operators now.\n. Do you get some linker/compiler error when you build?\n\u2014\nSent from my iPhone\nOn Thu, Sep 25, 2014 at 8:41 AM, Joshua Kaden notifications@github.com\nwrote:\n\n+ 1\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/37#issuecomment-56837998\n. Perhaps, it seems like just the string equality failures. So I merged it in for now, but I will not merge other PR until the tests pass again.\n\n@rhoegg, I merged in some PR, could you verify this is still an issue?\n. It might be stale derived data. I've noticed this issue more often in Xcode 6 over previous versions of Xcode.\n. I don't think this is any issue anymore (at least on Xcode 6.1). I'm closing this. Reopen if you still see issues.\n. I'm not a big fan of removing the text Optional text from the string directly. There is another way by explicitly supporting the optional and non-optional matches:\n``` swift\npublic func beEmpty() -> MatcherFunc {\n    return MatcherFunc { actualExpression, failureMessage in\n        failureMessage.postfixMessage = \"be empty\"\n        let actualSeq = actualExpression.evaluate()\n        var generator = actualSeq.generate()\n        return generator.next() == nil\n    }\n}\npublic func beEmpty() -> MatcherFunc {\n    return (beEmpty() as MatcherFunc).asOptional(matchesNil: true)\n}\n```\nIt does require making a whole set of new matchers for it though. But some way to solve the generic function that calls an overloaded function would be ideal.\n. Sorry for my terribly slow turnaround time. But thanks a ton @rbeeger! (I did get to verify it on Xcode 6.1).\n. Could you try importing xctest explicitly? What is under the target dependencies? What ios version are you targeting?\n. Nimble/Quick uses XCTest internally which provides integration with Xcode.\nAre you testing on device? It\u2019s currently not supported (see https://github.com/Quick/Quick/issues/140).\n\u2014\nSent from my iPhone\nOn Thu, Oct 2, 2014 at 1:42 PM, arvindraghavan notifications@github.com\nwrote:\n\n\nI have XCTest imported in one of my existing XCT-basd test cases. Note that when I install Nimble & Quick, without any new Quick-based tests added the tests stop running to completion. I have the same problem and output when I add a Quick-based test case, and import XCTest (not sure why XCTest needs to be imported when I\u2019m using Quick/Nimble??) Here is the output I see in addition to the error message I had in my original description:\nthread #1: tid = 0xeb88f, 0x318e1518 libsystem_kernel.dylib`mach_msg_trap + 20, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\nframe #0: 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20\n     frame #1: 0x318e1310 libsystem_kernel.dylibmach_msg + 40\n     frame #2: 0x23c32dca CoreFoundation__CFRunLoopServiceMachPort + 146\n     frame #3: 0x23c31390 CoreFoundationCFRunLoopRun + 1016\n     frame #4: 0x23b7edb0 CoreFoundationCFRunLoopRunSpecific + 476\n     frame #5: 0x23b7ebc2 CoreFoundationCFRunLoopRunInMode + 106\n     frame #6: 0x2aee2050 GraphicsServicesGSEventRunModal + 136\n     frame #7: 0x27149f00 UIKitUIApplicationMain + 1440\n     frame #8: 0x00159570 BatteryPacktop_level_code + 72 at AppDelegate.swift:21\n     frame #9: 0x001595ac BatteryPackmain + 48 at AppDelegate.swift:0\n     thread #2: tid = 0xeb8a0, 0x318e12c8 libsystem_kernel.dylibkevent64 + 24, queue = 'com.apple.libdispatch-manager'\n     frame #0: 0x318e12c8 libsystem_kernel.dylibkevent64 + 24\n     frame #1: 0x31803ec8 libdispatch.dylib_dispatch_mgr_invoke + 280\n     frame #2: 0x31803bfa libdispatch.dylib_dispatch_mgr_thread$VARIANT$mp + 38\n     thread #6: tid = 0xeb8bc, 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20, name = 'com.apple.NSURLConnectionLoader'\n     frame #0: 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20\n     frame #1: 0x318e1310 libsystem_kernel.dylibmach_msg + 40\n     frame #2: 0x23c32dca CoreFoundation__CFRunLoopServiceMachPort + 146\n     frame #3: 0x23c31390 CoreFoundation__CFRunLoopRun + 1016\n     frame #4: 0x23b7edb0 CoreFoundationCFRunLoopRunSpecific + 476\n     frame #5: 0x23b7ebc2 CoreFoundationCFRunLoopRunInMode + 106\n     frame #6: 0x237371fe CFNetwork+[NSURLConnection(Loader) _resourceLoadLoop:] + 486\n     frame #7: 0x2497b1ba Foundation__NSThread__main** + 1118\n     frame #8: 0x31973e66 libsystem_pthread.dylib_pthread_body + 138\n     frame #9: 0x31973dda libsystem_pthread.dylib_pthread_start + 118\n     thread #8: tid = 0xeb8c0, 0x318f508c libsystem_kernel.dylib__select + 20, name = 'com.apple.CFSocket.private'\n     frame #0: 0x318f508c libsystem_kernel.dylib__select + 20\n     frame #1: 0x23c37552 CoreFoundation__CFSocketManager + 490\n     frame #2: 0x31973e66 libsystem_pthread.dylib_pthread_body + 138\n     frame #3: 0x31973dda libsystem_pthread.dylib_pthread_start + 118\n     thread #10: tid = 0xeb94f, 0x318f59cc libsystem_kernel.dylib__workq_kernreturn + 8\n     frame #0: 0x318f59cc libsystem_kernel.dylib__workq_kernreturn + 8\n     frame #1: 0x31971ea0 libsystem_pthread.dylib`_pthread_wqthread + 792\n     * Canceling tests due to timeout in Waiting for test process to check in... If you believe this error represents a bug, please attach the log file at /var/folders/ty/1k36_68s0zg7kg24qvv_1gp00000gn/T/com.apple.dt.XCTest-status/Session-2014-10-02_13:37:55-aT9maQ.log\nUnder target dependencies, I only have the main project (=BatteryPack in my case, with BatteryPackTests being the target for my tests where I install Nimble/Quick). \nTarget version iOS 8.0\n   On Oct 2, 2014, at 9:11 AM, Jeff Hui notifications@github.com wrote:\nCould you try importing xctest explicitly? What is under the target dependencies? What ios version are you targeting?\n\u2014\nReply to this email directly or view it on GitHub.\n\n\n\n\n\nReply to this email directly or view it on GitHub:\n   https://github.com/Quick/Nimble/issues/41#issuecomment-57702252\n. Closed. See Quick's Documentation on how to set this up.\n. Thanks @rbeeger, I tested it on Yosemite. I rebased the changes on.\n. Thanks for the heads up.\n\nSent from my iPhone\n\nOn Oct 28, 2014, at 1:18 AM, Robert Beeger notifications@github.com wrote:\nOK, thanks.\nBTW: You could close #22 now.\n\u2014\nReply to this email directly or view it on GitHub.\n. Hey @nikita-leonov thanks for the bug report.\n\nI looked into this, but I'm also not sure how to resolve this. Due to the nature of the run loop, there is no way to advance the run loop without potentially hitting expensive code on the main thread. It is currently intended behavior, but not ideal.\nAs a reference note, XCTest's async expectations also exhibits this failure (although it bails out). The best I can do is bailout early when seeing a stalled main thread.\n. @modocache, agreed about the autodialing part. The testing infrastructure for objective-c isn't super great. I'll make the change and add some test, and beef it up on the branch.\nI might merge that branch into this one, once that works. What do you think?\n. Agreed!\n. Thanks @jspahrsummers!\n. Great stuff @ashfurrow and @orta!\nI marked the diff.\n@modocache, Nimble hasn't been versioning anything. Do you find it valuable if the Quick + Nimble versions match?\n. Do you remember what looked off? My naive eyeballs can't see it :(\n. Hey @zdrossman,\nYup, that looks like a bug to Nimble. Thanks for the catch! I think the current implementation is way more complicated than it should be these days (the betas sometimes didn't include equality). The one currently in Nimble doesn't seem to work right either.\n. Hey @ole.\nAn index out of bounds in Swift is not an exception. Swift has no notion of exceptions. The runtime simply causes the program to abort with an invalid assembly instruction (which you can see in the stack trace of fatalError).\nBut ignoring the technical details, its definitely valuable to state that in the documentation.\n. Hey Nathan,\nThis is the default behavior of XCTest. You can provide a custom AssertionHandler for Nimble that fails immediately.\n- Jeff\n\u2014 Sent from my iPhone\nOn Mon, Dec 1, 2014 at 1:01 PM, Nathan Broadbent notifications@github.com\nwrote:\n\nHi,\nI just started using Quick + Nimble, and I noticed that all my expectations are run even when the first one fails. Is there a way make the test crash after the first failure?\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/69\n. Ah I was thinking it was about rspec's --fail-fast option. My bad.\n\nThis just requires setting continueAfterFailure = true on the XCTestCase. Quick doesn't officially support this, but it's not hard to do manually:\nswift\nclass MySpec: QuickSpec {\n    override func setUp() {\n         continueAfterFailure = false\n    }\n    override func spec() {\n         it(\"fails only once\") {\n             fail(\"Only I appear\")\n             fail(\"And I don't\")\n         }\n    }\n}\nI filed an issue on Quick for an official way to support feature: https://github.com/Quick/Quick/issues/249.\nClosing this issue, continue the conversation on that issue.\n. Thanks @modocache!\n. Hey @feinstruktur. Thanks for the PR!\nI personally haven't decided if adding custom operators is something Nimble should definitely provide yet (thoughts @Quick/contributors?). That being said, I do really like the \u00b1 operator, but ~= reminds me more of the match operator that other languages have (although, it's =~ for those).\nBut everything else looks pretty good to me.\n. Is option-x the hotkey you're looking for?\nI'm not at a computer to try this out.\n. Thanks @feinstruktur for the yummy bacon! :+1:\n. I don't think there is any technical reason why it's missing. It was probably oversight on my part.\n. Hey @jspahrsummers, thanks for the bug report. Just making sure I understand correctly: This issue occurs on Nimble master?\nI couldn't seem to replicate it on master or v0.2.0. What type is commitDescription? What version of Xcode are you using?\n. Hey @gowthamyemme, sorry for the slow reply (Happy holidays!).\nAre you using swift or objective-c? I'll try and get around to manually verifying this later today.\n. Hey @gowthamyemme, I couldn't reproduce your issue. Is your derived data clean? What version of Xcode are you using?\n. Do you have a sample project that exhibits this issue? Or some detailed steps to reproduce?\n. Hey @gyemme, thanks for the sample project! It's been super helpful.\nIt seems like the podfile was generated from 0.35.0 (See podfile.lock).\nBeta cocoa pods should be generating frameworks IIRC. If I rerun pod install with no podfile changes but using 0.36.0.beta.2, it works. I'm tempted to close this issue as an older version of cocoa pods use. Hopefully when cocoa pods official releases swift support this gotcha won't happen.\n. Closing. Reopen if this surfaces again on later cocoapods versions.\n. As per pull request #81 discussion, Nimble is now on cocoapods trunk.\n. Thanks! I think it would also be useful to set that warning inside Nimble as well.\n. Thanks @ashfurrow! I tweaked the podfile slightly after the fact for pod spec validation, but #79 prevents Nimble from actually being on trunk (at least I can't push it). I'm not actually sure what's involved on cocoa pods for that transition.\n. Cool. Thanks for pushing to trunk.\n. @modocache, I merged the changes into master. I just wanted sleep between reviewing the code I wrote late-night. Sorry for the troubles.\n@klaaspieter, it's an interesting idea. I'm definitely in the (smaller) camp that async tests should be used sparingly:\n- WebKit (and other apple components) historically crash non-deterministically when advancing the run loop which creates a flaky test suite.\n- Async tests slow down test execution because of its polling nature. Even waitUntil, which is similar in design the XCTest's async expectations, both internally advance the main runloop.\n- Async tests encourage poorer designs: non-deterministic behavior and parallel execution. I personally think threads are a global resource and should be treated as such.\nSo you could say I don't mind the (tiny) barrier it takes to convert between sync and async tests, but I definitely could be convinced otherwise. It's definitely an idea worth considering since I do like consistency :).\n. I moved the discussion over to another issue. Feel free to elaborate more on it.\n. Tagged. I forgot to push the podspec to trunk but now it's done. Thanks!\n. Hey @NebulaFox, could you elaborate more on this or give me an example? I'm not quite sure what you mean. I tried this example, but I got what seems to me as reasonable results:\n``` swift\nstruct Foo {}\nextension Foo: Printable {\n    var description: String { return \"LOL\" }\n}\nvar f: [Foo]? = [Foo()]\nexpect(f).to(beNil()) // message: \"failed - expected to be nil, got <[LOL]>\"\n```\n. Thanks for the example.\nHm, I still get the sample behavior has before:\n``` swift\nenum SpamEggs : Printable {\n    case Spam\n    case Eggs\nvar description: String {\n    switch self {\n        case .Spam:\n            return \"SpamEggs.Spam\"\n        case .Eggs:\n            return \"SpamEggs.Eggs\"\n    }\n}\n\n}\nstruct Foo : Printable {\n    let spamEggs:SpamEggs\ninit(spamEggs:SpamEggs) {\n    self.spamEggs = spamEggs\n}\n\nvar description:String {\n    return \"Foo{\\(spamEggs)}\"\n}\n\n}\nclass FooTest: XCTestCase {\n    func testStringification() {\n        let foo:Foo? = Foo(spamEggs: SpamEggs.Eggs)\n        expect(foo).to(beNil()) // \"failed - expected to be nil, got \"\n    let foo2:[Foo]? = [Foo(spamEggs: SpamEggs.Eggs)]\n    expect(foo2).to(beNil())  // \"failed - expected to be nil, got <[Foo{SpamEggs.Eggs}]>\"\n}\n\n}\n```\nXcode 6.1.1 and Xcode 6.3 beta have the same behavior for me.\nI wonder if this a Quick + Nimble integration issue. Further investigation is required, I'll take a look at it when I get some free time, thanks @NebulaFox.\n. I tried this with Quick, and I still have the same problem. Do you have a sample project that shows this behavior you're describing?\n\nI tried this on Xcode 6.1 and 6.3 beta. I still have the same string output as I shown previously.\n.  (\u256f\u00b0\u25a1\u00b0\uff09\u256f\ufe35 \u253b\u2501\u253b\nI only managed to ever get it to reproduce once on Xcode 6.1. But not since then :(.\nI'll probably close this issue in a few days since I haven't gotten it to reproduce on Xcode 6.3. But let me know otherwise if you have the time. Sorry, :sob:.\n. Looks good to me, thanks @narfdotpl. I added a few tests for happy-path cases, but other than that merged! :+1:\n. Hey @rbeeger, I like the overloaded allPass matcher that also accepts a nimble matcher.\nFor the objc part, is there something that prevents the use of NSFastEnumeration/NSEnumeration? It would help generalize it for more than NSArray and NSSet.\n. After looking at it again, there seems to be some more complex details with nested matchers.\nShould matching nils in collections be allowed?\nswift\nexpect([nil, nil] as [Int?]).to(allPass(beNil()))\nWhat's the error message for matching nils against non-nil accepting matchers?\nswift\nexpect([nil, nil] as [Int?]).to(allPass(beLessThan(5)))\nThoughts @Quick/contributors & @rbeeger?\n@rbeeger, a minor quibble: allPass fails to explain that nils should explicitly use beNil():\nswift\n    func testAllPassFailsAgainstNils() {\n        // should it be \"pass\" instead of \"match\"?\n        // expected error message: \"expected to all match (use beNil() to match nils)\"\n        failsWithErrorMessageForNil(\"expected to all match\") {\n            expect(nil as [Int]?).to(allPass(beLessThan(5)))\n        }\n    }\nAlso, I put one other comment in the commit.\n. NonNilMatcherFunc and MatcherFunc are API-conveniences (since defining functions using generic protocols is verbose), it might be better if allPass utilizes the underlying protocols instead: Matcher, BasicMatcher, NonNilBasicMatcher. Nimble currently doesn't provide a good abstraction to using these protocols since only Expectation needed to use those protocols.\nThat compiler crashing seems like a radar to file :bug:. Although I think having a more restrictive matcher is better than nothing. So if non-nil sequence types can only be matched, I think that's an acceptable compromise until Apple addresses that compiler bug.\n@rbeeger, thanks again for the exploring the problem space.\n. Hey @rbeeger, I ran this against my Xcode 6.3 beta 2 and it seemed to run just fine (test passing and all). Maybe this is just another stale derived data issue that you've been experiencing?\n. Agreed!\n\u2014 Sent from my iPhone\nOn Wed, Feb 18, 2015 at 9:05 AM, Markus Kauppila notifications@github.com\nwrote:\n\nI think this would be a great enhancement. This would certainly reduce the brittleness of matching exception in specs. So I'd be all :+1:  for this.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/96#issuecomment-74902767\n. Closed. Thanks @rbeeger!\n. Out of curiosity, what is the difference between this and just matching against the properties? It seems like it's conveying the same meaning as\n\nswift\nexpect(error.domain).to(equal(\"io.modocache.Gift\"))\nexpect(error.localizedDescription).to(match(\"Could not resolve path\"))\nwith some more API surface area to maintain. Maybe for future consideration, but I'm not particularly sold on it's value in Nimble. Outside of Nimble seems fine.\nAlthough it would be valuable to build a list of external nimble matchers. It would be nice to have a place to find some ;)\n. master of Nimble is tracking Swift 1.2 (Xcode 6.3 beta). Checkout the swift-1.1 branch for Xcode 6.1.1\n\u2014\nSent from my iPhone\nOn Fri, Feb 20, 2015 at 2:12 PM, kglee79 notifications@github.com wrote:\n\nI cloned the latest version from the repo and am not able to get the project to build.  I just cloned it, opened the project in XCode 6.1.1 and am trying to build it, but seeing around 38 errors.  Haven't done anything else to it.  One is in DSL.m, where it references , however Nimble-Swift.h doesn't appear to exist anywhere.  In addition, there are a lot of places where casting with \"expected as! String\" is being used and Xcode is complaining that it's expecting a type after \"as\".  In Equal.swift, the class \"Set\" is being used, however the class does not appear to exist.  Perhaps I'm doing something incorrectly because it's showing as build passing on Github.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/98\n. Thanks @rbeeger, looks good to me. I merged it with some whitespace trimming. I also changed 'named' to 'with name' for the error message. The raiseException error message should probably be reworded to a better english sentence, but that can be a separate issue.\n\n:+1: \n. Yeah, Nimble v0.3.0 is the latest swift 1.1 release while v0.4.0 is the latest swift 1.2 release. master refers to Swift 1.2 while the swift-1.1 branch refers to swift-1.1 work.\n. Hmm, cocoapods prevents me from pushing to trunk:\n$ pod trunk push Nimble.podspec\n -> Nimble (0.3.1)\n    - ERROR | [iOS] Swift support uses dynamic frameworks and is therefore only supported on iOS > 8.\n    - NOTE  |  ld: warning: embedded dylibs/frameworks only run on iOS 8 or later\n@orta, is there some way to ignore this error specifically? While dynamic frameworks on rejected for app store submissions that support < 8.0, it seems harmless in testing (works on 7.0 simulator).\n. Hey @kostiakoval,\nThanks for letting us know. The documentation needs to be updated to include use_frameworks! since it's been changed in a newer beta of cocoapods.\n. Hey @silkentrance,\nI'm not sure I full understand but this is roughly what Nimble does:\n- It creates an implicit closure using @autoclosure to create a block.\n- The raiseException matcher calls this closure inside a try-catch call.\nSince Swift doesn't support catching exceptions, they're implemented in objc.\n. It seems like it should work otherwise. Without more thorough code examples I can't really say much else. I'm assuming you're not assuming that Swift code will raise exceptions, since swift assertions simply abort the program execution.\n. Could not reproduce. This might be related to an Xcode not always being able to successfully build Nimble on fresh compile. Closing for now.\n. Thanks @solidcell. This was definitely a feature I had in mind, but never got around to implementing.\nFWIW, this would probably require changing NMB_expect to be a overloaded function that captures more type information of the boxed value.\n. Thanks @iv-mexx, sorry for the slow turn-around. @modocache did cut a release of v0.4.1. Does that not work for you?\n. Hey @ikesyo,\nI haven't used carthage so I'm not familiar with the configuration process required for it. Is there a different usability benefit for using pre-built binaries or is it only for faster to compiles for CI?\n. @gfontenot, I'll take you on that offer since I'm not a user of Carthage (yet). I'm not sure of the code-signing requirements that would be necessary or if that should be something the Quick org should privately own. Thoughts @modocache?\n. Nimble 1.0.0-rc1 now includes pre-built binary. Thanks everyone! Reopen or file more issues if this is still a problem.\n. Merged. Pushed v0.4.2. Thanks!\n. As what @rbeeger says.\nIt's generally bad form to do assert against a concrete type. Usually it's an indirect validation. A concrete type-check is a proxy assertion: by assuming particular type supports all the behavior you intend.\nWhile it might be possible to do this assertion with Swift types, those matchers would never fail if they compiled since Swift's type checker will ensure that your types always conform. I considered adding it, but deemed it more detrimental to writing good tests than their potential benefit (if any).\n(Objective-C types don't ensure type-correctness so it makes more sense.)\n. @rbeeger, I'd say that concrete types that a factory produces behind a protocol (or parent) type is an implementation detail. The caller should probably never know the concrete types. But I see that testing factories tend to make the sense for brevity's sake.\n. Thanks @sharplet!\n. What type is FBLikes? Is it an objective-c based or swift based type?\n. The Swift compiler ensures proper types that makes beAnInstanceOf redundant. The compiler doesn't give a great error, but Nimble only supports objective-c types for Objective-C based types.\nThis is a duplication issue of https://github.com/Quick/Nimble/issues/119.\n. No worries @pfitz.\nI think it's worthy to try and surface this more usefully than the current compiler errors Swift is. I've opened that as another issue: #123.\n. Is your storyboard particularly large?\nAn alternative is to simply advance the runloop yourself:\nobjc\n[[NSRunLoop mainLoop] runUntilDate:[NSDate date]]\nAlthough you may want to increase the run date time.\n. Thanks for the suggestions!\nCircleCI recently added support for Xcode (including 6.2 + 6.3), but it's in beta. I'll see if I can get it up and running on Nimble in the next few days. But until then, ignore it :stuck_out_tongue_winking_eye: \n. I've added a small change for FailureMessage since it's part of breaking changes. But also I think I've got circleci up and running on this PR.\n. Merged. Also, 1.0 sounds good. I'll probably add a few documentation strings before cutting 1.0.\nAlso, I create a repo for code styles :sunglasses:. It's far from complete. I'll try to add to it in the coming weeks when I get time: https://github.com/quick/codestyle. Feel free to update it\n. The raiseException() no-arg is already on the README. It's secretly been there :wink:.\n. Hey @ypwu1, did the suggestions discussed here help?\n. Closed, Please reopen if this is still an issue. Thanks everyone for helping to diagnose. :+1: \n. Hey @Noobish1,\nWhat cocoapods version are you using?\nI'm suspicious that it's related to https://github.com/Quick/Nimble/issues/128. I'll try to get some time to look into this in the next few days since I did see this before.\n. Thanks @Noobish1. I was able to reproduce. It seems like OS X frameworks want this import, but iOS refuses to build if this import line is present. Needs some more investigation.\n. I've looked into this a bit further. It's either something with cocoapods or xcode. The #import <Nimble/Nimble-Swift.h> line seems required for subsequent build of Nimble that isn't the first build. Putting this first line will always make the first build fail because the \"Nimble\" module doesn't exist.\n. Closing this issue. I've filed a radar to the fruit company. The easiest workaround is to use @import Nimble;. I've updated the README to use that instead.\nThanks for reporting the issue :smile:.\n. Thanks @rbeeger! :+1: \n. Sounds good to me!\n. Hey @gavrix,\nSee Lazily Computed Values, it should be something like this:\nobjc\nexpectAction(@throw [NSException exceptionWithName:@\"\" reason:@\"\" userInfo:nil]).to(raiseException());\nThat being said, the example in the \"Exceptions\" section isn't great and needs to be improved. \nAlthough I do like the syntax that you're proposing for ObjC ;).\n. Closed, this has been merged into swift-2.0 / 2.0.0-rc.2.\n. Thanks @joshuatbrown, I've updated the releases with the new changes :+1: \n. Thanks @neilpa! Yeah, CircleCI only has Xcode 6.3 support atm and the ignore branch feature doesn't seem to work well with PRs.\n. Thanks @robb!\n. @dwaite, I'll be merging this PR for now, but I'm still open to refactoring to a ResultType return before Swift 2.0 goes final. But in the meantime, I think merging this PR through #143 will be useful for users to try out now.\nThanks for keeping me in the loop with your investigations :+1: \n. Hey @mrackwitz,\nThanks for the PR! :+1: \nI like the API you're providing with throwError. I think much better than what I have in #142. Although I do prefer #142's behavior with uncaptured errors:\nswift\nexpect { try jsonDeserialize(\"{\") }.to(equal(nil)) // Failed - unexpected error thrown\nIt points to the failure location better than showing the failure at try! in Expression.evaluate.\nI think some merge between the two PRs would be great: Your matcher + #142's internal try refactoring.\n. Hey guys,\nI haven't looked much into making it completely devoid from XCTest, but it's linked to support the primary use case of making test writing for apps easier. I do want to eventually divorce from explicit XCTest linkage before open source swift is released, so it's on the horizon.\nThere are some avenue of options that I haven't tried yet, but it might be worth exploring:\n- Using Weak Linking to refer to XCTest. This might require breaking some initialization / bootstrap work for Nimble. That is acceptable if it means XCTest can be optionally linked.\n- Use C-styled runtime magic to load/lookup the XCTest function at runtime. I'm not too thrilled about this option TBH.\n- Separate the XCTest integration to a separate library. I rather have the Nimble project (or at least preserve the way people install Nimble) integrate with XCTest and separate out the \"core\" to a separate project. Although this creates ongoing managerial burden I'd like to avoid with the first option if possible.\n. @modocache,\nWeak linking is the best option simply because it covers both cases without having restore to making another framework. Recent Xcode betas seem to better support weak linking swift code.\nAt worse, existing users of Nimble with a weakly linked XCTest only need to explicitly link XCTest.\n146 is acceptable if there is minimal intrusive change for existing users (aka - having to explicitly linking to XCTest) and supports the case @tjarratt and @briancroom intend - using Nimble without having to link to XCTest.\n\n\nUse C-styled runtime magic to load/lookup the XCTest function at runtime. I'm not too thrilled about this option TBH.\n\nHonestly this option is out of my depth. Could you explain what this would look like, or link to some resources to learn more?\n\nUsing dlopen and it's family of c functions allows you to manually invoke the dynamic linker/loader. This technically allows us to emulate weak linking via code. But dlopen may not be supported / allowed by the simulator or actual devices on iOS, since it's a load-level api. I haven't really tried.\n. This should be already implemented since Nimble 2.0.0. Closing. Thanks guys for all the hard work!\n. Thanks @briancroom!\n. Don't worry about CircleCI, it doesn't support Swift 2.0 yet, so it's always red for the swift-2.0 branch. I manually run the tests before merging in PRs. The master branch is for stable swift (1.2).\nHey @briancroom, are you doing something special to get Nimble working without XCTest? I've tried importing Nimble as an app dependency in a demo app as an example (using carthage or cocoapods), but it doesn't work. libswiftXCTest is still required.\n$ otool -L /Users/jeff/Library/Developer/Xcode/DerivedData/Nimble-ejlspkozrikyvdavdrwfoyknlvax/Build/Products/Debug-iphoneos/Nimble.framework/Nimble\n/Users/jeff/Library/Developer/Xcode/DerivedData/Nimble-ejlspkozrikyvdavdrwfoyknlvax/Build/Products/Debug-iphoneos/Nimble.framework/Nimble (architecture armv7):\n    @rpath/Nimble.framework/Nimble (compatibility version 1.0.0, current version 1.0.0)\n    @rpath/libswiftXCTest.dylib (compatibility version 0.0.0, current version 0.0.0)\n    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1223.1.0)\n    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1223.0.0)\n    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1223.1.0)\n    @rpath/libswiftCore.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftCoreGraphics.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftCoreImage.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftDarwin.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftDispatch.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftFoundation.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftObjectiveC.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftSecurity.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftUIKit.dylib (compatibility version 0.0.0, current version 0.0.0)\n/Users/jeff/Library/Developer/Xcode/DerivedData/Nimble-ejlspkozrikyvdavdrwfoyknlvax/Build/Products/Debug-iphoneos/Nimble.framework/Nimble (architecture arm64):\n    @rpath/Nimble.framework/Nimble (compatibility version 1.0.0, current version 1.0.0)\n    @rpath/libswiftXCTest.dylib (compatibility version 0.0.0, current version 0.0.0)\n    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1223.1.0)\n    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1223.0.0)\n    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1223.1.0)\n    @rpath/libswiftCore.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftCoreGraphics.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftCoreImage.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftDarwin.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftDispatch.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftFoundation.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftObjectiveC.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftSecurity.dylib (compatibility version 0.0.0, current version 0.0.0)\n    @rpath/libswiftUIKit.dylib (compatibility version 0.0.0, current version 0.0.0)\n. Hey @briancroom, would this script be safe to run in always or does this cause surprising failures when XCTest should automatically be linked, but isn't? I'm wondering if this is something more automatic or documentation that needs to mention how to run Nimble without XCTest.\nSorry, I haven't been spending significant time on Nimble since it's annoying that Xcode 7 beta 5 crashes on Nimble's test suite.\n. Hey @briancroom,\nIn Xcode 7 beta 5, it doesn't seem like      'SWIFT_STDLIB_TOOL_DESTINATION_DIR' exists?\n. Oh never mind, I configured it incorrectly. My bad. But I still seem to get failure when running. This could be because I'm now running Xcode 7 beta 6.\n\nSorry for the long turnaround. I've also uploaded my repo that I've been using to test: https://github.com/jeffh/NimbleCocoaPodsExample.\nI'll raise this issue to a higher priority so I can respond more regularly.\n. I'll take a look tonight. Thanks.\n\u2014\nSent from my iPhone\nOn Wed, Sep 2, 2015 at 10:56 AM, Brian Croom notifications@github.com\nwrote:\n\nHey Jeff, thanks for that repo. That was useful for testing just now. I just found some time to get this rebased to include the new commits on the swift-2.0 branch. After doing so, I was able to get your example repo working by using the following Podfile:\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'NimbleCocoaPodsExample' do\n  pod 'Nimble', :path => '../TestingTools/Nimble' #:git => 'https://github.com/briancroom/Nimble', :branch => 'weakly-link-xctest'\nend\ntarget 'NimbleCocoaPodsExampleTests' do\n  pod 'Quick', :git => 'https://github.com/Quick/Quick', :tag => 'v0.6.0'\n  pod 'Nimble', :path => '../TestingTools/Nimble' #:git => 'https://github.com/briancroom/Nimble', :branch => 'weakly-link-xctest'\nend\nWhen you get a few minutes, could you take another look?\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/pull/146#issuecomment-137190535\n. Thanks @briancroom, I've gotten it to work. Although, I'm not sure if it was cache cleaning, cocoapods update, or xcode update that's related to the original issues i've been having.\n. Yes! :+1: \n. Thanks again @romanki\n. Hey @ratkins. Nope, you're not missing anything. Nimble doesn't currently add any extra == implementations for types not owned by Nimble. Swift's stdlib doesn't support equality of arrays of optionals. It would be good to file a radar for this.\n\nSecondarily, we could add equality. Investigation is required to see if implementing == for array of optionals causes problems when other libraries / applications also implement it. Alternatively, an nimble-specific overload could be defined.\n. Yes, a Nimble-specific one is preferred.\n. Closing. This is now in v3.1.0. Thanks everyone!\n. Thanks @sync!\n. Thanks @abbeycode!\n. Thanks @brentleyjones\n. Hey @dduan,\nThanks for reminding me to push another release. I'll cut a release once I fix my CI builds.\n. Release cut. Closing\n. Good idea :+1:.\nI tend to use the latter form because I personally see it as less implementation magic, but I don't really have strong opinions either way.\n. Feature was merged sometime ago, and I forgot about this issue. Closing. Thanks for filing an issue!\n. Sorry about that. Still had the old syntax stuck in my head. Updated! Thanks for filling an issue @mrackwitz! :smile: \n. Updated. Thanks @ikesyo, I can't seem to not cause this error :cry:.\n. :+1: Thanks @mrackwitz, that was also my bad for missing that.\n. @fatuhoku Did you try full cleaning the project? Xcode is inconsistent with modules and tends to persist these errors longer than it should.\n. Thanks @romankl!\nSorry for the longer turnaround, the latest Xcode 7 beta crashes when compiling Nimble's test suite. So I need to do manual verification. I added some tests for fail() and failWithMessage() and merged the PR.\n. Yes please. Thanks!\n\u2014\nSent from my iPhone\nOn Thu, Aug 13, 2015 at 4:34 AM, romankl notifications@github.com wrote:\n\nAh the unit tests, sorry. \nShall I submit a back port for the swift 1.2 branch? (Just to keep the API equal across the versions)\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/pull/163#issuecomment-130630689\n. I've disabled bitcode for Nimble. Thanks for filing @deemadden!\n. Hey @deemadden,\n\nThanks for filing this issue. I don't know about Xcode 7 beta 5, but previous beta versions also gave this warning. Removing the extra framework include causes Quick & Nimble to not build (after full clean). I haven't looked at it since, but it would be idea to resolve.\n. This should be resolved on master now (swift-2.0 branch has been merged into master too). Closing.\nReopen/create a new issue if you still see this. Thanks!\n. Hey @romankl, this is the swift-1.1 branch, did you mean the master branch (swift 1.2)?\n. Thanks @romankl!\n. Thanks @romankl!\n. Thanks for the discussion, Nimble hasn't cut a new release since Nimble's test suite currently fails in Xcode 6 beta 6. I'll get around to addressing it in the next few days when I have time before cutting a release.\n. @akhilsuri, are you having this issue on Nimble's swift-2.0 branch? I don't see this issue on my machine on my machine.\n. Thanks @zbeckman, I was able to reproduce. I'll get a fix in soon\n. Could you submit a PR with tests? Sounds great!\n. Yeah, although it might be better to improve the 'NMBDoubleConvertible' protocol to support this. Although I don't remember if nsdate printouts are as precise to the millisecond. Nothing is more annoying than hiding the source of the inequality.\n\u2014\nSent from my iPhone\nOn Wed, Aug 26, 2015 at 8:54 AM, Dov Frankel notifications@github.com\nwrote:\n\nI committed a solution, but I wish the reported failure had formatted dates, instead of the opaque NSTimeInterval:\n\nexpected to not be close to <462296591.0000> (within 10.0000), got <462296580.0000>\nWhat's the easiest way to achieve that? Should I overlose the beCloseTo matcher with explicit date support that formats the message appropriately?\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/171#issuecomment-135077892\n. I'm not sure what you're trying to get at. Do you have an short example?\n\n\nIf you're just concerned about how to print the error message, you can also completely override the error message using failureMessage.stringValue.\n. Thanks for the clarification.\nIt depends on what test you're writing: for testing equality for test types or to simply test value equality only for tests.\nIf you're testing equality, you'll need to either write a matcher, define a helper function, or compare exhaustively for each leaf-value you have.\nOtherwise, your options are to implement the == operator. You can keep them high-level if you implement Equatable for all your own types.\nIf you want to be explicit that it should only be available for tests, overload Nimble's == and equals matcher functions. I encourage you to see the Nimble's equals source for examples.\n. Looks good. I think having a protocol extension for stringRepresentation that has a default protocol implementation could be useful to generally cover the NSNumber case. Here's some example implementations:\n- call debugDescription for CustomDebugStringConvertible types\n- call stringValue for CustomStringConvertible types\nAnd I think that would allow you to not have to explicitly implement one for NSNumber.\nSide note: It's probably better that beCloseTo uses FloatingPointType instead of CDouble. But I'll create another issue for that after this PR is merged.\n. Thanks @abbeycode!\n. It should be in 2.0.0-rc.3. RC 2 was before this PR.\n. When Nimble's test suite actually passes, there are currently some issues related to iOS that my Xcode Server is experience. But since there seems to be an increase in server hanging, it taking a bit longer than normal to troubleshoot.\n. Closing, I've pushed v2.0.0 RC 3. Thanks for filing an issue.\n. Hey @zbeckman,\nI'd like to understand more context behind or. Normally, it's preferred for tests to be explicit about what it's comparing against. In your example above, I'd expect someThing to be one of the given values.\n. You've convinced me, the alternatives are less ideal. I'm just not sure how the DSL should look. Some random ideas to ponder over:\nswift\n// or on expectation\nexpect(value).to(equal(2)).or(equal(3))\n// operator ?\nexpect(value).to(equal(2)) || equal(3)\nswift\n// or matcher combinator ?\nexpect(value).to(or(equal(2), equal(3))\n// looks better as an operator\nexpect(value).to(equal(2) || equal(3))\nswift\n// or as a wrapper around expect\nanyOf(\n    expect(value).to(equal(2)),\n    expect(value).to(equal(3))\n)\n// operator ?\nexpect(value).to(equal(2)) || expect(value).to(equal(3))\nSomething to sleep on.\n. This is now in v3.1.0. Closed. Thanks everyone for the contributions!\n. Hey @ashfurrow,\nSorry for the long turn around. Do you still get this issue? Do you still get this issue if you remove the guard clause in pollBlock of Nimble?\n``` swift\n// Try this implementation\ninternal func pollBlock(pollInterval pollInterval: NSTimeInterval, timeoutInterval: NSTimeInterval, expression: () throws -> Bool) -> PollResult {\n    let runLoop = NSRunLoop.mainRunLoop()\n    let startDate = NSDate()\n    runLoop.runUntilDate(startDate)\n    var pass = false\n    do {\n        repeat {\n            pass = try expression()\n            if pass {\n                break\n            }\n            let runDate = NSDate().dateByAddingTimeInterval(pollInterval)\n            runLoop.runUntilDate(runDate)\n        } while(NSDate().timeIntervalSinceDate(startDate) < timeoutInterval)\n    } catch let error {\n        return .ErrorThrown(error)\n    }\nreturn pass ? .Success : .Failure\n\n}\n```\n. Random question: do you tests that use WebKit?\n. This will require more investigation into what is being stuck on the run loop when this error occurs.\n\u2014\nSent from my iPhone\nOn Wed, Oct 14, 2015 at 12:34 PM, Ash Furrow notifications@github.com\nwrote:\n\nNegativo.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/177#issuecomment-148169558\n. Not being familiar with your codebase, but how many timers do you have when you print out the run loop around the failure?\n\nswift\nprint(NSRunLoop.mainRunLoop().getCFRunLoop())\nIt should give you a rough guess how much is enqueued. Note that timers will include long-deferred timers too (eg - 5 years in the future).\nIf you want to look deeper, you'll probably have to do some trickery on the CFRunLoop. A place for inspiration is my defuncted Robot project which set all timer fire dates to now. (aka - use CFRunLoopTimerGetNextFireDate)\n. Hey @ashfurrow, I don't know if you still have a case to reproduce, but could you try PR #224? It's a rewritten async code that hopefully addresses flaky issues.\n. Fix is on master. Closing. Thanks for the help @ashfurrow.\n. Hey @bhawna08,\nIt's a pretty broad question that depends on how you're building your application:\n- Is it iOS / OS X?\n- Are you using Storyboards, Nibs/Xibs, or just in code?\nI think the Quick Documentation can be useful to learn how to test in views.\n. No worries, closed. I've replied on that thread too. :+1: \n. hey @bhawna08, what do you mean by doesn't work? What error message do you get?\n. I'm, unfortunately, unable to reproduce this on my local machine (high-end MBP 15' mid-2014). Running Nimble's test suite multiple times (which includes that code) doesn't seem to reproduce for me.\n. I have merged a fix into master. Please let me know if you have any issues (a release will come out later today).\n. Closing. This is now in v3.1.0.\n. I don't know the context but could you read from the properties?\nswift\nexpect(myController.myTextLabel.textColor).to(equal(UIColor.redColor()))\n. Closing for idle activity, please reopen if you're still having problems or confusion. Thanks!\n. Looks good @mkauppila :+1: I do think it would be nice to expand haveCount to the more general SequenceType or CollectionType in swift. Same for some of the Foundation Objective-C types: NSDictionary, NSSet, NSHashTable.\n. Also, don't forget to document this matcher in the README :smile: \n. Yeah. Add NSMapTable too. I forgot about that one. Thanks!\n. Thanks @brentleyjones!\n. Merged in. Closing\n. Closing, I've cherry-picked this into master, which is now supporting swift-2.0.\nThanks @taiheng! :smile: \n. Closed. I've cherry-picked this into master, which is now supporting swift-2.0.\nThanks @mkauppila! :smile: \n. Merged, thanks @keith.\nSorry, I was busy upgrading my devices to GM :hourglass: \n. \ud83d\udc4d agreed! Thanks for going ahead and doing it.\nSent from my iPhone\n\nOn Sep 23, 2015, at 8:46 PM, Brian Gesiak notifications@github.com wrote:\nEnded up deleting the branches. Pretty sure you can restore them if necessary anyway.\n\u2014\nReply to this email directly or view it on GitHub.\n. Hey @bhawna08,\n\nI don't see this issue when I'm trying to reproduce on my own machine. I'll need some details of your setup:\n- Does this error exist without Nimble?\n- Are you installing via cocoapods, carthage, or manually?\n- Version of Xcode?\n- Version of Nimble?\n- Is your project a hybrid Objective-C / Swift project?\nIf you can, if you have a sample project that can reproduce the behavior that's ideal.\n. I'm closing this issue. @bhawna08, please reopen with more information if your problem isn't resolved.\n. Current work is on my repo. Checked off what's covered right now (App bundles with test bundles for iOS & OS X).\n. Hey @aexmachina,\nDo you get this when using master? swift-2.0 was merged into master a bit time ago. It's been deleted now. What Xcode versions and platforms are you using carthage for? You might need to specify a platform with carthage: (eg - --platform tvOS)\nI don't actively use carthage so I'm not sure what's the best way to troubleshoot this.\n. Hey @aexmachina,\nThe errors seem to indicate that Darwin headers are missing. Does your project build without Nimble and when you use the Darwin module? I can't reproduce locally.\nAlso, could you try running NATs to see if this fails for you too?\n- Jeff\n. Do you have a sample project that demonstrate this failure. I'd like to know the issue with setting up via Carthage\n\u2014\nSent from my iPhone\nOn Mon, Oct 5, 2015 at 10:25 PM, Simon Wade notifications@github.com\nwrote:\n\nClosed #191.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/191#event-427566840\n. Thanks @nikita-leonov!\n. You have time. I'll most likely get time time to push a release this weekend.\n\n\u2014\nSent from my iPhone\nOn Wed, Sep 30, 2015 at 11:39 AM, Nikita Leonov notifications@github.com\nwrote:\n\n@jeffh with pleasure. Any plans on doing release / another RC with this change? Do I have one or two days to push trough one more PR with the similar change for fail?\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/pull/194#issuecomment-144502558\n. Thanks for the heads up. That's definitely not ideal. I'll revert it this weekend.\n\n\u2014 Sent from my iPhone\nOn Thu, Oct 1, 2015 at 3:21 PM, Nikita Leonov notifications@github.com\nwrote:\n\n@jeffh ok, forget about this. There is a swift language limitation \u2014\u00a0curried functions does not support default values. As result it is impossible to implement multi-purpose interface that will not cause ambiguity for an end user. Looks like we will need to wait a little bit for swift updates.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/pull/194#issuecomment-144865283\n. Oh ok. I guess I don't really understand what you previously said then. I'll have to play around with it when I get a chance\n\n\u2014\nSent from my iPhone\nOn Thu, Oct 1, 2015 at 10:16 PM, Nikita Leonov notifications@github.com\nwrote:\n\n@jeffh looks like something lost in translation :) I was talking about impossibility of fail implementation. Current PR with done that was recently merged is fine.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/pull/194#issuecomment-144923999\n. Hey @nikita-leonov,\n\nI'm not sure about why. It seems like an bug report for Apple. It seems like the the type inferencer of the Swift compiler decides to use the NMBContainer specific version of contains, which it then fails later down the line:\n\n- Jeff\n. I can't reproduce this anymore, so I'm closing the issue. It seems like the Swift Compiler has fixed it. Feel free to reopen this issue if you still encounter this bug.\n. Hey @bielikb,\nThis has been a past issue before. Bitcode generation is disabled on Nimble because XCTest doesn't support it either - which gives errors that you see.\nAlthough since you've mentioned you're not linking to XCTest, have you correctly added the removed script mention in the README section?\n- Jeff\n. Closing, please try on v3.0.0 and reopen issue if you're still having problems. Thanks!\n. There's no implementation of equality for ErrorType in Nimble. A pull request (with tests) is appreciated though!\n\u2014\nSent from my iPhone\nOn Tue, Sep 29, 2015 at 3:59 PM, Scott Robbins notifications@github.com\nwrote:\n\nSo let me know if there's a better way to do this that I'm overlooking.\nI have a situation in a unit test where I'm giving (Object1) a mock delegate (Mock1). I'm then calling an async function on Object1 that is going to notify Mock1, its delegate of an error (passing an ErrorType). In my test I am trying to confirm that the error that Mock1 received is a specific error.\nThe problem i'm running into is that ErrorType doesn't conform to Equatable, and I can't extend a protocol to conform to another protocol. Because of this, I can't say in the tests\nswift\nexpect(mockObject.receivedError).to(equal(ThisErrorEnum.SomeError))\nI can compare the domains and the codes by hand in each test but that's not very elegant. Temporarily I put this in my test module:\n``` swift\nfunc equal(expectedValue: ErrorType?) -> NonNilMatcherFunc {\n    return NonNilMatcherFunc { actualExpression, failureMessage in\n        failureMessage.postfixMessage = \"equal <(stringify(expectedValue))>\"\n        let actualValue = try actualExpression.evaluate()\n        if expectedValue == nil || actualValue == nil {\n            if expectedValue == nil {\n                failureMessage.postfixActual = \" (use beNil() to match nils)\"\n            }\n            return false\n        }\n    return expectedValue! == actualValue!\n}\n\n}\nfunc stringify(error: ErrorType?) -> String {\n    return \"Domain: (error?._domain) | Code: (error?._code)\"\n}\nfunc ==(lhs: ErrorType, rhs: ErrorType) -> Bool {\n   return (lhs._domain == rhs._domain) && (lhs._code == rhs._code)\n}\n```\nSo my question is whether there's an elegant way that already exists to make this comparison, and if not whether adding an equal function to handle ErrorTypes specifically would be useful.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/197\n. Not sure, enums don't inherit an existing type that can be overridden for this behavior. I'll revert this merge commit before release. I didn't consider this case, thanks @sync.\n. This has been merged into master (#260) using a matchError.\n\nI'll close this issue when a release has been made.\n. Cut v4.0.0. Closing.\n. Thanks @scottrobbins!\n. In order to not block release, I've reverted this commit until this is resolved.\n. Hey @nikita-leonov,\nIt seems to me like some overloading would resolve this instead of having to revert:\n``` swift\npublic func waitUntil(timeout timeout: NSTimeInterval = 1, file: String = FILE, line: UInt = LINE, action: ((Any?, Any?...) -> Void) -> Void) {\n    NMBWait.until(timeout: timeout, file: file, line: line, action: bridgeToVoidAction(action))\n}\npublic func waitUntil(timeout timeout: NSTimeInterval = 1, file: String = FILE, line: UInt = LINE, action: ((Void) -> Void) -> Void) {\n    NMBWait.until(timeout: timeout, file: file, line: line, action: action)\n}\nprivate func bridgeToVoidAction(vargAction: ((Any?, Any?...) -> Void) -> Void) -> ((() -> Void) -> Void) {\n    return { voidDone in\n        vargAction() { _ in\n            voidDone()\n        }\n    }\n}\n```\nI haven't thoroughly tested all those cases with this. If we do keep this, we should add more cases for this feature :)\n. Does this not work in swift 2.1? I was using stable Xcode (7.0).\n\u2014\nSent from my iPhone\nOn Thu, Oct 8, 2015 at 8:49 AM, Nikita Leonov notifications@github.com\nwrote:\n\n@jeffh yes, as I mentioned in rollback it is my plan to provide overloads with multiple arguments. It will work, but only in Swift 2.1 since it has functions covariance support. I think implementation set of functions with up to 5 arguments should be enough. Playground with proof of concept available by the link \u2014\u00a0https://drive.google.com/file/d/0BwZZrY1XCsVGUkMtcGxzWTNodDQ/view?usp=sharing\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/199#issuecomment-146585446\n. I don't quite understand what you're saying @nikita-leonov, using the overloaded code I listed before seem to cover both of those cases (aka - they pass) on Swift 2.0.\n\nIs there something I'm misunderstanding?\n. Hmm, I can't reproduce what I produce before in the playground. But specifying overrides of waitUntil will give you this:\n\nAnd strangely enough, this has no compiler errors:\n\nI'll merge your revert to allow more time to investigate it. I'm thinking it's a bit too early to adopt.\n. Thanks for the effort @nikita-leonov. I'll close the issue for now. Feel free to reopen this issue/pr if apple fixes this.\n. Thanks @jondwillis!\n. Embarrassing oversight on my part. Thanks for the PR, @nmccann! :smile: \nAs a side note, issues are not required prior to a PR. Although an issue helps avoid waste if you're considering major changes in the project.\n. Holding to merge. See comment on issue.\n. Thanks @yoichitgy!\n. I think swift 2.0 changed this behavior. A PR to change the Readme would be awesome!\n\u2014\nSent from my iPhone\nOn Wed, Oct 14, 2015 at 6:43 AM, Jonas Schmid notifications@github.com\nwrote:\n\nThe README states:\n\nbeIdenticalTo only supports Objective-C objects: subclasses of NSObject, or Swift objects bridged to Objective-C with the @objc prefix.\nI just tested using Swift-only types and it works fine. \nDid it change?\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/204\n. Thanks @jschmid!\n. You're replacing UIColor type to a generic type in the scope of the function.\n\n\nChange this line: \nswift\npublic func equalColor<UIColor>(expectedValue: UIColor) -> NonNilMatcherFunc<UIColor> {\nTo this:\nswift\npublic func equalColor(expectedValue: UIColor) -> NonNilMatcherFunc<UIColor> {\nCheers,\nJeff\n. Sure, although it should be called beCloseTo and work for OSX and iOS.\nI'll close this issue since it's not a direct Nimble bug. Please open a new issue or create a PR for that change.\nThanks,\nJeff\n. Hey guys,\nSorry for the slow turnaround, most of the current contributors to Quick are currently not active and I can only guarantee a few hours a week.\nI would be more comfortable releasing if I didn't receive conflicting results of enabling and disabling bitcode for tvOS. I think I'll just bite the bullet and release with bitcode enabled and see if there's any fallout for that.\nThanks,\nJeff\n. I've cut v3.0.0.\nPlease let me know if you're having any issues.\n. Please make it as a separate PR. Thanks!\nSent from my iPhone\n\nOn Oct 22, 2015, at 5:42 PM, Rhys Powell notifications@github.com wrote:\nIt seems like we should probably add a target to build for tvOS, though I'm not sure if that needs to be done as part of this PR.\n\u2014\nReply to this email directly or view it on GitHub.\n. Hey @leepfrog, does removing tvOS resolve any issues? I'll be look into it after I get Quick & Nimble to compile on xcode7.1\n. Verified issues with tvOS, merged. Thanks @leepfrog!\n. Hmm, historically XCTest doesn't contain bitcode which would cause the same issue as https://github.com/Quick/Quick/pull/409 and https://github.com/Quick/Nimble/issues/170.\n\nI'll have to take a look more thoroughly when I get more time.\n. Hey @neilpa, I've enabled bitcode for tvOS. Let me know if you have any more issues.\n. @neilpa, Please submit a PR for this. My apple tv has not arrived yet (it got lost in shipping), so I can only verify the simulator.\n. Hey @LukeDefeo,\nYou'll need to get your enum to implement equality: either as an Equatable, RawRepresentable, or OptionSetType. rawValue is not native to enum types without inherited one of those types (or inheriting a type that implements one of those)\nAlternatively, you can also override Nimble's equal operator to support your enum type.\n. @LukeDefeo,\nDid you solve your problem or is this still an issue?\n. Are you testing on the simulator or on device?\n. Carthage wants to build for both device and simulator platforms into one binary. I'm not sure if there's anything we can do.\nIt's probably better to file a radar to apple about this. A second-best solution is to see if the carthage team would want to address this.\n. That sounds good to me. Just make sure it honors Nimble's accidental nil-ness behavior for all other equalities.\n- Jeff\nSent from my iPhone\n\nOn Oct 31, 2015, at 7:02 PM, Jerson Michael Perpetua notifications@github.com wrote:\nHow about if we define a constant (global only to Nimble):\nlet Nil: NilLiteralType = NilLiteral()\nwhere NilLiteralType and NilLiteral are defined as:\nprotocol NilLiteralType {}\nstruct NilLiteral: NilLiteralType {}\nand override the equality operators:\nfunc ==(lhs: Expectation, nilLiteral: NilLiteralType)\n{\n  lhs.to(beNil())\n}\nfunc !=(lhs: Expectation, nilLiteral: NilLiteralType)\n{\n  lhs.toNot(beNil())\n}\nso that expressions like the following are possible:\nexpect(foo) == Nil\nexpect(bar) != Nil\nI can create a PR if you don't think this is a stupid idea.\n\u2014\nReply to this email directly or view it on GitHub.\n. Nope, my cert expired and carthage didn't error when I auto-uploaded it. I'll push a new one later tonight. Thanks for reporting this @roman-dzieciol!\n. Ok, I've uploaded it. Note that it currently does not include tvos (there are current pending issues with it).\n. Hey @mfclarke, how many timers do you have when you print CFRunLoop near point where you get the main thread stall?\n\nswift\nprint(NSRunLoop.mainRunLoop().getCFRunLoop())\n. Hey all,\nI merged a fix on master, if if you can confirm that would be great! I'll try to get a release out soon.\n. Closing. This is now in v3.1.0. Thanks everyone!\n. Do you have a example test case?\nSent from my iPhone\n\nOn Jan 20, 2016, at 8:35 AM, Maximilian Clarke notifications@github.com wrote:\n+1, issue still persists with Xcode Server for me too\n\u2014\nReply to this email directly or view it on GitHub.\n. It's always possible to use something else other than to\n. @modocache: I just don't see a big upside for the breaking change for existing users. I'm not against changing the entire API, but for what amounts to syntax change (with little end-user benefit), it doesn't seem as critical to break existing users. While I do understand the visual appeal of the dot-styled syntax and it's autocomplete benefits, I need more convincing to break every user of Nimble.\n\nMaybe I just don't see it, but I'm not visualizing unique features, significantly better code (maintenance) as a benefit to this change. For example, an alternative to writing combinators:\nswift\n// Adding `or` combinator to the existing system\nexpect(something).to(equal(2) || equal(4))\nWhile I haven't really thought through it enough to make an opinionated stance to support combinators, the existing system makes it easy to extend towards that. But maybe enough people don't care about that kind of feature to be worth effort.\nIf there's something significantly more advantageous to doing dot-styled syntax, I could be convinced for a drop-the-world syntax replacement. Making (thousands of) developers to spend several hours updating their expectations is wasted engineering I prefer not to do at a drop of a hammer. I'd rather to a gradual migration instead (in parallel for several releases before removing the old).\nAlso, it needs more thorough evaluation based on what the swift compiler can handle (these existing generics have been painful to extend because of it).\n\nNow my 2 cents about the syntactic style.\nThe first style:\nswift\nexpect(foo).isEmpty()\nexpect(foo).isNotEmpty()\nLooks pretty expensive to implement and maintain. We'd need four methods for every matcher-expectation combination (to, toNot, toEventually, toEventuallyNot). Correct me if I'm wrong, but I'm not too thrilled about that.\nThe second style is much more to my liking overall. There are possible other styles, just throwing some ideas:\n- expect(x).should.equal(y) (old-rspec; gomega)\n- it(x).should.equal(y) - We'd have to make sure overloading works between Quick & Nimble\n- then(x).will.equal(y), then(x).should.equal(y), then(x).is.equalTo(y) - more cucumber-like\n. Sorry for the slow response. Still recovering from an illness :frowning:.\n176: Was requesting matching IPv6 or IPv4 addresses (and not just by http(s)). While you can use a conditional regex, it gets far less pretty:\nswift\nexpect((device.primaryIPAddress =~ RegularExpressions.IPv4Pattern) || (device.primaryIPAddress =~ RegularExpressions.IPv6Pattern)).to.beTruthy()\nA matcher framework like Hamcrest uses combinators to build a feature-rich matcher library. It's more flexible at the cost of less discoverability (because it's all function composition):\njava\n// java\nassertThat(responseString, either(containsString(\"color\")).or(containsString(\"colour\")));\nIn my opinion, good architecture of software is keeping the most options available regardless about what design patterns are used. I understand people love protocol extensions as a new paradigm, but it seems mostly the same to me -- granted, with better discoverability semantics. Just saying it's an evolution to a language is interesting to note, but it's just an appeal to authority. Language designers can make mistakes too.\n\nHere's what I've understand around the tradeoffs of the dot-syntax:\nPros:\n- It's less syntactically noisy\n- It's more discoverable for new users (eg - autocomplete)\nCons:\n- Disallows the creation of matcher combinators\n\n@stephencelis, that's for discovering that both can live side by side. It's good to hear :+1:.\n. If we look at that, it's ambiguous meaning:\nswift\n// a.\nexpect(device.primaryIPAddress).to.match(IPv4Pattern)\n// b.\nexpect(device.primaryIPAddress).to.match(IPv4Pattern).or.match(IPv6Pattern)\nHow does Nimble know which form (a or b) is executing? Is it ok to perform an assertion during the invocation to match? That would invalidate the purpose of the or. Alternatively, you'll need some wrapping call around the grammar (or only use operators):\nswift\n// || operator takes both args as autoclosures to capture both matchers:\nexpect(device.primaryIPAddress).to.match(IPv4Pattern) || \n   expect(device.primaryIPAddress).to.match(IPv6Pattern)\nA combinator needs to control when it's child matchers execute. I don't think that syntax can cover it.\n. That requires double the implementations for matcher writers. But I think you've convinced me enough. I'll merge that PR once it's a good state :+1: \n. Hey @stephencelis,\nSorry for worst turn-around on record. I'll look to try and get the PR up-to-date in the coming weeks.\nI'm still interested in getting this into Nimble. I was wondering what were you're thoughts on getting satisfyAnyOf to function as a protocol extension?\n. I'll add a note to get around to this. Although I want to new matcher api into master to avoid lots of conflicts.\nOn Feb 23, 2017, 10:30 AM -0800, Brian Gesiak notifications@github.com, wrote:\n\n\nit might be good for one of the owners to itemize the requirements!\n\n\nI think @jeffh (https://github.com/jeffh) understands these best. No pressure \ud83d\ude0e\u26f1\ud83c\udf24\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/pull/218#issuecomment-282078627), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCN5YIUbD_HQNzjy8kJcbs-FEDv8Bks5rfdBagaJpZM4Gm7YK).\n\n. Is there a way to get this integrating into Nimble proper? I'm not familiar\nwith Playgrounds, but I'm not sure why it needs to be a minimal subset of\nNimble.\nOn Sat, Feb 25, 2017 at 11:22 AM Brian Gesiak notifications@github.com\nwrote:\n\nThat sounds awesome! If you wanted, I'd be happy to add it as a project in\nQuick's GitHub organization, or you maintaining it as a totally separate\nthing, with as much or as little attribution as you'd like. :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Quick/Nimble/pull/218#issuecomment-282506110, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEMCF1vKpKmhjuogO3Y0X1fP_jef0Fbks5rgH90gaJpZM4Gm7YK\n.\n. Feel free to transfer to the Quick org. I'm fine with that as well. In response to the concerns you had:\n\n\nDistribution: I don't know much about distributing on the iPad, but would a script that just assembles the zip / folder to add to Playgrounds suffice?\nReporting: Nimble has a protocol that can override it's console output reporting to whatever you need (eg - Traffic Lights)\nLegacy: Nimble and Quick also run on Linux where the Objective-C runtime is unavailable. So I don't know if I see the problem here. \nPerformance: I'm incline to agree with you but I'd be more comfortable with that statement if there was some data to back that. It's all too often that performance problems are misunderstood without actually measuring it.. Also, I've added your @shaps80 to the Quick org. Welcome \ud83c\udf89!. Closing issue. Thanks @morganchen12 for the PR.\n\n@rasool310, if you're still not clear on what to do, please reopen this issue. Thanks!\n. Thanks for filing an issue @Dschee.\nIt definitely needs to be more clarification. But Swift's error handling is separate from Objective-C's exception handling.\nswift\n// swift does not catch this exception\ndo {\n    NSException(name: \"hello\", reason: \"world\", userInfo: nil).raise()\n} catch error {\n    // ...\n}\nWhile it's good practice to throw exceptions to indicate programmer error, various systems do throw exceptions (eg - CoreData). Also testing throwing of exceptions is useful to test in a library.\nNimble also does handle unexpected swift errors. Also there's a  throwError matcher if you expect an error to be thrown.\n. Sadly, there's limited vocabulary for these definitions. Yes, Swift doesn't have exceptions, but it has syntactic sugar around errors. Hence the differing names of throwError and raiseException.\nExceptions are generally associated to its common implementations:\n- Exceptions need to find their handlers when thrown (aka - find the closest catch / finally block).\n  - This implies an extra runtime cost when exceptions are thrown\n- Exceptions use extra storage for handlers + stack metadata\n  - Which means having a CPU cache miss when exceptions occur because it's stored in distant memory addresses (0-cost exceptions implementation)\n  - Or always incur a small overhead for being in a try / catch for cleaning local memory addresses, if that's used (naive exception implementations)\n- Many implementations capture stack traces when thrown\n  - Capture stack information requires more runtime calls and address to function lookups\nAll of which make exceptions are slower than return values. That's why I'm afraid of using the term exception for Swift's error handling model. It's technically incorrect, even though it might be more common to say it's an exception.\nIn comparison, errors are more accepted as a data structure that is returned by a function. A perfect example is to see how the go programming language handles errors:\ngo\n// go code\nfunc stuff() error {\n    f, err := os.Open(\"filename.ext\") // Open can fail\n    if err != nil {\n        // handle error: 98% time we return the error to our caller\n        return err\n    }\n    // do more stuff\n}\nObviously this is annoying to write an if case for every error. Especially since the common case is for a function to return its error back to the caller. So swift has syntax that converts code to what go programmers would normally write in functions:\nswift\n// swift code\nfunc stuff() throws {\n    let f = try open(\"filename.ext\")\n    // do more stuff\n}\nWhich is much more concise. When handling errors, swift uses syntax similar to how developers are familiar with exceptions:\nswift\ndo {\n    try stuff()\n} catch let error {\n    // log error\n}\nBut that can be a simple conversion to an if statement in compiled code (like go's):\nswift\nlet error = try stuff() // fake: pretending `try` returns the error\nif error != nil {\n    // log error\n}\nOf course, it's useful to quote a more authoritative source about swift's implementation. A note under the \"Handling Errors\" section of the Swift Language Guide that says:\n\nError handling in Swift resembles exception handling in other languages, with the use of the try, catch and throw keywords. Unlike exception handling in many languages\u2014including Objective-C\u2014error handling in Swift does not involve unwinding the call stack, a process that can be computationally expensive. As such, the performance characteristics of a throw statement are comparable to those of a return statement.\n\nThis is the reason why Swift always refers them to errors, and not exceptions.\n\nAll that as a long-winded way to say:\n- Objective-C has errors (NSError) and exceptions (NSException)\n- Swift only has errors (ErrorType)\nAnd with the above explanation, you can say:\n- Errors don't suffer the performance cost of exceptions\n- Swift makes errors look like exceptions\nI hope that was a bit clearer :wink:.\n. Done, thanks for the feedback @Dschee. :+1: \n. The test failed probably because of #177, I reran the build from travis and it seems to be working. I haven't fully reviewed the PR but its API is pretty cool.\nIronically, I would be more inclined to move mocking to a separate library. I still feel It's much more sensitive to the implementation of Swift that would require more regular updates than most of Nimble's matchers. It would more likely mean moving this PR to a separate library.\nAll being said, I'll take a closer look this weekend. Thanks for the massive work in the PR :+1: \n. I've put comments into this. Although I would be more comfortable moving this to a separate library under the quick org. I'm not really super comfortable to the string parsing of descriptions. Thoughts @quick/contributors?\nAnyway. I'd recommend changing the tests to be more of how a test writer would use this API instead of using APIs marked internal. Developers will most likely look at these tests to see how to perform specific kinds of expectations.\n. Hey @Rivukis,\nI got a chance to play around with this more.\nI seem to get a failure with differing types:\n``` swift\nclass TestClass : CallRecorder {\n    var called = (functionList: String, argumentsList: [Any])  \n    func doSomething(string: String, value: Int) {\n        self.recordCall(function: FUNCTION, arguments: [string, value])\n    }\n}\nlet testClass = TestClass()\ntestClass.doSomething(\"foo\", value: 1)\nexpect(testClass).to(call(function: \"doSomething(_:value:)\", withArguments: [\"foo\", 1]))\n```\nWhich produces:\nAssertions: failed - expected to call <doSomething(_:value:)> from TestClass with foo, 1, got <doSomething(_:value:) with (foo,1)>\n. @tjarratt, it's valuable, but there's still more work needed than the code available IIRC. I haven't looked at this in awhile. It's a lot of code that I haven't had time to fully review but, I'd be up to doing so if it was mergeable. A smaller MVP may be easier to get merged and grow from there (e.g. - call with only argument equality as the first step).\nI will admit that I'm biased and currently prefer manual mocks. I'm willing to accept this code mostly as-is, but I personally wouldn't put much to maintain it (other @Quick/core members may have other opinions). Mostly because it doesn't feel like it fits well inside Nimble or even Swift:\n\nThere's no integration to allow use of other Nimble matchers. That's mostly my fault and I'm looking into redesigning the Matcher API. But I'd almost prefer just property accesses that use Nimble's normal matchers instead of overloading it all into call.\nArgument checking behavior is based on stringification.\nArgument equality is based on stringified values. See line in question. It just seems like a gotcha. I know it's perhaps a limitation of Swift, but it feels like surprising behavior to me.\nNil / Optional detection is based on parsing the description of the value? I haven't fully checked, but it seems like it.\n\n\n\n\nIgnoring architectural complaints I have, I'm looking for at least:\n\nDocumentation about gotchas of the current implementation\n[ ] Does floats work with this matcher (I'm guess probably not)?\n[ ] ~~A section about the stringification implementation since it's a leaky implementation detail.~~\n[ ] This probably leaks if self is passed as an argument that is captured. We should note that case.\n\n\nSignificantly more test coverage of the current implementation:\n[ ] Test Argument.* passed to call matcher\n[ ] Test with custom class instances arguments\n[ ] Test with custom structs as arguments\n[ ] Test with other built-in data types than strings and ints (arrays, maps, floats, tuples)\n[ ] Failure messages & negation tests of the above behaviors\n[ ] Test with Objective-C classes as argument\n[ ] Test if argument equality works with class inheritance\n\n\n[ ] SwiftLint compliance\n\n...for this to be mergeable.. @Rivukis, I must of missed that reading through the code. I thought that's what the behavior of the program was when I last checked it out. I'll have to try again.\nThe matcher feature can to be deferred to a later point. The list of requirements I mentioned earlier would make me willing to accept it.\nI'll check out this PR and review it again tomorrow on my allocated OSS time.. @tjarratt, Yes, that's part of what the Matcher API redesign is trying to address. It's worth noting that this PR will still require some work in creating your mocks. They're not as feature-rich as Cedar's mocks or OCMock. You're still required to define the methods of the mocks you create.\nWhile I know many people would like a mock feature. I have a concern of the support issues based on expectations of mocks in other languages and what's supported.. I tried running this PR, but it was a non-trivial merge beyond just naively merging the xcodeproj file to get it running on Xcode 8.2.1. I'm not too familiar on the Linux side of things, but it seems like isKind(of:) isn't available in Linux, probably because the Objective-C runtime doesn't exist. See beAKindOf.. Thanks for following up @Rivukis! I think it would be nice to have a wiki page on Quick that lists various supporting libraries (linked to on the README) and Spry could be there.. Thanks @tmandry, I can confirm the issue. This definitely requires more investigation.\n. Hey @tmandry,\nThis issue has to do with both implementations assuming control of the run loop to process async dispatches to the main thread. For now, I've provided a more explicit error message.\nThese changes are currently only on master.\nThanks for filing the bug! I'll close this issue once this change is in a release.\n. Closed. This is now in v3.1.0.\n. This PR's waitUntil implementation is more similar to XCTest's expectations:\nswift\nfunc xctest() {\n    let expect = expectationWithDescription(...)\n    // do async code\n    dispatch_async(dispatch_get_main_queue()) {\n       expect.fulfill()\n    }\n    // end\n    waitForExpectations(...)\n}\n// equal to above\nfunc nimble() {\n    waitUntil { done in\n        // do async code\n        dispatch_async(dispatch_get_main_queue()) {\n           done()\n        }\n        // end\n    }\n}\nIn the current implementation of waitUntil, it dispatches the closure to main thread asynchronously:\nswift\nfunc nimble() {\n    waitUntil { done in\n       done() // dispatch asynchronously to main thread\n    }\n}\nUnfortunately, doing this implicit dispatch currently conflicts with trying to provide helpful error messages for nested async expectations. It needs to be resolved before merging this PR (or remove the helpful error message).\n. This PR is ready for feedback, @Quick/contributors.\n. Thanks for the review @ashfurrow!\n. Thanks @ricardopereira! :+1: \n. This is exciting @briancroom! I think we should just #if out any code that isn't compatible with the open source swift version: \n- Don't extend NSHashTable and NSMapTable for linux\n- Exclude all NMB* protocols in `MatcherProtocols.swift since they're targeted for Objective-C\nI do think it's worth leaving a comment before the compiler conditional if it's potentially removable if swift open source may add it because Foundation is incomplete (eg - NSHashTable and NSMapTable).\n. If you think it's worth maintaining it on a separate branch. There's a couple large changes in the pipeline that'll need to be merged into this branch (protocol extensions, async). I was also hoping to get swiftlint into the project at some point in time too.\n. Either would work. Although I just merged a bunch of PRs waiting to be merged, so that's my bad, but the changes here can't merge cleanly.\nI'll hold out on the linting task until this gets in on master.\nI think it's probably easier to break it out into smaller changes that can be more easily accepted. Although if you find that too difficult, I'll still accept larger PRs.\nRelated to this work, it's probably good to get travis' multi-os support enabled for linux.\n. Unfortunately, swift currently doesn't have a clean way of representing arbitrary tuples for Nimble to perform equality against. There only way is to implement it for each tuple of a given size (unlabeled).\nFor now, you'll have to compare each element in the tuple manually.\n. Hey @bgerstle,\nThanks for the PR. I like what you arrived at as a solution. It's simplier than having to write custom matcher for all permutations.\nI've written some feedback inlined to the PR. Please reply on this PR when you want me to review it again since github doesn't notify me when a PR changes. :+1:\n. Yeah, that\u2019s related to https://github.com/Quick/Nimble/pull/224 https://github.com/Quick/Nimble/pull/224, so don\u2019t worry about that.\nI kind of like original helper function that captured the notifications in closure. It seems like it would be a bit harder this matcher to compare notifications by notification name, for example.\nBut I personally don\u2019t use NSNotifications that much, so I\u2019m not drawing from a lot of experience testing them.\n- Jeff\n\nOn Jan 8, 2016, at 8:41 AM, Brian Gerstle notifications@github.com wrote:\n@jeffh https://github.com/jeffh looks like there's a flaky ObjC test https://travis-ci.org/Quick/Nimble/jobs/100944007#L2216, probably unrelated to my changes.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/Quick/Nimble/pull/228#issuecomment-170050672.\n. This looks good, although the work on Linux support is conflicting with the PR, I'll see if I can get a merge in after that all settles.\n. Hey @bgerstle,\n\nI've merged in the changes and resolved the conflicts, there's still missing the README and Objective-C support. Are you interested in picking that up?\nLinux support is in this PR: https://github.com/Quick/Nimble/pull/246\n. Hmm, the isEventually postNotifications test seems flaky: https://circleci.com/gh/jeffh/Nimble/25\n. Don't think so, it looks like other notifications fired during that time:\nswift\nexpected to eventually equal <[NSConcreteNotification 0x7fb0a24df940 {name = Foo}]>,\ngot <[__CFNotification 0x7fb0a24e1b00 {name = NSUserDefaultsDidChangeNotification; object = <NSUserDefaults: 0x7fb0a2400f10>},\n__CFNotification 0x7fb0a24e1b80 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24e1cb0 {name = NSUserDefaultsDidChangeNotification; object = <NSUserDefaults: 0x7fb0a2400f10>},\n__CFNotification 0x7fb0a24e1ce0 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24e1bb0 {name = NSUserDefaultsDidChangeNotification; object = <NSUserDefaults: 0x7fb0a2400f10>},\n__CFNotification 0x7fb0a24c9b00 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24c9b90 {name = NSUserDefaultsDidChangeNotification; object = <NSUserDefaults: 0x7fb0a2400f10>},\n__CFNotification 0x7fb0a24c9bc0 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24c9bf0 {name = NSUserDefaultsDidChangeNotification; object = <NSUserDefaults: 0x7fb0a2400f10>},\n__CFNotification 0x7fb0a24c9c20 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\nNSConcreteNotification 0x7fb0a24df940 {name = Foo}]>\n. Using a private one probably wouldn't hurt.\n\nJeff Hui\nSent from my iPhone\nOn February 3, 2016 at 5:57:36 AM, brian gerstle (notifications@github.com)\nwrote:\n\nAh, that's a relief. Can either change expectation to \"contains\" or use a\nprivate Notification Center.\nOn Wed, Feb 3, 2016 at 01:27 Jeff Hui notifications@github.com wrote:\n\nDon't think so, it looks like other notifications fired during that time:\nexpected to eventually equal <[NSConcreteNotification 0x7fb0a24df940\n{name = Foo}]>,\ngot <[__CFNotification 0x7fb0a24e1b00 {name =\nNSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24e1b80 {name =\ncom.apple.CFPreferences._didChange; object = com.apple.CFPreferences;\nuserInfo = {}},\n__CFNotification 0x7fb0a24e1cb0 {name =\nNSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24e1ce0 {name =\ncom.apple.CFPreferences._didChange; object = com.apple.CFPreferences;\nuserInfo = {}},\n__CFNotification 0x7fb0a24e1bb0 {name =\nNSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24c9b00 {name =\ncom.apple.CFPreferences._didChange; object = com.apple.CFPreferences;\nuserInfo = {}},\n__CFNotification 0x7fb0a24c9b90 {name =\nNSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24c9bc0 {name =\ncom.apple.CFPreferences._didChange; object = com.apple.CFPreferences;\nuserInfo = {}},\n__CFNotification 0x7fb0a24c9bf0 {name =\nNSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24c9c20 {name =\ncom.apple.CFPreferences._didChange; object = com.apple.CFPreferences;\nuserInfo = {}},\nNSConcreteNotification 0x7fb0a24df940 {name = Foo}]>\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/228#issuecomment-179118948.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/228#issuecomment-179248082.\n. Hey @jwfriese,\n\nThanks for the PR & bringing up potential issues. It looks mostly good at far as the changes stands. As a bonus, you can write an || operator for matchers that utilizes satisfyAnyOf internally. :smile:\nFor (1), I think it's reasonable to emit an error message per line. This will allow a reasonably short error for Xcode, but emits the full error in the terminal (or in the test log):\nexpected to all be less than 4, but failed first at element <5> in <[5, 6, 7]>, got [5, 6, 7] ...\nor expected to equal <[1, 2, 3, 4]>, got [5, 6, 7]\nThis is reasonable because then Xcode will show the first line, but it's still possible see both lines (albeit, a bit harder in Xcode). I think the flow is acceptable because you'll get to fix each error per run if the test writer doesn't wish to see all the errors.\nI definitely agree with your concern of (2), but I think unnecessarily limiting it isn't necessary. But documenting a bit about the dangers of using this matcher would be nice.\nThe only mitigation I could suggest is to provide an || operator and encourage the use of that instead of satisfyAnyOf. The || matcher would have natural limit because swift's type checker fails if expressions are too large.\nJust addressing / responding to comments + the error messaging and this is merge-able. Just reply when you made all the changes because github doesn't notify me when the PR changes. :+1: \n. Hey @jwfriese,\nAbout the macro, I was thinking along the lines of:\n``` objc\ndefine NMB_satisfyAnyOf(...) NMB_satisfyAnyOfWithMatchers(@[VA_ARGS])\n```\nThis means passing nil to NMB_satisfyAnyOf will fail in both runtime and compile-time (if statically known).\nAlso, satisfyAnyOf should error when it's not given any matchers:\nswift\nexpect(...).to(satisfyAnyOf()) // failure - satisfyAnyOf requires at least one matcher\nAnd I think everything else is great! :+1: \n. No worries and thanks for all the hard work @jwfriese!\n. Sounds good to me.\nI don't particular mind either - beIdenticalTo maps to my head more readily than be.\n. An alias works for me. \nSent from my iPhone\n\nOn Jan 21, 2016, at 7:31 AM, James Campbell notifications@github.com wrote:\nAn alias would be great :) \n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, my bad. Closing now :smile: \n. Hey @mbogh,\n\nYep, I don't see any issues with it. You'll need to use case to destructure the value out to compare:\n``` swift\nenum MyError: ErrorType {\n    case ValueError(text: String)\n}\nfunc throwable() throws {\n    throw MyError.ValueError(text: \"hello\")\n}\nexpect{ try throwable() }.to(throwError { (error: MyError) in\n    if case .ValueError(let text) = error {\n        expect(text).to(equal(\"hello\"))\n    } else {\n        fail(\"Not ValueError\")\n    }\n})\n```\n. Thanks for following up @Dschee. Closing.\n. Looks good! Thanks @jwfriese!\n. Yeah, @morganchen12's proposal is preferred. I don't really like having a test-helper library that is linked in the main app.\nSince we can't fork(), mach exception handling is probably the best solution. Otherwise fatalError() may trigger a SIGILL, although I haven't verified that or not.\n. Merged. Thanks @briancroom\n. Thanks @briancroom!\n. Thanks @briancroom!\n. Thanks @briancroom!\n. LGTM, thanks for the patience @briancroom!\n. I've noted the change I made when merging your PR. Thanks @jwfriese!\n. I've merged this on to master. I'll cut a release soon.\n. Also, @briancroom. The changes looked compatible enough to just bump the major version and not have to warrant cutting a separate branch. That sounds ok?\n. Go for it! I usually just do some manual verification before cutting a\nrelease. If you have some missing permission, let me know.\nOn Sun, Mar 13, 2016 at 10:23 PM Brian Croom notifications@github.com\nwrote:\n\n@jeffh https://github.com/jeffh were there any outstanding items you\nwere hoping to get in before a release? If it's just a time issue, I'd be\nmore than happy to give it a go myself.\nI had initially been thinking it would make sense to wait until #261\nhttps://github.com/Quick/Nimble/pull/261 could be merged, but now it\nlooks like the next snapshot is going to include breaking changes related\nto Swift 3, so I'd say let's go for it!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/issues/242#issuecomment-196149248.\n. Thanks @NachoSoto and @briancroom! I'll cut a new release soon.\n. My vote is with @briancroom on the 4th wording.\n. Thanks @briancroom! Been waiting for this! :+1: \n. Hey @abbeycode,\n\nSorry for the late response, an illness put me out for a couple weeks. I'll be busy with a conference this week. But excellent stuff in this PR!\nReplies are after each question.\n\n\nHow do we want to credit @mattgallagher, as discussed in the issue thread?\n\nYup, add it to the README (next to the matcher) and the source files we include.\n\nAre we okay shipping with tvOS support based on POSIX signals? This means that tvOS schemes will have to turn off the Debug executable setting in their Test configuration. @mattgallagher and I discussed this in Issue #3 of his repo\n\nDoes @asm work around this issue? I'm thinking something like:\nswift\n@asm(mach_msg)\npublic func evil_mach_msg(msg: UnsafeMutablePointer<mach_msg_header_t>, _ option: mach_msg_option_t, _ send_size: mach_msg_size_t, _ rcv_size: mach_msg_size_t, _ rcv_name: mach_port_name_t, _ timeout: mach_msg_timeout_t, _ notify: mach_port_name_t) -> mach_msg_return_t\nI had some limit luck using that to call fork on \"unsupported\" platforms before. Since we're only in tests, I think it should be ok.\n\nHow do we handle non-x86_64 test runs? I currently have the throwAssertion() matcher conditionally compiling to fatally error with a clear message. Would it be better to return false from the matcher with a descriptive message?\n\nI'd prefer compile errors with a clear message how to conditionally disable the expectation (I'm guessing with some swift build conditional). Otherwise, having the matcher fail with a description failure message as a fallback is acceptable. Nimble prioritizes simulator over devices in these decisions to allow CI environments to run more comprehensively.\n\nAre we happy with the throwAssertion name? If not, what would be better?\n\nI don't have any other particular standout names. Sounds fine by me.\n\nI made CwlPreconditionTesting a submodule, and then included the files from it statically. Is this the right way to go?\n\nIdeally some versioned dependency would be better, but CwlPreconditionTesting probably doesn't fit well with package managers. The submoduled project doesn't support Cocoapods or SPM.\nWhile we could add the files to the podspec in the submodule, I think it might be more problematic for SPM.\nSPM is strongly conventions based. I'm not sure if we could include sources that don't reside in the Sources directory.\nThis sadly make me lean towards just adding the files manually in Nimble's source, with proper attribution (README, Source Files). Please also add the SHA that the files originated from, so it'll be easier to know when we deviate from the original.\n. I think the issue is that #endif needs a newline or the compiler might not\nlike having a build conditional over the entire file,, but I'm not entirely\nsure.\nOn Thu, Mar 10, 2016 at 12:57 PM Dov Frankel notifications@github.com\nwrote:\n\n@jeffh https://github.com/jeffh Please let me know how to fix the build\nfailures when you have a chance.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/248#issuecomment-195044715.\n. Also, for the @asm. You can use @asm like a forward declaration:\n\nswift\n@asm(mach_msg)\npublic func evil_mach_msg(msg: UnsafeMutablePointer<mach_msg_header_t>, _ option: mach_msg_option_t, _ send_size: mach_msg_size_t, _ rcv_size: mach_msg_size_t, _ rcv_name: mach_port_name_t, _ timeout: mach_msg_timeout_t, _ notify: mach_port_name_t) -> mach_msg_return_t\nNow you can use evil_mach_msg instead, which the compiler won't complain about.\nswift\n// code that needs to use `mach_msg`\nevil_mach_msg(...)\nThat is predicated on the fact that the asm code can still be linkable. Sorry, I should have elaborated that more.\n. Yeah, it theoretically should work on this, because it bypasses the\ncompiler's unavailable attribute.\nOn Mon, Mar 14, 2016 at 11:41 AM Dov Frankel notifications@github.com\nwrote:\n\n@jeffh https://github.com/jeffh Thanks for the explanation; I now\nunderstand what the @asm attribute is, and how to use it. I'm not sure I\nfollow how it helps with the question I asked, though:\nAre we okay shipping with tvOS support based on POSIX signals? This means\nthat tvOS schemes will have to turn off the Debug executable setting in\ntheir Test configuration. @mattgallagher\nhttps://github.com/mattgallagher and I discussed this in Issue #3\nhttps://github.com/Quick/Nimble/pull/3 of his repo\nWould the approach you described allow tvOS to use the primary mach-based\napproach, instead of relying on the POSIX approach?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/248#issuecomment-196464134.\n. TL;DR: I think it's ok to not support tvOS for now.\n\nI have an unsupported assumption that mach_msg wouldn't be broken in tvOS since mach messaging is pretty fundamental to the Darwin kernel. Many Apple Frameworks that use IPC/XPC will implicitly rely on this function to work properly. I'm not saying it wouldn't break, but I'm just hedging bets ;)\nFor 3, SPM supposedly has an exclude parameter to exclude folders.\nFor 4, let's table tvOS support for this feature. I'm perfectly fine with that.\n\nAs for the build exception, I'm seeing this locally on my machine. I'm guessing Swift is name-mangling BadInstructionException when exposing it to Objective-C, it's better to be explicit about it's name:\nswift\n@objc(BadInstructionException)\npublic class BadInstructionException: NSException {\n...\n}\nThat seems to resolve the build error on my machine.\n. Ignore my previous comment about the @objc, it doesn't seem to work after removing derived data. I'll play around with it a bit more.\n. Well it gets more interesting, but it's basically seems like a non-deterministic generation of Nimble-Swift.h based on architecture.\nSo if we modify CwlBadInstructionException.swift to add an else-generation:\n``` swift\nif arch(x86_64)\n// same code as before\nelse\n@objc public class BAAAAADCompiler: NSException { }\n\nendif\n```\nIf you look at different runs of generating Nimble-Swift.h interface header, sometimes you'll see it follow the x86_64 build conditional and sometimes not:\nswift\n// If the compiler decided to generate as non-x86-64\nSWIFT_CLASS(\"_TtC6Nimble15BAAAAADCompiler\")\n@interface BAAAAADCompiler : NSException\n- (nonnull instancetype)initWithName:(NSString * _Nonnull)aName reason:(NSString * _Nullable)aReason userInfo:(NSDictionary * _Nullable)aUserInfo OBJC_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;\n@end\nVersus sometimes the compiler will produce:\nswift\n// If the compiler decided to generate as x86-64\nSWIFT_CLASS(\"_TtC6Nimble23BadInstructionException\")\n@interface BadInstructionException : NSException\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;\n+ (kern_return_t)catch_mach_exception_raise_state:(mach_port_t)exception_port exception:(exception_type_t)exception code:(mach_exception_data_type_t const * _Null_unspecified)code codeCnt:(mach_msg_type_number_t)codeCnt flavor:(int32_t * _Null_unspecified)flavor old_state:(natural_t const * _Null_unspecified)old_state old_stateCnt:(mach_msg_type_number_t)old_stateCnt new_state:(thread_state_t _Null_unspecified)new_state new_stateCnt:(mach_msg_type_number_t * _Null_unspecified)new_stateCnt;\n@end\nAs a work-around, it might be better to have a build conditional that produces a runtime error / exception instead of conditionally generating this class.\n. Yeah! :+1: In theory, this could just require one file to repro. I happened to move on to other things ATM, but feel free to file one\n. Hey @inamiy,\nLooks good, but I'm trying to see the use case that the compiler couldn't statically know. Could you give a more concrete example use case for this matcher?\nEven better, add it to the test case. :)\nOther than that, I don't see any reason not to merge it.\n. Thanks for the context! Merged\n. This change broke the Linux build :(\nOn Wed, Feb 17, 2016 at 7:16 AM Brian Gerstle notifications@github.com\nwrote:\n\nShould make them less flakey.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/Quick/Nimble/pull/251\nCommit Summary\n- use private notification center during tests to prevent side effects\nFile Changes\n- M Sources/NimbleTests/Matchers/PostNotificationTest.swift\n  https://github.com/Quick/Nimble/pull/251/files#diff-0 (33)\nPatch Links:\n- https://github.com/Quick/Nimble/pull/251.patch\n- https://github.com/Quick/Nimble/pull/251.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/251.\n. Foundation Linux has NSNotificationCenter. The logs seemed to indicate\ncalling super wasn't allowed though.\n\nOn Thu, Feb 18, 2016 at 9:20 AM Brian Gerstle notifications@github.com\nwrote:\n\n@jeffh https://github.com/jeffh the log isn't very helpful, any idea\nwhat could be wrong? should notification-based testing be run on OSX only,\nsince it's specific to Foundation?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/251#issuecomment-185823251.\n. Merged. Thanks @bgerstle!\n. I think this would be great to have.\n. I want to cut a one more new release before merging this change in, IIRC, there aren't any API breaking changes in this up-coming release.\n. Thanks for the review, @briancroom! :+1: \n. Agreed with @briancroom. That being said, it would be nice to have support for this.\n\nRelated issue: https://github.com/Quick/Nimble/issues/113. Using overloadable would be a nice way to improve Nimble's Objective-C's interface.\n. Hey @mjbeauregard,\nThis is the first time someone has filed an issue to raise this issue. I personally prefer to avoid async tests when possible because it's time-dependent behavior.\nThat being said, I don't mind if there was a way to globally increase the timeout. Seems like a useful feature to have in tweaking the async timeout for CI.\n. I think it isn't too farfetched\u00a0to see file an issue to the Promises library you're using. I haven't used much Promises libraries in Swift, but the one I used in Objective-C did support a blocking synchronous flow to allow tests to not be async (using semaphores).\nThat being said, see my comment in the PR, you might want to debug how much async work you have enqueued in your run loop.\n. Have you tried looking at the CFRunLoop to see what timers you have attached at the point of failure?\nThe PR looks good to me, although I just merged in support for bleeding edge swift that moved files around and broke the mergability of the it.\nI'll have some time after this week to try and resolve the merge conflicts if you don't get around to the PR.\n. Thanks @briancroom! I was planning to do that, but you beat me to the punch :smile:.\n. Agreed. I originally wanted to make this public, but I don't like the current state that stringify exists as. It needs some more refactoring before made available.\nThat most of that code existed before the ability to dynamically type check swift-only types: (eg - generic T or even AnyObject).\nI was thinking perhaps a more protocol-extension based approach, but we would need to dynamically check if the type supported the protocol and not require all types implement it.\nBut I'm open to other kinds of refactors to improve that the state it currently is in.\n. Hey @inket,\nThanks for filing an issue. Actually Nimble doesn't do any truncation of any output. Getting NSData's description will output that.\nThat being said, I think it's perfectly reasonable to have Nimble truncate its data.\n. LGTM, Thanks @briancroom!\n. Hey @briancroom, I'm pretty sure this was part of some Swift releases. I'm assuming we need to still work on this to get Nimble updated on the latest swift releases?\n. Closing, these changes were merged into master.\n. Hey @oks,\nThanks for the pull request. Although Nimble has these warnings, they're purposefully there because it does run on for iOS 7 (see PR). I don't know how common it is to still support iOS 7 targets, but in the past we've received PRs reverting these changes. Perhaps @modocache may know?\n. If you can submit a PR to suppress this warning, that would be great!\nOn Thu, Mar 10, 2016 at 10:33 AM Oks notifications@github.com wrote:\n\nReopened #262 https://github.com/Quick/Nimble/pull/262.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/262#event-585307543.\n. Hey @oks,\n\nPlease submit another PR if you figure out how to suppress this warning :smile:. I'll be closing this one, thanks for submitting a PR.\n. Hey @inket,\nLooks good to me. Although I would like to have a test to make sure this doesn't regress at a later period before merging this in.\n. LGTM, thanks @inket!\n. Hey @morganchen12,\nJust getting back in the groove from jet lag.\n- Stringifiers for SequenceTypes were suppose to keep the format looking similar to Arrays. I haven't recently verified the output, but generators don't usually return useful truing values by default.\n- The quoting of strings was an artifact from the old dates. Ideally, Nimble could print strings that could be copy-pasted as code. But that's probably nice for some theoretical future. It's fine that you removed it.\n- Agreed. TestOutputStringConvertible sounds good to me! :+1:\n. Thanks @morganchen12!\n. As @morganchen12 mentioned, the version of swift referenced via swiftenv needs to be updated to the latest snapshot.\nAlso, I think these changes would force us to maintain a separate branch until Xcode stable has these changes.\n. Hey John,\nI\u2019ve been thinking about this feature, but I\u2019m not sure where I stand on this. It\u2019s a more polarizing feature. Do you prefer Cedar\u2019s incantation or Gomega\u2019s JustBeforeEach?\nOf course, this is much more of a Quick feature than a Nimble one. Please file the issue on Quick and we can continue the discussion there.\nThanks,\n- Jeff\n\nOn Mar 15, 2016, at 6:57 AM, John Mejia notifications@github.com wrote:\nCedar has a very useful \"subject action\" which runs after every before each within a block.. Could this be an enhancement to Quick?\nDescription from Cedar's documentation:\nGenerally you want each top-level describe block to describe a single method or action. Often you end up calling this action in multiple places at multiple levels of nesting after various amounts of setup. In this case you can use a subject action block to simply your specs. A subject action block differs from a before each block because you may have only one for any given example group (if multiple levels define a subject action block Cedar will throw an exception), and it will run after all before each blocks for a given example.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/Quick/Nimble/issues/266 https://github.com/Quick/Nimble/issues/266\n. Actually, searching on this on Quick resulted in this: https://github.com/Quick/Quick/issues/209.\n\nFeel free to expand the discussion there if you prefer. Closing this issue. Thanks for filing an issue: @jmejiaa! :smile:\n. Thanks for the bug @szweier, it was useful to develop the fix.\nI've opened at PR for the fix. We'll cut a new release when it merges into master\n. Thanks for pinging, I just cut a new release! (v4.0.0)\n\nOn Apr 5, 2016, at 6:50 AM, Travis Bogosian notifications@github.com wrote:\nHi, I'm facing the same issue. Any updates on when this release will be available? Thanks!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub https://github.com/Quick/Nimble/issues/267#issuecomment-205813715\n. Hey @humblehacker:\n\nTravis CI is reporting a build failure on Linux-Swift:\n/home/travis/build/Quick/Nimble/Tests/Nimble/Matchers/BeEmptyTest.swift:65:34: error: argument type 'Int' does not conform to expected type 'AnyObject'\n            expect(NSSet(object: 1)).to(beEmpty());\n                                 ^\nSwift Linux doesn't have automatic type coercion from Int to AnyObject, I think you'll just need to change that for the build to pass.\n. @briancroom, yeah it's ok to merge into master since Swift 2.2 is out.\n. Thanks for filling an issue.\nNimble doesn't do much with test reporting (only reporting assertion failures), so it's more likely a downstream issue to scan or whatever tooling you're using the parse tests from stdout since it seems like xctest no longer emits the output by default.\nClosing for now.\n. @briancroom: Would all this be resolved if we just removed CurrentTestCaseTracker and converted all file references from String to StaticString?\n. Ah I see, sadly I don't think so. There's not an explicit separation in C. :frowning:\n. Hey @Blackjacx,\nNimble's async polling is similar to your code with a couple of notable differences to cover more cases:\n- Any stops of NSRunLoop will not cause the NSRunLoop to stop running. Some Apple internal frameworks will call stop that can cause a premature failure.\n- There's additional verification that the match runs within a given time interval. This can be backlogged due to amount of work on the run loop (eg - sleep(10)).\n- Nested runs of NSRunLoop can create non-deterministic failures of the outer run.\n- Nimble adds a high-priority timeout in an attempt interrupt to the run loop before other work gets processed.\nIt's based on the behavior of XCTest's expectations, but only assumes work that can be done in-process. Nimble can't restart the process with saved test running state when the timeout triggers (Which is what Xcode's XCTest does sometimes).\n\n@ldiqual, What's the context of the code that changes the wasDidUpdateTimeSlotsCalled property? Is it on another thread? Does the code that sets it to true run by attaching to the run loop?\n. Hey @priyapy, could you elaborate on the specific error you're having or a sample project that is showing the error?\n. Thanks @wongzigii and @dlo! The README has been updated. \ud83d\udc4d \n. Hey @RonanMcH, what version of Xcode, Cocoapods, & Nimble are you using?\n. Closing, thanks for following up @RonanMcH! \ud83c\udf89 Feel free to reopen if you still have issues.\n. Thanks for filing an issue, @d-lord.\nI agree, having waitUntil or another Nimble function that can specify the number of successful callbacks would be valuable.\n. I've tried this in Xcode 8 & Nimble/swift-3 without any error. It seems like it was fixed in swift?\n. Closing for idleness - feel free to reopen if you're still interested in this issue. While I agree there's ambiguity, the full waiting behavior can also be considered misleading.. Thanks for filing an issue, @Reflejo.\nFWIW, Gomega has this as Consistently(..).be(matcher).\nBut I'm personally hesitant to add this matcher. It is a negative assertion which is generally a testing smell that should be used sparingly. It's easy to fill a test suite with negative assertions that don't add a like of confidence to a test suite:\nswift\n// positive expectations\nexpect(1 + 1).to(equal(2))\n// negative expectations\nexpect(1 + 1).toNot(equal(3))\nexpect(1 + 1).toNot(equal(4))\nexpect(1 + 1).toNot(equal(5))\n// etc.\nIt's easy to generate many permutations of negative expectations that won't describe the behavior as well as the first expectation.\nThe above example is mostly harmless burden because there's not a significant runtime impact. However, something like Consistently / toAlways will always introduce slow-downs to the timeout period specified. That'll result in a weaker test suite that takes orders of magnitude longer.\nAlternatively, you can poll for an expected behavior then expect the callback to not be called:\n``` swift\n// alternative solution 1:\nsendRequest { successfulResponse in\n    called = true\n}\nexpect(sentRequests().count).toEventually(beGreaterThan(0))\nexpect(called).to(beFalse())\n```\nOr fail inside the callback:\nswift\n// alternative solution 2:\nsendRequest { successfulResponse in\n    fail(\"should not be called\")\n}\nGranted, I don't think fail is thread-safe, but maybe it's worth making that into a feature.\nCorrect me if I'm misunderstanding the test case you're trying to write.\n. You're right @MP0w, a negative async assertion would always have to wait for the timeout to indicate success.\nI don't know of a good way to prevent this unexpected behavior \u2013 short of removing toEventuallyNot. Although I'm open to suggestions.\nThere can definitely be better documentation related to how toNotEventually / toEventuallyNot behaves. The original intended behavior @Reflejo wanted could be replicated by sleeping:\n```swift\nvar called = false\nfunc thisShouldNeverBeCalled() {\n    called = true\n}\n// (.. async stuff ..)\n// sleep for 10 seconds while still processing the run loop\nNSRunLoop.currentRunLoop().runMode(NSDefaultRunLoopMode, beforeDate: NSDate().addingTimeInterval(10))\nexpect(called).to(beFalse())\n```\nI don't think this PR is worth merging into Nimble. But thanks for putting in the effort, @Reflejo.. Unfortunately, that can make tests flaky with another non-intuitive behavior:\nvar value = 0\nDispatchQueue.main.async {\n    value = 2\n}\n// ...\nexpect(value).toEventually(equal(2))\nsomething like that could fail (depends on when the dispatch is called) if we ensured the matcher failed first. Or just the smaller:\nvar value = 2\nexpect(value).toEventually(equal(2))\nSeems a little bit surprising?\n\nOn Nov 29, 2016, at 11:05 PM, Alex Manzella notifications@github.com wrote:\n@jeffh https://github.com/jeffh I was thinking about ensuring that the condition is false the first time (but there might be cases where this is not right?)\nE.g\nexpect(value).toEventually(equal(value2))\nBehaves like:\nexpect(value).toNot(equal(value2))\nexpect(value).toEventually(equal(value2))\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/Quick/Nimble/pull/323#issuecomment-263799334, or mute the thread https://github.com/notifications/unsubscribe-auth/AAEMCD-yBkHp2Pdv2Mw1QtgpeQu2_XrRks5rDSAdgaJpZM4JdYTX.\n\n\n. I don't think it's desirable behavior. We should probably fix this.\n. @ikesyo, what's left that prevents this from merging into master?\n. Thanks for the update @ikesyo.\n\nAPI Design (Naming) Guidelines\n\nI think that can be addressed when we attempt to switch matchers to use protocol extensions. I'll try again next week to play around and see if protocol extensions don't cause all sorts of problems.\n\nIPHONEOS_DEPLOYMENT_TARGET is bumped to 8.0 (we can't select 7.0 on Xcode 8 GUI anymore)\n\n\ud83d\udc4d . This is fine. If someone still manages to get it to work on 7.0, we can accept a PR as needed.\n\nBeIdenticalTo implementation which is affected by id-as-Any.\n\nWhile not ideal, the implementation seems workable.\nOther than that one change. It seems ready to merge, imo.\n. Thanks everyone for putting in all the effort! \ud83d\udc4f \n. @GregoryMaks: What version of carthage & xcode are you using?\nThis is an ongoing issue, maybe the latest releases of Xcode has resolved this, but it requires more investigation to figure out if setting ENABLE_BITCODE=YES fixes it.\nHistorical Context:\n- Carthage required a fat binary (simulator + device) for tvOS (until v0.17)\n- tvOS requires bitcode enabled except XCTest in simulator (see https://github.com/Quick/Nimble/issues/170 & https://github.com/Quick/Nimble/issues/213)\n- the toolchain (historically) incorrectly assumes XCTest requires bitcode if linked via another framework (see https://github.com/Quick/Nimble/issues/165)\n- Cocoapods (historically) didn't work with bitcode enabled for tvOS (see https://github.com/Quick/Nimble/issues/196).\nNimble has historically swapped between both enabling and disabling bitcode to no avail in an attempt to cover all cases.\nThe easiest, immediate fix is to do one of the following:\n- upgrade to carthage 0.17+ as it should have resolved this issue. Although, I haven't personally verified that.\n- use git submodules (carthage: --use-submodules) and add Nimble.xcodeproj manually\n- use --platform flag to exclude tvOS\n. Any update @GregoryMaks?\n. Thanks @ikesyo!\n. Hey @fmaxx, what does you Podfile look like? What version of Nimble are you using?\n. I'm looking into cutting a release tonight when I get free time. I just need to verify the release will work in the various setups we support.\nOn Sep 19, 2016, 9:29 AM -0700, Anthony Miller notifications@github.com, wrote:\n\nI would really like to see this happen soon. I'm having to depend directly on the master branch from all my pod files right now.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/issues/339#issuecomment-248043960), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCGJiaBuoZ7pfuTJYtAE_IWtpb30xks5qrrhtgaJpZM4KAqdx).\n. Thanks @ikesyo!\n. Thanks @ikesyo!\n. @Quick/core, this is ready for review.\n. Closing, feel free to reopen if you think it's a problem with Nimble.\n. Hey @asalom,\n\nSadly, timeout tweaking is inherit to asynchronous tests (I personally prefer to avoid them whenever possible because of this). But you can increase the default timeout as documented in the README as a hacky-fix:\n```swift\n// Increase the global timeout to 5 seconds:\nNimble.AsyncDefaults.Timeout = 5\n// Slow the polling interval to 0.1 seconds:\nNimble.AsyncDefaults.PollInterval = 0.1\n```\nAlternatively, you can set specific timeouts for specific expectations:\nswift\n// Evaluate someValue every 0.2 seconds repeatedly until it equals 100, or fails if it timeouts after 5.5 seconds.\nexpect(someValue).toEventually(equal(100), timeout: 5.5, pollInterval: 0.2). Thanks!\n. Use the beCloseTo matcher instead for changing accuracy\n. Please review @Quick/core and @abbeycode.\nNote: This PR should probably be squashed due to the amount of messy history it produces. A more comprehensible commit message could probably be written up.\n. Thanks @mattgallagher, I've submitted a PR on your project for the fix I used in this PR.\n. Hey @dotpooch,\n- How are you organizing your tests? Are you using test bundles? What targets do your tests reside in?\n- Cocoapods, submodules, or carthage?\n- Do you have a sample project that's causing this problem?\n. Hey @ksm, what version of Swift and Nimble are you using?\n. Hey @lauracalinoiu,\nDid you perform a clean build? What's the type definition of viewModel.wikiURL?\n. See https://github.com/Quick/Nimble/pull/358\n. Hey @jorishjanssen,\nThanks for filing a bug. The behavior you see is definitely not ideal. It seems like two separate issues.\nFirst, Nimble is producing an error message that is inconsistent with the actual value it produced. The error message Nimble produces is inconsistent with the result the matcher got because the failure message string currently calls myFunc() again to get the value \u2013 which happens to change to true the split-second after the matcher failed.\nThe intermittent fails depends a lot of what myFunc() does. One way to check is by trying to increase your timeout duration. But it's difficult to say without knowing what myFunc() is actually doing. Unfortunately, this is inherent to asynchronous tests.\n. Hey @jwfriese,\nI think that's a great idea. I've left comments inline for the actual PR. Other than my comments, it all looks good to me \ud83d\udc4d \n. Also, don't forget to add documentation in the README.\n. @jwfriese, my bad \u2013 I forgot to submit the review. I always do this \ud83d\ude1e \n. LGTM, thanks @jwfriese!. Thanks @ikesyo!\n. Thanks @wongzigii!\n. Historically, Swift prevented checking of types that were provable by the compiler - which meant all swift-only types. I'm pretty sure it's changed since then. But if it's possible to get pass and failure cases without the compiler giving you a warning then Nimble should have those matchers work with Swift types.\n. This has been merged into master. Closing. Thanks for filing an issue @SebastianOsinski!. Thanks @jwfriese!. Hey @tali,\nThanks for filing an issue. I've confirmed that it is an issue. It's related to now NImbleXCTestHandler.swift tries to conditionalize its code for OSS Swift and iOS/macOS Swift. Unfortunately using #if _runtime(_ObjC). I think we should be using SWIFT_PACKAGE instead.. Hey @garie,\nThanks for filing an issue! I turned around to get some free time to look more thoroughly into this issue. Does this also work without Nimble in XCTest? I seem to get Xcode to hang when I po out a variable instead of getting this auto-import error.\nThat being said, I'm testing with iOS 9.0 sim. I'll be trying it on iOS 9.3 to see if there's any differences. Edit: No difference.. I'm going to close this issue due to idleness, but feel free to reopen if you still find it Nimble at fault and not some Xcode / XCTest weirdness.. I don\u2019t think so. Old versions of Swift had issues with return values and closures. I think there just needs to be a test / verification that something like this works:\nit(\u201cshould work\u201d) {\n\u00a0 \u00a0 expect { try someFunc() }.toNot(throwError()).to(equal(5))\n}\nThe swift compiler couldn\u2019t figure out that it only accepted Void as a return value and incorrectly inferred the closure to have a return value. I\u2019m pretty sure that has been fixed in recent Swift versions.\n\nJeff\n\nOn Dec 22, 2016, 2:52 PM -0800, Yurii Samsoniuk notifications@github.com, wrote:\n\nSince the Expectation is an immutable structure, is there any reason why we cannot just extend its methods with an additional result returning self?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hey @ltrainpr,\n\nThanks for filling an issue. We're aware that SwiftLint fails with Nimble, it's work schedule to be done, but it hasn't been completed yet. Related issue: https://github.com/Quick/Quick/issues/641. I'm going to change this issue to be Nimble's equivalent issue.. I've enabled HoundCI on Nimble. Thanks for the contribution @sigito!. Good point, I'll reopen this issue and update the body.. Thanks @ikesyo!. Hey @rlam3,\n\nWhat version of Xcode version are you using?\nAre you using a package manager (Carthage, Cocoapods, SwiftPM)? What version are they?. Closing. This seems to be a cocoapods issue (see https://github.com/CocoaPods/CocoaPods/issues/5521). You'll need the following in your Podfile until cocoapods fixes it:\n\nruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '3.0' # to whatever swift version you're using\n    end\n  end\nend\nFeel free to reopen if that doesn't solve your problem.. Xcode has seem to fix this in some intermediary version. Closing.. Yeah, we should be careful in trying to call methods on NSProxy unnecessarily.\nOn Dec 14, 2016, 12:44 AM -0800, Syo Ikeda notifications@github.com, wrote:\n\nMaybe we should have a special handling for NSProxy?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/issues/377#issuecomment-266976315), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCLCzIsd4PqKdt66NrVFiyeGRethRks5rH6x6gaJpZM4LMiDg).\n\n. Do you have a small sample project that can reproduce it? I did some native NSProxy implementations that didn't seem to cause any problems. I guess next time I get a chance I'll try with OCMock.. Interesting, it seems like the Swift compiler chooses to convert the instance to it's corresponding class. It might seem that Swift accidentally interprets the pointer as a class.. Thanks @sigito!. LGTM, thanks @sigito!. I'll get around to cutting a new release soon (after I finish vacation-ing \ud83d\ude05 ). Look for it sometime next week.. Closing, Nimble 6.0.0 / 6.0.1 is out which includes this fix.. Hey @drkibitz,\nThanks for filling an issue.\nShort answer: Normally just using carthage checkout seems to work just in SwiftGit2. And as the issue that you filed on that project suggests, using the submodules will probably work fine too.\n\nLonger answer: Bitcode is a weird state when any framework links to XCTest. It roughly approximates to the fact that XCTest doesn't actually support bitcode on any platform.\nThere's some trickery that goes on with xcodebuild test when linking against XCTest. xcodebuild will intelligently modify build settings (aka - disables bitcode) when building for tests. Add a tool like Carthage which builds binaries separate from a test action causes it to fail. Carthage doesn't allow Xcode to infer that the entire project is being built for tests or not.\nIf you'd like more context, here's two issues that cover most of it from Nimble's perspective:\n\nhttps://github.com/Quick/Nimble/pull/210\nhttps://github.com/Quick/Nimble/issues/213\n\nI've attempted to build SwiftGit2 as your issue mentioned on SwiftGit2 and got Guanaco linker errors (carthage checkout):\n```\nxqejmjz/Build/Intermediates/Guanaco.build/Release-iphoneos/Guanaco-iOS.build/Objects-normal/armv7/Guanaco (No such file or directory)\nerror: cannot parse the debug map for \"/Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/Guanaco.framework/Guanaco\": No such file or directory\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nfatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file: /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Intermediates/Guanaco.build/Release-iphoneos/GuanacoTests-iOS.build/Objects-normal/armv7/GuanacoTests (No such file or directory)\nerror: cannot parse the debug map for \"/Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/GuanacoTests.xctest/GuanacoTests\": No such file or directory\nA shell task (/usr/bin/xcrun xcodebuild -workspace /Users/jeff/workspace/SwiftGit2/Carthage/Checkouts/Guanaco/Guanaco.xcworkspace -scheme Guanaco-iOS -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:\n BUILD FAILED \nThe following build commands failed:\n    Ld /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Intermediates/Guanaco.build/Release-iphoneos/Guanaco-iOS.build/Objects-normal/armv7/Guanaco normal armv7\n    Ld /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Intermediates/Guanaco.build/Release-iphoneos/Guanaco-iOS.build/Objects-normal/arm64/Guanaco normal arm64\n    CreateUniversalBinary /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/Guanaco.framework/Guanaco normal armv7\\ arm64\n    GenerateDSYMFile /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/Guanaco.framework.dSYM /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/Guanaco.framework/Guanaco\n    Ld /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Intermediates/Guanaco.build/Release-iphoneos/GuanacoTests-iOS.build/Objects-normal/armv7/GuanacoTests normal armv7\n    Ld /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Intermediates/Guanaco.build/Release-iphoneos/GuanacoTests-iOS.build/Objects-normal/arm64/GuanacoTests normal arm64\n    CreateUniversalBinary /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/GuanacoTests.xctest/GuanacoTests normal armv7\\ arm64\n    GenerateDSYMFile /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/GuanacoTests.xctest.dSYM /Users/jeff/Library/Developer/Xcode/DerivedData/Guanaco-eysiauicwtxjnxdaagvywxqejmjz/Build/Products/Release-iphoneos/GuanacoTests.xctest/GuanacoTests\n(8 failures)\n```\nIt seems like Guanaco needs to set ENABLE_BITCODE=NO.\nIf you have any other questions or issues. Feel free to reply here or open a new issue.\n-Jeff\n. Related to what @morganchen12 says about runloop cruft, you can print out the main loop's CFRunLoop to see debugging information about how many timers are actively enqueued.. Thanks for the detailed response Michael! \ud83d\ude03\nOn Jan 10, 2017, 8:39 AM -0800, Michael Beauregard notifications@github.com, wrote:\n\nClosed #385 (https://github.com/Quick/Nimble/issues/385).\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/issues/385#event-917794003), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCPwoRXp6aJgZsMQIYGwpL6JFPgFSks5rQ7RMgaJpZM4Lb8I5).\n\n. Hey @wongzigii,\nThis failing the cocoa pods test for some reason. I'm guessing cocoa pods tries to honor .swift-version?. Hey @sharplet,\nAccording to the JIRA issue, it seems like it's fixed on latest snapshots. Is that correct?. Thanks for following up @sharplet! \ud83d\udc4d . This is a bug. It was a limitation of an older implementation of Nimble that I think isn't a problem anymore.. Hm, it's still a problem with the type hierarchy ATM. Perhaps a future release a Nimble will properly handle this situation.. Thanks @ikesyo. Yeah, I'm planning on working on it this Sunday and Monday. I'll probably\nhave to cut its scope to get it in a workable state.\nOn Fri, Feb 24, 2017 at 9:19 AM Shaps notifications@github.com wrote:\n\n@jeffh https://github.com/jeffh\nWhen are you planning to get this in? I wanted to work on #218\nhttps://github.com/Quick/Nimble/pull/218 -- perhaps I should merge this\nchange in to mine to include it?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Quick/Nimble/pull/390#issuecomment-282349256, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEMCBwnhFacUsttNxfL8e8Zs0mBkTa8ks5rfxEsgaJpZM4Lr2_o\n.\n. @Quick/core, this should be mostly ready for review! I still need to write documentation and to plan a migration strategy for AsyncMatcherWrapper (probably remove it as a Matcher / Predicate). . Thanks @bonkey!. Sure, I'll cut a new release soon.. Hey @lferro9000,\n\nThere was a merge conflict because of recent CwlPreconditionTesting updates, but I've updated the project to SwiftLint and credited to your name.\nAlso, I've correctly the NSString(stringLiteral:) usage to not require suppressing the warning as well.\nHere's the commit if you're interested, cheers.. IMO, issues is probably not the best place to poll users (agreed, analytics would be nice). We could bump major versions, but I\u2019d be more hesitant to add this feature back in. Features that come in-and-out are features probably not worth having (imagine an API feature that was only available every other quarter).\nSince it\u2019s to support a swift-specific feature, is having it in Objective-C only isn\u2019t particularly useful? Or did you mean just when the Objective-C runtime is available? In general, we usually skew to Swift-only features than ObjC-only features, but I\u2019m certainly not against any ObjC only features.\n\nJeff\n\nOn Feb 7, 2017, 8:27 AM -0800, Aaron Crespo notifications@github.com, wrote:\n\nI use it, but I'm not married to it and only in a few places. Would like to hear what other users are thinking... Might also be interesting to see if people would want to keep the feature for obj-c but not for swift. I don't know the maintainer thoughts on cross language feature parity.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks, I've merged this into master. Closing! \ud83d\ude4c. Hey Nacho, I forgot getting around to notify this thread, but this has been fixed in the latest release.\n\nCheers,\nJeff\nSent from my iPhone\n\nOn Mar 27, 2017, at 12:45 PM, NachoSoto notifications@github.com wrote:\nAny chance you could make a release with this fix? \ud83d\ude4f\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hey @szweier,\n\nHow are you managing the view? Could you provide more code context for the view lifecycle during the test run?. Thanks for follow following up!\nOn Feb 11, 2017, 12:38 PM -0800, Steven Zweier notifications@github.com, wrote:\n\nClosed #396 (https://github.com/Quick/Nimble/issues/396).\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/issues/396#event-958457734), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCGMP2S1hVYjvtti_jHJaO4vt43cIks5rbhwygaJpZM4L64aa).\n\n. CWL doesn't support this, so it needs to be excluded from that target IIRC. Thanks @aaroncrespo!. Thanks @JakeLin!. Hey @Nandiin,\nThanks for filing an issue. I cloned your repo and saw the issue you were talking about. But I manually re-added the Nimble.framework under MainProjTests > Build Phases > Link Binary With Libraries by:\n\ndeleting the existing reference to Nimble.framework\nclicking the + in that section\nselect Nimble-iOS and click Add\nRe-run tests\n\nI don't know how you've configured Xcode, but ../Vendor/Nimble/build/Debug-iphoneos/Nimble.framework sounds vaguely custom relative build directory for derived data, but I don't have that build folder showing. The project's currently path for Nimble.framework is incorrect and should be referencing inside derived data.. The path /Users/nandiin/Library/Developer/Xcode/DerivedData/NimbleIssue-fkhppktoktwpjodtarmzrjobszwv/Build/Products/Debug-iphonesimulator/Nimble.framework/Nimble is the final destination of the resulting framework. The basic process Xcode is going through is this:\n\nBuild Nimble.framework <-- either build or derived data dir (?)\nBuild MainProj <-- probably derived data dir\nBuild MainProjTests <-- derived data dir\nCopy MainProj product to MainProjTests <-- derived data dir\nCopy Nimble.framework product to MainProjTests location in derived data <-- derived data dir\nRun MainProjTests\n\nI'm not sure what you mean by manually adding, could you break down the steps you did? When I add it through the steps I previously describe I get a path that looks like this:\n\nAlso, what is the path of the built Nimble.framework product? You can see them from the build output, near the end of the build process for the framework:\n\nIt seems like only the final framework was added linked to the project, which doesn't tell Xcode that one project depends on the result of another.\n. Hey @AnthonyMDev,\nI think this is resolved with a CwlPreconditionTesting update. Let me know if this PR https://github.com/Quick/Nimble/pull/407 works. This has been merged into master, closing. Feel free to reopen if this doesn't address the issue.. Thanks @soranoba!. Hey @ecbrodie,\nIt's not a great error message that Xcode gives, but essentially contain doesn't work with integers. I think you're looking for something like:\nswift\nexpect(myArray).to(contain(\"a\"))\nInstead of the length of myArray\nThere's a proposal to add protocol extensions, but we're partially at the mercy of how Xcode decided to expose these type errors.\nI'm closing the issue, but feel free to reopen if you think there's a different problem.. Hey Evan,\nIt\u2019s probably because the Foo class isn\u2019t Equatable. Try making it equatable and I\u2019m guessing it\u2019ll probably work.\n\nJeff\n\nOn Mar 7, 2017, 5:51 AM -0800, Evan Brodie notifications@github.com, wrote:\n\n@jeffh Eek, I must have drank a bad batch of coffee before I submitted this issue. I should not have been applying the contain matcher onto the result of myArray.count, that semantically makes no sense. The correct line should have indeed been expect(myArray).to(contain(\"a\")).\nI just tried the correct code in my Xcode IDE and I am happy to say that it compiled correctly and passed. HOWEVER, I am still running into this issue with the error message Ambiguous reference to member 'contain' when I am asserting on an array of objects instead of simple types like String or int. For example, the following code will produce the same error (regardless of Foo being a struct or a class):\nclass Foo {\n   let name: String\npublic init(_ name: String) {\n     self.name = name\n   }\n }\noverride func spec() {\n   describe(\"example tests\") {\n     it(\"verifies array contents\") {\n       let foo1 = Foo(\"abc\")\n       let foo2 = Foo(\"def\")\n       let fooArray = [foo1, foo2]\n       expect(fooArray).to(contain(foo1))\n     }\n   }\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hey @caynan,\n\nDo you have a code sample that reproduces the issue you're having?\nThanks.. Hey @abbeycode,\nDo you think this related to #400 and #406? If so, then PR https://github.com/Quick/Nimble/pull/407 may help.. I've merged the PR on master. So I'm closing this issue now. Feel free to reopen it if it's still a problem. Yep, when I get a good block of time to verify master in the various build configurations.. Hey Ryan, thanks for filing an issue!\nThat\u2019s definitely looks like a problem. If you could submit a pull request that would be great! Otherwise we\u2019ll get around to fixing this issue when we get the time available to do this.\n\nJeff\n\nOn Mar 7, 2017, 6:35 PM -0800, Ryan Fitzgerald notifications@github.com, wrote:\n\n\u2022 I have read CONTRIBUTING and have done my best to follow them.\nWhat did you do?\nCreated a test using a toEventually block. I've found that this retains the object being tested for the entire test suite.\nWhat did you expect to happen?\nI expect that the object under test would be released after the specific test function finished executing.\nWhat actually happened instead?\nThe object remained in memory for the entire test suite run, well after the specific test had finished running.\nEnvironment\nList the software versions you're using:\n\u2022 Quick: 1.1.0\n\u2022 Nimble: 6.0.1\n\u2022 Xcode Version: 8.2.1\n\u2022 Swift Version: 3\nPlease also mention which package manager you used and its version. Delete the\nother package managers in this list:\n\u2022 Cocoapods: 1.2.0\nProject that demonstrates the issue\nimport XCTest\nimport Quick\nimport Nimble\n@testable import NimbleExample\nvar allocations = 0\nclass Foo {\nvar count = 0\ninit() {\n   allocations += 1\n }\ndeinit {\n   print(\"foo dealloced\")\n   allocations -= 1\n }\n}\nclass NimbleMemoryLeakExampleSpec: QuickSpec {\noverride func spec() {\n   describe(\"memory leak\") {\n     it(\"allocates object\") {\n       let foo = Foo()\n       expect{allocations}.to(equal(1))\n   expect{foo.count}.toEventually(equal(0))\n }\n\n it(\"but is never released\") {\n   expect(allocations).toEventually(equal(0)) // This will fail and foo is being retained by AwaitPromiseBuilder<Bool>\n }\n\n}\n }\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It's possible to use instruments, although you'll probably need to tick some flags in the schema settings or manually attach to the process.\n\nOn Mar 14, 2017, 5:53 AM -0700, Ricardo Pereira notifications@github.com, wrote:\n\n@jeffh (https://github.com/jeffh) Any tip? Is it possible to analyse this issue with Instruments? Never done that for XCTestSuite.\n@ryanfitz (https://github.com/ryanfitz) Did you try with an autoreleasepool?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/issues/405#issuecomment-286411891), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCPXUk4PLK0DW0XsoTnwxJ8bcM3aZks5rlo3kgaJpZM4MWS0G).\n\n. Hey @lazerwalker, thanks for filing an issue!\nI think this is mostly because Nimble hasn't update CwlPreconditionTesting yet, I have PR https://github.com/Quick/Nimble/pull/407 that might have this fixed. Let me know if that branch works for you.. I've merged this PR into master. Let me know if this is a problem! \ud83d\ude03\nOn Mar 15, 2017, 9:49 AM -0700, Mike notifications@github.com, wrote:\n\nWe managed to get this integrated (ugh, recursive git submodules...). Will check back with you in a day or two when it should become clear whether this has cleared up or not.\nThanks again!\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub (https://github.com/Quick/Nimble/issues/406#issuecomment-286805237), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEMCPQNz_qnWqVwGAYREIM8VdC0RVANks5rmBaRgaJpZM4MYiml).\n\n. Did you mean \u201ctoNot(beNil())\u201d ?\n\nJeff\n\nOn Mar 15, 2017, 1:38 AM -0700, maasim94 notifications@github.com, wrote:\n\nI was able to find replacement of \"XCTAssertNil\" as to(beNil()), But there is no replacement to check not nil test\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks @wongzigii!. Hey @Rivukis,\n\nThis looks great! I just have a question:\nDid you consider passing the closure to succeed instead of the expectation? I'm curious on your thoughts about that as an alternative solution. I'm thinking something like:\nswift\nexpect(2).to(succeed({ actual in\n    return actual.evaluate() == 2 ? .succeeded : .failed(reason: \"some reason\")\n}))\nIt may be not as concise in your enum case, but it might be more generalized to handle more scenarios. (Of course if the closure was in the matcher the name of the matcher might need to change.). Also I forgot to talk about the documentation.\nThe documentation for Nimble is normally added to README. I'd probably put this one under 'Built-in Matcher Functions', right above 'Writing Your Own Matchers'.. Hey @Rivukis,\nThanks for responding. I just wanted to make sure that you considered other possibilities besides the current implementation. But this solution is probably the best option for a quick drop-in custom matcher.\nThanks @Rivukis! \ud83c\udf89 \n. Hey @benasher44, Could you try the freshly cut Nimble v6.1.0? 6.1.0 includes an updated version of CwlPreconditionTesting that should solve this issue.. Thanks for following up @holmes. I'm glad you figured out your issue \ud83d\ude04 . Thanks for filing an issue and following up!\n\nOn Mar 27, 2017, at 9:16 PM, Jason Holmes notifications@github.com wrote:\nI have no idea what's going on - but a project clean and rebuild got it working.\nIgnore me\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hey @olbrichj,\n\nThanks for filing an issue. The following code you mentioned didn't work:\nswift\nexpect { () -> Int in fatalError() }.to(raiseException())\nIs invalid because fatalError() doesn't return Int, but returns Never. Changing to:\nswift\nexpect { fatalError() }.to(raiseException())\nMakes it compile. Although fatalError() doesn't raise an exception, but an assertion error (aka - it crashes the program). You'll want throwAssertion() instead.\nIf that doesn't work out, feel free to reopen this issue.. Thanks @ysk-tngc!. Hey @dagio,\nHmm, Nimble v6.1.0 and master currently builds fine on my machine.\nThe issue you've linked to uses Nimble v5.1.1, but upgraded to Xcode 8.3, could that be your problem?. Thanks @honghaoz!. Thanks @chamander for fixing up the README. It's been much needed \ud83d\ude04 . Thanks @zacharynguyen for filing an issue. I can reproduce the issue and a fix will be coming shortly.. Hey @gavanchan-outware / @chamander, thanks for filing an issue.\nI can reproduce the issue, although I can also reproduce the same failure on Nimble v6.1.0. I think this behavior regressed from a Swift compiler change when generics dispatch implementation was probably changed.\n\nFor a little bit about the code context, failsWithErrorMessage is a utility helper to test failure messages in Nimble's test suite. Instead of letting the test failures bubble up to XCTest, and thus always causing the test suite to fail, failsWithErrorMessage expects an error from Nimble by replacing it's error reporting interface with its own to observe for errors. I'd recommend looking at the AssertionHandler protocol or the NimbleAssertionHandler global for more details of the inner workings of that layer. In short, XCTest integration is isolated to NimbleXCTestHandler (and it's possible to use Nimble without XCTest).\n\nAs for your last message, #2 is different from the code that's listed in the test suite (toNot instead of to):\nswift\nexpect([\"a\", \"b\", \"c\"]).toNot(contain(\"bar\", \"b\")). Ah, I see the issue with failsWithErrorMessage. That's a good find. A better change is to modify the inner loop of failsWithErrorMessage to be:\nswift\nfor assertion in recorder.assertions {\n    if !assertion.success && assertion.message.stringValue == msg {\n        lastFailure = assertion\n        foundFailureMessage = true\n        break\n    }\n}\nWhich shows the same 24 failures that you're mentioning.. I've left some WIP changes on my branch attached as a PR #428. I'll see if I can try and get to this tomorrow when I get some time.. Hey @gavanchan-outware / @chamander,\nI've merged a fix into master. I'll probably cut a patchfix release next week. Let me know if this solves the issues you've been getting.\nThanks,\nJeff. Thanks @Lutzifer!. Hey @agordeev, I'm not sure what you want, but perhaps you're looking for some custom validation?. Hey @darrarski,\nI cloned the repo you linked to and was able to build UnderControlTests-tvOS target:\n\ngit clone https://github.com/darrarski/UnderControl\npod install\nopen UnderControl.xcworkspace\nSelect UnderControlTests-tvOS\n\u2318U and see tests pass\n\nAlthough I'm using Xcode 8.3.3 (8E3004b). Did you try cleaning your derived data?. Thanks for following up and closing the issue. \ud83d\ude00\n\nJeff\n\nSent from my iPhone\nOn Jun 27, 2017, 3:53 AM -0700, Dariusz Rybicki notifications@github.com, wrote:\n\nClosed #430.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks @sharplet!. Thanks for filing the issue. Yeah, it's a Carthage issue. I'll close this issue.. Hey @Pitsko, I'm not sure exactly what you're trying to do, but Nimble doesn't support an explicit way to retry. The easiest way is to implement it yourself for tests:\n\nswift\nfunc retryableRequest(complete: (success) -> Void) {\n    var remainingAttempts = 3\n    api.sendRequest { success in\n        if success {\n            complete(success)\n        } else {\n            if remainingAttempts == 0 {\n                complete(false)\n            }\n            remainingAttempts -= 1\n        }\n    }\n}. Whoops, didn't mean to close the issue.. Thanks @mrh-is! . Thanks @ikesyo. Thanks @ikesyo!. Hey @timojaask, thanks for filing an issue.\nCurrently the warnings are expected for Nimble as some of its public APIs are in mist of migrating starting with v7 release. Once the migration is complete, then all these warnings/deprecations will be removed.. Thanks @ikesyo!. FileString apparently isn't portable to @objc. I'm not entirely sure why, but you could have a build conditional for the swift version for a quick-fix. But it probably warrants more investigation to why.. Thanks @ikesyo!. Hey @aboedo,\nThanks for filling an issue. Unfortunately, Nimble currently uses Swift's interop with Objective-C which currently doesn't support Objective-C++.\nFor now, I have a hacky proof-of-concept that simply carries the swift-bridged types over to ObjC on my branch. Let me know if that works.. Thanks @ryanfitz! (I've modified the test to avoid linting failures.). There's a past issue with me and Ash Furrow talking about intermittent\nfailures that's worth finding. But in short, printing CFRunLoop prints out\nall the attached timers that may be blocking the run loop.\n\nJeff\n\nOn Fri, Oct 27, 2017, 7:16 AM Mark Anders notifications@github.com wrote:\n\nAfter more testing, it still does happen with 9.0, but not nearly as much\nas with 9.0.1.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/Quick/Nimble/issues/475#issuecomment-339984078, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEMCCXPAP3KOA9GIeQJfu8U4KSJxPXoks5sweXAgaJpZM4P60lw\n.\n. Hey @mosamer,\n\nI haven\u2019t had much free time to do any development for awhile (computer and apt issues).\nIs there a reason to introduce a new extensible matched type over extending predicate (or even expectation)?\nAlso, could you please add tests, thanks!. If I recall correctly, responder chains require being attached to UIWindows.\n\nJeff\n\nSent from my iPhone\nOn Nov 27, 2017, 6:19 AM -0800, AdamMak notifications@github.com, wrote:\n\nList the software versions you're using:\n\u2022 Quick: 1.2.0\n\u2022 Nimble: 7.0.2\n\u2022 Xcode Version: 9.1\n\u2022 Swift Version: 4.0\n\u2022 Cocoapods: 1.3.1\nI am trying to write a test that will determine whether a textfield has become active or not but it seems when I write the expect statement to check if a textfield is first responder, it alway returns false.\nI have started a new project, just placed one text field in the middle of the screen and on viewDidLoad made the text field first responder\n@IBOutlet var testField : UITextField!\noverride func viewDidLoad() {\n       super.viewDidLoad()\n   testField.becomeFirstResponder()\n\n}\nIn my spec test, I have written this\n override func spec() {\n     var viewController : ViewController!\n   beforeEach {\n       let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n\n       viewController = storyboard.instantiateViewController(withIdentifier: \"viewController\") as! ViewController\n       _ = viewController.view\n   }\n\n   describe(\"On load, text field becomes active\", {\n\n       it(\"TestField should be first responder\"){\n\n           expect(viewController.testField.isFirstResponder).toEventually(beTrue())\n       }\n   })\n\n}\nHowever, every time, the expect test fails, as the isFirstResponder is always false. This code works fine in my view controller, I can call isFirstResponder and it returns true, however in the QuickSpec test it always returns false. Can anyone help me understand why this particular test is failing?\nThanks in advance\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks @fphilipe!. Hey I haven\u2019t done swift programming in awhile. I\u2019ve been mostly burnt out of OSS and haven\u2019t considered returning to a large project. By now, other @Quick/core team members probably have a lot more context of the code than I do (thanks for all the effort you\u2019re putting in @ikesyo \ud83d\udc4f )\n\nWith that out of the way,, @ikesyo is correct. forcefullyAbortTimeout is additive to the original timeout. It\u2019s a weak heuristic to forcefully end the run loop\u2019s current execution. That\u2019s because the normal fail timeout code runs on the run loop. But if that callback doesn\u2019t get to run, there needs to be another recovery mechanism. That\u2019s what the forcefullyAbortTimeout parameter is used for: to dangerously interrupt the run loop to avoid potentially having a run loop that doesn\u2019t end.\n@cruisediary, it\u2019s probably useful to understand how your using it that\u2019s causing this to fire. Because it\u2019s usually a sign of a filled main run loop that prevents the normal Nimble timeout from triggering. But that\u2019s for the other Quick contributors to look into.\nA possible better alternative is to switch to XCTest\u2019s async (Nimble\u2019s async existed before XCTest).. Extra double quote :(\n. These are two separate elements in contains() right?\n. beTruthy() I presume ;)\nThere's another one like that below.\n. Correct me if I'm wrong, but I thought: expect(dolphin).to(beAKindOf(Mammal)) also works. \n. Remove this line? It's not on the Quick pod spec. I assume @modocache didn't signup as the social media guru :P\n. Do we need a source 'https://rubygems.org' line here?\nI happen to get this without it:\ntext\njeff@cyborg ~/w/Nimble-CocoaPods> bundle install\nFetching https://github.com/CocoaPods/CocoaPods.git\nFetching https://github.com/CocoaPods/Core.git\nFetching https://github.com/CocoaPods/Xcodeproj.git\nResolving dependencies...\nYour Gemfile has no gem server sources. If you need gems that are not already on your\nmachine, add a line like this to your Gemfile:\nsource 'https://rubygems.org'\nCould not find gem 'cocoapods-trunk (~> 0.4.0) ruby', which is required by gem 'cocoapods\n(>= 0) ruby', in any of the sources.\n. TO use Nimble in CocoaPods form to test your iOS or OS X applications\nIs this \"To use Nimble in CocoaPods from your iOS or OS X applications\"\nor \"To use Nimble in CocoaPods to test your iOS or OS X applications\"?\n. Change this to the official repository?\n. The non-static dispatch_once_t is intended. It's to ensure the action() doesn't get called multiple times per waitUntil call, but the dispatch_once closure should be called once per invocation of waitUntil.\n. Just a tiny question: should we prefix \"private-ish\" functions with an underscore? Or do you prefer snake-casing it instead?\n. Should this if statement be inlined to where collectionIsUsable = false? I think we can remove that variable entirely.\n. Oops, my bad, I didn't see that, thanks for the pointing that out.\n. Yeah, there needs to be some changes to simplify the internals. I think the removal a BasicMatcher and NonNilBasicMatcher would be preferred in some way. There also needs a reinvestigation if the swift compiler still gives an obscure message when a generic does match optionals. having the matcher be able to specify that while Nimble's Expectation and matcher protocols be ignorant of that detail would be best.\nAll that stuff are just floating in my head right now. For various personal reasons, I don't have the available free time yet.\n. I definitely agree. I think I forgot this one, but added it other places. I'll add internal.\n:+1: For a consistent style guide. I don't really care too much what the conventions are, just that it's consistent.\n. Sounds good. I'm just not sure what of a good name :blush:. They're taken directly from the original to and toNot methods. It's mostly bootstrapping of the expectation. It's a messy part that I'm not sure the best way to break it apart.\n. Thanks! I'll reword it into something clearer.\n. Not that I could tell, although it's weird either way. Nimble's Objective-C matcher API probably needs some reworking for this. I'll need to take another pass to see if it's worth removing use of location in MatcherBlock and FullMatcherBlock.\n. I'll create a style guide on the Quick Org if that sounds good to you. We can discuss and nitpick all the styles before applying them uniformly across Quick & Nimble.\n. Actually, after thinking about it more, it was a bug if the ObjC matcher was used but the passed in source location wasn't used :fearful:.\nNow, I've changed the ObjCMatcher to drop location from the block, making this change mandatory.\n. just a nitpick, I prefer to avoid one letter variables (d). Thanks!\n. Setting the dateFormatter's dateFormat property generally negates the performance benefits of memoizing the instance. Although that behavior may have changes in later versions of iOS, I haven't verified recently.\nYou can either inline the let expression or use an anonymous closure invocation:\nswift\nprivate let dateFormatter = {\n    let formatter = NSDateFormatter()\n    // ...\n   return formatter\n}()\n. Yeah, it would be better to just replace with a default parameter (with non-optional NSTimeInterval). It existed because past swift / xcode versions needed the duplicated versions to provide more sane auto-complete options.\n:+1: \n. Nitpick: I think this would be better in a separate test case that explains its purpose.\n. I'd prefer 'Anything' instead of 'DontCare'\n. Extra print should be removed\n. Extra print should be removed\n. Nitpick: make the ordering explicit\n. Is there a better way to make this internal without exposing these methods?\nAlso, make the tests use what an end user use instead of accessing internals in tests.\n. Is this needed?\n. Please add some documentation comments for the public matcher functions. It helps when testers are typing / jump to definition.\n. Nitpick: It might be better to use an array literal in the macro instead of nil termination. This gives us a compiler / runtime error when nil is passed along. IIRC, nil termination short-circuits if an earlier nil is given in the arg list.\n. We need one more case: If no matchers a given to satisfyAnyOf, then we should fail with an error like:\nsatisfyAnyOf requires at least one matcher\n. Nitpick: Please remove the header comments. Mostly just to be consistent with the rest of the code base (and they don't add much value)\n. I think the postedNotifications func is causing problems that forces expect(expression: ...) form you're talking about. postedNotification should return the observed notifications:\nswift\npublic func postedNotifications(notificationCenter: NSNotificationCenter = NSNotificationCenter.defaultCenter(),\n                                block: () throws -> Void) throws -> [NSNotification]\nNimble's expect(...) argument is an @autoclosure. This means the expression in that argument is an implicit closure:\nswift\n// this line\nexpect(postedNotification { ... }).to(equal(...))\n// is equivalent to this line\nexpect { postedNotification { ... } }.to(equal(...))\nThis allows Nimble to catch errors despite looking like a normal argument:\nswift\nexpect(try somethingThatThrows()).to(throwError(...))\nexpect(raisesNSException()).to(raiseException(...))\n. I think the need for regular expression failure messages can be removed by using NSString's format to get the memory address. beIdenticalTo's tests do this:\nswift\nfunc testBeIdenticalToPositiveMessage() {\n    let num1 = NSNumber(integer:1)\n    let num2 = NSNumber(integer:2)\n    let message = NSString(format: \"expected to be identical to <%p>, got <%p>\", num2, num1)\n    failsWithErrorMessage(message.description) {\n        expect(num1).to(beIdenticalTo(num2))\n    }\n}\nI don't think there's a need to add regular expression matching for failsWithErrorMessage.\n. Nitpick: Please be explicit about visibility scope for top-level types (add internal keyword).\n. I think this expression needs to be refactored so that ! doesn't cause an assertion failure.\n. If we can't use isKindOfClass for linux, I don't think we need this matcher at all. It's really only for objective-c objects anyway.\n. Is it possible to just #if !os(Linux) this entire file? I'd still prefer to have tests for iOS / OS X :wink:\n. It's just a line number to make all the other line number indicators derived of. This makes it a bit easier to change the error message without having to update every time the error message changes.\nThe error message emits line numbers based on where waitUntil and toEventually is used.\n. I'm just talking about operator precedence.\n. I still prefer Anything mostly because I'm not a fan of contractions in source code.\n. Is there a reason to not make function equal to __FUNCTION__ by default?\n. what's the reason for this switch and keeping the old function around?\n. As long as they're internal and there is only one of these implementations. I don't have a particular preference. \nSent from my iPhone\n\nOn Jan 21, 2016, at 2:25 PM, Brian Croom notifications@github.com wrote:\nIn Sources/Nimble/Matchers/Contain.swift:\n\n@@ -9,7 +9,7 @@ private func contain\n\nWhich way do you prefer? Free function or protocol extension? Regardless, we don't need both, you're right.\n\u2014\nReply to this email directly or view it on GitHub.\n. Perhaps it's better to just compiler-comment out this line? This is to array bridging from swift arrays <-> NSArrays\n. Type conversion tests, probably better to leave it compiler-commented.\n. I'm a bit mixed about even having this around to support toEventually when it doesn't really work as expected.\n\nI prefer having toEventually removed from the API for linux. Thoughts?\n. While it's nice to note that it's an alias to beIdenticalTo, it's still useful to provide a one-liner description on what it actually do.\n. I don't see an issue for using Nimble expectations here. Please use it instead of XCTest to be more consistent\n. We should get rid of the return value because it isn't used.\n. Old habits die hard \ud83d\ude22 \n. Thanks! I'll get that in before merging\n. Please add the following test cases:\n- Test negative assertions (using toNot)\n- Test error messages with negative assertions (using toNot)\n. Awesome on adding Objective-C support too! Like above, please add test cases for negative assertion cases.\n. Could we support other collection types?\n- NSSet\n- NSOrderedSet\n- NSHashTable\n- NSIndexSet\nI'm thinking perhaps relying on NSFastNumeration or NSEnumerator?\n. Nitpick: Please remove @testable - Nimble only tests public APIs.\n. Could we use fileprivate instead of having to prefix the class names?. Ditto Previous: \n\nCould we use fileprivate instead of having to prefix the class names?. Since this supports Swift types, it's probably useful to remove/adjust it's ObjC-runtime only build conditional?\n\n(Also, don't forget to conditionally do this for tests).. @sigito: CI will be set up to enforce this for contributions. Otherwise all users of Nimble will require swiftlint.. I'd have to check if these attributes still cause build errors. If @available(*, deprecated, message: \"...\") causes a build failure, then it's effectively the same as removing the API.. Agreed. I'll get that change in. ",
    "endersstocker": "@jeffh \nI would use the < expected, got > pattern where possible. E.g., expected a kind of 'NSDate', got 'NSString', expected a value less than '2', got '10'. If the message cannot be clearly represented using this pattern I would use < expected subject to, got >. E.g., expected subject to be empty, got 'Hello', expected subject to end with 'ing', got 'TARDIS'.\nThere would be two patterns in use: a primary and a secondary.\n. ",
    "blindsey": "@jeffh I'm struggling with getting the tests to run after removing Nimble-Bridging-Header.h. The 'expect' func isn't exported anymore. Curious to see what your investigation turns up.\n. return range && range!.startIndex == actual.startIndex\n. return range && range!.endIndex == collection.endIndex\n. I think this needs to be:\nreturn range && !range!.isEmpty\nOtherwise you are negating a conditional/nil.\n. ",
    "sync": "@drmohundro \nremove:\n@interface NMBExpectation : NSObject\n- (id)initWithActualBlock:(NSObject *(^)())actualBlock negative:(BOOL)negative file:(NSString *)file line:(int)line;\n@end\nmake NMBExpectation and init method public:\npublic class NMBExpectation : NSObject { ...\npublic init(actualBlock: () -> NSObject!, negative: Bool, file: String, line: Int) {\nthen it will compile :+1: \n. It is quite common to override equality test in an enum if you have associated values\nfor example:\n```\npublic enum Error: ErrorType {\n    case Parsing(reason: String?)\n    case Response(statusCode: Int)\npublic var toNSError: NSError {\n    return NSError(domain: _domain, code: _code, userInfo: userInfo)\n}\n\nprivate var userInfo: [NSObject : AnyObject]? {\n    var localizedDescription: String?\n    switch self {\n    case .Parsing(let reason):\n        localizedDescription = reason\n    case .Response(let statusCode):\n        localizedDescription = NSHTTPURLResponse.localizedStringForStatusCode(statusCode)\n    }\n\n    return localizedDescription.map { [NSLocalizedDescriptionKey: $0] }\n}\n\n}\nextension Error: Equatable {}\npublic func == (lhs: Error, rhs: Error) -> Bool {\n    switch (lhs, rhs) {\n    case (.Parsing(let lReason), .Parsing(let rReason)):\n        return lReason == rReason\n    case (.Response(let lStatusCode), .Response(let rStatusCode)):\n        return lStatusCode == rStatusCode\n    default:\n        return false\n    }\n}\n```\nwith these changes my equality tests are now failing because an enum is by default an ErrorType\n```\ncontext(\"when not equal\") {\n                    it(\"should not be equal\") {\n                        let error: Error = .Parsing(reason: \"test\")\n                        let error2: Error = .Response(statusCode: 5)\n                        expect(error) != error2\n                    }\n                context(\"with different reason\") {\n                    it(\"should not be equal\") {\n                        let error: Error = .Parsing(reason: \"test\")\n                        let error2: Error = .Parsing(reason: \"another test\")\n                        expect(error) != error2\n                    }\n                }\n            }\n\n```\n. It is quite common to override equality test in an enum if you have associated values\nfor example:\n```\npublic enum Error: ErrorType {\n    case Parsing(reason: String?)\n    case Response(statusCode: Int)\npublic var toNSError: NSError {\n    return NSError(domain: _domain, code: _code, userInfo: userInfo)\n}\n\nprivate var userInfo: [NSObject : AnyObject]? {\n    var localizedDescription: String?\n    switch self {\n    case .Parsing(let reason):\n        localizedDescription = reason\n    case .Response(let statusCode):\n        localizedDescription = NSHTTPURLResponse.localizedStringForStatusCode(statusCode)\n    }\n\n    return localizedDescription.map { [NSLocalizedDescriptionKey: $0] }\n}\n\n}\nextension Error: Equatable {}\npublic func == (lhs: Error, rhs: Error) -> Bool {\n    switch (lhs, rhs) {\n    case (.Parsing(let lReason), .Parsing(let rReason)):\n        return lReason == rReason\n    case (.Response(let lStatusCode), .Response(let rStatusCode)):\n        return lStatusCode == rStatusCode\n    default:\n        return false\n    }\n}\n```\nwith these changes my equality tests are now failing because an enum is by default an ErrorType\n```\ncontext(\"when not equal\") {\n                    it(\"should not be equal\") {\n                        let error: Error = .Parsing(reason: \"test\")\n                        let error2: Error = .Response(statusCode: 5)\n                        expect(error) != error2\n                    }\n                context(\"with different reason\") {\n                    it(\"should not be equal\") {\n                        let error: Error = .Parsing(reason: \"test\")\n                        let error2: Error = .Parsing(reason: \"another test\")\n                        expect(error) != error2\n                    }\n                }\n            }\n\n```\n. ",
    "drmohundro": "@blindsey thanks - got the conditional checks around range corrected. @sync got NMBExpectation working. I could've sworn I tried that, but clearly I didn't and I'm still trying to learn how Swift and ObjC work together. :+1:\nThe next steps I believe are to get the tests passing, which is what @blindsey was referring to I believe.\n. Good catch - corrected. Right now, I'm dealing with BasicMatcher not conforming to Matcher protocols. I'm not sure if I messed up something while adding public accessors to get things to compile or if it's a compilation difference between beta 3 and beta 4.\n. Made it quite a bit farther now... I'll try to summarize what's happened and ask for some eyes/feedback on what I've done, because I may have taken some missteps.\n- First off, I made the Matcher protocol inherit from BasicMatcher - it seemed to simplify some operations and also leads into the next bullet...\n- I was running into \"invalid redeclaration\" errors around the to extension method and the actual implementation that lives on Expectation. I ended up leaving those methods internal and renaming them to toImpl and toNotImpl. This way, the only public to methods that will be accessed are the extension methods.\n- failsWithErrorMessage in the test utils is crashing the test runner. I'm not sure why yet.\n- testArrayEquality is failing to compile right now, specifically the calls that take an Array<Int> in as opposed to an array literal (like [1,2,3]). Not sure about that yet.\nIf I exit out of failsWithErrorMessage early and comment out the 3 lines in testArrayEquality, all but 5 tests pass.\nLet me know if I'm way off base or anything with these changes! Thanks!\n. Thanks @tonyd256 and confirmed, everything builds and all tests pass on my box, too!\n:+1:\nLooks like either this PR or #10 should get beta 4 compatibility working.\n. Interesting... I am getting failures while running ./test.sh, just not when running the tests in XCode. It does look like it is in the tests related to beCloseTo. Let me dig on that some.\n. Interesting... you're right, I can repro it within XCode by using iPhone 4S simulator as an example. Here's a screenshot if anyone has any good ideas. I was going to say it might have something to do with the Expression instance getting cleaned up, but as far as I can tell, everything is a struct at this level of the call stack (so no deinit).\n\n. Awesome, thanks for the tip @atermenji! test.sh now passes with Array equatable implementation.\n. Quick question on my changes thus far... I'm not really a fan of all of the nil checking that I added as a result of Optionals no longer conform to BooleanType (formerly LogicValue).\nI hadn't spotted it yet, but there is a hasValue method on Optionals now, so all of the nil checking code that I added could be rewritten. See the below example:\nBefore:\nswift\nreturn instance != nil && instance!.isMemberOfClass(expectedClass)\nAfter:\nswift\nreturn instance.hasValue && instance!.isMemberOfClass(expectedClass)\nAny thoughts on which one is better? I personally like checking hasValue better, but I'd rather get input first before I go changing more.\n. Done! That's much nicer and clearer I think.\n. ",
    "atermenji": "@drmohundro as for testArrayEquality:\nIn the newest XCode compiler now complains to [T] not being Equatable in the func equal<T: Equatable>(expectedValue: T?).\nI guess this is a normal behaviour, because Swift Array is not Equatable.\nThere are several ways to bypass this restriction:\n1. Use NSArray instead of an Array\n2. Write expectation in different style:\nswift\nexpect(arrayOne == arrayTwo).to(beTrue())\n1. Overload equal function to support Arrays somehow like this\nswift\nfunc equal<T: Equatable>(expectedValue: [T]?)\nWe are facing the same problem in our similar framework and we've decided to use NSArrays instead of Arrays by now.\n. @drmohundro  you may use _bridgeToObjectiveC() instead of bridgeToObjectiveC()\n``` swift\nextension Array : Equatable { }\npublic func ==(lhs: Array, rhs: Array) -> Bool {\n    return lhs._bridgeToObjectiveC() == rhs._bridgeToObjectiveC()\n}\n```\n. ",
    "tonyd256": "@drmohundro I cloned your branch and tried out a few things.  I got stuff mostly working by adding these things:\n```\nextension Array: Equatable {\n}\npublic func ==(lhs: Array, rhs: Array) -> Bool {\n    return lhs.bridgeToObjectiveC() == rhs.bridgeToObjectiveC()\n}\n```\nextension Optional: Printable {\n    public var description: String {\n        switch self {\n        case let .Some(value):\n            return toString(value)\n        default: return \"nil\"\n        }\n    }\n}\nFinally, on line 40 of BeEmptyTest.swift replace \"<(1)>\" with \"<[1]>\"\nThere are still 3 (2 really) tests that fail.  The async wrapper and the identical to message test.\n. Also, there was a typo in Contain.swift ... line 20 should read: return range && !range!.isEmpty ... there was a logical negation missing.\n. OK ... figured out the Async issue:\nIn AsyncMatcherWrapper.swift, in the Expectation extension, use toImpl() and toNotImpl() instead of to() and toNot().  Should look like this:\n```\nextension Expectation {\n    public func toEventually(matcher: U, timeout: NSTimeInterval = 1, pollInterval: NSTimeInterval = 0.1) {\n        toImpl(AsyncMatcherWrapper(\n            fullMatcher: FullMatcherWrapper(\n                matcher: matcher,\n                to: \"to eventually\",\n                toNot: \"to eventually not\"),\n            timeoutInterval: timeout,\n            pollInterval: pollInterval))\n    }\npublic func toEventuallyNot<U where U: BasicMatcher, U.ValueType == T>(matcher: U, timeout: NSTimeInterval = 1, pollInterval: NSTimeInterval = 0.1) {\n    toNotImpl(AsyncMatcherWrapper(\n        fullMatcher: FullMatcherWrapper(\n            matcher: matcher,\n            to: \"to eventually\",\n            toNot: \"to eventually not\"),\n        timeoutInterval: timeout,\n        pollInterval: pollInterval))\n}\n\n}\n```\n. That only leaves issues with the error messages.  It seems the actual Nimble lib works for beta 4.\n. ugh ... ok that seemed silly .. I got everything passing ... I'll PR into here and to @drmohundro's fork.  Not sure how you want to handle getting all this in.\n. ",
    "szehnder": "https://github.com/drmohundro/Nimble.git compiles with XCode6 beta4\n. ",
    "modocache": "I think beFalsy should match nil (i.e.: a zero value) and beTruthy should match non-nil (i.e.: non-zero values). This is the same as Specta behavior.\nIn addition I would want beTrue and beFalse matchers, which only match true and false.\n. See: https://github.com/rspec/rspec-expectations#truthiness\nRSpec has both be_truthy and be_true. :point_up: :bulb: \n. >  I generally pull from the python community for technical writing guidance (e.g. zope and django).\nAwesome resources--thanks!\nI agree with you on tone and 1st-person speech. I usually end up writing how I speak, and I'm trying to use 1st-person more often (i.e.: \"I write unit tests\", rather than \"You should write unit tests\"), hence the 1st-person READMEs.\nBut I agree that my writing ends up being really long, so I'll try a rewrite of both Quick and Nimble READMEs after reading the articles you linked to.\n\nFYI, I think documentation and stability are the most important factors driving Quick and Nimble's adoption, so I'm planning to invest a lot of time in these two. :v: :sparkles: \n. @jeffh Updated with style changes, but not yet complete. If you've got a minute let me know what you think so far! :monkey_face: \n. @jeffh This is ready to merge, provided you're OK with the changes. Any and all feedback welcome! :+1: \n. @jeffh All great catches, thanks! :tophat: :sparkles: \n\nWriting this was also great for learning more about Nimble--it's so well built! Way to go! :+1: \n. \nAwesome, thanks! :+1: \n. +1, I think it'd be interesting to explore whether this is possible. Simply wrapping async functionality in XCTest might more stable, in the long run, than re-inventing that functionality in Nimble.\n. Nope! Same as before: expect(...).toEventually(...) provides a better API that isn't coupled to _XCTCurrentTestCase being set, or any of the other internal chicanery of XCTest. My original comment, in 2014, was wrong: rolling our own solution in Nimble has proven far more stable than interoperating with XCTest. Our async functionality continues to work, even on Linux, with no source code changes.\nThanks for the follow up, though! It's fun looking back on this decision, especially since I think we made the right one here. :)\n. @tonyxiao Is there something that you're missing from expect(...).toEventually(...), or some functionality that exists in XCTestExpectation but not in our API?\n. XCTestCase's wait for expectations method does pretty much the same thing, waiting for any outstanding expectations to be fulfilled. It is nice that you can call it once to wait for all expectations. On the other hand, you can't wait for individual expectations.\u00a0\nWe could build an API that mirrors the XCTestExpectation pattern... but I prefer Nimble's individual expectation API, so I'm in no hurry to build something like that. :)\nOn Fri, Jul 1, 2016 at 5:42 PM -0400, \"tonyxiao\" notifications@github.com wrote:\n@modocache not specifically. I liked the fact that XCTestExpectation seems explicit about promises being fulfilled whereas expect(...).toEventually(...) repeatedly checks value until expectation satisfies. Not sure how much difference that actually makes in every day usage. \n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. IIRC this was with a completely clean derived data.\nBTW I definitely wouldn't recommend using Yosemite. I'm kicked off wifi constantly, it's such a pain. :(\nSent from my iPhone\n\nOn Sep 18, 2014, at 5:36 PM, Jeff Hui notifications@github.com wrote:\nHey @modocache, is this a stale derived data cache? I'm not using Yosemite, so I can't verify this.\n\u0081\\\nReply to this email directly or view it on GitHub.\n. Fixed in pull request #35.\n. @jeffh @nerdyc I tried my hand at it but didn't get anywhere. But I think we should merge this as-is.\n\nThe impact to users of doing so is having them say \"Hey, these failure messages are kind of weird.\"\nRight now, the reaction is more like \"Hey, Nimble doesn't work at all!\"\n. I'm experiencing the same issue. Xcode doesn't show any compiler errors, but the Report navigator reveals:\nCommand /Applications/Xcode-Beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1\nNot the most helpful error message! :speak_no_evil: \nThe changes in pull request #35 got my tests to build; any chance we can merge that one to close this issue, @jeffh? It appears that patch causes some of Nimble's tests to fail, but I think it's better than compilation failures. Thoughts?\n. I don't think Nimble appearing in red is an error; so long as your tests run, everything's working fine. I've seen libraries show up in red in Xcode before--I'm not really sure what it's supposed to mean, actually!\nSent from my iPhone\n. Awesome! Thanks, @rbeeger and @jeffh, it's great to put this one to rest! :100: \n. @robrix Thanks for the pull request! :cocktail: :sparkles: \nI think this test may be relevant, since the Nimble README mentions that C primitive conversion works, even without explicitly specifying both the actual and expected values: https://github.com/Quick/Nimble#c-primitives\nIf that no longer works, the test fixes should be accompanied with a README edit.\nCurrently downloading Xcode 6.1b3.\n. Oops, just realized this hadn't been merged. Sorry, @robrix, and thanks! :revolving_hearts: :sparkles: \n. Travis CI appears to be hanging on this one. Normally I'd merge anyway, but I'm super stoked @jeffh added CI in the first place, and I don't want to be the first person to break the build :sweat_smile: \nI reached out to Travis CI for some insight as to why we're not seeing any output: https://twitter.com/modocache/status/524637270247501824\n. No word from the fine folks at Travis, but looks like the job completed successfully. :green_heart: \nThanks, @jspahrsummers! :+1: \n. \"Tailor\" was an artifact from ancient times. Thanks for the update, @swizzlr!\n. > This does have the incidental consequence of truncating the actual value before the expected value.\nThanks for the heads up! I like the consistency in the messages. If you're fine with this, then I think it's good. Code looks fine to merge, of course :100: \n. Just one question on the failure message, other than that looks good to merge!\n. Looks good to me! Awesome as usual, @jeffh! :sparkles: \n. @jeffh Oops, saw this too late--I already tagged v0.1.0! So the cat's out of the bag: I don't think we have to match the versions; each library should update its version to whatever makes sense for that library. Otherwise we may end up with a major change in Quick, and Nimble would have no differences between v0.1.0 and v0.2.0.\nI do think we should begin to think about semver. We should update major version numbers (i.e.: v0.1.0 to v0.2.0) in the release after breaking changes are introduced.\n. GitHub doesn't seem to be surfacing it in the UI, but I also had a question on social media URL: https://github.com/Quick/Nimble/pull/56#discussion_r20642239\n. Awesome! Thanks a ton! :sparkles: \n. Thanks a ton for this issue, @gfontenot! I've tagged the current head as v0.1.0. :+1:  /cc @jeffh \nLet us know how you enjoy using Nimble with Carthage!\n. By the way, @gfontenot, Carthage allows you to just use the latest version:\n```\nRequire exactly version 0.1.0\ngithub \"Quick/Nimble\" == 0.1.0\nUse the latest version\ngithub \"Quick/Nimble\"\n```\n:+1: :sparkles: \n. Oh, my bad, this was fixed shortly after I reported it, in 62e0d794f5aceace41eddb66000c1dd26426079b. Thanks for the follow up!\n. Had a few questions, but overall seems like a huge improvement! Yay 1st-class Objective-C support!\n. Looks good, I say merge when ready! I chimed in on #62; I don't think beEmpty() should match nil.\n. Thank you kindly, @a2! :+1: \n. I'd say no. It'd be quite surprising.\n. Nice addition to the documentation! :+1: \n. Awesome! :+1: \n. Excellent! Now we can wait in all sorts of environments.\n\n. Nice catch, @kylef! :100: \nThis means https://github.com/Quick/Quick/issues/121 is an especially egregious bug, since it prevents use of XCTAssert from within Quick examples written in Objective-C, even where they may be more type-safe.\n/cc @jeffh for any thoughts and, if none, a merge.\n. Oh wait, never mind--of course XCTAssert in Objective-C doesn't have type safety. :stuck_out_tongue: \nStill, this seems like an accurate change to the documentation--Nimble shouldn't advertise advantages that already exist in (the Swift versions of) XCTAssert.\n. \n. Thanks for the pull request, @feinstruktur! :wave: :grin: \nRSpec dropped support for matcher operators like == when they migrated to the expect(...).to(...) syntax, primarily due to runtime warnings from the Ruby interpreter. Since we don't have that problem in Swift, I'm not opposed to matcher operators.\nI'm largely ambivalent, though.\nI don't think they provide enough value to justify the lines of code needed to define them--even if that's a very small amount. But I personally don't use them, so I really can't speak to how useful they are! :speak_no_evil: :banana: \nI would say that ~= reminded me of the Ruby operator =~, so I think I'd find it confusing to use. But again, I don't normally use matcher operators, so take that with a grain of salt.\n. Option-x makes \u2248 for me. That's pretty awesome, actually. :open_mouth: \n. Can't unsee.\nSent from my iPhone\n\nOn Jan 2, 2015, at 3:50 PM, Paul Young notifications@github.com wrote:\nIt also looks like bacon \u2248 \n\u2014\nReply to this email directly or view it on GitHub.\n. Awesome, thanks for the diagnoses and follow-up, @rbeeger and @jspahrsummers! :+1: \n. > blew away derived data several times before declaring myself insane\n\nSorry if I'm misunderstanding--this means that the build error occurs every time, even after clearing derived data, right? Just want to make sure! :monkey: \n. I think this is worth considering--thanks for the heads up, @kylef! :+1: \nBefore merging this, I'd like to reach out to @MarcoSero for his thoughts on the matter. :email: :sparkles:\n. After speaking with @MarcoSero, we've decided to keep this project's CocoaPod name the same, but change his to Nimble-CoreData. He asked if I (or someone contributing to this project) could take care of the name change for him (I don't blame him--I'm actually not entirely sure how to do this either!).\nI'll close this pull request, and in its place #79 will track changing that project's name to Nimble-CoreData.\n. Thanks, @broderboy! :+1: \n. Closing in favor of #88, which builds upon this PR to include test fixes. Thanks a ton, @mprudhom!! :+1: \n. Closing in favor of #88, which is issued from a branch on the main Nimble repository.\n. @jeffh Are we ready to push and tag this, with the general approach of expect{...} for asynchronous/exception expectations, and expect(...) for everything else?\nOnce we update Nimble, I'll update the Quick README wherever it uses the old syntax.\n. Thanks, @klaaspieter! I think that's a compelling idea. In the short term, it would mean greater migration costs from the Swift 1.1 branch. But it would be much simpler in the long term. So a tentative +1 from me, although I'd like to hear some other arguments as well.\n. @ssherar Are you using Swift 1.1 or prior? :point_up: :bulb:\nv0.4.0 of Nimble supports Swift 1.2--you'll need to build using Xcode 6.3 in order for it to work. If you'd like to use Swift 1.1 (available on Xcode 6.2 or prior), use v0.3.0.\nLet me know if that resolves your issue!\n. I think this looks great. I'll merge tonight unless any @Quick/contributors want to chime in. :cherry_blossom: \n. Thanks again, @rbeeger! :+1: \n. I played around with this concept in a custom matcher I'm writing, and came across an interesting problem: what if I want to make a negative assertion? For example:\nswift\nexpect(actual).to(raiseException(\n    name: equal(NSInternalInconsistencyException),\n    localizedDescription: doesNotMatch(\"wtf\")\n))\nThe doesNotMatch() matcher, of course, doesn't exist. Instead, Nimble allows users to write notTo.match(). Would it be worth trying to accomplish something similar here? Like a not() matcher that returns the negative of the given matcher?\nexpect(actual).to(not(equal(\"value\")))\nexpect(actualClosure).to(raiseException(\n    name: equal(NSInternalInconsistencyException),\n    localizedDescription: not(match(\"wtf\"))\n))\nI think the not() matcher is an interesting idea, but it may also be overkill. Maybe we should just focus on non-negative assertions here?\n. Yep, being able to match on code would be great, too! Thanks for the feedback, @mkauppila! :+1: \nMy biggest dilemma at the moment: what to call the matcher? Is there a better name than beAnError()?\n. > Out of curiosity, what is the difference between this and just matching against the properties?\nOh, good call! Now that you mention it, I think you're absolutely right, @jeffh. And I hate widening API surface area! :japanese_goblin: :zap:\nThanks for the insight!\n. Looks good to me, thanks @delasteve and @erudel! :+1: \n. Oomph, thanks for the heads up!\nNimble v0.4.0 can only be built using Xcode 6.3 and Swift 1.2. Are you sure your command-line tools are using Xcode 6.3's xcodebuild? :bulb: \n. @dfreniche Thanks for the heads up! This isn't a bug, though: Nimble v0.4.0 supports Swift 1.2 (included with the Xcode 6.3 betas). If you'd like to use Nimble with Swift 1.1 (included in Xcode 6.2), use v0.3.*. :+1: :sparkles: \n. Thanks for the report, @haifengkao! Which version of Nimble are you using? v0.4.0 supports Swift 1.2/Xcode 6.3, v0.3.0 supports Swift 1.1/Xcode 6.2.\n. @sasijp Sorry about that! I checked, and it looks like v0.4.0 didn't build on the latest Xcode 6.3\u03b23. Please use v0.4.1 instead.\n. Thanks anyway, @silkentrance! :tulip: \n. Looks like the CI is broken--Circle CI is reporting no tests? I assume it's not a failure I should be paying attention to, since last time I checked we have CI shut off for both Quick and Nimble's master branches... :sob: \n. I had a few suggestions, but...\n\nHow would you feel about branding this a v1.0? I'm thinking of tagging v1.0 of Quick once https://github.com/Quick/Quick/pull/287 is merged.\n. > I'll see if I can get it up and running on Nimble in the next few days.\nIf you're able to do this, I'd love to do the same for Quick.\n\n. @Quick/contributors This obviously won't pass CI, and probably won't for a while, until CIaaS companies like Travis CI and Circle CI support Xcode 7. \nJust as when we supported Swift 1.2, I suggest having master compatible with the latest toolchain. We can create a swift-1.2 branch for backwards compatibility. I'll add a commit to this branch that disables CI and points the README CI badge at the state of the swift-1.2 branch.\nThoughts? :raised_hands: \n. @fabiomassimo This confusion definitely occurred during the period of time we supported Swift 1.1 and Swift 1.2. At that time, we used a swift-1.1 branch. Tons of issues were opened by people who were confused by the fact that Quick \"didn't compile\".\nI'm open to new ideas this time. For context, here's our previous discussion on the subject: https://github.com/Quick/Quick/issues/243\n. @neilpa Looks like the issue is with tags containing dashes and hyphens, not branches. We'll be tagging versions using semantic versioning, which Carthage will certainly support, so no worries there! :+1: \n@jeffh We're probably going to want to tag a Swift 2.0-compatible release once we cut a swift-1.2 branch. The latest version of Nimble is v1.0.0-rc.1, which supports Swift 1.2. What should the Swift 2.0-compatible version be? There are no API changes, but the new code won't run on Xcode 6.*. Personally, I think it should be v2.0.0-rc.1 (although to be honest, I'm not a fan of rc releases). Thoughts? :8ball: \n. Closing in favor of #132. Let's continue this discussion there.\n(Boy, it sure would be nice if GitHub allowed you to edit the target of a pull request.)\n. Reviews of this on the original pull request seemed positive, so I'm merging this! Let's cut a tag tomorrow.\n. I'll be tagging the release off of the swift-2.0 branch v2.0.0-rc.1, as per https://twitter.com/jeffhui/status/608416725168738307.\n. Done! Someone who knows how should attach a prebuilt Carthage binary to the release.\n. I don't get it. Locally, the tag is pointing to fa73feeb156d8af7f47ae94dde07f1f7847bb1a3, which is the correct commit. Why does dc7c527de09228aaa231108e9e3e17f46cdb71ff also appear as if it's tagged with v2.0.0-rc.1 in the GitHub UI?\nhttps://github.com/Quick/Nimble/releases/tag/v2.0.0-rc.1 itself on the GitHub UI shows that it's pointing to fa73feeb156d8af7f47ae94dde07f1f7847bb1a3.\nPerhaps someone can reach out to GitHub for support? Locally, Git behaves as expected.\n. Thanks, @paulyoung! That'll probably be more effective than my 140 characters. :wink: \n. @paulyoung I believe that's explained by https://twitter.com/jspahrsummers/status/609547269533097984.\nIt's unfortunate that Carthage doesn't handle trailing characters, although not doing so makes a lot of sense to me. I'm actually not a fan of \"RC\" versions, but I figured a Swift 2.0-compatible version of Nimble v1.0.0-rc.1 should be v2.0.0-rc.1.\nIn any case, this seems like a non-issue from Nimble's point of view, so I'm closing this. Thanks anyway, @sync! :+1: \n. @yariksmirnov Great idea! Could you give an example of what you'd like to see?\n. This is something I'm very interested in accomplishing, both for Nimble and Quick. Thanks for the discussion, everyone! :heartbeat: \n\nSeparate the XCTest integration to a separate library. I rather have the Nimble project (or at least preserve the way people install Nimble) integrate with XCTest and separate out the \"core\" to a separate project.\n\nI believe https://github.com/Quick/Quick/pull/287 is along the lines of what @jeffh and @tjarratt are proposing here. I may be mistaken, but wouldn't users interested in XCTest integration have to import both Nimble.framework and NimbleCore.framework in this case? If not, I think this is a great direction to go in. Otherwise, I think the burden on current users is unfortunate, but it may be worth it in order to take these projects in a great new direction.\n\nUsing Weak Linking to refer to XCTest. This might require breaking some initialization / bootstrap work for Nimble. That is acceptable if it means XCTest can be optionally linked.\n\nIt looks like #146 is weak linking, right? I'll read through what's going on there, but could you explain what you mean by \"acceptable\", @jeffh?\n\nUse C-styled runtime magic to load/lookup the XCTest function at runtime. I'm not too thrilled about this option TBH.\n\nHonestly this option is out of my depth. Could you explain what this would look like, or link to some resources to learn more?\n. This is really cool! :+1: \nCode looks good to me, but I'll defer to @jeffh to merge. If this is the direction Nimble is taking, I'd love to explore whether Quick could also use weak linking.\n. Oops! Sorry, hadn't noticed that one.\n. Thanks, @phatblat! :100: \nHow about a pull request against Quick to bump its unit tests' Nimble dependency? :heart_eyes: \n. Gomega, a matcher library for Go, added support for this in https://github.com/onsi/gomega/pull/108.\n. Any thoughts, @jeffh? :raised_hands: \n. @jeffh Mind if I delete the swift-2.0 and swift-1.1 branches? I did so on https://github.com/Quick/Quick to prevent confusion when submitting pull requests--which I think may have happened on #192 and #193.\n. Ended up deleting the branches. Pretty sure you can restore them if necessary anyway.\n. @nikita-leonov master is indeed the branch you want! swift-2.0 was merged into master a week ago, in #187. I'll reopen your request against master, #192.\n. Oops, looks like I can't... :astonished:\n\n. Could you include a unit test in your PR that demonstrates the new, consistent syntax (i.e.: won't compile without this change)? That way we can ensure that this change doesn't regress in future releases.\n. Overall this seems like a reasonable change to me--I just had a few suggestions and nitpicks. I defer to @jeffh, in case he has any thoughts on whether this should be included.\nSorry again for closing this pull request! Please re-submit it against the master branch if you don't mind. Otherwise, once it's reviewed one of us can merge it manually into master.\n. Definitely agree! This changes the custom matcher interface, which means a major version bump for Nimble. Still, I think the improvement in autocompletion is well worth it.\n. > It might not even have to be a breaking change immediately. We could add the protocol extension layer and call the module functions from there.\nBrilliant! :100: \n. What about no backwards-compatibility and a major dot release? Just an idea, feel free to push back on it.\n. Well, I mean, whatever @jeffh thinks is a good idea. I'm just throwing it out there. Seems like we have to compromise on the API to be backwards-compatible, so what does it look like if we remove that constraint?\n. Based on the discussion in https://github.com/Quick/Nimble/issues/217, it looks like the overall approach was agreed upon. I think if the pull request were to be rebased we could all give it a review. :). > it might be good for one of the owners to itemize the requirements!\nI think @jeffh understands these best. No pressure \ud83d\ude0e\u26f1\ud83c\udf24. That sounds awesome! If you wanted, I'd be happy to add it as a project in Quick's GitHub organization, or you maintaining it as a totally separate thing, with as much or as little attribution as you'd like. :). A resounding \"yes!\" from me on making it an entirely new project under the org. Very excited to see this develop.\n\nAnyway. I'd recommend changing the tests to be more of how a test writer would use this API instead of using APIs marked internal. Developers will most likely look at these tests to see how to perform specific kinds of expectations.\n\nAbsolutely +1.\n. The failing jobs appear to be SwiftPM related. Here's the error from the SwiftPM jobs, on both macOS and Linux:\nCompiling Swift Module 'Nimble' (47 sources)\n/home/travis/build/Quick/Nimble/Sources/Nimble/CallRecorder.swift:290:24: error: value of type 'NSObject' has no member 'isKindOfClass'\n                return recordedArgAsObject.isKindOfClass(type)\n                       ^~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~\n<unknown>:0: error: build had 1 command failures\nerror: exit(1): /home/travis/.swiftenv/versions/DEVELOPMENT-SNAPSHOT-2016-02-25-a/usr/bin/swift-build-tool -f /home/travis/build/Quick/Nimble/.build/debug.yaml default\nI'm not sure if this version of Swift, DEVELOPMENT-SNAPSHOT-2016-02-25-a, defines NSObject.isKindOfClass(). We should probably update the Swift CI uses -- instead of a snapshot, we should use the official release of Swift 2.2.\nI'm not sure why the Xcode 8 job failed, the log appears to have been cut off... are we emitting too many logs? Maybe we should condense the output using xcpretty...? @sharplet, you added Xcode 8 to the build matrix, so maybe you know what might be going on here?\n. I believe it's true that Nimble doesn't provide this functionality. I think it would be very interesting to support this, but I'm not sure it's possible. The Swift stdlib's unit tests have a way to do this; perhaps we can borrow some concepts from there?\n. @morganchen12 was kind enough to point out that this is being discussed on the Swift mailing lists.\nThe mailing list discussion is rooted in XCTest, which is an interesting topic indeed. Nimble tries to limit its dependency on XCTest. Perhaps we could pioneer an approach and then submit an evolution proposal for it to be added to XCTest as well?\n. Just a quick note: I haven't had time to think about it in depth, but no matter how we incorporate fatalError testing, we should give attribution to @mattgallagher in some way. It looks like his code is going to have a heavy influence on the code we'll be including in Nimble either way. We should probably also reach out to @mattgallagher and make sure he's OK with whatever approach we end up taking--once we decide what that is.\n. @mattgallagher Great! I didn't have a specific question, just wanted to make sure once we decided on something we ran it past you. Glad to have your input!! Up for a code review once we have something operational? :wink: \n. Looks good to me! But I'll defer to @jeffh. :bow: \n. Oomph, yet another reason we need something like https://github.com/Quick/Quick/issues/238. Thanks for noticing!\n. Ah, life on the bleeding edge! I'm thankful we now get to see these changes propagate in apple/swift and apple/swift-corelibs-xctest before users encounter them on the latest Xcode beta. :innocent: \n. @briancroom Done! I added you to Quick and Nimble.\n. > I'm disappointed that nobody (including myself!) realized the ObjC bridging implications while discussing the StaticString change in the XCTest overlay previously. \nI feel this would've taken a great deal of foresight, from someone with a ton of context on StaticString, the SDK overlay, and  how the file parameter is used by third-party testing tools. There's hardly anyone with that much breadth of knowledge--although you're fast becoming that person! Don't let this one setback get you down, your work is much appreciated!! And thanks for commenting on https://github.com/apple/swift/pull/888. :100: \n. Awesome!! The message could be further improved by indicating that users may use any of to, toNot, toEventually, etc. I'd happily merge as-is, though.\n. :shipit: Thanks, @pcantrell!!\n. Heh, cute. :stuck_out_tongue: \n. Thanks, @mjbeauregard! \ud83d\udc4d \nI'd happily merge pull requests to add docblocks to the public symbols in AsyncDefaults, as well as to expand the documentation on methods like toEventually. Strikes me as a potential point of confusion for users, who shouldn't be expected to know how async matchers poll their expectations.\n. Oy, sorry for not reviewing this sooner. I think it looks great!!\nI initially wondered about the naming of the matchError(), but I guess it's named that in order to differentiate it from throwsError(). I think it'd be a good idea to document what this matcher does in the \"Swift Error Handling\" portion of the README. A blurb on the difference between this and the throwsError() matcher would also be nice.\n@jeffh, do you have any thoughts here? I plan on merging this soon, unless you have any additional feedback.\n. Breaking changes be damned, I'm merging this.\n\n. @phatblat Don't suppose I could trouble you to update the Nimble submodule in the Quick build...? :pray: \n. LGTM, thanks for the quick response! Normally I'd defer to @jeffh, but in the interest of unbreaking people's workflow I'll merge this now. If we ever think of a more elegant approach we can fix forward.\n. @paweldudek mind sending a PR to bump the Nimble submodule in Quick?\n. Thanks, @morganchen12!\n. I'd like to reiterate my thought that XCTest should export both APIs until Swift 3 is officially released: SR-1215. We're doing very little to make things smooth for early adopters of corelibs-xctest, I think we could do better in that respect.\n. Makes sense to me! Theoretically it's possible to have CI build the Swift 3 branch by compiling Swift from source, then passing SWIFT_EXEC to xcodebuild. That seems like overkill, though--should we just go without CI for Swift 3?\n. Thanks, @ashfurrow! Help with the podspec is very much appreciated! \ud83d\ude0d \n. All on the repo, and I'd like to keep it that way. Personal preference to be sure, but my arguments are:\n1. People with feedback of any kind can know exactly where they should go for help. No \"routing\" (i.e.: \"GitHub issues are for bugs, for usage questions, please post on Stack Overflow\"), which I think discourages people.\n2. Maintains a public record. Makes it easy to answer questions like \"why was this done this way?\" -- it's easy to send a link as an answer to many questions. (I really love detailed commit messages for this reason as well.)\nI am partial to arguments that some people find it easier to ask a quick question on Slack, and those people might hesitate to submit a GitHub issue. Still, I think the two benefits above outweigh those concerns. Instead, I've tried to make it clear we really welcome GitHub issues -- although more could be done, I'm sure. :)\n. +1 for not deleting the release notes. I would always git show $TAG in order to copy them back into my clipboard anyway.\n. I agree that a pod lib lint step in CI sounds great!\n. @priyapy Is the problem that autocomplete doesn't work? Or is it a build error?\nI think a specific compiler error would help here, or even a screenshot of the error you're seeing. Something like this:\nQuickFocused-iOSTests Group\n/Users/bgesiak/GitHub/modocache/Quick/Sources/QuickFocusedTests/FocusedTests.swift\n/Users/bgesiak/GitHub/modocache/Quick/Sources/QuickFocusedTests/FocusedTests.swift:1:8: No such module 'Quick'\nOr this:\n\nThanks!\n. @priyapy You mean \"No such module 'Quick'\"?\n. Sounds great!! Thanks for the speedy work, @sharplet and @ikesyo!\n. Let's do it! \ud83d\ude80\nOn Sat, Jun 18, 2016 at 4:14 PM -0400, \"Adam Sharp\" notifications@github.com wrote:\nOk, so everything is fine on CI for all platforms except iOS on Xcode 8. Everything is peachy on my machine. @Quick/contributors what do you say we go ahead and merge this then push a new release?\n\u2014\nYou are receiving this because you are on a team that was mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks, @ikesyo!\n. Thanks to @norio-nomura, we have a pull request open to support Swift 3! \u2764\ufe0f  https://github.com/Quick/Nimble/pull/277\nPlease checkout that pull request locally if you'd like to give it a try right away.\n. This sounds like a nice change to me! Thanks for the suggestion, @Ben-G. Would you be interested in sending a pull request to implement this?\nIt might be a good idea to add a source code comment to the implementation that links back to this issue -- I think this is an improvement, but some people might prefer more information, even if it is too long for Xcode to display.\n. Hello, @repl-ullas-ml! Great question. I agree that it's sometimes very useful to assert things like this. In Objective-C, I'd typically use OCMock to make such an assertion:\nobjc\nOCMVerify([mockObject someMethod:someParameters]);\nIt's not possible to do this for Swift objects that don't inherit from NSObject. For testing approaches in Swift, I'd instead recommend watching this video, by Jeff Hui: https://realm.io/news/testing-in-swift/.\nUsing the techniques from that video and OCMock, I think, provide all the functionality you'll need. As for your question of whether Nimble itself provides this functionality, the answer is \"no\". You could probably write a custom matcher for OCMock, such as the following:\nswift\nexpect(mockObject).to(receiveMessage(#selector(someMethod), withParameters:someParameters))\nBut I think that's actually less readable than using OCMock directly. OCMock is also a third-party dependency that not everyone uses, so we wouldn't include such a matcher in Nimble itself -- it belongs in a separate repository (which you're free to make, and I'd be happy to provide feedback on!).\nHope that answers your question! :)\n. It's also worth noting that Kiwi made the following possible:\nobjc\n[[myObject should] receive:@selector(someMethod)];\nThis is because Kiwi was both a testing framework (like Quick or Specta) and a mocking framework (like OCMock). Quick and Nimble do not couple these two things -- instead, they encourage users to use both Quick/Nimble and OCMock, as separate dependencies.\n. This is a most excellent bug report. Thank you!! \u2764\ufe0f \nI ran:\n$ sudo gem install cocoapods\n$ pod repo update\n$ cd Example\nExample $ pod install\nI then opened Example.xcworkspace to run the tests, and I also encountered the error you described:\n```\nThread 1Queue : com.apple.main-thread (serial)\n0  0x000000010798c108 in specialized _fatalErrorMessage(StaticString, StaticString, StaticString, UInt) -> () ()\n1  0x000000010783d308 in _arrayConditionalBridgeElements ([A]) -> [B]? ()\n2  0x000000010783bf67 in _arrayForceCast ([A]) -> [B] ()\n3  0x00000001111f99d9 in ExampleTests.(testExample() -> ()).(implicit closure #1) at /Users/bgesiak/Downloads/Example/ExampleTests/ExampleTests.swift:18\n4  0x00000001111f9a17 in thunk ()\n5  0x00000001111f9581 in partial apply for thunk ()\n6  0x000000011124cd27 in (memoizedClosure (() throws -> A) -> (Bool) throws -> A).(closure #1) at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Expression.swift:9\n7  0x000000011124bf5d in partial apply for (memoizedClosure (() throws -> A) -> (Bool) throws -> A).(closure #1) ()\n8  0x000000011124c6bf in Expression.evaluate() throws -> A? at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Expression.swift:84\n9  0x000000011124130d in (equal ([A?]) -> NonNilMatcherFunc<[A?]>).(closure #1) at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Matchers/Equal.swift:60\n10 0x000000011123c45c in partial apply for (equal ([A?]) -> NonNilMatcherFunc<[A?]>).(closure #1) ()\n11 0x0000000111254a58 in NonNilMatcherFunc.matches(Expression, failureMessage : FailureMessage) throws -> Bool at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Matchers/MatcherFunc.swift:47\n12 0x0000000111255373 in protocol witness for Matcher.matches(Expression, failureMessage : FailureMessage) throws -> Bool in conformance  NonNilMatcherFunc at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Matchers/MatcherFunc.swift:46\n13 0x0000000111249ad2 in expressionMatches (Expression, matcher : B, to : String, description : String?) -> (Bool, FailureMessage) at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Expectation.swift:8\n14 0x000000011124ad78 in Expectation.to (A1, description : String?) -> () at /Users/bgesiak/Downloads/Example/Pods/Nimble/Sources/Nimble/Expectation.swift:46\n15 0x00000001111f940f in ExampleTests.testExample() -> () at /Users/bgesiak/Downloads/Example/ExampleTests/ExampleTests.swift:18\n16 0x00000001111f95b2 in @objc ExampleTests.testExample() -> () ()\n17 0x000000010552b5cc in __invoking___ ()\n18 0x000000010552b41e in -[NSInvocation invoke] ()\n19 0x0000000110df9ef3 in __24-[XCTestCase invokeTest]_block_invoke_2 ()\n20 0x0000000110e2e613 in -[XCTestContext performInScope:] ()\n21 0x0000000110df9d78 in -[XCTestCase invokeTest] ()\n22 0x0000000110dfa3a2 in -[XCTestCase performTest:] ()\n23 0x0000000110df7cf7 in -[XCTestSuite performTest:] ()\n24 0x0000000110df7cf7 in -[XCTestSuite performTest:] ()\n25 0x0000000110df7cf7 in -[XCTestSuite performTest:] ()\n26 0x0000000110de4b10 in __25-[XCTestDriver _runSuite]_block_invoke ()\n27 0x0000000110e05b4c in -[XCTestObservationCenter _observeTestExecutionForBlock:] ()\n28 0x0000000110de4a55 in -[XCTestDriver _runSuite] ()\n29 0x0000000110de57d1 in -[XCTestDriver _checkForTestManager] ()\n30 0x0000000110e2fa9a in _XCTestMain ()\n31 0x00000001055682ec in CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK ()\n32 0x000000010555df75 in __CFRunLoopDoBlocks ()\n33 0x000000010555d6d2 in __CFRunLoopRun ()\n34 0x000000010555d0f8 in CFRunLoopRunSpecific ()\n35 0x0000000109d0cad2 in GSEventRunModal ()\n36 0x0000000105e6cf09 in UIApplicationMain ()\n37 0x000000010546d692 in main at /Users/bgesiak/Downloads/Example/Example/AppDelegate.swift:12\n38 0x0000000107eaa92d in start ()\n39 0x0000000107eaa92d in start ()\n```\n. Is there a workaround? Maybe try the following, and report back the results?\nswift\nexpect(array).to(haveCount(1))\nexpect(array).to(contain(item))\n. Oops, sorry @ikesyo! I just sent you a Twitter message about becoming a maintainer. I hadn't realized you'd already posted about it here. Sure thing, I'll add you!\n. > I'll add you!\nDone! Thanks a lot for your help, sorry it took so long. And thanks, of course, for the pull request! \u2764\ufe0f \n. I agree it's confusing. Perhaps this would be clearer as toEventuallyNot()? If you were to tell me \"I expect this counter to eventually not be greater than one\", I would interpret that as \"I expect this counter to eventually be less than or equal to one\". And if it was immediately less than or equal to one, I would tell you your condition has been met!\nAlso, thanks for the follow-up matcher in #323. I'll look at that now.\n. @Reflejo Thanks for this!! \ud83d\udcaf \nThe code looks good, and I like the concept, but I wonder if the name could be improved. Specifically, toAlways() doesn't imply asynchronicity to me. I imagine new users who aren't aware of Nimble's asynchronous test features would mistakenly try to use toAlways(). For example, if I have a function:\nswift\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\nI could see myself (mistakenly) writing expect(add(1, 2)).toAlways(beEqual(2, 1)). Or I might mistake it for a QuickCheck-style, \"property-based\" assertion: expect(add(n, m)).toAlways(beEqual(m, n)).\nIt would be nice, instead, if toAlways() was named something that made it very clear that it's intended to be used for asynchronous expectations.\nI don't have any brilliant ideas here, but maybe something like the following?\n- toContinueTo()\n- toContinuously()\n- toPerpetually()\nI'm not super attached to any of these names. Let's brainstorm!\n. Thanks for the report! Do you happen to know if it worked in your project using Xcode 8 beta 5 or earlier? I'm wondering whether this is an Xcode 8 beta 6 issue.\nHas anyone in @Quick/core tried to use Nimble in Xcode 8 beta 6?\n. Nice! Thanks!!\n. Wow, fantastic! Thanks, @ikesyo! I had one comment, but I'll merge this now and you can follow up later if you wish.\n. Hello! Hmm, sounds like a problem, but not one I've ever encountered. It's also not caught by our test suite. Could you submit a pull request to add a test to Nimble's test suite that demonstrates the failure you're seeing? Alternatively, could you create a small sample project that demonstrates the failure? That'd really help us solve this issue quickly! :)\n. Thanks @wongzigii!\n. Looks good to me, but I admit I'm not an expert here. :)\n. As @ikesyo pointed out, this seems like something that could be fixed by modifying Nimble's stringify function to handle NSProxy. I think adding an if let value = value as? NSProxy { ... } statement to handle this case should do the trick.\n@joeljfischer, would you be willing to submit a pull request for that case? Since you have a test suite that demonstrates the problem, I think you'd be able to quickly iterate on the solution.. Awesome, thanks for working on this! A few questions that could help me figure out what's going wrong here:\n\nYou mention an error -- are you referring to the crash this issue is in reference to?\nDo you mean that, without any modifications, turning off optimizations when building Nimble caused the crash to stop occurring? Or, if you made some modifications, could you post the diff here?. Hmm, that's definitely interesting. My understanding is that program behavior should never change due to optimization level, just the speed at which the program executes. Changes in behavior seem like a bug in the compiler or runtime.\n\nStill, since finding a workaround here is probably the first step to diagnosing any compiler bugs anyway, let's start there. If it were me, I'd switch back to an optimized build and try to find a workaround that prevents the crash from happening. I still think the NSProxy theory is a strong one, so I'd add the if statement I mention a few comments above and see what happens.. Yeah, I suppose a debugger won't work because it's optimized. I'd probably switch to print-based debugging at this point (a tool of the pros).. Does your stack use xctool or something like that? It looks like the test output is being piped through some sort of formatter. Does your stack have a --verbose option that can display the full, unadulterated output from the tests?. Wow, good catch!!. Thanks for the report, @sharplet! I assume this should be fixed in apple/swift, is that what you had in mind as well?. I wonder how many people use precondition testing? (It's times like this I wish we had analytics of some kind.) Could we simply remove it and bump Nimble's major version, at least for now?. It looks like there may not be cause to take it out anyway: https://github.com/mattgallagher/CwlPreconditionTesting/commit/e11db1661274909fb820a2bff57f4effb578bf9d. Nice catch, thank you!. Sounds good, feel free to merge :). I agree this could be improved, excellent suggestion.\n\nFor the cases in which the count is different, we could print that, and then which elements exists in one array but not the other.\nPretty-printing the arrays would also be nice.\nBeyond that, some more advanced diffing would be cool, too. I bet there's a lot of prior art out there, in other matcher frameworks and diffing programs.\n\n. Great, thank you @mrh-is!. Awesome, thank you @holmes!. This branch is executed if I pass in something that isn't an array, set, or string, correct? What does the failure message look like in this case? Does it make it clear to the user that it failed because of a type mismatch?\n. Should we share a Quick Twitter account? :laughing: I follow RSpec on Twitter, but I'm pretty sure we won't be as good about posting.\n@orta I seem to recall you telling me that social_media_url was part of some important metric on CocoaPods. Should all projects have one? If so, I wouldn't mind mine or @jeffh's account here. But if not then let's leave it out.\n. We now have a version v0.1.0, so this should be updated to that.\n. Just checking: are these deployment targets correct? 10.7 seems prehistoric.\n. Haha, I was hoping you could tell me! :laughing: \nHonestly, I've always been murky on the subject. From what I hear, Swift libraries can target iOS 7.0+ and OS X 10.9+, so I guess we should go with those?\nBut I'm pretty sure our CI only tests the latest, i.e.: 8.0 and 10.10--is that concerning? I don't want to promise support for targets that aren't tested.\nWe could just play it safe with 8.0 and 10.10, and update the podspec/CI if someone requests support for older targets.\n. Awesome, thanks!\n. Wow, I must have been extremely tired when I wrote this. Thanks for pointing this out! It turns out this was the cause of my troubles with waitUntil. :+1: \n. @jeffh may have more context; I actually wasn't aware of any difference!\n. I was following the convention used in Quick for it blocks. I have no strong preference either way. I suppose using nmb_ would cause NMB_, the prefix used for non-shorthand Nimble DSL, to autocomplete for these snake-case builders.\n. This is tangential to this pull request, but I recently created a matcher similar to this one: https://github.com/modocache/Guanaco/blob/18126c0c8ba9a7cb3cc5d43aec83c81047410ab6/Guanaco/HaveSucceeded.swift#L21-L49\nI also had to write several matcher functions in order to handle Matcher, BasicMatcher, and NonNilBasicMatcher. Architecturally, this seems like a shortcoming. Any thoughts on improvements here, @jeffh?\n. I take it you're not a fan of including the internal keyword, even if that's (currently) the default? That's cool, just wondering.\nTangentially, do you think it'd be worth it to use a single OSS Swift style guide across the repos in the Quick org? I could be convinced either way. I ask because there are a few discrepancies between Quick and Nimble:\n1. Quick always marks internal, never relying on that being the default access control.\n2. Quick uses /** */ for documentation, but Nimble uses ///.\nI don't have strong feelings about which of the two styles are better, I'd just prefer to be consistent.\n. I guess the point of both of these functions is to call matches or doesNotMatch, then check if any value has been set for the actualValue message. If none has been set, the functions set a default value. That right?\nA nitpick to be sure, but since I had to read the implementation to grok the point of the functions, I'd try:\n1. Rename these two functions to express the above intent\n2. Extract the shared logic into a function with an expressive name (on the condition that made the code easier to read)\n3. Add comments if the first two steps haven't cleared this up\nUp to you! :basketball: \n. Oh, haha, looks like the readability issue I commented on above already existed! I still stand by it, though. :sweat_smile: \n. :+1: for fewer matcher interfaces!\n. \n. Nitpick: This sentence is a little confusing. I interpreted this to mean: \"If your matcher takes other matchers as an argument, use ~~MatcherFunc~~ the Matcher protocol instead.\"\n. Same as above re: clarity of the documentation.\n. Same as above re: clarity of the documentation.\n. Was this a bug? :bug: \n. Awesome, I feel the same. First person to submit a PR to either of the CONTRIBUTING.md's with a link to the style guide we should use wins!\n. I believe this is meant to read \"expect this closure to raise an exception named...\", and thus the name of this parameter.\nIn any case, that's the current API. Changing it should be part of a separate pull request.\n. Ah, gotcha. Yeah, open an issue if you feel strongly about it and we'll deal with it separately. :snail: \n. nit: Add a space in between done: and (), as in done: () -> Void.\n. nit: Remove this extra whitespace.\n. nit: Typo, should be \"as it supports function covariance\".\nnit: Add a space in between // and This.\n. Nice catch! Let's fix this in another PR/commit.\n. Ha! Clever, I like it. \ud83d\ude04 \n. nit-pick: \"github releases\" should probably be \"GitHub release\" -- proper capitalization and pluralization.\n. This isn't defined on Linux? Maybe it's imported under a different name...? \ud83d\ude15 \n. If this is Swift 3, the new namings might make it look more like DispatchTimeInterval.nanoseconds(1). Although were we to use that, I guess we'd need to move the _runtime(_ObjC) check lower to the callsite...?\nAnyway, I'm not sure it's better to use DispatchTimeInterval.nanoseconds(1), just thought I'd point out there's an alternative to NSEC_PER_SEC in Swift 3, so there might be a different way to do this here.\n. Awesome! I didn't know about CDispatch, that's great!\n. Do we still need the runtime check?\n. Ah, gotcha. In that case, LGTM! Thanks!\n. Tiny nit-pick: Above you use NSNumber* (no space), here you use NSString * (space between type and pointer).\n. Awesome docs! \ud83d\ude0d \n. ",
    "ashfurrow": "Ah, yes it is. I didn't see that. Maybe we ought to close https://github.com/Quick/Quick/issues/84 then? \n. Really good catches \u2013 most of those are oversights. I'll address and push. \n. @jeffh Hey Jeff! I've been working with the CocoaPods people to get this resolved. We've already renamed the old Nimble spec to be called Nimble-CoreData, so this should be good to go. \n. Cool, this has been pushed to trunk with the following owners:\n- Ash Furrow <ash@ashfurrow.com>\n- Brian Gesiak <modocache@gmail.com>\n- Jeff Hui <jeff@jeffhui.net>\nAny one of us can manage this list. \n. Looks :tada: \n. :tada: \n. :+1:\n. Looks good to me. I would add another readme example and test for raising any exception (no name, etc specified) since it's not immediately obvious that that's a thing. \n. Looks good Brian!\n@fabiomassimo I think keeping this PR open until Swift 2 is out would be a good idea. For further updates (like Swift 2 beta 2), we can submit PRs into this branch. \nThat's just one idea \u2013 lots of different approaches. \n. I'm seeing something similar \u2013 initially thought it was related to #180, but this sounds like it could be it. I'm on a fast machine, Xcode 7, but sometimes specific tests take a number of seconds to pass. Adding a higher timeout would work, but I'd have to do that for every test :sweat_smile: \nThis is the code that fails:\nswift\nwaitUntil(timeout: 10) { (done) in\n    dispatch_async(dispatch_get_main_queue()) {\n        done()\n    }\n}\nLet me know if I can help or provide any more details. \n. Hey, no problem! Still having the issue \u2013 I'll try to update it and let you know. \n. Hard to reproduce reliably \u2013 mostly this occurs on CI. I've updated to 2.0.0 and hopefully we see it happen less :sweat_smile: \n. Still seeing this on the latest release. \n. Negativo. \n. I'll see what detail I can get you \u2013 probably later this week or next week. \n. The builds (example) are failing consistently on a single test, but only on Travis. Investigating now. \n. Alright, documenting this all, mostly for my own benefit.\nThe test itself looks like the following:\nswift\nkioskWaitUntil { done -> Void in\n    subject.updatedContentsSignal.take(1).subscribeCompleted {\n        done()\n    }\n}\n(kioskWaitUntil is the following.)\nswift\nfunc kioskWaitUntil(action: ((Any?...) -> Void) -> Void) {\n    waitUntil(timeout: 10, action: action)\n}\nThe updatedContentsSignal is a RACSignal instance (still haven't upgraded away from the ObjC interface :grimacing:). The property is computed with the following definition:\nswift\nvar updatedContentsSignal: RACSignal! {\n    return RACObserve(self, \"sortedSaleArtworks\").distinctUntilChanged().mapArrayLengthExistenceToBool().ignore(false).map { _ -> AnyObject! in NSDate() }\n}\nIt's a RACObserve of a (private) dynamic property called sortedSaleArtworks. We use a RAC operator distinctUntilChanged to ignore subsequence identical property values, and map the array into a bool which is true iff the array is not nil and contains at least one value. We ignore false, then map into NSDate() so that the caller subscribing to the signal gets the date/time that the content was updated. \nSo I think the issue is that sortedSaleArtworks isn't getting set to a non-empty array, so let's look at how that is set. sortedSaleArtworks is bound to a signal that maps saleArtworks to be sorted. So how does that property get set? It is bound to recurringListingsRequestSignal(). \nThis is a recurring signal that starts immediately and maps to a sequence of network requests, which are stubbed. The logic here is complex, and if something is putting too much on the main thread, it's likely here. \nI'll keep investigating. \n. In the course of https://github.com/artsy/eidolon/pull/539 I found that our test subject was outliving its intended lifetime and continuing to enqueue things onto the main thread. I've removed it but things are still failing; I suspect there may be something else in our code that's the problem. Continuing to investigate. \n. Thanks for the kind advice \u2013 appreciated! :cake:\n. Oh my \u2013 the print yielded 157 lines of description :see_no_evil: Looks like I know where to start. Thanks again Jeff!\n. OK, will do. I should have commented here earlier that I've not seen the problem in some time \u2013 your suggestions helped me identify some runaway timers. \n. I'm seeing problems too, with test cases similar to this. The failures are intermittent, but I've reproduced them with the following test:\nswift\nwaitUntil { (done) -> Void in\n    done()\n}\nBased on the other thread, it seems like calling done() before the closure returns is not supported behaviour. @jeffh could you confirm? \n. Fab, thanks!\n. I'm only somewhat familiar with the Nimble codebase, but everything here makes sense to me :ok_hand: \n. Agreed dispatch_async isn't usually the best, but I think it works in this case. \nI've run this locally and verified it works \u2013 thanks @paweldudek for such a quick turnaround on this :bow: I'm going to defer to @jeffh on merging.\n. Sounds like this was fixed in #278, are we okay to close?\n. Fab!\n. If Travis is difficult with OS X builds, I think removing them and keeping Linux for now would be a reasonable compromise. \n. Looks good to merge! (modulo comments)\n. Looks great :+1: Gonna leave it up to @briancroom to hit the 'merge' button.\n. Hey, I was having the same issue and I've opened a pull request on Nimble to fix it: https://github.com/Quick/Nimble/pull/283\nIn the meantime, you can use my fix immediately by using this in your podfile:\nrb\npod 'Nimble', :git => 'https://github.com/ashfurrow/Nimble.git', :branch => 'podspec-update'\n. This was initially red from an intermittent CI failure, but is green now. \n. Happy to help! We ought to consider making a 4.0.1 release so others experiencing the build issue can fix it just by running pod update Quick instead of editing their Podfile. Is there a slack or anywhere where these sorts of decisions are discussed, or is it all on the repo (which I think is awesome too)?\n. Awesome, I am onboard with this idea for all of the reasons you listed \ud83d\udc4d \nSo I'd like to propose we release v4.0.1 \u2013 I'm happy to take this on, it looks like @briancroom has done it before so maybe it makes sense to get his opinion/help. \n. Super-cool! I'll try it out and let you know if I run into issues. Thought it looks like the podspec version does get updated, unless I'm reading this wrong: https://github.com/Quick/Nimble/blob/b6483301d3d76d494cec81acbb599183316d42a0/script/release#L153 \n. Ok, cool! 4.0.1 is up! I'll announce and update Quick as per the contributing guidelines. There are a few inconsistencies in the guidelines and release script that I'll address in a pull request, as well as a few ideas I have to make this easier (like printing out the contents of the release notes oil before it gets deleted, and automatically opening https://github.com/Quick/Nimble/releases/new?tag=$VERSION_TAG in a browser for you). \n. I suppose it depends on why it is being deleted at all, I would prefer not to but there might be a good reason to. Then again, that reason might not make sense now, even if it did before. \n. Ok, I'll make those changes and amend. Thanks! \n. Alrighty, I've got the changes up in some amended commits. \n. This is a good idea \u2013 I'm personally in favour of moving it to CI to catch problems earlier. \n. OK, cool. One more question: there are a lot of references to Carthage in the script that have been all commented out, should they just be removed? It looks like they were for attaching binary releases to GitHub, which we don't do anymore. \nThe Quick release script does still produce the binaries, but they haven't been uploaded since October. Should we remove the references from the Quick release script and docs, too?\n. OK, I'll remove.\n. Cool, changes made and CI is \ud83c\udf4f I think this PR is ready for final review.\n. Well that didn't go as planned. \n\nThe error seems to be from Ruby itself, which is segfaulting. It shouldn't do that \u2013 even with invalid Ruby code the runtime shouldn't segfault, as far as I understand it. Going to ask some smarter people and see what they think. Crash log is available.\n. I wasn't able to reproduce this crash locally, but I'm running system Ruby and Travis is running RVM with a slightly different version number. I saw others were having a similar issue with the json gem that appears to be causing the segfault, and a common solution is to change Ruby versions. I've tried specifying in the Travis config 2.2 instead of 2.0, we'll see. \n. Moving this to a work-in-progress while I try some things with CI. \nLooking at this with fresh eyes, I see that originally it was the json gem segfaulting, but when I try to do a gem install json, it's psych that is segfaulting. This leads me to wonder if the problem is running Ruby in general, since otherwise we don't do it on CI. I think this is a possibility given the problems that Travis has had with running Ruby code on OS X machines (and we're using a \"general\" machine with os: ox, might be an edge case). Looking into it...\n. Agreed using Bundler is preferable to avoid problems like this :+1: It also makes using specific versions (and beta versions) of CocoaPods a breeze. \n. Whoa, got it to work with sudo. Gonna try something less drastic.\n. Hmm. I'm more and more suspicious that this is a problem on Travis' end caused by an edge case of language: generic and os: osx. In fact, Travis specifies this in their documentation:\n\nNot all tools may be available on OS X.\n\nI think it's not unlikely that this generic/osx combo wasn't tested to make sure gems like CocoaPods can run (since my puts \"hi\" test worked).\n. This is working for the push check, but not the pr check. Not sure why. In any case, I'm moving this to another pull request that has these squashed (I want to leave the commits as a record in case they help someone else).\n. Reopening to test something.\n. Ha, so updating to the latest-and-greatest json gem somehow causes bundle install to segfault on psych? Dunno how that works. Still playing around to see if I can get this without requiring sudo.\n. Well, it wasn't meant to be. \n. Agreed, surprised me too. Can you take a look at #288 when you have a moment? It follows your advice on using bundler.\n. Cool!\n. Strange that it failed only on merge. Could be a Travis thing involving changes to its config file? I'm willing to bet if we merged it, master would be fine, and if it does fail, we could revert. Open to suggestions. \n. Can't win them all \ud83d\ude04 \n. The code and tests make sense to me, I'm happy to merge but I'm afraid I don't have the context/history for the feature, so is like a second opinion. \n. Makes sense, happy to test on Eidolon to make sure it works in production. I can get to it this week. \n. Thanks @morganchen12 for the thorough follow-up! I agree the effects of the change aren't fantastic, outside of the added feature of course. It goes a little bit against the principle of least surprise \u2013 I'm curious if you could tell us what sort of compiler errors you were getting that led you to the fixes for Eidolon? Do you think a user would be able to figure out what to unwrap based on the errors? If it's clear what to do, then I don't have a problem introducing a little friction for a nil literal matcher.\n. Makes sense to me, adding a compiler warning is a good idea to prevent this from happening again! \nSide note: I can't believe it's 2016 and computers still can't just do this for us \ud83e\udd14\n. Hmm, puzzling. I've not seen that before. Have you made any progress on this? Since expect uses autoclosures, I would typically write this as\nswift\nexpect(delegate.wasDidUpdateTimeSlotsCalled).toEventually( beTrue() )\nBut I doubt that has any effect on the outcome. \n. Makes sense to me! Nice tests. \n. Fab!\n. Switch structs are value types, and (at first glance) not compatible with beIdenticalTo because they're value types. Consider:\n``` swift\nvar a = ActorIdentity(PINCode: \"1234\", identityToken: \"ABCD\")\nvar b = a\n// a and b are now two different values, even if they hold the same struct fields.\na === b // compiler error, because they're two different types.\nb.PINCode = \"0000\"\n// It's now more clear that a and b are not identical, but they never were.\n```\nIf you're looking for equality comparison, you can create an == operator for your struct and use expect(identity).to( equal(identity) ). Does that answer your question?\n. I agree, documentation could definitely be improved. There used to be a note in the Readme about this matcher only working on Objective-C-compatible objects, but was removed with Swift 2. I think adding back in a comment about the matcher only working with classes would be great. Would you be able to send a PR? The Readme would be the place to put it, maybe elsewhere if you think it would be helpful? \n. Fixed in #299.\n. Thanks a lot!\n. Seems reasonable, I can't think of any adverse effects. \n. Super, thanks @akashivskyy!\n. It all counts :wink:\n. Hmm, interesting. You say the problem is you can't access Quick or Nimble? Could you post an example test file that's presenting the problem? Is there a compiler or other error you can provide? \n. Fab!\n. Looks good, I'll take care of it \ud83d\udc4d \n. Done: https://github.com/Quick/Nimble/releases/tag/v4.1.0 Also: https://twitter.com/ashcommits/status/744301119728394244\n. Thanks for the question \u2013 could you clarify the problem with the issue navigator? Right now, this wording is consistent with other matchers (ex: \"expected true to be false\", \"expected [] to not be empty\", etc). Do you reckon there's  a way we can improve the message and the experience of quickly understanding the test failure without breaking the existing behaviour?\n. That makes sense, thanks for the clarification. I'm not sure how to proceed, I think it's worth getting input from @Quick/contributors. \n. \n. It's tricky to prove something is false \u2013 there are entire wikipedia articles on the subject, and unfortunately, this case is no exception. The code you will work, but will also add five seconds to every test run, which isn't great. I've looked through my code to find an example I could show you, but nothing strikes me as applicable to your case. I'd recommend considering a small restructure to your code: maybe the block is always called with a success: Bool parameter, or something similar. Good luck!\n. The compromise of moving details to the end sounds good to me, \ud83d\udc4d \n. @Ben-G what does the message look like, in terms of poor formatting? \n. That's a tricky one, a bit outside my wheelhouse I'm afraid. \n. Looks \ud83d\udc4d to me. \n. Looks like CI is all green except on one test, involving async timeouts. I've restarted the build, hopefully it'll be \ud83c\udf4f this time :) . Hey @ikesyo I meant to response earlier to this, apologies. I've added you as an owner to the library in CocoaPods trunk. Would you like to do the honours and push 7.0.2?. Hmm, pretty big diff. Would you mind giving a high-level description of what changed? Just curious what the issue was.\nI trust your judgement, plus we've had @Blackjacx test, so I'm good to merge \ud83d\udc4d. Looks good to me \ud83d\udc4d. @Quick/core This looks good to go, pretty small, additive change. Any objections to merging?. My apologies \u2013 I must have been confused. So #531 was merged but has not yet been released?. Thanks!. It's still there when you run pod init, so I'll keep it for now. \n. :beers: will do\n. I just copied them from ... gosh I can't remember where. What are the officially supported versions? 10.9 I suspect? \n. I like this. \n. Shouldn't the parameter name internal to the function be called name? \n. Ah, you're right. I was suggesting keeping the interface the same but renaming the local parameter to \"name\" instead of \"named\" \u2013 does that make sense? Totally up for a separate PR. \n. Is this invocation of waitUntil meant to be part of this test case?\n. reference line?\n. :+1: for documentation :tada: \n. Looks good! Do you think it makes sense to have \"beIdenticalTo\" as \"beIdenticalTo\"?\n. Seems like the kind of line we should document?. ",
    "akashivskyy": "How is this different from #20 and why are they both open?\n. Been a pleasure to contribute even at such a small scale \ud83d\ude04 \n. @wongzigii What's the status of this PR? Do you need anything else from me? \ud83d\ude0a . ",
    "bendjones": "Opps. Didn\u2019t see #20 https://github.com/Quick/Nimble/pull/20. I submitted fixes for Nimble and Quick at the same time.\n\nOn Aug 20, 2014, at 12:52 PM, Adrian Kashivskyy notifications@github.com wrote:\nHow is this different from #20 https://github.com/Quick/Nimble/pull/20 and why are they both open?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/Quick/Nimble/pull/21#issuecomment-52834094.\n. \n",
    "paulyoung": "When considering test frameworks I've always thought it a plus when the default stuff was used under the hood.\n. I can confirm that self.expectationWithDescription and self.waitForExpectationsWithTimeout is required to use those methods inside of a QuickSpec.\n. I would expect it not to.\n. Sorry @jeffh :cat:  - I took a look at this the other day and was meaning to dig in a bit more but never got chance.\n. I don't know much about Nimble yet but this all looks good too me.\n. It also looks like bacon \u2248 :+1: \n. Looks pretty good to me :star2: \n. I'll email GitHub support on this one.\n. @jspahrsummers thanks for clearing that up!\n\nWhy does dc7c527 also appear as if it's tagged with v2.0.0-rc.1 in the GitHub UI?\n\nCan you offer any insight on that? I think that only added to the confusion here.\n. ",
    "tonyxiao": "any updates 2 years later? :)\n. @modocache not specifically. I liked the fact that XCTestExpectation seems explicit about promises being fulfilled whereas expect(...).toEventually(...) repeatedly checks value until expectation satisfies. Not sure how much difference that actually makes in every day usage. \n. Got it. Thank you for the clarification!\n. What about performance testing btw? Does Quick have something equivalent to measureBlock?\n. ",
    "xcthulhu": "I'm on 10.9.4, on Xcode 6.1b2, I have exactly this same problem.\n. (btw, this appears to be fixed in https://github.com/nerdyc/Nimble/tree/xcode61-beta2 , although I suppose it's up to nerdyc to make a pull request)\n. ",
    "rbeeger": "I wasn't aware that there is a swift variant of Hamcrest. I took a look at the sameInstance-matcher and if I'm not missing something then replacing all occurrences of \"NSObject\" with \"AnyObject\" and reimplementing _identityAsString like this\nswift\nfunc _identityAsString(value: AnyObject?) -> String {\n    if value == nil {\n        return \"nil\"\n    }\n    return NSString(format: \"<%p>\", unsafeBitCast(value!,Int.self))\n}\nseems to fix the problem. Will take another look at it tomorrow and provide a pull request if no one else is faster with this or points out some problem with it.\n. OK, I created a pull request with this. I could not test it on OS X as I don't have a system running 10.10, though.\n. OK, I created a new XCTestCase that does all the tests of the original BeIdenticalToTest with objects.\n. OK, I get it now. So the problem is that the operators return Bool and the implicit return tries to return that Bool where only Void is expected.\nI think it's unnecessary for the Nimble operators to return Bool. As Expectation is neither Equatable nor Comparable we don't override the Comparison operators. We define new ones that look like them.\nI created a new pull request for this, but since my earlier pull request for beIdenticalTo was on master, this new one inherited the commits from it. That should teach me not to create pull requests on master ;)\n. I didn't know either. I played around with it and it worked. Afterwards it feels reasonable that it works. I hope it stays that way with future updates to Swift.\n. I'm not a fan of that either, but I prefer it to having a test suite that stays red for a longer time. That way you won't notice when a new tests starts breaking or when it starts breaking in a new way after a new contribution.\nI agree that in the end there should be a better way to do it without the hack. Having to create this optional matcher each time looks tiresome, though. What if we change the base of Nimble in a way that all actual and expected values are optional and can be nil? You would always create a MatcherFunc<S>,  but Expression and all other dependent parts would take and return S? .\n. OK, I removed the textual stripping of Optional, and pushed the fact, that we get optionals in expectations into expect() and Expression. Now all Nimble-iOS-Tests work here.\nI still cannot test it on Yosemite and XCode 6.1 and I also don't know if I haven't somehow broken it for Objective-C tests. It looks good here, though \ud83d\ude04\n. OK, thanks.\nBTW: You could close https://github.com/Quick/Nimble/issues/22 now. \n. This was implemented in https://github.com/Quick/Nimble/pull/95 and can be closed.\n. I think creating a custom AssertionHandler won't help here. If I get this right, an AssertionHandler only decides how or if a failure is displayed or passed to XCTest, but it cannot prevent the evaluation of any other expectations after a failed one.\nThe behavior asked for in this request would immediately break out of the current it and resume execution on the next it, context or whatever comes next.\nThe only way for an AssertionHandler to do this would be to throw an exception, but then https://github.com/Quick/Quick/blob/master/Quick/Example.swift#L68 would need to somehow handle it. Otherwise it would break the whole test run.\n. I tried to reproduce this without any success.\nI used:\n- XCode 6.1.1 (6A2008a) with Nimble's swift-1.1 branch\n- XCode 6.3 (6D250o) with Nimble's master branch\nDoes this bug still occur for you @jspahrsummers or has it disappeared because of updates to XCode or Nimble in the meantime?\n. NSFastEnumeration doesn't work in swift's for in. It only works in the ObjC for in. But here http://stackoverflow.com/questions/25788290/nsfastenumeration-in-swift someone mentioned NSFastGenerator which allows to handle all NSFastEnumerations quite well. It works for the tests I have written for it. I've added a new commit with this change to this pull request.\n. Oops, while changing to NSFastEnumeration, I removed rejecting objects it cannot handle. And the error message also looked wrong. \n. I fixed the handling of nil epected values.\nThe other one is harder. Each attempt at allowing matching nils in collections I made failed. We have two layers of generics here. One is in the allPass matcher and the other in the used matcher.\nCurrently the passed collection cannot have an optional generator element type. Passing '[1,2,3,4] as [Int?]' in any of the tests of the allPass matcher breaks it. I haven't found the correct generic types constellation that would make it work.\nThe problem is in getting the optional from the test through allPass into the used matcher without having it wrapped in yet another optional.\n. I investigated sequences of optional values as expected values a bit further and still haven't found a solution that works well.\nI can change the element type of the sequence to T? like in \nswift\npublic func allPass<T,U where U: SequenceType, U.Generator.Element == T?>\n    (matcher: NonNilMatcherFunc<T>) -> NonNilMatcherFunc<U> {\n        return createAllPassMatcher() {matcher.matches($0, failureMessage: $1)}\n}\nOf course I need to change createAllPassMatcherso that it accepts T?. No problem here. But then I can still not check that all elements of a sequence are nil, So I need to duplicate the allPass function to work for MatcherFunc. Also no problem.\nError messages now contain Optional<whatever> in the listing of the sequence contents. That can be handled by stringifying all elements locally.\nBut now we get to the part that doesn't work anymore \nswift\nexpect(Set([1,2,3,4])).to(allPass(beLessThan(5)))\nThat's because we now need a sequence of Int? as the actual value. Int? is not Hashable and you can only create Sets of Hashables.\nI cannot duplicate the functions with Tand T? as sequence element types, because that crashes the Swift compiler. I could provide specific functions for Sets, but that would still break with other sequence types that have similar requirements.\nBTW: If we were to have those sequences of optional values, we would need to wrap the usage of NonNilMatcherFunclike this\nswift\npublic func allPass<T,U where U: SequenceType, U.Generator.Element == T>\n    (matcher: NonNilMatcherFunc<T>) -> NonNilMatcherFunc<U> {\n        let wrapper = NonNilMatcherWrapper(NonNilBasicMatcherWrapper(matcher))\n        return createAllPassMatcher() {wrapper.matches($0, failureMessage: $1)}\n}\nbecause some of them like beLessThanwill always tell you that nil is less than anything else. Only the wrapper rejects nils. That's a nonissue now as there cannot be any nil elements in the actual value.\n. The biggest problem is that NonNilBasicMatcher and BasicMatcher don't share a common super protocol. So you have to implement anything for both if you want to support both. In Swift 1.2 as now also works for protocols. So maybe there would be some way to provide such a common protocol and factor the specific handling with wrappers out of Expectation. I'll probably give it a try one of these days.\nAnyways, always interesting to work on Nimble.\n. Unfortunately replacing the usage of NonNilMatcherwith NonNilBasicMatcher currently doesn't work. In AllPass.swift I changed the function dealing with the sub matcher like this\nswift\npublic func allPass<T,U,V where U: SequenceType, V: NonNilBasicMatcher, U.Generator.Element == T, V.ValueType == T>\n    (matcher: V) -> NonNilMatcherFunc<U> {\n        let wrapper = NonNilMatcherWrapper(NonNilBasicMatcherWrapper(matcher))\n        return createAllPassMatcher() {wrapper.matches($0, failureMessage: $1)}\n}\nThe static code analyzer seems to like it and compiling Nimble also seems to work, but the compiler crashes with a segmentation fault while compiling AllPassTest.swift for testing.\nHopefully XCode 6.3 beta 3 will be better at it. \n. OK, I found the problem. Tin my last comment wasn't used in the method itself. It was only needed to connect the sequence and the matcher. Removing Tand establishing a direct connetion U.Generator.Element == V.ValueTypefixed the problem.\n. I added support for Matcherand BasicMatchersub matchers, but that still doesn't enable you to check whether all elements of a collection are nil.\nAt first sight allPass behaves strangely when used with collections of optionals like [Int?]\nThe tests testAllPassCollectionsWithOptionalsDontWorkand testAllPassCollectionsWithOptionalsUnwrappingOneOptionalLayer show this strange behavior:\nhttps://github.com/rbeeger/Nimble/blob/allPassMatcher/NimbleTests/Matchers/AllPassTest.swift#L38-L55\nThe problem is that we loose the information about having a collection of optionals here https://github.com/rbeeger/Nimble/blob/allPassMatcher/Nimble/Matchers/AllPass.swift#L34 and end up with optionals that are again wrapped. So instead of nilwe get `\u00d2ptional(nil)`` which isn't nil.\nAs the second of the two tests shows, this special Optional layer can be removed in the variant that takes a simple function by force unwrapping the element to be tested.\n. @jeffh All the checked in tests also pass here. I wouldn't commit red tests \ud83d\ude00 . \nIn the first one two statements are wrapped in failsWithErrorMessage. If it worked the way I would like it to, those statements should run without failing, without the wrapper.\nThe second test shows how you can work around the current strange behavior.\nThe current situation is the best I can come up with for this matcher at this time. The two tests are just a warning to those using it. It shows that I am aware of this not fully satisfying situation with collections of optionals.\n. @jeffh I'm wondering if there is some serious problem with this pull request that keeps it from being merged and if there is something I could do to fix it.\nIt's not perfect, but the best I could come up with. And its little quirks don't look overly problematic to me.\n. This can be closed as it was implemented in https://github.com/Quick/Nimble/pull/99\n. Forgot to mention: The ObjC variant uses three new properties withName, withReason and withUserInfo to allow setting matchers instead of values. So for ObjC you either use the with-Variant for matchers or the one without \"with\" for the old value-based one. Mixing doesn't work. \n. That's because Swift is missing the necessary reflection features to find out if a Swift object is a member of a Swift class.\nYou can use \nswift\nexpect(authentication as? Authentication).toNot(beNil())\nbut unless you have some more compilicated class hierarchy XCode will tell you that authentication as? Authentication is an unnecessary cast.\nWhile you can write such tests in your code you cannot do it on the meta level where the matchers are implemented. So beInstanceOfand beAKindOfonly work with NSObjects because you can ask those whether they belong to a class or not.\nThis is actually not a problem of to() and toEventually() but an issue with the used matchers. \n. A situation where testing for membership to a class or conformance to a protocol can be useful is when you write a test for a factory that creates instances of different classes based on which parameters it is given.\nIn that case you know that the factory returns MyGenericProduct, but you want to test that it returns a MySpecializedProduct if you pass it some specific value as a parameter.\n. @tobinharris I don't know your exact situation here, but using a class for each authentication state looks a bit overly complicated. \nUsing an enum seems like a natural fit here. If you need different behaviors in the authentication state you can write methods that switch over the enum itself and even more complicated situations can be implemented with associated values. So if you wanted to know what user name was used for the authentication you could specify it with one. \nEnums are way more powerful in Swift than they ever were in Objective-C.\n. The error message is missleading in this case. It catches the most common case in which people try to use beAnInstanceOf on Swift types. Both beKindOf and beAnInstanceOf only work with Objective-C classes. You are trying to use it with a protocol.\nAs of now there is no matcher in Nimble that can be used to test protocol conformance.\nYou can work around this be directly calling conformsToProcollike in \nswift\nexpect(generated.conformsToProtocol(DataSource.self)) == true\n. Unfortunately there are two situations at which the collection becomes unusable:\n- it contains at least one object that isn't a NSObject (line 58)\n- the collection isn't a NSFastEnumeration\nInlining would double the same code.\nIt could be moved into a closure that would be called at both places, but that would add a variable for the closure and would make the whole thing more confusing.\n. ",
    "nerdyc": "Well crap. I cleaned my build folder and re-ran, and for some reason the tests are failing again, due to the wrong failure messages being generated.\nAny thoughts on how to replace the following, which is no loner valid in Swift 1.1?\nswift\nextension Optional: Printable {\n    public var description: String {\n        switch self {\n        case let .Some(value):\n            return toString(value)\n        default: return \"nil\"\n        }\n    }\n}\nWhat I've written (and seen pass at least a couple times on OS X and iOS) is:\n``` swift\nfunc stringify(value: T) -> String {\n    if value is Double {\n        return NSString(format: \"%.4f\", (value as Double))\n    }\n    return toString(value)\n}\nfunc stringify(value: T?) -> String {\n    switch value {\n    case let .Some(realValue):\n        return stringify(realValue)\n    default: return \"nil\"\n    }\n}\n```\n. I tried that, but the optional check will always succeed.\nThe code I wrote works fine in a playground. I'll try again tonight to see if I can reproduce the issue. I have a hunch that it's a compiler issue, perhaps combined with code elsewhere in Nimble.\n\nOn Sep 22, 2014, at 13:26, Jeff Hui notifications@github.com wrote:\n@nerdyc, is there a way to check for optionality like Double is done? I'm thinking something like:\nfunc stringify(value: T?) -> String {\n    if value is Optional && value == nil {\n        return \"nil\"\n    }\n    if value is Double {\n        return NSString(format: \"%.4f\", (value as Double))\n    }\n    return toString(value)\n}\nI don't have Yosemite installed, so I can't verify any of that. Also, I'm guessing the above code probably doesn't work?\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "JoshuaKaden": "+1\n. ",
    "rhoegg": "Thanks @jeffh.  I pulled the latest (latest commit e4cc93c054cdbaa8d343d0b14f38fe5bd75bfa2f) and Nimble still appears in red in XCode.  I went into Report Navigator and did not observe any errors, and my spec runs and passes: \nswift\nclass ExampleSpec: QuickSpec {\n    override func spec() {\n        describe(\"Nimble should work\") {\n            it(\"should let me assert some things\") {\n                expect(\"something simple\").to(equal(\"something simple\"))\n            }\n        }\n    }\n}\nI'm rather new to XCode and swift but would be happy to help figure this out.  Where can I look to find the real error?\n. ",
    "arvindraghavan": "\nI have XCTest imported in one of my existing XCT-basd test cases. Note that when I install Nimble & Quick, without any new Quick-based tests added the tests stop running to completion. I have the same problem and output when I add a Quick-based test case, and import XCTest (not sure why XCTest needs to be imported when I\u2019m using Quick/Nimble??) Here is the output I see in addition to the error message I had in my original description:\nthread #1: tid = 0xeb88f, 0x318e1518 libsystem_kernel.dylib`mach_msg_trap + 20, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\nframe #0: 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20\n    frame #1: 0x318e1310 libsystem_kernel.dylibmach_msg + 40\n    frame #2: 0x23c32dca CoreFoundation__CFRunLoopServiceMachPort + 146\n    frame #3: 0x23c31390 CoreFoundation__CFRunLoopRun + 1016\n    frame #4: 0x23b7edb0 CoreFoundationCFRunLoopRunSpecific + 476\n    frame #5: 0x23b7ebc2 CoreFoundationCFRunLoopRunInMode + 106\n    frame #6: 0x2aee2050 GraphicsServicesGSEventRunModal + 136\n    frame #7: 0x27149f00 UIKitUIApplicationMain + 1440\n    frame #8: 0x00159570 BatteryPacktop_level_code + 72 at AppDelegate.swift:21\n    frame #9: 0x001595ac BatteryPackmain + 48 at AppDelegate.swift:0\n\nthread #2: tid = 0xeb8a0, 0x318e12c8 libsystem_kernel.dylibkevent64 + 24, queue = 'com.apple.libdispatch-manager'\n    frame #0: 0x318e12c8 libsystem_kernel.dylibkevent64 + 24\n    frame #1: 0x31803ec8 libdispatch.dylib_dispatch_mgr_invoke + 280\n    frame #2: 0x31803bfa libdispatch.dylib_dispatch_mgr_thread$VARIANT$mp + 38\nthread #6: tid = 0xeb8bc, 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20, name = 'com.apple.NSURLConnectionLoader'\n    frame #0: 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20\n    frame #1: 0x318e1310 libsystem_kernel.dylibmach_msg + 40\n    frame #2: 0x23c32dca CoreFoundation**CFRunLoopServiceMachPort + 146\n    frame #3: 0x23c31390 CoreFoundation__CFRunLoopRun + 1016\n    frame #4: 0x23b7edb0 CoreFoundationCFRunLoopRunSpecific + 476\n    frame #5: 0x23b7ebc2 CoreFoundationCFRunLoopRunInMode + 106\n    frame #6: 0x237371fe CFNetwork+[NSURLConnection(Loader) _resourceLoadLoop:] + 486\n    frame #7: 0x2497b1ba Foundation__NSThread__main** + 1118\n    frame #8: 0x31973e66 libsystem_pthread.dylib_pthread_body + 138\n    frame #9: 0x31973dda libsystem_pthread.dylib`_pthread_start + 118\nthread #8: tid = 0xeb8c0, 0x318f508c libsystem_kernel.dylib__select + 20, name = 'com.apple.CFSocket.private'\n    frame #0: 0x318f508c libsystem_kernel.dylib__select + 20\n    frame #1: 0x23c37552 CoreFoundation__CFSocketManager + 490\n    frame #2: 0x31973e66 libsystem_pthread.dylib_pthread_body + 138\n    frame #3: 0x31973dda libsystem_pthread.dylib`_pthread_start + 118\nthread #10: tid = 0xeb94f, 0x318f59cc libsystem_kernel.dylib__workq_kernreturn + 8\n    frame #0: 0x318f59cc libsystem_kernel.dylib__workq_kernreturn + 8\n    frame #1: 0x31971ea0 libsystem_pthread.dylib`_pthread_wqthread + 792\n*** Canceling tests due to timeout in Waiting for test process to check in... If you believe this error represents a bug, please attach the log file at /var/folders/ty/1k36_68s0zg7kg24qvv_1gp00000gn/T/com.apple.dt.XCTest-status/Session-2014-10-02_13:37:55-aT9maQ.log\n1. Under target dependencies, I only have the main project (=BatteryPack in my case, with BatteryPackTests being the target for my tests where I install Nimble/Quick). \n2. Target version iOS 8.0\nOn Oct 2, 2014, at 9:11 AM, Jeff Hui notifications@github.com wrote:\n\nCould you try importing xctest explicitly? What is under the target dependencies? What ios version are you targeting?\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, I do realize that XCTest is being used by Quick/Nimble :-) I was thrown off by your request to explicitly include it\u2014 not sure why that was needed. \n\nAnyway, yes my errors and issue stem from the fact that I\u2019m trying to run on a physical device. I did not have any linker errors though. So I think I will open another issue so that folks starting out know this by just looking at the subject line in the issue list. This would have saved me a lot of time. \nThanks much!\nOn Oct 2, 2014, at 10:40 PM, Jeff Hui notifications@github.com wrote:\n\nNimble/Quick uses XCTest internally which provides integration with Xcode. \nAre you testing on device? It\u2019s currently not supported (see https://github.com/Quick/Quick/issues/140). \n\u2014 \nSent from my iPhone \nOn Thu, Oct 2, 2014 at 1:42 PM, arvindraghavan notifications@github.com \nwrote: \n\n\nI have XCTest imported in one of my existing XCT-basd test cases. Note that when I install Nimble & Quick, without any new Quick-based tests added the tests stop running to completion. I have the same problem and output when I add a Quick-based test case, and import XCTest (not sure why XCTest needs to be imported when I\u2019m using Quick/Nimble??) Here is the output I see in addition to the error message I had in my original description: \nthread #1: tid = 0xeb88f, 0x318e1518 libsystem_kernel.dylib`mach_msg_trap + 20, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP \nframe #0: 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20 \n   frame #1: 0x318e1310 libsystem_kernel.dylibmach_msg + 40 \n   frame #2: 0x23c32dca CoreFoundation__CFRunLoopServiceMachPort + 146 \n   frame #3: 0x23c31390 CoreFoundationCFRunLoopRun + 1016 \n   frame #4: 0x23b7edb0 CoreFoundationCFRunLoopRunSpecific + 476 \n   frame #5: 0x23b7ebc2 CoreFoundationCFRunLoopRunInMode + 106 \n   frame #6: 0x2aee2050 GraphicsServicesGSEventRunModal + 136 \n   frame #7: 0x27149f00 UIKitUIApplicationMain + 1440 \n   frame #8: 0x00159570 BatteryPacktop_level_code + 72 at AppDelegate.swift:21 \n   frame #9: 0x001595ac BatteryPackmain + 48 at AppDelegate.swift:0 \n   thread #2: tid = 0xeb8a0, 0x318e12c8 libsystem_kernel.dylibkevent64 + 24, queue = 'com.apple.libdispatch-manager' \n   frame #0: 0x318e12c8 libsystem_kernel.dylibkevent64 + 24 \n   frame #1: 0x31803ec8 libdispatch.dylib_dispatch_mgr_invoke + 280 \n   frame #2: 0x31803bfa libdispatch.dylib_dispatch_mgr_thread$VARIANT$mp + 38 \n   thread #6: tid = 0xeb8bc, 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20, name = 'com.apple.NSURLConnectionLoader' \n   frame #0: 0x318e1518 libsystem_kernel.dylibmach_msg_trap + 20 \n   frame #1: 0x318e1310 libsystem_kernel.dylibmach_msg + 40 \n   frame #2: 0x23c32dca CoreFoundation__CFRunLoopServiceMachPort + 146 \n   frame #3: 0x23c31390 CoreFoundation__CFRunLoopRun + 1016 \n   frame #4: 0x23b7edb0 CoreFoundationCFRunLoopRunSpecific + 476 \n   frame #5: 0x23b7ebc2 CoreFoundationCFRunLoopRunInMode + 106 \n   frame #6: 0x237371fe CFNetwork+[NSURLConnection(Loader) _resourceLoadLoop:] + 486 \n   frame #7: 0x2497b1ba Foundation__NSThread__main** + 1118 \n   frame #8: 0x31973e66 libsystem_pthread.dylib_pthread_body + 138 \n   frame #9: 0x31973dda libsystem_pthread.dylib_pthread_start + 118 \n   thread #8: tid = 0xeb8c0, 0x318f508c libsystem_kernel.dylib__select + 20, name = 'com.apple.CFSocket.private' \n   frame #0: 0x318f508c libsystem_kernel.dylib__select + 20 \n   frame #1: 0x23c37552 CoreFoundation__CFSocketManager + 490 \n   frame #2: 0x31973e66 libsystem_pthread.dylib_pthread_body + 138 \n   frame #3: 0x31973dda libsystem_pthread.dylib_pthread_start + 118 \n   thread #10: tid = 0xeb94f, 0x318f59cc libsystem_kernel.dylib__workq_kernreturn + 8 \n   frame #0: 0x318f59cc libsystem_kernel.dylib__workq_kernreturn + 8 \n   frame #1: 0x31971ea0 libsystem_pthread.dylib`_pthread_wqthread + 792 \n   * Canceling tests due to timeout in Waiting for test process to check in... If you believe this error represents a bug, please attach the log file at /var/folders/ty/1k36_68s0zg7kg24qvv_1gp00000gn/T/com.apple.dt.XCTest-status/Session-2014-10-02_13:37:55-aT9maQ.log \nUnder target dependencies, I only have the main project (=BatteryPack in my case, with BatteryPackTests being the target for my tests where I install Nimble/Quick). \nTarget version iOS 8.0 \n   On Oct 2, 2014, at 9:11 AM, Jeff Hui notifications@github.com wrote: \nCould you try importing xctest explicitly? What is under the target dependencies? What ios version are you targeting? \n\u2014 \nReply to this email directly or view it on GitHub. \n\n\n\n\n\nReply to this email directly or view it on GitHub: \n   https://github.com/Quick/Nimble/issues/41#issuecomment-57702252\n   \u2014\n   Reply to this email directly or view it on GitHub.\n. \n\n",
    "robrix": "There are some more fixes to come so closing this for the moment.\n. Gotcha :+1:\n. FYI: https://twitter.com/jckarter/status/518071078313132032\n. No worries at all :heart:!\n. An alternative might be to remove the NMBCollection override and add a CollectionType override relying on countElements(): CollectionType is more specific than SequenceType so it won\u2019t run into this ambiguity.\n. I feel like this should work; it probably warrants a radar.\n. Ditto this inference.\n. @modocache Updated the readme per your request :+1:\n. ",
    "swizzlr": "woooooooooooooo\n. ",
    "nikita-leonov": "Disregard request. Apparently we had \"dispatch_async(dispatch_get_main_queue()) {\" in a parallel test that was not wrapped into waitUntil, so test case was \"finished\" buts its code still was working and affected tests close to it.\n. I actually would like to reopen bug, as it is not clearly some specific project implementation issue but more fundamental Nimble issue. Here is a test that clearly shows how issue looks like \u2014\u00a0https://github.com/nikita-leonov/NimbleWaitUntilError\nwith some pre-steps following \"it\" will fail:\nit(\"will fail.\") {\n  waitUntil { done in\n    done()\n  }\n}\nI didn't investigate yet on alternative for waitUntil implementation, but hopefully there is a way that will allow to provide better isolation. \n. @jeffh thanks for an update. Indeed solution of such task is questionable, while having some additional log information may at least give an understanding that there is a \"third-party\" effects affecting test results and require additional care. Indeed solution proposed by you may save my day if it was in code before :) \n. Mistakenly branched from master, I just reintroduced the same for swift-2.0 branch.\n. @modocache Sure thing. I will redo it for master, as well as address your suggestions and will add unit tests. Sorry for the mess. Thanks!\n. @jeffh  done\n. It will be cool to wrap fail into curried function as well to be able to do similar things as with done but I will keep it for a separate PR.\n. @jeffh with pleasure. Any plans on doing release / another RC with this change? Do I have one or two days to push trough one more PR with the similar change for fail? \n. @jeffh ok, forget about this. There is a swift language limitation \u2014\u00a0curried functions does not support default values. As result it is impossible to implement multi-purpose interface that will not cause ambiguity for an end user. Looks like we will need to wait a little bit for swift updates. \n. @jeffh looks like something lost in translation :) I was talking about impossibility of fail implementation. Current PR with done that was recently merged is fine. No need to revery.\n. @jeffh I will prefer to roll-back my previous change till further notice :( Current implementation of functions covariance is not able to handle (Any?...) when it is passed as callback. I missed it when did an implementation. As result done can be used directly with any amount of arguments, but when it is passed as callback it does not work. \nI reported this behavior to Apple and created an open radar Radar: Covariance does not work for functions with variadic arguments http://www.openradar.me/radar?id=6617793151631360. I am not sure that it will be a top priority for Apple to fix, so I would not keep the code in a current branch for now. \nHere is a screenshot that explains problem:\n\nAs you can see lines 13 & 14 work perfectly, but 16 & 17 do not.\nI will create a new PR later today :(\n. @jeffh yes, as I mentioned in rollback it is my plan to provide overloads with multiple arguments. It will work, but only in Swift 2.1 since it has functions covariance support. I think implementation set of functions with up to 5 arguments should be enough. Playground with proof of concept available by the link \u2014\u00a0https://drive.google.com/file/d/0BwZZrY1XCsVGUkMtcGxzWTNodDQ/view?usp=sharing\n. As I know Xcode 7.0 has only Swift 2.0. Swift 2.1 appeared from Xcode 7.1. Covariance will not work in current stable version of Xcode. \n. Covariance for Any?... does not work even in a latest Swift 2.1. I reported this to Apple. \n. @jeffh could you clarify what you actually tried to validate with your overloads and how it is better in compare with current implementation? \nCurrently there are no tests cases that cover actually possibility to pass done as any function, but only possibility to call done as any function. Here is your overload will work with Swift 2.0 if it will be used as callback. As you can see both giveMeVoid and giveMeOne are failing. \n\n. My idea with various functions with multiple parameters failed as well. It will require implementation multiple of waitUntil and it will cause \"ambiguous use\" issues. The only hope now that apple will fix function covariance for Any?... to make it work as proposed in an original solution.\n. So for the Swift 2.0 I would recommend do current rollback, for Swift 2.1 I will need to write function overloads together with an extra tests that shows support of multiple arguments.\n. Also I noticed a code duplication. Two waitUntil methods, the only difference is a default timeout parameter. Would it be better to replace two of these implementations with the following:\npublic func waitUntil(timeout timeout: NSTimeInterval? = 1, file: String = __FILE__, line: UInt = __LINE__, action: ((Any?...) -> Void) -> Void) -> Void {\n    NMBWait.until(timeout: timeout!, file: file, line: line, action: bridgeToVoidAction(action))\n}\n. Learning \"nitpick\" the hard way... :) k.\n. ",
    "iroth": "I have a similar issue with contain not matching array of strings:\n                    expect(returnedNames).to(contain(productNames));\ntells me:\nfailed - expected to contain , got <(p1,p2,p3)>\n. ",
    "jspahrsummers": "Oops, wasn't up to date with master. Updated version in #54.\n. This isn't an issue in 56c3b79d5a32686fe5529d7aa305000b489ebdaa.\n. This was from the v0.2.0 tag, and doesn't occur on 56c3b79 (which was the version we were using before). I'm afraid I didn't investigate much further than this, as I was just trying to get a buildable project\u2014I ended up just reverting to that aforementioned commit of Nimble.\nThat property is an NSString (in Objective-C, though), and I'm using Xcode 6.1.1, build version 6A2006.\n. This appears to be fixed as of v0.3.0 (or perhaps earlier). :sparkles:\n. Carthage just uses xcodebuild, so it'll sign if that's how you've set up your libraries, or it won't if you've disabled it.\niOS frameworks require code signing, though, so there's really no choice. But @gfontenot is right that Xcode will re-sign them when copied.\n. This isn't an issue with GitHub, Quick, or Nimble. See https://github.com/Carthage/Carthage/issues/544#issuecomment-111757571.\n. ",
    "zdrossman": "Jeff - Thanks for the update. Just finished testing on my own code and works perfectly. Cheers, Zach\n. ",
    "ole": "My bad for confusing the terminology. Thanks for the clarification.\n. ",
    "ndbroadbent": "Oh awesome, sorry didn't realize it was an option in XCTestCase. Thanks very much for your help!\n. ",
    "kylef": "Exactly. Nimble doesn't have this for Objective-C either. Nimble has the same behaviour as XCTest when it comes to type safety in Swift and Objective-C so it's a bad comparison.\n. ",
    "finestructure": "Yes, ~= looks a lot like a regex matching operator. Quite conceivable that it will at some point clash with a regex library using it.\nOriginally I was thinking of using \u2248 instead of ~= but I dismissed it because I couldn't find a keyboard shortcut to type it. Short of knowing the unicode sequence or copy pasting it from somewhere there doesn't seem to be a simple way of actually typing it.\nOtherwise it would be pretty ideal - it's the corresponding math symbol, it's unlikely to be overloaded for anything else and it's not commonly used as an operator at all yet.\nShould we go for that? It would make code prettier to read albeit harder to write. Maybe there's an Xcode snippet I could add to create a shortcut or something.\n. Ah cool - it doesn't on a UK keyboard but that's not a big deal really. US layout is probably by far the most commonly used. I'll be travelling the next couple of days but if everyone's happy with \u2248 I'll make that change when I'm back.\n. Ok, the bacon operator is now available ;)\n. ",
    "gyemme": "@jeffh I am using a swift project. \n. Sorry for the delayed response. I created a sample project with that issue here https://github.com/gowthamyemme/NimbleIssue. The steps to recreate the issue are simple.\nCreate a brand new swift project\nAdd the following pod file \nplatform :ios, '8.0'\nsource 'https://github.com/CocoaPods/Specs.git'\ntarget 'iOSUnitTestingTests', :exclusive => true do\n  pod 'Quick'\n  pod 'Nimble'\nend\nRun the tests. \n\n. I have a work around for this problem which might provide some more information for debugging. \nuse the following in your podfile \npod 'Quick', :git => 'https://github.com/Quick/Quick.git', :commit => 'f8c9ff9f499fc5ea72ff55c1c5eed32e1ff303ea'\npod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :commit => '9538a301d5320fd607f01c931dc282868b0e827a'\nuse version 0.36.0.beta.2 for pods\n. @sergdort this issue could potentially be a duplicate of this https://github.com/Quick/Nimble/issues/98. Which version of Xcode are you using ? \n. That's one way to do it but as @jeffh mentioned in the previous post use swift-1.1 branch for Xcode 6.1.1\n. ",
    "eliperkins": "Running up against the same issue myself, blew away derived data several times before declaring myself insane :stuck_out_tongue: . \nI'm on Xcode Version 6.2 (6C107a), also got the same issue against Xcode Version 6.1.1 (6A2008a). Glad to help give more details!\n. Haha yup yup. Still occurs even after cleaning derived data.\n. Unfortunately, the project I had this crop up with is not a project I can share. I can share with you how I got here though.\nThe project has used Cocoapods for a while, 0.35.0 at the time. I cloned both Quick and Nimble locally, tweaked the deployment target on both projects and podspecs to be iOS 7 (the goal of the exercise being to validate Quick/Quick#206). I added Quick and Nimble to my podfile under my test target (which included a couple other pods, FWIW, OHHTTPStubs and OCMock). Now using Cocoapods 0.36.0, I pod installed. I went back into the project and added @import Quick to a test spec. I tried building the tests, but the build failed when trying to build Nimble, saying Use of unresolved Identifier 'NMBExceptionCapture'. Same issue occurred after a clean and build and after a rm -rf of derived data, a clean, and a build.\nI just tried replicating the same steps on another (OSS) project, but it didn't occur again there, everything built in that project just fine. Might be best to chalk this up to a build tools (Swift and/or Cocoapods) failure, but figured it was worthwhile to chime in here and see if I could give some more info.\n. ",
    "MarcoSero": ":+1: \n. ",
    "klaaspieter": "I would like to say that I would prefer consistency for expect. \nWhen writing my tests I don't want to have to think about the choice between {} and (). I also want to safely be able to change expect(value).to(equal(1)) to expect(value).toEventually(equal(1)) without my specs failing for seemingly no reason.\nIf Swift requires {} for lazily evaluated values, than I would argue {} should be used in all other cases as well.\n. ",
    "NebulaFox": "```\nimport Foundation\nimport Nimble\nimport Quick\nenum SpamEggs : Printable {\n    case Spam\n    case Eggs\nvar description: String {\n    switch self {\n        case .Spam:\n            return \"SpamEggs.Spam\"\n        case .Eggs:\n            return \"SpamEggs.Eggs\"\n    }\n}\n\n}\nstruct Foo : Printable {\n    let spamEggs:SpamEggs\ninit(spamEggs:SpamEggs) {\n    self.spamEggs = spamEggs\n}\n\nvar description:String {\n    return \"Foo{\\(spamEggs)}\"\n}\n\n}\nclass PrintSpec: QuickSpec {\n    override func spec() {\n        it(\"should fail with simple object\") {\n            let foo:Foo? = Foo(spamEggs: SpamEggs.Eggs)\n            expect(foo).to(beNil())\n        }\n    it(\"should fail with array\") {\n        let foo:[Foo]? = [Foo(spamEggs: SpamEggs.Eggs)]\n        expect(foo).to(beNil())\n    }\n}\n\n}\n```\ngives me\nTest Suite 'All tests' started at 2015-02-12 12:48:13 +0000\nTest Suite 'Quick.framework' started at 2015-02-12 12:48:13 +0000\nTest Suite 'Quick.framework' passed at 2015-02-12 12:48:13 +0000.\n         Executed 0 tests, with 0 failures (0 unexpected) in 0.000 (0.000) seconds\nTest Suite 'UnexpectedPrintTests.xctest' started at 2015-02-12 12:48:13 +0000\nTest Suite 'PrintSpec' started at 2015-02-12 12:48:13 +0000\nTest Case '-[UnexpectedPrintTests.PrintSpec should_fail_with_simple_object]' started.\n/Users/robbiebykowski/Desktop/UnexpectedPrint/UnexpectedPrintTests/PrintSpec.swift:44: error: -[UnexpectedPrintTests.PrintSpec should_fail_with_simple_object] : failed - expected to be nil, got <UnexpectedPrintTests.Foo>\nTest Case '-[UnexpectedPrintTests.PrintSpec should_fail_with_simple_object]' failed (0.002 seconds).\nTest Case '-[UnexpectedPrintTests.PrintSpec should_fail_with_array]' started.\n/Users/robbiebykowski/Desktop/UnexpectedPrint/UnexpectedPrintTests/PrintSpec.swift:49: error: -[UnexpectedPrintTests.PrintSpec should_fail_with_array] : failed - expected to be nil, got <[UnexpectedPrintTests.Foo]>\nTest Case '-[UnexpectedPrintTests.PrintSpec should_fail_with_array]' failed (0.007 seconds).\nTest Suite 'PrintSpec' failed at 2015-02-12 12:48:13 +0000.\n     Executed 2 tests, with 2 failures (0 unexpected) in 0.008 (0.009) seconds\nTest Suite 'UnexpectedPrintTests.xctest' failed at 2015-02-12 12:48:13 +0000.\n     Executed 2 tests, with 2 failures (0 unexpected) in 0.008 (0.010) seconds\nTest Suite 'All tests' failed at 2015-02-12 12:48:13 +0000.\n     Executed 2 tests, with 2 failures (0 unexpected) in 0.008 (0.011) seconds\nso it appears it doesn't work for me\nfailed - expected to be nil, got <UnexpectedPrintTests.Foo>\nfailed - expected to be nil, got <[UnexpectedPrintTests.Foo]>\nI do understand that my example above does not use extensions, but in the project I am working on, I use extensions and get the same result.\n. I have uploaded my project, https://github.com/NebulaFox/Unexpected-Print\nand here is screen shot of my errors\n\n. ",
    "narfdotpl": "Awesome! :smile: :sparkles: \n. ",
    "ssherar": "Well apparently I can't read. Thank you very much @modocache!\n. ",
    "mkauppila": "I think this would be a great enhancement. This would certainly reduce the brittleness of matching exception in specs. So I'd be all :+1:  for this.\n. I think this would be even more useful than #96. At least I tend to use NSerror more often than NSException so to me this would make sense. Tought I can't really comment whether this matcher should be part of Nimble or not. Though I'd like see this implemented :)\nJust wondering should the beAnError also optionally include the error code of NSError too? \n. Semantically it's the same. To me the difference is just cleaner, a bit more readable syntax. Though the difference is quite minor.\n. Thanks @jeffh. It would make sense to expand it to more general type. count seems to be defined in CollectionType and that's what we need here, so CollectionType it will be. Adding more Objective-C types also makes sense.  \nOh, I totally forgot the documentation :grin: Thanks for pointing it out!\n. @jeffh I noticed that NMBCollection protocol is currently only extended to NSSet, NSDictionary, NSHashTable and NSArray (through NMBOrderedCollection). Wouldn't it make sense to also extend the aforementioned protocol to NSMapTable? I see no reason why not, because NSMapTable also implements count. If you agree, I can do the changes in another PR :smiley: \n. Even though CircleCI is once again showing red. All the changes discussed above are done. So all comments are welcomed :flags:\n. Seriously cool stuff. Good job @jeffh IMHO it's ready to be merged :)\n. ",
    "kglee79": "My mistake, working after checking out the correct branch.  Thanks for pointing me in the right direction!\n. ",
    "sergdort": "@gyemme I'm using Xcode 6.1.1\n. @gyemme I've actually replaced all \"as!\" with \"as\" and it compiles for now. \n. ",
    "orta": "Hrm, can you raise this as an issue on cocoapods/cocoapods. I feel like we want the failure to be the default, but that this case in particular is pretty rare.\n. Yeaaaaahhhhhhhhhhh\n. \n. awesome\n. Cool - looks legit to me \ud83d\udc4d . Finally\n. we're undoing the deprecation on source in the next release, so feel free to remove\n. It's not a metric that we use for any quality stuff, so you're welcome to just not do it. :+1: \n. ",
    "delasteve": "Oh hey, didn't see this before I pushed my PR. Either one works I guess. Depends on if the maintainers want a default value.\n. :+1: Sounds good to me. Thanks for the help!\n. ",
    "erudel": "I think having a default value is a better solution.\n. ",
    "silkentrance": "Yes, this is exactly what I implemented, except for me not using the auto closures but rather\nNSException.try({\n     NSException(...).raise()\n}, catch: {\n     // ...\n})\nAnd in the ObjC part then something that is very similar to your implementation.\nNow, when using it like this, the exception will not be caught by the ObjC part, thus never entering the catch block. It seems as if @autoclosure circumvents this.\n. It turned out, that I did use\nNSException.raise(NSInvalidArgumentException, format: nil, ...);\ninside of the block I passed to NSException.try. Since non of the arguments is optional, I shouldn't have passed in nil. Turns out that the compiler will not report that mistake but rather report some entirely different error.\nAs for the problem with the exceptions not being caught, it simply went away after setting up the project from scratch and recompiling everything.\nProblem solved.\n. Arrgh, just forget it, it is already included :grin:\n. ",
    "ksmandersen": "No I'm still on Xcode 6.2 since 6.3 is still in beta. I assumed that 6.3 compatibility would be on a branch. My bad :) Thanks for the help :+1: \n. ",
    "dfreniche": "Looks like a problem in the last v0.4.0 version.\ndoing git checkout tags/v0.3.1 it compiles fine\n. ",
    "iv-mexx": "I've found in analogous PR in Quick that, in fact, Nimble v0.4.0 does not work anymore with the newest beta of Xcode (6.3b3) #105 \nThe solution would be to directly use the master branch for Nimble in the Podfile:\nruby\npod 'Nimble', :git => 'git@github.com:Quick/Nimble.git', :branch => 'master'\nHowever, I'm not sure if thats really the best idea or if its better to wait for the next release of Nimble to be released and to target that? \n. Oh i guess i've missed v0.4.1, sorry.\n. ",
    "ikesyo": "Hi @jeffh, sorry for the lack of context.\nAssumption: Carthage requires valid certificates, code signing settings in a target project for building, because the tool tries to create a fat binary where device builds, simulator builds with some architectures are in.\nThe benefit I was considering is not faster compilation, but is that there would be no need to import certificates, set up code signing in CI (e.g. https://github.com/Carthage/Carthage/blob/3a7147897ca7209cbed575b4981f21aa9d98fc2e/script/cibuild#L27-L52).\nThose process requires some development certificate (p12 file) and secure environment variable of the password for the certificate from CI's UI. This makes it very difficult for someone to create a pull request  which introducing Nimble (or Quick, or other libraries) for some libraries, because they might not have access rights for the repository.\n. This PR uses my forked repository of Nimble, which has attached binary for release v0.3.1. It is a example case for the issue.\n. This is re-raised in the final v2.0.0 release note.\n. No, this is  already addressed in Carthage 0.17\n\nFrameworks will be built for the simulator only on platforms that require bitcode when bitcode is disabled\n\nand Nimble v4.1.0\n\nBitcode is now disabled for the tvOS platform\n. Closing this due to inactiviy.. I think expect(object.dynamicType is MyClass.self).to(beTrue()) would be fine.\n. Resolved by #366.. WIP Xcode 8 beta 6 support is here: https://github.com/norio-nomura/Nimble/pull/6. Feel free to take over it!\n. ReactiveCocoa did: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3145\n. I'd like to officially manage Swift 3 migration in this repo and I've created swift-3.0 branch. @norio-nomura Could you change the base branch of this PR to that branch? Once that is done, I would merge this and submit a new PR from the branch to master. Then, subsequent PRs for Swift 3 should be targeted on the branch.\n. Thank you @norio-nomura and all who contributed to Swift 3 support on this PR! \ud83c\udf89\n. As written in README, I think you need to do as follows: \n\nswift\nexpect{ try game.playerWantsToPutStoneAtIndexPath(indexPath) }.to(throwError())\n. @sharplet https://github.com/Quick/Nimble/pull/302#issuecomment-226375515\nIt seems that #304 should fix the issue. See also https://github.com/Quick/Quick/issues/548.\n. What happens if we apply the patch, removing appletvos and appletvsimulator from SUPPORTED_PLATFORMS on Nimble-iOSTests:\ndiff\ndiff --git a/Nimble.xcodeproj/project.pbxproj b/Nimble.xcodeproj/project.pbxproj\nindex 1f929f9..099d0cb 100644\n--- a/Nimble.xcodeproj/project.pbxproj\n+++ b/Nimble.xcodeproj/project.pbxproj\n@@ -1595,7 +1595,6 @@\n                METAL_ENABLE_DEBUG_INFO = YES;\n                PRODUCT_BUNDLE_IDENTIFIER = \"net.jeffhui.${PRODUCT_NAME:rfc1034identifier}\";\n                PRODUCT_NAME = NimbleTests;\n-               SUPPORTED_PLATFORMS = \"iphonesimulator iphoneos appletvsimulator appletvos\";\n                SWIFT_OPTIMIZATION_LEVEL = \"-Onone\";\n            };\n            name = Debug;\n@@ -1613,7 +1612,6 @@\n                METAL_ENABLE_DEBUG_INFO = NO;\n                PRODUCT_BUNDLE_IDENTIFIER = \"net.jeffhui.${PRODUCT_NAME:rfc1034identifier}\";\n                PRODUCT_NAME = NimbleTests;\n-               SUPPORTED_PLATFORMS = \"iphonesimulator iphoneos appletvsimulator appletvos\";\n            };\n            name = Release;\n        };\n. :weary:\n\n2016-06-16 05:15:05.277 xcodebuild[1272:3682] Error Domain=IDETestOperationsObserverErrorDomain Code=3 \"Canceling tests due to timeout in Checking test manager availability... If you believe this error represents a bug, please attach the log file at /Users/travis/Library/Developer/Xcode/DerivedData/Nimble-cynnqpiijwxeiicemrswimekklda/Logs/Test/83D7476C-50D3-4831-B4EC-4673EEC57661/Session-NimbleTests-2016-06-16_051302-HzlhfC.log\" UserInfo={NSLocalizedDescription=Canceling tests due to timeout in Checking test manager availability... If you believe this error represents a bug, please attach the log file at /Users/travis/Library/Developer/Xcode/DerivedData/Nimble-cynnqpiijwxeiicemrswimekklda/Logs/Test/83D7476C-50D3-4831-B4EC-4673EEC57661/Session-NimbleTests-2016-06-16_051302-HzlhfC.log}\n2016-06-16 05:15:05.316 xcodebuild[1272:6197] Connection peer refused channel request for \"dtxproxy:XCTestManager_IDEInterface:XCTestManager_DaemonConnectionInterface\"; channel canceled \n. Yes, they don't announce anything about beta 2 support yet.\n. Xcode 8 and Swift 2.3 are already supported on master by #302 and #316.\n. Superseded by #321. Closing :pray:\n. ping\n. Is there any chance to get this merged? \ud83d\ude05\n. I'm willing to be a contributor if you contributors don't have much resources for the project for now. :pray:\n. ping (related to #325)\n. Thank you too @modocache!!\n. See #277 and #321. Some users (including me) are continuously following Xcode 8 beta changes.\n. You should use CocoaPods 1.1.0.beta.1 to use Xcode 8.\n. @jeffh I think this should get additional reviews, for example:\n- API Design (Naming) Guidelines\n- IPHONEOS_DEPLOYMENT_TARGET is bumped to 8.0 (we can't select 7.0 on Xcode 8 GUI anymore)\n- BeIdenticalTo implementation which is affected by id-as-Any.\n. @jeffh Thanks for the review! I've addressed the return value of nimblePrecondition.\n. You might currently use CocoaPods 1.0.1, but you need 1.1.0.rc.2 for Xcode 8: gem update cocoapods --pre\n. This should not be needed if you use Swift 3.0 in your test target and the latest CocoaPods 1.1.0 RC which is a requirement for Xcode 8. Could you try with the version?\n. \ud83d\udc4d \n. \ud83d\udc4d \n. Closing this due to inactivity.. > I assume it's just a workaround, I wonder if it's possible to improve Nimble, so it handles such matching automatically?\n\n@darrarski  This is a limitation of current Swift version unfortunately. We should wait for the conditional conformance feature of Swift generics.\n. > ~>5.11.0\nWe don't have such version. Do you mean 5.1.1?\nhttps://github.com/Quick/Nimble/releases/tag/v5.1.1\n. Then please try with github \"Quick/Nimble\" ~> 5.1.1.\n. I successfully built Nimble v5.1.1 with Xcode 8.1. Closing.\n. I've added some commits to your branch for making the tests work as expected.. That is because < operator which takes optional values is removed in Swift 3: SE-0121\nThe operator is re-defined in Nimble (tests) just for testing purpose here: https://github.com/Quick/Nimble/blob/v5.1.1/Tests/NimbleTests/Matchers/AllPassTest.swift#L6\nSo what you should do is using forced unwrapping or optional chaining or optional binding in the closure:\nswift\n// Forced unwrapping\nexpect([1,2,3,4]).to(allPass { $0! < 5 })\n// Optional chaining\nexpect([1,2,3,4]).to(allPass { $0 ?? 0 < 5 })\n// Optional binding\nexpect([1,2,3,4]).to(allPass { x in\n    if let x = x {\n        return x < 5\n    }\n    return false\n})\n. Maybe we should have a special handling for NSProxy? \ndescription of NSObjectProtocol, which will be the counterpart of Swift's CustomStringConvertible is implemented on NSProxy. On the other hand, debugDescription of NSObjectProtocol, which may mean CustomDebugStringConvertible in Swift is an optional property and will not be implemented on NSProxy.\n\nhttps://developer.apple.com/reference/foundation/nsproxy\n\nhttps://developer.apple.com/reference/objectivec/nsobjectprotocol/1418703-debugdescription. Closing this due to inactivity.. This should be a duplicate of #367 and that is fixed in master by #372 (but not released yet).. This is still happening in 2018. Looks like the problem here is that the type evaluated in beNil() is Double?? and the value is Optional.some(.none) so that value does not satisfy beNil() matcher.\n\n\nbeNil<T>() -> Predicate<T> is evaluated as beNil<Double?>() -> Predicate<Double?>\n\nSo let actualValue = try actualExpression.evaluate() is Double??\nactualValue == nil will be false because the actualValue is Optional<Double?>.some(.none) which is not nil in that context. > beCloseTo\n\nThe problem here is that we can't provide DefaultDelta value naturally since that must be a generic value of T: FloatingPoint.. It's obvious that this is not a Nimble issue so closing.. @serges147 What you wrote is not related this issue, but rather a duplicate of https://github.com/Quick/Nimble/issues/496#issuecomment-469632683.. Seems that throwAssertion only works on x86_64 with Objective-C runtime: https://github.com/Quick/Nimble/blob/v6.0.1/Sources/Nimble/Matchers/ThrowAssertion.swift#L50-L52\n    fatalError(\"The throwAssertion Nimble matcher can only run on x86_64 platforms with \" +\n        \"Objective-C (e.g. Mac, iPhone 5s or later simulators). You can silence this error \" +\n        \"by placing the test case inside an #if arch(x86_64) or _runtime(_ObjC) conditional statement\")\n\n. Closing this due to inactivity.. Closing this due to inactivity.. Thanks!. FYI this also happens in Nimble test suites.. Seems that this is not an issue anymore in Xcode 9 beta 3: https://github.com/Quick/Nimble/pull/446#issuecomment-316564931. Could you please check the FileString errors on the SwiftPM build as well?\nhttps://travis-ci.org/Quick/Nimble/jobs/250835198. > The project fully compiles however Tests are currently broken due to ambiguous method lookups. It seems to be affecting most matchers where the underlying type T is a Sequence.\nLooks like the issue is fixed in Xcode 9 beta 3.. This should be good to go with Xcode 9 beta 3.\n@shaps80 @jeffh . > Is there a reason you removed them?\nBecause that broke the SwiftPM build as I said above. But now I understand that is required for Swift 4 with SWIFT_SWIFT3_OBJC_INFERENCE = Off;. I'll take another look.. Addressed. \ud83d\ude09. Let's get this merged :shipit: . I can't see it on that line: https://github.com/Quick/Nimble/blob/70279be/Sources/Nimble/Utils/Errors.swift#L15. Maybe you use an older version of Nimble.. This is a duplicate of #444.. @Quick/core Any thoughts?. Let's go ahead.. Please see https://github.com/Quick/Quick/pull/728#issuecomment-321114995 and https://github.com/apple/swift-package-manager/blob/swift-3.1-branch/Documentation/Usage.md#packaging-legacy-code for the detailed explanation.. Sorry for the long delay, but let's get this landed!. Please review @Quick/core \ud83d\ude4f . Thanks for your review and the feedback @ashfurrow! \nI added a comment in 2f28fd3. Feel free to update it if it is insufficient or poor english \ud83d\ude4f \nMerging.. Hi, this is not an issue on master so please use master branch for a while.\npod \"Nimble\", :git => \"https://github.com/Quick/Nimble.git\", :branch => \"master\". FYI v7.0.2 has been released.. Thanks for the review! @wongzigii . It appears that this doesn't work well.. Hi @itsravenous, you should need to add Equatable conformance on your types:\nswift\nstruct Point2d: Equatable {...}\n// or\nextension Point2d: Equatable {}. v7.0.2 has been released. Closing.. FYI v7.0.2 has been released.. Thanks @ashfurrow! I've just published v7.0.2 \ud83d\udea2 \nhttps://github.com/Quick/Nimble/releases/tag/v7.0.2. This is related to https://github.com/Carthage/Carthage/issues/1268 and  https://github.com/Carthage/Carthage/pull/1280. You should need to add ENABLE_BITCODE=NO as a User-Defined build setting on your tvOS target. Please read that issues for the details.. Hi @mludowise, this is already addressed in the latest version v7.0.2, so please update your installation. Closing.. CI builds are passing and I can't reproduce it locally. Could you try a clean build or removing ~/Library/Developer/Xcode/DerivedData?. Thanks for the investigation @Blackjacx! That's really helpful.. @Blackjacx Could you try with this branch?. @Quick/core Any thoughts?. The first point is the commit which actually fixes #471: https://github.com/mattgallagher/CwlPreconditionTesting/commit/0e5ac0b417b61e6f7054a734eb7d53f1961b0b31\nSo updating CwlPreconditionTesting is required here.\nThe second point is that we now use Carthage (Cartfile.private) as a package manager to pull CwlPreconditionTesting (and CwlCatchException) sources into Nimble instaed of copying them manually, as discussed originally in https://github.com/Quick/Nimble/pull/248#issuecomment-189753786:\n\n\nI made CwlPreconditionTesting a submodule, and then included the files from it statically. Is this the right way to go?\n\nIdeally some versioned dependency would be better, but CwlPreconditionTesting probably doesn't fit well with package managers. The submoduled project doesn't support Cocoapods or SPM.\n\nI used Carthage because of the following reasons:\n\nCocoaPods can be used as well but that would produce unnecessary Nimble.xcworkspace\nBut may install! 'cocoapods', :integrate_targets => false be a help?\nSwiftPM handles dependencies as git repositoreis, so checking them in would be annoying\nThe standard tool might be preferable though. > Hmm, pretty big diff\n\nIf we explicitly depend on CwlPreconditionTesting and declare that on Cartfile, Nimble.podspec and Package.swift instead of embedding the dependency, the big diff can be avoided.. > Hmm, pretty big diff\nHow does this look like now?. Suppressed by #508.. All CI builds are red. Could you please check them first?. Closing this due to inactivity.. Addressed by #525.. Looks like we can adopt https://github.com/mattgallagher/CwlPreconditionTesting/commit/ce96cb1d81644b92c66fd2b622260905526a7c5f to address the issue.\nRelated to https://github.com/apple/swift/pull/11329.. Fixed by #545.. Hmm it's weird that I can't reproduce it in #482 \ud83e\udd14 . Hmm it's really annoying that the ambiguous overloads are introduced only in Swift 4.0.2 \ud83d\ude1e \n\nSwift 4.0: https://github.com/apple/swift-corelibs-foundation/blob/070f125d54dc65f7434889c6b5a516dd41fa1a7e/Foundation/NSNotification.swift#L191-L206\nSwift 4.0.2: https://github.com/apple/swift-corelibs-foundation/blob/1b180e7e5bda7c279520c44ef1efa5e4543e1452/Foundation/NSNotification.swift#L191-L211. Filed https://bugs.swift.org/browse/SR-6419.. https://github.com/apple/swift-corelibs-foundation/pull/1323. This is not harmful, so let\u2019s get this merged.. @lvsti Could you try with this branch?. This may be the same as https://github.com/Quick/Quick/issues/751 and unfortunately that is an issue of SwiftPM side.. > .target\n\nAdditionally you should use .testTarget for Nimble since this is a testing dependency which depends on XCTest framework unless you really try to developping a test framework which uses Nimble inside. . Looks like this has the correct answer. Closing.. Fixed by #512 . I think this (using wholemodule compilation for Debug builds) would reduce incremental compilation benefit for Nimble developers (not for Nimbe consumers).\nAnd also Carthage builds frameworks with Release configuration by default, so \n\nit will help Carthage users and will benefit day-to-day development.\n\nthat will not be true.. This is the rationale for don't doing this explained in WWDC 2018.\n\n. Could you please try with removing pod 'CwlPreconditionTesting' and pod 'CwlCatchException'? Those are embedded in Nimble so you don't need to include them manually.. Closing this due to inactivity.. Closing this due to inactivity.. ~~Looks like the matcher is somehow used instead of this.~~. Hmm I can\u2019t reproduce this locally (in the Nimble unit tests).. Interesting, thanks for the input.. @ianbytchek Thanks for the report! Could you please file a separate issue?. This is a duplicate of #455 and I\u2019ll merge that PR instead. Thanks for the pull request though! :pray:. I think you could have your custom AssertionHandler to do that job.\nRef: #543. Closing this due to inactivity.. As the error message says that is a SwiftPM\u2019s behavior; a dependency name should be consistent. You are trying to list Nimble as https://github.com/Quick/Nimble but Quick is also listing the dependency as https://github.com/Quick/Nimble.git: https://github.com/Quick/Quick/blob/14ffdf2b1b259eec5a1512842473b2d7f819f1f7/Package.swift#L11.\nSo you should write Nimble.git instead of Nimble to your Package.swift.. Looks like you are hitting #485 (and https://github.com/Quick/Quick/issues/751) and that\u2019s not our fault.. Sorry for the late response, but could you provide a minimal reproducible example code or project?. Closing this due to inactivity.. The enum is not the same as its underlying type (NSUInteger)  so Nimble could not have an overload for your enum type (EnumType in this case) by default. So wrapping the given value into NSNumber would address the issue:\nobjc\nexpect(@(EnumTypeC)).to(equal(EnumTypeB));\nOr define an overload for your type:\n```objc\ndefine DEFINE_NMB_EXPECT_OVERLOAD(TYPE, EXPR) \\\n    NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \\\n    NMBExpectation *NMB_expect(TYPE(^actualBlock)(void), NSString *file, NSUInteger line) { \\\n        return NMB_expect(^id { return EXPR; }, file, line); \\\n    }\n\nDEFINE_NMB_EXPECT_OVERLOAD(EnumType, @(actualBlock()))\nundef DEFINE_NMB_EXPECT_OVERLOAD\n```. FYI Conditional Conformance is a huge win for us \ud83c\udf89 \nhttps://swift.org/blog/conditional-conformance/. https://travis-ci.org/Quick/Nimble/jobs/364948714\n\n -> Nimble (7.1.0)\n    - ERROR | swift: Specification `Nimble` specifies an inconsistent `swift_version` (`4.0`) compared to the one present in your `.swift-version` file (`4.1`). Please remove the `.swift-version` file which is now deprecated and only use the `swift_version` attribute within your podspec.\n\nThis is annoying... .swift-version is for swiftenv, not for CocoaPods. \ud83d\ude15 \nEDITED: This will not be an issue once CocoaPods 1.6.0 is released. https://github.com/CocoaPods/CocoaPods/issues/7436. @Quick/core Please review \ud83d\ude4f . Thanks all! \ud83c\udf89 . Thanks @wongzigii!. throwAssertion() matcher expects that the given expression will throw assertion. But in the case of let expression = { asyncAssertNotThree(3) }, the expression which actually throws is not the closure ({ asyncAssertNotThree(3) }) nor asyncAssertNotThree function but the closure passed to DispatchQueue.asyncAfter API. Throwing an assertion is happening outside expect(...) body (context). So it seems to me that it is correct behavior.. @kaganriedel That is #478 and it's fortunate that it will be resolved in a next patch version (#545).. Closing.. No, this fully works with Swift 4.1/Xcode 9.3 as demonstrated on CI.. Basic functionalities of SE-0143 are implemented in Swift 4.1: https://swift.org/blog/swift-4-1-released/\nSee also https://github.com/apple/swift-evolution/pull/825.. Any other concerns?. I will go ahead within a few days.. This could be handled by Swift 4.1's Conditional Conformances: https://swift.org/blog/swift-4-1-released/.. - Updating to Swift 4.1\n- Implementing condional conformance of Event: Equatable where T: Equatable on your side\nwould address this. Closing.. Might be yes: https://github.com/Quick/Quick/issues/749. I'm not sure why, but the podspec already specifies 10.10: https://github.com/Quick/Nimble/blob/d47a10f4bf92cd53ad4591ae9c26e08fde12ad59/Nimble.podspec#L13. Thanks!. I'm fine for releasing this in a patch release. \ud83d\udc4d . I've ran the test suites on this branch but it failed \ud83d\ude31 \n\n. I'm also at WWDC and I went to the Swift Open Hours lab and @jckarter answered that the crash may be a Swift compiler bug. A temporal workaround is\n\nRemoving __attribute__((noescape)) from NMBExceptionCapture.tryBlock\nAdd @escaping to public func withAssertionHandler(_ tempAssertionHandler: AssertionHandler, closure: () throws -> Void)'s closure argument. @sharplet Okay, I will backport this to 7.x-branch and release 7.1.2.. @phatblat No rader nor a ticket on bugs.swift.org yet. Please follow #575.. v7.1.2 has been released \ud83d\ude80 \n\nhttps://github.com/Quick/Nimble/releases/tag/v7.1.2. v7.1.2 has been released \ud83d\ude80 \nhttps://github.com/Quick/Nimble/releases/tag/v7.1.2. > https://bugs.swift.org/browse/SR-7884\nThanks for the info @eelbeze!. \ud83d\udea2 . I found that the same thing happens on CwlPreconditionTesting which is used in Nimble.\n\n\n```\nTest Case '-[NimbleTests.ThrowAssertionTest testNegativeMessage]' started.\nFatal error: : file /Users/ikesyo/.ghq/github.com/Quick/Nimble/Tests/NimbleTests/Matchers/ThrowAssertionTest.swift, line 46\n2018-06-06 17:27:05.902357-0700 xctest[79915:24107707] Fatal error: : file /Users/ikesyo/.ghq/github.com/Quick/Nimble/Tests/NimbleTests/Matchers/ThrowAssertionTest.swift, line 46\n0    Nimble                             0x0000000103ef01c0 catchReturnTypeConverter(_:block:) + 306\n1    Nimble                             0x0000000103ef03b0 static NSException.catchException(in:) + 58\n2    Nimble                             0x0000000103ec4ef0 closure #4 in catchBadInstruction(in:) + 172\n3    Nimble                             0x0000000103ec5030 partial apply for closure #4 in catchBadInstruction(in:) + 35\n4    Nimble                             0x0000000103ec5070 thunk for @callee_guaranteed (@unowned UnsafeMutablePointer) -> (@error @owned Error) + 22\n5    Nimble                             0x0000000103ec50f0 partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutablePointer) -> (@error @owned Error) + 27\n6    libswiftCore.dylib                 0x0000000107337530 withUnsafePointer(to:_:) + 12\n7    libswiftCore.dylib                 0x00000001074f7ed0 withUnsafeMutablePointer(to:_:) + 9\n8    Nimble                             0x0000000103ec4170 catchBadInstruction(in:) + 954\n9    Nimble                             0x0000000103ef04c0 closure #1 in throwAssertion() + 324\n10   Nimble                             0x0000000103efed30 closure #1 in static Predicate.fromDeprecatedClosure(_:) + 120\n11   Nimble                             0x0000000103effc60 partial apply for closure #1 in static Predicate.fromDeprecatedClosure(_:) + 38\n12   Nimble                             0x0000000103efd8c0 Predicate.satisfies(_:) + 90\n13   Nimble                             0x0000000103e7da40 run #1 () in execute(_:_:_:to:description:captureExceptions:) + 520\n14   Nimble                             0x0000000103e7e640 closure #2 in execute(_:_:_:to:description:captureExceptions:) + 152\n15   Nimble                             0x0000000103e7e850 partial apply for closure #2 in execute(_:_:_:to:description:captureExceptions:) + 83\n16   Nimble                             0x0000000103e7e8b0 thunk for @escaping @callee_guaranteed () -> () + 45\n17   Nimble                             0x0000000103e6c520 -[NMBExceptionCapture tryBlock:] + 56\n18   Nimble                             0x0000000103e7d530 execute(_:_:_:to:description:captureExceptions:) + 876\n19   Nimble                             0x0000000103e7f290 Expectation.toNot(_:description:) + 300\n20   NimbleTests                        0x0000000103c85420 closure #1 in ThrowAssertionTest.testNegativeMessage() + 358\n21   Nimble                             0x0000000103ea1f70 closure #2 in withAssertionHandler(_:closure:) + 34\n22   Nimble                             0x0000000103ea2010 partial apply for closure #2 in withAssertionHandler(_:closure:) + 17\n23   Nimble                             0x0000000103e7e8b0 thunk for @escaping @callee_guaranteed () -> () + 45\n24   Nimble                             0x0000000103e6c520 -[NMBExceptionCapture tryBlock:] + 56\n25   Nimble                             0x0000000103ea1b60 withAssertionHandler(_:closure:) + 612\n26   NimbleTests                        0x0000000103c1d020 failsWithErrorMessage(_:file:line:preferOriginalSourceLocation:closure:) + 376\n27   NimbleTests                        0x0000000103c1eaf0 failsWithErrorMessage(_:file:line:preferOriginalSourceLocation:closure:) + 291\n28   NimbleTests                        0x0000000103c85370 ThrowAssertionTest.testNegativeMessage() + 138\n29   NimbleTests                        0x0000000103c85650 @objc ThrowAssertionTest.testNegativeMessage() + 36\n30   CoreFoundation                     0x00007fff39778bb0 __invoking___ + 140\n31   CoreFoundation                     0x00007fff397789d0 -[NSInvocation invoke] + 320\n32   XCTest                             0x00000001003761c7 __24-[XCTestCase invokeTest]_block_invoke_2.195 + 65\n33   XCTest                             0x00000001003e5008 -[XCTMemoryChecker _assertInvalidObjectsDeallocatedAfterScope:] + 51\n34   XCTest                             0x000000010037f11a -[XCTestCase assertInvalidObjectsDeallocatedAfterScope:] + 116\n35   XCTest                             0x00000001003760c8 __24-[XCTestCase invokeTest]_block_invoke.189 + 207\n36   XCTest                             0x00000001003d4466 +[XCTestCase(Failures) performFailableBlock:shouldInterruptTest:] + 36\n37   XCTest                             0x00000001003d439e -[XCTestCase(Failures) _performTurningExceptionsIntoFailuresInterruptAfterHandling:block:] + 54\n38   XCTest                             0x0000000100375a7c __24-[XCTestCase invokeTest]_block_invoke + 855\n39   XCTest                             0x00000001003d931f -[XCUITestContext performInScope:] + 237\n40   XCTest                             0x000000010037596c -[XCTestCase testContextPerformInScope:] + 87\n41   XCTest                             0x00000001003759e6 -[XCTestCase invokeTest] + 137\n42   XCTest                             0x0000000100377702 __26-[XCTestCase performTest:]_block_invoke_2 + 43\n43   XCTest                             0x00000001003d4466 +[XCTestCase(Failures) performFailableBlock:shouldInterruptTest:] + 36\n44   XCTest                             0x00000001003d439e -[XCTestCase(Failures) _performTurningExceptionsIntoFailuresInterruptAfterHandling:block:] + 54\n45   XCTest                             0x00000001003775ec __26-[XCTestCase performTest:]_block_invoke.334 + 88\n46   XCTest                             0x00000001003e1050 +[XCTContext runInContextForTestCase:block:] + 225\n47   XCTest                             0x0000000100376ab1 -[XCTestCase performTest:] + 675\n48   XCTest                             0x00000001003bb616 -[XCTest runTest] + 57\n49   XCTest                             0x0000000100371ba3 __27-[XCTestSuite performTest:]_block_invoke + 365\n50   XCTest                             0x00000001003714af -[XCTestSuite _performProtectedSectionForTest:testSection:] + 55\n51   XCTest                             0x0000000100371683 -[XCTestSuite performTest:] + 296\n52   XCTest                             0x00000001003bb616 -[XCTest runTest] + 57\n53   XCTest                             0x0000000100371ba3 __27-[XCTestSuite performTest:]_block_invoke + 365\n54   XCTest                             0x00000001003714af -[XCTestSuite _performProtectedSectionForTest:testSection:] + 55\n55   XCTest                             0x0000000100371683 -[XCTestSuite performTest:] + 296\n56   XCTest                             0x00000001003bb616 -[XCTest runTest] + 57\n57   XCTest                             0x0000000100371ba3 __27-[XCTestSuite performTest:]_block_invoke + 365\n58   XCTest                             0x00000001003714af -[XCTestSuite _performProtectedSectionForTest:testSection:] + 55\n59   XCTest                             0x0000000100371683 -[XCTestSuite performTest:] + 296\n60   XCTest                             0x00000001003bb616 -[XCTest runTest] + 57\n61   XCTest                             0x00000001003f5a98 __44-[XCTTestRunSession runTestsAndReturnError:]_block_invoke + 171\n62   XCTest                             0x00000001003f5c20 __44-[XCTTestRunSession runTestsAndReturnError:]_block_invoke.78 + 68\n63   XCTest                             0x00000001003948f0 -[XCTestObservationCenter _observeTestExecutionForBlock:] + 600\n64   XCTest                             0x00000001003f5637 -[XCTTestRunSession runTestsAndReturnError:] + 639\n65   XCTest                             0x0000000100357226 -[XCTestDriver runTestsAndReturnError:] + 424\n66   XCTest                             0x00000001003dd6bd _XCTestMain + 1493\n67   xctest                             0x00000001000022b8 main + 266\n68   libdyld.dylib                      0x00007fff61a95014 start + 1\nclosure argument passed as @noescape to Objective-C has escaped: file /Users/ikesyo/.ghq/github.com/Quick/Nimble/Carthage/Checkouts/CwlCatchException/Sources/CwlCatchException/CwlCatchException.swift, line 28, column 36 \n2018-06-06 17:27:06.180223-0700 xctest[79915:24107707] closure argument passed as @noescape to Objective-C has escaped: file /Users/ikesyo/.ghq/github.com/Quick/Nimble/Carthage/Checkouts/CwlCatchException/Sources/CwlCatchException/CwlCatchException.swift, line 28, column 36\n```\n\n\n. Looks like the underlying issue has been fixed in https://github.com/apple/swift/pull/17067 and https://github.com/apple/swift/pull/17071 (I hope that the fix will be included in Xcode 10 beta 2).. https://github.com/Quick/Nimble/pull/537#issuecomment-397163554\nLooks like the fix is not included in Xcode 10 beta 2 yet unfortunately \ud83d\ude2d . Xcode 10 beta 3 is out now.\nWhile the release notes says (in \"Known Issues in Xcode 10 beta 3 \u2013 Apple Swift and LLVM Compilers\" section):\n\nWhen Swift code invokes an Objective-C method that takes a block argument annotated with\n__attribute__((noescape)), the Swift runtime may raise an incorrect \u201cclosure argument passed\nas @noescape to Objective-C has escaped\u201d runtime error even when the Objective-C code does not\nescape the closure. (40857699)\n\nthe issue seems to be fixed. So let's try to revert the changes in this PR.. I can't reproduce it anymore now with Xcode 10 (10A255) so I'm not sure \ud83e\udd14 . #611 and #612 are different from this. This issue is specific for a compiler regression.. I don't think there is a way to suppress such warnings from the package author side, unfortunately.. But you can achieve it on your side (consumer side): $ swift test -Xswiftc -suppress-warnings. Closing this due to inactivity.. Since that is just an warning and the library is only for testing, that is safely ignored. But looks like we can mitigate the situation with specifying -Xlinker -no_application_extension to OTHER_LDFLAGS.. Addressed by #541.. @axandreo Could you try this branch?. Thanks @wongzigii, this should be addressed by #508. Closing.. Let's get this merged \ud83d\udea2 . Does non-breaking, implementations migrations for some public APIs make sense?\n\nNMBPredicate conforms to NMBMatcher here: https://github.com/Quick/Nimble/blob/d2eb6a0729f0c27fb7b383b73ab59d7c40183693/Sources/Nimble/Matchers/Predicate.swift#L260. While those are public API surfaces, the point is to change those implementations (yes it's privete, implementation detail) to avoid using deperecated Matcher's matches API.. https://github.com/Quick/Nimble/pull/546#discussion_r197803969\n\n\nOk so from what I can tell NMBObjCMatcher and NMBPredicate are separate classes that both conform to NMBMatcher \u2014 so it should be non-source-breaking to replace NMBMatcher with NMBPredicate (more specific return type), but it's technically breaking to replace NMBObjCMatcher with NMBPredicate, because they don't share a common base class other than NSObject. (Let me know if I'm missing something.)\nIt's probably unlikely to be a big deal, but worth considering.\n\nIt turns out that actually those API changes were partially done in v7.0.1 (#428, 4f0dab8).. Thank you so much!. Closing this for now.. Please fill the template:\n\nProject that demonstrates the issue\n\nor provide steps to reproduce the issue.. > - Xcode Version: 9.4.1\n\n\nSwift Version: 4.2\n\n\nXcode 9.4.1 ships with Swift 4.1.2, so this is odd.\nSwift 4.2 is still in development and included in Xcode 10 beta now.. Closing this for now.. Appreciate your review! \ud83d\ude02. Closing this in favor of #549. Thanks for the PR though!. Merging once the CI passes.. > Nimble: Latest version\nCould you please note the exact version?  The compile errors are definitely fixed in recent versions, so you should use an outdated version.. > Nimble: 6.0.1\nThe latest version is 7.1.2. Please update to it.. Then you should run $ pod repo update first. That is not Nimble's issue. \ud83d\ude09 . :shipit: . That is alreasy addrssed in #549 and #554. You can use 7.x-branch for now and we will have a new 7.x release in a few days.. > the correct podspec \nThe current podspec is not wrong, it's correct as is.\nNimble v7 is compatible with both Swift 3 and Swift 4 so it isn't necessary to add swift_version (but we'll use the functionality in Nimble v8 in a future). And also altering already published podspecs will not be good habit (or may not be possible with today's CocoaPods trunk).. v7.1.3 has been released.. I think so, looks like starting from an underscore is not permitted now:\n\nhttps://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/IdentifierNameRule.swift\nhttps://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/IdentifierNameRuleExamples.swift\n\nhttps://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/RuleConfigurations/NameConfiguration.swift. Disabling validates_start_with_lowercase option will be an option (but will not be preferable).. Probably related issues:\n\n\nhttps://github.com/realm/SwiftLint/issues/628\n\nhttps://github.com/realm/SwiftLint/issues/1762\n\nhttps://github.com/realm/SwiftLint/issues/1852. I'll merge this as is for now. Thanks for the review @sharplet!. Thsnks @sharplet! I'll merge this as is.. Merging, but feel free to leave comments and I'll address them later.. Hound is busy but Travis is okay, so let's merge this \ud83d\udea2 . Are you sure that Always Embed Swift Standard Libraries build setting in your test target is turned on? Nimble uses Swift in its implementation so Swift stdlib is requred.. Closing this due to inactivity.. I'm not sure how does #531 relate to #530. Are you just saying that #531 is not cherry-picked into 7.x-branch? master is now for a next major release so #531 is not included in v7.1.2. #530 was backported by #536.. Not yet. \n\n\n531 was merged into master but we haven't cut any releases from recent master which will be Nimble v8 in a future\n\nv7.1.2 and v7.1.3 were cut from 7.x-branch, not from master\n\n531 isn't backported to 7.x-branch\n\n\nSince #531 is purely additive change, backporting to 7.x-branch and releasing v7.2.0 (since that is an addition) should be okay.. Submitted #576.. I'll keep it open until v7.2.0 is released.. Nimble v7.2.0 has been released, closing.. I'll merge this once the CI passes.. Thanks @sharplet. Thanks @sharplet! I addressed your feedbacks.. Any is not Equatable so that can't do equality checks.. You may want a type something like this: \nhttps://github.com/thoughtbot/Argo/blob/ceb3775cfb22a3f0bf7f5aac1d71e3a89627ba36/Sources/Argo/Types/JSON.swift#L4. How do we compare those untyped objects correctly? The logic and included types will be different in each circumstances, so I think Nimble will not be able to provide a fits-all matcher.\nYou can still implement your custom equivalent matcher locally which meets your needs. Another direction is casting such data to NSDictionary/NSArray/AnyObject, then you can use a matcher for Objective-C types (NSObject subclasses).. I'm glad to hear that! \ud83d\ude04. Thanks @ashfurrow!. Actually this and #587 are preliminary works for replacing the implementation of public func to<U>(_ matcher: U, description: String? = nil) with execute (over current expressionMatches).. Any concerns? @Quick/core . Thanks @sharplet!. Hmm Utils/Async.swift should be renamed to Await.swift.. Thanks!. We should test this here instead: https://github.com/Quick/Nimble/blob/8aa77bcff3a73e4ddac822326964edab01f51276/Tests/NimbleTests/Matchers/AllPassTest.swift#L79-L86. Yes we are, see #514 and #515 for the details.. @sharplet Addressed your feedback!. Thanks!. The functionality is provided by to(_:description:)\nhttps://github.com/Quick/Nimble/blob/f52c57e36830352f7e9ea95b4d3ce364572fea62/Tests/NimbleTests/UserDescriptionTest.swift#L12. Without the laziness the given expression will raise an exception at the call site of expect and the exception will not be passed to a matcher (that means that a matcher can't test an expression at all).\n. > Are we testing that we can raise a certain exception? What is this for?\nTesting a function (defined in ObjC) which raises an exception in some situation does make sense to me.\n\nWhether the function correctly raises an exception in an expected situation\nWhether the function does not raise an exception in other situations. Closing this due to inactivity.. We use String as FileString on non-SwiftPM envrionment for Objective-C compatibility (StaticString can't be used in Objective-C): https://github.com/Quick/Nimble/blob/5eccb9524614fdd8bed37e6ea6f6dcbca6c8258e/Sources/Nimble/Utils/SourceLocation.swift#L3-L12\n\nSo you could use recordFailure wrapper instead of the direct XCTFail usage: https://github.com/Quick/Nimble/blob/b6f0a7b79182c1a70f33c8aa030c75f0b5901cfd/Sources/Nimble/Adapters/NimbleXCTestHandler.swift#L75-L91. Oh recordFailure is public only on master \ud83d\ude05 \nYou could use master for now. I'm going to backport #543 into 7.x.. I will go ahead \ud83d\ude80 \nThanks for the review @sharplet!. Nimble is a testing library (normally) used for test targets (within XCTests), it is not for application targets.. Looks like you confuse this and https://github.com/apache/mynewt-nimble. That is completely different and unrelated project. Closing.. Thanks @wongzigii. Thanks for the PR, but we (I) still want to keep Swift 4.1 compatibility.. Please update to the latest version (7.3.0) and it should work.. Could you please paste the actual error log? \n\nCarthage/Checkouts/Nimble/Sources/NimbleObjectiveC/NMBExceptionCapture.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler\n\nis insufficient.. That is just an carthage output, please check the actual xcodebuild log in /var/folders/wz/r9m4vxx11hs45gqcxblmx54c0000gq/T/carthage-xcodebuild.DIaEpR.log.\n. The fix for that is https://github.com/Quick/Nimble/pull/605 (which is in master) and the same fix is already applied to 7.3.1 (https://github.com/Quick/Nimble/pull/606). You may be hitting a build cache issue, so it may be good to remove DerivedData folder (/Users/jonas/Library/Caches/org.carthage.CarthageKit/DerivedData/10.0_10A255/Nimble/v7.3.1).. And also current master is heading to Nimble v8 which has some breaking changes but we are not ready to release the new major version yet.. a145269 seems totally unrelated. The error should mean the framework is not build yet. So I think running a clean build or clearing derives data folder would address your errors. Closing.. Okay, so I now understand that this issue is a different from #537 (which was a compiler regression) and #612 actually fix this.. That means you need to run pod repo update.. I'm sorry for the late response.\nI think that's because NSError equality check is implemented as such and the overload is used: https://github.com/Quick/Nimble/blob/025d0e25fc043534ae24e645e6729cd15851e28d/Sources/Nimble/Matchers/MatchError.swift#L34-L53\nSo I'd say this is an expected behavior.\nBut it may be good to provide another overload which takes an NSError and a matching strategy such as:\n``swift\nenum NSErrorMatchingStrategy {\n    casedefault// Rely onNSError'sEquatableimplementation\n    case ignoringUserInfo // Just comparedomainandcodeand ignoreuserInfo`\n}\nfunc matchError(_ error: NSError, strategy: NSErrorMatchingStrategy = .default) -> Predicate\n``. Looks like you confuse this and https://github.com/apache/mynewt-nimble. That is completely different and unrelated project. Closing.. @gladborn This is the second time that you created an issue on this repisotory: https://github.com/Quick/Nimble/issues/603. \ud83d\ude43 . https://github.com/apache/mynewt-nimble as I suggested above. What you use is **Nim BLE** (related to BLE: Bluetooth Low Energy) and this is **Nimble** (testing, matcher framework for Swift and Objective-C) which is completely unrelated to BLE.. /cc @jeffh as the original author of the component.. I think that theforcefullyAbortTimeoutis used as **additional time** once the giventimeoutInterval` has passed. The abort timeout does not start at the same time as the timeout interval. So I think the current code should be correct.\nWhen a timeout interval is 5 sec:\n\nCurrent: Aborted when 7.5 sec has passed (5 + 5/2)\nWith this PR: Aborted when 15 sec has passed (5 + 5*2)\n\nMaking additional time as twice as the original timeout interval does not seem correct.. Thanks @phatblat, I'll go for it!. Okay so we should override NSObject.hash here instead of Hashable.hashValue.\n\nhttps://github.com/Quick/Nimble/blob/df937ffd185b3dd1a44e0c234121cf826b599eb4/Sources/Nimble/Matchers/Predicate.swift#L314\n\nThis had been addressed on master by https://github.com/Quick/Nimble/pull/604 but not on 7.x-branch.. Should be addressed in v7.3.3.. I'll merge this once CI passes and cut v7.3.3.. I'm sorry for the inconvenience, that was due to my environment issue (with Xcode 10.2 beta). It has been published now.. There are some test failures such as:\n\n/home/travis/build/Quick/Nimble/Tests/NimbleTests/Matchers/BeCloseToTest.swift:135: error: BeCloseToTest.testBeCloseToArray : failed - Expected error message (expected to be close to <[0, 1]> (each within 0.0001), got <[0, 1.1]>), got (expected to be close to <[0.0, 1.0]> (each within 0.0001), got <[0.0, 1.1]>). Looks like the reduced condition is Sequence and SetAlgebra (not Collection) as the errors say.. We already recognized the issue, so locked this.\n\nThis is due to #594 and #609.. @ianbytchek\n\nDoesn't look like IndexSet has anything to do with Sequence.\n\nIndexSet is BidirectionalCollection, BidirectionalCollection is Collection, Collection is Sequence.. Hey folks, I submitted a PR #639 to fix this. So you could use fix-beempty-and-contain-matcher-ambiguity branch for a while.. I'll go ahead.. NSTimeInterval is used.\n. This file uses NSObject.\n. NSString and NSArray are used.\n. NSRunLoop, NSTimeInterval, NSDate are used.\n. NSObject, NSDictionary and NSException are used.\n. NSTimeInterval is used.\n. NSString and NSCharacterSet are used.\n. NSObject and NSFastEnumeration are used.\n. NSObject is used.\n. NSObject is used.\n. NSObject and NSNumber are used.\n. NSString, NSArray, and NSDictionary are used.\n. NSComparisonResult is used.\n. NSComparisonResult is used.\n. NSObject is used.\n. NSComparisonResult is used.\n. NSComparisonResult is used.\n. NSNumber is used.\n. NSObject and NSString are used.\n. NSObect is used.\n. NSString is used.\n. NSObject, NSArray, NSSet, NSHashTable, NSDictionary, NSNumber and NSString are used.\n. This setting is already set at the project level, so should not be set at each target level.\n. The framework intentionally supports iOS 7, see #118 and #262.\n. The OS X (macOS) CI builds are broken now with the scheme name change. \ud83d\ude22 \n- https://travis-ci.org/Quick/Nimble/jobs/149146818\n- https://travis-ci.org/Quick/Nimble/jobs/149146824\n. Thread.isMainThread is not implemented yet. \ud83d\ude22 \n. I got the error without this \ud83e\udd14 \n/project/Sources/Nimble/Utils/Async.swift:315:93: error: use of unresolved identifier 'NSEC_PER_SEC'\n            let interval = DispatchTimeInterval.nanoseconds(Int(pollInterval * TimeInterval(NSEC_PER_SEC)))\n                                                                                            ^~~~~~~~~~~~\nSwiftGlibc.CLOCKS_PER_SEC:1:12: note: did you mean 'CLOCKS_PER_SEC'?\npublic var CLOCKS_PER_SEC: Int { get }\n           ^\n. Okay, import CDispatch fixes the issue.\n. I'd tried to replace some TimeInterval parameters to DispatchTimeInterval, but this line made me unhappy at that time \ud83d\ude13 \n. Submitted https://github.com/Quick/Nimble/pull/343. \u2728 \n. There is no CDispatch module on Darwin.\n. Removal of this is breaking Linux build since NMBObjCMatcher is not available on Linux. extension NMBObjCMatcher { ... } in this file should be still surrounded by the #if _runtime(_ObjC) condition.. Thanks for the fix! But unfortunately it looks like func beAKindOf(_ expectedClass: AnyClass) -> NonNilMatcherFunc<NSObject> also should be only for ObjC runtime. NSObject on Linux (of swift-corelibs-foundation) doesn't have isKind(of:) method.. I'm using docker (you need to install this first: https://docs.docker.com/docker-for-mac/)\nbash\n$ docker pull swiftdocker/swift:3.0.1\n$ docker run -it -v `pwd`:/project swiftdocker/swift bash\n$ cd project\n$ swift test. Wrong indentation.. Wrong indentation.. This utilizes the change in SwiftLint 0.22:\n\nNested configurations will now be merged with parent configurations rather than replace them outright.. Unfortunately we can't use #if if swift(>=x.y.z) in Swift 3.0 \ud83d\ude1e \n\nhttps://travis-ci.org/Quick/Nimble/jobs/303516955. Using withoutActuallyEscaping may be another option.\ndiff\ndiff --git a/Sources/Nimble/Adapters/AssertionRecorder.swift b/Sources/Nimble/Adapters/AssertionRecorder.swift\nindex 1aad65a..0f7adbc 100644\n--- a/Sources/Nimble/Adapters/AssertionRecorder.swift\n+++ b/Sources/Nimble/Adapters/AssertionRecorder.swift\n@@ -46,15 +46,17 @@ public class AssertionRecorder: AssertionHandler {\n /// https://openradar.appspot.com/radar?id=5595735974215680\n ///\n /// @see AssertionHandler\n-public func withAssertionHandler(_ tempAssertionHandler: AssertionHandler, closure: @escaping () throws -> Void) {\n+public func withAssertionHandler(_ tempAssertionHandler: AssertionHandler, closure: () throws -> Void) {\n     let environment = NimbleEnvironment.activeInstance\n     let oldRecorder = environment.assertionHandler\n     let capturer = NMBExceptionCapture(handler: nil, finally: ({\n         environment.assertionHandler = oldRecorder\n     }))\n     environment.assertionHandler = tempAssertionHandler\n-    capturer.tryBlock {\n-        try! closure()\n+    withoutActuallyEscaping(closure) { escapable in\n+        capturer.tryBlock {\n+            try! escapable()\n+        }\n     }\n }. Those are written in string literals, so should be ignored.. Addressed in 13f2cc8.. Hmm it's unfortunate that the NMBObjcMatcher are exposed here instead of NMBMatcher. I'm okay to exclude them in this PR.. Let's revisit that in a separate PR (targeting to master branch).. This should be named ElementsEqualTest.swift (not Tests but Test) for consistency.. > , matcher: { (actualExpression, msg) in\nCould you please use trailing closure syntax here instead?. Could you remove these header comments as same as other source files?. This is just for consistency in the codebade. I prefer using just catch { ... } as well so let's replace them in a separate PR.. It makes sense \ud83d\udc4d(will be done in a separate PR). Addressed in cd886a5.. Totally makes sense \ud83d\udc4d . Addressed in 9bbe098.. FailureMessage is not a struct but a class that extends NSObject so that does not make sense. Instead, I would like to replace the function with one which returns ExpectationMessage (in a separate PR).. Makes sense :+1:. nil should not be converted to false here.. Testing contain matcher in ObjCEndWithTest.m is odd (and the fact the test is passing is odd as well) \ud83d\ude1b . Is this compatible with Swift 4.1?. I'll check the warning in Swift 4.2 mode later.. IIRC this had been warned from Swift 4.1, so this is okay (compatible with Swift 4.1).. https://github.com/apple/swift-evolution/blob/master/proposals/0191-eliminate-indexdistance.md\n\nStatus: Implemented (Swift 4.1). Totally makes sense :+1: Thanks for the input!. That is already covered here:\n\n\nhttps://github.com/Quick/Nimble/blob/7de081475abd9db7e43355990c8f8ec0c178efe3/Tests/NimbleTests/objc/ObjCBeFalseTest.m#L24-L29\nhttps://github.com/Quick/Nimble/blob/7de081475abd9db7e43355990c8f8ec0c178efe3/Tests/NimbleTests/objc/ObjCBeFalsyTest.m#L13\nhttps://github.com/Quick/Nimble/blob/7de081475abd9db7e43355990c8f8ec0c178efe3/Tests/NimbleTests/objc/ObjCBeFalsyTest.m#L26-L28\n\nPreviously the behavior is ensured by NMBObjCMatcher(canMatchNil: false): https://github.com/Quick/Nimble/blob/7de081475abd9db7e43355990c8f8ec0c178efe3/Sources/Nimble/Adapters/NMBObjCMatcher.swift#L47-L52\n. What I wanted to say is that the message\n\nnil should not be converted to false here.\n\nis only applicable to the new NMBPredicate impl in this PR, but not to the previous NMBObjCMatcher impl.. Sure, it's okay for ignoring the warning for now.. This now matches\nhttps://github.com/Quick/Nimble/blob/3f25b677eaadd009987386a368de173d9c0cad93/Sources/Nimble/DSL%2BWait.swift#L18-L23\nCompletely makes sense \ud83d\udc4d . Swift 4.2 is already supported above.\nswift\n                #if swift(>=4.2)\n                _ = RunLoop.current.run(mode: .default, before: .distantFuture)\nwhich had been addressed by https://github.com/Quick/Nimble/pull/549.\nThis breaks Swift 4.0/4.1 compatibility.. This is related to https://github.com/apple/swift-corelibs-foundation/pull/1762.. ",
    "gfontenot": ":+1: It also seriously speeds up the bootstrapping process. It's also really nice for users that don't want to use a dependency manager at all because they can just download the binaries themselves and integrate on their own. FWIW, Carthage makes it dead simple to create the zip files for releases. I'd be happy to help out here if y'all don't want to manage it.\n. Carthage signs the binaries when building, but Xcode re-signs them when they are copied into the app bundle, so I'm not sure if it's worthwhile trying to own the signing. Maybe @jspahrsummers has some guidance?\n. Nope, my bad. I misread this console output. I don't think this needs to be enabled.\n. ",
    "haifengkao": "My bad! The errors went away with v0.4.0\n. Thanks, v0.4.1 solves the error on XCode 6.3 beta 3.\n. ",
    "sasijp": "I am having same problem with Nimble v0.4.0 and Xcode 6.3 Beta 3\n* Fetching Alamofire\n* Fetching Quick\n* Fetching Nimble\n* Checking out Alamofire at \"2ff5749ffc0425f05a1411b5b6fd2c25241b5b14\"\n* Checking out Quick at \"v0.3.0\"\n** Checking out Nimble at \"v0.4.0\"\n.......\n...\n/Users/jpsasi/Developer/ClientProjects/Playfiks/Playfiks/Carthage/Checkouts/Nimble/Nimble/Wrappers/AsyncMatcherWrapper.swift:43:35: error: extra argument 'timeoutInterval' in call\n            to(AsyncMatcherWrapper(\n                                  ^\n/Users/jpsasi/Developer/ClientProjects/Playfiks/Playfiks/Carthage/Checkouts/Nimble/Nimble/Wrappers/AsyncMatcherWrapper.swift:57:38: error: extra argument 'timeoutInterval' in call\n            toNot(AsyncMatcherWrapper(\n. Thank you. It works now with v0.4.1\n. ",
    "tobinharris": "Hi folks. \nThanks for the feedback. @rbeeger, the cast worked, along with checking for nil.\nfunc testCanPassAuthentication() {\n  authentication.authenticate(\"123456\")\n  expect(self.authentication.state.value as? Authentication.Authenticating).toEventuallyNot(beNil())\n  expect(self.authentication.state.value as? Authentication.Passed).toEventuallyNot(beNil())\n}\nI think factories are a good case for asserting the correct class is instantiated. Or eventually instantiated in an async situation. In this case, I'm using class to differentiate state changes - just an experiment :)\n. Cheers @rbeeger, I'll check out the Swift enums for this. I just got started with Swift.\nI'm mainly playing with ideas on how to slim down my controllers and create a testable, simple, lightweight service layer. I'm not sure it's smelling right yet :)\n\n. ",
    "pfitz": "FBLikes is a swift type. Do I have to implement some special methods?\n. Doh! Guess im a little bit used to Objective-C :) Thanks.\n. ",
    "marciok": "Thanks a lot @jeffh ! :star2: \nI moved the view controller out of the storyboard but I was still getting Stall on main thread.\nI ended up increasing the run time on the mainRunLoop and it worked.\nThanks again. :+1:  :smile: \n. Hi,\nDid you try to clear your project folder  Command + Option + Shift + k and reset the simulator (at menu bar iOS Simulator -> Reset Content and Settings ?\n. Strange, I'm using CocoaPods 0.37.1 and it's fine. \n@manumax did you mange to work around this issue or did you rollback to CocoaPods 0.36 ? \n. ",
    "priteshshah1983": "Can you please share more details? What changes did you exactly make? An example, if possible, would be great!\nThanks in advance!\n. ",
    "manumax": "I had exactly the same problem with CocoaPods 0.37.1. With CocoaPods 0.36.1 all works fine. I think it's related with https://github.com/CocoaPods/CocoaPods/issues/3440.\n. I spent a full afternoon trying to understand what was going on and eventually I decided to rollback to 0.36. To clarify, it happened on a project of mine that was already using CocoaPods 0.36. When I decided to upgrade to 0.37, I started to get the error (I did the full clear of the project folder and derived data but I didn't reset the simulator). If I'll have some spare time later I could try again on a brand new project.\n. I did a few experiments and you're right, now it seems to work even with CocoaPods 0.37.1. I did reset the simulator, maybe that was the problem.\n. ",
    "zbeckman": "Ahh... nevermind. Fixed after interminable tinkering, cleaning, rebuilding, deleting, and rewriting my pod config file. :)\n~~This has popped up again, at least it looks the same to me. It is only happening in a new test target that we added to the project, but no matter what I do... can't seem to get the dyld to load:~~\n~~dyld: Library not loaded: @rpath/XCTest.framework/XCTest\n  Referenced from: /Users/zbeckman/Library/Developer/CoreSimulator/Devices/FCFAAFBF-1AB4-4223-9BCC-CA91CBDE96DC/data/Containers/Bundle/Application/DB1E94B2-3521-46CA-AB5A-A524BD9E14D6/Glimpulse.app/Frameworks/Nimble.framework/Nimble\n  Reason: image not found~~\n. @jeffh I'm seeing this too... but only on deployment to a device. The problem is occurring on the swift-2.0 branch but only when trying to build for a device. This is on Xcode 7 beta 6, with the latest pull from the swift-2.0 branch. (eg., when I try to build for my iPhone 6, I get the following error):\nLd /Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA\\ 1-iphoneos/Nimble.build/Objects-normal/armv7/Nimble normal armv7\n    cd /Users/zbeckman/Projects/XXX/iOS/project/XXX/Pods\n    export IPHONEOS_DEPLOYMENT_TARGET=8.0\n    export PATH=\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch armv7 -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk -L/Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Products/QA\\ 1-iphoneos -F/Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Products/QA\\ 1-iphoneos -F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk/Developer/Library/Frameworks -F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks -filelist /Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA\\ 1-iphoneos/Nimble.build/Objects-normal/armv7/Nimble.LinkFileList -install_name @rpath/Nimble.framework/Nimble -Xlinker -rpath -Xlinker @executable_path/Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -miphoneos-version-min=8.0 -dead_strip -fembed-bitcode-marker -framework XCTest -fobjc-arc -fobjc-link-runtime -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphoneos -Xlinker -add_ast_path -Xlinker /Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA\\ 1-iphoneos/Nimble.build/Objects-normal/armv7/Nimble.swiftmodule -framework Foundation -framework XCTest -single_module -compatibility_version 2 -current_version 2.0.0 -Xlinker -dependency_info -Xlinker /Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA\\ 1-iphoneos/Nimble.build/Objects-normal/armv7/Nimble_dependency_info.dat -o /Users/zbeckman/Library/Developer/Xcode/DerivedData/XXX-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA\\ 1-iphoneos/Nimble.build/Objects-normal/armv7/Nimble\nld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk/Developer/Library/Frameworks'\nld: '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture armv7\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. Awesome \u2013\u00a0Looking forward to the update. Our app is camera heavy which makes it impossible to test in the simulator. :)\n. The example I gave is something we have to deal with since our testing framework uses HTTPS for many transactions, but uses HTTP for some transactions.\nHowever, here is one that's a bit more tricky (less predictable). Depending on the device being used, we might be dealing with an IPv4 or an IPv6 address. We use two different regular expressions to validate each one:\nlet IPv4Pattern = \"^(?:[0-9]{1,3}\\\\.){3}[0-9]{1,3}(:[0-9]{0,3}){0,1}$\"\nlet IPv6Pattern = \"^(?:[A-Fa-f0-9]{0,4}:){7}[A-Fa-f0-9]{0,4}(:[0-9]{0,3}){0,1}$\"\nThe easiest solution is to query the device information, and make sure it matches one of these two patterns (this would require adding a matches handle that compares to a regular expression, which would also be incredibly useful):\nexpect(deviceIP).to(match(IPv4Pattern)).or(match(IPv6Pattern))\nRight now we do something like this instead (not exactly, I'm simplifying, but you get the idea)... This can work fine but is a little bit less elegant and readable:\nexpect(deviceIP.rangeOfString(IPv4Pattern, options: .RegularExpressionSearch) || deviceIP.rangeOfString(IPv6Pattern, options: .RegularExpressSearch)).to(beTruthy())\n. My first instinct was to try this:\nexpect(value).to(equal(2) || equal(3))\nWhich didn't work, so I looked at if with a functional perspective, and tried this:\nexpect(value).to(equal(2)).or(equal(3))\nI like the latter much more, I think. I'm not sure why. Probably because it does open up some interesting possibilities:\nexpect(value).to(match(\"\\\\w\")).andNotTo(match(\"\\\\w{3}\"))\nAnd being a Scala/functional programmer at heart I tend to expect every function to return something I can operate on. The very last example (with anyOf) is interesting too.\nJust more food for thought. I've written a short regular expression matching class, and added an infix =~ operator, so that now our test looks like this:\n```\nit(\"matches correctly on an IP address\") {\n    expect(ip =~ RegularExpressions.IPv4Pattern).to(beTrue())\n}\nit(\"returns a good IP address\") {\n    expect((device.primaryIPAddress =~ RegularExpressions.IPv4Pattern) || (device.primaryIPAddress =~ RegularExpressions.IPv6Pattern)).to(beTruthy())\n}\n```\nOf course the limitation here is that the failed case will report something like \"expected X to beTrue()\" which really doesn't tell me much. It would be great if we got back \"expected X to match pattern '...'\" but of course that would mean adding some kind of regex pattern matching to the expectations. Happy to share my regex class if interested (it's pretty trivial).\n. Just threw up a short gist so you can grab what you want from the regex class, if you want to create a similar matcher... https://gist.github.com/zbeckman/ef7ea36d70186e4dfdc5\n. Darn it. Sorry, this belongs in Quick. Recreated over there (see https://github.com/Quick/Quick/issues/373) \u2013\u00a0please close this issue.\n. ",
    "Noobish1": "We're using 0.37.1\n. ",
    "objczl": "+1\n. ",
    "poetmountain": "I know this issue is closed, but I'm seeing this same issue and neither of the workarounds noted in this thread (use @import or importing <Nimble/Nimble-Swift.h>) are working. Xcode can't find either of those from my Objective-C test cases.  I'm using Cocoapods 0.39.0 and Xcode 7.2, and Nimble 3.0.0.\n. ",
    "oks": "+1, any updates, team?\n. How it works for me:\nxcode 7.2, ios 9, objective-c\n1) install as submodule\n2) include framework following installation instructions (install via cocopods didn't work properly)\n3) as mentioned above add import <Nimble/Nimble-Swift.h> to your file. \n3.1) I've created pch file and put all imports there. \n3.2) don't forget to build framework\n. Okay, but maybe we can shut this warning, somehow? \n. ",
    "xmkevinchen": "Hey, I have a objective-c protocol\n@protocol DataSource\n@end\nand also I've a class adopting this protocol\n@interface CKDataSource: NSObject<DataSource>\n@end\nand a generator to give client the data source based on different situation\n@interface DataSourceGenerator\n - (id<DataSource>)dataSource\n @end\nI'm using Nimble beAnInstanceOf() method to test is the instance return from generator, I always get the error says, I can't use the Swift object to this method\nAm I doing something wrong for using the beAnInstanceOf() method?\nI believe I'm using the Nimble 1.0.0 version \n. ",
    "fabiomassimo": "@modocache  My two cents: the adoption of Swift 2 sounds like a major migration and it's available through Xcode 7 (beta) only. Wouldn't it be better to work on a separate branch swift-2.0 and keep master up to date with current Xcode stable version?\nIt wouldn't be weird if someone is expecting that master branch works with current stable version of Xcode rather than a pre-release one.\n. ",
    "neilpa": "Note that calling the branch swift-1.2 won't be compatible with carthage\n. > The latest version of Nimble is v1.0.0-rc.1, which supports Swift 1.2. What should the Swift 2.0-compatible version be?\nIf you want to drop Swift 1.2 then staying with v1 and bumping the RC would be acceptable since there's no compatibility guarantees for pre-release (c.f. Carthage/Carthage#499)\n. Looks like the build failed cause it's trying to run it against Xcode 6.3\n\nsudo xcode-select --switch /Applications/Xcode-6.3.1.app\n. This should explicitly set ENABLE_BITCODE = YES to be buildable from Carthage.\n\n```\nBuild settings from command line:\n    ONLY_ACTIVE_ARCH = NO\n    SDKROOT = appletvos9.0\n=== BUILD TARGET Nimble-tvOS OF PROJECT Nimble WITH CONFIGURATION Release ===\nCheck dependencies\ntarget 'Nimble-tvOS' has bitcode disabled (ENABLE_BITCODE = NO), but it is required for the 'appletvos' platform\n```\n. This now fails to link because of the issue you called out earlier.\nld: '/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest' does not contain bitcode.\nYou must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE) or obtain an updated library from the vendor for architecture arm64\nI'm not sure how to resolve these two competing problems.\n. I checked out just Nimble to experiment. Xcode must be doing something special because that builds and runs tests fine. However, I see the exact same failures from the command line with xcodebuild -target Nimble-tvOSTests\n. Specifying the scheme+destination instead of target seems to work regardless of bitcode setting because it forces the simulator instead of device. (c.f. http://www.mokacoding.com/blog/xcodebuild-destination-options/)\n\u276f xcodebuild -scheme Nimble-tvOS -destination 'platform=tvOS Simulator,name=Apple TV 1080p'\nMy guess for fixing this is to remove arm64 from supported platforms for now. Seems like you can't have a real device test target that also links other frameworks because of the xctest bitcode discrepancy.\n. Specifying the sdk explicitly seems to work (which is what xcode must be doing)\n\u276f xcodebuild -target Nimble-tvOSTests -sdk appletvsimulator9.0\n. I don't have a tvOS, I was just messing around with xcodebuild to try and make it work by hand from the command line. I'm not sure what the necessary Xcode settings are because nothing I tried ended up working.\n. ",
    "gavrix": "ok, got that. Thanks.\nyeah, coming to Nimble from Specta/Expecta background, and they were using that syntax, so I naively tried it without researching the Nimble sources.\n. BTW, having @throw inside expectAction macro breaks it, doesn't compile. Definitely makes sense to migrate to evaluate given blocks instead.\n. by replacing \n```\ndefine expectAction(...) NMB_expect(^id{ (VA_ARGS); return nil; }, FILE, LINE)\n```\nwith \n```\ndefine expectAction(x) NMB_expect(^id{ x(); return nil; }, FILE, LINE)\n```\nyou can have that kind of syntax\nexpectAction(^{\n    @throw [NSException exceptionWithName:@\"\" reason:@\"\" userInfo:nil];\n}).toEventually(raiseException());\n. ",
    "joshuatbrown": "I'm having the same issue and would love to help if I can.\n. ",
    "yariksmirnov": "I've been thinking for sometime. I actually don't know how to implement such feature.\nI believe it should look something like this:\nIn case we test function which accept args.\nexpect {\n    testingFuncWhichThrows(arg1, arg2)\n}.toThrow()\nAnd more convenient variant for case when func takes no args.\nexpect(testingFuncWhichThrows).toThrow()\n. ",
    "dwaite": "@jeffh After mucking around a bit, I'm thinking what may be the most appropriate course of action is refactoring FailureMessage into a new Result object. Rather than passing FailureMessages in to be modified and returned by matchers, you instead return the result and outer functions may manipulate it (such as changing from \"expect to match\" to \"expect not to match\")\nRather than expecting thrown on predictable failure, a result would be returned on failure or success - you need the messages within the results to handle composed cases, such as allOf. A matcher function type alias could still be declared to throw instead of returning a result - the caller would simply generate a default failing result from the ErrorType-compatible object received.\nI've switched to tinkering on this shift to Results myself, so I would not say I'm close to any sort of alternate proposal for handling Swift 2.0 errors.\n. ",
    "mrackwitz": "\nIt points to the failure location better than showing the failure at try! in Expression.evaluate.\nI think some merge between the two PRs would be great: Your matcher + #142's internal try refactoring.\n\nYes, I agree. Furthermore the #142's internal try refactorings ensures that just the expectation fails instead of an assertion, which crashes the whole test suite. I rebased my branch on yours and those changes together on swift-2.0. (The order shown here on GH doesn't match with that.)\n. What exactly are you missing from the new throwError matcher? (see #143)\n. ",
    "briancroom": "Another interesting use case for this would be the ability to use Nimble matchers in a playground as a lightweight TDD environment. Continuous feedback!\n. Would it make sense to apply this to a different branch (master?) instead?\n. That's interesting, @jeffh, I hadn't tried running inspecting the Nimble binary with otool. I've done some more digging, and it seems that the -L command reports linked dylibs without any indication of whether they are weakly referenced or not, however if you use -l to get the list of load commands, then you can see the distinction:\n...\nLoad command 10\n          cmd LC_LOAD_WEAK_DYLIB\n      cmdsize 72\n         name @rpath/XCTest.framework/Versions/A/XCTest (offset 24)\n   time stamp 2 Wed Dec 31 19:00:02 1969\n      current version 8131.5.0\ncompatibility version 1.0.0\nLoad command 11\n          cmd LC_LOAD_WEAK_DYLIB\n      cmdsize 56\n         name @rpath/libswiftXCTest.dylib (offset 24)\n   time stamp 2 Wed Dec 31 19:00:02 1969\n      current version 0.0.0\ncompatibility version 0.0.0\nLoad command 12\n          cmd LC_LOAD_DYLIB\n      cmdsize 96\n         name /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (offset 24)\n   time stamp 2 Wed Dec 31 19:00:02 1969\n      current version 1223.1.0\ncompatibility version 300.0.0\n...\nI have also pushed a branch that shows an example of using Nimble without XCTest to briancroom@0d3721f2f360e44038501f5ce1f7f3acef0e9ca8\nTo be fair, I haven't attempted this with pulling in the framework via Cocoapods or Carthage yet. I'm anticipating that Carthage will work, but it may take some additional work to get Cocoapods to build it correctly.\n. Ah, I see...there's more going on here than I realized. The example app I linked to was included in the Nimble workspace. It links with a copy of the Nimble framework that isn't embedded in the final app, which meant that swift-stdlib-tool didn't scan Nimble when it decides which Swift libraries to copy in.\nI tested it with Carthage now and encountered the same problem that @jeffh saw, presumably. swift-stdlib-tool copies libswiftXCTest.dylib into the app bundle, because it sees that Nimble can take advantage of it, but then the app crashes on launch because that dylib is strongly linked to XCTest.framework. I tried adding a Run Script to delete libswiftXCTest.dylib, but the Swift libs aren't copied until after the script executes.\nI'm going to need to experiment a bit more to determine what other approaches may be feasible to work around this.\n. A couple more findings...\n- When using this with Carthage, the app will launch and execute as expected if I manually delete libswiftXCTest.dylib from the app bundle after Xcode finishes making the build, however I haven't been able to figure out a way to make this work as part of a standard Xcode Run action\n- I'm intending to file a Radar on swift-stdlib-tool asking for more flexible handling of weakly linked libraries, or some other way to modify the handling of the XCTest support lib\n- Because of these issues, I've lost a lot of confidence in using weak linking as a solution to #144, unfortunately\n. A couple updates:\n- I rebased this against the latest on the swift-2.0 branch\n- I was able to get this working for iOS and Mac apps using Nimble as a Carthage-built framework by adding a post-build scheme action running a script[1] that deletes the copy of libswiftXCTest.dylib that swift-stdlib-tool copies into the bundle. This would only be a requirement for people trying to use Nimble without XCTest.\n- This patch set seems to me to align with @modocache's stated goal of trying to loosen Quick's coupling with XCTest.\n[1]\nrm \"${SWIFT_STDLIB_TOOL_DESTINATION_DIR}/libswiftXCTest.dylib\"\n. @jeffh I've pushed a usage example of this: https://github.com/briancroom/NimbleWithCarthageExample\n. Thanks for bringing up documentation @jeffh. I've added a section to the README indicating how this works.\n. @jeffh I just gave it another try on beta 5 and it seemed to be working. If the script isn't finding the environment variable, maybe check to make sure that you selected the right target in the script's \"Provide build settings from\" dropdown? When working on this, I was putting the following line in the script to see what I had available:\nexport > /tmp/out.txt\nDo you see the expected build settings env vars from that?\n. Hey @jeffh , thanks for that repo. That was useful for testing just now. I just found some time to get this rebased to include the new commits on the swift-2.0 branch. After doing so, I was able to get your example repo working by using the following Podfile:\n```\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'NimbleCocoaPodsExample' do\n  pod 'Nimble', :path => '../TestingTools/Nimble' #:git => 'https://github.com/briancroom/Nimble', :branch => 'weakly-link-xctest'\nend\ntarget 'NimbleCocoaPodsExampleTests' do\n  pod 'Quick', :git => 'https://github.com/Quick/Quick', :tag => 'v0.6.0'\n  pod 'Nimble', :path => '../TestingTools/Nimble' #:git => 'https://github.com/briancroom/Nimble', :branch => 'weakly-link-xctest'\nend\n```\nWhen you get a few minutes, could you take another look?\n. \ud83c\udf89 Thanks @jeffh for seeing this through! Also to @tjarratt for the initial inspiration. \n. This issue is pretty stale now, and I'm not observing the problem. I'm going to close it, but feel free to reopen it @fatuhoku if you are still running into it!\n. I've just pushed a bunch more work to this branch. A couple of workarounds for swift-corelibs-foundation are no longer needed and were removed, plus I've gotten the test suite running on Linux, though not without hacking around a number of issues, most notably the lack of automatic bridging to Foundation types like NSArray and NSNumber.\nThere are a couple dozen failing tests currently. Some are due to swift-corelibs-foundation bugs, many are due to string formatting differences between the platforms. Regardless, this is a big step forward.\n. Thanks @jeffh! It's been fun digging into this so far. I'm expecting to have some time next week to take another pass over this and I'll definitely take your comments into account. \nBecause there are so many changes here and there's a lot of churn on the Linux side right now, in particular around the Foundation and XCTest Corelibs projects, I would suggest we plan on maintaining this branch off master until we get a bit closer to the Swift 3.0 release, when those libs will have their official release. I'm hopeful that several more of these workarounds will become unnecessary as the weeks go by. \n. Hey @jeffh, I just finished going through this entire changeset again, and was able to remove a handful of workarounds that weren't necessary anymore with the latest developer snapshot of the Linux tools. Just a handful of the tests are failing now, generally due to variations in number formatting. \nI generally did keep versions of the NMB* protocols, for now at least, because they are required in some cases for classes provided by Corelibs Foundation to work properly. Theoretically these should gradually become unnecessary as the framework declares better Swift protocol conformance for the various value classes it provides. What do you think about this? Alternatively we could decide to deprioritize robust support for assertions on Foundation classes on Linux, and disable the rest of of the NMB* protocols.\nNow that some of the more unpleasant workarounds have been removed (e.g. the Base class), I would be open to trying to land this into master, especially if other chunks of work will be coming in soon. Nonetheless I do still anticipate that this patch could shrink a bit more as the tools develop further.\n. Another possibility would be for me to try to separate out some of the pieces that should be more stable (e.g. the big directory structure changes) and open a a separate PR to get portions of this in place sooner than later.\n. I'll take a look at getting everything rebased and PRd over the next few days. I tried to be diligent about keeping the commit history clean and focused while working on this so I don't anticipate any major issues. \nCompletely agree about Travis. I got it working nicely for Quick, we should do the same here once the entire suite gets to a passing state. \n. I've rebased everything, as well as opened #235 as the first piece of this. Once the file rearranging is done, that will make it easier for me to open a handful of other PR's to move this forward.\n. Alright, folks. I have opened a slew of PR's that break the rest of this down into slightly more manageable pieces, roughly in order of invasiveness:\n236 #237 #238 #239 #240\nI look forward to continuing discussing these changes in their new homes!\n. That feature from that proposal is now available in the latest Xcode, however it doesn't do much to help with @abbeycode's original feature request.\nSpecifically, the standard library now provides additional overloads of == and the comparison operators that accept tuples as their lhs and rhs arguments, however the tuples themselves aren't made Equatable or Comparable. This means that the new functionality is not automatically made available to Nimble's matchers, and it also means that comparing arrays of tuples hasn't gotten any less painful.\n``` swift\nlet tuple = (1, 2)\ntuple == tuple // This works now!\nexpect(tuple).to(equal(tuple)) // Error: Cannot invoke 'equal' with an argument list of type '(Int, Int)'\nlet tuples = [(1, 2)]\ntuples == tuples // Error: Binary operator '==' cannot be applied to two '[(Int, Int)]' operands\n```\n. I've just realized that the podspec needs updates as a part of this. \nAnd Quick's is currently broken due to https://github.com/Quick/Quick/pull/436 \ud83d\ude33\n. Added a podspec update now.\n. Thanks! I'll be opening some follow-ups shortly.\n. I've rebased and pushed a version that disables toEventually altogether for now.\n. Good feedback, thanks! I'll circle back to this once all the others are in.\n. I've just pushed some updates to this that get the entire test suite passing (minus the disabled test cases) on Linux using the latest development snapshot!\nThere's been no work yet on documentation or Travis CI, but this PR is ready to merge IMO. @jeffh \n. Thanks for the report @ratkins. To verify, you are actually using Xcode 7.3 beta 2, correct?\nThis is because Xcode is now shipping with betas of Swift 2.2, which includes https://github.com/apple/swift/pull/888\n@jeffh it may be necessary to introduce a Swift 2.2 branch to accommodate this breaking change. \n. @jeffh yes, I do believe that I managed to achieve compatibility with those changes :+1: \n. @jeffh were there any outstanding items you were hoping to get in before a release? If it's just a time issue, I'd be more than happy to give it a go myself.\nI had initially been thinking it would make sense to wait until https://github.com/Quick/Nimble/pull/261 could be merged, but now it looks like the next snapshot is going to include breaking changes related to Swift 3, so I'd say let's go for it!\n. Hey @jeffh I got started writing up release notes but realized I don't have pod trunk access to Quick or Nimble. Could you add me as a maintainer there? Thanks!\n. Sorry for the delay, but the release has been made now! Let me know if you have any issues: https://github.com/Quick/Nimble/releases/tag/v3.2.0\n. I'm going to go ahead and close this now that the release is out. Thanks everyone!\n. Hey @NachoSoto, thanks for taking a stab at this. I'm disappointed that nobody (including myself!) realized the ObjC bridging implications while discussing the StaticString change in the XCTest overlay previously. I've left a comment on the PR asking for additional input on this issue.\nAssuming that the change doesn't get reverted, though, does anybody have thoughts on how to work around this change? The only thing I've got so far would be to switch to bypass the Swift overlay and use the Objective-C XCTestCase.recordFailureWithDescription method for the failure reporting. This would require us to be able to reference the currently-running XCTestCase instance, which I believe we could track using XCTestObservationCenter.\n. Hah, disappointment was probably too strong a word. Let's rather call it mild annoyance at being caught off guard by the ramifications of a change that I was involved in :joy:\nAnyway, @NachoSoto and (@ratkins), I'm curious to hear how urgent you feel it is for us to try to get support for Xcode 7.3 beta 2? Even if apple/swift#888 ends up getting reverted (I'm not holding my breath! And I'm not even fully convinced that it should be, at this point), it will be a few weeks until the next beta rolls around.\n. I'm traveling right now and don't have connectivity for my laptop, but I've put s branch together with one approach to resolving this which I hope to push for review tomorrow. (Just a heads up in case anyone was was considering taking a stab at it!)\n. :+1: this is really great. I'm a huge fan of using these kinds of API affordances to let the compiler help users out as much as possible.\nI have a slight preference for the 4th proposed wording, but I think any of the others would do just as well.\n. Thanks for making this happen @jeffh. I'm really hoping to get a chance this week to sort out the Travis configuration to include a Linux job.\n. @jeffh I'm going to go head and merge this and make a couple tweaks on master so I can open a PR with the Linux job for Travis.\n. @abbeycode @morganchen12 I imagine this is the cause of the error: https://github.com/apple/swift/commit/fbd2e4d872d1aa57bfba2ab1f4d280bb1e90cbb8\nI wonder if it would be possible instead to use a C source file to re-export the function under a different name? I'm certain exactly what that would need to look like though. \n. This is a really interesting error happening on CircleCI, @abbeycode. Do you have any theories about what is triggering it? It seems like it could be a race condition between the production of the Nimble-Swift.h header, and the compilation of the .m file that imports it. Unfortunately the CircleCI build failed a second time, even after I kicked it off again.\nI would be hesitant to merge this if it would make our CI builds produce false negatives on a regular basis. I wonder reliability could be improved by manually adding the necessary declarations into CwlCatchBadInstruction.m instead of importing the generated header?\n(I'm really happy to see the progress with this, btw! It will be a pretty killer feature for Nimble.)\n. @bgerstle yes that's correct, although the conditional won't be needed for too much longer. See: https://github.com/apple/swift-corelibs-xctest/pull/40\n. LGTM!\n. Hey @fatuhoku, Nimble's Objective-C matchers only work with objects, so there's no way for them to work directly with NSRange structs. It is, however, possible to use the preprocessor to make this case less cumbersome. For example:\n```\ndefine valueOf(VAL) ({ typeof((VAL)) val = (VAL); [NSValue valueWithBytes:&val objCType:@encode(typeof((VAL)))]; })\nNSRange range = NSMakeRange(3, 5);\nexpect(valueOf(range)).to(equal(valueOf(NSMakeRange(3, 5))));\n```\n. Aaaaaand it's green :smile: \n. Resolved by #264. Thanks @morganchen12!\n. Any feedback on this? @Quick/contributors @rbobbins :grinning: \n. Thanks for one again encouraging me to produce documentation for my work @modocache! I've added the new matcher to the README now.\n. Hey @jeffh sorry for the slow follow up. Yes, this stuff will be needed, but the Swift 3 stdlib naming and importer changes also landed around the same time, so we will need to kick off a swift3 branch and of everything there together. I've started working a branch for this which I'm hoping to push tomorrow. I'd like to see #274 merged first though. \n. Do you think it would be useful to also include the data's byte count in the output?\n. I like the first one, myself!\n. Oh shoot, that's unfortunate. There are a number of places where we have introduced conditionals for Linux behavior already, and it seems reasonable to me to do so here as well. Please do leave a comment indicating the reason for it so that it is easier to try again in a few weeks/months and see if the issue has been fixed. \nIt'd be great if you could log an issue in bugs.swift.org as well!\n. Hey @szweier! Thanks for reporting this issue. Sorry to hear that you're having trouble. When you get a chance, could you provide some additional details about your environment and the behavior you are observing? Here are some particular items that are likely to be useful. I would like to understand what the differences are between your setup and what we have running on CI where the tests for this matcher are passing.\n. Nice @humblehacker! Could you add an assertion to the unit tests that uses the beEmpty matcher with an NSIndexSet instance? That will help ensure that this conformance doesn't get inadvertently lost in the future. With that, if you could squash the commits I would be happy to merge this!\n. LGTM! Thanks for the PR @humblehacker and sorry for the delay getting back to this.\n. Cool, thanks @phatblat for putting this together! (also thanks @younata for your previous work on this)\nSince Xcode 7.3 is out of beta now, I think it would make sense to merge this into master, even though it contains breaking changes. Users who need to stick with earlier Swift versions can continue using the previous releases, and the next release which includes these changes can be 4.0, bumping the version major number. Does that seem right, @jeffh?\n. Yeah.. unfortunately the CurrentTestCaseTracker was the least-bad workaround that I could produce for the StaticString issue, since we have to stick with String on Apple platforms to maintain Objective-C support. Some context is here. (It's worth noting, though, that StaticString may not be around forever. See Joe Groff's comment)\nThis morning @idoru and I spent some time thinking about approaches to this issue for Cedar which was experiencing the exact same issue. The best solution we came up with is effectively the same thing that @phatblat is proposing here, with the slight adjustment that we swizzled both -_addLegacyTestObserver: and the normal -addTestObserver: in hopes of reducing the chance of breakage with future Xcode versions. It's not a very satisfying solution, but it seems to do the job.\nRegarding additional XCTest framework hooks, it is possible for spec bundles to use the NSPrincipalClass key in their Info.plist to specify a class which will be instantiated before tests begin to execute. This is an officially supported hook for adding test observers. This isn't a great solution though either because it requires users of Nimble to perform additional setup steps before the framework can be used.\n. \ud83d\udc4d thanks for fixing this up @jeffh!\n. @atillman @kevinmcconnell Could you try this again with Nimble 4.0.0 or the latest master and report whether you are still seeing this? I have been unable to reproduce it locally and am hoping it may be behind us now. \n. Wow, this looks really great @norio-nomura! I'm especially impressed that you were able to achieve such good 2.2-3.0 compatibility. Could you rebase this when you get a chance?\n. Hi @norio-nomura, I'm sorry that there's been so little activity around here for so long.\nI'm inclined to say that we're best off introducing a swift3 branch for this for now, since the development snapshots are such a fast-moving target at this point and I feel like there's going to be a good bit of churn needed here to keep up. I would tentatively suggest that we could put this on master and do lightweight maintenance of a swift2.2 branch around WWDC-time, when official Swift 3 beta releases will presumably start to be pushed out.\nThoughts @norio-nomura @Quick/contributors?\n. In light of the comments on this PR, this discussion, and the evidence of the complexity of supporting 2.2 and 3 simultaneously as linked to above, I'm pretty convinced at this point that branching is required here. Additionally, I feel that the swift3 branch will need to track the development snapshots pretty closely for the next while, as breaking changes continue to roll in. Given all that, I don't think there is much value in keeping the Swift3to22.swift shim in this PR.\n@norio-nomura how would you feel about updating this to work with swift-DEVELOPMENT-SNAPSHOT-2016-04-25? I think we can use this as a start of a swift3 branch at that point.\n. Hmm, I wonder how feasible it would be to download and install a toolchain package until Travis starts getting Xcode betas that include a Swift 3 toolchain? Even if we decide not to do that, the Linux CI should still Just Work here, as it is already downloading and installing the specified dev snapshot.\n. That looks worth trying to me!\n. Hey @phatblat, thanks for moving forward with this! I'm left some comments on the implementation but I'm fine with the fundamental approach, as the least-evil solution we have available to us at this point in time.\nI'd love to hear input from @jeffh though, with his extensive experience monkey-patching ObjC. \n. Cool, yeah this looks good. Sorry to nit, but would you mind squashing the commits @phatblat? Then go ahead and hit the button, I'd say. I was hoping I could do the squash myself but it looks like that isn't enabled for this repo. @modocache I think you or another admin would have to turn this on?\n. Aha, that explains it. Glad to see this fix go in. Thanks @phatblat!\n. It seems to me that this kind of assertion should be used very rarely, if ever, because it would have such a negative effect on the speed of the test suite. That being said, you could do this to achieve something similar:\nswift\nvar a = 0\nNSRunLoop.currentRunLoop().runUntilDate(NSDate(timeIntervalSinceNow: 1))\nexpect(a).to(equal(0))\nThis wouldn't poll the expression periodically, however I see relatively little value in doing that because it would only cut the time short when the test is failing, which is hopefully not a state you are in very often!\n. If you are feeling the need to slim down tests like this, I'd suggest throwing in a custom matcher that lets you be more specific with the assertion. Something like this:\nswift\nfunc equalNames(expectedNames: [String]) -> NonNilMatcherFunc<[NSNotification]> {\n    return NonNilMatcherFunc { actualExpression, failureMessage in\n        failureMessage.postfixMessage = \"equal names <\\(stringify(expectedNames))>\"\n        guard let actualValue = try actualExpression.evaluate() else { return false }\n        return actualValue.map({ $0.name }) == expectedNames\n    }\n}\nwhich would let you write the test this way:\nswift\nfunc testPassesWhenExpectedNotificationIsPosted() {\n    expect {\n        self.notificationCenter.postNotification(NSNotification(name: \"Foo\", object: nil))\n    }.to(postNotifications(equalNames([\"Foo\"]), fromNotificationCenter: notificationCenter))\n}\nHope this helps!\n. Yes! Let's get this release out. I used the script with great success last time around. I'd be happy to do it again, but I do think it's important that all the contributors have experience doing this, so I'll let either of you have a chance at it first \ud83d\ude47 \n. Thanks so much @ashfurrow! \ud83d\udc4f \n. Very cool! Great ideas @ashfurrow. The only thing I'm wondering about is whether it might make more sense to just skip deleting the release notes file altogether. I'm not convinced that doing so might not be more destructive than its worth. Thoughts?\n. Related: https://github.com/Quick/Quick/issues/238\n. Agreed. We should reconsider this once Swift 3 brings ABI compatibility, which should theoretically make binary distributions of Swift frameworks feasible.\n. Looks great! Thanks @ashfurrow. \n. Strange, I don't remember having seen that test be flaky before. Anyway I restarted the job and it passed, so :tada: \nThanks @ashfurrow!\n. I'm hoping to take a closer look at this today or tomorrow.\nAt first glance, one thing that may speak against the NilLiteralConvertible conformance is the fact that none of the newly-added tests were able to take advantage of it, apparently? I don't have a clear understanding yet of the situations where it can and can't be used just yet.\n. Hey @morganchen12! Thanks for taking this to the next level. If we are going to go down this path, I agree that we should go all the way and change both the operator == and the normal equal matcher together.\nI'm hoping that we can get some feedback on the impact that this change will have on one or more large codebases (@ashfurrow would Eidolon be a good candidate for this, do you think?) While it is normally a very good thing to take advantage of Swift's type system to trigger compile-time failures instead of run-time failures, I see two potential drawbacks to this change:\n1. We lose out on some discoverability of the beNil matcher, because the compiler's diagnostics won't direct users to it the way that the current failure messages do. I could see this being detrimental for new users trying to learn the framework.\n2. I consider it important that Nimble make it easy for people to right tests that don't require explicit conditionals (leads to difficult-to-follow tests) or potentially risky force-unwraps (leads to crashy test suites). \nDespite these issues, I think I'm in favor of merging this PR to simplify Nimble's equality model a bit. Intuitively, I feel that it should be rare to have optionals as the expected value of the equal matcher, but I would prefer to gather some evidence for that before we make a change that could harm the UX of the framework.\nI'd love to hear your thoughts @Quick/contributors ! \ud83d\ude00 \n. Thanks for your input @sharplet! I completely agree with comments. Note, however, that the proposed change is to remove optionality from the equal matcher, not from the expect function. That is, the actual value would remain optional, which is the key point you are getting with your example. \nAre there situations where you would find an optional expected value useful?\n. > Side note: I can't believe it's 2016 and computers still can't just do this for us\nFile a radar? \ud83d\ude00\nI made this change for Quick now also (https://github.com/Quick/Quick/commit/f17f19431a645955fb7d97fb2f201684d228bb6b)\n. Awesome!\n. \ud83d\udc4d to @ashfurrow's comment. See also: https://github.com/Quick/Nimble/issues/281\n. @Ben-G Thanks a lot for taking the time to open this discussion and put the PR together! I think there can be a lot of value in these kinds of micro-optimizations, and the screenshots you posted in #308 sure do illustrate the issue well.\nI do have some concern about simply dropping the mored detailed information altogether. When I'm looking at the console output of a failed CI run, I almost always wish for more data about the failure rather than less! \ud83d\ude00 I think I'd rather see Nimble move in the direction of having a shorter failure of the summary as the first line, and including extra details afterwards. A little experimentation seems to indicate that the inline failure highlights in the Xcode source editor only include the first line of the message, with the rest available either in the console log, or test build log.\nWhat if we were to introduce the concept of \"extra details\" to the FailureMessage type which would be appended on a separate line when recording the failure. The haveCount message could then look something like:\nexpected to have Array<Int> with count 1, got 3\nActual value: [1, 2, 3]\n. Calling all @Quick/contributors :grinning: \n. I don't have a lot of context on the motivation for stripping newlines, but I'd wager that it is to help prevent failure messages from bloating too much when they contain descriptions of expected and actual values which are formatted to take a lot of vertical space. I've found it's easy to lose track of the failure message itself when the value descriptions are too overwhelming.\nMy thought here is that we should introduce a new optional String property on FailureMessage (extendedMessage or similar, perhaps?), which would get appended to the final string after a newline. How does that sound?\n. I feel pretty good about this! Thanks for sticking with it @Ben-G\nThe Linux CI failure is because NSHashTable isn't available in Corelibs-Foundation. Could you wrap that entry in the switch with a #if _runtime(_ObjC) conditional?\n. Excellent! Having seen no dissent to this approach in the last days, I'm really happy to merge this! Thanks again for this well thought-through contribution @Ben-G \n. Can you provide some additional details about your environment? Is this with a Nimble release, or master? It looks like you're using Cocoapods - which version are you running?\n. Git is just being tricksy here - this file was actually just moved!\n. Ah hmm, looking at this now it seems that there's no good reason for that change. At one point I remember I was trying to chain a function call on the collection before an all and that's why I tried changing it. That usage didn't survive, obviously.\nWhich way do you prefer? Free function or protocol extension? Regardless, we don't need both, you're right.\n. I've opted for the protocol extension since it lines up with how the stdlib evolved into Swift 2. Also rebased!\n. Excellent point. When I was first hacking on this I was looking for the smallest change set that would satisfy the compiler, but you're right that non-functional features should be entirely unavailable.\n. Good idea. Done!\n. Swift globals are always lazily initialized. Should we be referencing this somewhere where we are certain to be on the main thread to ensure that this works as expected?\n. This test class should also be added to the XCTMain invocation in Sources/NimbleTests/main.swift\n. Could you add the NMB_ prefix on here too? Or alternatively, turn it into a free function. \n. Dispatching isn't really needed here since the runtime provides the single-execution guarantee for the load method already. \n. We should be using dispatch_once here and below though! To ensure our observer is only added once regardless how many times Apple and others add observers. \n. You included Legacy in this method call - copy/paste I presume. \n. I think this also needs to be calling NMB_original_addTestObserver to avoid recursion. \n. ",
    "tjarratt": "Thanks for sharing your thoughts, @jeffh. I share the same feelings about runtime magic and want to preserve the existing use-case for 99.999999% of Nimble users.\nI'll have to take a look at what Weak Linking against XCTest would look like from Swift, since that sounds like the best option, although my gut tells me that option 3 (breaking out a \"Nimble-core\", and keeping the existing Nimble integrated with XCTest) will probably be the most likely to succeed, given what I know about XCTest today.\n. This is really awesome! It looks like the build failed because CircleCI doesn't support the latest swift compiler (but I'm not 100% sure).\n. Is this something that is still considered valuable? I noticed that this was in the blocked part of the prioritization project\n@Rivukis would you want a second set of eyes looking at the Xcode 8 job failure on Travis? It also seems like this needs to be rebased on top of master... Are there any other outstanding items?\nI'm asking because I was starting to write a Nimble matcher to do exactly this and remembered that I had stopped a year ago because it looked like this PR was going to get merged in. Chiming in now to see how I could help out, since I'd love to be able to use this in my projects.. Seems like we'd need a redesigned Matcher API in order to accomplish Argument checking behavior (not) being based on stringification -- ie: we want Nimble matchers to be able to compose other nimble matchers. The current Matcher protocol, with the associated type seems to makes it impossible to, say, have an array of Matcher that one would use to verify arguments to a method.\ne.g.:\nswift\nexpect(myFake).to(haveReceived(\"aMethod(withAnInt:andAnotherInt:)\").with(equal(5), beLessThan(8)))\nFor what it's worth, I've spent a fair amount of time writing and testing to manual mocks, and have found the assertion writing to be very tedious. It would be nice to have a matcher that could verify this behavior without \nIs this yet another reason why you opened that PR, @jeffh?. ",
    "stigi": "The readme still mentions #27 :\n\n\nIn Swift contain takes any number of arguments. The expectation\n  passes if all of them are members of the collection. In Objective-C,\n  contain only takes one argument for now.\n\n\nShall we just remove that note?\n. ",
    "dduan": "@ikesyo \nYes, import Foundation is in in those files, but Foundation gets \"imported\" regardless of the fact. For example, ObjCExpectation.swift currently includes a bunch of objects from Foundation, but import Foundation is never present in this source file.\nI have listed the benefit as number 3 of the PR description.\nYes, as you have pointed out, some Foundation objects are being used in these files, therefore their code can not be compiled when Foundation is unavailable. However, a good amount of the code can. There's an aesthetics argument to be made for keeping import Foundation in the former, but it stops at aesthetics.\nI'd like to see Nimble being used on Linux a few months. For now, I'll close this PR.\n. ",
    "abbeycode": "This would be super useful!\n. I'm taking a look at implementing this. Should the pull request go to the swift-2.0 branch?\n. I'm hitting a need for this too now. +1\n. I tried this out in my own code, and it did the trick:\nSwift\nextension NSDate: NMBDoubleConvertible {\n    public var doubleValue: CDouble {\n        get {\n            return self.timeIntervalSinceReferenceDate\n        }\n    }\n}\n. I committed a solution, but I wish the reported failure had formatted dates, instead of the opaque NSTimeInterval:\n\nexpected to not be close to <462296591.0000> (within 10.0000), got <462296580.0000>\n\nWhat's the easiest way to achieve that? Should I overload the beCloseTo matcher with explicit date support that formats the message appropriately?\n. Ah, that makes sense. I'll look into it (and make sure I include the fractional seconds)\n. Let me know what you think! The one thing I'm not totally happy with is that I had to repeat the double formatting. Do you have a suggestion for that?\n. These commits should address each issue you pointed out.\n. Do you have an ETA on a new CocoaPods release? It looks like 2.0.0-rc.2 doesn't include this change.\n. It looks like this is coming in Swift 2.2: https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md\n. I started looking into how fatalError() is implemented. This is what I found:\nswift/stdlib/public/core/Assert.swift:137:\nswift\n/// Unconditionally print a `message` and stop execution.\n@_transparent @noreturn\npublic func fatalError(\n  @autoclosure message: () -> String = String(),\n  file: StaticString = __FILE__, line: UInt = __LINE__\n) {\n  _assertionFailed(\"fatal error\", message(), file, line)\n}\n_assertionFailed(...) is defined in swift/stdlib/public/core/AssertCommon.swift:115:\nswift\n/// This function should be used only in the implementation of user-level\n/// assertions.\n///\n/// This function should not be inlined because it is cold and it inlining just\n/// bloats code.\n@noreturn @inline(never)\n@_semantics(\"stdlib_binary_only\")\nfunc _assertionFailed(\n  prefix: StaticString, _ message: String,\n  _ file: StaticString, _ line: UInt\n) {\n  // ...\n  // Writes out the message in a safe way\n  // ...\n  Builtin.int_trap()\n}\nI can't see where int_trap() is defined, though, and how we might be able to intercept it.\n. I thought I had something...\n\n. I've been working on incorporating the solution proposed in a Stack Overflow answer, but need some guidance.\nThe problem is that it's a two-part solution. The first part overrides fatalError() in client code, in a way that unit tests can swap out the implementation. I don't believe Nimble currently has any component meant to be linked into a client project though, correct? Would a solution that required that be out of bounds?\nYou would basically need to compile a single Swift file into the client code. I'm not sure how we would approach packaging this type of change for distribution.\n. @morganchen12 That's awesome. I'm beginning to implement a solution using Matt's code now.\n. Would it be preferrable to use Matt's code as a submodule, or to copy/appropriate it?\n. I made a pull request to implement this, when someone has a chance to take a look! I've got some issues and questions.\n. Can someone please help me to investigate what's going on with the Circle build? It seems like it's having problems with the nested #if statements in ThrowAssertion.swift, but the Travis builds are running fine.\n. After removing the tvOS checks from the code, Circle is now failing in ThrowAssertionTest.swift, which only has one #if statement. How is Circle configured differently than Travis?\nAlso, it seems that -[PostNotificationTest testPassesWhenExpectedNotificationEventuallyIsPosted()] fails intermittently. Is this a known issue with that test? I didn't make any changes that should have affected it.\n. @modocache @jeffh I'd love your feedback when you have a chance!\n. @jeffh I switched the CwlPreconditionTesting over from submodule to static inclusion, and I included instructions regarding the necessary compiler conditionals to include to avoid the fatalError() for non-x86_64 targets (it doesn't look like Swift currently has any notion of compiler assertions, though, so this has to remain a runtime assertion).\nI didn't understand your suggestion to use @asm(mach_msg) for tvOS compatibility. How is that supposed to work?\nAlso, I'm bewildered by the continuing Circle and Travis build failures. Could you please take a look?\n. @jeffh Please let me know how to fix the build failures when you have a chance.\n. @jeffh Thanks for the explanation; I now understand what the @asm attribute is, and how to use it. I'm not sure I follow how it helps with the question I asked, though:\n\nAre we okay shipping with tvOS support based on POSIX signals? This means that tvOS schemes will have to turn off the Debug executable setting in their Test configuration. @mattgallagher and I discussed this in Issue #3 of his repo\n\nWould the approach you described allow tvOS to use the primary mach-based approach, instead of relying on the POSIX approach?\n. @jeffh I'm trying out the @asm attribute, but it's not working (in Xcode 7.2 or 7.3b5). Both are giving me this error:\n\nUnknown attribute 'asm'\n\nIs there any import or compiler flag I'm missing or something? Also, looking at the mach_msg definition in message.h, I see a __TVOS_PROHIBITED annotation. Even if we get @asm to compile, won't that be a problem? Or are you saying that it prevents compilation, but the function will still be there are runtime?\n. @morganchen12 I get the same thing (in Xcode 7.3b5):\n\nUnknown attribute 'asmname'\n. @briancroom @morganchen12 @jeffh Some questions, in light of the discussion above:\n1. Are we sure, before taking the time to try getting that to work, that mach_msg is definitely available in tvOS's runtime? It would suck to make it callable, then find out that it's disallowed because it's not there\n2. Is hacking around compile-time limitations the best approach to solving this? I have it working now using POSIX signals instead of mach messages, and it works. It just has the slight drawback that for tvOS targets using the new call, they would need to turn off a single scheme option (Debug executable)\n3. If we go with the POSIX approach, though, I would need to figure out how to get the SPM packaging to work, since each approach uses an alternate implementation of BadInstructionException. In the Xcode project, there's no problem, as CwlCatchBadInstruction.(h/m/swift) belong only to the OS X and iOS targets and CwlCatchBadInstructionPOSIX.swift belongs to only tvOS, but I don't see a way to exclude certain source files from SPM\n4. Given 2 and 3 above, are we better off perhaps leaving out tvOS support altogether for this feature, creating a separate issue to add it later?\n. Alright, I removed tvOS and Swift Package Manager support, and got the build (mostly) fixed. The single build error that's showing up on Circle now is one that comes up intermittently in Xcode as well, and can always be fixed by a clean/rebuild.\n. @briancroom I was thinking along the same lines as you are, and agree it's a little risky introducing that kind of instability. It looks like it may have cleared up on Circle, though. There was a successful build before I pushed (not sure how that one was triggered), and the latest build succeeded. but now the iOS build on Travis has failed. Argh.\n\nRegarding the workaround you proposed, I was trying to leave the CwlPreconditionTesting sources unmodified, which is the only reason I'm hesitant. It would make it easier and less error prone in the future to just dump the latest files wholesale, instead of doing a diff to make sure we keep any modifications.\n. Ok, I also created an issue on the CwlPreconditionTesting project, in case @mattgallagher has any ideas.\n. Should we file a Swift bug?\n. @jeffh Thinking about it more, is it because it's building for arm and x86 at the same time, and the arm build is failing? It may not be a bug in Swift at all, then, and the right answer is what you suggested earlier: make sure it builds for all architectures, but have it fail at runtime for non-x86.\n. @ashfurrow Good point.\n@briancroom Thanks for that link. I liked your suggestion on that thread:\nNSRunLoop.currentRunLoop().runUntilDate(NSDate(timeIntervalSinceNow: 1))\n. @ikesyo Yes, sorry, I added the #if I'm using to the issue. @jeffh It could be related. I'll see if that PR fixes it.\n. Sounds good. Do you plan to cut a release soon?. @jeffh Is there anything I can do to help track this down, and maybe start working on a fix?. I've added some updates. Specifically, I'm seeing this locally too (as well as still in my Bot builds), and I've updated Xcode, Nimble, CocoaPods, and macOS. Still seeing this.. Good call, I didn't think of doing it in a closure like that.\n. ",
    "romankl": "PR #163 added this macro.\n. @jeffh could you take a look at it, please?\n. Ah the unit tests, sorry. \nShall I submit a back port for the swift 1.2 branch? (Just to keep the API equal across the versions) \n. Yep, sorry - missed it :/ I've corrected it in a new PR.\n. Hi @akhilsuri, bitcode should be disabled since d551d29, but it's not released using cocoa pods. You could include the nimble/ quick branch swift-2.0 branch as a sub module to get rid of the error. \n@jeffh  time for a new rc? \n. ",
    "ratkins": "I would think a Nimble-specific overload would be safer?\n. (ja, sorry\u20147.3)\n. My situation is, I want to try running our suite under 7.3b2 so I can tell if it fixes other (Xcode) bugs that are causing our CI to fail\u2014so I can feed that back in to the 7.3 beta. But at the same time I need to keep our master branch 7.2 compatible so we can release through TestFlight. I'm not sure what the best approach to this would be for us (with the added constraint that I'm only going to be on the project for another week, before sending the client home with whatever path forward I can come up with.)\n. ",
    "fatuhoku": ":+1: \n. No this is Xcode 6. I use Cocoapods.\n. @jeffh I'm pretty sure I tried cleaning and rebuilding before writing this issue. The error exists only for Nimble repeatedly, and not other modules if I remember. It's been a while since I've had the need to use Quick+Nimble.\n. ",
    "brentleyjones": "Is this Xcode 7? I've noticed it in Xcode 7, in my Swift tests. If I move a different module above it, like the module I'm testing, it errors there instead.\n. Also, I don't use CocoaPods, I have Nimble in my workspace as a project.\n. \n. It does support more than 2 platforms per target, as of 0.9.0. The called it \"universal framework support\". \n. 0.9: https://github.com/Carthage/Carthage/releases/tag/0.9\nhttps://github.com/Carthage/Carthage/pull/622\n. Glad to hear. I was pretty sure it worked once. \n. I'm also seeing it, with Xcode 7.2:\nconsole\nld: '/Applications/Xcode-7.2.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE) or obtain an updated library from the vendor for architecture arm64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. ",
    "tomomura": "I face same problem.\nAlso, I use Xcode6 and CocoaPods.\n. ",
    "programmerdave": "I got it to sort of work by setting the EMBEDDED_CONTENT_CONTAINS_SWIFT to YES directly on the Pod Target for Nimble. @fatuhoku  Can you try that?\n. ",
    "appleios": "I've tried setting EMBEDDED_CONTENT_CONTAINS_SWIFT to YES, but it doesn't solve the problem. \nBut after updating to ver3.0.0 issue was no longer there.\n. ",
    "deemadden": "Closed #164 as I had inadvertently created a duplicate.  Apologies for that.\n. Thanks for this @jeffh .  Nice to see you in the group here, @zbeckman !  Hope you are doing well.\n. ",
    "taiheng": "For some reason the location of the XCTest.framework has moved in Xcode 7 betas from the old path at\n/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk/Developer/Library/Frameworks\nto\n/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks\nIt's possible to fix this temporarily until the framework paths are updated in the project by creating a symbolic link to the new path in terminal:\ncd /Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk\nmkdir -p Developer/Library\ncd Developer/Library\nln -s ../../../../Library/Frameworks/ Frameworks\nI'm not sure if this is a permanent change or not and am hesitant to create a pull request correcting the path.\n. I don't see this issue in cocoapods on swift-2.0 branch. I've fixed it for carthage builds in quick/nimble#185. \n. ",
    "AnthonyMDev": "@taiheng Since this seems to be the case now, after the GM Release, I'm willing to bet the change is permanent.\n. Really? I'm still seeing this issue on the GM release with 2.0.0-rc3. Maybe they have fixed it since rc3\n. After some further research, I believe this is fixed in 4e6b23e. But, that commit was made after 2.0.0-rc.3\u00a0was released. When we get release candidate 4, this should be working fine.\n. When is a new version going to be released with the xcode7.1 branch merged?\n. I would really like to see this happen soon. I'm having to depend directly on the master branch from all my pod files right now.\n. ",
    "deju": "@taiheng  It works for me.\n. ",
    "akhilsuri": "@jeffh Need help\n. @romankl Thanks for update.\n. @jeffh Thanks for replying, Nimble has build issues on Xcode 7 beta6 as I checked on them yesterday. Will be looking forward for a new release. This issue was related to simulator on my system. Re-install of few things solved the issue. I am closing the ticket now.\nThanks\n. @jeffh The build is not executing when I try to build the app on iphone 6 iOS 8.2 for debugging. It is throwing the same error as stated above. Reopening the ticket and will wait for new release. Thanks \n. ",
    "c0diq": "It's still an issue for Carthage. Why is Bitcode not simply disabled at the project level?\n. ah thanks!\n. Not sure why but I can't bring Nimble with Carthage 0.16.2. Getting \n```\n=== CLEAN TARGET Nimble-tvOS OF PROJECT Nimble WITH CONFIGURATION Release ===\nCheck dependencies\ntarget 'Nimble-tvOS' has bitcode disabled (ENABLE_BITCODE = NO), but it is required for the 'appletvos' platform\n CLEAN FAILED \n```\n. Could we get a new release to get this fix please?. ",
    "angerman": "Ok. Sorry for not being clear. Let's assume the following code: (basically building a bunch of product and sum types)\n```\nenum E1 {\n    case E1A, E1B, E1C, E1D\n}\nenum E2 {\n    case E2A, E2B\n}\nstruct A {\n    var e1 : E1\n    var e2 : E2\n}\nstruct B {\n    var e1 : E1\n}\nstruct C {\n    var s1 : A\n    var s2 : B\n    var e2 : E2\n}\nlet c1 = C(s1: A(e1: .E1A, e2: .E2B), s2: B(e1: .E1D), e2: .E2B)\nlet c2 = C(s1: A(e1: .E1B, e2: .E2B), s2: B(e1: .E1A), e2: .E2A)\n```\nnow, I'd like to create an equality matcher == for C. So I can run\nexpect(c1) == c2.\nWithin the matcher I'd basically prefer to say:\nexpect(expectedValue.s1) == actualValue.s1\nexpect(expectedValue.s2) == actualValue.s2\nin the equality matcher for A, I'd like to say:\nexpect(expectedValue.e1) == actualValue.e1\nexpect(expectedValue.e2) == actualValue.e2\nand so on. \ne.g. basically breaking down the equality of the structure recursively\ninto each part, but still be able to write at a high level: expect(c1) == c2 and then have that fail.\nBest case would obviously be if one could hand down the actual compared name, to produce something like a keypath in the failure.\nI'm just not sure how to this could be implemented.\nHope this makes more explanation makes it clearer.\n. I did write a matcher similar to the following:\npublic func equalC(expectedValue: C) -> NonNilMatcherFunc<C> {\n    return NonNilMatcherFunc { actualExpression, failureMessage in\n        if let actualValue = try actualExpression.evaluate() {\n             // Ideally I'd like to write:\n             //   expect(expectedValue.e2) == actualValue.e2 // given that E2 implementes Equatable.\n             //\n             // right now the only option I see is:\n             if !(expectedValue.e2 == actualValue.e2) {\n                 failureMessage.postfixMessage = \"expected e2 to match: <\\(expectedValue.e2)>, got <\\(actualValue.e2)>\"\n             }\n             // more structural equality tests here...\n        }\n    }\n}\nIdieally I'd write the tests the other way around. So that I have equality matcher for each leaf, and can compose them to build up a matcher for the whole structure.\nWhat I fail to see is how one would compose matchers.\n. ",
    "bhawna08": "Thanks jeffh, i got succeed in fetching the value from static text, by setting accessibility value of labels and alerts:)\n. ",
    "nickygerritsen": "@brentleyjones: this seems to have broken Carthage builds completely. Carthage does not expect more than two supported platforms per target.\nOther projects just create a new scheme for tvOS instead of reusing the iOS version.\nIs there a reason you did not do that here or is it better that we try to convince the Carthage guys that they support more platforms per target?\n. Hmmm I swear I tested with 0.9.1. Will check it out later today\n. @brentleyjones: so if I have a Cartfile containing:\nruby\ngithub \"Quick/Nimble\" \"master\"\nAnd my Carthage version:\nbash\n$ carthage version\n0.9.1\nThen when I run\nbash\n$ carthage update --platform ios\nI get:\n``` bash\ncarthage update --platform ios                 \n Fetching Nimble\n Checking out Nimble at \"70b901e55bad427d211b93586a83e0e3bca32034\"\n xcodebuild output can be found in /var/folders/ml/m9ry2pvd58j86jy3v6pycmfw0000gn/T/carthage-xcodebuild.3pTME0.log\n Building scheme \"Nimble-iOS\" in Nimble.xcodeproj\nfatal error: SDK count 4 in scheme Nimble-iOS is not supported: file /Users/mdiep/Repositories/Carthage/Carthage/Source/CarthageKit/Xcode.swift, line 959\nCaught signal triggered by the Swift runtime!\nIllegal instruction: 4\n(etc.)\n```\nThe same when I use --platform tvos. For you it does work? Because then I wonder what I'm doing wrong :(\n. OK this seems to be fixed in 0.9.2, so I'll try this again soon :)\n. So what's the best way to this right now? Not use Carthage for Quick and Nimble? Any suggestions here?\n. ",
    "keith": "No problem! Thanks!\n. Is there going to be a new release including this change?\n. ",
    "aexmachina": "Yes, still happening when I specify master. I'm running Xcode 7.0:\n$ cat Cartfile | grep Nimble\ngithub \"Quick/Nimble\" \"master\"\n$ carthage version\n0.8.0\n$ carthage update --platform iOS | pbcopy\n...\nThe following build commands failed:\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Matchers/BeCloseTo.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Wrappers/MatcherFunc.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Expectation.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Adapters/NimbleXCTestHandler.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Utils/Stringers.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Utils/SourceLocation.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Matchers/BeLessThanOrEqual.swift\n    CompileSwift normal arm64 /Users/simonwade/dev/Workspace/nxgen-ios/Carthage/Checkouts/Nimble/Nimble/Adapters/AssertionDispatcher.swift\n    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler\n(9 failures)\nSee this gist for full output.\n. Thanks for responding. We've just switched to using CocoaPods for these dependencies, so this isn't a priority for me any more. Happy to help though.\nHere's the output of running NATs:\n$ rake\n-> Testing iOS-Cocoapods\n   OK\n-> Testing iOS-Carthage\n   OK\n-> Testing OSX-Carthage\n   OK\n-> Testing OSX-Cocoapods\n   OK\nThe project does build without Nimble (if we remove the code that uses it). Not sure what you mean by \"when you use the Darwin module\".\n. FWIW I eventually resolved this issue using these instructions to scorched-earth nuke Xcode. Go figure.\n. No I think the issue was caused by some bizarre issue with the Xcode install on my machine. Now that I've nuked all my Xcodes, restarted and reinstalled it's all working again.\n. ",
    "hectormatos2011": "I'm not terribly sure what this issue could be but I've had these Darwin errors before in one of my projects. It may not be related to Nimble but are there any Swift Scripts ANYWHERE in your project @aexmachina? \n. ^^^This is also in any pods, run script build phases, maybe Carthage uses them (dunno I've never used Carthage)\n. ",
    "ScottRobbins": "Created a PR with tests\n. Huh, hadn't tried doing that before. I'll have to think about if there's a good way to have the functionality of both. Any suggestions?\n. ",
    "yoichitgy": "I sent a similar pull request to Quick:\nhttps://github.com/Quick/Quick/pull/404\nIf the gitignore for Nimble should be formatted in the same way as that of Quick, I will format it and send a pull request again.\n. You can get more information with --verbose option to carthage command to solve the problem or to get help.\n. PR #210 has more info.\nI see the same issue, and so far, I use the zipped binaries attached to the latest release.\n. ",
    "jschmid": "Oh right...  Thanks @jeffh \nWould be be interested in a PR adding this matcher?\n. ",
    "nanoxd": "Upon further digging, the error stems from having bit code disabled for the tvOS slice. \n\nThe interesting part is that I'm not building all platforms (using carthage update --platform iOS) but the Supported Platforms contains references to the Apple TV\n\n. ",
    "eimantas": "I've forked quick/Nimble and updated the settings and the code base to compile under Xcode 7.1. You can check it out at walkingsmarts/Nimble (same branch: xcode7.1)\n. ",
    "RohanNagar": "+1 to this issue. This is currently broken for me and I can't run my tests :(\n. @jeffh Appreciate it, everything seems to be working after the upgrade.\n. ",
    "rhysforyou": "It seems like we should probably add a target to build for tvOS, though I'm not sure if that needs to be done as part of this PR.\n. ",
    "leepfrog": "No problem!  Sorry, didn't see this til just now!\n. ",
    "NachoSoto": "Yeah I'm seeing this too:\nld: '/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE) or obtain an updated library from the vendor for architecture arm64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nI think removing arm64 makes sense: if XCTest does not contain bitcode at the moment, there is no way to run tests on an Apple TV.\n. Thanks guys! There's definitely no rush for this beta. I just usually like to get a head start to find things like this (or like many other bad things I've found over the years \ud83d\ude05).\nI think we should consider this important, otherwise I can already see a 7.3 GM with this bug that would mean Nimble can't support Objective-C anymore, or that compromises have to be made :P\n. Continued in #244.\n. > This build on top of @NachoSoto's work in #243 (Sorry I'm not sure if there's a better way to do this besides opening a new PR like I am here!)\nYeah this is fine, thank you!\nThis makes sense! :shipit:\n. I pushed the necessary changes for beta 2 here: https://github.com/norio-nomura/Nimble/pull/2/files :)\n. Awesome, thanks for getting this started! Let me know if I can do anything to help.\n. \ud83d\udc4f\ud83c\udffb\n. Any chance you could make a release with this fix? \ud83d\ude4f . Maybe make this class final since it's not meant to be subclassed?\n. ",
    "LukeDefeo": "Yeah I managed to fix it with no-use-binaries flag. I guess that means there's something up with your pre cooked binary \n. Yeah all good thank you \n. ",
    "DenTelezhkin": "I want to be able to test on simulator of course.\nBasically, framework does not build when running carthage update, but build succeeds if i take Nimble.xcodeproj and drop it into my project.\n. > I think Nimble should also be able to attach pre-built frameworks to its GitHub releases for Carthage to use. If the tvOS framework included there doesn't have a device slice, then I think things will work.\nI don't think it's a good idea to make prebuilt frameworks until Swift 3.0 is released and is ABI-stable, Apple recommends against it.\nI was able to use Nimble from Carthage by using submodules, and including Nimble xcodeproj in my xcodeproj, thus building from source.\nSo,\ncarthage update --use-submodules --no-use-binaries\ncommand will fail, however it will successfully fetch all required dependencies. After initial install, I use\ncarthage checkout\nOr update submodules to fetch latest source. It seems like an Apple stuff that needs to be fixed by including bitcode for tvOS.\n. @ikesyo You are right, I updated my original message for clarity. But still, I think it's a good improvement for development, and one that does not cost anything at the moment.. Yeah, I agree) Basically, this had value for the last year and still has value prior to this fall when Xcode 10 will be released, but i guess there's no reason to merge this now, it's better to transition to incremental mode.. Hey! This is also related to PR I did a while ago - #489, that may improve build times even more.. ",
    "Danappelxx": "It's not working for me for TVOS either. Right now I'm just appending --platform macosx,ios to the end of the invocation, but it feels dirty.\n. ",
    "mdiep": "Here's a summary of the current status:\n- tvOS requires bitcode\n- XCTest doesn't include bitcode for tvOS\n- Consequently, Nimble can't link for tvOS on the actual device\n- Carthage always builds fat binaries that include both simulator and device slices\n- Consequently, carthage build fails for Nimble for tvOS\nYou can work around this by:\n- Using submodules and including Nimble.xcodeproj in your project's workspace\n- Using Carthage's --platform flag if you're not building for tvOS\nI think Nimble should also be able to attach pre-built frameworks to its GitHub releases for Carthage to use. If the tvOS framework included there doesn't have a device slice, then I think things will work.\nI don't think there's an easy way for Carthage to work around this. If anyone has a good idea for how to detect it generally\u2014not special casing for Nimble.framework, but detecting that XCTest is a dependency or that a dependency doesn't have bitcode\u2014then I'd be open to adding something to Carthage.\nIdeally, Apple would include bitcode in XCTest so that this wouldn't be a problem.\n. You can use --no-build instead of --no-use-binaries. Then the command will succeed and you can build Nimble by including the Xcode project.\n. ",
    "phatblat": "Carthage 0.17 is out now and has a change to work around this issue.\n. @jlalvarez18 this PR is brand-spankin' new but looks like I didn't break anything, so just a matter of the maintainers reviewing it and then buttoning up a release. :ship: \n. On it\n. I've logged this as rdar://25456276\n. FYI, rdar://25456276 is fixed in Xcode 8.\n. > I don't really know anything, I just have theories.\nI did a bit of swizzling to get a better sense of the observers in play relating to #271 and found the following:\n- XCTestLog\n- _TtC6Nimble22CurrentTestCaseTracker (aka Nimble.CurrentTestCaseTracker)\n- _XCTestDriverTestObserver\nXCTestLog\nThis one is responsible for writing test output to stdout. If it doesn't get added as an observer, there is almost no output.\nIt is the first observer added to the XCTestObservationCenter.observers array. While debugging in Xcode, I found it's actually added through the _addLegacyTestObserver: private method (swizzled version in the stack trace below) in response to CurrentTestCaseTracker calling sharedTestObservationCenter before adding itself as an observer.\n\nI'm confused how #271 was a timing issue as XCTestLog is always added first, but things could be different when Quick and Nimble are invoked from the command line vs from the Xcode GUI with debugger attached.\nQuick Test Failure\nThe failing test in Quick/Quick#507 is testFailureSpecFailureCountIsEqualToTheNumberOfFailingExamples. It is expecting 2 failures, but none are reported.\n```\n/Users/distiller/Quick/Sources/QuickTests/FunctionalTests/FailureTests+ObjC.m:58: ((result.failureCount) equal to (2)) failed: (\"0\") is not equal to (\"2\"):\n55 \n56 - (void)testFailureSpecFailureCountIsEqualToTheNumberOfFailingExamples {\n57     XCTestRun *result = qck_runSpec([FunctionalTests_FailureSpec_ObjC class]);\n58     XCTAssertEqual(result.failureCount, 2);\n       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n59 }\n60 \n```\nThe swift side of CurrentTestCaseTracker is responsible for recording these failures using the currentTestCase tracked through the XCTestObservation calls to testCaseWillStart and testCaseDidFinish. What's interesting about testFailureSpecFailureCountIsEqualToTheNumberOfFailingExamples is that it is run quite differently than the other Quick tests, a new XCTestSuite is constructed and run explicitly.\nTheory\nSomehow I think CurrentTestCaseTracker isn't getting hooked in correctly in some cases when the tests are invoked from xctool. Running Quick's tests through xcodebuild on the command line works fine as well as through the GUI.\n. I think I have this backwards. Maybe the root cause is the same as #271 - no output.\nIf I prevent XCTestLog from registering as an observer, there's almost no output, but the Xcode GUI still reports that all the tests pass. I suspect that's because it's using _XCTestDriverTestObserver to monitor the tests. Blocking only _XCTestDriverTestObserver I see test progress in the console, but Xcode reports that the tests failed with the following error.\nTest target Quick-OSXTests encountered an error (Early unexpected exit, operation never finished bootstrapping - no restart will be attempted)\nIf xcodebuild is also using this _XCTestDriverTestObserver to determine success vs. failure, then the real difference is the output, which xctool depends on.\n- :white_check_mark: Xcode GUI\n- :white_check_mark: xcodebuild\n- :no_entry_sign:  xctool\nSo, perhaps the XCTestLog is the culprit and it's somehow getting fouled up due to this separate test suite.\nI'll do some experiments to see if there are other hooks we can use to get CurrentTestCaseTracker wired up without borking XCTestLog.\n. OK, this is ugly, but it works. Moving the CurrentTestCaseTracker observer registration from +load into my swizzled _addLegacyTestObserver: method, but after XCTestLog registers, appears to do the trick. All the Quick tests pass when invoked from xctool.\n\nI don't really know what I'm doing and don't like the idea of swizzling since it's so fragile. Does anyone know of any other XCTest framework hooks that we can move this CurrentTestCaseTracker observer registration to?\n. @jeffh I tried that first, but the @objc(untilFile:line:action:) method can't be exported to Objective-C with StaticString in the signature. Is there any way to bridge from a String to StaticString?\n. I vote for safety-checked swizzling over requiring users to register a NSPrincipalClass.\n. Yep\n. This sounds like #270 which is fixed in master now but hasn't been included in a release yet.\nYou can test it out with the following in your Podfile:\npod 'Nimble', :git => 'https://github.com/Quick/Nimble.git'\n. This sounds like it could be due to #270 which is fixed in master now but hasn't been included in a release yet.\nYou can test it out with the following in your Podfile:\npod 'Nimble', :git => 'https://github.com/Quick/Nimble.git'\n. OK, good to know. Are any of these performance tests using measureBlock:?\n. Excellent. Closing as it appears this is resolved now.\n. Could one of the brilliant @Quick/contributors kindly look this over? Quick's Xcode 7.3 support is waiting on this fix.\n. Thanks for the feedback, @briancroom! I'll fix these up shortly.\n. This is ready for re-review.\n. Squashed. Just waiting for CI to finish and then I'll merge.\n. @briancroom the squash option shows up after the first click on the merge button\n\n. Nice catch. Thanks!\n. @ashfurrow there is a wonderful release script which does everything besides change the version number in the podspec.\n. One thing that I see missing from the release process is a pod lib lint. If the pod won't lint then the pod trunk push will fail. But, perhaps this should be worked into the CI build process to catch it earlier.\n. Same here.\nThese are great changes which I'd love to see applied in the Quick release script\n. IMO, we should remove the Carthage commands from the script. The binary incompatibilities between Swift versions makes pre-built frameworks pointless. I changed the Quick script to skip the tvOS platform because of Carthage/Carthage#1268, but even once that's resolved I don't see the point.\nPerhaps if Swift 3 really brings us ABI compatibility, we can bring back pre-built binaries.\n. IIRC, psych has given me headaches with different versions of Fastlane and uninstalling psych was the fix. Lately, I've been using bundler to install gems local to a project so that I don't have to do any cleanup like this.\n. Wow, didn't expect that to be so difficult \n. @c0diq There hasn't been a Carthage release since Carthage/Carthage#1280 was merged to address this.\n. I'm game. Let's see how it goes.\n. Well, the podspec build worked fine but one test failed in an unrelated build \u00af(\u30c4)/\u00af \n. Sounds good. Pushing now.. 7.0.1 is out. Thanks for the Swift 4 fix @sharplet!. Sounds good to me.. Closing now that #515 is merged.. \ud83d\ude4b\ud83c\udffb\u200d\u2642\ufe0fI\u2019m at WWDC and spending most of my time in the labs. I\u2019ll take this to the swift lab today. Lol I just got the same answer in the labs. @ikesyo did you file a radar I can dupe?. Radar: 40857699 \"Swift runtime crash when closure passed as @noescape is mistakenly identified as having escaped (Nimble)\". Thanks for finishing this up @ikesyo! Sorry, I've been slacking lately. Haven't been feeling well.. I think this is a good idea especially with the Xcode 10.2 beta 1 release today which includes Swift 5 and drops support for Swift 3.\n```\nerror: SWIFT_VERSION '3.0' is unsupported, supported versions are: 4.0, 4.2, 5.0. (in target 'Nimble-macOS')\nBuild system information\nwarning: Swift 3 mode has been deprecated and will be removed in a later version of Xcode. Please migrate \"Nimble-macOS\" to Swift 4.2 using \"Convert > To Current Swift Syntax\u2026\" in the Edit menu. (in target 'Nimble-macOS')\n```. Does CocoaPods 1.7 have fixes for Xcode 10.2 or Swift 5?. Good catch! Guess I should test this path. :frowning: \n. ",
    "mfclarke": "I have just checked with the Quick + Nimble submodules on master and I still have the same behaviour.\n. Many thanks @jeffh, I will check this today\n. +1, issue still persists with Xcode Server for me too\n. ",
    "alessandroorru": "I am experiencing the same issue.\nI have temporary worked around this with the following code (I'm relying on XCTest expectations). It uses a similar signature so in my case I just did a search & replace for waitUntil(timeout to waitExpectation(timeout\n``` swift\nextension XCTestCase {\n    func waitExpectation(timeout timeout: NSTimeInterval = 1, caller: String = FUNCTION, action: (done: () -> Void ) -> Void) {\n    let expectation = expectationWithDescription(caller)\n\n    action { done in\n        expectation.fulfill()\n    }\n\n    waitForExpectationsWithTimeout(timeout) { (error) -> Void in\n        if let error = error {\n            print(\"Error fulfilling expectation: \\(error)\")\n        }\n    }\n}\n\n}\n```\n. ",
    "vburojevic": "I'm having the same issue. Local tests run and pass just fine, but Travis tests fail because of a stall on a test that adds objects to core data synchronously.\n. ",
    "MattesGroeger": "+1 Also facing the same problem now, also locally.\n. ",
    "nerd0geek1": "+1\nI also facing the same issue on CircleCI, also locally.\n. ",
    "nordfogel": "+1 here\nlocal tests pass but not executed via teamcity ci\n. ",
    "PatrykKaczmarek": "+1 Same for me.\n Local tests always pass. On CI (Bitrise) fail randomly.\n. ",
    "attheodo": "+1, local always pass, Bitrise mostly fail. NSRunLoop hack works for local env but doesn't do the job on CI.\n. Runs ok on local, getting lots of failed - expected to eventually match (timed out, but main thread was unresponsive) on Bitrise CI\ncc @jeffh \n. ",
    "anas10": "I still have this issue quite often. It's quite random because when I relaunch it happens again but on other tests and not the previous one anymore.\n. ",
    "maqoo": "+1\nIm experiencing the same issue :( \n.toEventually() fails at random on Bitrise CI. ",
    "mjgaylord": "+1\nI am getting failures for toEventually and waitUntil when running my tests using fastlane scan or xcodebuild on my local machine and on CircleCI.. ",
    "stephencelis": "It might not even have to be a breaking change immediately. We could add the protocol extension layer and call the module functions from there. The question is if Swift will resolve func to() vs. var to.\n. If no one else wants to noodle on this, I can take a stab this weekend :smile:\n. Did a quick look at this and it doesn't look like var to and func to() can live in harmony :disappointed:\nI see two paths forward\u2026\n1. The backwards-compatible:\n``` swift\n   // current style\n   expect(array).to(beEmpty())\n   expect(array).toNot(beEmpty())\n// new style\n   expect(array).isEmpty()\n   expect(array).isNotEmpty()\n   ```\n2. The breaking:\nswift\n   expect(array).to.beEmpty()\n   expect(array).toNot.beEmpty()\n   // or: expect(array).to.not.beEmpty()\nThoughts? The latter seems to fulfill the expectations (har har) of someone familiar with BDD, though the former is more succinct and active, kind of like changing a spec from it \"should do this\"\n\u2014to: it \"does this\".\n. Sure. Ideas welcome if isEmpty()/isNotEmpty() and their ilk aren't desirable! Even is might work:\n``` swift\nexpect(array).is.empty()\nexpect(array).is.not.empty()\nexpect(foo).is.equalTo(bar)\nexpect(foo).is.not.equalTo(bar)\n``\n. I'm cool with that. And on second thoughtis` is a keyword, so it's not a friendly option. I'll try a breaking-change PR soon.\n. @jeffh I'm happy to work on a backwards-compatible version, which is why I suggested it as a good first step :)\nI may be in the minority, but I do think these kinds of changes go beyond syntax and visual appeal, and that the autocompletion benefits are invaluable to new users\u2014especially new developers. I think Swift 2 introduced protocol extensions as an important step in its evolution as a language.\nI also agree with you that using some kind of negating not (should vs. should.not) would be easier both maintainability- and discoverability-wise. It's just about finding the sweet spot, semantically.\n\nI just read the combinator thread and might need more examples to understand the need for this kind of binary expectation. Instead of:\nswift\nexpect(someThing).to(startWith(\"https://\")).or(startWith(\"http://\"))\nWhy not the following?\nswift\nexpect(someThing).should.match(\"https?://\")\n. Turns out it's a moot point. My earlier spike quickly led to an unhelpful compile-time error that was hiding the root of the problem. Both can live in harmony after all! :smile:\n. I don't see any reason why protocol extension-based syntax would disallow matcher combinators.\nAs an example:\nswift\nexpect(device.primaryIPAddress).to.match(IPv4Pattern).or.match(IPv6Pattern)\n. Swift type-checking could take care of it and correctly route things. The assertion would build lazily and be performed at the end of the statement.\n. :smile: Yay! Have you had a chance to read over #218 and address the concerns I brought up?\n. No problem! Open source should ideally be fun and low-stress (which I know open threads can rarely be). If you get this across the finish line, great!\nI wasn't familiar with satisfyAnyOf, but imagine the || version would still work:\nswift\nexpect(82).to.beLessThan(50) || beGreaterThan(80)\nAnd, more verbosely (without the free function):\nswift\nexpect(n).to.beLessThan(50)\n  || expect(n).to.beGreaterThan(80)\n. Closing this one out, sorry! I'll leave the branch around if anyone else wants to try \ud83d\ude04. Yep! I just don't have time to tackle it right now. Anyone that wants to help get things across the finish line is welcome to, but it might be good for one of the owners to itemize the requirements!. ",
    "shaps80": "Why did this never get merged in the end? Just want to understand the issues surrounding this approach.. Ah right, yeah I figured that's the case. I don't have time yet, but am considering taking this on. Its fairly straight forward, especially since you already did it once -- so I have a reference \ud83d\ude0f\nThe main issue I think is that it was done with Swift 2.2?. @jeffh I'd be keen to work on this\u2013agreed we should include the new Matchers API.\nQuick side note\u2013slightly related\u2013I have created a little project which is heavily based on (mostly copy) Nimble but strips out unnecessary code to make it streamlined and ready for Playgrounds, including on iPad.\nhttp://github.com/shaps80/Spry\nWould you guys be interested in making this a part of the Quick suite? If not would you be ok with me announcing this as available and obviously HEAVILY making reference that its basically Quick Lite?\n\nUnit tests are not 100% complete yet\nUnit tests are completely copied from Nimble -- allowed me to validate quickly\nMatchers are mostly identical too\nThe core is SIMILAR but simpler -- funnily enough I had a similar idea about simplifying the Matcher. I didn't realise you had similar aspirations in Nimble until now.\nHaven't setup Travis CI, etc... yet -- was hoping it could become a part of the Quick suite. @modocache I've LOVE to get this included as a part of the Quick organisation. I think it'll be a LOT more discoverable there.\n\nUpdate:\nI'd be happy to simply 'Transfer' this into the Quick organisation if I could become a permanent contributor to that repo?\nThe iPad Playground is finally working great, and I've even included a Glossary of terms/features, hints, etc... One cool feature I thought with this as well is to create a little Swift Playground's Book, which introduces people to testing in general. With pages or examples 'teaching' how to test something, etc...\n\n@jeffh Totally agree I would prefer this to share more code, but there are a few areas of concern -- which led me to creating a separate codebase.\nDistribution\nThere is no cocoapods/carthage, etc... Its really just a matter of either manually copying across the source folder, or downloading an example Playground. Both of which I provide (including one for iPad) from the README.\nReporting\nRunning code in a Playground has a very different experience to Xcode. Particularly on an iPad, where you don't even have access to things like a console.\nDescriptions have little value since you're not generally executing tests for multiple files in a project. You just have one file, and you can write your tests inline with the code itself. This pretty much gives you all the context you need -- so adding descriptions into the mix seemed unnecessary.\nTraffic lights are much nicer IMHO:\n\nLegacy\nNimble has been around for a number of years and as such has inherited some legacy code/tech debt. It was also released with Quick, which has Objective-C support, something you can't run in Playgrounds anyway.\nI re-wrote the core pieces of Nimble to include some new features, like NilLiterals, single Matcher type, etc... (after looking through your PRs and issues). This allowed me to ignore stuff like descriptions, objective-c references, linux references, etc... \nPerformance\niPad in particular has fairly slow execution times in Playgrounds. Adding a larger than necessary codebase seemed like a bad idea.\n\nWhat I would say is that its definitely possible to share all the Matcher's code along with the associated unit tests. I pretty much copy pasted those so far and its working really well. I think if we could find a way of sharing that code more long term, it would make this a lot more maintainable moving forward.\n\nSide note: My implementation already uses a single Matcher type, as well as takes advantage of Swift 3's type bridging from Objective-C types. I also included the NilLiteral idea from one of the PRs I came across here. \nI had intended on working on this PR for Protocol Extensions based Matchers as well -- with backward compatible API -- as I prefer the approach: expect(actual).to.beNil\nBut I halted on that last one until it was directly supported in Nimble.\nI'd be really keen to work on this and find a way to make both projects share the same code.. FYI: I'd recommend if its ok, that I transfer the Repo into the Quick organisation ASAP so that these conversations have a better place and focus.\nWith a goal -- to find a better sharing of code. \nThe project is live and working great already, but I'd much prefer to get it into the Quick org so that it gets better visibility.. Thanks for adding me to the org.  Quite proud to be a part of such a great project.\nI will move it into the Organisation now. Exciting :)\n\nJust to address your comments above.\n\nDistribution: I did consider this -- but at the time was uncertain about the code I'd be copying into the package. If we could get this working, would you prefer that its a part of Nimble in that case? Removing the need for a separate repo? I ask mostly from the visibility/discoverability perspective I mentioned previously.\nReporting: I wasn't aware of that protocol, however after looking at it I'm not sure it would suffice. Playgrounds render the result. So the functions would all need to return a color (as they do in Spry). Unless I'm missing something? Maybe this is something we could work into Nimble anyway.\nLegacy: I see your point, I guess if those things are compiled out then perhaps its a non-issue. I was more referring to the fact that the REPL would need to evaluate those things for every single refresh of the Playground, which can happen quite often.\nPerformance: Agreed! I have done some manual tests myself -- although I'll admit they were more UI focused. What I'll do is setup a performance branch with some code in a Playground that you can run yourself and see the stats.\n\n\nThanks again, I'll also get your PR/Issue templates into the repo, etc... to bring it inline with the code of conduct you guys have for the other repos.. @jeffh \nWhen are you planning to get this in? I wanted to work on #218 -- perhaps I should merge this change in to mine to include it?. Fair enough. As you said this is definitely a change worth getting in sooner rather than later, and then I can tackle the PO Matchers ticket, for both Nimble and Spry.. At a glance, I'm not really sure what's wrong with the Travis build... I'm a little stuck for time this week if someone else could take a look? I'd be happy to fix it if someone can point out the issue.. @ikesyo thanks for fixing up the remaining bits. \nThe only thing I noticed was that you removed @objc from a couple of methods which I think I added because from Swift 4, @objc inference is deprecated and all methods should be explicit moving forward.\nIs there a reason you removed them?. Awesome!. Any reason why you don't want use Swift attributes?\n@available(*, deprecated, message: \"...\")\nor perhaps unavailable is more appropriate here? \n@available(*, unavailable, message: \"...\"). Should this be Swift 3 style lowercasing?. deprecated causes a warning on calling code, not an error. This is generated by Xcode.. do you really expect me to fix this? \nNot trying to be difficult just pragmatic. :). ",
    "morganchen12": "Looks like this is a Quick-related issue. describe can only be used with the QuickSpec class, or the context required by describe will never be set up.\nTo clarify further, Nimble is a replacement for XCTAssertions; Quick is a replacement for XCTest. Nimble can be used within an XCTestCase, but Quick cannot.\nMaybe a more informative error would be helpful in this case, though.\n. I would imagine Builtin.int_trap() is just llvm.trap(), which is platform-dependent and just emits an undefined trap instruction or abort() if in doubt. I don't think it can be intercepted in a way that isn't painful. \n. @abbeycode I don't think that's a perfect solution either--even if we do find a way to inject a file into the code we're trying to test, it'll create duplicate symbols within the same module if they've also tried to add that same file and in either case it won't work if they're calling Swift.fatalError() instead of just fatalError(). Ideally we want our solution to be completely agnostic of the codebase we're testing.\nHowever, there is some good news: http://cocoawithlove.com/blog/2016/02/02/partial-functions-part-two-catching-precondition-failures.html\n. Agree 100% with crediting Matt \ud83d\udc4d\nJoe Groff mentioned on the mailing list that it'd be best to test fatal error failures using the tools we have now since compiler support for catching such failures would be expensive. If we want Nimble to work on Linux where Mach exceptions aren't available, we'll probably need to use a fork()-based approach.\nLandon Fuller has some other great writing on handling Mach exceptions (1, 2). \n. Try using @asmname(\"mach_msg\").\nBy using @asmname, we're basically betting on the function being available at runtime even though the __TVOS_PROHIBITED annotation says we're not allowed to use it.\n. 1. Yes, although even if it is there in the runtime there may be a good reason (even in unit tests on simulator) why it's labeled as prohibited.\n2. Probably not! Giving up the ability to debug a unit test run with lldb is pretty limiting, though. Signal handlers are also very hard to work with.\nI'm not sure about 3 or 4.\n. - I changed the behavior of printing all numbers to drop trailing zeros behind the decimal if they were unnecessary and round to four points of precision only if there were four or more digits behind the decimal. In hindsight I'm not sure why I did this. But it does mean that numbers are now represented consistently across platforms, and I got to delete a lot of (like 3) #if _runtime(_ObjC) clauses in our tests!\n- Adding the quotes back in would be very easy since Swift's string.debugDescription returns itself padded in quotes already. \n- Renamed Stringifiable to TestDebugStringConvertible.\n. CI doesn't seem to like this so much. If we bump the development snapshot version hopefully it'll fix itself?\n. The only reason we can't use nil  in those tests is because one of the other equality operators takes optional types (and Swift infers use of that operator), but then errors with \"use beNil() to match nils\". Removing the optionality from that equality operator allows us to take advantage of NilLiteralConvertible as expected.\nAs a bonus, I don't think we need the Nil global constant anymore.\n. With this new stuff in place, I feel like it's possible to remove optionality from all of our equal() matchers and turn all of the use beNil() to match nils runtime errors into compile time errors (which would be great imo).\nI've started working on this a little bit, but I've run into some horrible EXC_BAD_ACCESS in stringify of all places, so that work is going to live on another branch until I can figure it out.\nedit: nevermind I got it\n. This is ready for re-review \ud83d\ude47 \nI've unfortunately evolved this diff into a breaking API change.\n. Added some doc comments to point users to beNil(). This will make discoverability slightly less of an issue, though it's far from ideal--ideally we could have the compiler provide a fix-it saying \"did you mean to use beNil()?\".\n@sharplet with these changes Nimble still will have your back, but your comment does point out the weird asymmetry between having nullable expectations and non-nullable matchers. I'm of the opinion that expectations should be as allowing as possible and matchers should be as strict as possible, but one could argue that strictness in matchers is unnecessary if the whole point of tests is to verify behavior in runtime. On top of that, the majority of the benefits of static code checks will come from compiler checks in the codebase under test and not necessarily the tests of that codebase; having tests be lenient on compile-time checks does not take away from the main codebase in that regard.\n. Ready for re-review again.\nThanks for all the feedback! \u2728\n. I made a PR to Eidolon to fiddle around with this. There were 3 new compiler errors from these changes.\nThe first two were pretty simple: there's a stubbed test subclass that sets up some nonnull state that is nullable on the production superclass, and later on some tests make some assertions involving that nullable data that is actually never null because of how the stub sets it up. The changes look like this:\ndiff\n// PlaceBidNetworkModelTests.swift, line 80\n- expect(auctionID) == fulfillmentController.bidDetails.saleArtwork?.auctionID\n- expect(artworkID) == fulfillmentController.bidDetails.saleArtwork?.artwork.id\n+ expect(auctionID) == (fulfillmentController.bidDetails.saleArtwork?.auctionID)!\n+ expect(artworkID) == fulfillmentController.bidDetails.saleArtwork!.artwork.id\nHaving to force-unwrap this stuff even if it's never nil seems like needless inconvenience. For a longer series of assertions it might be helpful to unwrap the variable beforehand, but in this case it seems tedious. (Aside: I think it'd be cool if beNil() assertions could unwrap values underneath them like guard statements.)\nThe last compiler error came from a test where two values are transformed in a flexible way and then expected to not be equal to each other. Having to unwrap one side but not the other seems awkwardly asymmetrical for this purpose. The equal matchers are still asymmetrical regardless, so even if both values end up being different but the one on the right is nil the test will still fail. \ndiff\n// ListingsViewModelTest.swift, line 155\n- expect(initialFirstLotID) != subsequentFirstLotID\n+ expect(initialFirstLotID) != subsequentFirstLotID!\nThe effects of these changes on the Eidolon codebase seem mildly unpleasant. I might try to apply these changes to some other large open source projects like ReactiveCocoa and see what happens.\nAs always, feedback is welcome!\n. Xcode gave the ol' value of type Type? not unwrapped and provided fix-its using ! that resulted in the diffs above. I'd like to try using these changes on ReactiveCocoa tonight and see if there's ever a case where the force-unwrap fix-it is undesirable. I wonder if keeping the old methods around and marking them as obsolete with a message of \"use this thing instead\" would allow us to provide migration dialogues while preventing the compiler from inferring use of those methods.\nFor the case where one might compare against an optional type many times in succession, I'm considering introducing a new matcher to make this less painful.\n``` swift\nlet expected: Thing? = / ... /\n// unpleasant series of force-unwraps\nexpect(a) == expected!\nexpect(b) != expected!\nexpect(c) == expected!\n```\ninstead this could become\n``` swift\nlet expected: Thing? = / ... /\nexpect(expected).to(beNonNil(and: { unwrapped in\n  expect(a) == unwrapped\n  expect(b) != unwrapped\n  expect(c) == unwrapped\n}))\n``\n. The overloaded==operator expects the types it's comparing to conform toEquatable. WhileCGContextandCGPathprovide equivalence functions, they're plain C types bridged to Swift and therefore don't adopt theEquatableprotocol by default. Extending these types to conform toEquatable` should fix your problem.\n``` swift\nextension CGColor: Equatable {}\npublic func ==(lhs: CGColor, rhs: CGColor) -> Bool {\n    return CGColorEqualToColor(lhs, rhs)\n}\nextension CGPath: Equatable {}\npublic func ==(lhs: CGPath, rhs: CGPath) -> Bool {\n    return CGPathEqualToPath(lhs, rhs)\n}\n```\nThen you should be able to do\n``` swift\nlet color = UIColor.whiteColor().CGColor\nexpect(color) == UIColor.whiteColor().CGColor\nexpect(backgroundLayer.path) == UIBezierPath(arcCenter: CGPointMake(0, 0), \n    radius: 0, startAngle: 0, endAngle: 0, clockwise: true).CGPath\n```\n. I don't have write access but this LGTM :+1:\n. Seems like a bug to me. Thanks for reporting this!\n. This is probably a Quick issue, not a Nimble issue. Nimble just adds nicer test matchers/assertions.\n@istx25 does this look familiar?. If you profile your test suite, is there a lot of time spent in Quick/Nimble calls?\nCan you share the trace of the time profiler run?. If any of your code is setting NSTimers, make sure you're invalidating all of them so they don't stay attached to the main run loop and fire forever while your tests run.. Have you tried setting this variable to the version of Swift you're using? In the Xcode Build Settings inspector it shows up as \"Use Legacy Swift Version\". If it's unset but Xcode still displays a value, setting it to a different value and then back again should set it properly.\n. Under Pods.xcodeproj there should be a target for Nimble--if you set this variable in that target's build settings, does the error go away?\nIt seems to be already set in the Nimble project (see here and here). Maybe we're missing it somewhere else, or this is a CocoaPods-related issue (don't file an issue there yet though).\nIf you run pod --version and xcodeproj --version, what are the outputs?. xcodeproj --version is the version of the Xcodeproj Ruby gem that CocoaPods depends on, not your Xcode version. The reason I ask this is I'm wondering if there was a recent change in the Xcodeproj gem that would cause this issue--if manually downgrading the Xcodeproj gem version to a lower number makes the issue go away, then it's definitely something from CocoaPods.. Thanks for following up. I was also able to fix this locally by downgrading Xcodeproj to v1.5.1. If you're working with a team of devs, you can ensure your CocoaPods and XcodeProj versions are all the same by including a Gemfile in your project repo.. This was fixed by #532, but hasn't been released.. It'll be out in the 7.x release (see #536). I don't have an ETA for that, but it looks like @ikesyo plans on releasing soon.. This is also fixed in #532, which will likely be out before the Swift patch (and removes some redundant code anyway).. This was removed recently in #537 to work around an Xcode 10 beta bug.. \ud83d\ude05 whoops\n. typo longs -> logs; XCode -> Xcode\nthanks for the quick PR!\n. created #272 to address this :+1: \n. ",
    "Dschee": "Thanks for the clarification @jeffh, but I'm not sure I understood all you wanted to say correctly. Does the throwError matcher also match against Swift exceptions? Or is what you want to say that Swift still doesn't have exceptions but instead \"throws errors\"?\nIn any case, I didn't see the throwError method before, thanks for that, I think that is what I was asking for. But I still think the note from the README I quoted is clear. At least when I read it I didn't even look for another way of catching errors thrown by the Swift native way cause I thought Nimble is outdated. \nMaybe we should change it to something like:\n\nNote: Swifts exception handling works different than Objective-C's. It doesn't catch exceptions raised by NSException. Use the matcher throwError instead if you want to test against exceptions thrown the Swift way.\n\nOr do I still misunderstand?\n. @jeffh Thank you very much for that very detailed explanation. I realize now that I had fallen into the trap to assume I'm dealing with real exception handling when using do, try and catch \u2013 I simply had never heard of \"catching an error\" before, so I assumed the catch must be there for exceptions. Sorry for that misconception on my side. From my perspective, this issue can be closed now.\nBut in case you care about people who could fall into the same trap as I did, you might want to alter the README to state something like this (providing your great explanation above):\n\nNote: Swift currently doesn't have exceptions (see also #220). Only Objective-C code can raise exceptions that Nimble will catch.\n. I'm experiencing this same issue with Nimble although I integrated it with Carthage (alongside Quick) \u2013 so could we please reopen until the situation is clarified? Also any ideas are welcome. I already cleaned derived data, reset iOS simulator etc. \u2013 didn't help for now.\n. This issue was resolved for me once I followed the fourth step of the Carthage installation instructions correctly (seems I missed this one earlier, or it was added later on):\nOn your application targets\u2019 \u201cBuild Phases\u201d settings tab, click the \u201c+\u201d icon and choose \u201cNew Run Script Phase\u201d. Create a Run Script with the following contents:\n/usr/local/bin/carthage copy-frameworks\nand add the paths to the frameworks you want to use under \u201cInput Files\u201d, e.g.:\n$(SRCROOT)/Carthage/Build/iOS/Box.framework\n$(SRCROOT)/Carthage/Build/iOS/Result.framework\n$(SRCROOT)/Carthage/Build/iOS/ReactiveCocoa.framework\n\nAdditionally for my test targets I followed this here, too:\n\nIn rare cases, you may want to also copy each dependency into the build product (e.g., to embed dependencies within the outer framework, or make sure dependencies are present in a test bundle). To do this, create a new \u201cCopy Files\u201d build phase with the \u201cFrameworks\u201d destination, then add the framework reference there as well.\n\nMaybe this helps others experiencing the same issue. It actually doesn't seem to be a problem with this project so this can be closed, I think. Sorry for making you reopen.\n. @Buju77 I just came across the same issue and reported it on Quick here. Looks like it's part of Nimble. Let me have a look and try to fix this real quick .... I fixed this particular issue, though now I'm running into a different one. Looks like Xcode 10 support needs some more work, let me continue fixing stuff .... Okay, the second issue I've found was an issue with Nimbles internal tests. When building Nimble via Carthage in a project and using it for tests, everything is working now as expected, so I fixed the above issue and sent a Pull Request onto the branch of this PR here.\n@sharplet Would you mind have a look and merge, please?\n@Buju77 In the meantime, you can use my fork, e.g. for Carthage users it would now be:\ngithub \"Dschee/Nimble\" \"xcode-10\". Yeah, that's the \"second issue with Nimbles internal tests\" I was talking about earlier. But please note that this issue only arises when running tests on Xcode 10 beta, tests are passing in Xcode 9.4 which is what we should be worried about most right now.\nIt's possible that the failing test in Xcode 10 is due to bugs in the beta software. And even if this was not the case, this MR is still better merged cause it works for most of us and therefore is better than a version that doesn't build at all in Xcode 10.. Oh no, you're right. Okay, I've tried merging the two methods into one now. Should work since Swift 4.2 seems to always use the Optional method and not accept another non-optional method. The logic should be the same as before now. Sorry for the bad quick fix.. ",
    "Rivukis": "I can't figure out why the build failed. Everything works locally. I don't think I have access to start another build in hopes it is just a fluke. Any help is appreciated.\n-Brian Radebaugh\n. Thank you for the fast response. Whichever you decide (assuming you want this to be a part of Nimble) just let me know what I need to do.\nI thought of making mocking easier in swift, but without the objc-runtime it's near impossible. This part of remembering called functions is assuming that whoever is going to use this already has a plan for mocking objects. I provided an example in the README.md file in case they hadn't thought of one yet.\n. About the tests. I wrote them in that way since those APIs marked as internal (like it or not because of swift) are public. Also, if you look in the 'CallTest' file you'll see that I am testing the class using the preferred APIs.\nEssentially, the 'CallRecorderTest' file tests to make sure anything conforming to the protocol performs as expected, while the 'CallTest' file tests the matcher.\n. The class that failed was in the merge conflict in the project file. I ran git checkout --theirs Nimble.xcodeproj/project.pbxproj and then added my files back which shouldn't have messed up anything. I also ran all the tests on all three platforms afterward with zero failures. Can you re-run the CI build?\n. > Hey @Rivukis,\n\nI got a chance to play around with this more.\nI seem to get a failure with differing types:\n```\nclass TestClass : CallRecorder {\n    var called = (functionList: String, argumentsList: [Any])  \n    func doSomething(string: String, value: Int) {\n        self.recordCall(function: FUNCTION, arguments: [string, value])\n    }\n}\nlet testClass = TestClass()\ntestClass.doSomething(\"foo\", value: 1)\nexpect(testClass).to(call(function: \"doSomething(_:value:)\", withArguments: [\"foo\", 1]))\n```\nWhich produces:\nAssertions: failed - expected to call <doSomething(_:value:)> from TestClass with foo, 1, got <doSomething(_:value:) with (foo,1)>\n\nHey @jeffh,\nThe reason you got the failure is because the arguments parameter passed to recordCall() is variadic while the arguments parameter in call(function:withArguments:) isn't. In a nutshell you passed the arguments in doSomething(_:value:) as one argument that is an array holding the two values, which means the call recorder thinks there is only one argument for that function. The call matcher is then trying to match [\"foo\", 1] to \"foo\" and nothing to 1. In fact there is a short-circut in the call matcher that reports back false because the number of arguments expected versus actual don't match.\nI tried making the call matcher's arguments parameter also variadic but I kept running into issues. I've updated the README.md to reflect this. Also, until I can get the call matchers arguments parameter to be variadic it would probably be a good idea to not make the recordCall()'s arguments variadic. This way there's less confusion.\n. @jeffh \nAbout the variadic issue you ran into earlier. I've fixed it now in the other direction. Both are now variadic. Not sure why I was having problem making them variadic before. Either way, it's solved now.\n. I don't think that build server likes me... Let me know if it's on my end.\n. I found a way to no longer depend on the CustomStringConvertible for equality between arguments being passed in and arguments being recorded.\nNow the user just has to make sure they are conforming to GloballyEquatable which is only in name as the extension takes care of everything and to Equatable which they will have to make the global function, but I think this is a much better solution as it doesn't feel like a hack :)\nI had a better solution (that involves grabbing the .Some out of the optional using the Mirror type) that would hide the \"Optional : Equatable\" stuff from the user but there is a bug (at least I hope it's a bug) in Swift. I've filed an issue on their Jira board: https://bugs.swift.org/browse/SR-1132, and will commit the better solution if/when the bug is fixed.\n. After the merge conflict I'm not able to build the project, but it's due to classes that I didn't touch. Please let me know if I need to do something on my branch.\n. Why does travis-ci hate me? Help please.\n. I stopped working on this because I stopped getting feed back on whether or not people wanted this to get merged in. As far as the fixes necessary to get this merged in, I'm more than happy to pick this project back up.\nI think the list needs to be updated as far as what is necessary because the argument checking does NOT use stringification (I think v1 might have..?). Instead it is actually using the Swift provided protocol, Equatable. To get that to work when the types are unknown, I made GloballyEquatable. The function name is stringified but because that argument is defaulted to #function there isn't an issue except for function overloading.. As far as using other matchers, that would be cool, but I've never needed that functionality so I'm not sure if it is needed to get merged in but rather a feature to be added later.\nAs far as the manual mock, I recommend in the README a way to make this work which is to make your real class's interface a protocol and then have the real class plus the fake conform to it. The additional step is that the manual fake also conform to CallRecorder and call record() in each function. So I'm not sure what you mean when you want a manual mock that differs from this.\nAs far as the test coverage request. Some of what you've listed is being tested. However, all equality checks are predicated on using Equatable so as long as the type conforms to that protocol and GloballyEquatable (which requires no additional work for conformance) then any type will work. The only issue I can see is getting tuples and closures to conform to Equatable.. Can someone help me with the build server?. I decided to make a separate framework recording calls. It's call \"Spry\" and can be found on my GitHub page. It includes a way for test doubles to record calls and stub functions. Spry also has an optional \"Spry+Nimble\" cocoapod which includes a Nimble matcher for testing if a call was made. If anyone is interested, check it out and let me know what you think.\nI hope I wasn't out of line, but I copied a file out of Nimble to get my Nimble matcher tests to pass (I needed the NimbleUtil.swift file so I could test the failure message.) This copied file is not a part of any cocoapod nor will it ever be. It is used in the sample project for testing purposes ONLY. I also added a comment at the top of the file so anyone who sees it knows it came from this repository. If this is not allowed, please let me know. I will remove it and find another way to test the matcher.\nBecause of this, I am going to close this pull request. Thank you for all the feedback along the way!. Can you point me in the right direction on how to get started?\nThank you,\nBrian\n\nOn Jul 17, 2017, at 9:30 PM, Jeff Hui notifications@github.com wrote:\nThanks for following up @Rivukis https://github.com/rivukis! I think it would be nice to have a wiki page on Quick that lists various supporting libraries (linked to on the README) and Spry could be there.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/Quick/Nimble/pull/221#issuecomment-315955199, or mute the thread https://github.com/notifications/unsubscribe-auth/AFPLRmE9IFnj-Zh2mbpmhCBtkkT-Q56wks5sPDT5gaJpZM4Gs9iW.\n\n\n. This allows users to make their own validations inside a closure.\nI made this when I was 'TDD'ing a personal project that used a lot of enums with associated values. This made it so much easier write tests without having a lot of unnecessary conformances to Equatable.\nNo changes to the README.md file have been done for this matcher yet (not sure about the process for that). This was even more helpful when combining with toEventually.. @jeffh, I'm looking into your suggestions and I agree that would look and feel better. The problem is expect() requires a parameter, and I don't like putting in an arbitrary value to make it work.\nOptions I've come up with:\n1. Keep this version.\n2. Make a version of expect() that doesn't require a parameter.\n3. Have the return value of the closure conform to Equatable and have the expected return value be the parameter in expect()\nThe issues with Option 3:\n1. The user may only need a true false situation, so using true feels unnecessary.\n2. Requires the return value to be an Equatable type instead of an enum where the necessary information is required by said enum\n2. How does the user communicate a failure reason. I've built a working version that uses an inout parameter and throwing errors to communicate a failure reason. Neither feels great or obvious to the user.\nMy preference is Option 2 (version of expect() that doesn't take a parameter), but I wanted to get the opinion of those who know more about the internals of Nimble than I do. Any help is very much appreciated.. After thinking about it, I prefer Option 1. Anyway let me know what you all think, and what I can do to get this merged in. Thank you.. I was going to use 'Anything' but I didn't want it to conflict with idea of swift's 'Any' or 'AnyObject'. Also I thought it would read better when using 'toNot'. If you / everyone still agrees that 'Anything' would be better then I'll change it.\n. To be honest I'm not sure there is a better way. The mocked object needs to conform to this so that the matcher can call these functions on the mocked object. If you have an idea I'm willing to explore it, but as of now I'm not sure what I could do. That being said I'll think on it and see what/if I can come up with anything.\n. Just to be clear are you talking about the fact that '&&' has precedence over '||' or are you talking about the callers of this function not knowing which to put first 'didDoIt' or 'isNegationTest'?\n. No, sorry. This is a note to myself. It was a reminder for me to see if I wanted to include the called count of a function when the tester is wanting a specific 'count' times called (also 'atLeast' and 'atMost'). However after thinking about it I feel like it would be too much information since I already print out every called function on the object at the time it is tested (if the test fails)\n. Fixed\n. Fixed\n. fixed\n. Fixed by changing the bool check to only have to make one comparison instead of one, two, or three (depending on short-circuiting). It's probably insignificant savings, but when it comes to running a lot of tests, every little bit helps.\n. ",
    "sharplet": "Very nice, thank you!\n. > With this new stuff in place, I feel like it's possible to remove optionality from all of our equal() matchers and turn all of the use beNil() to match nils runtime errors into compile time errors (which would be great imo).\nI'm a little hesitant about removing the optionality for expect(). Let me share why! Here's a test that asserts a bit of async code will be executed on the main thread:\n``` swift\nit(\"runs my code on the main thread\") {\n  var onMain: Bool?\ndoSomethingAsync {\n    onMain = NSThread.isMainThread()\n  }\nexpect(onMain).toEventually(beTrue())\n}\n```\nThis test could fail for two main reasons:\n1. The code runs on a thread other than the main thread. This will generate a failure along the lines of \"expected , got \".\n2. The code never executes. This will generate the \"use beNil() to match nils\" failure.\nIf onMain was initialised to false, I could have false negatives if the code never actually ran. If onMain was initialised to true, I'd have false positives if the code never ran.\nI could factor this out into two expectations:\n``` swift\nit(\"runs my code on the main thread\") {\n  var onMain = false\n  var executed = false\ndoSomethingAsync {\n    onMain = NSThread.isMainThread()\n    executed = true\n  }\nexpect(onMain).toEventually(beTrue())\n  expect(executed).toEventually(beTrue())\n}\n```\nBut I really like how in the current design, Nimble's got my back. It can raise a little red flag for a case I may not have considered (the code not executing at all), which neither Swift nor Nimble can currently verify for me statically.\nSo I feel like this change would be an unfortunate regression for async tests.\n. It seems likely that this is just a bug in the beta's handling of Swift 2.3, so I'll probably file a radar.\n. Radar: https://openradar.appspot.com/radar?id=5006639585296384\n. I just realised there's a problem with the tvOS target under Xcode 8. When I compile for tvOS, I get this warning:\nwarning: target specifies SWIFT_VERSION = '2.3', but it is overridden by TOOLCHAINS = 'com.apple.dt.toolchain.AppleTVOS10_0'\nThis means that the target is always compiled under Swift 3, which doesn't work at all.\nI haven't been able to work out a way to disable this, looks like it could be a bug specific to the tvOS 10 SDK.\n. @jckarter and @ddunbar on Twitter have suggested some alternative workarounds:\n- https://twitter.com/jckarter/status/742843265557221376\n- https://twitter.com/daniel_dunbar/status/742893453038620672\nRaising the deployment targets to latest resolves the issue for iOS and macOS. I can't really verify with tvOS at this point. However it's not really a change that's appropriate to push onto users, so I'm not sure we can move ahead with it.\nI also tried disabling linking with standard libraries (i.e., -nostdlib), but that introduces other linker problems I'm not really sure how to resolve \ud83d\ude05 \n. Thanks @ikesyo tvOS is working now!\n. Alright, CI is looking good on Xcode 7.3 on all platforms. I've just pushed another commit that adds Xcode 8 to the CI matrix.\n. @Quick/contributors what are your thoughts about the idea of tagging v4.0.2 to include these changes?\n. Ugh, both CI failures seem to be related to code signing for iOS under Xcode 8.\n. I haven't been able to reproduce the failure locally. Not sure why it fails on Xcode 8 but not Xcode 7.3.\n. :fingers_crossed:\n. Ok, so everything is fine on CI for all platforms except iOS on Xcode 8. Everything is peachy on my machine. @Quick/contributors what do you say we go ahead and merge this then push a new release?\n. After checking the changes since v4.0.1, I think it would be best to bump to v4.1.0. Working on the release notes now!\n. Awesome, thanks!!\n. It look like the CI failures are because Travis CI hasn't updated to beta 2 yet?\n. Tests pass on my machine. lgtm \ud83d\udc4d \n. Tested on both Xcode 7.3 and Xcode 8 beta 2\n. Carthage builds all succeed too! \ud83d\udc4f \n. Yep, this seems like a pretty clear regression to me. I mainly raised it here for visibility. It would be possible to work around this by extracting the conditionally compiled code out of the closure expressions and into separate functions, but that doesn't seem worthwhile to me.. Seems to be working \ud83d\udc4d . @Quick/core Would love your input on whether to merge with this warning. If so, we could put out a patch release that supports Swift 4.. > There's a warning with Swift 3 but everything is still compatible with Swift 3 and you have a working version for Swift 4?\nThat's correct. In Swift 3 this change generates a new warning (and infuriatingy a fixit), and under Swift 4 in compatibility mode compiles without any new warnings.\nWe may also need to add -swift-version 3 for this to compile in Xcode under Swift 4. I'll investigate this before merging.. Ok, I've added the -swift-version 3 flag to the xcodeproj. Xcode made some automatic changes, so I committed those also.\nNote: The tests don't compile under Swift 4 due to operator overload ambiguity. I don't know why, but it seems like maybe a Swift 3 compatibility bug? This also probably indicates that Swift 4 consumers won't be able to use certain operators right now, but at least compiling is a start!. @phatblat Thanks! \u2728\nI don't use that email anymore, but I went ahead and added my current email address as an owner.. Discussing details of @Dschee's stringify fix over here: https://github.com/Quick/Nimble/pull/532#issuecomment-394761113.. It would be nice to also have this on CI, but that will probably take a little while. Shouldn't stop us from merging this I would hope. @Quick/core where do we stand on the definition of breaking changes? This should be a source-compatible change, in which case it seems fine to include this in a patch release. Not binary compatible though.. Is anyone at WWDC that could take this crash to the a Swift lab?\nIn any case, I'm going to go ahead and merge!. @ikesyo Interested in tagging 7.1.2?. @Dschee Will this result in optional values being stringified as Optional(thing) instead of thing?. Yep, looks like that's why the tests are failing: https://travis-ci.org/Quick/Nimble/jobs/388306269#L4047\nExpected error message (These aren't equal!\nexpected to not match, got <1>), got (These aren't equal!\nexpected to not match, got <Optional(1)>). Lgtm!. Would it make sense to stash the previous value so we can restore it, rather than assuming true?. Curious, can this closure be throwing? Would be nice to replace try! with try (although I'm not familiar with the possible failures here).. Ok so from what I can tell NMBObjCMatcher and NMBPredicate are separate classes that both conform to NMBMatcher \u2014 so it should be non-source-breaking to replace NMBMatcher with NMBPredicate (more specific return type), but it's technically breaking to replace NMBObjCMatcher with NMBPredicate, because they don't share a common base class other than NSObject. (Let me know if I'm missing something.)\nIt's probably unlikely to be a big deal, but worth considering.. Definitely cleaner \ud83d\udc4d . No need for let error here as error is bound automatically. same here about let error. let error. This error text is repeated, is there something we can extract here?. let error. let error. let error. Thoughts on restructuring this to avoid the force-unwrap?. Not necessary in this PR, but wondering if we can rename this to allSatisfy and make it a compatibility shim for Swift < 4.2? https://github.com/apple/swift-evolution/blob/master/proposals/0207-containsOnly.md. Thoughts on restructuring this to avoid the force-unwrap?. Would it make sense for this function to become a mutating method on FailureMessage?. FWIW, the explicit = nil shouldn't be necessary here.. How would you feel about moving this return statement into an else branch above?. It feels slightly weird to rely on NSSortOptions here, how do you feel about creating a TestOptionSet type for testing purposes?. Having our own option set type here would also decouple us from NSSortOptions's implementation of string conversion.. Oh, good catch. Should we add a test that covers this difference between beFalse() and beFalsy()? We're also accepting values that fail to cast to NSNumber, should we also return nil if the cast fails?. ",
    "tmandry": "An error message helps, thanks!\n. Curious what you mean about the new waitUntil behavior.. does that mean it will only wait for changes that are caused by background threads?\n. ",
    "wizzardchao": "It seems it's a swift compiler's bug to support array of tuple. I can also not append an element to an array of tuple.\n. ",
    "jonnolen": "in this case:  expect(tuple == tuple2).to(beTrue()) is what I ended up falling back to.  still won't handle arrays but solves the expected type issue.. ",
    "bgerstle": "@jeffh I've re-re-refactored the API in a way that uses more conventional Nimble syntax while also removing the need for expression: label.  I've also addressed your other comments\n. @jeffh If you like this new approach, I can add ObjC API & update README\n. @jeffh looks like there's a flaky ObjC test, probably unrelated to my changes.\n. @jeffh I agree that matching the name only is probably the most common use case and having the helper function allows users to map the output and compare only the field(s) they want.  IMHO it should be in the matcher and not in a helper for two reasons:\n- I didn't like the helper function since it didn't match the usage of anything else in Nimble\n- Keeping all the matching logic together results in better readability\nFor example:\nswift\nexpect { ... }.to(postNotifications(contains(notificationWithName(equal(\"Foo\"))))\nversus:\nswift\nexpect { postedNotifications { ... }.map { $0.name } }.to(equal(\"Foo\"))\nKeeping everything at the matcher level also allows users to mix and match concerns for individual notifications:\nswift\nexpect { ... }.to(postNotifications(contains(notificationWithName(equal(\"Foo\")),  testNotificationWithSpecificNameAndObject))\nAlso, I would postulate these kinds of field-specific matching use cases are common enough to justify their own generic matcher.  For example, OCHamcrest implements hasProperty so you can assert that an object's property value satisfies a matcher.  For example: assertThat(obj, hasProperty(@\"foo\", startsWith(@\"bar\")).  This is obviously harder to do with Swift (especially since var isn't accessible via getter function), but would make more sense if a functional approach were taken (e.g. lenses).\n. thanks @jeffh i'll merge in master soon and address remaining checklist items. would like to see this in as well :grinning: \n. @mgetzbw I believe so, using toEventually(postNotification(...)), but I'll have to check. Thanks for bringing it up!\n. @mgetzbw like I said, this should work as long as the notification is \"eventually\" posted to the observed center.  we might not be able to test .PostWhenIdle in practice because Nimble will be polling to check if the matcher was satisfied. Might need to adjust the polling interval, but either way I'll report back with whether or not I've tested .PostWhenIdle specifically\n. @mgetzbw perhaps, but runloop pumping might be sufficient to simulate idleness, which is what Nimble does while waiting for async expectations\n. Yeah! I'll try to get that in soon.\nOn Wed, Feb 3, 2016 at 01:34 Jeff Hui notifications@github.com wrote:\n\nHey @bgerstle https://github.com/bgerstle,\nI've merged in the changes and resolved the conflicts, there's still\nmissing the README and Objective-C support. Are you interested in picking\nthat up?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/228#issuecomment-179039168.\n. Could that be at all related to the stall on main thread issues?\nOn Tue, Feb 2, 2016 at 22:53 Jeff Hui notifications@github.com wrote:\nHmm, the isEventually postNotifications test seems flaky:\nhttps://circleci.com/gh/jeffh/Nimble/25\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/228#issuecomment-179049662.\n. Ah, that's a relief. Can either change expectation to \"contains\" or use a\nprivate Notification Center.\nOn Wed, Feb 3, 2016 at 01:27 Jeff Hui notifications@github.com wrote:\nDon't think so, it looks like other notifications fired during that time:\nexpected to eventually equal <[NSConcreteNotification 0x7fb0a24df940 {name = Foo}]>,\ngot <[__CFNotification 0x7fb0a24e1b00 {name = NSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24e1b80 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24e1cb0 {name = NSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24e1ce0 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24e1bb0 {name = NSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24c9b00 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24c9b90 {name = NSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24c9bc0 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\n__CFNotification 0x7fb0a24c9bf0 {name = NSUserDefaultsDidChangeNotification; object = },\n__CFNotification 0x7fb0a24c9c20 {name = com.apple.CFPreferences._didChange; object = com.apple.CFPreferences; userInfo = {}},\nNSConcreteNotification 0x7fb0a24df940 {name = Foo}]>\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/228#issuecomment-179118948.\n. @jeffh the log isn't very helpful, any idea what could be wrong? should notification-based testing be run on OSX only, since it's specific to Foundation?\n. @jeffh i found the offending build log statement, was just lost in all the Swift 3 warning noise.\n. it seems like setUp is still called, even though Linux XCTest doesn't seem to have a super implementation :confused: \n. Nice!\n\nOn Fri, Feb 19, 2016 at 11:53 AM, Brian Croom notifications@github.com\nwrote:\n\n@bgerstle https://github.com/bgerstle yes that's correct, although the\nconditional won't be needed for too much longer. See:\napple/swift-corelibs-xctest#40\nhttps://github.com/apple/swift-corelibs-xctest/pull/40\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Quick/Nimble/pull/251#issuecomment-186300580.\n. > I think the postedNotifications func is causing problems that forces expect(expression: ...) form you're talking about. postedNotification should return the observed notifications:\n\nYou're probably right, didn't think about how @autoclosure could be affecting parameter type inference.  I'll try your suggestion.\n. ",
    "mgetzbw": "Will this support .PostASAP and .PostWhenIdle?\n. @bgerstle I bring it up because I've had trouble getting those two to work properly even in XCTest so I'm curious if you'd found a solution. .PostWhenIdle is probably going to be the hardest because it requires the runloop to be \"Idle\" for a given definition of idle.\n. @bgerstle it strikes me that .PostWhenIdle may not be testable, as thread waits prevent the runloop from running, and the docs on .PostWhenIdle specifically mention that it runs as the last thing in the queue. This would preclude being able to race to the end unless we are able to run the test on an alternate runloop, which itself creates innumerable problems.\n. ",
    "jwfriese": "Hey there @jeffh,\nI've updated this PR with a set of changes that address most of your points. It even adds an || operator! :)\nThe only thing I wasn't able to address is your nitpick about using nil termination in the ObjC macro. I had trouble writing the macro such that it would not allow you to pass nil through in ObjC land. I tried using the _Nullable keyword in the macro with some success, but introducing it into the file raised compiler errors complaining about unspecified nullability in every other signature with an id in the file. \nI'd be happy to reproduce the code I'm talking about. Additionally, if you could point me in the direction of the fix you were talking about, I could take another crack at it. \nLet me know what you think! \n. @jeffh,\nThanks for the guidance w.r.t. the macro adjustment. To think I danced all around that! One of the commits makes this change. \nThe other commit prints an error message when the satisfyAnyOf matcher is called with no matchers in Objective-C land. The complier stops you from doing this in Swift land, but now there will be a runtime error that notifies you when you do it. \nLet me know what you think!\n. @jeffh - I agree with your sentiment -- beIdenticalTo for some reason is quicker to mind for me too. But then, I'm not super experienced in RSpec.\nWhat would you think about aliasing this and having both around? I can see where it might be needless bloat, but the thought crossed my mind when I first looked at this issue. \n. @jeffh @jcampbell05 \nIs this completed with #241? \n. @jeffh - Too much time must have passed since I last had my code reviewed... I seem to have forgotten how to see your comments, Jeff \ud83d\ude05 Where do I look to find the changes you've suggested? \n. @jeffh - No worries at all, it's happened to me before. \nI've addressed all your comments, and also slipped in a rename from ContainObjectSatisfying to ContainElementSatisfying, which I think is a more appropriate name. \nLet me know if there are any other changes you'd like to see, and thanks for being quick with your feedback. \n. @ikesyo @jeffh - Thanks for pitching in to help get the code working on Linux, Syo. Is this good to merge now?. @jeffh - You're 100% correct. \n@AdamMak - In order for this test to work in the way you're expecting, you'll have to host the text field in a view that itself is within a window. We had to do something like this to test the UITextView and UITextField functionality of Fleet. \nHere's the test that sets up the UITextField correctly: https://github.com/jwfriese/Fleet/blob/2f2ffd64d4b176d702ce8e756e0c69aeff5b448d/FleetTests/CoreExtensions/Controls/TextInput/UITextField%2BFleetSpec.swift#L19\nAnd here's the helper method that is used within the setup of that test: https://github.com/jwfriese/Fleet/blob/2f2ffd64d4b176d702ce8e756e0c69aeff5b448d/FleetTests/Helpers/EmbedView.swift#L21. Hi @rmato - \nI've taken a crack at reproducing the issue that you've experienced. Here's the modification that I made to the tests for beAnInstanceOf:\n```\nprivate class Superclass {}\nprivate class Subclass: Superclass {}\nprivate class SubclassOfSubclass: Subclass {}\n...\n        let superclass = Superclass()\n        expect(superclass).to(beAnInstanceOf(Superclass.self))\n        expect(superclass).toNot(beAnInstanceOf(Subclass.self))\n        expect(superclass).toNot(beAnInstanceOf(SubclassOfSubclass.self))\n    let subclass = Subclass()\n    expect(subclass).toNot(beAnInstanceOf(Superclass.self))\n    expect(subclass).to(beAnInstanceOf(Subclass.self))\n    expect(subclass).toNot(beAnInstanceOf(SubclassOfSubclass.self))\n\n    let subclassOfSubclass = SubclassOfSubclass()\n    expect(subclassOfSubclass).toNot(beAnInstanceOf(Superclass.self))\n    expect(subclassOfSubclass).toNot(beAnInstanceOf(Subclass.self))\n    expect(subclassOfSubclass).to(beAnInstanceOf(SubclassOfSubclass.self))\n\n```\nThe tests above all passed as you'd expect them to. Do you have any example code we could work off of to try to figure out what's going on? . Thanks for the quick feedback @ikesyo  -- I just push the fix you suggested. . @ikesyo - I've pushed another update. I'm sorry if my process seems a little cavalier -- I don't know of any way for me to easily test these changes on Linux locally. Do you have any suggestions, or is the process we're going through right now acceptable? . Cool, thanks so much for sharing that. In the future, I'll test my changes on Linux like this before pushing. . ",
    "jcampbell05": "An alias would be great :) :+1: \n. ",
    "mbogh": "Thank you so much @jeffh :+1: \n. ",
    "hamchapman": "Having deleted everything in DerivedData the problem remains but with a different library mentioned in the error:\n2016-01-12 11:31:11.685 xctest[37278:1011889] The bundle \u201cPusherSwiftTests\u201d couldn\u2019t be loaded because it is damaged or missing necessary resources. Try reinstalling the bundle.\n2016-01-12 11:31:11.686 xctest[37278:1011889] (dlopen_preflight(/Users/Hami/Library/Developer/Xcode/DerivedData/PusherSwift-cifrlthdfybbcedmlylirqthvkky/Build/Products/Debug/PusherSwiftTests.xctest/Contents/MacOS/PusherSwiftTests): Library not loaded: @rpath/CryptoSwift.framework/Versions/A/CryptoSwift\n  Referenced from: /Users/Hami/Library/Developer/Xcode/DerivedData/PusherSwift-cifrlthdfybbcedmlylirqthvkky/Build/Products/Debug/PusherSwiftTests.xctest/Contents/MacOS/PusherSwiftTests\n  Reason: image not found)\nProgram ended with exit code: 82\nSo I'm not sure if this is to do with Nimble at all...?\n. Closing for now as I think this is more to do with Cocoapods. See issue there: https://github.com/CocoaPods/CocoaPods/issues/4752\n. ",
    "ianbytchek": "@Dschee constantly forgetting this\u2026\n. @ikesyo Just updated to latest framework version and getting what seems to be a related issue with IndexSet, which conforms to both Collection and SetAlgebra:\nlog\nTest.Renderer.swift:18:57: error: ambiguous use of 'beEmpty()'\n            expect(renderer.pendingFrames).toEventually(beEmpty())\n                                                        ^\nNimble.beEmpty:1:13: note: found this candidate\npublic func beEmpty<S>() -> Nimble.Predicate<S> where S : Sequence\n            ^\nNimble.beEmpty:1:13: note: found this candidate\npublic func beEmpty<S>() -> Nimble.Predicate<S> where S : SetAlgebra\n            ^. Hmm, didn't look deeply at the source, but assuming there's a separate predicate for Collection? Doesn't look like IndexSet has anything to do with Sequence. Can I help with any other info?. ",
    "CullenSUN": "If you are including Quick please note\nYour Test Target Must Include At Least One Swift File\nRef\n. ",
    "mattgallagher": "By all means, copy my code. Provided you pull the copyright headers along with it, there's no other attribution required.\n@abbeycode Personal opinion: subtrees are usually better than submodules, where possible. They're no more tricky than copying and pasting files into your source tree. Which you're welcome to do as well, if it simplifies things.\n@morganchen12 If Linux support is valuable to you, you could catch the SIGILL with a signal handler. I've updated my post with a comment about why this is a pain in the butt but it remains possible.\n. @modocache If your question was: \"Am I happy with you copying the approach of my code but not the actual code itself?\"... Sure. I don't blog about it because I'm feeling proprietary :-) In that case, a link back to me is not technically required but always appreciated.\n. I had completely overlooked the POSIX target of CwlPreconditionTesting when I updated CocoaWithLove for Swift 3. I've immediately done that work, now. As for https://github.com/mattgallagher/CwlPreconditionTesting/issues/5 ... if you have a reproduction or PR for this, just let me know. I was never able to reproduce and assumed it was just one of those \"Xcode being glitchy\" issues.\n. ",
    "paulz": "Just got this error today on Xcode 7.3 beta, here is the complete list of errors and warnings: \nNimble/Adapters/NimbleXCTestHandler.swift:9:64: error: cannot convert value of type 'String' to expected argument type 'StaticString'\nNimble/Adapters/NimbleXCTestHandler.swift:25:48: error: cannot convert value of type 'String' to expected argument type 'StaticString'\nNimble/Matchers/Contain.swift:30:33: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.\nNimble/Matchers/Contain.swift:30:33: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.\nNimble/Matchers/Contain.swift:30:33: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.\nNimble/Matchers/SatisfyAnyOf.swift:13:56: warning: '++' is deprecated: it will be removed in Swift 3\nNimble/Matchers/SatisfyAnyOf.swift:13:9: warning: C-style for statement is deprecated and will be removed in a future version of Swift\nNimble/Matchers/SatisfyAnyOf.swift:13:56: warning: '++' is deprecated: it will be removed in Swift 3\nxcodebuild -version\nXcode 7.3\nBuild version 7D129n\n. This also crashes for us when we try to use .keys:\nit(\"contains keys\") {\n    let foo = [\"a\": 1, \"b\": 2]\n    expect(foo.keys).to(contain(\"a\", \"b\"))\n}\nhowever when we wrap them into an Array it works:\nit(\"contains keys\") {\n    let foo = [\"a\": 1, \"b\": 2]\n    expect(Array(foo.keys)).to(contain(\"a\", \"b\"))\n}\n. To reproduce set test target to Swift4.\nHere is a failing test example: https://github.com/paulz/Nimble/commit/1cda7c153e7f3d37fa28c01955d4a4f4f3f93d9c. Thank you for the info and link, @stardustWK \nLucky us to discover that in our quick specs! . ",
    "Hout": "beta 3 has the same issue\n. ",
    "JanC": "Hi\n\nI've merged this on to master. I'll cut a release soon.\n\nany update on this? It would be nice to have a release or beta with Siwft 2.2 in CocoaPods\n. ",
    "pcantrell": "Good point. Is there a term of art for all those? I was trying to keep the message short.\n. Here are screenshots of a few different approaches to the message, as they\u2019d actually appear to a user in Xcode.\n\n\n\n\nLet me know if there's one you prefer and I\u2019ll happily drop it into this PR \u2014\u00a0or you can just merge and then tinker yourself if you prefer.\n. Based on this opinion sample of N=2, I pushed the 4th wording with two minor additions:\n- single quotes around code to bring the message into line with other Swift compiler messages, and\n- a hint that some operators work as well as .to() and friends.\n. You bet!\n. @raphaelcruzeiro: Siesta has been using this fork successfully (and the corresponding Quick fork as well). On the beCloseTo question, I\u2019ve had success using \u2248 and \u00b1:\nhttps://github.com/bustoutsolutions/siesta/blob/swift3/Tests/ProgressSpec.swift#L112\nI was even able to remove a Double(\u2026) coercion that Swift 2 required.\nThanks, @norio-nomura, for keeping these forks going!\n. ",
    "benjaminsnorris": "I am really excited for the possibilities this would open up. It feels frustrating right now to not be able to test the edge cases of the app to define the cases where it should fail. Hopefully this can be merged soon!\n. ",
    "ReadmeCritic": ":wink: \n. ",
    "inamiy": "@jeffh \nThanks for reply!\nHere's a test code I wrote for next try! conference :)\n``` swift\ndescribe(\"skipSpaces\") {\nlet p: Parser<String, ()> = skipSpaces\n\nit(\"succeeds\") {\n    let reply: (input: String, output: ())? = parse(p, \" \\t\\n\\rabc\")._done\n    expect(reply?.input) == \"abc\"\n    expect(reply?.output) == ()\n}\n\nit(\"succeeds (no spaces)\") {\n    let reply: (input: String, output: ())? = parse(p, \"123\")._done\n    expect(reply?.input) == \"123\"\n    expect(reply?.output) == ()\n}\n\n}\n```\nI intentionally added type annotations above, but basically they can be omitted.\nBut if we do so, we will have no idea what type reply?.output will be, and all we can test is using expect(reply?.output).toNot(beNil()), which works fine but it is hard to describe that output actually returns Void.\nBTW, test code is already added in BeVoidTest.swift, and I think there's not much to add further.\n. Oh I also should mention that above == is actually using the following instead of normal one:\nswift\npublic func ==(lhs: Expectation<()>, rhs: ()) {\n    lhs.to(beVoid())\n}\n. Thanks! I will use this now :)\n. ",
    "glentregoning": "@ikesyo that indeed works, but not ideal.\nPerhaps I was a little strong saying this is impossible. I've updated my answer to say this isn't possible using the traditional matcher syntax. \n. ",
    "mjbeauregard": "I also much prefer to avoid async tests, but sometimes the things you are testing are inherently asynchronous. For example, when testing classes that use promises, even if the promise is fulfilled immediately you still need to do async testing due to the bit of thread-hopping inherent to that design. I don't think I can do much about that part. \nI wonder if this issue is related to this being a pretty large project (takes TravisCI over 20 minutes just to compile). As I mentioned, this problem never happens when running tests locally. I'll take a look and will probably submit a PR with the proposed change.\nThanks for your work on this fantastic library.\n. I made an interesting discovery yesterday while debugging this. I noticed that our Travis config was explicitly running tests on the \"iPad Air2\" simulator (where we were getting timeouts), but I always test locally on the \"iPad 2\" simulator (where we never had any timeouts). \nI have verified by playing with the destination simulator setting that we are getting consistent results between Travis and local builds now. Both builds have timeouts when running on the \"iPad Air2\" simulator and and both pass on the \"iPad 2\".\nI'm not sure why this would be the case just yet, but will keep digging and report back any findings. I agree that this could possibly be somehow related to the SwiftTask library that we are using.\n. Note that we are still testing this PR in a real project and the results are mixed. For a few days we thought we had solved the problem, but are seeing timeout errors again today which is getting really frustrating. I will follow up again after more testing.\n. Given the expression:\nexpect(someValue).toEventually(equal(\"blah\"), timeout: 5.5, pollInterval: 0.2)\nNimble will repeatedly evaluate someValue every 0.2 seconds until it equals \"blah\" or until it times out (after 5.5 seconds, at which point the test will fail).\n. Thanks for the suggestion. After a bit of exploration, it doesn't look like Quick or Nimble are directly consuming much time. \nI haven't profiled our tests before so I'll continue dig into that for a while to see if there is anything obviously slow in our tests. But even so, I'm not sure that would explain why the tests are fast when run individually compared to running within the full test suite.. Here is a followup after considerable debugging:\nI managed to trace the slowness down to a particular view controller test. I discovered that due to a retain cycle keeping the window.rootViewController instance alive, there was a condition where the subject under test was trying to present an alert from rootViewController during viewDidLoad. Since the rootViewController was still referring to the previous instance of the subject which had been removed from the view hierarchy in the afterEach, the attempt to present the alert was causing UIKit to complain with:\nWarning: Attempt to present <UIAlertController: 0x7fc3ed7f6110> on <App.TestViewController: 0x7fc3f08265c0> whose view is not in the window hierarchy!\nIt appears that UIKit can then get into a state where every subsequent view controller test runs very slowly despite the cpu being mostly idle. Fixing the retain cycle so that when the subject is removed from the view hierarchy in afterEach cures the warning as well as the slow UIKit behaviour that was slowing the remainder of the test suite.\nTLDR; This slowness seemed to be related to a UIKit bug that was triggered by trying to present an alert from a view that is no longer in the view hierarchy.\nThanks for your suggestions and help troubleshooting. I'm closing the issue since it appears to have nothing to do with Quick/Nimble. Thanks!. ",
    "pivotalstitch": "Can someone please specify what a polling interval is? Also, how would one use this?\n. ",
    "inket": "Alright :+1: \n. @briancroom \nThought about it but couldn't think of an appropriate format to represent it: NSData<hash=123456789,length=38849> or NSData(hash:123456789,length:38849) or other variations? I'm open to suggestions otherwise I will just use the first one.\nIt is indeed useful to show the byte count as it would make it easy to tell whether an NSData is empty or not (and other things) at a glance.\n. After implementing tests, it seems that the Linux test fails because NSData's hash() causes a segmentation fault.\nUsing the REPL on Mac:\nWelcome to Apple Swift version 3.0-dev (LLVM b361b0fc05, Clang 11493b0f62, Swift 24a0c3de75). Type :help for assistance.\n  1> import Foundation\n  2> \"foobar\".dataUsingEncoding(NSUTF8StringEncoding)?.hash\n$R0: Int? = 114710658\non Linux:\nWelcome to Swift version 3.0-dev (LLVM b361b0fc05, Clang 11493b0f62, Swift 24a0c3de75). Type :help for assistance.\n  1> import Foundation\n  2> \"foobar\".dataUsingEncoding(NSUTF8StringEncoding)?.hash\nExecution interrupted. Enter code to recover and continue.\nEnter LLDB commands to investigate (type :help for assistance.)\nI fixed that by using #if os(Linux) and falling back to NSData<length=*> for now. But if that's not ideal, we can use the NSData<length=*> for all OS ? Please advise.\n. Thanks! This PR is good for a last review now \ud83d\ude01\nWill report the bug on the Swift bug tracker later.\n. ",
    "younata": "Closing in favor of https://github.com/Quick/Nimble/pull/269\n. Thanks for doing this, @briancroom. Wish I had time (this is a lie, I've had time - I've just been busy with other projects) to see this through.\n. ",
    "jmejiaa": "Thanks @jeffh sorry for the late reply. I meant to add it to Quick. The thread suggests using a function in the beforeEach , which I guess would work just as well\n. Still having this issue on v7.0.2 - @stephengazzard did you change anything else that could havbe solved it?. ",
    "szweier": "Sure I'll get an example together shortly.\n. I've updated my comment above to show an example of what fails.  If there's more information that you'd need I'll be happy to provide what I can.\n. @briancroom any update here? I just moved to 7.3 so I have to upgrade but now I can't run any exception tests.\n. @briancroom I've added an example app to the original comment that you can check out for the failure I'm talking about.  Thanks.\n. Thanks @jeffh\n. Is there an eta on the new release?\n. After some more digging it looks like there's likely an issue in the overall setup of the tests I currently have.  A small scale test has shown that toEventually is working.  Will do more digging and open again if it proves necessary.. Seeing the same issue seems to be Xcode 9.1 specific.. ",
    "tbogosia": "Hi, I'm facing the same issue. Any updates on when this release will be available? Thanks!\n. ",
    "humblehacker": "Thanks for your feedback @briancroom.  I've added tests for beEmpty and haveCount for NSIndexSet. In the process, I also made the following changes:\n- Added a testDescription method to NSIndexSet to get its displayed string down to something reasonable. \n- Added a test for NSIndexSet stringification.\n- Added missing calls to stringify() in the HaveCount matcher.\n- Added some missing NSSet test cases to BeEmptyTest.testBeEmptyNegative()\n. @jeffh Thanks for the feedback.  All tests green!\n. I'm getting this too with Nimble 4.0.0 installed via CocoaPods.  I was able to temporarily work around it by editing the generated umbrella header and commenting out CurrentTestCaseTracker:\n``` objc\nimport \n//#import \"CurrentTestCaseTracker.h\"\nimport \"DSL.h\"\nimport \"NMBExceptionCapture.h\"\nimport \"NMBStringify.h\"\nimport \"Nimble.h\"\nFOUNDATION_EXPORT double NimbleVersionNumber;\nFOUNDATION_EXPORT const unsigned char NimbleVersionString[];\n```\nAfter this, I get warnings \n/Users/david/src/EasyShiftIOS/Carbon/Example/<module-includes>:1:1: Umbrella header for module 'Nimble' does not include header 'CurrentTestCaseTracker.h'\nbut my tests are successfully run.\nLooking for a more permanent solution as this clearly won't work for automated builds.\n. ",
    "jlalvarez18": "What's the status update on this pull request?\n. ",
    "mendesbarreto": "Hello man!\nI'm having the same issue here after I updated to xcode 7.3.\n. ",
    "paweldudek": "@jeffh unfortunately looks like the issue actually lies within Nimble :cry: \nSpecifically it looks like adding a custom tests observer (in this case CurrentTestCaseTracker) prevents default XCTest output from being printed onto console. Scan, and any other tool that relies on this output, will be broken since there's nothing to parse. \nI'm not yet entirely sure whether this is desired behaviour as there's little next to none documentation on this, but I'd rather say it's a bug in latest XCTest.\nEDIT: \nI did a bit more digging and it looks like that adding CurrentTestCaseTracker as tests observer in its +load method triggers a bug in XCTest that prevents it from adding the default tests reporter that prints that beautiful XCTest output onto console. Simply deferring registration fixed the issue. I'll try to come up with a PR in a second. \n. @modocache looks like @ashfurrow was faster than me :wink: \n. ",
    "palfvin": "Yes, that took care of it.  Thanks.\n. ",
    "atillman": "Also, this issue just started for all expecations in my project after I upgraded to the latest version and did not happen when I was running the xcode 7.2 with the xcode7.1 version of nimble and quick\n. Oops, I was mistaken.  I am already using master.  Sorry about that.  That is what is already in my Podfile.  I will update the description\n. No.  They are just basic spec tests.  I got it on the new spec I was writing but when back and checked that it happened with the old specs as well.\n. 4.0.1 also working for me.  Thanks!\n. ",
    "kevinmcconnell": "I'm seeing the same problem since #271.  Reverting to a version earlier than that seems to solve it, though.\n. I just updated to 4.0.0 and it's working great for me so far.  Test output looks correct, for both passing & failing expectations, and I no longer see any NSInternalInconsistencyException on failure.\nI'll let you know if the problem resurfaces for me later.  But as far as I can tell for now, it looks fixed.\nThanks!\n. ",
    "gca3020": "I was having a similar issue with 4.0.0, but updating to 4.0.1 seems to have fixed it.\n. ",
    "norio-nomura": "It seems updating test script for Linux is not needed.\n. Rebased.\n. This PR has already been incompatible with swift-DEVELOPMENT-SNAPSHOT-2016-04-12 because of SE-0046 Establish consistent label behavior across all parameters including first labels.\nAlmost of functions and methods need to be enclosed with #if swift(>=3) for supporting both of swift 2.2 and 3. e.g. https://github.com/antitypical/Result/pull/149/files\n. I can't say which is better whether supporting swift-2.2 and 3 simultaneously or branching them.\n. I'd happy to update nn-swift-3-compatibility to work with swift-DEVELOPMENT-SNAPSHOT-2016-04-25 and drop supporting swift-2.2. I hope I would do that before next snapshot coming.\n. We can use Swift 3 with Xcode 7.3 on Travis-CI as following: https://github.com/norio-nomura/SWXMLHash/blob/nn-swift22-and-swift3-compatibility/.travis.yml#L11-L18\n. Rebased and updated to swift-DEVELOPMENT-SNAPSHOT-2016-05-03-a.\n- [x] Removed Swift 2.2 support. Swift3to22.swift remains for linux support.\n- [ ] podspec fails since swift-DEVELOPMENT-SNAPSHOT-2016-04-12-a\n- [x] BeCloseToTest fails on linux since swift-DEVELOPMENT-SNAPSHOT-2016-05-03-a\n. Updated to swift-DEVELOPMENT-SNAPSHOT-2016-05-09-a.\nNow test podspec is only failing test on Travis-CI.\nDo we need to fix that for creating swift3 branch from this PR?\n. By using cocoapods-1.0.0, test podspec passed on Travis-CI. \ud83d\ude03 \n. Now, I updated to swift-3.0-preview-1 and all tests are passed on my Mac.\nOn Travis-CI:\n- test randomly fails\n- podspec is disabled because of https://github.com/CocoaPods/CocoaPods/issues/5519\n. I updated, but travis is not yet.\n. I updated, but travis is not yet.\nOn linux, it failed with https://github.com/kylef/swiftenv/pull/47\n. Tests passed on swift-3.0-PREVIEW-2\n. Now this PR is compatible with swift-3.0-PREVIEW-5. Thanks @mokagio!\n. @raphaelcruzeiro CGFloat was implicitly converted to NSNumber on Swift 2.2.\nSE-0072 removes those conversions.\nCasting your CGFloat to NSNumber will help you.\nOf course PR will be welcomed. \ud83d\ude09 \n. Maybe making CGFloat conforming to NMBDoubleConvertible will be better resolution.\n. Now CGFloat conforms to NMBDoubleConvertible by https://github.com/norio-nomura/Nimble/pull/7\nThank you @raphaelcruzeiro!\n. @ikesyo Thanks! I have changed base branch to swift-3.0. \ud83d\ude4f \n. Thanks! \ud83d\ude4f . For supporting uses associatedtype constraints on some functions, Sequence is defined as protocol inheriting SequenceType.\nThat would require some SequenceType types defined on consumer to conform as:\n``` swift\nif !swift(>=3)\nextension MyCustomSequence: Nimble.Sequence {}\nendif\n```\n. ",
    "liscio": "Just FYI I have opened a PR against Norio's fork here: https://github.com/norio-nomura/Nimble/pull/1\nIt now builds & passes the tests for both the iOS & Mac targets.\n. ",
    "andersio": "Lower deployment target to 10.9: https://github.com/norio-nomura/Nimble/pull/3\nPlease have a look.\n:)\n. ",
    "mokagio": "FYI, I did some work for Xcode 8 Beta 4 https://github.com/norio-nomura/Nimble/pull/5. There are two issues that I haven't yet been able to work around, I'd appreciate feedback on them.\n. Thanks @bonkey for this PR \ud83d\udc9a \ud83c\udf7b \n@jeffh would it be possible to release a patch update with this (6.0.1)?\nThis issue results in a failure when pulling Nimble via Carthage using the --no-use-binaries option, which makes Carthage to actually build the frameworks, and SwiftLint fails the build \ud83d\ude1e .. Received notification of v6.0.1. Thanks @jeffh you're the man! \ud83d\udcaa\u2764\ufe0f. ",
    "raphaelcruzeiro": "Did you have success using this branch of Nimble to tests actual projects? I'm trying to convert my tests to use this version of Nimble with Swift 3 and I have errors everywhere I use beCloseTo. Namely, Generic parameter 'T' could not be inferred and Ambiguous reference to member 'beCloseTo(_:within:)'.  My guess is that Nimble is not working well with CGFloat.\n. @norio-nomura Agreed. I'm gonna start working on that then ;)\n. Now that CGFloat conforms to NMBDoubleConvertible it should work fine for all the matchers.\nAnd yeah! Thanks to @norio-nomura for taking the step forward and getting this branch up and working!\n. ",
    "ldiqual": "@briancroom Thanks a lot for your response! This is useful in view controller testing to ensure that pressing a button doesn't show a specific modal, for instance.\nvc.button.sendActionsForControlEvents(.TouchUpInside)\nexpect { vc.presentedViewController }.toRemain(equal(nil))\nI like your solution, and it'll mostly cover the case above even if not polling periodically. I understand that my case might be too specific for an inclusion in Nimble, so I'll just write my own extension here. Thanks!\n. Weird indeed. I'll update my code to use implicit closures and will close the issue if I can't reproduce within a week. Thanks for the followup!\n. @jeffh This error still happens very infrequently, but I don't have reproduction steps so I'll close the issue. Thanks for following up!\n. Update: do/catch doesn't work around the issue :/\n. My bad, I was putting this code in a describe instead of a it. Closing.\n. Just saw https://github.com/Quick/Nimble/releases/tag/v7.0.1 and I'm really confused as I'm using 7.0.1. I'll clear my pods folder and try again.. Not sure what happened, but Quick now compiles. Closing now.. ",
    "delebedev": "@briancroom thanks for the snippet, I'm going to stick with this approach\n. Here is more real example I'm seeing:\nswift\nexpected to equal <[field(title: \"Amount\", value: \"<positive>+</positive>\u00a060.00\u00a0GBP\"), field(title:\n \"Date completed\", value: \"Monday, January 1, 2001\")]>, got <[field(title: \"Amount\", value: \"\n<positive>+</positive>\u00a060.00\u00a0GBP\"), field(title: \"topup.details.dateCmpleted\", value: \"Monday, \nJanuary 1, 2001\"), action(title: \"Repeat this pay-in\", type: \nCustomControls.TWButtonStyle.secondary, action: \nTransfer.ActivityDetailsViewModel.Action.repeatTransfer(1)), field(title: \"Transfer number\", value:\n \"#1\")]>\n. ",
    "raphaeloliveira": "Hi @briancroom, I'm struggling to translate your matcher to latest Nimble version. By any chance would you be able to help on this please?. ",
    "aaronbrethorst": "@raphaeloliveira \n```\npublic func equalNames(_ expectedNames: [Notification.Name]) -> Predicate<[Notification]> {\n    return Predicate.define(\"equal <(stringify(expectedNames))>\") { actualExpression, msg in\n        guard let actualValue = try actualExpression.evaluate() else {\n            return PredicateResult(status: .fail, message: msg)\n        }\n    let actualNames = actualValue.compactMap { $0.name }\n    let matches = expectedNames == actualNames\n    return PredicateResult(bool: matches, message: msg)\n}\n\n}\n```. Sorry yes. 5.1.1\n. ",
    "jeffscaturro-wf": "I thought it may be something like that but we could not narrow it down. @morganchen12 - thank you for your explanation as well as solution, just verified it works. Appreciate it!\n. ",
    "Blackjacx": "I have this issue too with nimble 4.1.0: \nexpect(panelMock.isSearchPanelAnimationInProgress).toEventually(beFalse())\ngives me \nexpected to eventually match, got <false>\nI needed to replace the toEventually by a preceeding call to the following function:\nfunc delay(seconds: NSTimeInterval) {\n    let end = NSDate(timeIntervalSinceNow: seconds)\n    while NSDate().compare(end) == .OrderedAscending {\n        NSRunLoop.currentRunLoop().runUntilDate(NSDate(timeIntervalSinceNow: 0.1))\n    }\n}\nThis function does not block the respective thread but gives it time to execute and finish tasks. I have seen that Nimble has these blocking issues too sometimes. How did you implement the function toEventually, especially the waiting part?\n. Hmmm I cannot reproduce that issue with a clean project but I get the following failure message:\ntimed out, but main thread was unresponsive\nI searched for it and it indicates a blocked main thread. This leads to randomly failing test cases that use toEventually. \nBut maybe I found a solution in our code for that. I do a performSelectorOnMainThread with waitUntilDone set to true. This may cause some deadlocks.\nSo I think it is a failure in our code and you can close this issue.\n. I've already cleaned everything. The CI builds of 4 of my projects are not passing and show the same errors:\n\nThe error message overlapping accesses to 'self', but modification requires exclusive access; consider copying to a local variable is a Swift 4 warning that is enabled in Xcode 9 by default.\nYou can try to compile the following projects:\n https://github.com/Blackjacx/SHSearchBar - scheme SHSearchBar\n https://github.com/Blackjacx/SHDateFormatter - scheme SHDateFormatter\n* https://github.com/Blackjacx/Source - scheme Source\nEDIT:\nI found out that this happens when I build my framework target with the Thread Sanitizer enabled. When I switch it off I can build without errors locally. My CI machine still delivers me that error. Maybe it uses this thread sanitizer despite I disabled it in my scheme settings...\nI only found this issue of another project with an related failure: https://github.com/algolia/algoliasearch-client-swift/issues/388. OK fixed this issue for me by disabling thread sanitizer... But it is still an issue for people with thread sanitizer enabled.\nYou can \n1. clone the project https://github.com/Blackjacx/SHSearchBar\n2. enable thread sanitizer for run and test phase\n3. build SHSearchBar scheme\nto reproduce the failure.. I like the project and use it a lot :-). Yep with this PR it works! Great \ud83d\udc4d. ",
    "denis631": "I haven't seen the curly braces... Sorry.\n. ",
    "lukeredpath": "Hi Ash, yes, that makes sense now. I ended up checking the identityToken on each one as it felt a bit wrong to define equality just for my tests (I had no use case for it elsewhere). Thanks.\nIts possible that this was just me being a bit slow today but I wonder if it would be helpful to clarify this in the documentation.\n. @ashfurrow sure, first pass above.\n. Yes, I missed that one.\n. ",
    "priyapy": "Thank you for the response. In test file Quick or nimble is not compiling. its not giving me provision to use any of the builtin methods in it. Rather i am not getting the quick or nimble in autofilling while trying to import\n. @modocache  yes, this is the error i am facing.\n. ",
    "wongzigii": "The Swift-3 branch has been merged into master. \ud83c\udf89 \n. Closing.\n. Try clearing CocoaPods cache to see if it works: https://gist.github.com/mbinna/4202236\n. @otaran You can just change the Podfile dependency to the latest commit, Or, I just create a sample repo which shipped with Xcode 8.  https://github.com/wongzigii/CrashSample\nMake sure to run pod install before build and test. \nEverything looks good in Xcode 8. (Hum, I actually have converted 1-2 files to met the Swift 3 syntax manually, though).\n. @ndelitski Using BarError.self in matchError is comparing errorType, actually. \nSee https://github.com/Quick/Nimble/blob/master/Sources/Nimble/Matchers/MatchError.swift#L19\n. Hi @GregoryMaks.\nGood catch! I just try carthage update and got the same issue. It seems that Kiwi has disable bitcode for all targets. See https://github.com/kiwi-bdd/Kiwi/pull/661. \n. Hi @tlandsmancars \nNimble with Swift 3 support will be released in the next few days. \nYou can change your podfile to latest commit if you need a workaround at this time:\npod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :commit => 'db706fc'\n. @thinkrad See https://github.com/Quick/Quick/pull/601\n. Nimble has been updated to v5.0.0 \ud83c\udf89\n. Thanks @gsabran !\n. @kdawgwilk You can use Nimble's beCloseTo matcher to compare two dates.\nAn example would be:\nobjc\n- (void)testDateMatches {\n    NSString *dateStr = @\"2015-08-26 11:43:00\";\n    NSString *dateStr2 = @\"2015-08-26 11:43:05\";\n    NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];\n    [dateFormat setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\n    NSDate *date = [dateFormat dateFromString:dateStr];\n    NSDate *date2 = [dateFormat dateFromString:dateStr2];\n    expect(date).to(beCloseTo(date2).within(10));\n}\n. Thanks @mikemee \n. @lauracalinoiu @ksm Have you try the latest Nimble v5.1.0 ?\n. Hey @darrarski ,  I believe your issue is related to #173 .\nSince case1 and case2 is MyEnum type so it will make sense to  implement Equatable for MyEnum. \n``` swift\nenum MyEnum {\n    case aCase(value: T)\n}\nextension MyEnum: Equatable {\n    static func ==(lhs: MyEnum, rhs: MyEnum) -> Bool {\n        switch (lhs, rhs) {\n        case (.aCase(let lvalue), .aCase(let rvalue)):\n            if lvalue is String && rvalue is String {\n                return lvalue as! String == rvalue as! String\n            }\n        }\n        return false\n    }\n}\n```\nthen you got:\nswift\nexpect(case1).to(equal(case2))\n. Hm, sorry @darrarski I miss your previous comment above.\nWhen I was trying to use extension MyEnum: Equatable where T: Equatable in early time and got this error: \n\nextension of type 'MyEnum' with constraints cannot have an inheritance clause\n\nSince conditional conformance is still on the way, as a workaround for this, just FYI @darrarski  , you might need to  combine your extension and enum definition :\n``` swift\nenum MyEnum: Equatable {\n    case aCase(value: T)\nstatic func ==<T: Equatable>(lhs: MyEnum<T>, rhs: MyEnum<T>) -> Bool {\n    switch (lhs, rhs) {\n    case (.aCase(let lValue), .aCase(let rValue)):\n        return lValue == rValue\n    }\n}\n\n}\nexpect(case1).to(equal(case2))\n```\n. Hm, I try to reproduce this on macOS 10.11, but everything looks fine for me. \n. Thanks! @sigito .     ....\n    build   19-Dec-2016 17:08:41    [17:08:41]: ? \ufffd[35m\ufffd[32;1m   Executed 70 tests, with 0 failures (0 unexpected) in 0.156 (0.211) seconds\ufffd[0m\n    ....\n    build   19-Dec-2016 17:08:46    [17:08:46]: ? \ufffd[35m\ufffd[32;1m   Executed 144 tests, with 0 failures (0 unexpected) in 1.288 (1.401) seconds\ufffd[0m\n    ....\n    build   19-Dec-2016 17:08:46    [17:08:46]: ? \ufffd[35m\ufffd[32;1m   Executed 92 tests, with 0 failures (0 unexpected) in 1.288 (1.401) seconds\ufffd[0m\n70 + 144 + 92 = 306\nIt seems like this is a bug of fastlane plugin, which scanning wrong number of tests.. Right, maybe we can add a flag to pod lib lint. See https://github.com/Quick/Quick/commit/3e46de695c2ec8c8e333951a7ccdb8ecb7b9718e. Closing for Swift 3.1 launched.. If you are testing equality, you can make your Enum conform to Equatable protocol and implement == operator. \nSomething likes:\nexpect(Enum.myValue) == variable. LGTM Thanks! @ikesyo . > it caused test target not work.\n\nWhat is your trouble?\nFYI @chenzww You can use Carthage to build frameworks base on Swift 4.0.2. > This change reduces build time on Nimble iOS target from 12 seconds to 3 seconds on my machine.\n\ud83d\udcaf . @mrh-is  You can wrap your own waitUntil function likes:\nprivate let timeOutInSecond = 5\nprivate func myWaitUntil(action: @escaping (@escaping () -> Void) -> Void) {\n    waitUntil(timeout: timeOutInSecond) { done in\n        done()\n    }\n}\n\nthen call it like:\nmyWaitUntil { done in \n    // ...\n    // done()\n}\n\nFeel free to reopen it if you have any further questions.\nEidt:\n/// If you are running on a slower machine, it could be useful to increase the default timeout value\n/// or slow down poll interval. Default timeout interval is 1, and poll interval is 0.01.\npublic struct AsyncDefaults {\n    public static var Timeout: TimeInterval = 1\n    public static var PollInterval: TimeInterval = 0.01\n}\n\nYou can also set Nimble.AsyncDefaults.Timeout to change timeout globally.\n. LGTM. \ud83d\udea2 Let's get rid of the (swift>= 4.0) version check.. Thanks for your great work!. So, our next release will target on Swift 4.2, right?. Should we also turn on APPLICATION_EXTENSION_API_ONLY in Quick ?. :shipit: . This issue is related to #508, can you checkout the master branch to see if this work now? (since we've not cut a latest release yet). https://github.com/Quick/Nimble/blob/master/Tests/NimbleTests/XCTestManifests.swift#L338 \nLinux entry should be updated too. \nYou can generate this automatically by running swift test --generate-linuxmain.. I just restarted the failed job and the test pass now. . Suggestion: remove NS prefix to fit Swift 3 \ud83d\ude03 \n. These kind of warnings should be suppressed. FYI: https://github.com/Quick/Quick/pull/649. Is this disable rule necessary? Otherwise looks good to me.. Prefer let over var. import Foundation is duplicate. Prefer function name -> testSequenceElementsEquality, just like functions name in EqualTest.. The warnings is Override of 'NSObject.hashValue' is deprecated; override 'NSObject.hash' to get consistent hashing behavior. Since Swift 4.1 or earlier NSObject has conform to Hashable so far, so this is compatible. . Here is the declaration of hashValue in NSObject header.\n\nNSObject implements this by returning self.hash. Subclasses can\n    customize hashing by overriding the hash property.. https://github.com/apple/swift/blob/6fc4cef671947d1d2482951853f7f82854473d91/test/Inputs/clang-importer-sdk/swift-modules-without-ns/ObjectiveC.swift#L77. \n",
    "Ben-G": "Thanks for the quick response. I should have added images to my issue. Hope these images help explain the issue:\nCurrent Implementation:\n\nPotential Change:\n\nIn the current implementation I find myself needing to open the issue navigator to find the information about actual count vs. expected count, because the description of the collection content takes up so much space.\nDue to the way Xcode's issue navigator works this ends up taking a fair bit of time when navigating a very large test suite.\nFor expectations that use the haveCount matcher I'm usually only concerned about the element count and not the content of the array; so to me personally it would be more helpful to see the count values first.\nThat said, I see that this causes an inconsistency & the solution of using the dynamicType of the collection can get a little ugly when using Objective-C types, as it exposes types names of internal types (concrete subclasses of NSArray).\nJust wondered if other people also see this as an issue.\nThanks a lot!\n. @modocache @ashfurrow Thanks for the quick response! I'll open a PR and add a link to this issue for future reference.\n. Implemented in #310 but never closed!\n. @briancroom You're bringing up a good point! \nI touched on this third option in #308 as well. We could conserve the details but simply move them to the end of the message so that we get the quick lookup in the source editor + additional detail in CI and other scenarios.\n\nWhat if we were to introduce the concept of \"extra details\" to the FailureMessage type which would be appended on a separate line when recording the failure. The haveCount message could then look something like:\nexpected to have Array with count 1, got 3\nActual value: [1, 2, 3]\n\nIntuitively this sounds great! But would love to hear other's opinions on this.\n. @briancroom @ashfurrow I just took a look at this again. There's code in place that trims whitespace characters and newlines (https://github.com/Quick/Nimble/blob/master/Sources/Nimble/FailureMessage.swift#L36-L41) which makes it difficult to implement this is as a small change.\nI can set the postfixActual value on FailureMessage but because of the lack of newlines / spacing the formatting is off.\nSeems like more changes would be required to support this. Probably not worth it? What do you think?\n. @ashfurrow Ah, once again lacking a screenshot. Here we go:\n\n. @ashfurrow The blame information on https://github.com/Quick/Nimble/blob/master/Sources/Nimble/FailureMessage.swift#L36-L41suggests that @briancroom might now why whitespaces / newlines are currently removed and if it is possible/desirable to change that.\nThanks a lot for trying to help! \ud83d\udc4d \n. @briancroom sounds good to me!\n. @briancroom I rewrote the the commit based on your latest suggestion. Let me know what you think of the result!\n. @briancroom updated and linux build is passing now!\nUnfortunately I need to move the runtime check out of the switch statement to avoid a compile error.\n. ",
    "RonanMcH": "We are using cocoapods to integrate. We are on version 4.1.0. Pre this version we never experienced this error.\n. Hi @jeffh ,\nWe resolved this issue a long time ago on our own and long since upgraded on Xcode, Cocoapods and Nimble. I cannot recall what versions we were on. Feel free to close this issue but I don't wanna speak for @RafaelPlantard .\nThanks,\nRonan.\n. ",
    "RafaelPlantard": "I'm facing this same issue...\n. You are right I'm not facing this problem more.\n. ",
    "repl-ullas-ml": "@modocache Oh i see. Thanks for your insights. Will probably stick with OCMock for now.\n. ",
    "otaran": "I am glad to help. Is there anything I can do to help fix this issue (apart from actually fixing it - I am not good at Swift Voodoo \ud83d\ude04 )\n. Yes, the workaround I have found is to create a copy of [item]:\nswift\nexpect(array).to(equal([String]([item]))) // this doesn't crash\n. Yes,\nswift\nexpect(array).to(haveCount(1))\nexpect(array).to(contain(item))\ndoesn't crash.\n. @jeffh , do you have a sample project compatible with Xcode 8? I tried to convert my project, but failed.\n. Thanks, @wongzigii ! The code doesn't crash in Xcode 8, everything seems to be good.\n. ",
    "stephenyao": "Also waiting on this, +1 for merging through\n. ",
    "MP0w": "Wouldn't this cause way slower tests? I guess it has to always wait for timeout to succeed?\nIn the other hand it can solve the problem of people forgetting to write failing tests (yes it happens):\nswift\nvar called = false\nfunc thisShouldNeverBeCalled() {\n    called = true\n}\n// (.. async stuff ..)\nexpect(called).toEventually(beFalse())\nIn the first line we have to remember to use nil (or the other way around if we eventually expect nil) to make sure is not matched immediately.\nMaybe we could find a way to prevent this?\nTBH when my colleagues and me started to use Quick & Nimble it was a bit tricky, now I'm used to it but would still be good to prevent it.\n. @jeffh I was thinking about ensuring that the condition is false the first time (but there might be cases where this is not right?)\nE.g\nexpect(value).toEventually(equal(value2))\nBehaves like:\nexpect(value).toNot(equal(value2))\nexpect(value).toEventually(equal(value2)). ",
    "zachlucas": "@ikesyo I should've specified that I'm using Swift 2.3, not 3.  I've tried pointing to your PR in #321 via CocoaPods, same build issue there.\n. @ikesyo that was it, thank you.\n. ",
    "tettoffensive": "Even though I have specified in my Podfile, Xcode 8 GM still complains and wants to convert to swift 3 for both projects. am I missing something?\nbash\npod 'Quick', :git => 'https://github.com/Quick/Quick.git', :branch => 'swift-3.0'\npod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'master'\n. @jeffh @ikesyo ?\n. ",
    "LinShiwei": "The readme puzzles me. I have to get  some information from issues.\nMaybe README needs update.\n. ",
    "kkrawczynski": "@GregoryMaks i had the same problem after i upgraded xcode to 8 here's what i did:\n- carthage update --platform [your_pick]\n- went into Carthage\\Checkouts for Nimble & Quick\n- manually opened xcodeproj, declined conversion, set Legacy Swift Language Version to Yes in all platform projects \n- carthage build --platform [your_pick]\n. ",
    "GregoryMaks": "Good news.\nChecked it now with XCode 8.0 and Carthage 0.17.2.\ncarthage update went fine this time, for all platforms.\nThe only thing that needed to be changed is setting the SWIFT_VERSION in Kiwi, because it seems that Nimble already utilizes Swift 3.0 which is great.\nI think it means that the issue can be closed for now. \nThanks everyone.\n. ",
    "Happy1983": "in cartfile:\ngithub \"Quick/Quick\"\ngithub \"Quick/Nimble\"\nin build settingL\nScroll down \u2013 It is right near the bottom and look for Use Legacy Swift Language Version. To the Right, there are three options when you click:\nUnspecified\nYes\nNo\nset YES worked for me. ",
    "Antondomashnev": "@ikesyo Thanks, I'll try and leave a feedback soon\n. @ikesyo It works, thanks\n. ",
    "fmaxx": "\n. @jeffh seems like my mistake, I've checked XCode (7.0) and I tested with Swift1.\n. ",
    "thinkrad": "Hey @wongzigii,\nWill the Swift 3 Nimble release coincide with a Swift 3 release for Quick?\n. ",
    "asalom": "We have this issue for some time now. We have a big test suite with 4000 tests, 122 of which make use of toEventually. When we run them locally, everything is good but whenever we use a slower machine for CI (either a local mac mini with Jenkins or a virtual machine with Travis), tests with toEventually randomly fail and it only happens some times, not every time. With Travis we realized that whenever we have several jobs running in parallel, the virtual machines we get are slower than if only one job is running. So whenever we spawn 4-5 jobs at once, some tests with toEventually are more prone to fail.. Thank you, we gave a small try to this but didn't work very well. A soon as we migrate to travis some other project where we kind of abused eventually clauses, we'll try again and I'll post the results here. ",
    "kdawgwilk": "The reason I am asking this is I want to test a model initializer that sets a default dateCreated: Date but I can't think of a good way to make sure the date got set right. Here is the test:\nswift\nit(\"should set default date created\") {\n    let item = Item(name: \"\", valueInDollars: 0)\n    expect(item.dateCreated).to(equal(Date()))\n}\nand here is the model:\n``` swift\nclass Item: NSObject {\n    var name: String\n    var valueInDollars: Int\n    var serialNumber: String?\n    let dateCreated: Date\n    let itemKey: String\ninit(name: String, serialNumber: String? = nil, valueInDollars: Int, date: Date = Date()) {\n    self.name = name\n    self.valueInDollars = valueInDollars\n    self.serialNumber = serialNumber\n    self.dateCreated = date\n    self.itemKey = UUID().uuidString\n\n    super.init()\n}\n\n}\n```\nI am guessing I will have the same issue when I get to the UUID() as well except XCTAssertEqualWithAccuracy wouldn't work in that case...\n. ",
    "iwllyu": "swift syntax\nexpect(actual).to(beCloseTo(expected, within: delta))\n. ",
    "truizlop": "Nevermind, apparently updating Cocoapods solved the issue\n. ",
    "lauracalinoiu": "I have those kind of errors too:\n\nMy Swift version is 3.0 and Nimble 5.0.0\nThanks\n. I did a clean build. viewModel.wikiURL definition is var imageURL: URL?\n. Ok, my mistake was that I compared a NSURL versus a URL:\nexpect(viewModel.wikiURL).to(equal(url)), type of wikiURL was URL?, while url is a NSURL\nThanks for the help, guys. @jeffh your question was a real help. \n. ",
    "ksm": "@jeffh Swift 3 (Xcode 8.0 8A218a) and Nimble v5.0.0. \nI ended up fixing all specs by replacing any beFalsy() or beTruthy() matchers that SourceKit complained about with to(beNil()) or toNot(beNil()).\n. ",
    "darrarski": "I have very similar problem when comparing two generic enums:\n``` swift\nenum MyEnum {\n    case aCase(value: T)\n}\nextension MyEnum where T: Equatable {\n    static func ==(lhs: MyEnum, rhs: MyEnum) -> Bool {\n        switch (lhs, rhs) {\n        case (.aCase(let lValue), .aCase(let rValue)):\n            return lValue == rValue\n        }\n    }\n}\n```\nFor given two variables:\nswift\nlet case1: MyEnum<String> = .aCase(value: \"a\")\nlet case2: MyEnum<String> = .aCase(value: \"a\")\nThis code works correctly:\nswift\nexpect(case1 == case2).to(beTrue())\nBut this code is not compiling:\nswift\nexpect(case1).to(equal(case2))\nWith Nimble 5.0.0, it produces compile-time error:\n\nArgument type 'NMBMatcher!' does not conform to expected type 'Matcher'\n\nWith Nimble 5.1.0, it produces compile-time error:\n\nCannot invoke 'to' with an argument list of type '(NMBMatcher)'\n\nAny ideas what's wrong?\nI am using Quick 0.10.0\n\nUPDATE:\nIt appears my issue can be fixed by implementing custom matcher:\nswift\nfunc equal<T: Equatable>(_ expectedValue: MyEnum<T>) -> MatcherFunc<MyEnum<T>> {\n    return MatcherFunc { actualExpression, failureMessage in\n        failureMessage.postfixMessage = \"equal <\\(expectedValue)>\"\n        if let actualValue = try actualExpression.evaluate() {\n            return actualValue == expectedValue\n        } else {\n            return false\n        }\n    }\n}\nI assume it's just a workaround, I wonder if it's possible to improve Nimble, so it handles such matching automatically?\n. @wongzigii I already did it, but I only make the Equatable extension valid for MyEnum that has equatable T, otherwise it makes no sense to compare them. Am I right?\nIf you look at my previous comment, you will see that I included my implementation of MyEnum Equatable extension.\n. It would be nice to be able to do it in Nimble. Using mentioned pattern, we can check for conformance to enum value, without checking its associated value. The capabilities of pattern matching like this are higher than what Equatable provides us.\n```swift\nenum Enum {\n    case text(String)\n    case number(Int)\n}\nlet value = .number(5)\nif case .text(\"a\") = value {} // does not match\nif case .text = value {} // does not match\nif case .number(1) = value {} // does not match\nif case .number(5) = value {} // matches\nif case .number = value {} // matches\n```\nI can imagine using it in Nimble, like this:\nswift\nexpect(value).to(beCase(.text(\"a\")) // does not match\nexpect(value).to(beCase(.text)) // does not match\nexpect(value).to(beCase(.number(1))) // does not match\nexpect(value).to(beCase(.number(5))) // matches\nexpect(value).to(beCase(.number)) // matches\nUnfortunately, I am not sure if it can be done because of limited reflection capabilities in Swift.. It looks like the problem was somehow connected to Xcode version. I tried cleaning up derived data and reinstalling pods several times, but on Xcode 8.3.2 build was always failing. Now I am using Xcode 8.3.3 (latest stable version at the moment) and it compiles just fine. \nI am closing this issue.. ",
    "jorishjanssen": "Hey @jeffh \nThanks for the response. The explanation about the error message inconsistency clarified a lot. I changed the timeout and it seems to have solved the issue. Nonetheless, would still be a nice improvement to avoid the second call to myFunc() to get the failure message string for others who are not aware of this.\nThanks again for the help!\nJoris\n. ",
    "tali": "@wongzigii can you reproduce it? What kind of additional detail do you need?\n. I can reproduce it reliably:\ngit clone https://github.com/tali/Nimble367Test\ncd Nimble367Test\nswift test\n. You can see the exception on https://travis-ci.org/tali/Nimble367Test\n. ",
    "garie": "Sorry I haven't had time to check yet. I'll try to get some time to work with this soon...\nI am still having this problem and probably will for as long as we support iOS 9. I usually develop on the iPad 2 sim (which only goes up to 9.3) because it's small enough to display on the screen without scaling down and it takes less resources to run. Right now when I need to debug in our test code I have to run with an iOS 10 simulator, which isn't a huge deal except that it's annoying to get back to where I was and some of our tests don't pass on iOS 10 (a problem on our side, of course, but it does add to the inconvenience).. Okay. We still have this issue but I think we're going to switch away from XCTest and use ruby with Appium instead, so it should no longer be a problem. The proof of concept ruby test I wrote did not use Nimble so it wouldn't matter which part is the problem.. Okay. I wasn't sure where to start. I have no idea at which point the tests are disappearing. Let me know anything I can do to help!. @wongzigii Thanks so much! I will refile with fastlane.. I've had a bit more time to run through this and figure out exactly what the problem is.\nI can reproduce this with asynchronous tests. I have a test that uses waitUntil which does not show up in my xcodebuild log, does not report to the command line (unless it fails), and is not counted in this number. I believe that fastlane isn't counting it in the number because it uses xcpretty to parse the xcodebuild log and there is no output for this async test.\nUnfortunately, while it is reproducible, it's not consistent. The same tests sometimes pass and appear in the output/count.. I converted one of my tests from using waitUntil to toEventually in case the waitUntil was the problem but the test still is sometimes missing from the list.. On second thought, what I said doesn't make sense. The test NEVER goes to the xcodebuild log but SOMETIMES is counted. I must be missing something else. . ",
    "sigito": "Since the Expectation is an immutable structure, is there any reason why we cannot just extend its methods with an additional result returning self? . Hi guys,\nI can do the initial setup of swiftlint. Do you have houndci attached to Nimble?\nDo you have any specific set of rules in mind? Or would it be OK to just have SwiftLint with a default config (empty)?. There are still rules to enable left (.swiftlint.yml). Should you have the same bug open as Quick/Quick#641, or reopen this one?. According to AllPassTest WAI. Done. But what is the incentive? People will use it without SwiftLint and provide new lint violation.. ",
    "ltrainpr": "From the answers in StackOverflow it seems that these are Swiftlint errors.  I'll have to figure out how to disable Swiftlint on 3rd party libraries so they don't fail the build.  \nYou should be aware that a lot of the Swift code in Nimble has issues.\n. ",
    "lferro9000": "Hi,\nI'm pushing a pull request to solve all of the outstanding issues.\nOne of them is done by a disable rule, because i don't know the finer details to make more drastic code changes on that area and because the matchers are going to be changed if i read the PR / WIP correctly, so having a temporary disable on there will not be too bad in the short time.\nNaturally, it would be better to avoid it, so if someone with better understanding of the codebase can fix that one and remove the disable rule, that would be better imho.\nCheers,\nLF. ",
    "rlam3": "I'm using \ncocoapods 1.1.1\nXcode 8.1\n. ",
    "joeljfischer": "Hello everyone, this still appears to be open, and unfortunately many of our unit tests are broken on the latest releases of Quick / Nimble. Has there been any further movement on this issue?. Sure, I'll try to take a look today.. I spent some time on this, and I repeatedly got the error until I turned off optimization on the Nimble project and rebuilt, then everything seems to work correctly. Any ideas on why that might be? Swift's debugging capabilities still kind of suck so it's hard to tell exactly what's going on.. 1. Yes, I was referring to the crash referenced in this issue.\n2. That's correct. With no modifications, by turning off optimizations (so that I could debug more easily) the crash disappeared.. I did attempt that first and it did not seem to help, but with the optimized build I wasn't able to step through to actually see what was happening. No breakpoints I set into the stringify function would actually fire, and the error would always fire on the return stringify(unboxed) line, which didn't help since it was likely failing in the unwrapped stringify method.. I wasn't able to get a small sample project that will reproduce it, but I pushed a branch of the primary project that has been showing the issue: https://github.com/smartdevicelink/sdl_ios/tree/hotfix/nimble_fix_tests\nYou'd just have to pull in the libraries with carthage and run the tests.. Using print statements, this is what I'm seeing.\nI changed the relevant Nimble code to:\n```swift\npublic func stringify(_ value: T) -> String {\n    print(\"Stringify: (value)\")\nif let value = value as? TestOutputStringConvertible {\n    print(\"TestOutputStringConvertible\")\n    return value.testDescription\n}\n\nif let value = value as? CustomDebugStringConvertible {\n    print(\"CustomDebugStringConvertible\")\n    return value.debugDescription\n}\n\nprint(\"None of those, describing...\")\nreturn String(describing: value)\n\n}\n/// -SeeAlso: stringify<T>(value: T)\npublic func stringify(_ value: T?) -> String {\n    print(\"Stringify? (value)\")\n    if let unboxed = value {\n        return stringify(unboxed)\n    }\n    return \"nil\"\n}\n```\nand this is the output\nStringify? Optional(<SDLConfiguration: 0x7ff562635390>)\nStringify: <SDLConfiguration: 0x7ff562635390>\nCustomDebugStringConvertible\nStringify? Optional(<SDLConfiguration: 0x7ff562635390>)\nStringify: <SDLConfiguration: 0x7ff562635390>\nCustomDebugStringConvertible\nStringify? Optional(OCProtocolMockObject)\nStringify: OCProtocolMockObject\nCould not cast value of type 'OCProtocolMockObject' (0x1164fc108) to 'Swift.CustomDebugStringConvertible' (0x1164390e8).\nIt's very interesting that it's saying it can't convert to a CustomDebugStringConvertible yet the print statement within that if let isn't firing. That makes me think something weird is going on on the cast in the if let itself.. I'm starting to break out into a cold sweat with the announcement that Xcode 8.3 will drop Swift 2.3 support. Once that happens, I won't have functioning tests. Any further ideas on a possible fix? I'll take another look soon.. Just wanted to note that now that Xcode 8.3 is out, we've had to disable all of our tests using OCMock. I'm not sure if there's any further thoughts on working around this bug, or if we're going to have to rethink how we do those tests.. ",
    "non-binary": "Hmm. Not sure what's happening but it doesn't look like it would be an issue with Nimble. I'll have to do some more investigating.. Mind refiling the issue on Quick? More traffic on there.. Please confirm. There's a warning with Swift 3 but everything is still compatible with Swift 3 and you have a working version for Swift 4? If so, LGTM (but I still recommend that we hear from a few others in the core team.. ",
    "Nandiin": "Okay, then why? Expecting [nil, nil, nil] to allPass a beNil() matcher is intuitive, isn't it?. I've also tried Embed Asset Packs In Product Bundle=YES and Always Embed Swift StandardLibrary=YES for both main target and test target. Still failed to wok.. I may say the Xcode I'm using is almost under \"default\" configuration since I've just re-installed my OS X (with full disk erasing) and Xcode.  I'd never changed the derived data location.\nGive the project structure like:\nNimbleIssue/\n   |- MainProj/\n        |- MainProj.xcodeproj  \n   |- NimbleIssue.xcworkspace\n   |- Vendor/\n        |- Nimble/\nmanually adding Nimble-iOS to the build phases of test target would result in ../Vendor/Nimble/build/Debug-iphoneos/Nimble.framework. That build folder doesn't exist on my machine as well, but Xcode seems to have somehow managed to find the Nimble.framework according to the error message \nReferenced from: /Users/nandiin/Library/Developer/Xcode/DerivedData/NimbleIssue-fkhppktoktwpjodtarmzrjobszwv/Build/Products/Debug-iphonesimulator/Nimble.framework/Nimble\n My understanding: Xcode found Nimble.framework at this long and fancy derived data path(I didn't changed the location, again) and at some point it failed to find a library libswiftSwiftOnoneSupport which is referenced from Nimble.framework.. By \"manually adding\", I mean the same steps you took. \nIt's really odd, on my mac, the path in red rounded rectangle is ../Vendor/Nimble/build/Debug-iphoneos/Nimble.framework. And another difference I noticed is the icon of the Nimble.framework in the Link Binary with Libraries panel is a white box on my mac instead of yellow briefcase like yours.\nI noted the steps I took in the README.md of the repo.\n\nI know that sometimes re-adding the Nimble.framework would change the reference directory and all things would work after then. But for me, it's somehow random. A project which is happy on my company's mac may fail after pulling it on my own mac at home, and re-adding Nimble.framework works sometimes. For now, I suppose there might be some asynchronous work happening at the build time and there is a chance that one may end up with ../Vendor/Nimble/build/Debug-iphoneos/Nimble.framework. \n. I'm experiencing same issue. \nI added a test that indicates this issue:\nswift\nfailsWithErrorMessage(\"expected to eventually not be nil, got <nil>\") {\n    let someNil: String? = nil\n    expect(someNil).toEventuallyNot(beNil())\n}\nbut this test passed, which means toEventuallyNot is acting as intended, which is actually not.\nSo I wrote another test like:\nswift\nlet someNil: String? = nil\nexpect(someNil).toEventuallyNot(beNil())  // passes \nfailsWithErrorMessage(\"expected to eventually not be nil, got <nil>\") { \n    // says that above line doesn't pass -- weird\n    expect(someNil).toEventuallyNot(beNil())\n}\nthis test passed as well, indicating there's something wrong inside failsWithErrorMessage helper (codes behave different inside it's closure argument and outside).. ",
    "aaroncrespo": "https://github.com/mattgallagher/CwlPreconditionTesting/issues/7. Barring an upstream fix to the approach CwlPreconditionTesting uses I think the fix is unfortunately getting rid of support for precondition expectations via CwlPreconditionTesting.. I use it, but I'm not married to it and only in a few places. Would like to hear what other users are thinking... Might also be interesting to see if people would want to keep the feature for obj-c but not for swift.  I don't know the maintainer thoughts on cross language feature parity. . @modocache @jeffh  checkout #397 Only the Cocoapods CI task is failing due to conditional imports that exclude required headers on tvOS. Not familiar with the rationale for that and if I was over broad in updating the Cwl code on various platforms. . There might still be some dust to settle on the Cwl Side. . I'm not 100% sure why this is failing the cocoa pods test:\nFirst failure was due to tvOS tests not running but it looks like this project doesn't support tvOS.\nI added files to the tvOS target and the tests pass locally and on CI but still cocoapods is failing because the files required to pass the tvOS tests are not part of the umbrella header because of conditional:\n```\nif !TARGET_OS_TV\n#import \"mach_excServer.h\"\n\nendif\nI think removing that check would fix cocoapod test, but it seems there is probably some good reason I am unaware of to exclude it on tvOS. . Cool, all checks pass now.. Carthage/Carthage/issues/1979. removingdiff\n-                               OTHER_SWIFT_FLAGS = \"$(inherited) -swift-version 3\";\n```\nAnd rebuilding the framework allows carthage to use the binary.. i think this will be fixed when \nhttps://github.com/Carthage/Carthage/pull/1984\nhttps://github.com/Quick/Nimble/pull/437\nmake it to releases.. Related? I get\nThe use of Swift 3 @objc inference in Swift 4 mode is deprecated. Please address deprecated @objc inference warnings, test your code with \u201cUse of deprecated Swift 3 @objc inference\u201d logging enabled, and disable Swift 3 @objc inference. \nEmitted from my \"check dependencies\" step this project's only dependency are Quick and Nimble for tests and itself has only pure swift definitions not tied to NSObject or @objc. +                SWIFT_SWIFT3_OBJC_INFERENCE = On; is set. un sure about this change, this was a dif from the existing code but is present in CwlPreconditionTesting. seems to be this is modifying a generated file but I am not well versed in these files.. ",
    "ecbrodie": "@jeffh Eek, I must have drank a bad batch of coffee before I submitted this issue. I should not have been applying the contain matcher onto the result of myArray.count, that semantically makes no sense. The correct line should have indeed been expect(myArray).to(contain(\"a\")).\nI just tried the correct code in my Xcode IDE and I am happy to say that it compiled correctly and passed. HOWEVER, I am still running into this issue with the error message Ambiguous reference to member 'contain' when I am asserting on an array of objects instead of simple types like String or int. For example, the following code will produce the same error (regardless of Foo being a struct or a class):\n```swift\n  class Foo {\n    let name: String\npublic init(_ name: String) {\n  self.name = name\n}\n\n}\noverride func spec() {\n    describe(\"example tests\") {\n      it(\"verifies array contents\") {\n        let foo1 = Foo(\"abc\")\n        let foo2 = Foo(\"def\")\n        let fooArray = [foo1, foo2]\n        expect(fooArray).to(contain(foo1))\n      }\n    }\n```. ",
    "caynan": "I'm having the same problem with a list of structs that implements the equatable protocol. And seeing the same error.. ",
    "serges147": "Same problem. Sample is simple:\nlet someSet: Set<String> = [\"a\", \"b\", \"c\"]\nexpect(someSet).to(contain([\"b\", \"c\"]))\nThe issue applicable both for Swift 4.2 (xcode 10.1) and Swift 5 (xcode 10.2.beta4).. It looks like any type which implements both Sequence and SetAlgebra is problematic for Nimble 8.. BTW, the same problem for the isEmpty() matcher.. I just noticed that this issue is 2 years old. Guys, please either reopen this issue or let me know if I have to create a new one (for Nimble 8).. ",
    "ricardopereira": "@jeffh Any tip? Is it possible to analyse this issue with Instruments? Never done that for XCTestSuite.\n@ryanfitz Did you try with an autoreleasepool?. ",
    "ryanfitz": "@jeffh I finally got some time to investigate this and found the reason it is happening. The timeout DispatchSourceTimer is never properly canceled out so its event handler remains in memory indefinitely and retains a reference to itself which is an AwaitPromiseBuilder.\nIf I force cancel the timeoutSource timer then memory is freed as expected. However, I don't have a final solution yet, as forcing a cancel causes a few async tests to fail. This bit of a timeout code is very intricate, if someone with more experience with this area of the code has any suggestions that would be appreciated. . ",
    "lazerwalker": "Ah, awesome. I really appreciate the quick reply, and you throwing together that PR!\nWorking on verifying the fix, but it might take a little while longer \u2014\u00a0our project is chock-full of some incidental complexity that ultimately means pointing our Nimble at a fork or a GitHub PR branch is frustratingly harder than it should be. Hopefully will have an update soon.. We managed to get this integrated (ugh, recursive git submodules...). Will check back with you in a day or two when it should become clear whether this has cleared up or not.\nThanks again!. ",
    "benasher44": "In an earlier beta, I saw this crash and reported and closed it here: https://bugs.swift.org/browse/SR-4258. @jeffh thanks for getting the update out! Somehow the compiler crash I was seeing magically disappeared. I'm unsure why the changes that occurred since the snapshot I was using would have fixed anything, since the only change appears to be how swift prints the version. There's probably some gap in my understanding of how toolchain releases work. Thanks again, and sorry for the trouble!. ",
    "holmes": "I have no idea what's going on - but a project clean and rebuild got it working. \nIgnore me. ",
    "dagio": "The issue happen when you use file system that are case sensitive.\nThe file name is \"CwlCatchBadInstructionPOSIX.swift\" but the reference in the project is \"CwlCatchBadInstructionPosix.swift\". ",
    "chamander": "If there are any hints as to what may be causing the predicates to misbehave, I would be keen to have a look. \ud83d\ude42. Looping in @Quick/core. Hey @jeffh, it's been almost two weeks and nothing that would raise a red flag has come up, so this looks great!\nThanks for the update! \ud83d\ude42 . Grammar mistake. \"using\", not \"use\".. Looking to make this much clearer, potentially removing the list the immediately follows.. I am unsure what the original author intended to note here, in this sentence; Particularly the portion of the sentence which references \"NSObject\".. Addressed in 0b97b1a. Addressed in 775093d. Okay. I think I may have worked it out. This is addressed in cfe66b5\nI wasn't actually aware that types conforming to NSFastEnumeration were able to capture elements which weren't subtypes of NSObject!. ",
    "gavanchan-outware": "Perhaps I lack context. Is there a reason why one of these would pass, but not the other:\n```swift\n// 1.\nexpect([\"a\", \"b\", \"c\"]).to(contain([\"a\", \"bar\"]))\n// 2.\nexpect([\"a\", \"b\", \"c\"]).to(contain([\"bar\", \"b\"]))\n```\nI believe that these should both result in failures, but the tests written in this image seem to indicate otherwise:\n\n. ",
    "kaosdg": "Sorry to bump this but seeing this issue in XCode 9 again, with Nimble 7.0.2. ",
    "danielaRiesgo": "Sorry, the problem was somewhere else.. Hello. Just wanted to know if there is an update about this?\nI'm having the same problem. Worked in XCode 9.2 but not in XCode 9.3.. ",
    "Visakeswaran": "Check out this link, it clearly explains how to get rid of the error\nhttps://youtu.be/T7TyB-R_rOk. ",
    "chronodm": "I've got a similar issue with Realm objects, and the error messages are pretty monstrous:\n/Users/david/Projects/OpenRoget/Tests/OpenRogetTests/OpenRogetSpec.swift:100: error: -[OpenRogetTests_macOS.OpenRogetSpec thesaurusFrom_realmFileURL____success__head_parsing__children__extracts_the_words] : expected to equal <SemicolonGroup {paragraph = Paragraph {partOfSpeech = PartOfSpeech {head = Head {headGroup = HeadGroup {subsection = <Maximum depth exceeded>;number = 5;first = 217;last = 218;heads = <Maximum depth exceeded>;};number = 218;name = Shallowness;origNum = #209.;classId = 0;sectionId = 0;subsectionId = 0;headGroupId = 0;partsOfSpeech = List<PartOfSpeech> <0x7f86dca98200> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>);};number = 3;type = ADJ.;paragraphs = List<Paragraph> <0x7f86dca98020> ([0] Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;});};number = 1;name = shallow;semicolonGroups = List<SemicolonGroup> <0x7f86dca97ea0> ([0] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 1;words = List<Word> <0x7f86dca99c20> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);},[1] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dca9af40> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);},[2] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 3;words = List<Word> <0x7f86dca9b030> ([0] <Maximum depth exceeded>);},[3] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 4;words = List<Word> <0x7f86dca9b140> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>);});};number = 2;words = List<Word> <0x7f86dc8ae8b0> ([0] Word {semicolonGroup = SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcaa07c0> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);};value = skin deep;number = 1;paraRef = (null);posRef = (null);headRef = (null);headRefId = (null);},[1] Word {semicolonGroup = SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcaa1870> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);};value = ankle deep;number = 2;paraRef = (null);posRef = (null);headRef = (null);headRefId = (null);},[2] Word {semicolonGroup = SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcaa33d0> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);};value = knee deep;number = 3;paraRef = (null);posRef = (null);headRef = (null);headRefId = (null);});}>, got <SemicolonGroup {paragraph = Paragraph {partOfSpeech = PartOfSpeech {head = Head {headGroup = HeadGroup {subsection = <Maximum depth exceeded>;number = 5;first = 217;last = 218;heads = <Maximum depth exceeded>;};number = 218;name = Shallowness;origNum = #209.;classId = 0;sectionId = 0;subsectionId = 0;headGroupId = 0;partsOfSpeech = List<PartOfSpeech> <0x7f86dcaa5ed0> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>);};number = 3;type = ADJ.;paragraphs = List<Paragraph> <0x7f86dcaa5d00> ([0] Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;});};number = 1;name = shallow;semicolonGroups = List<SemicolonGroup> <0x7f86dcaa5b80> ([0] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 1;words = List<Word> <0x7f86dcaa78f0> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);},[1] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcaa8bd0> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);},[2] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 3;words = List<Word> <0x7f86dcaa8cc0> ([0] <Maximum depth exceeded>);},[3] SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 4;words = List<Word> <0x7f86dcaa8db0> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>);});};number = 2;words = List<Word> <0x7f86dcaa05b0> ([0] Word {semicolonGroup = SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcaae440> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);};value = skin deep;number = 1;paraRef = (null);posRef = (null);headRef = (null);headRefId = (null);},[1] Word {semicolonGroup = SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcaaf590> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);};value = ankle deep;number = 2;paraRef = (null);posRef = (null);headRef = (null);headRefId = (null);},[2] Word {semicolonGroup = SemicolonGroup {paragraph = Paragraph {partOfSpeech = <Maximum depth exceeded>;number = 1;name = shallow;semicolonGroups = <Maximum depth exceeded>;};number = 2;words = List<Word> <0x7f86dcab1120> ([0] <Maximum depth exceeded>,[1] <Maximum depth exceeded>,[2] <Maximum depth exceeded>);};value = knee deep;number = 3;paraRef = (null);posRef = (null);headRef = (null);headRefId = (null);});}>\nI feel like the issue here isn't arrays per se, but anything with a long and unhelpful string representation.\nFor reference, here's what Java's AssertJ does (comparing two vavr Array objects, first the arrays themselves, compared as a generic Iterable, then their string representations:\norg.junit.ComparisonFailure: expected:<...12, 13, 14, 15, 16, [-]17, 18, 19)> but was:<...12, 13, 14, 15, 16, []17, 18, 19)>\nExpected :Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, -17, 18, 19)\nActual   :Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\norg.junit.ComparisonFailure: expected:<...12, 13, 14, 15, 16, [-]17, 18, 19)\"> but was:<...12, 13, 14, 15, 16, []17, 18, 19)\">\nExpected :\"Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, -17, 18, 19)\"\nActual   :\"Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\"\nIn both cases, you get, first, an abbreviated version that concentrates on the spots that differ, and then the full version of expected and actual on separate lines, so they're (relatively) easy to compare.. ",
    "SeanROlszewski": "I'm presently running into an issue using Nimble to equate strings that are quite large, and the output that's produced is pretty unusable. I wanted to throw my support for this style of diffing to be added to nimble.\nI have some spare bandwidth to make these changes if no one else is going to be working on this.. ",
    "timojaask": "A partial solution for those affected by the warnings is to disable warnings coming from Nible:\npod 'Nimble', :inhibit_warnings => true. ",
    "gabrieloliva": "Does #445 fix all this issue?. ",
    "ishaanSejwal": "A review on this? @ashfurrow @ikesyo . Looks like CI passes now \ud83d\udc4d @ashfurrow . ",
    "m1entus": "Could you then update Pods version poiting to a new master ?. ",
    "itsravenous": "Thanks!!. ",
    "stephengazzard": "We are encountering the same issue. \nQuick: 1.1.0\nNimble: 7.0.1\nXcode Version: 9.0 (9A235)\nSwift Version: 3.2\nCocoapods: 1.2.1\nThis is the code that's being tested:\nfunc log(_ message: String, level: LogLevel) {\n        DispatchQueue.main.async {\n            self.delegate?.newLogReceived(message)\n        }\n    }\nand the test:\nbeforeEach {\n    testContext.logger.log(\"1\")\n}\nit(\"the text field shows the log\") {\n    expect(subject.logsTextView.text).toEventually(equal(expectedString))\n}\n. Pointed my podfile at master and the issue went away. I think this will be solved with #467 . @jmejiaa Sorry - when I upgraded it just started working for me. If you're still encountering it on 7.0.2 probably better to raise as a new issue with repro steps. ",
    "paulthorsteinson": "This did not go away when I updated to 7.0.2 but did go away when I also updated quick to 1.2.0. ",
    "freak4pc": "Quick 1.2.0 and Nimble 7.0.2 still have this issue. \nEdit: Updating to Nimble 7.0.3 resolves the specific crash I had. . This is happening to me as well, extremely frequently. Currently I don't have a way to run my entire test suite without it crashing. \nSpecifically crashes here for me: \n\nIt's specifically failing on some Snapshot Test cases. The interesting bits here are that: \n\nIt's super flaky - sometimes it doesn't happen but mostly it does since Xcode 9.\nIt used to happen on Xcode 8.3.3 but way less often\nIf I run that test separately it would run just fine. It crashes specifically when running the entire test suite. \n\nIf you need any other information I'd love to provide it. \nEdit:\nBy the way might be related to this:\nhttps://forums.developer.apple.com/thread/83570\nhttps://openradar.appspot.com/radar?id=6138518606708736\nGonna try the iOS 10 simulator with same tests.\nEdit 2: \nFrom Xcode 9.1b2 release notes \n\n. ",
    "ChrisChares": "Seeing these same errors building locally with 9.0 9A235 (from the App Store)\n```\nPODS:\n  - Nimble (7.0.1)\n  - Quick (1.1.0)\nSPEC CHECKSUMS:\n  Nimble: 657d000e11df8aebe27cdaf9d244de7f30ed87f7\n  Quick: dafc587e21eed9f4cab3249b9f9015b0b7a7f71d\n```. You can solve these errors by using bleeding edge Quick/Nimble instead of the latest tagged version.  Specifically I think #735 may have fixed it.\npod 'Quick', :git => 'https://github.com/Quick/Quick'\npod 'Nimble', :git => 'https://github.com/Quick/Nimble'. ",
    "adamyanalunas": "@ChrisChares Thanks for the pointer towards edge. That solved my Travis build issues. I'll keep my eyes out for the next release. In the mean time I'll consider this issue resolved.. ",
    "fahadHyder": "@ChrisChares thank you.\nI had same set of errors, currently i am using bleeding edge, Its fixed my issue.\n@ikesyo integrated Quick and Nimble 2 days back, the issue still exist in the latest version in swift4.\nAny advice? . ",
    "edopelawi": "Folks, apologies for joining this issue, but when will the 7.0.2 be released? My library uses Nimble (and Quick) for testing, and currently using the master branch through Cocoapods... which cannot be used in travis-ci.com's free version due to cloning issues :( \nThanks in advance!. ",
    "lionhylra": "The reason is xcode by default only shows one line error message. Hover the mouse above the failing message to show the rest.. ",
    "surpher": "Ah, right. I gave it a crack and it builds now. Thanks for pointing it out. \nTo elaborate on how to make it build successfully, tvOS target doesn't have ENABLE_BITCODE setting in the Build Settings tab by default (iOS on the other hand does have it there already). Needed to add it manually through Editor > Add Build Setting > Add User-Defined Setting.. ",
    "mackoj": "I have this issue and I don't have Thread Sanitizer enable on Xcode 9.2\n```\n/Users/jmacko/pj/iOS-app/Pods/Target Support Files/Nimble/Nimble-umbrella.h:13:9: note: in file included from /Users/jmacko/pj/iOS-app/Pods/Target Support Files/Nimble/Nimble-umbrella.h:13:\nimport \"Nimble.h\"\n    ^\n\n/Users/jmacko/pj/iOS-app/Pods/Nimble/Sources/Nimble/Nimble.h:9:13: error: 'CwlPreconditionTesting.h' file not found\n    #import \"CwlPreconditionTesting.h\"\n            ^\n:0: error: could not build Objective-C module 'Nimble'\nTesting failed:\n    'CwlPreconditionTesting.h' file not found\n    Could not build Objective-C module 'Nimble'\n TEST FAILED \n```. I did include them because it wasn't working.. ",
    "saragiotto": "pod deintegrate\npod install\nWork for me just now.. ",
    "sergd2005": "Ok so this issue happens when host project is not using swift.  I can attach sample project here if you need it. But it is really easy to reproduce - just create project that uses objc as default language and try to install Nimble via CocoaPods. I use them for unit tests target. . Yes error goes away if I set it manually in Nimble target in Pods project. However it is not solution to this problem since Pods project will be regenerated on next pod install/update operation. \nCocoaPods are not using your project for development to generate Pods project and targets on client machines.  I think this settings should mentioned in podspec itself. \nI provided requested outputs initially. \nEnvironment\nList the software versions you're using:\nQuick: not using\nNimble: 7.0.2\nXcode Version: 9.0 (9A235) (Open Xcode; In menubar: Xcode > About Xcode)\nSwift Version: 4.0 (Open Xcode Preferences; Components > Toolchains. If none, use Xcode Default.)\nPlease also mention which package manager you used and its version. Delete the\nother package managers in this list:\nCocoapods: 1.3.1 (Use pod --version in Terminal)\n. oh sorry xcodeproj version is 1.5.2. I came to conclusion that problem should be fixed on CocoaPods side  and I found related topic https://github.com/CocoaPods/CocoaPods/issues/6791.\nFor now I think I ll fix post hooks as mentioned in post above. \nthis works:\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        if target.name == ''\n            target.build_configurations.each do |config|\n                config.build_settings['SWIFT_VERSION'] = \n            end\n        end\n    end\nend\nIt's not pretty but will do until they update your pods to Swift 4. \nThx for help.\n. ",
    "Kuniwak": "\nProblem about CoreGraphics Objects\n\nThis problem has been fixed. So, only a problem related xcpretty is remained.\nThe xcpretty related problem can be fixed by placing error: prefixes (or we can propose generic comment prefixes to xcpretty) for each diff lines.. ",
    "mrh-is": "I'm not using MapKit, so I don't think that's my problem, though it might still be a good clue!\nFor reference, one of the lines that crashes (I haven't done an exhaustive survey of which lines cause this yet) is:\nswift\nexpect(viewController).toEventually(beAKindOf(FooViewController.self)). I've finally been able to reproduce it on my machine! \ud83d\udc4f It looks like result is .blockedRunLoop, but then lastPredicateResult is nil (same as @freak4pc above).\nIt looks like the message output here is depending on the expression having been tested at least once, though that's not necessarily true if the run loop is blocked. I haven't been able to find out why the run loop is blocked in my case. Open to debugging tips for this if anyone has fixed this before!\nI'm able to make this problem go away (in most cases at least) by increasing the timeout to 3 seconds (i.e., AsyncDefaults.Timeout = 3). #workaround. Looks like that's #177.. Yeah, that's a workaround! But doing that only papers over the problem. (Not to mention it tries on the delay never going above 3s, which I can't guarantee.) Better to solve the underlying bug if I can. \ud83e\udd14. Again, great workarounds, but not actually a solution to what seems to be an underlying issue.\nI'll reopen if I find any better debug data.. ",
    "mark-anders": "I'm seeing something that might be related to this too. When I am in a toEventually call, depending on what I'm doing, I might see a \"disk I/O error\" while trying to do a Core Data fetch.. I just tried download Xcode 9.0 - I was on 9.0.1 - and that seems to have fixed my issue. I'm not seeing the crashes that I was. . After more testing, it still does happen with 9.0, but not nearly as much as with 9.0.1.. ",
    "rokridi": "Hello guys. I am facing the same problem. Is there any solutions for this issue or not yet ? Thanks.. ",
    "ethansinjin": "I'm also running into this. For me, I think it happens when a previous unit test utilizes application.open(url), as the app will then be in the background.\nEdit: this doesn't appear to be the issue; it's occurring regardless of application.open() being called. ",
    "instanceof-inf": "Hello. I am facing this exact problem. I also have two test functions calling the async 'toEventually' function, and when I run one of them alone, they succeed, but together they cause a crash. I tried to use @mrh-is's suggestion to increase the timeout using AsyncDefaults.Timeout, and I had initial success when I increased it to 10, but after a few runs it started crashing again.\n. ",
    "an0": "This pollBlock code is problematic. It is possible that expression is not run at all, as pointed out here. Can someone take a look at the PR?\n. ",
    "Constantine-Fry": "The solution is to set APPLICATION_EXTENSION_API_ONLY to NO on project level, but keep on for targets.\nhttps://github.com/Quick/Quick/issues/749#issuecomment-343232565. ",
    "VojtaStavik": "This is happening only when the test suite is run in the host application. For standalone tests everything works OK.. ",
    "bryantjustin": "You can continue the tests by clicking on \"Continue program execution\" but this gets tedious if you have a few of these type of tests.. @msewell Thanks for the tip. I just confirmed it and turning off \"Debug Executable\" stops this from happening. I guess if we need to actually have the debugger up for a test, we'll probably want to isolate using fdescribe(), fcontext(), or fit() to avoid having to go through all the fatalErrors.. ",
    "msewell": "As a sort-of workaround for getting stuck on debugger breakpoints for fatal errors when running tests, you can run your tests without debugging support. Disable 'Debug Executable' in your scheme by going to Edit Scheme > Test > Info and unchecking 'Debug Executable'.. @MortyMerr: Disabling debugging during test runs isn't really a solution (it hardly even is a workaround). This issue still needs a \"real\" fix.. ",
    "blessingLopes": "Many thanks for the feedback and useful suggestions!   . ",
    "ghost": "Maybe, you should mention this in documentation? Solution was not obvious for me.. Close, cause found similar issue, sorry. ",
    "rafaelnobrepd": "A side effect of disable debugging during tests (which is quite inconvenient as is), is that it seems to affect coverage reports (always reports 0% when debug executable is disabled).\nUnfortunately its a real pain, to the point that I'm considering removing the assertion expectations. ",
    "mvandervelden": "Haven't had this issue before, until I started using Xcode 9.3 / Swift 4.1, where it fails consistently. Can confirm that disabling debugging during tests works, but as mentioned before, it's not a suitable workaround.. ",
    "RetepV": "Woops. And I am finding this issue as well, after having upgraded to Xcode 9.3.\nit(\"Assertion from inch unit test\") {\n               expect {\n                    try HeightConverter.stringForProfileHeightUnit(HeightUnit.inch)\n                }.to(throwAssertion())\n            }\nCode to test executes the following assert:\nassert(false, \"Profile only defines cm or ft. Anything else is a bug.\")\nIn Xcode 9.2, the test pass fine. In Xcode 9.3, the line actually asserts and the test run fails because it detects an assertion (which it's actually supposed to detect).. ",
    "drekka": "Hitting this with 9.3 as well. \nIt appears from my testing that Apple has modified the way the debugger handles program exits and is aggressively halting at the point where the code exits. Thus making it impossible for Nimble to trap it.\nTurning off debugging of the executable does indeed halt the problem but is not really a solution as it effectively disables test debugging.\nI'm not sure that this can be addressed either with Nimble or XCTest functionality.. Problem is persisting in Xcode 9.4. I suspect this will not be fixed and Nimble will have to find an alternative solution. For myself, I've gone with the approach of using a local override of fatalError(...) and then adding code to set a mock equivalent during testing. Unfortunately I cannot publish the code here as I did it for a client and they would have to approve it (unlikely!), however I can say it was based on https://medium.com/@marcosantadev/how-to-test-fatalerror-in-swift-e1be9ff11a29\n. Thanks. I loaded up the Nimble code downloaded via Carthage and saw that code but I wasn't sure I understood the problem it was solving. I'm running in Xcode against a iOS simulator so I just assumed that FileString would be correct. \nI'll try the code you suggested and see how it goes. Thanks. . I ended up staying on the release code and using:\n```\nclass AssertionValidator: AssertionHandler {\nprivate var expectedError: String\nprivate var testcase: XCTestCase\n\ninit(testcase: XCTestCase, expectedError error: String) {\n    self.expectedError = error\n    self.testcase = testcase\n}\n\nfunc assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {\n    if message.stringValue != expectedError {\n        testcase.recordFailure(withDescription: message.stringValue, inFile: location.file, atLine: Int(location.line), expected: true)\n    }\n}\n\n}\n```\nWhich is working just fine for me. Thanks for pointing me at that code.\n . ",
    "mosamer": "@jeffh any chance this could be reviewed anytime soon?. ",
    "lvsti": "Well, one difference is that in your build you are building Nimble while in mine I'm building my project with Nimble as a dependency.. On a side note, have you checked that your newly added Package@swift-4.swift manifest actually gets parsed? In my setup, if I only have that in the repo root, SPM greets me with error: root manifest not found. FWIW, the libFoundation.a of the 4.0.2 Linux distribution of Swift indeed contains 2 symbols for NotificationCenter.addObserver:\n\n```\n$ swift demangle _T010Foundation18NotificationCenterC11addObserverAA16NSObjectProtocol_pAA14NSNotificationC4NameVSg03forI0_ypSg6objectAA14OperationQueueCSg5queueyAA0B0Vc10usingBlocktF\n_T010Foundation18NotificationCenterC11addObserverAA16NSObjectProtocol_pAA14NSNotificationC4NameVSg03forI0_ypSg6objectAA14OperationQueueCSg5queueyAA0B0Vc10usingBlocktF ---> Foundation.NotificationCenter.addObserver(forName: Foundation.NSNotification.Name?, object: Any?, queue: Foundation.OperationQueue?, usingBlock: (Foundation.Notification) -> ()) -> Foundation.NSObjectProtocol\n$ swift demangle _T010Foundation18NotificationCenterC11addObserverAA16NSObjectProtocol_pAA14NSNotificationC4NameVSg03forI0_ypSg6objectAA14OperationQueueCSg5queueyAA0B0Vc5usingtF\n_T010Foundation18NotificationCenterC11addObserverAA16NSObjectProtocol_pAA14NSNotificationC4NameVSg03forI0_ypSg6objectAA14OperationQueueCSg5queueyAA0B0Vc5usingtF ---> Foundation.NotificationCenter.addObserver(forName: Foundation.NSNotification.Name?, object: Any?, queue: Foundation.OperationQueue?, using: (Foundation.Notification) -> ()) -> Foundation.NSObjectProtocol\n```\nI'm not sure if this is a bug or a feature, but I believe that by explicitly choosing one or the other form at https://github.com/Quick/Nimble/blob/master/Sources/Nimble/Matchers/PostNotification.swift#L18 instead of the trailing closure syntax would resolve the issue.. it ran without errors: https://travis-ci.org/lvsti/MockSix/jobs/303702207 \ud83d\udc4d . ",
    "siuying": "I also see same error (using cocoapods). It will work if I change the version to 7.0.2.. ",
    "dlo": "This is broken for me too.. Removing Carthage from my .gitignore had no effect for me.. ",
    "boris-tschirschwitz": "Make sure your .gitignore doesn't contain Carthage.. ",
    "alper": "We are using checked in pods and somehow ended up with Carthage in the .gitignore, so yeah that was making sure that the Carthage/ subdirectory in Nimble wasn't ending up in the checkout.. ",
    "bclymer": "I'm seeing this issue as well. If it helps, the types are structs that are included via a Cocoapod that is linked statically. All of the structs that are failing extend a protocol. The expect portion of the expression is an optional array of the protocol and I'm comparing an instance of an index in the array.\n```\n// Definitions\npublic protocol MyProtocol {}\npublic struct MyStruct: MyProtocol {}\n// Test\n// object.myElements is Optional>\nexpect(object.myElements?[0]).to(beAnInstanceOf(MyStruct.self))\n```\nWithin beAnInstanceOf I have added the following statements\nprint(\"ExpectedType: \\(expectedType)\")\nprint(\"ValidInstance: \\(type(of: validInstance))\")\nprint(\"ExpectedType: \\(String(describing: expectedType))\")\nprint(\"ValidInstance: \\(String(describing: type(of: validInstance)))\")\nprint(\"Matches: \\(type(of: validInstance) == expectedType)\")\nwhich prints\nExpectedType: MyStruct\nValidInstance: MyStruct\nExpectedType: MyStruct\nValidInstance: MyStruct\nMatches: false\nI have validated MyStruct does not exist in any other project, so it's not just two types with the same name.. Update that I realized immediately after typing that comment. I'm seeing\nobjc[45000]: Class <blah> is implemented in both <bleh> and <bluh>\nThat's almost for sure the issue. The left side (expect) is the impl included with the app itself, and the right side (beAnInstanceOf) is the impl included with the test bundle.. ",
    "bpo217": "You know I have been thinking about this and is it possibly because swift enums aren't equatable?  I have a feeling this is the reason.  \nlet e = MyError.failed\ne == MyError.failed ? true : false //Fails to compile can't apply ==\nI'm going to add the equatable protocol to my enums in my project and check back here.. ### Update\nAfter implementing Equatable on the enum\nenum MyError: Error, Equatable {\n    case failed\n    public static func ==(lhs: MyError, rhs: MyError) {\n        switch (lhs, rhs) {\n        case (.failed, .failed):\n            return true\n        default:\n            return false\n        }\n    }\n}\nThe error has disappeared!\nGreat job bpo217. \npats back\n. ",
    "stardustWK": "It is a bug of swift 4 https://github.com/apple/swift/pull/12249. ",
    "jberkel": "so I guess this can be closed then?. ",
    "fabb": "example implementation:\n```\nfunc beEmpty() -> Predicate {\n    return Predicate.simple(\"be empty\") { actualExpression in\n        let actual = try actualExpression.evaluate()\n        return PredicateStatus(bool: actual == nil || actual!.isEmpty)\n    }\n}\nfunc contain(_ items: [T]) -> Predicate\n        where S.Element == T {\n    return Predicate.fromDeprecatedClosure { actualExpression, failureMessage in\n        failureMessage.postfixMessage = \"contain <(items)>\"\n        if let actual = try actualExpression.evaluate() {\n            return !items.contains(where: {\n                return !actual.contains($0)\n            })\n        }\n        return false\n    }.requireNonNil\n}\n```. But this issue does not need a new release, it just needs pushing the correct podspec to the Cocoapods spec repo.. Ok, good point. I\u2018ll just override the swift version build setting in my Podfile post_install until the changes you mentioned get released. . ",
    "deanWombourne": "This is entirely and absolutely my fault, predictably.\nTurns out I had a bug in an implementation of CustomStringConvertible on my Result type. Details are here if you're interested: https://stackoverflow.com/questions/48795712/why-does-this-switch-compile-when-its-not-exhaustive. ",
    "nhnam": "Please try with \nit(\"does the thing\") {\n   waitUntil(timeout:3.0, action:{ done in\n        zhuLi.doTheThing { success in\n            expect(success).to(beTrue()) // Zhu Li never fails\n            done()\n        }\n    }\n}\n// 3.0: time out in seconds. ",
    "Whirlwind": "I have same idea:\nexpect(value).to(isAKindOf(Array)) // the value is array or string\nif lastResult {\n    expect(value.count) == 2\n    expect(value[0]) == 'some'\nelse {\n    expect(value) == 'some'\n}\nIt seams that it could not be done with the AssetionHandler.. ",
    "DanielAsher": "Someone?. @wongzigii thanks so much for #511 \ud83c\udf89 Feel free to close when merged. I'll close after release \ud83d\ude01.  @wongzigii Cool!. ",
    "mathieutozer": "Oops I needed \n.bucketList).toEventually(contain(node)). ",
    "guidomb": "Ohh thanks for the explanation @ikesyo!. \n@ikesyo Your suggestion fixed the issue with SPM, tests run correctly if I run swift test but when I open the Xcode project I get the following error. Do you know what could be wrong?. ",
    "lyricsboy": "@ikesyo is this something you can take a look at? It randomly crops up for us and would be nice to have an upstream fix in Nimble.. ",
    "davidahouse": "oops didn't see #517. closing this.. ",
    "kaganriedel": "I am not seeing this issue on Xcode 9.2 / Swift 4.0, but after upgrading to Xcode 9.4 / Swift 4.1 I am experiencing the same issue described by @nevillco. Any updates on this?. Thanks for the response @ikesyo. That makes sense!\nI am seeing another issue as well. Ever since upgrading to Xcode 9.4 / Swift 4.2 tests stop program execution when hitting an assertion. The tests do pass, but I have to hit \"Continue program execution\" every time an assertion is thrown. I don't know if this is due to a change in Xcode, Swift, or Nimble. \nI've included a quick example, cribbed from the code above. Note that this is not related to the async tests. Let me know if you need more information or if further discussion should be moved to a separate issue.\nQuick example cribbed from above:\nWhat to do?\nRun this test from the above example.\nfunc testAssertion() {\n        let expression = { assertNotThree(3) }\n        expect(expression: expression).to(throwAssertion())\n    }\nWhat did you expect to happen?\nExpect the tests to run without being stopped by Xcode when as assertion is thrown when using expect(expression: expression).to(throwAssertion()).\nWhat actually happened instead?\nXcode stops program execution when the assertion is hit.. Wonderful! Thank you. \ud83d\udc4d . ",
    "takehilo": "Following works for me:\nswift\nextension Recorded: Equatable where Value: Equatable {}\nextension Event: Equatable where Element: Equatable {}. ",
    "afetrifork": "This is causing a warning in my project: \n\nAny fixes for that?\n. ",
    "axandreo": "I am getting the same warning as @afetrifork . Additionally, I can't tell if they're related but, I started getting this issue \n```\nAnalyzing dependencies\n[!] Unable to satisfy the following requirements:\n\nNimble required by Podfile\nNimble required by Podfile\nNimble (= 7.1.2) required by Podfile.lock\n\nNone of your spec sources contain a spec satisfying the dependencies: Nimble, Nimble (= 7.1.2).\n``\nThe error instructs me to dopod repo update. However,  invokingpod repo update` doesn't solve this error.\n. @ikesyo the branch is good. The warning is now gone. Thanks!. ",
    "Buju77": "I'm currently also having a endless recursion crash in stringify() method:\n\nmy invoking code looks like this:\n```\nvar user: RTUser!\n...\nexpect(self.user).toNot(beNil(), description: \"register should never fail!\")\n```\nany idea how i could fix this?. @Dschee cool thx. My tests are now working again. \ud83d\udc4d . ",
    "sunshinejr": "With the fix of #532 it works on my end as well, good job guys \ud83d\udc4d . ",
    "sirlantis": "This stopped working in Swift 4.1 because of SE-0189: Restrict Cross-module Struct Initializers.. Dropped the checkboxes from the PR description so that it looks more mergeable from the list.. @ashfurrow Is there anyone I could ping on this?. Promoting a closure to @escaping will make Swift require explicit self. when accessing properties from within that closure, making this a breaking change.\nWhile this isn't the same as #if XCODE_10, could the following be a compromise?\n```\nif swift(>=4.2)\npublic func withAssertionHandler(_ tempAssertionHandler: AssertionHandler, closure: @escaping () throws -> Void) {\nelse\npublic func withAssertionHandler(_ tempAssertionHandler: AssertionHandler, closure: () throws -> Void) {\nendif\n```. ",
    "hmlongco": "Missed it. Any idea when it will be merged?. ",
    "eelbeze": "Oh it's seems this issue is a regression in Swift 4.2 and already reported: https://bugs.swift.org/browse/SR-7884 \nThanks !. ",
    "zbencz3": "@ikesyo I am still experiencing this problem in XCode 10 GM with the latest release of Nimble. I might be missing something. Any idea?. @ikesyo I have the same XCode version: 10 (10A255).\nThere is a sample project my colleague created. We both get the crash. Can you please run it to see if you experience the same?\nEscaping.zip\n\n. note: \nhttps://github.com/Quick/Nimble/pull/612. ",
    "darronschall": "Oops. I meant to file this against Quick itself. Apologies. Closing.. ",
    "kleiberjp": "i just install the last version, run test and xcode launch that error.. ",
    "SenorWesley": "Small update: I just updated to bleeding edge, which reduces the compiler errors to the following:\n\n. @ikesyo I updated the issue. :-)\n. @ikesyo \nCocoaPods could not find compatible versions for pod \"Nimble\":\n  In Podfile:\n    Nimble (~> 7.1.2). Stupid me, completely forgot about that... Hahha thank you so much! . ",
    "LeeA1985": "moved more appropriately ( I think ) to https://github.com/Quick/Quick/issues/804. ",
    "LucianoPAlmeida": "Hey @ikesyo :))\nSure, extracted \ud83d\udc4d . Hey @wongzigii :))\nFixed, thanks for the comments \ud83d\udc4d . Hey @ikesyo \nSure, fixed \ud83d\udc4d \nThanks for the comments :)). @ikesyo Sorry \ud83d\ude05 Thank's for renaming :). ",
    "pobengtsson": "Yes, but does that mean that the case I describe is an invalid use case and should not be supported by Nimble? \n. Wrapping or converting like you suggest is not desirable, since I work with other frameworks (e.g. Alamofire) that follows the Apple way of using Any, [Any], [String:Any] for representing the JSON object. Wrapping or converting for the sake of being compatible with Nimble-matchers in tests seems to like a detour to me.\nWhat would be the problem with supporting the examples in Nimble?\nWhat requires the matcher/predicate to use the Equatable protocol, and not other comparison code?\nIf there is a problem with using the matcher function name equal, then another name could be chosen, perhaps equivalent?\n. Hi, I checked your suggestion on using NSDictionary / NSArray and from the first quick initial tests it seems to help me do what I want.  I changed my example into:\n```\nimport Quick\nimport Nimble\nclass NSCounterPartsSpec : QuickSpec {\n   override func spec() {\n      describe(\"matching [String:Any] dictionaries and [Any] lists\") {\n         context(\"a list of [String:Any]\") {\n            it(\"should compile and pass\") {\n               let actual_dict : [String:Any] = [\"foo\": 10, \"bar\": \"void\"]\n               let actual_list = [actual_dict]\n               expect(actual_list as NSArray).to(contain(actual_dict as NSDictionary)) // expect this to pass\n            }\n         }\n         context(\"a comparison of two [String:Any] dictionaries\") {\n            it(\"should compile and pass\") {\n               let one_dict : [String:Any] = [\"foo\": 42]\n               let the_other_dict: [String:Any] = [\"foo\": \"bar\"]\n               expect(one_dict as NSDictionary).notTo(equal(the_other_dict as NSDictionary)) // expect this to pass\n            }\n         }\n         context(\"a test of an [Any] list containing another [Any] list\") {\n            it(\"should compile and pass\") {\n               let one_list : [Any] = [1, \"two\", [\"foo\":\"bar\"]]\n               let the_other_list : [Any] = [1,\"two\"]\n               expect(one_list as NSArray).to(contain(the_other_list)) // expect this to pass\n            }\n         }\n      }\n   }\n}\nBut when I run this the last test fails. But this could be me misunderstanding the contains predicate, because it works, after I change the last expect into:expect(one_list as NSArray).to(contain(1,\"two\")) // expect this to pass```\nSo, for now, I don't see any problems for me to go with your suggestion and cast to NSDictionary or NSArray.\nThanks for your instant and helpful replys! . ",
    "revolter": "\n. ",
    "clayreimann": "Which is incompatible with the infix operators. Chai provides a similar api for their assertions that aren't function calls.. @ikesyo Any comment on this? Would such a PR be accepted?. ",
    "balichowdry": "I have updated to 7.3.0 still the same issue :(. ",
    "ragaisis": "I have problems too. Can't build using carthage 0.29, Swift 4.2,  xCode 10, Nimble v7.3.1\n```\nBuild Failed\n    Task failed with exit code 65:\n    /usr/bin/xcrun xcodebuild -project /Users/jonas/Projects/ios/ios-myapp/Carthage/Checkouts/Nimble/Nimble.xcodeproj -scheme Nimble-iOS -configuration Release -derivedDataPath /Users/jonas/Library/Caches/org.carthage.CarthageKit/DerivedData/10.0_10A255/Nimble/v7.3.1 -sdk iphonesimulator -destination platform=iOS\\ Simulator,id=AED494DB-1977-40E2-B9A3-A13440ED6E8A -destination-timeout 3 ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES build (launched in /Users/jonas/Projects/ios/ios-myapp/Carthage/Checkouts/Nimble)\nThis usually indicates that project itself failed to compile. Please check the xcodebuild log for more details: /var/folders/wz/r9m4vxx11hs45gqcxblmx54c0000gq/T/carthage-xcodebuild.DIaEpR.log\n```. carthage-xcodebuild.DIaEpR.log\nI think this part is most important and causing the error, but I don't know how to fix it\n```\nerror: Cycle inside Nimble-iOS; building could produce unreliable results.\nCycle details:\n\u2192 Target 'Nimble-iOS': CodeSign /Users/jonas/Library/Caches/org.carthage.CarthageKit/DerivedData/10.0_10A255/Nimble/v7.3.1/Build/Products/Release-iphonesimulator/Nimble.framework\n\u25cb Target 'Nimble-iOS' has a command with output '/Users/jonas/Library/Caches/org.carthage.CarthageKit/DerivedData/10.0_10A255/Nimble/v7.3.1/Build/Products/Release-iphonesimulator/Nimble.framework/Nimble'\n\u25cb Target 'Nimble-iOS' has link command with output '/Users/jonas/Library/Caches/org.carthage.CarthageKit/DerivedData/10.0_10A255/Nimble/v7.3.1/Build/Intermediates.noindex/Nimble.build/Release-iphonesimulator/Nimble-iOS.build/Objects-normal/x86_64/Nimble'\n\u25cb Target 'Nimble-iOS' has a command with output '/Users/jonas/Library/Caches/org.carthage.CarthageKit/DerivedData/10.0_10A255/Nimble/v7.3.1/Build/Products/Release-iphonesimulator/Nimble.framework/Nimble'\n BUILD FAILED \n```. I've found out that updating carthage by using \"master\" solves the problem\nCarthage file\n```\ngithub \"Quick/Quick\" \"master\"\ngithub \"Quick/Nimble\" \"master\"\n``\nwhen i runcarthage update --platform ios` i see\n```\n Checking out Nimble at \"a14526900f79402de46779ba4e6929112b6a34d5\"\n Checking out Quick at \"044ea18d202369e33e1fc1849498a7824b89f1c4\"\n```\nAnd it builds successfully.\nBut pointing to master is not the best practise, so could you release new version that is currently in master\n. ",
    "NeverwinterMoon": "Looks like the problem is fixed when using at state a14526900f79402de46779ba4e6929112b6a34d5. But none of the released versions work.. > We have the same issue. Any workaround for this issue ?\nI managed to avoid this problem for the time being by using a yet unreleased version, like so:\npod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :commit => 'a14526900f79402de46779ba4e6929112b6a34d5'. ",
    "abhilashdonepudi": "We have the same issue. Any workaround for this issue ?. Thanks for the quick reply. That fixed the issue.. ",
    "loudmouth": "Some additional notes:\nI did try to \"debug\" this on my own but couldn't figure it out. I had assumed that there was a file missing from the Nimble-tvOS target in Xcode from one of the Cwl... dependencies that Nimble rely's upon.\nI also tried using the latest version of Nimble at the HEAD of master and it did not solve the issue.\nLastly, I should note that this issue only started appearing on Xcode 10 and was not present on Xcode 9.x. Any chance anybody has had a chance to investigate this? On TravisCI I'm having to restart my tvOS builds until I'm lucky enough for them to pass...sometimes taking up to 6 tries \ud83d\ude22 \n. Unfortunately, this was such a big time-sink for me that i had to go ahead and prune Nimble from my project and replace all assertions with standard XCTest assertions. I will leave this issue open for now since I imagine the problem is still there, and leave it to the maintainers discretion whether or not to close it.\nSince I left a link to my project as an example of this issue, I can at least point you to the last tag that had Nimble in it: https://github.com/contentful/contentful.swift/releases/tag/4.1.2. ",
    "gladborn": "If I have such kind of doubts while using nimble package where should I post , could you please help @ikesyo ? . ",
    "cruisediary": "I'm curious why force abort timeout is shorter than timeout interval \ud83e\udd14 \n@jeffh any update? \ud83d\udc7b . @ikesyo, @jeffh thank you for review this PR \nI have used RxBlocking to test async with Quick, Nimble. I guess it make this confliction (RxBlocking also block run loop \ud83d\ude1e)\nwhen I tested all unit tests of project, i faced many main run loop blocked failure and after fixed Await.swift forcefullyAbortTimeout (I guess that should be * 2 \ud83d\udc7b) looks fine but @ikesyo is correct. maybe this change make heuristically recovery on my case\n. thanks :) I will close this PR . ",
    "jmfriend": "Fantastic. Many thanks. Quick & Nimble are great.. No worries. thanks for sorting so quickly \n\nOn 30 Jan 2019, at 14:42, Sho Ikeda notifications@github.com wrote:\nI'm sorry for the inconvenience, that was due to my environment issue (with Xcode 10.2). It has been published now.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/Quick/Nimble/issues/627#issuecomment-458968267, or mute the thread https://github.com/notifications/unsubscribe-auth/AAGhS9i2Zgcy3jJwAaE8RWTHkZM-4Fhaks5vIa9QgaJpZM4aaHg0.\n\n\n. ",
    "anayini": "Just ran into this as well.  I think because of Sequence and SetAlgebra.  Quick client side patch can be to write a function generic over Sequence & SetAlgebra so that swift chooses that one, or to wrap an ambiguous value into an AnySequence.  Although thats probably not best \ud83d\ude05 .  A particularly common case where this will come up is when using the stdlib Set. One fix @ikesyo could be to add:\npublic func beEmpty<S: Sequence & SetAlgebra>() -> Predicate<S>\nSo that Swift has a more specific implementation to choose.. ",
    "ollitapa": "I'm getting this with \"contain\" on even a simple sets\nswift\nlet a = Set([1, 2, 4])\nexpect(a).to(contain(1)) // Ambiguous\nLooks like a major usablity issue to me \ud83d\ude05 . ",
    "kastiglione": "What's the scoop on dispatch_once in Swift? In ObjC, the token has to be static for guaranteed correctness. I've seen non-static dispatch_once's elsewhere in the code which made me curious so I googled, and found some code that uses this approach:\n``` swift\nstruct TokenHolder {\n    static var token: dispatch_once_t = 0;\n}\ndispatch_once(&TokenHolder.token) {\n     // Code!\n}\n```\nFrom: https://gist.github.com/ketzusaka/94e6d0368675b54ead4c#file-inlinefunc-swift\n. How come there's both a function and macro named NMB_waitUntilTimeout?\n. I think this could probably just use a boolean to indicate whether to do the dispatch_async. Unless the block passed to pollBlock can be called concurrently, which doesn't look to be the case.\n. From: http://stackoverflow.com/a/19845164/73429\n\ndispatch_once_t must not be an instance variable.\nThe implementation of dispatch_once() requires that the dispatch_once_t is zero, and has never been non-zero. The previously-not-zero case would need additional memory barriers to work correctly, but dispatch_once() omits those barriers for performance reasons.\nInstance variables are initialized to zero, but their memory may have previously stored another value. This makes them unsafe for dispatch_once() use.\n. \n",
    "houndci-bot": "Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Colon Violation: Colons should be next to the identifier when specifying a type. (colon). Colon Violation: Colons should be next to the identifier when specifying a type. (colon). File Line Length Violation: File should contain 400 lines or less: currently contains 440 (file_length). Type Body Length Violation: Type body should span 200 lines or less excluding comments and whitespace: currently spans 226 lines (type_body_length). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Colon Violation: Colons should be next to the identifier when specifying a type. (colon)Nesting Violation: Types should be nested at most 1 level deep (nesting). Colon Violation: Colons should be next to the identifier when specifying a type. (colon)Nesting Violation: Types should be nested at most 1 level deep (nesting). Colon Violation: Colons should be next to the identifier when specifying a type. (colon). Leading Whitespace Violation: File shouldn't start with whitespace: currently starts with 1 whitespace characters (leading_whitespace). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace). Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace). Leading Whitespace Violation: File shouldn't start with whitespace: currently starts with 1 whitespace characters (leading_whitespace). Leading Whitespace Violation: File shouldn't start with whitespace: currently starts with 1 whitespace characters (leading_whitespace). For Where Violation: where clauses are preferred over a single if inside a for. (for_where). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Unused Optional Binding Violation: Prefer != nil over let _ = (unused_optional_binding). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Nesting Violation: Types should be nested at most 1 level deep (nesting). Colon Violation: Colons should be next to the identifier when specifying a type and next to the key in dictionary literals. (colon). Colon Violation: Colons should be next to the identifier when specifying a type and next to the key in dictionary literals. (colon). Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace). Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace). Line Length Violation: Line should be 120 characters or less: currently 144 characters (line_length). Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace). Line Length Violation: Line should be 120 characters or less: currently 139 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 158 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 138 characters (line_length). Colon Violation: Colons should be next to the identifier when specifying a type and next to the key in dictionary literals. (colon). Line Length Violation: Line should be 120 characters or less: currently 128 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 125 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 126 characters (line_length). Mark Violation: MARK comment should be in valid format. e.g. '// MARK: ...' or '// MARK: - ...' (mark). Mark Violation: MARK comment should be in valid format. e.g. '// MARK: ...' or '// MARK: - ...' (mark). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Line Length Violation: Line should be 120 characters or less: currently 130 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 125 characters (line_length). Trailing Comma Violation: Multi-line collection literals should have trailing commas. (trailing_comma). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Line Length Violation: Line should be 120 characters or less: currently 152 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 147 characters (line_length). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Empty Parentheses with Trailing Closure Violation: When using trailing closures, empty parentheses should be avoided after the method call. (empty_parentheses_with_trailing_closure). Line Length Violation: Line should be 120 characters or less: currently 157 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 163 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 135 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 133 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 127 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 123 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 137 characters (line_length). Void Return Violation: Prefer -> Void over -> (). (void_return). Syntactic Sugar Violation: Shorthand syntactic sugar should be used, i.e. [String: Int] instead of Dictionary. (syntactic_sugar). Syntactic Sugar Violation: Shorthand syntactic sugar should be used, i.e. [String: Int] instead of Dictionary. (syntactic_sugar). Syntactic Sugar Violation: Shorthand syntactic sugar should be used, i.e. [Int] instead of Array. (syntactic_sugar). Syntactic Sugar Violation: Shorthand syntactic sugar should be used, i.e. [Int] instead of Array. (syntactic_sugar). Syntactic Sugar Violation: Shorthand syntactic sugar should be used, i.e. [Int] instead of Array. (syntactic_sugar). Syntactic Sugar Violation: Shorthand syntactic sugar should be used, i.e. [Int] instead of Array. (syntactic_sugar). Vertical Whitespace Violation: Limit vertical whitespace to a single empty line. Currently 2. (vertical_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace). Leading Whitespace Violation: File shouldn't start with whitespace: currently starts with 1 whitespace characters (leading_whitespace). Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace). Trailing Comma Violation: Collection literals should not have trailing commas. (trailing_comma). Trailing Comma Violation: Collection literals should not have trailing commas. (trailing_comma). Identifier Name Violation: Variable name should be between 3 and 40 characters long: 'e' (identifier_name). Identifier Name Violation: Variable name should be between 3 and 40 characters long: 'd' (identifier_name). Identifier Name Violation: Variable name should be between 3 and 40 characters long: 'c' (identifier_name). Identifier Name Violation: Variable name should be between 3 and 40 characters long: 'b' (identifier_name). Identifier Name Violation: Variable name should be between 3 and 40 characters long: 'a' (identifier_name). Line Length Violation: Line should be 120 characters or less: currently 129 characters (line_length). Line Length Violation: Line should be 120 characters or less: currently 129 characters (line_length). Superfluous Disable Command Violation: SwiftLint rule 'line_length' did not trigger a violation in the disabled region. Please remove the disable command. (superfluous_disable_command). ",
    "soranoba": "Since I do not use swift, I did not know whether float and double are supported.\nSo, I added some tests.. ",
    "heyzooi": "@ikesyo the original Package.swift file have those trailing commas.\nAlso, I think it's a good think to keep trailing commas in case if you need to add a new item later the diff will have one less line.. "
}