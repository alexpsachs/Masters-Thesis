{
    "puffnfresh": "It's worth it. We'd definitely hit some blockers if we started right now and having blockers might mean that bootstrapping is trickier - but at least we've identified the blockers.\nI think we could start by translating some of the smaller modules. I'd guess lexer.js or typeinference.js would be good candidates.\nAlso, I haven't written a project in Roy yet, so Roy itself is probably be a good project to start with.\n. Roy is a bit of a mishmash of language syntaxes. I would probably say that it's most similar to an ML language.\nI started writing a highlighter for CodeMirror 2 but started hitting some problems. I wanted to have CodeMirror 2 support so that I could make a better \"Try Roy\" site.\nEventually I'm also going to work on an Emacs mode.\n. @alvivi not sure how to do it against existing issues :thumbsdown:\nI think it's fine to just do a pull request with a new issue, possibly referencing #2\n. @paulmillr I'm happy for them to be in the repository. No harm if they're 100 lines of code.\n. If anyone needs any help with this, I've got experience with Pygments and wrote the F# lexer:\nhttps://bitbucket.org/birkenfeld/pygments-main/pull-request/1/added-f-lexer\nNot sure if the Pygments guys will be completely happy to take on a language that isn't actually used - should this wait until a Roy application exists?\n. I wrote a program that does this over \"normal\" JavaScript. Will be able to easily plug this into Roy when I rewrite code generation to use escodegen (issue #151):\nhttps://github.com/pufuwozu/brushtail\n. @rtfeldman yes and yes! :+1: \n. Separate compilation.\n. That should be fixed, thanks!\n. Might be able to use bind. Not present on IE<9 or WebKit so would need polyfill:\nhttps://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n. Fixed in 03f86d8aebe723654c871172540feab7847f5bd2\n. Very, very cool. :+1:\n. @rtfeldman definitely!\n. IDL definitions come with the DOM specifications (e.g. DOM level 2). They describe the type signatures used in those standards.\nSo for us: input is IDL, output is Roy type aliases. Using that we'd have statically typed bindings to the DOM.\n. @DamonOehlman a better way to do this has come up since I filed it. Roy now outputs a .roym file which describes the exports of a module. The problem is that I haven't documented the format.\nIt looks something like:\nobj: {x: Number, y: Number, t: String}\nWhere obj is an identifier the right hand side is a type. I'm guessing the IDL grammer will output something like this:\ntype Element = {\n}\ndocument: {\n  getElementById: Function(String, Element)\n}\nNot sure if that will work since I haven't tested anything that complicated.\n. Was told I should look into domconv, especially the WebKit fork (whose IDL contains some useful extensions):\nhttps://github.com/ghcjs/domconv-webkit\n. I have a perfect domain for this:\nhttp://roylang.org/\nMy idea is a tutorial similar to layout as Learn You A Haskell but the code blocks are interactive (compiles and executes in the browser).\nI'd like to see that.\n. I've started writing documentation using Read the Docs:\nhttp://roy.readthedocs.org/en/latest/index.html\nSee the docs folder. Feel free to help out :)\n. Can you please clarify or give examples?\n. Definitely like them.\nThe point of difference is that Roy's QuickCheck could work on Roy's static types and inference to automatically create the test suites. You won't have to annotate your program with any QuickCheck-specific code.\n. Commands will be more useful for things like loading (:l) and viewing types (:t) but I'm happy to start with this.\n. Fixed in 97fba234b8f87580a59a53d673fcf9ce7a7ddfe0\n. Fixed in daad80b24083cb1d4a082eec94eb57c4dbe3d87b\n. I've been working on this for the past few days. I know what the problem in Roy's type system is, just need to fix it.\n. This should be fixed in f8465a08756f5393b1c05d6f602cf73dc3acc878 :)\n. I wasn't clearing the state on each type-check. Should be fixed now.\n. Thanks!\n. Nice catch! Thanks\n. Sounds good to me.\n. I love this idea. Having Unicode support for built-in syntax would be awesome.\nWhat to do about non-built-in syntax like in #16 might be a later issue.\n. Just wanted to say that I completely see both sides here.\nIt might increase inconsistency but hopefully a good style guide will eventually arise to mitigate that.\n. Sounds good. I think it's best to stick with existing syntax when possible so I vote for Haskell's (OCaml uses something similar, <--).\n. While I'd prefer nobody to use the JS eval in Roy, I don't want to modify the execution environment to hide things.\nI can't really provide a nice and easy \"Roy eval\" because that would have a dependency on the whole Roy compiler.\nAnyway, it sucks that people can do this:\nroy> let a = \"Test\"\nroy> eval \"a = 100\"\n100 : Native\nroy> a\n100 : String\nBut I think that's just the price of using eval.\n. I really like the example but $ isn't defined on the Roy website. It doesn't seem like you're using jQuery's $.ajax.\nWhere should it be coming from?\n. As far as I can tell, there's only jQuery.ajax( url [, settings] ) or jQuery.ajax( settings ).\nThat probably leaves us with a couple of options:\nbind: fn (x : Request) f =\n  $.ajax x.url {dataL x.payload, complete: f}\nOr:\nbind: fn (x : Request) f =\n  ($.ajax x.url).complete f\n. Awesome, I can fix that up locally.\n. Merged and pushed to http://roy.brianmckenna.org/\n. Added in 3359ab181f1445909449048ac204d052504a13cb\n. I cleaned this up a bit and pushed. Thanks!\n. Thanks heaps! I'm going to add a precommit hook so this doesn't happen again.\nFixed in 9517d9851d004bcc30248fb5b496c9eea084d45f.\n. Sorry @esehara this wasn't the idea I had in mind, it was more like @alvivi's implementation.\nStuff like this should work already;\nlet r = require\nlet fs = r \"fs\"\nSo we can already access external JS. I'm guessing you were getting the ReferenceError you got before was because the DOM only defines document and not Document.\n. Should work in 7ff4ac22b2d0a1ebdc80e162f1b1d64ced330c8f\n. I'd prefer for that notation to not convert into ADT lists.\nWe should compile into JavaScript arrays and use that. For a few reasons:\n- Performance\n- Debugging\n- Readability\nWe can still write a good standard library but we just have to come up with a good definition of JS arrays. At the moment I've done two things:\n- Tuples: (1, true, \"three\") is typed as (Number, Boolean, String) and output to [1, true, \"three\"]\n- Arrays: [1, 1, 1] is typed as [Number] and output to [1, 1, 1]\nThis creates the problem of requiring JavaScript definitions of core functions (head, tail, map, etc) to be written for arrays. Still not sure how we should do that.\nWhat do you think?\n. I'd put all Array functions into type-classes so other datatypes can implement them.\n. @darkf sadly it's not just a small change.\nWe use the unicode-categories package to give us ECMAScript 5.1 identifiers. The code goes like this:\nvar IDENTIFIER = new RegExp(\n    unicode.ECMA.identifier.source.replace('\\\\u03BB', '')\n);\nIt's definitely possible to do another replace on the regex:\nvar IDENTIFIER = new RegExp(\n    unicode.ECMA.identifier.source.replace('\\\\u03BB', '').replace(/]([^\\]]*)$/, \"']$1\")\n);\nBut that's very hacky :-1:\n. Very awesome!\n. Thanks, should be fixed in 9f1f5a83659719a8236b935e7a2e04907ed9b3c9.\n. Fixed in 9fce2052e3badd8747e9df788af38cf8fc3333f7\n. Thanks! I'll clean it up a bit and merge soon.\n. Thanks!\nThe FizzBuzz example was added in 17a4d29eac0772242a9c07d97e7b4322d65935db\n. @rtfeldman thanks!\n. Think this was fixed back in 43e78eca0090dc2e2d6aa50dae4401253e073ebb.\nLet me know if you find another place that breaks :)\n. 9f8ab04ee163a5503453a88da1ce5a99dcb24ab8\n. 30db61531ece2c40e87f3a4e29a1276af85d9c04\n. I committed f1ca20f2f773ba21dec88aef1728791f715a90eb to fix this.\nLet me know if it works!\n. Thanks!\n. Looks like this has worked since 0197c09513677efdb79775c3a84a409ed3b08210\n. Fixed in 29e9183622a00f1c07bf3c035fb17e0a94bdb3aa\n. We don't actually need prettyprint in the bundle, only in the REPL. I've committed 575a8a3c9bd61b7e19f557bb7459611054b7c94a to fix it.\nThanks!\n. Done! http://brianmckenna.org/blog/ray\n. I think it's alright to make people emulate it with an anonymous lambda and immediate application.\n. I'd really like these to be lenses.\nThen you could do something like:\nget (.inner .outer) obj\nget .outer.inner obj\nset (.inner .outer) obj 123\nset .outer.inner obj 123\n. This is a problem with Roy's type-system but I'm not sure what the best solution is:\n- I don't think it's wise to encode properties like length in the type-system for the String and Array types. You could just call s.length. But what if a specific engine (or library) provides an extra property we don't know about?\n- We could provide native JS functions that call these properties without type-safety. You would have to call stringLength s. Would work for extra properties but wouldn't be too nice.\nAny other ideas?\n. #17 is for giving types to JS natives. This relates to exporting for CommonJS.\nI've been working on modules for the past week. I'm hoping to come up with a way to unify the popular JS module systems and have Roy code work across them all.\nYou can generate a .roym (type information) file from other_module.roy:\nexports x y\n let x = 100\n let y = 10\nThe generated other_module.roym:\nx: Number\ny: Number\nAnd you can import it:\n```\nexports doubleX\nimport other_module\nconsole.log other_module.x\nlet doubleX = other_module.x * other_module.x\n```\nThis code should be able to compile to Modules/1.0, AMD and browser globals.\n. Pushed a commit which makes modules work in Roy: 85304e1eee4c3886c39299099e8bcbf08d0cfe47\n. Argh, it's a problem with a newer version of Jison. Thanks.\n. Looks like a bug in the latest version. Going to submit a pull request.\n. Pull request sent:\nhttps://github.com/zaach/jison/pull/80\n. Thanks, works in ebc38fefb7708d1a88d9bcbf3884e98a895b66d2.\n. Syntax is good, my parser is bad. I'll fix that up.\n. Fixed in c3deb1617e6fc6df9f57fb6464ab5ea6e79f1e23\n. Pushed a change. The input now compiles to this:\nvar f = function(x) {\n    var a = 2;\n    return a * x;\n};\nconsole.log((f(4)));\n. Awesome stuff. Thanks!\n. It's actually taken from OCaml.\nhttp://ocaml-lib.sourceforge.net/doc/Option.html\n. Thanks!\nThe data.roy and option.roy examples are more targeted towards the http://roy.brianmckenna.org/ website - where the prelude isn't defined. I added a -p flag to use instead of -r if you don't want to include the prelude.\n. :+1:\n. Thanks!\n. I just quickly added this.\nThe flag is called --stdio. Thanks!\n. Unnecessary parens removed in 8f68d3f46fde81d9ab4d501c1d949362bd2322cc\n. You should be able to do:\nmatch (f a b c)\n  case ...\nIs that a problem?\n. Fixed in 8f68d3f46fde81d9ab4d501c1d949362bd2322cc\n. Absolutely amazing. :+1:\n. @taku0 that's probably because I haven't implemented structural types using type constraints. Lazy/silly/short-sighted of me.\nFixing that is on my TODO list :)\n. @gregwebs absolutely awesome job. Thanks!\n. Fixed the problem in 0502301054e846fc3b2080bf6328f6949923ba0e\n. Awesome! Thanks\n. Thanks Damon!\n. Awesome, thanks!\n. @rightfold that's a misfeature of Scala. Globally unique type-classes are an important feature for modularity. See the following blog post for information about what problems arise when we're willing to give that up:\nhttp://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness/\n. @taku0 the rest of the sentence is this:\n\n... you might find yourself unable to compose two components because they accidentally defined the same type class instance, even though these instances are plumbed deep in the implementation details of the components.\n\nWhich is exactly the problem with not having global uniqueness.\n. We need to be able to easily change the types of values, not the instances for types. That way we get the benefits of both.\n. I've take a look at this previously - couldn't figure it out.\nNeed to take another look.\n. So Jison indexes lines from 0.\nThanks @alsonkemp - I've merged your commit.\n. Awesome.\nThe reason I split the two is because I need to generate a separate parser module for parsing module descripters (the .roym files).\nNo need for the grammar to live in separate files but sadly it seems like we need two parsers.\n. I stuffed up a while ago and tried writing my own test runner for Roy instead of using an existing one.\nI need to start testing the non-happy paths and more of the compiler internals. I'll start doing that in the coming months - any improvements in the meantime are greatly welcomed.\n. My original idea with let binding was to generate option 1 when a conflict was detected.\n. But I want the compiler to be smart enough to not have to place function expressions everywhere; it should only put them in places that a native JavaScript developer would want to place them.\n. Wow, this is great!\nI'm looking to rework Roy's tests very soon.\n. Thanks for the awesome summary! You've made the different approaches very clear.\nA few weeks ago I started work on generalising Hindley-Milner to a constraint based system (using Typing Haskell in Haskell as a guide). I'll then be able to add structural subtype constraints.\nI'll try to push the WIP branch later on today. Hopefully you can take a look and let me know what you think.\nI know you tweeted that a polymorphic record calculus could make sense for Roy. Do you still think this is the case?\n. Here's the branch: https://github.com/pufuwozu/roy/commits/constraints\nThis is the new type checker: https://github.com/pufuwozu/roy/blob/constraints/src/typeinference.js\nVery incomplete.\n. After deleting node_modules I can reproduce this. Crazy.\n. I did a binary search until I got a working version of Jison. I have no idea why this so suddenly stopped working.\nCan you do a git pull and confirm that 0.2.7 works for you?\n. Thanks!\n. Looks like interleave 0.1.1 has been removed from the repository. I know the author - asking him why.\nI'll update to a newer version and see if it works soon.\n. Looks like 0.5.11 is fine.\n. Awesome, thanks! Really helpful since I wasn't able to reproduce this problem.\n. The deep issue is that it looks like operator parsing is a bit broken.\nBut anyway, function application doesn't need parentheses. You want to use a - (Math.sqrt c).\n. :+1:\n. Busy this week but I'll publish to npm and a new version of the site this weekend.\n. Published! https://npmjs.org/package/roy\n. Awesome! Thanks.\n. @joneshf sorry, that made no sense. Just updated it with what I meant.\n. @zeckalpha Scala does something like that:\nscala\ndef f(a: (Int, Boolean), b: String) = ???\ndef g(a: (Int, Boolean))(b: String) = ???\n(I used a tuple as an argument type just to show that you can still have that)\n. @zeckalpha you can still have tupled arguments but they're not going to compile to a multiple argument JavaScript call. It'd have to be a tuple object.\n(Just like Haskell)\n. A pollyfilled Function.prototype.bind (pollyfined for IE6) would actually be more normal to see in plain JavaScript code. That could be a good approach to \"caller-side\" currying.\n. CoffeeScript used to do this when you used its \"fat arrow\" (now it's smart enough to just alias this):\njs\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\nI think that's a good default. Roy should probably have an ES5 mode to allow you to not have that and just rely on a builtin Function.prototype.bind but that can come much later.\n. A while ago I setup a drone.io build for Roy - just as a test. Works great!\n\nIf you create an account, I can add you as a collaborator. I can also move to or create a Travis build for Roy if there's a need.\n. @joneshf support for GitHub's Commit Status API would be very useful. I'll add a Travis build if it's too tricky to get working with Drone.\n. Setup a Travis build at: https://travis-ci.org/pufuwozu/roy\n. Awesome stuff\n. Website has been updated, example now works.\n. Did it last night with 63817baff5edf4892b68de6659d5ef75821640be\n. Thanks for the code review. New type inference engine is being worked on in the constraints branch (see 904f611f9a04b0dc189eb58a2fcb6e65c47a08fe) - it suffers the same problem so a pull request would be appreciated there.\n. Yeah, the wrapping is awful. The wrapping is to ensure new scoping for things like:\nroy\nlet x = if 2 > 0 then\n  let x = \"ok\"\n  x\nelse\n  let x = \"fail\"\n  x\nWhich becomes:\njs\nvar x = function () {\n        if (2 > 0) {\n            var x = 'ok';\n            return x;\n        } else {\n            var x = 'fail';\n            return x;\n        }\n    }();\nIt'd always be better to emit a ternary when there's only a single statement. That was an optimisation I've always wanted but didn't get around to.\nBut it might even be better to always emit ternary expressions:\njs\nvar x = 2 > 0 ? function() {\n        var x = 'ok';\n        return x;\n    }() : function() {\n        var x = 'fail';\n        return x;\n    }();\nUndecided, but I do like:\nroy\nlet x = if 2 > 0 then\n  \"ok\"\nelse\n  let x = \"fail\"\n  x\nBecoming:\njs\nvar x = 2 > 0 ? 'ok' : function() {\n        var x = 'fail';\n        return x;\n    }();\nSo maybe we should just run with that. I'll be able to add ternary support to Brushtail fairly easily.\nWhat do you think?\n. @nickmeharry brilliant. Thanks heaps.\n. @joneshf the main rationales for the \"readable JS\" is:\n- People won't be scared to try Roy, failure means just working on the JS output\n- Easier reasoning about what the VM/browser will be doing\n- Easier debugging\n- Performance\nI don't think the ternary causes much of a problem.\n. Yeah, as @taku0 points out. This isn't just syntactic sugar. It provides a version of polymorphism that works with mutually recursive functions, written by @taku0.\nI haven't ported it over to the constraint type system but I might now be able to make it work without the where keyword.\nNot sure.\n. @kennknowles commas:\ntype X = {a: Number, b: String}\nThe structural typing is unsound in master. It sadly allows you to do silly things like:\n```\ntype X = {a: Number, b: String}\nlet x: X = valueFromJS\n// wat, compiles fine:\nx.nonExistant\n```\nAs you probably know, I've been working on a branch to make the type-system work much better, specifically because of cases like this.\n. @kennknowles yeah, doesn't look like the typegrammar likes INDENT tokens, only commas:\nhttps://github.com/puffnfresh/roy/blob/master/src/typegrammar.js#L38\nShouldn't be too hard to fix up.\n. Great, thanks!\n. Yeah, use PureScript - has same goals, hits them better :+1: . This is the only part I don't understand. What's this for?\n. ",
    "abi": "\n1\n. Using the node.js API?\n. \n",
    "alvivi": "I added basic support for TextMate/SublimeText on my roy repository. I'm trying to figure out how to do a pull request attached to this issue (I'm a github newbie). \n. Seems to be a matter of taste, some projects have editor support in the same repository and others have not. \nAs you want :)\n. I wonder how to achieve automatic testing in the current state of roy. The Haskell QuickCheck implementation heavily depends on Testable and Arbitrary classes, in addition of currying to achieve automatic testing. I think that structural typing can't help here. Some background (35:00).\n. I'd prefer to follow the rule \"only one way to do things...\". In Haskell we got unicode symbols, but almost nobody use them (they have more uses in Literate Haskell, for pedagogical uses). If Roy provides unicode symbols the users will have option of use them, but the \"entropy\" of the language will be a little higher. Seems a matter of taste, and IMHO, not a high priority feature.\n. I've been working on this for a while. You can see an early version here. In my local repository is a bit more advanced, allowing extern function declarations. However, these changes involve type annotations in any expression. For example, this code is valid:\n```\nextern setTimeout :: Function -> Number -> Unit\n// I'm not very happy with this, it should be something like\n// extern setTimeout :: (Unit -> Unit) -> Number -> Unit\nlet x = 4 :: Number\n```\nIt is a major change in the type system, so I think that should be discussed before.\n. ",
    "paulmillr": "@alvivi in my opinion, roy textmate bundle / emacs mode should be located in separate repositories. Just as coffeescript addons.\n. @pufuwozu usual bundles are 1000-3000+ LOC -- https://github.com/jashkenas/coffee-script-tmbundle\n. @alvivi I've created repo for textmate bundle and added you as contributor. \n. > should this wait until a Roy application exists?\nThat's reasonable, I think so too.\n. See https://gist.github.com/1697037 -- workaround for lack of \"tail call optimization\" in JS\n. :+1:\n. So, it's adding static typing to existing things?\n:+1:\n. > Also it will introduce wars for coding style and decrease consistency\nNope, as we may see in haskell's / scala's example.\nThese are not additional constructs, they're just aliases\n. > Also, good editors make it possible to show unicode symbols instead of language constructs in case you want some prettiness.\nNoone would see this prettiness except me then.\nI think that Roy should follow the way of functional programming languages like scala & haskell instead of pythonic imperative one. Personally, I don't think there's should be only one way to do it, but definitely language shouldn't have 5 ways of doing the same thing etc (perl).\nScala also has nice community-drived coding style guide. And, as I saw, scala code is very consistent.\n. It's \"complicated\" only because programmers don't have a simple way to write those symbols. So this is a problem of tools, not language. And, IMO, this problem can be solved easily. All we need is an emacs mode & vim plugin (textmate bundle with support of symbols exists already).\n. > you won't be able to fix something with your phone or dumb terminal;\nI am able to fix something because it's an alternative syntax, not only.\nUPD:\nScala isn't complicated, it's clever.\n. Here's a simple script that replaces all the things :octocat::\nsed -e \"s/\\\\\\/\u03bb/g;s/<-/\u2190/g;s/->/\u2192/g;s/=>/\u21d2/g\"\nbash\n\u279c echo 'let a = \\\\a -> \\\\b -> \\\\c -> do return d <- e' \\\n  | sed -e \"s/\\\\\\/\u03bb/g;s/<-/\u2190/g;s/->/\u2192/g;s/=>/\u21d2/g\"\nlet a = \u03bba \u2192 \u03bbb \u2192 \u03bbc \u2192 do return d \u2190 e\nI've implemented it as a command in TextMate / Sublime2 (\u21e7\u2318P).\n. > There are Shift-jis,EUC-JP,ISO-2022-JP in Japan.\nYep, there's many encodings, but Unicode is only one we need in our case, it's 2011 at all. For example, I use TextMate. It doesn't support anything but unicode. What should I do when I see source code in some strange foreign encoding? Node.js doesn't support anything but unicode & ascii. Javascript itself is a unicode thing.\nI'm very glad that we are in the \"unicode future\", where most websites use one universal encoding.\nJust to note: Scala's very popular libraries, like Akka & Scalaz use this arrows, see example.\n. :+1:\n. This is duplicate of #11.\n. These are not keyword-operators:\n\u2200: for all\n\u2208: elem\n\u2209: not elem\n\u2218: function composition\nand they should be implemented as aliases to functions in std lib.\n. :-1:, this is very C-ish.\n. I think this issue needs more research.\nI've benchmarked Roy lists and they seem to be 10 times slower on 10 elements. This is a no-go, because for 100-element lists they would be 100 times slower.\n. I actually still think Roy should work with lists. I saw a node.js module two days ago that contained optimized list that was even faster than array on non-random access. \n. With my patch, you'll need to do npm link if you want to use roy from github (instead of stable roy from npm). It automatically creates all binaries.\n. Oh, my bad. npm link works with current master. Patch is not needed.\n. oh. this is invalid.\n. oh, I see, #17\n. That's the reason I hate package.json with versions like >=0.3.0. It fucks all dependencies (in my case, brunch isn't working now).\nI'll send a pull req with fix.\n. how about \u2218?\ngetData \u2218 getUser\nhttps://github.com/pufuwozu/roy/blob/master/lib/prelude.roy#L17\n. @andreypopp imo apl failed because of shitty charset standards back there in 80s. we now have unicode etc. the only thing that concerns me is editor support but it's achievable too.\nthat's what scalaz (quite popular module for scala) also does\n. @andreypopp that's what I meant by editor support, but the resolution is definitely achievable. Scalaz guys use some cool keyboard input source. I mean, it's pretty easy to make new keyboard input sources, so we could just make another one that on \u2325-> will produce \u2192.\n. Lambda syntax has been changed in #32. So:\nreturn: \\x -> x\n. You can get roy version from package.json.\n. ",
    "esehara": "I write Simple Syntax File for Vim. :)\nDraft Version is here:\nhttps://github.com/esehara/Vim-Roy\n. I try to given:\n[blank line]\nI get the same error as avobe.\n. I vote for \"be able not to Unicode operator as default syntax\". \nI like this idea,but I do not want Unicode Operator to be contained in default syntax.\nBecause I think that it becomes a cause by which a code becomes complicated. the core syntax should be kept simple.(and I love The Zen of Python \"There should be one way to do it.\" ;) ).\nInstead, I propose enabling it to use Unicode Operator as a standard module. \nexample:\nimport UnicodeOperator\n. The number of character codes is not one. There are Shift-jis,EUC-JP,ISO-2022-JP in Japan.\nIn fact, if \"\u2190\" as not Unicode is inputted, an error \"Couldn't tokenize\" will occur. \nIt seems in me that there is no character code agreement in Roy,\nbecause I think it excessive to use a multi-byte's operator(Unicode Operator) as default syntax.\nand I want not to recommend only Unicode.\n. I agree,too.\n\"<-\" is easy to understand \"bind\" because of graphical. I like it :).\nIf this issure were adopted, then I am happy.I vote for Haskell's.\n. Thanks ;)\n. Sorry,I mistake... \nI correct now.\n. Sorry, I mistake \"external\" .\nI think it means \"external\" treat Global Valuable example \"Document\",\"Window\",or etc.\nWe cannot use \"let\" for the purpose,because of Error.\nReferenceError: Document is not defined\nso,Fix \"external\" can treat undefined valuable in Roy. (not use in REPL now).\nexternal document = Document;\nTrancelate JS:\nvar document = Document;\n. Ok,I understand. Thanks :) \n. I think this Issure will not already have necessity because of \":s\" command added by reccent commit.\nI close it.\n. I accept a single entry point is just great practice, Really. :)\nBut I rather like the way of Schame or Python.It is because it is easy to write the way of it. I think, when required, the method of realizing a main function is made,but when not required, run with top-level expressions . \n. Example FizzBuzz:\n```\nlet isfizzbuzz x = \n  if (x % 15) == 0 then\n   console.log(\"FizzBuzz\")\n  else\n    isbuzz x\nlet isbuzz x = \n  if (x % 5) == 0 then\n   console.log(\"Buzz\")\n  else\n    isfizz x\nlet isfizz x =\n   if (x % 3) == 0 then\n    console.log(\"Fizz\")\n   else\n    console.log(x)\nlet fizzbuzz x y = \n   if (x < (y + 1)) then\n    isfizzbuzz x\n    fizzbuzz (x + 1) y\n   else\n    console.log(\"end\")\nfizzbuzz 1 25\n```\n. ",
    "jordwalke": "Thanks a ton @esehara / @paulmillr\n. @eegg It seems the most consistent and clear solution for binding values to names is to require the use of \"let\" not only for function values, but also for non-function values.\nWhy should they have two different ways of specifying values, when the only difference is that they have two different types?\nlet someNumber = 4 in ...\nlet id someFunc = x in ..\nsomeInt and someFunc are both bindings to values. One binding just happens to be of type function, and the other of type Number.\nMaybe neither should require the let keyword? Either way, it seems they are doing the same thing so they should use the same syntax. I suspect requiring let/in makes the grammar easier to define in an unambiguous manner.\n. I do see the distinction you're referring to. But they both bind a value to a name, correct? One just happens to be in the scope of the entire module. What value is there in \"top level definitions\"? Do you like them because you don't need to specify an in..end?\n. @tokland - There is a case where lets actually make the code more clear.\nDepending on how references are implemented, let allows the programmer to indicate when a reference binding is introduced the first time. Further reassignments (mutations) wouldn't typically require the \"let\". If I were to see an assignment without a let, I would know to be extra careful, because this is a reference binding, and there is some mutation happening to bindings in the environment.\nMaybe requiring some kind of keyword to indicate a reference _re_assignment would make more sense since it is more rare than the standard case.\n. ",
    "gregwebs": "Lack of a trampoline is one of my biggest concerns with Roy. It should be documented how to use iteration instead.\n. I don't think this helps Haskell much. a2 or a_ works fine, but usually the best is to use more descriptive names.\n. I am switching from -epb to -spb. from eval to stdin. So if Roy can take stdin and put the results on stdout that would be great!\n. tested it out, works well, thanks!\n. it looks like Roy does not support regex literals. I can change this to:\njavascript\nif (window.location.href.match 'localhost') then\nThis is still slightly unsatisfactory because it requires parens - that is probably the same issue as the match/case bug I opened up.\nHowever, this error message should still be improved.\n. yes, that does work\n. This seems to be working now\n. ",
    "raimohanska": "+1\n. It might prove hard (impossible?) to implement a fully automatic TCO system into Roy. The actual implementation for a single function is quite easy though, using the implementation found in the gist:\nfunction tco(f) {\n  var result, active = false, accumulated = []\n  return function accumulator() {\n    accumulated.push(arguments)\n    if (!active) {\n      active = true\n      while (accumulated.length) result = f.apply(this, accumulated.shift())\n      active = false\n      return result\n    }\n  }\n}\nAn easy workaround would be to add a means to indicate that a function is recursive, in which case the compiler would  apply tco as above.\n. That's very good news!\n. Btw, there's another trick in the example: the putStrLn implementation assumes that Roy functions are curried and partially applicable which apparently is not the case. Hence, my working version has also this change:\nlet putStrLn line = (\\() -> console.log line)\nIn this same experiment I tried to introduce \nlet const x = (\\() -> x)\nBut that doesn't compile; const seems like a reserved word. Don't know if that's intentional... (If I name it \"always\" instead, it compiles)\n. So I made a fix, but I gotta admit I don't understand the compiler thorougly enough to be totally convinced it works under all circumstances. I added a new testcase (callbackmonad.roy) an existing test case to also include a line where there's just a side effect and no assignment.\n. Works in Turtle Roy: http://turtle-roy.herokuapp.com/?turtle=2FTJWA37ZP\n. ",
    "rtfeldman": "This is in progress but still has some snags to work out.\nIt's worth noting that TCO goes against the goal of \"readable generated JS\", since it necessarily transforms your function call into something else, but I assume the consensus is that the benefit easily outweighs the cost here.\n. Is this really a bug? Seems like it should be wishlist.\n. +1 for allowing the bottom snippet...if we already have a delimiter like \\ or \u03bb to denote the start of a lambda, and are already using significant whitespace, not having to use parens as de facto curly braces would be awesome.\n. There are now quite a few examples in the repo; any objections to my closing this?\n. As far as I know there are no plans for this. @puffnfresh thoughts?\n. +1 on removing let for declarations. The arguments for doing so:\n- It's more concise\n- It's more familiar to Haskellers\n- It's more familiar to CoffeeScripters, even\n- Since there's no variable reassignment, = always does the same thing; as such, let does not reduce ambiguity in Roy's case, it only increases verbosity.\n. I profiled this to see what the impact was, including with and without running the generated JS through Closure Compiler: http://jsperf.com/lifted-lambdas\nThe performance difference is pretty minor without Closure Compiler, but with it, the proposed lifted version is mind-blowingly faster than the original - especially in Firefox and Safari.\nI was going to say that it would be better to err on the side of pretty generated JS, but this is a pretty massive difference in performance. It's probably worth considering.\n. At this late hour it seems safe to say Roy will not be using the CoffeeScript compiler as a base.\n. The [[Class]] solution has its own problem, which is that it's only doing string comparison. In contrast, instanceof checks actual references, so it's less prone to false positives.\nI propose that serialization and deserialization with type information is not something Roy should try to automate at a language level. Instead, that should be left to libraries such as HydrateJS.\n. << and >> sound reasonable.\nJust to throw an idea out there, ** is closer to \u2218 and it's easy to remember: \"++ for concatenation, ** for composition\".\n. +1 to >> and << for composition and >>> and <<< for bitwise shifts.\nI would suggest deferring consideration of |> and <| until a later release. Pipe is certainly not an urgent inclusion (as I'd say composition is for a functional language), and casual additions to the initial release of a language have a tendency to come back and cause unforeseen headaches later on.\nWhich is not to say that Roy should never have them, just that I think it's better to err on the side of a narrower scope for the initial release of the language.\n. Wow, I had no idea >>> and <<< were already taken!\nFor what it's worth, given how much more often composition will presumably be used compared to bit shifts, I think it's safe to assume that if >> is known to be for composition in Roy, anyone in the extremely uncommon position of needing a bit shift will hit the Roy docs to hunt down the appropriate operators. I doubt enough people will try to intuit it and then get confused to be worth worrying about.\nMy objection to .> is that all Roy operators can be used (as far as I know) without whitespace separating them from surrounding terms, which means foo.>bar would denote function composition...even though it could just as easily appear that you're trying to access the >bar field of the foo object instead. Neither foo>-bar nor foo>>bar has that problem. Personally I wouldn't use a composition operator without whitespace, but I've had coworkers who never used whitespace around operators; if it's allowed, some people will adopt it as a style, and that does seem like a potential cause for confusion.\nI don't have any strong preferences on >> vs. continuing to seek alternatives (although for whatever it's worth, one Haskell guy I talked to at a conference thought >> sounded confusing because it does something else in Haskell), but I would prefer to avoid three-character operators like ->- for tasks as common as composition when we could have two-character operators instead.\n. The drawback of IIFEs for things like this is that they interfere with TCO - see the TCO PR discussion.\nGiven that, I think renaming the shadowed var (e.g. var x2 = ...) is the best remaining option.\n. For reference, the current roy-brunch plugin implementation using Roy 0.1.4: https://github.com/brunch/roy-brunch/blob/master/src/index.coffee\n. Is this something we definitely do or do not want? I have no preference, except that we should close the issue if it's not going to make it in.\n. To confirm, is a - Math.sqrt(c) supposed to be valid, except the parser is rejecting it? Or is only a - (Math.sqrt c) intended to be allowed?\n. +1 for the original \"caller side\" proposal that generates the following for g:\nfunction g(b) {\n    return f(42, b);\n}\nIf exported Roy functions are curried, calling Roy libraries from vanilla JS will entail royFunc(arg1)(arg2)(arg3) instead of the usual royFunc(arg1, arg2, arg3). Then you must remember to use that calling style only for libraries written in Roy, making Roy libraries intrinsically inconvenient to vanilla JS users.\nThis is an especially important consideration for people wanting to incorporate Roy into existing codebases incrementally: rewrite one piece of legacy code in Roy, then another, then another...\nIf Roy functions require a different calling style, then implementing drop-in rewrites of individual JS functions or modules is off the table.\n. Tupled arguments are one approach to compatibility, but it means Roy authors have to consciously code with compatibility in mind.\nAs a Roy author I'd rather just code naturally and have the compiler take care of generating JS-friendly code.\n. Yeah, that's how I would expect it to work from the JS side.\n. That works too. As an aside I like the idea of saying \"Roy targets ES5, so include these polyfill libraries if you need to target lower than that\", or include something along the lines of a --polyfills compiler flag to allow you to opt into (or maybe opt out of) having polyfills included in the generated source.\nThe most important part to me is getting the best of both worlds: automatic currying when I'm writing Roy, and standard invocation style when I'm calling Roy functions from JS.\n. Sure, that's definitely a minor optimization.\n. Ah, makes sense. So my assumption that it was for scoping was incorrect.\nIn this particular case, the return statements inside the if and the else happen to make it work as an expression with or without the wrapper function. But I can easily see where that wouldn't generalize; if I'd been assigning the result to a variable, the wrapper function would be a clean way to do that:\njavascript\nvar result = function () {\n        if (a > 0) {\n            return a;\n        } else {\n            return b;\n        }\n    }();\nTwo alternative ways to generate JS for an if expression that don't involve a wrapper function are:\n``` javascript\n// Alternative #1: Reassignment\nvar result;\nif (a > 0) {\n    result = a;\n} else {\n    result = b;\n}\n// Alternative #2: Ternary\nvar result = (a > 0) ? a : b;\n```\nBased on some quick experimentation, CoffeeScript uses the ternary approach for cases like these.\nBenefits of the ternary over the function-wrapping approach include that it's better for performance because it's lower-overhead, it's TCO-friendly, and it's arguably clearer - the ternary is an actual conditional expression, whereas wrapping in a function and using return is a roundabout way to achieve the same.\nDrawbacks include that it can generate JS that's difficult to read when the conditionals have a lot going on in them (statements are comma-separated, etc.), and that it doesn't offer any more fine-grained control over scope. (Which, to be fair, I'm not sure we're actually using anyway.)\nAs an aside, it appears Brushtail doesn't TCO ternaries at present, so even assuming they are what we want, switching wouldn't be a drop-in fix just yet.\n. Nice! Thanks for all the great updates. I also think the ternary will be fine in terms of readable output, especially considering CoffeeScript uses it. Certainly many people are happy with the readability level of CoffeeScript's output.\nOne last thing to note:\njavascript\nvar x = 2 > 0 ? 'ok' : function() {\n        var x = 'fail';\n        return x;\n    }();\nThis ternary approach permits TCO in Roy when there is no let involved in a conditional, but supposing the else branch in this snippet returned a recursive call instead of x, that function wrapper would still prevent Brushtail from recognizing the call as being in the tail position.\nI think the best way to handle this case would be on the Brushtail side. If Brushtail could consider zero-arg anonymous functions that are immediately invoked as \"harmless\" (not impacting whether a call is in the tail position), and then migrate them during rewriting (to preserve the scoping properties), then I believe we'd have our bases covered on TCO for Roy.\n. Good points!\nIf doing a gensym-like approach to naming shadowed variables is on the table, we can still use ternaries as long as we put the var declarations up front, which is how CoffeeScript handles it:\n``` javascript\nvar x, x_;\n(2 > 0) ?\n  (x_ = \"ok\", x_) :\n  (x_ = \"fail\", x_)\n```\nI don't know if there's been much discussion on whether name collisions should be okay. I tentatively like the idea of prohibiting them, especially if let foo = is going to be replaced with the more concise foo =. For example:\ncoffeescript\nx = if 2 > 0 then\n  x = \"ok\"\n  x\nelse\n  x = \"fail\"\n  x\nThis looks very much like reassignment, even though it's really (intended to be) shadowing. Prohibiting this would be less flexible, but would simplify reading Roy code.\nEither way, I like the idea of sticking with ternaries while putting the necessary var declarations before the conditional in order to avoid anonymous function wrappers.\nThis seems like the best solution to the TCO roadblock proposed so far.\n. Any objections to merging this in?\n. ",
    "jameshfisher": "In lieu of exhaustiveness checking, I'd add a runtime exception as the final case in all matches.  So the Roy\n``` haskell\ndata Maybe a = Nothing | Just a\nlet x = match Nothing\n    case (Just x) = x\nconsole.log x\n```\nwhere it currently compiles to\njavascript\nvar Nothing = function(){};\nvar Just = function(a){this._0 = a};\nvar x = (function() {\n    if(new Nothing() instanceof Just) {\n        var x = new Nothing()._0;\n        return x;\n    }\n})();\nconsole.log(x)\nshould instead compile to\njavascript\nvar Nothing = function(){};\nvar Just = function(a){this._0 = a};\nvar x = (function() {\n    if(new Nothing() instanceof Just) {\n        var x = new Nothing()._0;\n        return x;\n    } else {\n        throw(\"/tmp/foo.roy:(line,col)-(line,col): Non-exhaustive patterns in case\");\n    }\n})();\nconsole.log(x)\nThis should be the default, only to be removed if and when Roy can verify that the matches are exhaustive.\n. Not sure what version is on http://roy.brianmckenna.org/, but tagged unions are now broken.  On the example I get the error\nError: Multiple declarations for data constructor: Some\n. (I should note that this would not really be useful until/unless Roy gets GADTs.)\n. I would then recommend defining a JS/JSON AST, and no-nonsense, plaintext, explicit syntax for this (e.g. something Lisp-like), for people working directly on Core.\n. We'd require a way of defining uncurried functions in order to state the type of external functions.  Or could these be modelled using tuples?\n. OK.\n. For reference, Haskell's alternative unicode symbols.\n. What things would this make impossible? Even conservative languages like Dart enforce a main function. A single entry point is just good practice.\n. I don't feel the need for a Roy module system, for the same reasons as you; a compiled Roy module should be able to be wrapped in any old module boilerplate. In what I'm proposing, this boilerplate would simply include a call to main(); at the end of the compiled JS module. The main function in the Roy code is where you'd add your exports and whatever else.\n. (Sorry, lexden is me. :)\n. To make myself perfectly clear: everything in the (nullary) main function would simply be dumped at the bottom of the compiled JS.  Therefore the only thing this proposal prohibits is the use of top-level expressions that precede definitions -- would anyone need these?\n. The issue here is whether or not Roy should encourage JS-style imperative coding, where the programmer thinks in terms of flow of execution (\"OK, I defined this function here, but redefine it here, so ...\").  I would argue that it should not: it is by design a static functional language, where one does not, and should not have to, think this way.\nThe stated goal of sticking to Javascript semantics is a separate from the issue of Javascript style, I think.\n. You should be able to define main anywhere, including at the top of your module.  So the following should be equivalent to my earlier suggestion:\n```\nlet main =\n  define [\"dep1\", \"dep2\"] module\nlet module dep1 dep2 =\n  {export1: something, export2: somethingelse}\n```\nWhich would again be equivalent to\nlet main =\n  define [\"dep1\", \"dep2\"], \\dep1 dep2 \u2192\n    {export1: something, export2: somethingelse}\nWhere the former should generate\njavascript\nvar module = function(dep1, dep2) {\n    return {\n        \"export1\": something,\n        \"export2\": somethingelse\n    };\n};\ndefine([\"dep1\", \"dep2\"], module);\nand the latter would generate\njavascript\ndefine([\"dep1\", \"dep2\"], function(dep1, dep2) {\n    return {\n        \"export1\": something,\n        \"export2\": somethingelse\n    };\n});\nwhich I think is exactly what we want.\n. If we want this (I'd actually be in favour of it), we can instead compile\n```\nlet main () =\n  define [\"dep1\", \"dep2\"] module\nlet module dep1 dep2 =\n  {export1: something, export2: somethingelse}\n```\nto\njavascript\nvar main = function() {\n  define([\"dep1\", \"dep2\"], module);\n}\nvar module = function(dep1, dep2) {\n    return {\n        \"export1\": something,\n        \"export2\": somethingelse\n    };\n};\nmain();\nI've modified the Roy main to take a value of unit type, which is current valid Roy and generates the desired nullary function.  Therefore my proposal becomes extremely simple:\n- Disallow top-level expressions.\n- If a function let main () = ... is defined in the module, the single line main(); is appended to the bottom of the compiled JS.\nI should note that an optimizer like the Closure compiler should reduce something of the form\njavascript\nvar main = function() {\n  define([...], module);\n}\nvar module = function(...) {\n  // do stuff\n}\nmain();\nto the more compact\njavascript\ndefine([...], function(...) {\n  // do stuff\n});\n. I just checked; Closure does do that.  It compiles\njavascript\nvar main = function() {\ndefine([\"dep1\", \"dep2\"], module);\n}\nvar module = function(dep1, dep2) {\n  console.log(dep1[\"foo\"]);\n  console.log(dep2[\"bar\"]);\n}\nmain();\nto\njavascript\ndefine([\"dep1\", \"dep2\"], function(a, b) {\n  console.log(a.foo);\n  console.log(b.bar)\n});\nSo I would call my suggestion of dumping the contents of main at the end of the file a premature optimization.  I am now in favour of the simple call to main().\n. This problem is also apparent in the lambda syntax:\nlet nullary = \\ -> 5\nGenerates the compiler error\nError: Parse error on line 2: Unexpected 'RIGHTARROW'\n. I would suggest:\n- Make the let syntax always generate a function, even nullary.  Introduce a var keyword for the current use of let with no arguments.\n- Allow nullary lambdas simply using the notation \\ -> ....\n. Of course, we also need a way of calling them rather than referring to them ...\n. I do apologize!  It seems Roy has a unit type/value, ():\n``` haskell\nlet foo () = 4\nlet bar = () -> 5\nlet baz = foo\nlet qux = foo ()\n```\ngenerates\njavascript\nvar foo = function() {\n    return 4;\n}\nvar bar = function() {\n    return 5;\n};\nvar baz = foo;\nvar qux = foo();\n. I think #41 is a prerequisite to this.\n. @jordow I'm not sure what you're saying.  Let's distinguish two language constructs:\n1. Top-level function definitions.  In Haskell, these are statements (not expressions) of the form foo arg1 ... argN = E either at the top-level of a module or in a where clause.  This defines a function foo of arity N.\n2. Let expressions.  In Haskell, these are expressions (not statements) of the form let f1 arg1 ... argN = E1 in E2.  This is semantically equivalent, I think, to the expression (\\f1 -> E2) (\\arg1 ... argN -> E1).\nThese are quite distinct, in Roy (if it gains let expressions) as in Haskell, the most important distinction being that the former is a definition, and the latter is an expression.  As such, I think they should be syntactically distinguished (to avoid confusion if nothing else).\nI'm not suggesting that we distinguish functions from values (nullary functions).\n. It may be sensible to lift all lambdas, not just those with no free variables, as a conceptual simplification during compilation.\n. Cool paper.  How would the types work here?  I guess we'd have something like\nget .outer.inner : { outer: { inner: a } } \u2192 a\nset .outer.inner : { outer: { inner: a } } \u2192 a \u2192 { outer: { inner: a } }\nWhat is the type of .outer.inner?  Are get and set non-first-class primitives?\n. ",
    "joneshf": "This seems pretty easy to implement, and we currently don't have exhaustiveness yet.  Is this viable, or is the constraints branch adding some of that goodness?\n. You should be able to do multi line stuff now.  So the first two examples should open up a new line for you to add most stuff to it.  The third example should just parse the whole thing like nobody's business.  The last example however, still wont tokenize.\n. This was actually fixed with #177.\n. This appears to have been fixed, but there's a few other issues with windows. I'll open a new issue for those in particular.\n. Can you explain a bit more in depth what you're suggesting?\n. This was not actually added to the list of help options.  I added that and browser here: https://github.com/pufuwozu/roy/pull/167\n. I like << and >>  as well.  ** has connotations in other languages, like f#, to mean exponentiation.  So, I think it'd be a bit confusing to have that mean composition.\n. Pipes sound like a good addition to me.\nSo are we cool with these additions/changes:\n- >> forward composition\n- << backward composition\n- >>> bitwise shift right\n- <<< bitwise shift left\n- |> forward pipe\n- <| backward pipe\n. That's probably a good idea.\n. Good point.  I have to wonder though, how often do people use the shift operators in js, and is it less of an issue for someone using roy?\n. Installation seems to work on win7/8 as of late.\n. Personally, I would prefer to not have semi-colons.  As far as the repl itself, can't we use the node repl to support  multilines?\nAlso, agreed about the issues.  There's a good deal sticking around that should be trimmed.\n. If there's still want for semi-colons feel free to open this up again, however, the example you posted should parse now.\nroy\nroy> let foo x =\n....   let bar y = x + y\n....   bar\n.... \nroy> foo\nfunction (x) {\n    var bar = function (y) {\n        return x + y;\n    };\n    return bar;\n} : Function(Number, Function(Number, Number))\nroy> foo 3\nfunction (y) {\n        return x + y;\n    } : Function(Number, Number)\nroy> (foo 3) 4\n7 : Number\n. Hmm, There still seems to be a bug about this as of 0.2.2.  It seems to still have to bind something in order for it to compile.\nSo something like:\nroy\nlet main = do someMonad\n  someFunc 37\nGives this traceback:\n/usr/lib/node_modules/roy/src/compile.js:152\n    var result = n.accept({\n                   ^\nTypeError: Cannot call method 'accept' of undefined\n    at compileNodeWithEnvToJsAST (/usr/lib/node_modules/roy/src/compile.js:152:20)\n    at compileNode (/usr/lib/node_modules/roy/src/compile.js:150:16)\n    at Object.n.accept.visitBind (/usr/lib/node_modules/roy/src/compile.js:317:27)\n    at accept (/usr/lib/node_modules/roy/src/nodes.js:146:26)\n    at compileNodeWithEnvToJsAST (/usr/lib/node_modules/roy/src/compile.js:152:20)\n    at compileNode (/usr/lib/node_modules/roy/src/compile.js:150:16)\n    at Object.n.accept.visitDo (/usr/lib/node_modules/roy/src/compile.js:388:27)\n    at accept (/usr/lib/node_modules/roy/src/nodes.js:156:26)\n    at compileNodeWithEnvToJsAST (/usr/lib/node_modules/roy/src/compile.js:152:20)\n    at compileNode (/usr/lib/node_modules/roy/src/compile.js:150:16)\n. This also affects #163.  I'm going to double check this later and probably merge it.\n. Yeah, after I took a step back and looked at it, the parens made more sense.  Guess I've been in js too much lately.\n. This doesn't actually need to be an issue.  Also, it's getting revamped for additional support of syntax highlighting, snippets, and sublime text 3 (now that it's in public beta).\n. @puffnfresh A good deal has changed since 0.1.5 was released.  How do you feel about going to version 0.2.0 after #178 is fixed?  Also, are we using semver for our versioning?\n. #180 is about the site, but still related.\n. Coolio!\n. @pufuwozu sorry, I don't really understand that last example.\n. @zeckalpha I kind of like the idea of a curry function, though I think we can generalize it.\njavascript\nvar curry = function(f) {\n  function currier(curriedArgs) {\n    // We need at least as many args as the function takes.\n    if (curriedArgs.length >= f.length) {\n      // Pass them all into the function.\n      // We could only pass as many as needed,\n      // but some goof could be using unnamed args like this is.\n      return f.apply(this, curriedArgs);\n    } else {\n      // Not enough args, let's curry it with what ever else comes down the pipe later\n      return function() {\n        var newArgs = curriedArgs.concat(Array.prototype.slice.call(arguments));\n        return currier(newArgs);\n      };\n    }\n  }\n  // Grab only the arguments.\n  return currier(Array.prototype.slice.call(arguments, 1));\n};\nSomething like that, except with more clarity.\nSo we should be able to do things like:\nhaskell\nlet f x y = x + y\nlet g = f 37\nconsole.log (g 3)\nand have it compile to\n``` javascript\nvar f = function(x, y) {\n  return x + y;\n};\nvar g = curry(f, 37);\nconsole.log(g(3));\nvar curry = function(f) {\n  function currier(curriedArgs) {\n    if (curriedArgs.length >= f.length)\n      return f.apply(this, curriedArgs);\n    return function() {\n      return currier(curriedArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n  }\n  return currier(Array.prototype.slice.call(arguments, 1));\n};\n```\n. Ah, thanks for the correction.\nSo I guess the question is, can a generalized curry function be written that is readable?  Or do we cut our losses and just say partial application is good enough?  How would a plain js developer do it?  Would they write the partial, or try for true currying?\n. I haven't looked at it too indepth, but underscore-contrib seems to actually do this: https://github.com/documentcloud/underscore-contrib/blob/master/underscore.function.arity.js#L127-L176 Based on https://github.com/eborden/js-curry But yeah, it seems like it's not the norm.\n. Very nice @nickmeharry! Can't wait for constraints to land.\n. Done, same username as here joneshf.  Is there an advantage to drone over travis?  Does drone have service hooks to test pull requests?  I remember now that was what I was actually wanting out of travis.\nEDIT: I see now it has some interesting features and supports more than just github.  I'll look into adding a hook on github for it.\n. Thanks for adding me.  Here's what I've found.  We can add a service hook for pull requests to drone on github.  That would send a message to drone.  Drone would interpret it as though a commit was pushed to master and try to build master.  Since they are parsing the JSON we don't have access to what was actually sent.  We could create a custom build script to handle this, and have it curl the github api for this repo to see what's new, then decide what to build.  But it seems like too much work.  At least for me.\nDrone is supposed to add support for pull requests in the future.  If you're alright with it, we can use travis in the mean time, and switch back to drone once they get pull requests set up.\nOr, if you're feeling cavalier/bored, you can setup a script to check pull requests, see if they're new and build them, then report the status.  Unfortunately, I think that master would have to be rebuilt after every pull request just to ensure that the status badge for master doesn't change due to a bunk pull request.\n. Well, I got bored and started something.  We'll see how it turns out.\n. Looks like 4-8 weeks.  So nevermind the build script I was working on.  I think this should stay open until there is pull request support, be that travis or drone.\n. So, it looks like travis has stopped building because of the namechange from pufuwozu to puffnfresh.  Can you change the travis build?  Drone is still going strong, they just need to add PR support so we can ditch travis.\n. Cool, I see you updated it.  Thanks.\nAlso, I'm going to remove the drone badge from the readme for now.  I don't think we need two badges showing the build passed.\n. The version that is on the site is a bit outdated.  There was support for lowercase e up until now.  I've just added uppercase E as well as + in the exponent.  Until we get a more current version up on the site, you can clone this repo and have support for scientific notation.\n. Looks like what's happening is that the last comment is going away completely, and any comments on the top level with no code beneath them are being put at the top of the file.\n. It's being wrapped because it's a conditional statement. https://github.com/puffnfresh/roy/blob/master/src/compile.js#L175-L220\nI forget the actual reason why conditionals are wrapped, but it allows you to use them as expressions, as you did there.  Unless that is the whole reason.\n. I think either way is fine.  In my mind it doesn't matter what the js looks like when it comes out, but wasn't one of the original ideas with roy to emit js that a normal person would write?  I'm not sure how many people would write a ternary like that.\nEDIT: just saw this, so do we favor ternary in this case?\n. I'm game.\n. Thanks for taking a look.\nGood catch on the colon, it was showing the help for things like {a: 17}.\nI'm not entirely sure what to do about do and match.  I'm thinking we have access to the tokens, could just tokenize the line and check for a do or match.  Any thoughts about that approach?  As it stands now, both of those statements require a block in order to parse correctly.\n. Hmm, so now : is parsed as an invalid command, in fact anything that begins with : and isn't in the list of commands parses as invalid.  As for the do/match hangup, if I understand the grammar properly.  It's gotta be\nroy\ndo <expr>\n  <block>\nor\nroy\nmatch <expr>\n  <block>\nSo, I updated it to work better with that.\nI tried the tests in the repl, and they seemed to pass with just pasting them in there.\nAny other suggestions?  If not I'm calling this good and merging it in.\n. That's actually something I was thinking about with #193 in particular commit  7cf240a.  You should review that PR and offer some opinions.\n. You may be right that this is a jison thing.  We are using an extremely old version of it.  I'm not sure what changed between 0.2.7 (which we currently require) and 0.4.13 (latest), or if it fixed anything, but feel free to update the version.  Might be as simple as that.\n. I was hoping someone more qualified would have looked at this by now, but I'm fine with it.  Maybe @puffnfresh, @taku0, or someone can give it a glance.  If not I'll merge it.\nUntil we get a quickcheck implementation in roy like suggested in #21, I don't see a problem in using claire.  The source may be written in ls, but what we'd get from npm would be js, so there's no extra dependency for it.  Feel free to add it if it makes this easier/better.\n. Yeah, it's a bit tough to use mutability. You have a few options. Here's two.\nUse something like underscore to update it.\nroy\nlet _ = require 'underscore'\nlet show el = _.extend el.style {display: 'block'}\nUse something like fantasy-lenses to still deal with immutability.\nroy\nlet ol = (require 'fantasy-lenses').objectLens\nlet show2 el =\n  (((ol 'style') .andThen(ol 'display')).run el).set 'block'\n. It was in order to normalize the type output.  {'a': 2} would type as {'a': Number} whereas {\"a\": 2} would type as {\"a\": Number}.  Seemed a bit inconsistent to me as either version is a valid string and the repl would print the object as {\"a\": 2} in either case.  Also, it apparently didn't type nested quotes properly, so I've fixed that.\n. Can you explain briefly why this change is necessary?  I assume that underscore returns -Infinity when the array is empty.  Is that correct?\n. Cool.  Thanks.\n. ",
    "piranha": "Do you want to use some existing IDL? Or just Roy types? I don't really care though, anything would be nice.\n. Ah, great then, would really cool to have type-checked DOM manipulation! :)\n. Why would you want to introduce some meta-commands when usual C-d works fine? :)\n. Well, I believe that introducing too many syntax constructs will make language noisy. Also it will introduce wars for coding style and decrease consistency. ;-) I.e. I believe Python philosophy should be followed - 'There should be one-- and preferably only one --obvious way to do it.'\n. > These are not additional constructs, they're just aliases\nThat's what I'm talking about. TIMTOWTDI. Perl, Ruby and to some extent CoffeeScript suffer from it.\n. Also, good editors make it possible to show unicode symbols instead of language constructs in case you want some prettiness.\n. > Noone would see this prettiness except me then.\nIt's not like this prettiness will make something easier. It's not easier to read, not easier to write, and someone without configured keybindings will send you patches with ->, inconsistent with your pretty codebase with \u2192. This will be a pain point.\n\nI think that Roy should follow the way of functional programming languages like scala & haskell instead of pythonic imperative one. \n\nI'm not sure I follow how is consistency bound to functional/imperative styles? Let's say roy should follow the way of functional programming languages like lisp instead of perl imperative one, would this better explain my opinion?\n. It's complicated because:\n1) you've got alternative syntax for language;\n2) you won't be able to fix something with your phone or dumb terminal;\n3) isn't that enough?\nIt may be pretty, but it's arguably complicates language. Is Haskell or Scala simple (rhetorical question)?\n. Unicode is not an encoding. UTF-8, UTF-16 and UTF-32 are encodings.\n. Hm, I thought about exactly jQuery's $.ajax. Why doesn't it look like this? Of course, to be able to run it, it would be nice to point to some real url, but it still needs jQuery for this.\n. Indeed I was wrong. I thought about $.get x.url x.payload f. :\\ Sorry.\n. This is duplicate of #17 and #18.\n. This one is just great!\n. Departing too far from JS semantics isn't good; making it impossible to execute certain instructions of JS will make Roy more limited in it's capabilities than otherwise.\n-1.\n. require.js would be impossible without top-level statements, taking this from stuff I work with.\nAnd, in case you can counter this example with that Roy can have it's own module format - having one single true format for modules (which can't be improved without changing the language) will make Roy incompatible with the rest of the world (and more difficult to add to existing projects).\nAlso, I believe that Dart is bad example. Java has no functions, only methods, should anybody follow this convention?\n. I don't see how this makes easier to integrate with current JS eco system. How would you implement module for require.js then?\n. > To make myself perfectly clear: everything in the (nullary) main function would simply be dumped at the bottom of the compiled JS.\nAh, in this case, it's not that bad when I think about it.\n\nHow would you currently implement it?\n\nSomething like this, of course:\ndefine ['dep1', 'dep2'], \\dep1 dep2 ->\n  {export1: something, export2: somethingelse}\nIt's a bit better than having main in this case because you see all dependencies at the top of the module. But that's quite minor I guess...\n. Indeed, in such case this seems almost good. 'Almost' because if someone decides to call 'main' in some function, defined in the same file, we've got a problem... Not that I think this is normal, but this is valid corner case.\n. ",
    "DamonOehlman": "I'd be happy to have a look at this one, if you had some pointers on where to start.  I found an IDL grammar for antlr but haven't really got a good idea on how to convert this to something usable in JS land...\nCompilers and parsers definitely aren't my strength, but I think this has some value and is reasonably self contained so would love to help out :)\n. ",
    "laslowh": "Maybe something like:\nhttp://tour.golang.org/#1\n. ",
    "seidtgeist": "Reminded me of @darrint's qc.js and @wkriesing's qc.js fork. Clearly you want to write yours in roy but maybe it helps :P\n. ",
    "TheDet": "Stumbled over that too, when I tried to convert the very first example on nodejs.org, a simple http server, to roy.\nThe API uses a dictionary with the header keys as domain, e.g. \"Content-Type\". This is rejected by the compiler.\n. I am new to Haskell and not very much at home in JavaScript.\nFor me the 'let' keyword in its current form (variable and function def.) looked very intuitive.\nIIRC declaring functions with let is in conformance with the GHC REPL, where functions indeed have to be declared with let (correct me if I'm wrong) \nThen let will be the preferred way to declare variables in ES.next. So don't dismiss it.\nAlso, understanding let as binding to a name in both cases is quite intuitive for newcomers, at least non-haskellers. The expression vs. statement  argument is not so intuitive, albeit logical.\nCan't check now: does roy have let..in syntax? Or is let always like var in Javascript? If the latter, then there is no confusion between variable binding and function definition like in haskell.\nAlthough I like much of the haskellish style of roy, I think that roy should be allowed to be different, for the sake of simplicity and adoptability by JS- and other PL users.\n. I had this error too ,but finally managed somehow to install roy on win7 as well as on win xp.\nIt seems to have nothing to do with roy, but with npm resp. Node installation.\nI installed it, standing in the node installation folder, manually with\n\nnpm install roy\n\nHTH\nDet\n. ",
    "noprompt": "Funny, I tried converting the same example @TheDet is referring to and encountered the same result - which led me here.\nTo get the example to work you'll need to patch grammar.js:\njs\n\"keyPairs\": [\n    [\"keywordOrIdentifier : expression\", \"$$ = {}; $$[$1] = $3;\"],\n    [\"keyPairs , keywordOrIdentifier : expression\", \"$$ = $1; $1[$3] = $5;\"],\n    [\"keyPairs TERMINATOR optTerm keywordOrIdentifier : expression\", \"$$ = $1; $1[$4] = $6;\"],\n    [\"STRING : expression\", \"$$ = {}; $$[$1] = $3;\"],\n    [\"keyPairs , STRING : expression\", \"$$ = $1; $1[$3] = $5;\"],\n    [\"keyPairs TERMINATOR optTerm STRING : expression\", \"$$ = $1; $1[$4] = $6;\"]\n],\nAnd comple.js:\njs\nvisitObject: function() {\n    var key;\n    var pairs = [];\n    pushIndent();\n    for(key in n.values) {\n        if (/^(?:\".*?\")|^(?:'.*?')/.test(key)) {\n            pairs.push(key + \": \" + compileNode(n.values[key]));\n        } else {\n            pairs.push(\"\\\"\" + key + \"\\\": \" + compileNode(n.values[key]));\n        }\n    }\n    return \"{\\n\" + getIndent() + pairs.join(\",\\n\" + getIndent()) + \"\\n\" + popIndent() + \"}\";\n}\nThen the following example should compile properly.\n``` hs\nlet http = require 'http'\nlet server = http.createServer (\\request response ->\n  response.writeHead 200 (Object {\"Content-Type\": \"text/plain\"})\n  response.end 'Hello World\\n'\n)\nserver.listen 8124\nconsole.log 'Server running http://127.0.0.1:8124'\n```\nThis is just a quick hack to get over the hurdle - it's by no means meant to be an elegant solution to the problem.\nP.S. Sorry for all the edits!\n. ",
    "michaelficarra": "related coffeescript discussion: jashkenas/coffee-script#1679\n. @alsonkemp: In vim, \u2192 (U+2192) is Ctrl-k followed by ->, so a natural choice for at least that reason. Unfortunately, the function composition operator being proposed (\u2218, U+2218) is Ctrl-k followed by Ob, not a very obvious sequence to me. It's better than not having a digraph defined, though.\n. You should be able to provide default implementations as well:\nroy\ntypeclass Eq #a {\n  eq, neq : Function(#a, #a, Boolean)\n  eq = not \u25cb neq\n  neq = not \u25cb eq\n}\n. Yes, Option 1 is very acceptable to me. My preferred compilation:\njs\nvar x = 1;\nvar f = function() {\n    console.log(x);\n    return function(x) {\n      return x;\n    }(true);\n};\nconsole.log(f());\nFor expressions without side effects (or if the new var is referenced at most once), the instances in the continuation can be rewritten to the assigned value:\nroy\nlet x = 1\nlet f = \\() ->\n  console.log(x)\n  true\nconsole.log(f())\njs\nvar x = 1;\nvar f = function() {\n    console.log(x);\n    return true;\n};\nconsole.log(f());\n... which is the \"ideal\" solution, though unfortunately not possible in all cases. IIFEs would be needed for things like this:\nroy\nlet x = 1\nlet f = \\() ->\n  console.log(x)\n  let x = g()\n  console.log(x)\n  x\nconsole.log(f())\njs\nvar x = 1;\nvar f = function() {\n    var __temp;\n    console.log(x);\n    return function(x){\n      console.log(x);\n      return x;\n    }(g());\n};\nconsole.log(f());\n. +1e6! Also, free source maps.\n. I'd be happy to help out with this. Should be really easy. Just point it at the module's entry point.\n. I believe @puffnfresh sees PureScript as a spiritual successor.. ",
    "darkf": "+1\n. a2 or a_ is ugly, and a' comes from some mathematics. I don't see any reason to leave this out, it's just a small change to the lexer.\n. ",
    "alsonkemp": "[Hope you don't mind a newbie commenting...]\nI added a missing value (10) to the Cons code and the Cons code is 92% slower:\nhttp://jsperf.com/linked-list-vs-array-roy/3\nI boosted to 20 items and the Cons code is 96% slower.\nhttp://jsperf.com/linked-list-vs-array-roy/2\nAs to what-to-do, I think Haskell provides good examples both of what-to-do and of what-not-to-do since it has both Data.List and Data.Array.\nUpshot: I agree with Brian and am a fan of CoffeeScript's principle of staying true to Javascript:\n- Roy runs on the JS VM.\n- The JS VM has a native Array type.\n- Roy should harmonize its Array type with JS's Array type (harmonize = be as compatible as is reasonable).\n- The JS VM has no List type, so Roy should provide a List type.\n- If beneficial, Roy could provide a GeneralizedArray which allowed for an index type.\nThis creates the problem of requiring JavaScript definitions of \n  core functions (head, tail, map, etc) to be written for arrays.\n  Still not sure how we should do that.\nIf there's a notation for emitting bare JS in Roy, then it'd be simple.  Assuming that a clearly-unsafe function is used [as in Haskell's unsafePerformIO]:\n```\nunsafeJS:: String -> a\nhead a = unsafeJS 'a[0]'\ntail a = unsafeJS 'a.slice(1,a.length)'\nmap f a = unsafeJS 'r = []; for (e in a){r.push(f(e))}; return r;'\n```\nVerifying type safety on this would be nearly impossible, but, as with Haskell, the issue would probably be small if the JS notation were used very sparingly.\n. > I actually still think Roy should work with lists.\nOops.  I see that I was unclear.  I agree, I didn't address a List type and that suggested that I was opposed to it.  I was suggesting that, similarly to Haskell, Roy have both: \n- an Array type which was aligned with and aware of the native JS Array; \n- a List type.\nUnlike Haskell, I'd prefer that the interfaces to the two datatypes be very similar.\n. I like Paul's suggestion even if I would have to type Ctrl-Shift-2218 for \u2218.\nOne tricky thing is that there are lots of very similar Unicode characters and it's difficult to tell which to use.  For example, the arrow in src/lexer.js @ 254:11 is U+2192 (\u2192), but I don't see that in http://en.wikipedia.org/wiki/List_of_Unicode_characters.  Doesn't mean that Wikipedia is right and Roy is wrong, but it does make it difficult to figure out which Unicode character to use.  U+2192 (\u2192), U+27F6 (\u27f6), U+U+2794 (\u2794), U+2799 (\u2799) and U+279D (\u279d) all seem reasonable to use...\n. +1\nAlso, typeclasses mean that you can pull over a fair number of Haskell libraries straight away.\n. The off-by-one error seems to be in lexer.js (I fixed it by setting lineno=0):\nexports.tokenise = function(source) {\n    indent = 0;\n    indents = [];\n    tokens = [];\n    lineno = 0;  // Was 1\n. ... so ...\nI'm merging the two over in my fork.  Assuming that it doesn't go pear-shaped, I'll let you know when something interesting happens.\nI'm also significantly restructuring grammar.js so that it's easier to understand.\n. Smashing.  I'll try to get my updated lexer/grammar working in the next few days and will commit it for your review.\nNote: I'm re-structuring/rearranging both.  In particular, I'm going to move lexing towards being grammar unaware since the lexer is fairly tightly coupled (e.g. identifierToken).  I like Haskell's definitions for both lexing and for grammar (http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2), so am pushing in that direction.\n. ",
    "kasperlanger": "Although the example above works I'm afraid the bind function is broken.\nThe problem is that the result of the function f which is passed to done is simply evaluated for side effects and the return value is discarded.\nConsider the following example\nlet v = (do deferred\n  value <- $.ajax {url: '/examples/helloworld.roy', payload: 'stuff'}\n  console.log value\n  return \"Hay World\"\n)\nHere v should be a deferred object wrapping \"Hay World\" but is instead the result of the $.ajax call.\nI think the bind should be something along the following coffeescript (sorry I hit the limit of my roy skills).\ncoffeescript\ndef_return = x -> $.when(x)\ndef_bind = (f,x) ->\n    dfd = $.Deferred()\n    x.done (val) ->\n        f(val).done (val2) ->\n            dfd.resolve val2\n    dfd\nHere a new deferred object is returned immediately and then when x is later resolved it's passed to f which again returns a deferred object which is passed a function that finally resolves the deferred object we created in the first place.\nThe example above should then compile to something like this:\ncoffeescript\nv = do ->\n    dfd = $.Deferred()\n    x = $.ajax {url: '/examples/helloworld.roy', payload: 'stuff'}  \n    x.done (val) ->\n        console.log val\n        $.when(\"Hay World\").done (val2) ->\n            dfd.resolve val2\n    dfd\n. Yay I got it working in roy:\n```\nlet deferred = {\n  return: \\x -> $.when(x)\n  bind: \\x f ->\n    let dfd = $.Deferred()\n    x.done(\\val -> \n        (f val).done(\\val2 -> dfd.resolve val2)\n    )\n    dfd\n}\nlet v = (do deferred\n  val <- $.ajax '/examples/helloworld.roy'\n  val2 <- $.ajax '/examples/alias.roy'\n  return val ++ val2\n)\n(do deferred\n  text <- v\n  console.log text\n)\n```\n. Thank you! Great project\n. Awesome thanks!\n. ",
    "lexden": "Having checked out RequireJS again, I'm not sure. :)  How would you currently implement it?\n. I suppose the following would be a current implementation:\n```\nlet module dep1 dep2 =\n  {export1: something, export2: somethingelse}\ndefine [\"dep1\", \"dep2\"] module\n```\nWould the following work as a require.js module?:\n```\nlet module dep1 dep2 =\n  {export1: something, export2: somethingelse}\nlet main =\n  define [\"dep1\", \"dep2\"] module\n```\nWhich would (in my proposal) compile to the JS:\njavascript\nvar module = function(dep1, dep2) {\n    return {\n        \"export1\": something,\n        \"export2\": somethingelse\n    };\n}\ndefine([\"dep1\", \"dep2\"], module);\n. ",
    "folone": "Thanks for help, this ticket is not needed, sorry for the noise.\n. ",
    "tokland": "+1. IMO, given the way Roy uses let function/binding, we could just remove it altogether. Every other statement has its keyword (data, type, ...), so it makes sense to make things easy for the most used statement, binding. \nI tried to remove those lets in the grammar and I got some conflicts on the accessor -> IDENTIFIER reduction, but in any case it'd easy to add those LETs in the lexer and keep the grammar unchanged if it's really hard to remove it there.\nPersonally I find the lets quite distracting.\n. > I don't think it's wise to encode properties like length in the type-system for the String and Array types.\nI agree, it'd be better to have some interface layer in between. \nI just skimmed through the examples of Roy, so I am not sure what the language can or can't do (or is planned to do). Some thoughts about this (I hope not too misleading):\nhttps://gist.github.com/1641425\nIt would be great to have some batteries include in the form of modules (String, List, Array) with the usual suspects for FP (List.map, List.filter, etc), but I guess that's another subject.\n. thanks!\n. That was fast, thanks! Now the code is working, but I still have a problem with tuples (maybe it's not related and I should open a new issue?):\n```\nlet triplicate_tuple (x:Number) : (Number, Number) = (x, x, x)\nconsole.log (triplicate_tuple 5)\n=> [ 5, 5, 5 ]\n```\nI guess the type-system should not allow that...\n. swell, thanks.\n. I added another commit to support one-liner conditionals. Check the operator precedence, it's my understanding that the ternary conditional has right associativity and low precedence: http://en.cppreference.com/w/cpp/language/operator_precedence.\nIf you'd prefer not to add more features at this moment just say the word.\n. ",
    "kmarekspartz": "There are some comments on syntax in https://github.com/pufuwozu/roy/issues/171\n. Regarding 5 and 6, it seems to me this is a result of compiling what we see as a curried function to a non-curried function. \nlet f a b = a + b\nshould compile to:\nvar f = function (a) { function (b) { return a + b; }};\nand \nlet f (a, b) = a + b\nshould compile to:\nvar f = function (a, b) { return a + b; }\nCurrently the first example compiles to the last. Is there rationale for not changing this?\n. Regarding 10, maybe := should be used for impure assignments?\n. The parens are internally consistent, but I would prefer consistency with ML and Haskell. I believe it can still be consistent with js if the tuple notation is used. Another option would be to define a curry function which can wrap around a js function.\nAlso, maybe all external js calls should be within a monad? The above change would make that a reasonable change.\n. I would expect the following:\nHaskell\nf (a, b) = a + b\ng a b = a + b\nto become:\n``` JavaScript\nvar f = function(a, b) {\n    return a + b;\n};\nvar g = function(a) {\n    return function (b) {\n         return a + b;\n    };\n};\n```\nThis would allow you to still use the tupled functions when you need to for compatibility. We can then have a functions to convert between curryable and tupled functions:\n``` Haskell\ncurry2 f a b = f (a, b)\ncurry3 f a b c = f (a, b, c)\netc.\nuncurry2 f (a, b) = f a b\netc.\n```\n---->\n``` JavaScript\nvar curry2 = function (f) {\n    return function (a) {\n        return function (b) {\n              return f(a,b);\n        };\n    };\n};\netc.\nvar uncurry2 = function (f) {\n    return function (a, b) {\n         return f(a)(b);\n    };\n};\netc.\n```\n. By this logic, lambdas could be lifted, too.\n``` haskell\nf a b = \\x -> a + x\ng b = f 12 b 12\n```\n--->\n``` JavaScript\nfunction f (a, b, x) {\n    return a + x;\n};\nfunction g (b) {\n    return f(12, b, 12);\n};\n```\nBut I'm not sure that is a good idea.\n. Perhaps a better name for this function would be partial since it isn't currying or uncurrying, but rather using partial  application and returning a closure for the remaining arguments.\n. I'm not really one, so I'm not sure exactly, but I don't think they would do it! The only use cases I can think of for partial application use an object passed in instead, e.g. in Underscore, the where method on collections.\n. Can't compatibility be managed using tupled arguments?\nf (a, b) = a + b\ng b = f (42, b)\n. I like the ability to have both tupled and curried functions in ML and Haskell. I found the curried notation and tupled semantics confusing coming to Roy.\n. I think https://github.com/purescript/purescript is the spiritual successor, but @puffnfresh might still have plans for roy.\n. ",
    "espringe": "+1 I think the current naming is taken from Scala, but Roy's 'Option' is far closer to Haskell's Maybe or C++'s Optional, than it is to Scala's Option. (Scala's Option[T] is a 4-state beast (not 2 like haskell), that is only really useful when T is or can be a primitive\n. Yes it does, it's just more subtle about it.  Also, you're forgetting about the Null/Nothing subclass.  If T is a reference type, for instance imagine a function that accepts an Option[String], there are four distinct states the type system will allow it be given: null, None, Some(null), Some(String).\nHence why I've found that Option[T] is only really useful and performant if T is or could be a primitive (e.g. Option[Int] ).\nBut if you ever did something like this in Scala: case class LinkedList[T](payload: T, rest: Option[LinkedList[T]])) you would be misusing Option. (As you can simply leave it out, to get a faster, more predictable and has-less-stupid-state version. On the other hand, this is the exact sort of definition you'd want in Roy/Haskell\n. ",
    "kputnam": "@espringe I don't think that's accurate. Scala's Option type has only two constructors: Some and None. Perhaps you're thinking of Lift's \"Box\", which has three constructors? Secondly, Scala doesn't distinguish primitive types from reference types like Java does (http://www.scala-lang.org/node/128).\n. I understand your point, but it seems analogous to saying Maybe has four states because Haskell's type system allows undefined and Just undefined as values of Maybe Int. It's not apples-to-apples, but I think the differences are attributable to language semantics rather than Option vs Maybe.\nAnyway I don't have a horse in this race; either name would be fine with me. Just wanted to clarify what you meant by Option having four states. Sorry about the digression!\n. ",
    "taku0": "The subtyping of objects seems very restricted.\nThe following code is typed:\n```\nlet f x = x.y.z\nf {x: 1, y: {z:1, zz: 2}}\n```\nwhile the following is not:\n```\nlet f x = x.y.z\nlet g h = h {x: 1, y: {z:1, zz: 2}}\ng f\n```\nThe following is also typed.\n```\nlet f x = x.y.z\nlet g h = h {y: {z:1}}\ng f\n```\n. Typed X(.\n```\nlet f x = x.y.z\nlet g h = h {}\ng f\n``\n. ECMAScript has two right shift operators: the signed right shift operator (>>) and the unsigned right shift operator (>>>). I worry that using>>as a function composition,>>>as a signed right shift operator, and>>>>` as unsigned right shift operator might confuse JavaScript programmers.\nHow about <. and .> for function composition?\nAlternatively, -<- and ->- for composition and -< and >- for pipe?\n. I noticed that foo>-bar is ambiguous, i.e. foo > (-bar). I withdraw -< and >-.\nIndeed shift operators are rarely used in JS, many programmers know shift operators. Therefore, if JavaScript programmer sees a Roy code, he/she would think the code is full of shift operators for some reason.\nFor example, reading readLine >> split ',', he/she thinks like that \u201cIt reads a line and... shifts it bitwise? Shifting a string? Does split ',' returns a number???\u201d.  On the other hand, if he/she reads readLine .> split ',', he/she would think \u201cOK, there is an unknown operator. I should refer to the document.\u201d\n. @puffnfresh \nThey say \u201cHowever, the problem with global uniqueness of instances is that they are inherently nonmodular\u2033.\n. @puffnfresh \nThey seem say if we allow local instance definition, implementation details of the components does not conflict and we can combine modules. Global uniqueness has pros and cons. Without (strict) global uniqueness, some data structure like Set does not work. With global uniqueness, implementation details leak out of modules, or we cannot define block local equality, ordering, monoid product, or traversal strategy.\n. Match expression has same problem.\nThe code below outputs undefined.\n```\ndata Option a =\n  Some a | None\nlet x = 2\nmatch (None ())\n  case None = console.log x\n  case (Some x) = console.log x\n```\nCompiled code:\n```\n...\nvar x = 2;\n(function() {\n    if(None() instanceof None) {\n        return console.log(x);\n    } else if(None() instanceof Some) {\n        var x = None()._0;\n        return console.log(x);\n    }\n})();\n```\nwhich is equivalent to\n```\n...\nvar x = 2;\n(function() {\n    var x;\n    if(None() instanceof None) {\n        return console.log(x);\n    } else if(None() instanceof Some) {\n        x = None()._0;\n        return console.log(x);\n    }\n})();\n```\n. I think it is acceptable. There seems to be no ideal solutions.\n. BTW, we need a testing script which ensures failures of inferences for non type-safe code.\n. The generalized type inferer would be a good foundation for the new type system, no matter which type system you choose or create new one.\nI will look the branch.\n\nI know you tweeted that a polymorphic record calculus could make sense for Roy. Do you still think this is the case?\n\nSince the main advantage of the polymorphic record calculus\u2014that is, objects compiled into arrays\u2014is irrelevant to Roy, the type systems with row variables (the system \u03a0* or the system \u03a0) are attractive since they can extend objects (that means we can represent mixins!).\nHowever, the syntax of the system \u03a0* is complicated a bit. We need to improve the syntax. For example, writing num? instead of 'u.num, num instead of pre.num, and !num instead of abs.num whenever possible.\nAnother option is the system \u03a0, not as powerful as the system \u03a0* but more powerful than the polymorphic record calculus. It is sufficient to represent object extensions without complicating the syntax.\nP.S. Here is a list of touchstone expressions. Some type systems can type them, others not.\nsimple object literal:\n{a: 1, b: 1}\nobject literal with generic function:\n{a: \u03bbx. x, b: \u03bbx. x}\nsimple function taking object:\n\u03bbx. x.a + 1\nfunction taking a function taking object:\n\u03bbf. f({a: 1, b: 1})\nfunction taking a function taking objects with different labels:\n\u03bbf. f({a: 1, b: 1}) + f({a: 1, c: 1})\n(not typed with the system \u03a0 or the polymorphic record calculus)\nfunction taking a function taking objects with same labels but different types:\n\u03bbf. f({a: 1, b: 1}) + f({a: 1, b: \"a\"})\n(not typed with the system \u03a0 or the polymorphic record calculus, the system \u03a0* requires explicit forget operator)\nlist of objects with different labels:\n[{a: 1, b: 1}, {a: 1, c: 1}]\n(not typed with the system \u03a0 or the polymorphic record calculus)\nlist of objects with same labels but different types:\n[{a: 1, b: 1}, {a: 1, b: \"a\"}]\n(not typed with the system \u03a0 or the polymorphic record calculus, the system \u03a0* requires explicit forget operator)\nobject extension (a fresh copy of x with a new field f):\n\u03bbx. {x with f = 1}\n(not representable in the polymorphic record calculus)\nobject merging (a fresh copy of x with all fields from y):\n\u03bbx y. {x with y}\n(not representable in the any type systems mentioned above)\nfield forgetting (a fresh copy of x without field f):\n\u03bbx. {x without f}\n(not representable in the polymorphic record calculus)\n. More complex examples:\n{a: bool, ...} \u2192 {a: bool}, {a: bool} \u2192 {a: bool}, or type error?\n\u03bbx. if x.a then x else {a: false}\n{a: bool, b: bool, ...} \u2192 {b: bool}, {a: bool, ...} \u2192 {}, or type error?\n\u03bbx. if x.a then x else {b: false}\n{a: bool, ...} \u2192 {} or type error?\n\u03bbx. if x.a then x else {a: 1}\n({a: num} \u2192 num) \u2192 {a: num, ...} \u2192 num?\n\u03bbf x. f x + f({a: 1})\n({a: bool, b: num} \u2192 bool) \u2192 ({a: bool, b: num} \u2192 bool) or ({a: bool, b: num} \u2192 bool) \u2192 ({a: bool, b: num, ...} \u2192 bool)?\n\u03bbf. if f({a: true, b: 1}) then f else \u03bbx. x.a\n({a: num, b: num} \u2192 bool) \u2192 ({a: bool, b: num, c: bool} \u2192 bool), ({a: num, b: num, c: bool} \u2192 bool) \u2192 ({a: bool, b: num, c: bool} \u2192 bool), ({a: num, b: num} \u2192 bool) \u2192 ({a: num, b: num, c: bool, ...} \u2192 bool), or type error?\n\u03bbf. if f({a: 1, b: 1}) then f else \u03bbx. x.c\n. I have read the new type checker. It is a nice functional code :), much readable than current code.\nCurrently, the typing rules for objects are like this:\n```\n          A_1, C_1 \u22a2 e_1: t_1 ... A_n, C_n \u22a2 e_n: t_n\n\n\u222aA_i, \u222aC_i \u22a2 {l_1: e_1, ..., l_n: e_n}: {l_1: t_1, ..., l_n: t_n} \n```\n```\n         A, C \u22a2 x: \u03c4\n\nA, C \u222a {\u03c4 \u2261 {l: \u03b2}} \u22a2 x.l: \u03b2\n```\nBoth rule use equality constraints and monomorphic object types that have only known fields but not unknown fields.\nThis is, as you know, inappropriate. Even {x: 1, y: 1}.x is not typeable.\nWe must adopt either subtyping constraints or polymorphic types that represent some known fields and other unknown fields.\nWe need to clarify the requirements for objects. How will objects be used in Roy?\nIf we need full featured object library like Scala, we might need rc-types. If objects are supplemental like OCaml, we should keep the type system simple.\n. Can we infer types of mutually recursive (possibly polymorphic) functions without where?\nFor example, is_even and is_odd below are mutually recursive functions having a type Number \u2192 Number while id is a polymorphic function having a type #a \u2192 #a.\nlet f x =\n  is_even x\nwhere\n  is_even x = if id (x == 0) then true else is_odd (id (x - 1))\n  is_odd x = if id (x == 0) then false else is_even (id (x - 1))\n  id x = x\nIf we can, I don't oppose dropping where.\n. ```\n// This shows the help for metacommands. Replacing /:/ with /^:/ will fix it. \n\":\"\n// Regarded as a start of a block.\n// Replacing \\b(do|match).+? to \\b(do|match)\\b.+? will fix it.\nlet maching = 1\nlet doc = 1\n// Regarded as a start of a block.\n// No simple fix.\n\"do\"\n\"match\"\n```\n. It seems fine to me.\n. ",
    "natecain": "+1\n. ",
    "LeifW": "CoffeeScript syntax lacks support for do-notation I believe, but there's that \"mofor\" branch someone submitted.\n. ",
    "andreypopp": "@paulmillr it's a straight road down to APL :-)\n. @paulmillr no, just take a look at your keyboard\n. ",
    "jb55": "For vim I use these bindings https://gist.github.com/2253102\nWhen in insert mode...\n  C-j  is  lambda\n  C-l  is  right arrow\n  C-h is  left arrow\n  C-o is  compose\nAlthough I don't think we should rely on people having their editors set up to support this. \nI like << since it kind of puts an image in your head of the flow from input to output.\n. You're seem to be correct :)\n. ",
    "nickmeharry": "+1 on << and >>. While I would rather have \u2218, the double angle brackets have the benefits of allowing backward function composition ((f << g) x = f (g x) and (f >> g) x = g (f x)).\nThere's a couple options for Unicode equivalents:\n-  \u300a (300a) and \u300b (300b) These seem to be double width\n- \u27ea (27ea) and \u27eb (27eb) Doesn't render for me, Firefox OS X\n- \u00ab (00ab) and \u00bb (00bb) Quote marks in some languages\n- \u226a (226a) and \u226b (226b) +1\nSimilarly, would it make sense to have a pipe operator? It's similar to function composition except that instead of adding one more argument at the end of the arguments list, it would put the result as the first argument.\n```\nlet f x y = x - y\nlet g z = z * z\ng 4 |> f 5 = f (g 4) 5 = 9\n```\nI'm not sure how this would work in the type system, but it would be useful for functions that pass the subject in the first argument and, for example, options in the second. Not sure about Unicode equivalents for this one, though.\n. I just landed a branch that implements this. Free sourcemaps aren't included yet, but should be in soon.\n. Fixed by #179 \n. This happened because some nodes have no output in the Javascript, like type definitions. We now delay those comments to the next outputting node and lift them up to the statement level afterwards.\n. > Undecided, but I do like:\n\nlet x = if 2 > 0 then\n  \"ok\"\nelse\n  let x = \"fail\"\n  x\nBecoming:\nvar x = 2 > 0 ? 'ok' : function() {\n        var x = 'fail';\n        return x;\n    }();\n\nI've implemented this in 01cd6b3.\n. The problem here is that this tosses away the trailing comments entirely. The point of having comments in the grammar at all is so that we can capture them and put them back in the Javascript output.\n. ",
    "NickHeiner": ":+1: The |> operator is one of my favorite features from F# that I constantly miss in js.\n. :+1: \n. ",
    "DanBurton": "```\ninstance stringMonoid = Monoid String {\n  append: \\x y -> x ++ y\n  empty: \"\"\n}\nconsole.log (append \"Hello!\" empty)\n```\nHow will the final line know to use the stringMonoid instance? I am actually working on enhancing generics in Racket; once I've solidified the technique, perhaps the same technique will be usable here.\n. ",
    "rightfold": "It would be useful if instances are first-class values that can be passed around like in Scala. This makes it possible to have multiple instances of Monoid Number, namely (0, +) and (1, *). This can be useful for Ord as well, as you can have sort but don\u2019t need sortBy.\nHaving a default instance would still be possible, but not required.\nThe syntax could look something like this:\n```\n// This is the default instance\ninstance Ord Number {\n  compare: \\x y -> x - y\n}\n// This is an alternative instance\nlet reverseOrdNumber = instance Ord Number {\n    compare: \\x y -> y - x\n}\nlet smallerThan x y = compare x y < 0\nconsole.log (smallerThan 1 2).toString () // uses default instance\nconsole.log (smallerThan{reverseOrdNumber} 1 2).toString () // uses alternative instance\n```\n. ",
    "cognominal": "Indeed the parser should accept comments in \"natural\" places.\nThis is a major annoyance because one cannot just comment out code that does not work.\nOne must move it in a safe place first.\n. This should fix https://github.com/puffnfresh/roy/issues/127\n. Currently I use this for learning the language. In my code I comment out stuff that does not work yet.\nAs I said in the commit, this patch is a useful start. Also I think that lines of comments within an statement\nor an expression are still problematic.\n. Nice. That means I can close my PR as duplicating part of yours\n. ",
    "dominictarr": "awesome\n. ",
    "alsuren": "I think that this is related: Some of the example code itself is broken:\n```\ndata Either a b =\n  Left a | Right b\nlet printString (s: String) =\n  console.log s\nlet printResult e = match e\n  case (Left x) = console.log x\n  case (Right x) = printString x\nprintResult (Left 10)\nprintResult (Right \"Error\")\n// Won't compile:\nprintResult (Right 10)\n```\nactually compiles fine.\nDo we need some kind of test runner that goes through the examples and uncomments each \"// Won't compile\" block in turn and makes sure it doesn't compile?\n. To clarify: found this code in the \"tagged union\" section of http://roy.brianmckenna.org/, and uncommented the last line.\nI just pasted this into repl.it and it broke as expected.\nI'm new to this language, so I don't really know what's broken here/which versions are broken.\n. ",
    "sophiebits": "Seconding this. This in conjunction with #17 would make JS globals much nicer.\n. ",
    "dckc": "My interest in this issue is overtaken by the emergence of purescript.\n. ",
    "pedrodelgallego": "Ditto, \n./roy -r examples/helloworld.roy\n/Users/pdelgallego/code/practice/live/roy/src/typeparser.js:146\n        if (actiontypeof  === \"undefined\" || action.length! || action[0]!) {\n                                                          ^\nmodule.js:434\n  var compiledWrapper = runInThisContext(wrapper, filename, true);\n                        ^\nSyntaxError: Unexpected token !\n    at Module._compile (module.js:434:25)\n    at Object..js (module.js:464:10)\n    at Module.load (module.js:353:31)\n    at Function._load (module.js:311:12)\n    at Module.require (module.js:359:17)\n    at require (module.js:375:17)\n    at Object. (/Users/pedrodelgallegovida/code/practice/live/roy/src/modules.js:2:18)\n    at Module._compile (module.js:446:26)\n    at Object..js (module.js:464:10)\n    at Module.load (module.js:353:31)\n. It works fro me as well. Thx\n. ",
    "Saulzar": "Same here. node.js 0.6.18\noliver:roy oliver$ ./roy\n/Users/oliver/Downloads/roy/src/typeparser.js:146\n        if (actiontypeof  === \"undefined\" || action.length! || action[0]!) {\n                                                          ^\nmodule.js:434\n  var compiledWrapper = runInThisContext(wrapper, filename, true);\nSyntaxError: Unexpected token !\n    at Module._compile (module.js:434:25)\n    at Object..js (module.js:464:10)\n    at Module.load (module.js:353:31)\n    at Function._load (module.js:311:12)\n    at Module.require (module.js:359:17)\n    at require (module.js:375:17)\n    at Object. (/Users/oliver/Downloads/roy/src/modules.js:2:18)\n    at Module._compile (module.js:446:26)\n    at Object..js (module.js:464:10)\n    at Module.load (module.js:353:31)\n. ",
    "bergmark": "It works! Thank you for your help!\n. ",
    "adrianheine": "FYI, this is caused by https://github.com/zaach/reflect.js/commit/df5420535d229dbbb3d43d65c9db0410cd3c82aa#L3L212.\n. ",
    "non": "Yeah I can confirm that the fix works. Thanks!\n. (Disclaimer: please feel free to ignore me on this)\nGiven that you have your own parser/compiler, I wonder if changing inner names to avoid collisions isn't something you want to be able to support? And if it is, then I could imagine wanting to avoid allocating closures, in which case Richard's first suggestion seems a bit nicer. For instance:\nlet x = if 2 > 0 then\n  let x = \"ok\"\n  x\nelse\n  let x = \"fail\"\n  x\njust becomes:\njavascript\nvar x;\nif (2 > 0) {\n  var x_ = \"ok\"\n  x = x_\n} else {\n  var x_ = \"fail\"\n  x = x_\n}\nOf course you can substitute whatever name-mangling scheme you want... adding trailing underscores just seemed easy. To me it seems like this code will hew closer to what a casual user might expect. The x = x_ line looks a bit weird, but then again so does the let in the earlier example.\n. ",
    "disolovyov": "I see you have a separate repo for Vim-Roy, and you fixed it there. Shouldn't it be linked to misc here?\n. ",
    "Constellation": "Wow! If you have question about impl & API of escodegen, feel free to ask us :-)\n. ",
    "dbousamra": "I also have this issue.\n. Ah cheers. \n. ",
    "ericbmerritt": "+1\n. ",
    "X1011": "@joneshf, I'm assuming by \"plain JS developer\" you mean a developer who writes plain JS in a functional style.\nramda.js, @DrBoolean's libraries, and prelude.ls all take your approach and make the functions they export partially applicable, and they all call it currying. DrBoolean's implementation comes straight from wu.js, and prelude.ls takes advantage of LiveScript's built-in implementation.\nI've not seen any functional JS libraries that do honest-to-goodness, one-function-per-argument currying by default.\n. ",
    "LarryBattle": "Thanks for your hard work. It works now. :+1: \n. ",
    "jedws": "indent 2 surely? :-)\ncheers,\njed.\nOn 30/07/2013, at 8:53 AM, Brian McKenna notifications@github.com wrote:\n\nJust looking at the JSHint options. Chuck the following under grunt.initConfig:\njshint: {\n    options: {\n        //onevar: true,\n        es3: true,\n        indent: 4,\n        noarg: true,\n        node: true,\n        trailing: true,\n        undef: true,\n        unused: true\n    }\n}\nAt the moment, looks like there's a few potential global leakages. We definitely don't want that.\nI'm also proposing we use onevar soon. Just to enforce a style.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "kennknowles": "I'd be perfectly happy with alternate suggestions of a different way to express the same idea. It must have decent Javascript interop.\n. Commas do not repair the situation. The problem appears to be the newline/indent: Unexpected 'INDENT'. The grammar does seem to include them for data but not really for type. No?\nAs for unsoundness, I'm porting a Javascript library, so I'll take what I can get :-)\n. This code does not work yet. I naively mimicked the object literal parsing, but there appears to be a fundamental error in how I am using Jison as now only empty object types can be parsed. Or maybe late last night I just made mistakes...\nI've viewed the automata and it seems to be constructed as intended, but when I hack the generated parsed to give more details, it says that expected contains } TERMINATOR typePair which makes me wonder if this is a Jison idiosyncrasy or it if thinks typePair is a terminal for some reason.\nFor context, I have extensive experience with bison, ply, happy, ocamlparse, etc, and have taught the class on how to build them. I'm very comfortable reading grammars and automata but do not know how to get diagnostic info from Jison about the state in which the parse failed, or how to start a parse from a different symbol in order to write more narrowly targeted tests.\nAny tips?\n. I just gave it a shot, but got the same errors. (But no others, so you certainly might as well upgrade jison.)\n. ",
    "schas002": ":+1:. @puffnfresh so basically, project abandoned? If so, I'd be kinda willing to maintain. :). ",
    "benjaminapetersen": "Still down.  Assuming it is the best place for a tutorial, tho not sure if 2 months down means the project is suspended?. ",
    "vendethiel": "The last commit on this repo was in 2013. I think the project has been suspended for some time.. Is there a reason why you don't use PureScript?. ",
    "devkat": "Exacly, this was changed in the meantime:\nhttps://github.com/jashkenas/underscore/commit/348c93515cf56263828c683ebab055e6c800b63b\n. "
}