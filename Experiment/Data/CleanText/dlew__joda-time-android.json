{
    "dlew": "Was added in 4d5aa308f31be6d62e4f95ea51419eedd5ef45e0\n. I've been thinking a lot about this one recently. Not sure if this is worth it, for a few reasons:\n- It's already easy to serialize/deserialize Joda-Time objects already, using toString() and parse().\n- It adds a lot of custom code to Joda-Time, making it harder to merge in changes whenever Joda-Time updates.\nI'm going to leave this open; if someone wants me to work on it let me know. But otherwise I'm not going to jump on it.\n. That's fair.  I'll work on this at some point.\n. Added in 7448f0be28be9072fefa6b6b853b57c78318c145\n. Added in c53b768d0d06f4b3cc426f1ddad0557daba5b54c.\n. Are you using Eclipse or Gradle?  I wonder where this manifests.\nThe core problem is that org.joda.convert (which is a pre-compiled dependency) uses java.xml.bind.  When I looked into the source it wasn't a problem because joda-time doesn't use the method that requires it, but I had to include a lint.xml that got rid of the error.  However, it looks like that same error shows up when anyone depending on the library uses it...  \nThree options spring to the top of my head:\n1. Use proguard to remove the offending method/class during AAR compilation.  (Not sure if this will work for Eclipse builds, though.)\n2. Figure out some way to include my lint.xml in future builds.  (Again, not sure if Eclipse will support.)\n3. Include joda-time-convert and remove the offending classes.\n. I should take care of it in at least the AAR as well.  It doesn't make sense to keep around classes that aren't used and cause lint errors.  :P\n. This is proving a lot trickier than I thought.  I can't just proguard the offending class out because it's being used elsewhere (just not the one method that would cause Android to blow up).  And I can't pass lint rules downstream for just this library, either.\nI'm asking to see if I can get a version of joda-convert which doesn't use javax.xml.bind.  Alternatively I guess I could import all of joda-convert and remove the offending class...\n. That's what I decided to do.  If joda-convert stops using javax.xml.bind then I'll switch back to using it as a dependency.  a5871b04c2865a9d3b7323cf6498790a1583d5fc\n. Added.\n. This ticket is not very high priority.  If you actually care leave a message; otherwise this may not end up ever happening.\n. I think I officially don't care anymore.  :P  14+ is the new game anyways.\n. Added in 45b35f3037f47ce79c0b46946449a9096d9f3a19\n. Hmm, interesting. I'll have to think on this for a bit. Does the receiver registration die when the application is cleared from memory?\n. Alright, I like it. A few small fixes before I merge:\n- Update README.md to inform people to use JodaTimeAndroid for init.\n- Update CHANGELOG.md so it has this change listed (underneath the \"changelog\" header; it gets versioned on new release).\n- Make it so that if you call ResourceZoneInfoProvider.init() directly (instead of via JodaTimeAndroid) it spits out a warning into logcat that that initializer is deprecated, then runs JodaTimeAndroid.init().  Maybe post that warning only on debug builds.\n. IMO, I'd make some sort of method in JodaTimeAndroid that indicates that it was run and just check that. You'd probably want it anyways so you don't double-init.\nStack trace is a bit too wonky.\n. Thanks for the work! When I'm a bit less busy maybe I'll push out 2.3.4.\n. Just an FYI, I accidentally merged this into master instead of dev, which caused #11. As a result I've rewound that commit and pushed out a new dev branch (which will get merged into master upon release).\n. v2.3.4 has just been pushed to maven central and should show up in a few hours; it'll have this change. Thanks again for your contribution!\n. Whoops! I accidentally pulled in dev code into master. It's now in the dev branch and master's docs are current again.\nIn the next version we'll want you to use that, but currently it's ResourceZoneInfoProvider.init().\n. Looks like the build system changed a bit; want to submit a PR?\n. Hey everyone's gotta have a first time right?  :)\nThanks!\n. This fixes #12.\n. joda-time-android is a repackaged version of joda-time specifically for Android. If you just need a JAR, use joda-time.\nBecause of reasons outlined in the readme, for memory efficiency reasons you must avoid using joda-time and a JAR when developing an Android app.\n. DateTimeFormat is part of joda-time and thus is ignorant of how Android's settings work. I'd like to keep the joda-time aspects of the code as clear as possible of changes.\nDateUtils.formatDateTime() is by far the preferred method of formatting date/times on Android because it handles localization well. I wrote about why a while back: http://blog.danlew.net/2013/06/27/how_to_correctly_format_date_time_strings_on_android/ (this was pre-joda-time-android so it doesn't mention it, but joda-time-android uses the same underlying methods).\n. I've updated the code in bd29ec71ea915da8ed5111f4a8462e821ce6268d.\nI'll push another update sometime soon.\n. 2.4.1 should be on maven central soon.\n. For Trello we \"provide\" joda-time for our pure Java libraries, then \"compile\" joda-time-android for the Android apps.\nIt's not the best solution, but joda-time-android is specifically optimized for Android; it just won't work without it. However, none of the method signatures have been changed (on purpose) so this testing solution should work.\n. I'm a bit confused. How is that a pure java library if you're using Activity?\n. You're including joda-time-android when you should just be using joda-time. I can't help without seeing what you're doing in gradle, but that's the gist.\n. That's what we do internally. In fact, nowadays joda-time-android has a transitive dependency on joda-time, so you're using exactly the same classes. The only difference is the ZoneInfoProvider.\n. Care to provide more information on how this happened?\n. Month is 1-12 in joda-time. I don't see how this is a bug; if you set an invalid month (0) then it shouldn't accept it.\nRegardless, you should create a ticket in https://github.com/JodaOrg/joda-time. This library does not attempt to make changes to joda-time itself, just adapt it for Android.\n. Are you trying to use a LocalDate to represent that difference? That would not work - you should be using an Interval instead: http://www.joda.org/joda-time/key_interval.html\n. This library cannot be used as just a JAR because it requires Android resources. As such I've never tried building it as a JAR so I don't know why your exception is happening, but it wouldn't work properly anyways.\nIt must be used as an Android library project, either by importing the project (pre-gradle) or adding a dependency (w/ gradle).\n. If it includes joda-time incorrectly then that's their issue, not this library's.\n. What's returned when you call DateTime.getZone()?\n. I'm not able to reproduce the problem, do you have any more details you could share?\n- What version of Android are you using?\n- What device are you using?\n- What timezone is your phone set to (exactly)?\n- Any sample code?\n. When you say \"returns\" - what are you using to get that value? It must be formatted somehow, and sometimes things can go a bit screwy during the formatting step.\n. AbstractDateTime.toString(), which is what would be used in the debugger, does not output the timezone. In the comments for the method:\n\nNote that this method does not output the chronology or time-zone.\n\nSo if the debugger is your basis for determining if the DateTime has your default DateTimeZone attached, then that's not the correct way to evaluate the problem.\nThe reason I keep asking around how you are coming to this conclusion is because I can't reproduce the issue here. I'd appreciate if you went in and tried to debug the issue because I can't tackle it without seeing it in action. I'd start by investigating DateTimeZone.getDefault() because that's what should be grabbing CEST.\n. What does TimeZone.getDefault() return? Chances are, DateTimeZone.getDefault() is calling this to get your zone:\n`DateTimeZone.forTimeZone(TimeZone.getDefault())`\nAlso, another random question - you're including this lib by adding it to the dependencies part of your build.gradle, right?\n. I tried running this and got the correct result: \nTimeZone tz = TimeZone.getTimeZone(\"Europe/Amsterdam\");\nDateTimeZone dtz = DateTimeZone.forTimeZone(tz);\nThe only thing I can think of is that, for some reason, the build system is only including the JAR of the library instead of the whole AAR. joda-time stores all its timezone data in the library itself (so it doesn't have to depend on outdated system libs). If, for some reason, all that data was not included, the library wouldn't crash, it just would default to UTC for everything.\nLet's find out if it's being included; gradle creates a build directory, and it should stick all its resources in that. In particular, I'm wondering if this file exists:\n$PROJECT/build/intermediates/res/<flavor>/debug/raw/__tzdata_europe_amsterdam\nNote that the directories might be named something slightly different based on build flavor/release type.\nIf that's still there, then maybe there's something that prevents it from being included in the final build even though it's being compiled. Are there any non-standard gradle scripts/plugins you're running?\n. I'll have to think on it more...  if I could reproduce, this is what I'd do:\n- Open up joda-time-android (the library) in Android Studio.\n- Set break points in DateTimeZone.forTimeZone()\n- Set break point in ResourceZoneInfoProvider.getZone()\n- Walk through sample lib to see what's going on.\nIf you can go through those steps you might be able to figure out the issue. forTimeZone() should be calling getZone(), which should find the resource in Android and return it.\n. Hmm, maybe it's a device-specific bug then? I'll have to try running some tests through my gamut of devices.\nI'd love it if a developer who can reproduce it on their device would take a crack at solving it.\n. I have my doubts that the latest version really changed anything, given that this issue was reported well before it came out, plus if you look at the diff of the actual code changes not much has changed in the DateTimeZone department.\nWhat's really bizarre is that it only affects some users some of the time. Time to boot up all them devices and test. :)\n. None of my devices can reproduce the issue, but I think I've found another possible avenue to investigate.\nThere is another way that the default TZ can get set: the TimeZoneChangedReceiver. Looking at it, I'm not actually sure it needs to even exist (since DateTimeZone should just be using TimeZone.getDefault(), which will update whenever the timezone changes). Regardless, it could be the way that UTC is being set for DateTimeZone.\nI'm wondering if, perhaps, on some people's networks they are constantly getting timezone change updates with IDs that are unrecognized (or \"UTC\"). That might explain the problem.\nI'm going to investigate removing TimeZoneChangedReceiver altogether, I don't think it should be necessary, and perhaps that'll fix the issue. That said, @kolczak, I'm really flying blind here because I can't reproduce, but you can. If you could explore either this idea or the ones above on your own I would be very grateful.\n. Ah, I remember now why we need it; DateTimeZone caches its default when it's first loaded.\nIs anyone calling DateTimeZone.setDefault(), perchance? That would seriously mess things up. :P\nI've solidified the code a smidge, but I still doubt this is the source of the problem: https://github.com/dlew/joda-time-android/commit/9dde8b64105ddcdb191170525e1a661d2c655170\n. Yeah, that's actually the same change I made in the dev branch. I might just push that out to see if it fixes it.\n. I'm going to hope that 9dde8b64105ddcdb191170525e1a661d2c655170 fixed it and close.\nUnless someone can reproduce (and is willing to debug the issue) I can't go much further anyways.\n. @riclage I'm releasing 2.5.1, which should be on maven central in a few hours. Would be curious to see if this fixes the problem.\n. Updated in 2cb29c20b64bb3806f2134d39671b84c252e4fc5\nShould be on maven central soon.\n. https://github.com/JodaOrg/joda-time/issues/220\n. Using normal dependency as of 80d3f6370c48a5bc3fbfa21608e2c38cae72ffad\n. Interesting. Would it make more sense to submit this issue to the core joda-time project, since that's where those files come from?\n. joda-time-android now entirely depends on joda-time, which is where those files are located; I suggest re-submitting to that project.\n. Closing now that this is in https://github.com/JodaOrg/joda-time/issues/228\n. Yeah, I've noticed that, too. I'm not really an expert on gradle-to-maven so I'm not sure why it's not uploading (the javadoc gets created but not sent over).\n. I'm hoping f2602e0bedd7f7fd79f43dc79badd986245dabd7 will fix the sources problem (though I won't upload a new version to maven central until there's either a new version of joda-time or the tzdata).\nAs for the joda-time dependency - the normal sources.jar on maven central should work, since it's all the same code. Does anyone know if there's anything else I can do to point it in that direction?\n. @christianguevara Javadoc for joda-time, or javadoc for the joda-time-android-specific classes (like DateUtils)?\nI won't be able to include javadoc in joda-time until joda-time itself updates, which it hasn't for a while.\n. Perhaps https://github.com/JodaOrg/joda-time/pull/392 will fix it?\n. Fine with me. I think it's fixed now, though it's dependent on joda-time making another release, so we can leave it open until then.\n. :+1: Thanks!\n. I think the real solution is to use joda-time's ZoneInfoCompiler, then use a gradle task to rename the output. Then I don't have to worry about maintaining another version.\nI'm going to be out of town for a week but I'll check this out when I get back.\n. Fixed as of 3d801213a05e92ef18246e178c313932c489fe5a\n. joda-time-android 2.7.1 has been pushed to maven central and should show up in a few hours.\n. Extremely low demand. There was another ticket no one said anything about for a long time: https://github.com/dlew/joda-time-android/issues/8\nTechnically, it's because of Arrays.copyOf(), which is present in joda-convert. I'd have to investigate deeper whether or not that converter is actually used in joda-time itself, which would take time, which is more than I want to do. :)\nIf someone else wants to prove it's not being used it could support 8 again, but... seriously, 8 is a bit low at this point.\n. Even if you could replace the code easily, the proper way to do it would be in joda-convert, which is a dependency for joda-time, which is a dependency for this library. So it would take a bit of time. :)\nAlternatively you could prove that that form of string conversion isn't used by joda-time itself, since joda-convert is a general utility library.\n. Yeah, that's probably correct.\nI suspect joda-time isn't using that method, but I don't want to lower the minSdkVersion unless I have proof that it's alright.\n. This is a duplicate of #27 \n. When you say \"fail\", what do you mean? Is the output incorrect? Does it crash?\nRegardless, I would avoid using DateTimeFormatter anyways, since it doesn't take into account all of the different Android configurations (such as day/month/year order and 12h vs. 24h). Better to use DateUtils included with this library.\n. I'm wondering if the best solution would be to add support for c (and while we're at it, L) to the joda-time formatter. Then one can keep using it.\nFor posterity, here's the crash logs:\nCaused by: java.lang.IllegalArgumentException: Illegal pattern component: cccc\n        at org.joda.time.format.DateTimeFormat.parsePatternTo(DateTimeFormat.java:566)\n        at org.joda.time.format.DateTimeFormat.createFormatterForPattern(DateTimeFormat.java:687)\n        at org.joda.time.format.DateTimeFormat.forPattern(DateTimeFormat.java:177)\n        at org.joda.time.format.DateTimeFormat$StyleFormatter.getFormatter(DateTimeFormat.java:833)\n        at org.joda.time.format.DateTimeFormat$StyleFormatter.printTo(DateTimeFormat.java:810)\n        at org.joda.time.format.DateTimeFormatter.printTo(DateTimeFormatter.java:684)\n        at org.joda.time.format.DateTimeFormatter.printTo(DateTimeFormatter.java:521)\n        at org.joda.time.format.DateTimeFormatter.print(DateTimeFormatter.java:625)\n        at net.danlew.android.joda.sample.JodaSampleActivity.test(JodaSampleActivity.java:56)\n        at net.danlew.android.joda.sample.JodaSampleActivity.onCreate(JodaSampleActivity.java:38)\n        at android.app.Activity.performCreate(Activity.java:5231)\n        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2148)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2233)\n        at android.app.ActivityThread.access$800(ActivityThread.java:135)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1196)\n        at android.os.Handler.dispatchMessage(Handler.java:102)\n        at android.os.Looper.loop(Looper.java:136)\n        at android.app.ActivityThread.main(ActivityThread.java:5001)\n        at java.lang.reflect.Method.invokeNative(Native Method)\n        at java.lang.reflect.Method.invoke(Method.java:515)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601)\n        at dalvik.system.NativeStart.main(Native Method)\n. I'm not 100% sure this is the reason, but it looks like it's including joda-time twice (once as a dependency for joda-time-android, once for jackson-datatype-joda). I think this is happening because jackson uses joda-time 2.2 (whereas we're using joda-time 2.7).\nYou can always exclude the joda-time dependency from jackson-datatype-joda:\ncompile('com.fasterxml.jackson.datatype:jackson-datatype-joda:2.5.0') {\n    exclude module: 'joda-time'\n}\nMight also want to submit a PR to jackson-datatype-joda updating their dependency.\n. I would ignore that; DateTimeZoneBuilder isn't used at all (except to generate the tz rules at build time).\nI wonder why it can't find ZoneInfoCompiler, though... should be included in the JAR too.\n. That's all you need; joda-time is a dependency of joda-time-android, so it'll automatically be pulled into the project.\n. Did you make sure to add \nrepositories {\n  mavenCentral()\n}\nAnywhere in the build.gradle file?\n. https://gradle.org/docs/current/userguide/working_with_files.html#sec:sync_task\n. Done as of 1de588e3cdc19cb3d3278259a6c7fdb84aeb25eb\n. It looks like you're only including the JAR, not the AAR, of this library. There are resources that are needed in the AAR for this library to work. What is in your build.gradle?\n. Hmm... without knowing more it's hard to help. But it should be pulling in the AAR file that includes __tzdata_zoneinfomap. Maybe it's being stripped out in another build step? Like some minifying?\n. I've got some good news and some bad news. The next version of joda-time should fix this issue. The bad news is that you'll probably run into unavoidable ProGuard issues at that point. :p\nI'll just have to come up with some ProGuard details on the README I think.\n. Not really - it'll depend on the underlying joda-time dependency updating.\n. Are you doing Eclipse builds or Gradle builds?\n. A combination of joda-time 2.8 and properly including joda-convert should fix all proguard issues (at least, they do on my end).\n. @Splaktar No, you shouldn't need to include it. My comment is slightly out-of-date. You either need to proguard, or you need to include joda-convert.\nThose crashes have nothing to do with this issue. I've looked into it and I honestly have no idea how that's happening, especially since it works fine on most phones.\n. @ligi Does it happen on any older builds?\n. I'm not seeing this problem when building your project. The problem I see w/ proguard is this:\nWarning: com.squareup.leakcanary.DisplayLeakService: can't find referenced method 'void setLatestEventInfo(android.content.Context,java.lang.CharSequence,java.lang.CharSequence,android.app.PendingIntent)' in library class android.app.Notification\nWarning: there were 1 unresolved references to library class members.\n         You probably need to update the library versions.\n         (http://proguard.sourceforge.net/manual/troubleshooting.html#unresolvedlibraryclassmember)\nWhich I actually happened to fix in LeakCanary, but it hasn't been released yet: https://github.com/square/leakcanary/pull/308\n. Ah, I've figured it out. Your proguard is removing stuff from your R. It just happens that joda-time-android is the first part of your app trying to access it.\nYou should really use the default proguard file Android comes with in addition to your own. It handles stuff like this:\nproguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt'\n. This is probably another instance of https://github.com/dlew/joda-time-android/issues/36; moving to there.\n. I run Android unit tests (no robolectric) so I haven't run into that in particular. What happens if you run the test without robolectric (as a normal Android test)?\n. @legarspol If you're doing a pure unit test, then just include joda-time for it instead of joda-time-android.\n. Did you make sure to call JodaTimeAndroid.init() at some point?\nCheck out usage: https://github.com/dlew/joda-time-android#usage\n. Hmm, I'll consider it in the future.\nIn the past we just... blew up if you didn't call it. Now it doesn't give a clear error message.\n. Hmm, I am not sure what's going on given that it's only failing once in a while. Could you paste the exact error?\nIn general, you should avoid any instantiation of DateTime objects before calling JodaTimeAndroid.init(). If there's some method being called beforehand (like a static initializer) then that could be the culprit for why it's not working so well.\n. \"The objects\" being what exactly?\nAnd yes, JodaTimeAndroid is a singleton.\n. No problem, have a nice day.\n. Given that I asked this two months ago and got a grand total of two replies, I'm going to say that supporting Eclipse going forward is probably not in the cards.\nThere are a few advantages to switching solely to Gradle-based system:\n- Single path of execution is simpler to manage.\n- Can depend solely on Gradle-based features (like dependency on joda-time).\n- Don't need to check in compiled version of tzdata into repo anymore.\nOn top of that, there's no reason older versions of joda-time-android wouldn't keep working going forwards for Eclipse. As a result, I think 2.8.1 will be the final version supporting Eclipse.\n. Whoops! Thanks.\n. If you're using gradle builds, then this library already includes joda-time 2.7.\nIf you're using Eclipse builds, then you need to include the JAR yourself anyways, so feel free to just update to 2.7.\n. Have you tried putting it in Application? Then it most likely run before any code that actually uses it.\n. The only change between 2.7.1 and 2.7.2 was updating the timezone database, so I doubt that had anything to do with it.\n. I'm busy with IO but I'll be working on a release soon.\n. ./gradlew connectedCheck probably fails because of date/timezone settings on the device. I should specify better what's needed in order for the test to run properly. (I haven't gone so far as to manipulate the device settings to run the test.)\nI'm fairly busy with IO today but at a glance this looks good.\n. Sorry for the delay, I got the conference crud! This looks good to me.\n. Duplicate of #46\n. It hasn't gone live yet; I was going to push soon but got held up by a build bug.\nI'm rolling back the README until it goes live.\n. Fixes #56 \n. After some deeper investigation, the answer is no. Not sure how I thought this was happening.\n. Please see this comment: https://github.com/dlew/joda-time-android/issues/37#issuecomment-75898305\nThis is caused by Robolectric: https://github.com/robolectric/robolectric/issues/1430\n. What happens if you don't have proguard enabled?\n. Are you able to reproduce it with your own devices, or are you only seeing crashes reported?\n. There's not much I can do without a reproduction. Maybe it has something to do with obfuscation?\n. I'm closing this until I see a repro.\n. Do you have a way to reproduce it, or are you just seeing it in crash logs?\n. Unfortunately, I can't really do anything about it without a repro. Maybe it's happening on custom ROMs, maybe the user is doing something screwy with the APK, who knows?\nThe code is pretty simple - it's just trying to open an asset.\n. The problem you're running into is that proguard doesn't use the test sources when computing what to remove and you don't use DateTime.now() in your app. That is, the build process looks like this:\n1. Compile all the app source files.\n2. Process them with proguard.\n3. Create an APK.\n4. Compile your test source files.\n5. Run tests against APK.\nAs you can see, proguard runs way before you even get to the test sources.\nI suggest creating a proguard file that hooks into the gradle parameter testProguardFile, wherein you can be far more permissive of what's included (since it's only run against test APKs).\n. The proguard being included automatically with the library is only for the essentials. It won't cover your back if some of your code is being removed because your APK isn't referencing it at all.\nYou can check it out here, it doesn't protect DateTime at all: https://github.com/dlew/joda-time-android/blob/master/library/proguard-rules.txt\n. Merging even though it fails; the problem are some tests which I didn't know were failing (which is due to CI not being place). I need the CI to double-check my own work!\n. In your tests you could use joda-time instead of joda-time-android, which has no dependency on Android. Alternatively, I've heard of people using Robolectric to run tests without using an emulator.\nThis issue tracker is specifically for problems with joda-time-android; testing Android-specific libraries without using the emulator is a problem for all Android libraries.\n. Could you be a bit more specific with how you're using the library? What exact syntax are you using?\n. You need to specify that you're using an AAR:\nxml\n<dependency>\n    <groupId>net.danlew</groupId>\n    <artifactId>android.joda</artifactId>\n    <version>2.8.1</version>\n    <type>aar</type>\n</dependency>\n. Thanks!\n. I think I need a bit more context for why you want the year to be Integer.MIN_VALUE.\n. This doesn't seem like an issue with joda-time-android, but with joda-time itself.\nRegardless, I would consider it alright that joda-time doesn't support further than 292 million years away.\n. Looked into it; resourcePrefix is more of a check than it is a generator.\n. joda-convert is optional. There must be another library including it.\nCould you run gradle dependencies and find out who is pulling it in?\n. TypeStringConverter isn't in joda-time. joda-time-convert is an optional dependency. It seems odd that TypeStringConverter would be the one getting an error if it's not even in the library.\n. If you can provide a sample app that shows this problem I can diagnose it, but I've never heard of it before, and we even took aims to provide a proguard file for joda-time-android (so I've checked into what sort of errors occur in the past).\n. I just tested again and the sample app (for this lib) can build on 2.8.2 with no proguard issues.\nI highly suspect there is more going on in your app than you realize, especially if you cannot reproduce the issue in a sample app.\n. Here's the output of ./gradlew :sample:dependencies as well:\ncompile - Classpath for compiling the main sources.\n\\--- net.danlew:android.joda:2.8.2\n     \\--- joda-time:joda-time:2.8.2\nNo joda-convert, no guava.\n. Given that 2.8.2 has been out months now, would you consider that maybe the release isn't broken?\nTry clean & build.\n. You should read the documentation here.\n. The library already includes the minimal amount of proguard necessary to get it running without warnings: https://github.com/dlew/joda-time-android/blob/master/library/proguard-rules.txt\nAny additional problems would have to be handled on an app-by-app basis - e.g., if you're using a class in test but not in prod, and proguard removes it by accident.\n. I'm not convinced that the proguard changes are the solution for the problem anyways. I'm pretty sure the missing ZoneInfoMap is just due to irregularities with the build system - whenever I see it (and it's rare), a clean build fixes the problem.\n. Thanks!\n. I've only ever seen this happen because of a bad build. Try cleaning/rebuilding.\n. Oh whoops, I misread this initially. ZoneInfoMap != ResourceZoneInfoProvider. Chalk it up to having just woken up. :P\nThe fact that it works on some devices and not others rules out proguard. But are you using multidex? That might be the culprit, since obviously your Application code would be in the primary dex file (but joda-time-android's classes could be in a secondary dex file).\nOn Lollipop+, multidex would happen naturally; but on KitKat and below you'd have to invoke the legacy multidex BEFORE trying to initialize joda-time.\n. It's not that the timezones weren't updated, it's that \"Arctic\" region timezones weren't being parsed (due to an oversight). I'll fix this up and it'll go out in the next release.\n. That's where it's generating all that data, yes. It's using the custom compileTzData task to do it.\nI was uncomfortable with having compiled resources in the source. Pre-gradle there wasn't an easy way around it, but with Gradle it's possible to compile the resources and add them at build time. This helps prevent a lot of potential problems, like inconsistency between the source and the build.\nAll that said, I'm not exactly sure how you're going to do it with BUCK. You'd have to replicate the compileTzData step, which relies fairly heavily on built-in Gradle functionality.\n\nRegarding adding a BUCK build file - what would be the advantage for the library?\n. Closing, for two reasons:\n1. This is a question about joda-time, not joda-time-android.\n2. You're converting a LocalDate (part of joda-time) to Date (part of Java), then back again. Date is old and has no concept of timezones. Therefore it's a lossy conversion, so it makes sense that something might go wrong.\n. The primary problem is that \"AST\" is a timezone that joda-time doesn't recognize.\nIn general, short timezones are not supported by joda-time because they are ambiguous. Some of them happen to work (for backwards compatibility) but I doubt they all do.\nThis is a problem in the base project, not joda-time-android. Please report the issue here: https://github.com/JodaOrg/joda-time\n. This was caused by the upgrade to using joda-time as an actual dependency (rather than just including everything). joda-convert is an optional dependency as of 2.7, but if you're using it (and it looks like Jackson is) then you need to include it:\ncompile 'org.joda:joda-convert:1.8.1'\nSee changelogs for more info: https://github.com/dlew/joda-time-android/blob/master/CHANGELOG.md#270-2015-01-19\n. What is the exact timezone you have set on the device?\n. What happens if you output TimeZone.getDefault()? I'm not exactly sure what CEST is supposed to correlate to in the tzdata.\nYour suspicion is probably wrong, btw. The reason that's needed is for the DateTimeZone to work if your timezone changes. Otherwise joda-time doesn't know that the default timezone has changed.\n. What does TimeZone.getDefault() give you? That's really what I'm interested in here...\n. I've just tried using Europe/Helsinki with the joda-time-android sample on a device and it works fine for me. Hmm... What happens if you try DateTimeZone.forTimeZone(TimeZone.getDefault())? I wonder: what is joda-time converting Europe/Helsinki into?\nAnother thought: are you calling JodaTimeAndroid.init(context);? If you don't do that, then everything won't work...\n. Alright, problem solved.\n. Did you follow the instructions here?\n. Do you happen to be including both joda-time and joda-time-android?\nI'm not really sure what's going on here because joda-time-android shouldn't be trying to load \"org/joda/time/tz/data/ZoneInfoMap\" at all; we use our own ZoneInfoMap.\n. What did you update from?\nIf you're coming from pre-2.7.0 you might want to check the changelog: https://github.com/dlew/joda-time-android/blob/master/CHANGELOG.md#270-2015-01-19\n. This is a duplicate of #99.\nAlso, this is a legacy multidex problem, not an issue with the library itself. Please ensure your primary dex file includes joda-time-android.\n. I'm not able to reproduce this behavior with the sample app. Can you reproduce it with the sample app from this project?\nAlso, how are you installing/starting the APK?\n. My guess is that you're creating a DateTimeZone sometime before you call JodaTimeAndroid.init(), but only on the first start of the app. That would cause it to get stuck on UTC until a timezone change occurs.\n. methodscount.com works perfectly fine for me on the latest version: http://www.methodscount.com/?lib=net.danlew%3Aandroid.joda%3A2.9.3\n. I don't like badges.\n. Usually people just include the plain joda-time dependency for unit tests, since it comes packaged with tzdb.\n. It is not pure Java if you're doing it inside of the Android framework.\nThat said, I see no reason to create a joda-time-android that includes the the tzdb in the JAR, because that's exactly what joda-time is already.\n. Yes, exactly.\n. Yes! Sorry this got dropped by the wayside.\nOnce IO is over I'll have time to put out another release.\n. joda_keep.xml doesn't apply to the localized files, only the timezone data itself, which is a necessary component of this library. The localized files should be removed if you use\nminifyEnabled true\nshrinkResources true\nin you build.gradle.. Want to submit a PR so I can give proper credit?\n. This part of joda-time-android was just a straight up port of the Android code, so any mistakes there will get transferred here.\n. Sounds good to me. I'll have to find some time to run https://github.com/dlew/joda-time-android/blob/master/utils/resource_extractor.py again.\n. I tried running the resource extractor again but ran into some problems. Mainly, in API 23 added more things from ICU4J to internal AOSP, so they can rely on it more than before. That means there are no actual strings in the resources for me to use.\nWe could either start importing those parts of ICU4J here as well, or we could give up and deprecate support for anything that required resources before (namely just getRelativeTimeSpanString(), getRelativeDateTimeString() and formatDuration()).\n. I think the halfway solution for the next release is going to be to gather the latest translations (for what we can), and otherwise split off that functionality into another lib.\n. This smells like a ProGuard issue.\nRegardless, this bug is mostly likely from DbFlow, not joda-time-android. If someone is referring to DateTime by reflection and you're not protecting it with ProGuard this will happen. I'm not familiar with DbFlow, so I don't know exactly what's going wrong. I'd file an issue with them: https://github.com/Raizlabs/DBFlow/issues\n. Then maybe it's a multidex issue? Though it should then probably also happen for 4.4...\n. From the stack trace it looks like this is a bug best filed in https://github.com/JodaOrg/joda-time.\n. It's still being maintained, especially for bugs like this.\n. For future reference, this is where the bug ended up in joda-time: https://github.com/JodaOrg/joda-time/issues/381\n. Since joda-time-android just uses joda-time as a dependency, you can just manually include joda-time 2.9.6 and it'll get used instead.\nI'm definitely open to updating the referenced library to 2.9.6 but I don't feel like a new release is necessary for it.\n. Thanks!\n. Thanks! Sorry this took so long, been on vacation.\n. I need to push the latest out there; this got merged a bit prematurely, sorry.\n. There, it's been released and should show up on maven central soon.\n. This fix should go into the joda-time library. The tests here are just copied from there, so changing them here won't help much.\n. This doesn't really match the code style at all.\n. I don't know why it's happening. I'm not able to reproduce it on my own project, which uses this exact setup in order to run unit tests without an Android dependency.\nMaybe it's a dependency freshness issue?\n. If you're using the UTCProvider then you may as well just use joda-time and skip joda-time-android, since the main benefit of this library is the timezone data.\nI'm willing to fix this problem, but I need a reproduction first because I am not seeing this problem myself.\n. I understand precisely, because we are doing the exact same thing within our app. The referenced issues above have explanations for how to solve the problem (e.g. https://github.com/dlew/joda-time-android/issues/17#issuecomment-56034133).\nThat's why I say that I need a reproduction because we're already doing the same thing as you but not running into problems.\n. Closing due to inactivity. Feel free to reopen if there's any new information.\n. If you're using Gradle it will automatically import joda-time as a transitive dependency.\n. What shows for joda-time-android if you run the Gradle dependencies task on your app's directory? E.g. ./gradlew :app-dir:dependencies.\n. Are you removing it via Proguard or something?\nA warning: This is quickly moving outside the bounds of the joda-time-android issue tracker, which is for issues with the library itself. This problem sounds more like an issue with your own build setup, which is preventing dependencies from being consumed.\n. Unfortunately I don't know what could be going on here - maybe Oneplus was making customizations with the locales?\nThat said - this sounds like a problem more for the base joda-time library because joda-time-android is just a wrapper around it. This library doesn't implement DateTimeFormatter itself, in other words.\nIt might help if you could step through the code and find out what it thinks is invalid about the string.\n. Closing due to inactivity. Feel free to reopen if there's any new information.\n. Are you initializing the library before trying to parse the dates?\n. I'm not able to reproduce the issue. I think I need a bit more to go on before I can diagnose it.\n. It's setup so that it only initializes once, even if called from multiple places, so it should be safe: https://github.com/dlew/joda-time-android/blob/master/library/src/main/java/net/danlew/android/joda/JodaTimeAndroid.java. Unfortunately, no. I think it's on the developer, though, if they start using a dependency without doing any research (at all) on it first.. It doesn't matter much, you can always increase your joda-time dependency independent of joda-time-android. This is just a book-keeping thing.. You could call DateTimeZone.setProvider() (like our init method does) and provide your own Android-tz-based provider.. Your code actually does nothing. Joda-time uses TimeZone.getDefault() anyways.\nIf device's current time is set incorrectly then you won't be able to calibrate anything yourself no matter how hard you try. Check out this setup:\n\nThe OS thinks that UTC time is 07:00 (the correct actual UTC time).\nOS TZ displays as 09:00 because it uses out-of-date information (think it's still +2).\nJoda-time TZ thinks it's 10:00 because it uses correct information (+3).\n\nIf your users changed the timezone to something that was also +3, then we'd be fine. But instead they changed the system clock, so this happens:\n\nThe OS thinks that UTC time is 08:00 (which is incorrect).\nOS TZ displays as 10:00 (+2 of incorrect UTC).\nJoda-time TZ displays as 11:00 (+3 of incorrect UTC).\n\nIf your OS is lying about what UTC time is, there's no way to know what the actual time is (short of pinging time servers yourself, in your app). As such, the only solution is to defer to whatever the users think is correct by getting rid of the custom timezone handling.. Sorry for the slow reply, been on vacation.\nI don't know anything about Unity, but it seems like it may just make more sense to use vanilla joda-time if all you can include is a JAR file. joda-time-android is specially optimized for Android APKs and requires the usage of the resource system, so if Unity can't use resources then this library won't help.. Sorry for the late reply (been on vacation), but liminal has the right answer here.\nMore discussion on this can be found here: https://github.com/dlew/joda-time-android/issues/127. Could not find in what way? Does it not compile?. I'm even more confused now. You say you removed the library from the gradle file. That means the library should no longer be present. This makes sense to me.. Thanks!. Whoops, thanks!. Gonna need some more clarification on what you want and why it is necessary.. Can't hurt to add that.. That's not a bug. The instructions state that you should call JodaTimeAndroid.init() before you can properly use joda-time-android.. joda-time is what implements the default behavior when you haven't provided your own timezone data, and at this point it's in maintenance mode, so I doubt they'd change the behavior at this point.\nWithout doing some tricky automatic hooks, I wouldn't be able to make this library automatically work (or automatically fail).. It looks like you're including joda-time and joda-time-android. You should only include joda-time-android, as it pulls in its own dependencies (which are subtly different from the normal, core joda-time).. ZonedDateTime is not part of joda-time. See the javadocs for what is included: http://joda-time.sourceforge.net/apidocs/overview-tree.html. Using up-to-date tzdata is one of the primary goals of joda-time-android. If you are using Android-based tzdata then it would make more sense to just use joda-time plain with your own provider.. If you're using obfuscation, then you might be renaming the assets that joda-time-android depends on. Theoretically, we should be keeping you from renaming the assets using our keep.xml: https://github.com/dlew/joda-time-android/blob/master/library/src/main/res/raw/joda_keep.xml\nCould you check your APK with the APK analyzer and see if the assets are being renamed? They should all look something like joda_america_chicago or something.. I haven't heard of an OS renaming resources... I'm honestly a bit at a loss here.. joda-time-android is incompatible with using the base joda-time library.\nYou should talk to the library about either using joda-time-android or using joda-time:joda-time:2.9.9:no-tzdb. Alternatively, you could forcibly remove the joda-time package from the library. Either way is a good move because of the reasons for not using the default joda-time library: https://github.com/dlew/joda-time-android#why-joda-time\nRegardless, this is not a bug with joda-time-android. It's an incompatible dependency setup.. Closing as a duplicate of #25.. This looks like an issue with joda-time, not joda-time-android. I suggest filing this bug there.. It's used to initialize the library, because it needs access to Context in order to operate.\nIf I were to rewrite the library from scratch these days, I'd probably use the ContentProvider initialization trick. But I don't want to fix what isn't broken, so it'll stay this way until some compelling reason makes me change it.. Pure Java joda-time does not require Context because it can load data from its own JAR. However, this has proven to be a bad practice on Android, thus we load it from resources here. See more on why here: https://github.com/dlew/joda-time-android#why-this-library. When you create a DateTime it has to get its timezone data from somewhere. There is a static singleton timezone data loader. For this library, you need to pass it the Context to get it started. In pure Java joda-time, you don't, because it (by default) grabs it from the JAR.\nThis is an issue tracker for bugs related to joda-time-android. This isn't a bug, if you have further questions please take it to StackOverflow or the like.. I'm not exactly sure what you're trying to do. If you're using LocalTime that means that you don't care about timezone at all, so to throw timezones into the mix confuses me.. Sure, you can construct a LocalTime from a DateTimeZone, but afterwards you are essentially losing that data. That's useful when you, say, have a time picker that includes timezone: the user picks the time they want (11 AM in zone X), you convert that to LocalTime (11 AM anywhere), and the timezone doesn't matter anymore.\nIf you want to convert LocalTime back to DateTime, maybe you should use LocalTime.toDateTimeToday()?. What timezone is your phone in, and how old is your phone? I'm beginning to suspect the problem may be that the zone data on your phone is out-of-date compared to joda-time. That could result in the output being wrong between the system clock and your app's clock.. I really don't know. I could look more into this if you provide a brief snippet that demonstrates the exact problem (and not just underlined areas of the sample app). Otherwise I don't really have time to chase this down; I'm guessing it's probably not the lib's fault, but some misunderstanding of the timezones involved.. Closing due to inactivity.. Which timezone ID are you passing in? The docs state that that exception happens when you pass in an unrecognized timezone ID.. If you're deserializing data from outside the app, you should probably have some safety checks that you're not grabbing timezones that aren't recognized.\nWithout knowing which timezone you're trying to request, it's hard for me to figure out what's happened.. Ah, I've figured out the issue then. It's because you're trying to serialize a DateTime, which does not work on Android because Android Serializable support is awful. See more here: https://github.com/JodaOrg/joda-time/issues/448\nI highly suggest not using Serializable on Android anyways; it's bad and slow. Just about anything besides that would be better.. https://github.com/JakeWharton/ThreeTenABP/blob/master/README.md#why-not-use-joda-time. You asked the exact same question in https://github.com/JakeWharton/ThreeTenABP/issues/61 and got your answer. I don't know what more you want.. joda-time-android is built on top of joda-time. They the same, except for where the timezone data is provided from. This is explained in the README.. Sorry for the slow response, been out Thanksgiving weekend.\nMenoData is correct. If you wanted consistency in the days between, you should be using LocalDate, not LocalDateTime. The extra precision that the time component adds messes up the days-between calcluation.. If you care deeply about including the notices/licenses in the APK, this only seems like a half-solution. Wouldn't you need to include all the licenses/notices if that's what you're worried about?. Thanks, I'm down with this version.. No ideas, I haven't started using bundles yet myself.\nYou should file a bug report with Android Studio, not joda-time-android.. I've been ruminating on this for a couple days and I honestly don't know what's going on. DateTimeZone.getDefault() should be based off of TimeZone.getDefault().\nI'd have to have more code to reproduce, or maybe you could try to figure out who is setting the default incorrectly.. Isn't that just what was posted earlier? I can't being to piece together why that is happening without a reproduction on my end.. We actually include our own proguard rules here, you shouldn't need to add anything: https://github.com/dlew/joda-time-android/blob/master/library/proguard-rules.txt\nThe reason this error comes up is usually because you're forcing removal of resources that should not be removed.. Well, in particular, it looks like the minifier is removing the resource joda_zoneinfomap. That should be kept, as per our resource keep rules: https://github.com/dlew/joda-time-android/blob/master/library/src/main/res/raw/joda_keep.xml. There's nothing obviously wrong as far as I can tell. I would guess that maybe it's a device that's got some weird set of locale rules or something that's causing parsing to fail?\nRegardless, this may be more of a core joda-time issue than one with joda-time-android; we don't touch the parsing code at all.. It would be possible to delay reading the zone data until first requested. Namely, in https://github.com/dlew/joda-time-android/blob/master/library/src/main/java/net/danlew/android/joda/ResourceZoneInfoProvider.java you could delay iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\")) until absolutely necessary.\nI'm a bit hesitant to make that change, though, just because it means you'd be adding execution time to some other random part of the app - changing behavior characteristics.\nWithin your own code, if you know you're not using DateTime until some time way after startup, you could delay calling JodaTimeAndroid.init() until then.. I don't think there is an issue with the library; if you just run ./gradlew :sample:assemble it works fine.\nIt looks instead like there's some issue with your instance with regard to instant run. If you disable instant run, does it work?. Did you leave the old joda-time dependency in at the same time? You will need to remove that if you switch to joda-time-android (joda-time-android brings in a special version of joda-time which can conflict with the main artifact).. You can force removal of transitive Gradle dependencies.\nThe version of joda-time that joda-time-android uses is completely compatible with normal joda-time. The only difference is that it doesn't package tzdata with it (since joda-time-android packages its own tzdata).. I don't feel like this is necessary, since gradle wrapper already exists for updating versions.\n. I don't replace the README on purpose, instead using it as a reference for the files.\n. This commented-out code is kept on purpose because this file is a copy (with slight modification) from the base joda-time library.\n. This fix should go into the joda-time library. The tests here are just copied from there, so changing them here won't help much.\n. Ah, I hadn't gotten the memo, thanks.. ",
    "zmalltalker": "Thanks for the quick feedback, @dlew \nI didn't realize the cause was from pre-compiled dependencies, I was probably a little quick in reporting this. That taken into consideration this looks like something I should take care of in my project, which I already did.\nOh, and I use gradle (does anyone really still use Eclipse? :trollface:)\n. Awesome!\n. ",
    "rlac": "Yes -  the method docs at http://developer.android.com/reference/android/content/Context.html#registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter) mentions in the Note section that the lifetime of broadcast receivers registered this way are tied to the object registering them.\nI've verified that the registration dies in the sample app by killing the app process then changing time zone.\n. I've made the changes you requested.\nI'm not sure if the implementation to check the caller of the ResourceZoneInfo init method is the best way to do this. I can't see a way to determine whether the application build is a debug build or not from the library, so the warning is printed regardless of the application's build type.\nI'm happy to revise further if required.\n. Thanks for the feedback.\nI've updated the JodaTimeAndroid class with an init called flag, checked by the method itself to avoid doing anything if init is called multiple times, and check this in ResourceZoneInfoProvider instead of using the stack trace.\n. ",
    "josiahneuberger": "I submitted a pull request; however; be advised that this is my first pull request.\n. ",
    "Geobert": "Ok, just discovered Date4J, seems to be what I need. Thanks.\n. ",
    "xylo04": "I guess DateUtils.formatDateTime fills the requirement better. That's probably the preferred route. It would be convenient if DateTimeFormat's convenience formatters would use the Android locale, but it's probably an enhancement and not a bug. Feel free to close this.\n. ",
    "anothem": "We use Robolectric for running Android unit tests on the JVM which would solve this problem. \n. ",
    "kaushikgopal": "Yup makes sense. Thanks for the great work. T\n. ",
    "caipivara": "@dlew can you show please how you use joda-time instead of joda-time-android for the pure java libraries? \nI\u00b4m trying to do just unit testing with MVP but I get when I try to use joda time android, trying to mock it too but don\u00b4t work.\nnew DateTime()\nError:\njava.io.IOException: Resource not found: \"org/joda/time/tz/data/ZoneInfoMap\" ClassLoader: sun.misc.Launcher$AppClassLoader@7852e922\n    at org.joda.time.tz.ZoneInfoProvider.openResource(ZoneInfoProvider.java:210)\n    at org.joda.time.tz.ZoneInfoProvider.<init>(ZoneInfoProvider.java:127)\n    at org.joda.time.tz.ZoneInfoProvider.<init>(ZoneInfoProvider.java:86)\n    at org.joda.time.DateTimeZone.getDefaultProvider(DateTimeZone.java:514)\n    at org.joda.time.DateTimeZone.getProvider(DateTimeZone.java:413)\n    at org.joda.time.DateTimeZone.forID(DateTimeZone.java:216)\n    at org.joda.time.DateTimeZone.getDefault(DateTimeZone.java:151)\n    at org.joda.time.chrono.ISOChronology.getInstance(ISOChronology.java:79)\n    at org.joda.time.base.BaseDateTime.<init>(BaseDateTime.java:61)\n    at org.joda.time.DateTime.<init>(DateTime.java:171)\n    at org.joda.time.DateTime.now(DateTime.java:89)\nWhy?\n. @dlew ! I copied the wrong line :P it happens when I try to create a new DateTime for mocking.\n. but I'm using it inside my api library and was using that auto import for proguard that you just added to this lib, any way to use it for tests automatic too? \n. Makes sense, thanks \n. ",
    "ghost": "This is a bit late but if anyone stumbles here, unfortunately not all of modules were pure java, but thankfully most of the package names and functionality in joda time android is similar to joda time, so for running jvm unit tests you can do something like\ntestCompile \"joda-time:joda-time:${jodaTimeVersion}\"\nAlthough this won't work for classes or modules where you are using jodaTimeAndroid exclusive classes, but in my case i was able to successfully use it in a lot of places\n@dlew i am assuming there shouldn't be any side effects with this approach like possible flaky tests\n. True, so I guess most people can do jvm tests without any problem for the\nmost part\nOn 20-Dec-2015 1:03 am, \"Daniel Lew\" notifications@github.com wrote:\n\nThat's what we do internally. In fact, nowadays joda-time-android has a\ntransitive dependency on joda-time, so you're using exactly the same\nclasses. The only difference is the ZoneInfoProvider.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/dlew/joda-time-android/issues/17#issuecomment-166017785\n.\n. \n",
    "Shahroz16": "Its a very old bug in joda. While setting LocalDate if you set Year to be 0\nIts crashed,same is the case if month is 0. This is the reason why I left Joda jar and choose your lib but its happening with your library too. \nHere is the similar bug, https://github.com/tminglei/slick-pg/issues/19\nthey say they have fixed it, but its not and I have seen many other guys facing this bug too. \n. This is definitely a bug, consider this use case.\nI want to get an age difference between two date of birth dates, that difference can surely give me difference in days and Years can be 0. \nNevertheless, I will create a ticket over there. Thanks for help \n. @dlew yup I finally switched to Interval. Its working now. (Y)\n. ",
    "rajuginne": "tring replace but\nprivate DateTime convertToDateTime(String stringToConvert) {\n         String[] newStringArray = convertStringToArray(stringToConvert);\n         LocalDate mLocalDate = new LocalDate(Integer.parseInt(newStringArray[2].trim()),\n                 Integer.parseInt(newStringArray[0].trim()),\n                 Integer.parseInt(newStringArray[1].trim()));\n         return mLocalDate.toDateTime(LocalTime.fromDateFields(mLocalDate.toDate()));\n//\n }\n\nprivate DateTime convertToDateTime(String stringToConvert) {\n         String[] newStringArray = convertStringToArray(stringToConvert);\nInterval mInterval = new Interval(Integer.parseInt(newStringArray[2].trim()),\nInteger.parseInt(newStringArray[0].trim()),\n                 Integer.parseInt(newStringArray[1].trim()));\n//cannot resolve interval (int int int)  error\n     return mLocalDate.toDateTime(LocalTime.fromDateFields(mLocalDate.toDate()));\n\n     Interval interval = new Interval(start, end);*/\n\n}\n//cannot resolve interval (int int int) error\n. ",
    "rambabupudari": "i am using aws-android-sdk-core jar for upload the file to amazon server.\nit contains joda time .\n. ",
    "kolczak": "UTC\nhowever when I use Calendar.getInstance(), it properly returns UTC+2\n. Sure:\n- 4.4.4\n- Nexus 4\n- Time zone is automatically assigned and it is GMT+2, Central European Summer Time\n- Sample is just a constructor:\nDate date = new Date();                                                     //returns Fri Oct 24 13:30:34 CEST 2014\nDateTime time = new DateTime();                                     //returns 2014-10-24T11:30:39.784Z\nDate callendarDate = Calendar.getInstance().getTime();  //returns Fri Oct 24 13:30:42 CEST 2014\n. I check the value during debugging, so no formatting issues concerned.\n. Hi\nI used \"toString()\" method. At 9:09 it returned me:\n2014-10-27T08:09:30.914Z\nNow it is one hour difference, but just because we changed current time to Winter Time since last weekend.\nDateTimeZone.getDefault().toString() returns me UTC.\nIt returns me time in UTC rather in my current time zone.\n. TimeZone.getDefault() returns: Europe/Amsterdam what is correct.\nYes, I use dependencies in build.gradle. I hope this is enough. I saw some step to fetch recent time zones, but I hope it is not necessary when using dependency in gradle.\n. The directory with Europe Amsterdam time zone exists.\nI don't use any custom or not standard gradle scripts.\nDamn, that sounded like good catch...\n. ",
    "riclage": "I'm getting a few users reporting a similar issue since I upgraded to your most recent update. I'm not sure it is related but on your previous version I was using ResourceZoneInfoProvider.init(this) instead of the new JodaTimeAndroid.init(this).\nUnfortunately I can't debug this because the problem does not happen on my devices. I also tried changing timezones to no avail. \nIf you think there is anything I can help you with, please let me know. For now, I'm reverting back to the original version of the library I was using before. I will let you know if I get any complains from using it.\n. I don't think so because users with the same devices as mine (for example a Nexus 4 running stock Android 4.4.4) have also reported this.\nI would love to to be able to reproduce this problem here and figure this out. Now that I reverted to the old version of the library, if the problem stops, I can try to compare the code to see where there might be a problem.\n. So far I'm not having any complaints with the old version of the library. This is a version prior to you adding the TimeZoneChangedReceiver. Since your last comments, I started looking at the code of this receiver and Joda's DateTime class. One thing that struck me is that DataTime always uses TimeZone.getDefault() to set the default time zone whereas the receiver was taking the code from the Intent data.\nSo I implemented your receiver manually on the old version I'm using and changed it to always update the time zone using TimeZone.getDefault(). This method already returns the updated time zone anyway so I think it is safer to be consistent with what DateTime does to update its time zone. But since I can't reproduce the problem, I'm not sure this is the solution for it.\nThanks!\n. I'm a bit reluctant to update this now as the version I described in my previous comment is working just fine. Thanks for the feedback.\n. So here is the solution: you need to update the ZoneInfoCompiler with the latest from the official lib. Note how the latest commit there was precisely to address the \"Asia/Dhaka\" timezone.\n. ",
    "austynmahoney": "I think the issue might be that Android Studio is looking for the wrong file. This library uses the no-tzdb jar, so Android studio looks for javadoc/sources for joda-time-2.7-no-tzdb.jar, which don't exist on Maven Central.\nError message in AS:\nSources for: joda-time-2.7-no-tzdb.jar not found\nIf I download the sources for the library, I can attach them manually to the lib classes like JodaTimeAndroid. The joda-time sources still won't attach though.\n. ",
    "christianguevara": "I dont know if you updated a new version in maven central, but still no javadoc found :(\n. ",
    "user-don": "dlew, first off this is a fantastic library and I'm a total fan. Any update on whether it's possible to get the joda-time javadocs available for use when developing?\n. ",
    "PaulWoitaschek": "Any news on this? Its quite annoying to go to view the javadoc in a browser when finding out what the meaning of a signature is.\n. @dlew Can you leave this open until its fixed?\n. Still present for me in 2.9.5\n. @victorhurdugaci \ngroovy\ntestCompile 'joda-time:joda-time:2.9.4.2'\n. As I now updated again, everything seems to be in place.\nThe weird part was that your classes like JodaTimeAndroidwere available but the org.joda... classes were not.\n. ",
    "xgouchet": "I'm also still waiting for this to be available\n. ",
    "benj56": "And 2.9.7.. it's really inconvenient, to the point where I use the regular jodatime when not doing a release build.. ",
    "PetarMarijanovic": "I really like this library, but it's hard to use it without the sources :S Are there any updates on this issue?. ",
    "xbao": "As a workaround you can download the javadoc jar from http://central.maven.org/maven2/joda-time/joda-time/2.9.9/joda-time-2.9.9-no-tzdb-javadoc.jar, right click on the joda-time-2.9.9-no-tzdb-javadoc.jar library under External Libraries in Android Studio, click Library Properties and add the javadoc jar . ",
    "mazurio": "That's true, we are currently debating if to drop support for Froyo but there is around 4,000 active users from 2.2 only for us, which is why I ask. Moving from Joda to Joda-Android dropped memory usage quite a lot.\n. Also it looks like it can be easily moved to System.arraycopy:\nhttp://stackoverflow.com/questions/14723748/most-efficient-way-to-make-a-copy-of-a-large-array-in-java\n. So if joda-time is using the same library and I had no problems with it on Froyo I guess I am still free to try and just joda-android for API 8?\n. ",
    "Thorbear": "A dirty workaround for this could be to rewrite the method parsePatternTo() in DateTimeFormat to handle 'c' and 'L' as 'E' and 'M' respectively.\n. It will fail in the sense that whenever the returned formatter is used it will throw an IllegalArgumentException, because it doesn't recognize the formatting 'cccc'.\nAvoiding DateTimeFormatter might be a good suggestion for JodaTime usage on Android in general, but I feel this is something that should at least be pointed out in some release notes, since it all happens inside the library.\n. ",
    "ScottDennison": "Thanks.\nI should have thought to use an exclude, which I should have done!\nI added it in and presto, it works.\n. ",
    "sjvc": "Ok, thanks, I added the rule to proguard.\nIf I'm using gradle, it's enough using \"compile 'net.danlew:android.joda:2.7.0'\" or do I need to include the joda-time jar?\n. Ok. Thank you Daniel!\n. ",
    "HenryTimelessness": "It seemed that there was some syncing issues in android studio. Unchecking the option to work in offline mode and retrying a few more times allowed me to successfully resolve the dependency. Thanks!\n. ",
    "samuelba": "I somewhat solved it, not a very nice solution, but it seems to work\nI downloaded the joda-time-2.7.jar and included: -libraryjars libs/joda-time/joda-time-2.7.jar into the proguard-rules.pro\nstill I can't write JodaTimeAndroid.init(this); how it is adviced here (https://github.com/dlew/joda-time-android#usage), but the app seems to work how it should and it doesn't crash anymore.\nBut I'm sill interested in the way to solve this problem without such a hack.\n. dependencies {\n    compile 'net.danlew:android.joda:2.7.1'\n}\nthis is in my build.gradle\n. ",
    "hiBrianLee": "I am using proguard to minify but I'm not seeing the issue. Not sure if this will help, but here's my build.gradle and proguard settings:\ncompile 'net.danlew:android.joda:2.7.1'\ncompile('com.fasterxml.jackson.datatype:jackson-datatype-joda:2.4.4') {\n    exclude module: 'joda-time'\n}\ncompile 'org.joda:joda-convert:1.7'\n-dontwarn javax.xml.bind.DatatypeConverter\n-dontwarn org.joda.time.tz.ZoneInfoCompiler\nI have some extra stuff as I am using jackson databind.\n. > I'll just have to come up with some ProGuard details on the README I think.\n^ This is great. I wish all open source Android projects had this (and closed-source commercial third party libraries should definitely have it). Thank you.\n. @appmath In your unit test, are you initializing JodaTimeAndroid with JodaTimeAndroid.init(context)? Depending on how your unit test is set up, it may not be calling the JodaTimeAndroid.init() code in your Application. Initializing it in the beginning of the unit test fixes the resource not found problem, but it does lead to other issue:\njava.lang.NullPointerException\n    at java.io.FilterInputStream.close(FilterInputStream.java:181)\n    at net.danlew.android.joda.ResourceZoneInfoProvider.loadZoneInfoMap(ResourceZoneInfoProvider.java:170)\n    at net.danlew.android.joda.ResourceZoneInfoProvider.<init>(ResourceZoneInfoProvider.java:39)\n    at net.danlew.android.joda.JodaTimeAndroid.init(JodaTimeAndroid.java:39)\nI am using Robolectric 3.0 and passing context from RuntimeEnvironment.application as shown in https://github.com/robolectric/robolectric/wiki/2.4-to-3.0-Upgrade-Guide-(Draft)\nAny tips @dlew? You don't run into issues when running unit tests?\n. Are you talking about InstrumentationTestCase that connects to the emulator? I suppose it will work. I'm guessing it's something to do with Robolectric not picking up the right resources or something (for my case). I'll update once I find out more. I'd be interested in knowing what @appmath is running though, and whether calling JodaTimeAndroid.init(context) will fix the problem for him/her.\n. At least for me, found out it's an issue with Robolectric. When opening raw resources from library, it always returns null - https://github.com/robolectric/robolectric/issues/1430\nWonder if there's a need to use Robolectric anymore, now that Android has native unit test support on the JVM. I should try it out.\n. ",
    "Narthe": "Same issue here, used maven option, this is my build.gradle :\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.android.support:appcompat-v7:21.0.2'\n    compile 'net.danlew:android.joda:2.7.1'\n}\n. ",
    "brsengar": "Hi\nAny idea when this would be fixed. I have similar issues in my project.\nThanks\n. ",
    "vovkab": "Try this proguard config:\n```\nJoda Time\n-dontwarn org.joda.convert.\n-dontwarn org.joda.time.\n-keep class org.joda.time. { *; }\n-keep interface org.joda.time. { *; }\n```\n. ",
    "squeeish": "Does @vovkab's solution work for anybody? It doesn't work for me.\n. @Splaktar Yeap that's what I meant, building is fine but the app crashes still. I'm pretty new to Proguard and all this obsfucating stuff. Could anyone shed more light on this matter?\nBtw, I commented out JodaTimeAndroid.init(this); as per @saduino's suggestion and it works. Now, what is affected if I leave out JodaTimeAndroid.init(this);?\n. @dlew Gradle :)\n. ",
    "Splaktar": "Yes, the Proguard snippet here fixed this for me. Thank you!\nUpdate: While it fixed the build warnings, the app still crashes with \"Could not read ZoneInfoMap\" in release mode.\n. So I need to add compile 'org.joda:joda-convert:1.2' to my app to get it to stop crashing with joda-time-android 2.8? I tried just using compile 'net.danlew:android.joda:2.8.0' but it still crashes on some user's phones.\nCaused by: java.lang.RuntimeException: Could not read ZoneInfoMap\n   at net.danlew.android.joda.JodaTimeAndroid.init(JodaTimeAndroid.java:42)\n. Yep, it is really puzzling. It works on my Nexus 5 just fine, but another customer's Nexus 5 crashes the app every time I try to go to joda-time-android 2.7.1 or above :( I'm using Proguard, so I'll remove the temporary joda-convert include, thank you.\n. ",
    "ligi": "I just ran into the problem with 'net.danlew:android.joda:2.9.2' with several gradle clean assemble -> Install runs\n. I just activated proguard on this project (\nhttps://github.com/ligi/PassAndroid )\n. When I start the app build with the latest master I get:\n```\n02-18 19:21:17.953  1559 30180 I ActivityManager: Start proc 4226:org.ligi.passandroid/u0a68 for activity org.ligi.passandroid/.ui.PassListActivity\n02-18 19:21:17.991  4226  4226 W System  : ClassLoader referenced unknown path: /data/app/org.ligi.passandroid-1/lib/x86_64\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid: Failed to retrieve identifier: type=class net.danlew.android.joda.R$raw name=joda_zoneinfomap\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid: java.lang.NoSuchFieldException: joda_zoneinfomap\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at java.lang.Class.getField(Class.java:891)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at net.danlew.android.joda.ResUtils.a(SourceFile:105)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at net.danlew.android.joda.ResourceZoneInfoProvider.b(SourceFile:114)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at net.danlew.android.joda.ResourceZoneInfoProvider.(SourceFile:39)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at net.danlew.android.joda.JodaTimeAndroid.a(SourceFile:39)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at org.ligi.passandroid.App.onCreate(SourceFile:27)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1013)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4707)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.app.ActivityThread.-wrap1(ActivityThread.java)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.os.Handler.dispatchMessage(Handler.java:102)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.os.Looper.loop(Looper.java:148)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at android.app.ActivityThread.main(ActivityThread.java:5417)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at java.lang.reflect.Method.invoke(Native Method)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n02-18 19:21:17.995  4226  4226 E JodaTimeAndroid:   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n02-18 19:21:17.996  4226  4226 D AndroidRuntime: Shutting down VM\n02-18 19:21:17.996  4226  4226 E AndroidRuntime: FATAL EXCEPTION: main\n02-18 19:21:17.996  4226  4226 E AndroidRuntime: Process: org.ligi.passandroid, PID: 4226\n02-18 19:21:17.996  4226  4226 E AndroidRuntime: java.lang.RuntimeException: Unable to create application org.ligi.passandroid.App: java.lang.RuntimeException: Could not read ZoneInfoMap\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4710)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.app.ActivityThread.-wrap1(ActivityThread.java)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.os.Handler.dispatchMessage(Handler.java:102)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.os.Looper.loop(Looper.java:148)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.app.ActivityThread.main(ActivityThread.java:5417)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at java.lang.reflect.Method.invoke(Native Method)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime: Caused by: java.lang.RuntimeException: Could not read ZoneInfoMap\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at net.danlew.android.joda.JodaTimeAndroid.a(SourceFile:42)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at org.ligi.passandroid.App.onCreate(SourceFile:27)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1013)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4707)\n02-18 19:21:17.996  4226  4226 E AndroidRuntime:    ... 8 more\n02-18 19:21:17.996  1559 30347 W ActivityManager:   Force finishing activity org.ligi.passandroid/.ui.PassListActivity\n```\nleak-canary is no-op for release - these stubs should not make any problem with proguard - but I will care for this when there is a problem and I overcome the joda-time crash\nreleaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'\n. thanks!\n. ",
    "appmath": "Thanks @tigerpenguin for the suggestion but I am only unit testing the model/domain/business rules which have absolutely not dependency on Android which explains how I was able to copy and paste these classes and the unit tests (dependency on non-android Joda-Time) to an IntelliJ temp project and quickly run them without any issues.\n. ",
    "CDRussell": "Not sure if this comment will be picked up given this issue is closed, but the linked issues don't seem like the right place for the either.\nI'm in the same boat as @appmath in that I have pure model/domain/business rules which have no Android dependency, but do live inside the same project as my main android app.\nI already have a depdendency on joda-time-android for my app, but ideally would like a way of avoiding the java.io.IOException: Resource not found: \"org/joda/time/tz/data/ZoneInfoMap\" error during pure JUnit tests (not android instrumentation, not robolectric).\nIs the only solution to separate these into a separate Java-only module? or is there a way to override the android joda time with normal joda time for testing?\n. Using DateTimeZone.setProvider(new UTCProvider()); eliminates the logged exception for me too.\nWould it be an unthinkable horror to have a UTCProvider baked into the lib as a default? (I confess to not having looked at the source to know what the provider does).\nI guess that might not even be possible from this library's point of view if it is outside of the control of joda-time-android to let that happen. \n. > you may as well just use joda-time and skip joda-time-android\nThat's something I'm not sure how to do currently.\nMy unit tests are mainly for testing business logic. This business logic has no dependencies on Android, other than the use of JodaTime classes. I don't think I can selectively target JodaTime from joda-time vs from joda-time-android. It is when this business logic's use of JodaTime is hit, that the exception occurs.\nMy unit tests do not use JodaTime themselves, but they do execute production code which does. \nIn production app, the init method with an Android context is executed so there are no problems there by the time the business logic is hit.\nIn the unit tests, there is no opportunity to call init with Android context, as I don't have (and hopefully don't need) any Android dependency for them to work.\nJust to be clear, I'm not seeing any problems which actually blocks me right now. I do see the exception being logged, but I can ignore that happily enough. I'm just not sure if it might cause strange problems under the hood by ignoring it.\nAny of that make sense? \ud83d\ude04 \n. > I need a reproduction because we're already doing the same thing as you but not running into problems.\nI understand. Clocking off for the week now, but will either get you a sample project with the problem or I'll work out what I've done wrong in the process. Either way, I'll come back to you next week.\nThanks.\n. > when Joda catches the exception and logs the stacktrace, it then immediately calls DateTimeZone.setProvider(new UTCProvider());\nCheers @vaughandroid, that's good to know! \n. I created a very simple project https://github.com/CDRussell/JodaTimeUnitTesting which shows one way of fixing the problem. This solution, as suggested by @dlew, seems to work for me and uses the following dependencies:\ncompile 'net.danlew:android.joda:2.9.4.1'\ntestCompile 'junit:junit:4.12'\ntestCompile \"joda-time:joda-time:2.9.4\"\nBy listing the testCompile on joda-time and not android-joda-time the exception isn't logged. If I comment out the second testCompile line it does show the exception again.\nI'll investigate later if I still have the issue on my real project I'm working on, but for now, I think this solution is good. That is to say @vaughandroid I'm not seeing your reported issue on this sample app, so I'm not sure what's going on there for you.\n. ",
    "legarspol": "Same problem here. We can't create DateTime object while doing pure unit testing as we don't have any context to initialize JodaTime with...\nI'm avoiding the problem by replacing DateTime instances with null for now but stop me from testing if model survive parceling and so on.\n. ",
    "victorhurdugaci": "@dlew probably trivial question but how do you include joda-time just for testing?\n. ",
    "imminent": "So, testCompile doesn't resolve the  crash for me in standard JUnit tests. I've tried something like this even:\ndebugCompile 'net.danlew:android.joda:2.8.1'\nreleaseCompile 'net.danlew:android.joda:2.8.1'\ntestCompile 'joda-time:joda-time:2.8.1'\nIn the past I avoided this by only using UTC and DateTimeZone.forOffset(), but it looks like the DateTimeFormatter.print\nI avoided the crash by setting DateTimeZone.setDefault() to an explicit timezone, such as UTC.\n. ",
    "ymka": "I've resolved \"java.io.IOException: Resource not found: \"org/joda/time/tz/data/ZoneInfoMap\"\" next way:\njava\n@Before\npublic void prepareBeforeTests() {\n    Context context = mock(Context.class);\n    Context appContext = mock(Context.class);\n    Resources resources = mock(Resources.class);\n    when(resources.openRawResource(anyInt())).thenReturn(mock(InputStream.class));\n    when(appContext.getResources()).thenReturn(resources);\n    when(context.getApplicationContext()).thenReturn(appContext);\n    JodaTimeAndroid.init(context);\n}\nDoes it resolve your issues?\n. ",
    "tasomaniac": "Oh really really sorry. It is a really basic mistake.\nBut somehow even I saw that part, I just copied Gradle dependency line and\ndirectly went to Android Studio. Maybe you should write this initialization\nbefore that.\nOn Wed, Feb 25, 2015, 12:03 AM Daniel Lew notifications@github.com wrote:\n\nDid you make sure to call JodaTimeAndroid.init() at some point?\nCheck out usage: https://github.com/dlew/joda-time-android#usage\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/dlew/joda-time-android/issues/38#issuecomment-75856530\n.\n. \n",
    "jondwillis": "@dlew I suspected that as well and removed static references to DateTime. This turned out to be a separate issue with Ion though.\n. ",
    "firetrap": "Sorry i've checked your source and everything is at it should, it was a bug in another lib which is using JodaTimeAndroid who tricked me.\nSorry and sincere apologies for opening an issue without any issue at all ;)  keep the good work \n. ",
    "AndwareSsj": "I also use eclipse\n. ",
    "yjukaku": "So do I :+1: \n. ",
    "pimato": "good decision, and thanks for the good work :+1: \n. ",
    "josefrvaldes": "I've made some changes and I've been the whole morning without issues.. But one of the changes I did was to downgrade from 2.7.2 to 2.7.1.\nI can't really afirm that it have been the downgrade what have fix the problem because I made several changes, but what I'll do is to go back to 2.7.2 and see if the error happens again, and then, I will let you know.. ok?\nThank you very much for your work!\n. Ok, I will upgrade then to the last version and I will let you know if it crashes again.\n. Ok, I've been testing it for several days and it haven't failed again, so I think it was my fault because I was doing something wrong or something. I will close this issue now.\nThank you very much for your help!\n. ",
    "jlelse": "Same problem here\n. ",
    "rhinon": "I'm semi-trapped by this as I'm trying to integrate the new google services for GCM and it's forcing me to use gradle 1.3 (https://developers.google.com/cloud-messaging/android/client).\nWish the old docs for gcm were still up.\n. ",
    "gfx": "Thanks. No problem ;)\n. ",
    "fnk0": "Sorry. This was fixed on 2.8. \n. ",
    "marlonbosse": "The same actually, I use JodaTimeAndroid.init(this); in onCreate of my Application extending Class.\nAny ideas?\n. Okay i got it, I had to add multiDexEnabled true and only tested on Lollipop Devices, when using multiDex on  pre 5.0 you have to add compile 'com.android.support:multidex:1.0.0' and make your Application class extend MultiDexApplication.\nI'm kinda curious why thats not shown in any of the logs, but because of the limit, every external library over the limit wasn't working anymore.\nThanks\n. ",
    "aviadmini": "Unfortunately only seeing crashes reported. \n. ",
    "OlekBodashko": "I had the same error:\nFatal Exception: java.lang.RuntimeException\nUnable to create application com.example.app.MyApplication: android.content.res.Resources$NotFoundException: File res/raw/__tzdata_zoneinfomap from drawable resource ID #0x7f0701cb\nCaused by java.io.FileNotFoundException\nandroid.content.res.AssetManager.openNonAssetNative (AssetManager.java)\nandroid.content.res.Resources.openRawResource (Resources.java:940)\nnet.danlew.android.joda.ResourceZoneInfoProvider.a (SourceFile:120)\nnet.danlew.android.joda.ResourceZoneInfoProvider.<init> (SourceFile:39)\nnet.danlew.android.joda.JodaTimeAndroid.a (SourceFile:39)\ncom.example.app.MyApplication: .onCreate (SourceFile:85)\nandroid.app.Instrumentation.callApplicationOnCreate (Instrumentation.java:1000)\nandroid.app.ActivityThread.handleBindApplication (ActivityThread.java:4566)\nandroid.app.ActivityThread.access$1300 (ActivityThread.java:156)\nandroid.app.ActivityThread$H.handleMessage (ActivityThread.java:1400)\nandroid.os.Looper.loop (Looper.java:153)\nandroid.app.ActivityThread.main (ActivityThread.java:5297)\njava.lang.reflect.Method.invokeNative (Method.java)\ndalvik.system.NativeStart.main (NativeStart.java)\nI use joda-time v2.7.2.  Please check this line of the code to see what can cause this error:\nnet.danlew.android.joda.ResourceZoneInfoProvider.a (SourceFile:120)\n. Just can see it in crash logs. It's a rare crash but it happens.\n. ",
    "KrzychuJedi": "I didn't notice that github remove all brackets from my post... I use standard maven syntax. I just add dependency to pom same as others libraries. I use intellij with maven integration and it show me that he add to libaries  joda-time:2.6 and joda-time:no-tzdb:2.8.1 and coudn't download android.joda\n. ",
    "OliviaLiao": "Because if I use Long.MAX_VALUE, like DateTime minTime = new DateTime(Long.MAX_VALUE); I will have a error message: org.joda.time.IllegalFieldValueException: Value 292278994 for year must be in the range [-292275054,292278993]\n. ",
    "fred8": "Just check and no dependencies on it. The problem is: it seems to refer to that dependency but the dependency cannot be resolve.\n. Unfortunately I'm not able to provide a sample app or the source of the app. However, here is our proguard config -- note that the version 2.8.0 perfectly compile / runs with it.\nI double checked, none of our deps are using guava.\n-keep class org.joda.* { ; }\n-dontwarn javax.xml.bind.DatatypeConverter\n-dontwarn org.joda.time.tz.ZoneInfoCompiler\n. Same here. But proguard fail. Anyway, thank you very much for taking the time to dig around that. I'll continue to investigate.\n. Your library used to have a dependency on joda-convert and we used to add joda-convert in our code to avoid a proguard issue. When we updated your lib to the last version, we also updated joda-convert which need guava. That's the all reason of the story. -> CLOSED\n. ",
    "ch4vi": "I solved with a mix from Android DateUtils and JodaTime Dateutils. I needed automatic translation:\n``` java\n        //DATE Android DateUtils\n        String s = DateUtils.getRelativeDateTimeString(getGlobalApplicationContext(),c.getTimeInMillis(),\n                DateUtils.DAY_IN_MILLIS,DateUtils.WEEK_IN_MILLIS, flags).toString();\n    String[] datetime = s.split(\",\");\n    String date = datetime[0];\n\n    //TIME JodaTime DateUtils\n    Calendar cc = Calendar.getInstance();\n    cc.set(Calendar.HOUR_OF_DAY, c.get(Calendar.HOUR_OF_DAY));\n    cc.set(Calendar.MINUTE, c.get(Calendar.MINUTE));\n    DateTime dt = new DateTime(cc.getTimeInMillis());\n    String time = net.danlew.android.joda.DateUtils.getRelativeTimeSpanString(getGlobalApplicationContext(), dt, true).toString();\n\n    return date+ \", \" + time;\n\n```\n. ",
    "hamen": "I see. Well, I had a problem similar to issues #32 and #36 and I thought it could be useful for others to know how it could be fixed. It could be considered a hint.\n. ",
    "SimonRolin": "We have already tried that many times.\nOne precision, this happen on samsung devices (S4 mini and Tab 3).\n. For those searching how to use legacy multidex,  http://developer.android.com/reference/android/support/multidex/MultiDexApplication.html\n. ",
    "theyann": "Indeed it worked when using legacy multidex. Thanks for pointing this out Dan.\n. ",
    "benkc": "Alright, I've hacked together something that seems to work -- it's putting ~477 files with names like \"joda_america_indiana_indianapolis\" in an output dir and sucking them into R.raw, and I'm seeing up-to-date timezone data when I build my app against that.  :)  And yeah, it took basically recreating the compileTzData stuff.\nAdding a BUCK build file would only be useful to anyone else who tries to use joda-time-android with BUCK, of course.  That may well be just us.  shrug\nThanks for the help!\n. Hi @felipecsl, sorry for the slow reply, I missed the email.\nIn case you still need it, I'm attaching my BUCK file for jodatime_android.  You'll have to scrub it for a couple references to our build_helper and remove_logs stuff, but other than that it should be usable as-is.\nHopefully this attachment works!\nEDIT: I was missing a file, I'd forgotten that I'd also written a custom Java class for this task.  Updated zip file has that included.\nBUCK.zip\n. Interesting, thanks!\nMy first attachment was missing a file, I've edited that for any future visitors to this thread.\n. ",
    "felipecsl": "i just ran into this problem as well. @benkc do you mind sharing your workaround? thanks!\n. @benkc thanks a lot for sharing we ended up using another workaround, which is to keep a fake class around that holds a reference to the R.raw fields accessed via reflection. I think you could also use this solution to keep them\n. ",
    "Jai-Jiks": "Getting same error. Anyone solution than please post.\n. ",
    "K0bin": "It is an emulator set to automatic. http://i.imgur.com/ZW5oieU.png\n. ",
    "murgo": "This is happening to me also. DateTime.now().getZone() returns UTC, I'm in Finland (so UTC+2). Also DateTimeZone.getDefault() returns UTC. Values are from IntelliJ IDEA debugger debugging real device, Samsung Note 4.\nI spent long time trying to figure out, why new DateTime().withHours(0) would change the date. Turns out it interpreted my new DateTime() of 01:00 (+2) as 23:00 (UTC) of the previous day, so the withHours acted little unpredictably.\n. Seems to give Europe/Helsinki as expected.\nlibcore.util.ZoneInfo[id=\"Europe/Helsinki\",mRawOffset=7200000,mEarliestRawOffset=7200000,mUseDst=true,mDstSavings=3600000,transitions=117]\n. Doh, the JodaTimeAndroid.init(context); makes all the difference. Too bad I didn't notice it 3 hours ago. Maybe the library could throw some kind of exception if it hasn't been initialized?\nFor me, this issue is fixed now.\n. ",
    "IvanLopezCarreira": "Yes. I use these version and initialize the library in Application onCreate(). The exception is catched in library, app is not breaking.\n. ",
    "zagum": "'net.danlew:android.joda:2.9.1' to  'net.danlew:android.joda:2.9.2'\n. Sorry, had problems in my project\n. ",
    "Sutirth": "@dlew Yep done the same for resolving the issue.Just was curious what exactly causes the issue\n. ",
    "nicdutil": "I did a new sample project using studio and it does grab \nthe correct timezone on the first install. \nNot sure what the difference is yet between my toy project and other one i'm working on.\nI'm installing the apks in the same way: as a debug build from studio. \n. Yes. That was it ! \nFrom the android doc:\npublic void onCreate ()\nCalled when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created.\nI didn't read that line carefully. I have a content provider which will create a database (and a table with some initial data) upon installing the apk for the first time.  I used a LocalTime object to populate one of the field of that table. \nMoving JodaTimeAndroid.init to the onCreate callback of the content provider did the trick.\nMight be good to add a footnote to your suggestion of where to put JodaTimeAndroid.init in your README.md file in case people have content providers in their app. \n. Thanks!\n. ",
    "meierjan": "Wondering why this is not working for 2.9.2 but anyway...\nI would welcome it to see the method-count in the Readme.md as 5k methods is really heavy and new android developers don't know about the 65k issue.\nThere is the fancy Badge @ methodscount.com:\n\nIf you agree I can provide a pull-request.\n. ",
    "ypresto": "Ah, sorry, we are testing pure-java classes IN Android application module. Not a independent library.\n. > Usually people just include the plain joda-time dependency for unit tests,\nPerhaps I was misunderstanding, did you mean something like below?\ngroovy\ndependencies {\n    compile 'net.danlew:android.joda:2.9.3'\n    testCompile 'joda-time:joda-time:2.9.3'\n}\n(There is similar question and solution on ThreeTenABP repo. https://github.com/JakeWharton/ThreeTenABP/issues/14#issuecomment-142049959 )\n. https://github.com/dlew/joda-time-android/issues/17#issuecomment-166010051\nOmg there was same Q&A here... I'm sorry for duplicated issue :sob: Thanks for replies..!\n. ",
    "nassendelft": "Doing some more digging i came across an exception: \n java.io.IOException: Resource not found: \"org/joda/time/tz/data/ZoneInfoMap\"\nI think this is causing the difference.\nThe reason it was working before restart is that particular code that triggers this is not called until i have my user logged in.\nI'm storing a DateTime object and reading it on startup. This is failing with that exception. I think this is the cause for the incorrect data. I'm investigating that exception now.\n. yep, so.... i had a silent crash on start up. It was trying to use the lib before it was initialised :(\n. ",
    "chibatching": "Hi, do you have the plan to merge this PR and release new version with new tzdata?\n. ",
    "zincle": "@dlew My apk size is increased with these localised files, is there any way I can exclude them from library, without using your library as module (currently using as implementation via gradle). Yeah my bad! I am already using mimifyEnabled and shrinkResources, I actually meant the timezone data strings, not the localized strings, but as you mentioned it is necessary component, so cant be detached from library, thanks.. ",
    "deinlandel": "Looks like other languages also might be affected, depending on their grammar rules. as far as I can see, number \"1\" is hardcoded for quantity=\"one\"  in many translations.\n. Fixed version of russian translation\n. ",
    "MenoData": "This concerns French, too. For example, French zero uses singular, not plural.\nAnd I also see another problem: If someone wants full text then there are often abbreviations only (for example the Russian word for \"minutes\" is only written as \"\u043c\u0438\u043d.\"). Maybe this problem is inherited from Android-DateUtils where they tried to circumvent the fact that many languages (for example most Slavish languages or Arabic) have more than only one plural form.\nLibraries with much better i18n-support are ICU4J and my lib Time4A which don't show these symptoms. The whole thing seems to be inherited from Android. Several people have complained about in the past, see also https://code.google.com/p/android/issues/detail?id=8287. Newer Android versions might have solved the problem however, see also https://developer.android.com/guide/topics/resources/string-resource.html#Plurals\n. I have now done some research. A newer version (see https://github.com/android/platform_frameworks_base/blob/4535e11fb7010f2b104d3f8b3954407b9f330e0f/core/res/res/values-ru/strings.xml) has this content:\n843     <plurals name=\"duration_minutes\" formatted=\"false\" msgid=\"643786953939956125\"> \n844       <item quantity=\"one\"><xliff:g id=\"COUNT\">%d</xliff:g> \u043c\u0438\u043d\u0443\u0442\u0430</item> \n845       <item quantity=\"few\"><xliff:g id=\"COUNT\">%d</xliff:g> \u043c\u0438\u043d\u0443\u0442\u044b</item> \n846       <item quantity=\"many\"><xliff:g id=\"COUNT\">%d</xliff:g> \u043c\u0438\u043d\u0443\u0442</item> \n847       <item quantity=\"other\"><xliff:g id=\"COUNT\">%d</xliff:g> \u043c\u0438\u043d\u0443\u0442</item> \n848     </plurals>\nSo it seems a solution for your problem is just updating all relevant resources and your adaptation of class android.text.format.DateUtils to the newest version.\n. If you want to convert other time zones like zones with a fixed offset or otherwise explicitly specified zone id (as in your test case) then such code can best be rewritten as:\njava\nDateTimeZone dtz = DateTimeZone.forID(\"+08:00\");\nSee also http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeZone.html#forID-java.lang.String-\nfor valid inputs of DateTimeZone.forID(...) This link also proves that the observed behaviour is NOT a bug but just a feature limitation. Personally, I think that this limitation is justified because zone identifiers should never be localized so apps have to find other ways to circumvent such problems.\nOtherwise, if you want to convert the system time zone then you have really a problem because you don't know the zone id at compile time. One time I have also struggled with such a strange situation where Android does not use stable non-localized identifiers and fortunately solved it in my own time library Time4A, see https://github.com/MenoData/Time4J/issues/463 . However, Joda-Time cannot handle this situation at all.\nMy recommendation in context of Joda-Time: Try first to parse the identifier yourself. If you find arabic digits then transform it to ASCII western digits before doing the conversion above. I know this is only an incomplete workaround which does not cover all strange scenarios but is at least a partial solution.\n. I have experienced the same problem when using an independent timezone database. So what is still the same (reasonable expectation) is the local time on both devices with user-workaround or devices with up-to-date timezone database in OS. This has caused me to offer a new API-method in my own time library Time4A, see: http://time4j.net/javadoc-en/net/time4j/SystemClock.html#inPlatformView--. @feinstein I am not sure that you are aware of the fact that ThreetenABP and Joda-Time-Android are both wrappers around two different libraries and APIs. ThreetenABP encapsules the backport of Threeten-project which is closely (but not exactly) related to JSR-310. But Joda-Time-Android is a wrapper around Joda-Time which is completely different from JSR-310 or the Threeten-project (although the primary developer of both libraries is indeed the same person).. @feinstein Okay, but which problem do you try to solve? You say you want to implement JSR-310 on old devices. If so then why not use ThreetenABP? What does prevent you from using that almost-jsr-310-implementation (adapted for Android)? Is the minimum compatibility level of ThreetenABP too high for you? Then you might consider a fork of ThreetenABP.\nI am just curious because I am also developing and distributing my own time library looking for possible enhancements.. Your code contains a bug. Generally you should not recalculate the expression LocalDateTime.now() multiple times but cache the first calculated now-timestamp.\nIn your example using the first line to determine the delta, fiveDaysAgo is slightly earlier than just 5 * 24 hours ago because you have based it on a later now-date, hence the delta is reduced by one day showing four instead of five days.. ",
    "i-sourabh": "thanks @dlew  one strange thing is no error comes for versions 4.4 or 5.0 , comes only for Api level 14 (4.0) \n. ",
    "jonatbergn": "Should be fixed with #138 \n. Ah, saw that to late. I updated the readme to only reference the data source now.\n. ",
    "dalewking": "Started to put it there but was scared away by the text saying basically that joda time is no longer necessary due to Java 8\n. Moved\n. This has been fixed in 2.9.6 of joda time. Can you update this version of the library to include that?\n. ",
    "vaughandroid": "I've just been pointed to a workaround, which is to call DateTimeZone.setProvider(new UTCProvider()); as part of the test setup. This fixes the issue, but might be fixing the symptom rather than the cause? It does seem more straightforward and than the compile/testCompile workaround.\nPerhaps worth mentioning something in the README?\n. For what it's worth, I've created a gist with a JUnit4 TestRule with the workaround here: https://gist.github.com/vaughandroid/99ce457e62f74ad9be2f794f014e3c8d\n. Thanks for the response. I'll see if I can put together a sample project to demonstrate the issue. Current project has about 30 dependencies, which doesn't help with diagnosing this kind of problem!\n. @CDRussell: Just FYI, when Joda catches the exception and logs the stacktrace, it then immediately calls DateTimeZone.setProvider(new UTCProvider());. So, you shouldn't see any issues from ignoring the exception - I just think it's worth having the workaround in order to stop the noise from stderr.\nRe. a sample project, I've a deadline early next week but if will hopefully get chance to look at setting up a sample project once that's passed, if @CDRussell doesn't get there first. :)\n. ",
    "Mithrandir21": "Than your Gradle is doing something my Gradle is not doing.\n. You are correct in assuming that JodaTime is a dependency of this library, as seen in the Gradle Dependencies check:\n\\--- net.danlew:android.joda:2.9.4.1\n \\--- joda-time:joda-time:2.9.4\nBut still can't manage to import anything from the Joda packages, like DateTime, DateTimeZone, etc.\nCould there be any other issues preventing JodaTime?\n. I understand.\nI will continue looking into to it as you suggest. Thank you for indulging me this far.\n. ",
    "diegoRodriguezAguila": "Indeed,  I'm initializing it in the application's onCreate as required in the docs \n. I have managed to fix it. The problem was in the serialization,  not in GSON but in Kyro. As I'm using PaperDb as a \"cach\u00e9\" for the web service results, and It uses Kyro serialization to save the objects.\nIt didn't threw any serialization exception, so I thought it was fine, later I found out it requires a JodaTimeSerializer to be set up, which they also provide.\nEverything is working fine now, sorry for the misleading issue.\n. @Dosssik I don't have the specific serializer right now, but you may just implement a kyro serializer for joda datetime objects, for instance, this is a kyro serializer for uris: https://github.com/diegoRodriguezAguila/SGAM.Elfec.Mobile/blob/master/app/src/main/java/com/elfec/sgam/local_storage/serializers/KryoUriSerializer.java\nIt uses the base type serialized as a string, for dates if highly recommended to serialize them to double type (milis). @Dosssik No need to do that, as Paper uses Kyro underhood, so you just add your serializer to Kyro directly.. ",
    "Dosssik": "@diegoRodriguezAguila Hi! I've got exactly same issue - we persist DateTime in PaperDb. May i ask you, how did u overcome this problem?. @diegoRodriguezAguila wow, thanks a lot! But is it possible to set my \"custom\" serializer for DataTime deserialization from Paper?. ",
    "p-fischer": "Yep, I see.\nHowever, in my scenario the developer using my lib sees DateTime is available and thinks he can use it right away. Is there a way I can ensure JodaTimeAndroid.init(this); has been called before my library is getting initialized in the app?. Sounds reasonables. Developers are clever people after all :). ",
    "reline": "joda-time 2.9.7 was just released :). ",
    "greuff": "I think this can be closed now.. ",
    "metinkale38": "Thank you, i will try that...\nBut why does DateTimeZone.setDefault(DateTimeZone.forTimeZone(TimeZone.getDefault())); not work?\nShould'nt it set the Phones Timezone to Joda?. if somebody needs it, my code is below, everybody can use it freely...\nit simply wraps androids TimeZone Objects with an Joda compatible DateTimeZone Object.\n@dlew i dont know how you want it to be, but i think it would'nt be a bad idea to have this as default (or atleast as an option) in your library. problems like i had can be quite confusing and it is normally expected to have the same time on  the phone and in the app...\n```\nimport android.util.ArraySet;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.tz.Provider;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Field;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.TimeZone;\n/*\n * Created by metin on 13.02.2017.\n /\npublic class AndroidTimeZoneProvider implements Provider {\n    private HashMap> cache = new HashMap<>();\npublic AndroidTimeZoneProvider() {\n\n}\n\n@Override\npublic DateTimeZone getZone(String id) {\n    if (id.equals(\"UTC\")) return DateTimeZone.UTC;\n    WeakReference<DateTimeZone> wr = cache.get(id);\n    if (wr != null) {\n        DateTimeZone dtz = wr.get();\n        if (dtz != null) return dtz;\n    }\n    TimeZone tz = TimeZone.getTimeZone(id);\n    DateTimeZone dtz = new MyDateTimeZone(id, tz);\n    cache.put(id, new WeakReference<>(dtz));\n    return dtz;\n}\n\n@Override\npublic Set<String> getAvailableIDs() {\n    ArraySet<String> set = new ArraySet<>();\n    Collections.addAll(set, TimeZone.getAvailableIDs());\n    return set;\n\n}\n\n\nprivate class MyDateTimeZone extends DateTimeZone {\n    private TimeZone tz;\n    private long[] transitions = new long[0];\n\n    MyDateTimeZone(String id, TimeZone tz) {\n        super(id);\n        this.tz = tz;\n\n        try {\n            Field f = tz.getClass().getDeclaredField(\"mTransitions\");\n            f.setAccessible(true);\n            long[] transitions = (long[]) f.get(tz);\n            if (transitions == null) return;\n            this.transitions = new long[transitions.length];\n            System.arraycopy(transitions, 0, this.transitions, 0, transitions.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String getNameKey(long l) {\n        return null;\n    }\n\n    @Override\n    public int getOffset(long l) {\n        return tz.getOffset(System.currentTimeMillis());\n    }\n\n    @Override\n    public int getStandardOffset(long l) {\n        return tz.getRawOffset();\n    }\n\n    @Override\n    public boolean isFixed() {\n        return !tz.useDaylightTime();\n    }\n\n    @Override\n    public long nextTransition(long l) {\n        int i = 0;\n        long time = System.currentTimeMillis() / 1000;\n        while (i < transitions.length && transitions[i] < time) {\n            i++;\n        }\n        return i >= transitions.length ? 0 : transitions[i];\n    }\n\n    @Override\n    public long previousTransition(long l) {\n        int i = -1;\n        long time = System.currentTimeMillis() / 1000;\n        while (i + 1 < transitions.length && transitions[i + 1] < time) {\n            i++;\n        }\n        return i >= 0 && i >= transitions.length ? 0 : transitions[i];\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof MyDateTimeZone)) return false;\n        return ((MyDateTimeZone) o).getID().equals(getID());\n    }\n}\n\n}\n```\n. yes, i do.\nbut lot's of people directly use this library, because the other one does not directly work, and can't see the issues, which might appear in other countries/devices.\nit's not a problem for me, it is only a suggestion, because i saw a few more people complaining about that (e.g. on StackOverflow)\nif you do not want that, you can just close this ticket... . ",
    "liminal": "android-joda is just 'joda-time:joda-time:2.9.6:no-tzdb'. with an android wrapper. Try using that dependency in the pure java module (maybe as a 'provided' dependency, I'm not 100% on this) and you should be all good.. Clarification:\nIn the app module you declare the dependency on joda-time-android\napp/build.gradle:\n```\napply plugin: 'com.android.application'\nandroid {\n...\n}\ndependencies {\n        compile 'net.danlew:android.joda:2.9.6'\n}\nAnd in the java library you declare that all the classes in joda-time will be available at run time basically.\nlib/build.gradle:\napply plugin: 'java'\ndependencies {\n     provided 'joda-time:joda-time:2.9.6:no-tzdb'\n}\n```\nsince joda-time is pure java the library won't complain and since joda-time-android pulls in those classes they will actually be available to the app.. ",
    "georgikoemdzhiev": "Hi! Yes, it does compile fine. However, Android Studio seems to be not able to recognize the library so it can do the necessary imports. I have to mention that at very first compile (first use of the library) everything was fine. However, since I have had removed the library from the gradle file > synced it a couple of items (I was not sure if I wanted to use it) it came to the above mentioned stage. . Yes, and then I added it again. When I tried to sync Gradle files it was not able to recognise Joda library classes. Anyway, if that has not happened before, it is probably something on my system. I will close the issue now. . ",
    "artem-zinnatullin": "At least you did not copy-paste changelog with 2016 year as I did for 3 moths haha. ",
    "southerton81": "Sorry, this was due to the fact that I forgot to place\nJodaTimeAndroid.init(this);\ninto Application.onCreate().. ",
    "tygalive": "I am using this library and I wanted to add a copyright notice showing the\nyear it was licensed as well as the person it is licensed to, as is\nrequired by an Apache License\nCopyright [yyyy] [name of copyright owner]\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\nOn Apr 10, 2017 8:43 PM, \"Daniel Lew\" notifications@github.com wrote:\n\nGonna need some more clarification on what you want and why it is\nnecessary.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/dlew/joda-time-android/issues/178#issuecomment-293041596,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ASoA-87EHB7Vh0692-O4Vqqd9OSalXBVks5rung6gaJpZM4M3ye9\n.\n. \n",
    "slimeradio": "I mean maybe you should rise exception? Its not normal behavior and finding this bug took a lot of time for me. . ",
    "mstevens83": "Oh you're right, thanks!. ",
    "MiralDesai": "Ah, shouldn't have expected it then. Fair enough. Must have got confused with the Java 8 APIs. ",
    "NirpE": "Hi, I checked the APK raw resources. All look to be fine. Can the OS do something weird here like rename those resources when the app is installed?\n\n. You are not the only one being lost with this issue \ud83d\udc4d . ",
    "serhii-pokrovskyi": "sorry, i'v found the error:\ni use library - https://github.com/anjlab/android-inapp-billing-v3\nit updated, and stated to use\ncompile 'joda-time:joda-time:2.9.9'\ni cant figure out what to do here =(\n. ",
    "TakWolf": "This library is a version of Joda-Time built with Android in mind.\nAbout Joda-Time api, see https://github.com/JodaOrg/joda-time.\nOthers, see this project's readme.\n . ",
    "AndroidDeveloperLB": "I noticed though that for samples on Joda, it works without initialization of the context.\nSo, in which cases does it use the Context?. I don't understand. You mean that if I don't initialize it with Context, it is loaded from Jar?\nThat there is a difference between this:\n    DateTime dt = new DateTime();\n\nand this:\n    JodaTimeAndroid.init(this);\n    DateTime dt = new DateTime();\n\n?. I don't understand. So the first snippet uses the JAR ? \nIf it's so needed, why not throw an exception? Or require a parameter?. ",
    "zezekalo": "Hmmm, but LocalTime-class  has the constructor which includes DateTimeZone parameter. If it means that LocalTime don't care about timezone then why it has DateTimeZone argument?\nMy idea is having normalized time, which doesn't depend on timezones and has no date. But I'd like to convert this normalized time to time of my device timezone.\nP.S. After a little investigation I tend to think that my case is an issue of MIUI 8 of Xiaomi. And it happens when I switch on 'Automatic time zone' in settings.. Yeah, thanks for your help, I think that this is what I want. But when I changed code to your advice then the time difference on my device is still present((\ntext.add(\"LocalTime, local time (device timezone) - \"\n                  + new LocalTime(millis, DateTimeZone.getDefault()).toDateTimeToday());\n\n. At the screenshot above I switched on 'Automatic time zone' and I gave 'timezone' from my internet provider.\nYes, my real timezone is \"Europe/Kyiv\"\nBut when I switched off 'Automatic time zone' and selected manually 'Europe/Kyev' I found  such result:\n\nBucarest? )) Chinese is such Chinese)). Hmmm, why do other time-applications work well in such case?)). ",
    "jaanmurumets": "We in app get time with timezone info from android.\nThat function on joda which crashes is not called from our app but during some deserialization.\nLonger stack\njava.lang.RuntimeException: \nat android.app.ActivityThread.performLaunchActivity (ActivityThread.java:3253)\nat android.app.ActivityThread.handleLaunchActivity (ActivityThread.java:3349)\nat android.app.ActivityThread.access$1100 (ActivityThread.java:221)\nat android.app.ActivityThread$H.handleMessage (ActivityThread.java:1794)\nat android.os.Handler.dispatchMessage (Handler.java:102)\nat android.os.Looper.loop (Looper.java:158)\nat android.app.ActivityThread.main (ActivityThread.java:7224)\nat java.lang.reflect.Method.invoke (Native Method)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:1230)\nat com.android.internal.os.ZygoteInit.main (ZygoteInit.java:1120)\nCaused by: java.lang.IllegalArgumentException: \nat org.joda.time.DateTimeZone.forID (DateTimeZone.java:229)\nat org.joda.time.DateTimeZone$Stub.readResolve (DateTimeZone.java:1314)\nat java.lang.reflect.Method.invoke (Native Method)\nat java.io.ObjectInputStream.readNewObject (ObjectInputStream.java:1849)\nat java.io.ObjectInputStream.readNonPrimitiveContent (ObjectInputStream.java:761)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1983)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1940)\nat org.joda.time.chrono.ISOChronology$Stub.readObject (ISOChronology.java:228)\nat java.lang.reflect.Method.invoke (Native Method)\nat java.io.ObjectInputStream.readObjectForClass (ObjectInputStream.java:1330)\nat java.io.ObjectInputStream.readHierarchy (ObjectInputStream.java:1242)\nat java.io.ObjectInputStream.readNewObject (ObjectInputStream.java:1835)\nat java.io.ObjectInputStream.readNonPrimitiveContent (ObjectInputStream.java:761)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1983)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1940)\nat java.io.ObjectInputStream.readFieldValues (ObjectInputStream.java:1113)\nat java.io.ObjectInputStream.defaultReadObject (ObjectInputStream.java:454)\nat java.io.ObjectInputStream.readObjectForClass (ObjectInputStream.java:1345)\nat java.io.ObjectInputStream.readHierarchy (ObjectInputStream.java:1242)\nat java.io.ObjectInputStream.readNewObject (ObjectInputStream.java:1835)\nat java.io.ObjectInputStream.readNonPrimitiveContent (ObjectInputStream.java:761)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1983)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1940)\nat java.io.ObjectInputStream.readFieldValues (ObjectInputStream.java:1113)\nat java.io.ObjectInputStream.defaultReadObject (ObjectInputStream.java:454)\nat java.io.ObjectInputStream.readObjectForClass (ObjectInputStream.java:1345)\nat java.io.ObjectInputStream.readHierarchy (ObjectInputStream.java:1242)\nat java.io.ObjectInputStream.readNewObject (ObjectInputStream.java:1835)\nat java.io.ObjectInputStream.readNonPrimitiveContent (ObjectInputStream.java:761)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1983)\nat java.io.ObjectInputStream.readObject (ObjectInputStream.java:1940)\nat android.os.Parcel.readSerializable (Parcel.java:2506)\nat android.os.Parcel.readValue (Parcel.java:2315)\nat android.os.Parcel.readArrayMapInternal (Parcel.java:2614)\nat android.os.BaseBundle.unparcel (BaseBundle.java:221)\nat android.os.BaseBundle.getBoolean (BaseBundle.java:659)\nat android.content.Intent.getBooleanExtra (Intent.java:6049)\nat com.my.package.TransactionActivity.onCreate (TransactionActivity.java:160)\nat android.app.Activity.performCreate (Activity.java:6876)\nat android.app.Instrumentation.callActivityOnCreate (Instrumentation.java:1135)\nat android.app.ActivityThread.performLaunchActivity (ActivityThread.java:3206). We have Transaction class with DateTime field:\n```\npublic class Transaction {\n    private DateTime validUntil;\nTransaction(int seconds) {\n    validUntil = new DateTime().plusSeconds(seconds);\n}\n\n}\n```\nIn Android service, we create new Transaction object, start new activity and send this object with intent. Additionally we send a boolean value:\nTransaction transaction = new Transaction(60);\nIntent intent = new Intent(this, TransactionActivity.class);\nintent.putExtra(\"transaction\", transaction);\nintent.putExtra(\"booleanValue\", true);\nstartActivity(intent);\nIn TransactionActivity we read the boolean value and app crashes on some devices:\ngetIntent().getBooleanExtra(\"booleanValue\", false);\nWe are not setting or reading timezone anywhere (directly).. ",
    "feinstein": "@dlew that's not my question. I am not asking why not to use Joda, I am asking the difference between your library and ThreeTenABP. As far as I can see, you both implement a simplified version of Joda Time, yet avoiding all its problems on Android, with the same strategy. . I asked there too so I could be fair with each other, if I just asked in one place this would be biased.\nThe answer he gave me doesn't makes much sense. He points out to a link about \"Why not to use Joda-Time\", I think he got confused about your library's name with he original one. . I see, it wasn't clear for me they where the same but the TZ data came from a different place, I just thought you chanced the way the Library is loaded. Thank you for the clarification.\nNow I believe the difference count  your library and ThreeTenABP is ThreeTenABP also simplifies the method count. . Yeah, took me a while to realize that. At first I thought they were all wrappers to backport Joda-Time somehow, but then I realized I was missing the details. Thank you for your time! (pun intended) . I want to use a good time library, that's small (because of dex method count), well documented and can be used in  older versions of Android (Lollipop at least, KitKat preferably). So far ThreeTenABP is my choice, specially for its size and resemblence to Joda-Time. . ",
    "JimVanG": "Hmm you\u2019re right the pickFirst would only pick the first 'META-INF/LICENSE.txt\u2019 that it ran into and then leave out the rest -- pickFirst. I think what you would actually want to do would do something like merge, again... only if you actually cared deeply about licenses and their requirements. So it\u2019d look something like this:\ngroovy\n    packagingOptions {\n        // This will get include every license and notice regardless of what dir it\u2019s in.\n        merge '**/LICENSE.txt'\n        merge '**/NOTICE.txt'\n        merge '**/notice.txt'\n        merge '**/license.txt'\n        merge '**/NOTICE'\n        merge '**/LICENSE'\n        merge '**/notice'\n        merge '**/license'\n        // This will exclude any README files, regardless of the dir or the file type.\n        exclude '**/README.*'\n    } \nBut i\u2019ll be the first to admit this is a petty PR... I was checking if you updated you\u2019re library recently and was kinda bored and submitted this pull request to the README. It\u2019s totally fine if you don\u2019t merge it and just close it hahah. In fact I learned about the merge command, so it\u2019s all good. I\u2019ll have to try it out actually.\nI\u2019ll be honest, that I do actually display the libraries and their licenses in my apps -- including yours ;). That\u2019s the \u201cfull-solution\u201d, but most licenses don\u2019t require that you display them from within the app. Though most require that they\u2019re packaged within the consuming software... but it\u2019s not any big deal obviously if you don\u2019t.\nHave a good one!. ",
    "ArilesGit": "Hello !\nSorry for the late reply.\nFor now, I forced it with DateTimeZone.setDefault(DateTimeZone.forID(...)) when the Application is created, which is bad... but it saves us sometime.\nI will try to look into this soon and keep you posted.. Hello !\nI may have a little info about this issue :\nTimeZone.getDefault().getID() returns Europe/Amsterdam, whereas\nDateTimeZone.getDefault().toTimeZone().getID() returns UTC.\n@dlew am I missing something ?\nPS: same result using the default emulator in android studio (API 23).. You are right, I thought I was able to reproduce it in the emulator without the 1st step\n\n\nI reset my android 6.0 tablet to factory default. At bootup, it comes with an older version of my app installed as a system-app which starts automatically.\n\n\nBut, it turned out I forgot to call JodaTimeAndroid.init(context) this time. Sorry about that.\nI'll keep looking and I'll update this issue if I find a way to reproduce it without having to reset the device to factory default.\nThanks again for being available. :medal_sports: . ",
    "alexhorsa": "Hmm, I am not aware of removing anything. I don't even know how to remove things with Proguard. What should I look for?. ",
    "DmitryGlotov": "Happened for me too, @alexhorsa 's proguard rules did the job,\nthat is very strange because I didn't changing anything and today it is stop working.\nI'm using D8/R8 and Android Studio 3.3 Canary 13 for a while.\n. ",
    "agap": "Happened to me as well, Android Studio 3.2.1.\nI am pretty sure I wasn't updating any proguard rules for at least as long as 2-3 months.\nI just pocked around in the debug build created by Android Studio (via Analyze APK) and found that all required timezone resources are still in the raw folder. For some reason the app can not pick them up, though.\nSomething noteworthy: I just updated the Kotlin plugin to 1.3.10 (the previous one was 1.2.71-something) and the issue seems to be resolved. @alexhorsa @DmitryGlotov check that case too (in case you're using Kotlin, ofc).. ",
    "EdwardQuixote": "Well, @dlew in my case, I can't disable Minify because I'm use a great number of Google libraries and together, number of methods called exceeds the set limits.\nSo @alexhorsa Proguard rules work for my case.\nHowever, disable Minify also works, but I can't rely on that solution on production environment.. ",
    "PacoSwifty": "I'll try posting over there and see if it sparks anything. Thanks for your quick reply.. ",
    "baole": "Thanks for clarification. It's better to move the init() call just before the app is actually needed Joda.. ",
    "AZOM": "I did a mistake myself and forgot to multiply the timestampUtc by 1000 (because it is in seconds). ",
    "ColtonIdle": "Sorry. I should have clarified that. I don't have the regular joda time dependency anymore. I'm assuming that I have other libraries, that are maybe bringing it in? I just recently converted to androidx as well so I was thinking maybe there's a known issue there.. It looks as though a module I'm using is depending on joda time. I don't necessarily have the ability to update that module version of joda time (It's a custom time picker). What would you recommend in this scenario @dlew ?. Thanks. I'll look into that.. ",
    "plastiv": "Np! Thx for quick reply.\n. ",
    "vanniktech": "There's 4.5. "
}