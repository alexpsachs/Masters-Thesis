{
    "mrtdeh": "Fd\n. ",
    "benjaminbojko": "Thanks for the contribution -- I added your fix to remove the console logs and it's in the latest versions. Regarding the scroll example: I want to keep the demos as simple as possible and all code styles consistent. It might make sense to add another scrolling demo, so if you're up for it perhaps that's a better place for that code. Actual implementation is up to the users of the library -- following the mouse is just one example to understand the concept.\n. Thanks for the suggestion. For now, I'd prefer to keep the demos as simple as possible so they highlight a specific feature or use case. Perhaps this could be a separate demo, but optimally I'd like to keep that as slim as possible.\n. The library is currently not written as an AMD module. If you want to load it with require, I would recommend using the require shim config option: http://requirejs.org/docs/api.html#config-shim.\nIt should probably look something like this (untested):\njs\nrequirejs.config({\n  shim: {\n    'shinejs': {\n      exports: 'shinejs'\n    }\n  }\n});\nAnd then:\njs\nrequire('shinejs', function(shinejs) {\n  var shine = new shinejs.Shine(document.getElementById('my-shine-object'));\n});\n\nEdit: I forgot to mention that you'll need to load the minified script for this to work. I'm currently working on AMD support.\n. Have you tried loading the minified version of the script?\n. Added AMD support with version 0.2.7. Generally, I suggest using the minified version over the non-minified version to prevent namespace issues.\n. Thanks for catching that. Merged and deployed.\n. Thanks for the feedback. Transparent PNGs and SVGs are definitely on the list. I played around with drop-shadow filters and got it to work, but unfortunately performance is much worse with filters than it is with text/box-shadows. I wasn't entirely sold on adding the feature in yet, but perhaps with a disclaimer it could be alright.\n. Thanks for the feedback. Currently the GitHub page uses gyroscope data to update the shadow -- that's a little hard to see if you have your iPad rotated to landscape.\nSince the page itself is just a demo, I'd encourage you to take a stab at any further features or implementations. The library itself is only for casting shadows and I don't want to bloat it too much with complexity.\n. Right now Shine only supports text or box shadow.\nI've looked into using CSS3 filters and SVG filters, but the performance hit was pretty big. If you're interested, feel free to look into this feature branch that I started a while ago but haven't had the time to finish:\nhttps://github.com/bigspaceship/shine.js/tree/feature/filter-support\n. I totally support this. Perhaps @tomccabe can marge the pull request?\n. Shine does modify the contents of the container to add shadow elements, but there shouldn't be a limit on the maximum number of items. It's hard to say what exactly is happening without looking at your code. Do you have an example that you could share?\n. That's actually a great find and I'm strongly considering merging this into the main repo. From the looks of it, your additions should make the script behave as intended. I assume that this hasn't been a larger issue since the library is mostly used decoratively in fairly straight forward settings. Let me take a closer look and I'll probably merge then.\n. Merged into master and tagged as version 0.2.8. Thanks for your help on this!\n. Great to hear that and curious to see the result when it's done!\n. @bravokiloecho Awesome! Glad to see it out in the wild and I love the samples you have, esp. the Beach one :)\n. Thanks, sounds good to me.\n. Shine uses CSS drop shadows, whereas the demo you referenced uses WebGL particles. Drop shadows are rendered entirely by the browser and there's not much more to be done to optimize them. Shine creates multiple drop shadows and merely changes their offset. Most browsers render drop shadows on the CPU, but if you're using Chrome (or better yet, Chrome Canary), you can force it to rasterize everything on the GPU. Copy/paste the following URL chrome://flags/#enable-gpu-rasterization and set the value for the Enable GPU Rasterization drop down to Force-enabled for all layers.\nWhat this will do is offload the rendering to the GPU and thus free CPU resources. On my Mac Pro, that reduces the CPU load from 85% to 15%. As you can see, there won't be much to optimize on the JS side since the majority of computation is browser internal rendering.\n. Hey Kannan,\nThat'll be hard to say without seeing any code. Have you tried following the example with two elements in the read me? https://github.com/bigspaceship/shine.js#configuration\n\u2013 Ben. ",
    "gfarrell": "That doesn't quite fix the \"exports is undefined error\". The shim doesn't work for me. I still get both the \"exports is undefined\" error and the \"module is undefined\" errors.  \nshine: '../lib/shine/dist/shine'\n},\nshim: {\n    shine: {\n        exports: 'exports'\n    }\n}\nI'm using the bower installed version (which, incidentally, is called \"shine\" not \"shinejs\", so I think the docs might be wrong).  \nOn Tuesday, 15 April 2014 at 18:14, Benjamin Bojko wrote:\n\nThe library is currently not written as an AMD module. If you want to load it with require, I would recommend using the require shim config option: http://requirejs.org/docs/api.html#config-shim.\nIt should probably look something like this (untested):\nrequirejs.config({ shim: { 'shinejs': { exports: 'shinejs' } } });  \nAnd then:\nrequire('shinejs', function(shinejs) { var shine = new shinejs.Shine(document.getElementById('my-shine-object')); });  \n\u2014\nReply to this email directly or view it on GitHub (https://github.com/bigspaceship/shine.js/issues/3#issuecomment-40508242).\n. Ah, that works. Thanks.  \n\nOn Tuesday, 15 April 2014 at 18:51, Benjamin Bojko wrote:\n\nHave you tried loading the minified version of the script?\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/bigspaceship/shine.js/issues/3#issuecomment-40512534).\n. \n",
    "vijay-vanecha": "Thanks for quick reply, I understand your point. Thanks again for sharing this awesome plugin.\n. ",
    "mcguffin101": "This can work with icon fonts. The trick is not to use pseudo elements. When you create the font, map it to letter instead of a unicode. That may not be the best way of doing it but it worked for me. :)\n. I don't have one live yet, I just figured it out. \nWhen you create the font map the icon to the letter e (or any letter).\nThe html looks like this \n<h2 id=\"headline\" class=\"sicon \">e</h2>\nAnd the css like this:\n.sicon{\n  background: none repeat scroll 0 0 rgba(0, 0, 0, 0);\n  display: inline-block;\n  font-family: \"myiconfont\" ;\n  font-size: 80px;\n  font-style: normal;\n  font-variant: normal ;\n  font-weight: normal;\n  line-height: 1em;\n  margin-left: 0.2em;\n  margin-right: 0.2em;\n  text-align: center;\n  text-decoration: inherit;\n  text-transform: none;\n  width: 1em;\n}\n. PS\nThe only thing that matters about the css is that you have the font family in there. The rest you can style anyway you want.\n. ",
    "edwardbattistini": "Hi mcguffin,\nDo you have an expemple of it ? for me the shadow does a square around the glyph\u2026\n\u2014\u00a0\nEdward Battistini\u00a0\nProduct Designer\nOn 23 September 2014 at 18:21:35, mcguffin101 (notifications@github.com) wrote:\nThis can work with icon fonts. The trick is not to use pseudo elements. When you create the font, map it to letter instead of a unicode. That may not be the best way of doing it but it worked for me. :)\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "Susie74TS": "Next . ",
    "hamblyfreeman": "Any updated on applying this to an SVG?\nSeems like the SVG shadow is very similar to the box and text ones, so surely simple enough to modify?\nhttps://jsfiddle.net/jamblo/kojh2xLk/387/. ",
    "bravokiloecho": "Hi Benjamin,\nThanks so much for getting back to me. I tried several things to try and find the route of this problem but to no avail. I even rebuilt most of the site in codepen where eveything actually worked as intended!\nHowever I did some digging around the in the plugin and I found the source of the issue...\nThe problem stemmed from the splitChildren prototype. What was happening was that during the for loop over the childNodes NodeList object, the object itself was being emptied of the child that was being appended to the wrapperElement after it was passed through the appendChild method. This was also effecting the number of iterations of the foor loop; there were 12 children on my site, and only 6 loops were being called. (I have no idea why this was happening on my site, but not on the codepen version. I tried it in Chrome, Safari, and Firefox and all had the same issue.)\nA fix that worked for me had two steps:\n1. Cache the childNodes.length as a variable and use this value in the for loop.\n2. Define the child always as childNodes[0] (rather than childNodes[i].\nI've applied these changes in this commit: SHA: 73f7c995e9b7d6927264ce7aa2d224745601e1a8\nIt's quite possible that if the original method works for people, then my new method won't so I'm not sure it's worth making a pull request.\nI had thought of another solution that would be more robust but slightly less efficient. This would involve...\n1. Converting the childNodes object into an array (as documented here).\n2. Reversing the array.\n3. Then within the for loop, defining the child as:\nvar currentChildIndex = childNodesLength - i - 1;\nvar child = childNodes[ currentChildIndex ];\nI hope this all makes sense and I'd be curious to know your thoughts.\n. You're very welcome! I'm glad I could help and I'm super pleased with how it looks on the site I'm building.\n. Hi Benjamin, it's a while since but I've just remembered I was going to show you the result of your code on the site I was building. Well you can see it here.\nMany thanks again for your work on shine.js!\n. "
}