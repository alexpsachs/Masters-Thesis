{
    "srdanrasic": "Thanks Harlan! Sure, it's in my todo list. Hope I'll get some time following week for it. \n. CocoaPods support added since v2.2.3.\n. Hi Rapha\u00ebl, this is actually a feature. Bond exists while it is retained by someone. Designated Bonds on UIKit objects are retained by those objects. You should retain a Bond you create For example, you can save it in a property.\n``` swift\nvar myBond: Bond?\n...\nself.myBond = foo ->> { foo in\n    println(\"foo changed: (foo)\")\n}\n```\nThanks for the issue though, documentation was probably not clear on this, will have to improve it.\n. Thank you slarew.\n. Thank you for the PR. Yeah, it looks like there is a flaw in the documentation. \nHowever, I'm not sure it's a good idea to extend UIKit objects with map/filter/reduce. I'll have to think about it more.\nPlease use textField.designatedDynamic().map for now.\n. Blocked because of an issue with command line compiling:\nBitcast requires types of same width\n  %15 = bitcast i128 %0 to %Sq.19, !dbg !2804\nStored value type does not match pointer operand type!\n  store %Sq.19 %15, i128* %23, align 8, !dbg !2807\n i128LLVM ERROR: Broken function found, compilation aborted!\n. Carthage support added since v2.2.2.\n. That was fast :) I'm waiting for Xcode to download.\nUnfortunately, appending exclamation mark is not backward compatible. Will have to think of something else...\n. Fixed by doing \n(name as? String)!\ninstead of\nname as! String\nfor all instances of\nname as String\n. Added in v3.0.1\n. Implemented in v2.2.0.\n. Can't or can but it doesn't work afterwards?\n\nOn 11 Feb 2015, at 18:31, juhaelee notifications@github.com wrote:\nwhen you try to hook up an action using storyboard after installing swiftbond, unbuttons can't create an ibaction using control+click+drag\n\u2014\nReply to this email directly or view it on GitHub.\n. Hmm, I don't see how this could be connected to Swift Bond. You should try reproducing it in a new project... If it doesn't work send me that new project and I'll investigate.\nOn 11 Feb 2015, at 18:41, juhaelee notifications@github.com wrote:\nThe option of \"action\" doesn't even appear anymore\nOn Wednesday, February 11, 2015, Sr\u0111an Ra\u0161i\u0107 notifications@github.com\nwrote:\n\nCan't or can but it doesn't work afterwards?\n\nOn 11 Feb 2015, at 18:31, juhaelee notifications@github.com\n<javascript:_e(%7B%7D,'cvml','notifications@github.com');> wrote:\nwhen you try to hook up an action using storyboard after installing\nswiftbond, unbuttons can't create an ibaction using control+click+drag\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/SwiftBond/Bond/issues/13#issuecomment-73926195.\n\n\nJu Hae Lee\n\u2014\nReply to this email directly or view it on GitHub.\n. Ok juhaelee, I was able to reproduce this. You don't need to send me anything. \n. This looks like a bug in Xcode. If you extend UIKit object, it looses action/event options in Interface builder. Even following is enough to break Interface Builder\n\n``` swift\nprotocol SomeProtocol {\n}\nextension UIButton: SomeProtocol {\n}\n```\nCrazy. I'll see what can be done...\n. Filed a bug at Apple Bug Reporter: 19799266.\n. juhaelee, you can use Bond to handle the action, for example:\nswift\nvar buttonEventBond: Bond<UIControlEvents>?\n...\nself.buttonEventBond = button.designatedDynamic().filter { $0 == UIControlEvents.TouchUpInside } ->> { event in\n  login()\n}\nMake sure you retain the bond like in the snippet above.\n. Fixed my answer.\nAnyway, I'm working on fixing this whole issue in another way. Hope I'll have something in a day or so.\n. You need to retain (strongly reference) the bond like this\n``` swift\nclass StoreTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar favoriteBond: Bond?\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n      addButton.imageView?.image = viewModel.addImage\n      favoriteBond = viewModel.favorite ->> { [unowned self] value in\n        println(\"The value changed\")\n        self.nameLabel = \"I changed\"\n      }\n    }\n  }\n}\n```\nI should emphasise this in readme I guess :)\n. Each UIKit object (button, label, imageview...) provides a Bond in a designatedBond property that you can use instead of creating and retaining your own bonds.\nWhen types mismatch, for example favoriteis Bool, but you want it to update label whose designatedBond needs String, you can use map() to transform type.\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n      viewModel.addImage ->> addButton.imageView!.designatedBond\n      viewModel.favorite.map { newValue in\n        return newValue ? \"favorited\" : \"not favorited\"\n      } ->> self.nameLabel.designatedBond\n    }\n  }\n}\n```\nAs designatedBond is defined by a protocol, following should also work:\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n      viewModel.addImage ->> addButton.imageView!\n      viewModel.favorite.map { newValue in\n        return newValue ? \"favorited\" : \"not favorited\"\n      } ->> self.nameLabel\n    }\n  }\n}\n```\n. Checkout the definition of ->> operator:\nswift\npublic func ->> <T>(left: Dynamic<T>, right: T -> Void) -> Bond<T>\npublic func ->> <T: Dynamical, U where T.DynamicType == U>(left: T, right: Bond<U>)\npublic func ->> <T: Dynamical, U: Bondable where T.DynamicType == U.BondType>(left: T, right: U)\npublic func ->> <T, U: Bondable where U.BondType == T>(left: Dynamic<T>, right: U)\nIt will return a Bond only when there is a closure on the right side because in that case a new Bond is created. In all other cases you already have a Bond on right side so there is no need to return anything.\nIn case of any UIKit object, Bond on the right side is the one saved into designatedBond property.\n. Checkout demo app, it shows very similar use case to yours: https://github.com/SwiftBond/Bond-Demo-App\n. Expression dynamic ->> closure creates a Bond, so you need to strongly reference it.\nExpression dynamic ->> bond does not create any Bond because you already have a Bond that you're binding to (the thing on the right side).\nExpression dynamic ->> someUiKitObject is equivalent to dynamic ->> bond because under the hood it actually performs dynamic ->> someUiKitObject.designatedBond. So, Bond object already exists, you're only establishing a connection to it.\nYour problem might be that you're not setting button's image correctly. You should use setImage:forState: method when setting an image of UIButton. For that you need a custom bond with closure.\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar favoriteBond: Bond?\n  var addImageBond: Bond?\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n  addImageBond = viewModel.addImage ->> { [unowned self] image in\n    self.addButton.setImage(image, forState: UIControlState.Normal)\n  }\n\n  favoriteBond = viewModel.favorite ->> { [unowned self] value in\n    println(\"The value changed\")\n    viewModel.addImage.value = UIImage(named: 'newImage')\n  }\n}\n\n}\n}\n```\nYou're welcome. Your questions tell me where I should improve documentation.\n. juhaelee, I updated readme and releases v2.2.0 with additional Bonds. Now you should be able to update your button image like this:\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar favoriteBond: Bond?\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n  viewModel.addImage ->> addButton.imageForNormalStateBond\n\n  favoriteBond = viewModel.favorite ->> { [unowned self] value in\n    println(\"The value changed\")\n    viewModel.addImage.value = UIImage(named: 'newImage')\n  }\n}\n\n}\n}\n```\n. Action connector bug in Interface Builder handled in v2.2.1.\n. Thank you Andy\n. Ideally, VM should provide exactly what V or VC need. In your case, it should provide first name, not a user.\nMaybe something like this:\n``` swift\nclass User {\n  let firstName: String\n}\nclass Api {\n  class func login(username: String, password: String, success: User -> Void) {\n    // make request, parse request, create user and call succes(user)\n  }\n}\nclass UserInteractor {\n  let user = Dynamic(nil)\nfunc login(username: String, password: String) {\n    Api.login(username, password: password) { [unowned self] in\n      self.user.value = $0\n    }\n  }\n}\nclass ViewModel {\n  let userInteractor: UserInteractor\n  let name: Dynamic\ninit(userInteractor: UserInteractor) {\n    self.userInteractor = userInteractor\n    self.name = userInteractor.user.map { $0?.firstName ?? \"\" }\n  }\n}\nclass ViewController {\n  var viewModel: ViewModel\nfunc viewDidLoad() {\n    super.viewDidLoad()\n    self.viewModel.name ->> nameLabel\n  }\n}\n```\nI borrowed Interactor concept from VIPER architecture. Basically, you do your business logic there.\n. Interesting scenario. Unfortunately, I don't see a \"Bond way\" of solving this at the moment. You can always manually implement data source and use ArrayBond to do table view updates like here: https://github.com/SwiftBond/Bond/blob/master/Bond/Bond%2BUIKit.swift#L589-L627\nBut you have valid scenario and we need to make it work :) I'll keep you informed.\n. Hi Pedro,\nBond v3 supports multiple sections so you can have first row as additional section. Check out updated README.\n. This is great catch, I wonder it didn't came up earlier.\nOperator ->> binds and fires with current value. There is a flaw in implementation of filter with regard to current value of filtered dynamic. This will be fixed in the next version, hopefully this weekend.\nWhat you should do is use operator ->| when observing events that should not fire at binding time.\nIn other words, operator ->> binds objects and calls Listener closure with current value. Operator ->| just binds objects (Listener will get called only on subsequent changes).\nHope it helps. \n. Hi Pedro. Bond v3 is out. With it you can do your example like this:\n``` swift\nclass ViewController: UIViewController\n{\n  lazy var startClick: Bond = Bond() { [unowned self] event in\n    self.project!.startSprint()\n  }\nlazy var stopClick: Bond = Bond() { [unowned self] event in\n    self.project!.stopSprint()\n  }\noverride func viewDidLoad() {\n    super.viewDidLoad()\nstartButton.dynEvent.filter(==, .TouchUpInside) ->> startClick\nstopButton.dynEvent.filter(==, .TouchUpInside) ->> startClick\n\n}\n}\n```\n. Hi @advantis, thanks for reporting this. It's unfortunate that iOS doesn't send notifications in that case.\nI'll leave it as is for now...\n. Hi Sergey,\nCan you try specifying the type as optional String and let me know if it helps:\nswift\nlet commonNameDynamic = Dynamic<String?>.asObservableFor(p, keyPath: \"commonName\")\nYou'll need to map it to non-optional when binding it to label.\nswift\ncommonNameDynamic.map { $0 ?? \"\" } ->> commonNameLabel\nAlso, aim for making your Dynamics as constants (using let keyword) instead of variables.\n. Thank you!\nYeah, that looks like a problem. Working on fix right now...\n. Yeah, it's pain looks like. I don't see a way to do it without defaultValue. If you want, you can do pull request with your update.\n. Its a good question, I'll give it some more thought tonight.\nTwo way binding with KVO property should also be doable by having feedback bond like this:\n``` swift\n  ...\nlet feedbackBond = Bond() { [unowned object] value in\n    object.setValue(value, forKey: keyPath)\n  }\ndynamic.bindTo(feedbackBond, fire: false, strongly: false)\n  dynamic.retain(feedbackBond)\ndynamic.retain(helper)\n  return dynamic\n```\nBut there are some problems with types I need to fix first...\n. Default value should always be needed to prevent unintentional bugs.\n. Thanks for your help @serieuxchat . I've fixed this in v3.0.1 with your suggestion.\nAdditionally, I added another way to create Dynamic representations of K-V observed properties which is to be used for two-way bindings. Checkout README.\n. You're welcome! Should you find any more issues, feel free to open another issue.\n. Hi @skywinder,\nThank you for this, but we will not need it at the moment. You've made a great script though :)\n. Thanks for the feedback Ian. Yeah, this'll need some improvement.\nIn addition to your suggestion, I'm thinking to allow option to retain observed NSObject by the Dynamic. Do you think that that might help in some situations?\n. Ok, I can see the problem. Please have in mind that Cocoa Touch does not officially support KVO on UIKit objects. It's just a coincidence it works. In your case, better approach would be to register your view controller as a delegate of your table view and implement method scrollViewDidScroll:.\nUITableView is a subclass of UIScrollView and UITableViewDelegate inherits UIScrollViewDelegate so you can get offset change that way.\n. I completely agree with you Zden\u011bk. Will do as soon as I get some spare time.\n. We don't have indexPath available in map function. Might be a good feature though in next version.\nDo you need to use indexPath variant for some reason?\n. Array map is pull-based so it means that cells are created on demand. Check out this section: https://github.com/SwiftBond/Bond/blob/master/README.md#map-and-filter\n\nMap function that operates on DynamicArray differs from map function that operates on basic Dynamic in a way that it evaluates values lazily. It means that at the moment of mapping, no element from source array is transformed to destination array. Elements are transformed on an as-needed basis. Thus the map function has O(1) complexity and no unnecessary table view cell will ever get created. (Beware that accessing value property of mapped DynamicArray returns whole array so it has to transform each element. Avoid accessing it.)\nBecause of its nature, filter function that operates on DynamicArray has O(n) complexity and you should be careful when using it.\n. UICollectionView support implemented in v3.1.0.\n. Yes, you can do that. Dynamic returned by map (or other similar functions) will retain source one.\n. Just be careful when working with K-V observing that your Dynamic does not outlive observed object (model in your case) as discussed in #21.\n. Hi Dan,\n\nLooks like there was an issue with dynTitle of UIButton. It's fixed now. Please get latest version (v3.1.1).\nThanks for reporting this! \n. A rule of thumb: always declare dynamics as constants - using let keyword.\nswift\nlet currentStop =  Dynamic<String>(\"Something\")\nBecause you should never reassign it, but change its value\nswift\ncurrentStop.value = \"Something else\"\n. Glad to hear that :)\n. If you're referring to Cocoa framework for OS X, there aren't any plans at the moment.\nFeel free to contribute though :)\n. Both should work, but second alternative is preferred way to go.\nmap, filter and other functions already produce Dynamic so you don't need another one.\n. That's a great suggestion, thank you. Let's me implement it.\n. Implemented in v3.3.\n. Could you write a minimal example that exhibits that issue?\n. Looks like there is an issue in filter function of an array. Working on the fix...\n. I give it less than a weekend :)\nNo problem, I actually appreciate that you're opening issues, it helps make this framework better.\n. Thank you! It should be fixed now. Please check v3.3.0.\n. I don't see how could this be Bond related. It does not affect layout in any way. It just provides data...\n. I was finally able to reproduce this... Working on it...\n. Caused by caching. So sad... It was great feature which had to be removed. v3.4.1 includes the fix.\n. This is due to pull-based behaviour of the array. \"Old objects\" array will be empty if those objects were not accessed previously or if they were but they are not alive anymore (no one is holding a reference to them).\n``` swift\nlet array = DynamicArray([1,2,3])\nlet mapped = array.map { $0 + 10 }\nlet bond = ArrayBond()\nbond.updateListener = { array, indices, object in \n  println(\"indices: (indices), objects: (objects)\")\n}\narray[0] = 5 // prints: indices: [0], objects: []\n// but if you access object before updating it\nprintln(mapped[0])\n// then\narray[0] = 6 // prints: prints: indices: [0], objects: [15]\n```\n. It would be bad if we would create few hundred UITableViewCells at one moment...\nBut looks like there is simpler solution to this. What you probably need is updateListener refactored as two listeners:\nswift\nwillUpdateListener: (DynamicArray<T>, [Int]) -> Void\nand \nswift\ndidUpdateListener: (DynamicArray<T>, [Int]) -> Void\nProbably same thing for remove listener. You'd be then able to access objects in array just before change happens.\nWould that work?\n. @zdenektopic Check out v3.4. It has addition listeners on ArrayBond. \n. Implemented in v4.\n. Hi Ian, thanks for the suggestions. I agree with you, that should be right direction in the development of Bond. I'm currently exploring some ideas, but have not committed on one yet.\nThinking about adding abstraction on top of Dynamic in form of value-less Signal. Something like Command could then act upon those signals instead of just upon dynamics. Basically more Reactive stuff...\n. @tonyarnold that would require introducing Disposables. Not sure if it would fit in current architecture where Dynamics (Observables) do not retain Bonds (Observers).\n.  observe method in v4 solves this..\n. Thank you Anthony, this is useful. Merging.\n. Could you elaborate this? Why would you use it?\n. Then I have good news for you - signals are work in progress - hope they'll be out by next weekend. \nSimilarly to RC, Dynamic will be improved to extend Signal. Everything will be backward compatible. \n\nOn 20 Mar 2015, at 17:34, Victor Shamanov notifications@github.com wrote:\nAs I understand, in current implementation, it's possible to change someone's Dynamic value.\nI'd like to forbid users to change value inside of my Dynamic property.\nLike in ReactiveCocoa's implementation, where there are RACSignal which value you cannot change, and RACSubject with changeable value. Also RACSubject is a subclass of RACSignal, so you can use RACSubject inside the class and give RACSignal to outside.\n\u2014\nReply to this email directly or view it on GitHub.\n. Hi @TadeasKriz, first beta version of Bond 4 with something like this will come out by the end of the week.\n. Yes, we will finally have real Observables and much more. Whole architecture has been revisited. I believe it's much better, but I'm looking forward to hear feedback from all of you active here before final release :) I'll be pushing next version in following days as I polish some details.\n. @thedevme The goal is September 9th.\n. Good idea :)\n. Huy,\n\nCheck out v3.4.2. I lowered deployment target to 7.0. Give us your feedback if it works. Thanks\n. Good catch. Forgot to handle initial case. What a fun. Fixed in v3.4.3.\nBtw, value is intended to be empty due to possible misuse. Use subscript syntax or enumerate it with for loop to get elements. \nThanks!\n. How would that work?\n. Well, you can do\n``` swift\nfor element in myDynamicArray {\n  // some work with the element\n}\n// or\nfor (index, element) in enumerate(myDynamicArray) {\n  // some work with the element and index\n}\n```\n. Thanks for reporting this. Should be fixed. Please check out v3.5.0.\n. Thank you Alex. I've made that method public. Check out v3.5.1.\n. Hi @laptobbe,\nDo you really need 'move'? This is not usual operation available on arrays, a similar thing can be achieved with remove-insert. \nI fear that adding two more listeners will make this to complex. We would also have to handle those listener in map/filter array functions...\n. Thank you @sync, it's now part of v3.5.x.\n. Unfortunately, caching would introduce more problems than it would fix so this will not be implemented.\nYou should aim for map/filter/reduce functions to be pure functional - they should not change state of the object and should produce same result on each run.\n. Thanks for reporting this Zden\u011bk, I'll investigate.\n. Looks like an issue with UICollectionView.\nThere is a new method in v3.7.0 on DynamicArray called setArray: which you can use to reset whole array to new value. That method calls will/didReset listeners, which in turn call reloadData on table views and collection views.\nIn other words, try array.setArray([]) instead array.removeAll().\n. Nop.\n. Thank you @adly-holler!\n. Thank you @tonyarnold for bringing this up. I'm open to changes, but I'd like to see additional opinions.\nRenaming Dynamic would require major version number change so that would potentially be part of next major release. I don't like the idea of doing major release just because of a rename.\nThere are no concrete plans for next major release yet - currently experimenting with signals that would be valueless abstractions of Dynamics.\n. /cc @hip4yes @sync @lyricsboy @zdenektopic @advantis\nFeel free to give your feedback.\n. Renamed to Observable in v4.\n. Thank you for this Tony. \nWhat would be great is to have unit test for each new dynamic, like there is for UIKit.\n. There was enough of this for a release. Thanks!\nPS CALayerTests.swift did not compile for iOS so I removed it from iOS target.\n. Hi @rvangraan,\nYou should be able to do that yourself with extensions, like this:\nswift\nprotocol DynamicProtocol {}\nextension Dynamic: DynamicProtocol {}\nThen you can declare an array of Dynamics of any generic type:\n``` swift\nvar dynamicValues = DynamicProtocol\ndynamicValues.append(Dynamic(0))\ndynamicValues.append(Dynamic(\"hi\"))\n```\nThat being said, for whatever reason you might need this, I'm not sure it's good approach. First of all, type information will be lost, so you'll need to cast to right type before binding:\nswift\n(dynamicValues[1] as! Dynamic<String>) ->> nameLabel\nAdditionally, if you replace a dynamic element in the array, the binding will be lost. For example, if you do:\nswift\ndynamicValues[1] = Dynamic<String>(\"Tim\")\nThen updating that new dynamic would not propagate to name label because that new Dynamic is not bound to it.\nI'd strongly recommend against doing all this.\nThanks\nPS You should always declare your Dynamics as constants, using let keyword:\nswift\nprivate let dynDescription = Dynamic(description)\nprivate let dynNetAmount = Dynamic(Money())\nprivate let dynVatAmount = Dynamic(Money())\n. Tagged as v3.7.0.\n. Great improvement, thanks!\nI agree with you about value property on proxy arrays. Supporting it might encourage bad practice.\nRegarding removeAll, I'd keep it as is. My reasoning is that this is the operation that modifies current array so I'd expect to be notified in my didRemove listener... Should user want didReset to be called, he can use set array to [].\n. That's sad. Will remove it...\n. Fixed in v3.8.\n. @ktomek, thanks for reporting this and sorry for not getting it fixed earlier. Fix available in v3.7.3.\n. Hi @felixpalmer, This is expected. Bond object has to be retained by someone. Usually you would have it defined as a property so it would be retained by self.\n. Good catch, thanks!\n. This is very strange. Do you know what's the underlying cause? I dread the idea of doing string comparison on each change... Is that bidirectional binding? \n. @morizotter, I fixed this in v3.7.2 in a bit different way. Thanks anyway!\n. If will fire if you change its dynFrame property. \nIf you really need to observe frame changes, you could create a Dynamic from KVO:\n``` swift\nclass customView:UIView{\n   ...\nlazy var frameListener:Bond = Bond(){ [unowned self] frame in\n        println(\"firing :D\")\n    }\nfunc bind() {\n    dynamicObservableFor(self, keyPath: \"frame\", defaultValue: CGRectZero) ->| frameListener\n}\n\n}\n```\nhttps://github.com/SwiftBond/Bond#key-value-observing\n. Yeah, that's due to unfortunate differences between ObjC and Swift. There is another way to create Dynamic from KVO property. It allows you to manually convert object. You need to pass two closures. One that converts AnyObject? to CGRect, and one other way round.\nswift\ndynamicObservableFor(self, keyPath: \"frame\", from: { $0?.CGRectValue() ?? CGRectZero }, to: { NSValue(CGRect: $0) })\n. Are you sure this is related to Bond?\n. @juandent, you're on good track, just mind your Types:\n``` swift\nclass NSComboBoxDynamicHelper: NSObject {\nweak var control: NSComboBox?\n  var listener: (Int -> Void)?\ninit(control: NSComboBox) {\n    self.control = control\n    super.init()\n    control.target = self\n    control.action = Selector(\"selectionChanged:\")\n  }\nfunc selectionChanged(sender: AnyObject?) {\n    if let combo : NSComboBox = sender as? NSComboBox {\n      let index = combo.indexOfSelectedItem\n      self.listener?(index)\n    }\n  }\n}\nclass NSComboBoxDynamicForIndex: InternalDynamic {\nlet helper: NSComboBoxDynamicHelper\ninit(control: NSComboBox) {\n    self.helper = NSComboBoxDynamicHelper(control: control)\n    super.init(control.indexOfSelectedItem )\n    self.helper.listener =  { [unowned self] in\n      self.updatingFromSelf = true\n      self.value = $0\n      self.updatingFromSelf = false\n    }\n  }\n}\nclass NSComboBoxDynamicForObject: InternalDynamic {\nlet helper: NSComboBoxDynamicHelper\ninit(control: NSComboBox) {\n    self.helper = NSComboBoxDynamicHelper(control: control)\n    super.init(nil)\n    self.helper.listener = { [unowned self, unowned control] in\n      self.updatingFromSelf = true\n      self.value = control.objectValues[$0]\n      self.updatingFromSelf = false\n    }\n  }\n}\nprivate var indexOfSelectedItemDynamicHandleNSComboBox: UInt8 = 0;\nprivate var objectValueOfSelectedItemDynamicHandleNSComboBox : UInt8 = 0;\nextension NSComboBox: Dynamical, Bondable {\npublic var dynIndexOfSelectedItem: Dynamic {\nif let d: AnyObject = objc_getAssociatedObject(self, &indexOfSelectedItemDynamicHandleNSComboBox) {\n  return (d as? Dynamic<Int>)!\n} else {\n  let d = NSComboBoxDynamicForIndex<Int>(control: self)\n  let bond = Bond<Int>() { [weak self, weak d] v in\n    if let s = self, d = d where !d.updatingFromSelf {  // prevents feedback loop\n      let itemCount = s.numberOfItems\n      if v > -1 && v < itemCount {\n        s.selectItemAtIndex(v)\n      }\n    }\n  }\n  d.bindTo(bond, fire: false, strongly: false)\n  d.retain(bond)\n  objc_setAssociatedObject(self, &indexOfSelectedItemDynamicHandleNSComboBox, d, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN_NONATOMIC))\n  return d\n}\n\n}\npublic var dynObjectValueOfSelectedItem : Dynamic {\nif let d: AnyObject = objc_getAssociatedObject(self, &objectValueOfSelectedItemDynamicHandleNSComboBox) {\n  return (d as? Dynamic<AnyObject?>)!\n\n} else {\n  let d = NSComboBoxDynamicForObject<AnyObject?>(control: self)\n  let bond = Bond<AnyObject?>() { [weak self, weak d] v in\n    if let s = self, d = d where !d.updatingFromSelf {  // prevents feedback loop\n      s.objectValue = v\n    }\n  }\n  d.bindTo(bond, fire: false, strongly: false)\n  d.retain(bond)\n  objc_setAssociatedObject(self, &objectValueOfSelectedItemDynamicHandleNSComboBox, d, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN_NONATOMIC))\n  return d\n}\n\n}\n}\npublic func <->> (left: NSComboBox, right: Dynamic) {\n  left.dynIndexOfSelectedItem <->> right\n}\npublic func <->> (left: Dynamic, right: NSComboBox) {\n  left <->> right.dynIndexOfSelectedItem\n}\n```\n. You're right, there is an issue. Bond should not be overwriting text field/view value on each change. Thanks for detailed explanation! \n. Hi @morizotter, please check out v3.7.2. \n. You're welcome! And thanks again for reporting this.\n. Fixed in v3.7.2. Thanks!\n. Thanks! That's great idea. Putting it in TODO list. I don't have much time at the moment though.\n. Not planned at the moment.\n. Hi @modnovolyk, you've presented good points there, this could be useful.\nJust one thing. I don't feel the name is descriptive enough. I would not expect that something called delay eats my value changes. Maybe we should go with throttle or something similar?\n. Agreed, that should be noted in the Readme. What do you think about changing name to throttle? I'd like to keep delay available for possible implementation of similar function, just without skipping. If you agree, you can update PR and I'll merge it.\n. Hi @modnovolyk, I merged this and will release new version soon after I do some tests. I changed the algorithm a bit and added optional argument that specifies queue to dispatch on (if someone will need it).\nChange is in that the dispatch will happen every N seconds even if value is changing at some rate smaller than N seconds.\nFor example, if I would throttle 2 seconds, and then type 10 characters with rate of one character per second, your implementation would do dispatch only once - after 12 seconds. New implementation will dispatch every two seconds. Hope this sill covers your scenario.\n. Ok guys, should be fixed in v3.7.3. AppKit support is kind of still unofficial. Feel free to contribute if you need additional extensions.\n. Oh. Well, v3.7.4 is out :)\n. Hi @arytbk, sorry for not getting earlier to this. If you're still facing the issue, try deliver method in v3.8.\nFor example:\nswift\ndeliver(repositories, on: dispatch_get_main_queue()).map { [unowned self] (repository: Repository) -> RepositoryTableViewCell in\n    let cell = self.tableView.dequeueReusableCellWithIdentifier(\"cell\") as RepositoryTableViewCell\n    repository.name ->> cell.nameLabel\n    repository.photo ->> cell.avatarImageView\n    return cell\n  } ->> tableViewDataSourceBond\n. Fixed in v4.\n. Hi @Ben-G,\nYou need DynamicArray only if you're interested in \"fine-grained\" changes - like what elements got inserted, deleted or updated. If you're only interested in a change of the array as whole, you don't need to use it.\nhttps://github.com/SwiftBond/Bond#arrays-are-special-and-great\nDynamicArray is also necessary when using table or collection view binding.\n. Are you trying to say that this works?\nswift\nvar exampleArray = Dynamic<[ExampleClass]>([])\nexampleArray.append(ExampleClass())\nHmm, that should not even compile because Dynamic has no method named append. Following will work, though:\nswift\nvar exampleArray = Dynamic<[ExampleClass]>([])\nexampleArray.value.append(ExampleClass())\nBut binding that to an ArrayBond like this:\nswift\nlet myBond = ArrayBond<ExampleClass>()\nexampleArray ->> myBond\nWill not work properly because fine \"fine-grained\" changes will not be propagated. For example, didInsertListener listener\nswift\nmyBond.didInsertListener = { array, indices in\n    println(\"Inserted objects at indices \\(indices)\")\n}\nwill not be triggered...\n. I should probably have said \"if you're interested in observing \"fine-grained\" changes\"... Anyway, glad it helps :)\n. @gvimlan95, there is no official Swift 2.0 support yet. Bond v4 will be Swift 2.0 ready. You can checkout  bond-4 branch, but it might now be fully stable yet. Also, some things have changes, so the documentation is out of the date.\n. Bond 4 is Swift 2 ready.\n. I think Swift can't handle your expression - multiplying Int64 with Double. Haven't tried, but this might work:\nswift\n(Double(a) / Double(b)) * 100.0\nOr this:\nswift\nDouble(a / b) * 100.0\n. You should not use any of those properties. They should have been marked internal/private.\nTo answer your question, when you bind a Dynamic to a Bond, it's retained by [bondedDynamics]. The other one, [bondedWeakDynamics], is used in cases when we don't want strong reference, for example for feedback Bond in two-way binding: \nhttps://github.com/SwiftBond/Bond/blob/master/Bond/Bond%2BOperators.swift#L85-L88\nWhy are you using this properties anyway?\n. Functions like map or filter return a Dynamic that's not referenced by anyone. For example, in order for this this to work:\nswift\nviewModel.name.map { $0.uppercaseString } ->> nameLabel\nBond on nameLabel's dynText must strongly reference result of mapping or it would get lost. This does not case any issues because (I assume) both your ViewModel and your Views (labels, etc...) are referenced by your ViewController, so when ViewController is deallocated, it will trigger deallocation of ViewModel, Views, Dynamics i.e. Bonds retained by Views, and finally of other Dynamics bound to those Dynamics, i.e. Bonds.\nIf you bind Dynamic to Bond weakly, it will work normally, but you have to make sure Dynamic stays alive.\n. You should not care how many references there are. It does not make application faster or better in any way. All that is important to understand is relationship graph, i.e. who owns whom. Also, beware of reference cycles when working with closures.\nSwift book explains those concepts very good: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html\n. That is expected. Setting the value (even same) triggers update. Framework does not check equality for multiple reason - it can impact performance, it can fail and it can be non-deterministic.\nIs this causing any issues to you?\n. You asked valid question. It's good to think about it. There might be cases when this might be an issue, but this is not the one. Even if that reduce method was called thousand times a second, it would still have negligible impact on performance because expression in reduce method is very simple. On the other hand, if you were doing very complex or slow operation, like loading file from disk, or making network request, then you would have to think about performance and ways to limit number of requests.\n. This is incorrect way to bind. You should use ->> operator or bindTo method.\nIt is fine to bind one Dynamic to multiple Bonds.\n. Ok, now I see :) Hmm, I guess I would not expect that behaviour. Set would be preferred in that case.\nThanks for bringing this up.\n. That would be great :)\n. I've released v3.8 with your improvements. Thanks a lot!\n. @ivanmoskalev, how do we do that? :)\n. This looks like a very good work. I'll go through it once more, but from what I can see there are no issues.\n. I'm thinking of making Dynamic.bonds property internal. It should have been marked like that already. I see no reason for it to be public.\n. Thanks @sync. Did Beta 2 fix that ABI compatibility error?\n. That's great. I've created swift-2.0 branch. Could you try doing PR into that branch?\n. @ivanmoskalev, that would be great. I guess it would work only with types conforming to Equatable?\n. That could be very powerful feature. We could easily extend Dynamic with a new function that would allow us to manually commit change while doing side effects.\nswift\nextension Dynamic {\n  public func intercept(closure: (Void -> Void) -> Void) -> Dynamic<T>\n}\nUser would provide a closure to perform side effects. The closure would receive another closure as an argument that would be used to propagate changes.\n``` swift\n@IBOutlet weak var label: UILabel!\nlet alpha = Dynamic(0)\nalpha.intercept { commit in\n  // perform some action before change\n  commit() // propagate change\n  // perform some action after change\n} ->> label.dynAlpha\n```\nSo, to animate change of alpha we could do:\nswift\nalpha.intercept { commit in\n  UIView.animateWithDuration(0.25){ \n    commit()\n  }\n} ->> label.dynAlpha\nI'm also thinking of a bit more powerful variant where user would also get a new value which he has to commit, potentially changing it. Like a real man in the middle attack on our binding. \nswift\nextension Dynamic {\n  public func intercept(closure: (T -> Void, T) -> Void) -> Dynamic<T>\n}\nswift\nalpha.intercept { commit, value in\n  UIView.animateWithDuration(0.25){ \n    commit(value)\n  }\n} ->> label.dynAlpha\nWould something like that work for you? Also, do you have any better name suggestion for such function?\n. I don't think this can be applied to v4. Method observe can be used to achieve something like that.\n. Thank you @ikesyo.\n. Oh, I've also hit that issue once. Didn't find any solution... :(\nI'm playing with Swift 2.0, though, and it seems it will be possible. We'll need to make Dynamic adopt some protocol because then we'll be able to extend that protocol using type constrained extension.\n``` swift\nprotocol Observable {\n  typealias ValueType\n}\nclass Dynamic: Observable {}\nextension Observable where ValueType: Equatable {\n  func distinct() -> Dynamic {}\n}\n```\nLooks like protocols are very powerful in 2.0. Might not be a bad idea to shift some things in that directions. \nFor now, let's keep this as function-only.\n. Thanks @murrayds. Can you just fix the indentation. This file used 2 spaces for indentation. It's customary to respect original indentation when editing existing file. Additionally, changing indentation of existing code marks those lines as modified. If you take a look at change log (https://github.com/SwiftBond/Bond/pull/89/files) you can see that dynText and dynAttributedText methods are marked as changed. I cannot clearly see if it's only indentation that's changed or something else. I'm sure there is nothing changed, but I cannot confirm that from this diff.\nI don't really care if someone uses 2 or 4 spaces, it's up to you, as long as there is consistency per file and existing indentation is not changed.\nOtherwise, this look good. I think that default text color should be black, though.\n. Great :) Thank you.\n. Thank you @tonyxiao.\n. Nice helper.\n. Excellent.\n. That's a good idea. I tried to setup Travis few months ago but had some issues and not enough time to fix it.\nI've linked the account and added repository: https://travis-ci.org/SwiftBond/Bond\nI guess you should do some dummy commit to this PR in order to trigger it.\n. I might be wrong, but it appears that Travis supports XCode only up to v6.1...\nhttp://docs.travis-ci.com/user/languages/objective-c/#Supported-OS-X-iOS-SDK-versions\nEDIT: Looks like there is  beta support: http://blog.travis-ci.com/2015-05-26-xcode-63-beta-general-availability/\n. That's great. Thanks @tonyarnold\n. Great! Is it possible to test BondOSX scheme too?\n. Thanks Ivan.\n. Great, thank you @ivanmoskalev! Merging this.\n. Batch updates are supported in v4. Closing.\n. @Darkhorse-Fraternity Unfortunately Bond does not work like that. It would be great, though :)\n@murrayds is right. You might also take a look at KVO: https://github.com/SwiftBond/Bond#key-value-observing\n. Thank you @murrayds for the PR and @ivanmoskalev for the review. I'll merge it.\n. Agreed, that would be much nicer. Those things are from the times when Xcode was so unstable that you had to make everything explicit or you'd end up with SourceKit crashes. \n. Hi @murrayds. I think that s in this case should be left in order to maintain atomicity of the operation.\n. Bond v4 is out which has this done differently. Thank you anyway!\n. Great PR :+1: \n. I'm going to revert this change as it's interfering with something else at the moment. Maybe there is a cleaner way to do this without complicating table/collection view bond.\n. I see the potential. Instead of modifying map, maybe we could introduce another function cache that returns a new proxy array that manages caching?\nswift\nlet images = fileNames.map { UIImage(named: $0) }.cache(.Lazy)\nWhat do you think?\n. Thanks @ivanmoskalev. I'm working on a next version of Bond with complete architecture redesign that will fix current flaws. It should have much more powerful yet simpler arrays. I'll push it in the development branch in next few days when I refine few details. I'll appreciate any feedback for you or anyone else, if you get some time to review it.\n. Closed as outdated.\n. Thanks for this. flatten is available in v4.\n. Thank you.\n. Great :)\n. Thank you @adly-holler. This looks good, but'll have to put this aside for the time being.\nI'm a bit worried about additional overhead and complexity this introduces. There's been few PR-s on Arrays recently, all introducing complexity. I want to take some time and rethink whole Array thing with those recent PRs. \n. Arrays have been completely revisited in v4. They should be much stable now. Closing this.\n. @tonyxiao, that you for this improvement. I've resolved the conflicts and will merge it after additional review.\n. Array have been completely revisited in v4. They now have support for batch updates. Thanks anyway!\n. Hi Jason,\nYou need to mapit, i.e. convert it to String.\nswift\ndroneRCGPSData.map { data in \"\\(data.mTime.mSecond)\" } ->> labelAppName\nHope this helps.\n. Sorry, I misspelled. It's corrected now. It's basic Swift string interpolation. \nhttps://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID292\n. Yes, we should rebase it. I'll close this. @ivanmoskalev would you like to do that?\n. Maybe rewrite method might be of some help...\nswift\nsomeButton.dynEvent.filter(==, .TouchUpInside).rewrite(yourValue) ->> someAction\n. Can you give us a bit more context around what you are trying to achieve?\n. Hope you have this solved. I'll close the ticket.\n. Arrays are refactored in v4. Thanks anyway.\n. A relic form Swift 1.0 I suppose. Does not really matter in this case because we are sure that if there is an object associated with that key, it will be our type. Unless someone messed with internal workings of the library, but in that case it's probably better to crash then to allow incorrect behaviour.\nWill make sure this comes out nicer in next version, though!\n. Will be available in v4.0. You can expect beta release this weekend.\n. Right, that's why it's bound with fire=false by the default. It's caused by a bad underlying design. In v4 we will have stateless Observables which will be right fit for this and some other cases like buttons taps, etc.\nThanks for bringing up things like these. I think you'll like v4 :)\n. Notification center support has been refactored in v4. Closing.\n. Great catch! Thanks.\n. The problem is that a Dynamic uses a Bond to make it bindable. If the Bond would accept only one connection, it would not allow updating the Dynamic from multiple sources where any is not feasible - a valid scenario.\nHopefully, Bond v4 deprecates Bond class in favor of a plain closure.\n. Bonds are deprecated in v4. Closing.\n. @ivanmoskalev Great idea!\n. There is currently a mess with all the different operators in FP frameworks around, so I was thinking that a little bit of consistency would make developers lives easier. I found ReactiveCocoa's operator most pleasing to work with.\nOn the other hand, you might have a point, they are using that as a pipe operator, so making a distinction might not be a bad idea in this case. \nI don't have a solid decision on the operator yet. All ideas are welcome, including keeping the old one.\n. One possibility is to deprecate custom operator altogether and just use bindTo() method.\n. @tonyxiao \nBindings are the priority, it will always stay like that, but bindings are, in their nature, reactive. \nMain improvement in v4 is that Bond now makes clear distinction between two different concepts: Observing (i.e. binding) - vs - State change. \nObserving/Binding in now implemented through the Observable class. It has no state, it just sends events to the registered observables. We needed something like this in order to make observing of things like button taps or notifications correctly, without any hacks.\nAs for state, we have two classes that can encapsulate it and provide it with the observing/binding capability. They do that by being subclasses of Observable that generate events when encapsulated state changes.\nScalar, the new Dynamic, is even more powerful, yet lighter. It's no longer burdened with memory management, nor with the disposal of Bonds. Bond, a class that had two arrays of back-references to  bound Dynamics for the sake of memory management has been completely deprecated in favour of a plain closure.\nSomething that I'm very thrilled about is Vector class. It improves upon its predecessor, the DynamicArray, on multiple levels. It no longer requires special kind of a Bond. Changes are delivered as events, sequentially, so it no longer requires various listener closures for different events. It can properly support batch updates and translate those into UICollection/TableView batch change sets.\nThose classes are much better now when they are backed by the Observable. Yes, having the Observable allows you to do reactive programming with Bond, but it's by no means a requirement.\n. @banxi1988 @tonyarnold @ivanmoskalev \nI'm currently leaning towards supporting both the bindTo() method and the old ->> operator in a way that the method will be preferred way to go and used in the documentation.\n. Thanks @bddckr!\nI'm still trying to find the best way to incorporate KVO. I'm currently exploring having Scalars (ex Dynamics) as KVO observers. It would allow you to do something like this with Realm (https://github.com/realm/realm-cocoa/issues/601):\n``` swift\nclass Dog: Object {\n  dynamic var name = \"\"\n  dynamic var birthdate = NSDate(timeIntervalSince1970: 1)\n}\nextension Dog {\nclass Observable {\n    let name: Scalar\n    let birthdate: Scalar\ninit(dog: Dog) {\n  name = Scalar(object: dog, keyPath: \"name\")\n  birthdate = Scalar(object: dog, keyPath: \"birthdate\")\n}\n\n}\nfunc observableVariant() -> Dog.Observable {\n    return Observable(dog: self)\n  }\n}\nlet myDog = Dog().observableVariant()\nmyDog.name.observe { newName in\n  print(newName)\n}\nmyDog.name.bindTo(nameLabel.bnd_text)\nrealm.write {\n  myDog.name.value = \"Jim\"\n}\n```\nScalar would retain its target object. It would also update value of key path when its value changes (ie it would be bidirectional).\nWhat do you think?\n. Those are good points. I'm willing to rename those types.  I'd favor the name that consists of only one word, but the descriptiveness of ObservableValue and ObservableArray might be a reasonable compromise. \n. Value - Array combination nicely translates to the underlying dimensions - single element vs. the collection of elements - and it also describes statefulness of the type. \nAs for the first part, I'm also in favor of Observable because it describes the type better. With Bindable it can be unclear whether that is something that can be bound to or something that binds to something else.\nThe length I don't like but since this is clearly impossible to make ideal we will have to compromise.\n. I'm glad we're having this discussion. As @ivanmoskalev, this should not be taken lightly.\nI like that spitball, @tonyarnold, but I'll have to see if it is possible. There already exists class Observable that does not hold state. Scalar and Vectors are like stateful Observables. Stateless Observable is used for things like buttons taps.\n. I can easily make this work for scalar values. Arrays are bit trickier, not sure if it is even possible. Problem is that the array Observable does not send events of an Array type, but of an ArrayEvent type that describes the change that just happened, like .Insert(element: T, atIndex: Int).\nSupporting \nswift\nlet title = Observable(\"\")\nlet state = Observable(State.Ready)\nis not a problem, but supporting \nswift\nlet messages = Observable([Message]())\nis a problem because the actual type has to be\nswift\nlet messages: Observable<ArrayEvent<Message>>\nAnd there does not seem to be a way to infer that just from the initializer. We would would always have to be explicit like\nswift\nlet messages = Observable(ArrayEvent([Message]()))\nor \nswift\nlet messages = Observable<ArrayEvent<Message>>([])\nor \nswift\nlet messages = Array.Observable([Message]())\nSwift Extensions are just not that powerful yet it would seem.\nI'm still not giving up, though, there might be a workaround through the protocols.\n. I've experimented with this for a while now and it does not seem possible to make Swift infer types in the fashion I described in the previous post.\nTherefore, I'm leaning towards using Observable and ObservableArray. I think those are the simplest and most understandable names to the majority of people.\n``` swift\nenum MessageFeedState {\n    case Ready\n    case Sending\n    case Failed\n}\nclass MessageFeedViewModel {\n    let title = Observable(\"\")\n    let state = Observable(MessageFeedState.Ready)\n    let messages = ObservableArray(Message)\n}\n``\n. @ivanmoskalev, great, I've just pushed it as v4.0.0-alpha.2 :)\n. Hi @bddckr, I'm not sure that I understand why you prefer coalescing observation of different key paths into one observable and then doingif` on the event over having one observable per key path. If retention is the only problem, you could save them into an array of [AnyObject] type, bud ideally you would have a property for each observable. \nYes, Observable will strongly reference the target object through KVOHelper. \nHaving a disposable manage lifecycle of the observable is an interesting idea I'll play with. \n. Glad to hear that, thank you. Yeah, Swift 2.0 made current version much simpler that it would otherwise be....\n. Good question @joshavant. No, there are no breaking changes in sight and all future updates should be just extensions that introduce new capabilities without changing existing APIs.\nIt was not an easy decision to change everything in v4, but trust me, it was necessary in order to make the framework future proof.\n. Thank you @ivanmoskalev, I appreciate that!\n. I think we are ready for the first beta. Merging.\n. Thanks, but this is available in v4.\n. Thanks, I have merged this manually to bond-4.\n. Hmm, are you sure this is related to Bond. Is your cell visible? Is index path good?\n\nReturn Value\nThe cell object at the corresponding index path or nil if the cell is not visible or indexPath is out of range.\n. Are you using Bond 4? Some things have been renamed. Check out Readme can that be found here: https://github.com/SwiftBond/Bond/tree/bond-4. Readme is not yet finished, though, but migration section might be useful. \n. You need to bindTo(imageView.bnd_image) because designated dynamics are deprecated. I'll be adding additional documentation in the following week. \n. Thank you!\n. Thank you, but I don't feel this needs to be part of the framework. If you're using this often, you can make extension in your project. \n. I think it would be enough if we had just something simple as\n\nswift\nextension NSLocale {\n  public var bnd_currentLocale: Observable<NSLocale>\n}\n. Hi @ushisantoasobu,  \nThanks for the PR, but I'm reluctant to do any changes to the currently stable v3 as we are in the process of transition to v4. This is solved in Bond v4 with deliverOn method:\nswift\nsome.image_url\n  .deliverOn(Queue.Background)\n  .map { url in\n    // download and return UIImage\n  }\n  .deliverOn(Queue.Main)\n  .bindTo(cell.avatarImageView.bnd_image)\nThere is a deliver function in v3, but is is not implemented as a method on the Dynamic, rather a plain function that accepts a Dynamic and a dispatch queue.\n. Hi @gvimlan95, how is your data define and how do you set it?\n. Hmm, this is probably due the fact that a Dynamic internally saves the value as an Optional. So the property value is actually of the type [PFUser]??. And it has value: Optional.None. Can you try:\nswift\nif let data = data.value! {\n  print(\"Data value (data.value)\")\n}\nI'll have to fix this in v4.\n. Yeah, it's missing the public initializer. Why are you using Dispatcher anyway and not the Observable?\n. The observable you need obviously does not have an initial value, which is fine. There are two issues with let observable = Observable() approach. First is that there is no such initializer, second is that Swift cannot infer event type because it is not specified.\nFor now, add this somewhere to you code:\nswift\nextension Observable {\n  convenience init() {\n    self.init(lifecycle: .Normal, producer: { sink in return nil })\n  }\n}\nThen you'll be able to do:\nswift\nlet observable = Observable<MyEventType>()\nobservable.next(.EventA)\nI'll improve this use case for Alpha 3 release so that there is no need for the extension.\n. Thank you, @slangley. Looks like your generics are not as bad as you think :) I'll merge it today, I have to get Beta 6 first to check some things out. I guess we will want to rename ObservableArray's splice method to insertContentsOf in order to keep parity with Swift's Array.\n. Thank you @LeeroyDing!\n. Thank you @mblsha! I just have few questions in comments.\n. Looking good now, thanks! In future we might add support for columns.\n. Well, not directly, but you could register a notification handler with Bond 4 for UITextFieldTextDidBeginEditingNotification notification:\nswift\nNSNotificationCenter.defaultCenter().bnd_notification(UITextFieldTextDidBeginEditingNotification, object: self.textField).observe { notification in\n  // your action\n}.disposeIn(self.bnd_bag)\nMake sure you unregister (dispose) the handler when your text field is destroyed. If you are doing this from a view or view controller, the easiest way is to dispose it in the dispose bag attached to view/view controller. bnd_bag is provided as an extension to NSObject and all of its subclasses. \n. Hmm, I was not able to reproduce your issue. How is your UIControl implemented? Does it even sends UIControlEvents.TouchUpInside events?\n. Hi @adly-holler,\nSorry for not responding earlier, I was on vacation. So, you'd prefer beginBatchUpdates/endBatchUpdates methods over performBatchUpdates closure? It would be a compromise of robustness for flexibly/convenience. Might be reasonable in this case. Give me a day to rethink.\n. Hi @adly-holler,\nI think we should keep performBatchUpdates method. Doing begin/end reduces robustness too much. \nWhat you can do easily is create ObservableArrayOperation.Batch operation that contains all operations that you calculated from FRC.\n``` swift\n// on FRC willChange:\nvar operations: [ObservableArrayOperation] = []\n// for each FRC call:\noperations.append(.Insert([1, 2], fromIndex: 0))\n...\n// on FRC didChange:\nlet batchOperation = ObservableArrayOperation.Batch(operations: operations)\narray.applyOperation(batchOperation)\n```\nMake sure you use beta 3. Hope this helps.\n. Thanks!\n. This should work now when we are out of beta.\n. Thank you for your offer. Documentation should be fine for the moment.\n. Thanks for reporting this, We'll make it public.\n. Yes, that will not work because Array is a generic type generalized over its element type. You cannot have elements of different types. Just like Swift Array cannot be initialized with elements of different types: let array = [1, 2, \"a\", \"b\"] does not compile.\nYou could solve this by having your arrays as arrays of AnyObjects, like \nswift\nlet channels = ObservableArray<AnyObject>\nlet photo = ObservableArray<AnyObject>\nObservableArray([channels, photo])\nAnd then downcast when using:\nswift\nlet firstChannel = channels[0] as! Channel\nThis is of course not ideal solution because you loose type information.\n. Hmm, v3 also did not support that. There is no way to make it work at the moment... I'll add this as an enhancement for v4.1.\n. @DenisLaboureyras , @iamtomcat, thanks for your feedback. Would you be able to give me an example of batch operations combinations that crash the app?\n. I'm not having any luck reproducing this... I've setup a simple table view controller and tried your algorithm:\n``` swift\nimport UIKit\nimport Bond\nclass ViewController: UITableViewController {\nlet data = ObservableArray([0, 1, 2])\noverride func viewDidLoad() {\n    super.viewDidLoad()\ndata.lift().bindTo(tableView) { (indexPath, array, tableView) -> UITableViewCell in\n  let cell = tableView.dequeueReusableCellWithIdentifier(\"Cell\")!\n  let element = array[indexPath.section][indexPath.row]\n  cell.textLabel?.text = \"\\(element)\"\n  return cell\n}\n\n}\noverride func viewDidAppear(animated: Bool) {\n    super.viewDidAppear(animated);\ndata.performBatchUpdates { (array) -> () in\n  array[0] = 100\n  array[1] = 101\n  array[2] = 102\n}\n\n}\n}\n```\nAlso tried the case when new elements are inserted:\nswift\n    data.performBatchUpdates { (array) -> () in\n      array[0] = 100\n      array[1] = 101\n      array[2] = 102\n      array.extend([3, 4, 5])\n    }\n... the case when existing elements are removed:\nswift\n    data.performBatchUpdates { (array) -> () in\n      array[0] = 100\n      array.removeRange(1..<3)\n    }\n... and the case when all elements are removed:\nswift\n    data.performBatchUpdates { (array) -> () in\n      array.removeRange(0..<3)\n    }\nMaybe I'm missing some case / combination of updates/inserts/deletes? Can you post the full message it prints - those mismatching number of elements?\n. Thank you @whateverx, I think I now have an idea what is going on wrong here. Insertions+Removes in  performBatchUpdates are are not correctly translated to Table/Collection view 'change sets'. I'll have to revise the algorithm. Hope I'll be able to handle it this week.\n. @DenisLaboureyras and @whateverx, thank you for you feedbacks. Issues with performBatchUpdates should be fixed now.\n@DenisLaboureyras, if you think that your second issue is also Bond related, please open a new ticket. Having dangling view controllers sounds very bad :)\nThanks! \n. Thank you!\n. You are right @joshavant, the readme is incorrect. I thought that CocoaPods supports betas per Semantic Versioning, but looks like that is not the case. \nWe are still in beta though - hope we'll be out by the end of the week - so the best way is actually to put pod 'Bond', '~> 4.0.0-beta3' in Podfile for now.\n. Yes, ObservableSet and ObservableDictionary might be interesting features. I had something like this in mind with Bond 4 but didn't have enough time to implement it. I'll put it in the ToDo list.\nRegarding CoreData, I'm not sure what kind of integration do you have in mind? You could use KVO to bridge scalar values to Bond. Sets would not work. Only way would be to convert them manually to ObservableArrays. Having less than a 100, maybe even 1000, objects in a Set would probably not impact performance in a significant way. CoreData (and even Realm) integration might be another ToDo item.\n``` swift\nclass Person: NSManagedObject {\n  @NSManaged var name: String\n}\nextension Person {\n  class ObservablePerson {\n    let name: Observable\ninit(person: Person) {\n  name = Observable(object: person, keyPath: \"name\")\n}\n\n}\nfunc observableVariant() -> Person.ObservablePerson {\n    return ObservablePerson(person: self)\n  }\n}\nlet p = Person(...).observableVariant()\np.name.bindTo(nameLabel)\n```\n. Do you have these two imports?\nswift\nimport Bond\nimport CoreData\nIt compiles fine for me...\n. This will not be part of Bond, but of its successor. See #200.\n. This will not be part of Bond, but of its successor. See #200.\n. Something like that sounds about right.\nIt may be possible to make NSFetchedController conform to SequenceType protocol and use it as an underlying sequence in events EventProducer<ObservableArrayEvent<NSFetchedController<ElementType>>>. There may be few others generalizations necessary, though, if we want to completely avoid any internal conversions to Array.\nFor example, Table/Collection view extensions require underlying type to be ObservableArray or they will convert it automatically - we should avoid that if we want best performance.\nPS. There is a bug #150 in ObservableArray performBatchUpdates method when used in conjunction with Table/Collection view. I'm working on it right now...\n. Not planned at the moment. \n. Thanks :)\n. Given that the view model instance outlives the view controller, think of what would happen if you do not dispose the observation. If you do only the following in viewDidLoad:\nswift\nviewModel.name\n      .observe { name in\n        print(name)\n      }\nEverything would still work, but name changes would be printed even when your view controller gets destroyed.\nIn v3 we had that unfortunate Bond class that was managing binding/observing, keeping it alive as long as the Bond instance is alive. \nIn v4 everything is changed and observings/bindings are alive until they are disposed. UIKit extensions will automatically dispose bindings when they are destroyed. For example, anything binding to UILabel's bnd_text property will be disposed when that label is destroyed. \nThat being said, you usually don't want your view models outliving the view controllers. If you stick to that rule, you won't have to worry about disposing observers.\n. Another way is to look at the method signature. Any observer is registered with following method:\nswift\nfunc observe(observer: EventType -> Void) -> DisposableType\nThe closure we pass in there will stay registered until dispose() is called on the returned disposable.\n. print is part of Swift 2.0 standard library. println is deprecated.\n\nAlso, in our app's architecture, our view controllers don't necessarily have knowledge of whether the view model will outlive the view controller. Does this mean we would have to append .disposeIn(bnd_bag) to all view model bindings, in this case?\n\nYou would have to manually dispose observations made with observe method. You would not have to manually dispose bindings established with bindTo method because those are disposed automatically.\nI see you understand the observe method correctly:\n\nJust to be sure I understand, are you saying the closure that's passed into observer() will be strongly retained by the receiver (i.e. the EventProducer) until dispose() is called?\n\nThat's right.\nMethod bindTo uses observe internally, but also handles the disposable by attaching it to the passed bindable object so it gets disposed when the bindable is destroyed.\nHere is how it works. Anything that conforms to the BindableType can be passed into bindTo method of an Observable (EventProducer). BindableType protocol defines one method that can be used to get a sink (a closure) used to send events to that object. It accepts a Disposable that it should dispose when it's destroyed.\n``` swift\npublic protocol BindableType {\n  typealias Element\n/// Returns a sink that can be used to dispatch events to the receiver.\n  /// Can accept a disposable that will be disposed on receiver's deinit.\n  func sink(disconnectDisposable: DisposableType?) -> (Element -> ())\n}\n```\nNow to bindTo method. It receives an object conforming to BindableType protocol. First, it creates a Serial Disposable. It's a disposable that can dispose itself plus some other disposable. Then is gets the sink from the received object passing it the serial disposable at the same time. That means that when the bindable gets destroyed it will also dispose our serial disposable. Next, we register an observer that passes events to the bindable using the given sink and we save the returned disposable as the other disposable of our serial disposable. In effect, observe's disposable will be disposed when the serial disposable gets disposed and as I already said, serial disposable will be disposed when the bindable is destroyed. Finally, serial disposable is returned if you, for some reason, want to cancel binding before the bindable is destroyed.\nswift\npublic extension EventProducerType {\n  public func bindTo<B: BindableType where B.Element == EventType>(bindable: B) -> DisposableType {\n    let disposable = SerialDisposable(otherDisposable: nil)\n    let sink = bindable.sink(disposable)\n    disposable.otherDisposable = observe { value in\n      sink(value)\n    }\n    return disposable\n  }\n}\nEventProducer (and so Observable) conforms to BindableType and UIKit extensions are just plain Observables so you get automatic disposing out of the box.\nHope this helps.\n. Closed as outdated.\n. Will make it public.\n. Done.\n. Search for NSTextView here https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226-CH1-SW17.\n. No, there are no breaking changes in sight and all future updates should be just extensions that introduce new capabilities without changing existing APIs.\nIt was not easy decision to change everything in v4 but, trust me, it was necessary in order to make the framework future proof.\nSorry for that week, hope it will pay off in a long run :)\n. Thanks!\n. Unfortunately it is not possible because iOS 7 does not support dynamic frameworks.\n. You're probably right. Thanks will fix it.\n. Fixed in v4.0.1.\n. Thanks!\n. Hi, thanks! Why would you want that? If name is not referenced by anything else, there is not way to change its value, so no point in having it bound to something. Or I'm missing something?\n. You are right, this should be improved.\n. Current version of Bond is conceptually different so there is no easy way to do this. If you really need something like this, check out #200. That project handles this in the way you need.\n. You probably want to do something like this:\n``` swift\n  var filter = Observable(\"\")\n  var allPeople = ObservableArray([])\n  var filteredPeople = ObservableArray([])\nfilter.throttle(0.5, queue: Queue.Main).observe { term in\n    filteredPeople.array = allPeople.filter { contactViewModel in\n      return / filter logic /\n    }\n  }\n```\nOf if both filter and allPeople changes should trigger reload:\nswift\n  combineLatest(filter, allPeople).throttle(0.5, queue: Queue.Main).observe { (term, allPeopleEvent) -> () in\n    filteredPeople.array = allPeopleEvent.sequence.filter { contactViewModel in\n      return true\n    }\n  }\nYou can remove throttle if you want to perform search for every letter user types, but it is usually a good trick to optimise CPU/network usage.\n. Thanks!\n. Sorry for not responding earlier. Are all event producers you need to combine into one event producer of the same type? There was function any in v3 which I forgot to port, but should be simple. Alternatively, we can add additional overloads for combineLatest that accepts more producers. What is maximum number of produces you expect to have?\n. That RAC method accepts a sequence of signals where all signals are of the same type. Same thing could be easily added to Bond.\nIf your event producers are of different type, what type would be the events the combined producer generates? Any?\n. Added up to 10 overloads to combineLatest in v4.0.2.\n. Did you try working with NSNumber instead?\nswift\nlet status = Observable<NSNumber>(object: item, keyPath: \"status\")\n. It's OK to do cast in your case because the value is coming from AVPlayerItemStatus enumeration.\n``` swift\nlet status = Observable(object: item, keyPath: \"status\")\nstatus.observe { rawStatus in\n  let status = AVPlayerItemStatus(rawValue: rawStatus)!\n  ...\n}\n``\n. Yeah, not simple at the moment...\n. It's actually difficult problem. Observables are expected to have value. Currently all methods return EventProducer because some of them might not produce a value, likeObservable(1).filter { false }.value`\n. Have you tried cleaning you project? Sounds like an issue with Xcode...\n. Swift compiler is full of issues...\n. That sounds bad :)\n. Fixed in v4.0.2.\n. It should be a simple improvement. I'll try to do it in next few days.\n. Improved in v4.0.2. Use proxy delegate in bindTo method to specify animation.\n. Save the disposable from the binding...\nswift\nlet disposable = name.bindTo(nameLabel.bnd_text)\n... it will be disposed when the binding is destroyed.\nswift\nif disposable.isDisposed {\n  print(\"Binding inactive\");\n} else {\n  print(\"Binding active\");\n}\nWhy do you need this anyway?\n. That is something you need to create and dispose in prepareForReuse :)\n``` swift\nclass MyTableViewCell: UITableViewCell {\n  let onReuseBag = DisposeBag()\noverride func prepareForReuse() {\n    onReuseBag.dispose()\n  }\n}\n```\nbnd_bag is automatically provided as an extension to NSObject and is disposed when object is deallocated.\n. Hi @thomjordan,\nOnly one data source can be bound to a table view. In your example, only row_4_datasource would end up being bound to table view. That might work, but if content of other datasources (1-3) changes, those changes would not be propagated the the table view. \nIt might be the best not to use NSTableView bindings if you have multiple columns for now. Just setup delegate and data source manually.\nI'll see if this can be improved in future.\n. ReactiveKit supports similar that with zipPrevious method. \n. Hi  @joshavant,\nI would not worry about performance. Having hundreds or even thousands variables would probably not be noticeable. \nOn the other hand, you might improve readability by mapping all the inputs to a boolean value:\n``` swift\nfunc isEntered(string: String?) -> Bool {\n  if let string = string {\n    return string.characters.count > 0\n  } else {\n    return false\n  }\n}\ncombineLatest(firstNameTextField.bnd_text.map(isEntered),\n  lastNameTextField.bnd_text.map(isEntered),\n  emailAddressTextField.bnd_text.map(Globals.isValidEmailAddress),\n  passwordTextField.bnd_text.map(isEntered),\n  sessionUpdateInProgress).map {\n    (firstName, lastName, emailAddress, password, updateInProgress) -> Bool in\n      return firstName && lastName && emailAddress && password && !updateInProgress\n  }.bindTo(signUpButton.bnd_enabled)\n```\nAssuming isValidEmailAddress can accept optional string.\n. You could simplify it even more. Swift is so powerful. You can define extension on an array of boolean event producers that returns event producer that check whether all inputs are true...\n``` swift\npublic extension CollectionType where Generator.Element: EventProducerType, Generator.Element.EventType == Bool {\npublic func allTrue() -> EventProducer {\n    return EventProducer(replayLength: 1) { sink in\n  let compositeDisposable = CompositeDisposable()\n  var truthMap = self.map { e in false }\n\n  self.enumerate().forEach { (index, producer) in\n    compositeDisposable += producer.observe { event in\n      truthMap[index] = event\n      sink(truthMap.reduce(true) { $0 && $1 })\n    }\n  }\n\n  return compositeDisposable\n}\n\n}\n}\n```\nThen you could do:\nswift\n[\n  firstNameTextField.bnd_text.map(isEntered),\n  lastNameTextField.bnd_text.map(isEntered),\n  emailAddressTextField.bnd_text.map(Globals.isValidEmailAddress),\n  passwordTextField.bnd_text.map(isEntered),\n  sessionUpdateInProgress.map { !$0 }\n].allTrue().bindTo(signUpButton.bnd_enabled)\n(I'm writing this in the browser, I didn't test this code)\n. Hi @ushisantoasobu, I don't think that would work. Changes to ignoreNil() will not get propagated back to bnd_text. In effect, that would become unidirectional binding in a direction of TextField -> ViewModel.\nYou should make your username Optional or establish two unidirectional bindings, one of them with ignoreNil.\n. Thank you, this was bad! Fix is out in v4.0.3. Thanks again! :)\n. I'd like to add it but don't have much time to do it. Hope I'll manage something in the following weeks.\n. V4.1 is out with basic support for tvOS.\n. @AnthonyMDev @zdenektopic  You guys will want to check out #200.\n. We'll not do this for Bond.\n. Thank you :)\n. Thanks @manas-chaudhari. This sounds like a reasonable solution, but I don't think that your implementation is correct. You probably want something like this:\nswift\npublic func combineLatest<S: SequenceType where S.Generator.Element: EventProducerType>(sequence: S) -> EventProducer<S.Generator.Element.EventType> {\n  return EventProducer(replayLength: 0) { sink in\n    let compositeDisposable = CompositeDisposable()\n    sequence.forEach { producer in\n      compositeDisposable += producer.observe(sink)\n    }\n    return compositeDisposable\n  }\n}\n. Thanks @manas-chaudhari. I still think that we should call this combineLatest to be consistent with other FRP frameworks out there.\n. You are right :) I'll merge this. Thanks!\n. Yeah, that's because Observable is a class. You could do this by introducing a struct wrapper around Observable.\n``` swift\npublic struct MutableObservable: EventProducerType {\nprivate var observable: Observable\npublic var value: Wrapped {\n    get {\n      return observable.value\n    }\n    set {\n      observable.value = newValue\n    }\n  }\npublic init(_ value: Wrapped) {\n    observable = Observable(value)\n  }\npublic var replayLength: Int {\n    return observable.replayLength\n  }\npublic func observe(observer: Wrapped -> Void) -> DisposableType {\n    return observable.observe(observer)\n  }\n}\n```\nThan, you would use it like this:\nswift\npublic private(set) var name = MutableObservable(\"Jim\")\n. Yeah, that would be a good idea :)\n. Let me do it.\n. Implemented in v4.2.0.\n. @manas-chaudhari, private in Swift refers to file. When you set something to private it is visible only within that file. Playground is just one file. Had your ViewModel been defined in a separate file, this would work.\n. @manas-chaudhari, thanks for the question, I answered in #200.\n. That's much appreciated @tonyarnold. I'll setup the project within next few days, porting what we currently have, so we have something to start with.\n. @ramirez, actually, ReactiveKit has less lines of code then Bond and at the same time more features and better performance. So, hmm, no heavy weight.\n| Framework | Lines of code approx. (CocoaPods stats) |\n| --- | --- |\n| ReactiveKit | 1900 |\n| Bond | 2300 |\n| RxSwift | 7800 |\n| ReactiveCocoa | 10400 |\nI've spent significant amount of time trying to make it as lightweight as possible while at the same time solving deficiencies of Bond.\nDoing ObservableCollection (among other things) for Bond would introduce significant backward incompatible changes I don't want to introduce so that people can continue using Bond if it's enough for them. Who needs additional staff is welcome to upgrade to ReactiveKit.\n. @ramirez thanks, that's appreciated.\n. Thanks everyone! TODOs are listed in issues as enhancements - https://github.com/ReactiveKit/ReactiveKit/issues. Feel free to add/suggest your own.\n. Thank you @frogcjn, that's a good analysis. I'll try to incorporate that.\n. Implemented in v4.2.0.\n. Looking good :)\n. Make your view controller conform to BNDCollectionViewProxyDataSource protocol. Then in bindTo, pass you view controller as proxyDataSource.\n``` swift\nclass ViewController: UIViewController, BNDCollectionViewProxyDataSource {\n...\n  bindTo(collectionView, proxyDataSource: self) { ... }\n  ...\nfunc collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -> UICollectionReusableView {\n    ... \n  }\n}\n```\nLet me know if that works\n. Are you saying that you need two (or more) sections in your collection view? To do that, you must have observable array of observable arrays...\nlet content: ObservableArray<ObservableArray<Content>> ...\nYou work with that just as with any 2D array [[...]]. You don't need lift when binding 2D array.\nPlease put you code in code blocks, it's hard to read it like this...\nhttps://help.github.com/articles/github-flavored-markdown/#syntax-highlighting\n. I fear that you might unnecessarily overcomplicate your code by doing something like that. You should aim for model objects to be simple structs.\nswift\nstruct Bird {\n  var canFly: Bool\n}\nThen updating the dynamic/observable array like \nswift\nbirds[0].canFly = true\nwould send event.\n. Hi @ColinEberhardt,\n1. Not being a native english speaker makes things harder on the documentation front so I appreciate any help I can get on that. No pressure though, if/when you get time.\n2. Sure, feel free to contact me. What's you preferred method of communication? You can drop me an email at srdan.rasic@gmail.com.\nI'd like to make a note on Bond though. As explained in #200, going forward I'll be more focused on Bond's successor, ReactiveKit, and I'll advise people who are starting new projects to go with that instead. Bond does not really scale well and I don't want to introduce many breaking changes so I had to go with the new project. \nThanks for the contact, it's very appreciated.\n. Without doubt, ReactiveCocoa is a great framework. How it solved some problems was very inspiring. I however find bindings important because they simplify MVVM architecture a lot, especially table/collection view bindings. For that reason they are one of main features of ReactiveKit.\nRegarding your example, sure, feel free to share that project with me, I'll try to provide helpful feedback. You know my email and my Skype is same as my Github username :)\n. Hi @morizotter, thanks for the PR!\nI think we'll need to refactor this a bit because we might have redundant reloads with this solution. We should probably go with something simpler. For example, we could have delegate method \nswift\noptional func shouldReloadInsteadOfUpdateTableView(tableView: UITableView) -> Bool\nand then just reload and skip switch in array.observeNew (line 72) and switch in setupPerSectionObservers() when that delegate method is implemented and returns true.\nWhat do you think?\n. Thanks @morizotter!\n. Binding are automatically disposed (removed) when targets (text fields in your case) are deallocated. If you need to do that sometime earlier, store the disposable:\nswift\nlet disposable = TimelineViewModel._actStr.bidirectionalBindTo(actTextField.bnd_text)\nAnd later when you need it dispose it as @clooth said:\nswift\ndisposable.dispose()\n. Check out #187.\n. @DRosadoYew, thanks for the fix.\n@tonyarnold, yep, I've disabled per-commit notifications now.\n. @tonyarnold\nEDIT: Oh what am I even talking. Too early morning. Anyway, they are on for PRs, we'll see how it goes.\n. Hmm, looking at it. You have to specifies files. Problem is that Bond has both iOS and OSX source files in its root sources directory so the matching pattern would be complex.\nI think that getting ReactiveKit to work with it would be simpler as it does not contain OSX files.\n. I've investigated CocoaSeeds further. Their idea of stripping project file and using only sources will not work with Bond or ReactiveKit. Project files contain necessary compiler information and parameters without which frameworks won't compile well. It's not that easy.\nAlso, the code would probably work on iOS7 because frameworks are not relying on any often changing APIs, but I cannot provide any official support.\nIt's unfortunate that iOS 7 represents a lot of targeted users for you. Looking at Mixpanel stats, there is less than 5% of devices that are on pre-iOS8 version globally. In few months when you're done with the app it will be even less.\nIf you really want to use Bond or ReactiveKit the easiest way would be to fork them, lower the deployment target to iOS7 and use the fork with either plain Git submodules or with Carthage.\n. Hi @njtuxy, could you post more details about what have you done?\n. Hi @njtuxy, \nSorry for not getting back earlier to you... Have you found a solution? This looks very simple and I'm not sure what could go wrong here. Have you check that viewDidAppear is getting called? How exactly are you updating contacts array?\n. Hi @AdamSzeremeta ,\nI'm not sure I understand what exactly you're trying to achieve, but is replacing bindings really what you need? You should probably have one Observable per Text Field and then instead of changing bindings, change values of those observables. \n. Hi @JuGoo, could you post your code here? It should work like in that example. Just don't implement UITableViewDataSource but a BNDTableViewProxyDataSource - it has same methods.\n. You have to pass instance that implements BNDTableViewProxyDataSource into bindTo method.\nswift\ndataSourceSection.bindTo(tableView, proxyDataSource: self)...\n. Closed as outdated.\n. Thanks!\n. :+1: \n. Hi @Jkurbs,\nYou're using syntax from old, non-supported, version of Bond. Please check out the readme. On bottom of the page you'll also fined migration guide. But you should read whole readme anyway. Hope it'll help.\n. That's a great article, thank you! Awesome graphics too :)\n. Closed as outdated.\n. Closed as outdated.\n. Thanks!\n. This was fixed at one point.\n. Thanks @adamstener! Could you just update that operator?\n. Coverege is probably using different algorithms. Let's not worry about that right now. I'll merge this. Thank you @adamstener!\n. Hey @ndevenish, sorry for the late replay. macOS supported is very limited, but I in v5 it should work if you're still using it. \n. Hmm, that is quite puzzling. Any additional information you can provide might help. Under what circumstances does it happen? What transformations are applied? Thanks!\n. TLDR: Should have been supported out of the box, but I've missed to implement it. I'll have a fix version released probably today.\nLong story (Good to know!)\nCustomizing binding options can now be done with custom TableViewBond. \nTo understand it, it is best to show how default bindings work. Here is the implementation of bind(to:) method:\nswift\n@discardableResult\npublic func bind(to tableView: UITableView, animated: Bool = true, createCell: @escaping (DataSource, IndexPath, UITableView) -> UITableViewCell) -> Disposable {\n  return bind(to: tableView, using: SimpleTableViewBond<DataSource>(createCell: createCell))\n}\nSo it's an overload that uses something called SimpleTableViewBond. SimpleTableViewBond is just a wrapper struct over a closure that creates cell:\n``` swift\nprivate struct SimpleTableViewBond: TableViewBond {\nlet createCell: (DataSource, IndexPath, UITableView) -> UITableViewCell\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell {\n    return createCell(dataSource, indexPath, tableView)\n  }\n}\n```\nThe important part here is the TableViewBond conformance. That protocol is defined like this:\n``` swift\npublic protocol TableViewBond {\nassociatedtype DataSource: DataSourceProtocol\nvar animated: Bool { get }\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell\n  func titleForHeader(in section: Int, dataSource: DataSource) -> String?\n  func titleForFooter(in section: Int, dataSource: DataSource) -> String?\n}\n```\nWith the defaults:\n``` swift\nextension TableViewBond {\npublic var animated: Bool {\n    return true\n  }\npublic func titleForHeader(in section: Int, dataSource: DataSource) -> String? {\n    return nil\n  }\npublic func titleForFooter(in section: Int, dataSource: DataSource) -> String? {\n    return nil\n  }\n}\n```\nWhat that means is that you can implement your own custom TableViewBond to customise defined parameters. \nYou would do something like:\n``` swift\nstruct MyBond: TableViewBond {\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell {\n    // create cell here\n  }\nvar animated: Bool {\n    return false\n  }\n}\n```\nAnd then do the binding using an instance of your own bond.\nswift\narray.bind(to: tableView, using: MyBond())\nIf you don't like the idea of instantiating cells in your bond type, just wrap the creation closure like the SimpleTableView bond does.\n``` swift\nprivate struct NonAnimatedBond: TableViewBond {\nlet createCell: (DataSource, IndexPath, UITableView) -> UITableViewCell\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell {\n    return createCell(dataSource, indexPath, tableView)\n  }\nvar animated: Bool {\n    return false\n  }\n}\n```\nNow, you can extend a date source signal with a binding method that has additional parameter: animated.\n``` swift\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Error == NoError {\n@discardableResult\n  public func bind(to tableView: UITableView, animated: Bool, createCell: @escaping (Element.DataSource, IndexPath, UITableView) -> UITableViewCell) -> Disposable {\n    if animated {\n      return bind(to: tableView, using: SimpleTableViewBond(createCell: createCell))\n    } else {\n      return bind(to: tableView, using: NonAnimatedBond(createCell: createCell))\n    }\n  }\n}\n```\nBut it'll be easier to just wait for the fix :)\n. Fixed animated argument in v5.0.2.\n. Hi @zach-cmiel, you can use proxy data source. Check out bindTo method: https://github.com/SwiftBond/Bond/blob/master/Bond/Extensions/iOS/UITableView%2BBond.swift#L204\n. @pk1 that's possible with reactive delegates explained in the readme of new Bond v5.\n. Thank you @marciok! Sorry for not merging this before.\n. Thanks!\n. You're right @CallumOz , I'll have to revert this PR. @AlexEdunov you can just set .delegate on your UITableView.\n. Yes, work is in progress! :) There will be Bond 5 with Swift 3 support. You can expect some breaking changes both because Swift is changing and I'm doing a refactoring that will improve performance and simplify the library.\nYou can expect beta in one or two weeks. Final version will be ready with Xcode 8 GM.\n. Currently all effort is on Swift 3. But it should be simple to fork the repo and run migrator to 2.3.\n. Hi @tadasz, Beta 1 is already released. I think we are there 100% feature-wise. I'd just like to have more unit testing before releasing non-beta. \nHopefully it won't take longer than a week. If you're up for some unit testing, it would be great :)\n. Ah, the latest release. I'll have it fixed today. \n\nDen 14. sep. 2016 kl. 10.52 skrev Kersten notifications@github.com:\n@srdanrasic currently ReactiveKit throws an error in SignalProtocol.swift when compiled as a dependency of Bond5 with the latest Xcode 8 release. Any recommended workaround?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hi @Broich, I've just released v5.0.0-beta3. I hope it will work now.\n. Not sure if it's relevant, but make sure that you update git submodules if you are checking out the repo manually. \n. If using carthage, you can do\n\ncarthage bootstrap\notherwise you can do\ngit submodule update --init\nBtw, are you building this through Xcode? \n. Yeah, that's the way to do it :) It's very strange. I just tried clean clone it it works normally for me.\nProblem with SPM is that it is not integrated with Xcode so I wasn't even considering Bond supporting it at this time. How are you using SPM? Maybe I missed certain use cases.\n. @tlandsmancars you need to dispose the returned disposable. Either put it in a dispose bag or save it in an non-named variable if you really don't need it.\nswift\nlet disposeBag = DisposeBag()\n...\nname.observeNext { value in\n  print(\"Hi \\(value)!\")\n}\nor \nswift\nlet _ = name.observeNext { value in\n  print(\"Hi \\(value)!\")\n}\nto ignore it.\nPlease check out this: https://github.com/ReactiveKit/ReactiveKit#-cancellation\n. Hi @patrick-lind, I just added Package.swift.\n. Could you post more details about the issue? What exactly is failing?\n. Hi @chrisjb82, there is something very wrong with your setup. RawStream.swift is no longer part of ReactiveKit. Are you using Carthage or CocoaPods?\n. Hi @duanepfeiffer, please see comments from chrisjb82. He had the same issue. It is something related to CocoaPods.\n. @chrisjb82, hmm, it's not required to dispose bindings, just observations (observe, observeNext). If Xcode is printing warnings to dispose bindings it is a bug.\n. Observe functions are not annotated with @discardableResult because it's important to dispose the observations when you don't need them any more.\nOnly in rare cases you don't really care about disposals. In that case you can do\nswift\n_ = signal.observe { ... }\nor write your own overload of observe* methods that are annotated with @discardableResult if you really want that as default.\n. What issue? Are you using latest CocoaPods?\n. @KarthikV710 skip(1).observeNext {}. No, this is mostly bindings and only basic reactive programming. \n. Hi @Benuuu,\nBoth textField and stringObservable have initial value. In case of textField the initial value is nil but it's still a value of String? type. We have to take someones value as a starting point. Rule is that we take the initial value from the object on whom you call bidirectionalBindTo.\nHope this helps.\nYes, that is a typo in the documentation.\n. Haha, I'm late with unit testing for Bond 5 :) Thanks!\n. I've just released v5.0.0-beta3. It should work fine with Carhage.\nI'm having issues with CocoaPods. But I won't give up! :)\n. Ah, I know what is causing this. I'll have it fixed today. \n. Hey @EEimer, this is now fixed in beta4.\nUnfortunately, I can't release new version over CocoaPods because there are some issues with their servers. If you're using Carthage you should be fine, just update to beta4. Hopefully CocoaPods issues will be resolved soon.\n. Great! Thanks for reporting this. We are still in beta so feedback like yours is very valuable. \n. Hi @robertodias180,\nMake sure your data source is retained by someone. E.g. make it a property in your class.\nFor DisposeBag you'll have to import ReactiveKit. I'll see if I can do something anything that.\n. Hmmm, very strange, I've never encounter such issue. At first is sounded like threading issue, but logic around that is so simple and I don't see any problems.\nCan you confirm that the code that's creating cells in bind(to:) is actually being executed when you scroll down?\n. @robertodias180, yes, but there is/will be alternative. Please check out https://github.com/SwiftBond/Bond/issues/284.\n. Hi @AnthonyMDev, yeah, that was ugly thing. I had it fixed yesterday but could not release due to issues on CocoaPods servers. I retried now and it seems it worked. Please try beta6.\n. Hi @prefect42, yeah, I'm hearing about that often.\nIn previous versions of Bond it was possible to make ObservableArray of ObservableArrays, but that caused more issues than it solved. It had very complicated object/dependency graph so that feature has been removed in Bond 5.\nHowever, DataSourceProtocol and DataSourceEventKind in Bond 5 are designed to support sections. It would be easy to make something like ObservableSectionedArray.\nLet me try to make an example in next few days.\n. Ok guys, since this is often requested feature I decided to push it into Bond v5 initial release. v5.0.0-beta8 introduces new type - Observable2DArray. It's an array whose indices are IndexPaths so it supports sections.\nPlease check out new section in Readme.\nAny feedback is welcome!\n. Hah! :) Thanks for the PR.\n. Makes sense! Sure, feel free to do that :)\n. Super! :)\n. Why exactly do you need a Property and why is Signal not enough?\n. I was trying to see bigger picture, that was not my argument. Also, argument about keeping things lightweight applies only to ReactiveKit. I'm fine with Bond growing.\nThere are two problems with Property for KVO.\n1. Lifecycle management. Property is an object that can be observed while it's alive. When it's deallocated it will signal completed event and terminate. If I just wanted to observe KVO stream or transform it using FRP paradigm I would have to store/retain the property somewhere just to keep it alive.\n2. It duplicates value. In your example, name would be retained by the original object and by the property. I'm aware it's just one additional pointer, but it's not clean approach. It's like a cache so it has a potential to cause issues.\nHowever, I see that there is a room for improvement around KVO. Let me think for a day about this, I might have some ideas to make your use case better. \n. @AnthonyMDev hope a way to make property from dynamic subject as described in #290 will do?\n. Ah, I'll need to update readme. You should do this:\nswift\nextension UITableView {\n  var selectedRow: Signal1<Int> {\n    return bnd_delegate.signal(for: #selector(UITableViewDelegate.tableView(_:didSelectRowAt:))) { (subject: PublishSubject1<Int>, _: UITableView, indexPath: NSIndexPath) in subject.next(indexPath.row) }\n  }\n}\nYou need additional first argument - a subject - that you use to send events to signal.\n. You are right, we should improve that. Let me tackle the problem alongside the update I'm doing for #288.\n. Hey @AnthonyMDev, sorry for the slow progress during the past week. I moved to another country so I had very little time. Fortunately things are settling down now and I got some time during the weekend to work on this.\nPlease check out beta9. \nKVO key path can now be represented using a DynamicSubject so it's bidirectional. Use method dynamic(keyPath:ofType:) to get it. It can be both observed and bound to.\nIn addition, deallocation handling is now improved and observation will be disposed just before the target object is deallocated. Observation does not need to hold a strong reference any more.\nI still did not battle test this, but from extensive play in playgrounds there seems to be no issues. I'll be adding unit tests in following days. Please report if you find any issues.\nIf you really need a property, you can now do following:\n``` swift\npublic extension DynamicSubject {\npublic func asProperty() -> Property {\n    let property = Property(value)\n    bidirectionalBind(to: property)\n    return property\n  }\n}\n```\n. Ah, conversions... It will crash, but I prefer it that way because 1) you can always make it safer yourself and 2) it makes things easier to work with when everything is expected to be convertible - which I think is at least 90% of time. If the KVO signal would be failable, it would not be bindable.\nIf you expect KVO values that are not convertible, you can do conversion by yourself. Observe KVO values as Any? and then convert them manually.\nswift\nlet name: Signal<String, MyError> = object\n  .dynamic(keyPath: \"test\", ofType: Optional<Any>.self)\n  .tryMap { (value) -> Result<String, MyError> in\n    if let value = value as? String {\n      return .success(value)\n    } else {\n      return .failure(MyError.conversion)\n    }\n  }\nThank you for your assistance offer! Problem is that I wasn't sure myself how exactly should this be implement so I had to research a bit first.\n. @AnthonyMDev Just did!\n. Damn. Let's make it a failable signal as default then. Give me a day, I'll have to refactor DynamicSubject to be failable too.\n. Thanks! Actually it did, I forgot to tell you :) This is how KVO interface looks now:\nswift\npublic extension NSObject {\n  public func dynamic<T>(keyPath: String, ofType: T.Type) -> DynamicSubject<NSObject, T>\n  public func dynamic<T>(keyPath: String, ofExpectedType: T.Type) -> DynamicSubject2<NSObject, T, KVOError>\n}\nIf using second method, you get a failable signal (Signal<T, KVOError>) that will fire an error event KVOError.notConvertible when the value is not convertible. You'll have to handle and/or suppress the error before binding such signal using one of the ways mentioned in ReactiveKit docs. I guess suppressError(logging:) will be enough in your case.\n. Yes, this is by design. We have two types here as you have correctly inferred.\n1. DynamicSubject - both a producer and a consumer.\n2. Bond - just a consumer. \nReason Bond is just a consumer is that the underlying component doesn't produce anything. UILabel cannot change its text property on its own. \nOn the other hand, UITextField changes its text property when user writes/modifies text. Any component that produces values (basically any input component, i.e. a component that reads data from the user) is represented with DynamicSubject. That DynamicSubject usually wraps Target-Action or Delegate pattern.\nLet's say that you have a login button and an info label that is hidden only when button is enabled. My guess is that you've been doing something like this:\nswift\nviewModel.buttonEnabled.bind(to: button.bnd_enabled)\nbutton.bnd_enabled.bind(to: textLabel.bnd_hidden)\nProblem is that you're deriving state of one view from the state of another view. With that you're creating a chain of bindings and large chains are bad. They can be hard to debug. You change one thing, five others change to.\nInstead, we should always derive state from the place where the underlying truth lives, in our case from the view model. So we can rewrite that code to something like this:\nswift\nviewModel.canLogin.bind(to: button.bnd_enabled)\nviewModel.canLogin.bind(to: textLabel.bnd_hidden)\nIn other words, we were thinking \"If logging in is possible, enable the button. Also, if button is enabled show the label\" while we should have been thinking \"If logging in is possible enable the button and hide the label\".\nThis is trivial example, but shows the preferred way to go. Just replace X -> Y; Y -> Z to X -> Y; X -> Z.  Hope it helps.\n. Thanks everyone for your feedback. I see the inconvenience. I'm working on some ideas. \n. Unfortunately, making extensions Properties would mean giving up on all the benefits of structs. Current implementation is extremely lightweight.\nHowever, with some additions, they work almost as properties. Value getter is back. You can read it \nswift\nprint(textField.bnd_text.value)\nand if you want to set a new value and trigger an event, use next method\nswift\ntextField.bnd_text.next(\"test\")\nHope this helps! Check out v5.1.\n. Thanks!\n. Makes sense.\n. Yeah, much better! :)\n. Thank for reporting this. Should be fixed now in beta9.\n. 'filterRecursiveEvents' was removed and replaced with something else few weeks ago. Would you mind trying the latest version?\nIf it still persists, there must be something in your code that triggers infinite cycle. If you could trace it it would be great. \n. Glad to hear that :) Thanks!\nI'm not sure. There must had been an implicit cycle where A was updating B and B was updating A. Final release of v5 improved support for such cycles. Hopefully that's what fixed it.\n. Thanks @jechol, I'll take a look during the weekend. \n. Yeah, this need to be improved. Unfortunately it's not that trivial :) \n. Thanks everyone. Support for multiple observers is implemented in v5.1..\n. This could be a bug... I'm investigating.\n. Hi @elementsrtyte, it was fixed last week. Sorry I forgot to notify you. Thanks for reporting this!\n. No, let's merge this, it can be useful :) Thanks!\n. Ah, I made update for beta10 before I saw this. Appreciate you help anyway!\n. I think observeOn was probably not there at the time of PR, but it was added later so docs are now correct. Thanks for the PR @feighter09 anyway!\n. Sorry, I didn't have much time to process this and now it not applicable.. Thanks for pointing this out @sveinhal! The docs should be improved.\n. I'm not sure why are you getting that error, but a simpler way to achieve that would be to implement method collectionView(_:viewForSupplementaryElementOfKind:at:) and then set bnd_dataSource.forwardTo to self (or to whom ever is implementing the method).. Bond 7 favours binder data source subclassing instead of protocol proxies. https://github.com/DeclarativeHub/Bond/blob/master/Documentation/DataSourceSignals.md#advanced-bindings-custom-binder-data-sources. Hmm, I don't think that setting textfield.text ever fired an event, but setting textField.bnd_text.value did. It's not possible to do that any more, although you could simulate it with a dummy binding:\nswift\nSignal<String, NoError>.just(\"new value\").bind(to: textField.bnd_text)\nMake sure you import ReactiveKit (a Bond dependency). \nYou can even write it as an extension on DynamicSubject:\n``` swift\nextension DynamicSubject2 {\nfunc set(value: Element) {\n    Signal.just(value).bind(to: self)\n  }\n}\ntextField.bnd_text.set(value: \"new value\")\n```\nIf you think that this is something that is widely used and should be part of the framework, let's add it as a todo for next version.\n. Planning to make value settable again. \n. Implemented as explained here: https://github.com/ReactiveKit/Bond/issues/291#issuecomment-260435006.\n. Oh, Carthage is picking up latest version I guess... I'll be releasing update to Bond today that fixes this. \n. Ok, I've pushed latests version. We're out of beta now!\n. Great! :)\n. Hi @cowgp,\nThe trick is to use observable properties:\nswift\nclass WLEmail: Object, Mappable {\n    let id: Observable<String?> = Observable(nil)\n    let address: Observable<String?> = Observable(nil)\n    ...\nWithout that, it's impossible to do bindings.\n. Filtering is a very complex feature to maintain. But let's keep this ticket in mind as possible enhancement. \n. Map would be simpler.Let's discuss it for next version.\n. These are back since v5.2.0.. Fixed in v5.1.\n. Looks like this is same as #311. I still haven't found the best solution to this...\n. Closing as duplicate of #311 \n. Unfortunately no. You can only disable animations. \n. Hi @pk1,\nAre you maybe using CocoaPods? If yes, do you have latest version?\n. I guess we could expose the underlying array, but you can always work with the ObservableArray directly. It conforms to Collection protocol.\nIf you really need it as an Array, you can always do let array = Array(observableArray)\n. Implemented in v5.1.\n. \ud83d\udc4d \n. There is a debounce operator in Bond 5 / ReactiveKit that provides such behavior. Unfortunately it's not available in previous versions. \n. Nop, Swift is not there yet. You could use KVO, but that's not a better way.\n. What version of Bond are you using? I think in v5 we are observing all editing events.\n. Yep, they should be consistent. I'll have it fixed. \n. Fixed in v5.0.4.\n. Makes sense :)\n. I've tried the code you posted and it does not seem to cause issues. Can you provide more details like the error messages?\n. Yes, that's allowed, although you probably want them as signals:\nswift\nprivate let urlKVO: Signal<URL?, NoError>\n...\nurlKVO = webView.dynamic(keyPath: \"URL\", ofType: Optional<URL>.self).toSignal()\n. I still don't see how that can be related to KVO. Not saying it isn't, but I don't see a connection.\nMaybe something outside SomeView retains scrollView after SomeView and its WebView are deallocated, so ScrollView outlives its parent WebView and causes problems.\nAdditionally, maybe you should reset all delegates to nil in dealloc if you've set up any. \n. I'll try to research this more in following days.\n. Did you run pod repo update?. Yes.. It would be possible to implement that, basically we would need to expose underlying subject and do minor adjustments. The ObservableArrayEvent still carries source array (i.e. a reference to it).\nThe reason this is not implemented is that such feature can put destination array into invalid state. You could be piping two collections into one and whoever is observing that one would probably see a mess.\nPerhaps you could reorganise your code to work with the same instance of the array?. Since you've put so much effort into that, let's work this issue out :)\nI'll need few days to find the best solution or at least make binding available again.. Implemented :) Also added map and filter operators for observable arrays.. No worries :). You can use tableView.bnd_dataSource.forwardTo = self to forward calls to your own object where you should implement tableView(_:commit:forRowAt:).\nTo quote the Readme:\n\nNote: Protocol proxy takes up delegate slot of the object so if you also need to implement delegate methods manually, don't set tableView.delegate = x, rather set tableView.bnd_delegate.forwardTo = x. Yeah, that's one drawback of it. You can either not conform to the delegate protocol (but still implement the method), or you could just provide dummy implementation since those methods will never actually be called.. Ah :/ When you don't conform to protocol you have to use ObjC name tableView(_:commitEditingStyle:forRowAtIndexPath:). It's something in ObjC-Swift bridging that messes up otherwise.... Is following not working\n\narray.filter { $0 is U }.map { $0 as! U }\n?\nI might have not understood you correctly though :). Yes, that is heavy....\nSince your filter is observable, filtered array is \"a derivative of the filter\", so I think the simplest solution here is to flatMap filter into filtered array.\nswift\nfilter.flatMapLatest { (filter) -> Signal<ObservableArrayEvent<DocumentLayer>, NoError> in\n  if let filter = filter {\n    return children.filter(filter).map { $0 as! DocumentLayer }\n  } else {\n    return ObservableArray<DocumentLayer>([]).toSignal()\n  }\n}.bind(to: mutableFilteredChildren)\nIt would be much nicer if the filter was not optional :). There isn't an easy solution for that :( We could add overload for flatMapLatest that returns ObservableArray, but then one would expect the same for all other operators. That would be a bunch of overloads :)\nYou could implement something like:\n```swift\nextension SignalProtocol where Element: ObservableArrayEventProtocol, Error == NoError {\nfunc asObservableArray() -> ObservableArray<Element.Item> {\n    let array = MutableObservableArray<Element.Item>([])\n    map { ObservableArrayEvent(change: $0.change, source: $0.source) }.bind(to: array)\n    return array\n}\n\n}\n```\n(Unfortunately we have to map ObservableArrayEventProtocol to ObservableArrayEvent).\nHowever, there are ownership issues with such approach. Returned ObservableArray is an instance, so unlike Signal, it will not live until it \"completes\" (because it completes when it dies). That means that you cannot just bind the returned array, you also have to keep a reference to it.\nOn the other hand, do you even need an instance of ObservableArray? If you are using bindings, maybe Signal<ObservableArrayEvent<DocumentLayer>, NoError> is enough.. Unfortunately this is not supported out of the box at the moment. It's good suggestion for an improvement though.. That looks nice! If you can do a PR I'd be happy to merge it.. Released in v5.3.0.. Thanks @mtaweel!. Thanks for reporting this @garie! I've just released v5.3.1 with the fix. I think the issue is limited to (Mutable)Observable2DArray due to how indices are calculated. . Bond v6 is released!\nBtw, let's keep the project structure as is for now. I like the concept of single architecture, but I worry that we might stumble upon some unknown issues. If it becomes prevailing variant in the community we'll reconsider the decision.. Whenever you remove an item, all items that follow are shifted one place left so eventually you'll try to remove item at non-existing index path. Therefore, you have to delete items in reverse order. If you do reversed() just before forEach, I think it should work.  \nAnyway, it's a helpful feature, so let's plan it as an enhancement :). There is an operator zipPrevious that can help in this case. It combines latest event with the one before it.\nswift\narrayObservable\n  .zipPrevious()\n  .observeNext { prevEvent, newEvent in\n    switch newEvent.change {\n    case .deletes(let indices):\n        for index in indices {\n            if let deletedElement = prevEvent?.source[index] {\n                // deletedElement\n            }\n        }\n    default: break\n    }\n  }\nNote that prevEvent is optional, because the first element does not have a previous one.. You're right :( The only way to do it for now is to track previous state by yourself. . The integrated diff algorithm does not support moves, everything is insert or delete.\nFrom a quick look, Diff.swift looks interesting and much better solution. Let's add it as a todo for Bond 6. . Implemented.. Thanks Tony!\nWhat is the reason for removing support for arrays of indices in insert/delete/update? Individual indices were used in some previous versions of Bond, but it was causing a lot of issues with collection views. I think we'll need to keep that support.. For example, here: https://github.com/ReactiveKit/Bond/pull/346/files#diff-e5735bc52246a85d54712bfa2b9fb07bL129\nSuch operations must be sent as one event or collection view messes up in some cases. Also, it animates nicely if it's one event.\nIf we revert to\nswift\ncase inserts([Int])\ncase deletes([Int])\ncase updates([Int])\nI think you can still do diff at \"one insert, delete or move at a time\". Just send one index in the array :). Additionally, if we keep ObservableArrayChange structure intact, we can merge this to master and release it as v5.4 since we are not introducing breaking changes. . No worries @tonyarnold, we are not in a hurry :)\nBtw, tomorrow I'm traveling so not sure if I'll be available.. I'll merge this and fix SPM.. Ahh, Diff.swift v0.4 is not released over CocoaPods so we are blocked at the moment.\nI've opened a ticket at https://github.com/wokalski/Diff.swift/issues/30 so hopefully we'll have it unblocked.. The author released v0.4.1 over CocoaPods, but I'm having issues with releasing Bond:\nValidating podspec\n -> Bond (5.4.0)\n    - ERROR | [iOS] unknown: Encountered an unknown error (Unable to find a specification for `Diff.swift (~> 0.4.1)` depended upon by `Bond`) during validation.\nNot sure what's the issue. I tried cleaning CocaPods cache, tried resetting master repo.... Thanks for helping out @wokalski! \ud83d\ude47  \nNo worries @tonyarnold, we can solve everything. Final piece of puzzle was to use correct name in Podfile. It's 'Diff', not 'Diff.swift' \ud83d\ude03 \n. @cre8it, you can keep your optional if you do\nswift\nviewModel.ProfileCompleted.ignoreNil().bind(to: ProfileCompletedImage.bnd_isHidden). There is a simple was to observe notifications, so you can do\nswift\nNotificationCenter.default\n  .bnd_notification(name: .UITextViewTextDidBeginEditing, object: myTextField)\n  .observeNext { notification in\n    guard let textField = notification.object as? UITextField else { return }\n    textField.textColor = .red\n  }\nYou could even write an extension on UITextField  and expose it as a Signal.\n```swift\nextension UITextField {\nvar bnd_isFirstResponder: Signal<Bool, NoError> {\n\n    let begin = NotificationCenter.default\n        .bnd_notification(name: .UITextViewTextDidBeginEditing, object: self)\n        .map { _ in true }\n\n    let end = NotificationCenter.default\n        .bnd_notification(name: .UITextViewTextDidEndEditing, object: self)\n        .map { _ in false }\n\n    return merge(begin, end).start(with: isFirstResponder)\n}\n\n}\n```. You need to link the frameworks with the test target too, like you did with the app target.. Thanks @adenisonafifi for these great updates! :)\nI'm not sure there is a simple way to do update test. If you can come up with something, great, otherwise I'll do it at some later point.\nI have just one comment.. Hi @YouKnowOJ,\nBond uses ReactiveKit under the hood and some types like Disposable are coming from it. import ReactiveKit should fix your problem.. Unfortunately that's not supported. If you really want to trigger an event programatically, you can do:\nswift\ntextField.text = \"...\"\ntextField.sendActions(for: .editingChanged)\n. Yes, that makes sense. Thanks @jechol !. Makes sense :). Hmm, I'm not sure I can correctly decide :)\nWe don't have to limit things to Bonds, but we should include only what's applicable generally. It's also important that the features we include don't restrict normal usage. For example, in earlier versions of Bond, when using table/collection view bindings, it was very hard to implement some delegate methods. \nIf you have something you think would be a good fit, you can do another PR. I'll merge this :). I wander why the tests are failing. Any idea?. Don't worry about this too much @tonyarnold, I'll also have a look. :). Thanks @tonyarnold!. Is AppKit KVO compatible? :)\nWhat's the reason behind having all these as DynamicSubjects instead of Bonds?. This looks great - merging :). Sorry for the late replay, but you'll have to create dispose bag in the cell and dispose bindings there. Then, dispose the bag on each prepare for reuse.\n```swift\nclass PhotoTableViewCell: UITableViewCell {\nprivate let bag = DisposeBag()\n\nvar photo : Photo! {\n    didSet{\n        //binding\n        photo.photoAuthor\n           .bind(to: self.photoAutherLabel.reactive.text)\n           .dispose(in: bag)\n\n       ...\n}\n\noverride func prepareForReuse() {\n    bag.dispose()\n}\n\n}\n```. Fixed in v5.4.2. Thanks @houga for reporting this.. Great, thanks a lot @mtaweel!. Great, appreciate the verification :) . If that's the case, sending NSControl itself sounds like an on solution, but may I also suggest another one. Let the user specify interrogation closure\nswift \npublic func controlEvent<T>(_ read: @escaping (NSControl) -> T) -> SafeSignal<T>\nso that he can do\nswift\ncontrol.controlEvent { $0.integerValue }.observeNext { number in ... }\nBut you are the master of AppKit, you choose :)\nAs for the second question, NSButton.reactive.state as DynamicSubject<Int> sounds reasonable. Because you are using KVO, just make sure that you are not missing triggerEventOnSetting: false in dynamicSubject(...).\nIf doing $0.set($1, forKey: UserDefaultsKey.showCanvasInformationMessages) triggers event on self.keyPath(UserDefaultsKey.showCanvasInformationMessages, ofType: Optional<Bool>.self).eraseType(), then you need to set triggerEventOnSetting: false or you'll end up with duplicate events :). It's not imperative as most of those extensions are just reactive representations of corresponding properties. I'm merging this, thanks @tonyarnold!. Hi @svachmic, thanks for the well defined question :)\nBinding to a table view will overtake table view's delegate your EditTableViewController won't be a delegate any more.\nTo restore the delegate, you should set tableView.reactive.delegate.forwardTo = self (or  tableView.bnd_delegate.forwardTo = self in v5).\nCan you try and see if it helps?\n. Can you do it before defining the binding? :). Ok, we'll find a way :) I'm looking for solutions now.. Ok, there was a bug :) I've just released v5.4.3 with the fix.\nOh, and I meant data source, not the delegate: self.tableView.bnd_dataSource.forwardTo = self. But still, please update the dependency :). Damn, there was something wrong with the tag. I've fixed it as v5.4.4. Please check out.. Good :). Yeah, it makes sense for the selectedItem and family to be dynamic subjects as they are driven by user input.. Ah, cool :) I guess in that case we can also loosen the extensions constraint be removing Element.DataSource.Item: AnyObject.. I don't think we need, because one will be able to get that by doing Array<String?> so Item will be String?.. Thanks for the PR @tomaz! I like where this is going, but may I suggest looking at the UITableView binding: https://github.com/ReactiveKit/Bond/blob/master/Sources/UIKit/UITableView.swift#L39.\nIt goes even further and moves event application onto the configurator (called bond, but it might not be the best name). It uses associatedtype DataSource: DataSourceProtocol to get the right type.\nDo you think you could do something similar?\n. I'm wondering whether to rename TableViewBond protocol to something else. At least we should do UITableViewBond so that we can do NSTableViewBond for AppKit. . This is very nice now. Thanks @tomaz :). Lift is not needed any more. Check out the example in readme :). Since there are a lot of changes, I'd recommend rereading the README. There is an example of how to bind ObservableArray:\n```swift\nlet posts: ObservableArray <[Post]> = ...\nposts.bind(to: tableView) { posts, indexPath, tableView in\n  let cell = tableView.dequeueCell(withIdentifier: \"PostCell\", for: indexPath) as! PostCell\n  cell.post = posts[indexPath.row]\n  return cell\n}\n```\nJust remove the lift. Also, index path is now second argument of the closure instead of first.. Lift was used to convert 1D array into 2D arrays, but now you can use both 1D and 2D array without lifting.. I'll need few days to think about this :) I agree though, it would be nice to see sorting again. . Hi @iandundas, I didn't get much time to work on this recently. I want to do it but not sure when I'll get time. We would need a bit more performant implementation.. Sorting is back!. That looks bad :(. Just pushed v5.4.5 with the fix. Collections are hard.\nThanks for the detailed issue report! :). Ok, I've just merged fixes. You can use \"master\" if you wish instead of latest beta. I hope I'll release v6 over the weekend. Need to do some final tests :). You found a deeper problem :) I'm working on it.... Forgot to tell you, but this should be fixed in v5.4.6 and v6.. I'd go over ReactiveKit readme and see how Signal works.\nIf you need specific advice, please post a code sample.. @iandundas is right, additionally you can also use SafeReplaySubject to get previously sent events as in your example.\nvar bnd_lastDeal = SafeReplaySubject<Deal>()\nbnd_lastDeal.next(deal)\nbnd_lastDeal.observeNext { (deal) in\n    ...\n}\nbnd_lastDeal.bind(to: view.bnd_lastDeal) // signal only new values. Truth is, it was not intended to work that way. It's strange that your received \"Immediate\" in first example.\ntextField.reactive.text fires an event when it receives UIControlEvents.allEditingEvents, but that event is not being send when we update textField.text from the binding. \nIn other word, DynamicSubjects fire only on user events. We could reconsider this decision, but I'll need to confirm it does not have any unintended side-effects. . The two frameworks solve the same problem in slightly different ways so using them both in the same project would be redundant (unless during the transitional phase).\nIf you already have RxSwift deeply integrated and don't think that nicer syntax is worth the migration, I'd just keep it as is. RxSwift a great framework and you might get some of Bond's syntax features with few extensions of your own.\n. Thanks. I'll release a new version later today. . @LakhV, thanks for such a detailed issue report! :)\nYes, seems this was a bug in Bond. I've just released v6.0.1 that should fix this.. Thanks @tonyarnold!. Makes sense @tonyarnold, merging :). \ud83d\udc4d . Changing properties (observables) does not change to owner object so there is no way to observe changes of FoobarViewModel instance. However, Observables are Signals, so if you also import ReactiveKit, you can do \nswift\nmerge(name, phone, ...).observeNext { _ in \n  // either name or phone changed\n}\nto get notified when either of the properties change. If you care about individual properties values, you probably want:\nswift\ncombineLatest(name, phone, ...).observeNext { (name, phone) in \n  // either name or phone changed (at least once)\n}\nHope this helps.\n. There were some issues with the diffs in v5. It's fixed in v6.\nIt would be too hard to apply the fix to v5 so your best course of action would be to update. . Yeah, it should have said MutableObservableArray. It's fixed, thanks :). One would conform to BNDTableViewProxyDataSource to implement methods not supported by Bond like section headers and footers and action commits.\nIf you need to provide section headers or footer, create an objects that conforms to protocol TableViewBond and pass that to the binding call instead of createCell closure. Check out my answer here: https://github.com/ReactiveKit/Bond/issues/257#issuecomment-258863323. It talks about animations, but same the concept applies.\nIf you need to implement some other methods from the UITableViewDataSource protocol, like tableView:canEditRowAt:, conform to UITableViewDataSource protocol as you normally would and implement it like this:\n```swift\nextension MyViewController: UITableViewDataSource {\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    fatalError(\"Implemented by bindings.\")\n}\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    fatalError(\"Implemented by bindings.\")\n}\n\nfunc tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\n\n}\n```\nFirst two methods will never be called as they are implemented by the bindings so you can provide a dummy implementation to silence the compiler.\nFinally, instead of setting table view data source, set a proxy for reactive data source.\nswift\ntableView.reactive.dataSource.forwardTo = self\nHope this helps.. @softvision-catalinmustata you can use non-animated binding to achieve that:\nswift\ndata.bind(to: tableView, animated: false) {... }\n. Hmm, there has to be. Maybe Xcode does not show it because it is defaulted.\nhttps://github.com/ReactiveKit/Bond/blob/master/Sources/UIKit/UITableView.swift#L114\n. Ah, so you have a custom implementation :) In that case just implement apply method on your TableViewBond  like this:\nhttps://github.com/ReactiveKit/Bond/blob/master/Sources/UIKit/UITableView.swift#L104. WatchOS is not in the plan for now. However, ReactiveKit now provides inline bindings and key path bindings that can be used to solve much of the binding problems without the need for Bond. . Thanks @tonyarnold ! :). Hi @timothyarmes,\nemailField.reactive.stringValue is of type Bond<String>, while your observable is String?. For bidirectional binding to work, both must be of same type. Unfortunately Swift is not very good at error messages sometimes.\nThat being said, you probably want to bidirectionally bind to  emailField.reactive.editingString because that one gets changed when user inputs text.\nHope this helps :). Hi @kevinvugts,\nCheck out ReactiveKit docs on Disposing and see if that helps.. Thanks for reporting this @grzegorzkrukowski. The right solution here is to use observeNext as you pointed out. I'll update the documentation.. Hey @alistra \nMain queue is enforced only in the binding, i.e. only when you bind a signal to DynamicSubject. If you observe DynamicSubject you are observing on the thread wherever the events are sent from.\n```swift\nlet subject = object.keyPath(...)\nsubject.observeNext {\n   // called wherever KVO's observeValue(forKeyPath:of:change:context:) was called from\n}\n// However:\nsomeSignal.bind(to: subject) // will update subject on .main\n// You can do following instead:\nsomeSignal.observeOn(.background).observe(with: subject).dispose(in: bag) \n```\nHowever, you have a good point. Bindings should not be limited to main queue. I have an update in plan that will allow bindings to be used on other queues / threads.. I've just released v6.2.0 with support for bindings from other threads. This also upgrades KVO methods to support other context.\nswift\nfunc keyPath<T>(_ keyPath: String, ofType: T.Type, context: ExecutionContext? = nil)\nFor example, to update from wherever the signal is sending, do\nswift\nobject.keyPath(\"name\", ofType: String.self, context: .immediate)\nTo update from background queue, do\nswift\nobject.keyPath(\"name\", ofType: String.self, context: .background)\nDefault updates on main queue.\nswift\nobject.keyPath(\"name\", ofType: String.self)\nHere is more on the implementation:\nhttps://github.com/ReactiveKit/ReactiveKit#binding-targets. Thanks @alistra! You are right, I will probably have to narrow the conformance down to UIKit objects. I really thought I tested extension override, but apparently I did not :) Narrowing the conformance seems like to right thing to do anyway. I will make the changes tonight.. Check out v6.2.1 @alistra. I think this should be it :). Thanks for suggestion @lucianomarisi! It's implemented in latest version. https://github.com/ReactiveKit/Bond/blob/master/Sources/Bond/UIKit/UIAccessibilityIdentification.swift. Damn Xcode that does not support support Swift modules properly.\nI'm ok with having everything in one directory, but it will be harder to define Podspec excludes for iOS/macOS. Any ides on that?. Hey @tonyarnold,\nYeah, I've been reading more about SPM. It still is very experimental. I'm surprised it's evolving so slowly. Carthage for example was up and running in half of that time.\nWhat if we move everything from Sources to Sources/Bond? That way we would have module Bond that can have arbitrary number of subdirectories - which are not treated as modules. We could then add exclude directory Sources/Bond/UIKit to Package.swift.\nAlternative approach could be flattening the directory structure and using configuration macros #if os(iOS) / os(tvOS) / os(macOS) in all files. We could then have all files part of all targets. That would make both SPM and CocoaPods simpler to manage. I might actually be in favour of this approach. What do you think?\nUsing any approach, one thing still remains though. How do we handle BNDProtocolProxyBase class that is written in ObjC. . Released as 6.2.3.. Hi @pk1,\nCan you try with non-animated binding: bind(to: cardsTableView, animated: false) { ... }. UITableView does not really work well when appending a lot of items at the end.\nNext thing I would try is saving the content offset in reloadData. Make a subclass of UITableView and override reloadData.\n```swift\nclass MyTableView: UITableView {\noverride func reloadData() {\n    let offset = contentOffset\n    super.reloadData()\n    contentOffset = offset\n}\n\n}\n```\nUse your subclass instead of UITableView to instantiate the table view then.\nNote that reloadData is called only if binding is non-animated or if you use replace method instead of append:\nswift\ndataSourceArray.replace(with: dataSourceArray.array + newPageArray). This is awesome job @tonyarnold! \ud83c\udf89 \nI could not get it compiling though. Here is a screenshot. I made a clean build (deleted DerivedData too).\n\nThere seems to be some issues with BNDProtocolProxyBase target. I was able to get macOS target building with some combination of building dependencies first, but iOS still has issues, hmm. \nThinking now... Do we even need BNDProtocolProxyBase as a separate target in Xcode project? It makes sense to have it with SPM, but in Xcode project could we just make BNDProtocolProxyBase.h and BNDProtocolProxyBase.m part of Bond-iOS/tvOS/maxOS targets like they were before. \nWe would then import the target only if building with SPM. To do that, we could define -DIS_XCODE_BUILD in Other Swift Flags and in s.compiler_flags = '-DIS_XCODE_BUILD' in Podspec and then import if it is not set.\n```swift\nif !IS_XCODE_BUILD\nimport BNDProtocolProxyBase\nendif\n```\nWhat do you think?\n. Yup. I'd really love to see it more integrated with Xcode and with support for all platforms too.\nThanks for this updates! Everything seems to work now so I'll merge and release.. Hi @Burtan,\nIt's a bug in Swift compiler. You can avoid it by passing initial value:\nswift\nlet bla = MutableObservableArray<String>([]). You are right, I should. Btw, are you on Xcode 8.3?. Yeah, seems to be fixed :). Hi @natalia-osa,\nThanks for the detailed issue! I've experienced something similar once and the solution was to clear Carthage caches and rebuild. Cache is located at ~/Library/Caches/org.carthage.CarthageKit.\nHowever, I think there might be another problem because of updates to ReactiveKit. The best long-term solution would be to update Bond to latest v6, but I'm going to make an update to v5 that fixes ReactiveKit compatibility.\nGive me few minutes.. Ok, @natalia-osa @pixelrevision, I've just released 5.4.7 that fixes the issue. Please try updating the dependencies.\nEDIT: It will be 5.4.8 if using Carthage. . Great to hear that! :). That is very strange since we are setting the configuration flag/directive in Podspec. \nI'll look into this later today. . Hi @rvangraan,\nI just tried creating a new project and installing Bond via CocoaPods from scratch and everything went fine.\nThe directive is properly defined in Podspec: https://github.com/ReactiveKit/Bond/blob/master/Bond.podspec#L29\nDo you maybe have some kind of custom CocoaPods integrations or anything that might affect build settings?\nIf you do have custom build configuration that overrides CocoaPods' ones, make sure that SWIFT_ACTIVE_COMPILATION_CONDITIONS setting contains constant BUILDING_WITH_XCODE.\n. Hi @nabileisa, would be be able to send a demo project where this is happening? When I create a new project and add Bond pod I have no issues compiling it.. Thanks @nabileisa, that helped a lot! \nLooks like there is an issue with CocoaPods not correctly setting SWIFT_ACTIVE_COMPILATION_CONDITIONS. I've worked around this by using OTHER_SWIFT_FLAGS instead for now.\nPlease try 6.2.4.. Are you trying to implement table view with multiple sections? In that case I would suggest looking into Observable2DArray. \nObservableArray containing other ObservableArrays cannot be used to achieve table view with multiple sections.. ObservableArray containing other ObservableArrays is a very complex structure and it would be hard to implement proper bindings with multiple sections. In conformance to DataSourceProtocol, ObservableArray always returns 1 for numberOfSections.\nHopefully you'll get it up and running with Observable2DArray. It should be much simpler to manage. Feel free to ask more questions if something is unclear :). Hi @Burtan,\nWhen you bind to a table view, the binding sets itself as a data source, so your data source does not get called. \nWhat you have to do is set tableView.reactive.dataSource.forwardTo = self to forward the invocations that the binding does not handle to your own object that conforms to UITableViewDataSource. You will still need to provide required methods (numberOfRowsInSection and cellForRowAt), but you can just have a dummy implementation since they will not actually be called.. You can use merge operator:\n```swift\nimport ReactiveKit\n...\nmerge(o1.eraseType(), o2.eraseType(), ...).observeNext { _ in \n   // called when either observable fires an event\n}\n```\nMerge works on signals (observables) of the same type. If all your observables are of the same type, you can omit eraseType calls.\nThere is also combineLatest that you might find helpful.\nhttp://rxmarbles.com/#merge. Hi everybody,\nthis is actually possible by creating a type that implements protocol TableViewBond. You need to implement methods func apply(event: DataSourceEvent<DataSource, BatchKindDiff>, to tableView: UITableView) and func cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell.\nCheck out how Bond implements it by the default: https://github.com/ReactiveKit/Bond/blob/master/Sources/Bond/UIKit/UITableView.swift#L89\nIf you want configurable animation, do something like:\n```swift\nstruct MyTableViewBond: TableViewBond {\nlet animation: UITableViewRowAnimation\nlet createCell: (DataSource, IndexPath, UITableView) -> UITableViewCell\n\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell {\n    return createCell(dataSource, indexPath, tableView)\n}\n\nfunc apply(event: DataSourceEvent<DataSource, BatchKindDiff>, to tableView: UITableView) {\n    switch event.kind {\n    case .reload:\n        tableView.reloadData()\n    case .insertItems(let indexPaths):\n        tableView.insertRows(at: indexPaths, with: animation)\n    case .deleteItems(let indexPaths):\n        tableView.deleteRows(at: indexPaths, with: animation)\n    case .reloadItems(let indexPaths):\n        tableView.reloadRows(at: indexPaths, with: animation)\n    case .moveItem(let indexPath, let newIndexPath):\n        tableView.moveRow(at: indexPath, to: newIndexPath)\n    case .insertSections(let indexSet):\n        tableView.insertSections(indexSet, with: animation)\n    case .deleteSections(let indexSet):\n        tableView.deleteSections(indexSet, with: animation)\n    case .reloadSections(let indexSet):\n        tableView.reloadSections(indexSet, with: animation)\n    case .moveSection(let index, let newIndex):\n        tableView.moveSection(index, toSection: newIndex)\n    case .beginUpdates:\n        tableView.beginUpdates()\n    case .endUpdates:\n        tableView.endUpdates()\n    }\n}\n\n}\n```\nAfterwards you can use that in the binding:\nswift\ndata.bind(to: tableView, using: MyTableViewBond(animation: .fade, createCell: { ... }))\nTo make it simpler, make a new binding overload with your bond type:\n```swift\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Element.BatchKind == BatchKindDiff, Error == NoError {\n@discardableResult\npublic func bind(to tableView: UITableView, animation: UITableViewRowAnimation, createCell: @escaping (Element.DataSource, IndexPath, UITableView) -> UITableViewCell) -> Disposable {\n    return bind(to: tableView, using: MyTableViewBond<Element.DataSource>(animation: animation, createCell: createCell))\n}\n\n}\n``` \nThen you can do:\nswift\ndata.bind(to: tableView, animation: .fade) { ... }\nHope this helps.\n. Looks like you found a bug @bmetitiri :) Disposing the binding should have cleared the data source completely, but it did not. I've just released 6.2.5 that should fix this.\nThanks for the detailed issue report!. That's not good :). Thanks for the details @garie, I think I know where the problem is now. Working on it! :). Hi @bmetitiri and @garie, I think I have fixed this now. Please check out v6.2.6. Thanks for waiting! :). Thanks for the confirmation @garie!. When rebinding you must dispose previous binding otherwise you end up with multiple bindings and that is not supported.\n```swift\nlet bindingDisposable = SafeSignal<[String]>.just([\"A\", \"B\"]).bind(to: vc.collectionView!) { (array, ip, collectionView) -> UICollectionViewCell in\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: ip) as! VC.Cell\n    cell.label.text = array[ip.item]\n    return cell\n}\nbindingDisposable.dispose() // important if rebinding\nbindingDisposable = SafeSignal<[String]>.just([\"A\", \"C\", \"B\"]).bind(to: vc.collectionView!) { (array, ip, collectionView) -> UICollectionViewCell in\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: ip) as! VC.Cell\n    cell.label.text = array[ip.item]\n    return cell\n}\n```. I know it's late for the answer, but MutableObservableArray does not support sorting. You'll have to make sure to insert items in the right order. . You are right, that is inconsistent. However, I cannot just change it now because it would cause problems for people that are using it in its current form.\nWhat we could do is implement real distinct as, say, unique operator. Here is a possible implementation that you can use until I add it the to framework.\n```swift\nextension SignalProtocol where Element: Hashable {\npublic func unique() -> Signal<Element, Error> {\n    return Signal { observer in\n        var elements = Set<Element>()\n        return self.observe { event in\n            switch event {\n            case .next(let element):\n                if !elements.contains(element) {\n                    elements.insert(element)\n                    observer.next(element)\n                }\n            case .failed(let error):\n                observer.failed(error)\n            case .completed:\n                observer.completed()\n            }\n        }\n    }\n}\n\n}\n```\nI could also deprecate distinct and provide renamed version distinctUntilChanged so we can at some point in future deprecate unique in favour of distinct. \nThanks for pointing this out! :). Thanks :). Fixed in latest release! Thanks for reporting the issues and waiting.. You could wrap your object in an enum :)\n```swift\nenum Item {\n  case article(String)\n  case image(UIImage)\n}\nObservable2DArraySection\n```. That's really strange that you'd get such an error. Are you using latest Xcode with the default toolchain?. Awesome! :). I have a bad feeling about this one. Although it's something that should work, it's probably not trivial for them to implement it.\nI hope I won't have to rename Signal.Element, that would really be a bummer.. Yeah, that's probably going to happen. I'd like to see if Swift devs have some smart suggestions first before committing to the change.. Alternative is to drop the Collection conformance, but would that damage ObservableArray too much.. We'll have something later today - working on it :). Hey everyone! I created a swift-4 branch that compiles with Xcode 9. \nIn order to get it compiling I had to drop Collection protocol conformance from ObservableArray/2DArray/Dictionay/Set types. \nIf you were using methods provided by Collection protocol conformance, you can still use them by calling them on the underlying collection. For example, instead of observableArray.prefix(upTo: 3) you should now do observableArray.array.prefix(upTo: 3).\nNothing is lost from the functional perspective, it's just a bit more cumbersome to use it.. @tonyarnold, I could not find anything related to batched changes that could be affected by this update. Maybe you are observing an issue that exists on previous versions too... Do you have any more details? . @tonyarnold yeah, that seems like a bug :) We should update the array like in else block, but before we send the event. Can you see if that fixes your problem?. These issues should now be fixed as Xcode 9 is supported since 6.3.0.. Hey everyone,\nI'm not sure if we can make it work for specialized table view bonds. For now the requirement is that TableViewBond has to be generic over the data source.\n```swift\nstruct MyBond: TableViewBond {\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell {\n   ...\n}\n\nfunc titleForHeader(in section: Int, dataSource: DataSource) -> String? {\n    ...\n}\n\n}\n```\nI know it's not a perfect solution, but you can always downcast the data source if needed.\n```swift\nstruct MyBond: TableViewBond {\nfunc cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: DataSource) -> UITableViewCell {\n    if let dataSource = dataSource as? ObservableArray<MyObject> {\n        ...\n    }\n}\n\nfunc titleForHeader(in section: Int, dataSource: DataSource) -> String? {\n    ...\n}\n\n}\n```\nI'll see if it's possible to make non-generic table view bonds.. Unfortunately we cannot support older versions of Xcode.. Thanks @tonyarnold! Where did it hurt most?. I guess around QueryableDataSourceProtocol \ud83d\ude20  It's the same problem as Signal - Collection conformance conflict.. Thanks for reporting this @frankschlegel! Was it beta 3 that your tired with?. Hey @frankschlegel, do you know if this is still an issue?. Damn :) Do you mean like app projects, or we need to disable it in the frameworks? . This is now fixed by Carthage. I'm closing the issue.. Hey @dorad007! \nThere for the suggestion, however there are already few ways to achieve this so I don't think we need a special type for it. Here is what one could do:\n```swift\nclass C {\nlet firstName: Observable<String>\nlet lastName: Observable<String>\n\nvar fullName: SafeSignal<String> {\n    return firstName.combineLatest(with: lastName) { $0 + \" \" + $1 }\n}\n\n}\n```\nCheck out ReactiveKit README for more info on operators. Bond is built on top of ReactiveKit.\nHope this helps!. Great @tonyarnold! I fixed the ambiguity issue. . Hey @aregler, I'm not sure if that's really the cause, but disposing the observation from a cell in self.bag is logically not good because cells can be reused and you want to dispose all observations in prepareForReuse.\nCan you try disposing button observation in collectionNode.bag. I'm assuming collectionNode is equivalent to cell - I've never used AsyncDisplayKit.\nYou'll also want to dispose that bag when call is reused. Either override prepareForReuse on collectionNode if something like that exists or just before switch cellType { line, do collectionNode.bag.dispose().\nHope this solves the problem. . I was never able to reproduce something like that so I'll attribute this to AsyncDisplayKit and close the issue for now.. Thanks @nayzak for bringing this up!. @DarkByte3PG, how are you compiling Bond? CocoaPods, Carthage, ...?. There are issues with Swift 4 compatibility. Please use swift-4 branch.\nHere is more info: https://github.com/ReactiveKit/Bond/issues/425. It's in CocoaPods guide :)\nhttps://guides.cocoapods.org/using/the-podfile.html\npod 'Bond', :git => 'https://github.com/ReactiveKit/Bond.git', :branch => 'swift-4'. Hey @limeytrader007 - it seems that you are upgrading the an older version. Please check out the migration guide: https://github.com/ReactiveKit/Bond#migration. That's a bug! Thanks for reporting it, I'm looking into it.. This bug has been fixed in one of the previous releases. Sorry for the late notification. . Hey man!\nIn your case you'll need to implement your own delegate methods to provide custom views for headers/footers. You can use Reactive Delegates to implement tableView:viewForHeaderInSection: method if you want to keep bindings. . Thanks, I've applied the fix! :). Hey man!\nThis is expected behaviour - it's logical because labels generate no events (as opposed to text fields for example) so there is no need for such mechanism.\nA way to solve it is to feed recommendationsCounterLabel.reactive.isHidden from the same place you are feeding recommendationsCounterLabel.reactive.text.\n```swift\nlet text = Property(...)\n...\ntext.bind(to: recommendationsCounterLabel.reactive.text)\ntext.map { $0?.isEmpty ?? true }.bind(to: recommendationsCounterLabel.reactive.isHidden)\n```\nHope this helps.\n. Are you on swift-4 branch? . It's very strange that you are getting this error as I have no problem compiling swift-4 branch with Xcode 9b5. Also, looking at the code where the selector is defined - the method does not return an optional:\nswift\nfunc sel_registerName(_ str: UnsafePointer<Int8>) -> Selector\nThis feels more like CocoaPods integration issues.... Are you using CocoaPods? swift-4 branch only works with Carthage or manual integration because I don't know of a way to tell CocoaPods to use specific branch for a dependency. . The problem is when specifying a dependency to another pod, you can't use branch.\nhttps://github.com/ReactiveKit/Bond/blob/master/Bond.podspec#L33\nI'm not sure if there is a workaround around that. . Unfortunately not with CocoaPods at the moment. It's a limitation of CocoaPods. The problem will be solved by the time Xcode 9 is out of beta.. I'm positive. The issue is related to CocoaPods. Until Swift 4 is ready, and both ReactiveKit and Diff.swift (Bond dependencies) are out with Swift 4 version, Bond for Xcode 9 will not be available through CocoaPods. Hopefully, we will be able to solve this within a few days after Xcode 9 is out from beta. \n. I'm pleased to announce that Xcode 9 is supported now - just update to 6.3.0!\nYou can use the framework both from Swift 3.2 and Swift 4 code. \nIf you encounter any new issues, please open a new ticket. Check out this note if you are using observable collections: https://github.com/ReactiveKit/Bond#note-xcode-9-support\nThank you all!. Ah, damn, seems like CocoaPods is still not happy. Can you this this:\nhttps://github.com/CocoaPods/CocoaPods/issues/6791#issuecomment-320028044\nEDIT: Make sure you set it to 3.2, not 3.0.. More info about CocoaPods integration here: https://github.com/ReactiveKit/Bond/issues/460#issuecomment-329277714. @joshtobin If you have added a script to your Podspec as described in #460, you should remove that now.. You are trying to bidirectionally bind Observable<String> with DynamicSubject<String?>. Bidirectional binding only works with the same element type. Define your observable as Observable<String?>.. Hey,\nThere is actually a mistake it that code - it should be observeNext, not observe. I'm going to fix the readme now.\nAdditionally, you have a retain cycle in your code - you should probably do weak self.\nDisposing was not needed in previous versions of Bond, but in reality you almost always want to dispose observations so the compiler will print the warning to remind you of that.\nI also found such approach inconvenient so there is a better way! \ud83d\ude04\nInstead of observing a signal, you can bind it and binding with automatically take care of the disposing and retain cycles. You can get detailed info here.\nIn short, a preferred way to observe signals is like this:\nswift\nbutton.reactive.tap\n    .bind(to: self) { me in\n        me.doSomething()\n    }\nThat code is essentially a simpler way to write this:\nswift\nbutton.reactive.tap\n    .observeNext { [weak self] _ in\n        guard let me = self else { return }\n        me.doSomething()\n    }\n    .dispose(in: bag)\nBond readme craves for some updates. I'll see what I can do, but going thorough ReactiveKit readme is greatly recommended as Bond is build on top of it.\nHope this helps!. Thanks! :). Unfortunately Xcode 9 cannot compile Bond 6.2.6 due to breaking changes in Swift (in compatibility mode too). Only way to use Bond with Xcode 9 at the moment is to switch to swift-4 branch. \nOf course, as soon as Xcode 9 is out of beta, there will be Bond release supporting it. . ~> 3.5.3 only specifies minimal required version. pod update should install the latest compatible version which is 3.6.0. Hmmmmm.... :)\nAnyway, thanks for the PR, let's try it that way. I'm pushing it to CocoaPods now.\n. There is no \"official\" way of doing something like that so what you are doing is not bad :). Unfortunately there is no such operator at this time. . Hey @minsOne,\nThe operators are implemented only in ReactiveKit. Bond does not provide operators. \nI tested your code and it works fine in my project importing both ReactiveKit and Bond.\nXcode can sometimes point to the wrong implementation when you Command-Click the method, but that does not mean the compile is using it.. Ah, you are right about that when arrays are in question. Unfortunately, we cannot just drop ObservableArrayEventProtocol as some other things would stop working.\nWhat you can do is be explicit about the closure types so the compiler knows which operator to use. Instead of:\nswift\nlistSignal.filter { $0.count == 2 }.eraseType()\nDo:\nswift\nlistSignal.filter { (element: Int) -> Bool in\n    return element.count == 2\n}.eraseType()\nHope this helps.. Looks like CocoaPods is trying to compile it using Swift 4. Can you try adding this to your podfile?\nruby\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        if target.name == 'Diff'\n            target.build_configurations.each do |config|\n                config.build_settings['SWIFT_VERSION'] = '3.2'\n            end\n        end\n    end\nend. Great, thanks for the feedback :)\nThis is a limitation of CocoaPods. I'm not sure if there is a way to tell it what Swift version should the compiler use. Here is the official thread on the issue: https://github.com/CocoaPods/CocoaPods/issues/6791\nIn general, I'd recommend using Carthage as it honours project settings, among other things.\n. @mecid  It's true that Diff and Bond are not written using Swift 4 syntax (yet), but Swift 4 compiler can use code written in Swift 3.2 syntax without problems. It's CocoaPods that does not recognise the syntax version nor allow us to specify it manually.\nIntegration with Carthage or manually works flawless.. The script in podfile is no longer necessary as of 6.4.. This is a known CocoaPods issues. Try running pod repo update and then they updating the dependencies again. . Looking good! :). Yeah, there have been many changes... Type Bond is used as a binding point for signals and observables. It does not have .value property as it is pointless because you can just do self.isHighlighted = ..... You've saved the batch updates @tonyarnold! Also, I love the name you chose \ud83d\ude04 \nI'll update Bond to Swift 4 later today.\n. Looking good and thanks for merging the previous PR :). You could specify 3.6.2 in your Podfile.\nHowever, I've just released Bond 6.4.0 that works with ReactiveKit v3.7.x. I suggest you update to that so you're on latest everything (assuming you are on Xcode 9) :)\n. Hey, did you import ReactiveKit?. Yeah, I've been bumping to those things too. Sometimes you can use something you don't import. But I'd say that was a bug in Xcode.. UITextField.text is of String? type, not String :). It's because you bound loginEnteredText to enteredLoginTxt. Either reverse the order or use bidirectional bindings. Please consult readme for more info. . I think you want your signal element to be of an optional type.. I know where the problem is - thanks for reporting this. I'll fix it later today.. I've just released 6.4.3 where this should be fixed. CocoaPods release coming in few minutes... Thanks for waiting :). Awesome, I had no idea about that! :). Thank you for all your updates @tonyarnold! :)\nI would really love to see SPM support for iOS and other platforms. Would make testing easier. But I guess that won't happen any time soon.. Can you try 6.4.3? Thanks :). @tadasz thanks for checking it out. Is your project written in Swift 4?. It's not a code problem. The project compiles without any warning with Carthage or as standalone. It's the CocoaPods integrations that is messing things up and I'm not yet sure where the problem is. I assume it's trying to compile it using wrong Swift version. . This should be working now without any scripts. . What version of CocoaPods do you use? Bond does not support Swift 3 anymore. . You are right, you can't use start(with:) because the control will immediately follow with it's value and it does not work with bidirectional binding.\nSolving bidirectional binding's initial value is actually quite easy. Since both sides must be subjects, you can just reverse the order.\nswift\nviewModel.property.bidirectionalBind(to: myControl.reactive.someProperty)\nBoth one- and bi-directional bindings start with the value on the left hand side.\nSolving one-directional binding is not trivial as right hand side can be anything conforming to BindableProtocol - meaning it might not even have a value to use (eg not be a Property).\nSomething along your extensions could be the answer. You can suppress control's initial value by applying  skip(1) before start(with:). Unfortunately 1 is a guess here that will work in 99% of cases, but could burn you in the remaining 1%. If we had an operator that skips all synchronous events, it would be a better choice, but probably sill not perfect.\nIf your controls are usually represented by DynamicSubjects, you could extend DynamicSubjects and provide bind(to:startingWith) method where you do something like:  \n```swift\nextension DynamicSubject {\n@discardableResult\npublic func bind<B: BindableProtocol>(to bindable: B, startingWith element: B.Element) -> Disposable where B.Element == Element {\n    Signal.just(element).bind(to: self) // set initial value\n    return bind(to: bindable)\n}\n\n}\n```\nIf they are not subjects, maybe just stick with the manual setting of initial value. I can't think of a better idea at the moment :) . Ah, right, because bidirectionalMap is implemented on DynamicSubject. I think this could be moved, or re-implemented, on SubjectProtocol so Property gets it too.. Ok, but don't spend to much time on it if you are stuck. I'll have time later today to look into it too.. I've added bidirectionalMap to Property in 6.4.3 :). Thanks everyone for reporting this. I've just released 6.4.4 that should fix remaining types.. This is very nice @akbsteam, thank you!\nI'll merge and release. I think I'll make just one small change - renaming addGesture to addGestureRecognizer - just to be consistent.. Let's give it a try :). \ud83d\ude05. Thanks! :). Thanks everyone for reporting this. It should be fixed in v6.5.2.. This does not seem like a Bond issue. I hope you have figured it out. . Unfortunately Bond does not support sending an event when you programatically change the value - only when user types something in. . Hi @XavierQuincieux,\nCan you check what version you are using? There have been some fixes around that recently, but v6.5.2 should be good to go. I just run some additional tests and my cells are properly deallocating.\n. I'm puzzled why are you doing insert(model2VM, at: content.endIndex) instead of append(model2VM)?. If this is still a problem, I would suggest batching multiple changes:\nswift\ncontent.batchUpdate { content in \n       content.removeAll()\n       content.append(model1VM)\n       content.append(model2VM)\n}. Due to changes in Swift, ObservableArray could no longer conform to Collection protocol. It's noted on top of the readme under Xcode 9 support.\nYou need to call the method on the underlying array:\nswift\nif let index = fcpRecentLibraries.array.index(where: { $0.url == url })\n. I see two things that need to be addressed here.\nThread safety\nI haven't encountered any problems related to this, but I see how it can cause them. We could change the event protocol per @killev suggestion:\nswift\npublic protocol ObservableArrayEventProtocol {\n    associatedtype Item\n    var change: ObservableArrayChange { get }\n    var source: [Item] { get } // <- this is changed from ObservableArray\n}\nThis would be a source breaking change, but I don't think many people rely on the source type being ObservableArray.\nOn the other hand, we could just change the implementation of the ObservableArrayEvent initializer in a way that makes a copy of the source array.\nswift\npublic struct ObservableArrayEvent<Item>: ObservableArrayEventProtocol {\n    ...\n    public init(change: ObservableArrayChange, source: ObservableArray<Item>) {\n        self.change = change\n        self.source = ObservableArray(source.array) // <- change from `self.source = source`\n    }\n    ...\n}\nThis would ensure that each event has a thread safe copy without any API changes.\nInitially I was in favour of Peter's suggestion, but we also have to think of other collections and make the same change for all of them. In that case the second approach seems like a better solution. \nThis could be a separate PR.\nExtensibility\nWhat do we want to achieve with this? I don't think that subclassing ObservableArray is a good idea to implement a variant of ObservableArray for NSFetchedResultController.\nObservableArray is intended to be a wrapper/decorator over Swift.Array that provides reactive events describing modifications. Is has many things that are not related to something like NSFetchedResultController.\nIn order to make NSFetchedResultController work like ObservableArray, I would suggest defining following:\n```swift\npublic struct NSFetchedResultControllerEvent: NSFetchedResultControllerEventProtocol {\n    public let change: NSFetchedResultControllerChange // or ObservableArrayChange\n    public let source: NSFetchedResultController\n}\n// Following will make any SafeSignal> bindable to table/collection views:\nextension NSFetchedResultControllerEvent: DataSourceEventProtocol {}\n```\nThat defines NSFetchedResultControllerEvent type and enables signals whose elements are of that type to be bound to a table/collection views.\nHaving that defined, one will need something that converts NSFetchedResultControllerDelegate events into such signal. It would probably be an object that is a wrapper of NSFetchedResultController and that implements both the SignalProtocol and the NSFetchedResultControllerDelegate protocol. The object would be the delegate and use a Subject to propagate incoming updates. \nHere is a basic outline:\n```swift\nclass ObservableNSFetchedResultController: SignalProtocol, NSFetchedResultControllerDelegate {\nprivate let subject = PublishSubject<NSFetchedResultControllerEvent<Item>, NoError>()\n\ninit(_ fetchedResultController: NSFetchedResultController) {}\n\nfunc observe(with observer: @escaping (Event<NSFetchedResultControllerEvent<Item>, NoError>) -> Void) -> Disposable {\n    observer(.next(NSFetchedResultControllerEvent(change: .reset, source: self)))\n    return subject.observe(with: observer)\n}\n\n// MARK: NSFetchedResultControllerDelegate\n\nfunc controller(_ controller: NSFetchedResultsController<Item>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {\n    subject.next( event based on type)\n}\n\n}\n```\nin other words, I would suggest treating NSFetchedResultsController as another collection like Dictionary and Set for which we have ObservableDictionary and ObservableSet. As long as its events conform to DataSourceEventProtocol it will be bindable to a collection / table views.\nWhat do you think?\n. Thanks @killev, that is much appreciated. I've opened a separate issue regarding threading - #512. \nRegarding extensibility, not sure what are our goals. @tonyarnold did you have some ideas regarding that?. I like the idea of ObservableCollection that wraps anything conforming to Swift.Collection protocol. We had something like that in an early version of Bond, but Swift.Collection was a mess back then and working with it involved a lot of generic constraints that would crash Xcode all the time. \nI guess ObservableCollection could be defined as:\nswift\nclass ObservableCollection<UnderlyingCollection: Collection> {}\nWith a mutable variant:\nswift\nclass MutableObservableCollection<UnderlyingCollection: MutableCollection>: ObservableCollection<UnderlyingCollection> {}\nIts event could be defined as\nswift\npublic protocol ObservableCollectionEventProtocol {\n    associatedtype Item\n    associatedtype UnderlyingCollection: Collection\n    var change: ObservableArrayChange { get }\n    var source: UnderlyingCollection { get }\n}\nTo be consistent with changes proposed in #512. \nI really like this idea. It could replace all existing observable collections if done properly. . ObservableCollection and MutableObservableCollection are now available in Bond 7. Anything conforming to Swift.Collection can now be made observable. Check out the accompanying playgrounds.. Hey everyone,\nthe issue is caused by a regression in the Swift compiler: https://bugs.swift.org/browse/SR-6609.\nThe fix will be available in 9.3 beta 2, but I'll see if I can make a workaround in the meantime.\n. Workaround is available in swift-4.1 branch. . This is something that would be awesome to have, but since it's a private thing I'd rather not include it. Hopefully something like this becomes available at one point.. Great, thanks @tonyarnold :). You can use inline binding and do the following. Make sure to import ReactiveKit.\nswift\nloginViewModel.isUserSignedup.bind(to: signupButton) { button, signedUp in \n    UIView.animate(...) {\n        button.alpha = signedUp ? 1 : 0\n    }\n}. It seems that you are making multiple bindings to the table view. That is not really supported so you need to dispose previous binding when making a new one.\n```swift\nimport Bond\nimport ReactiveKit\nvar previousBindingDisposable: Disposable?\nviewModel.observableObject.observeNext { [weak self] (observableObject) in\n    guard let oo = observableObject else { return }\n    self?.title = \"\u2116(oo.id)\"\npreviousBindingDisposable?.dispose()\npreviousBindingDisposable = oo.observableArray.bind(to: self!.tableView, createCell: { (dataSource, indexPath, tableView) -> UITableViewCell in\n// cell stuff\n    return cell\n}\n\n}\n```\nUnrelated, but will make you code cleaner: Replace observeNext with inline binding.\n```swift\nimport Bond\nimport ReactiveKit\nvar previousBindingDisposable: Disposable?\nviewModel.observableObject.bind(to: self) { (me, observableObject) in\n    guard let oo = observableObject else { return }\n    me.title = \"\u2116(oo.id)\"\npreviousBindingDisposable?.dispose()\npreviousBindingDisposable = oo.observableArray.bind(to: me.tableView, createCell: { (dataSource, indexPath, tableView) -> UITableViewCell in\n// cell stuff\n    return cell\n}\n\n}\n```\n. Hmm, could it be that you have some layout issues? Bond should not affect layout of table view cells and views so I'm not sure what could be the reason for the overlap. . Check out last two section of https://github.com/DeclarativeHub/Bond/blob/master/Documentation/DataSourceSignals.md on two possible ways to implement that. . ObservableSet conforms to SignalProtocol with elements of type ObservableSetEvent. Table and collection view bindings work only with ObservabeArrayEvent.\nWhat would be required here is to implement an operator that maps ObservableSetEvent into ObservabeArrayEvent. It would probably be a sort operator that sorts the set elements into an array. \nSet has elements in an undefined order. When a new element is added, to order is usually completely shuffled so bindings would only make sense if there were some kind of a sort operator on set. \nSame applies for ObservableDictionary.\nThis is not a trivial work and I do not have the time to implement that, but I'll leave the ticket open as a possible future enhancement. . Bond 7 introduces sortedCollection operator on ObservableSet and ObservableDictionary which enables their binding to table or collection views.. Great work guys, thanks! . Hi @joergbirkhold,\nI have just released v3.7.0 with better support for table view animations customizations. Check the updated documentation.\nAs for the scroll position, that is a problem with UITableView and not related to Bond. Try googling for \"uitableview keep scroll position\". You could subclass UITableView and override methods like insertRows(at:with:) and adjust the scroll position there.\nCheck out this to see how Bond applies events to the table view. You could also implement a custom TableViewBinder and apply them yourself, but not sure if that would help.. Yes, you are right, there are issues UITableViewCellEditingStyle, more specifically, there are issues with ObjC enums. I'm not sure of a way to support that. It should probably be mentioned in the docs.\nWhat you can do is declare the parameter as NSNumber or Int and then instantiate UITableViewCellEditingStyle from raw value (the number).. I have updated the documentation with this so I'll close the ticket:\nhttps://github.com/DeclarativeHub/Bond/blob/master/Documentation/ProtocolProxies.md#important-argument-types. I think you are right. This should be able to move an item to the end. . Hmm, I was about to change this, but array.count + 1 is not the end of the array. The end is at array.count and array.insert(item, at: toIndex) when toIndex == array.count works. \nAre you sure that we have a problem here?. Could it have something to do with NSTableView? UITable/CollectionView expects toIndex to be: The index path of the item\u2019s new location. Docs. That is exactly what we send at the moment. \nNSTableView appears to behaving in the same way, actually.\nWha is your use case? User is reordering NSTableView and you need to update the ObservableArray? \nI've been googling, and there appears to be some adjustments of indices:\nhttps://gist.github.com/sooop/3c964900d429516ba48bd75050d0de0a\nApparently once you start dragging, the item is not yet removed from the NSTableView, so the drop index will be based on the array that still has the dragged item in its original location. It's like copy-paste, not cut-paste. That's why you have to shift toIndex by -1 if the row is being moved down. \nIf I'm correct, then the move method works property and it's up to you to adjust toIndex correctly before passing it in. . Good arguments. ObservableArray is supposed to have something like value semantics - it cannot be mutated from the outside - as opposed to MutableObservableArray which can be mutated by the user. \nThe ability to subscribe to the ObservableArray from the event is a problem though. You are right, it should not even be allowed.\nLet's change the events to send the underlying collection instead. Although it's a breaking change, it should be a minor one.\nWould you like to make a PR? . Cool, no rush.. @killev, yeah, let's not do that since we are doing the collection. . Implemented in Bond 7.. This is gold @tonyarnold!\nMaybe I could give you some help with this. What about SignalProtocol extensions like map, filter and others? Or something else if you prefer. . Thanks Tony. Let me implement some SignalProtocol extensions and see if this can completely deprecate ObservableArray or something.\nI'll merge your PR into observable-collection branch so we can work there and open a new WIP PR into master. . Conditional conformances \ud83d\ude0d\nhttps://github.com/DeclarativeHub/Bond/pull/514/commits/6d080122406b5310ca1a6a64ad9a3388cdf0d255. This seems like a great opportunity to refactor the event type in a way that would solve the current mess regarding diff and patch differences. I'm adding this as a TODO. Already have some draft version locally.\n. @tonyarnold I've pushed what I have so far, but it needs more work. It is not compatible with the DataSourceProtocol at the moment so binding won't work. It'll probably need refactoring of DataSourceProtocol too, along the lines of ObservableCollectionEvent. \nI don't think I'll be able to do anything today or tomorrow, but I plan to get it done over the weekend. . I thought members had write permissions. Fixed!. @tonyarnold the issues with NSOutlineView are caused by TreeNode being a struct. Apparently NSOutlineView requires a class-based tree structure because it operates with node references.\nI added the constraint that only class-based tree can be bound to NSOutlineView, but that means that TreeNode cannot be used with NSOutlineView anymore.\nTo work around, I added TreeNode.Object and TreeArray.Object variants to TreeNode and TreeArray. That means you can define a class based tree like:\nswift\nlet t = TreeArray<String>.Object([\n    TreeNode(\"Child X\"),\n    TreeNode(\"Child Y\", [TreeNode(\"Child U\")])\n])\nswift\nlet tree = MutableObservableCollection(t)\nand then do\nswift\ntree.append(TreeNode.Object(\"Child Y\"))\nClass-based tree nodes don't have value semantics so be careful when mutating node properties through subscripting.\nswift\ntree[[0]].value = \"X\"\nwill not be seen by the observable collection. You need to do something like\nswift\ntree[[0]] = TreeNode.Object(\"X\"). @tonyarnold I see that you already made some updates to Differ regarding Swift 4.1. Do you plan to release a new version that is Swift 4.1 warning free? . I'm planning to bump minor version number for Bond. That's the usual approach as far as I know. I don't think it justifies the major version number update.. Oh and, sure, no rush!. This is super interesting @tonyarnold! \ud83d\udca5 \nI wonder if ObservableTree could use CollectionOperation instead of TreeOperation and then get all the diffing for free. CollectionOperation has same set of cases as TreeOperation and it is generic over Index type so maybe we could fo typealias TreeOperation = CollectionOperation<IndexPath>? \nOr was your idea that this should replace ObservableCollection? \ud83d\ude00 . Another idea: ObservableTree as ObservableCollection<TreeNode> where TreeNode is a Collection with IndexPath for Index.. @tonyarnold I'm thinking what's the best way to port Observable2DArray to our new ObservableCollection type. \nCurrently Observable2DArray is backed by an array of Observable2DArraySection<Metadata, Item> but that will not work well with ObservableCollection.\nWhat seems to be a natural data structure for something like that is actually a tree. I'm playing with your TreeNode, but I'm hitting a wall with child -> parent relationship so I'm wondering is that something we really need? It prevents us from having value typed trees.\nEDIT: To refine my question: Is it something we really need in the protocol? You could still have a class-based implementation of a TreeNode that has child -> parent relationship.  . Oh, no worries, that was not my intention. I started playing with it on my own branch. Don\u2019t have much yet though. . Hey @Maxatma, have you seen this: https://github.com/DeclarativeHub/Bond/blob/master/Documentation/DataSourceSignals.md#advanced-bindings-for-table-views ?. Ah, yes, you should have inited it with createCell. I've just made a patch release 6.7.1 where that is not required so your code should work now if you update. Thank you for reporting this!. I would suggest checking out Bond 7 which favours default binder data source subclassing instead of using protocol proxies.. What version of Bond are you using? There were some changes a month ago and such use cases should now be supported.\nI think the issue here is of another nature. You are defining \nswift\nextension ReactiveExtensions where Base: UIScrollView {\n    public var delegate: ProtocolProxy {\n        return base.reactive.protocolProxy(for: UIScrollViewDelegate.self, selector: NSSelectorFromString(\"setDelegate:\"))\n    }\n}\nwhile there already is\nswift\npublic extension ReactiveExtensions where Base: UITableView {\n    public var delegate: ProtocolProxy {\n        return protocolProxy(for: UITableViewDelegate.self, keyPath: \\.delegate)\n    }\nprovided by Bond.\nNote that UITableView is a subclass of UIScrollView and UITableViewDelegate inherits UIScrollViewDelegate so there is some kind of a collision going on here. \nYou could try doing\nswift\nextension UITableView {\n    var scrolledY: SafeSignal<Float> {\n        return reactive.delegate.signal(for: #selector(UIScrollViewDelegate.scrollViewDidScroll(_:))) { (subject: SafePublishSubject<Float>, scrollview: UIScrollView) in\n            subject.next(Float(scrollview.contentOffset.y))\n        }\n    }\n}\nwhich uses UITableView delegate.. I would suggest checking out Bond 7 which favours default binder data source subclassing instead of using protocol proxies.. I'll close this since it's probably outdated now.. Hey @tonyarnold, how would you implement inserting or deleting objects with those classes? NSFastEnumeration is just an Objective-C style Sequence. So it does not, by itself, support any mutation. \nBtw, I'm using our own RangeReplacableTreeNode to implement editing, not RangeReplaceableCollection. We can change the protocol if needed. The idea is that the conforming class has to implement only one method, replaceSubrange. It then gets all other editing methods for free. . Good point, maybe we should rename that to replaceChildrenSubrange or something like that. Given that you don't have to conform to RangeReplaceableCollection, would you be able to implement replaceChildrenSubrange using the wrapper's existing API? . Alright, that method seems like the thing you are missing. I'm sure it can be implemented with a right combination of insert(at:) and remove(at:) methods. \nMy goal for Bond is to support something like that \ud83d\ude04 \nNote that batching, patching and diffing of the trees is not yet implemented. I'll be working on that today and over the weekend. . Batching, patching and diffing of the trees is implemented \ud83c\udf89  \nswift\ntree.batchUpdate { ... }\ntree.replace(with: otherTree, performDiff: true)\nNote that replace/performDiff will not handle moves across different levels. Those will fallback to D+I. On the other hand, batchUpdate can handle that.\nThere might be some bugs so I'll write some unit tests during the weekend. In the meantime, I'm merging this PR so we can start finalizing the huge work on observable collections \ud83d\ude05 . Unfortunately this would be a source breaking change so we can make it.. Thanks @npvisual! This should now be fixed in 6.8.2. \nUsing platform argument is still recommended though. There is no need to build architectures you are not deploying to.\n. Ignore Travis, there are some configuration issues we have to solve. Thanks for the PR!\n@tonyarnold should we move Bond to macOS 10.11?. .bind(to:cellType:) does not work with cells defined in a storyboards. Please use alternative method .bind(to:animated:rowAnimation:createCell).\nI'll make sure to document this properly.. Hi @ronnie70,\nNo, this is first time I see something like that. I can't think of anything specific to Bond that would cause this. How are you integrating Bond? CocoaPods or Carthage. I'd check is everything properly configured and linked. Also check signing options.   . Hi @ronnie70 @sebskuse I've just released Bond 6.8.3 with code coverage disabled in release configuration. I've also released ReactiveKit 9.3.5 with code coverage disabled in release configuration.\nLet me know if this helps.. I would suggest taking a look at Bond 7 which favours subclassing the default binder data source instead of using protocol proxies.. Swift 4.1 frameworks should be compatible with Swift 4.2 targets. Let me merge this anyway.\nThanks @maurovc !. v6.10 is out with Swift 4.2 support.. I assume this was fixed on the Differ side.. I would suggest taking a look at Bond 7 which favours subclassing the default binder data source instead of using protocol proxies.. Yeah, this is a duplicate of #519. Unfortunately I don't have any update on this at the moment.. Yeah, unfortunately it looks like closures are not supported \ud83d\ude1e . I would use loading signals for something like that.. There must have been something wrong with the syntax.. New version will be shipped in the following weeks without that warning. For now we have to keep it because of the backward compatibility. . I was able to silence that warning before the next major version release. It should no longer be there in v6.10.. Yup, makes sense!. Looks great!. Hi @trevor-sonic,\nit should be possible to implement it through a protocol proxy, but I agree that it is not very friendly.\nI've been working on a refactor of observable collections and their binders over the summer and new version should be ready in following weeks, hopefully before the end of a month. It will be much easier to customize the default binder. . Bond 7 introduces a new way of customizing binders. Binders now conform to UICollectionViewDataSource protocol and can be subclassed to provide additional functionality. Here is an example: https://github.com/DeclarativeHub/Bond/blob/master/Documentation/DataSourceSignals.md#advanced-bindings-custom-binder-data-sources\nIn other words, Bond 7 favours subclassing the binder and implementing additional datasource methods instead of working with protocol proxies. . Hi @madiguzel,\nBoth CollectionViewBinderDataSource and TableViewBinderDataSource implement only UICollection/TableDataSource protocols, the don't implement delegate protocols. \ntableView:viewForHeaderInSection seems to be a delegate method, so you should be able to implement delegate as you normally would. Note that you should also implement tableView:heightForHeaderInSection: if you want UITableView to display custom header views I think.\nIt might we nice to allow the binder subclass to conform to UICollection/TableDelegate so you can have your delegate code in there, but I'll need to make tableView/collectionView property open so you can set it easily.\nAs for collection view, collectionView:viewForSupplementaryElementOfKind seems to be a data source method, so it should work. You might need to set headerReferenceSize on the layout object or collectionView:layout:referenceSizeForHeaderInSection in the delegate. . Alright, I've just pushed to the master brach. You can now do something like this:\n```swift\nclass CustomBinder: TableViewBinderDataSource, UITableViewDelegate {\noverride var tableView: UITableView? {\n    didSet {\n        tableView?.delegate = self\n    }\n}\n\n@objc func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n        // todo\n    }\n}\n```\nI'll make this part of beta 2 in next few days, for now you can point your dependency to master branch if you wish.. Oh, damn. Looks like we are hitting this problem: https://stackoverflow.com/questions/48215689/dispatch-issue-with-generic-subclass-of-custom-table-view-controller\nIf I try\nswift\n@objc (collectionView:viewForSupplementaryElementOfKind:atIndexPath:)\nfunc collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {\n    ...\n}\nthen it works. Apparently there is a bug in Swift when implementing optional protocol methods in a generic subclass. \nI'm not sure if there is an easy easy solution to this or we will have to explicitly specify @objc names. . Awesome @npvisual!. Your custom text property has to be a signal type like Observable/Property. Then you can do currentPINTextField.myCustomTextAsObservable.bind(to: viewModel.currentPIN). Can you send me a link to that Cocoapod?. That is an interesting idea :)\nIf backend requires changes in form of operations on the array that one should perform one after another, then toPatches is what you want. \nreplace method should do the trick if you are just refetching all the data. When you switch to streaming API you could map API feed into Signal<ObservableArrayEvent<Item>, NoError> which you can then bind to a MutableObservableArray.\nNote that there will be some changes to the observable collections API in Bond 7 coming out soon (hopefully by the end of the month).  toPatches will be deprecated because patch will be available on the event itself, along the diff. No functionality will be drop though, so no worries about that.. Binding within a cell should be disposed when the cell is deallocated which should happen when the parent collection view is deallocated. The collection view should be deallocated when the view controller is deallocated which should should happen when it's dismissed/popped. Try adding deinit to the view controller and see if it gets called. \nSomething is probably holding the view controller or a collection view from getting deallocated. I don't see anything wrong in the code you posted, so it's probably elsewhere. \nIt super weird behaviour you are experiencing. Are you sharing a service instance between categories? . @tonyarnold objectValueFor data source method seems to be called in between begin/endUpdates after each patch, expecting the underlying collection to be be patched incrementally as operations are reported by calling insertRows, removeRows, etc.\nThe only solution I can think of is to have the binder keep local clone of the collection, like the outline view binder does.\nThis is different than what UIKit does - waits for all batch operations to complete and then queries the data source. . @tonyarnold NSTableView bindings should be fixed now. The binder is keeping its a local copy of the array. \nRegarding you last question; have you considered subclassing the binder? You'd implement additional data source methods in a subclass.. Great to hear that @tonyarnold! I\u2019ll try to write some docs over the weekend and prepare for a release. . combineLatest needs both signals to emit at least one event, otherwise there is nothing to combine. Because Subject does not have a concept of current value, there is nothing to emit until you explicitly send something with next method. This differs from Property/Observable which emits its current value when you start observing it. \nYour code is fine and the behavior is correct, but I guess you were expecting something else? What\u2019s the problem you are solving?\n. There is a couple of other ways, depending on what you need.\nYou could have subject start with a given element. Since you are working with Void type, you can start the signal with ():\n```swift\nlet string = Observable(\"test\")\nlet subject = SafePublishSubject()\ncombineLatest(string, subject.start(with: ()))\n    .observeNext  { string, _ in\n        print(string)\n    }\n```\nYou could achieve the same with replayLatest operator. It will re-emit the latest string event when the subject emits an event. It's a bit more descriptive that above:\n```swift\nlet string = Observable(\"test\")\nlet subject = SafePublishSubject()\nstring.replayLatest(when: subject)\n    .observeNext  { string in\n        print(string)\n    }\n```\nIf the code within observeNext does not work/depend on the string value, you could use merge operator. Merge operator works on the signals with same type of elements, so you either need to convert String observable into Void or Void subject into String. You can use map for that:\n```swift\nlet string = Observable(\"test\")\nlet subject = SafePublishSubject()\nmerge(string.map { _ in }, subject)\n    .observeNext {\n        // note no event element (string) in this case\n    }\n```. Your mapping closure seems to be missing the first argument - property value (Void). Then it should work. \nWhat about an alternative approach; Let users subclass the binder if they want to provide more functionality. RowCreation, CellHeightMeasurement and IsItemExpandable closures don't seem to be used in the signal extension bind(to:) method anyway. In other words, it user wants to provide row view, let them subclass the binder and implement delegate @objc func outlineView(_ outlineView: NSOutlineView, rowViewForItem item: Any) -> NSTableRowView?.\n(For some reason we need to prefix method with @objc in order of the frameworks to find it in the subclass.). It's unfortunate that we have to implement both NSOutlineViewDelegate and NSOutlineViewDataSource. I guess you'd like to implement NSOutlineViewDelegate elsewhere. Would that be the most common use case? If so, I agree with what you are trying to do, let's provide those method implementations through protocol proxies. \nThe reason behind not using protocol proxies is to make binder subclassing easier, but if NSOutlineViewDelegate is preferred to be implemented elsewhere, then it would make sense to use protocol proxies for that. The same should apply for NSTableView.. Here is an example of using protocol proxies instead of a delegate:\nswift\n    private func associateWithTableView(_ tableView: NSTableView) {\n        objc_setAssociatedObject(tableView, &TableViewBinderDataSourceAssociationKey, self, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        if tableView.reactive.hasProtocolProxy(for: NSTableViewDataSource.self) {\n            tableView.reactive.dataSource.forwardTo = self\n        } else {\n            tableView.dataSource = self\n        }\n        if let createCell = createCell {\n            _ = tableView.reactive.delegate\n                .feed(property: Property(createCell), to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:)))\n                { (createCell: CellCreation, tableView: NSTableView, tableColumn: NSTableColumn?, row: Int) -> NSView? in\n                    return createCell(self.changeset!.collection, row, tableColumn, tableView)\n                }\n        }. Done! \ud83d\udc4d. That's very nice work @Guferos! It would be cool to see if performances could be improved with just released Bond 7 (beta) that refactors observable collections.\nObservable collection are now properties of changeset type, for example:\nswift\ntypealias ObservableArray<Element> = AnyProperty<OrderedCollectionChangeset<[Element]>>\ntypealias MutableObservableArray<Element> = Property<OrderedCollectionChangeset<[Element]>>\nIt feels as though observed changes from RealmSwift.Results could be easily mapped into OrderedCollectionChangeset<RealmSwift.Results> which keeps RealmSwift.Results type so no need to map into the array.\nTo enable bindings, RealmSwift.Results should conform to QueryableSectionedDataSourceProtocol.. Alright, I gave this a try in Bond 7. Here is what I ended up with. RealmCollectionChange maps to OrderedCollectionChangeset so nicely \ud83d\ude04 \n```swift\nextension RealmCollectionChange where CollectionType: Swift.Collection, CollectionType.Index == Int {\nfunc toOrderedCollectionChangeset() throws -> OrderedCollectionChangeset<CollectionType> {\n    switch self {\n    case .initial(let collection):\n        return OrderedCollectionChangeset(collection: collection, diff: OrderedCollectionDiff())\n    case .update(let collection, let deletions, let insertions, let modifications):\n        let diff = OrderedCollectionDiff(inserts: insertions, deletes: deletions, updates: modifications, moves: [])\n        return OrderedCollectionChangeset(collection: collection, diff: diff)\n    case .error(let error):\n        throw error\n    }\n}\n\n}\nextension Results {\nfunc toChangesetSignal() -> Signal<OrderedCollectionChangeset<Results<Element>>, NSError> {\n    return Signal { observer in\n        let token = self.observe { change in\n            do {\n                observer.next(try change.toOrderedCollectionChangeset())\n            } catch {\n                observer.failed(error as NSError)\n            }\n        }\n        return BlockDisposable {\n            token.invalidate()\n        }\n    }\n}\n\n}\nextension Results: QueryableSectionedDataSourceProtocol {\npublic var numberOfSections: Int {\n    return 1\n}\n\npublic func numberOfItems(inSection section: Int) -> Int {\n    return count\n}\n\npublic func item(at indexPath: IndexPath) -> Element {\n    return self[indexPath.row]\n}\n\n}\n```\nHere is how it can be used:\n```swift\n// Get the default Realm\nlet realm = try! Realm()\n// Convert realm results into a changeset signal\nlet puppies = realm.objects(Dog.self).toChangesetSignal()\n// Changeset signals can then be bound to table or collection views\npuppies.suppressError(logging: true).bind(to: tableView, cellType: UITableViewCell.self) { (cell, dog) in\n    cell.textLabel?.text = dog.name\n}\n// Adding something to the results will cause the table view to insert the respective row\nDispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n    try! realm.write {\n        realm.add(myDog)\n    }\n}\n```. No more API changes are planned for Bond 7. I hope there are no bugs, but I still want to do more unit tests and write more documentation before it gets out of beta.. I've made this as a Community Extension - https://github.com/DeclarativeHub/Bond/tree/master/Extensions.. To be honest I don't know of a better solution than what you have. \nAVPlayer has addPeriodicTimeObserver(forInterval:queue:using:) method that one could use to make a signal, but AVAudioPlayer does not seem to provide anything like that.\n. Thanks for suggesting this @frederic-c-evo. I've added the feature in v7 beta 2. The method is called removeSubrange.. Yes, that's a very good point. They should use optionals. I'll fix it. Thanks for reporting this!. This is now implemented in v7 beta 2.. Thanks for bringing this up @eduardbosch!\nYou could work around it by accessing count though the underlying collection: nonMutableArray.collection.count, however this was not intended issue :)\nI have just released beta 2 that brings back non mutable extensions like count, isEmpty and subscript.. Good observation, thanks :). Thanks @ios122 !. Thanks @kaishin !. Implemented in 7.2.0.. Initial version of Bond v7 did not support tree/array2D diffing, but with Bond 7.1 the support is back \ud83c\udf89 \nThe syntax remains the same, just note that you should pass the underlying collection, not the observable collection. In you case, do:\n```swift\nlet newArray2d = Array2D(sectionsWithItems: [\n    (\"Cities\", [\"Paris\", \"Berlin\"])\n])\nmutableArray2d.replace(with: newArray2d, performDiff: true)\n```. Looks like this is something I missed. I'll implement support. In the mean time you should be able to do:\nswift\ntestProp\n    .map { OrderedCollectionChangeset(collection: $0, patch: []) }\n    .bind(to: testArray). Implemented in 7.2.0.. I've released Bond 7.2.1 that works around the compilation issues with Swift 5 compiler so that the project is usable with Swift 5 under 4.2 compatibility mode until we merge this in. https://github.com/DeclarativeHub/Bond/commit/1a8772db0ec0b36f177a29685dfdd549a872ea30. Thanks @bbaic for reporting this. It's fixed in 7.2.0... That looks pretty good Akos. I have a suggestion on how to simplify the delegate implementation. Instead of creating a patch on each change, accumulate the changes into a Diff, and send that when content change is done. It should yield better performances.\n```swift\n    // MARK: - NSFetchedResultsControllerDelegate\nvar diff = OrderedCollectionDiff<Int>()\n\n@objc public func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n    diff = OrderedCollectionDiff<Int>()\n}\n\n@objc public func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n    subject.next(OrderedCollectionChangeset(collection: fetchedResultsController.fetchedObjects!, diff: diff))\n}\n\n@objc public func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {\n    switch type {\n    case .insert:\n        if let newIndexPath = newIndexPath {\n            diff.inserts.append(newIndexPath.item)\n        }\n    case .delete:\n        if let indexPath = indexPath {\n            diff.deletes.append(indexPath.item)\n        }\n    case .update:\n        if let indexPath = indexPath {\n            diff.updates.append(indexPath.item)\n        }\n    case .move:\n        if let indexPath = indexPath, let newIndexPath = newIndexPath {\n            diff.moves.append((indexPath.item, newIndexPath.item))\n        }\n    }\n}\n\n```. Here is an idea with section data. Note that I haven't tested this, but it could work.\n```swift\nprivate final class ObservableSectionedFetchedResultsController: NSObject, NSFetchedResultsControllerDelegate, SignalProtocol {\nprivate let subject = PublishSubject<TreeChangeset<Array2D<String?, ResultType>>, NSError>()\nprivate let fetchedResultsController: NSFetchedResultsController<ResultType>\n\nvar fetchedArray2D: Array2D<String?, ResultType> {\n    let sections = fetchedResultsController.sections ?? []\n    return Array2D(\n        sectionsWithItems: sections.enumerated().map {\n            let (section, info) = $0\n            let indexPaths = (0..<info.numberOfObjects).map { item in IndexPath(item: item, section: section) }\n            let items = indexPaths.map { fetchedResultsController.object(at: $0) }\n            return (info.name, items)\n        }\n    )\n}\n\ninit(fetchedResultsController: NSFetchedResultsController<ResultType>) {\n    self.fetchedResultsController = fetchedResultsController\n    super.init()\n    self.fetchedResultsController.delegate = self\n    fetchedResultsController.managedObjectContext.perform {\n        do {\n            try self.fetchedResultsController.performFetch()\n            self.subject.next(TreeChangeset(collection: self.fetchedArray2D, diff: OrderedCollectionDiff()))\n        } catch let error as NSError {\n            self.subject.failed(error)\n        }\n    }\n}\n\npublic func observe(with observer: @escaping (Event<TreeChangeset<Array2D<String?, ResultType>>, NSError>) -> ()) -> Disposable {\n    return subject.observe(with: observer)\n}\n\ndeinit {\n    subject.completed()\n}\n\n// MARK: - NSFetchedResultsControllerDelegate\n\nvar diff = OrderedCollectionDiff<IndexPath>()\n\n@objc public func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n    diff = OrderedCollectionDiff<IndexPath>()\n}\n\n@objc public func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n    subject.next(TreeChangeset(collection: fetchedArray2D, diff: diff))\n}\n\n@objc public func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {\n    switch type {\n    case .insert:\n        if let newIndexPath = newIndexPath {\n            diff.inserts.append(newIndexPath)\n        }\n    case .delete:\n        if let indexPath = indexPath {\n            diff.deletes.append(indexPath)\n        }\n    case .update:\n        if let indexPath = indexPath {\n            diff.updates.append(indexPath)\n        }\n    case .move:\n        if let indexPath = indexPath, let newIndexPath = newIndexPath {\n            diff.moves.append((indexPath, newIndexPath))\n        }\n    }\n}\n\n}\n```\nIf we were to add this to Bond, then Bond would have a dependency on CoreData. Most users don't use CoreData so I'm not in a favour of adding such dependency.\nBut if you come up with a nice implementation, it would be great if you would add it to the Extensions directory and make a PR. You could name file Bond+CoreData. Take a look at the Realm example:\nhttps://github.com/DeclarativeHub/Bond/tree/master/Extensions\nI'll make a link to the extensions from the main readme. . Unfortunately there is an issue in Swift compiler when dealing with ObjC delegate methods in generic subclasses. You have to manually provide ObjC method name. Check out the example in one of the playgrounds:\nhttps://github.com/DeclarativeHub/Bond/blob/master/Playground-iOS.playground/Pages/UICollectionView%2BObservableArray2D.xcplaygroundpage/Contents.swift#L68\n. I guess this would be tree equivalent of firstIndex(where:)? We could add that to the Tree. . Implemented in 7.2.0.. To be honest I can't remember if there was any specific reason for this. Feel free to try to improve it, I don't think it should be too much work. . Hey @tonyarnold, what did you exactly mean by \"need to manually push changes through to the underlying data structure, rather than just using the methods on MutableObservableArray2D to affect changes.\" Could you post an example? . This is great @jonathanfoster, thank you for your contribution! I've added a playground that shows how to use this. . Merged with #595 . Thanks @pilmen !. Note that I've renamed the property to numberOfItemsInAllSections since Items is the term usually used for the elements of a 2D array section. . Hmm, 2-level index paths are invalid for the tree in your example. For example, index path [] refers to the root node, index path [1] refers to the second child of the root node, while index path [1, 2] refers to the third child of the second child of the root node.\nFollowing works correctly for me:\n```swift\nvar t = TreeNode(\"Root\", [\n    TreeNode(\"Child 0\"),\n    TreeNode(\"Child 1\"),\n])\nlet ot = MutableObservableTree(t)\not.observeNext { (cs) in\n    print(cs.collection, cs.diff, cs.patch)\n}\not.move(from: [1], to: [0])\n```\nWhen I do ot.move(from: [0, 1], to: [0, 0]), it crashed as expected. \nThe same rules apply to tree arrays:\n```swift\nvar t = TreeArray([\n    TreeNode(\"Child 0\"),\n    TreeNode(\"Child 1\"),\n])\nlet ot = MutableObservableTree(t)\not.observeNext { (cs) in\n    print(cs.collection, cs.diff, cs.patch)\n}\not.move(from: [1], to: [0])\n```. That would be valid, sure. I can't reproduce your issue though:\n```swift\nvar t = TreeArray([\n    TreeNode(\"Child 0\", [\n        TreeNode(\"Child 00\"),\n        TreeNode(\"Child 01\")\n    ]),\n    TreeNode(\"Child 1\", [\n        TreeNode(\"Child 10\"),\n        TreeNode(\"Child 11\")\n    ])\n])\nlet ot = MutableObservableTree(t)\not.observeNext { (cs) in\n    print(cs.collection, cs.diff, cs.patch)\n}\not.move(from: [0, 1], to: [0, 0])\n```\ncorrectly gives me:\n[(Child 0: (Child 01: -), (Child 00: -)), (Child 1: (Child 10: -), (Child 11: -))] Inserts: [], Deletes: [], Updates: [], Moves: [(from: [0, 1], to: [0, 0])] [M(from: [0, 1], to: [0, 0])]. It's not as easy as it seems.\nMutableObservableArray<T> emits events of the element type OrderedCollectionChangeset<[T]>. The changeset contains both the collection (array) itself, as well as the description of changes (diff).\nTo merge two or more observable arrays into one 2D array you have to merge one or more OrderedCollectionChangeset<[T]> into one TreeChangeset<Array2D<U, T>>. \nWe can start by doing the following\n```swift\nlet a = MutableObservableArray([1, 2, 3])\nlet b = MutableObservableArray([10, 20, 30])\nlet ab = a.combineLatest(with: b) { (a: OrderedCollectionChangeset<[Int]>, b: OrderedCollectionChangeset<[Int]>) -> TreeChangeset> in\n    let array2D = Array2D(sectionsWithItems: [(\"A\", a.collection), (\"B\", b.collection)])\n    let diff = OrderedCollectionDiff() // empty diff\n    return TreeChangeset(collection: array2D, diff: diff)\n}\n```\nYou can then bind ab signal to a table or a collection view and you'll get two sections. You can also bind it to a MutableObservableArray2D instance, although it's not necessary just for the sake of the table/collection view bindings. \nThis will work, however each change to any of the source arrays will trigger table/collection view reload. You won't get fine-grained updates. The reason is that we've ignored diffs from a and b, we are sending just the empty diff and the empty diff makes the view reload the data. \nTo improve, we should merge the diffs from the source arrays into a 2D array diff, i.e. a tree diff. Source array diffs are of the type OrderedCollectionDiff<Int>. We need to merge those into single OrderedCollectionDiff<IndexPath> diff.\nDiffs are just arrays of indices that describe changes. We need to transform Int indices that refer to source arrays into IndexPath indices that refer to the destination 2D array. There is a map on the diff type that maps indices so we can use that. It idea here is to group arrays into sections in order they are passed into.\nLet's implement this in a convenience initializer of OrderedCollectionDiff\n```swift\nextension OrderedCollectionDiff where Index == IndexPath {\ninit(sectionArraysDiffs diffs: [OrderedCollectionDiff<Int>]) {\n    let diffs = diffs.enumerated().map { (pair: (Int, OrderedCollectionDiff<Int>)) -> OrderedCollectionDiff<IndexPath> in\n        let section = pair.0\n        let diff = pair.1\n        return diff.map { IndexPath(item: $0, section: section) }\n    }\n    self.init(\n        inserts: diffs.flatMap { $0.inserts },\n        deletes: diffs.flatMap { $0.deletes },\n        updates: diffs.flatMap { $0.updates },\n        moves: diffs.flatMap { $0.moves }\n    )\n}\n\n}\n```\nNow we can do\nswift\nlet ab = a.combineLatest(with: b) { (a: OrderedCollectionChangeset<[Int]>, b: OrderedCollectionChangeset<[Int]>) -> TreeChangeset<Array2D<String, Int>> in\n    let array2D = Array2D(sectionsWithItems: [(\"A\", a.collection), (\"B\", b.collection)])\n    let diff = OrderedCollectionDiff<IndexPath>(sectionArraysDiffs: [a.diff, b.diff])\n    return TreeChangeset(collection: array2D, diff: diff)\n}\nand our ab signal will then contain the fine-grained changes (diff) too. \nTo make things nicer, we could make a function that can combine N observable array signals into a single 2D array signal:\n```swift\nfunc combineIntoArray2DChangeset(_ signals: [S], sections: [T]) -> Signal>, S.Error> where S.Element: OrderedCollectionChangesetProtocol, S.Element.Collection.Index == Int {\n    return combineLatest(signals.map { $0.toSignal() }, combine: { (changesets) -> TreeChangeset> in\n        let sectionsWithItems = Array(zip(sections, changesets.map { Array($0.collection) }))\n        let array2D = Array2D(sectionsWithItems: sectionsWithItems)\n        let diff = OrderedCollectionDiff(sectionArraysDiffs: changesets.map { $0.diff })\n        return TreeChangeset(collection: array2D, diff: diff)\n})\n\n}\n```\nIt's a bit uglier than I wanted it to be, but it enables us to do the following:\n```swift\nlet a = MutableObservableArray([1, 2, 3])\nlet b = MutableObservableArray([10, 20, 30])\nlet ab = combineIntoArray2DChangeset([a, b], sections: [\"A\", \"B\"])\nab.bind(to: tableView, cellType: Cell.self) { (cell, item) in\n    // todo\n}\n``.text` on the text field is an optional string, so your observable also needs to be optional string in order for the bidirectional binding to work.\nswift\nvar emailID = Observable<String?>(\"\"). Yes, you cannot merge signals of different types. What would the resulting signal type be? String or Void?\nYou can solve this by mapping signals to the same type, Void in your case:\nswift\nmerge(pbsubj1, pbsubj2, observableProperty.map { _ in })\n. merge and combineLatest work exactly as they are depicted on RxMarbles. You can see there that they are also using the same type in the merge example (Int) and the different types in combine example (Int + String).\nIt see you problem. I think it still boils down to choosing the right type. You could map all signals into String? and then make different request based on whether it's nil or not.\nswift\nlet requestIntent = merge(\n    pbsubj1.map { String?.none },\n    pbsubj2.map { String?.none },\n    observableProperty.map { String?.some($0) }\n)\nYou could introduce a custom type and map it into that if you want to be more descriptive.\nswift\nenum RequestIntent {\n    case refresh\n    case load(String)\n}\n. Hi Akos,\nFor a single diff, there can be multiple valid patches. Both first and second patch are correct. You can check that if you try to apply the operations.\n1st example:\nStep|Array\n---|---\nInital | []\nI(Apple, at: 0) | [Apple]\nI(Pear, at: 1) | [Apple, Pear]\nI(Banana, at: 2) | [Apple, Pear, Banana]\n2nd example:\nStep|Array\n---|---\nInital | []\nI(Apple, at: 0) | [Apple]\nI(Banana, at: 1) | [Apple, Banana]\nI(Pear, at: 1) | [Apple, Pear, Banana]\nAs you can see, in both cases we end up with the correct array. If we were to try your example, this would happen:\nStep|Array\n---|---\nInital | []\nI(Apple, at: 0) | [Apple]\nI(Banana, at: 2) | Fatal error (index out of bounds)\n... | ...\nWe cannot insert at index 2 if the array size is 1.\nThere are more possible valid patches for the same diff, for example this one:\nStep|Array\n---|---\nInital | []\nI(Banana, at: 0) | [Banana]\nI(Pear, at: 0) | [Pear, Banana]\nI(Apple, at: 0) | [Apple, Pear, Banana]\nNow, the reason we are getting different patches from the same, but differently sorted, diff is that the algorithm that generates it is not stable. The order of diff indices will cause the algorithm to take different paths and produce different results. The result is still correct, we are just taking the most efficient way to generate it.\nIf you need a stable patch generation, then you'll need to sort diff indices before getting the patch. . @tonyarnold I'd love to hear your input on this. Hopefully things should not break too much, but you might need to do some renaming and deleting.. Thanks @tonyarnold! Great point with the names. I felt something was weird, but didn't give it much attention.. You could subclass the table view and override reloadData, insertRows, etc, by doing the scroll after calling the super implementation. \nAlternatively you can implement a custom binder by subclassing the default one TableViewBinderDataSource and overriding applyChangeset and/or applyChangesetDiff.. The first example is almost correct, you just need to return a value:\nswift\nextension UITextField {\n    var textShouldBeginEditing: SafeSignal<Bool> {\n        return reactive.delegate.signal(for: #selector(UITextFieldDelegate.textFieldShouldBeginEditing(_:))) { (subject: SafePublishSubject<Bool>, _: UITextField) -> Bool in\n            subject.next(false)\n            return false\n        }\n    }\n}. Well, DynamicArray is a subclass of Dynamic so from that point of view it could be OK. In practice, there should be no reason to use this functionality.\n. We are keeping this as an array? Well, I guess that's OK. We are using it only for retaining and unbinding purposes.\n. Agreed.\n. Is this needed?\n. We should still be able to optionally unwrap self even with unowned?  self?.dispatchWillInsert(i)\n. Let's not worry about naming right now. I'm working on next major version of Bond that will have all names fixed. I might need some input in few days. Keep you posted....\n. You're right. For some reason I thought it was implicitly unwrapped optional...\n. Unintentionally :)\n. Agreed, it should be improved.\n. Why are you going with the delegate instead of with createCell closure?\n. Argument array should be properly typed. Having createCell closure would make this easier. \n. I didn't know that difference. Let's leave it as it is then. For UIKit I had to create \"proxy\" delegates to enabled hooks for methods not implemented by Bond.\n. You can create a typealias Element in the protocol for the element type and use that to define array as ObservableArray<Element>.\n. Delegate protocol should be typed, like this:\nswift\npublic protocol BNDTableViewDelegate {\n  typealias Element\n  func createCell(row: Int, array: ObservableArray<Element>, tableView: NSTableView) -> NSTableCellView\n}\nThen, you should generalize BNDTableViewDataSource over the delegate type or order to have the delegate as a property:\n`````` swift\nclass BNDTableViewDataSource: NSObject, NSTableViewDataSource, NSTableViewDelegate {\n  ...\n  private var delegate: DelegateType?\n  ...\n}\nNext, you'll be able to create an initializer like:\n```swift\ninit(array: ObservableArray, tableView: NSTableView, delegate: DelegateType) {\n  self.delegate = delegate\n  ...\n}\n``````\nActually element type you can get from delegate type: DelegateType.Element. Hope this helps.\n. I think you need to make bindTo function generic, not the ObservableType extension.\nswift\npublic func bindTo<D: BNDTableViewDelegate where D.Element == ElementType>(tableView: NSTableView, delegate: D) -> DisposableType\n. Can we name this shouldAnimateRowChangesAtIndexPaths instead?\n. Can we name this shouldAnimateSectionChangesAtIndices instead?\n. Hmm, we should not do reload in this method (applySectionUnitChangeSet) nor in the method applyRowUnitChangeSet because in case of batch updates reloadData could be called multiple times unnecessarily.\n. We need to use the '..<' operator here.\n. Can we put these two lines inside of a lock.atomic block?\n. Ah, yes, you are right :)\n. As follow up on my previous comment, here you could just do .inserts([index]).. No, no need for manual collation. Do exactly as you did, but just revert\nswift\ncase insert(Int)\ncase delete(Int)\ncase update(Int)\nback to\nswift\ncase inserts([Int])\ncase deletes([Int])\ncase updates([Int])\nDoes that make sense?. Could we make this a read-only property instead? So it's consistent with the standard library.. We should probably set object: self here and above :). Would you mind enabling these two options https://i.stack.imgur.com/KjGnz.png so we don't get the unnecessary changes?. I think we should rename this to just replace. Replacing it with another Observable2DArray implies that we are doing 2d replace. \nWe should also rename list to array because it's array.. Same comment as previous :). I guess this could be private.. Ah, it's so sad this is needed.. I hate adding this requirement to DataSourceProtocol because it's not always need. Also, the function should not be generic, rather we should introduce associated types for Item and Index (it is not alway Int). I suggest another protocol that inherits this one:\nswift\npublic protocol QueryableDataSourceProtocol: DataSourceProtocol {\n  associatedtype Item\n  associatedtype Index\n  func item(at index: Index) -> Item\n}\nIf you have a better name that would be cool :)\n. Make ObservableArray conform to QueryableDataSourceProtocol instead.. Make Array conform to QueryableDataSourceProtocol instead.. Make Observable2DArray conform to QueryableDataSourceProtocol instead. Index type would be IndexPath.. Base on comments down below, change the extension at line 39 from\nswift\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Error == NoError \nto\nswift\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Element.DataSource: QueryableDataSourceProtocol, Element.DataSource.Item: AnyObject, Element.DataSource.Index == Int, Error == NoError . Item should be set to the type of array elements. You can check type name from the array declaration:\nswift\nclass ObservableArray<Item>\nSo, it's also Item. \nYou don't have to explicitly set type aliases, just implement the protocol method and compiler will automatically infer associated types. \nswift\npublic func item(at index: Int) -> Item {\n  return self[index]\n}\nFor the Array you'd should do\nswift\npublic func item(at index: Int) -> Iterator.Element {\n  return self[index]\n}\nBecause Iteraror.Element is the type that represent swift array elements. \n. Is associating value types valid thing to do? :)\nIn any case, I think we should move this property into DefaultTableViewBond. Of course, it means that DefaultTableViewBond becomes a class, but that's ok.. Since we are moving updating to the bond object, I guess we can no longer have default method implementation.. Since we are moving updating here, it should be a class. I would also make it open class so that it can be subclassed by someone who wants to extend the default behaviour.. I agree, but since it makes more sense for updating to be here, class will do...\nThanks for working in this btw :). @tonyarnold are you 100% about this? There is a difference in what extendedDiff and patch produce. If I remember correctly, when doing table/collection batch updates, one should use diff, and when not doing batch updates one should use patch. I might be wrong.\nWokalsi also appears to be using diff for batch updated: https://github.com/wokalski/Diff.swift/blob/master/Sources/Diff%2BUIKit.swift. Oh that would suck, but I would not be surprised \ud83d\ude03 . Thanks for confirming you hunch! :)\nI've been playing with this in the morning and got an idea of an operator on the signal of observable array events that would, basically, do other kind of batching. \nIn short, we intercept beginBatchEditing and at that point save the array in a local variable. Then we ignore all events (default case) until we get endBatchEditing. At that point we calculate new diff and patch and send that out.\nI have not tested this well as I have to leave now, but give it a try :) Just call this operator before binding to an NSTableView.\nFeel free to update the PR with this if it works and if you wish to do so. If you have a better name for the operator that would be cool, I'm not sure abut this one.\n```swift\npublic extension SignalProtocol where Element: ObservableArrayEventProtocol, Element.Item: Equatable {\npublic func patchedBatch() -> Signal, Error> {\n    var isBatching = false\n    var originalArray: [Item] = []\n    return Signal { observer in\n      return self.observe { event in\n        switch event {\n        case .next(let observableArrayEvent):\n          switch observableArrayEvent.change {\n          case .beginBatchEditing:\n            isBatching = true\n            originalArray = observableArrayEvent.source.array\n            observer.next(ObservableArrayEvent(change: .beginBatchEditing, source: observableArrayEvent.source))\n          case .endBatchEditing:\n            isBatching = false\n            let array = observableArrayEvent.source.array\n            let diff = originalArray.extendedDiff(array)\n            let patch = diff.patch(from: originalArray, to: array)\n            for step in patch {\n              switch step {\n              case .insertion(let index, _):\n                observer.next(ObservableArrayEvent(change: .inserts([index]), source: observableArrayEvent.source))\n              case .deletion(let index):\n                observer.next(ObservableArrayEvent(change: .deletes([index]), source: observableArrayEvent.source))\n              case .move(let from, let to):\n                observer.next(ObservableArrayEvent(change: .move(from, to), source: observableArrayEvent.source))\n              }\n            }\n            observer.next(ObservableArrayEvent(change: .endBatchEditing, source: observableArrayEvent.source))\n          default:\n            if !isBatching {\n              observer.next(ObservableArrayEvent(change: observableArrayEvent.change, source: observableArrayEvent.source))\n            }\n          }\n        case .failed(let error):\n          observer.failed(error)\n        case .completed:\n          observer.completed()\n        }\n      }\n    }\n  }\n}\n```. There are two ways as far as I can see...\n\nMake use of type system so it's impossible to bind signal (array) with wrong batching algorithm. That would involve new types, probably another kind of ObservableArrayEvent. Our operator would then return Signal<AlternativeObservableArrayEvent<Item>, Error>. Alternative type would be identical to the original one, but NS views would only accept bindings with it. If we do that, compiler would guaranty that NS bindings work because AlternativeObservableArrayEvent events are generated only by patchedBatch operator. \nOnly document it.\n\nProblem with (1) is that it makes things more complex, while (2) makes it easy to do the wrong thing.. Name AlternativeObservableArrayEvent and patchedBatch are not good though \ud83d\ude04 \nEDIT: Hmm, would could also just call the operator within NSTableView bind(to:) method implementation... \ud83d\ude04 . Something like that sounds good! Give me some time, these changes are not trivial :). 0110 I guess -.-. @tonyarnold would you know how this affects things?. I've been playing with this a bit and apparently we need to cast it in order for the compiler to correctly bridge value types to ObjC types: String -> NSString, Int -> NSNumber, etc. \nI will see if this can be fixed in ProtocolProxy class implementation where the bridging is supposed to happen but  does not, probably due to actual type is hidden under generic.. Fixed in 6.4.2!\nI had to manually bridge types, but it was worth it as it also improves other kinds of delegates..  Far from that \ud83d\ude05 . @tonyarnold, hmm, is it a Swift object? Can you see if making it a subclass of NSObject fixes the issues?. Hey @killev,\nThis PR looks great. Could you elaborate why exactly is this needed? Is it only for tests to pass or there is something that actually does not work without this?. @DivineDominion This issue was very specific to Bond and how it implements protocol proxies by intercepting NSInvocations. The issue was related to Swift -> ObjC type bridging. Here is a first commit from the fix: https://github.com/ReactiveKit/Bond/commit/64f8e95596f11120253ef6006ccfe95fb1a94270\n. I'm going to merge your changes. Thanks a lot for figuring the issue out!\n. I wanted to hide the subject as an implementation detail. descriptiveUpdate should be used to update the collection and provide diff if known. Will that work for you? . Alright, great! :). These should now be implemented - would be great if you could try and see if you are still hitting some errors :). Alright, it would be great if you could find an example that is wrong.. That patch looks good to me. I don't understand your action though, you seem to want to move two elements to the same index.. Ah, ok. I think it boils down to how to apply such event.  Give me a minute.\n. I think you want to product the following diff:\nM(from[0], to+0)\nM(from[1], to+1)\n...\nAnd then in descriptiveUpdate update the collection (without using batchUpdate) and then send that diff. \n. I might be easier to update the collection by doing delete + insert. You would send diff of moves, of course :). So the diff you send from descriptiveUpdate is used as is. You (NSTableView) can then call .patch on it to get a sequence of patch events (implemented in CollectionOperation+Patch.swift). . @tonyarnold this is what I had in mind\n```swift\nextension MutableObservableCollection where UnderlyingCollection: RangeReplaceableCollection, UnderlyingCollection.Index: Strideable, UnderlyingCollection.Index.Stride == Int {\npublic func moveItems(from fromIndexes: [UnderlyingCollection.Index], to toIndex: UnderlyingCollection.Index) {\n    descriptiveUpdate { (collection) -> [CollectionOperation<UnderlyingCollection.Index>] in\n        let items = fromIndexes.map { collection[$0] }\n        for index in fromIndexes.sorted().reversed() {\n            collection.remove(at: index)\n        }\n        collection.insert(contentsOf: items, at: toIndex)\n        return fromIndexes.enumerated().map {\n            CollectionOperation<UnderlyingCollection.Index>.move(from: $0.element, to: toIndex.advanced(by: $0.offset))\n        }\n    }\n}\n\n}\n```. I think the patch is fine from the point of view that it represents a sequence of changes that when applied to the original array one after another give you the final array. \nThe question is - is that what NSTableView expects. From the documentation it seems yes, but I guess no.  \nBtw, is it possible to have NSTableView in a playgrounds as live view? I couldn\u2019t get it to show.. I\u2019m still uncertain if NSTableView wants diff or patch when changes are wrapped in begin/endUpdates. . Alright, I\u2019ll be working on this PR tomorrow so I\u2019ll check out NSTableView too. \nHave a nice day away from the Mac! \ud83c\udf1e. Thanks for that, I see now where the problem is! I'll try to fix it today.. @tonyarnold I made some improvements to the patch algorithm so it should now properly handle moves. I might have missed some corner cases so I plan to write some unit tests there. \nI've also detected an issue with batchUpdate when there is a specific combination of operations inside - will work on that tomorrow. \nmoveItem is renamed to move. move(from fromIndices: [Index], to toIndex: Index) is now part of the framework. \nYour test app should now work, at least the dropping part. Note that you have to manually calculate to index:\n```\n    func tableView(_ tableView: NSTableView, acceptDrop info: NSDraggingInfo, row: Int, dropOperation: NSTableView.DropOperation) -> Bool {\n        // Unpack the source indexes from the drag\n        let indexData = info.draggingPasteboard().data(forType: .stringData)\n    guard\n        let _indexes = indexData.flatMap(NSKeyedUnarchiver.unarchiveObject(with:)) as? IndexSet,\n        _indexes.isEmpty == false\n    else {\n        return false\n    }\n\n    let indexes = _indexes.map { $0 }\n    strings.moveItems(from: indexes, to: row - indexes.filter { $0 < row}.count)\n\n    return true\n}\n\n```\nI haven't tested the dragging part. Not sure how to trigger that \ud83d\ude04 \n. I might have broken something regarding dragging then. \nBatch updates should now work. I've completely refactored the internal algorithm that merges diffs. I feel I got it right this time - it super exhausting to think about how these indices are shifting back and forth \ud83d\ude05 \nAs for move(from fromIndices: [UnderlyingCollection.Index], to toIndex: UnderlyingCollection.Index), I think that the current implementation makes sense. to refers to the staring index that the elements will be moved to. It's NSTableView that is giving us a different kind of an index - one that refers to the source array instead of the final one. \nIf we would make the adjustment in our method, we would be specializing the method only for NSTableView usage.. This is currently used for batch updates / patching, but I think we'll need to express this differently. I'll think about it.. Yes, I think we can make children a collection.\nAs for the Value type (not to be confused with Element which is another ThreeNode<Value>), could you maybe define your tree as TreeNode<Layer?>? It should have the same effect. \nAlternatively, maybe a better solution would be to use enum to define all possible tree node type:\nenum Item {\n    case page(Page)\n    case layer(Layer)\n}\n. Would that work for you? I don't think it's possible to make a tree with different value types on different levels, at least not without having an infinite number of generic arguments \ud83d\ude05 . @tonyarnold I've made Children an associatedtype.. @tonyarnold what about following:\n```swift\n        disposable += outlineView.reactive.dataSource.feed(\n            property: dataSource,\n            to: #selector(NSOutlineViewDataSource.outlineView(:child:ofItem:)),\n            map: { (dataSource: Element.UnderlyingCollection?, : NSOutlineView, child: Int, item: Element.UnderlyingCollection?) -> Any in\n                guard let item = item else {\n                    // if item is nil, then we return root node\n                    return dataSource!.value\n                }\n                // otherwise return item's child\n                return item.children[child]\n            }\n        )\n    disposable += outlineView.reactive.dataSource.feed(\n        property: dataSource,\n        to: #selector(NSOutlineViewDataSource.outlineView(_:numberOfChildrenOfItem:)),\n        map: { (dataSource: Element.UnderlyingCollection?, _: NSOutlineView, item: Element.UnderlyingCollection?) -> Int in\n            return item?.children.count ?? 0\n        }\n    )\n\n``. @tonyarnold btw, you'll have to pull the latest changes. I added a constraint that TreeNodeProtocol.Children has to haveIndex == Int.. Thanks for the sample Tony! This was an issues in BNDInvocation and should be fixed now. There are few issues in OutlineViewBinder though. I'm going to make few comments.. I don't thinkat.itemwill work here and below. It's probably something likeat.last!` that we need.. There is something weird about that data source. I have to go now, but will explore this further tomorrow if you don't solve it :) . @tonyarnold alright, I solved some issues so we have the tree rendering. If you start with a tree like:\nswift\n    let tree = MutableObservableCollection(TreeNode(\"Root\", children: [\n        TreeNode(\"Child X\"),\n        TreeNode(\"Child Y\", children: [TreeNode(\"Child U\")])\n    ]))\nyou'll see in the the outline view. Now, for some reason subsequent modifications of the tree do not seem to work - at least some of them like moves or insert. Append might work. We'll have to explore this further. From what I can see the binder calls appropriate methods on the outline view but nothing happens.  \nAnother thing to think about is that NSOutlineView can show multiple nodes in the top level, while tree structures have only one root node. Maybe we should refactor this so that the root node is not displayed in the outline view, rather the first level is root node's children.\nNote that batchUpdate will also not work properly as I still have some work to do regarding that.. I'll be working on this tomorrow. I'm thinking of introducing another type that will act as a root node for such trees. Something like TreeArray that would contain an array of TreeNodes. TreeArray is what we would bind to NSOutlineView then. It'd basically be a TreeNode without a value. . Uh, something very weird happen when I pulled last time:\nYour branch and 'origin/observable-collection' have diverged,\nand have 54 and 47 different commits each \nHopefully it's fixed now \ud83d\ude05 . It would require some refactoring of Array2D to achieve that. \nBtw, is the underlying tree type you have a value or a reference type?. I was able to relax the constraints so that any type conforming to TreeProtocol can be bound to NSOutlineView. You no longer need to use TreeNode/TreeArray.. I've refactored Array2D and simplified TreeNodeWithValueProtocol.. Looks like the outline view actually accepts Any? so I've changed this to Any? as well. That being said, the delegate method is called ...objectValueFor... so it's hard to say if all Swift types will work. My guess would be that only types that can be exposed to ObjC will work like bridgeable struct types such as String or Int based enums. . ",
    "raphaelmor": "Thanks, I was going nuts ! \nYes most of the documentation is centered around UIKit items.\nI'll see if I have time to propose a PR for the doc.\nThank you for the quick answer!\n. ",
    "mpon": "Oh, I get it.\nSince I just wanted to know your idea, I will close this PR. Thank you.\n. ",
    "pnicholls": "I think you might have missed on @srdanrasic?\n```\nBond/BondTests/FoundationTests.swift\nerror: 'AnyObject?' is not convertible to 'NSNumber'; did you mean to use 'as!' to force downcast?\n    let height: Dynamic = dynamicObservableFor(user, keyPath: \"height\", from: { ($0 as NSNumber).floatValue }, to: { NSNumber(float: $0) })\n```\n. ",
    "juhaelee": "The option of \"action\" doesn't even appear anymore\nOn Wednesday, February 11, 2015, Sr\u0111an Ra\u0161i\u0107 notifications@github.com\nwrote:\n\nCan't or can but it doesn't work afterwards?\n\nOn 11 Feb 2015, at 18:31, juhaelee notifications@github.com\n<javascript:_e(%7B%7D,'cvml','notifications@github.com');> wrote:\nwhen you try to hook up an action using storyboard after installing\nswiftbond, unbuttons can't create an ibaction using control+click+drag\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/SwiftBond/Bond/issues/13#issuecomment-73926195.\n\n\nJu Hae Lee\n. I get the error \"UIButton\" does not have a member named 'filter'. Does it need to be a Dynamic ?\n. Thank @srdanrasic, I have another question if you have the time:\nI have a ViewModel called ItemViewModel, a UITableViewCell called ItemTableViewCell and a view Controller called ItemViewController.\nIn my ItemsViewController I store a private variable called Items which I load in viewDidLoad(). And to get my tableview running I have the following cellForAtIndexPath function:\n```\nfunc tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCellWithIdentifier(itemCellIdentifier) as ItemTableViewCell\n\n    let item: ItemViewModel = items[indexPath.row]\n    cell.viewModel = item\n\n    return cell\n}\n\n```\nTrying to do the MVVM pattern, in my ItemTableViewCell I have the following code:\n```\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n@IBOutlet weak var nameLabel: UILabel!\n@IBOutlet weak var addButton: UIButton!\n\nvar viewModel: ItemViewModel! {\n    didSet {\n        itemImage.image = viewModel.image\n        nameLabel.text = viewModel.name\n        addButton.imageView?.image = viewModel.addImage\n        viewModel.favorite ->> Bond<Bool>() { [unowned self] value in\n            println(\"The value changed\")\n            self.nameLabel = \"I changed\"\n        }\n    }\n}\n\n}\n```\nWhat I'm trying to do here is that every time a cell is replaced with a new Item, it creates a Bond for the viewModel's property 'favorite', so that whenever favorite is changed, I can change something in the view of the ItemTableViewCell\nHowever, when I try to test it out using didSelectRowAtIndexPath:\nfunc tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {\n        let item: ItemViewModel = items[indexPath.row]\n        println(\"\\(item.name) : \\(item.favorite.value)\")\n        item.favorite.value = true\n    }\nIt does NOT execute the Bond. Can you tell me what I'm doing wrong here?\nHere is the ViewModel if it helps:\n```\nclass ItemViewModel {\nlet name: String\nlet image: UIImage\nvar addImage: UIImage\nvar favorite: Dynamic<Bool>\n\ninit(_ rlmItem: Item){\n\n    name = rlmItem.name\n    image = UIImage(data: rlmItem.image!)!\n    followImage = UIImage(named: \"favorite\")!\n    favorite = Dynamic(false)\n\n}\n\n}\n```\n. Awesome that worked!!! Say if I wanted to put another bond that responded to that first bond though. I changed addImage in my model to be Dynamic and changed my  tableviewcell to:\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar favoriteBond: Bond?\n  // add a new UIImage bond\n  var addImageBond: Bond?\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n      // create a new bond that has the button's image view watching for changes in the viewMode's addImage(:UIImage) \n      addImageBond = viewModel.addImage ->> addButton.imageView!\n      favoriteBond = viewModel.favorite ->> { [unowned self] value in\n        println(\"The value changed\")\n        self.nameLabel = \"I changed\"\n      }\n    }\n  }\n}\n```\nHowever I get this error that says 'UIImageView' is not convertible to 'Bond'\n. How come I can't retain the viewMode.addImage ->> addButton.imageView! bond in a variable like: \nswift\nvar addImageBond: Bond<UIImage?>?\nso that I can store it in didSet within ItemTableViewCell like so:\nswift\ndidSet {\n   addImageBond = viewModel.addImage ->> addButton.imageView!\n}\nI'm getting the error: 'UIImageView' is not convertible to 'Bond'\n. Sorry about all the questions. And thank you so much for answering them. I'm still confused though. I thought I needed to store a strongly referenced variable to the ItemTableViewCell\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n@IBOutlet weak var nameLabel: UILabel!\n@IBOutlet weak var addButton: UIButton!\nvar favoriteBond: Bond<Bool>?\n\nvar viewModel: ItemViewModel! {\n    didSet {\n        itemImage.image = viewModel.image\n        nameLabel.text = viewModel.name\n        addButton.imageView?.image = viewModel.addImage\n        favoriteBond = viewModel.favorite ->> { [unowned self] value in\n           println(\"The value changed\")\n           self.nameLabel = \"I changed\"\n        }\n    }\n}\n\n}\n```\nThis makes sense to me now. However, what if I wanted to do this:\nWhen the Model view's favorite property is changed, I want to change the modelView's addImage image\nso in the favoriteBond, can I do this?:\nswift\n favoriteBond = viewModel.favorite ->> { [unowned self] value in\n               viewModel.addImage.value = UIImage(named: 'newImage')\n}\nBut I also want the ItemTableViewCell to watch and change the itemImage(:UIImageView) when the viewModel's addImage  changes. So I would typically use:\nswift\nviewModel.addImage ->> addButton.imageView!\nRight? But this doesn't happen when I change the viewModel's favorite property because it doesn't have a strong reference within the ItemTableViewCell\nSo currently I have this code:\n``` swift\nclass ItemTableViewCell: UITableViewCell {\n@IBOutlet weak var itemImage: UIImageView!\n  @IBOutlet weak var nameLabel: UILabel!\n  @IBOutlet weak var addButton: UIButton!\nvar favoriteBond: Bond?\nvar viewModel: StoreViewModel! {\n    didSet {\n      itemImage.image = viewModel.image\n      nameLabel.text = viewModel.name\n      // create a new bond that has the button's image view watching for changes in the viewMode's addImage(:UIImage) \n      viewModel.addImage ->> addButton.imageView!\n      favoriteBond = viewModel.favorite ->> { [unowned self] value in\n        println(\"The value changed\")\n        viewModel.addImage.value = UIImage(named: 'newImage')\n      }\n    }\n  }\n}\n```\nSo my question is, how do I create a strong reference to the viewModel.addImage ->> addButton.imageView! bond so that whenever the viewModel's favorite property changes, it automatically updates the UIButton in the ItemTableViewCell?\n. @srdanrasic Beautiful. Thank you so much, the documentation is also much better now! Awesome update\n. ",
    "DenTelezhkin": "@srdanrasic Hey! What's status on this bug? This is happening in my project with ReactiveKit and ReactiveUIKit. I first noticed this on UISegmentedControl, all actions are gone, unless UISegmentedControl extension is commented out.\n. ",
    "jsslai": "Thanks for the response. Just wanted to know if this can be used as a ReactiveCocoa alternative. Maybe for simple project Bond is enough.\n. ",
    "pasviegas": "Cool, and thanks a lot for updating the readme :D\n. ",
    "clooth": "@advantis I solved this in my application by running the validations manually (in my case for email-addresses) on the return handler where I switch to the next UITextField.\nVery annoying for iOS to not send the event.\n. Couldn't you use dispose() in your willRemoveSubview on the parent view? (Just throwing ideas.)\n. ",
    "serieuxchat": "Just tried it. Unfortunately, it still crashes...\nThanks for making such an awesome framework, btw! (we'll iron out these small things, I am sure; as for the rest, it just rocks!)\n. I guess, the problem is here:\nlet dynamic = InternalDynamic((object.valueForKeyPath(keyPath) as? T)!, faulty: false)\nvalueForKeyPath gives back nil, and then there is a forced unwrap, right?\n. Thanks, mate!\n. Hi Sr\u0111an,\nSo far I have come up with the following work-around (added a method that also accepts a default value - to be used in case the property is nil)\n```\npublic class func asObservableFor(object: NSObject, keyPath: String, defaultValue: T) -> Dynamic \n{\n    let keyPathValue: AnyObject? = object.valueForKeyPath(keyPath)\n    let value: T = (keyPathValue != nil) ? (keyPathValue as? T)! : defaultValue\n    let dynamic = InternalDynamic(value, faulty: false)\nlet helper = DynamicKVOHelper(keyPath: keyPath, object: object as NSObject) {\n    [unowned dynamic] (v: AnyObject) -> Void in\n\n    if (v is NSNull)\n    {\n        dynamic.value = defaultValue\n    }\n    else\n    {\n        dynamic.value = (v as? T)!\n    }\n}\n\ndynamic.retain(helper)\nreturn dynamic\n\n}\n```\n. I will think a little more about it, but for now, I guess, it would do with the defaultValue approach.\nAre you going to keep the second version of the method or always require a default value (if you do a pull request)?\nIt also looks like it's currently not possible to have an update go in the other direction (with some property of NSObject) I.e. if I want to have person.commonName updated automatically whenever a user types something into some corresponding text field... (In this case the property is not a dynamic and must be updated with setValue:forKeyPath, right?)\n. Awesome!\nThanks a lot for reacting so quickly!\nI am sure, the framework will get used a lot. You've done a beautiful thing! Thanks again for the effort and the love you've put into this.\nKind regards,\nSergey\n\nOn 4 mrt. 2015, at 22:37, Sr\u0111an Ra\u0161i\u0107 notifications@github.com wrote:\nThanks for your help @serieuxchat . I've fixed this in v3.0.1 with your suggestion.\nAdditionally, I added another way to create Dynamic representations of K-V observed properties which is to be used for two-way bindings. Checkout README.\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks a lot!\n\nThere is a small question I have: I am trying to write a function which would return an EventProducer for a network operation (to retrieve a certain kind of value). However, there seems to be no built-in way to have such operation to fire (i.e. to trigger it). I was looking at an example of NSNotificationCenter+Bond, but there the firing of a notification is done by NSNotificationCenter itself. \n. It works with Int, so it was enough for me:\nlet status = Observable(object: item, keyPath: \"status\")\n. I was wondering if it were possible to detect that Wrapped is an enum with a raw value and try to do the cast inside the constructor... (probably not simple in any case).\n. ",
    "nayzak": "I think it would be more dangerous to retain observed NSObject by the Dynamic than to ask user to stop observing directly.\nNow I'm working on tiny \"mvvm\" framework for my own use and I found many interesting ideas in SwiftBond project (but I think it little bit complex for my taste). So I tried to make an infinite scroll for UITableView and found that issue with removeObserver. Infinite scroll object had a Dynamic instance witch observed table's contentOffset. And when table view tried to deallocate itself an app was crashed because infinite scroll object was an instance value of UITableView (and also it's subview). So I made a special Dynamic class only for KVO with special method for removing itself from NSObject observers. And than I used it in willMoveToSuperview of infinite scroll object. \nI'm not a person who knows many programming patterns and is able to make a good architecture. More of that I have only starter level of knowledge in iOS development. So I don't think that I could give you any advice at this point.\n. Hm. Just made infinite scroll using Bond and KVO observing. It seems to be no issue if make the bond (contentOffset listener) equals to nil in right place. \n. Thanks for answer, Sr\u0111an. Unfortunately my mind is lack of architecture patterns (shame on me). If I understood right, your goal is to make a library, not framework. I mean that Bond will include just all basic stuff that user needs. And with all this stuff everyone can make everything they need for specific solutions? If I'm right than there is no place for  something like commands in your library. Because in my opinion commands are not multipurpose. In my example they can be used for controls and controls passing themselves to command. For example sometimes it's better to show action sheet from view model. in this case passing some UIView subclass instance to command can be useful. Also specifically for controls command store some Dynamic<Bool> value for easy and obvious enabling\\disabling of control. But in table view's case it's just necessary to pass row index to command if that command responsible for select action.\nI'm sorry if it's difficult to understand me :) I'm not english speaking person.\n. Just off top. When I tried to implement MVVM pattern in my projects I began to develop own library that behaves like Bond v4, but it was far away from Swift 2.0. I gave up because Bond become nice multipurpose library (over engineered for my taste). And now it seems to be great tool for that purposes it been thought for. Great work! Thank you.\n. @srdanrasic, @tonyarnold, thank you guys for spending your time for this helpful project \ud83d\udc4d . Hi @srdanrasic, @tonyarnold! Did you look at my demo (https://github.com/nayzak/BondBugDemo) that reproduces the bug? I've just updated it to Swift 4 and latest Bond release an it still crashes without casting to AnyObject.. It was surprising for me too :) But obvious thing is that something goes wrong on a \"glue level between Swift and ObjC\". I've just made an assumption that objc definitely needs object, however Apple made Any same thing as id. Anyway I'm not that guy who knows what's actually going on in this case.. Ha-ha:) Me too :) But crash occurs only in one place and floats between project builds. I thought that it's sort of compiler issue.. ",
    "zdnk": "I am currently in the same situation. I have couple KVO observers, then values mapped to viewModel and those dynamics bound to UIViews. This all is wrapped in DynamicArray which when cleared (removeAll) causes crash\n\n'An instance 0x1706690c0 of class BETPossibilityModel was deallocated while key value observers were still registered with it. Current observation info: (NSKeyValueObservationInfo 0x174458e10) (\n)NSKeyValueObservance 0x1740d5540: Observer: 0x1740d54d0, Key path: name, Options: (New: YES, Old: NO, Prior: NO) Context: 0x0, Property: 0x174458d80)\n\nHow to fix this? :O\n. Awesome. I have one off-topic question tho. Why do you use dequeueResuable..... without indexPath? Can you use the one with indexPath?\n. Performance reasons obviously. Meaning you cant use map function tho. It is supposed to reuse instances of UITableViewCell. Map function just creates new array with all the cells already instantiated, which is not so good actually. 200 cells might take up some memory, specially if you are loading more as user scrolls down.\n. I think you should refactor this into simple array ->> UITableViewBond, where bond holds the actual cell creation/reuse and configuration\n. I see. Nicely done. I can now see it also supports having different cells for each section.\n. the object i am doing this in has strong reference to the model, so it should not be a problem i suppose, model can outlive Dynamic or they are both released at the same time\n. Thanks, probably should mention this in READ ME. I know there are examples for UIViews only, so it makes sense to use binding, however when you have custom Dynamics like that, it seems natural to use created instance directly I guess.\n. Well, Ill start with description.\nI have DynamicArray as property in my controller (A). I instantiate this controller (A) in another controller (B) and append elements to that DynamicArray (it has some map and filter function bound to it). It DynamicArray is bound to UITableViewDataSourceBond and the controller (A) is also a delegate for UITableView. Actually the controller (A) is UITableViewController. Controller A is child controller of controller B and I have didSelect... on A where I push controller C. And the crash happens on pop when controller B clears the array (property of controller A). Called via viewWillAppear.\n. Yeah, I thought so. Currently blocking me, I cold do workaround by reassigning the property with new instance of DynamicArray but I give it a weekend if you can come up with a solution,\nBtw, sorry for spamming you with issues, but Bond is awesome! :100: :+1: \n. I have reproduced the crash for you:\n```\n        var ints = Int\n    for var i = 0; i < 100; i++ {\n        ints.append(i)\n    }\n\n    let arr = DynamicArray<Int>(ints)\n    let filtered = arr.filter { i -> Bool in i % 3 == 0 }\n    let mapped = filtered.map { i -> String in \"\\(i*i)\" }\n\n    NSLog(\"arr: \\(arr.value)\")\n    NSLog(\"filtered: \\(filtered.value)\")\n    NSLog(\"mapped: \\(mapped.value)\")\n\n    arr.removeAll(false)\n\n```\nAgain, crashes on removeAll.\n. Awesome, thanks!\n. actually not even that, it fixes when i scroll the entire UITableViewController within UIPageViewController\n. there are more issues, same as before when I have filter, map, filter UITableViewDataSourceBond on update does empty rows and stuff like that, its weird\n. actually the issue with tableView simply happens when the content is bigger than tableview, meaning the table view is scrolling\n. Yes, its weird, but when I used classic UITableViewDataSource it worked fine, i have ArrayBond with reloadData() in each listener, and it just works.\n. Call stack:\n```\n0  0x0000000100b782cc in Swift._fatalErrorMessage (Swift.StaticString, Swift.StaticString, Swift.StaticString, Swift.UInt) -> () ()\n1  0x0000000100b52814 in Swift._ContiguousArrayBuffer._isValidSubscript (Swift._ContiguousArrayBuffer)(Swift.Int) -> Swift.Bool ()\n2  0x0000000100b526b8 in Swift._ArrayBuffer._isValidSubscript (Swift._ArrayBuffer)(Swift.Int) -> Swift.Bool ()\n3  0x0000000100b6b7a0 in Swift.Array._checkSubscript (Swift.Array)(Swift.Int) -> () ()\n4  0x0000000100b6b73c in Swift.Array.subscript.getter (Swift.Int) -> A ()\n5  0x00000001001d1c60 in Betty.ActiveBetsViewModel.(init (Betty.ActiveBetsViewModel.Type) -> (bets : Betty.DynamicArray) -> Betty.ActiveBetsViewModel).(closure #3) at /Users/zdenektopic/betty_ios/Betty/Betty/ActiveBetsViewModel.swift:39\n6  0x00000001001b0974 in reabstraction thunk helper from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) at /Users/zdenektopic/betty_ios/Betty/Betty/EventsListViewController.swift:163\n7  0x00000001001d1534 in partial apply forwarder for reabstraction thunk helper from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) ()\n8  0x00000001001c82c8 in reabstraction thunk helper  from @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) to @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:184\n9  0x00000001001be3a8 in Betty.DynamicArray.(dispatchUpdate in _6B65D22929435F0224F3247BF6E10FE5) (Betty.DynamicArray)(Swift.Array, objects : Swift.Array) -> () at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:192\n10 0x00000001001c9744 in Betty.(DynamicArrayMapProxy in _6B65D22929435F0224F3247BF6E10FE5).(init (Betty.(DynamicArrayMapProxy in _6B65D22929435F0224F3247BF6E10FE5).Type) -> (sourceArray : Betty.DynamicArray, mapf : (A, Swift.Int) -> B, cache : C) -> Betty.(DynamicArrayMapProxy in _6B65D22929435F0224F3247BF6E10FE5)).(closure #3) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:342\n11 0x00000001001c8f30 in reabstraction thunk helper  from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:313\n12 0x00000001001c0998 in partial apply forwarder for reabstraction thunk helper  from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) with unmangled suffix \"41\" ()\n13 0x00000001001c82c8 in reabstraction thunk helper  from @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) to @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:184\n14 0x00000001001c5d14 in Betty.DynamicArrayFilterProxy.(dispatchUpdate in _6B65D22929435F0224F3247BF6E10FE5) (Betty.DynamicArrayFilterProxy)(Swift.Array, objects : Swift.Array) -> () at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:673\n15 0x00000001001cc0d8 in Betty.DynamicArrayFilterProxy.(init (Betty.DynamicArrayFilterProxy.Type) -> (sourceArray : Betty.DynamicArray, filterf : (A) -> Swift.Bool) -> Betty.DynamicArrayFilterProxy).(closure #3) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:611\n16 0x00000001001cad68 in reabstraction thunk helper  from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:525\n17 0x00000001001c4438 in partial apply forwarder for reabstraction thunk helper  from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) with unmangled suffix \"58\" ()\n18 0x00000001001c82c8 in reabstraction thunk helper  from @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) to @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:184\n19 0x00000001001be3a8 in Betty.DynamicArray.(dispatchUpdate in _6B65D22929435F0224F3247BF6E10FE5) (Betty.DynamicArray)(Swift.Array, objects : Swift.Array) -> () at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:192\n20 0x00000001001c9744 in Betty.(DynamicArrayMapProxy in _6B65D22929435F0224F3247BF6E10FE5).(init (Betty.(DynamicArrayMapProxy in _6B65D22929435F0224F3247BF6E10FE5).Type) -> (sourceArray : Betty.DynamicArray, mapf : (A, Swift.Int) -> B, cache : C) -> Betty.(DynamicArrayMapProxy in _6B65D22929435F0224F3247BF6E10FE5)).(closure #3) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:342\n21 0x00000001001c8f30 in reabstraction thunk helper  from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:313\n22 0x00000001001c0998 in partial apply forwarder for reabstraction thunk helper  from @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) to @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) with unmangled suffix \"41\" ()\n23 0x00000001001c82c8 in reabstraction thunk helper  from @callee_owned (@in (Betty.DynamicArray, Swift.Array, Swift.Array)) -> (@out ()) to @callee_owned (@owned Betty.DynamicArray, @owned Swift.Array, @owned Swift.Array) -> (@unowned ()) at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:184\n24 0x00000001001be3a8 in Betty.DynamicArray.(dispatchUpdate in _6B65D22929435F0224F3247BF6E10FE5) (Betty.DynamicArray)(Swift.Array, objects : Swift.Array) -> () at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:192\n25 0x00000001001bcce8 in Betty.DynamicArray.subscript.setter (Swift.Int) -> A at /Users/zdenektopic/betty_ios/Betty/Vendor/Bond/Bond/Bond+Arrays.swift:164\n26 0x00000001001416c4 in Betty.ActiveBetsViewController.(eventList (Betty.ActiveBetsViewController) -> (Betty.EventsListViewController, placeBetOnEventAt : Swift.Int, eventItemAt : Swift.Int) -> ()).(closure #2) at /Users/zdenektopic/betty_ios/Betty/Betty/ActiveBetsViewController.swift:174\n27 0x0000000100142050 in reabstraction thunk helper from @callee_owned (@owned ObjectiveC.BETBetModel) -> (@unowned ()) to @callee_owned (@in ObjectiveC.BETBetModel) -> (@out ()) at /Users/zdenektopic/betty_ios/Betty/Betty/ActiveBetsViewController.swift:162\n28 0x000000010013e98c in partial apply forwarder for reabstraction thunk helper from @callee_owned (@owned ObjectiveC.BETBetModel) -> (@unowned ()) to @callee_owned (@in ObjectiveC.BETBetModel) -> (@out ()) ()\n29 0x000000010017e454 in TFFFFC5Betty7Promise4thenU__FGS0_Q__U__FT7onQueueCSo8NSObject4bodyFQd__Q__GS0_Q__U_FTFQ_T_FCSo7NSErrorT__T_U_FT_T_U_FT_T at /Users/zdenektopic/betty_ios/Betty/Vendor/PromiseKit/swift/Sources/Promise.swift:111\n30 0x00000001000a9220 in reabstraction thunk helper from @callee_owned () -> (@unowned ()) to @callee_unowned @objc_block () -> (@unowned ()) at /Users/zdenektopic/betty_ios/Betty/Betty/BETLoginFormViewController.swift:47\n31 0x0000000100fa4fd4 in _dispatch_call_block_and_release ()\n``\n. Ok, I understand. But why is it pull-based? Why dont you propagate all the changes up when the root array changes?\n. I see ... but is there another reason besides UITable/UICollectionViewCells? Because if it is just because that you could simply have a configureCell listener property on UITableViewDataSourceBond instead of using map on DynamicArray, or is there any issue with that?\n. it wont work with iOS 7 since it is written in Swift. It requires compiling the po as Dynamic Framework which can be embedded into iOS 8 deployment targets\n. interesting, could you post some link or anything that refers to this?\n. Cocoapods adds Swift source code to the project? Didnt know about that :O\n. Well it is weak-linked, it builds with stable release version of Xcode so I suppose they should accept it? Specially if Cocoapods supports dynamic frameworks with deployment target 7.0\n. I getld: embedded dylibs/frameworks are only supported on iOS 8.0 and later (@rpath/Bond.framework/Bond) for architecture arm64` when trying to compile for iOS 7.\nEDIT: sorry, forgot to change ios version in Podfile, works! \n. It was an error. Solved, see my edit.\n. however, i am kinda sure this will only work if the application is running on iOS 8. If you run it on iOS 7 it will crash. Right?\nit generates ld: warning: embedded dylibs/frameworks only run on iOS 8 or later warning now.\n. Well I think you should introduce \"each\" function then. \n. As you described, same princial as using subscript, but honestly I dont like myself the for pattern. Foreach or each patterns are much better to use for developer. thats my point of view. Example:\n```\nmyDynamicArray.each { element in \n  // some work with the element\n}\n// or\nmyDynamicArray.each { element, index in \n  // some work with the element and index\n}\n```\n. I am idiot. Missed the \"enumerate it with for loop to get elements\". Sorry.\n. Well I currently solved this by proxying this thru separate ArrayBond that inserts/updates/deletes \"mapped\" objects to \"proxy\" array.\n. I have created project which reproduces this issue:\nhttps://github.com/zdenektopic/UICollectionViewBondTest\n. Same thing happens with ArrayBond setup (performBatchUpdates -> insert/reload/deleteItemsAtIndexPaths) and classic UICollectionViewDataSource. Its weird.\n. I found workaround. In didRemoveListener, instead of doing performBatchUpdates -> deleteItemsAtIndexPaths i called reloadData and it works fine.\n. will those call the didRemove and didInsert listeners?\n. you need to retain the bond\n. Hi. I was thinking. What about instead of textField.bnd_text to have something like textField.bind().text.bindTo(something) or next {} etc...\n. You've got a PR for tvOS basic support - https://github.com/SwiftBond/Bond/pull/186\n. Any extensions actually. It is way more easier to use core of the Bond on any platform, OSX, iOS, watchOS or tvos.\n. I have big iOS project that needs to support iOS 7 as it represents a lot of targeted users and I really, I mean I REALLY would like to use Bonds or ReactiveKits observables and UI extensions. I would use ReactiveCocoa, but to be honest it seems too complicated for simple things like reacting to value change in model.\n. And actually I wanted to know if it will work with iOS7 without any troubles. \n. Thanks, helped!\n. its thworing \n\n'-[WKWebView _stopScrollingAndZoomingAnimationsPinningToContentViewport:]: unrecognized selector sent to instance 0x10283da00'\n\nI will try to figure it out tomorrow, probably I am doing something wrong then. Am I supposed to retain result of webView.dynamic method at all?\n. Thanks.\nThe issue seems to be that WKWebView suddenly receives method calls for UIScrollView. It tries to call setDelegate and _stopScrollingAndZoomingAnimationsPinningToContentViewport which are both methods of UIScrollView, the later one is internal.\n. Figured out what is causing the issue. I have computed property scrollView:\n``` swift\nclass SomeView {\n   private let webView: WKWebView\n   var scrollView: UIScrollView {\n     return webView.scrollView\n   }\n// KVO properties\n    private let urlKVO: DynamicSubject\n    private let titleKVO: DynamicSubject\n    private let canGoBackKVO: DynamicSubject\n    private let canGoForwardKVO: DynamicSubject\n    private let loadingKVO: DynamicSubject\n    private let estimatedProgressKVO: DynamicSubject\n    private let hasOnlySecureContentKVO: DynamicSubject\n// MARK: - Initializers\n\ninit(frame: CGRect, configuration: WKWebViewConfiguration) {\n    webView = WKWebView(frame: CGRect.zero, configuration: configuration)\n    urlKVO = webView.dynamic(keyPath: \"URL\", ofType: Optional<URL>.self)\n    titleKVO = webView.dynamic(keyPath: \"title\", ofType: Optional<String>.self)\n    canGoBackKVO = webView.dynamic(keyPath: \"canGoBack\", ofType: NSNumber.self)\n    canGoForwardKVO = webView.dynamic(keyPath: \"canGoForward\", ofType: NSNumber.self)\n    loadingKVO = webView.dynamic(keyPath: \"loading\", ofType: NSNumber.self)\n    estimatedProgressKVO = webView.dynamic(keyPath: \"estimatedProgress\", ofType: NSNumber.self)\n    hasOnlySecureContentKVO = webView.dynamic(keyPath: \"hasOnlySecureContent\", ofType: NSNumber.self)\n\n    super.init(frame: frame)\n\n}\n```\nwhich i access outside SomeView and when it calls something on it while deallocating it gets somehow redirected to WKWebView or something like that.\nI believe its caused by method swizzling in Bonds KVO, or not at all. Not sure here.\n. I dont see the connection either, however it just doesnt happen when I do KVO manually by addObserver and observeValue method. Happens just with Bonds dynamic method.\n. ",
    "andersklenke": "I don't know why. But I still can't manage to get this to work.\nView: \nSwift\nlistViewModel.currentStop <->> currentStopButton.dynTitle\nViewModel:\nSwift\nvar currentStop =  Dynamic<String>(\"Something\")\nThe button text is set to \"Something\". But if I re-assign the value of currentStop later, the button is not reflecting the correct string. \n. Thanks @srdanrasic ! I still have a lot to learn. \nIt works like a dream now :+1: \n. ",
    "jeff-h": "Hi \u2014\u00a0that's exactly what I meant; sorry I was a bit obtuse. I'll need to learn a bunch more before I'll be of any use on this :)\n. ",
    "paulofaria": "@srdanrasic that idea about value-less signal is very nice. While playing with Bond i caught myself mapping to void quite sometimes, when I just wanted the signal.\n. oh man! me too! haha please tell me you found a solution! @srdanrasic any idea?\n. ",
    "tonyarnold": "Something that allows me to bind a Command/Bond without having retain it in a property myself would be very, very welcome if that falls within the ideas you have for Signals.\n. I'm seeing the same thing. Filters don't seem to be filtering:\nswift\nsomeDyn\n    .filter { $0 != nil }\n    .map { $0.doSomething() } // Called every time\n    ->> someBond\n. Thanks! The 3.5.1 release cleared up all the problems I was seeing :)\n. OK, I've added unit tests for each of the dynamics I exposed. I think this is a good start, but it's missing a lot of coverage of useful properties on NSView, NSControl, etc.\n. Just use myButton.dynEnabled \u2014 NSButton is a subclass of NSControl. dynEnabled is included as part of the NSControl Bond extensions.\n. @ahmedtarek- I think you're in the wrong place. This project is for Swift on Apple's platforms, not for Android.\n. Good call - that was it, thanks!\n. This would be great. I could use this if you implemented it.\n. That looks pretty close to what I want. The only thing I'm missing now is some method to coalesce disparate changes across multiple controls and properties (although I'm not sure how that would look API-wise).\nThanks @srdanrasic :)\n. No, they added Xcode 6.4 support today: https://twitter.com/travisci/status/616007115832999936\n. Sounds like this addresses my issue #95.\n. Ooooo! \ud83d\udc86\ud83c\udffb\n. What's the thinking behind |>? I'm no FP expert, but I thought (left associative) bind was >>= in more functional languages like Haskell.\n. I think you should make the operator optional. There will be people who find bindTo() more \"Swift-like\" than the operator. There's no penalty other than documentation to having them both available.\n. :+1: sounds good to me, @srdanrasic!\n. Yeah, I think @frankschlegel has a good point. I'd prefer more easily readable/comprehendable names too. FP has a tendency to wander off into academic naming for things, and that discourages people from exploring libraries like RAC, Bond, etc. \n. @ivanmoskalev I quite like the inclusion of \"Value\" in there. I'd cast my vote for Observable before Binadable, but I'm easy \u2014 both options are better than Vector/Scalar.\n. Naming, cache invalidation and off by one errors, hey? :smile: \nRight, well let's come at this another way \u2014 is the Value/Array suffix necessary? Could things just be declared Observable and be done with it? I'm spitballing here.\n. Why did you close this? Did you get it working?\n. Righto \u2014 yep, that would do it! :+1:\n. I'm happy to help with the AppKit bindings when that project gets going.\n. Sorry to digress for a moment @DRosadoYew --\n:point_up: Did anyone setup @codecov-io explicitly? If not, that's a new level of GitHub spam\u2026 \n. @srdanrasic no worries. If it's useful, don't turn it off on my account \u2014 I've just seen some \"pushing\" of code coverage services into repos (usually it's via a PR though).\n. How does Codebeat help? Do you have documentation/material that project maintainers can read to help decide if this is something they want to include?\n. Duplicate of #229.\n. Hi @eriklamanna - thanks for this. \nI believe that managing references to self in closures is something every Swift developer should know and understand - it's not specific to Bond. I think your changes could benefit from a link to Apple's documentation on this topic: Resolving Strong Reference Cycles for Closures. What do you think?\n. I'm not sure what happened, but this PR includes a lot more than an edit to the README. Could you either update your branch and reopen this PR, or submit a new PR if this change is still relevant? \n. Nice idea, but Bond has been moved to ReactiveKit. Thanks for the suggestion!\n. Bond v5.x is compatible with Swift 3, and was released just under a month ago. I think the original issue posed here is addressed \u2014 please open new issues if you're having specific problems with the latest release of Bond. Thanks!\n. v5.0.2 was released 3 days ago. Hope that helps!\n. ``` swift\n/// Set the execution context used to dispatch events (i.e. to run the observers).\npublic func observeIn(_ context: @escaping ExecutionContext) -> Signal {\n  return Signal { observer in\n    return self.observe { event in\n      context {\n        observer.on(event)\n      }\n    }\n  }\n}\n/// Set the dispatch queue used to dispatch events (i.e. to run the observers).\npublic func observeOn(_ queue: DispatchQueue) -> Signal {\n  return observeIn(queue.context)\n}\n```\nBoth methods exist within SignalProtocol.swift. I'm pretty sure the migration is documented correctly?\n. I don't think I explained this very well. \nI basically wanted a \"child\" ObservableArray that was a filtered/mapped derivative of a parent ObservableArray. \nI basically have something like this now:\n```swift\n// DocumentLayer is a subclass of DocumentItem\ntypealias Filter = (DocumentItem) -> Bool\nvar filter = Observable(.none)\nvar children: ObservableArray {\n    return self.mutableChildren as ObservableArray\n}\nvar filteredChildren: ObservableArray {\n    return self.mutableFilteredChildren as ObservableArray\n}\nprivate let mutableChildren = MutableObservableArray([])\nprivate let mutableFilteredChildren = MutableObservableArray([])\nfunc observeChangesToFilteredChildren() -> Signal<[DocumentItem], NoError> {\n    return combineLatest(self.children, self.filter) { event, filter in\n        guard let filter = filter else {\n            return event.source.array\n        }\n    return event.source.array.filter(filter)\n}\n\n}\nself.observeChangesToFilteredChildren()\n    .flatMap { $0 as? DocumentLayer }\n    .ignoreNil()\n    .collect()\n    .observeNext { [unowned self] children in\n        self.mutableFilteredChildren.replace(with: children, performDiff: true)\n    }\n    .disposeIn(self.disposeBag)\n```\nThis allows me to attach a table view or data source to the filteredChildren ObservableArray and receive appropriate diffs/updates. It feels a bit heavy, but I'm yet to see any performance issues with it (this is in a desktop app, so memory is a bit less of a concern).. Could definitely do that, but I think you've well and truly answered my question. Thank you!. Is there a way to have the flatMapLatest return an ObservableArray<DocumentLayer> directly, or do I absolutely need to bind to the mutable instance to do that? It'd be nice to have a read-only view without the additional properties.. No, that's OK \u2014 I understand what you're saying, and the \"backing\" ObservableArray seems to work just fine without considerable overhead, so I have an answer and am happy :+1:. One thing I'd like to suggest: make a single framework and test target, and allow them to target all valid platforms. I've done this for a number of libraries already, and it drastically simplifies maintenance and means you can just have a single scheme that can generate iOS, macOS, tvOS and watchOS. \nIt'd require a little target/scheme restructuring, but I'm happy to do the work if this sounds like a good idea to you?. Sounds great. I'll probably pull together a PR shortly, as I have need of it in a client project now. \nAre you OK with introducing Diff.swift as a dependency (rather than pulling in the source directly as you did with Dwifft)? There are alternatives using CocoaPods or splitting out the ObservableArray diffing into a separate framework, but they would make it harder to just install and go.. Also, I'm not sure if I should be targeting master, develop or bond-6. Thankfully PRs can be re-targeted now! Just let me know.. It was mainly so that Diff.swift was doing all of the work. It supports \"patches\" between collections, that are sent through one insert, delete or move at a time - the original code only seemed to support groups of inserts and deletes. The problem there is that the animation for delete and then insert is different to the animation for move - in NSTableView, it didn't animate correctly until I added support for moves.\nIt's your project, but I'd prefer to figure out why collection views were having troubles rather than do our own processing of diffs.. Not a problem. I'll update the PR later on, or tomorrow (my kids are both sick, or I'd do it now \ud83e\udd12).. Should I bump the ReactiveKit dependency in Package.swift to 3.0.0 minimum? It's currently targeting a beta prerelease.. This PR is dependent on https://github.com/ReactiveKit/ReactiveKit/pull/129 being merged, and a release being cut first. Without this, Swift PM support is broken (I believe it might currently be broken in master as well, but haven't checked yet).. God, yeah, sorry - that's my fault. I don't use CocoaPods for anything, so I forget that it needs tending like a special little snowflake.. Oh, @wokalski facepalm on my part you will need to push the pod spec to CocoaPods using pod trunk - sorry, that was a poor bit of release management on my part. It won't happen again.. /cues Yackety Sax. @srdanrasic I'm not quite sure where to draw the line with what should be included in Bond with regards to AppKit support. I have a bunch of helpers that wrap common things, but they're not all Bonds. Some are Subjects wrapping delegates and the like. \nDo you think it's worthwhile including these, or would you prefer to leave that to consumers to implement?. I'm looking at the tests now. Travis is such a time sink :(. That'd be great. Travis is slow tonight, so it's not quick to check that the workarounds I'm adding are actually having any success.. Far out: it finally passed.. Most all of AppKit is, yes (unlike UIKit). I made these DynamicSubjects because Bonds are set-only, aren't they? . Following our conversation on Gitter, I've changed all of the DynamicSubjects into Bonds, and exposed willChangeSelection/didChangeSelection on NSTableView. \nI get it now \ud83d\ude44 \ud83d\ude00 . No, this change looks good to me. Not entirely sure why I thought the patch was necessary, but you're right - in our case, the extended diff is \ud83d\udc4c \n(I verified by porting this change forward to a local branch of Bond 6, and tried it with a semi-complex outline view setup). I also have to say, I'm unsure whether to expose things like NSButton.reactive.state as DynamicSubject<Int>. It's really common to bind the value of a button to something like UserDefaults in traditional Cocoa Bindings. I guess it could be considered similar to NSTextView.reactive.string? \nI have wrappers around my user defaults that look similar to:\n```swift\nimport Foundation\nimport ReactiveKit\nimport Bond\nstruct UserDefaultsKey {\n    static let showCanvasInformationMessages = \"ShowCanvasInformationMessages\"\n}\npublic extension ReactiveExtensions where Base: UserDefaults {\npublic var showCanvasInformationMessages: DynamicSubject<Bool> {\n    return dynamicSubject(\n        signal: self.keyPath(UserDefaultsKey.showCanvasInformationMessages, ofType: Optional<Bool>.self).eraseType(),\n        get: { $0.bool(forKey: UserDefaultsKey.showCanvasInformationMessages) },\n        set: { $0.set($1, forKey: UserDefaultsKey.showCanvasInformationMessages) }\n    )\n}\n\n}\n```\nSo when I follow the currently implemented API, it looks like:\n```swift\nself.showCanvasInformationMessagesButton.reactive\n    .controlEvent\n    .map { $0.state == NSOnState }\n    .bind(to: UserDefaults.standard.reactive.showCanvasInformationMessages)\nUserDefaults.standard.reactive\n    .showCanvasInformationMessages\n    .map { $0 ? NSOnState : NSOffState }\n    .bind(to: self.showCanvasInformationMessagesButton.reactive.state)\n```\nIf NSButton.reactive.state were a DynamicSubject it could be:\nswift\nself.showCanvasInformationMessagesButton.reactive.state\n    .bidirectionalMap(\n        to: { $0 == NSOnState },\n        from: { $0 ? NSOnState : NSOffState }\n    )\n    .bidirectionalBind(to: UserDefaults.standard.reactive.showCanvasInformationMessages)\n. Thanks for the KVO tip - I hadn't seen the triggerEventOnSetting parameter - that's nice!\nAs to the NSControl event - I don't think it's onerous for the user to map the control to extract the desired value themselves. Your suggestion is good - I've included it in addition to the plain property. \nI should probably properly document all of these Bonds and Subjects I'm adding\u2026. Ignore me, swiftc was being slow. It works fine, thanks :). Does it need to be Optional<Any>, given the return type is optional? I'm still not 100% across how generic constraints work.. OK, makes sense. Thanks!. I am an idiot. I just need to invert the calling order. \nswift\nself.myButton.reactive.state\n    .bidirectionalMap(\n        to:  { $0 == NSOnState },\n        from: { $0 ? NSOnState : NSOffState }\n    )\n    .bidirectionalBind(to: viewModel.isDoingTheThing)\nWorks fine.. Hi Michael, can you check which version of Bond and Diff.swift you're using? There were issues compiling Diff.swift under early betas of Xcode 8.3, but I believe the Swift team fixed those a couple of betas ago.. Actually, bear with me - the fixes to Diff.swift aren't in a release yet. We'll get this sorted shortly, but in the meantime you can reference https://github.com/wokalski/Diff.swift/pull/49 for more details.. Not really, I'll have to manually exclude where appropriate. I'm almost finished drawing up a PR, then we can discuss if and how to proceed.. I've got this building under Swift Package Manager, there are a few limitations:\n\nIt's macOS only right now - that's a limitation of Swift Package Manager\nIt requires manually excluding individual sources for AppKit/UIKit in the Podspec\n\nBased on the proposals, it looks like Swift Package Manager v4 will be a more rounded release and will likely support everything needed, but right now, it's more of an interesting experiment than a production-ready package manager (at least for apps - it seems like sadly, it is heavily targeting backend/server-based targets?).\nI'm still happy to create the PR - I'd love to use Swift Package Manager in my macOS projects - but I don't want to make your work harder. What are your thoughts, @srdanrasic?. OK, see #408 for the implementation I came up with. It's a bit of a hybrid of both approaches we discussed above, but does work for all the scenarios.. You can test these changes by building/testing as normal from within Xcode, Carthage and CocoaPods, then on the command line:\nsh\nswift build\nswift test. @srdanrasic good suggestion. I've done that in the latest commits against this branch. \nHere's hoping Swift Package Manager allows more flexible directory layouts in v4 \ud83c\udf89 . It hasn't been added because nobody has needed it yet. PRs are very welcome \ud83d\ude00 . Honestly, I'd lean toward renaming so that we can keep projects moving under Xcode 9. It's not great, but it's pragmatic. It can always be changed back if the Swift team manage to fix the issue.. I agree on both of your points. Let's see what the Swift guys say, and then you can make an informed decisions. Thanks @srdanrasic!. Works for me, for now - thanks for the speedy changes @srdanrasic!. I'm still debugging the issue, but I think that this change may have broken batched moves? I can move individual elements without any problems, but the moment I try to batch a bunch of moves I get beginUpdates and endUpdate through to my tableview without any other events.. I haven't had a chance to do much more digging, I'm sorry! \nIt looks like when I batchUpdate moves on an ObservableArray to a bound NSTableView, that the .reload I would expect to see is instead coming through as .beginUpdates then .endUpdates with no actions in between. \nI'm not sure if this is Bond, or Diff - I'll need to go back and really run through it - I'll open a new issue or PR if I can figure out why this is happening.. OK, I've had a bit of a chance to dig at this and I'm quite sure what the issue is. I've narrowed it down to the batchUpdate method, specifically the .reset code path: https://github.com/ReactiveKit/Bond/blob/master/Sources/Bond/Collections/ObservableArray.swift#L210\nIt looks to me like the backing array for the ObservableArray instance is never updated to include changes from the proxy instance?\nHere's the relevant code from my project:\n```swift\n// Sync change to document adaptor\nlet indexesBeforeNewRowIndex = fromIndexes.filteredIndexSet { $0 < adjustedToIndex }\nlet indexesAfterNewRowIndex = fromIndexes.filteredIndexSet { $0 >= adjustedToIndex }\nobservableArray.batchUpdate {\n    for (enumerationIndex, elementIndex) in indexesBeforeNewRowIndex.reversed().enumerated() {\n        let toIndex = (0 ... $0.count - 1).clamp(toIndex - 1 - enumerationIndex)\n        $0.moveItem(from: elementIndex, to: toIndex)\n    }\nfor (enumerationIndex, elementIndex) in indexesAfterNewRowIndex.enumerated() {\n    let toIndex = (0 ... $0.count - 1).clamp(toIndex + enumerationIndex)\n    $0.moveItem(from: elementIndex, to: toIndex)\n}\n\n}\n```\nIf I check observableArray.array before and after those changes (and there are changes in there), it's the same.\n. It kind of fixes the issue, but I believe I have other dramas going on now (integrating with an NSOutlineView). Thanks for the confirmation.. We don't properly support Xcode 9 yet - that will come closer to release. For now, you should refer to the conversation in #425.. As per the discussion in this PR, the changes I've made here would break UIKit diffs. @srdanrasic is going to tackle this in a different manner.. Yeah, that change for Swift 4 makes me sad \ud83d\ude14 . @mecid as @srdanrasic mentioned above, this is a limitation of CocoaPods and we'd recommend you look at using Carthage instead.\nI'm working on a Swift 4 version of Diff, but I'm not sure that really solves the problem as I don't believe that Bond is ready to move to Swift 4 syntax.. Hi @lucasPelizza, I think you want to change that to:\nswift\nlet user = ReplayOneSubject<Int, NoError>(). \ud83c\udf89  I'll have a look at why that's failing on Travis.. Hah! Me either until today \ud83d\ude09 . OK, this is good to go when you are, @srdanrasic - sorry for the really quick bunch of updates. From my end, that's it for a while now. At least until the Xcode 9.2 beta lands :trollface: . Yeah, I've heard a few Xcode engineers say \"soon\" for SPM integration into the IDE, but \"soon\" in Apple-land seems to generally be on a scale of years.. No, now I get that this isn't implemented. \nI guess it's probably a two-stage change to support something like this:\n```swift\nimport ReactiveKit\nextension SignalProtocol where Error == NoError {\n@discardableResult\npublic func bind<B: BindableProtocol>(to bindable: B, startingWith element: B.Element) -> Disposable where B.Element == Element {\n    return bindable.bind(signal: toSignal().start(with: element))\n}\n\n@discardableResult\npublic func bind<B: BindableProtocol>(to bindable: B, startingWith element: B.Element) -> Disposable where B.Element: OptionalProtocol, B.Element.Wrapped == Element {\n    return map { B.Element($0) }.bind(to: bindable, startingWith: element)\n}\n\n}\nextension BindableProtocol where Self: SignalProtocol, Self.Error == NoError {\n@discardableResult\npublic func bidirectionalBind<B: BindableProtocol & SignalProtocol>(to target: B, startingWith element: B.Element) -> Disposable where B.Element == Element, B.Error == Error {\n    let context: ExecutionContext = .nonRecursive()\n    let d1 = observeIn(context).bind(to: target, startingWith: element)\n    let d2 = target.observeIn(context).bind(to: self)\n    return CompositeDisposable([d1, d2])\n}\n\n}\n```\nAnd then some kind of extension to support providing the startingWith: value from a DynamicSubject or Property instance.. Nah, that doesn't work at all. \nA bidirectionalMap(\u2026).bidirectionalBind(\u2026) seems to send the control's value first to update the view model's property which is the opposite of what I'd want. \nI think this might be the result of bidirectionalBind(\u2026) mapping in the opposite direction of what I'd expect. For example, I would expect the following to be an expression of me binding the value of my control to the view model first, then binding the view model back to the control. \nswift\nmyControl.reactive.someProperty.bidirectionalBind(to: viewModel.property)\nIs my thinking off base here? I can't go in the other direction, because I'm using bidirectionalMap(\u2026).. bidirectionalBinding(\u2026) is fine, it's the bidirectionalMap(\u2026) that's causing me grief. I can't invert the order when using that.. That's what I was hoping. I'm having a (very uneducated) look right now :). Hey, perfect! If you're happy to have a look, that would be great - thanks! I'll leave it be.. Works beautifully! Thank you, @srdanrasic!. I think I've been looking for something like this - @srdanrasic what are your thoughts on tidying this up and making a PR?. Yeah, I'm following along with @killev here. My use case right now is as follows:\nI have a framework that exposes an Objective-C wrapper that sits around a C++ \"core\". This exposes an underlying C++ list that for all intents and purposes looks like an NSMutableArray. \nIn order to make changes, or to read changes, they must go back through the C++ list (via the ObjC API).\nWhat I'm trying to do is wrap an ObservableCollection (inspired by ObservableArray) around this so that I change the ObservableCollection instance, and it directly updates the underlying instance (versus what ObservableArray does now, which is takes a copy of the array used to initialise the instance).\nDoes that make sense? Having support via a standard ObservableSequenceEventProtocol or ObservableCollectionEventProtocol would make my life a lot easier.. I\u2019ll take a swing at this - I\u2019d mostly ended up on this in my own work - I just need to re-implement the diffing. . OK, there's some initial work in #513 to expose a more extensible ObservableCollection - I need to:\n\nWrite some tests\nFlesh out some documentation on how to extend\nDeprecate/typealias ObservableArray to this new class. Interesting, thanks for the extra context Dave! I sure hope that pitch gets off the ground.. Actually this is me being dumb.. This is confusing the hell out of me: and I think it's how macOS handles drag and drop in tables.\n\nBasically it allows dragging between existing indexes, however it works like this:\nPosition 0\nItem 1\nPosition 1\nItem 2\nPosition 2\nItem 3\nPosition 3\nI've probably got some logic in my app that's countering that. I will dig deeper.. OK, so my new concern is that this is not following the same insertion order as Swift's Array insert, specifically:\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection\u2019s endIndex property as the index parameter, the new element is appended to the collection.\nSource: https://developer.apple.com/documentation/swift/array/2894126-insert\n\nSo I would expect the method to resemble the following:\n```swift\npublic func moveItem(from fromIndex: Int, to toIndex: Int) {\n     lock.lock(); defer { lock.unlock() }\n     let item = array.remove(at: fromIndex)\n  var adjustedToIndex = toIndex\n  if fromIndex < toIndex {\n        adjustedIndex -= 1\n }\n\n array.insert(item, at: adjustedToIndex)\n subject.next(ObservableArrayEvent(change: .move(fromIndex, toIndex), source: self))\n\n}\n```\nThis is all extremely confusing.. Yeah, this is absolutely a misunderstanding on my end. Thanks for taking some time to work through it with me!. @killev sorry, that's my fault. I had an in-progress version of what was being discussed, so I thought tidying it up would save some time. \nI have yet to do the same for the 2D arrays, dictionaries or sets - but yeah, there's not a lot of work left in it.. Feel free, @srdanrasic! I had this much already written in my own project, but I\u2019m struggling to find the time to finish it. I\u2019d love the help!. I know, right? They\u2019re excellent. . @srdanrasic any chance you could share your draft ideas? I've got some time today/tomorrow that I can throw at this, and I really need these changes.. Thanks, @srdanrasic! I'll see what I can work out from what you've pushed. I assume you'd want to move to TableViewBinder and remove the old TableViewBond?. It looks like I don't have permission to push changes to your branch - I had a couple of changes to TableViewBinder so that it included the NSTableColumn in the cell creation closure (that's pretty important for multi-column tables!). \nI'll try to get a PR against this branch together in the morning, but here's a gist of the changes if you get enthused: https://gist.github.com/tonyarnold/ead7c419f881b0f1846c98326937e837. Write permissions still don't seem to be working, but I've just created a PR and merged it in. All good!. Once this work is finished, I\u2019m going to take a look at rolling moves into NSTableViews that are bound to a MutableObservableCollection :+1:. Very interesting. I'd forgotten about the use of structs in this way from Objective-C. Thanks!. @srdanrasic is descriptiveUpdate expecting a diff, or individual patches? I assume patches?\nRTFM, Tony: a diff between the beginning and end states.. So I've hit something that needs design consideration. NSOutlineView seems to expect that you bundle both the data changes and the UI changes into a beginUpdates()/endUpdates() together (at least if you enable the launch argument -NSOutlineViewValidateChanges YES). \nI've been using descriptiveUpdate to send through a tailored move that supports the tree of my own data structure, and the actual moves work ok, but the nodes that gain/lose children aren't updating. I assume this is because reloadItem(\u2026) is called on an unexpected/offset item when calling OutlineViewBinder.apply(\u2026).. Yes, absolutely. It\u2019s pretty much ready, I\u2019m just thinking through how to release it so it doesn\u2019t impact users still on Swift 4.0. I\u2019ll finalise and release an update tomorrow \ud83d\udc4d\ud83c\udffb. Sorry about the delay - you should be able to bump to Differ 1.1.0 for Swift 4.1 compatibility.. Interesting ideas - I'll have a poke at it today and see what I can come up with. Thanks for the feedback and encouragement!. > Or was your idea that this should replace ObservableCollection?\nOh geez, no. This is going to be pretty unoptimised in places - ObservableCollection will still (for now) be a faster, simpler option. I mean, I guess we could potentially use this to back the same ideas as ObservableCollection\u2026. > ObservableTree as ObservableCollection<TreeNode> where TreeNode is a Collection with IndexPath for Index\nI think this might be the winner. I really wanted the various levels of the tree to do their own change tracking/sending, but I'm not sure that's going to work.. No, it\u2019s not necessary to be honest. I need it for my use case, but I believe you could make the rest of tree node work without it. . I didn't make time to look at this last night, I'll see what I can do tonight once the kids are asleep - I also realise that children should be a Collection or Array of Self, not a direct reference to the type.. So the main issue I can see is that it doesn\u2019t appear to be possible to construct a proper index path for the various events, ie.: \nswift\n/// Append `newElement` at the end of the collection.\npublic func append(_ newElement: UnderlyingTreeNode.Element) {\n    descriptiveUpdate { (node) -> [TreeOperation] in\n        var parent = node as! UnderlyingTreeNode.Element\n        parent.children.append(newElement)\n        let insertionIndex = parent.children.index(parent.children.endIndex, offsetBy: -1)\n        return [.insert(at: parent.indexPath.appending(insertionIndex))]\n    }\n}\nMy brain\u2019s not firing on all cylinders, but perhaps there\u2019s some way to make this work without having direct access to the parent\u2019s index path? Do you have any ideas, @srdanrasic?. The easy answer is to make MyDataSource a subclass of NSObject. \nI\u2019m not sure what this has to do with Bond, though?. Sorry you're seeing this problem, I'd like to help but I need more information:\n\nWhen is this occurring? \nHow are you including Bond in your project?\n\nCan you verify that you have SWIFT_VERSION = 4.0 (or 4.1) set in your project?. So bear with me here, I want to confirm a couple of basics in the use of this feature:\n\n\nIs the intent that all edits to the tree should be done via the \"root\" node, with an appropriate IndexPath? \n\nIf so, does this mean that we just need to observe the root node for diffs/patches. \n\nThat's what I was aiming for with my initial work - I just want to see if you're thinking the same. \nI've implemented a TreeNodeProtocol conformer in my local project, and that seems to match what I was expecting, so it's all looking very promising!. @srdanrasic what was the driver behind using RangeReplaceableCollection to implement editing here? I am having hell's own trouble retrofitting some Objective-C NSFastEnumeration classes to implement RangeReplaceableCollection - is there an alternative way to come at editing?. I am in an odd situation where I have an Objective-C wrapper class sitting around a C++ class that does the heavy lifting of insert/update/delete/etc. The class presents with an API that\u2019s almost identical to NSArray/NSMutableArray, but isn\u2019t a subclass of either. This is why I\u2019ve been pushing pretty hard on using Collection over Array - I can make these custom classes present with most of the Collection conformances (although RangeReplaceableCollection eludes me at this point).\nThe implementation of RangeReplacableTreeNodeis calling replaceSubrange() on the collection, so I assumed that it needed the collection to conform to RangeReplaceableCollection.. Potentially, yes - I'm talking to the C++ developer on the project about providing an analogue to NSMutableArray's API for this:\nswift\nfunc replaceObjects(in range: NSRange, withObjectsFrom otherArray: [Any])\nAs always, you do what you think it is the best outcome for Bond. I'm basically mirroring the editing APIs in my project for these custom list classes so that I can workaround differences in indexing, so I can just update my local versions when the core versions change.. Yes, I think I may have done that in the ObservableCollection branch. If not, I'll do it this morning.. There\u2019s no option for this currently. I currently work on a project that\u2019s a mix of C++ and Objective-C/Swift, and we took a slightly different approach: the C++ components are all pulled out into a separate framework that exposes an Objective-C API. This way, all of the application code can remain in Swift. \nThat may not be suitable for your purposes and your situation, but it has been working really well (and means I get to use Bond for UI components).. Hi @luziqin - did you manage to sort this issue out?. Thanks @maurovc - were there changes needed for the macOS targeting classes? \nI'll look into the status of Travis' support for Xcode 10 - we probably can't merge any of this to master until Xcode 10 is generally available.. Also, you may wish to merge my changes in master from today - they fix Travis builds so that we can properly see if your changes work under the released version of Xcode.. Can you please provide some details about your build environment - which version & build of Xcode are you using, on what release of macOS?. Hi @ramunasjurgilas - as @Maxatma pointed out, skip(first: \u2026) will skip the first X number of events that are sent to that signal. It is useful for avoiding initial state being overwritten, or in situations where you know you do not need the first in a sequence of events. \nIf you have further questions about this method, please feel free to reopen this issue and ask them.. Try using .skip(first: 1) on your observable (before you bind).. Oh crap, I have no idea what happened here. GitHub, be smarter! Superseded by #549.. @srdanrasic yeah, that definitely works. I'm still feeling a lot of friction around the wrapping of the datasource - I wonder if there is a way that the Binder could still be the datasource, but also have its own optional dataSource property that it calls before using its own implementation? That might make things simpler in terms of implementation (the ProtocolProxy handlers are a bit unwieldy in use IMO). \nWhat would be the best way to implement this? Allow there to be an array of forwardTo objects in ProtocolProxy and we just ask them in sequence until one is hit that implements the method we're looking for?. Thanks, @srdanrasic. \nI ended up creating subclasses of the binders for my custom implementation after posting this question, and that has worked a treat \ud83d\udc4d . Ok, alongside the work in PR #566, this is all working really nicely for me - thanks for your hard work @srdanrasic!. Actually, do you know what? Maybe I'm misunderstanding protocol proxies? Can I use those where I want to return a value to a delegate method?. To clarify, something like this should work, right?\nswift\ntableView.reactive.delegate\n    .feed(\n        property: Property<Void>(()),\n        to: #selector(NSTableViewDelegate.tableView(_:rowViewForRow:)),\n        map: { (_: NSOutlineView, _: Int) -> NSTableRowView? in CustomTableRowView() }\n    )\n    .dispose(in: bag). Does the associateWithTableView(\u2026) method still need the following?\nswift\n        objc_setAssociatedObject(tableView, &TableViewBinderDataSourceAssociationKey, self, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        if tableView.reactive.hasProtocolProxy(for: NSTableViewDataSource.self) {\n            tableView.reactive.dataSource.forwardTo = self\n        } else {\n            tableView.dataSource = self\n        }. Ok, so I've taken another tack here - neither the AppKit TableViewBinderDataSource or OutlineViewBinder provide any support for delegate methods. \nThis simplifies what the classes need to do, but realistically most developers are going to provide NSTableView cells and rows via Storyboards or XIBs. When they don't, it'll be easier for them to provide a full delegate implementation rather than trying to mix-and-match with ours. \nIn terms of impact, it should be minimal - if the incoming view has an objectValue property (which it will if it is a child instance of NSTableCellView), then our the returned element from our collection/changeset will automatically be passed to this property by AppKit.. What I'd like to do after this PR is provide the data source methods and API necessary to allow drag and drop re-ordering/re-parenting. But one thing at a time.. I'm still working through wiring all of this up to my AppKit app, however I found something I think may not work:\n```swift\n/// Move the node from one position to another.\npublic mutating func move(from fromIndex: Index, to toIndex: Index) {\n    let subtree = remove(at: fromIndex)\n    insert(subtree, at: toIndex)\n}\n/// Gather the nodes with the given indices and move them to the given index.\npublic mutating func move(from fromIndices: [Index], to toIndex: Index) {\n    let items = fromIndices.map { self[$0] }\n    for index in fromIndices.sorted().reversed() {\n        remove(at: index)\n    }\n    insert(contentsOf: items, at: toIndex)\n}\n```\nShouldn't the toIndex used to re-insert the removed elements be adjusted before insertion? . Thank you!. @srdanrasic do you recall what happened if value types were used with NSOutlineView and NSTableView (ie. TreeNode instead of ObjectTreeNode)? Was it an easily visible issue?. Oh dear, I'm going to have to make TreeArray and friends TreeCollection, aren't I?. I'm trying hard to think of a good example - my tree structure is like above, but the Not Array Collections are structured like so:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   MaterialList   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502\n          \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u251c\u2500\u2500\u2500\u2500\u25b6\u2502    Material    \u2502\n          \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502              \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502              \u2514\u2500\u2500\u2500\u2500\u25b6\u2502MaterialLayerList \u2502\n          \u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                              \u2502\n          \u2502                              \u2502\n          \u2502                              \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502                              \u251c\u2500\u2500\u2500\u2500\u25b6\u2502 MaterialLayer  \u2502\n          \u2502                              \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                              \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502                              \u251c\u2500\u2500\u2500\u2500\u25b6\u2502 MaterialLayer  \u2502\n          \u2502                              \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                              \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502                              \u2506\u2500\u2500\u2500\u2500\u25b6\u2502 MaterialLayer  \u2502\n          \u2502                              \u2506     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                              \u2506\n          \u2502                              \u2506\n          \u2502                              \u2506\n          \u2502                              \u2506\n          \u2502                              \u2502\n          \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2506\u2500\u2500\u2500\u2500\u25b6\u2502    Material    \u2502\n          \u2506     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2506\n          \u2506\n          \u2506\nThe issue is that I can't find a way to map that structure into compatible protocols so I can use it with Array2D directly - I need to map it into a new structure, which means any changes I make to those \"List\" items only affect the mapped structure, not my original data.\nDoes that make sense?. \u250c\u2500\u2500\u2500\u2510\n\u2502 0 \u2502\n\u2514\u2500\u2500\u2500\u2518\n  \u2502    \u250c\u2500\u2500\u2500\u2510\n  \u251c\u2500\u2500\u2500\u25b6\u2502 0 \u2502\n  \u2502    \u2514\u2500\u2500\u2500\u2518\n  \u2502    \u250c\u2500\u2500\u2500\u2510\n  \u2514\u2500\u2500\u2500\u25b6\u2502 1 \u2502\n       \u2514\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518\n  \u2502    \u250c\u2500\u2500\u2500\u2510\n  \u251c\u2500\u2500\u2500\u25b6\u2502 0 \u2502\n  \u2502    \u2514\u2500\u2500\u2500\u2518\n  \u2502    \u250c\u2500\u2500\u2500\u2510\n  \u2514\u2500\u2500\u2500\u25b6\u2502 1 \u2502\n       \u2514\u2500\u2500\u2500\u2518\nRight, but in this situation (which is what I have), wouldn't a move from [0, 1] to [0, 0] be valid?. Yeah, this seems to be an issue in my implementation. Sorry for taking up time on it!. Initial impressions: \n\nThis looks like a great improvement, and I'm keen to see if it addresses some of my additional needs with my non-standard tree lists (although I'll need to bring this up to work with swiftc 5.0 first)\nI feel like the dfsView and bfsView might be more ergonomic if they were spelled out - something like depthFirst and breadthFirst? I get where you're coming from with the name you have right now, but in use it's not particularly readable.\n\nI'll try this PR branch out in a project this week - but this looks great \ud83d\ude00 . One thing I'd like to tease out (perhaps after this PR is finalised and merged) is how I might be able to provide filtered views into tree objects (ie. for filtering outline views in the UI). I currently maintain a fair bit of backing code to do this, and I wonder if maybe it might be easier to provide some kind of additional protocol/implementation on top of what you've done here\u2026. Wow, this last set of commits has really made a difference to the ergonomics of these changes! Really, really nice @srdanrasic - thanks for persisting!. Is this change due to the preceding [unowned self]?\n. It's probably worth a separate issue, but the Objective-C names for these classes should probably have a class prefix (which is what @objc does in Xcode 7.0b4 and higher I believe)\n. Seeing unowned always makes me :disappointed: \n. Sure, no worries \u2014 I wasn't suggesting that we change any of the \"real\" Swift class names \u2014 just what's exposed to Objective-C. It would be good to consider that for the big update you have coming :smile: \n. From the Swift 2 prerelease book:\n\nUnlike a weak reference, however, an unowned reference is assumed to always have a value. Because of this, an unowned reference is aways defined as a non-optional type.\n\nSo what @sync has done is correct.\n. Right, so you think we can still do away with the manual collation of inserts and deletes as shown here? If I send through each \"change\" (insert/delete/move) but wrap each in an array does that solve the collection view issues? \nI'm not sure I follow. Do you need the inserts and deletes separated still?. Yeah, absolutely - no dramas \ud83d\ude01 . Oh, god \ud83e\udd26\u200d\u2642\ufe0f I've been using this API (NSNotificationCenter) for over a decade, and I still get it wrong\u2026. This all sounds good to me, however I'm having a bit of a conceptual issue. Given:\n```swift\nextension ObservableArray: QueryableDataSourceProtocol {\n  public typealias Item = ???\n  public typealias Index = Int\npublic var numberOfSections: Int {\n    return 1\n  }\npublic func numberOfItems(inSection section: Index) -> Int {\n    return count\n  }\npublic func item(at index: Int) -> Item {\n    return self[index] as! Item\n  }\n}\n```\nWhat do I type alias Item to?. Ahhh yes, that did it. SourceKitService.got it's pants caught around it's ankles again. Thanks for the advice!. Using ExtendedPatch, my moves and reorders of multiple items work consistently. Using ExtendedDiff, the ordering is out of sequence (it looks like it's using the original indexes for elements in the array).  Moves of a single element work fine with both.\nI am beginning to suspect that this may be a difference between UIKit (UITableView) and AppKit (NSTableView).\nI need to read the docs on how UITableView treats the indices of moved elements in between a UITableView.beginUpdates() and UITableView.endUpdates(), and whether it expects you to adjust the \"from\" index at each step, or just use the index of the item in the original array.. Sadly, my hunch is correct. \nUIKIt allows you (within the confines of beginUpdate()/endUpdate()) to address elements by their pre-modification indices: \nmove(from: 1, to: 5)\nmove(from: 2, to: 6)\nAppKit expects you to use the post-modification sequence. The same sequence as above would need to be represented as:\nmove(from: 1, to: 5)\nmove(from: 1, to: 5)\nI'll have a think about how to handle this - obviously I don't want to break UIKit to address AppKit's needs.. Yeah, that definitely does the trick. Now the question is how we wrap that up nicely and make it clear that NSTableView and NSOutlineView expect it.. I think you could simplify the func patchedBatch() method to something like var patches, or func toPatches().\nIn terms of the ObservableArrayEvent naming - perhaps ObservableArrayDiffEvent (replacing ObservableArrayEvent) and ObservableArrayPatchEvent for the new variant?. I appreciate it, @srdanrasic - I'm not in a hurry so please take your time, you've given me a perfectly workable workaround for the time being.. So terrible. I can't think of a clean generic solution to this, so \u00af_(\u30c4)_/\u00af . To be honest, I'm not sure what the intent here is. The closure still returns Any, and it's not a conditional downcast\u2026 I don't think it's necessary?\n@nayzak do you recall why you needed this?. Just had a look now - wow, that's\u2026 special.\nI'm honestly not sure where this issue is coming from - I'm not saying we shouldn't fix it, but I'd like to know what knock-on effects we're going to see from casting absolutely everything to AnyObject (which is essentially saying \"this is a reference type now\", right?). You're a goddamned wizard, 'arry. \ud83c\udf1f . Oh dagnabbit, I updated to 6.2.4 today, and now whatever changes occurred here are causing my code to crash. \n\n\n(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\n    frame #0: 0x00007fff7ec19181 libobjc.A.dylib`objc_release + 33\n    frame #1: 0x00000001039b9797 libswiftCore.dylib`swift::metadataimpl::ValueWitnesses::assignWithTake(swift::OpaqueValue*, swift::OpaqueValue*, swift::TargetMetadata const*) + 23\n    frame #2: 0x000000010396d2e0 libswiftCore.dylib`assignWithTake value witness for Swift.ImplicitlyUnwrappedOptional + 192\n  * frame #3: 0x0000000102849af6 Bond`write #1 (value=, type=, self=0x000060300008d370) in BNDInvocation.writeReturnValue(_:) at ProtocolProxy.swift:78\n    frame #4: 0x0000000102848cdd Bond`BNDInvocation.writeReturnValue(value=, self=0x000060300008d370) at ProtocolProxy.swift:101\n    frame #5: 0x00000001028526e0 Bond`closure #1 in ProtocolProxy.registerInvoker3(invocation=0x000060300008d370, block=0x0000000102870160 Bond`partial apply forwarder for closure #1 (A, B, C) -> E in closure #1 (ReactiveKit.PublishSubject) -> ReactiveKit.Disposable in Bond.ProtocolProxy.signal(for: ObjectiveC.Selector, dispatch: (ReactiveKit.PublishSubject, A, B, C) -> E) -> ReactiveKit.Signal at ProtocolProxy.swift) at ProtocolProxy.swift:179\n    frame #6: 0x000000010286e258 Bond`partial apply for closure #1 in ProtocolProxy.registerInvoker3(for:block:) at ProtocolProxy.swift:0\n    frame #7: 0x000000010284c419 Bond`thunk for @callee_owned (@owned BNDInvocation) -> () at ProtocolProxy.swift:0\n    frame #8: 0x000000010286e2ea Bond`thunk for @callee_owned (@owned BNDInvocation) -> ()partial apply at ProtocolProxy.swift:0\n    frame #9: 0x000000010284c37f Bond`thunk for @callee_owned (@in BNDInvocation) -> (@out ()) at ProtocolProxy.swift:0\n    frame #10: 0x00000001028628d2 Bond`thunk for @callee_owned (@in BNDInvocation) -> (@out ())partial apply at ProtocolProxy.swift:0\n    frame #11: 0x000000010284c983 Bond`ProtocolProxy.handle(invocation=0x000060300008d370, self=0x0000606000361160) at ProtocolProxy.swift:137\n    frame #12: 0x000000010284caeb Bond`@objc ProtocolProxy.handle(_:) at ProtocolProxy.swift:0\n    frame #13: 0x00000001028072fb Bond`-[BNDProtocolProxyBase forwardInvocation:](self=0x0000606000361160, _cmd=\"forwardInvocation:\", invocation=0x00006060000ae8c0) at BNDProtocolProxyBase.m:86\n    frame #14: 0x00007fff582ac24c CoreFoundation`___forwarding___ + 748\n    frame #15: 0x00007fff582abed8 CoreFoundation`__forwarding_prep_0___ + 120\n    frame #16: 0x00007fff55a5a41f AppKit`-[NSTableView(NSTableViewViewBased) _delegate_viewForTableColumn:row:] + 86\n    frame #17: 0x00007fff559d4b90 AppKit`-[NSTableView(NSTableViewViewBased) makeViewForTableColumn:row:] + 87\n    frame #18: 0x00007fff559d4413 AppKit`-[NSTableRowData _addViewToRowView:atColumn:row:] + 342\n    frame #19: 0x00007fff559d40eb AppKit`-[NSTableRowData _addViewsToRowView:atRow:] + 211\n    frame #20: 0x00007fff559d276a AppKit`-[NSTableRowData _initializeRowView:atRow:] + 397\n    frame #21: 0x00007fff562bd1a8 AppKit`-[NSTableRowData _preparedRowViewForRow:storageHandler:] + 154\n    frame #22: 0x00007fff559d0b97 AppKit`-[NSTableRowData _addRowViewForVisibleRow:withPriorView:] + 392\n    frame #23: 0x00007fff562ba3de AppKit`-[NSTableRowData _slideInsertRow:intoClipView:withPriorView:] + 45\n    frame #24: 0x00007fff55a942c8 AppKit`-[NSTableRowData _updateVisibleViewsBasedOnUpdateItems] + 3976\n    frame #25: 0x00007fff55a931f6 AppKit`-[NSTableRowData _updateVisibleViewsBasedOnUpdateItemsAnimated] + 234\n    frame #26: 0x00007fff559c3f54 AppKit`-[NSTableRowData _doWorkAfterEndUpdates] + 85\n    frame #27: 0x00007fff559c3e00 AppKit`-[NSTableView _endUpdateWithTile:] + 137\n    frame #28: 0x00000001028339e9 Bond`DefaultTableViewBond.apply(event=, tableView=0x000061400001d640, self=0x00006080001c2ba0) at NSTableView.swift:128\n    frame #29: 0x00000001028355aa Bond`protocol witness for TableViewBond.apply(event:to:) in conformance  DefaultTableViewBond at NSTableView.swift:0\n    frame #30: 0x000000010283cb74 Bond`closure #5 in SignalProtocol._bind(tableView=0x000061400001d640, event=0x00007ffeefbf3ce0, dataSource=, bond=) at NSTableView.swift:206\n    frame #31: 0x00000001028433db Bond`partial apply for closure #5 in SignalProtocol._bind(to:using:) at NSTableView.swift:0\n    frame #32: 0x0000000102c4fa9a ReactiveKit`closure #1 in closure #1 in SignalProtocol.bind(target=, setter=0x0000000102843320 Bond`partial apply forwarder for closure #5 (__ObjC.NSTableView, A.Element) -> () in (extension in Bond):ReactiveKit.SignalProtocol.(_bind in _BD200F2498C7964CF80293E5276838A7)(to: __ObjC.NSTableView, using: A1) -> ReactiveKit.Disposable at NSTableView.swift, element=0x00006040002735a0) at Bindable.swift:110\n    frame #33: 0x0000000102c513d9 ReactiveKit`partial apply for closure #1 in closure #1 in SignalProtocol.bind(to:context:setter:) at Bindable.swift:0\n    frame #34: 0x0000000102c6e205 ReactiveKit`closure #1 in static ExecutionContext.immediateOnMain.getter(block=0x0000000102c51330 ReactiveKit`partial apply forwarder for closure #1 () -> () in closure #1 (A.Element) -> () in (extension in ReactiveKit):ReactiveKit.SignalProtocol.bind(to: A1, context: ReactiveKit.ExecutionContext, setter: (A1, A.Element) -> ()) -> ReactiveKit.Disposable at Bindable.swift) at ExecutionContext.swift:60\n    frame #35: 0x0000000102c6dc82 ReactiveKit`ExecutionContext.execute(block=0x0000000102c51330 ReactiveKit`partial apply forwarder for closure #1 () -> () in closure #1 (A.Element) -> () in (extension in ReactiveKit):ReactiveKit.SignalProtocol.bind(to: A1, context: ReactiveKit.ExecutionContext, setter: (A1, A.Element) -> ()) -> ReactiveKit.Disposable at Bindable.swift, self=(context = 0x0000000102c6df40 ReactiveKit`closure #1 (() -> ()) -> () in static ReactiveKit.ExecutionContext.immediateOnMain.getter : ReactiveKit.ExecutionContext at ExecutionContext.swift:58)) at ExecutionContext.swift:47\n    frame #36: 0x0000000102c4f41d ReactiveKit`closure #1 in SignalProtocol.bind(element=0x00007ffeefbf43a0, context=(context = 0x0000000102c6df40 ReactiveKit`closure #1 (() -> ()) -> () in static ReactiveKit.ExecutionContext.immediateOnMain.getter : ReactiveKit.ExecutionContext at ExecutionContext.swift:58), target=, setter=0x0000000102843320 Bond`partial apply forwarder for closure #5 (__ObjC.NSTableView, A.Element) -> () in (extension in Bond):ReactiveKit.SignalProtocol.(_bind in _BD200F2498C7964CF80293E5276838A7)(to: __ObjC.NSTableView, using: A1) -> ReactiveKit.Disposable at NSTableView.swift) at Bindable.swift:112\n    frame #37: 0x0000000102c4f61b ReactiveKit`partial apply for closure #1 in SignalProtocol.bind(to:context:setter:) at Bindable.swift:0\n    frame #38: 0x0000000102b93c7c ReactiveKit`closure #1 in SignalProtocol.observeNext(event=, observer=0x0000000102c4f550 ReactiveKit`partial apply forwarder for closure #1 (A.Element) -> () in (extension in ReactiveKit):ReactiveKit.SignalProtocol.bind(to: A1, context: ReactiveKit.ExecutionContext, setter: (A1, A.Element) -> ()) -> ReactiveKit.Disposable at Bindable.swift) at SignalProtocol.swift:57\n    frame #39: 0x0000000102b93ece ReactiveKit`partial apply for closure #1 in SignalProtocol.observeNext(with:) at SignalProtocol.swift:0\n    frame #40: 0x0000000102c49c44 ReactiveKit`AtomicObserver.on(event=, self=0x000060c0000bf800) at Observer.swift:83\n    frame #41: 0x0000000102c4adf2 ReactiveKit`protocol witness for ObserverProtocol.on(_:) in conformance  AtomicObserver at Observer.swift:0\n    frame #42: 0x0000000102c4b187 ReactiveKit`ObserverProtocol.next(element=0x00007ffeefbf4ec0, self=0x000000010ab9c2a0) at Observer.swift:97\n    frame #43: 0x0000000102bd35d1 ReactiveKit`closure #2 in closure #1 in SignalProtocol.take(event=, observer=0x000060c0000bf800) at SignalProtocol.swift:758\n    frame #44: 0x0000000102c3f9ae ReactiveKit`partial apply for closure #2 in closure #1 in SignalProtocol.take(until:) at SignalProtocol.swift:0\n    frame #45: 0x0000000102c49c44 ReactiveKit`AtomicObserver.on(event=, self=0x000060c00009e080) at Observer.swift:83\n    frame #46: 0x0000000102c4adf2 ReactiveKit`protocol witness for ObserverProtocol.on(_:) in conformance  AtomicObserver at Observer.swift:0\n    frame #47: 0x0000000102c4b187 ReactiveKit`ObserverProtocol.next(element=0x00007ffeefbf69f0, self=0x00007ffeefbf69d0) at Observer.swift:97\n    frame #48: 0x00000001028c8d1d Bond`closure #1 in closure #1 in SignalProtocol.toPatches(event=, isBatching=0x000060300043c5e0, originalArray=, observer=) at ObservableArray.swift:790\n    frame #49: 0x00000001028c9754 Bond`partial apply for closure #1 in closure #1 in SignalProtocol.toPatches() at ObservableArray.swift:0\n    frame #50: 0x000000010289458d Bond`thunk for @callee_owned (@in Event, NoError>) -> () at ObservableArray.swift:0\n    frame #51: 0x00000001028c5962 Bond`partial apply for thunk for @callee_owned (@in Event, NoError>) -> () at ObservableArray.swift:0\n    frame #52: 0x0000000102893d26 Bond`thunk for @callee_owned (@owned Event, NoError>) -> () at ObservableArray.swift:0\n    frame #53: 0x0000000102893e22 Bond`partial apply for thunk for @callee_owned (@owned Event, NoError>) -> () at ObservableArray.swift:0\n    frame #54: 0x0000000102b4aba7 ReactiveKit`thunk for @callee_owned (@in Event) -> () at Subjects.swift:0\n    frame #55: 0x0000000102b5b0a6 ReactiveKit`partial apply for thunk for @callee_owned (@in Event) -> () at Subjects.swift:0\n    frame #56: 0x0000000102b4bda7 ReactiveKit`thunk for @callee_owned (@in Event) -> (@out ()) at Subjects.swift:0\n    frame #57: 0x0000000102b5b5ce ReactiveKit`thunk for @callee_owned (@in Event) -> (@out ())partial apply at Subjects.swift:0\n    frame #58: 0x0000000102b49548 ReactiveKit`closure #1 in Subject.send($0=0x0000000102b5b560 ReactiveKit`reabstraction thunk helper  from @callee_owned (@in ReactiveKit.Event) -> (@out ()) to @callee_owned (@in ReactiveKit.Event) -> ()partial apply forwarder with unmangled suffix \".48\" at Subjects.swift, event=) at Subjects.swift:54\n    frame #59: 0x0000000102b4965d ReactiveKit`partial apply for closure #1 in Subject.send(_:) at Subjects.swift:0\n    frame #60: 0x0000000102b4c74e ReactiveKit`Subject.forEachObserver(execute=0x0000000102b49600 ReactiveKit`partial apply forwarder for closure #1 ((ReactiveKit.Event) -> ()) -> () in ReactiveKit.Subject.send(ReactiveKit.Event) -> () at Subjects.swift, self=0x0000606000317a80) at Subjects.swift:81\n    frame #61: 0x0000000102b48ef0 ReactiveKit`Subject.send(event=, self=0x0000606000317a80) at Subjects.swift:54\n    frame #62: 0x0000000102b487d3 ReactiveKit`Subject.on(event=, self=0x0000606000317a80) at Subjects.swift:50\n    frame #63: 0x0000000102b4cc22 ReactiveKit`protocol witness for ObserverProtocol.on(_:) in conformance  Subject at Subjects.swift:0\n    frame #64: 0x0000000102c4b187 ReactiveKit`ObserverProtocol.next(element=0x000000010af58b60, self=0x000000010af58b40) at Observer.swift:97\n    frame #65: 0x00000001028ae4dd Bond`MutableObservableArray.replace(array=1 value, performDiff=true, self=0x00006040000cd4d0) at ObservableArray.swift:362\n\n\nThe object being represented here derives from a protocol that declares conformance to AnyObject.. They are Swift objects, however, making them subclasses of NSObject does not fix this issue.. Interestingly, they are Swift objects that conform to a protocol that declares conformance to AnyObject. They're definitely not subclasses of NSObject, so I'm not sure why they'd even satisfy the conditions of the switch in the protocol proxy.. I think I have a fix - give me 20 mins to prepare a PR.. @DivineDominion I'm not sure it was me who ended up fixing this. I think @srdanrasic ended up rewriting some of the protocol proxy to address similar issues to this one. What specifically did you want to see?. You'll want to move Differ up to \"1.1.0\" for the Xcode 9.3/Swift 4.1 compatibility.. You'll want to move Differ up to ~> 1.1.0 for the Xcode 9.3/Swift 4.1 compatibility.. You'll want to move Differ up to ~> 1.1.0 for the Xcode 9.3/Swift 4.1 compatibility. The Podspec is already deployed to CocoaPods.. Is there any way this could be public? I have a custom collection conformance that isn't an array, and I'd like to be able to feed events through to it manually myself.. I also have times where I need to send an event that's already occurred. Creating new instances in this custom collection time automatically inserts them into the collection, which means I need to send the event without ever performing an insert.. Oh! Can I use descriptiveUpdate(\u2026) for this? Nice!. Yeah, ignore all of that - descriptiveUpdate does exactly what I need. Man, you're a smart cookie!. NSTableView code works \ud83d\udc4c \nNicely done - this is awesome, and has solved so many problems for me - I've been able to remove an entire layer of abstraction due to this WIP PR!. > I'm missing some details regarding move operations, but other operations should work\nAh yes, I just hit this, I think. All good, this is looking fantastic! Thank you so much for your work.. I'm seeing some unusual behaviour around batched moves. I'll try to get some meaningful data together about it, but the actual moves being produced appear to be incorrect.. OK, so it looks like there's something busted with batch move patches: \nI have an array:\n[1, 2, 3, 4]\nI'm going to perform the following action: fromIndexes: [2, 3], toIndex: 1, which produces a diff that looks like this:\n[M(2, 1), M(3, 1)]\nThe resulting patch looks like:\n[M(2, 1), M(2, 1)]\nWhich when followed through step by step:\n\n[1, 3, 2, 4]\n[1, 2, 3, 4]\n\nI'll have a look at the code now, but that's the one that's tripping me up.\n. I have a move(fromIndexes: IndexSet, to toIndex: Int) method - it removes the elements from their original indexes, and re-inserts them in order at the specified toIndex.\nIn which case the patch above should have produced [1, 3, 4, 2].. I tried to construct the moves manually using descriptiveUpdate {} and applying each move in sequence, wrapped in a batchUpdate {} without much luck.. The actual change to the data is fine - I have a method on my collection that handles it (and I've verified as working) - it's the construction of the CollectionOperation.move that's tripping me up. \nI'll keep playing and bring you something concrete if I find it. Thanks @srdanrasic!. Are the operations returned from descriptiveUpdate() used as-is, or are they converted to patches for things like NSTableView?. Thanks for looking into this, @srdanrasic. I really appreciate it.\nSo that still doesn't seem to do what I would like - I plugged the extension into the Table View Binding playground:\nswift\nlet c = MutableObservableCollection([\"1\", \"2\", \"3\", \"4\"])\nc.moveItems(from: [2,3], to: 1)\nThat code generates a diff of:\n[M(2, 1), M(3, 2)]\nWhich is resulting in a patch of:\n[M(2, 1), M(2, 2)]\nThat patch seems suspect to me. The second move does nothing to the tableview when it's applied (so I end up with the data in the right state [\"1\", \"3\", \"4\", \"2\"], but the NSTableView is showing [\"1\", \"3\", \"2\", \"4\"]).\nThis seems like it should be simple enough to solve, but my brain is doing loops \ud83e\udd15 . Even within a batch, I believe NSTableView needs patches. The underlying indexes are updated immediately after the call to insert/remove/move - it\u2019s just the view updates that are held back. . It should be possible to show a table view in a playground, but I\u2019m not near my Mac so I can\u2019t check, sorry!. Thanks! I'll sit down tonight and get you some answers about the playground support - but yes, time away from the computer is \ud83c\udf3b . OK, I couldn't get NSTableView working in a playground, so here's a sample project that implements the absolute minimum for drag-rearranging an ObservableCollection: \nTable Move Test.zip\nI always get tripped up by selecting and moving multiple items at once, but obviously even the basic single item moves are broken here (although curiously only when fromIndex < toIndex). \nI came across this implementation earlier today, which looks messy, but seems to work for multi-item moves: https://stackoverflow.com/questions/2121907/drag-drop-reorder-rows-on-nstableview\nI'll keep at this as I can, but hopefully this helps clarify the problem for you, too.\n\ud83d\ude4f . Fantastic, thanks @srdanrasic! I can\u2019t wait to have a look at this (when the kids leave me be for 30 minutes!) . > I haven't tested the dragging part. Not sure how to trigger that\nI'm not sure what you mean? You should just be able to drag with your mouse - select a row or two and drag away!\nThis all seems to work nicely. Have you considered placing the row offset logic inside the move method, like so?\nswift\npublic func move(from fromIndices: [UnderlyingCollection.Index], to toIndex: UnderlyingCollection.Index) {\n    descriptiveUpdate { (collection) -> [CollectionOperation<UnderlyingCollection.Index>] in\n        let adjustedToIndex = toIndex - fromIndices.filter { $0 < toIndex }.count\n        collection.move(from: fromIndices, to: adjustedToIndex)\n        return fromIndices.enumerated().map {\n            .move(from: $0.element, to: adjustedToIndex.advanced(by: $0.offset))\n        }\n    }\n}\nThen you could just pass the raw index from NSTableView?. > we would be specializing the method only for NSTableView usage\nYeah, fair call. \nThank you so much for looking into this when I needed it - I owe you. I think this PR has made a pretty great change to Bond - it's certainly freed things up to support what I needed. I'll try to get the observable tree work tidied up this coming week, too.\n. Is there a way to express this without forcing it to be an array? Making this a Collection or MutableCollection would solve some headaches for me.\nNot exactly this, but similar:\n```swift\npublic protocol TreeNodeProtocol: MutableCollection where Index == IndexPath, Element == Self {\nassociatedtype Value\nvar value: Value { get }\n\nassociatedtype Children: MutableCollection where Index == Self.Index, Element == Self.Element\nvar children: Children { get }\n\n}\n``. It'd also be nice to have a \"root\" tree node that returnsvalueasnil, or a type that's not the same asElement`. \nI have a structure I'm working against that is:\n\nPage\nLayer\nLayer\nLayer\nLayer\nLayer\n\n\nLayer\n\n\n\netc, etc. It supports basically infinite recursion on the Layer objects.. ~How do you see the enum work in this context? That's obviously preferable, but I'm not sure how it fits alongside what we're designing here.~\nGot it, I can see how that would work.. This is going to be an interesting challenge - these are the required NSOutlineViewDataSource delegate methods:\n\noutlineView(_:child:ofItem:)\noutlineView(_:isItemExpandable:)\noutlineView(_:numberOfChildrenOfItem:)\noutlineView(_:objectValueFor:byItem:)\n\nNote the method signature of the first one:\nswift\nfunc outlineView(_ outlineView: NSOutlineView, child index: Int, ofItem item: Any?) -> Any\nYep, that's an Int in there as the index for retrieving a child from the passed item. We may need to place some restrictions on what Index/Indices an ObservableCollection wrapping TreeNodeProtocol has before allowing binding.. In theory, something like this should work I would expect:\n```swift\ndisposable += outlineView.reactive.dataSource.feed(\n    property: dataSource,\n    to: #selector(NSOutlineViewDataSource.outlineView(:child:ofItem:)),\n    map: { (dataSource: Element.UnderlyingCollection?, : NSOutlineView, child: Int, item: Element.UnderlyingCollection?) -> Any in\n        guard let item = item else {\n            let index = dataSource!.startIndex.advanced(by: child, atLevel: 0)\n            return dataSource![index]\n        }\n    let index = item.startIndex.advanced(by: child, atLevel: 0)\n    return item[index]\n}\n\n)\n```. I'm seeing a crash in BNDInvocation that originates from this method:\n\nCrash Log\n* thread #1, queue = 'com.apple.main-thread', stop reason = Fatal error: Unexpectedly found nil while unwrapping an Optional value\n    frame #0: 0x0000000100a0bfd0 libswiftCore.dylib`_swift_runtime_on_report\n    frame #1: 0x0000000100a4fb41 libswiftCore.dylib`_swift_stdlib_reportFatalError + 113\n    frame #2: 0x0000000100780866 libswiftCore.dylib`function signature specialization ) -> () to @callee_guaranteed (@unowned Swift.UnsafeBufferPointer) -> (@out ()), Argument Types : [@callee_guaranteed (@unowned Swift.UnsafeBufferPointer) -> ()]> of generic specialization <()> of Swift.StaticString.withUTF8Buffer((Swift.UnsafeBufferPointer) -> A) -> A + 54\n    frame #3: 0x00000001009f0ca3 libswiftCore.dylib`partial apply forwarder for closure #2 (Swift.UnsafeBufferPointer) -> () in Swift._fatalErrorMessage(Swift.StaticString, Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never + 99\n    frame #4: 0x0000000100780866 libswiftCore.dylib`function signature specialization ) -> () to @callee_guaranteed (@unowned Swift.UnsafeBufferPointer) -> (@out ()), Argument Types : [@callee_guaranteed (@unowned Swift.UnsafeBufferPointer) -> ()]> of generic specialization <()> of Swift.StaticString.withUTF8Buffer((Swift.UnsafeBufferPointer) -> A) -> A + 54\n    frame #5: 0x0000000100908c60 libswiftCore.dylib`function signature specialization  of Swift._fatalErrorMessage(Swift.StaticString, Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never + 96\n    frame #6: 0x0000000100780493 libswiftCore.dylib`Swift._fatalErrorMessage(Swift.StaticString, Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never + 19\n  * frame #7: 0x000000010057e49a Bond`BNDInvocation.readArgument(index=3, self=0x0000608000024ea0) at BNDInvocation.swift:60\n    frame #8: 0x000000010050c4d2 Bond`closure #1 in ProtocolProxy.registerInvoker2(invocation=0x0000608000024ea0, block=0x0000000100518ab0 Bond`partial apply forwarder for closure #1 (A, B) -> D in closure #1 (ReactiveKit.PublishSubject) -> ReactiveKit.Disposable in Bond.ProtocolProxy.signal(for: ObjectiveC.Selector, dispatch: (ReactiveKit.PublishSubject, A, B) -> D) -> ReactiveKit.Signal at ProtocolProxy.swift) at ProtocolProxy.swift:95\n    frame #9: 0x0000000100517c85 Bond`partial apply for closure #1 in ProtocolProxy.registerInvoker2(for:block:) at ProtocolProxy.swift:0\n    frame #10: 0x000000010050ae1f Bond`thunk for @escaping @callee_guaranteed (@owned BNDInvocation) -> () at ProtocolProxy.swift:0\n    frame #11: 0x0000000100517ce1 Bond`thunk for @escaping @callee_guaranteed (@owned BNDInvocation) -> ()partial apply at ProtocolProxy.swift:0\n    frame #12: 0x000000010050ae04 Bond`thunk for @escaping @callee_guaranteed (@in BNDInvocation) -> (@out ()) at ProtocolProxy.swift:0\n    frame #13: 0x0000000100512101 Bond`thunk for @escaping @callee_guaranteed (@in BNDInvocation) -> (@out ())partial apply at ProtocolProxy.swift:0\n    frame #14: 0x000000010050b082 Bond`ProtocolProxy.handle(invocation=0x0000608000024ea0, self=0x00006040000453d0) at ProtocolProxy.swift:66\n    frame #15: 0x000000010050b0fc Bond`@objc ProtocolProxy.handle(_:) at ProtocolProxy.swift:0\n    frame #16: 0x00000001004d2fdb Bond`-[BNDProtocolProxyBase forwardInvocation:](self=0x00006040000453d0, _cmd=\"forwardInvocation:\", invocation=0x000060800006b500) at BNDProtocolProxyBase.m:86\n    frame #17: 0x00007fff541425ac CoreFoundation`___forwarding___ + 748\n    frame #18: 0x00007fff54142238 CoreFoundation`__forwarding_prep_0___ + 120\n    frame #19: 0x00007fff517dd271 AppKit`-[NSOutlineView _expandItemEntry:expandChildren:startLevel:] + 417\n    frame #20: 0x00007fff517d2cfb AppKit`-[NSOutlineView _uncachedNumberOfRows] + 313\n    frame #21: 0x00007fff517d87ef AppKit`-[NSTableView _verifySelectionIsOK] + 517\n    frame #22: 0x00007fff517d8558 AppKit`-[NSTableView _tileAndRedisplayAll] + 345\n    frame #23: 0x00007fff518a4658 AppKit`-[NSOutlineView reloadData] + 586\n    frame #24: 0x00007fff517d3a3e AppKit`-[NSOutlineView setDataSource:] + 261\n    frame #25: 0x00000001004e9994 Bond`key path setter for NSOutlineView.dataSource : A.Base at NSOutlineView.swift:0\n    frame #26: 0x00000001004e99cb Bond`___lldb_unnamed_symbol77$$Bond + 27\n    frame #27: 0x0000000100855585 libswiftCore.dylib`Swift.NonmutatingWritebackBuffer.__deallocating_deinit + 197\n    frame #28: 0x0000000100a0e130 libswiftCore.dylib`_swift_release_dealloc + 16\n    frame #29: 0x000000010056d647 Bond`OptionalKeyPathProtocolProxyPropertyController.delegate.setter(newValue=0x00006040000453d0, self=0x0000600000040330) at ProtocolProxyController.swift:0\n    frame #30: 0x0000000100511fd5 Bond`ProtocolProxy.registerDelegate(self=0x00006040000453d0) at ProtocolProxy.swift:280\n    frame #31: 0x000000010050cb6c Bond`ProtocolProxy.registerInvoker3(selector=\"outlineView:child:ofItem:\", block=0x00000001005189e0 Bond`partial apply forwarder for closure #1 (A, B, C) -> E in closure #1 (ReactiveKit.PublishSubject) -> ReactiveKit.Disposable in Bond.ProtocolProxy.signal(for: ObjectiveC.Selector, dispatch: (ReactiveKit.PublishSubject, A, B, C) -> E) -> ReactiveKit.Signal at ProtocolProxy.swift, self=0x00006040000453d0) at ProtocolProxy.swift:110\n    frame #32: 0x00000001005101f4 Bond`closure #1 in ProtocolProxy.signal(subject=, self=0x00006040000453d0, selector=\"outlineView:child:ofItem:\", dispatch=0x0000000100516c00 Bond`partial apply forwarder for closure #1 (ReactiveKit.PublishSubject<(), ReactiveKit.NoError>, B, C, D) -> E in Bond.ProtocolProxy.feed(property: ReactiveKit.Property, to: ObjectiveC.Selector, map: (A, B, C, D) -> E) -> ReactiveKit.Disposable at ProtocolProxy.swift) at ProtocolProxy.swift:217\n    frame #33: 0x0000000100512402 Bond`partial apply for closure #1 in ProtocolProxy.signal(for:dispatch:) at ProtocolProxy.swift:0\n    frame #34: 0x000000010050ec04 Bond`closure #1 in ProtocolProxy._signal(observer=, registerInvoker=0x00000001005123a0 Bond`partial apply forwarder for closure #1 (ReactiveKit.PublishSubject) -> ReactiveKit.Disposable in Bond.ProtocolProxy.signal(for: ObjectiveC.Selector, dispatch: (ReactiveKit.PublishSubject, A, B, C) -> E) -> ReactiveKit.Signal at ProtocolProxy.swift, self=0x00006040000453d0, selector=\"outlineView:child:ofItem:\") at ProtocolProxy.swift:148\n    frame #35: 0x0000000100518c09 Bond`partial apply for closure #1 in ProtocolProxy._signal(for:registerInvoker:) at ProtocolProxy.swift:0\n    frame #36: 0x000000010041cc4b ReactiveKit`Signal.observe(observer=0x00000001003c6590 ReactiveKit`partial apply forwarder at Subjects.swift, self=(producer = 0x0000000100518bf0 Bond`partial apply forwarder for closure #1 (ReactiveKit.AtomicObserver) -> ReactiveKit.Disposable in Bond.ProtocolProxy.(_signal in _23028F409340362020B24E8EAAA251BA)(for: ObjectiveC.Selector, registerInvoker: (ReactiveKit.PublishSubject) -> ReactiveKit.Disposable) -> ReactiveKit.Signal at ProtocolProxy.swift)) at Signal.swift:41\n    frame #37: 0x000000010041ceb7 ReactiveKit`protocol witness for SignalProtocol.observe(with:) in conformance Signal at Signal.swift:0\n    frame #38: 0x00000001003dbdda ReactiveKit`SignalProtocol.observe(observer=, self=) at SignalProtocol.swift:50\n    frame #39: 0x00000001003d9394 ReactiveKit`ConnectableSignal.connect(self=0x0000608000045e50) at Connectable.swift:50\n    frame #40: 0x00000001003d9650 ReactiveKit`protocol witness for ConnectableSignalProtocol.connect() in conformance ConnectableSignal at Connectable.swift:0\n    frame #41: 0x00000001003d9c02 ReactiveKit`closure #1 in ConnectableSignalProtocol.refCount(observer=0x00006080000e1680, lock=0x00006080000c50f0, count=0x0000608000024cd0, self=0x0000608000045e50, connectionDisposable=nil) at Connectable.swift:76\n    frame #42: 0x00000001003d9e32 ReactiveKit`partial apply for closure #1 in ConnectableSignalProtocol.refCount() at Connectable.swift:0\n    frame #43: 0x000000010041cc4b ReactiveKit`Signal.observe(observer=0x0000000100516cb0 Bond`reabstraction thunk helper from @escaping @callee_guaranteed (@unowned ReactiveKit.Event<(), ReactiveKit.NoError>) -> () to @escaping @callee_guaranteed (@in ReactiveKit.Event<(), ReactiveKit.NoError>) -> ()partial apply forwarder with unmangled suffix \".83\" at ProtocolProxy.swift, self=(producer = 0x00000001003d9df0 ReactiveKit`partial apply forwarder for closure #1 (ReactiveKit.AtomicObserver) -> ReactiveKit.Disposable in (extension in ReactiveKit):ReactiveKit.ConnectableSignalProtocol.refCount() -> ReactiveKit.Signal at Connectable.swift)) at Signal.swift:41\n    frame #44: 0x000000010051344a Bond`ProtocolProxy.feed(property=, selector=\"outlineView:child:ofItem:\", map=0x00000001004fbaf0 Bond`partial apply forwarder for reabstraction thunk helper  from @escaping @callee_guaranteed (@in Swift.Optional, @owned __ObjC.NSOutlineView, @unowned Swift.Int, @in Swift.Optional) -> (@out Any) to @escaping @callee_guaranteed (@in Swift.Optional, @in __ObjC.NSOutlineView, @in Swift.Int, @in Swift.Optional) -> (@out Any) at NSOutlineView+ObservableTree.swift, self=0x00006040000453d0) at ProtocolProxy.swift:314\n    frame #45: 0x00000001004f98b0 Bond`SignalProtocol<>.bind(outlineView=0x0000000101306510, binder=, self=0x000060000026b580) at NSOutlineView+ObservableTree.swift:150\n    frame #46: 0x000000010000353f Outlines`ViewController.viewDidLoad(self=0x00006000000e1d80) at ViewController.swift:31\n    frame #47: 0x0000000100005224 Outlines`@objc ViewController.viewDidLoad() at ViewController.swift:0\n    frame #48: 0x00007fff5172d20a AppKit`-[NSViewController _sendViewDidLoad] + 97\n    frame #49: 0x00007fff51cd1afd AppKit`_noteLoadCompletionForObject + 641\n    frame #50: 0x00007fff516b197d AppKit`-[NSIBObjectData nibInstantiateWithOwner:options:topLevelObjects:] + 2042\n    frame #51: 0x00007fff517acd1e AppKit`-[NSNib _instantiateNibWithExternalNameTable:options:] + 679\n    frame #52: 0x00007fff517ac97a AppKit`-[NSNib _instantiateWithOwner:options:topLevelObjects:] + 136\n    frame #53: 0x00007fff517abc50 AppKit`-[NSViewController loadView] + 343\n    frame #54: 0x00007fff51723a9e AppKit`-[NSViewController _loadViewIfRequired] + 75\n    frame #55: 0x00007fff51723a09 AppKit`-[NSViewController view] + 30\n    frame #56: 0x00007fff518a2365 AppKit`-[NSWindow _contentViewControllerChanged] + 109\n    frame #57: 0x00007fff5625ce8e Foundation`-[NSObject(NSKeyValueCoding) setValue:forKey:] + 331\n    frame #58: 0x00007fff518e50c5 AppKit`-[NSWindow setValue:forKey:] + 111\n    frame #59: 0x00007fff518e5029 AppKit`-[NSIBUserDefinedRuntimeAttributesConnector establishConnection] + 637\n    frame #60: 0x00007fff516b1719 AppKit`-[NSIBObjectData nibInstantiateWithOwner:options:topLevelObjects:] + 1430\n    frame #61: 0x00007fff517acd1e AppKit`-[NSNib _instantiateNibWithExternalNameTable:options:] + 679\n    frame #62: 0x00007fff517ac97a AppKit`-[NSNib _instantiateWithOwner:options:topLevelObjects:] + 136\n    frame #63: 0x00007fff51f0346c AppKit`-[NSStoryboard instantiateControllerWithIdentifier:] + 236\n    frame #64: 0x00007fff516a5a27 AppKit`NSApplicationMain + 729\n    frame #65: 0x000000010000701d Outlines`main at AppDelegate.swift:7\n    frame #66: 0x00007fff7c461015 libdyld.dylib`start + 1\n\n\n. Both of those suggestions work \ud83d\udc4d . So a bit of further info on this crash (I haven't figured it out yet):\nIt's crashing when trying to provide:\nswift\nfunc outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -> Int\nwhen trying to readArgument() at index 3 (I assume that's the result?). It's crashing at BNDInvocation.swift:L60 with the following error:\nThread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nDo you have any ideas of how I can track this down? My local implementation of that method in the OutlineViewBinder is:\nswift\ndisposable += outlineView.reactive.dataSource.feed(\n    property: dataSource,\n    to: #selector(NSOutlineViewDataSource.outlineView(_:numberOfChildrenOfItem:)),\n    map: { (dataSource: Element.UnderlyingCollection?, _: NSOutlineView, item: Element.UnderlyingCollection?) -> Int in\n        guard let dataSource = dataSource else { return 0 }\n        return item?.children.count ?? dataSource.count // TODO check if this is correct\n    }\n). OK, here's a reproduction of this crash using the latest changes: \nOutlines.zip\n. > Maybe we should refactor this so that the root node is not displayed in the outline view, rather the first level is root node's children.\nYes, I agree with this. We should remove the requirement for a value on the root node. I'm not sure how this would look.. > From what I can see the binder calls appropriate methods on the outline view but nothing happens.\nI've been looking into this today. I'm honestly not sure why these changes aren't propagating to the NSOutlineView control. The events appear to be coming through as expected, but calling the insert/etc methods on the outline view have no effect. \n\nMaybe we should refactor this so that the root node is not displayed in the outline view.\n\nI've pushed up a change that should do just that.. Sounds perfect, and more closely matches the situation I'm working with - thanks @srdanrasic! \nI've had no luck so far working out why the outline view is not updating. I also have a cold. Extrapolate from that what you will \ud83d\ude1c . Whoops! \ud83d\ude1d . Yeah, that was absolutely my fault. I rebased master onto this branch so that it was mergeable again - I should have given you a heads-up - sorry!. It is absolutely necessary to have the initialiser be a requirement of conformance to the protocol? This is getting in the way of conforming existing types to this protocol.. It\u2019s an NSObject so reference type. . Is there any limitation that would prevent this from being Any? instead of AnyObject?? Seems like it might be really nice to pass around raw Swift structs and enum values?. Thankfully, I've tested this and it seems to work just fine with enums as well. Let me check the specifics, but it seems to work just fine.. @raygun101 - this isn't a comment on the contents of the PR - more about etiquette. \nYou should include this message/content in the PR description, not inside the readme in the repository.. ",
    "wiruzx": "As I understand, in current implementation, it's possible to change someone's Dynamic<T> value.\nI'd like to forbid users to change value inside of my Dynamic property.\nLike in ReactiveCocoa's implementation, where there are RACSignal which value you cannot change, and RACSubject with changeable value. Also RACSubject is a subclass of RACSignal, so you can use RACSubject inside the class and give RACSignal to outside.\n. That's great\n. ",
    "TadeasKriz": "Hi, any progress on this feature? Thanks.\n. @srdanrasic Awesome! Thanks! Btw, are you thinking about including the rename in the new major release as well as talked in #47? :)\n. @srdanrasic What's your view on this?\n. @srdanrasic What is the difference between:\ndynamic1 ->> dynamicX\ndynamic2 ->> dynamicX\nand\nany(dynamic1, dynamic2) ->> dynamicX\nBecause I think that even the dynamic should not be allowed to have more than one other dynamic binded to it. What is the use case for it anyway?\n. ",
    "thedevme": "How long do you think it will be before Bond 4 is out of beta?\n. ",
    "huyphams": "It works fine if you include Bond as Dynamic Framework with optional option. I did a lot of research about using Dynamic Framework in Swift with iOS7. :dancer: \n. Here bro :dancer: \nhttp://quellish.tumblr.com/post/103107323582/dynamic-frameworks-on-ios-7\n. But there are no Dynamic Frameworking linking in Cocoapods. Cocoapods imports Bond source code directly to your project, so you don't need to worry about that issue.\nEdit: Sorry, in swift it must be framework.\n. @zdenektopic  sorry about that, in switf it must be framework.\n@srdanrasic thank you, I'll give a try right now.\n. Hi zdenektopic,\nIt works as expected, but I don't know Apple accept or reject if my project use Dynamic Framework target to 7.0\n. Many thanks :dancer: \n. It's an error or warning?\n. It won't crash if in your framework does not contain \"App extension\". App extension only supports iOS > 8.0.\n. ",
    "PrideChung": "@huyphams How to write the Podfile to specify Bond should be weak linked? I'm eager to know, thanks.\n. ",
    "laptobbe": "Yes it should definitely be possible to achieve with a remove and insert. But I tried that with the TableView Bond and the resulting animation was less then ideell. Also the move did not work everytime I suspect because of calls to begin and end updates. So I implemented this instead. If we can get it to work with a remove and insert that would be great.\nI am using it this way. Just wanted to share if someone had experienced the same problems.\n. ",
    "raven": "I found Dynamic to be somewhat confusing as well. Whilst reading your initial blog post I was following along ok, but after cloning and playing with the framework I was lost again and had to force a mental mapping. Also as dynamic is a declaration modifier in Swift, that can also lead to confusion.\n. ",
    "advantis": "Agree. To me Dynamic sounds more like a physics term. And InternalDynamic is quite obscure (but it's internal after all :). But this definitely requires a major version change, so we could put it on hold for a while.\n. ",
    "sync": "I don't mind Observable, alsoBinding could lead to confusion\n. See https://github.com/SwiftBond/Bond/pull/97\n. Yes it did, sorry I should have mentioned this\n. Doing this now\n. Yes :-(\n. ",
    "lyricsboy": "While I don't have a strong opinion, I will note that the first thing that comes to mind when I hear Observable is Java. :japanese_goblin: \n. ",
    "Adlai-Holler": "Implemented in #51 \n. Also wondering if you think removeAll should be implemented as setArray:[]?\n. I started thinking about removing/adding bonds at inconvenient times. So in the latest commit, if you add a bond in willChange, or remove a bond in didChange, we'll respect that. \nIn willChange we keep going through self.bonds, dispatching any newly added bonds until there aren't anymore to call.\nIn didChange we go through the bonds we dispatched in willChange, but before calling each one we check that it's still a member of self.bonds. Slower but much safer.\n. @srdanrasic Good catch! I've made the change\n. Yeah but unfortunately by the time I apply the operation, my FRC's data has already changed so if any of the changes cause someone else to look at the FRC, they'll be expecting to see an older version of the data than they'll get. \nNo big deal though, and no great way around it.\n. I had to move super.init([]) after pointers is set up, so that the initial count that DynamicArray reads will be correct.\n. What is the policy about directly modifying DynamicArray.value? Is that something that should be supported at all?\n. ",
    "JustinTulloss": "Ok. Seems like I probably should have thought of that, but it wasn't obvious to me from the docs.\nThanks!\n. (And I see that it's explicitly stated in the docs now, it's just not actually spelled out in the examples)\n. ",
    "juandent": "Thanks!!!\nSorry hadn't seen that!!\n. Thanks!\n. version 3.7.4 has not corrected this problem... @objc does not solve it. Only eliminating private qualifier will work!\nJuan\n. No I am not sure! Because I comment out all the use of Dynamic and Bond and I still get the message!!\nWhat could it be? What does INM Stall mean? How can I debug it?\nThanks!!!\nJuan Dent\n. Another question more on Bond's side for sure:\nI need to create a dynamic property for the objectValueOfSelectedItem in a NSComboBox .. Have been trying to add an extension to NSComboBox like so.. the dynIndexOfSelectedItem seems to work fine but I am having trouble with the dynObjectValueOfSelectedItem: it says it cannot compile \n``` swift\nclass NSComboBoxDynamicHelper: NSObject {\nweak var control: NSComboBox?\nvar listener: (Int -> Void)?\n\ninit(control: NSComboBox) {\n    self.control = control\n    super.init()\n    control.target = self\n    control.action = Selector(\"selectionChanged:\")\n}\n\nfunc selectionChanged(sender: AnyObject?) {\n    if let combo : NSComboBox = sender as? NSComboBox {\n        let index = combo.indexOfSelectedItem\n        self.listener?(index)\n    }\n}\n\n}\nclass NSComboBoxDynamic: InternalDynamic {\nlet helper: NSComboBoxDynamicHelper\n\ninit(control: NSComboBox) {\n    self.helper = NSComboBoxDynamicHelper(control: control)\n    super.init(control.indexOfSelectedItem )\n    self.helper.listener =  { [unowned self] in self.value = $0 }\n}\n\n}\nclass NSComboBoxDynamicT: InternalDynamic {\nlet helper: NSComboBoxDynamicHelper\n\ninit(control: NSComboBox) {\n    self.helper = NSComboBoxDynamicHelper(control: control)\n    super.init(nil )\n    self.helper.listener =  { [unowned self] in self.value = $0 }\n}\n\n}\nprivate var indexOfSelectedItemDynamicHandleNSComboBox: UInt8 = 0;\nprivate var objectValueOfSelectedItemDynamicHandleNSComboBox : UInt8 = 0;\nextension NSComboBox: Dynamical, Bondable {\npublic var dynIndexOfSelectedItem: Dynamic<Int> {\n\n    if let d: AnyObject = objc_getAssociatedObject(self, &indexOfSelectedItemDynamicHandleNSComboBox) {\n        return (d as? Dynamic<Int>)!\n\n    } else {\n        let d = NSComboBoxDynamic<Int>(control: self)\n        let bond = Bond<Int>() { [weak self] v in if let s = self\n            {\n                let itemCount = s.numberOfItems\n                if v > -1 && v < itemCount\n                {\n                    s.selectItemAtIndex(v)\n                }\n            }\n        }\n        d.bindTo(bond, fire: false, strongly: false)\n        d.retain(bond)\n        objc_setAssociatedObject(self, &indexOfSelectedItemDynamicHandleNSComboBox, d, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN_NONATOMIC))\n        return d\n    }\n}\n\npublic var dynObjectValueOfSelectedItem : Dynamic<AnyObject?> {\n\n    if let d: AnyObject = objc_getAssociatedObject(self, &objectValueOfSelectedItemDynamicHandleNSComboBox) {\n        return (d as? Dynamic<AnyObject?>)!\n\n    } else {\n        let d = NSComboBoxDynamic<AnyObject?>(control: self)\n        let bond = Bond<AnyObject?>() { [weak self] v in if let s = self\n            {\n                s.objectValue = v\n            }\n        }\n        d.bindTo(bond, fire: false, strongly: false)\n        d.retain(bond)\n        objc_setAssociatedObject(self, &objectValueOfSelectedItemDynamicHandleNSComboBox, d, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN_NONATOMIC))\n        return d\n    }\n}\n\n}\npublic func <->> (left: NSComboBox, right: Dynamic) {\n    left.dynIndexOfSelectedItem <->> right\n}\npublic func <->> (left: Dynamic, right: NSComboBox) {\n    left <->> right.dynIndexOfSelectedItem\n}\n```\nThanks.,\nJuan Dent\n. I also use a datasource for the combo so i cannot use the objectValueOfSelectedItem property\n!!\n. I see that we have notifications for ComboBox -- maybe I should try to capture these?\n. How can I contribute to this amazing framework?\n. can I have some support if I contribute to this framework?\n. HI,\nI reported this issue a while ago... I think adding @objc attribute makes the most sense since it allows us to keep it private\nRegards,\nJuan Dent\n. First one remark: this framework is AWESOME! Congratulations!\nJust had one question: is there no support for Set or at least NSSet?\nRegards,\nJuan\n. If no support is currently available for Sets, what do you suggest is the best workaround?\n. For instance, CoreData uses NSSet, NSOrderedSet etc for to many relationships ... how we interact with these if we have no ObservableSet?\nOne idea (not sure about performance) would be to create an ObservableArray with the set's contents and interact with that instead of with the set... Could it work?\nRegards,\nJuan\n. Hi!\nO tried this idea but it does not compile\nLet name : observable. \nCannot be initialized with \n\nname = Observable(object: person, keyPath: \"name\")\n\n??\nRegards \nJuan dent\nSent from my iPhone\n\nOn Sep 23, 2015, at 8:39 AM, Sr\u0111an Ra\u0161i\u0107 notifications@github.com wrote:\nYes, ObservableSet and ObservableDictionary might be interesting features. I had something like this in mind with Bond 4 but didn't have enough time to implement it. I'll put it in the ToDo list.\nRegarding CoreData, I'm not sure what kind of integration do you have in mind? You could use KVO to bridge scalar values to Bond. Sets would not work. Only way would be to convert them manually to ObservableArrays. Having less than a 100, maybe even 1000, objects in a Set would probably not impact performance in a significant way. CoreData (and even Realm) integration might be another ToDo item.\nclass Person: NSManagedObject {\n  @NSManaged var name: String\n}\nextension Person {\n  class ObservablePerson {\n    let name: Observable\ninit(person: Person) {\n  name = Observable(object: person, keyPath: \"name\")\n}\n}\nfunc observableVariant() -> Person.ObservablePerson {\n    return ObservablePerson(person: self)\n  }\n}\nlet p = Person(...).observableVariant()\np.name.bindTo(nameLabel)\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes now it works!! \n\nThanks!\nJuan\n\nOn Sep 27, 2015, at 8:13 AM, Sr\u0111an Ra\u0161i\u0107 notifications@github.com wrote:\nDo you have these two imports?\nimport Bond\nimport CoreData\nIt compiles fine for me...\n\u2014\nReply to this email directly or view it on GitHub https://github.com/SwiftBond/Bond/issues/153#issuecomment-143560913.\n. \n",
    "felixpalmer": "Forgot to say: version 3.7\n. OK makes sense. I should have read the docs more closely. Not sure if it is possible, but it would be great if the framework could catch when an unretained Bond like this is created, and warn the user\n. ",
    "ahmedtarek-": "@felixpalmer hello there! I wanted to ask you about the android visualizer code! I am trying to edit the for loop which generate the points in onRender() method in LineRenderer class to only have a thin line that plays with music without all the other graphs. But I can't find a way to do that, any help?\n. ",
    "morizotter": "I'm not an expert of bidirectional binding. But I can explain the reason of the pull request https://github.com/SwiftBond/Bond/issues/61 from 2 points of view. First is conflict and second is the underlying cause. It's probably that the problem is not in Bond but UITextField/View's behavior.\n1 The conflict\nIf Bond set the new value to the text field / view when user is editing it, it's conflict. This is the difficult issue that needs decision. But I think it's better to prioritize user's input. This pull request prioritize user's input. If the Bond value is different from user's input, prioritize Bond value. This is decision. When this pull request is merged, It is maybe good to write this behavior in README.\n2 The underlying cause is the behavor of UITextField\nI think the underlying cause is the behavor of UITextField/View. Try getting textField's text - which needs conversion, for example Japanese -  when editingChanged(control: UITextField) called and set it to the same instance of textField without using Bond. The result is pre-confirmed text and converting text. Bond or bidirectional binding is not the cause.\nWhen editingChanged(control: UITextField) is called, the value of text field is not confirmed. Although setting the new value to text field, text field's unsettled value remains.\nThis strange behavior is probably only for UITextField/UITextView. So, you don't have to write if-clause every other binding item.\nI made issue https://github.com/SwiftBond/Bond/issues/64 . Because many users are interested in this issue and needs more discussion.\n. This issue is made by the discussion of https://github.com/SwiftBond/Bond/issues/61 .\n. @srdanrasic Thanks! It helps us a lot!\n. I can use Carthage. This issue can be closed.\ngithub \"SwiftBond/Bond\" == 3.7.4\n. See https://github.com/SwiftBond/Bond/pull/211\n. @srdanrasic  Thank you for your review! I think your solution is good, simpler! I rewrote my pr :+1: \n. ",
    "whateverx": "Thank you, got it for dynFrame\nUsing  Bond 3.7.2, I was playing with dynamicObservableFor but it throw me an error during the cast of the generic T on this line\nswift\npublic func dynamicObservableFor<T>(object: NSObject, #keyPath: String, #defaultValue: T) -> Dynamic<T> {\n...\nlet value: T = (keyPathValue != nil) ? (keyPathValue as? T)! : defaultValue\nCould not cast value of type 'NSConcreteValue' (0x1740576b8) to 'C.CGRect' (0x1002c5f80)\ni'll try to find out what is going wrong\n. I had to use NSValue for the defaultValue and map to  CGRect because object.valueForKeyPath(keyPath)return  an NSValue \nnow it works great !\nswift\ndynamicObservableFor(self, keyPath: \"frame\", defaultValue:NSValue(CGRect: CGRectZero)).map{$0.CGRectValue()} ->| frameListener\nis there a better way ? \n. The second way seems to be better\nYou've done an amazing job with Swift Bond, thank you!\n.  @srdanrasic\n I can reproduce a crash (maybe it is the same as @DenisLaboureyras)\nI set an ObservableArray with 200 strings\nEach 0.2 seconds I remove 5 objects in the performBatchUpdates\nIt always (randomly) crash\n``` swift\n     @IBOutlet weak var tableView: UITableView!\nvar arraybind:ObservableArray<String>!\n\nvar queue: dispatch_queue_t!\nvar timer: dispatch_source_t!\n\noverride func viewDidLoad() {\n\n    super.viewDidLoad()\n\n\n    var array:[String] = []\n    for _ in 1..<200 {\n\n        array.append(NSUUID().UUIDString)\n\n\n    }\n\n\n    arraybind = ObservableArray(array)\n    arraybind.lift().bindTo(tableView) { indexPath, dataSource, tableView in\n        let cell = tableView.dequeueReusableCellWithIdentifier(\"Cell\", forIndexPath: indexPath)\n        cell.textLabel?.text = dataSource[0][indexPath.row]\n        return cell\n    }\n\n\n\n    queue = dispatch_queue_create(\"timer\", nil);\n    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, UInt64(0.2 * Double(NSEC_PER_SEC)), UInt64(0.2 * Double(NSEC_PER_SEC)));\n    dispatch_source_set_event_handler(timer) {\n        dispatch_async(dispatch_get_main_queue(), {\n\n\n\n            self.arraybind.performBatchUpdates { myArray in\n\n                if myArray.count > 10 {\n\n\n                    // create an array with unique random index\n                    var arrayIndexToDelete:[Int] = []\n                    while arrayIndexToDelete.count < 5 {\n                        let randomIndex = (Int(arc4random_uniform(UInt32(myArray.count-5))))\n                        if !arrayIndexToDelete.contains(randomIndex){\n                            arrayIndexToDelete.append(randomIndex)\n                        }\n\n                    }\n\n\n                    // delete\n                    for randomIndex in arrayIndexToDelete {\n\n                        myArray.removeAtIndex(randomIndex)\n\n                    }\n\n                }\n\n            }\n\n\n        })\n    }\n\n    dispatch_resume(timer)\n\n\n    arraybind.observe { event in\n\n        switch event.operation {\n        case .Insert(let elements, let fromIndex):\n            print(\"Inserted \\(elements) from index \\(fromIndex)\")\n        case .Remove(let range):\n            print(\"Removed elements in range \\(range)\")\n        case .Update(let elements, let fromIndex):\n            print(\"Updated \\(elements) from index \\(fromIndex)\")\n        case .Reset(let _):\n            print(\"Array was reset \")\n        case .Batch(let operations):\n            print(\"Operations \\(operations) were perform on the array\")\n        }\n    }\n\n\n\n}\n\n```\nthe error seems to happen in ObservableArrayEvent.swift\nswift\npublic func changeSetsFromBatchOperations<T>(operations: [ObservableArrayOperation<T>]) -> [ObservableArrayEventChangeSet]\nwe got 5 operations (delete) and should return an array of type ObservableArrayEventChangeSet with 5 Deletes(Set), but sometimes it return only 4 Deletes. \nSo the tableView.endUpdates() crash\nseems to happen when we want to delete two ranges who are close \n[Bond.ObservableArrayOperation<Swift.String>.Remove(Range(64..<65)), Bond.ObservableArrayOperation<Swift.String>.Remove(Range(63..<64)), Bond.ObservableArrayOperation<Swift.String>.Remove(Range(6..<7)), Bond.ObservableArrayOperation<Swift.String>.Remove(Range(17..<18)), Bond.ObservableArrayOperation<Swift.String>.Remove(Range(66..<67))]\n[Bond.ObservableArrayOperation.Remove(Range(64..<65))\nBond.ObservableArrayOperation.Remove(Range(63..<64))\n. ",
    "arytbk": "Sure!\nI just tried to do it myself starting with WKInterfaceLabel, however I was blocked by the fact that WatchKit properties are write only - so there is a setText but you can\u2019t read back the current value of the text property!\nFor this we might need write-only Dynamic ?\n\nOn 21 May 2015, at 13:15, Sr\u0111an Ra\u0161i\u0107 notifications@github.com wrote:\nThanks! That's great idea. Putting it in TODO list. I don't have much time at the moment though.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/SwiftBond/Bond/issues/66#issuecomment-104213197.\n. \n",
    "modnovolyk": "When i first run thought Bonds readme i thought skip function does the same. In fact it does the same but takes count as parameter, not time interval.\n. Another question is multithreading and this function. As far as i know it is not possible to dispatch_after on specific (current) Thread. So current implementation use main_queue to do that. In general, i think it is safe (for all UI events and properties and changes from main Thread), but could be very confusing in rare cases. We should clearly note that in Readme.\n. ",
    "rnine": "@srdanrasic Unfortunately the changes in v3.7.3 did not fix this issue.\nI noticed you added the @objc to the class rather than the private function, hence the situation has not changed (selector is still not recognised.)\nSwift\n    @objc private func textChanged(sender: AnyObject?) {\n        self.listener?(control?.stringValue ?? \"\")\n    }\nThis, however works as intended :+1:\n. @srdanrasic Great, thank you! :+1: \n. ",
    "zipme": "never mind, it's the Build config issue\n. I only need a very simple event emitter, that's why I use Dispatcher.\nI am trying out Observable now as you suggested, any idea which initializer I should use?\nFor example, I have an event type:\nenum MyEventType {\n case EventA, EventB\n}\nTo create an instance of Observable, I  do let observable = Observable()\nAnd to send a event observable.next(MyEventType.EventA) which gives an error.\nIf I do Observable(MyEventType.EventA) then everything works fine. What bothers me is that in order to have an initial event for Observable during initialization, I need to add something like case Empty to MyEventType.\nDid I do something wrong here?\n. \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\nCool! Thanks for the info!\n. ",
    "Ben-G": "Thanks @srdanrasic for the quick response!\nAs Im trying to say, also \"fine-grained\" changes (as examples shown above) lead to a reassignment of Swift Arrays, therefore the Bond functionality works as expected for any modification of Swift Arrays.\nJust trying to confirm that and make sure I'm not missing something :]\n. Sorry; my example at the top was missing the access to .value.\nI understand what you are saying now! If I'm interested in the details of a fine grained change I need to use DynamicArray.\nHowever, even fine grained changes to regular Swift Arrays will trigger the regular listener - I just won't get detailed information about what has changed. \nThanks for clarifying!\n. ",
    "toineheuvelmans": "With Xcode 7.0 beta 3 and today's (July 10th) version of Bond swift-2.0 branch I get a compile error in Bond+Foundation.swift:50 :\noverride dynamic func observeValueForKeyPath(...)\n\"Method does not override any method from its superclass\". Any idea?\n. ",
    "gvimlan95": "Adding this framework(by copy and pasting all the swift files) to my existing framework running on Xcode 7 beta 4 gives error on the bond swift files.Anyway I can solve this?\nthank you\n. @ushisantoasobu  Hey man, Thanks for the reply. But sadly I m facing the same error even after changing. \n\n. @srdanrasic \nHey man. Yes I m using Bond V4. Thank you for the reply. I looked up at the migration document earlier and it was advised to \"bindTo\" instead of \"-->\". However, I still had the same problem. \n\n. @srdanrasic \nIts working :)\nThank you my friend. And your doing a great job with the framework.\n. @srdanrasic Thank you for  your reply. \n Below is my full function:\nvar data = Dynamic<[PFUser]?>(nil)\nif let data = data.value{\nprint(\"Data value (data.value)\")\nreturn\n}\n. Its working man. Thank you :)\n. ",
    "weiqingfei": "Thanks for your reply.\nActually I don't use the properties directly. I just wonder why the Dynamic must be retained(strong reference) by Bond.\nNormally we create a Dynamic retained by a viewModel, when we bind it to a Bond, then the Dynamic will be retained by 2 objects.\nwhat will happen if we only let Bond to weak reference to Dynamics?\n. Thanks for your reply.\nI think I know why. Very clever design.\nI'm a newbie to swift, and fear using strong references, I tend to make a object retained by only one as possible.\nThanks again.\n. Thank you for your kind reply.\nI will study the document.\n. Actually I haven't started a real app with this framework yet.\nI just want to know how it works now.\nNormally setting the same value will make the same result, if we can check the value's change, app will not to do same invalid work, especially in some case it will trigger a lot of update.\nSorry, maybe I was thinking too much.\n. Thank you for your advice, I'll pay attention to that.\n. ",
    "ivanmoskalev": "I'm sorry that I didn't make clear what I intended to communicate in the initial post.\n``` swift\n  func testMultipleBonds() {\n    let dynamicInt = Dynamic(0)\nvar counter = 0\nlet intBond = Bond<Int>({ value in\n  counter++\n})\n\ndynamicInt ->| intBond\ndynamicInt ->| intBond\ndynamicInt ->| intBond\n\ndynamicInt.value = 1\n\nXCTAssert(counter == 1, \"Bond called more than once\")\n\n}\n```\nAs you may see, I'm binding the same Bond to the same Dynamic, three times. I use the ->| operator which doesn't fire on binding. After that I change the value of a dynamic, and the bond's handler closure gets called three times.\nI would expect that it would be called only once.\nIt happens because bonds property of Dynamic is an array, and not a set.\npublic var bonds: [BondBox<T>] = []\nIf this is the expected behavior, then let's close this issue! :) \nOtherwise, we can make every Bond and Dynamic (and their *Boxes) Hashable and Equatable (I guess, it is possible to use UnsafePointers to achieve this), and then use Sets to reference bindings.\n. I can submit a pull request if you like! :)\n. I'm glad my little effort helped your great library! Keep up the awesome work! :+1: \n. Hi! Did you try to use Two way Key-Value-Observing?\n. @srdanrasic I suggest we make a tag on Stackgoverflow for questions, what do you think? Typhoon does that.\n. Just ask people to use it in Readme :)\n. Needs thorough review + testing with examples.\nI would probably want to add tests for Bond/BondBox implementation of Hashable before merging in.\n. Done with that. Please review, and I'll do rework if it is needed.\n. Thank you! A good architecture is always a pleasure to work with! :)\nI thought about one thing though: Dynamic.bonds is public. Could my change have broken some end users' code? append vs. insert etc.\n. Yes, exactly! \n. Closed, PR merged in\n. Awesome @srdanrasic!\nI just thought: maybe it would be appropriate to name this operator decorate? Not only does it extend the particular Dynamic's behaviour ('decorating' it), but it is also intended primarily for adding animations and other visual adornments \u2013 decorations :) \n. @levous I'm mainly waiting for the public release of v.4, when things get stable. Otherwise @srdanrasic  will just have more tests to edit in case of restructuring the framework.\n. Yay, cool! Thanks for the info, I didn't have the chance to have a detailed look at 2.0 protocols, will do this tonight :)\n. I think I fixed it, guys. Please don't merge before I squash the branch\n. We are good to go!\n. Code Coverage is currently unsupported for Swift. I suggest we freeze this PR until it becomes available. \n. @srdanrasic we now have Code Coverage! The only thing \u2013 I had to use xcodebuild as xctool doesn't support Xcode's new coverage generation option yet. This made logs a bit verbose, I'm afraid.\n. I think this can be merged.\n@srdanrasic, can I merge the PRs, or you'd prefer to do it yourself?\n. Awesome! :+1:\nI personally like the shorthand-arg way of doing it. \n. Awesome, thank you!\n. Awesome :+1: I'd love to have that.\n. @srdanrasic :+1:  wonderful and abstract: we can have caches not only for arrays. \n. Hi Austin! Thank you for a contribution! :)\nI have asked several questions, and I think it is worth sorting them out before merging. I hope you don't mind :)\n. Good to merge :+1: \n. @srdanrasic @adly-holler I think this is where my performance tests project can come in handy, at least they should help detecting emerging computational complexity issues. I'm sorry it is taking so long, I have quite a high workload right now, but I will mosdef get back to it around next week.\n. I think we should rebase swift-2.0 on top of develop, not merge the latter into the former.\n. cc/ @srdanrasic\n@mattijsf I think you can just close it, I have opened #115. Hope we can do it today :)\n. @srdanrasic I have began work\n. Rebased successfully. Pushed to the new swift-2.0-rebased branch (forcepushing to original branch will rewrite commit SHA's \u2013 leading to havoc, possibly)\n. Good catch, I've encountered that just today. I think any Bond indeed shall be bound to only one Dynamic at a time.\n. I too think that allowing multiple sources is encouraging bad practices. If\nwe need this only internally, maybe it makes more sense to make a special\nmany-to-one Bond for internal use?\nBy the way, I can't wait to see Bond v.4 :) Have a feeling it would be\nsuper awesome.\n\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a, 10 \u0430\u0432\u0433\u0443\u0441\u0442\u0430 2015 \u0433. \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c Tadeas Kriz \u043d\u0430\u043f\u0438\u0441\u0430\u043b:\n\n@srdanrasic https://github.com/srdanrasic What is the difference\nbetween:\ndynamic1 ->> dynamicX\ndynamic2 ->> dynamicX\nand\nany(dynamic1, dynamic2) ->> dynamicX\nBecause I think that even the dynamic should not be allowed to have more\nthan one other dynamic binded to it. What is the use case for it anyway?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/SwiftBond/Bond/issues/123#issuecomment-129368126.\n. Awesome :+1: \n. @srdanrasic Maybe you can open a pull request to master, so we can discuss things in code comments?\n. @srdanrasic @UPetersen I used Bond both ways and I can say that the function version looks cleaner. It represents an abstract concept that's instantly understandable even to people who don't know about Bond or haven't read its documentation\n. @srdanrasic @frankschlegel @tonyarnold to my mind ObservableValue etc. is too long and verbose.\nWhat about Bindable and BindableArray? It also plays well with the library name.\n. @frankschlegel this is not about the typing effort. Verbose names for generic entities are not a good thing, as much information is filled in later.\nbecause they are way too generic.\n\nThey do serve a generic purpose.\nBut yes, @srdanrasic and @tonyarnold, I agree, Value-Array postfixes are logical. I too agree that my Bindable example is not good, for the reasons stated and because it is verbose as well. \nI'm still convinced that we should think twice before renaming, and try to imagine the actual code.\n``` (swift)\nenum MessageFeedState {\n    case Ready\n    case Sending\n    case Failed\n}\nclass MessageFeedViewModel {\n    let title = ObservableValue(\"\")\n    let state = ObservableValue(.Ready)\n    let messages = ObservableArray([])\n}\n```\nIt is definitely much readable than Vector/Scalar, but it is very verbose.\nPlus, Observable in the aforementioned case wraps a property of a class or structure, not the value (which changes). It is ObservableProperty then. We bind to properties and variables, but not to their values.\nRight, and it is also quite possible that the contained type has reference semantics (plainly put, is a class), and so the instance of Observable stores a reference. \nI by no means push my opinion, I just try to highlight the fact that naming is a difficult thing and can't be taken lightly. \n. @frankschlegel @tonyarnold Really speaking, I'm not that much against the proposed naming to argue over it a lot. I think I conveyed what I thought might be useful for making the final decision, probably better to stop the discussion at that :) \n. @frankschlegel Hey, it was me arguing the most :)\n. @srdanrasic I'm for this decision.\n. I have browsed through the changes and I think this is just awesome and fantastic. Superbly done @srdanrasic! This is literally the framework of my dreams :)\nI'd give it a try later tonight in my recent prototype project and will share my impressions with you!\n. @serieuxchat I think what you are talking about is futures and promises. I think those were featured in the first alpha of v4 but removed later.\nHave a look at BrightFutures. You can subscribe to the result of a Future and manipulate your Observables imperatively from there (using someObservable.next(value))\n. @DenisLaboureyras can you please show us the code which does the merging.\nAs a wild guess: It seems that replacing happens in two discreet steps, and there is a race condition in which the deletion sometimes occurs after the insertion.\n. @DenisLaboureyras you could try logging a message before each change is applied to the ViewModel. This can give you some insight into what operation / pattern of operations causes the crash :)\n. @juandent Hi!\nA very interesting topic!\nCan we continue this discussion in a separate issue please? :)\n. @AnthonyMDev awesome, let's do it! \n. @srdanrasic I'll be glad to help with ReactiveKit too. CI / Coverage / Tests as usual :) If you add me to the organization, I'll set it all up.\n. @srdanrasic Ready for merge.\n. Hello @huanghe810229530. Could you please clarify your question? Some examples of what you want to achieve (with code) would be perfect.\n. I think a counted set is best fit for all reference counting tasks! \nBut since the only way one can manipulate these arrays is bind(...) and unbindAll(), I think an array is OK! Maybe it could cause trouble if there was an individual unbind() operation \u2013 for example, if user could do so:\nb.bind(a) // 1st time\n<...>\nb.bind(a) // 2nd time\n<...>\nb.unbind(a) // binding dangling\nBut so far it seems this is out of scope of this issue / PR.\n. Why not just self?.userInteractionEnabled = v? \n. I agree on that :)\n. Bond already implements Equatable based on identity \u2013 take a look here! \n. Maybe it is worth shipping this feature in a separate PR? \n. I think we need a test assertion here.\n. What was wrong about value.first?\n. What was wrong about value.last?\n. Why make it a static (class) function? I think instance function would be much prettier.\nswift\npublic func flatten() -> DynamicArray<T> {\n  return DynamicArrayFlattenProxy(nestedSourceArray: self)\n}\nUsage:\nswift\nlet nestedArray = DynamicArray<DynamicArray<String>>([DynamicArray([\"d\", \"e\", \"f\"])])\nlet flattened = nestedArray.flatten()\nMoreover, I'd implement it first as a module-level function (see map)\n. Why is it public? Testing reasons?\n. Complexity is O(n).\nMaybe it is worth to measure and in case of issues replace it with a simple linked-list? (how much I'd like an std::deque here :)\n. ",
    "levous": "Great suggestion!  If you've tested it, could you contribute the first performance tests?  Im sure the project maintainers will feel more compelled to ensure those tests are automated and tracked over time if they have something to start with. \n. ",
    "murrayds": "It sounds like your variable \"sceneModel.req.password\" is of type String and not of type Dynamic.\nTry instantiating the password variable like this: \nvar password: Dynamic<String> = Dynamic(\"default\")\nand accessing the value like this:\nlet value = sceneModel.req.password.value\nBonds can only be made between two dynamic variables or between a dynamic variable and a bond. \n. Awesome. I also personally like the shorthand no-arg way of doing it, Unless there are any objections I might soon start working on the necessary changes.\n. I have been making some changes to the code as per the decisions made in this issue however I noticed a few interesting details while searching through the code.\nIn some parts of the project, in particular the UITableView and UICollectionView extensions under their respective declarations of their data source bonds. \n```\nself.didInsertListener = { [weak self] array, i in\n      if let s = self {\n        if let tableView: UITableView = self?.tableView {\n          perform(animated: !disableAnimation) {\n            tableView.beginUpdates()\n            tableView.insertSections(NSIndexSet(array: i), withRowAnimation: UITableViewRowAnimation.Automatic)\n        for section in sorted(i, <) {\n          let sectionBond = UITableViewDataSourceSectionBond<Void>(tableView: tableView, section: section, disableAnimation: disableAnimation)\n          let sectionDynamic = array[section]\n          sectionDynamic.bindTo(sectionBond)\n          s.sectionBonds.insert(sectionBond, atIndex: section)\n\n          for var idx = section + 1; idx < s.sectionBonds.count; idx++ {\n            s.sectionBonds[idx].section += 1\n          }\n        }\n\n        tableView.endUpdates()\n      }\n    }\n  }\n}\n\n```\nIf you look at the above snippet, you should notice that the variable 's' stored self and is explicitly defined in the top if let... statement. The 's' variable is then referenced several times in the following block. The question is: should the 's' variable continue to be used? or should the upper-most if let... statement be removed and instead replace 's' with 'self?' in the code block? \n. @ivanmoskalev Sorry for the delay in responding to this comment. The updated statement you recommend works fine however it is inconsistent with the implementation of other dynamic variables in the project. I do believe that all dynamic variables should be updated however that task is outside the scope of this branch. \n. @ivanmoskalev Thanks for the input, I created an issue for the proposed changes so that discussion can take place. I might take ownership of the issue and make the change in the near future.\n. ",
    "adcooley": "Made some changes, still need to get tests passing. I'll mention you at that point\n. hey guys, reviewed all comments and made some changes. Also fixed tests...it works now :) @ivanmoskalev @srdanrasic \n. Calling value.first will crash on the internal proxy array because we aren't allowed to get the value\n. Same here\n. I'm not sure of a way to make flatten an instance function. Basically this only works on DynamicArrays of DynamicArrays. I went ahead and moved it to a module-level function though\n. negative...good catch\n. ",
    "tonyxiao": "Also it looks like since I last checked there are now merge conflicts. Will resolve and update the PR.\n. It feels that we are moving closer to ReactiveCocoa with the bond-4 release. As I understood the initial motivation for Bond (http://five.agency/solving-the-binding-problem-with-swift/) is to have a dead simple implementation of binding for those who don't want the complexity of introducing a reactive paradigm into their programming model. Is that still the case? How do you see us positioning ourselves conceptually?\n. I actually implemented CoreData integration for bond v3, working on getting it upgraded to bond v4 at the moment. Take a look (v3 version) https://github.com/tonyxiao/Bond/blob/coredata/Bond/Bond+CoreData.swift\n. My thinking it that we can have a sibling class of Observable array (so subclass of EventProducer<ObservableArrayEvent<Array<ElementType>>>) that's backed by CoreData / Realm. \n. Yea, I started the conversion to v4. I have a version now that compiles but I haven't gotten a chance to actually test it with TableView yet. It's especially not clear to me how to compose multiple FetchedResultsArray as sections of a single Observable parent array yet. But here's the wip https://github.com/tonyxiao/Bond/blob/master/Bond/Extensions/iOS/CoreData+Bond.swift\n. ",
    "ZENUAV": "Thanks for speedy response.\nThe compiler does not like the \\\nIs this correct??\n. ",
    "mattijsf": "Ah yes! ugh Why didn't I see that ;) Shall I close / remove this one then?\n. ",
    "ushisantoasobu": "If the type of value i wanna access is Int (or like kinds of that), it's pretty bad workaround, but i can do it like below.\nsomeButton.dynEvent.filter(==, .TouchUpInside)\n                .rewrite(UIControlEvents(rawValue: UInt(someValue))) ->> someAction\nlazy var someAction: Bond<UIControlEvents> = Bond() { [unowned self] event in\n    print(Int(event.rawValue))\n}\nIf we can make some UIControlEvent's subclass, it maybe easier...\n. Thank you for your consideration. What I try to achieve is simple. I made a UITableView about Group data.\nself.groupList.map { [unowned self] (group: Group) -> UITableViewCell in\n    let cell = GroupTableViewCell()\n    group.name ->> cell.nameLabel.dynText\n    cell.editButton.dynEvent.filter(==, .TouchUpInside) ->> self.editTapListener\n    return cell\n} ->> tableViewDataSourceBond\nAnd when we tap a button on the cell, I wanna do some action depending on each group data like below.\nlazy var editTapListener: Bond<UIControlEvents> = Bond() { [unowned self] event in\n    var vc = GroupEditViewController(groupId: groupId) // How can I do??\n    self.navigationController?.pushViewController(vc, animated: true)\n}\n. @gvimlan95 \nYou should use dynImage, below is an example.\nswift\nvar image = Dynamic<UIImage?>(UIImage(named: \"some_icon\"))\nimage ->> someImageView.dynImage\nWe can make confirmation here\nhttps://github.com/SwiftBond/Bond#what-about-uikit\n. @srdanrasic Thank you for reply, and I recognized your roadmap. \n. @srdanrasic I'm sorry...it's my lack of confirmation. \n\nestablish two unidirectional bindings, one of them with ignoreNil.\n\nI did adopt this way, thank you.\n. ",
    "retsohuang": "This is what I use in my project https://gist.github.com/retsohuang/b74c473ec9ccd6cbcac1\n. My bad :(\n. You missing the sendActionsForControlEvents(.TouchUpInside)\n. Thanks for replay, do you have any other (keep type information) ideas that I can use multiple section with different view model bind to a table view like v 3.X does?\n. Thank you!! \n. ",
    "UPetersen": "ReactiveCocoa seems to move away from the |> operator with swift 2.0: \nhttps://github.com/ReactiveCocoa/ReactiveCocoa/pull/2189\n. ",
    "banxi1988": "I'd prefer not change the operator. cause we have to change more code.\n. ",
    "bddckr": "Great work!\n:+1: to the use of the method instead of the operator.\nNow that v4 has a proper alpha release, installing via CocoaPods works by pointing at the branch.\nThe readme currently states \"\u2026observing photo downloads with KVO\u2026\", but I can't find anything to use KVO with Bond v4. Is it coming later? No hurry, just wondering if I'm missing something. :smile:\nI'm asking, because I'm trying to use Bond with Realm. They added full support for KVO for all persisted properties just a few days ago.\n. @srdanrasic That looks exactly like what I want. I like the non-magical approach via observableVariant. Still waiting for the mentioned fine-grained notifications for Realm, so no rush :smile:\n. @tonyarnold @srdanrasic That would provide very concise variables:\n``` swift\nclass MessageFeedViewModel {\n  enum State {\n    case Ready\n    case Sending\n    case Failed\n  }\nlet title = Observable(\"\")\n  let state = Observable(State.Ready)\n  let messages = Observable(Message)\n}\n```\nI can see the distinction between stateful and stateless observables useful for implementing Bond, but have API consumers any interest in the distinction? Observing button taps vs changes to a string are in the end just observations.\n. @srdanrasic I have a use case to use the KVO part differently than currently possible.\nI have some key paths to observe that result in different EventTypes. Because of the lifecycle management I have to store the Observables somewhere (using ObservableLifecycle.Managed would help here)\u2026\nswift\nvar observables: [ObservableType] // error: protocol 'ObservableType' can only be used as a generic constraint because it has Self or associated type requirements\nswift\nvar observables: [Observable<EventType>] // won't work: I observe multiple `EventType`s\nTo solve this I'd just do\nswift\nvar disposables: [DisposableType]\nbut this won't retain the observed Observables, effectively observing nothing.\n\nIdeally I'd be able to do\nswift\nlet theObject: ObservedObject = \u2026\nlet observable = Observable(object: theObject, keyPaths: [\"name\", \"balance\"])\nlet disposable = observable.observe { (object, keyPath, changes) in\n    // theObject === object\n    // theObject.name or theObject.balance did change, check keyPath for which\n    // changes is the KVO change array of type [String: AnyObject]\n}\ndisposables.append(disposable) // no need to store observable\nTo improve the KVO API to include every use case, I suggest something like this:\n``` swift\npublic extension Observable {\n    typealias KeyValueChanges = [String: AnyObject]\n    // ideally these class funcs would be convenience initializers\u2026\n/// Creates a new Observable<(T, String, KeyValueChanges)> that observes the specified key paths on object\n/// (observed object, changed keyPath, kvo change array)\npublic class func observeKeyPaths<T: NSObject>(object: T, keyPaths: [String], options: NSKeyValueObservingOptions = .New) -> Observable<(T, String, KeyValueChanges)> {\n    // \u2026\n    let tuple = (object, \"\", KeyValueChanges())\n    return Observable<(T, String, KeyValueChanges)>(tuple) // don't send anything to potential observers, NSKeyValueObservingOptions.Initial will handle this\n}\n\npublic class func observeKeyPath<T: NSObject>(object: T, keyPath: String, options: NSKeyValueObservingOptions = .New) -> Observable<(T, KeyValueChanges)> {\n    // \u2026\n    let tuple = (object, KeyValueChanges())\n    return Observable<(T, KeyValueChanges)>(tuple) // don't send anything to potential observers, NSKeyValueObservingOptions.Initial will handle this\n}\n\n}\n```\nI don't know if object can be stored strongly on the returned Observable (or the used KVOHelper object). The docs say \"Neither the receiver, nor anObserver, are retained.\"\nOne could argue that T in the EventType tuple is not needed. But I think this would enable the caller to reuse observing closures (at least when the type is the same).\nWith this one could leverage all the KVO functionality. Let me know what you think.\nEdit: I may have successfully implemented this, I will post it later\u2026\n. @srdanrasic combineLatest on multiple KVO observables helps with my use case a lot\u2026 I guess you can forget everything I wrote. :sweat_smile: Thanks for listening, though!\n. I'm not fussed about mapNilToEmpty, we can remove it if it's not needed.\n. ",
    "frankschlegel": "Maybe I'm too picky, but I think Scalar and Vector aren't good names (so was Dynamic), because they are way too generic. How about something like ObservableValue and ObservableArray?\nAnyways, thanks for the great framework!\n. That's what we have auto-completion for, right? And normally you only have to use the names once in the declaration of a variable, and not every time you use it. I'm pro descriptive names, even if they are more verbose.\n. @ivanmoskalev  I actually like your code, but that's a question of taste, I guess.\nAlso, the Observable doesn't wrap the property, it is the property and wraps the property's value.\nIf you don't like value because of the ambiguity with the reference semantics, how about ObservableScalar?\n. @ivanmoskalev Agreed. I wasn't meant to be rude, sorry!\n. Yes, but it actually seems to be a Carthage issue\u2026 kinda.\nWith Carthage the dependencies are build externally and not as part of the project build process. I guess that's why they contain coverage data now after the recent changes to Xcode.\nI already filed a bug report for Carthage, maybe it can be fixed there.. Yes, it actually is. I still think it should be fixed on Carthage's side, but this seems to be harder then expected.\nWhat you could do on your side to circumvent the issue is to disable the \"Gather code coverage\" option for your projects if you don't need it.. In the frameworks -.-\nBackground: The binaries get build with coverage data baked in when you enable that option and use the \"build\" action, but not on \"archive\". So it's usually not an issue if you build the frameworks alongside your app, like you would do when using submodules or CocoaPods. However, Carthage builds the frameworks independently by using the \"build\" action and you just copy them to your app when deploying\u2026 so that the coverage-induced binary ends up in you final app bundle.. @SeanRobinson159 Yes, there was a big discussion going on in the linked Carthage issue. I think they fixed it now (using the archive instead of the build action for ARM binaries), but it's not yet released.. ",
    "joshavant": "For anyone who stumbles on this page from searching around the Bond GitHub project, it seems like some of info in the original post in this thread is out of date. Consult the official documentation/source for the latest info!\n. @srdanrasic The breaking changes from v4 to v3 have been a particularly large and difficult set of changes. That leads me to ask... What are your plans for the future of Bond?\nHow often will there be breaking changes like the v4 -> v3 transition?\nHopefully the (long awaited) stability of Swift 2.0 means that there will be some kind of stability in the Bond API?\n. This addresses #145\n. :+1: \nThanks for maintaining this great project!\n. @srdanrasic Thanks for your helpful reply! That helped a lot to clarify.\nRe: your first comment - Sorry, is the call to print in the code example a class method inside the view controller or the Swift Standard Library function (i.e. the old println from Swift 1.2)?\nAlso, in our app's architecture, our view controllers don't necessarily have knowledge of whether the view model will outlive the view controller. Does this mean we would have to append .disposeIn(bnd_bag) to all view model bindings, in this case?\n(An example of this is if a VC passes the same instance of a View Model it has along to the next View Controller being displayed. If you end up doing that - which is a pretty common occurrence, in our app - it sounds like you'd technically need to dispose all the bindings from the first VC.)\nRe: your second comment - Just to be sure I understand, are you saying the closure that's passed into observer() will be strongly retained by the receiver (i.e. the EventProducer) until dispose() is called?\n. Aha! Ok, I get it now!\nOne more question... How does this work for bidirectionalBindTo?\nFor example:\nviewModel.firstName.bidirectionalBindTo(firstNameTextField.bnd_text)\n...where viewModel outlives the View Controller.\nWould I still need to add .disposeIn(bnd_bag)?\n. Thanks for the update, glad to hear all of this!\nFWIW, as I'm migrating, I really like the syntax and direction of v4, as compared to v3. Awesome work!\n. Thank you so much for the pointers, Sr\u0111an! That worked great!\n. Awesome suggestions, @srdanrasic! Thank you!\nYou're great with the browser... that all (mostly) worked. My only change was to declare the extension, like so:\nextension CollectionType where Generator.Element: EventProducerType, Generator.Element.EventType == Bool {\n(tl;dr - dropped the leading public)\nAlso, instead of passing a function in (because I have to validate lots of forms around the app), I decided to do this:\nfirstNameTextField.bnd_text.map{ !($0?.isEmpty ?? true) }\nIt's not the most pretty or readable, but it also means I don't have to add/maintain a small, one-off extension for String or CollectionType just to check count > 0.\n. ",
    "mblsha": "Is there anything else that should be improved in this pull request?\n. I want to be able to hook up to other NSTableViewDelegate methods, like handling selections and tweaking visual stuff.\nIn AppKit, DataSource is not responsible for cell creation, unlike UIKit.\nIs there an easier way to override only the createCell, with having all other NSTableViewDelegate methods pass-thru?\n. If I do that, I get an error: Protocol 'BNDTableViewDelegate' can only be used as a generic constraint because it has Self or associated type requirements at private var delegate: BNDTableViewDelegate? line.\nAnd I can't specialize it either by appending <T> to the end: Cannot specialize non-generic type 'BNDTableViewDelegate'.\nAm I missing something? Is there a better way to handle this?\n. Wow, this was indeed super helpful. But I'm still stupefied about ObservableType extension. It seems that I can't make it generic, and I can only specialize by specifying ObservableType's typealiases. Is there a way around this as well?\n. Phew! This stuff is hard. Now I know a couple more tricks to make the type system happy. Thank you very much!\n. ",
    "zhouhao27": "Sorry, my mistake. The latest source code has no problem.\n. Inside the customised UIControl I got the TouchUpInside event. Should I do something in that event handler?\nMy code in my UIControl:\n```\n// MARK: local functions\nfunc setup() {    \n    self.addTarget(self, action: \"onTouchUpInside:\", forControlEvents: UIControlEvents.TouchUpInside);\n}\nfunc onTouchUpInside(sender: UIControl) {\n    isChecked = !isChecked\n    delegate?.didSelectCheckbox(self)\n}\n```\n. ",
    "entotsu": "Sorry, I didn't use Swift2.0.\n. I download Xcode7-beta.\nI made empty project and install \"v4\" with Carthage again.\nBut, It still can't install. :sob: \nSame Error is Occurred.\nA lot of amount errors like below.\n\nFunction: void XCGccMakefileDependenciesParsePathsFromRuleFile(NSString strong, void (^_strong)(NSString *strong))\nThread:   {number = 8, name = (null)}\nPlease file a bug at http://bugreport.apple.com with this warning message and any useful information you can provide.\n2015-09-08 14:25:20.606 xcodebuild[82300:1779869]  DVTAssertions: Warning in /SourceCache/IDEXcode3ProjectSupport/IDEXcode3ProjectSupport-7709/Xcode3Core/LegacyProjects/Frameworks/DevToolsCore/DevToolsCore/SpecificationTypes/BuiltInSpecifications/Compilers/XCGccMakefileDependencies.m:77\nDetails:  Failed to load dependencies output contents from ``/Users/Takuya/Library/Developer/Xcode/DerivedData/Bond-fqgmogkbouyvqebifdubujldystv/Build/Intermediates/Bond.build/Release-iphonesimulator/Bond.build/Objects-normal/x86_64/UIView+Bond.d''. Error: Error Domain=NSCocoaErrorDomain Code=260 \"The file \u201cUIView+Bond.d\u201d couldn\u2019t be opened because there is no such file.\" UserInfo=0x7fd1d64019d0 {NSFilePath=/Users/Takuya/Library/Developer/Xcode/DerivedData/Bond-fqgmogkbouyvqebifdubujldystv/Build/Intermediates/Bond.build/Release-iphonesimulator/Bond.build/Objects-normal/x86_64/UIView+Bond.d, NSUnderlyingError=0x7fd1d6448960 \"The operation couldn\u2019t be completed. No such file or directory\"}. User info: {\n    NSFilePath = \"/Users/Takuya/Library/Developer/Xcode/DerivedData/Bond-fqgmogkbouyvqebifdubujldystv/Build/Intermediates/Bond.build/Release-iphonesimulator/Bond.build/Objects-normal/x86_64/UIView+Bond.d\";\n    NSUnderlyingError = \"Error Domain=NSPOSIXErrorDomain Code=2 \\\"The operation couldn\\U2019t be completed. No such file or directory\\\"\";\n}.\nFunction: void XCGccMakefileDependenciesParsePathsFromRuleFile(NSString __strong, void (^__strong)(NSString __strong))\nThread:   {number = 8, name = (null)}\nPlease file a bug at http://bugreport.apple.com with this warning message and any useful information you can provide.\n_ BUILD FAILED *\n. Finally I installed v4 from GitSubmodule.\n. \n",
    "yoshinorisano": "@entotsu \nI've successfully installed 4.0.0-beta3, which is the latest version, with Xcode 7 GM seed using CocoaPods.\nMy Podfile is like this:\nuse_frameworks!\npod 'Bond', '4.0.0-beta3'\nThe README.md states that we should add pod 'Bond', '~> 4.0' to Podfile, but this does not work for now.\n. ",
    "iamtomcat": "I think there are still some bugs in this area. I was able to crash my app pretty consistently a while ago just by using batch updates and removing all items. To get around this atm I just do a removeall and add the items back in as needed. Obviously not very efficient, but I haven't had a chance to look at the code for this area to see what the issue is.\n. ",
    "DenisLaboureyras": "Thanks for your answer!\nHere is a sample of my code.\nThe function called when new data (array of members in this case) arrived:\n```\nfunc mergeMembers(newMembers: [SRMembers])\n{\nself.membersViewModel.performBatchUpdates { membersViewModel in\n\n    //update existing viewmodels replacing member inside the viewmodel\n    for (index, _) in membersViewModel.array.enumerate() {\n        if(index < newMembers.count){\n            membersViewModel[index].changeMember(newMembers[index])\n        }\n\n    }\n\n    //delete old viewmodels if needed\n    if(membersViewModel.count > newMembers.count){\n        membersViewModel.removeRange(newMembers.count..<membersViewModel.count)\n    }\n\n    //append new viewmodels if needed by creating them\n    if(membersViewModel.count < newMembers.count){\n        let membersToExtend = newMembers[membersViewModel.count..<newMembers.count].map {SRMemberCellViewModel(member: $0)}\n        membersViewModel.extend(membersToExtend)\n    }\n\n\n}\n\n}\n```\nThen a (simplified) version of the binding function to the collection view:\n```\nself.viewModel.membersViewModel.lift().bindTo(collectionView, proxyDataSource: self) {[weak self] indexPath, dataSource, collectionView in\nlet memberViewModel = dataSource[indexPath.section][indexPath.row]\nlet cell = (collectionView.dequeueReusableCellWithReuseIdentifier(\"MemberCell\", forIndexPath:indexPath) as SRMemberCell\n\nmemberViewModel.name\n    .bindTo(cell.memberName.bnd_text)\n    .disposeIn(cell.bnd_bag)\n\nreturn cell\n\n}.disposeIn(bnd_bag)\n```\nI tried also more simple versions of the merge function, but it produced the same result.\nNow I'm simply using this syntax to update the array, the UI flash but it is working: \nself.membersViewModel.array = newMembers.map {SRMemberCellViewModel(member: $0)}\n. Here is the fullstack trace. Basically the array is initialized with 0 elements, the cache system fills the array with 3 elements, then the server replaces these 3 values with 3 newer values. Another thing, the merging task is asynchronous, I dispatch it on the main queue.\nThe problem doesn't occur every time, sometimes it works, sometimes not... And btw I blame more the UICollectionView than Bond on the issue :).\nI will try to provide you tomorrow or this WE a small app that reproduces the problem, it will be easier for you.\n* Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of items in section 0.  The number of items contained in an existing section after the update (3) must be equal to the number of items contained in that section before the update (3), plus or minus the number of items inserted or deleted from that section (3 inserted, 0 deleted) and plus or minus the number of items moved into or out of that section (0 moved in, 0 moved out).'\n* First throw call stack:\n(\n    0   CoreFoundation                      0x000000010a453f65 **exceptionPreprocess + 165\n    1   libobjc.A.dylib                     0x000000010706fdeb objc_exception_throw + 48\n    2   CoreFoundation                      0x000000010a453dca +[NSException raise:format:arguments:] + 106\n    3   Foundation                          0x000000010927aae2 -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 198\n    4   UIKit                               0x0000000108564c3b -[UICollectionView endItemAnimationsWithInvalidationContext:tentativelyForReordering:] + 15247\n    5   UIKit                               0x000000010856bc3e -[UICollectionView _performBatchUpdates:completion:invalidationContext:tentativelyForReordering:] + 415\n    6   UIKit                               0x000000010856ba7c -[UICollectionView _performBatchUpdates:completion:invalidationContext:] + 74\n    7   UIKit                               0x000000010856ba1f -[UICollectionView performBatchUpdates:completion:] + 53\n    8   Bond                                0x00000001052684d5 _TFFC4BondP33_9102B403720A1FA7EF4238F1B745828427BNDCollectionViewDataSource24setupPerSectionObserversurFGS0_q__FT_T_U_FGVS_20ObservableArrayEventGSaQT + 1093\n    9   Bond                                0x0000000105268ceb _TTRGrXFo_oGV4Bond20ObservableArrayEventGSaqdT__XFo_iGS0_GSaq_dT** + 43\n    10  Bond                                0x0000000105232afe TFFeRq_4Bond17EventProducerType_S_S0_10observeNewuRq_S0Fq_FFqq_S0_9EventTypeT_PS_14DisposableType_U_FQQPS0_9EventTypeT_ + 158\n    11  Bond                                0x000000010522dcec TPA__TFFeRq_4Bond17EventProducerType_S_S0_10observeNewuRq_S0__Fq_FFqq_S0_9EventTypeT_PS_14DisposableType_U_FQQPS0_9EventTypeT + 156\n    12  Bond                                0x000000010522d7b8 _TTRGrXFo_iq__dT__XFo_iq__iT + 24\n    13  Bond                                0x000000010522d3e1 _TPA__TTRGrXFo_iq__dT__XFo_iq__iT__ + 97\n    14  Bond                                0x000000010522d794 _TTRGrXFo_iq__iT__XFo_iq__dT__ + 36\n    15  Bond                                0x000000010522b952 _TFC4Bond13EventProducerP33_E3AABF94B17DA8055EE44FE13449BAE812dispatchNexturfGS0_q__Fq_T + 786\n    16  Bond                                0x000000010522b063 TFC4Bond13EventProducer4nexturfGS0_q__Fq_T + 563\n    17  Bond                                0x0000000105240f8e TFC4Bond15ObservableArray19performBatchUpdatesurfGS0_q__FFGS0_q__T_T + 1102\n    18  MyApp                               0x00000001034d4ef8 TFFC11MyApp21SRMyMembersModel12mergeMembersFS0_FGSaV15SRSharedDataKit6SRUser_T_U_FT_T + 120\n    19  Async                               0x00000001052133e7 _TTRXFo__dT__XFdCb__dT__ + 39\n    20  libdispatch.dylib                   0x000000010b33349b _dispatch_client_callout + 8\n    21  libdispatch.dylib                   0x000000010b3155e7 _dispatch_block_invoke + 716\n    22  Async                               0x0000000105213403 _TTRXFdCb__dT__XFo__dT__ + 19\n    23  Async                               0x0000000105213431 _TTRXFo__dT__XFo_iT__iT__ + 17\n    24  Async                               0x00000001052133b1 _TPA__TTRXFo__dT__XFo_iT__iT__111 + 81\n    25  Async                               0x0000000105213460 _TTRXFo_iT__iT__XFo__dT__ + 32\n    26  Async                               0x00000001052133e7 _TTRXFo__dT__XFdCb__dT__ + 39\n    27  libdispatch.dylib                   0x000000010b312ef9 _dispatch_call_block_and_release + 12\n    28  libdispatch.dylib                   0x000000010b33349b _dispatch_client_callout + 8\n    29  libdispatch.dylib                   0x000000010b31b34b _dispatch_main_queue_callback_4CF + 1738\n    30  CoreFoundation                      0x000000010a3b43e9 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE + 9\n    31  CoreFoundation                      0x000000010a375939 __CFRunLoopRun + 2073\n    32  CoreFoundation                      0x000000010a374e98 CFRunLoopRunSpecific + 488\n    33  GraphicsServices                    0x000000010c401ad2 GSEventRunModal + 161\n    34  UIKit                               0x0000000107d46676 UIApplicationMain + 171\n    35  MyApp                               0x00000001038e8a7d main + 109\n    36  libdyld.dylib                       0x000000010b36892d start + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n. @ivanmoskalev the merge function is in my 2nd post (named mergeMembers).\nMaybe it's a race condition indeed, but don't know really why.\nI've build a small app to reproduce the issue, but it's too simple and it works fine... I will try to add step by step the complexity of my real app to figure out where the problem can be.\nKeep you posted.\n. Sorry I was a bit busy these days and had not much time to dig my issue.\nAnyway, I found the root of my problem (and the solution :)) and think my problem was a little bit different than @whateverx.\nMy problem occurred when I was changing view controllers quickly, and my assumption is that my collection view or cells were not deallocating correctly (haven't found why yet), but the view model was deallocated.\nSo when I was going back to my page, the perform batch operations was asking to insert new elements to my collection view, assuming it had no elements in it, but my collection view had retained old elements from previous loading... I'm not 100% sure but think that was the reason\nI manage to fix that by reseting the array when I initialize my view model instead of doing batch operations, and then performing batch operations when I update my view model.\nHope it helps... \n. ",
    "tempire": "Any updates on this?\n. ",
    "sohooo": "Interested as well if there's a chance CoreData/Realm will be supported.\n. ",
    "damianesteban": "Concerning integration with Realm, this library - RealmResultsController - takes an interesting approach.    I'm wondering if something like that could work with Bond.  Going to play around a bit with it tonight and tomorrow.\n. I wonder if this will be easier now that Realm finally has fine-grained notifications? \n. Nevermind, didn't see it.  Sorry about that.\n. ",
    "loganallenc": "I'm also interested in the possibility of CoreData support.\n. ",
    "MattNewberry": "+1\n. ",
    "okla": "Great, this diff method is right what I need. Found similar project, maybe it can help https://github.com/khanlou/NSArray-LongestCommonSubsequence\n. It turns out that the problem occurs when Whole Module Optimization turned on.\n. Sure. I'm on Xcode 7.0, OS X El Cap.\n. Turned WMO on again and now it found duplicate with FontAwesome..\nOutput:\nduplicate symbol __TTSg5O10AppName10ModelState___TFC10AppName13EventProducerP33_D6B553B696813232F95C039DE50201B312dispatchNexturfGS0_q__Fq_T_ in:\n    /Users/user/Library/Developer/Xcode/DerivedData/AppName-fpxzofbepdulhpdcemeqatauwvqq/Build/Intermediates/AppName.build/Debug-iphoneos/AppName.build/Objects-normal/armv7/FontAwesome.o\n    /Users/user/Library/Developer/Xcode/DerivedData/AppName-fpxzofbepdulhpdcemeqatauwvqq/Build/Intermediates/AppName.build/Debug-iphoneos/AppName.build/Objects-normal/armv7/EventProducer.o\nduplicate symbol __TTSg5SS___TFC10AppName13EventProducerP33_D6B553B696813232F95C039DE50201B312dispatchNexturfGS0_q__Fq_T_ in:\n    /Users/user/Library/Developer/Xcode/DerivedData/AppName-fpxzofbepdulhpdcemeqatauwvqq/Build/Intermediates/AppName.build/Debug-iphoneos/AppName.build/Objects-normal/armv7/FontAwesome.o\n    /Users/user/Library/Developer/Xcode/DerivedData/AppName-fpxzofbepdulhpdcemeqatauwvqq/Build/Intermediates/AppName.build/Debug-iphoneos/AppName.build/Objects-normal/armv7/EventProducer.o\nld: 2 duplicate symbols for architecture armv7\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. @srdanrasic got it, thanks!\n. Is it possible?\n. I saw some replayBuffer in source code.. isn't it for that?\n. ",
    "kevin-hirsch": "Hey @srdanrasic, is there any updates on this issue? :)\n. What I want to do here to have my model with a @property in Objective-C (e.g. name property) and be able to create an Observable for this property, so when the name property is changed, the Observable gets updated and triggers what it is bonded to (here a textField.bnd_text).\nAm I thinking about this the wrong way?\n. ",
    "kafejo": "+1\n. Maybe it would be worth to take a look at the previous version of Bond as @kevin-hirsch saying the feature was there.\n. Thank you. I use Bond for KVO binding between model and view model in MVVM architecture. For example:\n```\nclass Car: NSManagedObject {\n    var currentSpeed: NSNumber?\n}\nclass CarViewModel {\n   let model: Car\n   var disposeBag: [AnyObject]\n   private(set) lazy var currentSpeed: String = {\n       let currentSpeed = Observable(\"\") \n       let speed = Observable(object: self.model, keypath: \"currentSpeed\").map { \"($0) km/h\"}.bindTo(currentSpeed)\n       self.disposeBad.append(speed)\n       return currentSpeed\n   }() \n}\n```\nWhenever the model's current speed changes, the view model's currentSpeed gets update and the views which are bound with it as well\n. Because sometimes we don't need binding, only the value. For example in UITableViewCell when the table uses NSFetchedResultsController to update cells, binding is not necessary but rather overkill.\n. ",
    "AnthonyMDev": "+1 \nThis seems difficult to implement without creating a retain cycle though. If the name has a reference to the registered observer, the textField in this case, and the textField also has a reference to the name, then don't we have a retain cycle? How do we implement this without creating memory leaks?\n. @srdanrasic Thanks, I understood that it was due to Observable being a class. Making a struct wrapper around the class is a great idea. I feel that this would be a good addition to the core library. Is there any interest in including this, or should I just go ahead and make the struct in my own project?\n. Great. @srdanrasic Do you want to make a PR since you basically already wrote something in the above post? I haven't actually implemented this in my project yet, but I'd be happy to work on it if you don't!\n. @srdanrasic Has a beta been pushed to CocoaPods with this yet? The CocoaPods issues have been resolved.\n. It looks like you are using an IndexPath with only one index in your events. collectionView.insertItems(at: indexPaths) assumes this one index is the section.\n. So, I was able to fix this by changing kind on ObservableArray to return IndexPaths with a row and section.\nswift\n  public var kind: DataSourceEventKind {\n    switch change {\n    case .initial:\n      return .reload\n    case .inserts(let indices):\n        return .insertRows(indices.map({ IndexPath(row: $0, section: 0) }))\n    case .deletes(let indices):\n      return .deleteRows(indices.map({ IndexPath(row: $0, section: 0) }))\n    case .updates(let indices):\n      return .reloadRows(indices.map({ IndexPath(row: $0, section: 0) }))\n    case .move(let from, let to):\n        return .moveRow(IndexPath(row: from, section: 0), IndexPath(row: to, section: 0))\n    case .beginBatchEditing:\n      return .beginUpdates\n    case .endBatchEditing:\n      return .endUpdates\n    }\n  }\nI'm not sure if this breaks anything else, but it does fix this issue.\nHopefully we can get a fix for this sent out ASAP?\nThanks!\n. Thanks! It works perfectly.\n. I made PR #286 to fix this. If you don't want to solve this in the way that I did in the PR, then we can discuss other possible methods for making this fix.\n. Also, should we have a replace() function that does not have a performDiff parameter that is performable on a MutableObservableArray that does not conform to Equatable?\nI think that is an important piece of functionality. Can I make a separate PR for that ?\n. Thanks for the merge. I'll handle the other PR later this afternoon.\n. New PR for this other functionality has been made. #287. Thanks!\n. That's my fault! I'll fix this in the morning. Good catch!\n. Because I'm using them on a view model object. After editing the view model object, I need to be able to retrieve the values and use them to generate JSON for uploading objects to my REST API.\nI MAY be able to refactor that code to use Signal, but it would be awkward and would likely result in more weird boilerplate code.\nThe reason for this proposal is that I believe this would make the public API for the Property type more easily consumable. If the argument against it is, \"Well why would you need a Property instead of a Signal?\" then why do we even include the Property object in the library in the first place? Obviously there are situations where a Property is more convenient, or even necessary, so I don't see why we wouldn't want to make it as easy to use as Signal.\nI recognize and respect the desire to keep this library as lightweight as possible. However, from my team's personal experience, this is such a commonly used practice, that I feel it is worth including.\n. Understood.\nComments on your problems:\n1. I think that's just fine though. The property WOULD be retained as long as you want to access it. This doesn't seem to add any complexity to me.\n2. Sure, it does duplicate values. The issue here is that a property is being used when you want to be able to observe changes to the KVO but also want to be able to set the value. If I just want to observe the KVO, then the Signal is fine. If I want to be able to set the value from my view model also, then I need a Property. Using proper dependency inversion, my controllers don't know about my actual model object, just the view model via a protocol. To set the value on the observed object I currently am doing this:\nswift\nlet name = Property<String?>(nil)\nobject.valueFor(keyPath: \"name\").bind(to: name)\nname.observeNext { object.name = $0 }.disposeIn(bnd_bag)\nBeing able to create a Property from an RKKeyValueSignal would include the ability to set the value on the Property and bind to the KVO bi-directionally.\nThanks for your time as always @srdanrasic \n. I'm going to look into this either today or tomorrow and I'll let you know my comments. From the description in #290, it sounds like it will work wonderfully.\n. @srdanrasic This does a huge part of what I need. After starting to implement it, I realized that I also need the ability to transform the value from the RKKeyValueSignal to a different type. (ie. String to Int). I've created PR #306 to add this functionality. I hope that this PR works for you. Thanks!\n. Thanks! You know I'm always willing to make PRs but I'm not sure exactly how you want to tackle this one, so if you are already handling it that's great. \nAs always, thanks for all your hard work. \n. @srdanrasic I'd really love to see this implemented soon. I know you're probably super busy, but if you have the time to even discuss what for you are thinking these errors would take, I'd be happy to help with a PR for this and #288.\n. No apologies necessary at all! I know you're a busy guy and you work very hard to maintain this repository as quickly as possible. I just wanted to extend the offer of help again since I do need to get this for a release version ASAP.\nThese changes sound awesome! Thanks so much! That seems to fix #288, and it does fix the scenario where the object's deallocation was causing the fatalError. However, if the value fails to convert, will this still throw a fatalError? Have you added some other error handling for that, or did you decide to leave it as is?\nThanks again\n. Cool thanks for the info!\n. @srdanrasic I'm having trouble depending on the newest beta because it still uses a dependency on ReactiveKit beta-5. Can you release a new beta that uses ReactiveKit beta-6 please?\n. Thanks!\n. @srdanrasic This is still causing me issues when dealing with NSManagedObject. The deallocation handling is working fine for the object itself, but often times the NSManagedObjectContext is deallocated before the object and it faulting the key values to nil. I don't really feel like the best option is to crash when the value is non-convertible by default.\n. @srdanrasic Well, I still understand your original argument that making it failable makes it harder to work with. So, we could consider something else... \nWhat if, rather than crashing, no event was emitted if the value is not convertible?\n\nIf the KVO signal would be failable, it would not be bindable.\n\nI want to be able to handle errors here, but I also don't think that its a good thing to make it so that DynamicSubject is no longer bindable. Bindable in ReactiveKit works with SignalProtocol even if it has an error. Why are you saying that it wouldn't be bindable?\n. I saw that version 5.0.0 was released! Congrats! Did this not end up making the cut for this version?\n. @srdanrasic This looks good, however this is now causing me to be unable to use bidirectionalBind on a DynamicSubject. Is that intended behavior? Is there a way to work around that?\nThanks!\n. Never mind. I figured this out! Thanks so much!\n. Thanks for considering addressing this issue @srdanrasic. I'd like to give some input as well if that's alright.\nI agree that these bindings should be Property type instead of DynamicSubjects. Being able to manually set these properties and know that they will emit events when they are set is a valuable feature.\nAs for @connectdotz other point about the button state:\n\nOne could argue the button's background and title actually depend on the button's own state, not necessary the models affect the button, i.e. the \"truth\" is the button's own state. So it doesn't make much sense for the models to reach into the button's own background and title with binding...\n\nCouldn't this be solved by creating a new state or even a simple property on your view elements yourself? If you want one property that will change multiple properties on the button you can do this.\nswift\nlet buttonEnabledState: Property<Bool> =  {\n    let property = Property(true)\n    button.bnd_enabled.bind(to: property)\n    button.bnd_hidden.bind(to: property.map { !$0 })\n    return property\n}()\nThen you can bind your view model to the new property.\nswift\nviewModel.buttonEnabled.bind(to: button.buttonEnabledState)\nThe buttonEnabledState property can be added either in a custom subclass of UIButton or using an associated value on an extension on UIButton itself.\nWould this solve your problem @connectdotz or am I misunderstanding your point?\n. If you decide you don't want to include this function, would it be possible to make public the target, signal, getter, and setter on DynamicSubject. That way I can still include this functionality myself as an extension.\n. Actually if you look up about it's still wrapped in the lock.atomic.\nThe entire if performDiff { ... } else { ... } is wrapped in the `lock.atomic.\n. ",
    "hzahnlei": "Hello.\nThis is my first post here and I want to support this question.\nI have built a user registration screen.\nThe \"register user\" button gets enabled only if all required fields are filled out.\nWith Bond 3 I was just nesting several calls to reduce().\nAlternatively I created my own reduce() function that was built after Bond's reduce() but accepting more parameters.\nWith Bond 4 I have moved to combineLatest().\nAgain I built my own version of combineLatest() that accepts the number of parameters I desire.\nI did that by chaining combineLatest() with increasing arity, starting with four arguments, since Bond already provides combineLatest() with two and three arguments.\nHowever, I am not sure this is the right approach.\nEspecially given that the absolutely harmless mapping function caused an \"expression to complex to be solved in reasonable time\" error.\nAny help appreciated.\nThank you, great framework.\n. My use case is similar to Adam's in that all event producers potentially have a different type.\nI added my own combineLatest() functions in addition to Bond's:\n``` swift\npublic func combineLatest( a: A, _ b: B, _ c: C, _ d: D ) -> EventProducer<(A.EventType, B.EventType, C.EventType, D.EventType)> {\n    return combineLatest( a, b, c ).combineLatestWith( d ).map { ($0.0, $0.1, $0.2, $1) }\n}\npublic func combineLatest( a: A, _ b: B, _ c: C, _ d: D, _ e: E ) -> EventProducer<(A.EventType, B.EventType, C.EventType, D.EventType, E.EventType)> {\n    return combineLatest( a, b, c, d ).combineLatestWith( e ).map { ($0.0, $0.1, $0.2, $0.3, $1) }\n}\n.\n.\n.\npublic func combineLatest( a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H ) -> EventProducer<(A.EventType, B.EventType, C.EventType, D.EventType, E.EventType, F.EventType, G.EventType, H.EventType)> {\n    return combineLatest( a, b, c, d, e, f, g ).combineLatestWith( h ).map { ($0.0, $0.1, $0.2, $0.3, $0.4, $0.5, $0.6, $1) }\n}\n```\nOf course, this approach is not universal.\nYou cannot have an arbitray number of event producers.\nYou have to add another combineLatest() functions should you need 9 parameters instead of the 8 I am offering.\nFurthermore, the Swift compiler was complaining.\nIt issued an \"Expression to complex to be solved in reasonable time\" error when I was using my own method like this:\nswift\ncombineLatest( self.status, self.settings.userId, self.firstName, self.lastName, self.email, self.emailRepeated, self.password, self.repeatedPassword ).map {\n    status, userId, firstName, lastName, email, emailRepeated, password, passwordRepeated in\n       return\n            status == 0\n        &&  isValidUserId( userId )\n        &&  firstName != \"\" && lastName != \"\"\n        &&  isValidEmailAddress( email ) && emailRepeated == email\n        &&  isValidPassword( password ) && passwordRepeated == password\n} ->> self.registerAccountButtonEnabled\nHowever, everything works fine, when I use it like this:\nswift\ncombineLatest( self.status, self.settings.userId, self.firstName, self.lastName, self.email, self.emailRepeated, self.password, self.repeatedPassword ).map {\n    status, userId, firstName, lastName, email, emailRepeated, password, passwordRepeated in\n        let nameOK = firstName != \"\" && lastName != \"\"\n        let emailOK = isValidEmailAddress( email ) && emailRepeated == email\n        let passwordOK = isValidPassword( password ) && passwordRepeated == password\n        return\n            status == 0\n        &&  isValidUserId( userId )\n        &&  nameOK\n        &&  emailOK\n        &&  passwordOK\n} ->> self.registerAccountButtonEnabled\nThe strange thing is, that Swift 2.0 was complaining that the return expression was to complex.\nThis was no issue with Swift 1.2.\nActually, I would have been less surprised if my cascade of combineLatest() functions would have caused an error.\nThis is why I am not sure my approach is advisable.\nNevertheless, it seems to work fine.\nBreaking up the return statement seems to do the trick.\n. ",
    "aputinski": "The event producers would all be of different type. I was looking for something similar to this:\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/blob/swift2/ReactiveCocoa/Swift/Signal.swift#L1362\nI tried writing a something like:\nswift\n[a,b,c].reduce(a) { $0.combineLatestWith($1) }\nbut I couldn't get that to compile.\n. What would your recommendation be? Is a sequence the wrong way to approach the problem? I noticed that RAC has overloads for combineLatest that go up to 10 arguments.\n. ",
    "adamkuipers": "Closing to clean up my opened issues but let me know if you have any comments.\n. Yeah, I hadn't thought about how it would work with other methods. Thanks for the insight. \n. ",
    "kentwilliam": "Perfect, thank you!\n. ",
    "scisci": "Nevermind I guess I'm supposed to use observeNew, might be good to add that to the docs, didn't know about it.\n. Would it be possible to outline a migration guide from Bond to ReactiveKit?\n. ",
    "thomjordan": "I mistakenly referred above to \"binding each row separately\", which I realize now doesn't even make sense !   I've actually been using a datasource array for each individual column and binding them to the same delegate object, which can work in a specific arrangement as described below. \nThanks for the update, and sorry for the confusion. I had gotten it to work binding to each column\nseparately using the approach cited above, which surprised me, so after\nhearing back from you I went back and double checked everything. It turns\nout that (as far as I can tell) it does work binding each column to the same\ndelegate instance, as long as there is a separately defined datasource for\neach column, while any column-specific functionality is isolated within the\ncreateCell() method. I made some minor changes to the\n\"NSTableView+Bond.swift\" file, to add a new column parameter to\ncreateCell() for this purpose. When it came time to do the actual binding\nthough, I was stumped, because I had a separate datasource for each column,\nand realized that I would have to bind multiple datasources to the same\ndelegate instance. I was about to give up then when I tried it anyways, and\nsurprisingly it worked.  This approach is quite brittle though, since it\nonly seems to work correctly if the datasource, tableView & delegate\ncomponents are instantiated in a particular order. I want to do a backtrace\nlater to see if this is indeed the case.  I spent most of the day yesterday\ntrying to refactor my code into a better design three separate times,\nincluding using one datasource that hosts model objects with a field for\neach column, and in each case the tableView showed unpredictable behavior\nimmediately when adding rows and the changing the content of the datasource\nrows programmatically. After reading your response then it makes more sense\nto me now why nothing was working for me yesterday.\nThe good news is that I just rigorously rechecked the behavior of the\ntableView in the particular arrangement that seems to be working for me,\nchanging content for multiple rows and columns of the datasource within\nboth single and separate code blocks, and also manually changing various\ncell content in the view, and everything is working as expected. I'm only\nusing the .Update case of the ObservableArray operations, so I'm not sure\nif that is a special case or not.  I have no experience with unit testing,\nand this looks like a good time to change that. If I can put together a\ncorrect test case in my spare time over the next few days, as soon as I\nknow one way or another, I'll report back with the relevant info. If I can\nconfirm that this implementation does indeed work correctly, and if a\nparticular instantiation sequence contributes to that, I'll include a more\ncomplete example that can be reproduced.\nBest,\nThom\nOn Wed, Oct 21, 2015 at 3:18 PM, Sr\u0111an Ra\u0161i\u0107 notifications@github.com\nwrote:\n\nHi @thomjordan https://github.com/thomjordan,\nOnly one data source can be bound to a table view. In your example, only\nrow_4_datasource would end up being bound to table view. That might work,\nbut if content of other datasources (1-3) changes, those changes would not\nbe propagated the the table view.\nIt might be the best not to use NSTableView bindings if you have multiple\ncolumns for now. Just setup delegate and data source manually.\nI'll see if this can be improved in future.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/SwiftBond/Bond/issues/182#issuecomment-149998625.\n. I'm also comparing Strings instead of objects so this might only work with value types.\n. I mistakenly wrote \"row\" instead of column in the first code example above, and then unconsciously propagated that error in my subsequent comments.  I just went back and updated both comments with the correct info.  The multi-column NSTableView I've been using is working well with a separate datasource for each column.  Sorry for the mixup !\n. Good to hear !  \n\nHave you seen ReactiveKit yet?  It's Srdan's successor to Bond I think. Some of the intro docs explains some of the difference between the two. I've been using that now for a few weeks and have been seeing great results.  The Cocoa version of TableView doesn't address separate columns yet. It probably could be altered in a similar way to Bond. The code for it in ReactiveKit looks very similar. \n. Here's the explanation of why a new framework was needed.\n. ",
    "lambdaupb": "This worked for me as well.\nSupport for multiple Columns in a TableView is kind of essential :)\n. Hm, looks a lot nicer, especially the ObservableCollections. But I cant find any Cocoa View extensions for OSX yet.\n. Thanks for taking the time to answer.\nObservable<NSDate> of course :) error while typing this up.\nThis is pretty much what I ended up doing.\n.map({(date) -> String in  cell.textField!.formatter?.stringForObjectValue(date))!}).bindTo(cell.textField!.bnd_text)\n(I'm not sure anymore if that worked out)\nInside a TableViewDelegate.\nThe thing is:\nThe TextField owns a DateFormatter (which might be changed in the NIB or by the system or whatever) and applies it by itself when using the NSTextField.setObject(NSDate) setter.\nThats why a Sink-Only binding target for .setObject() might be useful.\n. ",
    "manas-chaudhari": "The event can be reduced to a pair of values with previous and the current value.\n```\nlet e = EventProducer()\nlet pairs = e.reduce((nil, nil)) { (pair, new) -> (Int?, Int?) in\n    return (pair.1, new)\n}\npairs.observe { old, new in\n    // Do your thing\n}\n```\nThis can be generalised using generics.\nOnly problem I see: new becomes an optional.\n. Thanks @srdanrasic. This is more simple and generic. I was unnecessarily trying to reuse the available merge function. Will update the pull request.\n. @srdanrasic Have updated the implementation as per our discussion\n. I referred these links:\n- http://reactivex.io/documentation/operators/merge.html\n- http://reactivex.io/documentation/operators/combinelatest.html\nHere's my understanding:\n- Combine transforms the multiple values from different signals into a single value. The transform is must for combining into a single value. In case of SwiftBond, I see that the transform function has been omitted  and we always use combining into a tuple as the transform.\n- Merge requires that values be of same type and it simply merges them.\nEquivalent methods in RxJava:\n- CombineLatest\n- Merge\nBased on these, I think merge fits better. @srdanrasic: Let me know what you think \n. I am facing a similar issue with EventProducer. Another struct/class can be created for EventProducer.\nI feel that outputs of rx operators like map, filter, combine should be immutable event producers as they are like derived properties. Only the source where an EventProducer/Observable is constructed should have access to next/value. \n@srdanrasic: What do you think?\n. @srdanrasic I am failing to understand how this is solving the problem. Please explain.\nHere's what I tried:\n```\nclass ViewModel {\n    private(set) var readOnlyVariable: MutableObservable = MutableObservable(\"inner\")\ninit() {\n    readOnlyVariable.observe(on: ImmediateExecutionContext) { (e) -> () in\n        print(e) // Prints 'value from outside'\n    }\n}\n\n}\nViewModel().readOnlyVariable.value = \"value from outside\"\n```\nI am able to change the value of the observable from outside the class.\nIf I use let, then it cannot be modified. But then, it cannot be modified from inside also.\nP.S. I tried this in ReactiveKit's playground\n. I tried with separate files and it works.\nThanks. \n. @srdanrasic I would love to contribute. Where can I find the roadmap/TODOs? \nAlso, I think it would be a good idea to document the shortcomings that you have realised in SwiftBond, and how you have/will overcome them in ReactiveKit.\n. You can bind an EventProducer to your observable.\nlet ob1 = Observable<String>(\"aaa\")\nlet ob2 = Observable<Int>(1)\nob1.map { $0.characters.count }.bindTo(obj2)\nMay I know what's the use case for this? Do you intend to modify obj2 via some other source?\n. Okay. \nI am curious. Why not keep EventProducer in the view model instead?\n. ",
    "Danappelxx": ":+1: I'm all for it\n. :+1: \n. ",
    "ramirez": "This means that if I need ObservableCollections, which seems it should naturally be a part of bond, I need to buy the whole heavy weight of ReactiveKit, including the promises kit (AKA Operations). Sad.\n. Hmm... Ok. I'll try it. I'm also happy to contribute, if needed.\nL.\n. ",
    "frogcjn": "the Element type alias in BindableType should be renamed, or it will be conflicted with ArrayLiteralType if the ObservableArray conforms to ArrayLiteralConvertible\n``` swift\npublic protocol BindableType {\n  typealias BindableTypeElement\n/// Returns a sink that can be used to dispatch events to the receiver.\n  /// Can accept a disposable that will be disposed on receiver's deinit.\n  func sink(disconnectDisposable: DisposableType?) -> (BindableTypeElement -> ())\n}\n```\nAnd also the subscript in ObservableArray should be write-enabled.\nswift\n    public subscript (bounds: Range<Int>) -> ArraySlice<ElementType> {\n        get {\n            return array[bounds]\n        }\n        set {\n            applyOperation(ObservableArrayOperation.Remove(range: bounds))\n            applyOperation(ObservableArrayOperation.Insert(elements: Array(newValue), fromIndex: bounds.startIndex))\n        }\n    }\nwith these modifications, the ObservableArray class can be similar to Array\n```\nextension ObservableArray : RangeReplaceableCollectionType{\n    public convenience init(){\n        self.init([] as [ElementType])\n    }\npublic func replaceRange<C : CollectionType where C.Generator.Element == Generator.Element>(subRange: Range<Int>, with newElements: C) {\n    replaceRange(subRange, with: Array(newElements))\n}\n\n}\nextension ObservableArray : MutableSliceable {\n}\nextension ObservableArray : ArrayLiteralConvertible {\n    public convenience init(arrayLiteral elements: ElementType ...){\n        self.init(elements)\n    }\n}\n```\n. Which version is compatible with Swift 2.3 and which version is compatible with Swift 3?\n. ",
    "codecov-io": "Current coverage is 69.91%\n\nMerging #203 into master will increase coverage by +2.11% as of 23df21b\n\ndiff\n@@            master    #203   diff @@\n======================================\n  Files           38      38       \n  Stmts         1848    1848       \n  Branches         0       0       \n  Methods          0               \n======================================\n+ Hit           1253    1292    +39\n  Partial          0       0       \n+ Missed         595     556    -39\n\nReview entire Coverage Diff as of 23df21b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 67.96%\nMerging #205 into master will increase coverage by +0.16% as of 2231ea0\n\ndiff\n@@            master    #205   diff @@\n======================================\n  Files           38      39     +1\n  Stmts         1848    1879    +31\n  Branches         0       0       \n  Methods          0               \n======================================\n+ Hit           1253    1277    +24\n  Partial          0       0       \n- Missed         595     602     +7\n\nReview entire Coverage Diff as of 2231ea0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 67.80%\nMerging #208 into master will not affect coverage as of cd07a65\n\ndiff\n@@            master   #208   diff @@\n=====================================\n  Files           38     38       \n  Stmts         1848   1848       \n  Branches         0      0       \n  Methods          0              \n=====================================\n  Hit           1253   1253       \n  Partial          0      0       \n  Missed         595    595\n\nReview entire Coverage Diff as of cd07a65\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 67.61%\nMerging #210 into master will decrease coverage by -0.19% as of fcd64c4\n\ndiff\n@@            master    #210   diff @@\n======================================\n  Files           38      38       \n  Stmts         1848    1862    +14\n  Branches         0       0       \n  Methods          0               \n======================================\n+ Hit           1253    1259     +6\n  Partial          0       0       \n- Missed         595     603     +8\n\nReview entire Coverage Diff as of fcd64c4\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 67.74%\nMerging #211 into master will decrease coverage by -0.06% as of 5d38d80\n\ndiff\n@@            master    #211   diff @@\n======================================\n  Files           38      38       \n  Stmts         1848    1851     +3\n  Branches         0       0       \n  Methods          0               \n======================================\n+ Hit           1253    1254     +1\n  Partial          0       0       \n- Missed         595     597     +2\n\nReview entire Coverage Diff as of 5d38d80\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 69.45%\nMerging #218 into master will increase coverage by +1.93% as of de10eb3\n\ndiff\n@@            master    #218   diff @@\n======================================\n  Files           38      48    +10\n  Stmts         1860    1565   -295\n  Branches         0       0       \n  Methods                          \n======================================\n- Hit           1256    1087   -169\n  Partial          0       0       \n+ Missed         604     478   -126\n\nReview entire Coverage Diff as of de10eb3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 61.06%\nMerging #221 into master will decrease coverage by -6.46% as of 7aea0fb\n\ndiff\n@@            master    #221   diff @@\n======================================\n  Files           38      48    +10\n  Stmts         1860    1564   -296\n  Branches         0       0       \n  Methods                          \n======================================\n- Hit           1256     955   -301\n  Partial          0       0       \n- Missed         604     609     +5\n\nReview entire Coverage Diff as of 7aea0fb\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 61.06%\nMerging #222 into master will decrease coverage by -6.46% as of e52e5ae\n\ndiff\n@@            master    #222   diff @@\n======================================\n  Files           38      48    +10\n  Stmts         1860    1564   -296\n  Branches         0       0       \n  Methods                          \n======================================\n- Hit           1256     955   -301\n  Partial          0       0       \n- Missed         604     609     +5\n\nReview entire Coverage Diff as of e52e5ae\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #223 into master will decrease coverage by -6.63% as of 7acc3f3\n\ndiff\n@@            master    #223   diff @@\n======================================\n  Files           38      48    +10\n  Stmts         1860    1565   -295\n  Branches         0       0       \n  Methods                          \n======================================\n- Hit           1256     953   -303\n  Partial          0       0       \n- Missed         604     612     +8\n\nReview entire Coverage Diff as of 7acc3f3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #226 into master will not affect coverage as of 1c6d578\n\ndiff\n@@            master    #226   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1565       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 1c6d578\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 61.09%\nMerging #227 into master will increase coverage by +0.20% as of 159af75\n\ndiff\n@@            master    #227   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1573     +8\n  Branches         0       0       \n  Methods                          \n======================================\n+ Hit            953     961     +8\n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 159af75\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #229 into master will not affect coverage as of 841196c\n\ndiff\n@@            master    #229   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1565       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 841196c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.81%\nMerging #232 into master will decrease coverage by -0.08% as of cb342f4\n\ndiff\n@@            master    #232   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1567     +2\n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n- Missed         612     614     +2\n\nReview entire Coverage Diff as of cb342f4\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #235 into master will not affect coverage as of 9dcd04a\n\ndiff\n@@            master    #235   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1565       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 9dcd04a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #238 into master will not affect coverage as of 5e6cfb5\n\ndiff\n@@            master    #238   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1565       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 5e6cfb5\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #240 into master will not affect coverage as of 406fb5d\n\ndiff\n@@            master    #240   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1565       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 406fb5d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 60.89%\nMerging #243 into master will not affect coverage as of 406fb5d\n\ndiff\n@@            master    #243   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1565       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            953     953       \n  Partial          0       0       \n  Missed         612     612\n\nReview entire Coverage Diff as of 406fb5d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 40.74%\nMerging #244 into master will decrease coverage by -20.15% as of 29d1698\n\ndiff\n@@            master    #244   diff @@\n======================================\n  Files           48      48       \n  Stmts         1565    1566     +1\n  Branches         0       0       \n  Methods                          \n======================================\n- Hit            953     638   -315\n  Partial          0       0       \n- Missed         612     928   +316\n\nReview entire Coverage Diff as of 29d1698\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 40.74%\nMerging #250 into master will not change coverage\n\ndiff\n@@           master    #250   diff @@\n=====================================\n  Files          48      48          \n  Lines        1566    1566          \n  Methods         0       0          \n  Branches        0       0          \n=====================================\n  Hits          638     638          \n  Misses        928     928          \n  Partials        0       0\n\nPowered by Codecov. Last updated by 731eefc...d40f16c\n. ## Current coverage is 40.50%\nMerging #251 into master will decrease coverage by -0.24% as of 15fa590\n\ndiff\n@@            master   #251   diff @@\n=====================================\n  Files           48     48       \n  Stmts         1566   1575     +9\n  Branches         0      0       \n  Methods                         \n=====================================\n  Hit            638    638       \n  Partial          0      0       \n- Missed         928    937     +9\n\nReview entire Coverage Diff as of 15fa590\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 40.66%\nMerging #252 into master will decrease coverage by -0.08% as of 0e2d609\n\ndiff\n@@            master    #252   diff @@\n======================================\n  Files           48      48       \n  Stmts         1566    1569     +3\n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            638     638       \n  Partial          0       0       \n- Missed         928     931     +3\n\nReview entire Coverage Diff as of 0e2d609\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 40.74%\nMerging #253 into master will not affect coverage as of 17773e0\n\ndiff\n@@            master    #253   diff @@\n======================================\n  Files           48      48       \n  Stmts         1566    1566       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            638     638       \n  Partial          0       0       \n  Missed         928     928\n\nReview entire Coverage Diff as of 17773e0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 67.54%\nMerging #254 into master will increase coverage by +26.80% as of 3d48196\n\ndiff\n@@            master    #254   diff @@\n======================================\n  Files           48      38    -10\n  Stmts         1566    1855   +289\n  Branches         0       0       \n  Methods                          \n======================================\n+ Hit            638    1253   +615\n  Partial          0       0       \n+ Missed         928     602   -326\n\nReview entire Coverage Diff as of 3d48196\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 40.74%\nMerging #255 into master will not affect coverage as of 16512c3\n\ndiff\n@@            master    #255   diff @@\n======================================\n  Files           48      48       \n  Stmts         1566    1566       \n  Branches         0       0       \n  Methods                          \n======================================\n  Hit            638     638       \n  Partial          0       0       \n  Missed         928     928\n\nReview entire Coverage Diff as of 16512c3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 40.74%\nMerging #261 into master will not change coverage\n\ndiff\n@@             master       #261   diff @@\n==========================================\n  Files            48         48          \n  Lines          1566       1566          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits            638        638          \n  Misses          928        928          \n  Partials          0          0\n\nPowered by Codecov. Last updated by d6fd4ad...72a8be5\n. ## Current coverage is 36.45%\nMerging #265 into master will decrease coverage by 0.20%\n\ndiff\n@@             master       #265   diff @@\n==========================================\n  Files            38         38          \n  Lines          1432       1432          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n- Hits            525        522     -3   \n- Misses          907        910     +3   \n  Partials          0          0\n\nPowered by Codecov. Last updated by 234ddf3...c836fb6\n. ## Current coverage is 36.55% (diff: 100%)\nMerging #268 into master will not change coverage\n\ndiff\n@@             master       #268   diff @@\n==========================================\n  Files            38         38          \n  Lines          1428       1428          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits            522        522          \n  Misses          906        906          \n  Partials          0          0\n\nPowered by Codecov. Last update 3754de4...4b0734f\n. ## Current coverage is 36.55% (diff: 0.00%)\nMerging #274 into master will not change coverage\n\ndiff\n@@             master       #274   diff @@\n==========================================\n  Files            38         38          \n  Lines          1428       1428          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits            522        522          \n  Misses          906        906          \n  Partials          0          0\n\nPowered by Codecov. Last update 46518e1...d92205a\n. ## Current coverage is 36.50% (diff: 0.00%)\nMerging #275 into master will decrease coverage by 0.05%\n\ndiff\n@@             master       #275   diff @@\n==========================================\n  Files            38         38          \n  Lines          1428       1430     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits            522        522          \n- Misses          906        908     +2   \n  Partials          0          0\n\nPowered by Codecov. Last update 46518e1...aea9b86\n. ## Current coverage is 61.33% (diff: 0.00%)\nNo coverage report found for master at 1200a00.\nPowered by Codecov. Last update 1200a00...f89a56e\n. ## Current coverage is 61.33% (diff: 100%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...9c1b416\n. ## Current coverage is 61.33% (diff: 33.33%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...1a9f01e\n. ## Current coverage is 61.04% (diff: 0.00%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...9e5a25f\n. ## Current coverage is 61.33% (diff: 0.00%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...7b5f16c\n. ## Current coverage is 61.33% (diff: 20.00%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...b7d6923\n. ## Current coverage is 61.33% (diff: 100%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...0c07800\n. ## Current coverage is 61.91% (diff: 64.28%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...2d850d7\n. ## Current coverage is 62.10% (diff: 72.72%)\nNo coverage report found for master at 9ac8d86.\nPowered by Codecov. Last update 9ac8d86...78fbeb7\n. ## Current coverage is 60.64% (diff: 0.00%)\nNo coverage report found for master at 95f4f89.\nPowered by Codecov. Last update 95f4f89...bf6e637\n. ## Current coverage is 60.61% (diff: 100%)\nNo coverage report found for master at 37ee618.\nPowered by Codecov. Last update 37ee618...36a4105\n. ## Current coverage is 60.61% (diff: 100%)\nNo coverage report found for master at ccbe0c1.\nPowered by Codecov. Last update ccbe0c1...eea8052\n. ## Current coverage is 67.80% (diff: 100%)\nNo coverage report found for master at 6bfa47b.\nPowered by Codecov. Last update 6bfa47b...143b53b\n. ## Current coverage is 68.10% (diff: 0.00%)\nNo coverage report found for master at 4516eaa.\nPowered by Codecov. Last update 4516eaa...4d04e09. ## Current coverage is 69.25% (diff: 0.00%)\nNo coverage report found for master at 984ca8a.\nPowered by Codecov. Last update 984ca8a...f6a41f3. ## Current coverage is 69.97% (diff: 89.39%)\nMerging #351 into master will increase coverage by 1.27%\n\ndiff\n@@             master       #351   diff @@\n==========================================\n  Files            49         50     +1   \n  Lines          2259       2325    +66   \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n+ Hits           1552       1627    +75   \n+ Misses          707        698     -9   \n  Partials          0          0\n\nPowered by Codecov. Last update 3f013a7...9cc4c5f. ## Current coverage is 68.70% (diff: 100%)\nMerging #354 into master will not change coverage\n\ndiff\n@@             master       #354   diff @@\n==========================================\n  Files            49         49          \n  Lines          2259       2259          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1552       1552          \n  Misses          707        707          \n  Partials          0          0\n\nPowered by Codecov. Last update 3f013a7...bf9d59c. ## Current coverage is 68.64% (diff: 100%)\nMerging #356 into master will increase coverage by 0.18%\n\ndiff\n@@             master       #356   diff @@\n==========================================\n  Files            49         49          \n  Lines          2267       2261     -6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1552       1552          \n+ Misses          715        709     -6   \n  Partials          0          0\n\nPowered by Codecov. Last update 0418444...7d6174c. ## Current coverage is 68.46% (diff: 100%)\nMerging #357 into master will not change coverage\n\ndiff\n@@             master       #357   diff @@\n==========================================\n  Files            49         49          \n  Lines          2267       2267          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1552       1552          \n  Misses          715        715          \n  Partials          0          0\n\nPowered by Codecov. Last update 0418444...b41d9b4. ## Current coverage is 68.46% (diff: 100%)\nMerging #358 into master will not change coverage\n\ndiff\n@@             master       #358   diff @@\n==========================================\n  Files            49         49          \n  Lines          2267       2267          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1552       1552          \n  Misses          715        715          \n  Partials          0          0\n\nPowered by Codecov. Last update 1733659...3ea6559. ## Current coverage is 70.09% (diff: 88.96%)\nMerging #363 into master will increase coverage by 1.72%\n\ndiff\n@@             master       #363   diff @@\n==========================================\n  Files            49         50     +1   \n  Lines          2270       2414   +144   \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n+ Hits           1552       1692   +140   \n- Misses          718        722     +4   \n  Partials          0          0\n\nPowered by Codecov. Last update cab59d0...9a761db. ## Current coverage is 68.37% (diff: 100%)\nMerging #365 into master will not change coverage\n\ndiff\n@@             master       #365   diff @@\n==========================================\n  Files            49         49          \n  Lines          2270       2270          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1552       1552          \n  Misses          718        718          \n  Partials          0          0\n\nPowered by Codecov. Last update cab59d0...9f095fa. ## Current coverage is 71.28% (diff: 100%)\nMerging #367 into master will not change coverage\n\ndiff\n@@             master       #367   diff @@\n==========================================\n  Files            51         51          \n  Lines          2476       2476          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1765       1765          \n  Misses          711        711          \n  Partials          0          0\n\nPowered by Codecov. Last update 3dadbe0...59340fb. ## Current coverage is 71.28% (diff: 100%)\nMerging #368 into master will not change coverage\n\ndiff\n@@             master       #368   diff @@\n==========================================\n  Files            51         51          \n  Lines          2476       2476          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1765       1765          \n  Misses          711        711          \n  Partials          0          0\n\nPowered by Codecov. Last update 3dadbe0...68ce896. ## Current coverage is 71.28% (diff: 100%)\nMerging #369 into master will not change coverage\n\ndiff\n@@             master       #369   diff @@\n==========================================\n  Files            51         51          \n  Lines          2476       2476          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1765       1765          \n  Misses          711        711          \n  Partials          0          0\n\nPowered by Codecov. Last update 3dadbe0...d1b88fd. ## Current coverage is 71.11% (diff: 0.00%)\nNo coverage report found for master at 71410be.\nPowered by Codecov. Last update 71410be...75c09f1. ## Current coverage is 71.11% (diff: 100%)\nMerging #373 into master will not change coverage\n\ndiff\n@@             master       #373   diff @@\n==========================================\n  Files            52         52          \n  Lines          2482       2482          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1765       1765          \n  Misses          717        717          \n  Partials          0          0\n\nPowered by Codecov. Last update 41d3b4c...704d6a1. ## Current coverage is 71.11% (diff: 100%)\nMerging #374 into master will not change coverage\n\ndiff\n@@             master       #374   diff @@\n==========================================\n  Files            52         52          \n  Lines          2482       2482          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1765       1765          \n  Misses          717        717          \n  Partials          0          0\n\nPowered by Codecov. Last update 884945b...08555d9. # Codecov Report\nMerging #383 into master will not change coverage.\nThe diff coverage is 50%.\n\n```diff\n@@          Coverage Diff           @@\nmaster    #383   +/-\n======================================\n  Coverage    77.7%   77.7%         \n======================================\n  Files          52      52         \n  Lines        3153    3153         \n======================================\n  Hits         2450    2450         \n  Misses        703     703\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Shared/NSObject.swift | 73.33% <\u00f8> (\u00f8) | :white_check_mark: |\n| Sources/Shared/NSObject+KVO.swift | 89.72% <50%> (\u00f8) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update dd1fa26...d8e8010. Read the comment docs.. # Codecov Report\nMerging #386 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@           Coverage Diff           @@\nmaster     #386   +/-\n=======================================\n  Coverage   77.13%   77.13%         \n=======================================\n  Files          51       51         \n  Lines        3167     3167         \n=======================================\n  Hits         2443     2443         \n  Misses        724      724\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 06d6b4f...525a491. Read the comment docs.. # Codecov Report\nMerging #387 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@           Coverage Diff           @@\nmaster     #387   +/-\n=======================================\n  Coverage   77.13%   77.13%         \n=======================================\n  Files          51       51         \n  Lines        3167     3167         \n=======================================\n  Hits         2443     2443         \n  Misses        724      724\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 06d6b4f...44c0ce8. Read the comment docs.. # Codecov Report\nMerging #388 into master will not change coverage.\nThe diff coverage is 50%.\n\n```diff\n@@           Coverage Diff           @@\nmaster     #388   +/-\n=======================================\n  Coverage   77.13%   77.13%         \n=======================================\n  Files          51       51         \n  Lines        3167     3167         \n=======================================\n  Hits         2443     2443         \n  Misses        724      724\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Collections/ObservableDictionary.swift | 0% <\u00f8> (\u00f8) | :white_check_mark: |\n| Sources/Collections/ObservableSet.swift | 32.92% <100%> (\u00f8) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5bad00b...eeee1b2. Read the comment docs.. # Codecov Report\nMerging #399 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@           Coverage Diff           @@\nmaster     #399   +/-\n=======================================\n  Coverage   77.28%   77.28%         \n=======================================\n  Files          51       51         \n  Lines        3152     3152         \n=======================================\n  Hits         2436     2436         \n  Misses        716      716\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update aa9458a...ac93409. Read the comment docs.. # Codecov Report\nMerging #405 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #405   +/-\n=======================================\n  Coverage   77.25%   77.25%         \n=======================================\n  Files          51       51         \n  Lines        3174     3174         \n=======================================\n  Hits         2452     2452         \n  Misses        722      722\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9b5ce42...203b88d. Read the comment docs.. # Codecov Report\nMerging #408 into master will decrease coverage by 15.32%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster     #408       +/-\n===========================================\n- Coverage   77.25%   61.92%   -15.33%   \n===========================================\n  Files          51       51             \n  Lines        3174     4418     +1244   \n===========================================\n+ Hits         2452     2736      +284   \n- Misses        722     1682      +960\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Tests/BondTests/UICollectionViewTests.swift | 84.05% <\u00f8> (\u00f8) | |\n| Sources/Bond/UIKit/UIRefreshControl.swift | 100% <\u00f8> (\u00f8) | |\n| Sources/Bond/UIKit/UIImageView.swift | 100% <\u00f8> (\u00f8) | |\n| Tests/BondTests/UIKitTests.swift | 100% <\u00f8> (\u00f8) | |\n| Tests/BondTests/Helpers.swift | 75.22% <\u00f8> (\u00f8) | |\n| Sources/Bond/Shared/SignalProtocol.swift | 13.54% <\u00f8> (\u00f8) | |\n| Sources/Bond/QueryableDataSource.swift | 0% <\u00f8> (\u00f8) | |\n| Sources/Bond/UIKit/UISegmentedControl.swift | 100% <\u00f8> (\u00f8) | |\n| Sources/Bond/UIKit/UIDatePicker.swift | 100% <\u00f8> (\u00f8) | |\n| Tests/BondTests/NSObjectTests.swift | 100% <\u00f8> (\u00f8) | |\n| ... and 42 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1e42e4c...5d3ec67. Read the comment docs.. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (master@050244a). Click here to learn what that means.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster     #436   +/-\n=========================================\n  Coverage          ?   60.53%         \n=========================================\n  Files             ?       51         \n  Lines             ?     4614         \n  Branches          ?        0         \n=========================================\n  Hits              ?     2793         \n  Misses            ?     1821         \n  Partials          ?        0\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 050244a...a697018. Read the comment docs.\n. # Codecov Report\nMerging #442 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #442   +/-\n=======================================\n  Coverage   60.46%   60.46%         \n=======================================\n  Files          52       52         \n  Lines        4619     4619         \n=======================================\n  Hits         2793     2793         \n  Misses       1826     1826\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 06cc0b2...d2feda2. Read the comment docs.\n. # Codecov Report\nMerging #452 into master will not change coverage.\nThe diff coverage is 0%.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #452   +/-\n======================================\n  Coverage    60.4%   60.4%         \n======================================\n  Files          52      52         \n  Lines        4624    4624         \n======================================\n  Hits         2793    2793         \n  Misses       1831    1831\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Bond/Shared/NSObject+KVO.swift | 88.75% <0%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5f8a235...c864e43. Read the comment docs.\n. # Codecov Report\nMerging #455 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #455   +/-\n======================================\n  Coverage    60.4%   60.4%         \n======================================\n  Files          52      52         \n  Lines        4624    4624         \n======================================\n  Hits         2793    2793         \n  Misses       1831    1831\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5f8a235...912ae23. Read the comment docs.\n. # Codecov Report\nMerging #463 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #463   +/-\n=======================================\n  Coverage   60.31%   60.31%         \n=======================================\n  Files          53       53         \n  Lines        4631     4631         \n=======================================\n  Hits         2793     2793         \n  Misses       1838     1838\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1c0bf5b...8830260. Read the comment docs.\n. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (master@66e74b7). Click here to learn what that means.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster     #478   +/-\n=========================================\n  Coverage          ?   59.96%         \n=========================================\n  Files             ?       52         \n  Lines             ?     4571         \n  Branches          ?        0         \n=========================================\n  Hits              ?     2741         \n  Misses            ?     1830         \n  Partials          ?        0\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Tests/BondTests/ProtocolProxyTests.swift | 95.55% <100%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 66e74b7...7f03989. Read the comment docs.\n. # Codecov Report\nMerging #482 into master will decrease coverage by 0.69%.\nThe diff coverage is 0%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster     #482     +/-\n=========================================\n- Coverage   59.16%   58.47%   -0.7%   \n=========================================\n  Files          53       53           \n  Lines        4643     4698     +55   \n=========================================\n  Hits         2747     2747           \n- Misses       1896     1951     +55\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Bond/UIKit/UIGestureRecognizer.swift | 0% <0%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 582d250...2d02aa3. Read the comment docs.\n. # Codecov Report\nMerging #483 into master will decrease coverage by 0.02%.\nThe diff coverage is 0%.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #483      +/-\n==========================================\n- Coverage   59.16%   59.13%   -0.03%   \n==========================================\n  Files          53       53            \n  Lines        4643     4645       +2   \n==========================================\n  Hits         2747     2747            \n- Misses       1896     1898       +2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Bond/ProtocolProxy.swift | 46.61% <0%> (-0.38%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 582d250...64d863b. Read the comment docs.\n. # Codecov Report\nMerging #484 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #484   +/-\n=======================================\n  Coverage   58.48%   58.48%         \n=======================================\n  Files          53       53         \n  Lines        4699     4699         \n=======================================\n  Hits         2748     2748         \n  Misses       1951     1951\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 2f8811d...0785b10. Read the comment docs.\n. # Codecov Report\nMerging #485 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #485   +/-\n=======================================\n  Coverage   58.48%   58.48%         \n=======================================\n  Files          53       53         \n  Lines        4699     4699         \n=======================================\n  Hits         2748     2748         \n  Misses       1951     1951\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 2f8811d...4228f11. Read the comment docs.\n. # Codecov Report\nMerging #496 into master will increase coverage by 0.51%.\nThe diff coverage is 69.23%.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #496      +/-\n==========================================\n+ Coverage   69.53%   70.04%   +0.51%   \n==========================================\n  Files          55       55            \n  Lines        4388     4396       +8   \n  Branches      164      165       +1   \n==========================================\n+ Hits         3051     3079      +28   \n+ Misses       1331     1309      -22   \n- Partials        6        8       +2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Bond/UIKit/UICollectionView.swift | 80.21% <100%> (+8.48%) | :arrow_up: |\n| Tests/BondTests/UICollectionViewTests.swift | 82.29% <66.66%> (+0.68%) | :arrow_up: |\n| Sources/Bond/Collections/ObservableArray.swift | 63.32% <0%> (+1.48%) | :arrow_up: |\n| Sources/Bond/ProtocolProxy.swift | 51.66% <0%> (+1.66%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 54b5ff3...cb28f5d. Read the comment docs.\n. # Codecov Report\nMerging #497 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #497   +/-\n=======================================\n  Coverage   69.53%   69.53%         \n=======================================\n  Files          55       55         \n  Lines        4388     4388         \n  Branches      164      164         \n=======================================\n  Hits         3051     3051         \n  Misses       1331     1331         \n  Partials        6        6\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Bond/Bond.swift | 79.31% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 54b5ff3...047647e. Read the comment docs.\n. # Codecov Report\nMerging #498 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster     #498   +/-\n=======================================\n  Coverage   69.53%   69.53%         \n=======================================\n  Files          55       55         \n  Lines        4388     4388         \n  Branches      164      164         \n=======================================\n  Hits         3051     3051         \n  Misses       1331     1331         \n  Partials        6        6\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Bond/Shared/NSObject+KVO.swift | 87.79% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 54b5ff3...0a933f8. Read the comment docs.\n. # Codecov Report\nMerging #511 into master will increase coverage by 0.33%.\nThe diff coverage is 89.65%.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #511      +/-\n==========================================\n+ Coverage   70.04%   70.37%   +0.33%   \n==========================================\n  Files          55       56       +1   \n  Lines        4396     4425      +29   \n  Branches      165      166       +1   \n==========================================\n+ Hits         3079     3114      +35   \n+ Misses       1309     1303       -6   \n  Partials        8        8\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Tests/BondTests/UIKitTests.swift | 100% <100%> (\u00f8) | :arrow_up: |\n| Sources/Bond/UIKit/UISearchBar.swift | 78.57% <78.57%> (\u00f8) | |\n| Sources/Bond/ProtocolProxy.swift | 55.41% <0%> (+3.75%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a90d5c6...3cc57f7. Read the comment docs.\n. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (master@6fb49d6). Click here to learn what that means.\nThe diff coverage is 44.03%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster     #514   +/-\n=========================================\n  Coverage          ?   64.13%         \n=========================================\n  Files             ?       77         \n  Lines             ?     5498         \n  Branches          ?        0         \n=========================================\n  Hits              ?     3526         \n  Misses            ?     1972         \n  Partials          ?        0\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| ...ervableCollection+RangeReplaceableCollection.swift | 0% <0%> (\u00f8) | |\n| ...bservableCollection/ObservableCollection+Set.swift | 0% <0%> (\u00f8) | |\n| ...ableCollection/CollectionOperation+DiffPatch.swift | 0% <0%> (\u00f8) | |\n| ...Bond/ObservableCollection/ModifiedCollection.swift | 0% <0%> (\u00f8) | |\n| ...ervableCollection/ObservableCollection+Array.swift | 0% <0%> (\u00f8) | |\n| ...eCollection/CollectionOperation+Differ+Array.swift | 0% <0%> (\u00f8) | |\n| ...s/Bond/ObservableCollection/TreeNodeProtocol.swift | 0% <0%> (\u00f8) | |\n| ...llection/CollectionOperation+Differ+TreeNode.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/ObservableCollection/TreeArray.swift | 0% <0%> (\u00f8) | |\n| ...servableCollection/ModifiedCollection+Signal.swift | 0% <0%> (\u00f8) | |\n| ... and 14 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 6fb49d6...656acce. Read the comment docs.\n. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (observable-collection@a67293e). Click here to learn what that means.\nThe diff coverage is 17.56%.\n\n\n```diff\n@@                   Coverage Diff                    @@\nobservable-collection     #524   +/-\n========================================================\n  Coverage                         ?   68.11%         \n========================================================\n  Files                            ?       73         \n  Lines                            ?     5116         \n  Branches                         ?        0         \n========================================================\n  Hits                             ?     3485         \n  Misses                           ?     1631         \n  Partials                         ?        0\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| ...nd/ObservableCollection/ObservableCollection.swift | 0% <\u00f8> (\u00f8) | |\n| ...ond/ObservableCollection/CollectionOperation.swift | 0% <\u00f8> (\u00f8) | |\n| ...rvableCollection/MutableObservableCollection.swift | 0% <0%> (\u00f8) | |\n| ...ableCollection/ObservableCollection+TreeNode.swift | 0% <0%> (\u00f8) | |\n| ...ableCollection/CollectionOperation+DiffPatch.swift | 0% <0%> (\u00f8) | |\n| ...eCollection/ObservableCollectionEvent+Signal.swift | 0% <0%> (\u00f8) | |\n| ...s/Bond/ObservableCollection/TreeNodeProtocol.swift | 0% <0%> (\u00f8) | |\n| ...ervableCollection+RangeReplaceableCollection.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/ObservableCollection/TreeNode.swift | 0% <0%> (\u00f8) | |\n| ...servableCollection/ObservableCollectionEvent.swift | 0% <0%> (\u00f8) | |\n| ... and 4 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a67293e...10fc1a3. Read the comment docs.\n. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (master@1a8772d). Click here to learn what that means.\nThe diff coverage is 52.5%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster     #582   +/-\n=========================================\n  Coverage          ?   62.72%         \n=========================================\n  Files             ?       86         \n  Lines             ?     3474         \n  Branches          ?        0         \n=========================================\n  Hits              ?     2179         \n  Misses            ?     1295         \n  Partials          ?        0\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| ...a Sources/FlatDataSourceChangesetConvertible.swift | 0% <\u00f8> (\u00f8) | |\n| Sources/Bond/UIKit/UITableView.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/UIKit/UICollectionView.swift | 0% <0%> (\u00f8) | |\n| ...ervable Collections/Signal+ChangesetProtocol.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/Shared/CALayer.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/UIKit/UIStepper.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/Data Structures/TreeNode+Differ.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/Shared/NSLayoutConstraint.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/UIKit/UIApplication.swift | 0% <0%> (\u00f8) | |\n| Sources/Bond/UIKit/UIGestureRecognizer.swift | 0% <0%> (\u00f8) | |\n| ... and 23 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1a8772d...e15ac28. Read the comment docs.\n. \n",
    "Dubey-Quod": "This is my implementation of viewForSupplementaryElementOfKind :\nfunc collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -> UICollectionReusableView {\n        let headerView: TimelineHeaderView = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: headerViewIdentifier, forIndexPath: indexPath) as! TimelineHeaderView\n        headerView.dateLabel.text = TimelineViewModel.getDateLabelAtIndex(indexPath.section)\n        return headerView\n    }\n. Thanks! It worked for me.\n. Hi,\nSorry for reposting on this issue. The problem is that I am getting only one header. How should I make my data source array so that I get a 2 dimensional observable array? And how to bind this with collection view so that every header has designated cells?\nbinding in collection view:\nTimelineViewModel.observableCellsContentArray.lift().bindTo(collectionView, proxyDataSource: self) { indexPath, cellContent, collectionView in\n            let cell = collectionView.dequeueReusableCellWithReuseIdentifier(self.identifier, forIndexPath:   indexPath) as! CollectionViewCell\n            let timeslotAtIndexPath = cellContent[indexPath.section][indexPath.row]._timeslot!\n            cell.layer.borderWidth = 0.5\n            cell.activityLabel.text = TimelineViewModel.getActivityString(timeslotAtIndexPath)\n            cell.placeLabel.text = TimelineViewModel.getLocationString(timeslotAtIndexPath)\n            return cell\n        }\nThanks in advance for your help!!!\n. Thanks! I will try that. And sorry for putting the code in unreadable format.\n. Yes it worked. Thanks!\n. Thanks I found the workaround:\n    func pickerView(pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\n        let name  = Observable(activityObservableArray[row])\n        name.map{ \"($0)\" }.bindTo(actTextField.bnd_text)\n    }\n. Thanks @clooth and @srdanrasic  for the solution. I am very new to reactive programming and I have started with SwiftBond to learn it properly. It's amazing and I hope to get more support from here.\n. ",
    "Evgeniy-Odesskiy": "Thank you for response.\nThis approach works great!\nBut my code is reasonable complicated because I need abilities bind to canFly property and filter array by this property. How can I achieve this?\n. ",
    "ColinEberhardt": "Thanks for getting back to me - I'll raise PRs as and when I spot issues.\nI'm happy to discuss over email / Hangouts / Skype or whatever works best. Firstly what I want to do is come up with an example project then share it with a few people for feedback - I could perhaps include you in that?\nThanks for the heads-up on ReactiveKit - I wasn't aware of that! So many options ...\nI think I'll still focus on Bond, as I mentioned, I've written about FRP with ReactiveCocoa a few times. What I wanted to focus on with this article was lightweight UI binding.\nAs I am sure you are aware, ReactiveCocoa is a very good (if slightly confusing) implementation of FRP, however, it has very few UI binding features. As an example it lacks table binding, why is why I created a reasonably popular table binding helper - which looks very similar to the solution you have in Bond, with observable arrays.\nIn my opinion once someone understand the concepts (MVVM / FRP), moving from one framework to another is quite a simple task\n. ",
    "njtuxy": "Sure, \nI use a struct to save an ObservableArray which like this:\nDefinition for Contacts:\n\nstruct Contacts {\n    static var contacts = ObservableArray([Contact]())\n}\n\nDefinition for Contact\n\n struct Contact {    \n    let email: String!\n    let uid: String!    \n    init(uid: String, email: String){\n        self.email = email\n        self.uid = uid\n    }\n}\n\nThen I add an observer in the landing view's viewDidAppear section:\n\n    override func viewDidAppear(animated: Bool) {\n           super.viewDidAppear(animated)          \n       Contacts.contacts.observe{event in\n             print(event.sequence)\n         }\n    }\n\nThe result: \nIf I update the Array's value from another view(or outside of the app), the observer never got triggered.\nJust FYI, I am using Swift version 2.1\nThanks!\n. ",
    "JuGoo": "Sure,\nfor example my data is:\n``` swift\nvar list = [\"Vegetables\": [\"Carrot\", \"Potato\", \"Radish\"], \"Fruits\": [\"Apple\", \"Banana\"] ...]\nvar dataSource = ObservableArray>()\nin viewDidLoad\ndataSource.bindTo(tableView) { (indexPath, dataSource, tableView) -> UITableViewCell in\n            let cell = tableView.dequeueReusableCellWithIdentifier(\"cell\", forIndexPath: indexPath)!\n            let viewModel = dataSource[indexPath.section][indexPath.row]\n        return cell\n    }\n\n```\nand extension\nswift\nextension MyViewController: BNDTableViewProxyDataSource {\n    override func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -> String? {\n        //return \"Header\"\n        //here i would return section name like Vegetables, Fruits...\n    }\n}\n. Ok, now i use that:\ndataSource.bindTo(outletTableView, proxyDataSource: self) { (indexPath, dataSource, tableView) -> UITableViewCell in\n            let cell = (tableView.dequeueReusableCellWithIdentifier(\"cell\", forIndexPath: indexPath) as? SettingsMenuTableViewCell)!\nlet viewModel = dataSource[indexPath.section][indexPath.row]\n        print(viewModel)\n        return cell\n    }\nSo, how can set title for header?\nThank's in advance @srdanrasic \n. ",
    "pk1": "Hi,\nI'm adding my question to this issue because the main topic seems to be more or less the same (regarding section titles).\nIn my implementation I have a tabbar with several buttons each of them triggering a search which will fill the table view with the appropriate data. Depending on the selected tabbar button the table will contain\\show different sections. I have implemented BNDTableViewProxyDataSource and the titles in the header are shown correctly (for each section a different title). So far so good. Furthermore the section title contains a dynamic part which is simply the amount of rows in each section (for example -> The section contains 10 rows). Now as the data gets populated the function titleForHeaderInSection in BNDTableViewProxyDataSource gets triggered several times. In this function I'm accessing my view model which is returning the correct amount of rows for each section. But for some reason the section titles are not really updated for each iteration.\nWhile the data is collected and new elements are inserted in my observable array, the mentioned function is triggered now several times and I can see that the constructed section title should start with \"The section contains 0 rows\" and end with \"The section contains 10 rows\":\n- The section contains 0 rows\n- The section contains 1 rows\n- The section contains 2 rows\n- The section contains 3 rows\n  .......\n  ...\nWhat I am expecting is that after the last iteration when the title that is returned is \"The section contains 10 rows\", the appropriate section will reflect also that title but this is not the case. It still shows \"The section contains 0 rows\".\nAny ideas what I'm doing wrong here?\n. @zach-cmiel \ncan you please provide more information on how to exactly use edit actions with a proxy data source?\nBNDTableViewProxyDataSource seems not to implement the editActionsForRowAtIndexPath function.\n. Thanks for the quick answer and yes indeed I'm using CocoaPods but I think that I'm not on the latest version. Will try that out.\n. After updating CocoaPods to version 1.1.1 and running pod install it started to re-create CocoaPods and this finally did the trick. Bond is now compiling without any error.\nThanks @srdanrasic and keep up the good work!\n. Thanks for the quick reply @srdanrasic (appreciate it)!\nI refactored my code according to your proposals and it seems that it did the trick.  At least it looks promising on the first few tests I did. Will have a deeper look and try also if maybe only using the non-animated-binding is the solution (at the moment I'm using the non-animated binding and the UITableView subclass). I think we should continue this discussion in SOF because it has nothing to do with the issue in this thread.. ",
    "micpringle": ":+1: \n. ",
    "kArTeL": "I realized that is equal to the traditional way:\nSwift\n    func collectionView(collectionView : UICollectionView,layout collectionViewLayout:UICollectionViewLayout,sizeForItemAtIndexPath indexPath:NSIndexPath) -> CGSize\n    {\n        let cellSize:CGSize = CGSizeMake(150, 200)\n        return cellSize\n    }\n. ",
    "yanamura": "@dreday966 \nHow about create Bond extension in your project like below\n```\nimport Bond\nextension EventProducerType {\n  public func same() -> EventProducer {\n    return EventProducer(replayLength: replayLength) { sink in\n      var lastEvent: EventType? = nil\n      return observe { event in\n        if lastEvent == nil || lastEvent! == event {\n          sink(event)\n          lastEvent = event\n        }\n      }\n    }\n  }\n}\n```\n. It looks only os/x test coverage is working..\n. @1994ericseo \ntry to use BNDTableViewProxyDatasource.\n```\nfunc tableView(tableView: UITableView, animationForRowAtIndexPaths indexPaths: [NSIndexPath]) -> UITableViewRowAnimation {\n  return .None\n}\nfunc tableView(tableView: UITableView, animationForRowInSections sections: Set) -> UITableViewRowAnimation {\n  return .None\n}\n```\n. @ohde-sg \nThis behavior is not bug.\n\"observeNew\" is same meaning of \"skip(1).observe\".\nI think what you want to do is below.\nage.skip(1)\n    .filter{ (age) -> Bool in return age > 20 }\n    .observe{ (age) in print(\"\\(age)\") }\n. ",
    "curtisforrester": "Hi - and welcome to the ecosystem. Mind the Tigers :)\nIf I'm understanding, you'd like to set the text of the NSTextField to the NSDateFormatter result of the observed date (though it appears you have the date as a string?). In Swift I display a date like this:\n```\nself.dateStart\n     .map { date in\n          return MyDateFormatters.shortDateFormatter.stringFromDate(date)\n     }\n     .bindTo(self.dateLabel.bnd_text)\n```\n. Agree. Might be a better way, but here's what I do for now:\nvar counter: Int = 0\n@IBOutlet weak var someLabel: UILabel!\n// ....\nself.myObservableArray.observe({ item in\n    self.counter = item.sequence.count\n    // Or to show in a label...\n    self.someLabel.text = \"\\(item.sequence.count)\"\n})\nWhen the array is changed the block will be called, updating the counter or label's text.\n. For my UITableViewController that is its own data provider, my first \"bindTo\" line reads:\nself.bindDisposable = self.myArray.lift().bindTo(self.tableView, proxyDataSource: self) { indexPath, dataSource, tableView in\n...\n}\n. ",
    "CallumOz": "I know this is an old issue but I come across it and it got me thinking.\nHere is my proposition (it's untested), it would need to be added directly into EventProducer.swift since replayBuffer is private.\n``` swift\npublic extension EventProducer {\npublic func observeOnce(observer: Event -> Void) -> DisposableType {\n    if let last = replayBuffer?.last {\n        observer(last)\n        return SimpleDisposable()\n    }\n    else {\n        var disposable: DisposableType!\n        disposable = observeNew { (event) in\n            observer(event)\n            disposable?.dispose()\n        }\n        return disposable\n    }\n}\n\n}\n```\nAnd you would use it like this:\nswift\nflag.filter { $0 }\n    .observeOnce { [unowned self] (_) in\n        self.doSomething()\n    }\n    .disposeIn(bindingBag)\nI hope someone will found this useful someday \ud83d\ude04 \n. I'm glad it was helpful to someone \ud83d\ude09\n. https://github.com/SwiftBond/Bond/blob/master/Bond/Extensions/iOS/UIButton%2BBond.swift#L35\nEventProducer<Void> works, I have used it many times in my own project.\n. These methods:\noptional func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -> UIView?\noptional func tableView(tableView: UITableView, viewForFooterInSection section: Int) -> UIView?\nare a part of the UITableViewDelegate Protocol, and not UITableViewDataSource, so this shouldn't be added to the Proxy Data Source.\nIf you check, the method on the BNDTableViewDataSource should never be called.\nHowever this should work if and only if the the Proxy Data Source and the Delegate are the same class because the methods on the Proxy and the Delegate have the same signature.\n. You need to use ObservableArray.appleOperation(_:).\nWell anyway that's how I dealt with it.\nswift\nbnd_dealArray\n    .map { (deal) -> NSTimeInterval in\n        return deal.startQuoteDate.timeIntervalSinceDate(deal.endQuoteDate)\n    }\n    .observe { (event) in\n        bnd_dealDurationArray.applyOperation(event.operation)\n    }\nHope that helps \ud83d\ude09\n. I have the same problem. I found that you need to explicitly initialise the MutableObservableArray with an empty array.\nswift\n    private let _panels: PanelArray = PanelArray([])\nI hope that fixes your problem too \ud83d\ude09\n. @Bubcho, glad to hear that!\n. What about map though ? It doesn't seem as complicated to me.\n. Great news, thanks \ud83c\udf89. ",
    "feighter09": "@CallumOz it was very helpful to me!\n. cmd + click the replace method. Does it bring you to \nswift\npublic func replace(with array: [Item])\nor \nswift\n/// Replace all emitted elements with the given element.\npublic func replace<T>(with element: T) -> ReactiveKit.Signal<T, Self.Error>\nIt's very easy to accidentally be using the latter when types don't match up exactly right, in which case the method acts very differently than you'd expect. ",
    "eriklamanna": "@tonyarnold Yes, I believe you're correct that the Apple docs are probably things people should know. I just noticed that since I last looked at this there has been quite a bit of new work on master. I think most of the examples now are straight forward enough that this may not be as confusing as previous versions of the README. I'm going to close this for now for that reason.\n. ",
    "goodwithgit": "I was experiencing a similar issue ... the startWith() event was not seen.\nI tried out @yanamura3's fix (in commit 03693b6) for this and noticed that the startWith() event propagates, but it doesn't do so until a subsequent event is posted.   In my case, I was expecting it to propagate immediately.    Am I wrong to expect that?\nI do get the behaviour I want by altering @yanamura3's startWith() slightly as follows:\npublic func startWith(event: EventType) -> EventProducer<EventType> {\n        var hasDispatch = false\n        return EventProducer(replayLength: replayLength + 1, lifecycle: EventProducerLifecycle.Managed) { sink in\n            if !hasDispatch {\n                hasDispatch = true\n                sink(event)\n            }\n            return observe { subsequentEvent in\n                sink(subsequentEvent)\n            }\n        }\n    }\nIs this good or bad?   I'm quite new to Swift, binding, reactive-ness, MVVM, etc. etc., so I'm at a bit of loss to evaluate.\n. ",
    "adamstener": "I've got more to do, there were a few issues with tests and the TV target, will clean all that up and switch the operator.\n. Not sure why the coverage dropped so much, could be because of the new #file operator doing something I don't understand yet.\n. Is it possible that the drop in code coverage is simply due to the environment change?\n. This probably shouldn't be pulled into master, maybe Bond needs a Swift-2.2 branch.\n. Not sure what else to do, with the new environment the testing coverage dropped.  I've been using a local copy of this but would love to figure out what it needs to get merged.\n. ",
    "lyptt": "Any progress on this?\n. ",
    "adhanji": "@mingyeow It seems like we can just use the delegate methods as normal based off this issue: #230 \n. ",
    "mikhaelt": "I got this issue in the same point, using Xcode 7.3 also.\nHave any solution for this?\nThanks\n. ",
    "liuduoios": "This is a Swift 2.2 bug, update Xcode to 7.3.1 can solve this issue.\n. ",
    "shams-ahmed": "Any chances this feature could be fixed and merged? \n. ",
    "johnliedtke": "Was not using ObservableArrayEvent.... my mistake. \n. ",
    "Broich": "BNDTableViewProxyDatasource is gone in Bond5 - What is the preferred way to do this now?\n. @srdanrasic currently ReactiveKit throws an error in SignalProtocol.swift when compiled as a dependency of Bond5 with the latest Xcode 8 release. Any recommended workaround? \n. Thanks so much! \ud83d\udc4d ...and yes it works\n. ",
    "igorkulman": "What is the way to do it with the current version? here is no var animated: Bool on TableViewBond anymore.. ",
    "zach-cmiel": "So @curtisforrester what is self.bindDisposable's type in this situation?\n. ",
    "marciok": "Any reasons to not merge? :)\n. \ud83d\ude34\n. ",
    "AlexEdunov": "Thanks a lot! The fastest merge in my life:)\n. Thanks a lot!\n. ",
    "orchetect": "The name's Bond. Swift Bond.\n. ",
    "mshibanami": "Thanks!\n. ",
    "siavashalipour": "Thanks @srdanrasic . I have already migrated my project to 3.0 and made the changes to the Bond (although nothing very specific just made it compile with 3.0). Just also wanted to thank you for this amazing pod. I am really enjoying using it.\n. @SCasarotto  Try this pod 'Bond', '~> 5.0.0-beta9'\n. ",
    "bytegh": "Hey @srdanrasic  is there any branch support swift2.3? I want to use in that version. thanks\n. Got it! Trying to do that. thanks @srdanrasic \n. sorry, misoperation. ",
    "tadasz": "Is there anything I could help with migration to 3.0? When are you planning to have a working version?\n. @srdanrasic  could you give us a tip how to fix it, i want to test some feature on ios10 and it would be great to have a fix locally until new release. thanks!. it's still the same. yes it is. once i force selector unsafeBitCast(imp, to: _IMP.self)(me, selector!)  it compiles fine. ",
    "patrick-lind": "Maybe it's just me but when I pull down the master branch and try to compile in Xcode 8 I get the following error messages:\nSwift Compiler Error Group\n/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator10.0.sdk/System/Library/Frameworks/UIKit.framework/Headers/UIKit.h:8:9: 'UIKit/UIKitDefines.h' file not found\nCould not build Objective-C module 'UIKit'\nAnyone else seeing this?\n. I completely wiped out my Bond folder and downloaded from scratch from the newest master branch and still seeing the same thing. If I run 'git submodule update' nothing appears to happen and still get the same error messages. I will be transparent and mention that I'm not really familiar with working with Carthage and git submodules as well!\n. Tried both of those options and seeing the same thing. Yes I am building through Xcode... Is that not the way to do it? Also for context, I was trying to figure out how to enable Swift Package Manager support and contribute back :)\n. Well basically I'm trying to import your excellent Bond project into my project using SPM. So far the other dependencies I've used are supporting it: AlamoFire and etc. Also ReactiveKit, which you appear to depend on now is supporting it. I agree SPM is a little tedious at this point. You need to specify your Package.Swift file and then run \"swift package generate-xcodeproj\" and then it creates the Xcode project for you that has the dependencies plugged in appropriately.\n. Still trying to figure out my \"Could not build Objective-C module 'UIKit'\" issues. That said, I believe you may need to update some of the imports to get the SPM to work. When I run \"swift build\" on the repository I get the following error:\n/Bond/Sources/AppKit/NSSegmentedControl.swift:34:35: error: use of undeclared type 'Bond'\n  public var bnd_selectedSegment: Bond {\n                                  ^~~~\n. Sorry I was trying to fix it for you but still trying to figure out what's going on with my setup.\n. CocoaPods vs Carthage appears to be the new tabs vs spaces argument. It's pretty much preference; each has their strong suits.\n. ",
    "tlandsmancars": "I'm trying to convert my project with Swift 3 and I'm getting warnings \"Result of call unused\"\nThis happens even in the example given: \nlet name = Observable(\"Jim\")\n    name.observeNext { value in\n        print(\"Hi \\(value)!\")\n    }\nHow should we handle this?\n. Thanks srdanrasic!\nOne more quick question - what's the equivalent to observeNew?  I can't seem to get an equivalent working. \n. ",
    "chrisjb82": "Hi there, i've just updated to Xcode 8 and can't seem to get Bond to compile. The issue appears to be coming from ReactiveKit, any ideas? It's version 3.0.0-beta5\nBtw Bond is an awesome framework and very much appreciated!!\n. Line 437 of RawStream.swift (return distinct(areDistinct: !=)) is returning an error.\nIt would appear that there are two functions called distinct, one which takes no params and one which does. The compiler thinks it's trying to call the function which takes no params and throws a warning. \nThis is happening with the GM build of XCode 8, when opening my project i have clicked the 'Update to Swift 3.0' button (after updating to 5.0.0-beta6).\n. I'm using cocoapods, is carthage better? I completly erased the Pods/ folder and  then ran 'pod install', it bought down v3.0.0-beta5 but it looks like something else must be wrong. I also got a few compile issues in Bond, looks like they were to do with updates to parameter naming in swift 3, they maybe part of the same issue...\n. Switching to Carthage seems to have fixed the issues i was seeing :)\n. @duanepfeiffer I had quite a few issues, needed to remove cocoa pods (old files left linked to workspace) and add via Carthage. One this is done you'll still have lots of issues to fix but they'll be in your code where you are using bond, this is mainly due to swift 3 syntax changes. if you look at the change log it should point you in the right direction, also note that you'll need to dispose of your binding else Xcode 8 will raise lots of warnings\n. Apologies, i meant observations!\n. I'll have a look this weekend and get back to you, hopefully it'll work now with the current stable release.\n. Hi @srdanrasic, i tried the code again after updating to Bond v5.0.2 and it would appear the issue is no longer present.\nDo you know what could've been causing the issue in the first place? It would be good to know just incase i've done something i shouldn't have when hooking up the bindings on my TableView.\nMany thanks again for a great Framework. Bond should be included as standard in iOS IMO!\n. Hi @srdanrasic, i'm using v4.3.1 of Bond as i was experiencing issues #302 with v5.0.0, however, this issue appears to be apparent in v5.0.0 too.\nIn the file UITextField.swift bnd_attributed only monitors .editingChanged wheras bnd_txt monitors .allEditingEvents as you said, should they not be the same?\nThe same issue is present in UITextView.swift where only UITextViewTextDidChange is monitored.\nTook me a wee while to figure out what was going on there! :)\n. ",
    "Joebayld": "Trying to migrate my project to Bond5. Is it possible to access the original array in a MutableObservableArray? I use NSCoding and need to be able to serialize the data. See the following: \nlet data = NSKeyedArchiver.archivedData(withRootObject: model.testObjects.array)\n. Hey @srdanrasic. What would your thoughts be on making the ObservableArray's array variable a public getter? That way it's possible to access the items for things like encoding the array. \n```\npublic class ObservableArray: Collection, SignalProtocol {\npublic fileprivate(set) var array: [Item]\n  fileprivate let subject = PublishSubject, NoError>()\n  fileprivate let lock = NSRecursiveLock(name: \"ObservableArray\")\n``\n. Hey guys. Should the newreplace()function be public? Right now it's not accessible. That way it's possible to do a replace on theMutableObservableArraywithout the items beingEquatable`\n287\n```\nextension MutableObservableArray {\npublic func replace(with array: [Item]) {\n    lock.atomic {\n      self.array = array\n      subject.next(ObservableArrayEvent(change: .reset, source: self))\n    }\n  }\n}\n```\n. Yeah that would be great. Or maybe a public getter only? private(set) public var array. \nI know you can use the collection methods, but I feel it would still be useful to access the underlying array in an ObservableArray. Also, would the getter need to be contained in an atomic lock?\n. ",
    "duanepfeiffer": "I just added Bond5 beta8 to an existing project but it doesn't seem to be ready for Swift 3.  I get hundreds of compiler errors after converting to swift 3.  What am I missing?  I'm using cocoa pods.  the errors appear to be in ReactiveKit\n. ",
    "angadn": "Since I was heavily reliant on the old Bond in a framework-project, and hesitant to adding Obj-C bridging of the new Bond 5 beta, I've ported SwiftBond (4.3.1) to Swift 3.0 here in case it helps: https://github.com/angadn/bond\nPart of maintaining a framework-project is also that I have to embed Bond in my source-code instead of relying on dynamic-linking, and that's where bridging makes things messy for some clients :)\n. ",
    "i-schuetz": "@srdanrasic\nRE: Disposables, couldn't the functions be annotated with @discardableResult? \n. ",
    "a-rodriguez296": "@tlandsmancars @srdanrasic  did you ever get a response for your question regarding observeNew? \n. ",
    "obuseme": "FYI in case anyone missed it, Xcode 8.2 will be the last version that supports Swift 2.3.  Apple suggests migrating projects to Swift 3.\nhttps://developer.apple.com/library/prerelease/content/releasenotes/DeveloperTools/RN-Xcode/Introduction.html\nI'm anxiously awaiting a Bond release compatible with Swift 3.\n. ",
    "poseidonsw": "Any word on how to fix the issue with installing using cocoapods? I really don't want to change over carthage for this project now.\n. ",
    "KarthikV710": "@srdanrasic What is the equivalent for observeNew?. Thanks a lot @srdanrasic . Appreciate your help :). ",
    "Benuuu": "@srdanrasic thanks! that clears things up.\n. ",
    "adellibovi": "@srdanrasic you're welcomed :) I really like the 5.0, keep going with the good work! \ud83d\udc4d \n. ",
    "ben73": "I'm have same error.\n. Fix: Just add next line to your Podfile\npod 'ReactiveKit', :git => 'https://github.com/ReactiveKit/ReactiveKit.git', :tag => 'v3.0.0-beta2'\n. @vulgur Fixed in this commit\n. ",
    "vulgur": "@ben73 Well, I've already add this line: github \"ReactiveKit/ReactiveKit\" ~> 3.0\", and carthage download the v3.0.0-beta2, but it doesn't work.\nI will try your solution.\n. @ben73 That's right it was fixed, but it just don't work in  carthage update.(Maybe it works by CocoaPods)\n. Yes! It works in Beta-3! Great works! \n. ",
    "EEimer": "Thank you so much @srdanrasic ,  fortunately we use carthage :) \nJust cloned it -> works perfekt! \nThanks for the awesome fast fix and this awesome lib :) \n. Hi @AnthonyMDev, hey @srdanrasic, \nHad the same problem with beta 4, just updated to beta 6.\nIssue is fixed => Thanks  :) \n. ",
    "robertodias180": "Hi @srdanrasic, \nthe import ReactiveKit solve the DisposeBag issue. Thank you.\nAs for the data source it is a var inside a static let sharedInstance: RSNewsManager = RSNewsManager() so retained  it should not be a issue.\n. @srdanrasic i removed all pods and re-installed everything and it is working now.\nAlso i noticed that if you use this var dataSource: MutableObservableArray <MutableObservableArray< News >> it wont work as before.\nWas sections support removed?\n. Thank you @srdanrasic\n. ",
    "brandon-james105": "Fixed by doing this:\nlet voters = viewModel?.voterNames\nlet dataSource = ObservableArray([voters!])\n. ",
    "yuvalt": "+1 for an example. Thanks :-)\n. Thank you!. ",
    "prefect42": "\ud83c\udf89 Thanks\n. Haha. Okay. I did not see this when writing the other issue a minute ago \ud83c\udf89. Please merge this!. ",
    "jonathanfoster": "If anyone comes across this issue, the section @srdanrasic referenced has now moved to https://github.com/DeclarativeHub/Bond/blob/master/Documentation/ObservableCollections.md#observable2darray--mutableobservable2darray.. @johanneskares I just ran into this same problem trying to implement tableView(_:commit:forRowAt:). I know this issue is already closed, but I thought it would be helpful to document a working solution given the original request (would've saved me some time that's for sure).\nThe problem occurs because Objective-C enum types are not supported as arguments. Change UITableViewCell.EditingStyle to Int and it will work fine. You'll just need to convert the editing style raw value back to UITableViewCell.EditingStyle.\nHere's a working version of the code above.\n```\nlet commit = tableView.reactive.dataSource.signal(\n    for: #selector(UITableViewDataSource.tableView(_:commit:forRowAt:)),\n    dispatch: { (\n        subject: SafePublishSubject<(Int, IndexPath)>,\n        tableView: UITableView,\n        editingStyle: Int,\n        indexPath: IndexPath) -> Void in\n            subject.next((editingStyle, indexPath))\n})\ncommit.observeNext { (editingStyle, indexPath) in\n    print(\"test\")\n}\n. A simple bind work around is:\n_ = timePicker.reactive.controlEvents(.valueChanged).observeNext { value in\n  viewModel.time.value = timePicker.countDownDuration\n}\n```. I threw together a potential implementation based on UITableView binding extensions. If this is headed in the right direction, then I could submit a PR and work feedback from there. \nhttps://github.com/jonathanfoster/Bond/blob/pickerview-bind/Sources/Bond/UIKit/UIPickerView.swift. @npvisual: Thanks for the update. I ended up going a different direction for the use case that prompted this issue so I abandoned the effort.\nI just ran into the same use case again so I'm going to revisit this issue and update the fork. I'll try to get whatever I come up with upstream. I'm upping the difficulty level this time, I need a 2D array bound for height (feet and inches options). I'll start with the simple 1D array use case first though.. ",
    "MickCrozier": "Awesome - Thank You!\n. ",
    "jechol": "I feel same. I don't understand why many of bnd_xxx became just consumer.\nHard to migrate.\nI believe there's good reason in the decision.\n@srdanrasic Could you please clarify what I misunderstand now.\n. @srdanrasic Totally agree now.\nWhat makes me hard to migrate was wrong state derivation path. Thanks for the explanation.\n. Have same change in https://github.com/ReactiveKit/Bond/pull/294\n. Yeah, I tried to patch myself, but target is weak ref so that target is released immediately.\nI'm working around by call bnd_tap only once in client side now.\n. ",
    "connectdotz": "@srdanrasic, thanks for the explanation. \nI completely understand what you are saying and agree that it is indeed the right way of thinking about some use cases. However, there are some other use cases that might not fit quite as obvious. For example, when multiple ViewModels need to trigger the same view behavior, such as enable/disable a commit button (visually changing button's background color and title) when any form field changes. One could argue the button's background and title actually depend on the button's own state, not necessary the models affect the button, i.e. the \"truth\" is the button's own state. So it doesn't make much sense for the models to reach into the button's own background and title with binding...\nObviously we need to be careful with such reasoning so it won't become unnecessary spaghetti code as you are rightfully trying to avoid. The question is should the library dictate the use case or provide the flexibility and let developer decide how to use them (+ best practice to warm cases like you mentioned)\nRegarding the DynamicSubject vs Property: I see one more difference that you explicitly distinguish \"how\" the text changed: triggered by events vs. manually setting. With Property, it handles both cases internally, i.e. it can be observed for changes caused by UI or by setting value manually. With DynamicSubject, it only emit signal for UI triggered changes. \nI can see your intent to simplify and enforce proper patterns, that's all good; and sure we can just add the additional properties for our own use cases, but if this is a common pattern (maybe?...:-)), I wonder will it be more benefitial to add it in the library?\n. @AnthonyMDev, yes we are fully aware that adding our own property can address the problem, and that is exactly what we did to work around the current problem. My main point is: if many people end up creating many similar/dup properties, it might make more sense to have the library providing it instead. Imagine if the attributes are all Property, then we don't need to create any extra attributes, isn't that better?!\n. ",
    "IceFloe": "Hi all! Just want to say, that I can agree with @connectdotz that this is a problem, now I have to write more code is some situations, this is rly painful. Let see some example \n```\nBefore:\n        viewModel.iDontCareFilter.bidirectionalBindTo(doesNotMatterFilterBtn.bnd_selected)\n        viewModel.lowFilter.bidirectionalBindTo(lowFilterBtn.bnd_selected)\n        viewModel.mediumFilter.bidirectionalBindTo(mediumFilterBtn.bnd_selected)\n        viewModel.hardFilter.bidirectionalBindTo(hardFilterBtn.bnd_selected)\n        viewModel.insaneFilter.bidirectionalBindTo(insaneFilterBtn.bnd_selected)\n@IBAction func changeFilterState(_ sender: FilterButton) {\n        sender.bnd_selected.value = !sender.bnd_selected.value\n    }\n```\nAfter:\n```\n        viewModel.iDontCareFilter.bind(to: doesNotMatterFilterBtn.bnd_isSelected)\n        viewModel.lowFilter.bind(to: lowFilterBtn.bnd_isSelected)\n        viewModel.mediumFilter.bind(to: mediumFilterBtn.bnd_isSelected)\n        viewModel.hardFilter.bind(to: hardFilterBtn.bnd_isSelected)\n        viewModel.insaneFilter.bind(to: insaneFilterBtn.bnd_isSelected)\n@IBAction func changeFilterState(_ sender: FilterButton) {\n        if sender == self.doesNotMatterFilterBtn {\n            viewModel.iDontCareFilter.next(!sender.isEnabled)\n        }\n    if sender == self.lowFilterBtn {\n        viewModel.lowFilter.next(!sender.isEnabled)\n    }\n\n    if sender == self.mediumFilterBtn {\n        viewModel.lowFilter.next(!sender.isEnabled)\n    }\n\n    if sender == self.hardFilterBtn {\n        viewModel.lowFilter.next(!sender.isEnabled)\n    }\n\n    if sender == self.insaneFilterBtn {\n        viewModel.insaneFilter.next(!sender.isEnabled)\n    }\n\n}\n```\nAlso now, I can't do mapping from ui value to my value in model because it is not a Property :(\n. ",
    "rsaarloos": "As far as I know this behaviour was not like this in the rTap of ReactiveUIKit. In my project I replaced ReactiveUIKit with Bond and I'm running in the same behaviour. I did not really understand what was going on as only my latest bind did actually work. But this explains the behaviour at least. Maybe this info will help @srdanrasic ?\n. ",
    "elementsrtyte": "Any updates on this one @srdanrasic ?\n. Any updates on this? \ud83d\ude4f\ud83c\udffd. ",
    "SCasarotto": "Wonderful that worked. The docs should be updated to reflect. Thanks!\n. Ah yes sorry to be more clear. I was updating the bnd_text value with the following before and currently. On viewDidLoad I set up bindings between my model and the text field with the following:\nDriver.sharedInstance.nameF.bindTo(fNameInput.textField.bnd_text) (Pre Swift 3)\nDriver.sharedInstance.nameF.bind(to: fNameInput.textField.bnd_text) (Swift 3)\nwhere nameF is declared as: let nameF : Observable<String?> = Observable(nil)\nIn pre-swift 3 (Bond 4) this was triggering my validateTextField() on first value update and any updates after (nameF was being set by a firebase watcher) but now is not.\n. This work-around seems to have the intended affect. \nDriver.sharedInstance.nameF.bind(to: fNameInput.textField.bnd_text)\nDriver.sharedInstance.nameF.observeNext\n    {[unowned self] text in\n        quickPrint(\"Observe Next Attempt\")\n        self. fNameInput.validateTextField()\n    }\n    .disposeIn(bnd_bag)\nHowever it feels like it should work the way I described before and did work in previous version.\nThoughts @srdanrasic ?\n. Great thanks. \nAlso I noticed the readme says cocoaPod integration pod 'Bond', '~> 5.0' however I attempted to use that last night with no luck. It seemed like I still had to use pod 'Bond', '~> 5.0.0-beta10'.\n. ",
    "svachmic": "Hi there,\nI'm trying to implement section headers somewhat along the lines @sveinhal outlined, but I seem to be getting a lot of errors, notably Ambiguous reference to member 'collectionView'.\nI've tried the feed option and came up with this:\n```\ncollectionView?.bnd_dataSource.feed(\n            property: self.viewModel.contents,\n            to: #selector(UICollectionViewDataSource.collectionView(_:viewForSupplementaryElementOfKind:at:)),\n            map: {\n                (value: Observable2DArraySection, col: UICollectionView, kind: String, indexPath: IndexPath) -> UICollectionReusableView\n            let headerView = col.dequeueReusableSupplementaryView(ofKind: UICollectionElementKindSectionHeader, withReuseIdentifier:\"iconHeaderCell\", for: indexPath)\n\n            headerView.backgroundColor = .yellow\n            return headerView\n    })\n\n``\nwith no luck - am I getting closer?\nCheers. @srdanrasic yes, I've tried that too - that works. But not in combination withself.viewModel.contents.bind(to: self.collectionView!, using: MyBond())- when I addself.collectionView?.bnd_dataSource.forwardTo = self`, the first statement stops working for some reason.... @sveinhal alright so I actually ran into an interesting problem. I did it the way you described and I wouldn't get it to work. I couldn't figure out what it was and then I \"externalized\" the method into a separate object (NSObject to be assigned to the forwarding), which made it to work. \nWhen I implemented the method as you said (with the @objc) within UICollectionViewController it wouldn't work. I guess there is some internal machinery within UIKit that prevents this from working. Anyway - I got it to work, in case somebody else will try to solve the same issue, hopefully our discussion will be of any help. Thanks a lot again to both of you.. To give a complete example:\n\nThis is when it works:\n\n```\nclass EditTableViewController: UITableViewController {\nlet data = MutableObservableArray<String>([\"A\", \"B\", \"C\", \"D\", \"E\"])\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    self.tableView.setEditing(true, animated: false)\n}\n\noverride func didReceiveMemoryWarning() {\n    super.didReceiveMemoryWarning()\n}\n\n// MARK: - Table view data source\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"editCell\")!\n\n    cell.textLabel?.text = self.data[indexPath.row]\n    cell.showsReorderControl = true\n\n    return cell\n}\n\noverride func numberOfSections(in tableView: UITableView) -> Int {\n    return 1\n}\n\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return data.count\n}\n\noverride func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\n\noverride func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {\n    if editingStyle == .delete {\n        // Delete the row from the data source\n        tableView.deleteRows(at: [indexPath], with: .fade)\n    } else if editingStyle == .insert {\n        // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view\n    }    \n}\n\noverride func tableView(_ tableView: UITableView, moveRowAt fromIndexPath: IndexPath, to: IndexPath) {\n    self.data.moveItem(from: fromIndexPath.row, to: to.row)\n}\n\noverride func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\n\n}\n```\n\n\nThis when it doesn't work:\n```\nclass EditTableViewController: UITableViewController {\nlet data = MutableObservableArray([\"A\", \"B\", \"C\", \"D\", \"E\"])\noverride func viewDidLoad() {\n    super.viewDidLoad()\nself.data.bind(to: self.tableView) { conts, indexPath, tableView in\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"editCell\")!\n\n    cell.textLabel?.text = conts[indexPath.row]\n    cell.showsReorderControl = true\n\n    return cell\n}\n\nself.tableView.setEditing(true, animated: false)\n\n}\noverride func didReceiveMemoryWarning() {\n    super.didReceiveMemoryWarning()\n}\n// MARK: - Table view data source\noverride func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\noverride func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {\n    if editingStyle == .delete {\n        // Delete the row from the data source\n        tableView.deleteRows(at: [indexPath], with: .fade)\n    } else if editingStyle == .insert {\n        // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view\n    }  \n}\noverride func tableView(_ tableView: UITableView, moveRowAt fromIndexPath: IndexPath, to: IndexPath) {\n    self.data.moveItem(from: fromIndexPath.row, to: to.row)\n}\noverride func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\n}\n```. Thanks for quick answer @srdanrasic \n\n\nI just tried self.tableView.bnd_delegate.forwardTo = self (I'm on v5) right below defining the binding. It didn't help unfortunately.. Yes, I did that too, I'm sorry for not mentioning it. No change.. Thanks for the update :) however, when I do self.tableView.bnd_dataSource.forwardTo = self, it rewrites the binding, so it shows nothing at all. When I assign the bnd_delegate it's the same as before (no change).. Haha, that happens to all of us :) it works great now. Thank you for your time and quick action! Loving ReactiveKit + Bond so far!. Yeah, I'm already on Xcode 9.\n6.4.0 works great. Thanks a lot, you rock ;). ",
    "sveinhal": "You need to implement it like this:\nswift\n@objc(collectionView:viewForSupplementaryElementOfKind:atIndexPath:)\nfunc collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {\n    // ....\n}. ",
    "cowgp": "Nice! I new there had to be a trick!  thanks for pointing me in the right direction.\n. ",
    "markst": "Can I confirm bidirectionalBind is still not possible without the use of Observable properties?\nI'm using NSManagedObject subclass & this is the only way I seem to get it working:\nswift\nself.booking?.customer?.reactive.keyPath(\"otherNumber\", ofType: String.self, context: .immediateOnMain)\n    .bidirectionalMap(to: { (value) -> String in\n        return value\n    }) { (string) -> String in\n        return string!\n    }?\n    .bidirectionalBind(to: self.customerDetailsPanel.otherNumberField.reactive.text)\n. ",
    "Bubcho": "Thanks @CallumOz, you ended my day-and-a-half misery\n. Hello @srdanrasic,\nThank you for your reply. I tried forwarding the data source back to my view controller, but then my view controller needs to conform to UITableViewDataSource and implement tableView(_:numberOfRowsInSection) and tableView(_:cellForRowAt). These two methods are already handled by Bond, so how do I proceed in this case?. @srdanrasic, the strange thing is that I'm experiencing the opposite behavior - when I implement the method tableView(_:commit:forRowAt:) without conforming to the data source protocol, the method never gets called and I don't have swipe-to-delete. If I conform to the protocol and provide dummy implementations to the required methods, these methods actually get called and things mess up (I get a NSInternalInconsistencyException because the dummy tableView(_:numberOfRowsInSection:) method returns 0 and I'm adding to the observable array).\nDon't know if it's related, but I also forward the table view's delegate in this way to have a custom section header. And in the case of the delegate, it works by only providing the method implementation tableView(_:viewForHeaderInSection:), regardless of whether I conform to UITableViewDelegate or not.. @srdanrasic, indeed, you're right! I have spent a lot of time on this, but I haven't thought about using the ObjC name of the method. Thank you for your support and I also have to congratulate you on your beautiful and extremely useful framework. Have a great weekend! :-). ",
    "Calagahn": "You saved my week and the migration of my project from Swift 2.2 to 3.0! Thanks!\nFor posterity, I was struggling with the following build error in two different classes :\n<unknown>:0: error: unable to execute command: Segmentation fault: 11\n<unknown>:0: error: compile command failed due to signal (use -v to see invocation)\nInitializing the MutableObservableArray I was using in those classes was the key.... ",
    "smeis": "@CallumOz Thank you so much!. ",
    "santiagoprieto": "OMG. Savior of life.. ",
    "ghost": "+1 good to know!. Are there any updates on this? By the way. awesome library! \n. ",
    "JettF": "You are right! My apologies for opening an extra issue. Sadly, I don't have any suggestions yet, but I will give it some thought.\n. ",
    "enigma2006x": "The problem was in the CocoaPods master repo, I removed the master repo and clone again and now is working, thank you.. ",
    "jordancamara": "Yes, it's possible. There is a bnd_controlEvents property on UITextField that you can subscribe to different specific events. Here is some sample code\nyourTextField.bnd_controlEvents(.primaryActionTriggered).observeNext {\n                self.view.endEditing(true)\n                // necessary code here.\n }. That helps a lot.\nHow do you remove an binding on UITextField's bnd_controlEvents? I am needing to dynamically set this.. Nevermind. I think I found my own solution. Using dispose bags now. Thanks.. ",
    "RomanVolkov": "Great, thanks a lot. ",
    "iandundas": "(basically I used to pipe CollectionChangeset events through to be applied onto the collection, but the new ObservableArrayChange struct doesn't carry the collection as well so I guess it's impossible? \ud83d\ude14 ). Actually it was more ambitious than that - I'd built a lib (utilising CollectionProperty) to swap out different reactive collection providers on the fly (I have adapters for Realm's Result, NSFetchedResultsController and static arrays for now but it should be pluggable enough to work with anything that emits changesets), with CollectionProperty diffing the two collections and my lib then rebinding to the new provider. \nLibrary: https://github.com/iandundas/HotTakeCore\nDemo: https://github.com/iandundas/HotTakeDemo\nI understand the valid concerns about getting into invalid state using it as you described above, but for this particular usage it was working well (tests etc) and I've used it in a shipping app. \nI'm wondering where to go next r.e. adopting Swift 3 and upgrading to ReactiveKit 3 + Bond. I could port the existing CollectionProperty from ReactiveKit 2 to use 3.0 and get it to compile for Swift 3, but I think this could be a lot of work, and depends on the magnitude of the changes between 2.1 and 3.0 \ud83d\ude42 (which I've not checked fully yet)\nThe better alternative would be, as you suggested above, somehow surfacing the subject within Bond and going from there - do you think that could potentially be okay? \n\nThe ObservableArrayEvent still carries source array (i.e. a reference to it)\n\nah yeah! I had another look (it was midnight last night\ud83d\ude1b) - I'd thought there was only ObservableArrayChange, but yes ObservableArrayEvent is indeed perfect.\nCheers \ud83d\ude47\ud83c\udffb. Thanks a lot! Appreciate it.\nGoing camping now, back in a couple \u26fa\ufe0f\nOn 1 Dec 2016, 15:44 +0700, Sr\u0111an Ra\u0161i\u0107 notifications@github.com, wrote:\n\nSince you've put so much effort into that, let's work this issue out :)\nI'll need few days to find the best solution or at least make binding available again.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub (https://github.com/ReactiveKit/Bond/issues/335#issuecomment-264113157), or mute the thread (https://github.com/notifications/unsubscribe-auth/ABFFv0ZLxj7ZmGZh_Tck_IjUZWY35u6Mks5rDojfgaJpZM4LASoz).\n\n. Awesome!! Many thanks :) I'll check it out today . Apologies, you fixed it quickly but I haven't integrated it yet - will definitely do it tomorrow. Life has got in the way \ud83d\uddd3 cheers. The hard bit is mapping the ObservableArrayChange:\n```swift\nlet sorted = collection.map { (event: ObservableArrayEvent) -> ObservableArrayEvent in\nevent.dataSource.sorted(by: (String, String) -> Bool) // easy to sort\n\n// The hard bit: \nswitch event.change{\ncase .inserts([Int]):break;\ncase .deletes([Int]):break;\ncase .move(Int, Int):break;\ncase .updates([Int]): break;\n}\n\n}\n```\nTaking a look at the algorithm used in ReactiveKit 2 to see if I can do it . Here's my rather na\u00efve implementation:\n```swift\nextension ObservableArray where Item: Equatable {\npublic func sorted(by sorter: @escaping (Item, Item) -> Bool) -> Signal, NoError>{\n    return Signal { (observer: AtomicObserver, NoError>) -> Disposable in\n  let disposable = DisposeBag()\n  var differ: MutableObservableArray<Item>! // Stores a sorted version of the datasource, generates diff events\n\n  self.observeNext(with: { (latestUpdate: ObservableArrayEvent<Item>) in\n    let sorted = latestUpdate.dataSource.array.sorted(by: sorter)\n\n    if differ == nil {\n      differ = MutableObservableArray<Item>(latestUpdate.dataSource.array)\n      differ\n        // we don't want to pass on the first .reset event containing the unsorted array\n        .skip(first: 1)\n        // pass events from the differ to the signal observer:\n        .observeNext(with: observer.next).dispose(in: disposable)\n\n      // create our own .reset event instead, with the sorted array:\n      observer.next(ObservableArrayEvent(change: .reset, source: sorted))\n    }\n    else {\n      guard let differ = differ else {return}\n\n      // Replace contents of differ to generate diff event for observer:\n      differ.replace(with: sorted, performDiff: true)\n    }\n  }).dispose(in: disposable)\n\n  return disposable\n}\n\n}\n}\n```\nUsage:\n```swift\nlet collection = MutableObservableArray([])\nlet sorted: Signal, NoError> = collection.sorted { (a, b) -> Bool in\n    return a < b\n}\nsorted.observeNext { (event: ObservableArrayEvent) in\n    print(\"Received: (event.change), array: (event.dataSource.array)\")\nswitch event.change {\n    case .reset: fallthrough\n    case .endBatchEditing: print(\"\")\n    default: break\n}\n\n}\ncollection.append(10)\ncollection.append(3)\ncollection.append(2)\ncollection.append(1)\ncollection.moveItem(from: 0, to: 2)\ncollection.remove(at: 1)\ncollection.remove(at: 2)\n```\nOutputs:\nReceived: reset, array: []\n\nReceived: beginBatchEditing, array: []\nReceived: inserts([0]), array: [10]\nReceived: endBatchEditing, array: [10]\n\nReceived: beginBatchEditing, array: [10]\nReceived: inserts([0]), array: [3, 10]\nReceived: endBatchEditing, array: [3, 10]\n\nReceived: beginBatchEditing, array: [3, 10]\nReceived: inserts([0]), array: [2, 3, 10]\nReceived: endBatchEditing, array: [2, 3, 10]\n\nReceived: beginBatchEditing, array: [2, 3, 10]\nReceived: inserts([0]), array: [1, 2, 3, 10]\nReceived: endBatchEditing, array: [1, 2, 3, 10]\n\nReceived: beginBatchEditing, array: [1, 2, 3, 10]\nReceived: endBatchEditing, array: [1, 2, 3, 10]\n\nReceived: beginBatchEditing, array: [1, 2, 3, 10]\nReceived: deletes([1]), array: [1, 3, 10]\nReceived: endBatchEditing, array: [1, 3, 10]\n\nReceived: beginBatchEditing, array: [1, 3, 10]\nReceived: deletes([0]), array: [3, 10]\nReceived: endBatchEditing, array: [3, 10]\n\nWhereas the output if observing the collection (unsorted) directly is: \nReceived: reset, array: []\n\nReceived: inserts([0]), array: [10]\nReceived: inserts([1]), array: [10, 3]\nReceived: inserts([2]), array: [10, 3, 2]\nReceived: inserts([3]), array: [10, 3, 2, 1]\nReceived: move(0, 2), array: [3, 2, 10, 1]\nReceived: deletes([1]), array: [3, 10, 1]\nReceived: deletes([2]), array: [3, 10]\n\nSo the difference is an overuse of the begin/endBatchEditing (coming from the internal use of replace(with: sorted, performDiff: true)), but I can't see that doing much harm. In terms of performance it's probably not ideal I guess.\nWould you be interested in me submitting a pull request for this with tests, or is there another implementation path that could be better?. updated the above to make examples better. Cool \ud83d\udc4d\ud83c\udffb. Hey - did you have further ideas on this one?. hey @srdanrasic  no worries :) fingers crossed . . Sorry - this is on Bond v5.4.4 (latest).    Event: reset\n    Event: beginBatchEditing\n    Event: deletes([0])\n    Event: deletes([1])\n    Event: deletes([2])\n    Event: endBatchEditing\n\ud83d\ude4f\ud83c\udffc thanks!. Though a heads-up man, it's also there on master (i.e. Bond 6) \ud83d\ude14\nEvent: reset\nEvent: beginBatchEditing\nEvent: deletes([0])\nEvent: endBatchEditing. Hey again,\nThink there's still an issue, again caused by .filter, and in both 5 and 6: \n```swift\nlet collection = MutableObservableArray([])\ncollection.filter {_ in return true}.observeNext { (event) in\n    print(\"Event: (event.change)\")\n}\ncollection.replace(with: [\"hello\"], performDiff: true)\n```\nProduces: \nEvent: reset\nEvent: beginBatchEditing\nEvent: endBatchEditing\n\n. # \ud83d\udd75\ud83c\udffb\ud83d\udcab\ncool :). great work, thanks!!\n. SafePublishSubject can be used in the same way. This is in 6.0.0-beta.3. Wait you released 6.0 proper - I'll check with that  . Okay good to know - thanks! I've reworked what I was doing a bit to use bidirectional binding instead, and that works great. Cheers man.. Hey, I'm not sure about older versions of Bond, but to answer your question:\n.observe gives you Events, where Event is an enum defined as: \nswift\nenum Event<Element, Error> where Error : Error {\n    case next(Element)\n    case failed(Error)\n    case completed\n}\nSo Events can be .next(let value), .completed or .error(let error).\n.observeNext gives you just the .next case's value directly, and is just a convenience method really (you can also observeCompleted, for example).\n\nWhat I am trying to do is add an observer that will ignore any previous elements and only respond to new ones from the time the observer is added and I'm not seeing a way to do that\n\nBoth - in the general case - give you values from the time that you observe the signal, so this should be what you want. What kind of Signal type are you observing? You'd see different results from e.g. an ObservableArray or a ReplaySubject, perhaps.. off the top of my head you could try .skip(first:1), I think.. i.e. someProperty.skip(first:1).bind(to: self){...}. ",
    "mtaweel": "After taking a look on how you did it with MutableObservableArray, I've added the following to MutableObservable2DArray to support replace with diff, should I submit a pull request with this change? what do you think?\n```\nextension MutableObservable2DArray {\npublic func replaceSection(at index: Int, with section: Observable2DArraySection<SectionMetadata, Item>)  {\n    lock.lock(); defer { lock.unlock() }\n    sections[index] = section\n    subject.next(Observable2DArrayEvent(change: .updateSections([index]), source: self))\n}\n\n}\nextension MutableObservable2DArray where Item: Equatable {\npublic func replaceSection(at index: Int, with section: Observable2DArraySection<SectionMetadata, Item>, performDiff: Bool) {\n    if performDiff {\n        lock.lock()\n        let diff = Array.diff(sections[index].items, section.items)\n\n        var deletes: [Int] = []\n        var inserts: [Int] = []\n        deletes.reserveCapacity(diff.count)\n        inserts.reserveCapacity(diff.count)\n\n        for diffStep in diff {\n            switch diffStep {\n            case .insert(_, let index):\n                inserts.append(index)\n            case .delete(_, let index):\n                deletes.append(index)\n            }\n        }\n        let deletesIndexPaths = deletes.map { IndexPath(item: $0, section: index) }\n        let insertsIndexPaths = inserts.map { IndexPath(item: $0, section: index) }\n\n        subject.next(Observable2DArrayEvent(change: .beginBatchEditing, source: self))\n        sections[index].metadata = section.metadata\n        sections[index].items = section.items\n        subject.next(Observable2DArrayEvent(change: .deleteItems(deletesIndexPaths), source: self))\n        subject.next(Observable2DArrayEvent(change: .insertItems(insertsIndexPaths), source: self))\n        subject.next(Observable2DArrayEvent(change: .endBatchEditing, source: self))\n        lock.unlock()\n    } else {\n        replaceSection(at: index, with: section)\n    }\n}\n\npublic func replaceSection(at index: Int, with items: [Item], performDiff: Bool) {\n    replaceSection(at: index, with: Observable2DArraySection<SectionMetadata, Item>(metadata: sections[index].metadata, items: items), performDiff: performDiff)\n}\n\n}\n```. Done! https://github.com/ReactiveKit/Bond/pull/339. Thanks @srdanrasic. I applied your comments to the pull request . ",
    "garie": "Thanks! I updated and was able to remove my workarounds. I'll file another if I see similar issues with other arrays in the future.. I think I am seeing the crash as well. I updated to 6.2.5 this morning and get a crash when attempting to use dataSource. The crash goes away if I use 6.2.4 instead. \nStack trace:\n2017-04-26 10:05:25.634 Rounding[68667:553053] -[Bond.ProtocolProxy numberOfSectionsIn:]: unrecognized selector sent to instance 0x7bfd1e40\n2017-04-26 10:05:25.666 Rounding[68667:553053] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Bond.ProtocolProxy numberOfSectionsIn:]: unrecognized selector sent to instance 0x7bfd1e40'\n*** First throw call stack:\n(\n    0   CoreFoundation                      0x033e8494 __exceptionPreprocess + 180\n    1   libobjc.A.dylib                     0x02ea2e02 objc_exception_throw + 50\n    2   CoreFoundation                      0x033f2253 -[NSObject(NSObject) doesNotRecognizeSelector:] + 275\n    3   CoreFoundation                      0x0332789d ___forwarding___ + 1037\n    4   CoreFoundation                      0x0332746e _CF_forwarding_prep_0 + 14\n    5   RoundingView                        0x01dce7d7 _TFC12RoundingView11StackedViewP33_DFD35309960E46F800E54925B3B5150F13populateStackfT_T_ + 135\n    6   RoundingView                        0x01dceb72 _TFC12RoundingView11StackedView10reloadDatafT_T_ + 34\n    7   RoundingView                        0x01d7d2e3 _TFFe12RoundingViewRx11ReactiveKit14SignalProtocolwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS0_7NoErrorrS1_4binduRd__S_15StackedViewBondrFT2toCS_11StackedView5usingqd___PS0_10Disposable_U3_FQQPS1_7ElementT_ + 899\n    8   RoundingView                        0x01d7d827 _TPA__TFFe12RoundingViewRx11ReactiveKit14SignalProtocolwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS0_7NoErrorrS1_4binduRd__S_15StackedViewBondrFT2toCS_11StackedView5usingqd___PS0_10Disposable_U3_FQQPS1_7ElementT_ + 183\n    9   ReactiveKit                         0x026592b4 _TFFE11ReactiveKitPS_14SignalProtocol11observeNextFT4withFwx7ElementT__PS_10Disposable_U_FGOS_5EventQQPS0_7ElementQS4_5Error_T_ + 180\n    10  ReactiveKit                         0x0266adaf _TPA__TFFE11ReactiveKitPS_14SignalProtocol11observeNextFT4withFwx7ElementT__PS_10Disposable_U_FGOS_5EventQQPS0_7ElementQS4_5Error_T_ + 79\n    11  ReactiveKit                         0x02680087 _TFC11ReactiveKit14AtomicObserver2onfGOS_5Eventxq__T_ + 631\n    12  ReactiveKit                         0x02665b1b _TFFFFE11ReactiveKitPS_14SignalProtocol5delayFT8intervalSd2onCSo13DispatchQueue_GVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_U_FGOS_5EventS7_S8__T_U_FT_T_ + 251\n    13  ReactiveKit                         0x0267e360 _TPA__TFFFFE11ReactiveKitPS_14SignalProtocol9observeInFVS_16ExecutionContextGVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_U_FGOS_5EventS7_S8__T_U_FT_T_ + 80\n    14  ReactiveKit                         0x02690531 _TTSf4g___TFZFV11ReactiveKit16ExecutionContextg15immediateOnMainS0_U_FFT_T_T_ + 81\n    15  ReactiveKit                         0x0268fd49 _TFZFV11ReactiveKit16ExecutionContextg15immediateOnMainS0_U_FFT_T_T_ + 25\n    16  ReactiveKit                         0x02666f36 _TFFFE11ReactiveKitPS_14SignalProtocol9observeInFVS_16ExecutionContextGVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_U_FGOS_5EventS7_S8__T_ + 342\n    17  ReactiveKit                         0x0267e302 _TPA__TFFFe11ReactiveKitRxS_14SignalProtocolwx5ErrorzOS_7NoErrorrS0_6tryMapu0_Rd_0_s5ErrorrFFwx7ElementGOS_6Resultqd__qd_0__GVS_6Signalqd__qd_0__U_FGCS_14AtomicObserverQd__Qd_0__PS_10Disposable_U_FGOS_5EventQQPS0_7ElementS2__T__merged + 98\n    18  ReactiveKit                         0x0267e298 _TPA__TFFFE11ReactiveKitPS_14SignalProtocol9observeInFVS_16ExecutionContextGVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_U_FGOS_5EventS7_S8__T_ + 40\n    19  Bond                                0x0272c00e _TPA__TTRG0_rXFo_iGO11ReactiveKit5EventGV4Bond22Observable2DArrayEventxq__OS_7NoError___XFo_oGS0_GS2_xq__S3____ + 62\n    20  Bond                                0x0276a0d3 _TFC4Bond17Observable2DArray7observefT4withFGO11ReactiveKit5EventGVS_22Observable2DArrayEventxq__OS1_7NoError_T__PS1_10Disposable_ + 83\n    21  Bond                                0x02729696 _TTWu0_rGC4Bond17Observable2DArrayxq__11ReactiveKit14SignalProtocolS_FS2_7observefT4withFGOS1_5Eventwx7Elementwx5Error_T__PS1_10Disposable__merged + 102\n    22  Bond                                0x02727fdb _TTWu0_rGC4Bond17Observable2DArrayxq__11ReactiveKit14SignalProtocolS_FS2_7observefT4withFGOS1_5Eventwx7Elementwx5Error_T__PS1_10Disposable_ + 91\n    23  ReactiveKit                         0x02679b64 _TPA__TFFE11ReactiveKitPS_14SignalProtocol9observeInFVS_16ExecutionContextGVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable__merged + 196\n    24  ReactiveKit                         0x0266adfb _TPA__TFFE11ReactiveKitPS_14SignalProtocol9observeInFVS_16ExecutionContextGVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_ + 59\n    25  ReactiveKit                         0x02689604 _TFV11ReactiveKit6Signal7observefT4withFGOS_5Eventxq__T__PS_10Disposable_ + 340\n    26  ReactiveKit                         0x0264d6be _TTWu0_R_s5ErrorrGV11ReactiveKit6Signalxq__S0_14SignalProtocolS0_FS2_7observefT4withFGOS0_5Eventwx7Elementwx5Error_T__PS0_10Disposable_ + 94\n    27  ReactiveKit                         0x026594ef _TFE11ReactiveKitPS_14SignalProtocol11observeNextfT4withFwx7ElementT__PS_10Disposable__merged + 111\n    28  ReactiveKit                         0x02658a41 _TFE11ReactiveKitPS_14SignalProtocol11observeNextfT4withFwx7ElementT__PS_10Disposable_ + 81\n    29  RoundingView                        0x01d7bafe _TFe12RoundingViewRx11ReactiveKit14SignalProtocolwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS0_7NoErrorrS1_4binduRd__S_15StackedViewBondrfT2toCS_11StackedView5usingqd___PS0_10Disposable_ + 2926\n    30  RoundingView                        0x01e799cd _TFC12RoundingView30AuditRoundInstanceFindingsView7setDatafT4dataC17RoundingViewModel21FindingGroupViewModel10storyboardGSqCSo12UIStoryboard_15findingActivityCS1_24FindingViewModelActivity_T_ + 541\n    31  RoundingView                        0x01dd14c7 _TFC12RoundingView24FindingsGroupTableBonder10cellForRowfT2atV10Foundation9IndexPath9tableViewCSo11UITableView10dataSourcex_CSo15UITableViewCell + 615\n    32  RoundingView                        0x01dd239c _TTWuRx4Bond18DataSourceProtocolrGC12RoundingView24FindingsGroupTableBonderx_S1_21TableViewBondExtendedS1_FS3_10cellForRowfT2atV10Foundation9IndexPath9tableViewCSo11UITableView10dataSourcewx10DataSource_CSo15UITableViewCell + 76\n    33  RoundingView                        0x01deeaf8 _TFFe12RoundingViewRx11ReactiveKit14SignalProtocolwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS0_7NoErrorrS1_4binduRd__S_21TableViewBondExtendedwd__10DataSourcezWxS2_10DataSource_rFT2toCSo11UITableView5usingqd___PS0_10Disposable_U_FTGSqQQQPS1_7Element10DataSource_S10_CSo11NSIndexPath_CSo15UITableViewCell + 712\n    34  RoundingView                        0x01deec83 _TPA__TFFe12RoundingViewRx11ReactiveKit14SignalProtocolwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS0_7NoErrorrS1_4binduRd__S_21TableViewBondExtendedwd__10DataSourcezWxS2_10DataSource_rFT2toCSo11UITableView5usingqd___PS0_10Disposable_U_FTGSqQQQPS1_7Element10DataSource_S10_CSo11NSIndexPath_CSo15UITableViewCell + 163\n    35  RoundingView                        0x01deece4 _TTRG__Rx11ReactiveKit14SignalProtocold__12RoundingView21TableViewBondExtendedwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS_7NoErrorwd__10DataSourcezWxS3_10DataSource_rXFo_iGSqWxS3_S9___oCSo11UITableViewoCSo11NSIndexPath_oCSo15UITableViewCell_XFo_iGSqWxS3_S9___iS10_iS11__iS12__ + 84\n    36  RoundingView                        0x01deee1c _TPA__TTRG__Rx11ReactiveKit14SignalProtocold__12RoundingView21TableViewBondExtendedwx7Element4Bond23DataSourceEventProtocolwx5ErrorzOS_7NoErrorwd__10DataSourcezWxS3_10DataSource_rXFo_iGSqWxS3_S9___oCSo11UITableViewoCSo11NSIndexPath_oCSo15UITableViewCell_XFo_iGSqWxS3_S9___iS10_iS11__iS12__ + 188\n    37  Bond                                0x0275081d _TPA__TFFC4Bond13ProtocolProxy4feedu2_rFT8propertyGC11ReactiveKit8Propertyx_2toV10ObjectiveC8Selector3mapFTxq_q0__q1__PS1_10Disposable_U_FTGCS1_14PublishSubjectT_OS1_7NoError_Q0_Q1__Q2_ + 157\n    38  Bond                                0x0275833f _TPA__TFFFC4Bond13ProtocolProxy6signalu2_rFT3forV10ObjectiveC8Selector8dispatchFTGC11ReactiveKit14PublishSubjectq0_OS3_7NoError_xq__q1__GVS3_6Signalq0_S5__U_FGS4_Q1_S5__PS3_10Disposable_U_FTQ_Q0__Q2_ + 79\n    39  Bond                                0x0274e59f _TFFC4Bond13ProtocolProxyP33_23028F409340362020B24E8EAAA251BA15registerInvokeru1_rFT3forV10ObjectiveC8Selector5blockFTxq__q0__P11ReactiveKit10Disposable_U_FTFTSiGSqSv__T_GSqFGSqSv_T___T_ + 319\n    40  Bond                                0x02757bf1 _TPA__TFFC4Bond13ProtocolProxyP33_23028F409340362020B24E8EAAA251BA15registerInvokeru1_rFT3forV10ObjectiveC8Selector5blockFTxq__q0__P11ReactiveKit10Disposable_U_FTFTSiGSqSv__T_GSqFGSqSv_T___T_ + 113\n    41  Bond                                0x02757ca6 _TPA__TTRG1_rXFo_oXFo_dSidGSqSv___oGSqFGSqSv_T____XFo_iTXFo_iTSiGSqSv___iT__GSqFGSqSv_T____iT__ + 166\n    42  Bond                                0x02754fb2 _TTSf4n_g_g_n___TFC4Bond13ProtocolProxy6invokefT4withV10ObjectiveC8Selector17argumentExtractorFTSiGSqSv__T_14setReturnValueGSqFGSqSv_T___T_ + 546\n    43  Bond                                0x0274dd1e _TToFC4Bond13ProtocolProxy6invokefT4withV10ObjectiveC8Selector17argumentExtractorFTSiGSqSv__T_14setReturnValueGSqFGSqSv_T___T_ + 238\n    44  Bond                                0x0271d8a9 -[BNDProtocolProxyBase forwardInvocation:] + 333\n    45  CoreFoundation                      0x03327668 ___forwarding___ + 472\n    46  CoreFoundation                      0x0332746e _CF_forwarding_prep_0 + 14\n    47  UIKit                               0x00484934 -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 822\n    48  UIKit                               0x00484a7d -[UITableView _createPreparedCellForGlobalRow:willDisplay:] + 90\n    49  UIKit                               0x00454b32 -[UITableView _updateVisibleCellsNow:isRecursive:] + 3347\n    50  UIKit                               0x00473416 __29-[UITableView layoutSubviews]_block_invoke + 52\n    51  UIKit                               0x0048e6cc -[UITableView _performWithCachedTraitCollection:] + 88\n    52  UIKit                               0x004732eb -[UITableView layoutSubviews] + 214\n    53  UIKit                               0x003c93d4 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 810\n    54  libobjc.A.dylib                     0x02eb7059 -[NSObject performSelector:withObject:] + 70\n    55  QuartzCore                          0x08e3f096 -[CALayer layoutSublayers] + 144\n    56  QuartzCore                          0x08e328b6 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 388\n    57  QuartzCore                          0x08e415b0 -[CALayer(CALayerPrivate) layoutBelowIfNeeded] + 44\n    58  UIKit                               0x003b6ba4 -[UIView(Hierarchy) layoutBelowIfNeeded] + 1258\n    59  UIKit                               0x003b66a6 -[UIView(Hierarchy) layoutIfNeeded] + 82\n    60  RoundingView                        0x01d64e39 _TFE12RoundingViewCSo11UITableView15reloadTableviewfT_T_ + 249\n    61  RoundingView                        0x01d64f32 _TToFE12RoundingViewCSo11UITableView15reloadTableviewfT_T_ + 34\n    62  RoundingView                        0x01dd193e _TFFC12RoundingView24FindingsGroupTableBonder10cellForRowFT2atV10Foundation9IndexPath9tableViewCSo11UITableView10dataSourcex_CSo15UITableViewCellU_FGV4Bond22Observable2DArrayEventC17RoundingViewModel31QuestionAnswerFindingsViewModelCS7_16FindingViewModel_T_ + 302\n    63  RoundingView                        0x01dd1b90 _TPA__TFFC12RoundingView24FindingsGroupTableBonder10cellForRowFT2atV10Foundation9IndexPath9tableViewCSo11UITableView10dataSourcex_CSo15UITableViewCellU_FGV4Bond22Observable2DArrayEventC17RoundingViewModel31QuestionAnswerFindingsViewModelCS7_16FindingViewModel_T_ + 64\n    64  RoundingView                        0x01dd1be7 _TTRGRx4Bond18DataSourceProtocolrXFo_oGVS_22Observable2DArrayEventC17RoundingViewModel31QuestionAnswerFindingsViewModelCS2_16FindingViewModel___XFo_iGS1_S3_S4____ + 71\n    65  RoundingView                        0x01dd1ca7 _TPA__TTRGRx4Bond18DataSourceProtocolrXFo_oGVS_22Observable2DArrayEventC17RoundingViewModel31QuestionAnswerFindingsViewModelCS2_16FindingViewModel___XFo_iGS1_S3_S4____ + 103\n    66  ReactiveKit                         0x026592b4 _TFFE11ReactiveKitPS_14SignalProtocol11observeNextFT4withFwx7ElementT__PS_10Disposable_U_FGOS_5EventQQPS0_7ElementQS4_5Error_T_ + 180\n    67  ReactiveKit                         0x0266adaf _TPA__TFFE11ReactiveKitPS_14SignalProtocol11observeNextFT4withFwx7ElementT__PS_10Disposable_U_FGOS_5EventQQPS0_7ElementQS4_5Error_T_ + 79\n    68  ReactiveKit                         0x02680087 _TFC11ReactiveKit14AtomicObserver2onfGOS_5Eventxq__T_ + 631\n    69  ReactiveKit                         0x02665b1b _TFFFFE11ReactiveKitPS_14SignalProtocol5delayFT8intervalSd2onCSo13DispatchQueue_GVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_U_FGOS_5EventS7_S8__T_U_FT_T_ + 251\n    70  ReactiveKit                         0x0267e360 _TPA__TFFFFE11ReactiveKitPS_14SignalProtocol9observeInFVS_16ExecutionContextGVS_6Signalwx7Elementwx5Error_U_FGCS_14AtomicObserverQQPS0_7ElementQS6_5Error_PS_10Disposable_U_FGOS_5EventS7_S8__T_U_FT_T_ + 80\n    71  ReactiveKit                         0x0268fd7e _TTRXFo___XFdCb___ + 30\n    72  libdispatch.dylib                   0x04ed29e3 _dispatch_call_block_and_release + 15\n    73  libdispatch.dylib                   0x04ef06ed _dispatch_client_callout + 14\n    74  libdispatch.dylib                   0x04ed9286 _dispatch_main_queue_callback_4CF + 689\n    75  CoreFoundation                      0x033321be __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 14\n    76  CoreFoundation                      0x032f0434 __CFRunLoopRun + 2356\n    77  CoreFoundation                      0x032ef846 CFRunLoopRunSpecific + 470\n    78  CoreFoundation                      0x032ef65b CFRunLoopRunInMode + 123\n    79  GraphicsServices                    0x08ce9664 GSEventRunModal + 192\n    80  GraphicsServices                    0x08ce94a1 GSEventRun + 104\n    81  UIKit                               0x002f8eb9 UIApplicationMain + 160\n    82  Rounding                            0x00058bf1 main + 145\n    83  libdyld.dylib                       0x04f15a25 start + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\nnumberOfSectionsIn is using feed as follows:\nstackedView.reactive.dataSource.feed(\n            property: dataSource,\n            to: #selector(StackedViewDataSource.numberOfSections(in:)),\n            map: { (dataSource: DataSource?, _: StackedView) -> Int in\n                dataSource?.numberOfSections ?? 0\n        })\nWhen updating to 6.2.5, I added the result of feed to my CompositeDisposable.\nI can try to come up with some example code that reproduces the issue if you need it.. I can confirm the app no longer crashes. I can't speak to the original issue, though, because I don't really understand the symptoms. Thanks!. ",
    "drw86312": "Awesome! Thanks for the help.. ",
    "Bargetor": "\nthe prevEvent.source and newEvent.source is same instance, I still can't to know. ",
    "wokalski": "I think I know what's the problem... The 0.4.1 tag doesn't contain the Podfile. \nI added it after @tonyarnold added a tag. Since he has push access to the repo, feel free to resolve the issue. (probably by adding another dummy version with a Podfile contained in a release \ud83d\ude44). It's weird though because cocoa pods does some validation before adding a spec.. Also, I haven't used cocoapods in years but I believe there's --verbose option which might be helpful. . No worries. I also forgot about it when I released 0.4. . I've just pushed the podspec. Everything should work now.. Cocoapods doesn't accept dots /shrug. . ",
    "cre8it": "Never mind, the error came because I declared my Bool as optional in my ViewModel... problem solved. @srdanrasic thanks for that hint, I will certainly keep it mind for cases where I need to have optionals ... great! Thanks . ",
    "kaszasdavid": "Thanks, will do.\nI think it was supported before Swift 3, that's why I was confused.. ",
    "DaichiSaito": "sorry...\nI forgot to add import ReactiveKit. ",
    "hitendradeveloper": "@srdanrasic Thanks a lot for your valuable response.\nIt's worked \ud83d\udcaf  . ",
    "tomaz": "Didn't check UITableView in latest codebase as UIKit bindings were somewhat different from AppKit in 5.x. But it's important to keep stuff as similar as possible, so sure, will check tonight and see what I can come up with!. Indeed, I'll include this in any change I make. @srdanrasic Refactored, it now uses same approach as UITableView - I like it much more than my previous attempt, thanks for tip!\nTried to keep it as close as possible to UITableView implementation, though had to extend it a little in order to support animations on NSTableView, at least until Apple adds support for auto-layout based cell heights as there is in UIKit - for which I'm not holding my breath :/\n\n\nChanged default builtin bond to actually animate when animated is true - this will alter all existing users, so I was hesitant, but ultimately it felt worse to have animated: true and then not have any animations... This could be compensated by changing default animated value to false - then users won't notice any difference behavior wise (unless they explicitly set animated to true, but in this case I'd assume they do want to see animations \ud83d\ude04 Besides, I bet AppKit users are far less in number than UIKit, so it likely won't affect many \ud83d\ude05\n\n\nDefault apply function implementation can swap between animated or not based on configuration (if both animation options are nil, it will simply do reloadData). This makes it much simpler to for example prevent animations when replacing the whole array (i.e. master controller selection changes), but allow it when inserting/deleting rows. As this is quite common, I felt it's best to allow this out of the box. Although I might be confused in difference between MutableObservableArray.replace(with:) and replace(with:performDiff:) - are animations only supposed to happen when performDiff: is true? As far as I tested, individual insertion/deletion events were still posted even when using replace(with:) so assumed it's bond implementation that ultimately decides about it...\n\n\nDidn't find any better spot for adding updating property, so implemented it as associated object on table view - it has to live outside apply lifetime. Perhaps naming isn't the best in this case - I'd suggest adding prefix which is still encouraged for ObjC class extensions, even in Swift (bond_updating?).\n\n\nKept the same name for bond as for UITableView - they live in different frameworks so there's no name clash. \n\n\nAnyways, let me how you feel about this and if you want additional changes. (I'll cleanup commits once it's ready for merge).\nCheers!. Allright, I think this should be done as agreed: default bond is now class, so it can use updating property directly without any ObjectiveC runtime shenanigans...\nStill left default apply implementation, though now it just reloads data - it's simpler to adopt protocol and have working solution out of the box. And because animations are now specific to default bond, moved them out of protocol too - no need to pollute namespace anymore.\nAnd no worries, it's nice to contribute back to community \ud83d\ude04 Definitely let me know if anything else catches your eye - now's the time. Besides, I always appreciate constructive \"critique\".. Thanks!. Yup, sounds sane, was thinking of this solution, but protocol with default implementation in extension was way nicer to implement in custom implementations. Will look into it later today. ",
    "arasu01": "Where there nothing related lift in the readme. Then how can I blindly check it? Since I'm new to this library.. Thanks. Got it.. ",
    "slavikus": "I'll watch this ticket as I'd love to see sortable arrays as well :). @srdanrasic @tonyarnold your magic is needed! :)). ",
    "aleos": "Here is an example:\nvar bnd_lastDeal = EventProducer<Deal>()\nbnd_lastDeal.next(deal)\nbnd_lastDeal.observe { (deal) in\n    ...\n}\nbnd_lastDeal.bind(to: view.bnd_lastDeal) // signal only new values. @iandundas , @srdanrasic Thank you very much! It is great!. ",
    "SPopenko": "@srdanrasic thank you for your quick reply. I would agree :) \n. ",
    "DimaVartanian": "Hi, thanks for the response! I actually just tested this and it is not exactly the case. To summarize, when you add an observer to a normal observable/property, by default the block will fire once immediately using the last value from the observable. As such, just doing skip(first: 1) does the trick here by ignoring just that existing value and firing for everything going forward. In any case, thanks for the help! I consider this closed now.. ",
    "Burtan": "Nevermind, I just found the solution my self.\nlet _ = dbObject.variable.observeNext { [weak self] variable in\n    if (1 == 0) {\n        print(self?.x)\n    }\n}\n. Thanks for the info! Pretty annoying bug, took me some time to find out. Maybe you could add a hint into the documentation until it is fixed.. Nope, not yet. Maybe it's fixed. Good to know :-). Anyway thanks for the fast response!. Thanks for the fast response, I understand. . Thanks for the suggestion. I've read parts of your documentation and came to two results. The merge approach is very useful when observing a class that is static about its Observables, e.g. does not add or remove them dynamically. The class can create a \"classObservable\" on construction that makes all events observable. This can be done by custom code or recursively analyzing the class for Observables using reflection. Something like this:\n```\nprotocol ClassObservableProtocol {\nvar classObservable: Signal<Void, NoError>? {get set}\n\n}\nextension ClassObservableProtocol {\nfunc getClassObservableRecursively(ignoreClasses types: [Any.Type]) -> Signal<Void, NoError>? {\n    let mirror = Mirror(reflecting: self)\n    var classNames = Swift.Set<String>()\n    for type in types {\n        classNames.insert(String(describing: type))\n    }\n    return getClassObservable(ignoreClasses: classNames, mirror, self)\n}\n\nfileprivate func getClassObservable(ignoreClasses classes: Swift.Set<String>, _ mirror: Mirror, _ object: Any)\n                -> Signal<Void, NoError>? {\n\n    //ignore objects that are marked to be ignored\n    if classes.contains(String(describing: mirror.subjectType)) {\n        return nil\n    }\n\n    var optSignal: Signal<Void, NoError>?\n\n    //loop through superclasses\n    if let superclassMirror = mirror.superclassMirror {\n        optSignal = getClassObservable(ignoreClasses: classes, superclassMirror, object)\n    }\n\n    //loop through properties\n    for child in mirror.children {\n        //loop through property properties\n        let childMirror = Mirror(reflecting: child.value)\n        optSignal = saveMerge([optSignal, getClassObservable(ignoreClasses: classes, childMirror, child.value)])\n    }\n\n    //TODO check if object is Observable\n    if let observable = object as? Observable<String> {\n        optSignal = saveMerge([optSignal, observable.eraseType()])\n    }\n\n    return optSignal\n}\n\nfileprivate func saveMerge(_ optSignals: [Signal<Void, NoError>?]) -> Signal<Void, NoError>? {\n    var signals = [Signal<Void, NoError>]()\n    for optSignal in optSignals {\n        if let signal = optSignal {\n            signals.append(signal)\n        }\n    }\n    if signals.isEmpty {\n        return nil\n    }\n    if signals.count == 1 {\n        return signals.first\n    }\n    return merge(signals)\n}\n\n}\n```\nThe second approach would be using a Subject as a classObserver to dynamically inform it when Observables send events.. ",
    "mkalinowski": "@alistra: The following code works:\nlet names = ObservableArray([\"Steve\", \"Tim\"])\nlet nameLengths = MutableObservableArray<Int>()\nnames.map { $0.characters.count }.bind(to: nameLengths). ",
    "softvision-catalinmustata": "So... what happened to shouldReloadInsteadOfUpdateTableView? I'm trying to migrate a older project that was using Bond 4.x to 6.x and Swift 3 and I cannot find any reference on where this got moved (or if it's needed anymore). Ah, I understand the connection. However, \npublic func bind<B : TableViewBond where B.DataSource == DataSource>(to tableView: UITableView, using bond: B) -> Disposable\ndoes not have an animated property (TableViewBond) doesn't seem to have one either\n. Yes, I noticed that one, but I need to use the second function, that receives a TableViewBond object and doesn't have the animated property.. Yes, there's one place that needs a custom implementation. However the old method returned false, so I'd assume I need to work with beginUpdate and endUpdates instead of reloadData(). Yes, it looks like that. I'm working on migrating this older project that wasn't developed by me and I'm still trying to get a grip on the whole logic. \nI'll try to move everything towards an Observable2DArray. However, I'm a bit confused as to why ObservableArrays do not work for this, as they do implement DataSourceProtocol, which has both numberOfItems(inSection:) and numberOfSections.. ",
    "lucianomarisi": "cool, literally just tried that and it works, thanks\nswift\nsomeProperty.skip(first: 1).bind(to: self) { this, someProperty in\n    // Only call this when someProperty changes, not on setting up the binding\n}. Thanks, very elegant solution, and I can say today I learned about the UIAccessibilityIdentification protocol!. ",
    "timothyarmes": "Thank you, that worked.\nI think the README documentation needs updating, since all the examples use UITextField's text property directly. It's not obvious that the same approach isn't used for NSTextField.\n. Ah yes, I should have thought of binding. Thanks.. ",
    "alistra": "From what I understand the bind method has an ExecutionContext parameter, so it shouldn't be needed to use the ImmediateOnMainExecutionContext there.. Really awesome changes!\nI would narrow down the compliance to BindingExecutionContextProvider to UIView and UIViewController (or all base UIKit classes for which it makes sense), because currently you can't override the conformance to something deriving from NSObject\nI'm trying to do something like this, but it errors out on not being able to override it.\nThe errors say \"Overriding non-open var outside its defining module\" and \n\"Declarations in extensions cannot override yet\"\nextension NSManagedObject {\n    override var bindingExecutionContext: ExecutionContext {\n        return (managedObjectContext?.perform).flatMap { ExecutionContext($0) } ?? .immediate\n    }\n}\nI think just changing it to open won't work, as the second error says you can't override from an extension.. ",
    "willjstevens": "Hi @pki , would you be willing to post the portions of code relevant to your tableview setup with Bond?  I am trying to do similar but struggling, after following the documentation and table view unit test. \nI also posted on SOF: http://stackoverflow.com/questions/43150045/reactivekit-bond-uitableview-not-updating  . ",
    "pixelrevision": "This looks like an issue with the dependency on ReactiveKit.  Initially I was able to create a cocoapods project and it pulled ReactiveKit (3.1.1) and things worked fine.  After updating my pod repos it started using ReactiveKit (3.5.1) which emits the same issue.\nNote this only happens on 5.x not 6.\n. ",
    "natalia-osa": "@srdanrasic Thank you for awesome & fast support! Version 5.4.8 works perfectly, issue cannot be reproduced any more.. ",
    "nabileisa": "Hi, I have the same problem , tested with brand new project and default configuration using  .\n CocoaPods version 1.2.0 & xcode 8.3  and pod 'Bond'. Hi @srdanrasic \nI have attached an Example project in the following link , this a simple project with just Bond installed and nothing else , and the build fails with the error posted in the original issue.\nbondapp.zip\nhope it helps, and if I'm doing something wrong please let me know .. Tested with 6.2.4 and i can confirm now that the build succeeds and the issue is resolved, thank you for the great work .. ",
    "omerCoosto": "Any news about this feature? is it planned?. Thanks for the quick reply.\nIt works well!. still no way for now as i understand from the #539? :S. ",
    "frederic-c-dcode": "Great answer. Works fine\u00a0!\nThank you @srdanrasic\u00a0!. ",
    "bmetitiri": "So after examining the code and documentation again, I see that the numberOfItems(inSection:) hook up comes from a call to reactive.dataSource.feed, and the docs mention that \n\nYou should not set more that one feed property per selector. \n\nI assume that's what I'm running up against? Is the expected use case that a UICollectionView or UITableView only ever has one array bound to it during it's lifecycle? . Hmm, after updating, the same code is giving me a crash after calling bind on a collection view that has been reused. . ",
    "Art3mS1d": "Hi. Original issue still not fixed. I can't rebind collectionView to another array, it still uses the first one.. Currently, I found only one way to reset dataSource's protocolProxy and it is bad way cause it can break something else. But it works:\nobjc_removeAssociatedObjects(collectionView)\n. ",
    "grzegorzkrukowski": "Thanks for the quick solution ! Really helpful stuff.\nI totally understand the problem of changing functionality for existing methods.\nWould be great to have unique() as part of framework I'm sure about it.\nI trust you are gonna pick the best solution to sort this problem out.\nFor now I'm happy to use extension outside framework.. Try adding this in your pod file - that will make sure you have Swift 4 correctly set on your pod:\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        if\n            target.name == \u2018Bond\u2019\n            target.build_configurations.each do |config|\n                config.build_settings[\u2018SWIFT_VERSION\u2019] = \u20184.0\u2019\n            end\n        end\n    end\nend. ",
    "mkeiser": "I have the same issue. Is there a solution for this?. ",
    "daviskoh": "any updates?. any updates?. just realized...it has to do w/ type safety and how UITextView & UITextField require Strings\ntry converting the Int to a String 1st or map it like so:\nobservableInt.map({ \"\\($0)\" }).bind(to: textView2). im seeing something similar when using Cocoapods as well. ",
    "asen-oit": "How to do bidirectionalBind from a Int property in model to UITextFiled?. ",
    "igorleonovich": "@srdanrasic Thanks a lot! I'll consider this way.. ",
    "doradsoft": "I had to install macOS Sierra in order to use the latest Xcode 8.3.2 So it took a little time. It works now.\nThanks!\n\u05d1\u05ea\u05d0\u05e8\u05d9\u05da 4 \u05d1\u05d9\u05d5\u05e0' 2017 2:11 PM,\u200f \"Sr\u0111an Ra\u0161i\u0107\" notifications@github.com \u05db\u05ea\u05d1:\n\nThat's really strange that you'd get such an error. Are you using latest\nXcode with the default toolchain?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveKit/Bond/issues/424#issuecomment-306033633,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFVs1JbBfWQ4C-q_LjvBbXC1KjPXd3WPks5sApDmgaJpZM4NvK_P\n.\n. You might chose a specific use case of computed observable and demonstrated the implementation. However, ComputedObservable is a wider component.\nAdditionally, i think that the implementation is really not intuitive. Anyway thanks.. \n",
    "fruitcoder": "Thanks so much for looking into this!. Awesome @srdanrasic \ud83d\udc4d . ",
    "pvegh": "A feature branch with the rename quickfix would keep us bleeding edge users floating. Using that quickfix branch with Cocoapods is easy, wouldn't have to be necessarily integrated to any future version.\nJust an idea if you find the time to implement it.\nOf course anyone can do this in their own fork.. ",
    "codedbypm": "The same issue happens when compiling with XCode 9 (b6) and Swift 3.2. Is that normal? . Having the same issue with XCode 9 beta 6 and Cocoapods. \n\nThe problem will be solved by the time Xcode 9 is out of beta.\n\nIf the issue is cocoapods related, how certain is your statement?. What about as a temporary fix a guard in _swizzleDeinit(:)? \nguard let selector = sel_registerName(\"dealloc\") else {\n    return\n}\nIsn't safe to assume that the call to sel_registerName will never return an optional?. I think I hit the same issue when handling NSRange types in UITextViewDelegate's method textView(_:shouldInteractWith:in:interaction:). Any clue?. ",
    "Myryx": "Just bumped into it. @srdanrasic is there something we can do about it? It's a stopper, unfortunately :(\nIt seems like it interferes with some Apple's internal APIs so it won't use Bonds bind method. How come no one talks about this issue? It basically prohibits you from implementing all the additional DataSourse methods. ",
    "rlmartin": "This has to do with Whole Module Optimization being turned on in the Build Settings for the Bond Pod. Though this isn't necessarily recommended, you can get around this by going to Pods, choosing the Bond target, then Build Settings => Swift Compiler - Code Generation => Optimization Level => Release and changing it to Fast [-O] or None [-Onone].\nThere must be some other class in a different file that the compiler is combining/optimizing with the ObservableArray class and causing this error. If you drill down on the error, is says Multiple matching types named 'Element' and lists two, one in this file and one that is missing. I think the key to fixing this is to identify that missing matching type and disambiguating it enough from the ObservableArray class such that the compiler doesn't optimize it and combine the two classes.\nUnfortunately I don't know enough about generics in Swift to be able to resolve this right now.. ",
    "SeanRobinson159": "I'm having the same issue.\nXcode 9, Swift 4, and Carthage.\nBond v6.4.2\nRunning this stackoverflow answer works, but it has to be done every time you run carthage --update\nhttps://stackoverflow.com/a/46226810. ",
    "kaishin": "I am in a similar situation. I made it to work in 6, but I am struggling a bit to do so with my view-based NSTableView in 7-beta. Specifically, I am not sure what's the rationale behind the changes and the recommended way of using TableViewBinderDataSource (subclassing, extending, etc). I'd be happy to open PRs and add missing functionality, but I can't do so without more understanding of the reason behind these changes in 7.. I am dealing with the same problem. I believe createCell was removed from the API, so I opened https://github.com/DeclarativeHub/Bond/pull/576 to remove it. That said I have no further knowledge about the circumstances and of its removal nor the roadmap of the library.. ",
    "aregler": "Hi @srdanrasic. You were totally right. \ud83d\ude05\nThank you very much for all your work!. Hey @srdanrasic. Unfortunately I have been glad too early \ud83d\ude06\nThe problem still exists, but at this point i am not sure if this should concern you.\nI'll reopen this issue, but if you think it's too much related to ASDK then just close this issue.\nThanks anyway \ud83d\ude0a. ",
    "limeytrader007": "Any luck on this? I'm facing a similar issue that I put on the 'Issues' tab when upgrading to XCode 9. . Check my post (it's the one above yours in the Issues tab). Developer is saying to switch to swift-4 branch but I'm unsure how to add Bonds to my project since I did it with CocoaPods. . Hey DarkByte. Check my post again, owner responded. Thanks!. Similar issue.. looking into it now...\n\n. yeah I think you're right. Do you have a link to that page? I remember hearing about it but can't find it. Thanks!. Lemme try it. Thanks boss!\n. How do I install from your Swift 4 branch if Bond was initially installed with Cocoapods a few months back? Thanks!. You ROCK!!! Thank you so much sir!. @srdanrasic Now having this sir...\n\n. ",
    "DarkByte": "No luck so far, as I was busy switching between branches for preparing a release build (using the old Swift 2.3 code). If I find something, I'll be sure to post it here - please do the same :)\nGood luck!. ",
    "DarkByte3PG": "Thanks, @limeytrader007 , I'll try that.. @limeytrader007 @srdanrasic : I'm still having a problem with using the swift-4 branch, as illustrated in the attached screenshot.\nJust a reminder: I am using Xcode 8.2.1 (working on converting the project to Swift 3).\n\n. bnd_text? I think you should replace that with \"reactive.text\", since Bond v6.. You can find this on the main page of Bond (readme.md)\n\n. Reminder:\n@limeytrader007 @srdanrasic : I'm still having a problem with using the swift-4 branch, as illustrated in the attached screenshot - using Xcode 8.2.1 (working on converting the project to Swift 3).\n\n. I'm integrating it via cocoapods, if that's what you mean.. ",
    "marclove": "I'm encountering the same problem with index(of:), though I suspect it's the same root cause: attempting to iterate over elements in sections using subscripts, starting with an index of 0, without first checking if the section is empty.. @srdanrasic does this mean Bond won't be supported on Xcode 9 with Swift 3.2? My project is stuck at 3.2 for reasons outside my control and Xcode 9 is becoming necessary due to iPhone X.. ",
    "Maxatma": "Any example? Example's selectedRow method and feed to numberOfRowsInSection isn't so clearly to understand how to bind uiviews to tableView:viewForHeaderInSection: method.\nShould I have Propery<Array<UIView>> and feed them into selector signal how to be with indexes? \n. @dcrobert  so how to do that ?. @dcrobert thanks, for example. But, I guess this is nothing about reactive delegates, mentioned by @srdanrasic. . @lucasPelizza \n Bond isn't a Signal or a Producer. So u can't observe it. But u can bind to it. \nSomething like that: \nvc has a button:\n@IBOutlet weak var button: UIButton!\nvm has Observable:\nlet highlighted                 = Observable<Bool>(true)\nvm.highlighted.bind(to: button.reactive.isHighlighted)\nso if u need change ur button highlights u do in vm: \nhighlighted.next(false)\nI'm not sure about previous versions, was a button.isHighlighted available to observe? . Well, you can't append(contentsOF: ) \nAnd Is there any difference? I can't insert in .endIndex ?\nI checked, it crash with append too.\nVerified, it use Bond's removeAll()\n. @srdanrasic Yes, sure. Still a bit complicated to understand what I'm doing wrong.\nShould I init AttachmentsBinder with createCell? . @srdanrasic Thanks!\nHow about header/footer implementation in TableViewBinder?\nThere is no analog for this function in TableViewBinder, as I can see :\n  func titleForHeader(in section: Int, dataSource: Observable2DArray<String, AttachmentCellVM>) -> String? {\n        return dataSource[section].metadata\n    }\n. I forgot to say, this is what u have in your documentation.. If u gonna rewrite some vms to use Bond, why cant u rewrite it using Swift?. It is not clear enough what do you mean saying \"my app was not working properly\". \nSometimes u have to use it skip first 'some number of' fired event. So it does exactly what its name says. . @srdanrasic would be nice to have this in readme :). Seems like \nlet stringSubject = SafePublishSubject<String>()\n    let voidSubject = SafePublishSubject<Void>()\n(subjects with different Element)\nare also impossible to combine.\nIs it expected behaviour? \n. @srdanrasic It's simple, I want to get 3 types of evens independently , 2 of them just make request, 3rd makes request with value in produced. \nI can't use combineLatest, coz i want them to work independently. \nSee the difference between merge and combineLatest:\nhttps://rxmarbles.com/ . @srdanrasic oh, i see, it work exaclty like on marbles. \nSure i can use some workaround code to achieve my needs, but I dont understand why two similar operators work so differently: there is not only difference that they produce events in different manner (merge in any of observed  event, combineLatest in case all appears first and the on every next even)   , but they first produce _ ,_ , _ and merge only _\nI think should exist merge analog which produce every value _ ,_ , _ on any event. . ",
    "dcrobert": "Depending on the use case, you could add section metadata for the sections and then load a custom view based on that metadata. . Something like this may work.... \n```swift\n// Code In ViewModel or elsewhere\ntypealias MonthSectionMetadata = (date: Date)\ntypealias MonthSection = Observable2DArraySection\ntypealias MonthSectionArray = MutableObservable2DArray\n// Map your date items grouped by month and set their metadata\n.map { MonthSection(metadata: (date: $0.0), items: $0.1) }\n// then in your tableview do something like this. This isn't necessarily the method, just an example of how to check the metadata\nfunc tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {\n  if let view = view as? MonthHeaderView {\n    let metadata = viewModel.months[section].metadata\n    if metadata.date = \"January\" {\n      view.backgroundColor = UIColor.blue\n    }\n  }\n}\n```. import ReactiveKit. combineLatest(emailTextField.reactive.text, passwordTextField.reactive.text).map { email, pass in\n  return email.length > 0 && pass.length > 0\n  }.bind(to: loginButton.reactive.isEnabled)\ncombineLatest().map <---. TBH Im not 100% positive... It looks like Bond imports ReactiveKit in itself, but the actual method for combineLatest lives in ReactiveKit.... seems strange to me as well.. Can you verify that you are calling Bond's .removeAll() and not the one in Swift?. ^^ Also True. I believe I had a similar issue and I switched to using append instead. (after questioning why I was trying to insert at the last index anyway). ",
    "debbiegoldsmith": "Patch attached.\nLeakFix.diff.txt\n. The new, type-safe extension of BNDInvocation in ProtocolProxy.swift does not handle structure types (NSObjCStructType). Unfortunately, quite a few delegate selectors in AppKit and UIKit use structure types like NSPoint and CGPoint. Those used to work in the old version of the proxy, but now they get a fatal runtime error with \"unsupported type\". Is there any possibility of re-supporting structure types in protocol proxies?. ",
    "gilazr": "Thanks for your response :)\nIn V4 it was bidirectional. I was wondering if this functionality was removed on purpose.\nThank you.. ",
    "mecid": "@srdanrasic any idea why this error appear?. @srdanrasic sure). @srdanrasic swift-4 branch have problems in Diff which not for swift-4.. @srdanrasic we are using cocoapods.\nYou can do it like this:\npod 'Bond', :git => 'https://github.com/ReactiveKit/Bond.git', :branch => 'swift-4'. @srdanrasic so, we can't use Bond with Swift-4?. @srdanrasic i have issue with Bond dependency Diff.\n\n. thanks. Not working for me, same error in Diff appearing.. @tonyarnold @srdanrasic  there is a problem with Diff and Swift 4, no problem with CocoaPods. Please release new Diff version with Swift 4.. @srdanrasic as you can see on screenshot, problem is using removed in Swift4 toIntMax() function.. ",
    "joshtobin": "I think this has been broken again in 6.4.0. @srdanrasic no I hadn't used that script, this was actually just while I was updating to Xcode9, one developer on the team updated pods to 6.3.0 and it was working fine, I updated and got v6.4.0 and it didn't work. I have fixed the pod version to 6.3.0 and it's working again now, so I honestly think 6.4.0 is causing it again.. ",
    "prakashraman": "Also. A one way binding works fine.\nviewModel.name.bind(to: nameTextField). Ah! Damn, right! What a simple change. Yes it working great now :) \nThanks!. ",
    "jberkel": "I noticed that 2 methods are not covered by tests (the ones which fail with fatalError) . Maybe this could be done with the help of CwlPreconditionTesting ?. ",
    "sathishkraj": "got it, confused with swift 4 complier. using \"develop\" solved it. but \"SwiftBond/Bond\" \"6.2.6\"  should compile in xcode 9 right. will there be any fix for this error? Build Failed Task failed with exit code 65:, This usually indicates that project itself failed to compile.. ",
    "Cedrick84": "Created a pull request. ",
    "Vinzius": "Hi,\nYou should .map the value of your .selectionType property to a Bool. Something like\n.selectionType.map { $0 == \"checked\" }\nAnd then bind the result to the reactive.isEnabled of your button.\n.bind(self.button.reactive.isEnabled)\nThat should work.\nFor some \"support\", you better should use the gitter ( https://gitter.im/ReactiveKit/General )\nBests. ",
    "tkanzakic": "Not sure if this will work for you but in a similar case I do something like this and it works like a charm:\n```Swift\nlet isDataValid = Observable(false)\nvar questionViews:[KnowledgeQuestionView]! {\n    didSet {\n        let observables = questionViews.map {\n            $0.isDataValid.toSignal()\n        }\n    combineLatest(observables) { elements -> Bool in\n        /*\n         iterate over elements and if any are false 'return false'\n         */\n\n        return true\n    }).bind(to: isDataValid)\n}\n\n}\n```. ",
    "minsOne": "Thanks for the reply @srdanrasic \nyou says 'The operators are implemented only in ReactiveKit. Bond does not provide operators.', but Bond`s map, filter operator is existed. Here\nThe problem I'm experiencing is when I used a two-dimensional array type.\nBecause array type is conforming ObservableArrayEventProtocol, then operator such as map, filter on Bond can use.\nSo Instead of renaming an existing operator, i`d like to modify the code in the DataSource.swift file as follows:\n(before)\nextension Array: DataSourceEventProtocol, ObservableArrayEventProtocol {\n\u2014\n(after)\nextension Array: DataSourceEventProtocol {\nThen, compiler point only Reactivekit when I used two-dimensional array type.\nThanks. Thanks.. ",
    "andr3a88": "I had to put both Diff and Bond to make it compile\nruby\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        if target.name == 'Diff' || target.name == 'Bond'\n            target.build_configurations.each do |config|\n                config.build_settings['SWIFT_VERSION'] = '3.2'\n            end\n        end\n    end\nend. ",
    "w4-sglim": "Hey guys! I found solution! Remove the lines like below in your Podfile:\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '3.0'\n    end\n  end\nend\nThis enforce your library to use swift 3.0.\nWith this solution, bond (>= 6.4) works with Swift 4.x.. Hey guys! I found solution! Remove the lines like below in your Podfile:\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '3.0'\n    end\n  end\nend\nThis enforce your library to use swift 3.0.. ",
    "KausiAhmed": "Yep.  Just fixed it.  Thanks. . ",
    "lucasPelizza": "@srdanrasic, \nFirst of all, thank you for taking the time to answer my question.\nI will try with that solution, but what do you think about the second line:\n\"self.bnd_highlighted.observe\" \nBecause the reactive.isHighlighted does not have the observeNext\nThis is a part of my old code:\nswift\nimageButton.bnd_highlighted.observe { [weak cameraImageView] in\n    cameraImageView?.highlighted = $0\n}. ",
    "beltik": "I have not. Thanks, it solve problem. However, in XCode 8 i did not import it and everything was just fine. . Also look like :         self.vm.enteredLoginTxt.bind(to: txtf.reactive.text) not working.\nOr maybe it's my mistake in code somewhere else?. it appears that i did add input mask lib and text field stop to send events when value changed. Issue is unrelated to Bond.. ",
    "thang2410199": "I figured out that I need to convert the Observable object to Signal before binding:\nviewModel.spotPriceRecord.toSignal().bind(to: self.spotPriceView.reactive.price). ",
    "caprapaditu": "Same problem. ",
    "Janneman84": "Here too in 6.4.0, I'm back to 6.3.0 for now.. Doesn't help here either, I'm trying to run my current Swift 3 project in Xcode 9.\n(sure it's an easy fix but I prefer not to have to unlock pods and mess with them). Okay I found out that it has to do with the UISplitViewController that I'm using. If I run the app on iPhone it works fine but when I run it on iPad in split view mode it does not. I have an other app that doesn't use UISplitViewController altogether and there it works fine on iPad as well.\nI'll see if there is a difference between master and detail, I've only tried detail so far.. ",
    "pkl728": "To fix this I had to go into my project and manually set my Bond pod to use Swift 4.0. When I did that it started working.. ",
    "bj97301": "Got this error just now with version 6.6.0 swift 3 xcode 9.2.. Went back to 6.3.0 and seems to work.  I didnt try all of the version after that.  . ",
    "gabrielsscavalcante": "I had the same issue right now.... ",
    "sblepa": "This also happens for UITableViewCell when binding the tableview . ",
    "phjacobs7AG": "Has it been fixed yet ?. ",
    "omerozk": "Thanks i tried with it also but then i got a new errors.\nIn the first line i get:  Argument type '(, ) -> Bool' does not conform to expected type 'SignalProtocol'\n```\ncombineLatest(emailTextField.reactive.text, passwordTextField.reactive.text) { email, pass in\n     return email.length > 0 && pass.length > 0\n}.bind(to: loginButton.reactive.isEnabled)\n```\nNow what i did to bypass this error is to don't use the parameter.\n```\ncombineLatest(emailTextField.reactive.text, passwordTextField.reactive.text) { (, ) in\n      return (self.emailTextField.text?.count)! > 0 && (self.passwordTextField.text?.count)! > 0\n}.bind(to: loginButton.reactive.isEnabled)\n```\nBut i definitely would to find a way to make it work like the example in the readme (which should be adapted I think). Ok thank you that worked. I think an update of the Readme is needed.\nHere the example working code for swift 4:\ncombineLatest(emailTextField.reactive.text, passwordTextField.reactive.text).map { (email, pass) -> Bool in\n      return (email?.count)! > 0 && (pass?.count)! > 0\n}.bind(to: loginButton.reactive.isEnabled)\nJust a question why do we need to import Bond and ReactiveKit, shouldn't be Bond which make the link?. ",
    "killev": "The second I clarified is that we have no any public/open abstractions under ObservableArray. So it's not expandable by the 3d party libraries.\nI forked the Bond and did the following.\n\nSplit ObsevableArray into 2 classes:\nopen ObservableArrayBase. Align all external functiality to it (maps, bindings etc.).\npublic ObservableArray derived from ObservableArrayBase\nConverted array into propery so that inherited classes can provide their own implementation\nChanged  source to Array in order to prevent race condition\nOther minor changes.\n\nYou can find the changes here:\nhttps://github.com/killev/Bond/commits/master\n. @tonyarnold @srdanrasic Let's split them into 2 different issues and discuss them separately. I have some arguments for both of them.\nBTW. And if we clarify the architecture I would be pleased to implement it on my own.. So discussing extensibility here.\nI've just realized what is the purpose of DataSourceEventProtocol  \ud83d\ude04\nFrom this point of view, the solution suggested by @srdanrasic seems to be more preferable. \nOn the other hand, we have a bunch of useful functionality already bound to ObservableArrayEventProtocol like map, filter.\nAlso, having the class ObservableArray in\nswift\npublic protocol ObservableArrayEventProtocol {\n    associatedtype Item\n    var change: ObservableArrayChange { get }\n    var source: ObservableArray<Item> { get }\n}\nprevents us from using  ObservableArrayEventProtocol as events for other classes. Only inheritance is supported.. I fixed it here: #496 . @srdanrasic @tonyarnold \nLet's think of this from another point of view: Is it really correct to send a source (producers) of change as a part of payload? In this case Properties (which may be treated as a common case of ObservableArray) also should send themselves instead of the value.\nThen.\nHaving a source in observation block propagates to use it as Signal. For example, it becomes possible to subscribe to it (senseless especially, if it's always a new copy of the source, like you're suggesting), or (in some cases) even perform next (it's even more dangerous as brakes locking!!).\nIn observation logic, you need just an immutable data, not a source.\nAs to supporting other collections.\nThey all consist of some data inside of them.\n```swift\npublic class Observable2DArray: SignalProtocol {\npublic fileprivate(set) var sections: [Observable2DArraySection<SectionMetadata, Item>]\n\n```\nAnd this data just should implement DataSourceProtocol to be easily used in bindings. So we shouldn't break a lot.\nPS. Anyway, you usually use source just to reach data! Not more!. Moreover.\n\nThis would be a source breaking change, but I don't think many people rely on the source type being ObservableArray.\n\nAccording to above, this change:\nswift\npublic struct ObservableArrayEvent<Item>: ObservableArrayEventProtocol {\n    ...\n    public init(change: ObservableArrayChange, source: ObservableArray<Item>) {\n        self.change = change\n        self.source = ObservableArray(source.array) // <- change from `self.source = source`\n    }\n    ...\n}\nis even more dangarous as those people who rely on source being ObservableArray won't get the original instance anymore.. Ok. I'll make it over the weekend.. @tonyarnold @srdanrasic Correct me I'm wrong, but there's nothing to do anymore with this according to #513.\nAs long as you need any help - let me know. I have next several days free and!\nBTW. If you need to something from me - reach me on skype: mw_peter, or let me know about any suitable channel for you (Slack, Viber, WhatsApp).. Briefly - it's rather UICollectionView's issue. It crashes if you change it before it appears on screen (viewDidAppear). UITableView works great with the same\nMany libraries suffer from the same issue,  IGListKit for instance. \nBut far as Reactive approach is driven by data changes, and bindings should work despite the fact a view is shown or hidden. So we can't ignore this.\nTry a simple example here:\nhttps://gist.github.com/killev/b802c213a1e1a9d05853ca7b869bcc28\n. ",
    "hrandeniya": "Yup, getting same issue. Any fix?. ",
    "davedelong": "Well, @_exported is technically private API and you're not really supposed to use it.\nA pitch just went up on the Swift forums about doing something about this: https://forums.swift.org/t/exported-and-fixing-import-visibility/9415. ",
    "stefanoa": "Hi all,\nI found a solution that makes a better use of Bond, instead of using the UITextField delegate I will observe the control event .editingDidEndOnExit.\nThis is the new code:\nimport UIKit\nimport Bond\n```\nclass TestViewController: UIViewController,UITextFieldDelegate {\n    @IBOutlet weak var nameTextField: UITextField!\n    @IBOutlet weak var lastNameTextField: UITextField!\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    let _ =  nameTextField.reactive.controlEvents(.editingDidEndOnExit).observeNext { [weak self] e in\n        self?.lastNameTextField.becomeFirstResponder()\n    }\n}\n\n}\n```\nI hope it will be useful to someone having the same issue. ",
    "chipbk10": "I did figure it out when coming to build a project that support for both iOS and OSX. The podfile is configured properly and now everything is fine. You can close this issue.. ",
    "mladenny": "Here\u2019s the sample project:\nBond-sample.zip\nI\u2019ve tried to make some clarifications with comments in the code, but I think running the project will illustrate the problem well.. ",
    "IvoPintodaSilva": "Yes, Bond will not affect the layout of the views.\nBond only lets you define the title for the section header using the TableViewBond's\nfunc titleForHeader(in section: Int, dataSource: DataSource) -> String?\n  func titleForFooter(in section: Int, dataSource: DataSource) -> String?\nThen the default section header is built and attributed that title.\nWhat I would like to do is to have a custom section header. Basically, instead of only returning the header's title, I would like to return the header's view.. ",
    "shmidt": "OK, after some time I realized that NSTextField uses 'editingString'... \nFor me it feels that I would like to see 'text' property for text controls, as it is on iOS.... ",
    "dantheli": "This is an extension for UISearchBar's text property:\n```swift\npublic var delegate: ProtocolProxy {\n        return protocolProxy(for: UISearchBarDelegate.self, keyPath: .delegate)\n    }\npublic var text: DynamicSubject<String?> {\n    let selector = #selector(UISearchBarDelegate.searchBar(_:textDidChange:))\n    let signal = delegate.signal(for: selector) { (subject: SafePublishSubject<Void>, _: UISearchBar, _: NSString) in\n        subject.next()\n    }\n\n    return dynamicSubject(signal: signal, get: { $0.text }, set: { $0.text = $1 })\n}\n\n}\n```\nIt'd be nice to include this in Bond, perhaps one of us can make a PR at some point.. ",
    "harryblam": "@dantheli you sir, are both a gentleman and a squire. Will do now.. ",
    "npvisual": "As a point of reference, I also implemented the following, that works really well : \nvar moveRow: Signal<(Int, Int), NoError> {\n        return reactive.dataSource.signal(for: #selector(UITableViewDataSource.tableView(_:moveRowAt:to:))) {\n            (subject: SafePublishSubject<(Int,Int)>, _: UITableView, moveRowAt: IndexPath, to: IndexPath) in\n            subject.next((moveRowAt.row, to.row))\n        }\n    }\nSo it seems that BNDInvocation is just having a hard time with the enum UITableViewCellEditingStyle. . Ok. Thanks for the pointer. I tested it this morning and it works fine : \n```\n    // Swipe-to-delete feature\n    var commitStyle: Signal<(Int, Int), NoError> {\n        return reactive.dataSource.signal(for: #selector(UITableViewDataSource.tableView(_:commit:forRowAt:))) {\n            (subject: SafePublishSubject<(Int, Int)>, tv: UITableView, editingStyle: Int, indexPath: IndexPath) in\n            subject.next((editingStyle,indexPath.row))\n        }\n    }\n```\nAnd then to observe the signal : \ncontroller.tableView.commitStyle.observeNext { (editingStyle,row) in\n            switch editingStyle {\n            case 1: service.family.remove(at: row)\n            default:  print(\"Hmmm, not sure about that one.\")\n            }\n        }.dispose(in: controller.bag)\n. FYI. Running the following will bypass the issue in the macOS build until it's resolved : \ncarthage bootstrap --platform ios. Hmmm... Things compile fine on my end. Looks like Travis is having some issues with some destinations for the Bond-iOS scheme. I don't think that's related to my change, but that's past my pay-grade here.... \n```\n...\n    Ineligible destinations for the \"Bond-iOS\" scheme:\n        { platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Generic iOS Device }\n        { platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Generic iOS Simulator Device }\n....\nThe command \"xcodebuild -project Bond.xcodeproj -scheme Bond-iOS -sdk iphonesimulator -destination platform=iOS Simulator,name=iPhone 7,OS=11.0 test\" failed 3 times.\nThe command \"set -o pipefail && travis_retry xcodebuild -project Bond.xcodeproj -scheme Bond-iOS -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 7,OS=11.0' test | xcpretty\" exited with 70.\n```. @trevor-sonic , did you take a look at this section ? This seems to indicate that supplementary views like header / footer would need to be handled via protocol proxies.\nHTH.. Awesome. Thanks !. Note : \nIf I bind directly to tap then I don't get any compiler error, but I am unable to observe a signal to generate a call to the backend DB (similar to what todoService.complete(todoItem) would do).\ncell.selectedItem.reactive.tap.bind(to: cell) { cell in\n                print(\"[ItemDetail View] Just pressed \\(item.displayName)'s button\")\n                service.complete(todoItem)  // that's never observed of course....\n            }.dispose(in: cell.bag)\n        }\nSo apparently the flatMapLatest call is the issue. I guess I am either not injecting the proper parameters in the closure, or something fishier is going on...\n```\n            cell.selectedItem.reactive.tap\n                .flatMapLatest {\n                    service\n                        .complete(todoItem)\n                        .mapElement { $0.value }\n                }\n                .bind(to: cell) { cell, result in\n                    cell.selectedItem.isSelected = result\n                }.dispose(in: cell.bag)\n```. ### Resolution\nFlashback from a few months ago... Seems like I already faced this issue before and just remembered the solution : \ncell.selectedItem.reactive.tap\n                .flatMapLatest { _ -> Signal<[Bool], NoError> in\n            ....\n                }\n                .bind(to: cell) { \n            ....\n                }.dispose(in: cell.bag)\nThis has to be a Signal<Something, NoError> otherwise it will not work. So specifying the expected return type of the closure and ensuring that it's a safe signal is the answer.\nNot quite sure I 100% agree with the logic, but it's compiling now. The service method unfortunately still doesn't work...\n. One interesting piece of information : even if I add a breakpoint at todoService.complete (in the flatMap), this second \"shadow\" call isn't caught -- however the call is stopped by the debugger during the tap in the first category).. Thanks Srdan.\n\ndeinit is never called.\nyes, I am sharing the service instance between the categories (using a ReplayOneSubject for the selected category).\n\nI am using the Binder architecture to create the different controllers (so using a static function to \"make\" the controller). Specifically for the category detail view the call from the Binder is   : \n```\n        service.selectedCategory.toSignal().bind(to: controller) { me, category in\n            let ctrl = ToDosForCategoryController.makeViewController(with: session)\n            controller.navigationController?.present(ctrl, animated: true) { ctrl.bag.dispose() }\n        }\n```\nI am trying to force the dispose() in here as well, but that doesn't seem to work either.\nThe fact that the part of the code that's updating the status of the to-do is never caught by the compiler's breakpoint the second time around is kinda crazy..... Thanks for the pointers @frankois944. Good read. Since I am mostly using closures for bind() and some other ReactiveKit / Bond functions, I went over my code several times, but that didn't really help.\nHowever, that got me looking into the Xcode memory graph and I was definitely able to see the retained view controllers and cells growing over and over as I selected more categories.\nSo... I went back to the drawing board and went through a process of elimination.\nSolution\nWell, it was (of course) pretty darn simple... For some weird reason (probably cut & paste) I had failed to inject the proper reference in some of my bind statements. So instead of using the parameter local to the closure, I was using the outer parameter. For example : \n```\n        session.someService.isConditionTrue.bind(to: controller) { ctrl, value in\n                controller.removeToDo.isHidden = !value\n        }\n```\nchanging that to : \n```\n        session.someService.isConditionTrue.bind(to: controller) { ctrl, value in\n                ctrl.removeToDo.isHidden = !value\n        }\n```\n(and in a few other places) did the trick.\nThanks @srdanrasic  and @frankois944 for the help.. I found the answer before posting this issue, but I figured it might be useful for someone down the road. So here's what the issue was : \nthere was a leftover .dispose(in: bag) of a previous .observeNext.\nOnce I removed that I was, of course faced with the argument type issue due to enum type.\nThe minor change necessary was to replace EKEventEditViewAction with Int in the dispatch section : \npublic var eventAction: SafeSignal<Int> {\n        return delegate.signal(\n            for: #selector(EKEventEditViewDelegate.eventEditViewController(_:didCompleteWith:)),\n            dispatch: { (subject: SafePublishSubject<Int>, controller: EKEventEditViewController, action: Int) in\n                subject.next(action)\n        }\n        )\n    }. @jonathanfoster : nice implementation. I started using this in my project since I wanted to use bind(to:) on UIPickerView.\nHowever, I had to change the Element conformance to 'SectionedDataSourceChangesetConvertible' to be able to bind an ObservableArray to UIPickerView (and a few more lines).\n```\npublic class PickerViewBinder {\n    public var createTitle: ((DataSource, Int, Int, UIPickerView) -> String?)?\n...\nextension SignalProtocol where Element: SectionedDataSourceChangesetConvertible, Error == NoError {\n    public typealias DataSource = Element\n...\n        map: { (dataSource: DataSource?, pickerView: UIPickerView) -> Int in\n            return dataSource?.asSectionedDataSourceChangeset.collection.numberOfSections ?? 0\n\n...\n        map: { (dataSource: DataSource?, pickerView: UIPickerView, component: Int) -> Int in\n            return dataSource?.asSectionedDataSourceChangeset.collection.numberOfItems(inSection: component) ?? 0\n\n```\nNot sure if that's the right thing to do or not, but once that was done, things worked really well.. Tested your suggestion, seems to work fine. So I'll use that in the meantime. Thanks !. Works great in 7.2.0. Thanks !. Great ! Thanks a lot for the detailed explanation and code. This works really well.. Would there be a way to make this more generic down the road ? I.e. by adding it to a MutableObservableArray's combine operation (so they can be chained) ? Something along the lines of : \nMutableObservableArray.combine(with:sections:). ",
    "exevil": "@srdanrasic: Shouldn't it then be implemented as a scroll view delegate proxy at first and then be extended with table view delegate methods for proper inheritance? . Here's some temporary fix:\nextension ReactiveExtensions where Base: UIScrollView {\n    /// Delegate protocol proxy.\n    var delegate: ProtocolProxy {\n        // Since reactive delegate has been already declared in Bond core, return it for table view base\n        if let base = base as? UITableView { return base.reactive.delegate }\n        return protocolProxy(for: UIScrollViewDelegate.self, keyPath: \\.delegate)\n    }\n}. ",
    "hrstruggle1": "@tonyarnold  hi, thank U for your reply  : )\nyes, i verify my project SWIFT_VERSION = 4.1, and use cocoapods 1.5.0 installation. ",
    "ronnie70": "Ah, didn't know that, thanks!. Hi,\nI used Carthage to integrate it in my project (Xcode 9.3), along with some other frameworks like Moya and Realm.\nBut as the error message specifically mentions Bond.framework, I suspect something's wrong in there.\nWhen disabling App-thinning, everything works fine and I can just upload it to iTunesConnect.\nAnyway, I will take a further look. Thanks.. Hi,\nI did some further investigation and it definitely seems to point to a problem in the Bond.framework.\nWhat I did was making a fresh empty project and (using Carthage) adding different frameworks to the project (and making sure the \"/usr/local/bin/carthage copy-frameworks\" was called for this particular framework). Then I archive the project and do an Ad Hoc export.\nThis works fine for all frameworks (Differ, Realm, Moya, SwiftyBeaver, Result), but only with the Bond.framework the above mentioned error message is shown.. @sebskuse, \nMight be, this is what it says at the bottom of the alert:\n```\nerror: Ld: cd /var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/tempYnGgru\n    \"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld\" \"-arch\" \"arm64\" \"-dylib\" \"-compatibility_version\" \"1.0.0\" \"-current_version\" \"1.0.0.0.0\" \"-install_name\" \"@rpath/Bond.framework/Bond\" \"-ios_version_min\" \"8.0.0\" \"-rpath\" \"@executable_path/Frameworks\" \"-rpath\" \"@loader_path/Frameworks\" \"-dead_strip\" \"-application_extension\" \"-syslibroot\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk\" \"-sdk_version\" \"11.3.0\" \"-filelist\" \"/private/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/BondRuglIx/Bond.arm64.out.LinkFileList\" \"-ignore_auto_link\" \"-allow_dead_duplicates\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/Differ.framework/Differ\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/ReactiveKit.framework/ReactiveKit\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/System/Library/Frameworks/Foundation.framework/Foundation.tbd\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libobjc.A.tbd\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libSystem.B.tbd\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation.tbd\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/System/Library/Frameworks/QuartzCore.framework/QuartzCore.tbd\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/System/Library/Frameworks/UIKit.framework/UIKit.tbd\" \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libobjc.A.tbd\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftCore.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftCoreFoundation.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftCoreGraphics.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftCoreImage.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftDarwin.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftDispatch.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftFoundation.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftMetal.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftObjectiveC.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftQuartzCore.dylib\" \"/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/ipatool20180508-66491-3f8ejc/thinned/arm64/Payload/appThingTest.app/Frameworks/libswiftUIKit.dylib\" \"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/lib/darwin/libclang_rt.ios.a\" \"-o\" \"/private/var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/BondRuglIx/Bond.arm64.out\" \n    -= Output =-\n    Undefined symbols for architecture arm64:\n      \"__T06Differ12ExtendedDiffV5patchSayAA0B5PatchOy7ElementQzGGx4from_x2toSbAcGO_AMtcSg4sortts10CollectionRzs9EquatableAHRQlF\", referenced from:\n          __hidden#1268_ in 14.o\n          __hidden#3563_ in 52.o\n    ld: symbol(s) not found for architecture arm64\n    Exited with 1\nerror: Failed to compile bundle: /var/folders/k1/s407rnvx4hd751d3n_yvh5080000gn/T/BondRuglIx/Bond.arm64.xar\n\n```. Hmmm I just tried and I see it pulled in Differ 1.2.3, but when archiving and doing an AdHoc export I still get the same error unfortunately.... BTW, disabling code coverage in Release build also doesn't seem to fix it.... Thanks @srdanrasic and @sebskuse, it's working! . ",
    "pimnijman": "\n.bind(to:cellType:) does not work with cells defined in a storyboards. Please use alternative method .bind(to:animated:rowAnimation:createCell).\nI'll make sure to document this properly.\n\nI took me quite some time before figuring out that `bind(to:cellType:configureCell:) doesn't work with cells that are defined in storyboards. Only after I knew what to look for I found this issue.\nHas this been added to the documentation and did I just miss it, or haven't you had the time to add it yet?. ",
    "sebskuse": "I believe this is the same issue I was seeing on Friday, it's actually an issue in the Differ dependency related to code coverage being enabled for the Release scheme. You can verify this by copying the full contents of the alert, which at the very bottom will give you the underlying failure.\nI've fixed this in the following PR - https://github.com/tonyarnold/Differ/pull/33, and Differ 1.2.3 contains the fix, so hopefully @srdanrasic or @tonyarnold could look at updating the dependency?. Yeah, that's the same log I was getting. \nHave you tried a rebuild using Carthage? It should pull 1.2.3 in, which should resolve the issue.. Hm, yeah I'm still getting a failure when exporting for App Thinning after rebuilding Bond using Carthage. \nLooking at Carthage/Checkouts/Bond/Carthage/Checkouts, the version of Differ it's got has code coverage still switched on, so it looks like it's still pulling the old version. Last week we ended up rebuilding Bond manually outside of Carthage with codecov switched off for Release which seemed to resolve the issue as a quick fix to get something in the store.. Thanks @srdanrasic, looks like this is working for me :+1:. ",
    "noaraz": "Are there any news about the subject?. ",
    "jsembdner": "This seems to be another linked issue to this.. I tried this using the CustomBinder as described here, because I also want to show a section header.\nAfter binding my custom cell class, only the standard cells are created. The TableViewBinderDataSource seems to register new cells which causes Bond to initialize my CustomCell not with the storyboard initializers.\nThe only way I could make it work is using the tableview bind and dequeueing my own cells in the closure. But if you use this approach, then you can't change other TableViewDataSource delegates e.g. the section header.. ",
    "olbrichj": "We're using a lot of C++. So no way around Obj-C. ",
    "eduardbosch": "Thanks @srdanrasic Works like a charm . Many thanks @srdanrasic !\nI thought It was not intended. I'm glad they're back :). ",
    "fishcharlie": "Any updates on this? Is there anything I can help with to push this across the finish line?. The solution was to add s.swift_version = '4.2' to my PodSpec file. ",
    "angu": "https://github.com/DeclarativeHub/Bond/blob/master/Documentation/ProtocolProxies.md. ",
    "ericsilvapaucar": "Thank, It work. I created a extension with this.. ",
    "trevor-sonic": "Hi @edwardmp as far as I understood;\nTableViewBinder is replacing TableViewBond\nI post an example code below. But I have to say that after this implementation you will loose the section headers. I couldn't find the way to bring back.\nfunc titleForHeader is removed in TableViewBinder. So something is missing. Maybe you have better understanding to find out.   \n```\nclass TvBond: TableViewBinder, DataSourceProtocol{\nlet viewModel = ViewModel.sharedInstance\n\nvar numberOfSections: Int{\n    return viewModel.array.sections.count\n}\n\nfunc numberOfItems(inSection section: Int) -> Int {\n    return viewModel.array.numberOfItems(inSection:section)\n}\n\noverride func cellForRow(at indexPath: IndexPath, tableView: UITableView, dataSource: MyDataSource) -> UITableViewCell {\n    let city = viewModel.array[indexPath]\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n\n    cell.textLabel?.text = city.name\n\n    return cell\n}\n\n}\n```\nAnd bind like;\nviewModel.array\n            .bind(to: tableView, using: TvBond())\n            .dispose(in: bag). @npvisual I'd like to explain the problem better;\nIn the library there is no any logic/implementation about defining a header/section view UICollectionReusableView\nIn the library;\nBond / UICollectionView \nThe class\nCollectionViewBinder<DataSource: DataSourceProtocol> \nhas a method ;\nfunc cellForRow (...)->UICollectionViewCell\nfor setting the dequeueReusableCell for indexPath. \nBut there is no any similar implementation for UICollectionReusableView to define what kind of header cell we'd like to use/set.\nI set the header in cellForRow method, like;\nlet head = collectionView.dequeueReusableSupplementaryView(ofKind: UICollectionElementKindSectionHeader, withReuseIdentifier: \"HCell\", for: indexPath) as! HCell\nbut it makes the section headers static, they dont move.\nWith protocol proxies I couldn't set the viewForSupplementaryElementOfKind\nTo me; even everything works perfectly item/row level. Sections/headers side is not implemented yet. Or I miss something?. Hi @srdanrasic,\nThank you for your understanding my issue.\nI'd like to share whole UICollectionView class modified by me.\nI've commented what I have added cause didn't work need more integration with cell init etc.\nfunc supplementaryViewForRow\nand other add into the bind(to :... section. \nThis might be helpful for you. And also can show my desperate effort to find a solution.\nI'm looking forward to see the update!\nThank you\n```swift\n//\n//  The MIT License (MIT)\n//\n//  Copyright (c) 2016 Srdan Rasic (@srdanrasic)\n//\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files (the \"Software\"), to deal\n//  in the Software without restriction, including without limitation the rights\n//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//  copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions:\n//\n//  The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n//\nif os(iOS) || os(tvOS)\nimport UIKit\nimport ReactiveKit\n\npublic extension ReactiveExtensions where Base: UICollectionView {\n\n    /// A `ProtocolProxy` for the collection view delegate.\n    ///\n    /// - Note: Accessing this property for the first time will replace collection view's current delegate\n    /// with a protocol proxy object (an object that is stored in this property).\n    /// Current delegate will be used as `forwardTo` delegate of protocol proxy.\n    public var delegate: ProtocolProxy {\n        return protocolProxy(for: UICollectionViewDelegate.self, keyPath: \\.delegate)\n    }\n\n    /// A `ProtocolProxy` for the collection view data source.\n    ///\n    /// - Note: Accessing this property for the first time will replace collection view's current data source\n    /// with a protocol proxy object (an object that is stored in this property).\n    /// Current data source will be used as `forwardTo` data source of protocol proxy.\n    public var dataSource: ProtocolProxy {\n        return protocolProxy(for: UICollectionViewDataSource.self, keyPath: \\.dataSource)\n    }\n\n    /// A signal that emits index paths of selected collection view cells.\n    ///\n    /// - Note: Uses collection view's `delegate` protocol proxy to observe calls made to `UICollectionViewDelegate.collectionView(_:didSelectItemAt:)` method.\n    var selectedItemIndexPath: SafeSignal<IndexPath> {\n        return delegate.signal(for: #selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:))) { (subject: SafePublishSubject<IndexPath>, _: UICollectionView, indexPath: IndexPath) in\n            subject.next(indexPath)\n        }\n    }\n}\n\n/// A type used by the collection view bindings that provides binding options and actions.\nopen class CollectionViewBinder<DataSource: DataSourceProtocol> {\n\n    open let createCell: ((DataSource, IndexPath, UICollectionView) -> UICollectionViewCell)?\n\n//        open let createHCell: ((DataSource, IndexPath, UICollectionView) -> UICollectionReusableView)?\n    public init() {\n        createCell = nil\n\n//            createHCell = nil\n        }\n    /// - parameter createCell: A closure that creates cell for a given collection view and configures it with the given data source at the given index path.\n    public init(_ createCell: @escaping (DataSource, IndexPath, UICollectionView) -> UICollectionViewCell) {\n        self.createCell = createCell\n\n//            self.createHCell = nil\n        }\n    /// - returns: A cell for the given collection view configured with the given data source at the given index path.\n    open func cellForRow(at indexPath: IndexPath, collectionView: UICollectionView, dataSource: DataSource) -> UICollectionViewCell {\n        if let createCell = createCell {\n            return createCell(dataSource, indexPath, collectionView)\n        } else {\n            fatalError(\"Subclass of CollectionViewBinder should override and implement cellForRow(at:collectionView:dataSource:) method. Do not call super.\")\n        }\n    }\n\n    /// - returns: A header cell for the given collection view configured with the given data source at the given index path.\n\n//        open func supplementaryViewForRow(at indexPath: IndexPath, collectionView: UICollectionView, dataSource: DataSource) -> UICollectionReusableView {\n//            if let createHCell = createHCell {\n//                return createHCell(dataSource, indexPath, collectionView)\n//            } else {\n//                fatalError(\"Subclass of CollectionViewBinder should override and implement supplementaryViewForRow  method. Do not call super.\")\n//            }\n//        }\n    }\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Element.BatchKind == BatchKindDiff, Error == NoError {\n\n    /// Binds the signal of data source elements to the given collection view.\n    ///\n    /// - parameters:\n    ///     - collectionView: A collection view that should display the data from the data source.\n    ///     - createCell: A closure that creates (dequeues) cell for the given collection view and configures it with the given data source at the given index path.\n    /// - returns: A disposable object that can terminate the binding. Safe to ignore - the binding will be automatically terminated when the collection view is deallocated.\n    @discardableResult\n    public func bind(to collectionView: UICollectionView, createCell: @escaping (DataSource, IndexPath, UICollectionView) -> UICollectionViewCell) -> Disposable {\n        return bind(to: collectionView, using: CollectionViewBinder<DataSource>(createCell))\n    }\n\n    /// Binds the signal of data source elements to the given collection view.\n    ///\n    /// - parameters:\n    ///     - collectionView: A collection view that should display the data from the data source.\n    ///     - binder: A `CollectionViewBinder` or its subclass that will manage the binding.\n    /// - returns: A disposable object that can terminate the binding. Safe to ignore - the binding will be automatically terminated when the collection view is deallocated.\n    @discardableResult\n    public func bind(to collectionView: UICollectionView, using binder: CollectionViewBinder<DataSource>) -> Disposable {\n\n        let dataSource = Property<DataSource?>(nil)\n        let disposable = CompositeDisposable()\n\n//            // MARK: - Header section\n//            disposable += collectionView.reactive.dataSource.feed(\n//                property: dataSource,\n//                to: #selector(UICollectionViewDataSource.collectionView(_:viewForSupplementaryElementOfKind:at:)),\n//                map: { (dataSource: DataSource?, collectionView: UICollectionView, indexPath: NSIndexPath) -> UICollectionReusableView in\n//                    return binder.supplementaryViewForRow(at: indexPath as IndexPath, collectionView: collectionView, dataSource: dataSource!)\n//            }\n//            )\n        disposable += collectionView.reactive.dataSource.feed(\n            property: dataSource,\n            to: #selector(UICollectionViewDataSource.collectionView(_:cellForItemAt:)),\n            map: { (dataSource: DataSource?, collectionView: UICollectionView, indexPath: NSIndexPath) -> UICollectionViewCell in\n                return binder.cellForRow(at: indexPath as IndexPath, collectionView: collectionView, dataSource: dataSource!)\n            }\n        )\n\n        disposable += collectionView.reactive.dataSource.feed(\n            property: dataSource,\n            to: #selector(UICollectionViewDataSource.collectionView(_:numberOfItemsInSection:)),\n            map: { (dataSource: DataSource?, _: UICollectionView, section: Int) -> Int in\n                dataSource?.numberOfItems(inSection: section) ?? 0\n            }\n        )\n\n        disposable += collectionView.reactive.dataSource.feed(\n            property: dataSource,\n            to: #selector(UICollectionViewDataSource.numberOfSections(in:)),\n            map: { (dataSource: DataSource?, _: UICollectionView) -> Int in\n                dataSource?.numberOfSections ?? 0\n            }\n        )\n\n        var bufferedEvents: [DataSourceEventKind]? = nil\n\n        disposable += bind(to: collectionView) { collectionView, event in\n            dataSource.value = event.dataSource\n\n            let applyEventOfKind: (DataSourceEventKind) -> () = { kind in\n                switch kind {\n                case .reload:\n                    collectionView.reloadData()\n                case .insertItems(let indexPaths):\n                    collectionView.insertItems(at: indexPaths)\n                case .deleteItems(let indexPaths):\n                    collectionView.deleteItems(at: indexPaths)\n                case .reloadItems(let indexPaths):\n                    collectionView.reloadItems(at: indexPaths)\n                case .moveItem(let indexPath, let newIndexPath):\n                    collectionView.moveItem(at: indexPath, to: newIndexPath)\n                case .insertSections(let indexSet):\n                    collectionView.insertSections(indexSet)\n                case .deleteSections(let indexSet):\n                    collectionView.deleteSections(indexSet)\n                case .reloadSections(let indexSet):\n                    collectionView.reloadSections(indexSet)\n                case .moveSection(let index, let newIndex):\n                    collectionView.moveSection(index, toSection: newIndex)\n                case .beginUpdates:\n                    fatalError()\n                case .endUpdates:\n                    fatalError()\n                }\n            }\n\n            switch event.kind {\n            case .beginUpdates:\n                bufferedEvents = []\n            case .endUpdates:\n                if let bufferedEvents = bufferedEvents {\n                    collectionView.performBatchUpdates({ bufferedEvents.forEach(applyEventOfKind) }, completion: nil)\n                } else {\n                    fatalError(\"Bond: Unexpected event .endUpdates. Should have been preceded by a .beginUpdates event.\")\n                }\n                bufferedEvents = nil\n            default:\n                if bufferedEvents != nil {\n                    bufferedEvents!.append(event.kind)\n                } else {\n                    applyEventOfKind(event.kind)\n                }\n            }\n\n             // Hack to immediately apply changes. Solves the crashing issue when performing updates before collection view is on screen.\n            _ = collectionView.numberOfSections\n        }\n\n        return disposable\n    }\n}\n\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Element.DataSource: QueryableDataSourceProtocol, Element.DataSource.Index == IndexPath, Element.BatchKind == BatchKindDiff, Error == NoError {\n\n    /// Binds the signal of data source elements to the given collection view.\n    ///\n    /// - parameters:\n    ///     - collectionView: A collection view that should display the data from the data source.\n    ///     - cellType: A type of the cells that should display the data. Cell type name will be used as reusable identifier and the binding will automatically dequeue cell.\n    ///     - configureCell: A closure that configures the cell with the data source item at the respective index path.\n    /// - returns: A disposable object that can terminate the binding. Safe to ignore - the binding will be automatically terminated when the collection view is deallocated.\n    @discardableResult\n    public func bind<Cell: UICollectionViewCell>(to collectionView: UICollectionView, cellType: Cell.Type, configureCell: @escaping (Cell, DataSource.Item) -> Void) -> Disposable {\n        let identifier = String(describing: Cell.self)\n        collectionView.register(cellType as AnyClass, forCellWithReuseIdentifier: identifier)\n        return bind(to: collectionView, createCell: { (dataSource, indexPath, collectionView) -> UICollectionViewCell in\n            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, for: indexPath) as! Cell\n            let item = dataSource.item(at: indexPath)\n            configureCell(cell, item)\n            return cell\n        })\n    }\n}\n\npublic extension SignalProtocol where Element: DataSourceEventProtocol, Element.DataSource: QueryableDataSourceProtocol, Element.DataSource.Index == Int, Element.BatchKind == BatchKindDiff, Error == NoError {\n\n    /// Binds the signal of data source elements to the given collection view.\n    ///\n    /// - parameters:\n    ///     - collectionView: A collection view that should display the data from the data source.\n    ///     - cellType: A type of the cells that should display the data. Cell type name will be used as reusable identifier and the binding will automatically dequeue cell.\n    ///     - configureCell: A closure that configures the cell with the data source item at the respective index path item.\n    /// - returns: A disposable object that can terminate the binding. Safe to ignore - the binding will be automatically terminated when the collection view is deallocated.\n    @discardableResult\n    public func bind<Cell: UICollectionViewCell>(to collectionView: UICollectionView, cellType: Cell.Type, configureCell: @escaping (Cell, DataSource.Item) -> Void) -> Disposable {\n        let identifier = String(describing: Cell.self)\n        collectionView.register(cellType as AnyClass, forCellWithReuseIdentifier: identifier)\n        return bind(to: collectionView, createCell: { (dataSource, indexPath, collectionView) -> UICollectionViewCell in\n            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, for: indexPath) as! Cell\n            let item = dataSource.item(at: indexPath.item)\n            configureCell(cell, item)\n            return cell\n        })\n    }\n}\n\nendif\n. Hello, I'm still waiting for a solution to usesupplementaryViewForRowwithout this **fundamental** functionality, this library is unfortunately unusable. Can you point me how can I achieve this? \nMy code below is as same as given in the documentation but I can't complete the missing part.swift\nclass TheVC: UIViewController {\n  func setupBond(){\n        let cvcBond = CVCBond()\n        collectionView.reactive.dataSource.forwardTo = self\n    viewModel.array\n        .bind(to: collectionView, using: cvcBond)\n        .dispose(in: bag)\n\n}\n}\ntypealias MyDataSource = Observable2DArray\nclass CVCBond: CollectionViewBinder,DataSourceProtocol {\n    let viewModel = ViewModel.sharedInstance\n    var numberOfSections: Int { return viewModel.array.sections.count }\n    func numberOfItems(inSection section: Int) -> Int { return viewModel.array.sections[section].items.count }\n///Render Cell For Row is OK\noverride func cellForRow(at indexPath: IndexPath, collectionView: UICollectionView, dataSource: MyDataSource) -> UICollectionViewCell {\n    let city = dataSource.item(at: indexPath)\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CCell\", for: indexPath) as! CCell\n    cell.cellLabel?.text = city.name\n    return cell\n}\n\n///Render Supplementary View For Row is missing in the library\n\n===>func supplementaryViewForRow {}<===\n   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n}\n```\n. ",
    "madiguzel": "Hi Srdan,\nI've tried to customize section header view by subclassing both CollectionViewBinderDataSource and TableViewBinderDataSource with no luck.\n```\nclass WorkLogCollectionBinder: CollectionViewBinderDataSource where Changeset.Collection == Array2D {\n@objc func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {\n    let headerView = collectionView.dequeueReusableView(WorkLogSectionHeaderView.self, kind: kind, indexPath: indexPath)\n    headerView.date = changeset?.collection[sectionAt: indexPath.section]\n    return headerView\n}\n\n@objc override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueCell(WorkLogCollectionCell.self, forIndexPath: indexPath)\n    cell.workLog = changeset?.collection.item(at: indexPath)\n    return cell\n}\n\n}\n```\n```\nclass WorkLogBinder: TableViewBinderDataSource where Changeset.Collection == Array2D {\n    @objc func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView {\n        let viewSectionHeader = UILabel(frame: CGRect(x: 0, y: 0, width: tableView.bounds.width, height: 44))\n        viewSectionHeader.textAlignment = .center\n        viewSectionHeader.text = changeset?.collection[sectionAt:section].toFormat(DateFormat.dMMMMyyyy.rawValue)\n        return viewSectionHeader\n    }\n@objc override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueCell(WorkLogCell.self, forIndexPath: indexPath)\n    cell.workLog = changeset?.collection.item(at: indexPath)\n    cell.willShowActionButton = false\n    return cell\n}\n\n}\n```\nNeither viewForSupplementaryElementOfKind in CollectionViewBinderDataSource nor viewForHeaderInSection method in TableViewBinderDataSource is getting called.\nAny idea?\n. Thanks for quick reply.\n\nAs for collection view, collectionView:viewForSupplementaryElementOfKind seems to be a data source method, so it should work. You might need to set headerReferenceSize on the layout object or collectionView:layout:referenceSizeForHeaderInSection in the delegate.\n\nI've added collectionView:layout:referenceSizeForHeaderInSection method. Now app crashes after  collectionView:layout:referenceSizeForHeaderInSection method is called. viewForSupplementaryElementOfKind method is not still called. Here is the crash log: \n2018-11-17 21:18:33.322071+0300 MyApp[18737:3330810] *** Assertion failure in -[UICollectionViewAnimation initWithView:viewType:finalLayoutAttributes:startFraction:endFraction:animateFromCurrentPostion:deleteAfterAnimation:customAnimations:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKitCore_Sim/UIKit-3698.93.8/UICollectionView_InternalHelperClasses.m:247\n2018-11-17 21:18:33.340013+0300 MyApp[18737:3330810] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'attempt to create view animation for nil view'\n*** First throw call stack:\n(\n    0   CoreFoundation                      0x000000010f1981bb __exceptionPreprocess + 331\n    1   libobjc.A.dylib                     0x000000010e21e735 objc_exception_throw + 48\n    2   CoreFoundation                      0x000000010f197f42 +[NSException raise:format:arguments:] + 98\n    3   Foundation                          0x000000010dc21877 -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 194\n    4   UIKitCore                           0x00000001189c19db -[UICollectionViewAnimation initWithView:viewType:finalLayoutAttributes:startFraction:endFraction:animateFromCurrentPostion:deleteAfterAnimation:customAnimations:] + 825\n    5   UIKitCore                           0x0000000118980cdb -[UICollectionView _viewAnimationsForCurrentUpdate] + 4677\n    6   UIKitCore                           0x0000000118986911 __71-[UICollectionView _updateWithItems:tentativelyForReordering:animator:]_block_invoke.1997 + 173\n    7   UIKitCore                           0x00000001195ed235 +[UIView(Animation) performWithoutAnimation:] + 90\n    8   UIKitCore                           0x000000011898565d -[UICollectionView _updateWithItems:tentativelyForReordering:animator:] + 3847\n    9   UIKitCore                           0x000000011897f555 -[UICollectionView _endItemAnimationsWithInvalidationContext:tentativelyForReordering:animator:] + 16936\n    10  UIKitCore                           0x000000011897aa87 -[UICollectionView _updateSections:updateAction:] + 431\n    11  UIKitCore                           0x000000011897aafa -[UICollectionView insertSections:] + 64\n    12  Bond                                0x000000010d11066c $S4Bond30CollectionViewBinderDataSourceC17applyChagesetDiffyyAA07OrderedbI0Vy10Foundation9IndexPathVGF + 1100\n    13  Bond                                0x000000010d10ff24 $S4Bond30CollectionViewBinderDataSourceC13applyChagesetyyxF + 676\n    14  Bond                                0x000000010d10f443 $S4Bond30CollectionViewBinderDataSourceC9changesetxSgvW + 435\n    15  Bond                                0x000000010d10f541 $S4Bond30CollectionViewBinderDataSourceC9changesetxSgvs + 129\n    16  Bond                                0x000000010d112182 $S11ReactiveKit14SignalProtocolP4BondAD39SectionedDataSourceChangesetConvertible7ElementRpzAA7NoErrorO0M0RtzrlE4bind2to5usingAA10Disposable_pSo16UICollectionViewC_AD010Collections6BindergH0CyAF_0I0QZGtFyAQ_AGtcfU_ + 162\n    17  Bond                                0x000000010d113ba9 $S11ReactiveKit14SignalProtocolP4BondAD39SectionedDataSourceChangesetConvertible7ElementRpzAA7NoErrorO0M0RtzrlE4bind2to5usingAA10Disposable_pSo16UICollectionViewC_AD010Collections6BindergH0CyAF_0I0QZGtFyAQ_AGtcfU_TA + 25\n    18  ReactiveKit                         0x000000010d4338de $S11ReactiveKit14SignalProtocolPA2A7NoErrorO0F0RtzrlE4bind2to7context6setterAA10Disposable_pqd___AA16ExecutionContextVyqd___7ElementQztctAA13DeallocatableRd__lFyAPcfU_yycfU_TA + 94\n    19  ReactiveKit                         0x000000010d4612ea $S11ReactiveKit16ExecutionContextV15immediateOnMainACvgZyyyccfU_ + 74\n    20  ReactiveKit                         0x000000010d432e2d $S11ReactiveKit14SignalProtocolPA2A7NoErrorO0F0RtzrlE4bind2to7context6setterAA10Disposable_pqd___AA16ExecutionContextVyqd___7ElementQztctAA13DeallocatableRd__lFyAPcfU_ + 237\n    21  ReactiveKit                         0x000000010d43382d $S11ReactiveKit14SignalProtocolPA2A7NoErrorO0F0RtzrlE4bind2to7context6setterAA10Disposable_pqd___AA16ExecutionContextVyqd___7ElementQztctAA13DeallocatableRd__lFyAPcfU_TA + 45\n    22  ReactiveKit                         0x000000010d439503 $S11ReactiveKit14SignalProtocolPAAE11observeNext4withAA10Disposable_py7ElementQzc_tFyAA5EventOyAH5ErrorQzGcfU_ + 275\n    23  ReactiveKit                         0x000000010d453cf9 $S11ReactiveKit14SignalProtocolPAAE11observeNext4withAA10Disposable_py7ElementQzc_tFyAA5EventOyAH5ErrorQzGcfU_TATm + 25\n    24  ReactiveKit                         0x000000010d4488b0 $S11ReactiveKit14SignalProtocolPAAE11observeNext4withAA10Disposable_py7ElementQzc_tFyAA5EventOyAH5ErrorQzGcfU_TA + 16\n    25  ReactiveKit                         0x000000010d456bd2 $S11ReactiveKit14AtomicObserverC2onyyAA5EventOyxq_GF + 210\n    26  ReactiveKit                         0x000000010d456d30 $S11ReactiveKit14AtomicObserverCyxq_GAA0D8ProtocolA2aEP2onyyAA5EventOy7ElementQz5ErrorQzGFTW + 16\n    27  ReactiveKit                         0x000000010d4562a9 $S11ReactiveKit16ObserverProtocolPAAE4nextyy7ElementQzF + 201\n    28  ReactiveKit                         0x000000010d442c80 $S11ReactiveKit14SignalProtocolPAAE4take5untilAA0C0Vy7ElementQz5ErrorQzGqd___tAaBRd__lFAA10Disposable_pAA14AtomicObserverCyAiKGcfU_yAA5EventOyAiKGcfU0_ + 464\n    29  ReactiveKit                         0x000000010d452aed $S11ReactiveKit14SignalProtocolPAAE4take5untilAA0C0Vy7ElementQz5ErrorQzGqd___tAaBRd__lFAA10Disposable_pAA14AtomicObserverCyAiKGcfU_yAA5EventOyAiKGcfU0_TA + 29\n    30  ReactiveKit                         0x000000010d456bd2 $S11ReactiveKit14AtomicObserverC2onyyAA5EventOyxq_GF + 210\n    31  ReactiveKit                         0x000000010d453c97 $S11ReactiveKit14SignalProtocolPAAE5start4withAA0C0Vy7ElementQz5ErrorQzGAI_tFAA10Disposable_pAA14AtomicObserverCyAiKGcfU_yAA5EventOyAiKGcfU_TA + 23\n    32  ReactiveKit                         0x000000010d45aac1 $S11ReactiveKit5EventOyxq_GIegn_ADytIegnr_s5ErrorR_r0_lTRTA + 17\n    33  ReactiveKit                         0x000000010d45ae51 $S11ReactiveKit5EventOyxq_GytIegnr_ADIegn_s5ErrorR_r0_lTRTA + 17\n    34  ReactiveKit                         0x000000010d45aa9a $S11ReactiveKit7SubjectC4sendyyAA5EventOyxq_GFyyAGXEXEfU_TA + 26\n    35  ReactiveKit                         0x000000010d458a66 $S11ReactiveKit7SubjectC15forEachObserver33_28E3A09E90FC5EE9CF408F665E91B8EFLLyyyyAA5EventOyxq_GXEXEF + 294\n    36  ReactiveKit                         0x000000010d4580c4 $S11ReactiveKit7SubjectC4sendyyAA5EventOyxq_GF + 100\n    37  ReactiveKit                         0x000000010d457f54 $S11ReactiveKit7SubjectC2onyyAA5EventOyxq_GF + 116\n    38  ReactiveKit                         0x000000010d458b70 $S11ReactiveKit7SubjectCyxq_GAA16ObserverProtocolA2aEP2onyyAA5EventOy7ElementQz5ErrorQzGFTW + 16\n    39  ReactiveKit                         0x000000010d4562a9 $S11ReactiveKit16ObserverProtocolPAAE4nextyy7ElementQzF + 201\n    40  ReactiveKit                         0x000000010d42b542 $S11ReactiveKit8PropertyC5valuexvsTf4gn_n + 178\n    41  ReactiveKit                         0x000000010d42a163 $S11ReactiveKit8PropertyC5valuexvs + 19\n    42  Bond                                0x000000010d0f8cf5 $S11ReactiveKit8PropertyC4BondAD17ChangesetProtocolRzlE9changesetxvs + 21\n    43  Bond                                0x000000010d0f9169 $S11ReactiveKit8PropertyCyxG4Bond26ChangesetContainerProtocolA2E0eG0RzlAeFP9changeset0E0QzvsTW + 9\n    44  Bond                                0x000000010d10e21d $S4Bond26ChangesetContainerProtocolPAAE17descriptiveUpdateyySay0B0_9OperationQZGAE_10CollectionQZzXEF + 269\n    45  Bond                                0x000000010d14695e $S4Bond26ChangesetContainerProtocolPA2A04TreebD00B0RpzAA016RangeReplaceableE4NodeAE_10CollectionRPzrlE6appendyyAE_AH05ChildH0QZF + 126\n    46  Bond                                0x000000010d16e9d8 $S4Bond26ChangesetContainerProtocolPA2A04TreebD00B0RpzAA0e5ArrayD0AE_10CollectionRPzAA0E4NodeVyAE_AH10ChildValueQZGAE_AH0iH0RTzAA014Array2DElementD0AMRQrlE13appendSectionyyAE_AhL0N0QZF + 312\n    47  MyApp                         0x000000010b24ab7e $S11MyApp32TimesheetApprovalDetailViewModelC5parse33_AB1CF64CAFFF0A118E5A2D3C299C0338LLyyAA0C22WorkLogsByDateResponseCF + 1806\n    48  MyApp                         0x000000010b24c1dc $STA.22 + 28\n    49  MyApp                         0x000000010b20ba8f $S11MyApp31TimesheetWorkLogsByDateResponseCIegg_ACIegn_TR + 15\n    50  MyApp                         0x000000010b20baf1 $S11MyApp31TimesheetWorkLogsByDateResponseCIegg_ACIegn_TRTA + 17\n    51  MyApp                         0x000000010b3a34e2 $S11MyApp7BaseAPIC30handleSuccessfulResponseObject33_F6C31622C0E902A97BC2201B57485A57LL11dataRequest7succeedy9Alamofire04DataR0C_yxct0H6Mapper8MappableRzlFyAH0uG0VyxGcfU_ + 706\n    52  MyApp                         0x000000010b3a46c4 $S11MyApp7BaseAPIC30handleSuccessfulResponseObject33_F6C31622C0E902A97BC2201B57485A57LL11dataRequest7succeedy9Alamofire04DataR0C_yxct0H6Mapper8MappableRzlFyAH0uG0VyxGcfU_TA + 36\n    53  Alamofire                           0x000000010d5f4f68 $S9Alamofire11DataRequestC8response5queue0D10Serializer17completionHandlerACXDSo012OS_dispatch_E0CSg_xyAA0B8ResponseVy16SerializedObjectQzGctAA0bkF8ProtocolRzlFyycfU_yycfU_TA + 56\n    54  Alamofire                           0x000000010d5ea3d0 $SIeg_IeyB_TR + 32\n    55  libdispatch.dylib                   0x00000001120fc595 _dispatch_call_block_and_release + 12\n    56  libdispatch.dylib                   0x00000001120fd602 _dispatch_client_callout + 8\n    57  libdispatch.dylib                   0x000000011210a99a _dispatch_main_queue_callback_4CF + 1541\n    58  CoreFoundation                      0x000000010f0fd3e9 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9\n    59  CoreFoundation                      0x000000010f0f7a76 __CFRunLoopRun + 2342\n    60  CoreFoundation                      0x000000010f0f6e11 CFRunLoopRunSpecific + 625\n    61  GraphicsServices                    0x0000000114a9f1dd GSEventRunModal + 62\n    62  UIKitCore                           0x000000011911181d UIApplicationMain + 140\n    63  MyApp                         0x000000010b22b0a1 $S11MyAppySpySpys4Int8VGGXEfU_ + 241\n    64  MyApp                         0x000000010b22b0d6 $SSpySpys4Int8VGGs5Error_pIgyzo_ADytsAE_pIegyrzo_TR + 22\n    65  MyApp                         0x000000010b22b15b $SSpySpys4Int8VGGs5Error_pIgyzo_ADytsAE_pIegyrzo_TRTA + 27\n    66  libswiftCore.dylib                  0x00000001103d396f $SSP17withMemoryRebound2to8capacity_qd_0_qd__m_Siqd_0_SPyqd__GKXEtKr0_lF + 15\n    67  libswiftCore.dylib                  0x00000001106242af $SSp17withMemoryRebound2to8capacity_qd_0_qd__m_Siqd_0_Spyqd__GKXEtKr0_lF + 15\n    68  MyApp                         0x000000010b22aef1 main + 321\n    69  libdyld.dylib                       0x0000000112173575 start + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException. ",
    "akshit-zaveri": "Thanks. The TextField is in a Cocoapod. I am not able to override the property in an extension. Do you suggest something?. ",
    "frankois944": "Hey, \nthinks to add unowned / weak self when using closure.\nhttps://medium.com/@abhimuralidharan/functional-programming-closure-reference-cycle-and-fix-f42cc53c6213\nHope it will help. ",
    "Guferos": "I wanted to execute the same chunk of code whenever my Observable emits a next event or when there is an event from the Subject. I didn't want to wrap the code into a function and I was looking for a way to combine both so I could put my code into one observeNext block. I've changed the PublishSubject to Observable and I made it work:\n```\n        let string = Observable(\"test\")\n        let subject = Observable(())\n    combineLatest(string, subject)\n        .observeNext(with: { _ in\n            print(\"changed\")\n            ...\n            // Here I have a large chunk of code that needs to be executed\n            // either on string or subject next event.\n        })\n\n    string.value = \"test2\"\n    // prints \"changed\"\n\n    subject.next()\n    // prints \"changed\"\n\n``\nStill unsure though if this is a proper way of handling my case.. Thanks for the very detailed answer. I end up using thestart(with:)` method.. Could not find anything online so I end up writing simple wrappers myself. \nRealm collection to ObservableRealmArray (same behaviour as ObservableArray):\nObservableRealmArray - gist\nRealm Object to ObservableRealmObject (same behaviour as Observable):\nObservableRealmObject - gist\nAnd you can simply use it like in the example below:\n```\nclass User: Object {\n    @objc dynamic var firstName = \"\"\n    @objc dynamic var lastName = \"\"\n}\nclass ViewController: UIViewController {\n@IBOutlet private weak var tableView: UITableView!\nvar users: ObservableRealmArray?\n  var user: ObservableRealmObject?\noverride func viewDidLoad() {\n     super.viewDidLoad()\n let realm = try! Realm()\n\n users = realm.objects(User.self).sorted(byKeyPath: \"firstName\", ascending: true).toObservable()\n\n users?\n    .bind(to: tableView, createCell: { (data, indexPath, tableView) -> UITableViewCell in\n       let cellIdentifier = \"Cell\"\n       var cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier)\n       if cell == nil {\n           cell = UITableViewCell(style: .subtitle, reuseIdentifier: cellIdentifier)\n       }\n       let user = data.item(at: indexPath.row)\n       cell?.textLabel?.text = user.firstName\n       cell?.detailTextLabel?.text = user.lastName\n       return cell ?? UITableViewCell()\n   })\n\n  user = realm.objects(User.self).first?.toObservable()\n  user?.map({ $0?.firstName }).bind(to: navigationItem.reactive.title)\n\n}\n}\n```\nIt works pretty well, the only issue may arise when one will feed ObservableRealmArray with large collection from the Realm query. The Realm collections are lazy but the ObservableRealmArray loads all the data immediately therefore it may block the UI during updates. However collections must be really huge to cause any blocking, I've tested 10k records and it was still fine. To avoid any issues make sure you filter the data on the query level if you have massive collections of objects.. Found a small issue with ObservableRealmObject. I didn't know that once object is deleted from the Realm db it gets invalidated and cannot be accessed anymore, therefore deletion callback needs to be handled and the value property in the ObservableRealmObject must be changed to an optional . Will try to update it today.. I have updated the ObservableRealmObject to use optional for its value and the observer is handling the deleted notification now. . I've just test it and it works like a charm! It's great to see how easily it all mapped together and I am excited that we can keep the Result type so the lazy loading stays.\nIt's very tempting to update to the Bond-7 now, therefore I wondered if you planning more API changes in that release or it's all about bugs fixing and performance improvements now?. Thanks for replying ! I'll stick to what I have then.. ",
    "bbaic": "@CelinaSkywalker  I want to say it's because the UILabel doesn't emit signals, as it only changes programatically. Replacing it with a UITextField (with no other changes to your code) worked in a test for me. May not solve your desired use case here, but it's something...!. Awesome, thank you for your hard work creating/maintaining this!. a2DArray.collection.children.map({ $0.count }).reduce(0, +) do what you want?. My fault!! \nThe table and datasource got rebound during the navigation exchange.... ",
    "dsringari": "I resolved my specific issue by accessing the NSObject through myMutableObservableArray.collection[indexOfMyElement].readStatus = true, which worked. But how could I replace the entire object if needed?. ",
    "akospalfi": "Thank you for your suggestions Sr\u0111an, it really improves the code, I'll test it in my app and will let you know the results. I also have plans to implement support for sectioned data, and I only tested this on macOS, but I'm curious if it works correctly on iOS as well. Would you be interested to merge this piece of code to Bond when it's done?\nAnother question that come into my mind since I wrote the original code is that how could it work in a bidirectional fashion? So that if the tableview is editable then the changes could be automatically propagated to Core Data. I haven't looked into the code yet, I'm just thinking out loud and wondering if this is something that you think would worth working on?\n. > If we were to add this to Bond, then Bond would have a dependency on CoreData. Most users don't use CoreData so I'm not in a favour of adding such dependency.\nMakes sense.\n\nBut if you come up with a nice implementation, it would be great if you would add it to the Extensions directory and make a PR.\n\nThank you, I'll put it all together, test it and prepare a PR.. Oh, now everything makes total sense! Thank you so much for the detailed explanation Srdan!\nNow I see that the problem was of course in my own code, but I was testing with a very complicated dataset, and I wasn\u2019t able to figure out from the logs why the indices are so \u2018weird\u2019, but now I was able to solve the puzzle. :). ",
    "Super29": "Thanks it worked for me. \ud83d\udc4d \n. ",
    "pilmen": "Yep, that\u2019s what I do. I thought it whould be great to add it like a property to Observable2DArray. \n. Pull request with these improvements was merged into master branch. So I think we can expect this functionality in next version.. One more thing Custom Cell identifier should match Cell's class name.. #591 . Yes, numberOfItemsInAllSections is more explicit. Thanks.. ",
    "DivineDominion": "@tonyarnold  Can you post a link to your PR?. I'm hunting down a similar crash in another situation (and without Bond), so I am curious what you did to fix this.. Thanks a ton!. "
}