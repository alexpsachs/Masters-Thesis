{
    "dhh": "You change the key. Either change something in the template to bust the digest or touch the models it depends on. \nOn Sep 2, 2012, at 11:08, lephyrius notifications@github.com wrote:\n\nHow do I manually expire fragments?\n\u2014\nReply to this email directly or view it on GitHub.\n. We already have a cache for this: https://github.com/mschae/cache_digests/blob/63e29254153c1cc99fead9622419e249b7532ba0/lib/cache_digests/template_digestor.rb#L28\n. That is indeed the case. I've documented things when this got merged into Rails:\nhttps://github.com/rails/rails/blob/502d5e24e28b3634910495d0fb71cb20b1426aee/actionpack/lib/action_view/helpers/cache_helper.rb\n\nOn Sep 25, 2012, at 11:37 AM, Cody Robbins wrote:\n\nSkimming through the code it looks like if a template calls a helper; and the helper is changed; then the digest for the cache won\u2019t change and the cache won\u2019t be busted. If this is indeed the case it\u2019s something to be aware of and I think it should be mentioned in the readme. I\u2019m happy to make the change.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nDavid Heinemeier Hansson\n. Just one comment on the implementation. Otherwise looks good. Please prepare a PR for rails/master as well. Thanks for finding and fixing this.\n. Perfect, thanks again.\n. This has not been tested with haml, so if its not working, it'll need someone who cares to work on that to look into it. \nOn Oct 31, 2012, at 4:48, mb-dev notifications@github.com wrote:\n\nI am having trouble getting this to work. I update the partial but the caching is still not refreshing.\nLet me know if this is compatible with haml and i'll post some code snippets.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, and jbuilder. Please do investigate.\n\nOn Oct 31, 2012, at 9:24 AM, Piotrek Oko\u0144ski notifications@github.com wrote:\n\n@ddh was it tested with ERB only? Because I'm willing to take a look into HAML/Slim issues.\n\u2014\nReply to this email directly or view it on GitHub.\n. I haven't heard of any. Have at it!\n\nOn Dec 6, 2012, at 1:20, Brandon Hansen notifications@github.com wrote:\n\nDo we have any movement on this? If not, it is something that I would be interested in looking in to.\n\u2014\nReply to this email directly or view it on GitHub.\n. Probably not. Putting the local in there or wrapping the cache call in local_cache sounds like the way to go. \n\nOn Nov 2, 2012, at 8:47, Kalys Osmonov notifications@github.com wrote:\n\nLet's assume that we have partial like below:\n<% cache @post do %>\n  <%= t(:post_created_at) %> <%= @post.created_at %>\n<% end %>\nCaching doesn't know about locales and it won't replace cache if locale is changed.\nThe following code works.\n<% cache [I18n.locale, @post] do %>\n  <%= t(:post_created_at) %> <%= @post.created_at %>\n<% end %>\nWill caching implicitly depend on I18n.locale in future versions?\n\u2014\nReply to this email directly or view it on GitHub.\n. Please create a similar PR for rails/master. Thanks!\n. If you don't want the templates cached, why would you turn caching on in development mode? By default it's off. I don't really understand this request?\n. Fabio, if you leave caching off in development, then the template digest is not used. If you turn caching ON, then template digests are used, and so are the caches. Isn't that the point? Otherwise you're paying for the stat calls on every request to check the whole graph, which might take a while, somewhat defeating the purpose of turning caching on.\n\nOn Dec 15, 2012, at 6:30 PM, Fabio Rehm notifications@github.com wrote:\n\n@genezys that's actually better that what I've done :-)\n@dhh not sure if I got it right but looking at this part of the code seems that this specific cache from the code I provided is used to avoid \"recalculating\" the template digest for a given fragment (which under development might change).\nEven though we are replacing it with a NullStore, the result of rendering the template would still be cached if the application cache is enabled.\n\u2014\nReply to this email directly or view it on GitHub.\n. Correct, but the whole cache do/end call is being ignored when caching is off-by-default in development. You are only seeing this problem as you turn caching on explicitly, no?\n\nOn Dec 15, 2012, at 7:08 PM, Fabio Rehm notifications@github.com wrote:\n\nMaybe I'm missing something but because of the ActiveSupport::Cache::MemoryStore set here, digests won't change if the views have changed, that's why we have to restart the app to see the changes :-)\nI know that each request would end up recalculating the digest, but we'd still be caching the result of whatever hard work is being done on the fragment itself. On environments other than development we'd still keep the MemoryStore around.\n\u2014\nReply to this email directly or view it on GitHub.\n. :+1:\n\nOn Dec 15, 2012, at 19:36, Fabio Rehm notifications@github.com wrote:\n\nYup I forgot to mention that, my bad :-P\nMaybe the README note that @genezys proposed could be changed to something like:\nNote that if your application cache is enabled, the template digest will not be recomputed until you restart your application and you will have to restart the app whenever you change template code.\nFor development environment you might want to cache your fragments AND have dependent partials changes detected (with the penalty of recomputing the digests for each request). For that you can add CacheDigests::TemplateDigestor.cache = ActiveSupport::Cache::NullStore.new to your development configuration.\nWDYT?\n\u2014\nReply to this email directly or view it on GitHub.\n. I like skip_digest: true. Do make it so. \n\nOn Nov 20, 2012, at 22:51, Drew Ulmer notifications@github.com wrote:\n\nBecause Memcache has no way of searching for a key by regex and cache_digests adds an MD5 hash to the end of all cache keys (with the notable exception of any keys that are arrays with the first element being \"v#\"), I humbly request an additional way to indicate an explicit opt-out of the addition of the fragment digest for a single cache call. This would allow something like this:\n<%= cache ['v1', 'sidebar-navigation'] do %>\n  <%= render \"sidebar-item\", :collection => expensive_queried_collection %>\n<% end %>\nMy cached navigation only needs to be invalidated after I update one of the items in the collection but there's no way to find this using Memcache due to the MD5 hash. In this circumstance, having a key without an MD5 hash would allow easy lookup and expiration.\nImplementation ideas:\n<%# view %>\n<%= cache 'sidebar-navigation', :skip_cache_digest => false do %>\nlib/cache_digests/fragment_helper.rb\ndef fragment_for(key, options = nil, &block)\n  skip_digest = expicitly_versioned_cache_key? || (options && options.delete(:skip_cache_digest))\n  # ...\nend\nI'll submit a PR if this idea seems acceptable.\n\u2014\nReply to this email directly or view it on GitHub.\n. Caching classes doesn't really have anything to do with this, though.\n\nHow is this a problem for you?\nOn Nov 21, 2012, at 12:57, Prathan Thananart notifications@github.com wrote:\n\nIt wasn't until I inspect the source of CacheDigests::TemplateDigestor that I realized the digests themselves are only compute once and cached in a MemoryStore.\nIt would be nice if cache_digests could detect if class caching is disabled in Rails, then disable this caching of digests, following the principle of least surprise.\n\u2014\nReply to this email directly or view it on GitHub.\n. We should have a dedicated setting, then.\n\nOn Nov 21, 2012, at 23:39, Prathan Thananart notifications@github.com wrote:\n\nI'm working on an app which will employ russian-doll caching heavily, and I'd like to have perform_caching enabled in development to make sure fragments get rendered/cached correctly.\n\u2014\nReply to this email directly or view it on GitHub.\n. Call #touch on whatever you've made that cache depend on. See key-based expiration. \n. Cache digests is not intended to work with manual expiration using a sweeper. Only key-based expiration. \n\nOn Nov 24, 2012, at 9:24, phuongnd08 notifications@github.com wrote:\n\nOkay, I guess my case is a little special:\nSo I make a cache like this:\ncache 'testimonials' do = render 'testimonials', :testimonials => Testimonial.approved\nInside the testimonials template, we fetch all approved testimonials using: Testimonial.approved and render each of them. We implemented a sweeper to make a call to expire_fragment('testimonial') when a testimonial is changed. But as far as I tried, expire_fragment doesn't work (because the cache key 'testimonial/'?)\n\u2014\nReply to this email directly or view it on GitHub.\n. Correct. They are not designed to work together. Cache digests are only intended to work together with key-based expiration where you never need to manually expire and know the whole cache key.\n\nThere's a pull request available for turning off the digest on a per-call basis pending, though. \nOn Nov 25, 2012, at 7:05, phuongnd08 notifications@github.com wrote:\n\nAre you saying expire_fragment work without cache_digests but won't work with cache_digests?\n\u2014\nReply to this email directly or view it on GitHub.\n. Great work. Can you get this fix into rails/master as well?\n. Hmm, how do we currently lookup template handler from the extension? There must be something similar to do here.\n\nOn Feb 19, 2013, at 12:31 PM, Daniel Schierbeck notifications@github.com wrote:\n\n@dhh this has been tested and works with Curly. However, I'm not quite sure how tracker registry should work. Since Template#handler returns the actual handler object, not a symbolic representation (e.g. :erb) we need to do e.g.\nCacheDigests::DependencyTracker.register_tracker(ERB, ErbTracker)\nI'm not sure if it's possible to get a symbolic representation of the template type, since it doesn't seem to be stored on Template. Would it be okay to use the actual objects as keys?\n\u2014\nReply to this email directly or view it on GitHub.\n. Looking good. Can you cross-post a pull to rails/master? Then we'll get a review going.\n. Please rebase.\n. I like the idea. Have you actually used this for a second dependency tracker, like for mustache or something else?\n\nOn Feb 18, 2013, at 4:26 PM, Daniel Schierbeck notifications@github.com wrote:\n\n@dhh done.\nWhat do you feel about #19?\n\u2014\nReply to this email directly or view it on GitHub.\n. I'd definitely be happy to support this extension. Makes good sense to me.\n\nOn Feb 18, 2013, at 6:37 PM, Daniel Schierbeck notifications@github.com wrote:\n\n@dhh I developed it for Curly, which is similar to Mustache in design. I haven't had it running for a while, I can try hooking it up again tomorrow. There's also an open PR on the Rails repo, but it hasn't received much attention.\n\u2014\nReply to this email directly or view it on GitHub.\n. This is great. Let's notch up the explicit nature though and call it view_cache_dependency. Then we're good to go.\n\nCould you send a PR against rails/master as well for parity?\nThanks!\n. Yup, that'll work! Cache will be busted when you change the content. But of all you are doing is what you show below, it's not really worth it. The goal is to save on computation. No real computation is needed for that block.\nOn Jan 16, 2013, at 2:37, hayksaakian notifications@github.com wrote:\n\nMaybe I'm too new at this, but is there any way this could be used to cache static pages generated with embedded ruby (html.erb)?\nexample: I have some marketing pages with embedded ruby in my InfoController.\nAn about us page, tutorial page, a downloads page, and these will only ever change between code updates.\nI'm not sure how to implement this, or if cache digests are even the correct way to do it.\nsomething like\nin InfoController#about\n<% cache %>\n    About\nThis is a Software as a Service web application\n    <%= link_to 'learn how to use the software', tutorial_path %>\n<% end %>\n\u2014\nReply to this email directly or view it on GitHub.\n. You have to explicitly state the dependencies in that case. See the docs on explicit deps and ignore the log line. \n. Right, then it's all good! Just ignore the logging.\n\nOn Feb 1, 2013, at 15:44, Nick notifications@github.com wrote:\n\nSorry, but I have tried to add template dependencies like this before render:\n<%# Template Dependency: objects/item_features_rent %>\n<%# Template Dependency: objects/item_features_sale %>\nBut it says that it can't find the template anyway. Guess I will have to ignore it.\n\u2014\nReply to this email directly or view it on GitHub.\n. Cache digests is not designed to be manually expired. The cache will simply stop being used when the key changes. See http://37signals.com/svn/posts/3113-how-key-based-cache-expiration-works.\n. Not like this, no. What you can do to have a similar effect is make a timestamp part of the key that you'll manually bump to signify the expiration.\n\nOn Feb 18, 2013, at 4:56 PM, tomaswitek notifications@github.com wrote:\n\nThanks for quick reply. I know how it works, but there is no possibility to use these two types of invalidation separately in one application?\n\u2014\nReply to this email directly or view it on GitHub.\n. Cache digests have been rolled into Rails. So it's the same code base.\n\nIn your case, I would just add an md5 of the runtime template to the cache key itself. That's all Rails does anyway. So <% cache person, custom_template.md5 do %>.\nOn Feb 26, 2013, at 4:31 AM, Daniel Schierbeck notifications@github.com wrote:\n\nI'm running into an issue that makes it hard to use Cache Digests in some cases. In the app I'm working on, users can upload custom templates. When these templates are rendered directly as views, Cache Digests works fine -- the template is resolved by a custom resolver, and the template handler injects a cache call that includes the template's digest (computed separately) in the cache key. This trick doesn't work if the custom template is rendered as a partial, as it is assumed that a template does not change at runtime.\nI can get around this by disabling caching of digests -- then all templates are loaded and their digests computed. I could even get rid of my custom digest hack that predates Cache Digests. However, this would impact performance.\nIf Cache Digests included the view path in the cache keys, I think the issue would go away. We could ask each resolver in the path for a cache key and include them in the final cache key. That way, my custom resolver could just check if there have been any changes to the templates since last time and compute a cache key accordingly.\nIs this something you would be interested in having in Cache Digests? It feels like it would touch too deeply into Rails, so perhaps it should just go there instead.\n\u2014\nReply to this email directly or view it on GitHub.\n. Pushed new 0.3.0 version.\n. Can you make this update to rails/master as well? I think we need to get it into 4-0-0 and 4-0-stable as well.\n. Ah, wasn't aware of the fork there.\n. Can you add a test for this to prevent regression? And then submit a PR for rails/master as well. Thanks for finding this!\n. Please confirm if this is an issue on 4-0-stable/4-0-0/master as well. Thanks!\n. Open one for master and note that it applies to all of them. \n\nOn May 28, 2013, at 23:42, Sean Huber notifications@github.com wrote:\n\nIt does still appear to be an issue for 4-0-stable/4-0-0/master. Each of those railties need the action_view.caching initializer updated with\nunless ActionView::Base.cache_template_loading\n  ActionView::Digestor.cache = ActiveSupport::Cache::NullStore.new\nend\nDoes a pull request need to be opened for each branch? Or just 4-0-stable?\n\u2014\nReply to this email directly or view it on GitHub.\n. This could definitely be handy. When encapsulating caches expire, you often have to read a lot of underlying caches. Very curious how you intend to solve this, though. ERb's a processed linearly. So you're going to have to make some sort of two pass solution where you keep track of cache misses and then go back and re-render. Kinda of science project, and may screw with things like progressive rendering, but give it a shot!\n\nOn Jun 2, 2013, at 12:08 AM, Randy Schmidt notifications@github.com wrote:\n\nDo you think there is much benefit to adding tracking of the keys and using read_multi if there are a lot?\nI know the goal of this gem is that in the end you only have a few keys since changes propagate up. However, I'm using this on a site that is kind of hard to do that which results in a lot of cache reads. I'm mostly using this gem for the key change when the template is updated feature.\nI'd be happy to investigate if you think it would be worth it.\n\u2014\nReply to this email directly or view it on GitHub.\n. Please fix this for rails/master as well. Thanks!\n. 0.3.1 released.\n. Why is that a problem? Why shouldn't the cache be shared between \"1\" and [\"1\"]?\n\nOn Jun 17, 2013, at 9:10 AM, Kevin Sylvestre notifications@github.com wrote:\n\nIt appears cache keys are identical for an ActiveRecord::Base and ActiveRecord::Relation if the ActiveRecord::Relation is the single ActiveRecord::Base object. For example:\nPerson.create(name: \"Kevin\")\n@person = Person.find_by(name: \"Kevin\") # \n@people = Person.where(name: \"Kevin\") # ]>\n@person.to_json # { name: \"Kevin\" }\n@people.to_json # [{ name: \"Kevin\" }]\nThis causes a bug with the following snippet:\n<% # user/_json.html.erb %>\n<% cache object do %>\n<%= object.to_json %>\n<% end %>\nResults:\n<% # user/random.html.erb %>\n<%= render 'json', object: @people %> # [{ name: \"Kevin\" }]\n<%= render 'json', object: @person %> # [{ name: \"Kevin\" }]\nNote: the last two lines result in the same JSON although the second should not be nested inside an array.\n\u2014\nReply to this email directly or view it on GitHub.\n. Cache digests includes the path of the partial in the cache key. So you can use \"cache @model\" in two different partials without a collision.\n\nOn Jun 17, 2013, at 6:47 PM, Kevin Sylvestre notifications@github.com wrote:\n\n@dhh Thanks for getting back. My thought is that the keys should be different because ActiveRecord::Base and ActiveRecord::Relation are completely different and won't return consistent results for any of the to_json, to_xml, etc methods.\nI ran into an issue trying to cache a partial used to render either a Backbone model or collection into the DOM on page load. I fixed it by using two different partials for the relation versus base, however it wasn't clear this is desired behavior.\n\u2014\nReply to this email directly or view it on GitHub.\n. If it's the same partial, I don't understand why the output would be different between [1] and \"1\"? If the output is different, then different partials sounds like the way to go.\n\nOn Jun 17, 2013, at 7:44 PM, Kevin Sylvestre notifications@github.com wrote:\n\n@dhh Thanks. I ran into a collision because I was using the the same partial (maybe a bad idea? the code was the same for both in my case). Closing.\n\u2014\nReply to this email directly or view it on GitHub.\n. Hi dasch, how is 'devices' different from the feature we already have in formats? Which is already being computed as part of the cache digest.\n. Gotcha. Seems reasonable. cache_digests have been rolled into Rails, so this repo actually isn't maintained any more. I should make that clear. But please submit a PR to Rails itself!\n. No, I'd like to have these tasks in Rails 4 as well. Please extract and prepare a PR for Rails.\n\nOn Sep 26, 2013, at 12:37 AM, Thomas von Deyen notifications@github.com wrote:\n\nThis gem offers great rake tasks:\nrake cache_digests:dependencies \nrake cache_digests:nested_dependencies\nAlthough cache_digests was merged into Rails 4, the rake tasks weren't?\nIs there any reason for this?\n\u2014\nReply to this email directly or view it on GitHub.\n. Inline this as name.split(\"/\")[0..-2].join(\"/\").\n. \n",
    "kalys": "Will Rails.cache.clear work?\n. Thank you.\n. ",
    "krainboltgreene": "I'm actually having problems that indicates Rails.cache.clear won't bust the cache.\n. ",
    "unimatrixZxero": "+1\n. ",
    "mschae": "Thanks @kirel for your input\n. Sorry for the oversight, thanks\n. ",
    "codyrobbins": "Missed that\u2014thanks!\n. ",
    "mrship": "OK, I've inlined the directory splitting as suggested. I'll do the rails PR shortly.\n. I'm having issues with getting Rails to install from source locally. It's hanging on the bundle install when communicating with Rubygems. However, I've patched my fork of Rails with the changes needed. \nPerhaps you can review the commit and see if it's enough for you to commit to rails/master? I appreciate it isn't ideal, but I'd be unsure about creating a PR for rails/master that I couldn't actually test myself.\nThoughts?\n. OK, I got it working (eventually!). PR for Rails submitted.\n. ",
    "pokonski": "@ddh was it tested with ERB only? Because I'm willing to take a look into HAML/Slim issues.\n. ",
    "Arjeno": "I can confirm it's working with Slim. Although not in development mode.\n. ",
    "azul": "Does not seem to work with haml for me either. Adding content in the template that has the cache line will not expire the cache in development.\n. @phuongnd08 same thing here. Have you been able to fix it?\n. Turns out i still lacked the initializer and with the initializer it works for me now.\nThanks for the quick reply never the less, @phuongnd08. :smile: \n. ",
    "ready4god2513": "Do we have any movement on this?  If not, it is something that I would be interested in looking in to.\n. ",
    "dasch": "Could the dependency tracking be moved to the template handlers, perchance? That way, each handler could go about it its own way. \n. Also: this refactoring would make it easier to test the specific dependency tracking code, e.g. by passing in the source directly instead of using file fixtures.\nruby\nclass ErbTrackerTest < TestCase\n  def test_extracts_explicit_dependencies\n    source = %(<%# Template Dependency: foo/bar %>)\n    template = FakeTemplate.new(\"baz\", source)\n    assert_equal [\"foo/bar\"], ErbTracker.call(\"baz\", template)\n  end\nend\n. @dhh this has been tested and works with Curly. However, I'm not quite sure how tracker registry should work. Since Template#handler returns the actual handler object, not a symbolic representation (e.g. :erb) we need to do e.g.\nruby\nCacheDigests::DependencyTracker.register_tracker(ERB, ErbTracker)\nI'm not sure if it's possible to get a symbolic representation of the template type, since it doesn't seem to be stored on Template. Would it be okay to use the actual objects as keys?\nUpdate: We could use ActionView::Template.handler_for_extension to resolve the symbolic representation at startup time. That's probably the best.\n. > Hmm, how do we currently lookup template handler from the extension?\nThe template resolvers call ActionView::Template.handler_for_extension with the symbolic name, getting a handler back. Unfortunately, the symbolic name is not stored on the Template instances the same way formats is, so we only have the handler object to go by.\nI think it would be best if register_tracker did something like this:\nruby\ndef register_tracker(extension, tracker)\n  handler = ActionView::Template.handler_for_extension(extension)\n  @trackers[handler] = tracker\nend\n. @ddh I think this is looking pretty good. The only remaining question I have is whether to register the ERBTracker with other supported extensions, e.g. builder or HAML?\n. @dhh there was already one open. I've rebased it and updated it with the changes from this PR: https://github.com/rails/rails/pull/8530\n. @dhh done.\nWhat do you feel about #19?\n. @dhh I developed it for Curly, which is similar to Mustache in design. I haven't had it running for a while, I can try hooking it up again tomorrow. There's also an open PR on the Rails repo, but it hasn't received much attention.\n. @dhh we're running into issues in production \u2013 would it be okay to merge this in?\n. @dhh I chose this example before that feature was added to Rails :-)\nI'm running a multi-tenant app where the customer can select from different themes. We have a custom resolver that loads a subset of templates based on the current theme, which is passed as part of the details. Since cache_digests does not take these details into consideration, we don't get proper cache busting when we deploy. Since the details are solely used to correctly look up the desired templates \u2013 and are configurable \u2013 I feel that cache_digests should support them.\n. ",
    "balexand": "I'm using cache_digests with HAML and the only issue I can find is fixed in #21. I also created tests in #22. I included the tests separately, since I'm not sure if @dhh will want the added complexity in the test suite. This issue can be closed after #21 is merged.\n. This issue can be closed now that #34 has been merged. /cc @rafaelfranca \n. A workaround for this is to include a trailing space after the explicit dependency. And since relying on trailing spaces is a terrible idea, I'd also suggest adding another arbitrary character after the trailing space like this:\n-# Template Dependency: things/_thing >\n. Sure. I'll add tests to this PR shortly.\n. @rafaelfranca @elia I created #34, which includes tests. I didn't know how to add more commits to this PR since I had deleted my fork of the repo. Sorry for the issue clutter. Thanks!\n. Closing. I'll add some simpler tests to #21 like I did in https://github.com/rails/rails/pull/8586\n. @rafaelfranca Thanks. I appreciate that you're always so quick with feedback on and merging of pull requests. :smile: \n. ",
    "rafaelfranca": "Yes. Thank you\n. Could you add the tests too?\n. Thank you. Is my job as Rails Core member to make easier to contribute. \n. Could you update this pull request too?\n. Merged in 4-0-stable\n. ",
    "phuongnd08": "I'm using cache_digests (0.3.1) with haml right now and rake  cache_digests:dependencies still returns empty array all the time. I even put this in initializer: CacheDigests::DependencyTracker.register_tracker :haml, CacheDigests::DependencyTracker::ERBTracker.\n. I switched over to AngularJS a while back so we no longer need html fragment caching.\n. Okay, I guess my case is a little special:\nSo I make a cache like this:\n- cache 'testimonials' do\n  = render 'testimonials', :testimonials => Testimonial.approved\nWe implemented a sweeper to make a call to expire_fragment('testimonial') when a testimonial is changed. But as far as I tried, expire_fragment doesn't work (because the cache key 'testimonial/'?)\n. Are you saying expire_fragment work without cache_digests but won't work with cache_digests?\n. Oh, look like it won't work during development mode because the digest is calculated only once\n. Fantastic. Thanks.\n. @latortuga: I don't understand cache_digests that well to know if such method is necessary or not :) Let's hear from @dhh then.\n. ",
    "jjb": "as of https://github.com/indirect/haml-rails/pull/51/, haml-rails will automagically do this\n. update: https://github.com/indirect/haml-rails/ will now automagically include the initializer code. so if you are using rails you can just put haml-rails in your gemfile and this is taken care of.\n. Whoops, meant to submit this to rails. Will do so...\n. ",
    "pekeler": "Your suggestion solves changing the locale, but what if I change the translation for :post_created_at?\nhttp://stackoverflow.com/questions/11055056/how-can-the-cache-for-the-views-with-translations-be-invalidated has an interesting solution. However, figuring out the scopes for deeply nested views is a hassle and seems like it would duplicate the work that cache_digest does anyways (finding sub-views). So I think it would make a lot of sense if cache_digest was i18n-aware.\n. ",
    "cmer": "+1\n. Would really like to see this merged.\n. ",
    "fgrehm": "I was able to get it working under development with this monkey patch:\nterminal\nif Rails.env.development?\n  class CacheDigests::TemplateDigestor\n    cattr_accessor(:cache) { ActiveSupport::Cache::NullStore.new }\n  end\nend\nJust place this code on a initializer file and things will work just fine ;-)\nThis might also be a fix / workaround for #8 \n@ddh does it make sense to have something like this code on the gem itself?\n. @genezys that's actually better that what I've done :-)\n@dhh not sure if I got it right but looking at this part of the code seems that this specific cache from the code I provided is used to avoid \"recalculating\" the template digest for a given fragment (which under development might change).\nEven though we are replacing it with a NullStore, the result of rendering the template would still be cached if the application cache is enabled.\n. Maybe I'm missing something but because of the ActiveSupport::Cache::MemoryStore set here, digests won't change if the views have changed, that's why we have to restart the app to see the changes :-)\nI know that each request would end up recalculating the digest, but we'd still be caching the result of whatever hard work is being done on the fragment itself. On environments other than development we'd still keep the MemoryStore around.\n. Yup I forgot to mention that, my bad :-P\nMaybe the README note that @genezys proposed could be changed to something like:\n```\nNote that if your application cache is enabled, the template digest will not be recomputed until you restart your application and you will have to restart the app whenever you change template code.\nFor development environment you might want to cache your fragments AND have dependent partials changes detected (with the penalty of recomputing the digests for each request). For that you can add CacheDigests::TemplateDigestor.cache = ActiveSupport::Cache::NullStore.new to your development configuration.\n```\nWDYT?\n. @genezys I had some free time today and ended up creating the new request :-)\n. Join us at #11 :-)\n. @dhh Thanks!\n. ",
    "genezys": "Thanks @fgrehm for the idea. I ended adding the following line at the end of my environments/development.rb\nCacheDigests::TemplateDigestor.cache = ActiveSupport::Cache::NullStore.new\n. I agree the new comment is better. I will create a new request with it.\n@dhh About enabling caching in development, I think this is a good idea to check the behavior of caching in development because caching has an impact on the logic of the app. I want to see if my queries are ok, if I missed a partial declaration or if I missed a touch attribute on a relation. When I enable caching in development, I don't need the performance improvement, I just need the caching behavior.\n. ",
    "scomma": "If maintainers approve of the idea I'll work on a pull request.\n. I'm working on an app which will employ russian-doll caching heavily, and I'd like to have perform_caching enabled in development to make sure fragments get rendered/cached correctly.\n. Ok, working on a patch.\n. ",
    "HaloZero": "I'm with @scomma on this, it would be nice to know this since I wanted to test how well it works before I deploy it. assuming that this is the reason why it doesn't work in development mode.\n. ",
    "BlakeWilliams": "Sounds broken to me.\n. ",
    "latortuga": "Yes absolutely. I will post again when I submit it.\nOn Nov 25, 2012 5:49 AM, \"David Heinemeier Hansson\" \nnotifications@github.com wrote:\n\nGreat work. Can you get this fix into rails/master as well?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/rails/cache_digests/pull/16#issuecomment-10692616.\n. @dhh @phuongnd08 I have a unit test and an implementation for skip_cache: true in rails master however there is currently no support for cache_digests' explicitly_versioned_cache_key? check. Would you like me to add that implementation as well?\n. You can declare dependencies explicitly very easily. The readme is pretty clear that it isn't intended to catch all versions of render and that you'll have to be explicit sometimes.\n. I guess I'm not sure. The easy fix is to be explicit. I can look into writing a fix but I'll defer to @dhh before spending time on it. My guess is that this probably won't be changed due to a) needing to change both Rails master and this gem and b) it being such a small difference that can be mitigated in a well-documented way.\n. Good find, I just reproduced this as a regex issue, I'll submit a PR to fix it soonish. \n. Will do.\n. \n",
    "michal-samluk": "This bug is still present with cache_digests 0.3.1. \nCouldn't find template for digesting: eds/ed.html\n. ",
    "elia": "@rafaelfranca this has been merged into rails (as rails/rails#8586), can you merge this PR too?\n. @rafaelfranca I think they're in #22 \n/cc @balexand\n. ",
    "GabKlein": "After couple of test its a problem with \ngem \"mongoid\", :git => 'git://github.com/mongoid/mongoid.git', :branch => \"4.0.0-dev\"\n. ",
    "satb": "I am getting the same error as well. Using JRuby 1.7.2 and rails 3.2.12. I am using the \"closure_tree\" gem that has some sort of recursion. Don't know if that is causing this.\nSystemStackError - stack level too deep:\n  org/jruby/RubyProc.java:261:in call'\n  org/jruby/RubyProc.java:249:incall'\n  org/jruby/RubyHash.java:681:in default'\n  org/jruby/RubyHash.java:1070:in[]'\n  (gem) actionpack-3.2.12/lib/action_view/template/resolver.rb:127:in query'\n  org/jruby/RubyArray.java:2595:inreject!'\n  org/jruby/RubyArray.java:2558:in reject'\n  (gem) actionpack-3.2.12/lib/action_view/template/resolver.rb:126:inquery'\n  (gem) actionpack-3.2.12/lib/action_view/template/resolver.rb:117:in find_templates'\n  (gem) actionpack-3.2.12/lib/action_view/template/resolver.rb:46:infind_all'\n  (gem) actionpack-3.2.12/lib/action_view/template/resolver.rb:77:in cached'\n  (gem) actionpack-3.2.12/lib/action_view/template/resolver.rb:45:infind_all'\n  (gem) actionpack-3.2.12/lib/action_view/path_set.rb:65:in find_all'\n  org/jruby/RubyArray.java:1613:ineach'\n  (gem) actionpack-3.2.12/lib/action_view/path_set.rb:64:in find_all'\n  org/jruby/RubyArray.java:1613:ineach'\n  (gem) actionpack-3.2.12/lib/action_view/path_set.rb:63:in find_all'\n  (gem) actionpack-3.2.12/lib/action_view/path_set.rb:58:infind'\n  (gem) actionpack-3.2.12/lib/action_view/lookup_context.rb:109:in find'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:79:insource'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:43:in digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:32:indigest'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:297:in fetch'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:520:ininstrument'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:296:in fetch'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:31:indigest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:85:in dependency_digest'\n  org/jruby/RubyArray.java:2348:incollect'\n  org/jruby/RubyArray.java:2356:in collect'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:84:independency_digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:43:in digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:32:indigest'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:297:in fetch'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:520:ininstrument'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:296:in fetch'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:31:indigest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:85:in dependency_digest'\n  org/jruby/RubyArray.java:2348:incollect'\n  org/jruby/RubyArray.java:2356:in collect'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:84:independency_digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:43:in digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:32:indigest'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:297:in fetch'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:520:ininstrument'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:296:in fetch'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:31:indigest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:85:in dependency_digest'\n  org/jruby/RubyArray.java:2348:incollect'\n  org/jruby/RubyArray.java:2356:in collect'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:84:independency_digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:43:in digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:32:indigest'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:297:in fetch'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:520:ininstrument'\n  (gem) activesupport-3.2.12/lib/active_support/cache.rb:296:in fetch'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:31:indigest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:85:in dependency_digest'\n  org/jruby/RubyArray.java:2348:incollect'\n  org/jruby/RubyArray.java:2356:in collect'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:84:independency_digest'\n  (gem) cache_digests-0.2.0/lib/cache_digests/template_digestor.rb:43:in `digest'\nNot having issues if I remove \"cache_digests\". It works without causing the \"stack too deep\" problem with just fragment caching\napplication.html.erb has:\n```\n<% root_children = Category.root.children %>\n                    <% cache \"menu\" do %>\n                        \n                          <% root_children.each do |c| %>\n                            <%= render partial: \"categories/menu\", locals: {category: c} %>\n                          <% end %>\n                        \n                    <% end %>\n```\ncategory/_menu.html.erb\n<% if not (category.leaf?) %>\n    <li class=\"dropdown\">\n      <a data-toggle=\"dropdown\" class=\"dropdown-toggle\" href=\"#\"><%= category.name %><span class=\"caret\"></span></a>\n      <ul class=\"dropdown-menu\">\n        <li>\n            <%= link_to \"All #{pluralize(\"\", category.name)}'\", items_path(category_id: category)  %>\n        </li>\n        <% category.children.each do |c| %>\n            <%= render partial: \"categories/menu\", locals: {category: c} %>\n        <% end %>\n      </ul>\n    </li>\n<% else %>\n    <%= render partial: \"categories/menu_item\", locals: {category: category} %>\n<% end %>\ncategory/_menu_item.html.erb\n<li>\n  <%= link_to \"#{category.name}\", items_path(category_id: category) %>\n</li>\n. I don't think we can close this issue because it happens even without Mongoid\n. ",
    "speedmax": "I run into the same problem using rails4 and github: 'mongoid/mongoid'\nindex.html\n<%= render @items %>\nitems/_item.html.erb\n<% cache item do %>\nhello\n<% end %>\neven string cache key breaks\n<% cache \"hello\" do %>\nhello\n<% end %>\nCompleted 500 Internal Server Error in 198ms\nActionView::Template::Error (stack level too deep):\n  activesupport (4.0.0.beta1) lib/active_support/cache.rb:93\n\n. ",
    "yuki24": "I described more about this issue on https://github.com/mongoid/mongoid/issues/2903#issuecomment-15672128.\nI also don't think this is an issue of cache_digests, so we can close this issue now.\n. @satb I think you are having a different issue. Create a new issue then try to solve again.\n. ",
    "jamis": "Updated to use a declarative API (and updated the example in the pull request description).\n. Cool. I'm working on patching rails/master now.\n. ",
    "scootklein": "https://github.com/nhocki/cache_digests/commit/ce2fe2531017b19b05b0115350367d31b8a8902d\n. ",
    "viniciusnz": "If using rails 4.2 look at https://github.com/rails/rails/issues/17657#issuecomment-71385191\n. ",
    "hayksaakian": "I know how to do this now. (cleaning up my old issues at the moment)\n. ",
    "firedev": "Sorry, but I have tried to add template dependencies like this before render:\n<%# Template Dependency: objects/item_features_rent %>\n<%# Template Dependency: objects/item_features_sale %>\nBut it says that it can't find the template anyway. Guess I will have to ignore it.\n. I still think this is somewhat untidy. Besides it goes against everything I know. If you see warnings in logs - fix them.\n. Nope, just ignored it.\n. ",
    "marcusg": "@firedev Have you found a way to fix the warnings in logs?\n. ",
    "maxgronlund": "The whole idea about caching is speed improvement, logging 'non errors ' is a drawback in that direction and noise for the developers that have to know 'oh that warning just ignore it'\n. ",
    "mahemoff": "+1 Habitually ignoring errors in log messages is not a good practice.\n. ",
    "jwaldrip": "+1 Agreed\n. ",
    "bolshakov": "Instead ignoring log messages you may stop logging at all\n. ",
    "pelargir": "+1 for a fix. ",
    "cpuguy83": "Yes, but does that make this not an issue?\nAlso, according to the docs a simple call as shown above should work.\n. I'll definitely see if I can get my hands dirty here.\n. ",
    "tomaswitek": "Thanks for quick reply. I know how it works, but there is no possibility to use these two types of invalidation separately in one application?\n. ",
    "jeremy": "Good catch! Could you file a pull request in Rails for this? Changing an association should touch the old associate.\n. ",
    "caarlos0": "OK, I'll try.\nBy now, if someone else have this issue, I fixed it with this:\nbefore_update {\n    if self.person_id_changed?\n      Bike.find(self.id).person.touch\n    end\n  }\nCheers\n. ",
    "gmcnaughton": "Unfortunately it looks like this breaks the server, not just the rake task.  Trying to hit a page with a fragment cache wrapped around the recursive partial crashes WEBrick with Illegal instruction: 4 (WEBrick 1.3.1, OSX Mountain Lion 10.8.3)\n. Oops, I didn't think to check!  Thanks for the tip!\n. ",
    "buffym": "I just ran into this issue too, and noticed it has been fixed in master, but the gem version  hasn't been bumped yet. If you uninstall your cache_digests gem and reinstall from git, it should fix it. It appears to have been fixed in #10 \n. ",
    "yob": "Is this fixed in rails4 too?\nWe also have a comments partial that renders itself recursively and I'm seeing a similar error while trying to upgrade our app from rails v3.2.13 to v4.0.0\n. ",
    "gokure": "+1\nthe second argument will break jbuilder gem now\n. ",
    "john-999": "+1\nv0.3.0 throws \"wrong number of arguments (1 for 2)\" argument error, when used with gem https://github.com/n8/multi_fetch_fragments\n. ",
    "drale2k": "+1 it will break jbuilder for me\nThis fork fixes the issue, maybe it can be merged? https://github.com/s12chung/cache_digests\n. +1 same issue here without the \"multi_fetch_fragments\". Trying to use it to cache jbuilder templates.\n. ",
    "s12chung": "it's been about a month. it's a pretty simple change. anything I need to do to get it merged?\n. Doesn't seem like it's needed... Unless you want the dependencies parameter to be exposed publicly for: https://github.com/rails/rails/blob/master/actionpack/lib/action_view/helpers/cache_helper.rb#L154\n. ",
    "eimermusic": "I am mostly an Rspec guy but I'll give it a shot.\n. The test did fail and changing the FixtureFinder made them all pass again. Do you think that is enough regression protection?\n. I am concerned that the problem of template lookup may be more subtle than I first expected. I have a very interesting failure case.\nBefore my patch\n\ndigests would always be made of the some_view.html.erb even when another format was requested (e.g. some_view.pdf.erb)\ndigests could be made of that template \"at any time\" (read on for clarification).\n\nAfter my patch\n\ndigests will be made of the requested format and dependencies tracked correctly.\ndigests can no longer be generated after a render() has been performed. At least not always.\n\nWhat do I mean: after render()\nI am generating pdfs from a view (using Wicked PDF) and using the digest of the view tree to invalidate and re-render the pdf when required.\n1. a new ActionView object is created and rendered to a string\n2. the html string is given to Wicked PDF.\n3. When saving the pdf file a digest is generated based on the cache digest among other things.\nThis is how one view performs its rendering before the digest is generated.\nSome code (finally)\nlookup_context = ApplicationController.new.lookup_context\nCacheDigests::TemplateDigestor.new(\"some_view.pdf\", :html, lookup_context).digest # no problem here\nCacheDigests::TemplateDigestor.new(\"some_view\", :pdf, lookup_context).digest # boom!\nTo be clear. Both versions of the Digestor above work when run before the instantiated view renders. They both produce the same digest of the pdf formatted view. After render, though, the more correct one blows up. The template object is returned empty which causes a call to scan() to be done on nil.\nThis is somewhat similar to the failures I see trying to make the same patch to Rails master and takes me deep inside rails where I very easily get lost. I spent several hours in Rails master but haven't yet figured anything out.\n. ",
    "aquayee": "I got the anser from stackoverflow, close this.\n. ",
    "bricker": "@rafaelfranca :thumbsup: Thanks\n. ",
    "pifleo": "Same problem here, I'm using it like that: - cache user do\n. ",
    "nickurban": "I made some assumptions about why this isn't automatically registered (i.e. that it's not officially supported). If I'm wrong about that, please correct me.\n. Hey @tim-vandecasteele, I didn't add Slim because I haven't tested it myself. \nCan you confirm that it works?\n. ",
    "tim-vandecasteele": "Yes, I confirm it's working for me. Dependencies are properly calculated when checking with the rake task.\n. Maybe add a similar line for Slim\nruby\n  # Or enable experimental Slim support with the ERB Dependency Tracker\n  CacheDigests::DependencyTracker.register_tracker :slim, CacheDigests::DependencyTracker::ERBTracker\n. ",
    "eprothro": "+1 for this PR. We lost a few hours that would have been saved by this being called out in the README.\n. In case anyone is looking for the code for Haml (and other templating languages) support for view template cache digesting in Rails 4, it's referenced in this haml-rails PR: https://github.com/indirect/haml-rails/issues/50 \nNot trying to troll this post, but I think many may end up here if they're looking for how to get haml digestion to work in Rails as the code was ported from this repo.\n. FYI, @austenito if you're using the latest haml-rails release, it includes the necessary code to ensure cache digesting works properly.\n. @austenito no problem! Please let us know over on haml-rails if you have issues. \n. ",
    "austenito": "+1 for this. Spent some time trying to configure cache_digests and didn't figure out what was up until I check the source.\n. @eprothro thanks I'll give that a shot!\n. ",
    "mupkoo": "I have the same issue, using Rails 4.0.0. When I try to cache a segment with recursion, I get this error:\n```\nSystemStackError at /testing-webcast/sections\n=============================================\n\nstack level too deep\n\nactivesupport (4.0.0) lib/active_support/notifications/instrumenter.rb, line 23\n```\nHere is the code from my app\nmodels/section.rb\n```\nclass Section < ActiveRecord::Base\n...\n\n# Relations\nbelongs_to :webcast\nbelongs_to :speaker\nbelongs_to :parent, class_name: Section\nhas_many :children, class_name: Section, foreign_key: :parent_id\n\n# Scopes\ndefault_scope -> { order(:position) }\nscope :root, -> { where parent_id: nil }\n\n....\n\nend\n```\nsections/_webcast.html.erb\n<% cache [ 'sections', sections.maximum(:updated_at).to_i ] do %>\n    <%= render 'sections/list', sections: sections.root %>\n<% end %>\nsections/_list.html.erb\n```\n\n    <% sections.each do |section| %>\n        \n\n<%= section.get_title %>\n\n        <% if section.children.count > 0 %>\n            <%= render 'sections/list', sections: section.children %>\n        <% end %>\n    </li>\n<% end %>\n\n\n```\nEverything works, if I remove this part.\n...\n<% if section.children.count > 0 %>\n    <%= render 'sections/list', sections: section.children %>\n<% end %>\n...\nOther thing is that, after I remove the part from above, the cache is created.\nAfter this I add the part again to the template, remove the cache manually (delete the files)\nand it starts to work.\n. ",
    "charles": "Try this way...\n<% if section.children.count > 0 %>\n    <%= render sections: section.children, partial: 'sections/list' %>\n<% end %>\n.",
    "shuber": "It does still appear to be an issue for 4-0-stable/4-0-0/master. Each of those railties need the action_view.caching initializer updated with\nruby\nunless ActionView::Base.cache_template_loading\n  ActionView::Digestor.cache = ActiveSupport::Cache::NullStore.new\nend\nDoes a pull request need to be opened for each branch? Or just 4-0-stable?\n. ",
    "sadjow": "+1\n. ",
    "ksylvest": "@dhh Thanks for getting back. My thought is that the keys should be different because ActiveRecord::Base and ActiveRecord::Relation are completely different and won't return consistent results for any of the to_json, to_xml, etc methods. \nI ran into an issue trying to cache a partial used to render either a Backbone model or collection into the DOM on page load. I fixed it by using two different partials for the relation versus base, however it wasn't clear this is desired behavior.\n. @dhh Thanks. I ran into a collision because I was using the the same partial (maybe a bad idea? the code was the same for both in my case). Closing.\n. ",
    "Osseta": "This is discussed in https://github.com/rails/cache_digests/issues/53\n. ",
    "aikko": "Thanks\n. ",
    "tvdeyen": "Done\n. Woot! That was fast :heart:\n. ",
    "tispratik": "Should this gem have a dependency on activesupport? \n. ",
    "sahin": "+1\n. ",
    "bquorning": ":+1:\n. ",
    "alex-ut": "It should also be stated exactly what Rails version it was added to.\n. ",
    "peternixey": "I'm self-closing this on the premise that the templates are either \na) a part of the file system in which case you can manually add them in using the commenting\nor\nb) completely dynamic and stored in the database in which case they can just be treated as if they were any other piece of data. \nI think this is correct\n. ",
    "Overload119": "Try, json.cache! @videos do\n. ",
    "amnesia7": "I think it's something along the lines of what @teeparham has done with https://github.com/neighborland/cache_rocket although I'm unsure if I can use it yet because it mentions a dependency of rake ~> 10.3 and I'm limited to ~> 0.9.6. but I am on ruby 2.0 rails 4.1. \nUnless there's a way to do this using normal rails caching then I guess I'll have to checkout cache_rocket out and see if that can do what I'm after.\n. Thanks @teeparham I'll have to give it a whirl then\n. ",
    "teeparham": "@amnesia7 Yes, those are the two ways to the replacement: client-side javascript or server-side with cache_rocket (or similar). The rake dependency in cache_rocket is only a development dependency - there is no runtime dependency.\n. "
}