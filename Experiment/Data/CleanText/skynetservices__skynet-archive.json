{
    "bketelsen": "Absolutely!  I'll organize my ideas and plans into some easy to bite off issues. \n. 14 new issues added.  Pick one that makes some sense on its own and doesn't have too many dependencies on the others and enjoy!\n. lower priority\n. Closing - not sure what else can be done.\n. no more doozer\n. Looks cleaner.\n. Go apps grab a big chunk of memory and never fully release it.  It's a known issue.  It won't grow, just doesn't release unused RAM.\nThe interface needs to be more broad.  Let me think about it over dinner.\nOn Jul 27, 2011, at 5:03 PM, cdunn2001 wrote:\n\nI just killed doozerd on my Mac. It was consuming 700 MB. Not good! I wasn't using it, so why did it chew up memory?\nI am working on the interface for the config manager, and I thought I would use doozer's. However, the Wait() method returns a doozer.Event object. I'm not sure how to interface that. Is it possible?\ntype Event struct {\n     // copied from doozer\n     ...\n   }\n   type Config interface {\n     // other methods are fine, but not Wait(): \n    Wait(glob string, rev int64) (ev Event, err os.Error)\n   }\n   var DC Config\nconfig.go:100: cannot assign doozer.Conn to DC (type Config) in multiple assignment:\n       doozer.Conn does not implement Config (wrong type for Wait method)\n               have Wait(glob string, rev int64) (ev doozer.Event, err os.Error)\n               want Wait(glob string, rev int64) (ev Event, err os.Error)\nDo you have any idea how to get this interface to compile?\nHow certain are you that you want doozer? If not, we need to discuss the interface that you really want.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/issues/9#issuecomment-1667720\n. This is a doozer idiom.  We're getting a rev from Doozer, then locking this document to that rev.  Any changes to that doc have to be saved at a later rev.  So it needs to be atomic at the document (route here) level.\n. I was thinking redis would be a very simple to implement config store.\n. doozer just keeps adding memory as it runs until it hits its max.  Check the doozer list - there's a way to cap it.\n\nOn Jul 30, 2011, at 1:25 PM, cdunn2001 wrote:\n\nIt creates another dependency though. I wish we had something pure-Go.\nBy the way, doozer consumes only 50MB at invocation on my Mac. Its memory consumption seems to rise continually even when not in use. Maybe I had something set up wrong.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/issues/9#issuecomment-1688903\n. There are some pure go KVStores out there on github.  I might have even opened a ticket last night suggesting we use zeroconf/mnds\n. I'm probably too opinionated on this, but I really want a simple developer experience.  People who want to mess around with internals of Skynet can fork and change to their hearts' content.  Joe developer who may be relatively new to Go should be able to set a flag somewhere and rock on.\n\nLet's build Doozer, and Redis into skylib and make them settable at runtime by a flag.\nThe other option - and I kind of like this too - is having multiple skylibs -- skylibredis skylibdoozer, etc.  Then skygen asks which to support and uses that as the import statement.\nthen we do all the abstraction in our multiple skylibs to get a single interface for skynet agents to use, and manage all the code sharing ourselves.  Skynet users simply goinstall one or both skylibs and link to the right one.\nThe changes that Christopher and Paulo have suggested over the past few days have been great from a usability front.  I think we're on a good path.\nOn Aug 4, 2011, at 2:52 PM, cdunn2001 wrote:\n\n(From Brian's comment in a gist)\n\nLet's name the storage engine and the rpc protocol on the command line, but let sky lib pick the ports:\n./bin/myrouter --storage=doozer://192.168.228.1:6842 -protocol=rpc\n./bin/myrouter --storage=redis://192.168.228.1:6942 -protocol=json\nSkylib will then pick a random open port within a range and register with the storage engine. If we want named ports, we do that on the command line too\n./bin/myrouter --storage=doozer://192.168.228.1 -protocol=rpc -port=9001\nEvery choice should have a default, and be over-rideable on the command line.\nDefaults should be the fastest and most reliable - dozer and go's rpc\n\nFor the transport, I agree, since different servers could be using different transports. Skynet needs to support several all the time.\nHowever, the Registry (doozer for now) is a singleton. Skynet will only use one at a time. If it supports several Registry implementations, then every Agent will link with all those unused libraries (doozer, reddis, etc.). That's bloat, extra link time, and most important, extra work just to get Skynet installed.\nI think it's better to let the choice of Registry be taken at compile-time. Each back-end could have a Skynet plugin, wrapped by our registry API (a Facade), which would be imported by a generic name. Since GoLang does not provide a configuration system, that's a bit tricky. We cannot do this:\nimport \"github.com/user/reddis_adaptor/skylib/registry\"\nThat would hard-code the choice of implementation. Instead, we can do this:\nimport \"skylib/registry\"\nThen, we would provide directions on how to install each adapter. E.g.\ncd $GOROOT/src/pkg\n   git clone git:user/skynet-reddis-adapter/skylib/registry skylib/registry\n   goinstall skylib/registry\nEach adapter would hard-code the path to the back-end, e.g.\n// In the doozer adapter file, skylib/registry/registry.go\n   package skylib\n   import \"github.com/ha/doozer\"\nThat would automatically goinstall the back-end.\nAn alternative would be to store all the adapters in skylib, but without the .go extension. The user would then choose one and rename it. That would be easy, but maybe confusing and less flexible. I'm using this for now, with doozer's API, since that obviates the wrapper for doozer.\nIf you really want it your way -- the runtime option -- then we need a Registry \"interface\" for DC. (That's the Adapter Pattern, which differs from the Facade in that it's polymorphic.) Either way, we should think about what API we want for the Registry. We're using doozer's at the moment: https://gist.github.com/1125911\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/issues/9#issuecomment-1729635\n. awesome.\n. I would like to see performance testing before and after on go's RPC vs JSON-RPC.  Go has nice benchmarking framework for this.\n. That's why I'm sure we'll end up with PB or MsgPack or Json-RPC when we get to the point that we're cross platform.\n. Interesting.  Did you do any benchmarks?  In order to make this work, you would want to change the RouteGetUserDataRequest function to call the callRpcService function passing in the protocol parameter.  The protocol could be part of the config stored in Doozer.  Then there could be any number of protocols supported.\n. Just flew by on Twitter : ruby object serialization library benchmark results, 100k runs: json: 4.7s, bert: 22s, marshal: 1.5s, message pack: 0.6s. crazy.\n\nMessage Pack seems like a very nice option for fast serialization.\n. I debated this online with @paulosuzart and I think it makes the most sense to support at least Gob and JSON-RPC initially, and let each node determine what it will implement.  Gob for speed, json-rpc for compatibility.\n. This is high priority.  Start all initiators on port 8000.  If they can't listen, add one and listen again.  Routers start on 7000, services start on 9000, watchers should start on 10000.\n. Done - on STORE branch\n. added you as a collaborator.  Wiki pages already were there but empty.\n. completed\n. I take one day off to write the web development chapter in my book and you guys kick up a storm around here.  Nice.\n. Right now, I don't test anything - that's high on the list of stuff to fix.  I think this one may need a scripted test though.\n. What if we create a skynet mesh as our \"master\", and build an extractor to extract the pattern into the generator. It might make testing easier.  We'll build the mesh tests into the master app, and extract those tests into the template too.   This is a really hard problem to solve.\n. Yes - Ask questions, prompt for answer.  Receive interactive input from the user.  Store all interactive input until questions have been answered, then generate a Skynet mesh.\n. Gack.  It's just as simple to write a simple Go script :)  I was thinking of just changing Skygen so that if there were no command line flags given, it would ask nicely with good prompts.\n. I do know Ruby.. but the Skygen code is already in Go.  I was thinking like this:\nWhat name for your service:  BriansCoolAPI\nDo you need initiators? {y/N}  Y\netc.\n. That's almost right.  The Initiator knows the service name it will be routing to.  So it asks Doozer for a router that provides that routing service.\n. But you have the principle right. No centralized servers, even Doozer can have many masters.  Skynet was designed specifically to cross data centers.\n. I'm sorry, didn't mean to muddy the original point - you're right we don't query Doozer every time.  But I was saying that even doozer isn't a single point of failure or scalability risk.  Doozer config changes are pushed to each node in the mesh, so there isn't any querying happening, it's all push.\n. I want to change skygen completely -- see my previous issue.  Let's hold off on read me changes until skygen changes.\n. Bob never took the bait.  Closing the issue.\n. I agree on the prioritization of transports first.   Protocol specific stuff, I'm not sure -- probably we can put it in skylib, but I'd have to think hard about it.  Skylib would be ideal, certainly.  But on the service side... it could get confusing.  Prototyping may solve this.\n. my worry is that the way the code stands now, the transport mechanism for RPC is tied directly into the generated code.  Abstracting it out into sky lib would be idea, but I can't see how that would work without trying it.  That's all I'm saying.\n. This is a duplicate of issue #9\n. Yes, we could even use NetChannels in Go if we wanted.\n. removed doozer\n. This is low priority\n. So excited to see Dave Cheney's zeroconf library come together!\n. Does this do auto-port assignment too?  This looks like almost exactly what we have been discussing.  Simple for the service author to implement.\n. this looks pretty good.  If I pull this now and start working on Redis will that be in your way while you finish the cleanup?\nOn Aug 5, 2011, at 6:15 PM, cdunn2001 wrote:\n\nHowever, none of the other Agents have been modified yet, in order\nto reduce the number of diffs to examine. Thus, there is some\nduplicate code in skylib. We will address that soon...\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/pull/40\n. Pulled.\n\nOn Aug 5, 2011, at 8:24 PM, cdunn2001 wrote:\n\nI already have the filesystem version of the Doozer API ready. Once this is pulled, I'll submit that next step. (That's why the doozer-specific stuff is pulled into doozer.go.)\nFor now, it is the Doozer API precisely, but we can change that. The earlier we agree on the API, the better. Then you can do the Redis stuff without affecting anything else.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/pull/40#issuecomment-1740153\n. come to think of it, MongoDB would be dead simple for a storage engine.  I need to see if mongo supports watches.  If not, we could do a 1s poll.\n\nOn Aug 5, 2011, at 8:24 PM, cdunn2001 wrote:\n\nI already have the filesystem version of the Doozer API ready. Once this is pulled, I'll submit that next step. (That's why the doozer-specific stuff is pulled into doozer.go.)\nFor now, it is the Doozer API precisely, but we can change that. The earlier we agree on the API, the better. Then you can do the Redis stuff without affecting anything else.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/pull/40#issuecomment-1740153\n. Is this close-able?\n. this is closable, and perhaps a duplicate of the one that was just closed.  SendOnce works and Send supports timeouts.\n. We all love metrics and graphs, skynet will make sure you get your daily fix. More than likely we will utilize something like graphite to log time series data regarding number of requests, which calls are being made, response times, cpu/memory/load so that you can determine the state of your skynet cluster quickly with a dashboard of metrics.\n\nAfter this functionality has been added we'd like to create a nice web interface to be hit and see live statistics going on across the system at that moment and refreshed live.\n__ \nMake it easy to add new metrics.  Use something like https://github.com/peterbourgon/g2g\n. Half completed in #49 \n. makes good sense.\n. Yes, that's perfect.  I think we can close this issue.\nOn Aug 8, 2012, at 11:46 AM, John Asmuth notifications@github.com wrote:\n\nCurrently you can set retry and giveup timeout durations. To make a call, you can call .SendOnce() if you want to avoid retries, and it will timeout after giveup time has passed. If you call .Send(), it will send a request to a different instance every time retry time has passed, until a response is received or giveup time has passed.\nThis sound ok?\n\u2014\nReply to this email directly or view it on GitHub.\n. can we close this with the current implementation?\n. Then I'm closing this and will open a new ticket for logging viewer.  Perfect, thanks!\n. I am not 100% convinced that we need events.  The idea is that we might use an event early in the life cycle of a request to fetch data or prepare for a data operation later in the life cycle of the same request.  Technically though this could be just another sky net service.  So adding events as a concept may be over complicating things.  I am happy to entertain discussion on this...\n\n\nBrian\nOn Jul 30, 2012, at 6:46 AM, Henrik Johansson reply@reply.github.com wrote:\n\nWhat kind of events are we talking about here? Is the client listening for events regarding a specific service or can services listen to other services lifecycle events?\nRequest cycle implies some sort of interceptor design and then it could be used to inject custom filters and such. Is the idea that a given client can register custom callbacks (event listeners i guess) or are the service implementor responsible for it?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/issues/57#issuecomment-7365215\n. They all work fine but we need to pick one and set it up!  One idea was that we needed to start many virtual machines to test a sky net cluster. \n\n\nBrian\nOn Jul 30, 2012, at 7:29 AM, Henrik Johansson reply@reply.github.com wrote:\n\nThe existing things are not working? Travis or Jenkins? There are cloud versions available for both I guess not sure about pricing for OSS projects but often they are cheap if not free.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/issues/58#issuecomment-7365946\n. I think that makes good sense.    Go for it!\n. I'm going to leave this ticket open because there is likely plenty more refactoring to do.\n. complete\n. sounds good to me.\n. This will be the first web ui for skynet.  Use Bootstrap (from twitter) or something similar so we can have a consistent look and feel across all the UI's that we build.\n. This is effectively done. Any new work can be in a new ticket for refinements.\n. LGTM\n. This can't be automatically merged.  What are the conflicts?\n. I think skynet.Log.Panic is best\nI think we should contain panics to libraries like Go conventions do\nI like the SKYNET prefix for env vars, but it makes them big.  Does anyone care if they're long?\nlet's gofmt everything every time.\n. duplicate\n. and make the service not dependent on a specific logging engine - make it an RPC service that does Log4J type stuff... so we can set up file logging, mongodb logging, etc.\n. business specific -not a skynet bug/feature\n. replace with JSON/REST\n. this seems reasonable to merge.  It is a go/build issue, but one we can work around for now.\n. What name would you like to be added to the contributors file?  Thanks for your pull request!!\n. Your English is perfect.  Thank you!\n\n\nBrian\nOn Oct 9, 2012, at 10:37 PM, mikespook notifications@github.com wrote:\n\n@bketelsen, \"Xing Xing mikespook@gmail.com\" is OK, the same as in http://golang.org/CONTRIBUTORS.\nOT _Sorry for the inconvenience because of my bad English. Could any one tell me how to describe this is better? _\n\u2014\nReply to this email directly or view it on GitHub.\n. I think this sort of configuration should be implemented by the sky daemons and should be stored in etcd or something similar.  \n\n/skynet/services/regionname/servicename/minimumrunning = 5\n. Thanks for the contribution!\n. Have you attempted to recreate this under Go 1.1?\n. Thanks!\n. this is implemented already\n. awesome.  Thanks for the fix!\n. Skynet2 is where we're doing all the work, and it'll be merged back into this repo shortly.  What we're missing right now is lots of good user documentation.  Sorry - we're busy finishing all the big stuff first.  We'll leave this issue open until we can make a better documentation effort.\nMaybe others who are using skynet can chime in with some quick getting started guides?\n. Brilliant idea.  We'll whip something up, but it will be a few days at least.  Still much refactoring going on.\n. try here?  https://github.com/bketelsen/skynet\nmay have to look at git history though.. This can't go in sky lib?\n. aahhh I see.. it's hard to follow these on my iPhone (on vacation).  The initiators have rpc calls for service.ping requests, which is what the reaper uses for keepalives.\n. I like these better.\nOn Aug 3, 2011, at 5:34 PM, cdunn2001 wrote:\n\n\n@@ -99,7 +95,7 @@ func main() {\n http.HandleFunc(\"/\", homeHandler)\n http.HandleFunc(\"/new\", submitHandler)\n-    rpc.HandleHTTP()\n-    rpc.HandleHTTP() // I think we still need this here.\n\nActually, this might be more recent terminology. They are using \"Provider\" where I used \"Agent\"; they use \"Agent\" where I used \"Node\", and they use \"Model\" where I used \"Interface\" (or earlier, \"Provision\"). I'll switch to those.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/pull/36/files#r81967\n. what are your changes to doozer client?  Anything substantial?\n. \n",
    "cdunn2001": "Changed log module.\nskylib.LogError(skylib.DEBUG, msg)\n// is now\nskylib.LogDebug(msg)\nThis is similar to the Python logging module, Java log4j, etc.\n. I just killed doozerd on my Mac. It was consuming 700 MB. Not good! I wasn't using it, so why did it chew up memory?\nI am working on the interface for the config manager, and I thought I would use doozer's. However, the Wait() method returns a doozer.Event object. I'm not sure how to interface that. Is it possible?\n```\ntype Event struct {\n  // copied from doozer\n  ...\n}\ntype Config interface {\n  // other methods are fine, but not Wait(): \n Wait(glob string, rev int64) (ev Event, err os.Error)\n}\nvar DC Config\nconfig.go:100: cannot assign doozer.Conn to DC (type Config) in multiple assignment:\n    doozer.Conn does not implement Config (wrong type for Wait method)\n            have Wait(glob string, rev int64) (ev doozer.Event, err os.Error)\n            want Wait(glob string, rev int64) (ev Event, err os.Error)\n```\nDo you have any idea how to get this interface to compile?\nHow certain are you that you want doozer? If not, we need to discuss the interface that you really want.\n. I meant to ask you about something else. I'm not sure of the intent here. It doesn't seem thread-safe, since the rev could change before Set() is called:\n165     // Get the current revision number of the doozer \"store\".\n166     rev, err := skylib.DC.Rev()\n167     if err != nil {\n168         log.Panic(err.String())\n169     }\n170 \n171     // Set the contents of a file in the \"store\" to our JSON\n172     // string, if the file has not been modified since rev.\n173     filename := \"/routes/\" + sName\n174     _, err = skylib.DC.Set(filename, rev, b)\n175     if err != nil {\n176         log.Panic(err.String())\n177     }\n. It creates another dependency though. I wish we had something pure-Go.\nBy the way, doozer consumes only 50MB at invocation on my Mac. Its memory consumption seems to rise continually even when not in use. Maybe I had something set up wrong.\n. (From Brian's comment in a gist)\n\nLet's name the storage engine and the rpc protocol on the command line, but let sky lib pick the ports:\n./bin/myrouter --storage=doozer://192.168.228.1:6842 -protocol=rpc\n./bin/myrouter --storage=redis://192.168.228.1:6942 -protocol=json\nSkylib will then pick a random open port within a range and register with the storage engine. If we want named ports, we do that on the command line too\n./bin/myrouter --storage=doozer://192.168.228.1 -protocol=rpc -port=9001\nEvery choice should have a default, and be over-rideable on the command line.\nDefaults should be the fastest and most reliable - dozer and go's rpc\n\nFor the transport, I agree, since different servers could be using different transports. Skynet needs to support several all the time.\nHowever, the Registry (doozer for now) is a singleton. Skynet will only use one at a time. If it supports several Registry implementations, then every Agent will link with all those unused libraries (doozer, reddis, etc.). That's bloat, extra link time, and most important, extra work just to get Skynet installed.\nI think it's better to let the choice of Registry be taken at compile-time. Each back-end could have a Skynet plugin, wrapped by our registry API (a Facade), which would be imported by a generic name. Since GoLang does not provide a configuration system, that's a bit tricky. We cannot do this:\nimport \"github.com/user/reddis_adaptor/skylib/registry\"\nThat would hard-code the choice of implementation. Instead, we can do this:\nimport \"skylib/registry\"\nThen, we would provide directions on how to install each adapter. E.g.\ncd $GOROOT/src/pkg\ngit clone git:user/skynet-reddis-adapter/skylib/registry skylib/registry\ngoinstall skylib/registry\nEach adapter would hard-code the path to the back-end, e.g.\n// In the doozer adapter file, skylib/registry/registry.go\npackage skylib\nimport \"github.com/ha/doozer\"\nThat would automatically goinstall the back-end.\nAn alternative would be to store all the adapters in skylib, but without the .go extension. The user would then choose one and rename it. That would be easy, but maybe confusing and less flexible. I'm using this for now, with doozer's API, since that obviates the wrapper for doozer.\nIf you really want it your way -- the runtime option -- then we need a Registry \"interface\" for DC. (That's the Adapter Pattern, which differs from the Facade in that it's polymorphic.) Either way, we should think about what API we want for the Registry. We're using doozer's at the moment: https://gist.github.com/1125911\n. I just pushed a branch called store to this repo. It does not alter any code, just new files.\n- store.go is the interface. We will have to agree on the API. For now, it's a subset of doozer's.\n- fsstore.go is my filesystem-based store, which uses flocker\n- flocker.go uses flock() and link() for NFS-safe file-locking. It might go into a different package someday, but until the GoLang crew gets relative imports working, that's kind of a pain. (Same for the rand stuff.)\nI suggest creating mongo_store.go, redis_store.go, etc. After I add doozer_store.go, which will be a doozer adapter (necessary since doozer.Event is technically not the same type as the identical skylib.Event) we will let DC be the Store interface. Then we'll have run-time store selection.\n. doozer_store.go is done, in store branch. Take a look. You can work in that branch. It will merge back to master cleanly.\nAt some point, (unless we change the API) I will swap in doozer without the adapter, to check the speed penalty of the extra indirection. It's probably negligible, but with a new language it's worth checking.\n. I was studying RPC last night. Doozer uses ProtocolBuffers, but that's just data, not methods. Go's RPC uses introspection to discover methods. To use PB or some others, we would need to copy some of that introspection code into skylib.\nI'll look into the ones you mentioned, but I am thinking JSON-RPC is probably the best choice for now. First, we need to re-factor the RPC calls into skylib, to hide RPC from client code. Then, we'll be more free to alter the protocol. Is that what you had in mind?\n. Ok. \"rpc\" is a nice package. We will use its \"Codec\" interface. \"jsonrpc\" is an example of a json-rpc codec, and we can create more for other protocols (if they don't already exist).\nI'll alter the codebase to use the jsonrpc codec. That will make it more clear. Then I'll show you the code, but not push yet. I want to set up testing first.\nIt would be nice if we could test without doozer. Maybe that's another thing to abstract out. Hmmm....\n. Ok.\n. I'll bet that gob (the default) is faster than either jsonrpc or xmlrpc (if we can find that). But gob is Go-specific. Let's make the benchmarking a separate Issue.\n. I tried to use rpc's http support with a different protocol. Unfortunately, the gob codec is hard-wired. It's possible to copy rpc and alter it, but ... Anyway, rpc should work fine with simple net servers. We just lose the debug view in the browser. I did copy the codec for the gob server though -- just for benchmarking.\n(The reason why rpc's http is so closely tied to the codec is that the codec operates on a \"hijacked\" http connection, after the initial CONNECT. From that point on, http is not even used.)\nOk. I got jsonrpc working for the service.go server. There are some problems with exiting goroutines (a watcher, maybe?) but the web page works. It's just a handful of changes, for now. If you want to try it:\ngit remote add cd git://github.com/cdunn2001/skynet.git\ngit fetch cd\ngit checkout cd/jsonrpc\nAs you can see, the initiators contact the router using \"html-rpc\". The router contacts the server via \"jsonrpc\". Making it work with generic codecs would be more work. Later. I want to figure out the bugs first.\n. That makes sense. However, if the protocol changes in doozer, I think we have a race condition.\nNo benchmarking yet. I wanted to write a file-based alternative to doozer first -- using syscall.Flock() -- but it's taking awhile. Maybe I should concentrate on a simpler initiator, one which just pumps out a series of random words to a server, and a server which reverses and returns them.\n. For now, we support jsonrpc and http+gob. (It's important to remember that it's not just gob. The connection is established via http first. We could provide a pure-gob codec someday.)\n. Added rand-init/rand-agent: simplest possible consumer and provider.\n. I've done GitHub Wikis before. First, click Admin. Then check the Wiki box.\nAfter that, I'll clone your Wiki and see whether I can issue pull-requests for Wiki updates. Or, just make me a \"Collaborator\" so that I can alter your Wiki pages directly.\n. The problem appears to be the dependency order for gb. It worked after I built myStartup first. @paulbellamy never had the problem (for neither router nor his new mangoInitiator), so I think he must have had an existing myStartup built already. It fails on a fresh check-out.\nI will see whether I can figure out how to fix the dependency order...\n. Thanks, Paul. I'll submit this to go-gb. John will want to debug this, I'll bet.\n. This has the same problem as another example: myStartup is missing. But bk and I will address that ourselves.\nThanks, Paul!\n. Interesting. Are you using gb?\n. If you have any ideas, you can post here: https://github.com/bketelsen/skynet/issues/19\n. Created and pushed. Now, the tip of release is installed by goinstall. We can develop in master and merge to release.\nQuestion: How do you test changes? We may need some adjustments. For example, skygen creates templates which depend on GitHub. We need a way to test using the local skylib. For now, I'll set it up to use an environment variable to replace github.com/.../skylib with just skylib.\nSomeday, we might add another branch for code that uses the latest version of golang.\n. I'm working on it. The biggest problem for me is the most basic: How to use more than one version of skynet locally. I think that the answer is for devs to rely on $GOPATH, while non-devs can still use goinstall github.com/bketelsen/skynet/... automatically.\nI have done lots of experimenting over the weekend (with the many idiosyncrasies of both goinstall and gb) and I hope to have a pull-request ready today.\n. > we create a skynet app.... and use it as the extraction source for the generators.\nDo you mean to compare the generated source code byte-for-byte against the example that we create? Yes, that would work.\n. Might be high bang-for-buck, but I don't know what you mean by interactive. Do you mean Q&A via a command-line tool?\n. A simple Ruby or Python script is a good start then.\n. Gack? I thought you knew Ruby. I can't believe you're using Ruby for web-dev and Go for a simple script. It should be the other way round!\nI guess you want to query for the eventual components of the service request and response structs. Is that the idea?\n. I don't think we should be afraid of other languages, especially for proto-typing. We are already using bash and make, plus a C-compiler for Go, and those imply the existence of perl, python, and probably ruby. One advantage of Go over Ruby for web-dev is that you can push a fully-compiled application. You do not need a Go compiler on the host. But we are dealing with source-code, so we know we have a full compilation environment. When we decide we need type-safety, I can usually translate between languages much faster than I can write the original code.\nAnyway, just type up a typical session. It should be simple to code.\n. Oh. Now I see why it's scalable. Instead of a central ESB, the logic for finding the next service pipe is compiled into each initiator. If we refer to a central server at any time, we lose all scalability, so this is the essential step.\nHowever, since it is compiled into each initiator, with doozer we can replace each initiator one-at-a-time when we want to change the algorithm. Pretty sweet.\nAm I understanding it properly?\n. I see how it can cross data-centers, but why query doozer? I thought doozer was just for config management. Why not get the entire list from doozer now and then, to avoid central interaction.\nEven if doozer \"has many masters\", calling doozer each time must go through something central, no?\n. I see. You don't see the system being used without skygen. Sort of like protocol-buffers -- They can work if you just set up your own bindings, but the authors expect you to write some JSON files to describe your protocols and let them do the rest of the work.\nI'm getting more and more around at the golang folks. Since we separate pkg from cmd, the cmd has to mention github in its package import statement. Somebody made a big mistake there.\n. I think we need to prioritize other transport protocols over this. Otherwise, we could have a lot more work to do later. I think we can re-factor most of the protocol-specific work into skylib. No?\n. > Prototyping may solve this.\n?...  Do you mean by defining a protocol somehow, and letting a generator generate appropriate code? Hmmm.\n. Oh, \"prototyping\" as in trying something to see what it looks like. Great! I love that. Big fan. Concrete implementations are much easier to argue over. I thought you were referring to a CS concept, like JavaScript prototype-based OOP.\n. Lots of progress with a simple initiator and jsonrpc, but there is a bug. I won't have time to work on this until Saturday, unfortunately, so I'm afraid the new guy and I will have conflicts. Oh, well.\n. > Did you test compilation?\nYeah. But if you want to, just click on the question mark -- in the next Pull Request. GitHub tells you how to pull into a local branch and test. Well, you probably already know how, but it gives you a simple cut-and-paste.\nAlso, if you merge locally, you can make it a fast-forward merge. Do you have a preference one way or the other? A merge-commit makes the development branches clear, whereas a fast-forward makes the history nice and linear. Opinions vary. If you don't have a good git GUI, click on Network in GitHub. The colored parts are the branches. Mouse over dots to see who did what. With FF merges, there would be fewer colored parts.\n. Oops. Now I understand what you meant there. I thought there was something magical. I guess that's the first thing to do then.\nWe may want to abstract out the HTTP transport too, eventually. DialHTTP does not exist for jsonrcp, e.g.\n. Auto-port assignment is not there yet. That's a nice, well-defined task to let another volunteer get involved. If there is an issue for it, you could offer that to somebody on skynet-dev. But we need to get this basic re-factoring agreed, finalized, and merged first, I think.\nYes, it's basically what we've been discussion (sans reddis), but anything can be changed. I am a big fan of proto-typing, so that discussions become more concrete. I am not yet sure whether the original Agents (router, watcher, etc.) have been properly migrated either.\n. I already have the filesystem version of the Doozer API ready. Once this is pulled, I'll submit that next step. (That's why the doozer-specific stuff is pulled into doozer.go.)\nFor now, it is the Doozer API precisely, but we can change that. The earlier we agree on the API, the better. Then you can do the Redis stuff without affecting anything else.\n. Ignore this one. I rebased because of an oversight. (That's the danger of leaving old code lying around. We need to delete the old API code soon, but I didn't want to confuse you with excessive diffs.) See the other \"All Agents now use the new API\" request.\n. It is in skylib, in Node::Serve(), which is called by Agents, not by Initiators. (It is called by Start() for each registered Server.)\nAll it does is call http.Handle(), similar to the 2 previous lines, but for rpcPath and rpcDebugPath. It's safe to call it twice, though that won't happen in this case.\nBut I'm not sure it's really called for here, since the web Initiator is probably not expected to serve RPC requests from the internet.\n. First, a change in terminology, which seems to be what the the SOA world is using:\n```\nclass FooInterface {\n    int FooOperation1(req, resp);\n    int FooOperation2(req, resp);\n};\nclass CommonInterface {\n    int Ping(req, resp);\n};\n```\nThe Interfaces define groups of Operations. (A Contract would include the Interface plus any pre and post conditions, and possibly the transport protocol.) With these Interfaces, a Node would have at least one server, maybe more. A Service is then the actual provision of those operations by a given Server.\nI'll re-adjust my code to that and re-start the Pull request, in a moment.\n\nFor the Heartbeat, I would have every Node auto-register a Ping Operation amongst the CommonInterface. In that case, every Node has at least one server.\nThen, instead of walking through all Services and calling Ping as if each were a separate process (recall that an Agent can offer multiple Services, each of which may provide multiple Operations), the monitor could grab just the CommonInterface Services and call Ping on each of them.\nThere is a question of whether to offer both Interfaces on the same port, by the same Server. That would be cheaper (in terms of numbers of Ports) but a long-running Operation would block the Ping request.\n. Actually, this might be more recent terminology. They are using \"Provider\" where I used \"Agent\"; they use \"Agent\" where I used \"Node\", and they use \"Model\" where I used \"Interface\" (or earlier, \"Provision\"). I'll switch to those.\n. ",
    "paulbellamy": "Might be an issue with gb not finding the include.  When I run 'gb' in the project root it fails, however if I switch to the example directory it works, as below:\n$ cd examples/GetWidgets && gb\n(in watchers/generic) building cmd \"generic\"\n(in initiators/mango) building cmd \"mango\"\n(in router) building cmd \"router\"\n(in watchers/reaper) building cmd \"reaper\"\n(in initiators/web) building cmd \"web\"\n(in service) building cmd \"service\"\nBuilt 6 targets\n. @cdunn2011 when it was working for me, I was building the example outside of the main project directory.\n. Odd. Both of them compiled fine here...\n(release golang)\n. yeah, I was using gb\n. ",
    "erikstmartin": "adding the vagrant nodes to /ctl/cal was not happening properly, which made it appear as if doozer wasn't handling failure well, this has been tested i have killed doozer nodes while running vagranttests and no lost requests\n. This is exposed via daemon metrics now.\n. I plan to implement an interface so packages can be created to register themselves similar to the sql package.\nCreate a metrics package to report metrics to https://tempo-db.com\nAlso leverage https://github.com/jondot/gosigar to report CPU/Mem/Load/Disk to doozer for load balancer, and to the metrics interface\n. The base of this is completed, although we plan on adding graphs and other cool features, i'm going to close this ticket and allow us to open tickets and prioritize each of those separately.\n. Completed\n. Completed.\n. This has been completed, any additional work will be a new feature. Closing ticket.\n. I'd say that all the refactoring is done, we are in a new feature, and bug fix mode now. Closing ticket\n. Some work has been done here, but it really needs to be refined, and tweaked\n. working on this, fixing a merge conflict\n. That's a valid point, so we really have 2 options here.\n1) we can expose the notificationChannel so that you can utilize it in mux() and make the callback optional, and can be done in a .SetCallback method as mentioned above.\n2) you could pass in a callback method that sends the notification down your own channel that is being selected on in mux()\nwhich do we prefer?\n. Ok guys, all suggested changes have been made. Looking for a thumbs up :)\n. order may be important if it receives an add then a delete of an instance, if you get the add second you will have an instance that isn't really live\n. we also have the option of just sending a whole list again if we get too many notifications queued?\n. I think i'm confused what you mean, so pass a list of notifications on the channel rather than a notification itself?\n. Some mongo logging logic has been done, but it needs to be modified to be more inline with symantic_logger\n. LGTM\n. This isn't a huge priority right now, it was only meant as a way to abstract the MongoDB requirement from skynet.\n. Definitely leaning more towards #194 putting mongo logger in it's own package that can be included by people who want it.\nOpinions? if the consensus is towards #194 then this ticket can be closed\n. LGTM, i'm going to go ahead and pull this merge in\n. LGTM\n. LGTM\n. Leaving StopAll, RestartAll logic we aren't using it currently, but we may in the future. I have removed the Start logic in SHA: 7d0168c\n. also make sure that any wiki pages and the README.md point to the correct doozer fork\n. No references to github.com/ha/doozer(d) in the wiki or codebase, closing\n. forgot vagrant.go, other than that LGTM\n. this is Clarity specific, so it won't be a part of the open-source skynet package, but created in an internal repository\n. fair enough. right now it doesn't panic and logs that it tried to write to a closed connection. so that may be the ideal solution\n. handled suggestions from code review, commented out stopping of unmanaged instances when sent the restart command for now. We'll determine if we want to restart unmanaged instances later, and how we will accomplish that, if we need to do a deploy etc.\n. I'd say to attempt to reconnect a couple of times automatically, and reset that counter each time a connection is established, so it's only after a specified timeout that it gives up and displays the message\n. John just tackled this\n. We'll definitely need a FileLogger, at some point someone could do a syslog one if they wanted as well\n. Let's rename Payload to something else. skynet.LogMessage or something where it's more clear in the code what this is. the word Payload is too ambiguous.\n. LGTM aside from the Ambiguous name of Payload, the need for helpers to create these payloads in case you don't want to supply any additional criteria you don't need to create the object before each message, and we might want to log errors for logging straight to stdout from within the logging API so that each call to log doesn't have to account for the error\n. also i notice that the payloads are created using &Payload{} so we are creating pointers to these messages, this could possibly end up creating these on the heap, and creating more garbage for the GC to cleanup.\nI know Go's gc has some smart logic about whether or not to create on the heap vs stack if the pointers are passed to other functions/returning, but probably safer that sorry as there isn't really a need for these to be pointers, at least from what i can tell.\n. Thanks! I kept meaning to fix those :)\n. Steve this is probably the highest priority, we definitely want to make sure log messages provide the: service name, version, host:port, region, request uuid, and maybe even the service uuid. This will help finding the log messages we need to troubleshoot problematic requests and services dramatically.\n. Yeah, we can move it into a flag like some of the other config properties\n. This merge has conflicts, please pull the latest from master and fix any conflicts.\n. Agreed, now that mongo logging has been updated by Steve, we need to have a shared way to get the value for all clients/services, that's reusable. We might want to move this into one of the helper methods inside config.go GetServiceConfigFromFlags/GetClientConfigFromFlags\n. It will be used by both, if the implementors choose to use it, it's possible for any given service/client that they may just want to log to console etc.\n. Awesome, thanks for the contribution, do you want to add yourself to the documentation/contributors.txt file as part of this pull-request and i'll go ahead and get it merged in and tested.\n. I'm working on fixing this today, we're going to fork the doozer dependencies so that we can ensure they work with skynet.\n. We have forked doozer into our GitHub organization, so this should no longer be a problem.\n. This is implemented in the newer skynet repo that will be merged in, although there is not a way to tell the daemon itself to change it's log level.\n. This is really so it defaults to something sane, but if we want to pass in a value through the cmd line we can so that we can try things at different versions etc.\n. This seems to be called still. and it shouldn't be as ss.running is set to false in ss.Stop(), which ultimately causes a service to start back up after it's been stopped\n. typo: must have at least one connection allowed to an instance\n. writing it to stdout is probably a safe bet\n. We should really provide a way to help accomodate filling this backtrace, for example something like: https://gist.github.com/3899233\n. 0 is Go's sane default for an integer, so if it's 0 chances are they haven't set it.\nRather than setting the pool size to 1 and limiting their possible throughput without them even being aware seems like a bad choice, better for someone to be notified of this when building the client, so that they can set a value that's appropriate for them.\n. ",
    "skelterjohn": "I don't believe anything in the client package does this right now.\nIt might be useful to have both timeouts and secondary requests. That is, if you don't hear back in X seconds, send out another call to another instance and take the first result.\n. A note here before it slips my mind: perhaps the Deregister function should only return once all current requests have completed.\n. I have built into services an admin RPC server using the bsonrpc package. Currently it has register and unregister functions that appear to work.\nAt the moment, starting, stopping and restarting are done through interacting with the SkynetDaemon service (which is done with the sky command), rather than the admin rpc server.\n. Currently you can set retry and giveup timeout durations. To make a call, you can call .SendOnce() if you want to avoid retries, and it will timeout after giveup time has passed. If you call .Send(), it will send a request to a different instance every time retry time has passed, until a response is received or giveup time has passed.\nThis sound ok?\n. I'm going to grab this one as my first major task. Sticking my nose in all over the place to add logging hooks should help me get a better view overall.\n. The logging works, but there is nothing for easy viewing. Also, I don't believe I'm the right person to work on that.\n. I've worked on a CI tool: github.com/skelterjohn/rerun. It uses a nice cross-platform fsnotify package. Unfortunately that package suffered from occasional deadlocks (haven't checked in a while); to use it I might have to fix it.\nIn any case, it is no problem to take the GOPATH name of a binary (eg \"github.com/bketelsen/skynet/examples/service\"), set a watcher for its source and all of is deps, and efficiently rebuild/relaunch when something changes.\n. I'd like to split up and relocate the skylib package into three different packages: \"github.com/bketelsen/skynet\", \"github.com/bketelsen/skynet/client\", and \"github.com/bketelsen/skynet/service\".\nOpinions?\n. https://github.com/bketelsen/skynet/pull/67\n. The issue is an old version of github.com/4ad/doozerd. If you pull the\nlatest you'll get what you need.\n- John\nOn Jun 30, 2012, at 10:29 PM, qinhui99\nreply@reply.github.com\nwrote:\n\nI try to install the skynet and get these errors:\ngithub.com/4ad/doozer\nc:\\go\\src\\pkg\\github.com\\4ad\\doozer\\conn.go:184: cannot use &t.req (type reques\nt) as type proto.Message in function argument:\n       request does not implement proto.Message (missing ProtoMessage method)\nc:\\go\\src\\pkg\\github.com\\4ad\\doozer\\conn.go:198: cannot use &r (type response)\nas type proto.Message in function argument:\n       response does not implement proto.Message (missing ProtoMessage method)\nI use the google protobuf 2.4.1. Does the skynet need the lower version of protobuf ?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bketelsen/skynet/issues/61\n. It makes me feel strange to have commits going into the master so quicky - it's what people get when they use \"go get\". perhaps we can create a \"go1\" branch for what we want to have face the public? \"go get\" will get that branch instead of master, if it exists.\n. Oh, this also merges in the mux() methods used by a service to safely manage concurrent RPC and doozer requests.\n. PTAL\n. It was something really weird - the conflict was just inserting a section. Maybe it was indentation?\n. yes\n. I do not expect to touch dashboard. I wanted the instance monitor stuff.\n\nIf you want comments, you should make a pull request!\n. LGTM\n. I get what you were saying about factoring out the listen channels.\nI'm not sure that's a good idea. In many cases (for instance, the ServiceClient) the adds/removes have to come in on channels so they can be part of a mux()'s select{} statement. If only callbacks are allowed, I would simply create a callback that sent on a channel.\nMaybe make an InstanceListener.SetCallback(aCallbackFunction) that would intercept the things coming in on the channel, if the user definitely wanted a callback rather than a channel? And leave the channel exported so it can be selected on directly?\n. also, gofmt :)\n. I would prefer method 1, since method 2 involves an extra goroutine. Goroutines are light, but they add up, especially when looking through stack traces.\n. I think it might be reasonable to just drop notifications that overflow the buffer, then, and leave it up to the client code to pull the whole list.\n. I have a solution: it's a bit funky seeming at first but it's a great\nconcept I've played around with on go.uik.\nA stacked channel is one with a buffer of size one, where sends never\nblock. If the buffer is full, the thing you try to send gets \"stacked\" with\nwhatever is already there. Stacking in this context just means combining in\nsome relevant way.\nIn this case, the thing on the channel is a list of the updates to the\ninstance list. Some adds, some removes. Stacking an add on top would either\nput the instance into the add list, or take it out of the remove list\n(depending on if it were in the remove list). Stacking a remove does the\nsame but in reverse.\nThe way to stack a value is like so:\nfunc stack(ch chan Whatever, w Whatever) {\n  select {\n    case oldW := <- ch:\n      ch <- myStackFunction(w, oldW)\n    case ch <- w:\n  }\n}\nIf there is nothing on the chan, w is put there like normal. If something\nis there, it's taken off, combined with w, and then put back on.\nFor our particular case, it makes sense to do a stacked channel like this.\nOn Thu, Aug 9, 2012 at 6:42 PM, mirtchovski notifications@github.comwrote:\n\n\nso i guess your only worry is whether to make the\nbuffer static or let it grow a-la bufio.Buffer. it will get cleaned up on\nclient timeout, right?\n\nscratch that: there could exist a very slow reader that fits just\ninside the heartbeat yet doesn't consume enough, allowing your\nunconstrained buffer to always grow given a fast producer....\nmy bad.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/pull/82#issuecomment-7629297.\n. Minor error - can't just send the stacked result on the channel. You need to select again or this isn't threads ate. Easy fix.\n. it'd be a chan struct { Additions, Removals []*Service }. The first time\nthe client recvs from the channel, Additions would be the set of all\ncurrently known instances and Removals would be empty. Every subsequent\nrecv would get the delta.\n\ntype Notification struct {\n  Additions, Removals []*Service\n}\ntype NotificationChan chan Notification\nfunc (ch NotificationChan) Stack(n Notification) {\n  for {\n    select {\n      case ch <- n:\n        return\n      case on := <- ch:\n        n = union(n, on)\n    }\n  }\n}\nand the union function is the one I described before that turns two ordered\nNotification instances and turns them into a single combined Notification.\nSince we're dealing with insertions to and deletions from a set, it's easy\nto write this union function.\nSo when the InstanceMonitor gets a new service that is accepted by a query,\nit creates a Notification with just that one addition and stacks it onto\nthe NotificationChan. If the client recvs from the channel right away,\nthat's great. If not, and another new service comes, the stacking makes a\nNotification with the two additions, and that will be ready to be received\nby the client. etc.\nOn Thu, Aug 9, 2012 at 8:18 PM, Erik St. Martin notifications@github.comwrote:\n\nI think i'm confused what you mean, so pass a list of notifications on the\nchannel rather than a notification itself?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/pull/82#issuecomment-7630985.\n. LGTM\n. You shouldn't use .Println or .Printf for logging. A raw string is not convenient to search for in a database. Instead use log.Item() with a custom type. See skynet/logmessages.go. You only have to make a .String() method for pretty printing on the console. It will go into mongo as a serialized json object, paired with the program's UUID and the type of the message.\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LFTM (looks fine to me, since I don't really know much about the js client code)\n. vagrant appears to do its own arg handling? https://github.com/bketelsen/skynet/blob/example-args/examples/testing/vagranttests/vagrant.go#L30\n. LGTM\n. This is generally impossible - it's racy. There is no way to guarantee that\nthe connection wasn't closed between when you last checked and when you\ntried to write. The appropriate thing to do here is to attempt to write and\nhandle the error gracefully.\n\nOn Wed, Sep 19, 2012 at 11:18 AM, Erik St. Martin\nnotifications@github.comwrote:\n\nwe need to ensure the connection hasn't been closed by the client before\nwriting to it\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/issues/140.\n. once the comment on calling .AdminStop() is addressed, LGTM\n. No, it shouldn't. The deploy stuff uses the whole import-style path to uniquely identify the program it intends to run. If we modify it to look up a program by its simple name, we would just use $PATH, and it would be the user's responsibility to ensure that $GOBIN is included there.\n. Oh, looking at your diff I see what you mean now. This strikes me as an issue in the go/build package, rather than skynet.\n. once the comment is addressed, LGTM\n. This leaves out the possibility that someone would restart the same service.\n\nI think it'd be better to track down why the .Shutdown() method is being called more than once in the first place.\n. Stick it in ServiceConfig, and add a line to FlagsForService()\n. This seems fine, on its own, but it might be worth it to add some kind of standardized method for setting the mongo host. Many services will want to do this.\n. I believe skynet should reference the correct version of doozer - it looks\nlike the docs are out of date. doing a \"go get\ngithub.com/skynetservices/skynet\" should install everything you need.\nOn Sat, Jan 26, 2013 at 2:27 PM, Lee Sylvester notifications@github.comwrote:\n\nHi Sridhar,\nYou're using the wrong version of Doozer. There's a version in the\nskynetservices Github account.\nLee\nOn 26 Jan 2013, at 18:25, Sridhar Ratnakumar notifications@github.com\nwrote:\n\nthe official install instructions does not work for this reason.\ngo/src/pkg/github.com/4ad/doozer/msg.pb.go:10: undefined:\nproto.GetString\nthis particular issue was fixed in repos like\ngithub.com/ActiveState/doozerd\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/skynetservices/skynet/issues/179#issuecomment-12740668.\n. You're safe just removing all that stuff - the things using printfs were\nwhat i do instead of using gdb.\n\nOn Fri, May 31, 2013 at 1:38 PM, Erik St. Martin\nnotifications@github.comwrote:\n\nService client is using it's own logging functionality through fmt. It\nneeds to use the logger associated with the client.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/skynetservices/skynet/issues/197\n.\n. I did some stuff with recompiling the protobufs, but 4ad has merged that in. I'll switch back to his import.\n. I do have a more substantial change to doozerd, that supposedly allows it to bring in a new server days after the doozerd cluster is started. Erik gave me the patch - I've got a pull-request in to 4ad/doozerd, but he's sitting on it for the moment (he probably forgot about it).\n. This channel should be buffered, so the instance monitor doesn't have to wait for the listener to read from the channel before continuing.\n\nActually, this opens up a vulnerability (not a security vulnerability, but a deadlock vulnerability). If the person listening to instance notifications stops listening without informing the monitor, a deadlock will occur once the buffer on that channel is filled.\nMy recommendation would be to have a channel with a decent-sized buffer (perhaps 10), and a select{} with a default case to send on that channel. The default case will be empty, and the normal case will be the send you're already doing. That way if the buffer gets full and the listener is behaving poorly, future notifications will just be dropped.\nThe down side is that if the listener is just blocked on something that takes a few seconds, and during those few seconds a large number of instances are discovered, then the listener will not be notified about all of them.\nIdea: in the default case, spawn a new goroutine whose job it is to send to the channel. When this happens, the number of goroutines goes up, and notification order gets lost, but notification order isn't important in the first place, and the #goroutines only goes up in pathalogical situations.\n. This function is racy. If I understand right, this function is called and then the notification chan is received upon. Another gororoutine might receive on that chan in the meantime, flushing out the desired list.\nI recommend giving InstanceListener a .List() method that returns a []*Service, and having a separate means of communication to the InstanceMonitor's mux(). Something like:\nfunc (il _InstanceListener) GetInstances() []_Service {\n  ilq := InstanceListRequest{ // a new type\n    Query: il.Query,\n    Results: make(chan []Service, 1),\n  }\n  // a new chan in the monitor\n  il.monitor.instanceListRequests <- ilq \n  return <-ilq.Results\n}\n. What's the logic here?\n. this should probably not be a pointer, since it makes no sense to have a Service with no ServiceInfo\n. common practice for this sort of thing would be \"make([]skynet.ServiceInfo, 0, len(instances))\", which would pre-allocate the right number of entries in the slice while keeping the semantics of a zero-len slice. not a big deal.\n. You can also use something like this: http://code.google.com/p/gonicetrace/ (I am the author, feel free to copy/paste code without citation if you want any of it)\n. why do we need to consider exceptions at all?\n. what returned error value?\n. this type should have godoc some comments\n. ",
    "dahankzter": "What kind of events are we talking about here? Is the client listening for events regarding a specific service or can services listen to other services lifecycle events?\nRequest cycle implies some sort of interceptor design and then it could be used to inject custom filters and such. Is the idea that a given client can register custom callbacks (event listeners i guess) or are the service implementor responsible for it?\n. This way its getting rather deep into orchestration land which may or may not be good thing. It can clearly complicate things but if the use-case warrants it perhaps its worth it.\nI haven't looked into how the other type of functions like stats collection etc monitoring and what not are implemented (arr they yet?) but possibly an interceptor approach could be used for these things and when that is in place the event functionality could come by itself.\n. The existing things are not working? Travis or Jenkins? There are cloud versions available for both I guess not sure about pricing for OSS projects but often they are cheap if not free.\n. Ah yes maybe a cluster setup requires more custom work but perhaps getting started just having the tests running continously we could go for Travis CI: http://about.travis-ci.org/docs/user/languages/go/\n. ",
    "elimisteve": "I'm down to work on this if it's ever a high enough priority.\n. Done!\n. @bketelsen How much of the Log4J type stuff do you have in mind that log4go does or doesn't do? http://code.google.com/p/log4go/\n. @exsys Hmm having one ORM for the many kinds of fundamentally kinds of databases (e.g., Redis and MongoDB) seems hard to do without just covering their greatest common denominator, which is probably key/value pairs. I've definitely thought it'd be cool to have an ORM for all, say, document-oriented DBs (like Mongo and Couch), then another one for all columnar DBs (e.g., HBase and Hypertable), etc. And because Go is so new -- relatively speaking -- none of this has been done!\nI've done mostly Python for the past 4 years and have enjoyed its infinite library support, though it's much harder to make one's mark for that reason.\nMongo is open source and the most common persistent NoSQL DB, so true lock-in shouldn't be an issue. ElasticSearch sounds interesting though; I'll look into it more.\n. @bketelsen How high a priority is this? Let me know if it makes sense for me to tackle it.\n. I'll look into this\n. Right now, if the WebSocket connection is broken, an error message is added to the DOM saying so.\n@bketelsen Is the desired behavior something different? If so, let me know if you'd like me to work on this.\n. Just ignore this Pull Request and accept my latest one instead: https://github.com/bketelsen/skynet/pull/163\n. Merge conflicts fixed; see https://github.com/bketelsen/skynet/pull/164 instead\n. I almost always use pointers when I can so that data structures aren't unnecessarily copied multiple times as they're passed around.\nIf you find some docs, comments, or the like that suggest my approach is less efficient rather than more efficient, let me know. I am also not sure what exactly confuses/causes problems for the GC.\n. Yay!\n. I believe it's safe to merge this in. In case not, I've created a new branch you can pull from just yesterday. See https://github.com/elimisteve/skynet/commit/59fc2f73445e15026a401fafd69f990f3442415b\n. Already merged\n. @skelterjohn The Log method returns an error\n. Will add\n. Two comments:\n1. The idea is that within a recover() block we'd store the stacktrace info from panics. I'm calling them \"exceptions\" to maintain compatibility with semantic_logger.\n2. The Exception type is removed in later commits; this info should be part of the Payload struct.\n. @erikstmartin That's what it does in the latest version, which was also part of the Pull Request\n. @erikstmartin This code, too, is included in the Pull Request. It's based upon some very helpful code that John wrote for the original logger.\n. ",
    "mirtchovski": "Is this merging the dashboard branch into master?\nOn Wed, Aug 8, 2012 at 4:36 PM, John Asmuth notifications@github.comwrote:\n\n\nYou can merge this Pull Request by running:\ngit pull https://github.com/bketelsen/skynet dashboard\nOr view, comment on, or merge it at:\nhttps://github.com/bketelsen/skynet/pull/79\nCommit Summary\n- start of dashboard\n- removed binary file\n- Beginnings of a websocket log streamer...\n- book.txt is necessary for the dummy log. will be removed in the\n  future.\n- still figuring out git. these changes were not being pushed. should\n  b\u2026\n- tweaking style of dashboard a bit, as well as making it a layout\n  that\u2026\n- gofmt everything.\n- tweaking highlight regexp for logs to use a negative lookahead so\n  tha\u2026\n- minor adjustments to debugging output.\n- Merge branch 'dashboard' of https://github.com/bketelsen/skynet into\n  \u2026\n- stubbing markup for region/node/instance list, next up rigging it\n  int\u2026\n- merging master into dashboard\n- ensure no duplicate paths return when querying hosts/regions\n- start of websocket and InstanceMonitor\n- instance monitor now keeps it's own internal list of services\n- finished InstanceMonitor.mux() method, listeners are now returned\n  wit\u2026\n- go fmt\n- fixing issue with waitPath in monitor instances, when we get the\n  init\u2026\n- websocket should return json response object for better parsing on\n  th\u2026\nFile Changes\n- M .gitignore (1)\n- A client/instancemonitor.go (174)\n- M client/query.go (14)\n- M client/serviceclient.go (7)\n- M config.go (14)\n- A dashboard/book.txt (7450)\n- A dashboard/conn.go (73)\n- A dashboard/dashboard.go (112)\n- A dashboard/hub.go (36)\n- A dashboard/instancesocket.go (36)\n- A dashboard/logreader.go (69)\n- A dashboard/tmpl/images/SkyNetLogo.png (0)\n- A dashboard/tmpl/images/bg.png (0)\n- A dashboard/tmpl/images/favicon.ico (0)\n- A dashboard/tmpl/images/foundation/orbit/bullets.jpg (0)\n- A dashboard/tmpl/images/foundation/orbit/left-arrow-small.png (0)\n- A dashboard/tmpl/images/foundation/orbit/left-arrow.png (0)\n- A dashboard/tmpl/images/foundation/orbit/loading.gif (0)\n- A dashboard/tmpl/images/foundation/orbit/mask-black.png (0)\n- A dashboard/tmpl/images/foundation/orbit/pause-black.png (0)\n- A dashboard/tmpl/images/foundation/orbit/right-arrow-small.png (0)\n- A dashboard/tmpl/images/foundation/orbit/right-arrow.png (0)\n- A dashboard/tmpl/images/foundation/orbit/rotator-black.png (0)\n- A dashboard/tmpl/images/foundation/orbit/timer-black.png (0)\n- A dashboard/tmpl/index.html.template (190)\n- A dashboard/tmpl/javascripts/app.js (247)\n- A dashboard/tmpl/javascripts/jquery.customforms.js (258)\n- A dashboard/tmpl/javascripts/jquery.min.js (4)\n- A dashboard/tmpl/javascripts/jquery.orbit-1.4.0.js (633)\n- A dashboard/tmpl/javascripts/jquery.placeholder.min.js (2)\n- A dashboard/tmpl/javascripts/jquery.reveal.js (178)\n- A dashboard/tmpl/javascripts/jquery.tooltips.js (166)\n- A dashboard/tmpl/javascripts/modernizr.foundation.js (4)\n- A dashboard/tmpl/javascripts/mustache.js (613)\n- A dashboard/tmpl/layout.html.template (63)\n- A dashboard/tmpl/search.html.template (11)\n- A dashboard/tmpl/stylesheets/app.css (51)\n- A dashboard/tmpl/stylesheets/foundation.css (899)\n- A dashboard/tmpl/stylesheets/ie.css (0)\n- M sky/sky.go (10)\nPatch Links\n- https://github.com/bketelsen/skynet/pull/79.patch\n- https://github.com/bketelsen/skynet/pull/79.diff\n\u2014\n  Reply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/pull/79.\n. are you expecting to make changes to dashboard/*? I have uncommitted\nchanges there and am waiting for brian/erik to comment on a few things.\n\nOn Wed, Aug 8, 2012 at 5:05 PM, John Asmuth notifications@github.comwrote:\n\nyes\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/pull/79#issuecomment-7600463.\n. not comments, more questions:\n- log.Fatal, skynet.log.Panic or os.Exit? all three seem to be used, should\n  I convert to skynet.Log.Panic instead?\n- panic across library boundary, ok? (doozer.go has 7 recovers alone,\n  dashboard 1)\n- environment variables: prepended with SKYNET or not? SKYNET_MGOSERVER or\n  just MGOSERVER (or is there an equivalent?)\n- non-gofmt-ed code: should gofmt, or should switch to 2-space tabs?\n\none comment on instancesocket.go: you can use websocket.JSON.Send and\nwebsocket.JSON.Receive for less code.\nif the pull requests are the preferred way to go then I'll stick with them.\n. LGTM\n. > I think it might be reasonable to just drop notifications that overflow\n\nthe buffer, then, and leave it up to the client code to pull the whole list.\nyou saw the timings and sizes for fully buffered (find().All()) and\nunbuffered (find().Iter().Next() in a loop) database reads -- due to\nchannel copies the memory consumed by the former was about twice the size\nof the input read (100mb footprint for 50mb data). timing-wise they weren't\nsignificantly different, so i guess your only worry is whether to make the\nbuffer static or let it grow a-la bufio.Buffer. it will get cleaned up on\nclient timeout, right?\n\ni guess the real question is how much data do you expect to accumulate in\n15 seconds? for mgo simple queries i can read 50mb in 40 seconds, so\n18.75mb in 15 seconds at full-throttle.\n. > so i guess your only worry is whether to make the\n\nbuffer static or let it grow a-la bufio.Buffer. it will get cleaned up on\nclient timeout, right?\n\nscratch that: there could exist a very slow reader that fits just\ninside the heartbeat yet doesn't consume enough, allowing your\nunconstrained buffer to always grow given a fast producer....\nmy bad.\n. moved the discussion in chat.\nOn Tue, Aug 14, 2012 at 2:09 PM, John Asmuth notifications@github.comwrote:\n\nYou shouldn't use .Println or .Printf for logging. A raw string is not\nconvenient to search for in a database. Instead use log.Item() with a\ncustom type. See skynet/logmessages.go. You only have to make a .String()\nmethod for pretty printing on the console. It will go into mongo as a\nserialized json object, paired with the program's UUID and the type of the\nmessage.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/pull/87#issuecomment-7738474.\n. PTAL\n. LGTM if you like the scrolling fix.\n. \n",
    "sdmajor": "I like the idea of log4go\nnot a big fan of mongo and plan to remove skynets dependency on it with an\nORM once I get up to speed on skynet development. Seems to me people should\nbe able to pick their db backend skynet shouldnt vendor lockin. For\ninstance for logging an elasticsearch cluster is much better than mongo,\nthe slicing and dicing capabilities and the ease of scale make it a perfect\nfit for logging, it really removes the need for stuff like graphite as well\nbecause you can simply setup a JS frontend using stuff like:\nhttp://code.shutterstock.com/rickshaw/\nhttp://square.github.com/crossfilter/\nwith elastic searches capabilities these make for an amazing realtime\nstats, logs, analytics platform... But to each is its own which is why\nmongo needs to be tied to ORM so people can choose, memsql, mongo,\nelasticsearch, redis, or whichever makes sense for the platform they are\nbuilding.\nthere is also stathat.com as well... so really the mongo decision seems to\nbe pushing skynet away from a platform that works for everyone.\nOn Wed, Sep 12, 2012 at 10:23 PM, Steve Phillips\nnotifications@github.comwrote:\n\n@bketelsen https://github.com/bketelsen How much of the Log4J type\nstuff do you have in mind that log4go does or doesn't do?\nhttp://code.google.com/p/log4go/\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/issues/99#issuecomment-8518577.\n. to add check out this talk: http://vimeo.com/44716955\n\nOn Wed, Sep 12, 2012 at 10:37 PM, Stephen Major smajor@gmail.com wrote:\n\nI like the idea of log4go\nnot a big fan of mongo and plan to remove skynets dependency on it with an\nORM once I get up to speed on skynet development. Seems to me people should\nbe able to pick their db backend skynet shouldnt vendor lockin. For\ninstance for logging an elasticsearch cluster is much better than mongo,\nthe slicing and dicing capabilities and the ease of scale make it a perfect\nfit for logging, it really removes the need for stuff like graphite as well\nbecause you can simply setup a JS frontend using stuff like:\nhttp://code.shutterstock.com/rickshaw/\nhttp://square.github.com/crossfilter/\nwith elastic searches capabilities these make for an amazing realtime\nstats, logs, analytics platform... But to each is its own which is why\nmongo needs to be tied to ORM so people can choose, memsql, mongo,\nelasticsearch, redis, or whichever makes sense for the platform they are\nbuilding.\nthere is also stathat.com as well... so really the mongo decision seems\nto be pushing skynet away from a platform that works for everyone.\nOn Wed, Sep 12, 2012 at 10:23 PM, Steve Phillips <notifications@github.com\n\nwrote:\n@bketelsen https://github.com/bketelsen How much of the Log4J type\nstuff do you have in mind that log4go does or doesn't do?\nhttp://code.google.com/p/log4go/\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/issues/99#issuecomment-8518577.\n. @Steve\n\n\nhttps://github.com/astaxie/beedb\nwhile not on the nosql side it is an ORM for golang, it should be possible to\nmake drivers for nosql as well\nOn Wed, Sep 12, 2012 at 11:19 PM, Steve Phillips\nnotifications@github.comwrote:\n\n@exsys https://github.com/exsys Hmm having one ORM for the many kinds\nof fundamentally kinds of databases (e.g., Redis and MongoDB) seems hard to\ndo without just covering their greatest common denominator, which is\nprobably key/value pairs. I've definitely thought it'd be cool to have an\nORM for all, say, document-oriented DBs (like Mongo and Couch), then another\none for all columnar DBs (e.g., HBase and Hypertable), etc. And because\nGo is so new -- relatively speaking -- none of this has been done!\nI've done mostly Python for the past 4 years and have enjoyed its infinite\nlibrary support, though it's much harder to make one's mark for that reason.\nMongo is open source and the most common persistent NoSQL DB, so true\nlock-in shouldn't be an issue. ElasticSearch sounds interesting though;\nI'll look into it more.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/issues/99#issuecomment-8519256.\n. why not keep it simple follow the same method stathat.com uses, then have a\nORM layer to make it so any driver can be developed for storage, even a\ndriver for stathat.com itself if one so wishes to use it for analytics. If\nyou watched the talk on elastic search it is really easy to slice and dice\non this type of data for advanced near real time analytics.\n\nOn Fri, Sep 14, 2012 at 12:10 PM, Reid Morrison notifications@github.comwrote:\n\nThe challenge is not so much where to store the data, but how do we get\nlogging data into a datastore such that it is meaningful for analytics.\nCurrent logging frameworks such as log4j and log4go only write text\nformatted content to their various appenders or filters. In order to use\ntext log data one would have to use extremely complex regular expressions\nto try to make sense of all the logging data.\nMuch like the movement towards the Semantic Web, we need to make logging\ndata machine readable and understandable. So not only do we want to log a\ntext message, but we should be able to log any semantic information along\nwith the log entry. For example, a tracking_number, userid, application\nname, etc.\nIf we look at current log api's in ruby for example:\nlogger.info(\"Queried users table in #{duration} ms, with a result code of #{result}\")\nTo add semantic information we could just pass in a second parameter, say\ncall it payload, which is a hash of information related to the call:\nlogger.info(\"Queried table\", {\n   :duration => duration,\n   :result   => result,\n   :table    => \"users\",\n   :action   => \"query\" } )\nIf the logger then writes this data to elastic search, MongoDB, or another\ndocument datastore then we can easily perform analytics against the text\nmessage and it's payload. Trying to do the same against text files with\nregular expressions or similar would be painful to say the least.\nAll that we need then is for the logging API to add a second parameter to\nthe existing logging calls that takes a payload object that can be\nserialized or stored in a meaningful way.\nExisting file or other appenders/filters would just serialize the second\nparameter and append it to the message as readable text before writing to\nfile, etc.\nSince the binding between the payload and the final datastore is\nexternalized from the application, the appender/filter can be changed by\nthe end-user to any datastore of their choice. This also avoids the lowest\ncommon denominator across data stores as each appender can take full\nadvantage of the underlying datastore without affecting the application.\nFor an example of the enhanced logging interface, see\nhttps://github.com/ClarityServices/semantic_logger\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bketelsen/skynet/issues/99#issuecomment-8572426.\n. I agree... asked a long time ago for it to be pluggable on this list.\n\nNot a fan of mongo... I would rather fire off to a message que and store in\nthe highly searchable elasticsearch\nOn Mar 28, 2013 9:08 AM, \"Erik St. Martin\" notifications@github.com wrote:\n\nDefinitely leaning more towards #194https://github.com/skynetservices/skynet/issues/194putting mongo logger in it's own package that can be included by people who\nwant it.\nOpinions? if the consensus is towards #194https://github.com/skynetservices/skynet/issues/194then this ticket can be closed\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/skynetservices/skynet/issues/99#issuecomment-15597207\n.\n. I second this, now that I have some time on my hands I would like to try\nand learn skynet in a fast forward style so I can get up to speed and start\nmaking working applications.\n\nOn Fri, Aug 9, 2013 at 5:10 AM, Richard Hooker notifications@github.comwrote:\n\nI want to really start looking at skynet; (should I be using skynet2).\nhowever I cannot see any clear docs on Getting Started; (Either golang or\nthe Ruby)\nIn a nut shell I want to run on my local machine create some Services and\nsee what I can come up with.\nwhat are the easiest coolest steps to get this going? I think this would\nreally helpful for people that want to get to grip oon this beast\nThanks\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/skynetservices/skynet/issues/207\n.\n. \n",
    "reidmorrison": "The challenge is not so much where to store the data, but how do we get logging data into a datastore such that it is meaningful for analytics. Current logging frameworks such as log4j and log4go only write text formatted content to their various appenders or filters. In order to use text log data one would have to use extremely complex regular expressions to try to make sense of all the logging data.\nMuch like the movement towards the Semantic Web, we need to make logging data machine readable and understandable. So not only do we want to log a text message, but we should be able to log any semantic information along with the log entry. For example, a tracking_number, userid, application name, etc.\nIf we look at current log api's in ruby for example:\nlogger.info(\"Queried users table in #{duration} ms, with a result code of #{result}\")\nTo add semantic information we could just pass in a second parameter, say call it payload, which is a hash of information related to the call:\nlogger.info(\"Queried table\", {\n   :duration => duration,\n   :result   => result,\n   :table    => \"users\",\n   :action   => \"query\" } )\nIf the logger then writes this data to elastic search, MongoDB, or another document datastore then we can easily perform analytics against the text message and it's payload. Trying to do the same against text files with regular expressions or similar would be painful to say the least.\nAll that we need then is for the logging API to add a second parameter to the existing logging calls that takes a payload object that can be serialized or stored in a meaningful way.\nExisting file or other appenders/filters would just serialize the second parameter and append it to the message as readable text before writing to file, etc.\nSince the binding between the payload and the final datastore is externalized from the application, the appender/filter can be changed by the end-user to any datastore of their choice. This also avoids the lowest common denominator across data stores as each appender can take full advantage of the underlying datastore without affecting the application.\nFor an example of the enhanced logging interface, see https://github.com/ClarityServices/semantic_logger\n. ",
    "mikespook": "@bketelsen, \"Xing Xing mikespook@gmail.com\" is OK, the same as in http://golang.org/CONTRIBUTORS.\nOT Sorry for the inconvenience because of my bad English. Could any one tell me how to describe this is better? \n. Oh, ja, you are right! I should reconsider the solution.\nconfig, _ := skynet.GetServiceConfig()\ns := &Service{}\nservice := service.CreateService(s, config)\n// ServiceDelegate.Stopped will be called in service.Shutdown. (FIRST TIME)\ndefer service.Shutdown() \n// watchSignals is called, when signals captured, service.Shutdown is also called. (SECOND TIME)\nwaiter := service.Start(true)\nwaiter.Wait()\n. ",
    "lfranchi": "I believe this was just fixed by @erikstmartin a few hours ago.\n. Makes sense. Is mongo logging used only by services, or only by clients, or both? I can move the mongo flags into the appropriate Get*ConfigFromFlags\n. Ok, cool. I moved the code to be shared and any client/server can access the mongo host/db if they so desire.\n. Sure, though this a bit of a trivial change :) Updated. Thanks for the reviews!\n. ",
    "srid": "the official install instructions does not work for this reason. \n\ngo/src/pkg/github.com/4ad/doozer/msg.pb.go:10: undefined: proto.GetString\n\nthis particular issue was fixed in repos like github.com/ActiveState/doozerd\n. ",
    "Lazarus404": "Hi Sridhar,\nYou're using the wrong version of Doozer.  There's a version in the skynetservices Github account.\nLee\nOn 26 Jan 2013, at 18:25, Sridhar Ratnakumar notifications@github.com wrote:\n\nthe official install instructions does not work for this reason.\ngo/src/pkg/github.com/4ad/doozer/msg.pb.go:10: undefined: proto.GetString\nthis particular issue was fixed in repos like github.com/ActiveState/doozerd\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "serussell": "I have verified the problem on a quad-core machine running Ubuntu Linux with the same code posted above.  This is without my debugging changes to bsoncoders.go.  I'm now sure that it's not a platform issue.\nOS: Ubuntu 12.10 3.5.0-17-generic #28-Ubuntu SMP x86_64\nCPU: Intel Q8200 (quad-core, 64-bit\nGo: go1.0.2\nSkynet: 2cf329fcc9f11e\n```\nskynet: 2013/02/05 19:36:45 trace: Service \"Art\" registered\nskynet: 2013/02/05 19:36:53 trace: Method \"Put\" called with RequestInfo &{127.0.0.1:41675 127.0.0.1:41675 cdead888-8fea-4117-8e69-f572c531dcfd 0}\npanic: runtime error: makeslice: len out of range\ngoroutine 20 [running]:\ngithub.com/skynetservices/skynet/rpc/bsonrpc.(Decoder).Decode(0xf8401276b0, 0x583be8, 0xf84010e2e0, 0x0, 0x0, ...)\n        /usr/lib/go/src/pkg/github.com/skynetservices/skynet/rpc/bsonrpc/bsoncoders.go:56 +0x2b5\ngithub.com/skynetservices/skynet/rpc/bsonrpc.(scodec).ReadRequestHeader(0xf84010efc0, 0xf84010e2e0, 0x0, 0x0, 0x100000000, ...)\n        /usr/lib/go/src/pkg/github.com/skynetservices/skynet/rpc/bsonrpc/server.go:25 +0x60\nnet/rpc.(*Server).readRequestHeader(0xf8400cb5a0, 0xf84010d4c0, 0xf84010efc0, 0x0, 0x0, ...)\n```\n. I haven't but I will.  Thanks.\n. Tested with go1.1.1.  Appears to be working correctly, at least with the min_test.\nClosing this ticket.\n. ",
    "hookercookerman": "just seen a nice big refactor; skydns :smile: ; \nI would really like to get learning skynet basically from an App point of view creating clients and services; is there a Docker image out there with the new setup so I can get testing and creating services;\nthanks\n. ",
    "miekg": "This is with skydns version 1 probably? Note that main development is now\nfocussed on skydns2 where things are done different.\nOn 25 Jul 2014 03:26, \"zweite\" notifications@github.com wrote:\n\nskynet service hadn't GetServiceConfig function, it change to\nNewServiceInfo.\nfunc main() {\ntutorial := &TutorialService{}\nconfig := skynet.NewServiceInfo(\"TutorialService\", \"1\")\nconfig.Region = \"Development\"\nservice := service.CreateService(tutorial, config)\ndefer func() {\n    service.Shutdown()\n}()\nwaiter := service.Start()\nwaiter.Wait()\n}\nHowever, I found the exception ,\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal 0xb code=0x1 addr=0x0 pc=0x4f0a9e]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/skynetservices/skynet/issues/208.\n. \n",
    "zweite": "thank you\n. "
}