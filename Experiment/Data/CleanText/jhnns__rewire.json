{
    "jhnns": "rewire can't currently be used with browserify. browserify emulates just some parts of the node module architecture. In this case it is complaining that the core module called \"module\" can't be used in the browser. To solve this rewire should support browserify #2\n. I've removed the whole caching functionality because it made the whole thing more complicated.\n. Could you run the rewire unit tests? If they fail try downgrading browserify to 1.15.2 and retry the unit tests. Maybe tomorrow I'll have time to fix that.\nOn Jun 29, 2012, at 7:29 PM, Paul Torka reply@reply.github.com wrote:\n\nAs the title already said rewire seems not to work with the browser.\nI'm using the middleware for use with browserify in nof5 like described in readme.\nBut it seems that the following conditional does not work:\nif (process.title === \"browser\") {\n       module.exports = require(\"./browserify/browserifyRewire.js\");\n   } else {\n       ...\n   }\nprocess.title is still \"node\" and the require(\"./browserify/browserifyRewire.js\") is not happening.\nYou can take a look for my implementation here.\nThis error is thrown:\nError: No wrapper for core module: \"module\" from directory \"my/dir\" while processing file /my/dir/project_anme/node_modules/rewire/lib/rewire.js\nIf rewrite the code and force to use require(\"./browserify/browserifyRewire.js\"); it breaks because of this reason:\nReferenceError: window is not defined\nNot sure what is wrong ...\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jhnns/rewire/issues/5\n. Yes thats because substack accepted my pull request and I havent updated rewire yet. He should have used another mayor version Because he broke the API.\n\nOn Jun 30, 2012, at 12:37 PM, Paul Torka reply@reply.github.com wrote:\n\nI ran the tests and \u2716 3 of 19 tests failed:\n1) rewire (browser) should work like require():\n2) rewire (browser) should cache the rewired module:\n3) rewire (browser) #reset should remove all rewired modules from cache:\nCurrent Version of browserify is 1.13.5.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jhnns/rewire/issues/5#issuecomment-6684375\n. Am 30.06.2012 13:43, schrieb Paul Torka:\nOK, but you suggested to downgrade to 1.15.2 Did you meant 1.13.2?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jhnns/rewire/issues/5#issuecomment-6684717\nYes, the next lower version.\n. I've tried to run the unit tests as well. The last version of browserify that works with rewire is 1.13.3.\n. Should be fixed with 0.3.1.\n. Could you also copy the complete stack trace of the error?\n. Yeah! First pull request :+1: \n. Thanks for your positive feedback! :smile:\n\nI haven't tested if rewire works with CoffeeScript, but since many node hackers are also using CS it would be really useful. I have no clue why CS wraps the code in an anonymous function because node does that already. Do you know any reasons?\nSince you can't access scoped variables in JavaScript the only solution would be to remove the generated wrapper when the file starts with // Generated by CoffeeScript\n. That's tricky... don't you use any bundler like browserify or webpack? Or how do you resolve requires in the browser? Usually wrapping code in closures should be done by a bundler imho. rewire currently supports browserify and webpack.\nWith CoffeeScript wrapping your code, you won't be able to rewire modules on the client-side (unless you're sending a pull request to rewire :wink:)\nBut there's another solution. How do you compile your files in node? If you're using require.extensions you could pass a flag to CoffeeScript to disable the closure. This way you won't have closures in node, but in the browser.\nI'll leave a note for CoffeeScript in the readme if we find an applicable solution.\n. K thx. Then I'll close this one for now. Just drop a note here if u have a good solution.\n. I'm not in with CoffeeScript so I don't know how most devs are using it. Is CoffeeScript compiling the files on the fly or do you have to compile it into a folder and then run the output with node? How is your workflow with mocha?\nrewire itself should not set compiler flags. So currently I don't see any cleaner solution. But I don't get why CS is wrapping the code when running on node.\nI'll add your snippet to the documentation :smile:\n. This would just hide the ugliness behind a nice function :grinning: ...\nUsually I don't think that a non-app module should mess with require.extensions unless it's a compiler. But I also see that rewire() is something in-between - and it could modify it temporarily without influencing other modules. I'll try it when I have some time.\n. Shipped with rewire 1.1.0 :smile: \n. Mhmm ... I'm afraid sooner or later we have to remove this feature again: https://github.com/joyent/node/issues/5430#issuecomment-17612595\n. K thx. Haven't read this note yet. Think I'll keep the feature.\n. Nice! thx.\nThe travis build fails now because webpack introduced some api changes. I'll have to fix that ... \n. Nice! I was wondering if I should open an issue at webpack to discuss that :smile: .\nThe current implementation is quite a hack, because webpack's module system in the browser was not prepared for such a use-case. But the plugin for browserify isn't better. I had to do a lot of tricks - but hey: It's working! :wink:\nBtw: You can switch the branch to webpack-update which contains a fast fix. But I will implement your suggestions the next days if I have time.\n. Unfortunately this doesn't work, because rewire - if used only in node - doesn't require webpack or browserify to work. Therefore I will extract all bundler-plugins into own repositories (I was just too lazy to do that before :grin:).\n. Wtf?! You're crazy! ^^\nI'll review it in order to understand what's going on (and will replace should() with expect(), but that shouldn't be much work). Anyway - thx!\n. I'll also add webpack and browserify as peerDependency.\n. :+1:\n. rewire will stay with webpack 0.8 support. For webpack 0.9 I've created an own module: https://github.com/jhnns/rewire-webpack\n. Ah nice! The description is good. The I18nPlugin looks also very interesting. :smile: :+1: \n. Everything rewire needs is bundler-independent, so it basically \"just\" has to be adapted to the new browserify api. But since I'm not using browserify anymore I'm currently not implementing it.\n. Did you use the browserify plugin? Did it work with browserify 2 as well? Or do you still use browserify 1?\nPersonally I prefer webpack, because it is more flexible. It comes with many loaders (like CoffeeScript, LESS, style, mocha) and supports different styles (commonjs, amd, components). But since browserify 2 a lot has changed, so browserify might be as good as webpack.\nwebpack's documentation is still in progress, but the maintainer @sokra is responding fast so this was not an issue for me.\n. @i-like-robots Cool! Since I'm not using browserify anymore I'm not too motivated to write a plugin :wink:.\nYour implementation is simple and straight-forward. It doesn't work exactly like rewire, but that's ok for client-side modules. It will be a problem for isomorphic modules that run in node.js and in the browser. That's why I decided to stick straight to the node-rewire API for my webpack plugin.\nIf you're planing to rewrite rewireify to be compatible to the node-rewire API here's some advice:\nRewire circumvents the require.cache so other modules don't require the rewired version. Additionally every rewire()-call creates a new module instance. Furthermore a call of rewire(\"./moduleA.js\") needs to add moduleA as dependency to the bundle. I don't know if browserify exposes the parser api to hack in these kind of things. Concerning globals I think you should also prepend the getImportGlobalsSrc()-content. If you add rewire as dependency of rewireify you can just require all the rewire utility modules like __get__, __set__, getImportGlobalsSrc and detectStrictMode.\nBack in the browserify 1 days I hacked a browserify plugin for rewire. May that's some inspiration (although there were some crazy hacks necessary because browserify didn't provide an useful api).\n. Well, you could just take my browserify 1 middleware and adjust it to the new transform api of browserify > 2. All the magic/crazy client-side stuff should still work. You just need to find the browserify-2-equivalents of bundle.register and bundle.require. \n. Could you make any progress yet?\n. Yep, it's cool. Just wanted to point out that the implementation differs a bit (see above).\n. There's no require.cache in browserify? They somehow must have reverted my pull-request with browserify 2...\n. I don't know enough about requirejs but since there is no compilation step, I'd assume that it's impossible to inject the __set__- and __get__-method into the private module scope.\n. @mik01aj Please be aware that rewireify doesn't mimic rewire exactly. Code that runs in node might break in the browser. However, if it's working for you, that's just fine :grin: \n. Ah thx. I've covered this case on the client-side, but haven't added it to the server-side code. :smile:\nI'll write a test for it.\n. Hi,\nunfortunately not, because JavaScript copies primitives like numbers by value. This means, that an assignment creates a copy of the original value. Changing the original value won't change the copy.\nFor instance:\n``` javascript\nvar a = 2;\nvar b = a; // assigns the value 2, not the reference a\na = 3;\nconsole.log(b); // 2\n```\nObjects (and arrays) on the other hand are copied by reference, so:\n``` javascript\nvar obj1 = {\n   foo: \"foo\"\n};\nvar obj2 = obj1; // assigns the reference of obj1 to obj2\nobj1.foo = \"bar\";\nconsole.log(obj2.foo); // \"bar\"\n``\n. Unfortunatly there is no operator to change this behaviour. I think they made this to keep JavaScript simple for beginners. But actually most of the time it's no real problem, it's only annoying if you want to copy an object.\n. If you just want to rewireproviders.foo` you could do:\njavascript\nvar subject = rewire('../../services/foo');\nsubject.__set__(\"providers.foo\", fooMock);\nor of course rewire the whole providers-object.\nSince the code is executed when calling rewire(), the reference of the original foo-module is copied instantly to the providers-object. So rewiring the foo-module won't change the copied reference. I don't see any other way than manually rewiring every reference in the module.\nYou could also take a look at injectr. There you can provide mocks for certain require()-calls. :smile:\n. I'll publish it tonight.\n. Ah thx. Seems like my global npmignore isn't working properly. I've added an npmignore locally:\nhttps://github.com/jhnns/rewire/commit/44f474a2ec40c2a93506f2651ec2a37a78f93a88\n. Thx. I'll take a look.\nI'm also using JSHint, but there are actually some lines that needed eval(), for instance, and I was just too lazy to deactivate the warnings via JSHint comments :smile: \n. Hmmm, this should definitly work. Since app is still a regular module, there should be no difference between rewiring an express app or any other module. Afaik express has no __set__-method which would clash with rewire's __set__.\nMaybe there's another mistake or typo. If not, could you provide additional information?\n. @Lastalas That's intended. rewire just evals the assignment within the module. Of course rewire can't know that x.__set__('http', function (){}) should mock the get-function of the http-module.\n. @Lastalas Using rewire is basically like you had written a setter in your server.js like this:\njavascript\n// inside server.js\nexports.__set__ = function (key, value) {\n    eval(key + \" = value\");\n};\nOf course, this is ugly. That's why rewire does all the dirty work for you :wink:.\nBut why would you replace the http-module with a function? \n. @mefernandez the problem with your code is, that sayHello is initially passed to express. By calling __set__ you only change the reference inside app.js, but not the reference express has. rewire would need to inject your mock between the declaration of sayHello() and app.get('/', sayHello) which is impossible.\nThere are two ways to solve this problem:\nSolution 1: Use an init-method\n``` javascript\nfunction sayHello(req, res) {\n  res.send(200, 'Hello!');\n  res.end();\n}\nexports.init = function () {\n    // all environments\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.errorHandler());\n    app.use(app.router);\napp.get('/', sayHello);\n\nreturn app;\n\n};\n```\nNow within your test you can modify sayHello before calling init(). Using an init-method might also be a good idea, since executing code on require reduces flexibility and can be confusing.\nSolution 2: Don't use rewire and do monkeypatching\nUsually you should define your middlewares in a separate module. So if you have a module like this:\n``` javascript\n// myAwesomeMiddlewares.js\nexports.sayHello = function sayHello(req, res) {\n  res.send(200, 'Hello!');\n  res.end();\n};\n```\n``` javascript\n// app.js\nvar mw = require(\"./myAwesomeMiddlewares.js\");\napp.get(\"/\", mw.sayHello);\n```\nNow you can change myAwesomeMiddlewares.sayHello to your mock before calling require(\"./app.js\"). But again, after that app.js is in the module cache and you can't do another test because the app is up and running already. The only way is by removing the app from require.cache which is usually an anti-pattern.\n. Btw: My personal opinion is to not write unit tests for middlewares. Middlewares are supposed to be used in a stack and therefore should be tested in an integration test.\nrewire has not been designed to be used in an integration test. So the only way of preventing node from doing real requests is by monkeypatching the http-module, which is fairly ok within integration tests.\n. @Lastalas Good idea! :+1: \n. We had this discussion on CoffeeScript in issue #8 and were talking about whether rewire should support compiling to CoffeeScript or not. I don't think that rewire should support every language in the node.js community (e.g. what about IcedCoffeeScript?). I think that anyone who is using a compile-to-js-language needs to take care of compiling it to JavaScript.\nPersonally I don't use CoffeeScript, so I don't know much about tools and typical workflows. Is there a possibility to add the CoffeeScript(Redux)-Compiler to require.extensions?\n. Could you give me a link to a readme or something where the behavior of mocha is described?\nIf rewire didn't modify require.extensions would you be able to use CoffeeScriptRedux by modifying require.extensions before starting your tests?\n. Are you calling mocha with --compilers coffee:coffee-script?\nIt seems to me that the CS \"feature\" of rewire #8 prevents you from using other CS compilers which means that the feature should be regressed.\n. Mhmmm k. And if you remove the whole CS-compile thing of rewire and start mocha with --compilers coffee:coffee-script it still works? If this is the case, I'll remove CS-support so everybody can choose his favorite CS-compiler.\n. Yep, the bare-option is needed as pointed out in this issue #8.\nrewire can't invalidate the way how JavaScript closures work. Variables hidden \"behind\" a closure can never be accessed. \nYour commit looks good, I think I'll regress the feature and bump the major version. @00Davo @djthread @es128\n. The problem is that rewire's CoffeeScript-feature prevents other users from using another CoffeeScript-dialect because rewire will always compile files ending on .coffee with the original CoffeeScript compiler. If you compiled all your CoffeeScript to JavaScript and then run your tests it should be no problem.\nIf you're using mocha you just need to use the --compilers coffee:coffee-script argument.\nThe main problem here is that rewire does not know anything about CoffeeScript or other compilers (and in fact it should not care about). It just enhances node's require so you have private access to your modules. \n. Seems like everyone who's using CoffeeScript doesn't like to pre-compile... ^^\n. @gprasant is pre-compiling an option for you?\n@es128 thx! :smile: \n. Cool! :+1: \n. rewire adds the setters and getters to the exports-object at the bottom of the module. Just imagine that rewire injects code at the bottom of your module that looks like:\njavascript\nexports.__set__ = function () { ... };\nexports.__get__ = function () { ... };\nSo if you do module.exports = helper, the setters and getters will be attached to the helper-function itself, not to the object returned by calling helper(app). \n. rewire still works when exporting a function. If you place your variables you want to mock in the top-level scope of the module, it should be no problem. Given this module:\n``` javascript\nvar http = require(\"http\"),\n      fs = require(\"fs\");\nfunction helper(app) {\n    return {\n        get_watch_list: function () { ... }\n        update_watch_list: function (r_ip) { ... }\n    };\n}\nmodule.exports = helper;\n```\nyou can still inject mocks for the http- and the fs-module. Just write\n``` javascript\nvar helper = rewire (\"./helper\");\nhelper.set(\"http\", { ... });\nhelper.set(\"fs\", { ... });\n```\n. Looks good! :+1: \nThanks @Lastalas for your detailed blog post. Wish I had more time to write such posts...\nJust found two things:\n- the link to rewire isn't working\n- you don't need the __dirname-thing in rewire(__dirname + '/server.js'). rewire works just like require and will resolve any relative paths to the current module\n. Mhmm I'm not sure. But this error surprises me anyway, since renaming a folder should work even if the directory is not empty. With current versions npm test doesn't throw an error.\n. 0.10.21 (ok, it's not the current ^^)\n. k thx :+1: \n. Yes, I see the advantages. It's more likely to change a variable name than the dependency.\nBut I think your suggestion is impossible to implement because rewire does no static analysis of your code. Thus it doesn't know which variables are referencing which module. The only way to accomplish this is by mapping the dependency-paths on module startup like node-sandboxed-module does:\njavascript\nvar foo = rewire(\"./foo.js\", {\n    \"./util.js\": utilMock\n});\nBut if your prefer this approach I think it would be better to just use node-sandboxed-module :wink:.\nPersonally I came to the conclusion that after all unit-tests are usually gray-box-tests. Basically you are aware of the implementation but you're trying to test it like you didn't know. If you're changing the implementation you'll likely need to adjust the unit-test as well.\nI like your idea, but I don't know how to implement it.\n. Nevermind, it's always good to discuss about improvements :+1:\n. I have to admit that the term dependency injection might be a bit confusing. Usually DI means that the dependencies of a module are not required by the module itself. Instead of they are configured in a separate file and injected on runtime. That's the exact opposite of how node modules are written. They usually contain a block of require() statements at the beginning of the file.\nrewire is not designed to provide dependency injection as described above. In fact I had only unit-testing as use-case in my mind.\nPersonally I don't think that dependency injection leads to cleaner and better maintainable code. It requires \"strong\" and well-defined interfaces which is rarely the case (at least in my projects :wink:).\n. Closing this for now....\n. First of all: thanks for your effort! You even included tests :+1: \nUnfortunately I'm not quite convinced. I understand your motivation because you'd like to simply swap the required module with a mock, but your solution will only work if the dependency is required after the module has been initialized. But most of the time - and I even consider it to be best practice - dependencies are required on initialization.\nOne thing I like about the way rewire works is that dependencies are resolved as usual and swapped after initialization which reveals errors like \"module cannot be resolved\". But this approach of course implies that all require() calls are done in the top-level scope of the module and that no logic is executed on module initialization.\nI discussed this topic some months ago in this issue.\nHowever, I do think that it's possible to swap the module's dependencies on initialization since rewire has access to the private scope of the module and thus can override the require()-function. The api could look like:\njavascript\nvar myModule = rewire(\"./myModule\", {\n    \"fs\": fsMock,\n    \"../other/module.js\": otherModuleMock\n});\nNeed to think about it. Any thoughts anyone? :grin:\n. Thx, but I know sandboxed-module. One key feature of rewire is that it doesn't use vm and is trying to emulate node's module environment. Instead of that it uses node's internal module-module to compile the rewired module, so everything is as if it would be required conventionally.\n. Yep, mock-fs is probably the better choice for your use-case. Anyway, thanks! :smile: \n. Mhmm interesting. I think this could be solved if you stored the rewired module under require.cache so node doesn't execute the code twice:\n``` javascript\nvar myModel = rewire(\"./myModel\");\nrequire.cache[require.resolve(\"./myModel\")] = myModel;\n// than somewhere else\nvar myModel = require(\"./myModel\"); // returns the rewired module\n```\nIt's important that rewire is the first one that executes the module since rewire always creates a fresh instance. node's require always looks up the require.cache before evaling the code.\n. Oh yes, you're right. require.cache stores the module, not module.exports. A quickfix would be:\njavascript\nvar myModel = rewire('./lib/myModel');\nrequire.cache[require.resolve('./lib/myModel')] = {\n    exports: myModel\n};\n... thus faking the actual module-object. As you can see in node's source code, they're directly returning module.exports if module is defined.\nBut that's surely not a clean solution. Maybe rewire should provide a method to directly store the rewired module in the require.cache, like:\n``` javascript\nvar myModel = rewire.global(\"./lib/myModel\");\nrequire(\"./lib/myModel\") === myModel; // true\nrewire(\"./lib/myModel\") === myModel; // false\n```\nBut what happens when the require.cache already contains an instance of the module? Is rewire allowed to replace the module? This could have serious implications...\nMaybe there's also another solution? Any suggestions?\n. Mhmm I don't get this fix ^^. If a test uses rewire() but receives require() instead, wouldn't that break the test? The returned module won't have a __set__- or __get__-method.\nAnother solution which came in my mind is to separate the registering-part from the definition. So instead of writing:\njavascript\nvar Cat = mongoose.model('Cat', { name: String });\nyou would write\njavascript\n// CatSchema.js\nmodule.exports = mongoose.Schema({\n    name: String\n});\njavascript\n// Cat.js\nmodule.exports = mongoose.model('Cat', CatSchema);\nI don't know what exactly you're trying to test and mock with rewire, but separating these two things is a good idea anyway.\n. Close?\n. Nice :+1:\n. No, you're not doing anything wrong :smile:. That's actually the desired behavior as described in the readme:\njavascript\n// There is another difference to require:\n// Every call of rewire() returns a new instance.\nrewire(\"./myModule.js\") === rewire(\"./myModule.js\"); // = false\nUnfortunately this is not easy to solve because both situations may be desirable:\n- In unit tests you only want to modify the module you're currently testing. In successive tests the rewired module should usually be back to normal again\n- In integration tests you may want to modify a specific module globally, like mocking http requests or mongoose models, yielding all the other modules to share the rewired module instead of the original\nLuckily the second use-case can be solved in user-land. I had the same discussion a month ago. I'm closing this one because we should keep all the discussion at one place. So please write your response in the other issue.\n. That's a cool and useful feature! :+1:\n@eicca Could you post an example of that api?\n. @eicca yep, I see the use-case for both situations. Your suggested feature could be implemented on top of the basic revert feature. However, I somehow don't like the api, because it's not obvious why __set__ takes a function as third parameter. I haven't seen this pattern yet.\nWhat about\n``` javascript\nsomeModule.with(\"myValue\", 4)(function () {\n});\n// respectively\nsomeModule.with({\n    someVar: 4,\n    otherValue: 5\n})(function () {\n});\n```\n?\n. Thanks for your awesome work @bobpace. I've merged it, but haven't published it yet because it's too late now :sleeping: \n. I was just wondering whether it was more useful, if rewire provided a __revert__-method which reverts all modifications by rewire. The problem here is, that rewire can only save the current value when __set__ is called. So calling __revert__ would not revert the module to its initial state, but to the state before the variable has been changed by rewire. I don't know if this would be the expected behavior.\nWhat do you think? This feature should be done carefully imho.\n. You're right! :+1: \n. Shipped today with v2.1.0\n. Hi, thanks for your pull-requests. I'll take a detailed look at them as soon as possible :+1: \n. Concerning the node 0.8 issue: We could remove node 0.8 from travis.yml, I guess.\n. I'm not sure about this feature... what has rewire to do with CoffeeScript and all its dialects? Modifying require.extensions shouldn't be done by rewire but by the user who is actually using CoffeeScript. We had this discussion in an issue before #21.\nAs you can see I was actually about to remove the feature, as it prohibits the use of other CoffeeScript dialects with the same file ending. So, please convince me why this feature needs to be part of rewire and not your project setup. :smile: \n. Cool. Anyway, thx!\nI hate to deny such thoroughly pull-requests, with tests and all... :unamused: \n. I'm glad it's not an issue with rewire :grinning: \n. Could you post your code which causes the error?\n. Excellent! :+1: \n. Published as 2.1.1\n. Damn ... without strict mode my IDE didn't highlight that. Thx!\n. Sorry, can you give me an example? I don't understand what the problem is :smiley: \n. > rewire didn't allow injecting variables that weren't defined with var.\nThat works, I've added a test-case for it.\nThe problem with implicit global vars is though, that they will be changed globally by rewire. Thus writing\njavascript\nProduct.__set__({ Vendor: vendorStub });\nis effectively the same as\njavascript\nVendor = vendorStub;\nThat's because rewire prepends a list of var statements that import global vars to the local scope. To create this we need to know all globals before the module is executed, but implicit global vars are created as the module is executed.\nHowever, I don't think that is a great problem. When the module to test uses implicit global vars you don't need rewire to change them. rewire has been designed to be used with a module system.\n. Sorry, but wrapping eval() with try/catch is not a valid option. The method call should fail if the variable is not defined.\nIf the variable has been added by Sails.js to the global scope before you call __set__, everything should work fine. When there is no global variable yet, rewire will throw a ReferenceError which is the desired behavior.\nCould you describe your actual problem? Is there an error? Does mocking not work?\n. Could you set up a tiny example project where the problem exists? It's hard to tell the issue when I don't know enough about Sails.\n. You need to initialize Sails at least to test your modules. Rewire can't mock anything when it is not defined.\n. How does your fork solve your problem? You're just wrapping the eval() with try/catch...\nYou just need to define the variables to mock on the global object and everything works fine. From the rewire point of view it doesn't make sense to mock global variables with rewire.\n. Sorry, that is just not true. The eval() throws an exception and the error is ignored, no variable is set on the global scope. Your provided test-case is checking for the wrong value, moduleFake.getValue() returns myValue, not undefinedValue.\n. > I will try to boil up another test case that makes more sense\nThat would be great :grinning: \n. I'm so sorry. I just didn't get what you were trying to say :grin:\nShould be solved with 2.3.0\n. Thx for reporting this. That's a hard bug indeed. However, I think it's not valid to just ignore it. It would be better to use the bracket notation:\njavascript\nsrc += \"var \" + key + \" = global[\" + JSON.stringify(key) + \"]; \";\n. I see, you're right. I'll leave a note in the README about that.\n. Technical speaking you're right. When there is a require(), it should be listed in the dependencies.\nI had quite a long discussion about coffee-script, because \u2013 after adding and removing it \u2013 I didn't want it to be a dependency of rewire #8. But it seems also quite hard to use rewire with coffee-script. That's why I decided to re-add support for coffee-script, but without adding it to the dependencies. That's why I've placed a note in the README that it should be listed in the dependencies of the package using rewire. Thus node still resolves coffee-script.\nThis approach doesn't work with browserify. But since rewire() isn't usable in browserify anyway, this is probably not a problem.\n. That's definitely more elegant, I'll consider this for the next major release :+1:\n. Does this commit fix this issue?\n. It looks like istanbul does not support code instrumentation for CoffeeScript (https://github.com/gotwarlost/istanbul/pull/167). You'll need to compile your CoffeeScript to JavaScript before instrumenting it...\n. @willmorgan @JvJefke thanks for pointing out. Does istanbul expose an environmental flag?. I've removed babel. Could you check it again?. Should be fixed with 2.1.5 :grinning: \n. javascript\n        revertRewire = modelsActions.__set__({\n          'Product.findAll': fakeFindAll\n        });\nThis syntax was never intended to work :grin:. But it is possible to implement, so I added it with v2.2.0\n. Rewire was using JSON.stringify. Your mock made the original JSON.stringify unaccessible for rewire.\n. @ameykpatil There should be no limitation. You can rewire just every variable. So in this case you just need to re-define the user variable with your mock:\n``` javascript\nfunction UserMock() {}\n// Put your prototype methods here\ncompany.set('user', UserMock);\n``\n. No, that is impossible. There is no way in JavaScript to access a function scope.\n. Rewire uses node'srequire()and node'srequire()uses thefsmodule to actually load the module. Just do you rewiring _before_ stubbing thefsmodule and everything should be fine.\n. Close?\n. Oh ... I think that is impossible, also without rewire. You need to wait for node loading theindex.js(using the originalfs` module), but then you'd need to prevent node from actually executing the module. There is no hook or something to do that.\nBut you can use rewire to check if privateFileContent is correct. Then you could modify privateFileContent and test if readFile returns your modified privateFileContent. But imho that test would be too implementation specific...\n. When the dynamic require() statement is immediately executed, rewire can't help here. You could create two dummy modules (text fixtures) and check afterwards the require.cache.\n. Do you use rewire in the browser context? The error is thrown when deleting the require.cache so I assume it's not node.js?\n. I don't know much about Jest, but afaik it brings its own mocking system. So I'd assume that rewire and Jest are not compatible.\n. Yes, it should be possible to inject b (rewired) into a (rewired).\nIn your test, just do\n``` javascript\nvar b = rewire(\"b\");\nvar a = rewire(\"a\");\na.set(\"b\", b);\n```\n. You're using dynamic dependencies which are always problematic when a static module analyzer like webpack or browserify is used. In general, my advice is to avoid dynamic dependencies at all. Most of the time they can be replaced anyway. It's strange that your code doesn't know on which modules it depends on.\nHowever, there are a few use-cases where dynamic dependencies are useful... I just wanted to say that you should probably re-think your architecture.\nSee further discussion at webpack/webpack#794\n. Ok. It's just that I can't do much about it :wink: \n. It looks like you're using browserify. Browserify + rewire is currently not supported #13 \n. Unfortunately there is no simple workaround because it's not a bug. rewire() is interfering with the require() mechanism which must be emulated when using browserify. I've pointed out the required steps.\n. It seems like your examples lack some information. Where does the TaskImporter come from?\nBut reading from your examples I guess you've misunderstood the rewire API. rewire is no mocking lib that stubs methods on objects (sinon is an excellent mocking lib). rewire can be used to change internal variables of a module.\nIn your example, rewire would be useful to mock the db object without interfering with other modules:\n``` javascript\nvar sinon = require(\"sinon\");\nvar FooTask = rewire(\"./FooTask.js\");\nFooTask.with({\n    db: {\n        getStuff: sinon.spy()\n    }\n})(function () {\n        var testTask = new FooTask();\n        var returnVal = testTask._run();\n        expect(returnVal).toBe(0);\n});\n```\n. Yep, that behavior is mentioned in the README :wink: \n. Please post an example of what you're trying to achieve.\n. Sorry, but that's not how rewire works. It does not replace automatically your dependencies when the module is required, but it provides you with a way to change the internal variables (and thus overriding dependencies).\njavascript\n// module.js\nvar a = require(\"a\");\nvar b = require(\"b\");\n``` javascript\nvar f = rewire(\"./module\");\nvar g = rewire(\"./module\");\nf !== g\n// Until now f and g both have the same instance of a and b\n// Now you can change these internal variables\nf.set(\"a\", aMock);\n// Now f and g won't share the same instance of a.\n```\nPlease be aware, that if you export the dependencies as stated in your example, you are copying the reference of a on your module.exports object. Thus running f.__set__(\"a\", aMock); won't change the reference attached to module.exports.\nJust think of rewire just adding these two methods to your module:\n``` javascript\n// module.js\nvar a = require(\"a\");\nvar b = require(\"b\");\nexports.set = function (key, value) {\n    eval(key + \" = \" + value);\n};\nexports.get = function (key) {\n    return eval(key);\n};\n```\n. Could you find out what traceur is trying to do?\nEspecially this line:\nat Function.defineProperty (/mnt/sdb1/code/dev/sane/node_modules/traceur/bin/traceur.js:257:7)\nCurrently I can't see that rewire has something to do with it.\n. You could create a minimal test-case that produces the error. And you could also check what value targetModule.id is here.\n. @IanVS are you using mocha as test runner?\n. > OK, it seems that this occurs if the module being rewired exports a string or a variable with a string value. Is that not a supported use of rewire?\nSorry, I've over-read this.\nUnfortunately yes, rewiring modules that export a primitive value is not possible, because the current API needs to attach methods like __set__ and __get__ to the export. I need to clarify that in my readme.\n. Could you set up a simple example repository (or a gist) that demonstrates the problem? It's hard to get a grasp of what is actually going on with such a description (though it is very extensive :grin:)\n\nwhere the file that has been rewired earlier (/folder1/index.js) has its functions in the cache and /folder2/index.js in unable to over-ride the function with same name\n\nThere is no such a \"function cache\"\n. Nice :+1: \n. It doesn't work because currently rewire executes the module as usual. After that it provides setters and getters to change internal variables. You need to replace the https module before the module is executed.\nMaybe that's possible, but then we'll need to add a second parameter to rewire():\njavascript\nvar myAgent = rewire(\"./myAgent.js\", {\n    https: { Agent: agentMock }\n});\n. Righty right\n. You're right, and your fix is probably sufficient. But afaik that would detect even wrong uses of \"use strict\" as legitimate.\n. Yes, probably the same error as in jhnns/rewire-webpack#12\n. Is React using Babel for transpiling?\n. I can't see how this could be fixed by my side. As @sairion pointed out, babel is changing variable names. Thus all uses of eval() will not work as expected.\nI hope babel will do something about it. Although eval() should not be used in day-to-day code, it is still part of the language and will not be deprecated.\n. Thx for the detailed report. Unfortunately I can't reproduce the error. After downloading the gist and running mocha test.js everything is just fine.\n```\nPecorino:eb09a24817bcc58f9421 jhnns$ mocha test.js \n0 passing (2ms)\n``\n. Thx for the detailed research. I was able to fix that problem by wrapping the source code inside an IIFE.\n. Nope, that is actually a limitation by JavaScript. It is not possible to access a function's scope...\n. Are you using rewire on the client-side?\n. You're right, the variabledocumentcan not created implicitly in strict mode. You just have to add it to theglobalobject first. Then you should be able toset` document just within a specific module.\n. Thx :+1: \n. Thx. :+1: \n. Sorry for the late response.\n\nIs this a bug, not a feature, or user error?\n\nThis is a feature, because this way you have the full control. Do you want the rewired version to be in the global require cache or do you just want the rewired version to be isolated \u2013 it's up to you. Imho it would not be a good style if rewire did that for you. Then there would be issues like \"Add option for global require cache\"...\n\nAny chance you could add this to the docs for future users?\n\nI am happy about pull-requests. :grinning: \n. Same as jhnns/rewire-webpack#12\nThis is not an ES6 issue, but caused by the way how babel emulates the new module system.\n. Further insights: babel/babel#1337\nUnfortunately, it's not easy to solve, because it requires a major rewrite. And tbh: I'm not very motivated, because babel's change, which is causing the problem, was driven by the misconception eval() was deprecated in ES6.\n. Definitely :+1: \nThe tests, however, should stay the same (and they should still run afterwards). Since it would be a great rewrite, I'd appreciate if you could do this in close consultation. @speedskater has already contacted me.\n. @trodrigues you can do that. However, it should not sound like it's impossible to use rewire with ES2015 modules. I just have to figure out a good way how to hook-in rewire. I'll probably also have to refactor the public API so that rewire \"ports\" like rewireify are easier to integrate (also see #78)\n. No prob!\n. Sure, what would you like to know?\n. Sorry, rewire can't remove event listeners for you (neither can any other module). You need to implement that for yourself.\n. Sorry, I won't explain how to write a constructor function in JavaScript. There are plenty of good tutorials on the internet...\n. I understand the need to intercept require() calls, but I am currently not planning to implement it, because then it needs to be implemented for rewire-webpack and for browserify someday too. Otherwise I will get new issues opened saying \"feature xyz is not working\".\nYou could wrap you code in an init() function which you can call again to re-initialize the cached functions.\n. That's normal JavaScript behavior :grinning: \nWhen you call rewire('routeModule'), the routeModule is executed. There, you store the reference to a function in the variable routeHandler. Additionally, you create an object with a property handler where the reference is copied. After that you change the variable routeHandler to point to the string 'test', but the copied reference on the handler property is not updated. That's why Hapi is still working with the original handler.\nYou're basically asking for pointers which are not available in JavaScript :wink: \n. Thx for providing a test repo. It looks like the error is only present in PhantomJS. Chrome and FF do not report errors.\nAfter adding console.log() I found out that typeof Function.prototype.bind is undefined. Then I saw that this is a known bug of PhantomJS 1.x. After adding a polyfill in your test, the test did work.\n. If you want to bring your module back to the initial state, I think it's the best to just rewire() it again. This will create a fresh instance of the module.\n. Thx for your suggestion.\nSince there are more important issues to solve (like babel compatibility), I don't think that this will be implemented soon. Especially because I don't want people to misuse __get__ to evaluate all kind of expressions.\n. Thank you for your detailed PR (with tests and docs :+1:). I'm definitely willing to merge this as it was already requested several times ( #24 #44 #68 ).\nOne problem I see, though, is that it needs to be implemented for rewire-webpack as well. I would like users to be able to use rewire features also with webpack without needing to care about which feature is supported.\nI need some time to implement it ...\n. Is this still an issue?\nCould you add a console.log(module.parent) here and compare the result in both envs?\n. No problem :grin: \n. There is no \"magic mocking\" behavior behind rewire. Calling __set__(variable, value) will just evaluate variable = value inside the module's scope. If your mock does not provide all console methods `, there will probably be errors.\nYou could use prototype inheritance instead:\njavascript\nvar consoleMock = Object.create(console);\nconsoleMock.log = function () {};\nApp.__set__('console', consoleMock);\nWriting App.__set__('console.log', consoleMock.log); will also work, but if you do so, you don't need rewire at all. It the same like writing console.log = consoleMock.log. Using dot notation was never intended and results in the opposite: You won't mock it, but change it globally.\n. You need to pass in variables names for __set__, not module paths.\n. Sounds good \ud83d\udc4d \nWould you make a PR?. Mhmm I'm not sure... @boneskull\nIn your example, wouldn't redefining __get__ or __set__ destroy the original getters and setters on the exported dependency? It looks like a small change, but I'm afraid that it might lead to subtle bugs when setters and getters are overwritten.\nUsually, rewire() should always return a fresh instance, so you would not have this kind of problem. It becomes a problem because people started to re-implement rewire() for other environments only to some extent.\n. @TheSavior that are all valid points. Maybe we should change the way how rewire() works. Maybe that's more pragmatically...\nI'm just not happy that there are so many modules that do it \"almost\" the rewire way, because it can behave very differently in certain situations. It's just too much confusion for beginners.\nConcerning this PR: I'm not quite sure... maybe I'll merge this PR as a quickfix. But it's not ideal because it obscures a conceptional problem underneath.\n. Well ... re-assigning const is not possible, rewire can't change this.\nIn order to do this, rewire would need to change the code (like @brenolf did manually). Therefore, we would need to use a parser which is currently out of scope.\nHowever, if we want to support ES6 modules someday, we will need a parser anyway, so I'll consider this when rewriting rewire.\n. Do you have an example? I'm pretty sure that this can not work.\n. > But maybe you were talking about overwriting?\nExactly\n. I think it's totally valid to change const objects, because const does not mean that the object itself is frozen (you could use Object.freeze() for that \ud83d\ude09 ). However, I would not change the code just for the test framework.\n. @shivarajnaidu I'm thinking about ES6 support, but it's not that easy :) \u2013\u00a0especially as long as the loader spec is not finished yet.\n. Rewiring const is supported since 3.0.0. @goyney Your example should work. Could you provide a demo that makes it reproducible. I did found a bug though where const was not properly detected when it was written like: const{ apiRoot .... I published a fix with 4.0.1. Could you setup a small example that demonstrates the problem?\n. I'm thinking about providing an option to specify the dependencies because this feature has been requested very often. #73\n. > In ES5, it would throw if given something that was not an object\nDoes this mean that null will throw on node 0.12?\n. Btw: Thx for your PR :+1:. I'll merge it asap.\n. Shipped with 2.5.1\n. Thx\n. Agreed\n. Thank you for pointing that out. I've answered it on SO and added a note in the README.\n. Thx\n. Have you forgotten to commit moduleWrapperSrc.js? :grin: \n. Oops, looks like the tests are not working anymore. You've moved the stuff that has been called for every rewire() out of the function. Now, it's only done on initialization. That's why some globals are not recognized anymore.\nIt is important that getImportGlobalsSrc() is executed for every rewire() again.\n. Thx for sharing this. Proxies will definitely play a big role in the future of mocking, especially because ES2015 modules leave us with many puzzles to solve.\nSince you were asking for feedback: To be honest, I think your example is too complex for the thing you're trying to achieve. I would be careful to check private function calls because they are too implementation dependent. Soon you'll find yourself in a situation where you're constantly adjusting your tests because they rely too much on internals instead of the public API.\nI clearly undestand the motivation behind this: sinon's sandbox is a nice thing, but it can't be used with __set__. But have you tried using rewire's __with__ method? It's also a \"sandbox\" which reverts its modifications afterwards. So, in your example, you'd write:\n``` javascript\ndescribe('module fake_http_client', function() {\n  describe('SomeModule', function() {\n    describe('instances', function() {\n      const instance;\n  beforeEach(function() {\n    instance = new SomeModule();\n  });\n\n  it('call a private function from a public method that passes through args', function() {\n    const privateMethod = sinon.spy();\n\n    some_module.__with__({\n      privateMethod\n    })(function () {\n      instance.publicMethodThatCallsPrivateMethod('foo');\n      privateMethod.should.have.been.calledWith('foo');\n    });\n  });\n});\n\n});\n});\n```\nIt does the same thing afaict and requires less \"hackery\".\n. > Having done that, I thought the most succinct way to test it was to test that the private function behaves as expected; and then test that the public methods call the private function in the way I'd expect them to.\nYes, that's the only use-case I can think of where testing private methods is actually better than writing 3 times almost the same testing code just to test the public API.\nAnd yes, writing __some_module.privateConst is definitely nicer than some_module.__get__('privateConst'). Proxies will be awesome for this kind of hackery.\nI also like your idea about using symbols. That approach doesn't even require rewire or some other library, it's just vanilla JS. The only thing that bothers me is that you have to modify your code just for your tests which is not a good thing imho.\nAnyways, I think I'll take this as inspiration for the next major version of rewire :grin: \n. Hehe, no problem, you're not the first one :wink:. \n. Thx \ud83d\udc4d Has been shipped with 2.5.2\n. Thank you for your PR \ud83d\udc4d \nUnfortunately, I don't think that this change makes a lot of sense. rewire does neither use the cached version from Node.js nor does it cache the module, so I don't know why it should miss with the cache anyway.\nClosing it for now, but maybe you can bring up a use case I should consider.. I'm not sure if I did understand the problem correctly. But you can solve that issue just by calling delete require.cache[require.resolve(targetPath)]; before calling rewire(), so I don't see the benefits of adding this piece of code to the library.. > I would expect that if I rewire a module, I'll always get a clean copy at the time of rewiring, which is not the case if that module has submodules.\nPersonally, I don't agree with that because for me, it would be surprising that some other module is executed by calling rewire(). Even in a production environment, sub modules might not be executed again when they are already in the cache.\nAnd: Your proposed change does not fulfill this requirement, it will only remove the rewired module from the cache (which has basically no effect because the module is not read from the cache anyway). . Nope. Accessing variables inside a function closure is not possible.. Rewire does not work with Browserify and Webpack out-of-the-box because it relies on the implementation of Node's CommonJS implementation. For Webpack, I've written the rewire-webpack plugin. But for Browserify, there is no plugin and I do not plan to support it, sorry \ud83d\ude1e . Sorry, path aliasing is not supported. The module is resolved with node's resolving algorithm.. Awesome \ud83d\udc4d \nPublished as 3.0.0. Sorry for letting you wait \ud83d\ude22. I'll look into this the next days.... Awesome, thanks. Sorry for the broken version. I think I've used require.resolve locally but haven't committed it somehow...\nShipped with 3.0.1. Thanks \ud83d\udc4d \nShipped with 3.0.1. Awesome, thank you! :+1:\nShipped as 3.0.2. Yes. It's only one level deep. And there are no plans to change that because I think it could be very confusing otherwise.. Thanks for this PR \ud83d\udc4d Although I've refactored it (removed babel again), it was still an important commit :)\nPublished as 4.0.0. Can you test it with rewire 4?. @bforbis thanks. The __core-js_shared__ property is used by core.js to share instances of polyfills where it's important that there is only one instance per runtime (see here).\nSince rewire@2 and rewire@4 are pretty similar, I guess the problem was introduced by a \"hidden\" update of your core-js module through transitive dependencies.. Can you provide a minimal reproducible example? :) That would help me to track down the bug.. I removed babel-core. Should be faster again.\nShipped with 4.0.0. Sorry, eslint is not a dev dependency in our case. Since we're rewriting const to let, we need to check first that const are not re-assigned.\nWhy is that a problem for you? If you're using ESLint in your project, wouldn't it make more sense to have it as a dev dependency in your application (assuming you're calling it via npm scripts)?. Thanks for reporting this.\nUnfortunately, I guess the behavior of rewire@3 was actually more surprising. You're surrounding your code with a curly braces, thus creating a block scope. rewire cannot access variables inside a block scope because that's impossible with pure JavaScript.\nYour test was only possible with rewire@3 because I used to transpile the code with babel which removed the block entirely I suppose. However, using babel for that job brings other problems as described here.\nI'd remove the curly braces around your module code because it's quite unusual and not necessary.. - rewire 3 uses Babel to transform const to let. That's why it doesn't work with special syntax like the object spread operator\n- rewire 4 uses a Regex to circumvent these issues. Can you create a flame graph of your tests to pinpoint me to the direction where rewire spends the most time? @jehy . Because it's used as regular dependency. It makes sure that const is not re-assigned before rewire changes const to let.. Hi @brokentone \ud83d\udc4b, thanks for reporting this \ud83d\udc4d \nI think your issue description is correct. rewire pollutes the extensions object  when a module with a different extension than .js or .coffee is being rewired and a loader has been registered for that extension (because otherwise, Node falls back to the js loader which works again).\nAfaict, the only reasonable fix for that is to remove the Module wrapper hack and use pirates for this.. Thx \ud83d\udc4d \ud83d\ude01 . Good catch \ud83d\ude01 . Any reason why you're not using the ^ operator? Personally, I prefer that.. Looks like you've forgotten this, but I'll clean it up, thanks :). ",
    "topa": "I ran the tests and \u2716 3 of 19 tests failed:\n1) rewire (browser) should work like require():\n2) rewire (browser) should cache the rewired module:\n3) rewire (browser) #reset should remove all rewired modules from cache:\nCurrent Version of browserify is 1.13.5.\n. OK, but you suggested to downgrade to 1.15.2 Did you meant 1.13.2?\n. Rewire's unit-tests are working with 1.13.2 and 1.13.3. \nFixed the version in nof5's package.json to 1.13.2. Reinstalled nof5, but got still the same error.\nCould you please take a quick look at the implementation here?\nI think it should be ok, but just to definitely be sure.\n. Uncaught Error: Cannot find module 'rewire' tests.js:6\nrequire tests.js:6\n(anonymous function) webpack-module:///home/topa/Applications/nvm/v0.8.9/lib/~/nof5/lib/bundler/webpackLoader.js!/home/topa/Applications/nvm/v0.8.9/lib/~/nof5/lib/bundler/webpackEntry.js:1\nwindow.nof5.enableTests tests.js:28\nwindow.nof5.enableTests tests.js:29\nrequire tests.js:12\nwindow.nof5.enableTests tests.js:20\nwindow.nof5.enableTests tests.js:22\nonConnect testRunner.js:59\nsayHello nof5.js:32\nEventEmitter.emit socket.io.js:633\nSocketNamespace.onPacket socket.io.js:2218\nSocket.onPacket socket.io.js:1930\nTransport.onPacket socket.io.js:1332\nTransport.onData socket.io.js:1303\nWS.open.websocket.onmessage\n. It seems that I've just forgotten to set \n{ output: \"bundle.js\" }\nBut now there is an other error. Stay tuned ...\n. nof5's WepbackBundler must return a String, but if I add the option from above like in the rewire documentation described a call to the function webpack() isn't returning a string, but instead an object.\nSo this is not the Error.\n. With the last update (1.0.1) it is working now. Thanks a lot for your work!\n. ",
    "djthread": "The one reason why this is slightly annoying, though, is that mocha is complaining that my @'d value I'm mocking out is a global variable. I need to disable this detection with the --ignore-leaks flag so it doesn't complain with\nError: global leak detected: myVariable\n. My best guess is to avoid polluting the global namespace, particularly on JS ran in the browser. But you're right -- modules already separate things in the node world.\nThe function wrapper can be avoided with a flag passed to the coffee compiler, which seems to be the best approach... But then I need to decide what to do with the frontend files and even my shared files. (backbone models)\nI can see how getting the mocked variables into the main scope is really the only solution...\nThanks for the confirmation :)\n. I will say that I'm very much a noob at this stuff, and there's a lot I haven't figured out yet.\nI'm currently using require.js to handle packaging and loading my javascripts on the frontend. Perhaps I really do want to eliminate that wrapping function for ALL my coffee compiles across the board.\nFor now, I think hoisting variables into the \"global\" scope using \"this.\" is a workable solution, but if I find myself with something better, I'll report back.\nThanks, Johannes.\n. You can compile the CS on demand or use the compiler with the -w flag to watch files and recompile them when saved. I actually integrated this into some node that will rerun the tests when a suite file is saved.\n. ",
    "00dani": "Hacking up require.extensions does the trick when using Mocha and its --compilers coffee:coffee-script option; when using Mocha in that way it's not obvious how to pass options like -b to the CoffeeScript compiler. \nI put the following in my test/common file and it seems to work fine. (If there's a cleaner way to pass options to the CoffeeScript compiler in require.extensions, that would be great?)\n``` coffeescript\nfs     = require 'fs'\ncoffee = require 'coffee-script'\nstripBOM = (content) ->\n  if content.charCodeAt(0) is 0xFEFF then content.substring 1 else content\nrequire.extensions['.coffee'] = (module, filename) ->\n  content = stripBOM fs.readFileSync filename, 'utf8'\n  content = coffee.compile content, {filename, bare: on}\n  module._compile content, filename\n``\n. My CoffeeScript-on-Node workflow is always to compile on the fly.\n- When running the project normally, I use thecoffeecommand instead of thenodecommand.\n- When testing, I runmocha --compilers coffee:coffee-script, which allows Mocha to compile and run.coffee` test files.\nI don't ever need to worry about compiled .js files through this setup, which is nice.\nPerhaps the above require.extensions hack could be included in rewire but not activated by default? Something like this, perhaps:\ncoffeescript\nrewire = require 'rewire'\nrewire.enableForCoffeescript()\n. Works flawlessly. Thanks! ^_^\n. ",
    "es128": "http://nodejs.org/api/globals.html#globals_require_extensions\n\nSince the Module system is locked, this feature will probably never go away.\n\nThe rewire implementation is probably safe actually, despite how distasteful the node maintainers find require.extensions to be now. \n. Wait, so why the need for the regress? This issue boiled down to an oversight of the requirement to use bare, which is good practice in node apps anyway since the module system does its own encapsulation.\nPlease... leave it alone.\n. But the feature as it stands works fine - allowing testing without a compilation step for the specific use-case. \nFor anyone else, they can precompile, which they'll have to do either way.\n. Actually, TBH, I usually do run the tests on precompiled code as it's noticeably faster. But I like the option of not having to, perhaps for smaller projects/experiments. And I'm just not understanding the benefit gained by removing the existing, working feature, by imposing the workaround on everyone instead of just outliers.\nBtw, since I haven't expressed this before - thank you for rewire, it is absolutely awesome. I will continue using it whether you decide to remove the built-in coffee-script support or not.\n. ",
    "sokra": "see #12 \n. :+1: \n. It's not really complex. It just replaces paths to modules in rewire(...) with webpack module numbers to a module with is additionally processed by a loader. The loader behaves like the node.js \"loader\". require(\"rewire\") is aliased to a small module loader (which do not cache).\n. oh I've forgotten to update the dependency to webpack 0.9.x...\n. do you want to support both webpack 0.8 and 0.9 or do you want to drop support for 0.8 when 0.9 is ready?\n. I created a list for webpack plugins: https://github.com/webpack/docs/wiki/webpack-plugins\nFeel free to edit the description...\n. I was mentioned... (Just to prove that I'll respond fast :smile:)\n. @jhnns You can use sandboxed-module with a rewire sourceTransformers.\n. ",
    "aleclofabbro": "you prefer webpack, i guess .. (i see you developed an adapter)\nwhy?\ni'm using browserify, i don't know webpack\niyho, whats worth for me? learning fast webpack or write an adapter for rewire?\n. ",
    "tphummel": ":+1: \n. ",
    "davidguttman": ":+1: \n. ",
    "jbaiter": ":+1:\n. ",
    "focusaurus": ":+1: \n. ",
    "i-like-robots": "Because I really needed something like Rewire for Browserify I went ahead and did the port, so far it's been working out nicely: https://github.com/i-like-robots/rewireify\n. @jhnns Thanks for more information, that's really helpful. I put this together extremely quickly as a proof of concept but I plan on working on it to make it more robust. I studied your implementation thoroughly and it was interesting working out how to lever it into Browserify. Unfortunately Browserify does not readily expose a require function to override but I think I can definitely improve on simply injecting the functions into each and every module!\n. That covers a lot of the things I've been thinking about, glad to see some of this stuff has already been solved! Thanks for digging that out for me.\n. ",
    "jprichardson": ":+1: \n. ",
    "jsdf": ":+1: \n. ",
    "wookiehangover": ":thumbsup: \n. ",
    "benatkin": ":+1:\n. ",
    "iamrandys": ":+1: \n. Thanks @i-like-robots!!  Your rewireify works perfectly!  I simply added it to my karma.conf and presto! Thanks again!\nbrowserify: {\n        debug: true,\n        transform: [ 'reactify', 'rewireify' ]\n    },\nhttps://github.com/i-like-robots/rewireify\n. :+1:\nAh as you stated, I see that rewire is clearing the require cache each time and returning a fresh instance.  This is very important when developing unit tests.  Rewireify is really close, but my unit tests are failing using because they are all using the same \"required\" instance and my mock call counts are not as expected when running multiple tests together.  If I run the tests one at a time they run fine.\nRewire is exactly what browserify needs, but I don't see any way to clear the require cache in browserify.\n\nDifference to require()\nEvery call of rewire() executes the module again and returns a fresh instance.\nrewire(\"./myModule.js\") === rewire(\"./myModule.js\"); // = false\n\n\n\nFurthermore a call of rewire(\"./moduleA.js\") needs to add moduleA as dependency to the bundle.\n\nI can easily add moduleA as a dependency in Browserify by calling bundler.require('/moduleA.js', {expose: './moduleA.js'). \n. +1\n. No matter how many +1s, it'll never happen ;) I've seen the +1s for months now... I believe rewirify uses rewire now?\n. ",
    "traviskaufman": ":+1: \n. ",
    "blairanderson": "i want browserify support\n. ",
    "danielyogel": "Browserify support would be great. Thanks!\n. ",
    "oncletom": "Pretty much interested by this feature to reuse my tests in karma as well :+1: \n. ",
    "jonykrause": "\ud83d\udc4d\n. ",
    "cyrilthomas": "how about requirejs?\n. ",
    "jstejada": ":+1: \n. ",
    "OscarGodson": ":+1: \n. ",
    "metrofun": ":+1:\n. ",
    "andrezsanchez": ":+1: \n. I submitted this assuming that the eventual plan is to get this module compatible with Browserify.\nI don't think that this library is the place to add compatibility with another language. Maybe the solution would be to allow a hash of temporary extensions to be passed to the library, and separate out the coffee compatibility to a separate lib?\nMaybe the API could look something like the following if you chose to do this.\neg.\n`` javascript\n// maybe put this in an actual module likerewire-coffee` or something\nfunction coffeeExtension(module, filename) {\n  var coffee = require(\"coffee-script\"),\n  content = stripBOM(fs.readFileSync(filename, \"utf8\"));\n  content = coffee.compile(content, {\n    filename: filename,\n    bare: true\n  });\n  module._compile(content, filename);\n}\nvar rewire = require('rewire').useExtensions({\n  '.coffee': coffeeExtension\n});\nvar module = rewire('./module.js');\n```\nThis would allow users to still use Rewire with the current API if they don't care about this sort of thing.\nMaybe this is a bit overkill if Coffee is the only lang that needs compatibility, but I figure it's worth considering.\n. ",
    "wildeyes": "+1\n. ",
    "knpwrs": ":+1: \n. ",
    "Lucas-C": "+1\n. ",
    "SizeSeeker": "+1\n. ",
    "mik01aj": "+1\nEDIT: I found https://github.com/i-like-robots/rewireify, which does the job for me. Thanks @i-like-robots !\n. ",
    "Prestaul": ":+1: Yes, please. A fully compatible browserify transform would be awesome.\n. ",
    "pjanuario": "Hi, I am working in some isomorphic code with rendrjs and stumble with this issue of using rewirefy with browserify 3 and karma. Any one was able to make this work on karma?\nBy the way, nice job with this module it's seems to work really nice on node.\n. @phun-ky same here... did you find any workaround for this? :/\n. ",
    "Josh-a-e": "+1\n. ",
    "nsonnad": "+1\n. ",
    "revolunet": ":+1: \n. ",
    "stuff": ":+1: I think we need an official browserify support...\n. ",
    "joswhite": "Edit: This would be cool, but I found that webpack actually does the job a bit cleaner. All you have to do is add the few lines to your config file. If you are using Node you'll also need to specify empty modules for fs, etc. This is my config file.\nvar RewirePlugin = require(\"rewire-webpack\");\nmodule.exports = {\n    plugins: [\n        new RewirePlugin()\n    ],\n    node: {\n        child_process:\"empty\",\n        fs: \"empty\"\n    }\n};\n. ",
    "allenm": "+1\n. ",
    "aroc": ":+1: \n. ",
    "djforth": "\n1\n. \n",
    "kvintessents": "+1\n. ",
    "BenGedi": ":+1:\n. ",
    "michaelobriena": "+1\n. ",
    "nicbarker": "+1\n. ",
    "ariporad": "+1\n. ",
    "danillouz": "+1\n. ",
    "tran2": "+1\n. ",
    "evanroane": "+1\n. ",
    "rikutiira": "+1\n. ",
    "mcabrams": "+1\n. ",
    "belen-albeza": "+1\n. ",
    "vdininski": ":+1: \n. ",
    "kleichtle": "+1\n. ",
    "JoshuaToenyes": "+1\n. ",
    "sporto": "Right, I tried to simplify the example too much making it different from my original use case and thus introduced the passed by value issue without noticing. \nThis is closer to what I would like to do, maybe this is possible:\n```\nvar foo = require('./foo');\nvar bar = require('./bar');\nvar providers = {\n    foo: foo,\n    bar: bar\n}\nmodule.exports = {\n    run: function (provider) {\n        return providers[provider];\n    }\n};\n```\nSo I have an object providers that has references to two modules. I want to dynamically call one of these modules depending on the params passed into my module.\nSo in my test I would like to rewire foo and get this line return providers[provider] to return the fake version.\nthanks\n. ",
    "mcandre": "Hehe, awesome.\nIf you can isolate the files that need eval() into subfolders, you can put a .jshintrc in the subfolders that ignores eval(), while still checking other code for its presence.\n. ",
    "davidposin": "It looks like it should work.  One thing I have noticed, particularly with trying to override modules inside modules, is that you need to override the object with an object.  For example,\nx.set('http', function (){}) doesn't work.\nBut,\nx__set_('http', {\n  get: function (){}\n}\nshould work.\nI have a small sample up on github and cloud9 if that would be helpful to you.\nhttps://c9.io/dposin/jasmine-node-rewire\nhttps://github.com/Lastalas/Jasmine-Node-Rewire-Example\nOn Fri, Oct 4, 2013 at 1:52 AM, Johannes Ewald notifications@github.comwrote:\n\nHmmm, this should definitly work. Since app is still a regular module,\nthere should be no difference between rewiring an express app or any other\nmodule. Afaik express has no set-method which would clash with\nrewire's set.\nMaybe there's another mistake or typo. If not, could you provide\nadditional information?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/jhnns/rewire/issues/20#issuecomment-25684282\n.\n. Oh, I know.  I love rewire.  The point is more that you can't set over\nthe http module with a new function directly.\n\nOn Fri, Oct 4, 2013 at 11:07 AM, Johannes Ewald notifications@github.comwrote:\n\n@Lastalas https://github.com/Lastalas That's intended. rewire just\nevals the assignment within the module. Of course rewire can't know that x.set('http',\nfunction (){}) should mock the get-function of the http-module.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/jhnns/rewire/issues/20#issuecomment-25718907\n.\n. A constructor, implement spys, block a module totally (like http so no\nemails can go out). But, it's not something I think one does normally.\n\nOn Fri, Oct 4, 2013 at 11:13 AM, Johannes Ewald notifications@github.comwrote:\n\n@Lastalas https://github.com/Lastalas Using rewire is basically like\nyou had written a setter in your server.js like this:\n// inside server.jsexports.set = function (key, value) {\n    eval(key + \" = value\");};\nOf course, this is ugly. That's why rewire does all the dirty work for you [image:\n:wink:].\nBut why would you replace the http-module with a function?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/jhnns/rewire/issues/20#issuecomment-25719296\n.\n. @mefernandez https://github.com/mefernandez If you are trying to test the\nsayHello function then  I would suggest using get to pull the function\nout, and then run it manually.  If you are attempting to test the server's\nresponse to that url then you are moving into the realm of integration or\nend to end testing.\n\nTry:\nit('should say Rewired', function(done) {\n    var rewire = require('rewire');\n    var app = rewire('../app.js');\n    var fn = app.get ('sayHello');\nvar res = {\n  send: function (status, msg){\n    expect(status).toEqual (200);\n    expect(msg).toEqual('Hello');\n  }\n}\nfn ({}, res);\n});\nOn Fri, Oct 4, 2013 at 11:55 AM, David Posin david.posin.smp@gmail.comwrote:\n\nA constructor, implement spys, block a module totally (like http so no\nemails can go out). But, it's not something I think one does normally.\nOn Fri, Oct 4, 2013 at 11:13 AM, Johannes Ewald notifications@github.comwrote:\n\n@Lastalas https://github.com/Lastalas Using rewire is basically like\nyou had written a setter in your server.js like this:\n// inside server.jsexports.set = function (key, value) {\n    eval(key + \" = value\");};\nOf course, this is ugly. That's why rewire does all the dirty work for\nyou [image: :wink:].\nBut why would you replace the http-module with a function?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/jhnns/rewire/issues/20#issuecomment-25719296\n.\n. @gprasant You can but you can only interact with variables at the \"top\" level.  You can't override http.get but you can override the http object to have a custom get function.\n\n\nI put together a sample on c9 where I override http.get here that might help:\nhttps://c9.io/dposin/jasmine-node-rewire\nAlso, I have a post that walks through rewire and jasmine-node:\nhttp://randomjavascript.blogspot.com/2013/10/jasmine-node-and-rewire-part-1.html\nHope this helps.\n. @jhnns I fixed the link.  thanks for spotting that.\nThe __dirname was because of the way c9 handles the actual file structure.  I'll look and see if I can remove it.\n. ",
    "mefernandez": "Hello,\nI've set up a little Gist with only 2 files to show the problem (plus the package.json to get the dependencies).\nhttps://gist.github.com/mefernandez/6829025\nIt's easy to set up. Remember to put the test-rewire.js file inside a test folder so paths works fine and install Mocha if you don't have it npm install -g mocha.\nI wished I had a clue to what's the problem.\nI really need a way to inject mocks into the Express app to test things.\nAnd thanks for all the help.\n. ",
    "gprasant": "The extension of CSR is still .coffee and so an addition to require.extensions is not needed. \nI see that you are doing a require(\"coffee-script\") in https://github.com/jhnns/rewire/blob/6040974a2f0bc91b3aed0a389584c967831dd1dd/lib/moduleEnv.js#L58\nThis \"coffee-script\" is a module name. In my case, Coffee-script-redux is a different (stricter) compiler for .coffee files. It would be good if there was a json file for settings where the compiler can be specified and the specified compiler can be required. I believe this is how mocha does it..\n. The readme is on http://visionmedia.github.io/mocha/. Please go to the link and Ctrl+F for --compilers\n. > Are you calling mocha with --compilers coffee:coffee-script?\nNo, I call it with --compilers coffee:coffee-script-redux. But you have the correct understanding of it.  \n\nIt seems to me that the CS \"feature\" of rewire #8 prevents you from using other CS compilers\n\nI think so too. Though, I did try to get rewire to work with CSR but failed. I haven't looked at it enough to see where the problem lies. In short, let me share the gist of what I did https://gist.github.com/gprasant/7399548\n. Let me check if that will work.\nOn Nov 11, 2013 2:29 PM, \"Johannes Ewald\" notifications@github.com wrote:\n\nMhmmm k. And if you remove the whole CS-compile thing of rewire and start\nmocha with --compilers coffee:coffee-script it still works? If this is\nthe case, I'll remove CS-support so everybody can choose his favorite\nCS-compiler.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/jhnns/rewire/issues/21#issuecomment-28182217\n.\n. Hello, I tried this today. I have a commit up at https://github.com/gprasant/rewire/tree/anycompiler \ncommit : https://github.com/gprasant/rewire/commit/9518cc4ee09947b3699eb65a3001b3b891a2746d.\nHere is what I found out  - One test fails it(\"should also work with CoffeeScript\") . But it looks like the coffeescript file is read. But rewire is not able to set a variable . I thought it could be because of an outer closure  introduced when compiling the file, but that doesn't look like it. You probably know more about how this works. Can you try to see if the way I have removed the coffeescript functionality is right and see whats causing rewire to not work in this case? \n\nUPDATE It looks like coffeeModule.readFileSync is resulting in calling the actual fs.readFileSync even though we have stubbed it out. \nUPDATE-2 Looks like it is the outer closure that was the problem. So, I compiled module.coffee with --bare and then ran the test against the compiled js file . This time, the test ran successfully. I don't know of a way to include this --bare switch in the mocha command line. yet.\n. I can manage precompiling \n. Does that mean the only way to be able to use rewire on a module is to\nexport an object and not export a function ? Do you know of any way to use\nrewire with the module pattern ?\nOn Nov 7, 2013 6:47 PM, \"Johannes Ewald\" notifications@github.com wrote:\n\nrewire adds the setters and getters to the exports-object at the bottom\nof the module. Just imagine that rewire injects code at the bottom of your\nmodule that looks like:\nexports.set = function () { ... }:exports.get = function () { ... };\nSo if you do module.exports = helper, the setters and getters will be\nattached to the helper-object, not to the object returned by calling\nhelper(app).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/jhnns/rewire/issues/22#issuecomment-27961747\n.\n. Thanks @Lastalas . \n\n@jhnns \n```\nvar helper = rewire (\"./helper\");\nhelper.set(\"http\", { ... });\nhelper.set(\"fs\", { ... });\nuse test_helper for calling functions & user helper for set and get .\ntest_helper = helper(app_stub);\n```\nThis is the style Im going ahead with. Looks good? Better Ideas?\n. Current versions of node? What version are you on ? \n. good enough. nodejs.org says current version is 0.10.22\n. OK. I think  I figured out the reason behind this. TLDR; is that its a non issue - for  any version of node. \nSo, what happened was during a particular test run, all tests had not run successfully, and this resulted in a state where I had both \ntestModules/fake_node_modules and \ntestModules/node_modules in the test directory. This resulted in a failure when trying to rename fake_node_modules to node_modules (because there was already a dir called node_modules in the same dir). Perhaps the message from fs.renameSync could have been better. I could not track this with git as well because node_modules are .gitignored.\n. submitted an issue in node https://github.com/joyent/node/issues/6534\n. ",
    "wnr": "Okay, thanks for your answer. Too bad I can't have the best of rewire and sandboxed-module. I think I'm gonna stick with rewire either way since I really like the non-eval approach :)\nInteresting about the gray-box-testing. Never thought about that in that way, but I guess it makes sense.\n. ",
    "dminkovsky": "Oh yes, definitely. Thank you very much for your thoughts.\n. ",
    "jankuca": "Um, nevermind.\nI was using the added methods for mocking of JSON files loaded via require() but I replaced this with mock-fs and it works flawlessly.\nFeel free to merge this later if you find it useful but I do not need the feature anymore. Cheers!\n. ",
    "jayfresh": "Hi, I've been trying this (I work with @csugden) and I'm getting undefined for the result of myModel. Specifically:\n```\nvar rewire = require('../node_modules/rewire'),\n  myModel = rewire('./lib/myModel');\nrequire.cache[require.resolve('./lib/myModel')] = myModel;\n// in another file\nvar myModel = require('./lib/myModel');\nconsole.log(myModel); // undefined\n```\n. As a follow-up, I noted that the object structure of what is put in the require cache by require is a bit different to what is put there by overwriting the cache. For example, modules in the cache that require has put there have a \"paths\" property.\n. The quickfix you suggested worked. Jasmine-node seems to collect the spec files together alphabetically, so I've got \"aFixSpec.js\" that gets loaded first.\nI also wanted to be able to run the tests independently, which meant keeping the use of rewire in the spec files. I got around this by using the same technique to overwrite require's cache of rewire and replace it with require (also in aFixSpec.js):\nrequire.cache[require.resolve('rewire')] = {\n  exports: require\n};\nThis means when you run all the tests at once, any further use of rewire outside of aFixSpec.js uses require and hence goes through the same cache, which looks like a noop; but as I mentioned above, this allows the rewire method to remain in the test specs so they can be run independently.\n. ok!\n. ",
    "Trindaz": "For future googlers, you could also try using sinon to enable rewire usage with mongoose models. Here is an example that worked for me:\njavascript\n  function disableNewModelDefinitions() {\n    var originalModel = mongoose.model;\n    sinon.stub(mongoose, 'model', allowModelRetrieval);\n    function allowModelRetrieval() {\n      if (arguments.length === 1) {\n        return originalModel.apply(mongoose, arguments);\n      }\n    }\n  }\n. ",
    "neverfox": "@Trindaz Could you provide an example of how you actually use that function? Thanks!\n. I believe this would work in most scenarios where you need to re-register a mongoose model:\njs\ndelete mongoose.connection.models['Cat'];\n// proceed with rewire, proxyquire, etc.\n. ",
    "coveralls": "\nCoverage remained the same when pulling 74dcfece99ff75e36a4ea544885f7aab888a82cf on bobpace:undo into d4bc6505c0c116074bc89697b553decfea54dec5 on jhnns:master.\n. \nCoverage remained the same when pulling ca709ede5ac0d633f5fec7a6e1e2c40a4db3c48e on bobpace:undo into d4bc6505c0c116074bc89697b553decfea54dec5 on jhnns:master.\n. \nCoverage remained the same when pulling e01178ade03e1a0000f9f934a2d3dc12270dc5c2 on bobpace:cjsx into d4bc6505c0c116074bc89697b553decfea54dec5 on jhnns:master.\n. \nCoverage remained the same when pulling 5edb4b669297ab7bcbe8eb58494b2da0d24472f1 on bobpace:cjsx into d4bc6505c0c116074bc89697b553decfea54dec5 on jhnns:master.\n. \nCoverage remained the same when pulling 6d83ba10154027cb8987a0991854da1b0c887bf8 on bobpace:cjsx into d4bc6505c0c116074bc89697b553decfea54dec5 on jhnns:master.\n. \nCoverage remained the same when pulling ad7056daa37b376bdddd990ad117fdd271dbda8d on nickb1080:master into 3e06f8784c0a08bf3dacf8eb15aff1b6902394a9 on jhnns:master.\n. \nCoverage remained the same when pulling 369f2d4b76740bcdc7f14291b4621f79c7fa1ee8 on Trott:fix-leak into 93d3907216f1a0ea4bc24eb0bc83775f84a6063c on jhnns:master.\n. \nCoverage remained the same when pulling 7e25ede892de0827d6d2df71690df8cb623bde4a on Trott:fix-leak into 93d3907216f1a0ea4bc24eb0bc83775f84a6063c on jhnns:master.\n. \nCoverage remained the same when pulling 15dc51b720825bb1a10e2d26343187e132de80ce on claydotio:you-dont-even-want-to-know-how-long-this-took-to-find into 79aac24c118799f39300ac18d8fc71c83eb6a527 on jhnns:master.\n. \nCoverage remained the same when pulling 09ad3c558db8de51f820a161231d137fe46f7cdf on andrezsanchez:dependencies into b4af5ba1bb3908b3f6743bf96d867c37c399a57c on jhnns:master.\n. \nCoverage remained the same at 100.0% when pulling f23df27380e506322daaf886b692b3770ab41bac on pdehaan:patch-1 into 39e7de2aa557685333a16a68914d8b2290d26d05 on jhnns:master.\n. \nCoverage remained the same at 100.0% when pulling cdec5561b900b612e3cfe9d115b892bac4f6e4e0 on stevemao:patch-1 into 39e7de2aa557685333a16a68914d8b2290d26d05 on jhnns:master.\n. \nCoverage remained the same at 100.0% when pulling 5561b8efaf7112a24072c170264cfc4653110f10 on tschaub:unmodified-extensions into f126dcbe4c97e695ffc2e3de0cfe0a8c32f66fc5 on jhnns:master.\n. \n\nCoverage decreased (-1.0%) to 99.048% when pulling cf7bfb583fa8d2465d7b9d064fa45358f66254b4 on mboudreau:master into fff5037950f78b4164c299560f761bd5e3dc9e06 on jhnns:master.\n. \n\nCoverage decreased (-1.0%) to 99.048% when pulling cf7bfb583fa8d2465d7b9d064fa45358f66254b4 on mboudreau:master into fff5037950f78b4164c299560f761bd5e3dc9e06 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling 291fb1b5ecc4e1a0e75d4df7b1ca362de6f70ae1 on killmenot:fix-101 into fff5037950f78b4164c299560f761bd5e3dc9e06 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling d1ad67aaa899b40d7fcf24df19d7f0a3fb8be70a on JvJefke:feature/const-let-conversion into fff5037950f78b4164c299560f761bd5e3dc9e06 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling c0e1b87c2a40eeb5046ed55f41f89755f1a51924 on JvJefke:feature/const-let-conversion into fff5037950f78b4164c299560f761bd5e3dc9e06 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling 501e4c29bd16eaafae348b8faba6e5b061b98bc4 on JvJefke:feature/const-let-conversion into fff5037950f78b4164c299560f761bd5e3dc9e06 on jhnns:master.\n. \n\nCoverage decreased (-1.7%) to 98.333% when pulling be35370c9bb9bc3787e069dc3537c9df2cb9427b on pr/origin/117 into fff5037950f78b4164c299560f761bd5e3dc9e06 on master.\n. \n\nCoverage decreased (-0.7%) to 99.32% when pulling d6bc7ac449793f5633ac23d5d22345e335fa494c on pr/origin/117 into fff5037950f78b4164c299560f761bd5e3dc9e06 on master.\n. \n\nCoverage remained the same at 100.0% when pulling ec2175b17bd1f2ecdb479c66fab8a01666d6da3a on pr/origin/117 into fff5037950f78b4164c299560f761bd5e3dc9e06 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 8b2ec0daa2773e2a674da88211d712ed54a73cc2 on killmenot:overridable into cce2de832c99e1f1491c9766bc6a2f1b4d0a3bd2 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling e5ce1ab76853a367e1af36215dcf9b10db521d1f on JvJefke:bugfix/babel-plugin-resolve into cce2de832c99e1f1491c9766bc6a2f1b4d0a3bd2 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling e5ce1ab76853a367e1af36215dcf9b10db521d1f on JvJefke:bugfix/babel-plugin-resolve into cce2de832c99e1f1491c9766bc6a2f1b4d0a3bd2 on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling 61fa5ec8661c1bcaa92efcc651a411211d90ec69 on JvJefke:bugfix/class-constructor into 2f6d7af3b57aaa55655019054365cc241fd9881a on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling 61fa5ec8661c1bcaa92efcc651a411211d90ec69 on JvJefke:bugfix/class-constructor into 2f6d7af3b57aaa55655019054365cc241fd9881a on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling 333bd1a0c6e64776a3e7a98ab218b0d95f996498 on JvJefke:bugfix/class-constructor into 2f6d7af3b57aaa55655019054365cc241fd9881a on jhnns:master.\n. \n\nCoverage decreased (-2.5%) to 97.458% when pulling 1250667cb3f2adeb8546ef3088d8d053ad26d456 on odedniv:coffeescript-package into 18c5d0e09ef0f6cf666d664fbbf74435e190f23c on jhnns:master.\n. \n\nCoverage remained the same at 100.0% when pulling 122689eac737b9d20a39314990647780e726765f on 2Pacalypse-:master into 18c5d0e09ef0f6cf666d664fbbf74435e190f23c on jhnns:master.\n. \n\nCoverage decreased (-2.4%) to 97.619% when pulling d124260bf69269a8903f84449bf60da2ea69bd9d on pr/origin/127 into e9437cc4fc137e3024163c59349866d1f30235ac on master.\n. \n\nCoverage decreased (-2.4%) to 97.619% when pulling 5bdc9c636e7b37939c39cf0f985f28cdefd94bcf on pr/origin/127 into e9437cc4fc137e3024163c59349866d1f30235ac on master.\n. \n\nCoverage remained the same at 97.619% when pulling 09529c8b77450b52e221f69274d353859075345c on odedniv:move-eslint-to-devdep into 6ffd4d1405c9f812f7bcd3b915f4da262afec754 on jhnns:master.\n. \n\nCoverage remained the same at 97.619% when pulling 460dfd1eb65cff2935fae460a6c71b0171b226c7 on fix/const-regex into 6ffd4d1405c9f812f7bcd3b915f4da262afec754 on master.\n. \n\nCoverage remained the same at 97.619% when pulling 460dfd1eb65cff2935fae460a6c71b0171b226c7 on fix/const-regex into 6ffd4d1405c9f812f7bcd3b915f4da262afec754 on master.\n. \n\nCoverage decreased (-0.6%) to 96.97% when pulling a7b7c384d92a9f766f9a58b87d41ccdebcff030c on brokentone:bugfix/error-if-requiring-wrong-file into c059ffc12be986fc02ae94bb9bc6475fd48fa5b2 on jhnns:master.\n. \n\nCoverage remained the same at 97.619% when pulling c9b6f8d930b18f35e19f703730ef0a8c2638d12e on emilgoldsmith:patch-1 into c059ffc12be986fc02ae94bb9bc6475fd48fa5b2 on jhnns:master.\n. \n\nCoverage remained the same at 97.619% when pulling dc5210836dbdc32cde5dc0ce560d6e5282261060 on dougmoscrop:master into 5bea3d816d0258e5204f1b49b08b9fb302ac53e1 on jhnns:master.\n. ",
    "eicca": "Just encountered the same need. Would be nice to have something like this.\nPerhaps, some function which will take a callback for modified value and at the end of the callback reset the set variable to its original value. In this case, we can always be certain that the modified variable is always reset.\n. @jhnns I meant something like this:\nsomeModule.__set__(\"myValue\", 4, function() {\n  // here myValue will be modified\n});\n// here myValue wiil be resetted to the previous value\nThe benefit of this approach, that you don't need to explicitly call undo().\nBut also I think that undo() functionality could be useful in some cases when you can't do everything in a callback. For example when you want to run several tests with override and then switch it back to the original implementation.\n. @jhnns yes, your suggestion with currying and another function name looks definitely nicer. At least, I don't see any better options.\n. @jhnns, @bobpace thanks! I'll try it.\n. ",
    "bobpace": "Happy to help :D Thanks for making rewire available it's been working out really well.\n. Hmm, definitely seems to be a more complicated task to track the lifetime of sets across the rewired module. However since the current behavior of rewire is such that every call of rewire() executes the module again and returns a fresh instance I'm thinking maybe the easiest way to achieve a full revert is just to rewire the module again.\n. Ut oh, looks like it's not happy with package.json dependencies that are specified like \"^1.7.1\". I thought I could just adjust mine but the coffee-react source does it inside theirs as well.\n. Cool thanks for looking them over, I'm happy to make any changes you want (that package.json whitespace edit was unintentional looks like doing a npm install cofee-react --save-dev rewrote it with 2 spaces instead of 4)\n. Ah, if that is the case then I agree this should stay out of rewire altogether. I had not read over the previous issues thoroughly (probably should have) and so as soon as I saw the spot in the source that enabled the .coffee extension it seemed like the way to get support for others. I'll take your advice and move that piece to my project setup. :)\n. ",
    "yamsellem": "This issue is relative to blanket issue #192\n. ",
    "Fishrock123": "Running into this same issue, not using blanket..\n. ",
    "Trott": "Fix for #33\n. ",
    "phishy": "I made a PR here, but weirdly, the try/catch block doesn't work in mocha so the test doesn't pass, but works find in my code. I don't get it.\nhttps://github.com/phishy/rewire/commit/9a459d1e0242cf40368f0b9c51176b58c63658bb\n. In MVC frameworks like Sails.js, global variables exist inside modules that are not defined in that module. I would like to be able to rewire those, however, rewire didn't allow injecting variables that weren't defined with var. This PR allows you to introduce new variables into a module that weren't defined with var in that module. Something like this: https://gist.github.com/phishy/e135bdddeaf176bd5a71\n. My change is still working locally, however, I believe Johannes fixed it\nwith a commit as well. Make sure you're on the right branch and you should\nbe good to go.\nOn Fri, Jan 2, 2015 at 2:10 AM, cdnadmin notifications@github.com wrote:\n\n@phishy https://github.com/phishy did this ever work for you? I'm\nhaving a similar issue with an AWS Lambda function. \"context\" is defined in\nthe aws env, so, my rewired tests are not working due to \"context is not\ndefined\" error.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-68511610.\n. @jhnns I'm sorry. I'm just now realizing that you added a test case but never added a fix like the one I had on my pull request. I'm just now realizing as I recloned my project and lost my changes to rewire.\n\nLet me try to explain further. Using the Sails.js framework, all Models and Services are automatically added to global scope. Therefore when I require a file in order to test it, there are variables being used in that file that were never defined within it (with or without var). This is why I created the pull request that allows overwriting variables that are attached to global.\nI understand that I'm requesting a feature in rewrite to overcome deficiencies in poorly designed frameworks, however, I don't know enough about rewire to understand if adding this feature would have side effects. Otherwise, it would allow mocking and testing object in Sails.js and frameworks like it that hang some objects onto global.\nhttps://github.com/phishy/rewire/commit/9a459d1e0242cf40368f0b9c51176b58c63658bb\n. When I am mocking the model, none of the variables that would be set by\nSails are there, hence undefined. Rewire fails to set them as well even if\nI call set.\nOn Feb 9, 2015 6:18 PM, \"Johannes Ewald\" notifications@github.com wrote:\n\nSorry, but wrapping eval() with try/catch is not a valid option. The\nmethod call should fail if the variable is not defined.\nIf the variable has been added by Sails.js to the global scope before\nyou call set, everything should work fine. When there is no global\nvariable yet, rewire will throw a ReferenceError which is the desired\nbehavior.\nCould you describe your actual problem? Is there an error? Does mocking\nnot work?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-73612353.\n. No problem. It's really just about testing files and mocking any globals\nthat would be injected by requiring another file, or being required by\nanother file.\n\nHere is a demo.\nhttps://ide.c9.io/phishy/sails\nWhen running the Mocha test, you can see that it fails to overwrite the\nStory variable, because it is not available outside of context when not\nloading up the framework. In this case I am only trying to mock out all of\nthe external dependencies.\nOn Tue, Feb 10, 2015 at 9:24 AM, Johannes Ewald notifications@github.com\nwrote:\n\nCould you set up a tiny example project where the problem exists? It's\nhard to tell the issue when I don't know enough about Sails.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-73706876.\n. I'm already successfully mocking everything and its working great. I guess\nI'll just use my fork. Thanks for your help. It seems within reason to me,\nthat rewire should be able to inject undefined variables.\nOn Feb 10, 2015 7:45 PM, \"Johannes Ewald\" notifications@github.com wrote:\nYou need to initialize Sails at least to test your modules. Rewire can't\nmock anything when it is not defined.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-73815820.\n. Its incredibly expensive to load Sails, hence the mocking, plus it's\ncleaner, IMO.\nOn Feb 10, 2015 7:45 PM, \"Johannes Ewald\" notifications@github.com wrote:\nYou need to initialize Sails at least to test your modules. Rewire can't\nmock anything when it is not defined.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-73815820.\n. It solves my problem by allowing me to inject global variables into the\nscript. I know, it's a stupid argument, but some of the major frameworks\noperate this way, and there's no reason to load the framework, and test it\nwhen I\"m writing userland code.\n\nIt solves the problem, because the patch actually allows writing a global\nvariable to succeed instead of throwing an exception.\nOn Wed, Feb 11, 2015 at 8:47 AM, Johannes Ewald notifications@github.com\nwrote:\n\nHow does your fork solve your problem? You're just wrapping the eval()\nwith try/catch...\nYou just need to define the variables to mock on the global object and\neverything works fine. From the rewire point of view it doesn't make sense\nto mock global variables with rewire.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-73882907.\n. Let me correct myself. It doesn't allow me to add variables onto global.*,\nit allows me to set any variable within the head of the script (ones not\nexplicitly defined with var). I will try to boil up another test case that\nmakes more sense, as it seems it is hard to explain how this change is\ncurrently working for me.\n\nOn Wed, Feb 11, 2015 at 10:51 AM, Johannes Ewald notifications@github.com\nwrote:\n\nSorry, that is just not true. The eval() throws an exception and the\nerror is ignored, no variable is set on the global scope. Your provided\ntest-case is checking for the wrong value, moduleFake.getValue() returns\nmyValue, not undefinedValue.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-73904327.\n. Here is a test case for wanting to be able to set undefined variables. https://gist.github.com/phishy/cb06c276a332b01ec149\n. Thanks.\n\nOn Mon, Feb 16, 2015 at 7:16 PM, Johannes Ewald notifications@github.com\nwrote:\n\nI'm so sorry. I just didn't get what you were trying to say [image:\n:grin:]\nShould be solved with 2.3.0\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/jhnns/rewire/issues/35#issuecomment-74595056.\n. This is directly related to: https://github.com/jhnns/rewire/issues/35\n\nHere is a test case: https://gist.github.com/phishy/cb06c276a332b01ec149\nIt seems @Zolmeister wishes to test Sails.js also ;-) A fix for this is crucial to doing so when when using globally injected variables in Sails.\n. ",
    "mathieumg": "I'm pretty sure I have a use case for this too, thanks!\n. ",
    "Zolmeister": "I tried that first. Problem is that that's invalid too.\njs\n// Syntax Error\nvar a-b = ...\n. bump\n. ",
    "mghaderyan": "I see. Thanks for that\n. ",
    "willmorgan": "@jhnns I think the Babel upgrade to allow const has made this an issue again, as I'm seeing this in the newest version.. @jhnns I've had a quick look, and it doesn't look like there's anything in the docs to suggest it does \ud83d\ude1e . @jhnns Just read the changelog - great work. I see that this is quite a nuanced issue. I'll upgrade rewire on our end and see if it plays nice with istanbul.. @jhnns Update: this looks way better. I think we can close it. Thanks again! \ud83c\udf89 . ",
    "JvJefke": "@jhnns It might be worth to look into something like this: https://github.com/istanbuljs/babel-plugin-istanbul. I'll check it out when I have time but it will not be for the this week.. Rewire will always return a new instance of the module. See the Caveats section in the readme.. This is not supported by rewire. See the limitations section in the readme.\nI don't think it is possible to overcome this limitation.. The tests are failing because of the fact that older node versions don't support ES6 syntax. Is there a way to only run these added tests in node 6.x versions?. @jhnns Could you give some input here? thx!. You're right about the option. Hadn't thought about that. I'll remove the option when I have time.. @jhnns I removed the options. It will now always use babel to convert const to let. I had to keep the old functionality though for .coffee scripts. Babel isn't able to convert it properly. I'll try to add the functionality for coffee scripts in the future.. Could you give the exact error?. I cannot reproduce this error. Would you be willing to give some example code where you experience this error? You're node version could also help :). Thanks for the example!\nI didn't have the time yet to look into this. I'll try to do it this evening.. I still can't reproduce this error. I added a test with your example, but it doesn't fail in node 8.9.1 on my computer.\nsee: https://github.com/JvJefke/rewire/commit/35d43982c8f11717761562fcc29b087b2dbd89f9. I also ran it from command line using plain node and it still worked.\nRewire uses babel internally to convert constants (const) to variables (var), but the tests itself aren't babelized.\nCould you perhaps pull the bugfix/class-constructor branch from my fork (https://github.com/JvJefke/rewire/tree/bugfix/class-constructor) and run npm test to see if it issue is environment related or not?. I opened a PR to fix this: https://github.com/jhnns/rewire/pull/123.\nThanks a lot for reporting this and helping us look for a solution!. Babel was introduced into 3.0.0 to enable mocking of const variables. Could you give example code so I can reproduce this error?. Thx! I opened a PR that should fix this. see #122.. No this will not be mocked. The only thing rewire does (at the moment), is giving you the opportunity to reassign global variables (var, let, const) of the module itself. It is also important to note that  the original fs will be loaded initially. You can replace the result of the require with a mock object using rewire __set__ or __with__. So if the required module (eg. fs) does something on initiating, this will still be executed. If this is an issue, you'll need something like proxyquire to prevent this.. Rewire still runs the file on require (like require). This means that the cli function executes twice. Once on initialisation (with process.argv parameters) and once from your test script. Are you sure, you tested the second execution?. I personally prefer to use fixed or ~. A package should not contain breaking changes on minor updates but it often does. I find it more secure to make it fixed or set it to patch updates. Let me know if I still need to change is :).. ",
    "rodrigoreis22": "I'm using jest 23.4.1 for a node.js (v 8.10) project and after using rewire my code coverage report doesn't work anymore. Any ideas? I'm not sure jest uses istanbul..\ni'm using rewire 4.0.1. ",
    "shengbolou": "using create-react-app with rewire v4.0.1, the code coverage report is not able to recognize rewired modules.\nAppreciate any help!. ",
    "ColCh": "Any ideas how revert is now working?\nHm, wrote small workaroud for a while:\n``` js\nvar rewireReplace = function (module, replaces) {\n  var reverts = {};\nObject.keys(replaces).forEach(function (key) {\n    reverts[key] = module.get(key);\n    module.set(key, replaces[key]);\n  });\nreturn function revert () {\n    Object.keys(reverts).forEach(function (key) {\n      module.set(key, reverts[key]);\n    });\n  };\n};\n```\nUsage:\n``` js\n      var revertRewire;\n  before(function () {\n    revertRewire = rewireReplace(modelsActions, {\n      'Product.findAll': fakeFindAll\n    });\n  });\n\n  after(function () {\n    revertRewire();\n  });\n\n```\n. Thanks.\nPartially :)\nWorks:\n``` js\n      var revertRewire;\n  before(function () {\n    revertRewire = modelsActions.__set__('Product.findAll', fakeFindAll);\n  });\n\n  after(function () {\n    revertRewire();\n  });\n\n```\nAlso this way it works too (I think it's a nice way to inject mocks):\n``` js\n      var revertRewire;\n  before(function () {\n    revertRewire = modelsActions.__set__({\n      Product: {\n        findAll: fakeFindAll\n      }\n    });\n  });\n\n  after(function () {\n    revertRewire();\n  });\n\n```\nAnd this - nope:\n``` js\n      var revertRewire;\n  before(function () {\n    revertRewire = modelsActions.__set__({\n      'Product.findAll': fakeFindAll\n    });\n  });\n\n  after(function () {\n    revertRewire();\n  });\n\n```\nSo, I really like this way\njs\n        revertRewire = modelsActions.__set__({\n          Product: {\n            findAll: fakeFindAll\n          }\n. Thank you! :+1: \n. ",
    "ameykpatil": "@basdag How did you solve it? How do you mock constructors & protoypes using rewire?  Any reference or link would be appreciated. \n. ",
    "kwakayama": "Hey @jhnns.\nThanks for your answer.\nMy problem is that I want to stub/modify the fs.existsSync before the index.js file is parsed.\nI tried to stub before rewiring the index.js file, however then it throws the error (see above).\nDo you have a solution for this scenario?\nbest,\nkentaro\n. ",
    "bendrucker": "You can use https://github.com/thlorenz/proxyquire for this\n. This is exactly what proxyquire does. Only require manipulation to help isolate tests, no eval:\nhttps://github.com/thlorenz/proxyquire\n. ",
    "jackofseattle": "I can't repro this in a normal scenario - I do get it when I try to run the files in Jest. My guess is that Jest is using it's own module system which doesn't have a cache object.\nI have a fix that seems to work for that environment - it's a simple check to see if require.cache exists before trying to delete from it.\n. ",
    "mattdell": "Yeah, this is when I'm trying to use it within Jest.\n@jackofseattle, can you give me a code example of your fix?\n. ",
    "emmenko": "@jhnns thx for the answer. I usually use static dependencies, just for this case I need it for some test utils where I can have the same setup for many modules (so I wanted to extrapolate the logic into a test util, hence the need for dynamic paths).\nI found a workaround anyway, just wanted to clarify that behavior first :)\n. Yeah, sorry I forgot to close the issue :)\n. ",
    "lebolo": "Sorry,I fixed my example, TaskImporter was the actual name of my method before I turned it into an example ;)\nIsn't doSomething just an internal variable of the FooTask module? Why does doSomething change before db.getStuff but not within the callback of db.getStuff? Can I refactor my code somehow to allow doSomething to be changed in all scopes?\nEither way, thank you for a great tool!\n. I figured out the problem - and by dumbing down the example, I removed a very important aspect. My _run method returns a promise. And the actual expect (not the one above) is testing that the promise is rejected in a certain way. So I forgot to add return returnVal; (which is a promise) after expect(returnVal).toBe(0);.\nSorry, my fault! In short: if you're testing an async method, you have to return that promise for rewire's undo to take effect at the right time.\n. ",
    "jacobp100": "js\n<module.js>\nreturn {\n    a: require('a'),\n    b: require('b')\n}\njs\n<index.js>\nvar f = rewire('./module', { skipModules: ['./a'] });\nvar g = rewire('./module', { skipModules: ['./a'] });\nf !== g\nf.a === g.a\nf.b !== g.b\n. ",
    "IanVS": "All it is doing is checking for a shim and then calling the object's normal defineProperty function.\n253  function defineProperty(object, name, descriptor) {\n254        if (isShimSymbol(name)) {\n255          name = name[symbolInternalProperty];\n256        }\n257        $defineProperty(object, name, descriptor);\n258        return object;\n259      }\nI'm not sure why this would be a problem in Treaeur, because everything works fine as long as I don't use rewire.  Is there anything else I can do to try to help troubleshoot?\n. Alright, I'll try to put something together in the next few days.\n. OK, it seems that this occurs if the module being rewired exports a string or a variable with a string value.  Is that not a supported use of rewire?\n. ",
    "ssshah5": "Hey Johannes,\nThanks for the quick response and sorry for confusing you with extensive yet insufficient information. I will try my best to illustrate the problem here with some snippets from different files. \nI am trying to test 2 different functions, with the same name, which are located in 2 different files. The functions in both the files are as below:\nFile 1: home/routes/folder1/index.js\nfunction getDocument(var1, var2, next) {\n    var dbName = conf.get(\"name\");\n    var db = con.getCon(dbName);\n    db.get(req.params.id, function (err, doc) {\n       doSomething;\n    });\n}\nFile 2: home/routes/folder2/index.js\ngetDocument = function(var1, var2, next) {\n    var callback = function(err,var2) {\n            doSomething;\n     }\n    db.get(var, callback);\n};\nFollowing is the configuration in my  /home/tests/test1.js to test the function in home/routes/folder1/index.js\n```\nvar rewire = require(\"rewire\"),\nrouter = rewire('home/routes/folder1/index.js'),\naccess= {};\naccess.getDocument = router.get(\"getDocument\");\n//testcase\nit('testing1', function (done) {\n         var mock_db = {\n               \"get\": function(var1,callback){\n                }\n          };\n        var mock_db = {.........};\n        var mock_con = {........};\n       revert = router.set({db:mock_db, conf:mock_conf, con:mock_con}) ;\n       access.getDocument(var1,var2,next) ;\n});\n```\nSimilarly, is the configuration in my /home/tests/test2.js to test the function in home/routes/folder2/index.js\n```\nvar rewire = require(\"rewire\"),\nrouter = rewire('home/routes/folder2/index.js'),\naccess= {};\naccess.getDocument = router.get(\"getDocument\");\n//testcase\nit('testing2', function (done) {\n         var mock_db = {\n               \"get\": function(var1,callback){\n                        callback(false,var);\n                }\n          };\n       revert = router.set({db:mock_db}) ;\n       access.getDocument(var1,var2,next) ;\n});\n```\nProblem:\nWhen I launch the tests using \"grunt test\", the testcases in test2.js seems to run first and corresponding testcase for getDocument passes successfully.\nHowever, when it reaches testcases in test1.js, the corresponding getDocument fails since its still pointing to getDocument defined in /folder1/index.js ((I can tell this from the error stack) rather than pointing to /folder2/index.js even though the var router in test2.js is rewired to /folder2/index.js.\nAll works fine if I name the functions differently but its desirable to keep the names same. I hope this clarifies the problem a bit better. \nI would appreciate any input/suggestions. I am still new to this so apologize if I missed any other essential detail.\n. Finally got the source of problem. \nIn the folder1/index.js, I changed the getDocument to a function expression and voila!\nfunction getDocument(var1, var2, next)\nchanged to \nvar getDocument = function (var1, var2, next)\nNot exactly sure why function expression worked as opposed to function declaration.\n. ",
    "jgrund": "This is sorely missed from this module. If we had this, we would not need to alter code structure to fit the tests.\n. ",
    "srph": "Having the same issue as well.\n. ",
    "mikeyamadeo": "+1\nUsing Babel for transpiling.\n. ",
    "damassi": "This is super disappointing as Rewire is the most useful library ever!  It might be worthwhile to start a discussion with the Babel folks.  \nI'll go ahead and close.\n. ",
    "doctyper": "Hm, then we may have a problem. Babel says it's not their issue: babel/babel#1337\n. ",
    "JustinTulloss": "For what it's worth, @speedskater has written an alternative that works with Babel's ES6 module compilation. https://github.com/speedskater/babel-plugin-rewire\n. ",
    "d4nyll": "Note that babel-plugin-rewire does not currently work with Babel 7. See Babel 7 Support? #209 for more details.. ",
    "MitMaro": "I noticed the issue I had linked was the incorrect one. It's been fixed.\n. Little mistake in the command, should be mocha index.js not mocha test.js.\nThe node version case it is useful:\nnode --version\nv0.10.38\nIf I get a chance this week I will try to debug the issue.\n. Did a quick look and it is because of the function name. global.run is a global that seems to be added by mocha but is undefined.\nThe getImportGlobalSrc.js file adds var run = global.run; which would hide the function run() {} in my test case.\nI don't know if there is a way to alert the user of this, or perhaps it can just be documented - if it's not already.\nedit: Added info on source of run global\n. After looking into the source a little more I can't see a way to warn a user if a local variable is being overwritten by a injected global without using some sort of JavaScript parser.\n. ",
    "Macil": "Oh this normally doesn't work. If you try to override a global (rather than a top-level variable) in a module, then a global is created that's visible outside of the rewired module. I don't think that seems useful in general. Maybe rewire should use strict mode inside its own function so that this always fails?\n. I was going to use it in Node to help test files that are intended to be used in browsers. I have a lot of tests right now where I set globals (like global.document to a jsdom object) before loading the files, but I run into issues occasionally when I want to set different globals to different modules I'm testing. Though now that I think about it, I can't really imagine how that would work (are the rewired globals viewable to other modules that they require? What if two rewired modules require each other? If every call to rewire came with a fresh new require.cache it could work right, but I don't think rewire does that. Maybe it's something good for a different project).\n. ",
    "cazgp": "OK so trawling through old issues seems to have helped.\nrequire.cache[require.resolve './validate'] = exports: validate\nAny chance you could add this to the docs for future users?\n. ",
    "mikaturunen": ":+1: for being honest and saying it's not motivating. \nYou ok with the idea that someone else does it and sends you a PR about it?\n. ",
    "jabhishek": "Is anybody working on this?\n. ",
    "GreenGremlin": "It looks like somebody did: https://github.com/speedskater/babel-plugin-rewire\n. ",
    "trodrigues": "Just landed here after headbutting my code for a while and then looking for information on this. Wondering if it would be a good idea to have a paragraph about this in the readme to avoid people trying to do this with rewire in the first place. I can submit a PR :)\n. Right. But I think the main issue here is not ES6 modules in themselves but transpiled ES6 modules. I think that's always going to be a case specific to babel users.\n. ",
    "adjavaherian": "I think I might be having a similar issue.  \nTypeError: Filename must be a string\n      at internalRewire (node_modules/rewire/lib/rewire.js:19:15)\n      at rewire (node_modules/rewire/lib/index.js:11:12)\nThis seems to happen only when I webpack my test files and their es6 deps and run them in mocha / node.  I don't see any issues when I run the same tests thru my karma config and run them in the browser.  The funny thing is that the webpack config should be about the same for both karma and mocha.  I'll check for differences, but any suggestions would be greatly appreciated.\nThanks!\n. ",
    "jamlen": "Just FYI, my approach to 'fix' this is:\njs\nimport _config from '../config';\nlet config = _config;\nThen rewire as normal:\njs\nconst thing = rewire('./path/to/thing');\nthing.__set__('config', testConfig);\nIt's a little dirty as I don't like changing production code for test purposes. I normally add a comment like // This is to allow rewire its hooks\n. @pilphil the rewire('./path/to/thing') is just the path to the class under test.\nSo if you have:\n.\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 thing.js\n\u2514\u2500\u2500 test\n    \u2514\u2500\u2500 test-thing.js\nand you are writing the test file ./test/test-thing.js, then this would be rewire('../lib/thing'). @robrtmain you could check out this answer of mine if stackoverflow...\nhttps://stackoverflow.com/a/30730818/2140627. @robertmain I have some examples somewhere... let me dig them out :) it does work (although I wasn't using TypeScript). My class looks like this:\n```js\nimport { EventEmitter } from 'events';\nimport _logger from './logger';\nimport { stock as mappers } from './mappers';\nimport { stock as _StockStore} from './stores';\nlet StockStore = _StockStore;\nlet logger = _logger;\nlet store, _debug;\n/* StockMigrator /\nmodule.exports = class StockMigrator extends EventEmitter {\n/** Create a StockMigrator. */\nconstructor () {\n    super();\n    store = new StockStore();\n    store.on('write_data', (type, key, duration) => {\n        this.emit('progress', 'write', key, duration);\n    });\n}\n\n// other methods here...\n}\n```\nMy tests look like this:\n```js\nimport rewire from 'rewire';\nimport deride from 'deride';\nconst Migrator = rewire('../../../src/stockMigrator');\nimport { stock as mappers } from '../../../src//mappers';\nimport data from '../../data/stock';\nimport config from '../../config';\ndescribe('Unit tests', () => {\n    describe('Stock Migration', () => {\n        let migrator, store;\n    describe('stockMigrator', () => {\n        before(() => {\n            store = deride.stub([ 'writeDocuments' ]);\n            store.setup.writeDocuments.toDoThis(() => {\n                store.emit('status', 'write_data', 'doc123');\n                return Promise.resolve();\n            });\n            Migrator.__set__({\n                StockStore: () => store,\n                logger: deride.stub(['debug', 'info', 'warn', 'error', 'audit'])\n            });\n            migrator = new Migrator();\n        });\n\n// describes here...\n``. @robertmain Yes, but with the caveat that you need to add alet` to allow rewire to be able to substitute the mock.. @robertmain at a guess I'd say this is a TS specific issue and probably raise a new issue for it.. ",
    "mdunisch": "@jamlen Thank you - that really solves my problem for now!. ",
    "gregorydrake": "@jamlen Good solution!!\nMy assumption is that import modules in ES6 are frozen - thus Rewire can't dynamically modify what's being imported - hence why your solution, @jamlen, works?. ",
    "pilphil": "@jamlen - pardon my ignorance, but  is the rewire('./path/to/thing') the workaround for rewire('../config')?. ",
    "robertmain": "Is this the right place/issue to ask about support for mocking out calls to imported dependencies like fs etc.?. @jamlen that's fine but it looks like you're using require(), rather than import which is what I was asking :)\nI know it works with require - what I was trying to figure out was if I could use it with import in TypeScript. @jamlen so you got rewire to work with import then?. ah!. @jamlen The problem I'm running up against at the moment with this in TypeScript is that it seems I have to load the thing I'm testing with rewire....which doesn't return the correct kind of object (it has no constructor) and then the ts language server gets upset.. ",
    "essekia": "@tormozz48 I have the same issue. Can you tell me how you resolved this?\n. ",
    "sfescape": "This is unfortunate, I'm feeling compelled to use jest exactly for this feature. I'm glad to see from #73 that you're revisiting this decision.\n. ",
    "thlorenz": "For intercepting require you may want to have a look at proxyquire which does exactly (and only) that.\nFor all other overrides you can then still use rewire.\nJest would work as well afaik but is a much larger package.\n. ",
    "jhorneman": "(FWIW I've opened the same issue here: https://github.com/i-like-robots/rewireify/issues/11, and a workaround was found. There's likely still a real bug somewhere though.)\n. Thank you!\n. ",
    "amay": "Fair enough. I'll close this.\n. ",
    "markelog": "Alrighty \n. ",
    "abou7mied": "Is there any updates regarding that issue?\nI need to get a variable but I don't know its accurate name, so It would be good if there is an ability to get all variables then I could use regex to find it from the returned list.. ",
    "timph": "Hi Johannes,\nI forgot to follow up. No, it's not an issue. It's a Capitalized LimitModel.js (wrong) vs limitModel.js (right). It's working fine with capitalized filename in Mac, but won't work for Jenkins env - linux. That is all. Sorry for the trouble :)\n. ",
    "coaxial": "On the other hand, the following doesn't seem to be as bad as the README depicts it:\n``` javascript\nvar consoleMock = {\n  log: function() { }\n};\nApp.set('console.log', consoleMock.log);\nconsole.log('not overriden');\n```\nThe console.log in App will be using the mocked version while console.dir will still behave normally. Within the test, console.log isn't mocked and still behaves as normal.\nI'm not sure if I'm missing the point or if doing it this way used to override console.log outside of App but it's the only way I can get rewire to not break anything that isn't mocked on an object.\n. Are you saying there is a difference between this:\njavascript\nModule.__set__('console.log', function() { });\nand that:\njavascript\nvar consoleMock = {\n  log: function() { }\n};\nModule.__set__('console.log', consoleMock.log);\nMaybe I'm tired but my understanding from the README is that setting console.log to whatever function will override the global console object and so your console.log will be changed not only within Module but also everywhere else console.log is used. But from the examples above, it doesn't seem to be the case. What gives?\n. ",
    "brennon": "It does work if you use dot notation, though.\nBased on the inordinate amount of time I spent trying to write a pull request to fix this, I'm convinced this is the intended behavior. It is, however, completely counterintuitive, as long as this difference between passing an object and a string in dot notation is not called out clearly in the docs.\n. No, my post is in response to your first post (the one to which the title of the issue seems to refer).\n. ",
    "machineghost": "The README could be improved to clarify this (and prevent future issues like the four existing ones of this nature).\nRight now you have an example, myModule.__set__(\"fs\", fsMock);, where it looks like you're passing in a \"path to a module\" (ie. \"fs\").  Adding even a simple second example of rewiring a local import (ie. something starting with ../ or ./) would most likely alleviate this.. ",
    "TheSavior": "Closing in favor of the PR\n. @jhnns Can this get some love?\n. > It becomes a problem because people started to re-implement rewire() for other environments only to some extent.\n@jhnns From your comments it seems like there is some misunderstanding between how all of our different rewire based packages work.\nYour modules rewire and rewire-weback have the same use case. You can call rewire instead of require and then have access to the rewire methods.\nrewireify, rewire-global, and babel-plugin-rewire have a slightly different usage pattern. Instead of explicitly calling rewire to add those methods, these modules add the functions to every module that is required via the standard require function. One reason to do this is to use the rewire functionality with proxyquire which also requires the user to use a different function than require. There are many other reasons as well.\nSo I think all of the module authors want us to all have the same API once rewire is enabled for a module, but we have different requirements for how rewire is injected into a module. In order for our modules to all be closer to rewire core, rewire-core needs to support both function injection patterns. I'm open to suggestions as to how you propose we get there.\n. @jhnns, I too am unhappy that rewire, rewireify, rewire-global, and babel-plugin-rewire are all slightly different. That is part of why I've been starting the discussions about how to make them all have the same api. This PR is a requirement that is blocking rewireify and rewire-global from using the same modules as rewire and thus having more shared functionality. \nI think we want the same things here.\n. We use both libraries by using rewire-global for node, and rewireify for the browser.\n. This PR makes all of my tests pass for rewire-global while reusing getImportGlobalsSrc and getDefinePropertySrc.\n. @jhnns I rebased this from master. What are your thoughts on this? I'd like to be able to make these modules share more and have a consistent API.\n. @jhnns Bump.\n. ```\n$ nvm use 0.12\nNow using node v0.12.7\n$ node\n\nObject.isExtensible(null)\nTypeError: Object.isExtensible called on non-object\n    at Function.isExtensible (native)\n    at repl:1:8\n    at REPLServer.defaultEval (repl.js:132:27)\n    at bound (domain.js:254:14)\n    at REPLServer.runBound [as eval] (domain.js:267:12)\n    at REPLServer. (repl.js:279:12)\n    at REPLServer.emit (events.js:107:17)\n    at REPLServer.Interface._onLine (readline.js:214:10)\n    at REPLServer.Interface._line (readline.js:553:8)\n    at REPLServer.Interface._ttyWrite (readline.js:830:14)\n(^C again to quit)\n$ nvm use node\nNow using node v5.0.0\n$ node\nObject.isExtensible(null)\nfalse\n```\n. Good catch. Added a test case for null.\n. Heh, wow. I'm amazed that I still had that file sitting on my disk.\n. \n",
    "boneskull": ":+1:\n. without this, rewire fails when running code with wallaby.js\ncc @ArtemGovorov\n. @jhnns regardless, rewire fails to work when run under wallaby due to this problem.  \n@ArtemGovorov could probably provided more accurate information if asked, but I think what's happening is:\n1. The user changes a test suite.\n2. The test suite is reloaded (rerun).\n3. The rewired module does not get reloaded (this partially accounts for the speed with which wallaby reruns tests).\n4. Result:  The rewired module has already been patched by rewire, and cannot be patched again due to writable's default of false.\nUnless it can be shown that setting writable to true actually causes a problem, this sounds a bit like FUD.\nIn case you disagree on philosophical grounds, I'm of the opinion that the responsibility of a JS library ends once it has done what it was intended to do.  It is not necessary for any library to prevent a consumer from augmenting its functionality thereafter, except in rare circumstances.  Perhaps this is especially so for rewire, which is intended to be run in test and augments its consumers' module(s)?  If JS didn't allow this behavior by nature, rewire probably wouldn't even exist.\n(FWIW, babel-plugin-rewire accepted a PR of mine to address this very issue.)\n. @ArtemGovorov I don't have one handy, but I can provide an example if it crops up again\n. ",
    "ArtemGovorov": "@boneskull You've described it pretty accurately for babel-plugin-rewire. However, I don't remember anyone reporting issues with using rewire itself in wallaby.js. If it does fail, then it's probably for the same reason. If there's some sample I could run to reproduce the issue with rewire itself, I could provide a detailed overview of what is happening.\n. ",
    "brenolf": "+1 for this. My workaround was using let instead of const to enable it to rewire.\n. I'm closing this issue because it no longer affects me. If this shows up again I can open another one.\n. ",
    "erbridge": "Yes, that works, and is my current workaround, but I really don't want to have to open the code up to bugs in order to test it...\n. ",
    "dcrockwell": "+1 for ES6 consts. Thanks to @brenolf for the workaround.\n. ",
    "alexweber": "@erbridge @brenolf dcrockwell @dcrockwell For what it's worth, proxyquire seems to work fine using ES6 consts.  \nI've yet to write some more complex tests with it but initial results are encouraging.\n. ",
    "kaktus42": "I can't reproduce this issue.\nI can rewire const functions.\n. js\nvar r = rewire('./reducer');\nconst reduceAddAction = r.__get__('reduceAddAction');\nWhere reduceAddAction is a const function.\nBut maybe you were talking about overwriting?\n. ",
    "awinder": "Riffing on what @kaktus42 was saying though, you can take advantage of the way JS const works for evil and profit in the case when it's an object: \nvar r = rewire('./reducer');\nconst reduceAddAction = r.__get__('reduceAddAction');\nreduceAddAction.method.to.stub = sinon.stub();\nIn this case you're not reassigning the variable identifier, and you're changing a referenced value, so it is possible, whether or not it's a good idea or not is another thing entirely \ud83d\ude04 \n. ",
    "daithi-coombes": "+1 for allowing rewire of const's\n. ",
    "kimpellikaan": "+1 again! \n. ",
    "rewiregps": "you should check this out : https://mathiasbynens.be/notes/es6-const\n+1 for rewire\n. ",
    "ScionOfBytes": "+1 yet again!\n. ",
    "ioanlucut": "+1\n. ",
    "shivarajnaidu": "+1 for const and for full es6 support... \n. ",
    "tbranyen": "@rewiregps You link an article that very well articulates why this cannot work. The bindings are immutable. So this already works exactly how it should. You cannot override a const binding, which is what rewire does.\n. ",
    "jsrraman": "Well, in my case, I needed to stub a method from a private const of a module.  proxyquire supports this use case\nFor example\nmy-module.js\nconst http = require('http')\nmy-module-spec.js\n```\nconst proxyquire = require('proxyquire');\nconst myModule = proxyquire('./my-module', { 'http': httpStub });\nhttpStub.Server = app => {\n      return { key: 'value' };\n    };\n```. ",
    "goyney": "@jhnns 4.0.0 here, this does not work.\nmain.js\nconst { apiRoot, defaultPort } = require('config');\nmain.test.js\n```\nconst myModule = rewire('myModule');\nmyModule.set('defaultPort', 123);\n```\n\nTypeError: Assignment to constant variable.. \n",
    "Sufiane": "@jhnns I do have the same problem as @goyney :( \nI already have rewire 4.0.1\nThe only difference I have is that it's not from destructuring.\nDemo:\nindex.js:\nconst myPromisifiedFunction = promisify(someFunct.ToPromisify)\nindex.test.js:\nconst myModule = rewire('../myModule')\nconst myStub = sinon.stub()\nconst myStubbedFunction = myModule.__set__('myPromisifiedFunction', myStub)\nAnd what I get when running tests is:\nTypeError: Assignment to constant variable.\n      at eval (eval at __set__ (index.js:159:5), <anonymous>:1:19)\n      at Object.__set__ (index.js:159:5)\n      at Object.<anonymous> (test/index.test.js:14:48). Thanks @Shakakai  ! I was indeed writing tests with jest. @sinkersan not on my end. ",
    "pandomic": "As a possible \"dirty\" workaround, it's possible to __get__ the function you need to test (which you expect to call other funcs), convert it to string, eval and test it in the context of your test. It works for small functions, but I'm sure with larger ones it might be a bit painful.\n```\n// myfunc.js\nconst unmockable = (a) => Hello ${a};\nconst myLovelyFunc = (a) => unmockable(a);\nmodule.exports = { myLovelyFunc };\n// - - - - - - - - - - - - - - - somewhere in myfunc.test.js - - - - - - - - - - - - - - -\nconst myLovelyFunc = rewire('./myfunc.js').get('myLovelyFunc');\nconst subject = eval(myLovelyFunc.toString());\n// Redefining function's local context\nconst unmockable - jest.fn(Bye, ${a});\nsubject('Dude'); //=> Bye, Dude\nexpect(unmockable).toHaveBeenCalledWith('Dude');\n```. ",
    "moimikey": "a-ha... it's actually just certain globals :/... can't set LC_CTYPE or LC_LANGUAGES, but can set LANG. interesting. \n. closing! i ended up also realizing that this was caused by my own bug too :|.\n. ",
    "edsharp": "Thanks for your feedback. I'll take some time to think about what you've said. \nI certainly like that idea that well tested public methods should negate the need for private method testing. \nWhat I'm wrangling with is where I've got maybe three public methods that shared a lot of overlapping logic. In those cases, I abstracted the shared logic into a private method, but I wanted it truly private, so it's just a function rather than an instance method. \nHaving done that, I thought the most succinct way to test it was to test that the private function behaves as expected; and then test that the public methods call the private function in the way I'd expect them to.\nWith that being the case, I then found it useful to stub/spy the private functions. I do wonder if there's a better pattern altogether.\nFWIW since writing the original post, I've got quite a bit of mileage out of this approach. I've extracted the proxy wrapping of rewire into a module of its own. By using the proxy, sinon's sandboxing works because sinon uses defineProperty and the proxy then translates that into to appropriate __set__ calls.\nThe __with__ approach you outlined does indeed work, although I really like that with the proxy I can then use the same syntax regardless of whether I'm stubbing private functions or public instance methods: I just use sandbox.stub(__some_module, 'privateMethod'). Also, in my simple example I only stubbed a method in a single test. In my actual usage, I sometimes stub a privateMethod in the before or beforeEach calls which works with the proxy approach. I think it would take a few more lines of code to replicate using just __get__ and __set__ or __with__ and possibly require some balancing calls in after or afterEach. The sinon sandbox reliably restores everything with each top-level afterEach.\nFinally, I like the syntactic sugar of calling __some_module.privateConst vs some_module.__get__('privateConst'). I reckon the double underscore prefix is enough to indicate that I'm operating on the rewired version of the module, but the syntax is as if I'd exported privateConst by name on the module.exports. I happen to use symbols to keep my private instances properties semi-private (at least private enough that they don't pollute the public instance properties).\nIn the module, I define the symbols which means in the tests I end up doing myInstance[__some_module.privatePropertyXSymbol] to access those symbol properties. I reckon that's a best-of-both worlds approach: I get the semi-private neatness of using symbol properties; I can still access the symbol properties in tests; and with the syntactic sugar of the proxy approach, getting at the symbols isn't arduous :)\nAnyway, thanks for contributing rewire to the community. For fun, I think I'll publish the rewire proxy module I mentioned as well as some working examples. It is heavier in weight than just using __with__ within a single test, but then it also has some other advantages.\n. ",
    "r4j4h": "Ah, I just realized my mistake. I should not be trying to \"mock\" the require call, but the global variable the result is stored in.\njs\nvar stripTrailingSlash = require('../../lib/stripslashes.js').stripTrailingSlash;\nSo in this case I should just pass stripTrailingSlash.\nThank you and I apologize for this mistake. I am going to leave it here in case it helps someone else, but please free to close it if you would like.\n. ",
    "Eli-Goldberg": "@scaljeri My guess is you'll have to wrap it in another service / module and rewire that.\nMaybe someone else will have an idea. ",
    "sebastienbarre": "@nschurmann did you happen to find a solution? #79 mentions thlorenz/proxyquire or speedskater/babel-plugin-rewire...\n. ",
    "ParseThis": "this would still be amazing for those not using babel.. ",
    "luanmuniz": "It would indeed be great to have this without babel. I'm not using babel and this is indeed a problem!. ",
    "firebait": "yeah, this is problem as it works with require but not import. I think the issue is that import makes the imported object immutable. This is a big one.\n. ",
    "tschaub": "@jhnns - let me know if I can provide any more detail or do anything else to help get this merged.\n. ",
    "drjasonharrison": "can you provide a code sample?. ",
    "brocoli": "I can.\n```javascript\n'use strict';\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nconst lodash = require('lodash');\nconst sinon = require('sinon');\nconst sinonChai = require('sinon-chai');\ndescribe('DataControl', function() {\n    chai.use(chaiAsPromised);\n    chai.use(sinonChai);\n    chai.should();\n// Tested module\nlet dataControl;\n\n// `dataControl`'s dependencies\nlet common;\nlet database;\nlet logger;\n\nbeforeEach(function() {\n    // Mocked dependencies   // In `data-control.js`, they're declared like this:\n    common = sinon.stub();   // const common = require('common');\n    database = sinon.stub(); // const database = new common.DB();\n    logger = sinon.stub();   // const logger = new common.Logger();\n\n    // Tested module and its dependencies\n    dataControl = rewire('../../../../app/business/data-control', {\n        common,\n        database,\n        logger,\n    });\n});\n\ndescribe('someTestedFunction(foo, bar)', function() {\n    it('should do some stuff', function(done) {\n        // Teste function arguments\n        const foo = lodash.cloneDeep(fixtureFooGood);\n        const bar = lodash.cloneDeep(fixtureBarBad);\n\n        // Tested function\n        const result = someTestedFunction(foo, bar);\n\n        // Assertions\n        result.should.be.fulfilled.then(() => {\n            database.readStuff.should.have.been.calledWithExactly(foo);\n            logger.info.should.have.been.calledWithExactly(bar);\n        }).should.notify(done);\n    });\n});\n\n});\n```\nThe idea here is that if you just common = rewire('common') and then i.e.\ncommon.__set__('DB', sinon.stub()), then the common module had an opportunity to run undesired code before we apply the stub.\nSame thing with the database = new common.DB() call. We would like to prevent these lines of code to even be run, since they're not part of our unit test.\nPassing the stub definitions like this to rewire would allow it to avoid running code that initialises a variable for which it already has a stub for. This is relevant for modules that run a lot of code directly when required. newrelic comes to mind (adds instrumentation to DBs), but is not the only case.. At the very least we could have something like this for requires, like proxyquire does, but with rewire's injected setters / getters too.. ",
    "test-as-other-user": "I know your reply is kind of outdated, but I agree with this; rewire should allow injection before execution; e.g. rewire(\"path/to/my/script\", {...keyValuePairsToOverride}). \nI think the simplest possible workaround is this is:\nSuppose you have one file which is our \"main\" in package.json:\n// index.js\nconst toBeOverridden = require(\"stuff\")\n// do stuff\nChange it to two files:\n// auxiliary.js\nconst toBeOverridden = require(\"stuff\")\nmodule.exports = () => {\n  //do stuff\n}\nand\n// index.js, our new \"main\" in package.json\nconst script = require(\"./auxiliary.js)\nscript()\nThen, you can just unit test auxiliary.js\n. ",
    "andreaazzara": "Hi, do you have a workaround for this?. ",
    "ttskch": "@andreaazzara I use setTimeout() actually in my test code instead of jasmine.clock() for now. See here.. ",
    "killmenot": "I did a PR with workaround. The solution is pretty simple I think\njs\nvar rewire = require('rewire');\nvar rewireOptions = {\n  ignore: ['setTimeout']\n};\nvar myModule = rewire('./myModule', rewireOptions);. @jhnns  Hi, any chance to have this PR merged?. @jhnns It's fine for me. Give me a week to find a time to update the PR. @jhnns Hi, is there any chance to have it merged? :). ",
    "mboudreau": "@JvJefke but sub-dependencies aren't, which kinds of defeat the purpose.. @jhnns I believe that you are mistaken in your assumption.  If you look at the requireProxy in moduleEnv.js, you'll see that the require within your module wrapper is using the internal Node require, hence all requires within rewire except for the top level module is cached.\nThis is extremely problematic in a testing environment where rewire is most (if always?) used, which then needs to be reset to it's original state on first require.  The best solution (other than this PR, which is a quick fix), would be for the requireProxy to keep tabs on every require that happens within the rewired module, which would get reset on the next rewire call to the same module.\nMy particular issue with this is that my rewire module was requiring another piece of important code in my project, which was dependent on an external variable, like an environment variable, which would cause trouble when trying to test out the top level rewire with different variables to see if it all worked. \nMy change here was a bit more 'global' in nature, but this code change did fix my issue that I had when trying to test out my code.. @jhnns well, I guess it depends on the purpose of rewire.  It's normally used in a testing environment and as such, as a user of rewire, I would expect that if I rewire a module, I'll always get a clean copy at the time of rewiring, which is not the case if that module has submodules.\nIn my particular use case, I had a lot of private functions that I wanted to test out, some of which are dependent on some other piece of code that I have.  The problem here is that I had a beforeEach that would use rewire to get a new version of that module, but it wouldn't get a new one of the submodule, and if there's anything wrong with that submodule's state (like using an environment variable), it would cause errors in my tests.\nThe reason I'd rather want it in rewire is because this is the behavior that I would expect of rewire, but my tests have shown otherwise.. ",
    "tagyoureit": "I found an answer and posted it to Stackoverflow (http://stackoverflow.com/questions/41787876/use-rewire-to-stub-function-in-anonymous-export-in-nodejs/41820440#41820440).  . ",
    "chfw": "I got the same problem so google brought me here. I solved it by using path:\n```\nconst path = require('path');\nvar scrappeteer = rewire(path.join(process.cwd(), 'src', 'scrappeteer.js')); // instead of '../src/scrappeteer.js'\n```. Yep, you are right. Advice taken.. ",
    "danosaure": "@chfw I would really suggest you to NOT use process.cwd(). That is dependent of where you are launching your process and you could be in another folder and this would fail. Just a word of advice.. ",
    "jamietre": "Oops - meant to post this on babel-plugin-rewire! Sorry!. ",
    "sunfeng90": "I write 'get' but show the get. Thx!The files in the same folder.The  rewire support export the closure function? . The closure like as: \nmodule.exports = function(CheckCode) {\n     var sum = (a, b) => {\n           return a + b;\n     }\n     ....\n};. Thanks. ",
    "jhofker": "Are your files in the same folder? Your relative path in the test implies they aren't, but that could be something to check.\nI'm also not sure that you're actually exporting the function that you're trying to get with rewire.\nTo get it to show up as __get__(...) on here, use the back tick character (`) to do it inline, or do three of them in a row on a new line (), then your code, then three more on another line.\nto do a block of code\n```. ",
    "vekexasia": "Hello, Any reason why this shouldn't work with a code written in typescript?. ",
    "rnemec": "TypeError: Class constructor Alg1 cannot be invoked without 'new'\n\ud83d\ude04 . Node: 8.9.1\nI'll try to find some time to create a reproducible example.. Here is the most trivial example. Three files in the same folder.\nalg1.js:\njs\nclass Alg1 {}\nmodule.exports = Alg1;\nalg2.js:\njs\nconst Alg1 = require('./alg1');\nclass Alg2 extends Alg1 {}\nmodule.exports = Alg2;\nalgtest.js:\njs\nconst rewire = require('rewire');\nconst Alg = rewire('./alg2');\nlet a = new Alg();\nRun node algtest, resulting in:\n```\nAlg2 = function (_Alg) {_inherits(Alg2, _Alg);function Alg2() {_classCallCheck(this, Alg2);return _possibleConstructorReturn(this, (Alg2.proto || Object.getPrototypeOf(Alg2)).apply(this, arguments));}return Alg2;}(Alg1);\n           ^\nTypeError: Class constructor Alg1 cannot be invoked without 'new'\n  at new Alg2 (/Users/rnemec/Projects/T/app/util/alg2.js:2:180)\n  at Object. (/Users/rnemec/Projects/T/app/util/algtest.js:3:9)\n  at Module._compile (module.js:635:30)\n  at Object.Module._extensions..js (module.js:646:10)\n  at Module.load (module.js:554:32)\n  at tryModuleLoad (module.js:497:12)\n  at Function.Module._load (module.js:489:3)\n  at Function.Module.runMain (module.js:676:10)\n  at startup (bootstrap_node.js:187:16)\n  at bootstrap_node.js:608:3\n```. @JvJefke  - did the example help to reproduce? It's 3 files, total 8 lines of code, and it's 100% reproducible for me. Please, have a look. Hmm, weird.\nI wonder - do you babelize your tests? What happens if you just run the test (or just a code that rewire-s and instantiates, like my 3rd file) from command line using plain node?. Pulled the branch and npm test succeeds with 63 passing tests. Will play with it more to see what may be going on... One difference I see is that I'm using rewire as npm module, not running inside, like your tests.. Oh, found what is causing it: I have a .babelrc in the project root that is used for some other code. When I temporarily remove the babelrc, rewire works OK. It seems that your use of babel picks up the babel setting in my project (and those settings are not rewire-friendly, apparently).\nPlease, let me know if there is anything I can do to help resolving this...\nOh, my .babelrc is:\njs\n{\n    \"presets\": [\"es2015\"],\n    \"plugins\": [\"transform-class-properties\"]\n}. My pleasure! Thanks guys for keeping this tool being one of top unit-testing utilities.. ",
    "ertrzyiks": "@jhnns Any chance to have it merged? It would make integration with https://github.com/sinonjs/lolex much easier. ",
    "wdullaer": "Checkout https://github.com/wdullaer/oplog-emitter and run npm run mocha on node 4\nThe issue does not occur on later node versions (presumably because babel realises that the features it's trying to compile are natively supported by the runtime and therefore does not hit the problematic code path). Cool!\nI'm not an expert on the internals of require, so I opened an issue rather than a PR.\nAlso thanks for this library that I've been happily using for a long time \ud83d\udc4d. ",
    "cjhoward92": "I verified it is an issue in my specific package, but I don't know why. I will let you know if i figure it out.. Destroying my node_modules and yarn.lock then running yarn cache clean && yarn worked fine... Weird!. ",
    "pdworniczak": "Will that pull request be merged anytime soon?. ",
    "rbriank": "When will this be merged into master?. Apparently there is a fix in the pipe for this already: #128  . ",
    "dimitriirybakov": "That's very important feature, because nodejs supports object spread. Merge it, please.. ",
    "okv": "Hi there.\n@jhnns any chance that pull request will be merged?). That's great, @jhnns could you also publish it to npm?. ",
    "amitguptagwl": "Hmm, It means I'll have to handle the first call in the way it doesn't impact another call.\nThanks for your quick suggestion.. ",
    "briandeheus": "I'd like to add this also happens on:\nOperating System: Fedora Release 26\nEnvironment information:\n node version: 6.11.5\n npm version: 3.10.10\nDowngrading to @2 works.. ",
    "brettstack": "@briandeheus which version of 2 works for you? I just installed 2.5.2 and it's still not covering.\nOSX Node version 8.5.0. Thanks @alfred. I definitely get coverage when I remove rewire and the tests that require it. Will try downgrading again.. I'm still not getting coverage when used with Jest. This definitely works when I remove rewire and all tests that use .__set__. ",
    "alfred": "@brettstack Not the above, but I use OSX rewire@2.5.2 with node@8.9.0 and npm@5.5.1 and it works for me. Double-check your tests?\nI downgraded from @3 as well.. ",
    "umarrasydan": "Using ~2.5.2 works for me\nno luck with @3. ",
    "GreensterRox": "I have the same issue: \ndoesn't work with rewire @3 / nyc 11.6.0 / node 4.4.5\ndoes work with rewire 2.5.2 / nyc 11.6.0 / node 4.4.5\n. ",
    "bforbis": "@jhnns I just confirmed that this has fixed the issue in my linked test repository. I also tested it on several of my private repos and saw that upgrading from rewire@2 to rewire@4 correctly preserves the code coverage from nyc, so looks like everything is working.\nI'll note that in one of my repos I did start seeing an issue with running mocha/nyc of this nature:\n\"before all\" hook:\n     Error: global leak detected: __core-js_shared__\nI don't have a minimum reproduction I can share that caused this, but I was able to fix this issue by updating my mocha command to mocha --require babel-register. More info on that here: https://babeljs.io/docs/setup#installation. ",
    "odedniv": "I did that eventually, it does make more sense to install eslint locally.\nThe problem was that I had configured eslint globally, including a plugin that was also installed globally. Because rewire had eslint installed locally my editor and package.json scripts used it instead, and the locally installed eslint wouldn't load the globally installed plugin which made my global configuration invalid (eslint crashed for missing plugin).\nThanks though. ",
    "DalderupMaurice": "You can achieve the same with a simple .eslintrc file, instead of having it in your code, right? \nI have the same issue as @odedniv as I am using babel 7 and eslint v4 is loaded with babel 6. ",
    "asamuzaK": "OK I got it, thanks.\n. ",
    "visoft": "What test runner are you using? I found you can't override const with Rewire in Jest. Change your constants to let and see if that works. Also see https://github.com/jhnns/rewire/issues/144 and https://github.com/facebook/jest/issues/6803. ",
    "jameswilddev": "Something which I've found really helps with performance, for stateless modules, is to rewire only once, then create a function which wraps .set.  This function tracks all changes it made, and reverts them all at the end of the tests (in this case, Jasmine's \"afterEach\").\nI'm not sure but it looks like you have an ES6 module being imported by a non-ES6 runtime.  Given Babylon (Babel's parser?) is in the stack, is your .babelrc definitely being loaded?. ",
    "jehy": "@jameswilddev we are running tests on Node.JS backend, there are no ES6 modules, only CommonJS.. @jhnns i tried to, but I can't find a working version of dtrace for ubuntu 18 :(. ",
    "spik3r": "+1\nI agree this would make writing tests much simpler & cleaner... I also don't like needing multiple frameworks.. ",
    "hmaracic": "I noticed the same thing.\nWhen a module is \"required\", the value of this inside a function defined as module.exports.someFunction is module.exports.\nHowever, when the same module is \"rewired\", even without making any changes to it with __set__, the value of this seems to be the global object.\nCan this be changed? Can we somehow invoke the function with the \"usual\" this?\nCalling the exported function with .call(someNewThis) from a module where it was \"rewired\" does not seem to change the this inside it.. ",
    "Shakakai": "I'd like to provide some additional evidence. The issue appears to happen when using the Jest testing library but not with Mocha. I created a git repo to show the issue: https://github.com/Shakakai/jest-rewire-const-error\nHere's a link to the issue in Jest: https://github.com/facebook/jest/issues/6803\nI'm not sure which library is responsible.. ",
    "sinkersan": "Any updates here?. ",
    "liunate": "Ran into the same issue with latest rewire@4.0.1, jest@23.5.0, 0% line coverage for private function being invoked in test\nHere's the demo repo showing the issue, simple jest test, also with my coverage report included\nhttps://github.com/liunate/rewire-coverage.git. ",
    "andynhi": "hitting same issue, i attempted to roll back rewire to @2 and @3, but no luck. ",
    "gnarmedia": "Rewire is amazing for testing our non-module code, but sadly I am having this issue as well.. ",
    "aonamrata": ":cry: Did this work for anyone? I am on \n\"@babel/core\": \"^7.0.0-0\",\n    \"rewire\": \"^4.0.1\",\n    \"babel-plugin-rewire\": \"^1.2.0\"\nand my tests run correctly but coverage is 0%\nbabel.config.js \nmodule.exports = {\n    presets: ['@babel/preset-env'],\n    \"env\": {\n        \"test\": {\n            \"plugins\": [\n                \"rewire\"\n            ]\n        }\n    }\n};\n. ",
    "o-t-w": "I am also hitting the same issue. ",
    "rafaelcamargo": "Looking for some alternative here because I've fallen in the same place as cited above, but I'd love to keep with rewire. Your API is awesome \ud83d\udc4d. I've just realized the any require() dependency could be easily mocked if you transform your module in a class:\n``` javascript\n// module.js\nconst rawFs = require('fs');\nclass Module {\n  constructor(fs){\n    this.fs = fs || rawFs;\n  }\n  doSomething(filepath){\n    const file = this.fs.readFileSync(filepath, 'utf-8');\n    ...\n  }\n}\nmodule.exports = Module;\n```\nSo, mocking becomes a breeze...\n``` javascript\n// module.test.js\nconst Module = require('./module');\ndescribe('Module File', () => {\n  it('should so something', () => {\n    const fsMock = { readFileSync: jest.fn() };\n    const filepath = 'some/path/to/file.js';\n    const module = new Module(fsMock);\n    module.doSomething(filepath);\n    expect(fsMock.readFileSync).toHaveBeenCalledWith(filepath, 'utf-8');\n  });\n})\n```. ",
    "brokentone": "Thanks for the response @jhnns! I personally believe that the current state is kind of the worst option -- not actually rewiring the module you intended, but actually rewiring a different one, and with the rewiring needs often being pretty subtle, it might be pretty hard to figure this out (thus my issue).\nI have proposed this PR: https://github.com/jhnns/rewire/pull/149 in which minimally it makes that disconnect much more obvious. It doesn't fix the issue as such, but it makes it obvious that you have an issue. I imagine including this in a release would increase the support needs / issues filed, so it would be important to explain this clearly that \"if you have X message now, you never were properly rewiring the named module\" etc.\nFor a solve, if you looped through all registered extensions and handled all of them -- or since you don't necessarily know how to handle particular files, perhaps there could be a singleton-y configuration step where users can add in other extensions? As a breaking change, the .coffee function could move to an example in the documentation?\nI like the proposal of migrating this logic to pirates as well.\nIf you point me a direction (and ideally merge the PR I mentioned) I can contribute some.. ",
    "akuroda": "Hi,\nIt seems methods of document object are lost after rewire. My workaround for similar problem is:\nconst f = document.getElementById.bind(document);\nconst mymodule = rewire('...');\noptions.__set__(\"document\", {\n    getElementById: f\n});\n// access document object inside mymodule\ncf: https://stackoverflow.com/questions/10743596/why-are-certain-function-calls-termed-illegal-invocations-in-javascript. ",
    "artyomsv": "Hi, I'm also interested in this topic. I would prefer not to haves eslint shipped by the rewire library.. ",
    "jdalton": "\ud83d\udc4b @mfolkeseth!\nThe esm loader maintainer here. This is not a rewire bug, it's an esm one.\nI'll update https://github.com/tapjs/node-tap/issues/509 with details.\nUpdate:\nv3.2.5 is released \ud83c\udf89 . ",
    "mfolkeseth": "Thanks! \ud83d\udc4b . "
}