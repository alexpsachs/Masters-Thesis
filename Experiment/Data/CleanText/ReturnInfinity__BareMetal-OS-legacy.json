{
    "Roxxik": "Why would we want to put the Kernel up there?\nAll the reasons I Saw for doing so are:\n1. 32-bit binaries can use the whole address space\n    - we don't have precompiled 32-bit binaries for BareMetal\n2. It's easier to set up VM86 processes\n    - currently there is no option to switch to VM86 mode and i don't think its planned\n3. The Applications don't have to know how much memory is required by the Kernel\n    - I think with such a tiny Kernel we're unlikely to hit 0x200000 soon so that should be ok too\nIf there are reasons to put the Kernel in the higher helf please let me know, otherwise it'd suggest to keep it just where it is\nP.S. Am I right in my prediction that the whole memory just gets identity mapped?\n. ah ok this sounds reasonable\nisn't this a issue of th bootloader?\nespecially this part\n; Move the trailing binary to its final location\n    mov rsi, 0x8000+6144        ; Memory offset to end of pure64.sys\n    mov rdi, 0x100000       ; Destination address at the 1MiB mark\n    mov rcx, 0x0D00         ; For up to 26KiB kernel (26624 / 8)\n    rep movsq           ; Copy 8 bytes at a time\nand all the things calling the kernel syscalls (0x100010 - 0x1000C0 at the moment) must be adjusted\nEDIT: and the paging table\n. This will lead to some difficult to track down problems if the OS crashes when you have a flag set while making a syscall, while this behaviour is not documented\nI'd recommend to clear the direction flag on the functions that would break and declare in the API that no assumptions about the direction flag have to be made after using said functions\nor alternatively if the direction flag has a deterministic state after making a syscall we can just document it\n. Some assumptions from my side:\neach 2MiB Page has one Byte in the os_MemoryMap structure\n0x01 is free\n0x02 is used\nthe whole memory is identity mapped (behave like paging is off)\nPML4 is a structure to keep track of virtual memory pages\nFrom Pure64/Pure64.asm/line 183\n; The higher half is identity mapped to the lower half\nThis comment doesn't make sense to me because identity mapping means mapping to the same address\nI'd recommend to set up the paging tables so that we can enter long mode(basically identity map everything) and keep the usage information in a seperate region\nThis has the drawbacks, that we can't load more than one application at a time unless\n1. we build a loader\n2. we use position independent executables which can be load everywhere\nwith paging enabled we could load more than one application to virtual address 0x200000, but this hinders IPC because u cannot just share some pointer between the two and but a spinlock infront of it\nfor that we either have to build some shared memory or build something into the Kernel that can share information between processes\n. Before removing the current cli from the Kernel the functionality from it must be accessible by system calls\nand right now i don't see any way from an application to print the version number(without knowing the exact memory location where it is saved) or clear the whole screen(without just outputting a ton of spaces/returns)\nI'd recommend to let the cli sit there for the moment and rewrite the Kernel API to make it possible to write a basic shell without hardcoding the location for the interesting informations(except for the systemcalls)\n. It happens that i have a working Hello World in Rust that compiles under rust 1.3.0 nightly.\nCurrently i don't have the time to upload it but i'll setup up a repo for this tomorrow.\nWith the inline assembly of rust... i'd currently not recommend to use it, it's poorly documented and likely to change. instead im linking to libBareMetal.\n. Isn't the easiest thing to just jmp to reboot?\n2015-07-08 16:09 GMT+02:00 Mason X notifications@github.com:\n\nWell, could another possible solution be to call the kernel again?\nie, jump to the start of the os and let everything re-initialize\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/pull/83#issuecomment-119592112\n.\n. because os_output_chars handles CR too, and my assembly isn't that good so i'm not quite sure what happens there\n. os_input is currently not calling os_print_newline\n. thats because the cli is calling os_print_newline itself explicitly\n\ncall os_input\ncall os_print_newline       ; The user hit enter so print a new line\n. Haven't seen that yet, why are there two versions of the OS?\n. eventhough in the other repo is no syscall that can output a newline directly\n. i'd do this like\nchar c = '\\n';\nb_output_chars(&c,1);\n. ah damn\n. I chose to not include rust inline assembly, because currently it is unstable, undocumented and not conformant to gcc inline assembly.\nThat's why i have included a c layer to make the systemcalls.\n(I tried to use it but the rust compiler always optimized the assembler away :(  )\n. My idea was that it could be part of a shell\nAm 10.07.2015 00:13 schrieb \"Mason X\" notifications@github.com:\n\nHowever, I fell like this loader should not be a part of the OS, but\ninstead a program that you can run.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/98#issuecomment-120163075\n.\n. The loader I'm currently thinking of is just an app which can load(and relocate) another binary into memory and jump to the start of it.\nKeeping it very basic right now.\n\nThis could be used by a shell to start another binary.\nThe binary could be started with smp_enqueue instead of a jmp which is essentialy multiprocessing.\nBut first of we need to be able to load an executable.\nIf this kernel is 'just' starting VMMs its basically a Hypervisor Hypervisor and not an exokernel.\nAnd if you want to load multiple VMMs you'd need to load them to different locations, too.\n. I think in the long term it would be best to choose what application is started first by the OS (currently hardcoded to the cli) by calling it a certain name (start.app, init.app ... the name is not a matter of this discussion)\nwhere the default would be to start a shell reading and executing another file (start, init ...) as shell script\nthis hypothetical shell can then be build in another repository\n. ",
    "IanSeyler": "The main reason was to have a linear range of memory without gaps. There are a lot of gaps in lower memory that can't be used by an application. The plan would be to map available memory starting at the higher half and run out of there without worrying about gaps.\n. Even at compile time? ELF could be a possibility down the line.\n. Linking the application with crt0.o fixes this issue. This will be added to the Newlib / C instructions.\nld -T app.ld -o helloc.app crt0.o helloc.o libc.a\n. With the AHCI driver it is ADMA by default.\n. Building it in C first to get a working prototype. See here: https://github.com/IanSeyler/minIP\n. BMFS for the win!\n. The ACHI spec can be viewed here: http://www.intel.com/content/www/us/en/io/serial-ata/serial-ata-ahci-spec-rev1_3.html\n. Looks like it works!\n. Specs:\nhttp://www.broadcom.com/collateral/pg/57XX-PG105-R.pdf\nhttp://www.broadcom.com/collateral/pg/5722-PG101-R.pdf\n. Can the i8254x driver be expanded to support the i8257x?\n. So far this work has been completed:\nEthernet ring buffer has been removed.\nos_string functions have been removed (but are now part of the CLI).\nException code has been optimized.\nFAT16 has been removed completely.\n. Complete!\n. Thanks! This has been fixed.\n. Thanks!\n. The max supported value with the current 16-bit value is 65535 MiB (64GiB).\nThis has been addressed in the latest Pure64 (http://code.google.com/p/pure64/source/detail?r=102) but still needs to be applied to BareMetal OS.\n. Also, Pure64 needs to be properly migrated off of Google Code and onto GitHub.\n. The cores shouldn't be a problem. Pure64 was recently tested a 64-core box (4 CPUs, 16 cores each) with 128GiB of RAM.\nhttp://twitter.com/ReturnInfinity/status/195205653722185728/photo/1\n80 cores? What CPU and motherboard?\n. This should be resolved. Pure64 is updated on GitHub as well.\n. Callback is now in the network interrupt handler.\n. Thanks again!\n. Should be resolved now. Thanks for pointing this out.\n. Odd. What version of VirtualBox? The 0.5.3 VMDK worked fine for me with VirtualBox 4.1.18 on Windows.\n. I just tested VirtualBox 4.1.18 on Mac OS and it works correctly.\n. Ah yes.. Pure64 0.5.0 was the first version that requires the IO-APIC. VirtualBox enables the IO-APIC by default if the VM is configured to have more than one CPU core.\nOnce I update the download page I will close this issue.\n. I have added a note on the download page.\n. I still need to go through what functions will be available to the applications. At the moment I am removing some of the function calls to make things cleaner.\n. Fixed!\n. This ties into the BMFS driver. Newlib isn't super useful if it can't work with files.\n. It works but is buggy. Will address issues in further tickets.\n. Complete.\nkernel.asm shows the new API that is available to the programmer.\n. The current driver is not \"C library ready\".\nNewlib requires open(), close(), read(), write(), lseek(), fstat(), stat(), link(), and unlink().\n. open(), close(), and read() are in.\n. Pure64 has been updated to v0.6.0\n. https://github.com/ReturnInfinity/BMFS\n. BMFS utility is now complete.\n. Hi David,\nThe utility is meant to be used from another OS like Windows, Linux or Mac OS X.\nIf you are looking to do something like dd then that functionality is in the kernel with the readsectors and writesectors functions. Going forward we will need to implement Newlib features like read(), write(), and seek() with proper file streams.\nAre you looking to dd other disks with various file systems?\n. Agreed, pretty sure this ticket was created when there was no good API doc. Closing.\n. The idea here is to use the PML4 as the memory map instead of the separate 128KB os_MemoryMap.\nI was going to test using the User/supervisor, Accessed, or Dirty bit in each PD entry to mark if a page is actually in use.\nMore info on those bits are in the Intel SDM docs. Section 4.4.2 - Table 4-9.\n. Following up the questions from @benaryorg \nThe BareMetal exokernel supports multi-threading but not in the conventional sense that most operating systems use. A thread is locked to a CPU core in BareMetal. If you spawn 5 \"threads\" and only have 4 cores then the last thread will only run once one of the first have completed.\nNo worries on drivers. BareMetal publishes a simple API for the drivers (network and disk).\nRight now a single bad program can crash the OS (for instance if you overwrite the IDT at memory address 0x0). There needs to be some work done to make sure that isn't possible.\n. Actually more was required to be \"C-ready\". Write isn't enabled yet but the framework is in.\n. It was implemented but I am re-organizing some of the code. It will be fixed shortly.\n. Fixed in the latest version.\n. This was caused by an error in the Newlib <-> BareMetal OS \"glue\".\nwrite() was set to return 0 instead of the number of bytes it actually wrote.\n. Complete.. still need to add function for callback.\n. Fixed in latest commit.\n. Fixed in latest version (Incorrectly tagged as \"Fix #49\").\n. I have no issues with the CLI being written in C and using NewLib. It would make it easier to add features anyway. Thanks for taking a look!\nSent from my iPhone\n\nOn Nov 15, 2013, at 7:33 PM, Alexandru Barbur notifications@github.com wrote:\nI'd like to take a stab at this. Should the CLI only use the OS API or can it depend on newlib? It's obviously doable either way (assembly version is written this way) but if we can use newlib that might cut down on code duplication.\n\u2014\nReply to this email directly or view it on GitHub.\n. I think it may be time to implement a foreground/background system. Let me think on this a bit more. I don't want to go multi-process or multi-user but it would be useful to have the user interface running while the app is.\n. Part of this has been implemented. os_ethernet_tx forwards the memory location of the packet directly to the network driver and the hardware handles it. No time is spent by the CPU to copy anything.\n\nos_ethernet_rx does one copy (from the OS packet buffer to the requested memory address) so that will need to be adjusted.\n. Yep, the thought was to add an option to specify the address - sort of like adding the network callback address.\n. That buffer, os_EthernetBuffer, only stores the most recent packet that was received by hardware. It used to be a ring buffer but that was removed once the callback code was enabled.\nWe're talking about system memory here and the current drivers do not support on-nic memory.\nHeres what is currently happening when a packet comes it:\n1) Hardware grabs the packet and stores it in a system buffer.\n2) App calls os_ethernet_rx to copy the packet in the system buffer to its own storage location.\n3) Repeat\nHere is what we want for zero-copy:\n1) Hardware grabs the packet and stores it in a buffer specified by the application.\n2) Repeat.\n. At the moment the only two system interrupts are caused by the RTC and the network. Each of those supports an application defined callback so polling isn't required.\n. At the moment BareMetal does not have zero-copy in its network stack.\nAlso I took a look at the existing network drivers and they contain the dredded rep movsb instruction. This change will involve driver modification as well. This is probably left overs from the ring buffer system that was removed.\n. init_bmfs checks to make sure a drive was found.\n. It appears that BareMetal is not finding a PCI device with ID '0x0106' which would be a SATA controller. Debugging has been added to dump the PCI device list.\nThe board in question is a Asus P8H61-M LE/USB3 - http://www.asus.com/Motherboards/P8H61M_LEUSB3/\nChipset is Intel H61 - http://ark.intel.com/products/52806/Intel-BD82H61-PCH\nPerhaps this is a PCI Express issue?\n. PCI dump did not detect any storage device on that motherboard.\nDetected:\n0600 Host bridge\n0604 PCI bridge\n0300 VGA\n0780 Communication controller\n0C03 USB controller\n0403 Audio device\n0604 PCI bridge\n0C03 USB controller\n0601 ISA bridge\n0C03 USB controller\n0604 PCI bridge\n0200 Ethernet\nNot searching PCI properly?\nChange needed for PCI Express?\n. Functions were not being tested for (Some PCI devices have multiple functions). Fixed!\n. Thanks!\nChanged to:\n\"At the moment there is no plan to build BareMetal into a general-purpose operating system\" [...]\n. Closing as I won't be able to test this.\n. The IO-APIC is working (keyboard and RTC are firing). Issue is with the call to os_ethernet_ack_int in net.asm.\nThis could be a i8254x driver issue. Or the IO-APIC is not mapped correctly.\n. This bug exists with the PIC as well.\n. Fixed in #75\n. Is something in crt0.c required for this? Should syscalls.c exit() have a fflush(stdout)?\n. The custom callbacks do not affect the system interrupt code. The callback code is executed as soon as the interrupt handler is finished.\n. Yes, that is correct.\n. Closing as I won't be able to test this.\n. Something has changed with the new versions of VirtualBox to cause this. Older OS revisions have the same issue running in the current version of VirtualBox.\n. I am not getting this error message. What version of NASM are you using? Please check the output of 'nasm -v'\n. Please upgrade to the latest (or at least newer) version of NASM. NASM is now at 2.10.09 and a lot of bugs have been fixed since then.\n. @wandernauta is correct. I've been in contact with one of their devs in the past. MenuetOS is trying to be a general purpose OS and that is not my vision for BareMetal.\n. As Wander already mentioned, this would involve a complete rewrite. An ARM 'port' is on our roadmap. We initially wanted to target the Raspberry Pi but the hardware did not meet our specifications (also I believe it was ARM V7).\nThe BeagleBone Black is V8, correct? http://beagleboard.org/Products/BeagleBone%20Black\n. Except for the iPhone 5s I suppose..\n. Thanks! Yes, I'll remove the RCX return value as it is not needed anymore.\nAs for Parallax, not yet but soon!\n. Fixed with the latest commits.\n. I'm made some changes to the documentation on this.\n. Specs: http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.pdf\nLegacy specs: http://ozlabs.org/~rusty/virtio-spec/virtio-0.9.5.pdf\n. Not really. Initial work was done on this but it was never in a working state. Would this be useful for you?\n. Try this: http://www.ic.unicamp.br/~pannain/mc404/aulas/pdfs/Art%20Of%20Intel%20x86%20Assembly.pdf\nIt's an older doc (doesn't cover 64-bit) but it is still a good read.\n. You are correct. RDX was not being preserved between the calls to readsectors. I'm taking a look at official changes to the code (mainly if we need to worry about multiple disks at the moment).\n. 1) Good find! You are correct. The value should be 0x80008060. Bits 29:16 in TXCW are reserved.\n2) Possible, but not necessary. This code only runs once at network card initialization and most systems are able to get the MAC address from the 'Receive Address Low/High' registers.\n. The total address is still 64-bit. The address has to be 1K aligned so bits 9:0 in PxCLB can only be 0.\nI wrote the driver from scratch. Intel hosts the AHCI specifications on their website: http://www.intel.com/content/www/us/en/io/serial-ata/ahci.html\n. Should be possible for any language out there. What is required is some 'glue' for Go so that it can call the OS functions. Unfortunately I don't have any experience with Go.\nIt's a similar issue to RustBoot (https://github.com/charliesome/rustboot) where a simple Rust program can run without a standard OS.\n. Closing this as it is out of scope for the OS itself.\n. Thanks!\n. Agreed, I can't say that I know a lot about programming in Rust so I would need assistance with this.\nA proof of concept already exists for free-standing Rust programs:\nhttps://github.com/charliesome/rustboot\nhttps://github.com/pcwalton/zero.rs\nI'm unsure of how to call C or Assembly functions from Rust. This would be required for a \"Hello World\" example.\n. I've uploaded a potential fix for this. Can you please give it a try?\n. Awesome! I'm glad that did the trick. Would you mind sharing how you start up QEMU with networking? I'd like to test and add it to the documentation. I've only tested the network code in VirtualBox or with physical hardware.\n. Thanks again!\n. Nothing to add here.\n. Agreed @benaryorg !\nCalling the CLI again is not the proper method... especially if a multi-threaded process exits while other CPU cores are still executing code.\nLooking into a fix for this that will involve resetting all CPU cores and restarting the CLI.\n. @benaryorg is correct.\nThe current plan is to add a system call (in b_system_misc) that does the following:\n-clear memory map\n-clear network and RTC callbacks\n-reset all CPU cores to jump to ap_clear in kernel64.asm (there is already an interrupt vector for this)\n-restart the CLI\n. Here is how BareMetal inits the CPUs: https://github.com/ReturnInfinity/BareMetal-kernel/blob/master/src/x86-64/init/64.asm#L163\nI just need to adjust the code for the new reset function. I don't want to reset the calling CPU core accidentally so will need to call os_smp_get_id first.\nos_smp_reset: https://github.com/ReturnInfinity/BareMetal-OS/blob/master/os/syscalls/smp.asm#L19\nThat code send a message via the APIC to a specific CPU core telling it to execute interrupt 0x81 which is ap_clear in kernel64.asm\n. @benaryorg For IPI code you can take a look here: https://github.com/ReturnInfinity/Pure64/blob/master/src/init/smp.asm\nThat is the code for how Pure64 (The BareMetal bootloader) 'boots' up the other CPU cores.\n. @benaryorg :+1:\n. This should be properly addressed in the last push: https://github.com/ReturnInfinity/BareMetal-OS/commit/59d15a4dcf39d77229e51fc4e261f0e437c0e9db\n. Thanks!\n. Thanks!\n. Awesome! Great optimization work.\n. Thanks!\n. Thanks!\n. Thanks!\n. LF is used in all source code since I develop mainly in Linux.\nDocumentation may be CR+LF since I write in Windows sometimes.\n. Yep, it should be able to handle both LF and CR+LF formats.\n. os_output_chars is able to print a single character. In needs the address of where the character is in memory and a count value of 1.\nTo print a newline you can use this:\nmov rsi, newline\nmov rcx, 1\ncall os_output_chars\n...\nnewline:        db 13, 0\n. Slick! I haven't had a chance to try it but looks good. Does Rust support inline assembly?\n. A part of this functionality was built into the CLI in the past. The CLI would begin and look for an app on the disk called 'start.app'. If it existed then it would be loaded and executed automatically. This function was removed for some reason I can't recall at the moment. Probably because it was limited to a specific app name to work properly.\nI guess we sort of need an autoexec.bat file :P\n. I'm also interested in this. https://github.com/ReturnInfinity/BareMetal-kernel was set up with a separate x86-64 folder for this reason. I'd also like to write a version for 64-bit ARM.\n. If there is enough demand this can go into BareMetal-kernel\n. Done!\n. Looks good!\n. Thanks!\n. Using 2MiB pages would be ideal as that is what BareMetal already uses for memory mapping.\nI'll investigate how this could be added. I'm just not sure of how caching should be configured.\n. Fixing the memory mapping that is currently being used is here: https://github.com/ReturnInfinity/BareMetal-kernel/issues/14\nAll further development is going into BareMetal-kernel. I'm moving away from a sort of \"general purpose\" OS to a more \"server node\" type of OS.\nFixes/additions may be back ported into BareMetal-OS but I'm not sure of its roadmap at the moment.\n. @Konard BareMetal-OS at the moment as there is no way to control an instance of just BareMetal-kernel yet as I stripped out the CLI.\n. Are these changes not already in the main source?\n. @ohnx Yep, might as well update it to 2016.\n. Good eye! Thanks\n. Thanks!\n. Thanks again!\n. I fixed a few more of the upper addresses not being set: https://github.com/ReturnInfinity/BareMetal-OS/commit/0f75e255a4bb7f6cc23e1854901c9a96da73c7ab\n. This probably won't happen in BareMetal OS. The BareMetal kernel is a possibility though: https://github.com/ReturnInfinity/BareMetal-kernel/tree/master/src/armv8\nI have yet to find an ARMv8 assembler though.\nAnd yes, it would be a total rewrite retaining the same API.\n. Closing this issue as it will be part of BareMetal-kernel when an ARMv8 version comes.\n. I will give this a try on my end and see what I can find. Thanks for reporting this.\n. This is confirmed as a bug. I tested with VirtualBox 5.1.8 and got the same results.\n. Check \"Offset 10h: PxIS \u2013 Port x Interrupt Status\" and \"Offset 30h: PxSERR \u2013 Port x Serial ATA Error (SCR1: SError)\" to see what the issue may be.\n. Set AHCI Enable (AE)? Currently the driver does not do this.\n. It's not AE (VirtualBox already has in enabled) and all of the BIOS handoff bits are clear.\n. Neat! So it's just iddrive function that hangs. Comment it out and BareMetal starts up fine (although it detects the disk is 0MiB). Reading from the disk after this works.\n. Set the FIS length to 5. This is the minimum for that type of FIS.. BareMetal does support SATA disks via the AHCI driver.\n- What hardware are you running it on?\n- Was the drive formatted with BMFS?\n. Check your SATA Configuration in the BIOS. \"OnChip SATA Type\" should be set to AHCI.\n. Awesome idea!! I'll give it a test on my end.\n. I had a reason for this back when initially writing this code as I came across something that said inc/dec should not be used in x86-64. I can't recall where I saw this but this would cut down on compiled code size.\n. Thanks for submitting this! I've also made the appropriate changes to BareMetal-kernel based on this pull request.\n. That is correct (though the BIOS settings should not have made an effect). The BareMetal kernel does not have a USB host driver. Booting can occur but it will not be able to see the boot medium after switching to 64-bit mode.\nAt the moment the fully supported boot medium is a SATA hard drive in AHCI mode.\n. This pull request has been accepted. I will most likely move the os_get_proc_time and os_set_proc_start_time functions into os_system_misc just to keep the call table tidy.\nGreat work!\n. How precise does this need to be overall? Currently os_ClockCounter is incremented 8 times per second.\n. Agreed on the APIC timer. I've couldn't get it to work before but it will required for precision.\n. HPET (https://en.wikipedia.org/wiki/High_Precision_Event_Timer) may be another option.\n. I don't see any problems with the code you provided - I added it to the CLI testzone on my dev system and it worked correctly. I'll need more details on this (other code changes, compile methods, etc).. Yes, I have run this on a few physical systems without any issues.. I'm not sure what this is for.. Closing.. ",
    "dsriram": "Since we are using a flat binary format it would be almost impossible to know the offset for the bss segment, unless we switch over to ELF.\n. How about this compile time structure for the .app header?\n``` nasm\nstruc OS_APP_HEADER\n.flags_addr:        resq    1\n  .code_addr:        resq    1 \n  .data_addr:        resq    1\n  .bss_addr:         resq    1\nendstruc\n```\nthis is just a nasm struc representation. the actual table will be generated through the linker script at compile time\n. Possibly because os_file_list function not implemented yet?\n. ",
    "Konard": "Any updates?\n. Why not to remove reference to latest year? 2016 is coming...\n. May be it is a good idea to make memory mapping as a \"plugin\"? So the developer can deside how to optimize caching? And provide a simpliest example how to implement it?\n. At least we can select features (modules or packages) that should be included OS (before compiling or writing to disk/flash). It can be done through modification of code, or through plugin system. By hand or automatically.\n. So what repository is most ready to be used? https://github.com/ReturnInfinity/BareMetal-OS or https://github.com/ReturnInfinity/BareMetal-kernel ?\n. ",
    "dansouza": "\nUtilities to transfer files between a computer running BareMetal OS and Linux/Windows.\n\nMaybe use TFTP? Should be simple enough, plus clients are already implemented.\n. ",
    "erichocean": "Well, one of the machines I'm wanting to use BareMetal with has 64 cores and 512GiB of RAM, and the box actually goes up to 80 cores and 2TiB of RAM.\n. > 80 cores? What CPU and motherboard?\nhttp://www.supermicro.com/products/system/5U/5086/SYS-5086B-TRF.cfm\n. Thanks!\n. Any movement on this?\n. ",
    "bendyer": "I see the same behaviour. The freeze occurs with \"3X34\" in the top-right corner of the screen, indicating that the problem is in Pure64 0.5.0 and that no valid ACPI could be found. The same image works fine in VMware Fusion, so I think it's a question of Pure64 0.5.0 not being able to recognise the ACPI structure created by VirtualBox.\nGiven the current Pure64 works in VirtualBox and VMware Fusion, I think a new release of the development VM images needs to be added to http://www.returninfinity.com/baremetal-download.html\n. I'm using VirtualBox 4.1.18 on OS X 10.8, using a VM created from the VMDK with default settings.\nI have just noticed that under the \"System > Motherboard\" preference pane, there's an \"Enable IO APIC\" option which was disabled by default. After it's enabled, the system boots up successfully, so that must be what's causing the crash.\nSo, rather than updating the release, it might be good to add a VBOX file with the correct settings.\n. ",
    "ghost": "Works for me too, on Windows.\n. Thanks for the update. Keep me posted.\n. Yes, but this was painful \"0x070000 -> 0x071FFF\" == 4096 Bytes ;)\n. I'm not familiar with AHCI, so i didn't know which was correct (just mentioned it)\n. Oh.. Sorry. I confused with BMFS.\nhttps://github.com/ReturnInfinity/BMFS/blob/master/README.md\n. I just checked again.\nIt says \"autoreconf -fi\"\n... sorry.\n. ",
    "krainboltgreene": "This has fixed the issue!\n. ",
    "davidrubert": "Ian,\nThere has been a flurry of activity on BMOS lately.\nBrilliant as always.  Thanks.\nA question about the BMFS utility.\nIs it meant to be used from within BMOS or is it just a untility to read\nBMFS data from another OS like Linux?\nFYI - the reason I ask and perhaps this is a second question really is that\nI'm looking to PXE boot BMOS then I want to image or \"ghost\" data on to the\nlocal drive\u2014so like the dd command.  I know you haven't written documention\nbut will BMFS have some of this code that could be leveraged?  I looked at\nthe includes in dd.h and I'm guessing it won't compile using just NEWLIB.\n But I'm unfortunately in deeper than my skill set and I may be completely\noff-base.  Perhaps for your consideration after your immanent 6.0 release\n(again, congratulations!)  some basic dd-lite functionality I think would\nbe a very cool feature.  I don't think BMOS needs various fs driver support\ngenerally, just the ability to write the bits to disk.\nOn Tue, Apr 9, 2013 at 5:43 PM, Ian Seyler notifications@github.com wrote:\n\nBMFS utility is now complete.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ReturnInfinity/BareMetal-OS/issues/30#issuecomment-16147354\n.\n. \n",
    "benaryorg": "Can this be closed or is there something left to do?\n. The question is if there are plans to make BareMetal-OS a multi-threading and multi-tasking OS.\nIf yes, then there is another question.\nWill it have memory isolation and the usual \u201ca single process cannot crash the whole OS\u201d mechanisms?\nJust keep in mind that BareMetal is an exokernel, which means every program will have to supply it's own drivers, which could influence each other.\n. Also a link to what PML4 exactly is: https://lwn.net/Articles/106177/\n. So, you want a syscall (?) to send a memory range directly onto the network?\n. It is a buffer, it will be hard to impossible to remove that, unless you let the application specify its own.\n. Is the buffer used for more than one packet?\n. I think it would be an overall good solution if the application could specify it's own handlers for all interrupts (without overwriting the system ones).\nThat would solve many problems. It would enable writing a task-switching mechanism and would enable some better mechanisms than polling.\nWe also had exception handling then.\n. Sorry, but I haven't had time yet to have a deeper look into BareMetalOS.\nIsn't there a Zero-Copy network \"stack\" then?\n. Please have a look at #83 for some possible solutions.\n. As you just mentioned in #43, there is the possibility of a custom callback.\nIs this callback replacing the original handler?\nBecause if it is, then I see no clean way of repeatedly increasing a 64-bit integer.\nElse, there could be problems if this would be done in a custom handler (in case there can only be one of them).\n(just throwing in some ideas)\n. So, you are planning to have the system interrupt triggered by the RTC to count up a 64-bit integer and have the gettimeofday (and possible other functions) return an accurate time based on that integer and the time saved by the hardware?\n. Then you could have some memory location (which is by default initialized to 0) which is used by all time functions to save the hardware time to (on first access just compare if it is zero) and in all of these functions just copy the hardwaretime into a register and add the counter.\n. Preferably you could write one function (similar to time(0)) which just returns the result of the addition, which then is used in all others. No need to repeat yourself then.\n. If you update the hardware time with this setup, you would just have to overwrite that memorylocation where the hardwaretime is saved in the firstplace with 0. Then all time functions would update automagically.\n. Please note that this would assume that the RTC interrupt only happens once per second, if an application needs a different interval and wants to use the RTC for that, the whole thing would break.\n. I think that is something that should be asked on some go-forums or mailinglists as it is not a feauture of an OS to run a language but a feature of a language to run on an OS, IMO.\nBut it would be nice to share your findings.\n. I think calling the command line is a very bad idea.\nFirst of all, call is meant for code that does actually return.\nThis does not return so we should probably use jmp.\nI will look into that.\u2026\n. ### programs are functions\n/os/cli.asm on line 78 calls the program too.\nSo we need to return to that piece of code.\nsolutions\nsimple returning\nAll we need to do that:\n1. we need the stackpointer to be exactly what it was when the program started execution\n2. then we need to place a ret statement there\nThis is (or should be) what happens after the program finished execution.\nThe problem is that the program need not have finished executing, so we needed some sort of bootstrapping.\nrebooting\nThe easiest solution (and probably the most safe one) would be to reboot the whole operating system. Note that I am talking about the OS, not the computer. The OS would need to disable all processors, it's stack and a few other things and jmp back to kernel_start.\nresetting one processor\nAs mentioned above, we have multiple processors.\nIf we look at /os/kernel64.asm on line 72, we see this comment:\n\nAll cores start here on first start-up and after an exception\n\nWhat does that mean?\nWe are working in a multithreaded environment, that means, if we call exit we either want to stop the whole program (which, in a single-process OS would lead to, more or less, rebooting the OS so, see above) or we want to exit our current thread.\nExiting our thread works by simply resetting it's stack and waiting for a new workload.\nUnfortunately this is exactly what happens in ap_clear (see the above links).\nSo in this scenario, the whole thread would just stop and opt out of existence.\nJust blame the programmers if they forget to unlock mutexes.\nwhat do we really want\nAs far as I know, newlib is trying to provide the same functionality (or at least a subset) as the standard C library. Please correct me if I am wrong.\nIf, in C, the exit(0) is called, it exit's the whole program.\nTo reproduce this the newlib would need to reset the whole OS (or at least some parts of it) as pointed out above. This would also fix #50.\nAlso it would be useful to have a syscall/function or something to exit the current thread (if that isn't yet implemented).\n. It exit() really resets all processors then the ret will never get executed. It will only have an effect if your custom programs main function returns.\n. Also, please keep in mind that we have multiple processors (or at least\nthreads) which are not just going to stop it one of them does.\nOne solution would be, to let them a l get an exception.\nThen there would only be left the reset of the memory structures (e.g.\nmemory allocations).\nHow about using paging to reset all threads?\nFirst emptying the smp-queue and then unmapping all memory allocated for\nthe program and the user allocated memory would do the trick I think.\n. Is it possible, and if yes, how, to send an interrupt to all processors?\n. Sorry, I wasn't clear enough.\nWhat I meant was:\n\nHow would that look in Assembly code?\n\nI quickly looked around the internet and found this Wikipedia Article but it is a bit short.\nIt would be great if someone of you added some sample code for x86_64 there.\n. @IanSeyler Thanks a lot!\n. You could, just to be sure to have everything cleaned up, do something like this then:\n- clear smp_queue\n- reset all CPU cores, but the calling one\n- clear memory map\n- clear network and RTC callbacks\n- enqueue the CLI\n- reset the calling CPU\n. So, now everything is right. Sorry for the wrong PR.\n. Yes it does.\n. @IanSeyler here, have some inline assembly.\n. I think the shell should be \"outsourced\" in it's own repo where it can\nbe developed as a general purpose app.\nThis has been discussed at #40 and @primoz made some pretty good progress.\nThis would ensure BareMetal stays bare metal.\n. My intent was to have a shell, which is a shell, and a loader, which\nis a loader, both completely indepentently developed.\nSo we would have the kernel being minimalistic.\nThe kernel could be configured to start the loader.\nThe loader would prepare an environment capable of running multiple independent programs, by for example exposing functionality to load programs.\nThese programs could be either drivers or applications.\nThe loader would start an unix-like init (or whatever you specified),\nwhich then starts the shell.\nBut that's only one possibility.\n. @scherrey Sorry for making that ambiguous.\nI edited that comment.\n. We can already load an executable. Only a binary, but an executable one.\nSo if someone make a program called \"loader\" that reads some e.g. elf file, parses and loads it (via paging so multiple instances can be run simultaneous) and provides that functionality to the program it just loaded, the underlying program could set up a fully working environment with process isolation and the usual stuff while keeping the kernel a simple exokernel.\n. ",
    "ohnx": "I feel like its more of a sort of ongoing thing.\n. One other option is to use ELF and just load the application whereever ;)\n. One possible (but probably horrible) solution would be to call the command line in exit()...\n. would the ret assembly call do anything in this case?\n. Well, could another possible solution be to call the kernel again?\nie, jump to the start of the os and let everything re-initialize\n. but that's rebooting, which is different from resetting.\n. loop through all processors?\n. yeah, most of us here are using Unix/Linux (Mac OS is Unix) when contributing to code, so LF is probably the way to go.\n. doesn't the newline print anyways because you hit ENTER?\n. interesting...\nWhenever I run commands in the console/shell, a newline is printed...\n. I believe this has changed in the other version of BareMetal OS here.\n. They are in docs/\n. https://github.com/ReturnInfinity/BareMetal-OS/tree/master/docs\nLICENSE.TXT\nCREDITS.TXT\n. However, I fell like this loader should not be a part of the OS, but instead a program that you can run.\n. I've actually started working on what was described in #40 here, you can take a look if you want. \n. yeah, copyrights can be rather annoying to keep up to date when there's a bunch of files.\n. This commit appears to do very little.\n. Ah, okay.\n. Nice job, that's a lot of files to keep track of.\n. @Konard Making BareMetal-OS a modular OS, where you could select extra features to suit your needs, is an interesting idea.\n. @Konard BareMetal-kernel is most up-to-date, but lacks many of the features present in BareMetal-OS. However, most of the big changes in the kernel are also committed to this repository.\n. I just thought I'd mention that 2016 is in around a month.\n. including a bootloader (so it's not just the OS)\n. Hi there!\nI'm working on compiling the program right now, but I'm having some issues :stuck_out_tongue_closed_eyes: \nI'll get back to you once I can confirm - but this program does compile.\n. It works, but it actually seems to be a bit slower than the current version (not sure since I just tested it by hand, I didn't actually time it).\nAlso, maybe you should try squashing your commits so that there aren't 10 1-line changes :smile: (@IanSeyler can also use this)\n. I think the idea is that you typically want to use these scripts to build BareMetal-OS.\nWhere does the README say to use autoconf -fi? I can't seem to find that.\n. I think you should be running autoreconf -fi, and not autoconf -fi. autoreconf automatically calls aclocal, autoheader, and those other commands.\n. ",
    "ankitCoreProgrammer": "Will this be Ok if we allocate the pages based on Present flag at the place of os_MemoryMap??\nHere it will be required to pre-allocate the pages of IDT and page-fault handler code. \nAnd afterwords we can allocate pages on page-fault. \nFor initial implementations this to implement, we can try the already loaded pages as not present by marking the page-flags in pagetables(PDE's) to not present(demand paging)[i have already tried the page-fault handler working fine for Pure64, and exact pages need to identity which should be kept pre-allocated for BareMetalOS(like for new IDT, SMP..)]. \nCan work on loading pages from disk later on(which ideally required.) by taking the file-sector number and offset-sector into it to be linked to particular PDE entry.\n. ",
    "CtrlC-Root": "I'd like to take a stab at this. Should the CLI only use the OS API or can it depend on newlib? It's obviously doable either way (ex: assembly version only uses OS API) but if we can use newlib that might cut down on code duplication.\n. So I've made some progress, you can see what I have so far in my master branch here: https://github.com/CtrlC-Root/BareMetal-OS/blob/master/programs/shell/shell.c. However, I think I may have run into a slight problem. The current CLI is part of the kernel but my shell program is already loaded at 0x200000 (I think this is correct). How am I supposed to load a different program into memory? I take it you can't simply pick a different location without fixing the program's instructions, right?\nAlso, while the current interface for managing (argc, argv) is acceptable, we may want to consider beefing it up or improving it a bit. It won't increase the code size by much but it will make starting other applications much easier.\n. I've thought about this a bit and I can see the following options. 1) We compile the shell application with a different base address. We modify the CLI code to look for and launch the shell.app application if it's there. The shell can then load and run other applications at 0x200000. 2) We implement a loader in the kernel that can relocate applications. 3) The shell relocates programs as they are loaded into memory.\nMy assembly and knowledge of operating systems is a little lacking, so I may have misunderstood the problem or missed an obvious solution. In any case, this is your project, so I'll leave the decision up to you. Personally I think (2) is the best choice. I know this isn't a general purpose OS and it would take some effort to implement, but it would be pretty useful for more than just the shell. If it's easy to load and run applications (maybe an execvpe equivalent?) then larger problems could be split up into several different applications that run/call each other. Otherwise (1) seems the most reasonable. The OS will need some way to start a default application anyways. It may as well be the shell and we can load it somewhere other than 0x200000 while we're at it. Just my 2 cents.\n. I'm willing to agree on limiting it to the OS API on principle but compiling and using newlib is really not that difficult. I'm actually almost done setting up the waf build system to do it automatically (for me; might do a pull request down the line). Also, I would say that even if it remains a single user system (as it should, it's for computation after all) there are still benefits to moving the CLI into a separate shell application. 1) More room in the kernel for more important features. 2) Not everyone will want/need to use the shell in production (ex: me) nor will it always be running.\nStill, none of this matters if we don't have the ability to load and run arbitrary programs.\n. Well, whenever you reach a decision, I would be more than happy to help implement this issue (and probably more in the future). I'm using BareMetal OS as the basis of one of my projects and want to help make it better in any way I can.\n. @primoze I haven't touched it since my last comment. The issue isn't that we can't move the CLI out of the kernel. I see I've deleted by branch but I had a solution for that as well. The actual issue, as best as I can remember it, was that there is no way to run more than one process at a time outside of the kernel. Yes, we could have some mechanism where when all processes are done we look for a file or a specially named application and run that. I feel like that's a bit of a hack but I wanted to get the author's  opinion on it.\nEDIT: And as you can see three comments above the author @IanSeyler said he would think on it.\n. @primoze A related issue I just remembered is that many of the facilities used by the CLI such as argc and argv are hard-coded in such a way that make it difficult to use them with more than one process.\n. ",
    "davidtsulaia": "If this system is to become a multiuser one at some point in history, then the CLI should be initiated by user log in and just malloced instead of statically loading into specific address. The \"default app\" mentioned above should be log in session manager of some sorts, with or without netwotking support. If the system will remain single user one, then I don't see any problem why should the CLI not be a part of the kernel and be what it is now.\nP.S. CLI should be using only OS Kernel API and that's it. This is my opinion. Using sxternal library is extra secutity risk + big PIA at that. This not only my opinion, but my experience as well.\n. If you ask me simplest solution for single user system CLI is to tie the shell program to keyboard interrupt callback. This way shell will not be running all the time. Right now size of kernel is not an issue, because it is extremely small and we live in the century of insane amounts of memory for really low cost and small sizes.\nI have more purist approach than others, it might seem old fashioned, but it has it's own benefits. I like to know the concrete mix I use to build the house and writing OS is really quite like building a house :)\n. ",
    "xieyuheng": "based on my language's interpreter, I can design an user interface for you,\nI can load a program as a FORTH function from BMFS, and call it from my interpreter.\n. Ian have written a great intro about assembly\n  http://ian.seyler.me/easy_x86-64/\nwith a good start point\nyou can also learn assembly by reading other people's code\nand searching for the information you need to understand them\n. bug fixed\nand something to learn from this  ^_^\nthe argument RDX = disk # of readsectors\nshould be setted by the function which calls readsectors\ni.e. in  every loop of os_bmfs_block_read\nbut should not be setted by the function which calls os_bmfs_block_read\ni.e. os_bmfs_file_read\n. ",
    "primoze": "Is anyone currently working on this?\nI played around with the code and came up with a setup like this:\n- instead of executing os_command_line here the code calls os_initproc, which loads a file named initproc from disk and jumps to that location (0x200000)\n- app.ld now links binaries to 0x300000, added initproc.ld which links them to 0x200000\n- initprocc.sh, which is basically appc.sh except it uses initproc.ld  and produces a file named initproc - this way any app can be rebuilt as an initproc\nAnother idea was to have an initproc.confwhich would contain the program name to run on boot (not have it hardcoded), but using 2 megs of disk space for 1 word of text seemed excessive.\nDoes this seem OK, or is it too hacky?\n. ",
    "drmint80": "@CtrlC-Root  \"3) The shell relocates programs as they are loaded into memory.\" really right approach, also we're terminal cli filling into user space in e.g 0x3000 - 0x4000 around memory space. \n. ",
    "tay10r": "I can see two ways of doing this.\nOne way is to compile the applications with a higher base address. The only clean way to load the application is to implement a memory allocation function that specifies an address to allocate the memory, similar to the first parameter in mmap in the POSIX specification.\nThe other way is to implement a function like the execve system call in Linux, which replaces the current process image with another. Although that would probably require more work, you would no longer need to compile the CLI or other applications with different base addresses.\n. @ohnx Using an elf header doesn't solve the problem.\n. Create an empty bmfs.image file and it should work just fine.. If you need to work with the filesystem image, use the BMFS utilities.. Use this to get the utilities:\nsudo apt-add-repository ppa:taylorcholberton/bmfs-utils\nsudo apt update\nsudo apt install bmfs-utils\nThe command bmfs-init can initialize a disk image of a specific size.\nThese other commands may help you:\n\nbmfs-cat\nbmfs-cp\nbmfs-rm\n\nThey all use the file disk.image by default, but you can use the --disk option to change that, or just rename the file.\nThey all support the --help option.. ",
    "hidnplayr": "Go for it! :)\n. ",
    "scherrey": "Are we talking about on-nic memory? Does the driver support this? If so how\nmuch is available?\nI did zero copy security systems in promiscuous mode back in my security\ndays. The cards we used had significant onboard memory which we reviewed in\nplace and decided which data to copy into machine shared memory and which\nto ignore.\nThe call back mechanism that exists should work well for such a design if\nthe memory is as fast or faster than system RAM otherwise it's best just to\ncopy to system shared memory. Just need to ensure that your process talking\nto the nic always has a cpu assigned to it.\n- - Ben\n  On Jul 13, 2015 2:49 PM, \"Katze\" notifications@github.com wrote:\n\nIs the buffer used for more than one packet?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/43#issuecomment-120841007\n.\n. Probably the \"easiest\" thing would actually be to have each executable run\nunder it's own VMX environment and have BareMetal act as a hypervisor. The\nmodel is not unlike the current smp concept except now enforced by the CPU.\nNaturally every VMM would be a root VMM with full access although the first\none would have to negotiate sharing of devices. I think the only overhead\ninvolved would be when sensitive instructions are intercepted and memory\npages come in and out needing remapping. Avoiding such instructions and\nmapping larger pages should make the performance impact too small to be\nmeasured. I've not looked at whether there's an impact on memory mapping in\nflat mode for VMM or not. I would suggest some range of memory be globally\nmapped to support sharing amongst processors and the rest be treated as\nprivate memory to the local VMM. In this manner each application would\neffectively have control of the entire computer but could still co-exist\nwith other apps who (preferably) have their own dedicated cores.\n\nThis probably isn't much more difficult than supporting elf or other\nrelocatable systems and offers a great deal more power and flexibility.\n-- Ben\nOn Wed, Jul 8, 2015 at 2:32 AM, Mason X notifications@github.com wrote:\n\nI agree with this. +1.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/98#issuecomment-119310789\n.\n. So the intent is for the shell should provide a relocatable loader? Elf or\nsome kind of special parsing?\n\n-- Ben\nOn Fri, Jul 10, 2015 at 5:53 PM, Katze notifications@github.com wrote:\n\nI think the shell should be \"outsourced\" in it's own repo where it can\nbe developed as a general purpose app.\nThis has been discussed at #40 and @primoz made some pretty good progress.\nThis would ensure BareMetal stays bare metal.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/98#issuecomment-120382091\n.\n. The thread started out as a discussion for how to handle multiple apps\nloaded at once. I'm not sure how you're defining your choice of words but\nmulti-tasking, to me, generally implies multithreading (more than one\nthread of execution on a cpu probably exclusive of hyper threading) whereas\nmultiprocessing would mean supporting as many processes as there are\navailable cpus (hyper threading potentially included). I'm not sure which\none you're suggesting. Outside of this - the level of isolation that is\nintended is another key point. The word's ambiguous enough to cover both\nbut I don't think the multi-processing meaning is common usage for\nmulti-tasking.\n\nMy thoughts so far, that would keep the kernel minimalistic but capable of\nfully utilizing the CPU(s), would be either go with a VTX style isolation\namongst one or more CPUs per VMM enforced by the chip set (possibly with a\nshared memory map for IPC) , or require applications to be written in a\nrelocatable format and everything goes into a big single memory space but\nCPUs are assigned to apps and concurrency is likely limited to however\nnumber of logical cores are available. The former seems like the next\nlogical \"level up\" step of BareOS but I'm not sure if there's an intent to\never go that far. The latter is the ultimate flat model and pushes most of\nthe effort over to the loader/software development tools which could\npossibly add friction for software development. If we're really serious\nabout the exokernel model then we could do the latter at first and offer\nanother kernel module that adds the VTX option later with probably little\nimpact to the relocatable loader option (although it may obsolete it for\nmany use cases).\nCare to clarify which intent (or some other) you have in this regard? I\npresume the latter but it's still not clear to me. I'd be very curious to\nhear what everyone elses' thoughts are regarding this, especially Ian's.\n-- Ben\nOn Fri, Jul 10, 2015 at 6:15 PM, Katze notifications@github.com wrote:\n\nMy intent was to have a shell, which is a shell, and a loader, which\nis a loader, both completely indepentently developed.\nSo we would have the kernel being minimalistic.\nThe kernel could be configured to start the loader.\nThe loader would initialize the multi-tasking.\nThe loader would start an unix-like init (or whatever you specified),\nwhich then starts the shell.\nBut that's only one possibility.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/98#issuecomment-120387246\n.\n. Major hurdle is you rewrite everything from scratch. :-)\n- - Ben\n  On Feb 10, 2016 11:12 AM, \"iceblu3710\" notifications@github.com wrote:\nYou mentioned \"I'd also like to write a version for 64-bit ARM\", have you\nmade any progress on this yet? I am interested in running a cluster of\nOdroid-XU4's.\nWhat is the major hurdle in porting to Arm's 64bit ASM from X86_64?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/110.\n. The CPU architecture is completely different. You can't reason about your\nsoftware and CPU state in the same way across the two CPU architectures. I\nthink the only similarities is that they are both large register-based CPUs\n(as opposed to something a bit more esoteric like a stack-based\narchitecture) and have some overlapping memory access methods. Would really\nbe an entirely independent project.\n\n-- Ben\nOn Sat, Feb 13, 2016 at 1:08 AM, iceblu3710 notifications@github.com\nwrote:\n\nWell obviously, but other than that its totally a weekend project right?\nlol\nWhat is the major difference between the languages, are their major x86\ninstructions that ASM does not have so those routines would need to be\ncompletely re-written?\nI imagine if they share 80% of similar instructions the majority of the\nwork could be mapping.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/110#issuecomment-183434251\n.\n. \n",
    "vilhelmgray": "The standard C exit function provided by newlib calls the _exit function defined in the syscalls.c file. Currently, the BareMetal syscalls.c _exit function is defined as follows:\nC\n// exit -- Exit a program without cleaning up files\nint _exit(int val)\n{\n        exit(val);\n        return (-1);\n}\nThe call to the standard C exit function creates an infinite recursion which I believe leads to the crash.\nThis _exit function should be reimplemented to use an appropriate BareMetal system call in order to \"exit the program without cleaning up files.\" Furthermore, the _exit function prototype's return type is void so the function should not return a value.\n. Actually, since the description of the _exit function explicitly states that the program should not clean up files, simply calling the command line in the _exit function would provide the behavior we expect in a monotasking operating system like BareMetal: the running program exits immediately to the command line, thus allowing the next program to run.\nNote that this would be a minimal implementation that should be improved in the future: most users expect operating systems to clean up files for them on a standard C _Exit call; however, the minimal implementation will at least solve the crash and make the function usable.\nRefer to section 7.20.4.4 of the C99 standard for more information on the standard C requirements of the _Exit function (of which the newlib _exit function is essentially an alias).\n. I'm not sure if this will compile, but it should be close to the general solution for a minimal implementation (note the void return type):\nC\n// exit -- Exit a program without cleaning up files\nvoid _exit(int val)\n{\n        asm volatile (\"call os_command_line\");\n}\nThe os_command_line routine is in the cli.asm file, but since it wasn't aligned in the kernel_start routine in the kernel64.asm file like the other system calls, I'm not sure if that inline assembly I added will work -- I'm not familiar enough with the code.\n. I'm not certain, but Newlib may already provide a default minimal implementation of environ, which would make this pull request moot.\n. Ah yes, os_system_misc would have be a far more apt place to put those routines.\nBy the way, I suspect a naive solution to break down the process time between user time and system time may be rather quick to code. One solution I've thought of is to use an additional sysvar variable to keep track of system time: current time is saved at the start of a syscall, then elapsed time is added to the respective sysvar variable at the end of syscall. The sysvar variable would accumulate the total system time, while the total user time can be computed by subtracting total system time from the total elapsed process time.\n. The C standard leaves the granularity of clock_t up to the implementation; but the existence of CLOCKS_PER_SECOND does imply an update frequency of at least 1 Hz.\nStill, however, 8 Hz is a rather slow frequency for CPU clock counter in general. A good future milestone to consider would be to reimplement the updates using the APIC timer so that the frequency can be much higher.\n. I discovered another option available which I would like to share: the Time Stamp Counter (TSC). Modern Intel processors feature a built-in clock counter which may be read via the RDTSC instruction. For example, to grab the current TSC value for the current CPU and return it in register RAX, you could do something like this:\nassembly\npush rdx\nrdtsc\nshl rdx, 32\nor rax, rdx\npop rdx\nNote that the RDTSC instruction loads the high-order 32 bits in RDX while the low-order 32 bits are loaded in RAX.\nWhile historically the TSC was unreliable and variable, modern 64-bit Intel processors have an invariant TSC in each which counts monotonically and is automatically reset to 0 when the respective core is reset. Since the counts are automatically maintained by the CPU, we don't need to use a timer IRQ to keep track of time.\n. Two caveats to keep in mind when working with the Intel processors' RTCs: RDTSC is not a serializing instruction (i.e. it may read the counter out of order), and the TSC value on each core is independent. Therefore, it's recommended to use the RDTSCP instruction instead, which is a serializing instruction and also loads the CPUID in register ECX as well to identify which TSC was grabbed.\n. ",
    "OffensiveCheese": "Pull #124 could solve this. ",
    "Terra854": "NASM version 2.08.01 compiled on Mar 10 2010\n. ",
    "wandernauta": "I would be very surprised if @IanSeyler didn't know about Menuet (see here for example).\n. To quote the README 'BareMetal is a 64-bit OS for x86-64 based computers'. BareMetal is written in x86 assembly, which is quite by definition non-portable to other architectures. You could rewrite it for ARM machines, but it would be a different OS.\nSo, probably not :)\n. ",
    "XVilka": "@IanSeyler No, Cortex A8 is still arm7, even cortex a15 is still arm7. ARM v8 - completely different architecture, have no real implementations.\n. ",
    "benjaminsavoy": "Not very groundbreaking work, but I wanted to get a test environment running, and learn some more about how the OS works. Hope the enhancements help!\nAlso, I noticed that memory allocation returned something in RCX, which is probably not necessary as RAX is already set to 0 on error, so I marked it as deprecated until it (maybe) gets removed?\n. ",
    "tomberek": "Thanks. btw: any update on parallax?\n. ",
    "zenware": ":+1:\n. ",
    "Pastor": "-1 for go support\n. ",
    "metakeule": "Ok, to be more specific:\nIt would be nice to check, if support for Go would be possible at all (i.e. if BareMetalOS supports everything, the Go runtime needs or if the BareMetalOS developers were willing to add the missing features).\n. @d2alphame correct. So the question remains if it will (or does already) support what\nis needed for the Go runtime (!= everything). Once there was some code supporting to run Go on bare metal (i.e. as operating system) but that code has not been maintained and is no longer compatible with the current Go runtime.\n. ",
    "d2alphame": "If BareMetal supported everything, it would be headed for the \"bloat ware\" status.\n. ",
    "iandeimster": "+1 Would love to use Golang on this.\n. ",
    "yui-konnu": "-1\nThis project should be kept minimal.\n. ",
    "techtonik": "This will also require changing description on https://github.com/ReturnInfinity/BareMetal-OS\n. I'd say that I don't know it much.\nFrom this mail http://comments.gmane.org/gmane.comp.lang.rust.devel/10876 there is a link to http://www.ntecs.de/blog/2014/07/29/rust-ported-to-dragonflybsd/ which says that The Rust libraries (e.g. liballoc, liblibc, libstd, libnative) need to be ported.. I am not sure at which level Rust accesses STDIN/STDOUT and how are they wrapped there.\nThe calling convention / mechanism for this OS is here https://github.com/ReturnInfinity/BareMetal-OS/blob/master/docs/BareMetal%20OS%20-%20API.md#b_output so I guess that the code generator for Rust should be modified to support this call if BareMetal OS is the target. http://www.slideshare.net/thomaslee/rust-march2014-32891901\n. Just for the reference, an example of Rust application is in 740d2b23 along with some comments.\n. ",
    "mntmn": "Cool, that was fast! I just merged your fix locally and can now use networking with an unpatched QEMU. So it seems to work, thank you very much!\n. Sure:\nqemu-system-x86_64 -monitor stdio -vga std -smp 2 -m 256 -device ahci,id=ahci -drive id=disk,file=bmfs.image,if=none -device ide-drive,drive=disk,bus=ahci.0 -name \"BareMetal OS\" -netdev bridge,id=net0  -device e1000-82544gc,netdev=net0,mac=52:54:de:ad:be:ef,id=nd0\n. ",
    "AaronM04": "Wait, this still doesn't make sense. Based on the \"equ\" statements, there are only 4096 bytes for each of those two tables. Nice try :)\n. How about changing it to 0x070000 -> 0x070FFF ? Then the comments can be internally consistent and correct, lol\n. Ah good point, I shouldn't have assumed the code was correct :)\n. ",
    "8l": "and here is yet another cpu, it also looks promising\ndifferent design, but implemented in chisel.\nhttp://www.rexcomputing.com/\nhttp://www.theplatform.net/2015/07/22/supercomputer-chip-startup-scores-funding-darpa-contract/\n. ",
    "Lidenburg": "It does indeed do very little, I wanted to see how doing a pull request works first before I touch something vital\n. ",
    "effbiae": "Maybe, as with another famous kernel, a config file (optionally generated\nby a menu system) can choose to include or exclude code.\nThe code might be best kept in one repo or optionally got from another\nrepo. (Hybrid system).\nI'm almost at the point of switching to BM but being able to map disk\nblocks into an address space is important for me.\nJack\nOn Thursday, December 31, 2015, Konstantin Dyachenko \nnotifications@github.com wrote:\n\nMay be it is a good idea to make memory mapping as a \"plugin\"? So the\ndeveloper can deside how to optimize caching?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/105#issuecomment-168082673\n.\n. i got curious on this question of multiple cmps vs lookup table.\n\ni found that cmps win for rdx<7 and then lookup win for the rest.  funny -\ni remember back in school, a lecturer said it's faster to do linear search\non n<=7 - i wonder if it's still true.\nhere's the gas code i used on linux - you can call  lookup() and cmps()\n$ cat j.s\n.intel_syntax noprefix\n.globl cmps,lookup\n.data\na:;b:;c:;d:;e:;f:;g:;h:;i:;j:;k:;l:;\nret\ncmps:\ncmp rdi,0\nje a\ncmp rdi,1\nje b\ncmp rdi,2\nje c\ncmp rdi,3\nje d\ncmp rdi,4\nje e\ncmp rdi,5\nje f\ncmp rdi,6\nje g\ncmp rdi,7\nje h\ncmp rdi,22\nje i\ncmp rdi,23\nje j\ncmp rdi,24\nje k\ncmp rdi,31\nje l\nret\n.data;.align 8\nfuns:\n.quad a,b,c,d,e,f,g,h,z,z,z,z,z,z,z,z,z,z,z,z,z,z,i,j,k,z,z,z,z,z,z,l,z\nlookup:\njmp qword [funs+rdi*8]\n z:\nret\nOn 7 October 2016 at 20:44, Faissal Bensefia notifications@github.com\nwrote:\n\nInstead of doing stuff like:\nos_system_config:\n    cmp rdx, 0\n    je os_system_config_timecounter\n    cmp rdx, 1\n    je os_system_config_argc\n    cmp rdx, 2\n    je os_system_config_argv\n    cmp rdx, 3\n    je os_system_config_networkcallback_get\n    cmp rdx, 4\n    je os_system_config_networkcallback_set\n    cmp rdx, 5\n    je os_system_config_clockcallback_get\n    cmp rdx, 6\n    je os_system_config_clockcallback_set\n    cmp rdx, 20\n    je os_system_config_video_base\n    cmp rdx, 21\n    je os_system_config_video_x\n    cmp rdx, 22\n    je os_system_config_video_y\n    cmp rdx, 23\n    je os_system_config_video_bpp\n    cmp rdx, 30\n    je os_system_config_mac\n    ret\nYou could do:\nos_system_functions dq   os_system_config_timecounter, os_system_config_argc, os_system_config_argv, os_system_config_networkcallback_get, os_system_config_networkcallback_set, os_system_config_clockcallback_get, os_system_config_clockcallback_get, os_system_config_clockcallback_set, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_video_x, os_system_config_video_y, os_system_config_video_bpp, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_no_function, os_system_config_mac\nos_system_config:\n    jmp qword [os_system_functions+rdx*4]\n    os_system_config_no_function:\n    ret\nAnd I believe it would be much faster, I also believe this is what GCC\ndoes (or at least, something similar) for switch statements.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/117, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AAn-H3ioEg_aDGf2VmRNt1Oy2zm_YLdBks5qxhSKgaJpZM4KQ2f6\n.\n. if you're interested in seeing how gcc optimizes a small function:\n\n$ cat t.c && for x in O2 Os; do (gcc -$x -c t.c && objdump -d -Mintel t.o\n|sed -ne '/._/,/^$/p');done\nint main(long c, char__v)\n{\n  long i,r=0;\n  while(c--)\n  {\n    if(v[c]!=0)\n      r+=(long)v[c];\n    if(c==0)\n      break;\n  }\n  return r;\n}\n0000000000000000 :\n   0: 31 c0                 xor    eax,eax\n   2: 48 85 ff             test   rdi,rdi\n   5: 75 02                 jne    9 \n   7: f3 c3                 repz ret\n   9: 48 03 44 fe f8       add    rax,QWORD PTR [rsi+rdi_8-0x8]\n   e: 48 83 ef 01           sub    rdi,0x1\n  12: 74 f3                 je     7 \n  14: 48 03 44 fe f8       add    rax,QWORD PTR [rsi+rdi_8-0x8]\n  19: 48 83 ef 01           sub    rdi,0x1\n  1d: 75 ea                 jne    9 \n  1f: eb e6                 jmp    7 \n0000000000000000 :\n   0: 31 c0                 xor    eax,eax\n   2: 48 85 ff             test   rdi,rdi\n   5: 74 0a                 je     11 \n   7: 48 03 44 fe f8       add    rax,QWORD PTR [rsi+rdi_8-0x8]\n   c: 48 ff cf             dec    rdi\n   f: eb f4                 jmp    5 \n  11: c3                   ret\n- use xor instead of mov x,0\n- use test instead of cmp x,0\n- for smaller code, use dec x otherwise sub x,1 for speed\nOn 12 October 2016 at 04:44, Ian Seyler notifications@github.com wrote:\n\nI had a reason for this back when initially writing this code as I came\nacross something that said inc/dec should not be used in x86-64. I can't\nrecall where I saw this but this would cut down on compiled code size.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/pull/118#issuecomment-252990778,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAn-H9vOG_b_IeJFivYQDtbW5wB6xszWks5qy8sBgaJpZM4KRb2J\n.\n. \n",
    "iceblu3710": "Well obviously, but other than that its totally a weekend project right? lol\nWhat is the major difference between the languages, are their major x86 instructions that ASM does not have so those routines would need to be completely re-written?\nI imagine if they share 80% of similar instructions the majority of the work could be mapping.\n. ",
    "hikilaka": "The instructions are very different.\n. ",
    "nbrecht01": "Sorry for taking so long to answer!\nYes, the drive was BMFS formatted.\nHardware:\n         AMD Athalon 64\n         M3A78-CM Motrherboard\nThe kernel boots fine, but the disk size is 0B and none of my apps will show up with the 'dir' command.\n. ",
    "Kagre": "sorry still a bit new to the community, is it still possible to squash these via the website now that i've done a pull request? or do i need to check them out again to another branch squash them via commandline and redo the request?\nalso note the multi-threaded version is likely to be slower overall, because the original skipped over the processes==3 step. but it seems odd to me that the updated algo runs slower since it reduces the loop count by roughly a half...\n. ",
    "faissaloo": "No problem, glad to help!\n. ",
    "fcnn": "I added some code in the pure64 boot loader to load elf kernel. the kernel is then compiled using:\nnasm -felf64 -o kernel64.o kernel64.asm\nld -T kernel.ld -o kernel64.sys kernel64.o\nstrip kernel64.sys\nof course also added entry point declaration and removed the ORG instruction.\nnow after some debugging, it seemed that mmu was not functioning properly. because the instruction,\ncall 0x200000\nwhen in runtime, will actually becomes something like,\ncall 0x30af....                  ; the address had automatically changed to 3M+\ni saw that through qemu monitor window. i can't see any reason to cause such issue.\n. ",
    "Eshmundev": "thanks for your help, I check it, especially the bmfs utils, That you are\nwell !.\n2017-06-21 14:05 GMT-05:00 Taylor Holberton notifications@github.com:\n\nUse this to get the utilities:\nsudo apt-add-repository ppa:taylorcholberton/bmfs-utils\nsudo apt update\nsudo apt install bmfs-utils\nThe command bmfs-init can initialize a disk image of a specific size.\nThese other commands may help you:\n\nbmfs-cat\nbmfs-cp\nbmfs-rm\n\nThey all use the file disk.image by default, but you can use the --disk\noption to change that, or just rename the file.\nThey all support the --help option.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReturnInfinity/BareMetal-OS/issues/125#issuecomment-310175308,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/Ab-YHYRLN53tsL1Rr_xVPd7N-jH_VA96ks5sGWlpgaJpZM4OBUuO\n.\n. \n",
    "mrm1ck": "I was going to say try master or original as I have my apps all modified for running multi system and in a sparatic output . git@gitlab.com:mmmickmason2/ether-way.git. git@gitlab.com:mmmickmason2/ethereum.git. git@gitlab.com:mmmickmason2/MRet.git. https://gist.github.com/mrm1ck/c2f87fa48ad67ce2d7bdb02e6b1913d5. git@gitlab.com:mmmickmason2/ether-router-master.git. "
}