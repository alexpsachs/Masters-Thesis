{
    "joeybloggs": "Will add new validators ltfield, ltefield, gtfield and gtefield, was originally going to add functionality to lt, lte, gt, and gte, which is possible, but the overhead of all of the type and fallback checks it will be much more efficient to add the new validators\n. Tested with the exact dates provided and validation is working as expected.\n. thanks I can't believe I missed that.\n. I'm nowhere near my dev machine and will merge into v4 as soon as I can\n. It looks great! I think I will merge it, I can update the unit test if it's too much trouble.\nI do have one request though, if you could make the pull request against the v4-development branch instead of v4 directly; I would also like to update a few issues I found in my documentation before merging into v4.\nThanks!\n. changes merge!\n. added\n. I will merge and modify the couple of changes I had noted.\n. adding hasRune as well to mach golang contains string params\n. modified to use contains, containsany and containsrune\nand added excludes, excludesall and excludesrune\n. I agree this makes sense for logging, I will remove the line breaks.\nI do however feel the need to point out that, like the documentation states, these errors are intended for debugging and not production error messages.\nFor example the end user would probably want to see the error\n\nEmail is required\n\nInstead of\n\nField validation for \"Email\" failed on the \"required\" tag\n. I am working on this and a few other things and should be completed within the next few hours.\n\nthe fix removes the extra 3 \\n's \n. thanks @manucorporat \nI'll take a look\n. OK I believe this is all setup now.\nIf you could please confirm, then I'll close this issue.\n. @pavlik thanks for the interest!\n. after looking into a little bit, caching will need to be automatic, because of the code changes needed for it cause the program to slow down.\n. Drastically improved time, B/op and memory allocations\n``` go\nOriginal Benchmarks\n$ go test -bench=. -benchmem=true\nPASS\nBenchmarkValidateField   2000000           651 ns/op         176 B/op          5 allocs/op\nBenchmarkValidateStruct   200000          6274 ns/op        1584 B/op         37 allocs/op\nOptimized No Cache Benchmarks\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             3000000           473 ns/op          80 B/op          4 allocs/op\nBenchmarkValidateStructSimple-4       300000          5010 ns/op        1200 B/op         33 allocs/op\nBenchmarkTemplateParallelSimple-4    1000000          2185 ns/op        1200 B/op         33 allocs/op\nBenchmarkValidateStructLarge-4         50000         28706 ns/op        6980 B/op        201 allocs/op\nBenchmarkTemplateParallelLarge-4      200000         14362 ns/op        6983 B/op        201 allocs/op\nOptimized Cached Benchmarks\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             5000000           333 ns/op          16 B/op          1 allocs/op\nBenchmarkValidateStructSimple-4       500000          2597 ns/op         752 B/op         13 allocs/op\nBenchmarkTemplateParallelSimple-4    1000000          1138 ns/op         753 B/op         13 allocs/op\nBenchmarkValidateStructLarge-4        100000         14663 ns/op        4806 B/op         78 allocs/op\nBenchmarkTemplateParallelLarge-4      200000          7112 ns/op        4810 B/op         78 allocs/op\n. only StructErrors can be reused with the updated code structure\n. go\nOld Benchmarks\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             5000000           333 ns/op          16 B/op          1 allocs/op\nBenchmarkValidateStructSimple-4       500000          2597 ns/op         752 B/op         13 allocs/op\nBenchmarkTemplateParallelSimple-4    1000000          1138 ns/op         753 B/op         13 allocs/op\nBenchmarkValidateStructLarge-4        100000         14663 ns/op        4806 B/op         78 allocs/op\nBenchmarkTemplateParallelLarge-4      200000          7112 ns/op        4810 B/op         78 allocs/op\nNew Benchmarks\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             5000000           318 ns/op          16 B/op          1 allocs/op\nBenchmarkValidateStructSimple-4       500000          2471 ns/op         624 B/op         10 allocs/op\nBenchmarkTemplateParallelSimple-4    2000000           975 ns/op         624 B/op         10 allocs/op\nBenchmarkValidateStructLarge-4        100000         13979 ns/op        4293 B/op         66 allocs/op\nBenchmarkTemplateParallelLarge-4      200000          5947 ns/op        4298 B/op         66 allocs/op\n```\n. changes implemented, changes will be in next release\n. also add a github project page\n. ## Ok v6 Benchmarks ( old v5 thrown in for comparison )\nOld v5 no caching\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             3000000           473 ns/op          80 B/op          4 allocs/op\nBenchmarkValidateStructSimple-4       300000          5010 ns/op        1200 B/op         33 allocs/op\nBenchmarkTemplateParallelSimple-4    1000000          2185 ns/op        1200 B/op         33 allocs/op\nBenchmarkValidateStructLarge-4         50000         28706 ns/op        6980 B/op        201 allocs/op\nBenchmarkTemplateParallelLarge-4      200000         14362 ns/op        6983 B/op        201 allocs/op\nNew v6 no caching\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkField-4                     3000000           524 ns/op         128 B/op          5 allocs/op\nBenchmarkFieldOrTag-4                 500000          2808 ns/op         180 B/op          7 allocs/op\nBenchmarkStructSimple-4               300000          4246 ns/op        1016 B/op         31 allocs/op\nBenchmarkStructSimpleParallel-4      1000000          1537 ns/op        1016 B/op         31 allocs/op\nBenchmarkStructComplex-4              100000         23908 ns/op        5079 B/op        183 allocs/op\nBenchmarkStructComplexParallel-4      200000          8845 ns/op        5081 B/op        183 allocs/op\nSummary\nOverall better performance, lower B/op and less allocations...except for Single Field validations which increased slightly; However to note the new v6 code is vastly simplified, streamlined and more maintainable.\nhow vastly you ask, well the main validator.go file went from 989 to 453 lines enough said.\n. Added just ValidationErros caching, more to come\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkField-4                     3000000           461 ns/op          80 B/op          4 allocs/op\nBenchmarkFieldOrTag-4                 500000          2756 ns/op         132 B/op          6 allocs/op\nBenchmarkStructSimple-4               300000          4362 ns/op         971 B/op         30 allocs/op\nBenchmarkStructSimpleParallel-4      1000000          1595 ns/op         971 B/op         30 allocs/op\nBenchmarkStructComplex-4               50000         24242 ns/op        5051 B/op        182 allocs/op\nBenchmarkStructComplexParallel-4      200000          8900 ns/op        5050 B/op        182 allocs/op\n. Added back tag parsing caching\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkField-4                     5000000           321 ns/op          16 B/op          1 allocs/op\nBenchmarkFieldOrTag-4                 500000          2566 ns/op          20 B/op          2 allocs/op\nBenchmarkStructSimple-4               500000          3233 ns/op         553 B/op         14 allocs/op\nBenchmarkStructSimpleParallel-4      1000000          1182 ns/op         554 B/op         14 allocs/op\nBenchmarkStructComplex-4              100000         19979 ns/op        3234 B/op        102 allocs/op\nBenchmarkStructComplexParallel-4      200000          7083 ns/op        3235 B/op        102 allocs/op\n. Added back struct caching, but now am torn...although it helps with B/ap and allocs/op for struct validation it absolutely kills parallel ns/op..just compare with above.\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkField-4                     5000000           316 ns/op          16 B/op          1 allocs/op\nBenchmarkFieldOrTag-4                 500000          2466 ns/op          20 B/op          2 allocs/op\nBenchmarkStructSimple-4               500000          3079 ns/op         513 B/op         10 allocs/op\nBenchmarkStructSimpleParallel-4       500000          3229 ns/op         514 B/op         10 allocs/op\nBenchmarkStructComplex-4              100000         17365 ns/op        2943 B/op         66 allocs/op\nBenchmarkStructComplexParallel-4      100000         13958 ns/op        2946 B/op         66 allocs/op\n. which is more important faster library or less garbage collection, guess I'll have to see how long garbage collection takes, if it's more than the time added to parallel ns/op then it's worth the performance hit as in actuality it would be faster, just the benchmarks wouldn't reflect that.\n. OK so decided to leave struct caching out, speed and scalability is the goal of the library and struct caching slows the speed and scalability and so a few more allocation, IMHO, are not a big deal.\n. v6 is now ready to rock! will be releasing after a few of the major players using the library have had a chance to review.\n@manucorporat if you wanted to take a look as I think it affects your project the most\n. Currently putting through it's paces in an internal project, and will be released soon\n. see documentation for the new \"dive\" tag\nbenchmarks have slightly increased ns/op and B/ops for this functionality and an additional allocation for single field validation.\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             3000000           439 ns/op         192 B/op          2 allocs/op\nBenchmarkValidateStructSimple-4      1000000          2382 ns/op         656 B/op         10 allocs/op\nBenchmarkTemplateParallelSimple-4    2000000           910 ns/op         656 B/op         10 allocs/op\nBenchmarkValidateStructLarge-4        100000         13201 ns/op        4309 B/op         60 allocs/op\nBenchmarkTemplateParallelLarge-4      300000          5240 ns/op        4311 B/op         60 allocs/op\n. from gin issue: https://github.com/gin-gonic/gin/issues/355\nThe validator version is latest 5.9.\nThe code:\n`` go\ntype ExternalCMD struct {\n    Userid stringjson:\"userid\"Action uint32json:\"action\"Data   interface{}json:\"data,omitempty\"`\n}\nfunc kickAction(c *gin.Context) {\n    var ecmd ExternalCMD\n    c.Bind(&ecmd)\nvar user *User\nusers.Lock()\nfor _, tmpuser := range users.m {\n    if tmpuser.mIzmoId == ecmd.Userid {\n        user = tmpuser\n    }\n}\nusers.Unlock()\n\nif user == nil {\n    c.JSON(http.StatusOK, gin.H{\"status\": \"error\", \"message\": \"user not found\"})\n    return\n}\n\nif ecmd.Action == 10000 {\n    user.Disconnect()\n}\n\nc.JSON(http.StatusOK, gin.H{\"status\": \"ok\"})\n\n}\nv1.POST(\"/kick\", kickAction)\n```\nThe POST Payload: {\"userid\":\"123456\", \"action\":10000}\n. quick update, it looks like I have a bug handling type interface.\nthe error stack trace you provided, suggests a different issue, I suspect that the real error was recovered from within gin, and because of that the cache within the validator plugin got out of sync and caused the issues your having now.\nI will refactor the code not to store the cached data until all fields have been processed successfully, so the cache cannot get out of sync. and I will address the interface issue within validator.\nI should be able to fix this within a day.\n. newest benchmarks\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkValidateField-4             3000000           434 ns/op         192 B/op          2 allocs/op\nBenchmarkValidateStructSimple-4       500000          2760 ns/op         656 B/op         10 allocs/op\nBenchmarkTemplateParallelSimple-4     500000          3607 ns/op         656 B/op         10 allocs/op\nBenchmarkValidateStructLarge-4        100000         14671 ns/op        4341 B/op         62 allocs/op\nBenchmarkTemplateParallelLarge-4      100000         15787 ns/op        4344 B/op         62 allocs/op\n. I will look into it, thanks!\n. it helps with parallel benchmarks a bit and slightly increases the non parallel ones, but it's negligible.\nsince this library is fully thread safe and I suspect will be used within a webserver or some other logic that will be parallelized this change will help with that.\nso going forward with the change.\n. True,\nok v5.10 is now out, I had to drop support for go 1.2 for this change, but I think that's more than justified.\n. @manucorporat I would definitly be interested in your opinion\n. After a bunch of discussions it has been decided, in v6 I will drop the error hierarchy and just return the field errors. see #74\n. I will take a look at this as tonight\nWhat values were set on MyStruct?\n. thanks @manucorporat I was having trouble making it panic myself, looking into this now.\n. hey @manucorporat I've corrected this issue and have published release 5.10.1\nthe panic was an edge case where the the interface had a value and no validation tag, was a simple fix.\nbased on your comment in the gin issue, I hope you aren't too disappointed with my library because of a couple issues.\nP.S. based on the question in #99 I would love your opinion, if you have time\n. Yes will connect in a minute\n. makes perfect sense I will merge this asap ( most likely this afternoon )\nI will also make the same changes to some other methods like:\nisGt\nisGte\nisLt\nisLte\n... and any others that should also be modified\n. I think I understand what you saying,\nWould you be able to provide a quick code sample and I'll take a look.\nP.S. are you using v5 or v6 of the library?\n~~update: I think your talking about this Value of type interface https://golang.org/src/database/sql/driver/driver.go?s=566:588#L12~~\nupdate oh I see this Valuer https://golang.org/src/database/sql/driver/types.go?s=1210:1293#L29\n. #### Summary\nOK so I did an implementation test for validating a type of Valuer and it all works except, that there is a performance hit and I'm not sure that this type of functionality should be within the library. The library validates data values, not data values from methods, I'm worried about opening a door to allow other interface types, and checking each is expensive, but usually less so in the calling program.\nBenchmarks\nns/op and B/op are ok but struct allocations are up from 30 and 72 to 33 and 75 and that is for all struct tests, regardless if type Valuer is even being used\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkFieldSuccess-4                  5000000           333 ns/op          16 B/op          1 allocs/op\nBenchmarkFieldFailure-4                  5000000           334 ns/op          16 B/op          1 allocs/op\nBenchmarkFieldOrTagSuccess-4              500000          2716 ns/op          20 B/op          2 allocs/op\nBenchmarkFieldOrTagFailure-4             1000000          1357 ns/op         384 B/op          6 allocs/op\nBenchmarkStructSimpleSuccess-4           1000000          1286 ns/op          24 B/op          3 allocs/op\nBenchmarkStructSimpleFailure-4           1000000          1847 ns/op         529 B/op         11 allocs/op\nBenchmarkStructSimpleSuccessParallel-4   5000000           385 ns/op          24 B/op          3 allocs/op\nBenchmarkStructSimpleFailureParallel-4   2000000           816 ns/op         529 B/op         11 allocs/op\nBenchmarkStructComplexSuccess-4           200000          7312 ns/op         416 B/op         33 allocs/op\nBenchmarkStructComplexFailure-4           100000         12253 ns/op        2909 B/op         75 allocs/op\nBenchmarkStructComplexSuccessParallel-4  1000000          2270 ns/op         417 B/op         33 allocs/op\nBenchmarkStructComplexFailureParallel-4   300000          5268 ns/op        2911 B/op         75 allocs/op\nPossible Alternative\nWhy not have a helper function within your code that would check if the value is of type Valuer and have that function call validator?\n``` go\n// Example\nfunc ValidateSQLField(field interface{}, tag string) ValidationErrors {\n    if valuer, ok := field.(sql.Valuer); ok {\n        val, err := valuer.Value()\n        if err != nil {\n            // handle the error how you want\n        }\n    field = val\n}\n\nreturn validate.Field(field, tag)\n\n}\n```\nwhat do you think @johnniedoe \n. @johnniedoe \nThanks, I will take a look before work this morning, I am still on the fence about adding but will let you know today regardless.\nThanks so much and I'm glad you like the library!\n. #### Summary\nok this was a tough one, I was able to implement without affecting allocations nor other performance impacts by tweaking your example a bit, see https://github.com/joeybloggs/validator/tree/add-sql-valuer and it's accompanying benchmarks below.\nhowever I had to take a step back and reevaluate what this library should be doing, what decisions it should be making and more importantly not making. The library validates fields and struct fields and  really shouldn't be extracting or calling functions to get the values for validation; that should be up to the calling program to determine.\na few things prompted this decision:\n- what if more cases like this were to be added? more checks, more overhead when the calling program could do it with little or no overhead.\n- what if there were multiple cases and was checking if implements an interface and two interfaces had the same exact function declarations, but needed to be handled differently?\n- what if there were multiple cases and was checking if implements an interface and the struct implements multiple interfaces? should I check one or both? would have to add case specific options, more checks, more overhead\nRecommendation\nI would recommend creating a/some helper functions as suggested above as it would the easiest and most potable and will avoid any of the issues/questions/points noted above.\nAlternatively you could fork the project and implement the same changes I did here: https://github.com/joeybloggs/validator/tree/add-sql-valuer, but then you have to maintain and merge in changes...\nNotes\n@johnniedoe I just want you to know that It was a hard decision not to implement this and thank you for suggesting it. If you have any other other recommendations or questions please don't hesitate to create an issue or email me.\nIt would also be nice to know what you ended up, or will end up, doing. If you could comment or add an example function here, I'm sure it would help others that may be reading this. Thanks!\nBenchmarks\ngo\n$ go test -cpu=4 -bench=. -benchmem=true\nPASS\nBenchmarkFieldSuccess-4                  5000000           319 ns/op          16 B/op          1 allocs/op\nBenchmarkFieldFailure-4                  5000000           320 ns/op          16 B/op          1 allocs/op\nBenchmarkFieldOrTagSuccess-4             1000000          2462 ns/op          20 B/op          2 allocs/op\nBenchmarkFieldOrTagFailure-4             1000000          1326 ns/op         384 B/op          6 allocs/op\nBenchmarkStructSimpleSuccess-4           1000000          1209 ns/op          24 B/op          3 allocs/op\nBenchmarkStructSimpleFailure-4           1000000          1829 ns/op         529 B/op         11 allocs/op\nBenchmarkStructSimpleSuccessParallel-4   5000000           341 ns/op          24 B/op          3 allocs/op\nBenchmarkStructSimpleFailureParallel-4   2000000           866 ns/op         529 B/op         11 allocs/op\nBenchmarkStructComplexSuccess-4           200000          7283 ns/op         368 B/op         30 allocs/op\nBenchmarkStructComplexFailure-4           100000         12043 ns/op        2861 B/op         72 allocs/op\nBenchmarkStructComplexSuccessParallel-4  1000000          2433 ns/op         368 B/op         30 allocs/op\nBenchmarkStructComplexFailureParallel-4   300000          5978 ns/op        2863 B/op         72 allocs/op\n. Hey @johnniedoe just saw your comment above my last, looks like we commented at about the same time so I almost missed it.\nI don't know if it would work as a baked in validator function because a few variables are out of scope at that point, such as field name, tags, ValidationErrors etc.. and after extracting the Value from Valuer you would have to call the traverseField function to do all the checks and apply all tags and errors if any, but you need the aforementioned fields that are out of scope.\n. @johnniedoe you gave me an idea maybe in the config I could have a map[reflect.Type]Func\nwhere Func is a function type that you have to comply with, like the baked in validator function, and the end user can fill this map with all of the types they wish to run a special function on and I can check if that type is within the map and if it is run the function which will return a value and I can validate.\nok I know run-on sentence but sudo coding it:\n``` go\n// this function within callers code\nfunc ValidateValuerType(field reflect.Value) interface {\n    if valuer, ok := field.Interface().(sql.Valuer); ok {\n        val, err := valuer.Value()\n        if err != nil {\n            // handle the error how you want\n        }\n       return val\n    }\nreturn nil\n\n}\n// this within validator package\ntype TypeOverrideFunc func(field reflect.Value) interface\n// this within calling program\nspecialTypes := map[reflect.Type]TypeOverrideFunc{}\nspecialTypes[reflect.TypeOf((*sql.Valuer)(nil))] = ValidateValuerType\n// NullTime comes from here https://github.com/go-sql-driver/mysql/blob/6d2067fccbf9cd2e000d1d2f5d9a89e78ffd0a7d/utils.go#L480\nspecialTypes[reflect.TypeOf((NullTime{}] = ValidateValuerType\n// .. and so on\nconfig := Config {\n   TypeOverrides: specialTypes,\n}\n// check in traverseField method to see if type is within map\n// if no continue on\n// if yes then run function to get value, and pass it to traverseField like I did up in my example\n```\nGood\n\nO of 1 lookup time for map\ncaller maintains full control about the value passed back\ncan override any type, even standard datatype such as int\ncompletely optional\n\nBad\n\nhave to add each type that implements Valuer to the map\n\nWhat do you think?\n. @johnniedoe perfect, yep the boolean check is exactly what I had in mind but check the len during the validator initialization within the New() function and set it as a value on the config object.\nI think map type lookups are ok, even if a little slow in comparison to int, doing it this way would be optional and if they don't want the extra overhead they can always extract the value themselves and validate just the value.\nI'll whip something up by next week, can't promise I will work on it during the long weekend ;)\nI'll let you know when I complete it so you can have a look and see if it fits you needs.\nP.S. I will probably only implement this functionality in v6 as v5 it would be too cumbersome, I'm sure @manucorporat will update to v6 soon enough, he's really good about that sort of thing.\n. Hey @johnniedoe I added this in https://github.com/bluesuncorp/validator/releases/tag/v6.2\nthanks for your ideas! \nI didn't want to have to think about it over the long weekend, so now I don't have to :smile: \n. Hey @alioygur that's an interesting one, I do have a few questions:\n- what version of this library are you using v5 or v6?\n- how are you checking if the error is nil or not from the calling code? could you provide a sample?\nThis is just a guess before I can get how your checking the nil, but if your using v6 and you are printing the error and it outputs map[]  this is a let's call it goism for lack of a better term. fmt.Println and log.Println don't always print the value but just call the String() function of the object, by default, and that function returns a string.\nV6 returns a type ValidationErrors which is really a map[string]*FieldError and a map in go is a by-reference type, meaning it's always passed by reference. Because of this a maps default value is nil, but printing it out it's Internal String() function will print \"map[]\" which is it's type and not value.\nAssuming this is all true if you do fmt.Println(err == nil) it will print \"true\", it is nil, just doesn't print that way by default in go unless other options with Printf are used, see fmt package documentation for those.\nEither way let me know\n. I will take a look at this asap, probably a little later tonight and get back to you.\n. P.s. doe's it work without name error parameters?\n. This is a little tricky to explain, but I'll try my best:\nUnderstanding By-Reference for map\nok so like I have mentioned above map is one of go's by reference data types, so what that means is that the map is actually a pointer to location in memory. In this case the pointer can point to a valid ValidationErrors object or nil; but either way the pointer is always valid even if the value it points to isn't\nin go you can access the values of reference types just like you would as if they were not ( except in special cases but we're not getting into that ) so that's why this works:\n``` go\n// declaring variables in long form for clarity\nvar err ValidationErrors = validate.Struct(user)\n// when accessing err it will actually access the value in memory which may be nil or valid\nif err != nil {\n// ...\n}\n```\nSituation\nIn validateStruct() your assigning\ngo\nerr = validate.Struct(user)\nbut the return value of validate.Struct() is of type ValidationErrors, you can do this because ValidationErrors implements the error interface; however it does not work quite how one would expect.\nExpected\nThe value of err gets set to the value of the ValidationErrors, which in your example is nil.\nWhat Actually Happens\nThe value of err gets set to the pointer of ValidationErrors which points to it's value\nso errs value -->pointer and pointers value --> value\nso that's why your error is always not nil, because it's value is actually the pointer, which is always not nil, even if it's underlying value is.\nWhy not pass back error from validate.Struct() instead of ValidationErrors\nIt's true that this would make your failing example work as expected. Doing it this way was a design decision so that some people may avoid unnecessary type assertions. Take the following example into consideration, many people, including myself, handle their errors right away, without passing the error around as error.\nfor example\n``` go\n// err will be ValidationErrors\nerr := validate.Struct(user)\nif err != nil {\n  // range over err, create error messages, based off of FieldError\n  // information and return those errors, or a map[string]string\n}\nreturn formatted errors\n```\nbut if I got type error returned\n``` go\nerr = validate.Struct(user)\nif err != nil {\n  // now to range over my ValidationErrors I would need to assert \n  // that the err object is in fact ValidationErrors\n  valErrs := err.(validator.ValidationErrors)\n  // then you can range over valErrs or whatever, however you see \n  // that we had to assign another variable and do a type assertion, \n  // although this is pretty light weight it still has some overhead\n}\n```\nso those that pass the ValidationErrors as error and want access to the FieldError data will need to do type assertions, but not everyone has to the way it works now.\nRecommended Approach if you still wish to pass by error\n``` go\nfunc validateStruct() error {\n    user := &User{\n        FirstName: \"Badger\",\n        LastName:  \"Smith\",\n    }\nerr := validate.Struct(user)\n\nif err != nil {\n    return err\n}\n\nreturn nil\n\n}\n```\n@alioygur sorry for being so long winded about this, but because you said you were new to go I just wanted the answer to be as thorough as possible. I hope I made sense, do you have any questions?\nFinal thoughts - also because you said you were new to go\nFeel completely free to totally disregard this recommendation, it's just a suggestion, as I've played around with named return params myself and stopped completely.\nI would recommend not using named return params they are a super micro micro optimization that tends, IMHO, to really hurt code maintainability; they seem like a good idea, but as your functions size grows and you have to constantly scroll back to see what you named the variable, and tracing back where a value was last set, or if a value was set really slow you down. On the flip side returning where and when you need to is easier to read, even for those that did not write the code, and is much clearer about what is happening.\n. No problem @alioygur I'll leave this issue open for a few days before I close it.\nIf you have any more questions, issues or any recommendations don't hesitate to ask!\n. Sure\n. It seems like you have a pretty good grip on go, code looks very good. And FINALLY! someone using the \"dive\" tag I worked so hard to have that work like it does :smile: \nI would recommend a few things, but they are minor and some just pure preference.\n1. DeletePost possible issue, see comment in code\n``` go\n// DeletePost delete post handler\nfunc DeletePost(c *Context) error {\n    post := new(Post)\n    err := DB.Find(post, c.Param(\":id\")).Error\n    if err != nil {\n        return err\n    }\n    // does DB.Find return an error when post is not found?\n    // if not the next line will probably error out\n\n   // secondly is not finding a post for deletion an error, or is it ok?\n\nerr = DB.Delete(post).Error\nif err != nil {\n    return err\n}\n\nreturn c.NoContent(204)\n\n}\n```\n2. Functions that don't return a new parameter\nthis ones totally a preference, but when a function doesn't return a new variable, save a reusable one like error, or I don't need the new variable below the current line, I tend to write it like this\n``` go\nvar err error\nif err = BindAndValidate(c.Request, req); err != nil\n  return err\n}\n```\nso your CreatePost could be rewritten in fewer lines, but just as readable\n``` go\n// CreatePost create post handler\nfunc CreatePost(c *Context) error {\n    var err error\nreq := new(NewPostReq)\n\nif err = BindAndValidate(c.Request, req); err != nil {\n    return err\n}\n\npost := new(Post)\nif err = CopyTo(req, post); err != nil {\n    return err\n}\npost.UserID = 1\nif err = DB.Create(post).Error; err != nil {\n    return err\n}\n\npr := new(PostResource)\nif err = CopyTo(post, pr); err != nil {\n    return err\n}\n\nreturn c.JSON(201, pr)\n\n}\n```\n3. dynamic structs\nThis one may be because of how JSON is processed, so if so totally ignore this. I usually take the time to create the sub structs that could be dynamic, which allows for reusability later down the line; but there are caveats, see below:\n`` go\n// so instead of\ntype NewPostReq struct {\n    Title       stringvalidate:\"required\"Description stringvalidate:\"required\"Body        stringvalidate:\"required\"Tags        []struct {\n        Tag stringvalidate:\"required\"}validate:\"min=2,dive\"`\n}\n// I would do \ntype Tag struct {\n  Name string validate:\"required\"\n}\ntype NewPostReq struct {\n    Title       string validate:\"required\"\n    Description string validate:\"required\"\n    Body        string validate:\"required\"\n    Tags        []*Tag validate:\"min=2,dive\"\n}\n// NOTE: you will notice that I used []*Tag, note the * \n// although there is debate on this I tend to pass almost \n// all struct by reference internally within my code.\n// but there are times to lock it down, just take a look\n// at Config within my validator, it is passed by value\n// so that it gets copied and you can't manipulate it after \ninitialization.\n```\nthe caveats are\n-  the JSON would probably have to be formatted differently\n- my validators error key in the map, if it failed, would be \"NewPostReq.Tags[0].Tag.Name\" instead of \"NewPostReq.Tags[0].Tag\" and the field would be \"Name\" instead of \"Tag\"\nanyways @alioygur I thinks that's it, and again, code looks great, hopefully you can star my repo if this package/library works out for you.\nP.S. if the code your working on becomes a project, and it's ok with you I would love to start listing some projects on my README that use my library. and be sure to check out some of my other projects here https://github.com/bluesuncorp I'm going to be adding more as time goes on.\n. No problems @alioygur, going to close this issue now and if you have anymore questions, just shoot me an email.\n. Love it! will merge but against v6-development but I have to add tests to keep my 100% test coverage before merging to v6\nThanks! @johnniedoe , will let you know when it's done.\n. pull request being handled in #140 , needed to merge into v6-development and add coverage tests\n. I think there may be some small confusion about how this works.\nValidator validates the data within the struct after it has been in unmarshalled from JSON.\nSo the steps that happen are:\n- JSON post received\n- during Bind the struct is initialized\n- the JSON is unmarshalled into the structure variables\nSince go is statically typed, regardless if truthiness is passed or not, the structure will always have a value and since go's bool's are not tri-state.\nIt does not validate the JSON but data after unmarshalling.\nSorry for no samples, answering from my phone.\nDoe's this answer your question?\n. Give me a few minutes, I have an idea that may work for you.\nJust tied up at the moment\n. I was thinking you could make the bool value a pointer, then it would fail when no value was present, but it would still fail ifvaluewas false so that won't work.\nI may look into adding a new tag, \"exists\" it will not have any validation functions associated with it, however will be the failure tag when value is a pointer and is value of nil.\nIn the mean time however, there really isn't a way to check if a bool is set.\n. I'm actually in the middle of adding the \"exists\" tag it's seem to work well when using bool as a pointer, will let you know when it's released; hopefully tonight.\n. Hey @davisford, guess I was closer than I though lol\nExample\nif you use \"exists\" tag like below and bool is a pointer you will get the functionality you are looking for.\nNOTE: this works with any Pointer, Interface or Invalid Type.\ngo\ntype Thing struct {\n  Truthiness *bool `json:\"truthiness\" validate:\"exists\"`\n}\nNotes\nThis change was implemented in v6 and back-ported to v5.\nI Highly recommend everyone to update to v6 if possible as some things added in v6 already cannot be back-ported to v5 due to the code change between v5 and v6\nUPDATE: Please let me know if this works as expected for you and I can close this issue\n. no problems, yes I tested with your exact scenario with bool as a pointer and using exists flag.\nP.S. @davisford I think gin allows for custom/other validation libraries to be plugged in, in this case just the updated version, however I don't have a link to the commit, or documentation.\nP.P.S star if you like, just trying to get more stars than the other validators out there, even ones that are unmaintained have more stars :frowning: \n. Hey @davisford I came across how to add your own validator in gin to avoid forking, it's in this issue 2nd or 3rd comment https://github.com/gin-gonic/gin/pull/224#issuecomment-117567957\n. Hey @codepushr I dropped exists in favour of just using required and added some nullable checks so required should work just like exists did in this scenario.\nif not then it could be a bug, could you provide some sample code and I'll check it out ASAP\n. Hey @codepushr thanks for the code,\nI already replicated the issue, just running last minute tests and fix will be out in a few minutes so required will now work as expected.\nwill tag you and this issue when making the final release.\nP.S. thanks for reporting.\n. ok @codepushr release 9.2.0 should fix this for you.\nPlease let me know if it works for you \ud83d\ude03 \nNOTE: the reason I removed exists is that required implies exists and had a number of people mention that it was confusing and so now required handles both, with one tag.\n. closing this issue, but am still interested in help with documentation + examples.\n. v7 has been released! see release notes here: https://github.com/bluesuncorp/validator/releases/tag/v7\ngiving a shout out to a few people that contributed code, ideas or may have just started using the library:\n@jtriber\n@ardan-bkennedy\n@muyiwaolurin \n@johnniedoe\n@manucorporat\n@davisford\n. No problems, @ardan-bkennedy I only had it that way while adding/updating some new functionality that didn't exist before and so had to point to my fork and not the stable branch; guess I forgot to change it back.\njust out of pure curiosity, GolangUK that's awesome how will you be using this library?\nP.S. I will ensure that v7 get's released before Friday and some changes from it backported into v6\n. That's Awesome! I guess this library is reaching further than I thought\nBest of luck at the conference :+1: \n. I will merge this once I create a branch for v7\n. closing this, changes were merged in from v6 into v7 before creating v7 branch\nP.S. @ardan-bkennedy v7 has been released! see notes here: https://github.com/bluesuncorp/validator/releases/tag/v7 according to the code I saw in your training material, this should be a drop in replacement.\n. What version of Go are you using?\nit sounds like you're using an older version of Go, I believe sync.Pool is only in go 1.3 and above\n. I should be able to get this done later tonight\n. Hello @fromYukki ,\nThanks for the question, a few people have asked on the side, but good to have it in an issue. I apologize for being so long winded but it's a complicated explanation; even I forget why I didn't implement this on occasion.\nSummary\nI thought about the ability to add custom error messages allot during the development of this package and every time have decided against it, the main reason is because of internationalization. Because validator is designed to be defined and used as a global object it is not tied to any specific context; I think the best way to describe the issue is to give an example of how I use the package myself.\nExample\nI have validator defined in an internationalized web application as a global variable.\nEach http request could be from any user with any locale and validator has no line of site to what locale, nor which i18n package is being used; this is one of the main reasons I return a map of *FieldError for creating your own messages. Even if I added another parameter as type interface{} to accept anything, like the i18 package or locale for translation, you the user would still have to specify a custom validation for each tag; but it's not as simple as that either as the tags can apply to multiple types i.e. len can apply to string, int, float, array, map and so forth so a single message per tag isn't enough as if validation failed for a string you may want to give an error about number of characters, but if int the error would be about the int value; which means that the custom messages would have to be by tag, by type or specify a function to run for each tag which checks the type and I would have to go the function route as I would need to pass the locale and i18n information to the function.\nAt this point validator would be clogged up with all of this code and translation info and it would actually be more complicated and ugly than just ranging over the map and doing a switch on the tag. This is the way I do my translations, I have created a common function which accepts the map of errors and returns a map of translated errors and has proved to be very maintainable.\nFinal Thoughts\nUnless I can find a better way, or someone could show me a better way I will likely not implement the ability to specify custom errors inline ( I am totally open to any ideas you may have )\nI realize a good number of people won't care about internationalization, however there are also a great number who do, and happens to be a requirement for me.\nwas able to explain why dealing with your own message creation may be the best option? and like I said I am open to ideas\n. P.S. I've been meaning to add an example with a default switch and default messages that users could copy, modify and add to in order to save some time. Guess I'll have to get on that a little quicker :)\n. Hey @mattes \nI did think about returning an error, however as in your example above it wouldn't really make sense as field \"Bogus\" does not doesn't have any errors; I know a technicality.\nI will definitely take a look and see if I can't make it panic though as it's really a configuration error rather than a validation one.\nThe real question is should StructExcept() panic as well?\n. Thanks @mattes glad you like the lib :smile: \nAfter a quick look I remember why I didn't add panicing in the first place; there is no guarantee validator will validate/hit all fields passed to StructPartial() or StructExcept() so keeping track if a field exists or not is a little problematic, let me explain:\n`` go\n// NOTE: this is a very simple use case I could have gotten into arrays and maps\n// but this will suffice\ntype ContactInfo struct {\n  Phone   stringvalidate:\"required\"Address stringvalidate:\"required\"`\n}\ntype User struct {\n  ID                 int          validate:\"required\"\n  FirstName          string       validate:\"required\"\n  LastName           string       validate:\"required\"\n  ContactInformation *ContactInfo validate:\"omitempty\" // optional\n}\nuser := &User{\n  ID: 1,\n  FirstName: \"Joey\",\n  LastName: \"Bloggs\",\n}\nerrs := validate.StructPartial(user, \"ContactInformation.Phone\", \"ContactInformation.Address\")\n// errs will be nil and that's ok beacause ContactInfomation is optional\nerrs := validate.StructPartial(user, \"ContactInformation.fwfwe\", \"ContactInformation.ewfwef\")\n// errs will also be nil even though the fields are bogus; validator stops at ContactInformation \n// because it was told it's ok too\n```\nThat's the dilemma I'm faced with and so initially decided it was the users responsibility, just like using SQL and adding an incorrect Field name to the database.\nWithout allot of preprocessing pre or post validation and allot of overhead I don't know of a good way to add this? I'm open to any ideas \n. Perhaps I can make it a configuration option whether to check that fields exist and during dev mode it can be set to true catching any issues and in production be set to off; my main concern is the overhead of the check, but this would alleviate that.\nthis will probably take me a while to implement, but think I can make it work.\n. @mattes I may make it mandatory, but it will probably slow down validate.StructXXX by 2 - 3 times and increase memory allocations by the same.\nbut I will definitely be panicing when a field doesn't exist; I will look into implementing this within the next few weeks.\n. sorry for the delay, I fully intend to implement this, just busy with work and other projects.\n. OK so went pretty far down the rabbit hole with this one, been racking my brains on how to reconcile type interface and if a field exists.\nScenario\nLet's say I had a field of type interface that was OK to be empty but otherwise filled with a struct, when the field was not populated I know of no way to check that the field exists because there is no type information associated with the interface field when not set.\nI know it sounds like an outlandish scenario, however I have run into many scenarios like this while developing this package that I thought would never happen, but they do.\nConclusion\nI think that this is an all or nothing issue because I cannot preclude the scenario from happening, I will keep this issue open for a while and try and figure something out  but realistically can't see a way around the above issue.\nAny thought's or help would be welcome.\n. Thanks! Must have been there a while\n. Thanks! looks great\nI noted 1 small error in the documentation.\nI will probably get to this either this afternoon or after I get off work today\n. Currently there are no built in tags to do Cross Field OR validation. once getting into situations like you defined above, I consider them to be complex validation rules that even if built in tags could be used, it would become very hard to read.\nBut the library has a an easy reusable way to achieve what you want by creating a custom validation function, and then you may use and reuse it as a tag in your structs.\nExample\n``` go\n// define funciton\nfunc oneFieldSet(v *Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    // use topStruct instead of currentStructOrField below if want function to be able to do cross struct cross field validation\n    currentField, currentKind, ok := v.GetStructFieldOK(currentStructOrField, param)\n    if !ok || currentKind != fieldKind {\n        return false\n    }\n// if field has a value, just like the hasValue function then return true\n// if currentField has a value return true\n// return false by default\n}\nvalidate := //new validator\nvalidate.RegisterValidation(\"eitherrequired\", oneFieldSet)\ntype User struct {\n  Username string validate:\"eitherrequired=Email\"\n  Email    string validate:\"eitherrequired=Username\"\n}\n```\nthen you could reuse this tag/validation function in a bunch of your structs\nDoes that make sense?\nP.S. you gave me a great idea, that I should expose the existing validators so that you can use them inside custom ones; then you could use hasValue ( which is the function that \"required\" tag runs ) in your custom function.\n. Hey @scisci \nI've updated validator to expose the baked in functions for use within custom functions, so below is a more complete example using the exposed functions.\nExample\n``` go\n// define funciton\nfunc oneFieldSet(v *Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    // use topStruct instead of currentStructOrField below if want function to be able to do cross struct cross field validation\n    currentField, currentKind, ok := v.GetStructFieldOK(currentStructOrField, param)\n    if !ok || currentKind != fieldKind {\n        return false\n    }\nif validator.HasValue(v, topStruct, currentStructOrField, field, fieldType, fieldKind, param) {\n  return true\n}\n\nif validator.HasValue(v, topStruct, currentStructOrField, currentField, fieldType, currentKind, param) {\n  return true\n}\n\nreturn false\n\n}\nvalidate := //new validator\nvalidate.RegisterValidation(\"eitherrequired\", oneFieldSet)\ntype User struct {\n  Username string validate:\"eitherrequired=Email\"\n  Email    string validate:\"eitherrequired=Username\"\n}\n```\nwill this work for your needs? it should be generic enough to use within many of your structs\n. perfect! glad I could help @scisci \nif you need any help or have any question, just let me know.\n. Hey @scisci thought I'd let you know about Struct Level Validations see here: https://github.com/go-playground/validator/releases/tag/v8.7\nthis may be an even better way to do your username or email check :smile: \n. @dennisfaust would you be able to provide a code sample that includes your Valuer function and Struct/Field your validating?\nI think it may be that your have required set as a validation, but exists is what your looking for...but I can't really tell without a sample.\n. Thanks @dennisfaust I will take a look later tonight after I get off work, should be able to come up with something.\n. #### Comments & Solution\nOK @dennisfaust I must say this is definitely a unique case because the kind of null.StringFromPtr(nil) is invalid so you have a value that can be invalid, the default string value and an actual value; not many can be all three, but validator can handle it! :smile: and it's relatively simple just change your struct to the following\ngo\ntype testNotBlankStruct struct {\n    ID    string\n    Token null.String `validate:\"gt=0,omitempty,notblank\"`\n}\n- omitempty handles the nil value and kind invalid\n- gt=0 handles the blank value\nSide note\nYou can probably eliminate the custom validator and have the \"notblank\" tag removed like so:\ngo\ntype testNotBlankStruct struct {\n    ID    string\n    Token null.String `validate:\"gt=0,omitempty\"`\n}\nunless you are using the gorm parameter for something in your full code...\nFinal Thoughts\nPlease let me know if this solution works for you, I'll leave the issue open until then.\n. Hey @dennisfaust just trying to confirm, did this worked for you?\n. closing.\n. Thanks,\nI don't see why not @solher I'll try and get it in there sometime today.\n. Hey @solher , the change has been made.\n. @zhengyangas so I'm assuming you were trying to update your own fork and this is a mistake?\n. @xservWhat version(s) of Go are on each machine? Validator needs at least v1.3, just a guess. Could you also output the-v output?\n. Is there anything special about the centos box vs Mac or Ubuntu ones? I.e. same location, behind firewall's...\nIt does not seem to be an issue with validator, github or gopkg.in.\n. @odinliu could I get a few more details, I believe it is an issue with centos itself, but I'm sure I can help in narrowing it down.\n1. How was go installed? Compiled, rpm....\n2. Can you go get any other packages?\n   3a. Can you go get validator directly with Go get gopkg.in/bluesuncorp/validator.v5 ? maybe a problem with gin and the godep programming that is being used\n   3b. Does go get gopkg.in/go-playground/validator.v5 work? Maybe a GitHub redirecting issue from old bluesuncorp to go-playgroind.\n3. What kernel version is in use, and how was that installed ?I.e. standard kernel or compiled custom.\n4. What version of git is installed?\nI still have a hard time believing it is the package itself as go get is essentially just a git clone, but I'm sure we can figure something out\n. @odinliu I think I may have discovered the problem, I think it may be the git version 1.7.1\nI read a bunch of articles like this one https://github.com/spf13/hugo/issues/297 where they were having the same sort of issue.\nbecause I'm using gopkg.in for my versioning it does a redirect to the real git branch to get the code and go get just proxies git and git 1.7.1 is not handling to redirects properly.\nIs it possible to upgrade your version of git and try again?\n. Great! @odinliu glad in the end it's a simple fix.\nI agree with centos being behind, it has it's purpose being stable and all but IMHO in todays rapidly shifting, changing and advancing software and technology that sort of mentality can get you left behind.\nI'll leave this up for a bit so others with the same problem can check for the solution.\nThanks for all your help in narrowing the problem down :thumbsup:\n. Hello @laeshiny \nI'm definitely willing to help, this must be an external issue though.\n1. Can you confirm that the git version in your current terminal session is using git 2.10.0 using git --version maybe it's using another found earlier within the $PATH\n2. Confirm go version using command go version\n3. If both 1 and 2 are ok can you do a regular git clone of the repo?\n4. Other thoughts are github.com or gopkg.in could be experiencing issues; it's rare but it happens.\n5. Are you able to try with any other is besides CentOS? Issues like these seem to always happen with it.\n6. Perhaps try running command as root, I think that go get suppresses some of the git clone errors, but unlikely.\nLet me know and I'll post of I can think of any more.\n. Did you try and git clone the gopkg.in address? I suspect t it will fail also which means git isn't following the redirects, which is strange considering that's been working since git > 1.7 see https://github.com/spf13/hugo/issues/297\nIf it works on CentOS 7 it must be a CentOS 6.3 issue, maybe a firewall, security or git config setting.\nI don't know how much further I can help, it doesn't seem to be an issue with the package, GitHub or gopkg.in; perhaps posting a question on Stack Overflow might yield more ideas.\nIt would be great to add a link from this issue to your question.\n. Hi @donileo I've covered this in several issues https://github.com/go-playground/validator/issues/142 https://github.com/gin-gonic/gin/issues/491...\nAnyways so summarise the \"required\" in the godocs states that it validates that the value isn't the fields default types default value, which for a bool is false and so properly fails validation. What I think your looking for is to use the \"exists\" tag and need to change the bool to be a pointer *bool like so:\ngo\ntype Respond struct { Accepted *bool \"`json:\"accepted\" binding:\"exists\"`\" }\nThe reason this needs to be done is because go is a static language, just to go through how binding works, assuming your using gin, is that the json is unmarshalled into your struct but before it can do that a new struct needs to be created and because go is static every field within will get a default value, the only way to validate exists is to make the field a pointer essentially making the field nullable.\nI wish there was a better way but have yet to find one. Most of the time this is a non issue though as for a bool not passing false is false, for a string it's blank.\nI hope my answer helps please let me know if this makes sense or have anymore questions.\n. @donileo I don't disagree if I were to redo it from scratch I may have named \"required\" something else like \"nondefault\" or something, but would be a big breaking change, maybe for v9 someday.\nthe difference with \"exists\" is that if validator finds that the field kind, after trying to find the underlying type, is still reflect.Ptr, reflect.Interface or reflect.Invalid and there are validation tags i.e. \"exists\" then that means there is no value and will fail on that tag. It's a little complicated if reading the code but validator will get into this is statement https://github.com/go-playground/validator/blob/v8/validator.go#L564 with your example when using \"exists\" and *bool \nNOTE: \"exists\" should be the first tag if multiple as when an error like the above occurs it will use the first tag.\n. Hey @scisci \nThis came up early in the design of this library and some people do want it to fail when it's blank and others not; so Yes most if not all my regexes are designed to fail when the value is blank and that is what the \"omitempty\" tag is for, so people can have their cake and eat it too.\nSo in your case that tags on your hexadecimal field should be \"omitempty,hexadecimal\"\nSorry for the lateness of my reply, am away from home visiting family\n. Thanks @byrnedo will add a boolean option to the config for this after the holidays\n. UPDATE: after some review will be adding another field on each FieldError for this as don't want to confuse StructPartial and StructExcept methods which use the key to determine which fields are to be included/excluded.\nlong story short want to ensure that if someone set the FieldNameTag in the validator config that no logic anywhere would break and this is the way to ensure that, while changing the key could cause issues to exiting code relying upon it.\n. @byrnedo I have completed the changes please check it out and let me know if it works for you.\n. np just let me know when you can\n. any word @byrnedo ?\n. Perfect\n. I think you are essentially asking the same thing as in issue https://github.com/go-playground/validator/issues/174#issuecomment-142464644\nAlthough it is about custom messages this directly applies to i18n.\nTo summarize, and this is exactly how I use validator myself, after validating if there are errors I range over them and use the FieldError properties to:\n- Create my own error message\n- Apply i18n translations\nhere is a quick snippet of how I do it ( it could be greatly refined, but just haven't found time )\n``` go\n// TranslateValidationErrors returns a map of translated error\n// key = field, value = translation\nfunc TranslateValidationErrors(errs validator.ValidationErrors, t *i18n.Translator) map[string]string {\ntranslatedErrs := map[string]string{}\n\nfor k, v := range errs {\n    translatedErrs[k] = TranslateValidationError(v, t)\n}\n\nreturn translatedErrs\n\n}\n// TranslateValidationError determines the translation type based off of the ErrorTag and call appropriate translation methods\nfunc TranslateValidationError(err validator.FieldError, t i18n.Translator) string {\nswitch err.Tag {\ncase \"required\":\n    return translateRequiredValidationError(t, err)\ncase \"len\":\n    return translateLenValidationError(t, err)\ncase \"min\":\n    return translateMinValidationError(t, err)\ncase \"max\":\n    return translateMaxValidationError(t, err)\ncase \"gt\":\n    return translateGtValidationError(t, err)\ncase \"lt\":\n    return translateLtValidationError(t, err)\ncase \"gte\":\n    return translateGteValidationError(t, err)\ncase \"lte\":\n    return translateLteValidationError(t, err)\ncase \"gtfield\":\n    return translateGtFieldValidationError(t, err)\ncase \"gtefield\":\n    return translateGteFieldValidationError(t, err)\ncase \"ltfield\":\n    return translateLtFieldValidationError(t, err)\ncase \"ltefield\":\n    return translateLteFieldValidationError(t, err)\ncase \"alpha\":\n    return translateAlphaValidationError(t, err)\ncase \"alphanum\":\n    return translateAlphanumValidationError(t, err)\ncase \"numeric\":\n    return translateNumericValidationError(t, err)\ncase \"hexadecimal\":\n    return translateHexadecimalValidationError(t, err)\ncase \"hexcolor\":\n    return translateHexColorValidationError(t, err)\ncase \"rgb\":\n    return translateRGBColorValidationError(t, err)\ncase \"rgba\":\n    return translateRGBAColorValidationError(t, err)\ncase \"rgb|rgba\":\n    return translateRGBOrRGBAColorValidationError(t, err)\ncase \"hsl\":\n    return translateHSLColorValidationError(t, err)\ncase \"hsla\":\n    return translateHSLAColorValidationError(t, err)\ncase \"hsl|hsla\":\n    return translateHSLOrHSLAColorValidationError(t, err)\ncase \"email\":\n    return translateEmailValidationError(t, err)\ncase \"url\":\n    return translateURLValidationError(t, err)\ncase \"uri\":\n    return translateURIValidationError(t, err)\ncase \"base64\":\n    return translateBase64ValidationError(t, err)\ncase \"eq\":\n    return translateEqValidationError(t, err)\ncase \"eqfield\":\n    return translateEqFieldValidationError(t, err)\ncase \"ne\":\n    return translateNeValidationError(t, err)\ncase \"nefield\":\n    return translateNeFieldValidationError(t, err)\ncase \"uniqueuserusername\":\n    return translateUniqueUserUsernameValidationError(t, err)\ncase \"uniqueuseremail\":\n    return translateUniqueUserEmailValidationError(t, err)\ncase \"uniquewpname\":\n    return translateUniqueWeeklPreferenceNameValidationError(t, err)\ncase \"contains\":\n    return translateContainsValidationError(t, err)\ncase \"containsany\":\n    return translateContainsAnyValidationError(t, err)\ncase \"containsrune\":\n    return translateContainsRuneValidationError(t, err)\ncase \"excludes\":\n    return translateExcludesValidationError(t, err)\ncase \"excludesall\":\n    return translateExcludesAllValidationError(t, err)\ncase \"excludesrune\":\n    return translateExcludesRuneValidationError(t, err)\n}\n\nreturn \"\"\n\n}\n// translateExcludesRuneValidationError translates the excludesrune validation error based off of the fields data type\nfunc translateExcludesRuneValidationError(t i18n.Translator, err validator.FieldError) string {\nreturn Translate(t, \"Validation_ExcludesRune\", map[string]string{\n    \"rune\": \"\\\"\" + err.Param + \"\\\"\",\n})\n\n}\n// translateExcludesAllValidationError translates the excludesall validation error based off of the fields data type\nfunc translateExcludesAllValidationError(t i18n.Translator, err validator.FieldError) string {\nbuff := bytes.NewBufferString(\"\")\n\nfor i := range err.Param {\n    buff.WriteString(\",\\\"\")\n    buff.WriteString(err.Param[i : i+1])\n    buff.WriteString(\"\\\"\")\n}\n\nreturn Translate(t, \"Validation_ExcludesAll\", map[string]string{\n    \"chars\":\n\n...\n```\n. No problem\nOn Fri, 8 Jan 2016, 10:56 a.m. whidbey notifications@github.com wrote:\n\nverygood ,and fast resposne,thank youl\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/go-playground/validator/issues/230#issuecomment-170038644\n.\n\n\nThanks,\nDean Karn\n. hey @irregular,\nI don't think there is the way validator works now; but maybe if you give me some more details and maybe an example of why you need it I could help you find a solution or maybe add support for that in the future if it makes sense.\n. Ok so just so I understand fully your looking to ensure that no struct has a field name exactly like the other?\n. Sorry just trying to fully wrap my head around the what and why. Is there a particular reason for this requirement? Maybe just need a few more details. Before making a breaking change I like to have the big picture.\n. I understand now, I do a similar thing to ensure that a users email is unique in the database prior to saving.\nAlthough a little more work instead of using a custom field validation, and the way I also do it,  I recommend using a struct level validation like in the examples here https://github.com/go-playground/validator/blob/v8/examples/struct-level/struct_level.go\nThe reason I do it that way is because not only do you usually need to ensure that field is unique but that when updating an existing record that if the database tables unique field is the same or not and trying to make that generic is a pain and you end up with a big switch statement that's not very flexible.\nWould this approach work for you?\n. I don't disagree @irregular just as soon as I make that sort of change someone else will ask for the Custom field name I.e. json name.... And probably more params and I'm just worried that the Custom validator function will start to contain too many parameters..\nI have been looking into passing a single object with all the params including field name just trying to work out how to keep allocations down and speed up because of all of the recursion.\nIf and when I get that working I will let you know and thanks for letting me know there was a need.\n. Wow thanks! @aarongreenlee !\nI wanted to clean it up for a while but can never find the time, may seem minor to you but means world's to me :+1: \nI will merge and cut a release sometime this weekend..\n. This is awesome! Thanks @krhubert\nSo these validate that the address is resolvable not just a valid address I can see how this would be very useful.\nI'd love for you to create some docs and tests!\n. Thanks I will review ASAP and if all is well merge this morning\n. so working on it now, am trying to fix the issue you filed with go.\nbut I have a question, because you are probably more familiar with networking than I.\ntake net.ResolveUnixAddr should it not error out when trying to validate a blank string? see here https://play.golang.org/p/0To1JR2dE9\nseems the other resolves also let \"\" pass too\n. ok I'm going to add a workaround for https://github.com/golang/go/issues/14037 as much as possible though, otherwise incorrect data may get saved in someones DB.\nHere's what I have so far:\nhttps://github.com/go-playground/validator/blob/krhubert/baked_in.go#L1254\nhttps://github.com/go-playground/validator/blob/krhubert/baked_in.go#L1272\nhttps://github.com/go-playground/validator/blob/krhubert/baked_in.go#L1323\nhttps://github.com/go-playground/validator/blob/krhubert/baked_in.go#L1335\nhttps://github.com/go-playground/validator/blob/krhubert/baked_in.go#L1347\nthat's all I've had time to do thus far, to accept \"\" just have to add to the if's as an example:\ngo\nif val != \"\" && !IsIPv4(v, topStruct, currentStructOrField, reflect.ValueOf(val), fieldType, fieldKind, param) {\nI'll have to continue work on it later today, or you can help finish them if you'd like.\nJust can't have bad data pass is all.\n. looks like there going to let the community come up with some idea's and have the fix slated for go1.7\nI will keep implementing the workaround for now as best I can.\n. Apologies for this taking so long @krhubert I will get it in as soon as I can..just have a few other projects eating all my time; should be this week though\n. Just an update, haven't forgotten about this, just still busy with another project... I will try my best to get it done this week any help would be welcome.\n. Hey @krhubert finally squeezed in some time to get this done! :smiley: \nI think I've covered all the basics, if could you could please take a look at this branch: https://github.com/go-playground/validator/tree/krhubert and run some tests on your end to ensure it works for you, I can get it merged in.\nP.S. ResolveUnixAddr I was discussing with a network specialist and he said that a blank unix addr is valid as it's assumed to be 0.0.0.0 ... I'm taking him at his word on that and \"\" is still valid in the test.\n. @krhubert  I will research a little bit more about UnixAddr, but even if it's left this way you can also add the \"required\" tag along with the \"unix_addr\" one and make it fail for blank that way.\nI've been totally busy creating this https://github.com/go-playground/lars but should be able to merge it in tonight after work\n. @krhubert ok I'm going to close this and make a pull request from my krhubert branch as everything is in there already. just a point of interest but have you looked at the ResolveUnixAddr code, it doesn't do anything but ensure the net string is a valid unix type and then just returns a new UnixAddr object see here https://golang.org/src/net/unixsock.go?s=826:883#L30\n. Awesome @krhubert I'm currently building a website and then converting a large web app to use lars, hence the 0.7.0 version, after that having 2 sites in production I'll bump the version to 1.0... but truthfully it's stable and nothing is likely to change, just adding functionality. I will be creating a sample app as well for use in a blog post about it.\nIf you need any help, have questions or think it's lacking something, just let me know and I'll see what I can do.\n. Thanks @moogle19 \n. #### Docs\nI specified right in the docs here https://godoc.org/gopkg.in/go-playground/validator.v8 about this very subject.\nSummary\nemail\n\"This validates that a string value contains a valid email This may not conform to all possibilities of any rfc standard, but neither does any email provider accept all possibilities.\"\nThe key being no email provider that I know of accepts all possibilities so passing validation on an email that can't exist in the wild would be worse IMO\nAccepting RFC email standard\nI am totally open to pull requests to add new validations to handle certain standards for example can add a new validation for the RFC3696 with the tag \"email_rfc3696\"\nIf you wanted to create it @moogle19 I would definitely add it to the list of validations\n. Thanks I will look into this right away\n. Tracked it down to this change in Go 617c93c\ncode now get's into the if and reports an invalid character. The URL however is valid, just not according to ParseRequestURI which assumes the request was sent via the browser and hence the fragment/suffix # will have already been removed.\ncan't use Parse because it's dumb in comparison, even lets \"\" pass :-1: \nso will keep as is and just emulate what the browser does and strip the # suffix prior to validation.\nfix coming forthwith\n. correction completed in release v8.17.1\nthanks for reporting @kbalonek \n. hello @0fuzz I'm a little confused about this one, was there some functionality that you desired that is missing; can't quite wrap my head around it?\n. No worries, and if you'd ever like something added to the library don't hesitate to ask.\n. Hello @byrnedo \nabsolutely I'd be interested, I could just update the \"alphanum\" regex found here I don't know that Go's regex handles \\p and {L} as I think they are PERL (PCRE) only, so I'd have to look into it. Any help you could provide is welcome \ud83d\ude04  I've gotten a bunch of requests lately for other projects, it may take me a little while to get to this, but I will.\nAs for a name in any language, this is allot more complicated, I'm not against it, just that I don't believe a single regex can be made to handle all situations i.e. regex to validate name \"John A. Smith\" would also say the name \"Dr. John Smith\" is valid, but \"Dr.\" is a title not name.... It may just be better to validate names as \"alphanum\" or split up the fields into First + Last name instead of a single field/variable.\n. that is true that most would expect it to be [a-zA-Z0-9], however that is ascii only, I can't see any harm in allowing unicode, because if anyone needed a field to specifically contain ascii only they should also already be using the builtin ascii validator as well.\nyes if you could fork and make a pull request, that would be extremely helpful. \ud83d\udc4d  might be a good idea to update both of there regex's:\nalphaRegexString          = \"^[a-zA-Z]+$\"\nalphaNumericRegexString   = \"^[a-zA-Z0-9]+$\"\n. Hey @byrnedo if you are still interested in this, I would definitely accept a pull request; but am closing for now.\n. Thanks @parveenkumar2308 \nYes you can override required and email, in fact can override any that is not part of this map by Registering a new validation see here\nIt's totally up to you, but since you need to register a new validation to override the old one anyway I would register the new email validation, but not override, but instead use a new name like \"uemail\"(for underscore email) that way you don't lose the functionality of  the regular email too.\nand as for the white space in the required tag you could combine required with any of the excludes tags \"excludes\", \"excludesall\" or \"excludesrune\", just so when someone reads your code(assuming someone else will) they can clearly see what's being validated.\nYou have many options :smile: the docs are pretty thourough if you need some code examples, I'd normally include some buy am out of town with no computer.\nHope this explains what you want, if not after I get back in town can provide some examples.\nP.S. you can also register alias validations that map to multiple others, see here to save some typing or add custom validation that are just a combination of existing validations\n. it doesn't really matter where the util file is defined, just need to register the functions.\nthere are 3 ways you can accomplish what you want with the required, I recommend option 2 or 3 but you may use any you wish.\nOPTION 1\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"regexp\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\nconst (\n    uEmailRegexString = \"custom email regex\"\n    uEmail            = \"uemail\"\n    sRequired         = \"srequired\"\n)\nvar (\n    validate    validator.Validate\n    uEmailRegex regexp.Regexp\n)\n// Person ...\ntype Person struct {\n    ID    string json:\"id\" validate:\"srequired,min=36,max=36\"\n    Name  string json:\"name\"\n    Email string json:\"email\" validate:\"required,uemail\"\n}\nfunc main() {\n    uEmailRegex = regexp.MustCompile(uEmailRegexString)\nconfig := &validator.Config{\n    TagName: \"validator\",\n}\n\nvalidate = validator.New(config)\nvalidate.RegisterValidation(uEmail, IsUEmail)\nvalidate.RegisterValidation(sRequired, RequiredWithEmptySpace)\n\nperson := &Person{\n    ID:    \"1\",\n    Name:  \"Joeybloggs\",\n    Email: \"Joey.Bloggs@email.com:\",\n}\n\nerrs := validate.Struct(person)\n\nif errs != nil {\n    for k, v := range errs.(validator.ValidationErrors) {\n        // Create error messages based on errors returned ...\n        fmt.Println(k, v)\n    }\n}\n\n}\n// IsUEmail ...\nfunc IsUEmail(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    return uEmailRegex.MatchString(field.String())\n}\n// RequiredWithEmptySpace ...\nfunc RequiredWithEmptySpace(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\nvar ok bool\n\nswitch fieldKind {\ncase reflect.Slice, reflect.Map, reflect.Ptr, reflect.Interface, reflect.Chan, reflect.Func:\n    ok = !field.IsNil()\ndefault:\n    ok = field.IsValid() && field.Interface() != reflect.Zero(fieldType).Interface()\n}\n\nif !ok {\n    return ok\n}\n\nreturn !validator.ContainsAny(v, topStruct, currentStructOrField, field, fieldType, fieldKind, param)\n\n}\n```\nOPTION 2\nno need for a custom validation for required, use 'excludesall= '\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"regexp\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\nconst (\n    uEmailRegexString = \"custom email regex\"\n    uEmail            = \"uemail\"\n)\nvar (\n    validate    validator.Validate\n    uEmailRegex regexp.Regexp\n)\n// Person ...\ntype Person struct {\n    ID    string json:\"id\" validate:\"required,excludesall= ,min=36,max=36\" // 'excludesall= ' ensures space is excluded\n    Name  string json:\"name\"\n    Email string json:\"email\" validate:\"required,uemail\"\n}\nfunc main() {\n    uEmailRegex = regexp.MustCompile(uEmailRegexString)\nconfig := &validator.Config{\n    TagName: \"validator\",\n}\n\nvalidate = validator.New(config)\nvalidate.RegisterValidation(uEmail, IsUEmail)\n\nperson := &Person{\n    ID:    \"1\",\n    Name:  \"Joeybloggs\",\n    Email: \"Joey.Bloggs@email.com:\",\n}\n\nerrs := validate.Struct(person)\n\nif errs != nil {\n    for k, v := range errs.(validator.ValidationErrors) {\n        // Create error messages based on errors returned ...\n        fmt.Println(k, v)\n    }\n}\n\n}\n// IsUEmail ...\nfunc IsUEmail(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    return uEmailRegex.MatchString(field.String())\n}\n```\nOPTION 3\nregister alias for required + excludesall to avoid some typing\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"regexp\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\nconst (\n    uEmailRegexString = \"custom email regex\"\n    uEmail            = \"uemail\"\n    sRequired         = \"srequired\"\n)\nvar (\n    validate    validator.Validate\n    uEmailRegex regexp.Regexp\n)\n// Person ...\ntype Person struct {\n    ID    string json:\"id\" validate:\"srequired,min=36,max=36\"\n    Name  string json:\"name\"\n    Email string json:\"email\" validate:\"required,uemail\"\n}\nfunc main() {\n    uEmailRegex = regexp.MustCompile(uEmailRegexString)\nconfig := &validator.Config{\n    TagName: \"validator\",\n}\n\nvalidate = validator.New(config)\nvalidate.RegisterValidation(uEmail, IsUEmail)\nvalidate.RegisterAliasValidation(sRequired, \"required,excludesall= \")\n\nperson := &Person{\n    ID:    \"1\",\n    Name:  \"Joeybloggs\",\n    Email: \"Joey.Bloggs@email.com:\",\n}\n\nerrs := validate.Struct(person)\n\nif errs != nil {\n    for k, v := range errs.(validator.ValidationErrors) {\n        // Create error messages based on errors returned ...\n        fmt.Println(k, v)\n    }\n}\n\n}\n// IsUEmail ...\nfunc IsUEmail(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    return uEmailRegex.MatchString(field.String())\n}\n```\nlet me know if this helps @parveenkumar2308, and if you have any more questions just ask.\n. Oh I misunderstood, options 2 & 3 are for any whitespace you are correct.\nthen option1 would be your best bet with your code changes :)\n. No problem, glad it worked for you :)\n. Hey @himanishk\nAbsolutely you should be able to combine baked in validation and Struct Level validation, could you provide a code sample of how you are trying to do it and I'll take a look ASAP\nUPDATE\nI think I may know the issue you may be running into, so you have a baked in required validation and in your struct validation are validating, let's say the field length, if you report the field length error from the Struct Level for the same field as the required it will override the required. I left it like this as someone may want to override i some situations.\nI can say though that moving your other validations to the Struct Level would be the best option to avoid this, if it is not desired. you can still validate fields from within the struct level if desired i.e.\n``` go\nerrs := v.Field(user.Required, \"required\")\nor\nerrs := v.Struct(user)\n// you can check if any errors or if that specific field error exists before running other \n// validations against it.\nif errs != nil {\n    structLevel. ReportValidationErrors(\"\",errs.(validator.ValidationErrors))\n}\n```\n. Hey @himanishk Thanks for the example.\nYes if Struct Level validation is present it will run regardless of an error on a single field, otherwise may miss out on reporting a different error on a different field. ( validator returns all errors for a struct, but only the first error encountered in each field. )\nThere are so many different ways to handle this, but in your situation I would recommend the following:\ngo\nif ptf.Start_Date != nil && ptf.Start_Date.Before(time.Now().UTC()) { // FAILS here with nil pointer as Start_Date is nil\n        structLevel.ReportError(reflect.ValueOf(ptf.Start_Date), \"UDateTime\", \"UDateTime\", \"afterdatetime\")\n  }\nYou can just check ptf.Start_Date != nil knowing that the required tag will already catch that error. This way you don't have to move all the validation inside the Struct Level.\nNOTE: even if you had to bring all validation for the Start Date field, there would be no need to bring the other field validation inside as well, baked-in and Struct Level validation play nice with each other.\nDoes this solve the issue?\n. no problems, \nP.S. just in case your interested I recently created a form decoder that is flexible like validator you can check it out here\n. I'm not quite sure what you mean, do you mean ability to validate []string on it's own and not part of a struct?\nor\nvalidate a single element within a []string but not the others?\nthere is the ability to validate any field individually using validate.Field example shown here\n. Oh OK, yes totally doable with or's in the tag\neg.\n``` go\npackage main\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\nvar (\n    validate *validator.Validate\n)\nfunc main() {\nconfig := &validator.Config{\n    TagName: \"validate\",\n}\n\nvalidate = validator.New(config)\n\nfld := []string{\"M\", \"F\", \"O\"}\n\n\nerrs := validate.Field(fld, \"dive,eq=M|eq=F|eq=O\")\nfmt.Println(errs)\n\n}\n```\ndive - tells the library to go into/dive into the array\neq=M|eq=F|eq=O - says any value in the array must be equal to M or F or O\nif using on a single field and not an array, just remove the dive tag.\ndoes this example explain what your looking for?\n. Hey @phenrigomes just checking if my example was what you were looking for?\n. Thanks! Is also a typo in the paragraph above if you would like to also fix and as soon as I'm back at a computer will merge and cut a release.\n. Thanks! @kenkouot \n. Although maybe a bit confusing, this is the expected behaviour.\nvalidator sees that there are validations that it is supposed to check, but has not been told it is ok to be nil and therefore fails on the max tag as it cannot be checked. The only alternative was to ignore validations for values that couldn't be read, but that is way worse IMHO.\nadding omitempty is the correct action if it is ok to be nil, otherwise because it's a pointer can use exists tag to ensure a value exists.\nSide note: I know the exists tag and required tag are a bit confusing as required kind of implies exists; required should really be nondefault and I will correct this in v9 some day, but right now would break a great deal of existing code.\nI hope this explanation makes sense?\n. @kujenga Awesome :)\nyes if a pointer is non nil, validator will extract the actual literal value and then validate agains't that. You can see how in the ExtractType function which is called before checking any values.\n. @robbrockbank Currently no there is no way to do this, the current design would be to register a validation for the thing Struct and validate field1 and field2 from within.\nBut you have peaked my interest about possibly adding this type of functionality and so looking to clarify the idea a bit more.\nSo checkFooStructIsBlue would be a method on the FooStruct like so?\n``` go\nfunction (f FooStruct) checkFooStructIsBlue(...validation helpers etc) {\n//validate here\n}\n```\n. Thanks for the details @robbrockbank , yes I am definitly interested in adding this sort functionality, I will have to think about what all to pass to the function. \nSecond part is should the function just return true or false for validation or allow for many fields to be validated like the Struct level validation...any input would be appreciated :)\nP.S. It may take me a while as I am creating, updating and maintaining a bunch of other projects in go-playground but promise I will get to it as soon as I can.\n. Awesome thanks!\n. Hey @robbrockbank \njust letting you know that I started looking into this, I could probably use the existing validation signature and ability to register custom funcs; the only thing I'm having trouble with is trying to figure out how to implement it without a bunch of rules that people would have to follow and remember.\neg. all validations need to be after struct specific tags such as structonly and nostructlevel but that's not always true as exists, omitempty and required can and should be used before the struct specific tags.\nI'm just worried that it will make the rules for using validations on structs so complex that it will make validator less user friendly.\nWhat do you think, would the example above be confusing or hard to remember? or am I just being pedantic?\n. Hey @robbrockbank \nI agree there are a few things that can be done to make it work, that was never in doubt, however all idea's that I can come up with would make it a little more confusing to use; I could eliminate the confusion and make it easy, but it would require some breaking changes.\nSo I think that, If you can live with Struct Level Validation for now, I will add this to the list of features for v9 where it can be added in a better manner better.\nIt will take a while to fully complete v9, but I think it will be worth it for all.\nplease let me know of any other changes that you may like to see and I'll also try and see what I can do for v9\n. Hey @robbrockbank after allot of tinkering and feedback from other users I will probably not be implementing this feature; it's just too much of a one off that really affects performance and ease of use.\n. Hello @wenchma\nthere are a few options, first off just need to point out that because Go is statically typed, the way Address is defined within the User struct it will never be empty.\nOption 1:\nchange address definition in user to Address *Address and then can add the omitempty tag.\nOption 2\nchange address definition to allow for multiple addresses `Address []Address's and when no items exist in the array it won't get validated.\nOption 3\nthis one is probably not desired but could also set omitempty tag on each field withing Address and allow a blank address.\nSorry for the lack of code, answering from my phone, please let me know if this makes sense or need any more help.\n. The only reliable way would be to convert it to the correct type and then validate,\nthere are a couple of options.\n1. Convert it prior to checking, I am assuming number is an int:\ngo\ni, err := strconv.Atoi(\"2\")\nif err != nil {\n// handle error here\n}\nv.Field(i,\"required,gt=1\")\n1. Create a Custom Validation which converts it in the background for you and then uses the normal validation.\nNOTE: didn't test the code but it should work\n``` go\nfunc AtoiGT(v *Validate, topStruct reflect.Value, currentStruct reflect.Value, field reflect.Value, fieldtype reflect.Type, fieldKind reflect.Kind, param string) bool {\nif fieldKind != reflect.String {\n    return false\n}\n\ni, err := strconv.Atoi(field.String())\nif err != nil {\n    return false\n}\n\nvo := reflect.ValueOf(i)\n\nreturn validator.IsGt(v, topStruct, currentStructOrField, vo, vo.Type(), vo.Kind(), param)\n\n}\nv := validator.New(&validator.Config{TagName: \"validate\"})\nv.RegisterValidation(\"atoigt\", AtoiGT)\nv.Field(\"2\", \"required,atoigt=1\")\n```\nPlease let me know if this helps :)\n. I will take a look at this asap\n. Hey @robbrockbank \nok I know why this is happening this way, let me explain:\nhere is from the docs:\nOmit Empty\nAllows conditional validation, for example if a field is not set with a value (Determined by the \"required\" validator) then other validation such as min or max won't run, but if a value is set validation will run.\nUsage: omitempty\nso the key there is determined by the \"required\" validator and as I have mentioned before required will become nondefault in v9 someday; so the reason it's not failing on gte is because required is seeing 0 as the default value for the int INSTEAD OF nil. So coincidentally the only reason there is an issue is because the value is 0, any other number would have proceeded as expected.\nI totally agree, this is a BUG and should have behaved as you expected! I plan to keep track if the field in question's base type was a pointer, and if it was and we get to the lower omitempty logic then don't have to check omitempty because if we got there, there is already a value. \nI think this also may be an issue if MyInt was an interface{}\nThank You! Very Much! for reporting @robbrockbank this is the first legit bug found and to be fixed in validator in quite some time; I will have the FIX in before the end of the day.\n. Hey @robbrockbank this should be fixed now via release v8.17.3\nplease update and let me know if this is fixed for you and we can get this issue closed! \ud83d\ude04 \n. No problem @robbrockbank I not only maintain but actively use validator in a bunch of enterprise applications, so if there's a bug I try to squash it immediately for everyone, including myself ;)\nok gopkg.in, I'll try to answer as best I can.\nSo first off ''go ge\" when hitting a gopkg.in URL is sent back what is essentially equivalent to , but not the same, as a redirect to an actual brach of your code.\nSo when you have more created any releases in your code, gopkg.in will grab the latest code in your repos default branch ( as I recall, you don't normally use it this way so...)\nso you setup a branch in your code say v1 then go to your releases tab in GitHub and create a release for branch v1. Now here's the most important part you have to use semantic versioning so your tag has to be in the form v1.0.0, or going.in will not recognise the release. And as soon as you do the gopkg.in knows to redirect to that specific branch with that release.\nSo in short to answer your question, gopkg.in will see the new released version as soon as you create it. Think of it as just redirecting go get to your released version. As for the godocs that gets refreshed at least once a day, but can force a manual refresh from the bottom of the godocs screen.\nThere is a bunch of documentation on Google.in here that may be more helpful http://labix.org/gopkg.in\nYa if you ever have any questions and don't want to create an issue, just contact me @ Dean.Karn@gmail.com\n. thanks @alioygur for your feedback! \ud83d\ude04  and don't worry the dive tag is staying!\nas for # 4 - I think you may be right\nI was hoping you could expand on 2 of your answers:\nChange required to nondefault or have both tags present? required makes more sense when reporting errors, but nondefault is clearer for those using the library. Thoughts?\nI do not agree with this.\nSo you are saying just stick with required?\nWhen you say it is small, do you mean the number of validations? if so if you could provide a list of ones you would like to see I could work towards adding them.\n. Hey @alioygur just released v9.0.0 RC1 and would love your feedback if you can find time :)\n. v9 has been released!\n. Hey @parveenkumar2308 \nI can't see where the regex validation is being registered, it may be that it's the undefined validation ( I will add a better error message with the tag in question within the error message ). \nThere also seems to be an  issue with your regex, Go does not support negative lookahead's:\npanic: regexp: Compile(\"^(?=.[a-zA-Z0-9`!@#$%^&.?/\\\\]).*$\"): error parsing regexp: invalid or unsupported Perl syntax: `(?=`\nIt also looks like you're running an older version of validator, I've made a few improvements to v8 ( all non-breaking changes ) that you should update; I don't think this is the problem but would help with the stack trace.\nRegardless of all that, I highly recommend you do not pass regex's as a validation param,\nhere is an excerpt from the documentation\n```\nregex\n    a regex validator won't be added because commas and = signs can be part\n    of a regex which conflict with the validation definitions. Although\n    workarounds can be made, they take away from using pure regex's.\n    Furthermore it's quick and dirty but the regex's become harder to\n    maintain and are not reusable, so it's as much a programming philosiphy\n    as anything.\nIn place of this new validator functions should be created; a regex can\nbe used within the validator function and even be precompiled for better\nefficiency within regexes.go.\n\n```\nhere is the way I recommend once you correct your regex ( as a side note I initially tried to use a regex for password validation, but because Go doesn't support negative lookahead's so I just did the checks without the regex within a custom validation )\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"regexp\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\n// Person ...\ntype Person struct {\n    ID       string json:\"id\" validate:\"required,min=36,max=36\"\n    Password string json:\"id\" validate:\"upwd\"\n}\nvar (\n    validate       = validator.New(&validator.Config{TagName: \"validate\"})\n    passwordString = \"^[a-zA-Z0-9]$\" // regex that compiles\n    passwordRegex  = regexp.MustCompile(passwordString)\n)\nfunc main() {\nvalidate.RegisterValidation(\"validpasswd\", func(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    return passwordRegex.MatchString(field.String())\n})\nvalidate.RegisterAliasValidation(\"upwd\", \"min=8,max=20,validpasswd\")\n\nvar errMsg string\n\nperson := Person{\n    ID:       \"36\",\n    Password: \"!!!!!!!!!!!!!!\",\n}\n\nif errs := validate.Struct(person); errs != nil {\n\n    if err := errs.(validator.ValidationErrors)[\"Person.Password\"]; err != nil {\n        if err.Tag == \"upwd\" {\n            errMsg = \"invalid password!\"\n        }\n    }\n}\n\nfmt.Println(errMsg)\n\n}\n```\nPlease let me know if this helps \ud83d\ude04 \n. Hey @parveenkumar2308 , sorry for the lateness of my reply, busy day,\nyes it could work for either one, but there are several reasons I would not.\n1.  you'd have to change all , within the regexes to 0x2C and all | to 0x7C a mentioned in the documentation here which makes reading your regex harder.\n2. putting regexes in tags quickly makes reading the tags harder and when combining with DB tags and JSON tags, can get dirty quick.\n3. regexes in the tags aren't reusable, if you wanted to reuse one you'd have to copy and paste. If a regex ever needed to be updated, would have to potentially update multiple locations and not forget one.... whereas registering a validation you can fix all locations in one stroke.\n4. if passing regexes in from the struct tags then you have to compile the regex every time a regex validation is used before even using it, which is allow of wasted CPU time. if added as a validation can precompile the regex and reuse that compiled version.\nHope this clears some of the details up :)\n. Hello @MarcoVigna17 \nYes it is possible, but there is no built in tag for it.\nYou have two options:\n1. Create a custom validation for your specific struct and then add that new tag to your struct field(s)\n2.  This level of complexity however is best suited for StructLevel validation I would just register a Struct level validation and use ReportError when there is an issue. Struct level and tags are completely compatible and work together.\nSorry for no examples, answering from my phone; if you need an example just let me know, I should be able to hop on a computer in a half hour or so.\nP.S. what version are you using? v8 or v9\n. Ok awesome, let me know how it goes.\nI know v9 says it's RC1 but I don't foresee any changes and will be flipping it to stable in a few weeks ( just want to add an extension to allow for translating errors using my universal-translator package, but will probably be located in another repo )\n. Hey @MarcoVigna17 \nya the reason it doesn't is because it's within an array, the dive tag is exactly what you're looking for, you can actually validate against array and then dive down into it like so:\ngo\ntype OuterStruct struct {\n    Values      []InnerStruct   `json:\"values\" validate:\"required,gt=0,dive\"`\n    ExtraValue   string         `json:\"additional_value\"`\n}\nand that will validate that the array exists, there is at least one entry in the array and then to div into it...\nsorry for the short answer, bust day today, let me know if this works for you.\n. Hey @MarcoVigna17 \nGlad it's working for you :) \nAs for the order, it's because the error returned is really of type ValidationErrors which is a map[string]*FieldError and maps in go are not ordered like in some other languages; in fact when iterating over them they are purposely randomised (there is a good reason why, but that's another discussion)\nThis is one of the things that v9 inherently solves though as the error returned is really an array of error instead of a map; if you are starting fresh I highly recommend using v9 over v8.\nLet me know if that makes sense :smiley:\n. that's great @MarcoVigna17 \nThe param represents the comparison value I.e. if you had a struct tag defined like so gt=1 then 1 would represent the param, in string form. I had forgotten to accept the param in v8. \nYou may be asking why it's important, well the errors returned are actually FieldError and all aspects of a validation error are accessible, including the param; the reason all aspects are accessible are is to allow for creation of your own error messages and the param not only should be in the error messages eg.  Field must be greater than 1 character long for a validation tag of gt=1 but also need it for proper plural rule translation which I intend to build functionality for using my universal-traslator package ( just debating on the best way to integrate it)\nThis version should be perfectly stable just like v8, they have and pass the same tests which cover 100% of the code; I will be flipping v9 to stable, I was just waiting to add the aforementioned translation logic, but no reason I can't flip it right now. I will flip it to stable for you by the end of the week.\n. Hey @MarcoVigna17 as promised v9 has been released!\n. Thanks!\n. Hey @adrian-sgn , thanks for the question\nThe dive tag is really used to dive into the values of a map or array not the keys. Usually the maps key type protects it from bad input.\nI think the way you have done it is correct all you have to do is cast the field as Label instead of String() and iterate over all keys.\napologies for the short example, answering from my phone\n``` go\nfunc ValidLangCode(fl validator.FieldLevel) bool {\n    validLangCodes := map[string]bool{\n        \"en\":true,\n        \"es\":true,\n        \"pt\":true,\n    }\n    fmt.Printf(\"Validating %s\\n\", fl.Field())\nvar ok bool\n\nfor k, v := range fl.Field().(Label) { // may also want to validate the cast to a label succeeds before this\n    if _, ok = ValidLangCodes[k]; !ok {\n         return false\n    }\n}\n\nreturn true\n\n}\n```\n. You are correct @adrian-sgn the key won't be returned,\nthe only way you could do that is using StructLevel validation, but may not be whay you want.\n. Not a bad idea, I was thinking of how to do it and a keys tag would definitly work.\nI will look at adding this in the weeks to come :)\n. Hey @adrian-sgn I took a preliminary stab at this and is currently under the validate-map-keys branch if you wanted to check it out and let me know if it works for you; I did build your example directly into the test here so you can take a look and reverse engineer.\nHow it works\n\nadd two new tags keys and endkeys ( needed to know when done with keys because of the multidimensional nature )\nexample:\n\n``` go\n// for a map of\nmap[string]string\n// and validation tag's would be\nvalidate:\"gt=0,keys,lang_code,endkeys,dive,required\"\n// and the validation with check lang_code against all keys and then continue and validate required on the values\n```\n. Hey @adrian-sgn not a bad idea, but this library is designed for tags to only apply to a single value instead of a type and that's why once you get into a certain level of complexity, it's usually better to use struct level validation, however you did give me a couple ideas I'll have to think about.\n1. Instead of/complimentary to struct level validation have a custom type validation where you register a type to be validated, much like struct level but for any type.\n2. Allow struct tags to not just point to a validation functions but custom type function, like number. 1 above but also have to provide a tag name.\nWow just got v9 out and these things although could be added in a backward compatible way, but will completely change the backend lol :smile: but this is exactly why I love open source with many people contributing ya can end up with something better than you could have imagined, just on your own \ud83d\udc4d \nI'll hold off adding key diving until I explore the above 2 options.\n. Hi @23doors I had a working implementation, but was considering perhaps adding the Map validation function instead as checking map values it usually about checking a range of values, which would be better to do in a custom function rather than in Struct tags as a hard coded list.\nEither way, map keys can already be checked by registering a StructLevel validation..Which is almost exactly like a map validation function; and works with the struct tags as well.\nMaybe if you can give me an example of your use case I can better determine what the best course of action to take.. Thanks @23doors and that's exactly why I haven't closed or completed this issue as nobody hasn't been able to satisfy their needs with struct level validation; so why add more complication to the library :)\nBut if someone can give me a use case for it, I'd definitely pursue it again.. @23doors I don't expose the function directly but do through validate.Var(...)\nSo they are exposed but you can also apply multiple validation checks at a time and can use ReportValidationErrors from within struct level validation.. @23doors I'd give a better example but am shopping and answering from phone...Let me know if you need any help.. Hey @jawher I'll have to think about this I just find being Implicit rather than explicit very dangerous.\neg. Developer 1 creates struct and add partial validation\n`` go\ntype Child struct {\n    Name       stringvalidate:\"required\"Age        intvalidate:\"gt=1\"`\n}\n// soma validation code, maybe not even in the same place as struct\nerrs = validate.StructPartial(subject, \"Child.*\")\n```\nThen some other developer comes along and adds another field, without knowing there is partial validation going on, \ngo\ntype Child struct {\n    Name       string `validate:\"required\"`\n    Age        int    `validate:\"gt=1\"`\n    Sex        string `validate:\"required\"`\n}\nand now the Sex field is being validated, but do you want it to be? Is it going to cause problems?\nI was very hesitant to add the StructExcept and StructPartial in the first place.\nRisks\nYou are correct it will affect performance of StructPartial times the number of partials passed in. I am not against this functionality if it only affects the StructPartial and StructExcept`(yes would be nice to have in except too ) functions performance. \nI would probably accept a pull request.\nNew Functionality\nI am currently experimenting with some new functionality that will solve several requests that have been raised here including #255, #254 and #245 which may make this unnecessary.\ninstead of some new partial validation as you suggested, I was going to add the ability to report error directly from within the FieldLevel validation functions, much like the StructLevel's ReportError(...) function.\nThis would essentially allow users to use custom validations just like they are today or if they choose, to implement more complex validations on their own and just return true.\nThere are a few hurdles I have to work out, like validation tags currently aren't supported on struct field except for omitempty and required.\nbut my v9 changes to interfaces will allow me to add this functionality without making breaking changes; it will affect performance but it should be negligible. It will take me a while to complete, pretty busy right now, but I intend to get this done if you can wait.\n. Hey @jawher \nthanks for the reply, I like it! it is a great idea! \ud83d\udc4d \nI would definitely like to add that functionality, the only change I'd make is passing the path via a []byte otherwise there would be an allocation for every field to create the string to be passed as the field namespace is a []byte and is would pass the Struct namespace and not the other that could be different by tag.\n``` go\nvalidate.ValidateFiltered(user, func(ns []byte) bool {\n    return !bytes.Contains(fieldPath, []byte(\".Sex\"))\n/// NOTE: []byte(\".Sex\") could be precomputed\n\n})\n```\nand just use the bytes functions instead of strings\n. Hey @jawher \nI added this functionality in Release 9.2.0 please take a look and let me know if this solves it for you.\n. Hey @jawher just checking in to see if you'd had a chance to check this out yet :)\n. Thanks @jawher I didn't realize that would happen...\nI'll merge this as soon as I get a chance this afternoon\n. Hey @YamiOdymel \nthat seems like a good and very common validation to have, if you could provide some sample code of how you are doing it manually I would definitely add it as one of the baked in validations :)\n. Thanks @YamiOdymel \nNo problem, I am busy also or would take a stab at it myself\n. Hey @mehdy\nWould you be able to provide and example of how/when this validation would be used?. @mehdy ok I see\nI don't think I'd want to add that to the built in validations, only because it is a pretty specific validation case, I only add ones to the core that everyone would use the same way.(I really need to create a separate repo for validations that aren't in the core so people can register then as needed)\nBut you could also implement this as a custom validation and replace the alias, then you could use a switch. https://godoc.org/gopkg.in/go-playground/validator.v9#Validate.RegisterValidation. Hey @dkostenko no problem, but there is actually a better way built in to get any tag name, even JSON\nyou just have to register your own TagNameFunc and then essentially do the same thing you did to grab the tag name and return, the benefits to using the built in way is that the information is cached and function really only called once.\nThen the err.Field() will have whatever name you returned from the function and err.StructField() will have the struct field name.\nSorry answering from my phone, I'll post some sample code once at a computer, but it's pretty easy to figure out :)\n. @dkostenko here is some sample code:\n``` go\nvalidate := New()\nvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n    name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\nif name == \"-\" {\n    return \"\"\n}\n\nreturn name\n\n})\n// ... validate\nvalidationErrors := err.(validator.ValidationErrors)\nvalidationErr := validationErrors[0]\nfieldName := validationErr.Field() // this will return the JSON tag name\n```\n. Hello @wanghq \nIn short yes the order of omitempty does matter, but not in your example, they should be false failing on the min validation.\nI don't exactly know what util.Int32(0) is returning, but I'm assuming it's a pointer to an integer with value of zero.\n``` go\npackage util\nfunc Int32(val int32) *int32 {\n    return &val\n}\n```\nI ran the following code, and both returned false for me and both failed on the min validation as expected.\n``` go\npackage main\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\nfunc main() {\nvar i int32\n\nthing1 := struct {\n    P1 *int32 `validate:\"omitempty,min=1,max=300\"`\n}{\n    P1: &i,\n}\nthing2 := struct {\n    P1 *int32 `validate:\"min=1,omitempty,max=300\"`\n}{\n    P1: &i,\n}\nc := &validator.Config{TagName: \"validate\"}\nv := validator.New(c)\nfmt.Println(v.Struct(&thing1) == nil) // false\nfmt.Println(v.Struct(&thing2) == nil) // false\n\nfmt.Println(v.Struct(&thing1))\nfmt.Println(v.Struct(&thing2))\n\n}\n```\nperhaps this was a bug, but has been corrected and you just need to run go get -u gopkg.in/go-playground/validator.v8 ... assuming you don't have the latest version already( allot of people use validator through gin, the bundled version in gin is: v8.15.1 but the current version is v8.18.1 )\nplease let me know if this fixes it for you \ud83d\ude04  if not we can dig a little deeper to find out what's going on.\nP.S. if you are new to validator I highly recommend using v9, allot was simplified and cleanup up for the end user, there is even an upgrade example for gin if you're using it that way here\n. Hey @jonmchan \nThat is very strange, the errors returned in v9 are in an array and validator is synchronous, so they should always return in the same order.\nI will investigate, if you could provide your full test code that would be helpful, just to rule out the reuse of a variable or something.\nP.S. it looks like your using validator through gin, could you please confirm that it is actually using v9 and not v8; the default vendored version in gin is v8 and v8 returns a map, so order cannot be guaranteed.\n. @jonmchan update,\nfound the issue, I was storing the field cache in a map (for some reason) converting to an array now; should be fixed within a few hours at most :)\nthanks for reporting\n. Hey @jonmchan \nI've made the appropriate changes in release 9.2.2, please confirm this solves this for you :)\n. Hey @justinclift \nalpha & alphanum should be the only validations that do not support latin characters that could/should(if not let me know) and yes I am interested in including 2 more validations.\nI would like to add unicodealpha and unicodealphanum to accept unicode characters, can't break the current validations, the only thing is that the regex in #239 not only accepts unicode characters but also symbols which is probably not desired.\nI am completely open to a pull request to add the above validations(or any other validations) as long as they only accept characters and alphanumeric characters; it's on my list of things to do but don't know when I'll get to it. Any help would be appreciated :smile: validations are pretty easy to add, it's all the tests to add that takes a bit.\nif you are also referring to actual name validation mentioned in #239, as I had mentioned this is a very subjective and case-by-case thing, however, I have been thinking of creating another repo(or perhaps a subfolder/subpackage in this one) to hold validations that are not in the core but are available to be easily registered if one wants to use them; what do you think?\n. Hey @justinclift \nNo you are not missing anything, as my previous comment mentioned, I would like to add them; they do not yet exist.\nMy time is just very limited right now and don't know when I can get to adding them, if someone could add them and make a pull request I'd merge it.\nI will attempt  to add these sometime this morning if I can find time.. Hey @justinclift \nI've added alphaunicode and alphanumunicode in Release 9.3.0\nplease let me know if this helps. No worries I know how things can get busy :smile:. Hey @mrLSD thanks,\nJust so I understand, so you have a custom validation and want to set the value of the field and after the validation has run have the field still be set on the struct or variable passed for validation?. @mrLSD \nok I understood correctly, unfortunately this is not possible the way that validator is currently configured to work. It seems simple at first glance, but once getting into nested structs, arrays, maps, interfaces and pointers assigning values gets allot more complicated and the way validator works is it dereferences pointers before passing along to the validation functions, and so although the field value is accessible, it is no longer assignable.\nI have toyed around with the idea of adding similar functionality, much like the conform library(which is almost what your looking for), however it always ends up overcomplicating the validator package and I would prefer to keep validator for validation only.\nI would recommend creating your own function to set default values and call that prior to validation; could even get fancy and have a map with key type and value the function to be called to set default values and have a single common function that all you need to do is call it and it will check the map and call function if exists.\nThanks for the question though \ud83d\ude03 \n. Thanks for reporting @thessem it ha been corrected in release v9.3.1\nPlease test yourself and let me know that it's working for you as well \ud83d\ude04 \nAs for making structonly the default behaviour currently there is no way to set that as the default behaviour thanks you for the idea though, I'll add this to a list of future additions much like it works in go-playground/form\nThis is just an assumption so please correct me if this is not correct, I assume if you're looking for structonly as the default behaviour then your using structlevel validation only, if that is the case and you don't have any validations on the struct fields themselves then they won't get cached and fields will not be checked every time if worried about performance.. Hey @thessem \nThis is an interesting one, haven't seen it in a while so there are a few options depending on how the references are made, but the best one is:\nYou could use the structonly or nostructlevel tag on the User field of Address after the required tag. this is a good option if the user on the Address is assigned by the program and not user input, which most circular data would be, see the docs here.\ngo\n// Address houses a users address information\ntype Address struct {\n    Street string `validate:\"required\"`\n    City   string `validate:\"required\"`\n    Planet string `validate:\"required\"`\n    Phone  string `validate:\"required\"`\n    User   *User  `validate:\"required,nostructlevel\"`\n}\nplease let me know if this works for you :). Hey @thessem just checking to see if this worked for you.. No problem @thessem \nI too wish there was an easier way, just don't know how to tell validator the user on the address and the address on the user is recursive without a tag or some other equivalent logic.\nAnother way, which would be more 'pure' would be to do only struct level validation that way you could program the logic to not recurse and still maintain all the benefits of validator.. Hello @cbandy \nI haven't seen that one before. \nI immediately suspect that it because the struct used in your array is unexposed(lowercase name) which will limit the I formation the validator package can get from the struct, but I will look into this and verify exactly what's happening.\nIf you wanted to try with an exposed struct in the mean time that would sure speed things along :)\nThanks. Hey @cbandy \nI've corrected the issue in Release 9.3.2 \nIt was an issue with checking the wrong namespace variable before calling nested struct validation.\nplease let me know if it solves the issue for you.. Thanks @osamingo \ud83d\udc4d . @pipejesus it sounds like your validation is getting a bit more complicated and there are a couple of options.\n\n\nCreate your own custom validation, requiredref or whatever you wish to call it, and within the validation you will have access to the entire struct via the Field Levels Parent function but this doesn't help you get the value out into the calling program so option 2.\n\n\nCreate a StructLevel validation where you have full control of the error reported using ReportError and access to all fields withing the struct, see here\n\n\nI hope to combine both FieldLevel and StructLevel validation in the next version to avoid any limitations.\nIf you have any more questions please don't hesitate to ask.. glad it worked for you @pipejesus\nYa there isn't a great way right now, but it all works and the most important thing is consistent error reporting output.\nThere is one more way you could do this if your interested, the very first value passed to ReportError will be accessable in the resulting FieldError from the Value that way you can get the jaref value and also a param of one exists...May also be a little more idiomatic.. @junaidaziz-kwanso It depends on how your storing it in your struct I suppose, more details are definitely needed; what does your struct look like?. Oh ok @junaidaziz-kwanso so it's a path to a file on disk.\nSo for checking if it's present you can use os.Stat() to determine if the file exists by checking if error returned is nil or not.\nAs for checking if it's valid, it depends on your situation, you could:\n- Check the file extension e.g. .PNG, .Jpg.. if that can be trusted\n- if it can't be trusted you could look into using the image package to decode the file and if it fails then it's not valid.\n- if the image is coming from an http request you could get and store the mime type alongside of the file path and validate it's validity based off of that field (this is the way I do it most of the time)\nSorry for the formatting but answering from my phone, not at a computer yet ;)\nPlease let me know if this helps or you need any help:). Ya no problem @junaidaziz-kwanso just give me a couple hours, I'm getting ready for work now :). ok @junaidaziz-kwanso so normally I have a struct like this:\ngo\n// Image struct for image information and storage location\ntype Image struct {\n    Path        string `validate:\"required\"`\n    Filename    string `validate:\"required\"`\n    Ext         string `validate:\"required\"`\n    ContentType string `validate:\"required\"`\n    Bytes       int32  `validate:\"required,gt=0\"`\n}\nThen parse the form and normal stuff\ngo\n// 1024 * 1024 * 2 = 2MB\nif err = r.ParseMultipartForm(1024 * 1024 * 2); err != nil {\n    fmt.Println(w, \"There was an error parsing the form values.\")\n    return\n}\nthen process the file information into the struct:\nhttps://golang.org/pkg/net/http/#Request.FormFile\n```go\nfile, header, err := r.FormFile(\"File\")\nif err != nil {\n    ...\n}\n// copy file to final destination, verify size limits or whatever your application does\n// note: if copied to final destination and/or renamed use those value(s) instead of \nheader.Filename for Path, Filename and Ext.\nimg := Image{\n    Path: filepath.Dir(header.Filename),\n    Filename: filepath.Base(header.Filename),\n    Ext: filepath.Ext(header.Filename),\n    ContentType: header.Header.Get(\"Content-Type\"),\n    Bytes: // can get this while copying or other ways....\n}\n```\nthen you can validate the Content-Type in your struct validaiton to ensure it's a supported image type; you may even want to verify that before doing all of the copying etc... but that's up to you.\n```go\n// var somewhere\nvar acceptedImages = map[string]struct{}{\n    \"image/png\": struct{}{},\n    \"image/jpg\": struct{}{},\n    ...\n}\n// in struct validation, assuming you're also storing Content-Type\nif , err := os.Stat(watermarkStep.WatermarkImage); err!=nil {\n    sl.ReportError(watermarkStep.WatermarkImage, \"WatermarkImage\", \"WatermarkImage\", \"image not found\", \"\")\n}\nif , ok := acceptedImages[watermarkStep.ContentType]; !ok {\n    sl.ReportError(watermarkStep.ContentType, \"ContentType\", \"ContentType\", \"unsupported image type\", \"\")\n}\n```\nHope this Helps \ud83d\ude04  think you'll be able to adapt to your needs; let me know if you need anymore help.. Thanks @ellisonleao . @fasilenko  It looks like GitHub or Gopkg.in is having some problems, the key error is error: RPC failed and fatal: The remote end hung up unexpectedly\nthis has happens to me a few times a year, I assure you it has nothing to do with validator itself.\nI just did a go get -u gopkg.in/go-playground/validator.v9 to confirm and it successfully completed for me.\nOther Possibilities\n\nInternet connection issues.\nFirewall or proxy is blocking.\n\nWhat OS are you using? and what Git version?. Thanks @mrxinu will fix tomorrow. Hey @semir-karic \nyep that's totally doable, you just have to Register a Custom Tag Name function\ne.g.\n```go\nvalidate := validator.New()\nvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n    name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\nif name == \"-\" {\n    return \"\"\n}\n\nreturn name\n\n})\n```\nThanks for the question, let me know how it goes :smile:. Awesome glad it worked :thumbsup:. Hey @adred \nThat is interesting, I will have to write up a proper test and check it out. I am unfortunately busy until the weekend, but would be happy to help then.\nI do have a suggestion though, would you be able to simplify your example and just have the Validate function return the validation error and print it out, just to rule out any of the other logic possibly causing an issue.\nAnd the other thing that may work is to try to get the value of the interface prior to validating eg.\n```go\n// Note not tested\nval := reflect.ValueOf(I).Interface()\nvalidate.Struct(val)\n```. Stack Overflow question delete, so I guess solved. Hey @theobouwman \nYou can validate every URL value on its own using 'validate.Var(...)`\nor decode the URL.Values into a struct and then validate the struct. Check out form for decoding URL.Values into struct.\nSorry about no code example, answering from my phone..Let me know if this helps :). Hey @theobouwman \nOk so your query param is all lowercase module-uuid and the form library doesn't know what field that is in the struct unless the field name matches or you add the following to the field tag form:\"module-uuid\" so it knows which field it should decode it into.. I'm far away from my computer right now but I think it may have something to do withuuid.UUID` type\nAlthough it's underlying type is string, which form is seeing,  a uuid isn't really a string...If that's the case then you just have to register the uuid.UUID type with form...I know it seems like allot and I wish I was near a computer to confirm...But let me know ow if that works. Oh I see both form and validator are intended to be initialized only once and then that instance reused eg.\ngo\ndecoder := form.NewDecoder(...)\nThen use decoder over and over throughout your entire application, it along with validator, cache the struct information for speed and efficiency.\nCould create a utility package which has both form and validator exposed.\nThe way I do it is have a struct with applications variables etc on it and my http handlers are just a function of that struct and so each handler has direct access to form and validator; if your new to go that may seem co fusing...I will post a sample later on in the day when I find some time though.. No @theobouwman it is not inneficient and works for most projects just fine.\nHowever once a project gets to a certain size it just becomes easier and easier for a config type package to become a dumping ground for anything and it can get harder to keep separations of concerns; it's like having a function that more and more parameters keep getting added, even if you only use two.\nHere is how I would do it.\n```go\npackage users\ntype UserConfig struct {\n  // application vars\n}\nfunc New(whatever vars the user handlers need) *UserConfig{\n  return & UserConfig {\n    // Set vars\n  }\n}\nfunc(app UserConfig) GetUsers(w http.ResponseWriter, r http.Request) {\n// now I have access to all the UserConfig vars directly app.WhateverVar\n\n}\n// And in main package\nusers := users.New(...)\nhttp.HanderFunc(\"/users\", users.GetUsers)\n```\nDoing it this way allows you to split/keep your applications logic in its rightful place and only exposes what you want to each of your handlers.\nNote: you can be as fine grained as you want with splitting your http handlers into packages like the users package above...It is not strictly necessary though.. Thanks @flebel . @nicpottier I have not encountered _examples as a convention for the filenames\nThis seems like an issue with glide itself; it should not be grabbing dependency imports except those referenced from the validator package.\nWhich means that it is behaving contrary to go get\nIf this is happening I would file an issue with glide as it is not behaving correctly or perhaps there is an option/argument for it.\nPlease let me know what comes of this, I am interested to know the results :)\n. Ok I see what's happening glide must be running go install ./... or go build ./... which is recursive.\ngo get does not behave this way it runs go install or go build\nperhaps try passing the -d flag like go get.\nThe -d flag instructs get to stop after downloading the packages; that is,\nit instructs get not to install the packages.\nYou are correct the go build will ignore any directory beginning with and _, . or the testdata directory.\nI will look into renaming the examples directory in all my pacakges to _examples to avoid this issue, but I still see it as an issue with glide. I see what you mean, it should panic if any issue; because if any validation fails to register there's a failure point, especially if an error is ignored.\nI think it must have been some legacy code hanging around.\nI unfortunately can't change v9 for compatibility reasons but will change as an enhancement for V10 some day :)\nThanks for bringing to my attention.. No there's currently no way to customize the field name, usually I keep the messages generic.\nIf you keep them generic then after validation could have your own logic to translate the field name and combine with the rest of the translation...or just handle the whole translation after an error.\nHaven't yet thought of a good way to dynamically change the field name.. Thanks @james-maloney means a lot :)\nActually there may be a way to do what your looking for, when registering a translation function your could reference a pre-built map, or translation from within your function and while building the translation could substitute the Field name with whatever your want.\nI admit it is an annoying amount to boilerplate to define a translation for every field name, but at least you only have to do it once...per language :(\nI wish I could think of a better way to do it, but the reality is for everything you want to translate you have to have a translation for...\nOpen to any suggestions or ideas anybody has :). Hey @s4l1h \nSo I'm assuming you are looking to access the struct field name from within the validation, currently there is no method to get that value...bit after a validation fails your can https://github.com/go-playground/validator/blob/v9/examples/simple/main.go#L72\nAny reason you need the field name from within the validation?. @s4l1h makes perfect sense\nI think I can pass the cached filed info along and then add a couple of methods to the FieldLevel interface to access both the struct and alt name's.\nIt may take me a few days, I'm out of town right now, but will try to make the changes asap.. Thanks @s4l1h  but I'd like to expose that information a little differently without exposing cField nor cTag\nI appreciate the help, but may close the PR after implementing and there will have to be allot more tests. Update see: https://github.com/go-playground/validator/tree/add-fl-field-name\njust have to write the tests...they need to cover not only a normal FieldLevel, but also and array and map to ensure the names are appropriate with key and or index included.. Hello @bsed \nSo it looks like you are creating a new Validator instance, assigning it to a global variable and then Registering a new struct validation each request; the issue is that RegisterStructValidation is not thread/goroutine safe as stated in the documentation here\nBy doing it this way you're missing out on all the caching benefits of Validator... so how do you use Validator? there are many ways, but with all Validator is only instantiated once.\n\n\nI see you are using echo and he has a recipe for this library here\n\n\nUse a global variable, I know some people frown on this but using it this way gives you a central place to add common validations, and in each custom application still have the ability to Register custom validations for each applications needs; I would even recommend creating a separate package or repo to house this. eg.\n```go\npackage data // in a separate repo\n\n\nimport (\n    \"gopkg.in/go-playground/validator.v9\n)\nvar Validate = validator.New()\nfunc init(){\n    // register any common validation for organization\n}\n```\nand then can use this anywhere, in any application:\n```go\nimport \"path-to-data\"\ndata.Validate.Struct(mystruct)\n// or\ndata.Validate.Var(myvar,\"required,email\")\n// and in main.go of project\ndata.Validate.RegisterStructValidation(...) // these will only be compiled into your project and not the common validations.\n```\n\nthere are more ways like passing through context etc.. but I recommend #2 it works for anyone, with any project and any framework.\n\nPlease let me know if this helps :). @bsed I think your misunderstanding when to use RegisterStructValidation\nyour calling RegisterStructValidation each http request and that's why you're running into the issue, as it's not thread safe\n```go\nfunc GetNation(c echo.Context) (*model.NationReqParam, error) {\nValidate.RegisterStructValidation(getNationValidation, model.NationReqParam{})\n\nu := &model.NationReqParam{}\nif err := c.Bind(u); err != nil {\n    return u, err\n}\n\nreturn u, Validate.Struct(u)\n\n}\n```\nwhat you should be doing it in main.go or your global validator only once\n```go\npackage validator\nimport (\n    \"gopkg.in/go-playground/validator.v9\"\n)\nvar Validate = validator.New()\nfunc init() {\n    // register it here or in main.go\n    Validate.RegisterStructValidation(getNationValidation, model.NationReqParam{})\n  }\n}\n```\nValidator remembers the struct by it's type, and there is no need to register it again.. Hey @0505gonzalez ya I really have to create an example for that, You just register a tag name function like here https://github.com/go-playground/validator/blob/v9/validator_test.go#L366\nThat example is for json but could use any other tag too.. Hey @geraldstanje no unfortunately not, validator is just not configured to do that, it's been asked about before, it's seems simple at first look, but way more complicated to do. I'd rather keep validator doing one thing really well.\nHowever there is another library that can help, it's actually in the README, https://github.com/leebenson/conform that is designed to do exactly that.\nSo you'd just call that prior to validation.\nPlease let me know if that helps :). Hey @bogh \nI guess the document should say has support for Valuer and overriding behaviour of any type. It works, just not out of the box, but it's only a few lines of code, please see the custom example; I only register some of the SQL.Valuer types in the example, but you can add the rest.\nExplanation of why it's not handled out of the box:\n1. The current way works with not only Valuer types, but any custom type you wish to handle the value differently.\n2. Validator doesn't want to make assumptions about what is an ok value for Valuer or not eg. When the Valuer field value is nil say for an sql.NullFloat64, some people want the default value of 0.0 returned for validation, others may want nil; it all depends on your application.\nPlease let me know if this makes sense :) and if you have any trouble getting it working.. It's also documented in the godocs under the required definition\nYes exists was removed because it was confusing, and functionality merged into required.\nJust make your int a pointer and keep using required tag. . Just checking in, did you get this all working?. Hey @mbn18 \nYou'd have to create a custom one, but should be pretty easy just copy-paste the current alphanum regex and add space and dash characters and register the new validation.\nIf you need any help just let me know.. @mbn18 thanks for the idea, but it's rare that regexes are that straight forward.\nBesides if I was another developer coming to read this code, I wouldn't have a clue what '32+95+45' meant. It will/could make the tags harder to read and much longer.\nI have document here why I don't have a regex tag( near the bottom) and this is pretty much the same.\nI should probably add that in a clearer place in the README.. Thanks @thaonx \nI really like this idea!  It would actually allow me to solve a few things I hadn't been able to reconcile until now :) like a better way to do translations.\nGive me some time to look over the PR I may want to incorporate into v10 and make a bunch of other changes at the same time but from my initial quick look I'll probably be able to merge into v9. just letting you know I haven't forgotten about this, just super busy with work, moving and other projects requesting changes.\nI promise I will get to it :). Hey @thaonx this is now added in release v9.5.0\nThanks! lots of great things on the horizon for v10!. Hey @thaonx added this + more in release 9.5.0, don't know why this didn't automatically get merged, I made all changes based off of this request.... Tanks @zhsj you're probably right, I'll adjust the tests to remove the false positive; nice that it's running so fast though!. This should be fixed in v9 release v9.5.0\ndon't know if i'll go back to fix in v8, I highly recommend upgrading to v9 or v10 which is on the horizon.. Ok considering that I'll backport the fix for you tonight or tomorrow.. OK @zhsj I've backported the fixes to v8 in release 8.18.12\nplease let me know if you encounter the issue again or need anything else :). Hey @nathanejohnson \nI did this more as a safety precaution than anything, validator is not panicing because of the input, which you are correct about validator not panicing in that regard, but rather it's more that there is a bug in your code.\npersonally if something like this accidentally, somehow without tests or testing first, got into production I'd rather the application panic and let me know the bug straight up rather than the potential for critical company data being saved that shouldn't if the error isn't handled properly. (and if this got into production, I'd be very suspect if the error is also checked properly)\nI'd say it's akin to passing nil to a function expecting a context.Context, they panic in the STD lib.\nI could add this functionality, but then everyone would also have to start checking all the error type returned from Validator.\nThis has given me an idea though, perhaps the validation functions should pass back 2 error variables, the first being the field validation errors, and the second being a processing error. That was as new error are added or removed from validator your logic will never have to change and will be able to remove the panics. perhaps not until the next version though.. As documented here it's for bad input types, not validation tags.\nI just want to say I do understand your position as well and am willing to add this in the next version with a new BadValidationTag or alike. Although the code wouldn't be a breaking change, the logic because nobody is checking for the error would be, and so will just have to wait until the next version.\nThanks for you opinions and views, it's what open source is all about :). it's for when bad data aka struct is passed to say validate.Struct(...)\nfor example if you passed nil, or a string to be validated as a struct.. @bokub sound like a pretty easy one to add, I'll add it as isdefault tag for clarity. Hey @bokub \nI was well underway adding this new functionality, when I realized that this new tag would not play nice with other validations or program flow.\nYour example illustrates it well, I can make forbidden error when a Customer is present that's fine, but then further in your program you're probably going to set a value for Customer and ID and want to validate that the values are correct and that's where the problems will start because now the forbidden is going to error, but we don't want it to.\nIt sounds like you're more interested in ensuring those values get set to their default values before proceeding rather than validating is that a fair statement?\nIf so I just finished a project that may be able to help https://github.com/go-playground/mold\nI have not yet added a default tag and modifier function, but that was going to be my next project then you could ensure values are as you like prior to validating or working with them; what do you think?. ok @bokub I'll continue this then.. No problem, glad I could make it work :). Thanks @ipiao seems like a reasonable new validation.. @ipiao haven't forgotten, sorry for the delay.. thanks @lucasmundim . Thanks @pigi72333 . Hey @ipiao sorry for the late reply, been super busy\nthere's no build in way to validate only a single array or map value using a tag validation, but you can add a Struct Level validation for this use case that works with your other tags, see here\nIt seems like a very one off case.. Thanks @aaronlehmann :+1:  I'll merge and these changes will become public when I get to cutting the next release.. Hey @aaronlehmann would you be able to produce an example outlining the issue, I'm not quite sure I fully have my head wrapped around the issue and why adjusting the relative namespace wouldn't work?. @aaronlehmann sorry for my late replies, been getting all settled after my move.\nI see how this would be useful, never expected anyone to use it that way, but makes perfect sense :)\nI do have some concerns about a couple pieces of code will comment on in the review; and if you could provide test for 100% test coverage that would also be great!\n. @mvrhov if I understand you correctly, the problem then becomes the consistency of how errors are used/handled, the top level ones don't have type info, but nested ones do?\nIMO this would only be a sources of confusion and pain for those wanting to write wrappers around handling of the errors.. @mvrhov I must not be understanding correctly, can you provide an example?. Thanks @nu11ptr I'll correct ASAP. Hey @DanielDHuynh thanks for the suggestion.\nAlthough this is possible to code, I highly recommend to everyone that once the validation reaches this level of complexity to use struct level validation; it can also be combined with validation via tags(they work together)\nIf I added this type of logic it would severely clutter the tags and make them hard to read; but beyond that doing it via struct level validation with be much more performance as well.\nHope this answer helps :). Hey @anam-digicom you would need to use the dive tag documented here\nbasic example:\ngo\ntype User struct {\n  Foo []string `validate\"required,dive,ne=bar\"`\n}\nlet me know if that helps.. @denouche because your validating a variable at this point you would use validate.Var(mySliceOfStructs, \u201crequired,dive\u201d) or if not required use \u201comitempty,dive\u201d. Hey @vitorleal what you have should work.\nI tested with the latest v8 & v9 just to make sure and it works:\n```go\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v8\"\n\n)\ntype User struct {\n    Name    string   validate:\"required\"\n    Address *Address validate:\"omitempty\"\n}\ntype Address struct {\n    Street string validate:\"required\"\n}\nfunc main() {\n    user := User{\n        Name: \"joeybloggs\",\n    }\nvalidate := validator.New(&validator.Config{TagName: \"validate\"})\nerrs := validate.Struct(user)\nfmt.Println(errs)\n\n}\n```\ncan you confirm you have the latest changes?. Hey @yharish991 sorry for the late reply \nCould you provide the values of country, company and productId, I assume they\u2019re blank but just double checking.\nAnd what\u2019s the output you expect? And could you print out the err right after validate.Struct(). Hey @yharish991 so I finally got to test this on a computer and realized it's not working because your fields aren't exposed and so they are ignored.\nchange\ngo\ntype FeatureCodesQueryParameters struct {\n    country      string     `validate:\"required\"`\n    company      string     `validate:\"required\"`\n    productid    string     `validate:\"required\"`\n}\nto\ngo\ntype FeatureCodesQueryParameters struct {\n    Country      string     `validate:\"required\"`\n    Company      string     `validate:\"required\"`\n    Productid    string     `validate:\"required\"`\n}\nand it should work as expected.. Hey @denouche \nthe link you provided is actually for custom type validations, like type for sql that implement sql.Valuer.\nif you just want to register a custom validation that can be used on one or many string fields there is a good example here\nand then if there are errors it's really of type.\ngo\n// ValidationErrors is an array of FieldError's\n// for use in custom error messages post validation.\ntype ValidationErrors []FieldError\nwhich has all the information to create your own error messages, if needed.\nplease let me know if that helps :). Hey @alexyans \nthere are 2 ways, I recommend the 2nd\n\n\nvalidate:\"eq=male|eq=female|eq=n/a\"\n\n\nUse a function eg.\n```go\nconst (\n  Val1 string = \"value1\"\n  Val2 string = \"value2\"\n   ...\n)\n\n\nm := map[string]struct{}{\n  Val1:struct{}{},\n  Val2:struct{}{},\n}\nvalidate := validator.New()\nvalidate.RegisterValidation(\"mytag\", func(fl validator.FieldLevel) bool {\n  _,ok := m[fl.Field().String()]\n  return ok\n})\n```\nplease let me know if that makes sense.. validate only caches fields that need validation, for performance and efficiency; I think you may be confused about what the custom type function is for.\nThe custom type fund is not used for validation at all, it\u2019s used to transform the data from one form to another for validations to use; for example sql.NullString some people will be ok with a null value and so if it\u2019s null return a string, other return null so it will error on required.\nIt is in a general sense used to extract the data you to validate from custom types, fields that are an interface like sql.Valuer or io.Reader; types that are not programmed into validator.\nand then another validation function actually does the validation on the transformed data.\nHope I\u2019m making sense.. Hey @7fELF great question\nAnd the answer is yes it is completely thread/goroutine safe and is designed to be used with a single instance. Validator also caches information about your struct and validations, in essence only parsing your validation tags once per struct type, without a single instance you wouldn\u2019t get the advantages of the cache.. Hello @lbozza \nWould you be able to provide a more complete example? It\u2019s a little difficult to diagnose with an incomplete picture, I have no idea how you populated the struct, which json library was used or what validations or json tags are set on the internal struct fields.\nHave you printed out the struct to ensure the data that was decided into it? I suspect that it might not the data.. @lbozza that makes sense, you can always make your struct implement UnmarshalJSON and you could decode that field to a json.Number in a custom struct and then populate the string field with the int value.. @yokanandCIC  please see issue #313 which is almost exactly the same as what you're asking and I provide 2 examples of how to do it.. Hey @timakin I feel like I've answered this a million times lol, time to add it to the docs or provide example I guess.\nok so here's the explanation, in multiple parts:\nGo's static nature doesn't allow nullable/unassigned/undefined types but initializes them to their default values.\nrequired - required under the hood checks if the value of the field is the default value of the datatype; in this case of a bool false.\nhere's an example of why required doesn't make sense on a regular bool\n```go\n// json\n{ \"bool\": false }\ntype Test struct {\n  Bool bool json:\"bool\"\n}\nvar payload Test\nerr := json.NewDecoder(r.Body).Decode(&payload)\n....\n// payload.Bool = false\n// and again, but with this json\n{}\ntype Test struct {\n  Bool bool json:\"bool\"\n}\nvar payload Test\nerr := json.NewDecoder(r.Body).Decode(&payload)\n....\n// it will also be payload.Bool = false\n// because Go initialized it to it's default value.\n```\nSo as you can see type bool will always be populated and so required doesn't make sense. Now having said that, you may be looking to validate that the JSON set the bool, then there are things you can do.\nchange the type to *bool and now the type is a pointer, and it's default value is nil and so required will work as most people expect if the data wasn't in the JSON.\nI personally try to model my data so that if no boolean value is passed, it's just like it was passed as false; that way I have no need to see if it was sent and can avoid the *bool altogether, but I know that's not always possible.\nSorry for the long winded explanation, please let me know if this all makes sense or you have any questions. P.S. I will look at adding this to the docs and/or add an example.. Hey @FlamingTree \nlet me think about it, there are a couple of reasons that functionality isn't implemented.\n\n\nInternationalization, a static message in one locale just doesn't cut it; however I would still add this functionality for those that don't require it.\n\n\nAn example will best explain the next one:\ngo\ntype User struct {\n  Name string `validate:\"required,lte=100\"`\n}\n\n\nThis is just a basic example, the complexity can be much higher once getting into arrays, maps, and even more validations, but the message you want can vary; \neg. Name is  required or Name must be less than 100 characters\nThis is why the error returned from validator is of type type ValidationErrors []FieldError, see here\nthat way you can create any message you want based on the error information, localization if you want. I know it's a bit of overhead to initially create, but one can create a customer reusable function to iterate over the errors and format them as the see fit.. Just checking in, I haven't forgotten about this, just been super busy.. Hey @AlexMain \nIf I understand you correctly, you only want to validate the array if it\u2019s present.\nI think you\u2019re looking for validate:\u201domitempty,dive,required\u201d\nPlease let me know if this is what you\u2019re looking for :). Hey @gangstaJS \nyour looking for the eqfield tag eg. validate:\"eqfield=ConfirmPassword\"\nPlease see the docs all tags should be thoroughly documented there.. Please let me know if this worked for you :). Hey @sirakuzi \nIf you register a TagNameFunc you can extract any tag names you want, including JSON, and then use the Namespace() function instead, StructNamespace() will remain unchanged eg.\n```go\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"strings\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\ntype User struct {\n    Name string json:\"name\" validate:\"required\"\n    Age  int    json:\"age\" validate:\"required\"\n}\ntype Family struct {\n    One   User    json:\"one\" validate:\"omitempty,dive,required\"\n    Two   User    json:\"two\" validate:\"omitempty,dive,required\"\n    Child []*User json:\"child_list\" validate:\"omitempty,dive,required\"\n}\nfunc main() {\n    fam := Family{\n        Child: []*User{&User{}},\n    }\nvalidate := validator.New()\nvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n    name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n    if name == \"-\" {\n        return \"\"\n    }\n    return name\n})\nraw := validate.Struct(fam)\nerrs := raw.(validator.ValidationErrors)\n\nfor _, e := range errs {\n    fmt.Println(\"NS:\", e.Namespace(), \"SNS:\", e.StructNamespace())\n}\n\n}\n```\noutputs:\nNS: Family.one.name SNS: Family.One.Name\nNS: Family.one.age SNS: Family.One.Age\nNS: Family.two.name SNS: Family.Two.Name\nNS: Family.two.age SNS: Family.Two.Age\nNS: Family.child_list[0].name SNS: Family.Child[0].Name\nNS: Family.child_list[0].age SNS: Family.Child[0].Age\nalthough the top level struct Family remains the struct name as there is no way to get a JSON name from it, this should get you 99% of the way to what you're looking for and then just string.TrimPrefix\nPlease let me know if this helps :). @jlpellicer yes you can there is however no built in validation to handle that, but you can easily register a custom validation and tag to use see here for a simple example\nIf you need anymore help, just let me know :). Hey @kickroot \nI think what your looking for is omitempty eg.\nvalidate:\u201domitempty,max=64\nPlease let me know if that works for you :). Hey @bsbak thanks for the question,\nwhat you\u2019ve done is almost what is needed, the only changes I\u2019d make are you don\u2019t have to create your own field translator, but rather just add translations for the field names to the ut which the translate function already has access to; that way you don\u2019t have to hack anything. You will have to RegisterTranslation for each English translation just as you have for your Russian (looks like Russian).\nI wish there was an easier way but the field name is a dynamic value. I have been thinking of how to improve ever since adding translations; I think in the next version I will allow registering of a translation function against a tag which only accepts context and the field error to allow people to use whatever they want to translate and even allow per request contextual information to be accessible.\nP.S. sorry for no examples, not at a computer and answering from my phone.\nPlease let me know if you have any questions :)\n. Hey @gwan284 \nYou just need to register a CustomTypeFunc so that validator knows what to do about that type, there is an example of almost exactly what you want https://github.com/go-playground/validator/blob/v9/_examples/custom/main.go\nValidator just uses that function so you can return the underlying value you wish to validate, in your case a float64.\nPlease let me know if this helps, or you have any other questions :). It knows how to extract for all values you've registered the type with; unfortunately there isn't a way to specify different behaviour per object using this... however if that is needed, you can register a StructLevel validation to treat structs differently, see here for the example.. Hello @skryja it's a little hard not knowing what the custom function do, but will try to layout the operations that should occur for the Path field:\nBlock1 & Block2 below are AND's eg. if Block1 and Block2 = validation success\nBlock1\n- first it will check attrpath|eq=''\n  - if attrpath returns true, move to the next validation block\n  - if attrpath returns false, move to eq='' if returns true move to next validation block otherwise return error and stop other validation for the field\nBlock2\n- next it will check isfield=Op:replace|isfield=Op:add|attrpath\n  - if isfield=Op:replace returns true, move to the next validation block(which there is none validation of field complete)\n  - if isfield=Op:replace returns false, move to isfield=Op:add if returns true, move to next validation block\n  - if isfield=Op:add returns false then move to attrpath if it returns true move to next validation block\n  - if attrpath returns false return error.\nit seems odd to me to have 2 validations here, and that attrpath is part of both, I think it could be combined to validate:\"eq='',isfield=Op:replace|isfield=Op:add|attrpath\" or even validate:\"omitempty,isfield=Op:replace|isfield=Op:add|attrpath\"\nI hope this helps, please let me know :). Hey @skryja I may have solved this in a dream ;)\none thing I realized was the eq='' is probably not checking for what you want it\u2019s equivalent to Path == \u201c''\u201d and not Path == \u201c\u201d and should be changed to eq=\nMaybe I\u2019m way off?\n. Hey @skryja I have confirmed that this is a bug and is due to the way I was checking when to terminate each or instance; will be fixed soon, nice catch \ud83d\ude04 . Thanks @skryja for reporting, it should now be fixed in v9.9.1 release, please update and try again\nif you have any more problems with it please let me know \ud83d\ude04 . @skryja  Thanks for that ! always interested in seeing how others are using it :) I may even add a few after seeing your like prefix and suffix validations.\noh and I noticed your issue 37 about the required tag failing, there are a few issue, think one still open tagged question, that explains required\u2019s behavior, but to paraphrase:\nrequired checks that the field is not the field types default value, for bool false, int 0, string \u201c\u201d and so forth.\nIt doesn\u2019t make much sense on a bool unless you need it tri-state and for that you would use a pointer to a bool. In fact if you have optional variables that\u2019s how you would handle if they were actually set or not as the default value of a pointer is nil(yes nil is a type). Hey @amirkheirabadi I'm not 100% sure what you mean?\nIf you mean for the custom validation to always have a certain parameter, then why not hard-code the parameter in your custom validation?\nIf you mean you wish to have a custom validation that a parameter can be set, but you don't want to set it everywhere, you can use Register Alias to alias a tag with a parameter, or even many tags.\nPlease let me know if I'm way off from what your asking, just trying to interpret :). Hey @moneyzmey the error is pretty telling, it appears that in the gin code the interface definition has changed and now requires an additional function to be added to defaultValidator called RegisterValidation, I\u2019ll try and update the example later today. . Hey @moneyzmey after digging into it a bit more it appears that in this commit the added the RegisterValidation function as part of the interface contract, but in doing so directly tied the framework to v8 of validator.\nI will be creating an issue to try and repeal that commit.\nSo you have 2 options:\n1. vendor a copy of gin from before that commit.\n2. Use validator outside of the gin framework, it doesn't have to be.\nexample of option 2.\ncreate a separate package for validator, can be in same project or even repo\n```go\npackage validation\nimport \"github.com/gopkg.in/go-playground/validator.v9\"\nvar Validate validator.Validate\nfunc init() {\n  Validate = validator.New()\n  // and customer settings or validations you want or need\n}\n```\nafter defining that you can use like this anywhere\ngo\nvalidation.Validate.Scruct(...)\n// or\nvalidation.Validate.Field(...). @moneyzmey the commit that caused the issue has been corrected https://github.com/gin-gonic/gin/issues/1211. Hey @alexdor \nNo currently there is no way to have multiple struct validations, internally only a reference to the struct's type is held, and why when registering 2 only the second is used as it overwrites/remaps the first. The reason that type is used is it's the only truly unique identifier between structs.\nThere are however there are some options, you could:\n- Use RegisterStructValidationCtx and pass in a value in the Context to indicate which validation to run inside a separate struct validation.\n- Separate your structs, To and Email; in my experience have one structure represent multiple things will always eventually get you into trouble (only mentioning because you want to run different validations depending on struct usage)\n. @alexdor I would definitely consider a PR, it all depends on how it would work, performance considerations and if there were any breaking changes.. Hey @cch123 \nOn a key by Key basis no, there is not support for that specific scenario; I'd add such a thing but unfortunately there would be varying opinions on exactly how it should work i.e. should all keys have to match in the maps or not....\nOnce logic is this specific I recommend creating custom validation, it's pretty easy :)\n```go\npackage main\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\nfunc main() {\nvalidationMap := map[string]string{\n    \"key\":  \"gt=10\",\n    \"key2\": \"len=10\",\n}\n\nvalidate := validator.New()\nvalidate.RegisterValidation(\"mapval\", func(fl validator.FieldLevel) bool {\n    m, ok := fl.Field().Interface().(map[string]interface{})\n    if !ok {\n        return false\n    }\n\n    for k, v := range validationMap {\n        if validate.Var(m[k], v) != nil {\n            return false\n        }\n    }\n\n    return true\n})\n\ntargetMap := map[string]interface{}{\n    \"key\":  \"yes\",\n    \"key2\": \"anyway1234\",\n}\n\nerrs := validate.Var(targetMap, \"mapval\")\nfmt.Println(errs)\n\n}\n```\nor if you want a completely generic validation function you can also pass the validation map in the context eg.\n```go\npackage main\nimport (\n    \"context\"\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\nvar MapValKey = struct {\n    name string\n}{\n    name: \"validation func\",\n}\nfunc main() {\nvalidate := validator.New()\nvalidate.RegisterValidationCtx(\"mapval\", func(ctx context.Context, fl validator.FieldLevel) bool {\n    m, ok := fl.Field().Interface().(map[string]interface{})\n    if !ok {\n        return false\n    }\n\n    vm, ok := ctx.Value(MapValKey).(map[string]string)\n\n    for k, v := range vm {\n        if validate.Var(m[k], v) != nil {\n            return false\n        }\n    }\n\n    return true\n})\n\ntargetMap := map[string]interface{}{\n    \"key\":  \"yes\",\n    \"key2\": \"anyway1234\",\n}\n\nvalidationMap := map[string]string{\n    \"key\":  \"gt=10\",\n    \"key2\": \"len=10\",\n}\nctx := context.WithValue(context.Background(), MapValKey, validationMap)\n\nerrs := validate.VarCtx(ctx, targetMap, \"mapval\")\nfmt.Println(errs)\n\n}\n```\nI did discover a bug while making these examples, so be sure to update to the latest validator.\nplease let me know if this helps :). Hey @kerak19 can you point out exactly where in the documentation that it states it returns the json name by default? and I'll correct right away.\nas for grabbing the json tag name, you have to register a tag name parser first eg.\ngo\n        validate := New()\n    validate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n        name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n        if name == \"-\" {\n            return \"\"\n        }\n        return name\n    })\nit's done this way in order to allow for parsing of any tag name like json, bson, sql tags etc...\nPlease let me know if this was helpful :). Thanks @pnicolcev-tulipretail I agree, any chance you could make a PR? . Hey @trvsysadmin \nfor 2 I understand the confusion, the only thing I can think of is in the future have param return []string; but even that's weird as the param values may not line up with the tags as not all have to have a param.\nAs for 1 that's pretty subjective question/suggestion;  normally I range through the ValidationErrors and build an array of objects containing the namespace and an error message, and in the client code the namespace matches the struct namespace(perhaps with json tags) and then sending that array back to the client there can be generic code to find objects and set errors on each field; but that's just how I'd use it.\nI can see how it would be useful to send just the ValidationErrors as JSON back to the client side if it's going to handle the error messages; I'll look at making it JSON marshallable.\nso to try and answer your questions:\na) It's up to you decide if you're doing the right thing, validator only provides the error information for your use and does not stick it's nose into what you do afterwards.\nb) I'd accept a PR adding this as an example; be sure to note which framework you're using to put it into context for those who read it :)\nIs there anything else or any other questions I can attempt to answer?. Thanks for your feedback about the evaluation result, I\u2019ll definitely try and think of a way to incorporate that in the results if it makes sense :). It was changed in v9 to VarWithValue to try and avoid some confusion as some people thought it had to be a struct field; must have missed updating it in the docs, thanks for reporting so I can correct them :). @ryan-ju corrected in Release 9.9.4. Thanks @glb . Thanks @dnartz I\u2019ll take a look as soon as I can, \nIf you wanted to make a PR That\u2019d be awesome too :). Hey @dnartz I added a new validation in Release v9.10.0 for RFC 1123 hostname called hostname_rfc1123\nI put a note in the release of how to continue to use the hostname tag with it.. Thanks @ansel1 for the PR! A couple thoughts:\n- it seems to be failing the tests in the CI\n- have you tried a RWMutex to see what perf may be?\n- why not also add float32 and float64 to the supported types :). Thanks @ansel1 \ntotally agree about float precision. About the build failures thanks for reminding me, I found a way to get around that, just haven't implemented yet.. awesome @ansel1 thanks, will try and get this merged tonight. Hey @gebv I think there may be confusion about what RegisterCustomTypeFunc is for; here is an example https://github.com/go-playground/validator/blob/v9/_examples/custom/main.go\nRegisterCustomTypeFunc is really for registering a function to take a certain type and transmute the data into what you want to validate eg.\nif I wanted to validate that an sql.NullString was required, we would have to get the value out before validating as whether the value is set or not is hidden within the struct sql.NullString, which is always set.\nso RegisterCustomTypeFunc is really for taking the sql.NullString and either extracting the string for validation or returning blank or nil.\nIn your example, the data isn't being transmuted, but the same value is returned causing an infinite loop.\nperhaps if I knew exactly what you were trying to accomplish I could provide an example, can you elaborate?. Normally validating with .Var isn\u2019t for struct so have been thinking about how to accomplish this best.\nI think creating a StructLevel validation is what your looking for and in that you can do your inmsk check, and report the error as you see fit and then you can use the validate.Struct instead of validate.Var. There should be an example in the repo.\nSorry for the lack of examples, answering from my phone, but will try and add one tomorrow morning for you(assuming you still need one). @gebv \nSo there are 3 ways to handle this, the decision is up to you which to implement:\n1. Struct level\n```go\npackage main\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\n// NullPoint ...\ntype NullPoint struct {\n    X     float64 json:\"lng\"\n    Y     float64 json:\"lat\"\n    Valid bool    json:\"valid\" // Valid is true if not NULL\n}\nfunc main() {\n    validate := validator.New()\n    validate.RegisterStructValidation(structLevelValidation, NullPoint{})\nvar pt NullPoint\nerrs := validate.Struct(pt)\nfmt.Println(errs)\n\n}\nfunc inMSK(point NullPoint) bool {\n    return point.Valid\n}\nfunc structLevelValidation(sl validator.StructLevel) {\n    pt := sl.Current().Interface().(NullPoint)\n    if !inMSK(pt) {\n        sl.ReportError(pt, \"in_msk\", \"InMsk\", \"inmsk\", \"\")\n    }\n}\n```\n\nCustom Type\n```go\npackage main\n\nimport (\n    \"fmt\"\n\"reflect\"\n\n\"gopkg.in/go-playground/validator.v9\"\n\n)\n// NullPoint ...\ntype NullPoint struct {\n    X     float64 json:\"lng\"\n    Y     float64 json:\"lat\"\n    Valid bool    json:\"valid\" // Valid is true if not NULL\n}\nfunc main() {\n    validate := validator.New()\n    validate.RegisterValidation(\"in_msk\", ValidationInMoscow)\n    validate.RegisterCustomTypeFunc(PointValuer, NullPoint{})\nvar pt NullPoint\nerrs := validate.Var(pt, \"in_msk\")\nfmt.Println(errs)\n\n}\nfunc ValidationInMoscow(fl validator.FieldLevel) bool {\n    return fl.Field().Bool()\n}\nfunc PointValuer(field reflect.Value) interface{} {\n    // TODO: do validation here and return primitive type for \"in_msk\" validation\n    point, ok := field.Interface().(NullPoint)\n    if ok {\n        return false\n    }\n    // TODO: check if in msk, return true or false\n    return point.Valid\n}\n```\n\nUse the NullPoint inner structure(assuming Valid == in_msk\n```go\npackage main\n\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\n// NullPoint ...\ntype NullPoint struct {\n    X     float64 json:\"lng\"\n    Y     float64 json:\"lat\"\n    Valid bool    json:\"valid\" validate:\"in_msk\" // Valid is true if not NULL\n}\nfunc main() {\n    validate := validator.New()\n    validate.RegisterValidation(\"in_msk\", ValidationInMoscow)\nvar pt NullPoint\nerrs := validate.Struct(pt)\nfmt.Println(errs)\n\n}\nfunc ValidationInMoscow(fl validator.FieldLevel) bool {\n    return fl.Field().Bool()\n}\n```\nplease let me know if this helps :). Thanks will update!. fixed this in commit d3984c2e0b6c0706c2d3bfa46730495657742583. Hey @lansana, I touch on this in the docs:\n```\nregex\n    a regex validator won't be added because commas and = signs can be part\n    of a regex which conflict with the validation definitions. Although\n    workarounds can be made, they take away from using pure regex's.\n    Furthermore it's quick and dirty but the regex's become harder to\n    maintain and are not reusable, so it's as much a programming philosiphy\n    as anything.\nIn place of this new validator functions should be created; a regex can\nbe used within the validator function and even be precompiled for better\nefficiency within regexes.go.\n\nAnd the best reason, you can submit a pull request and we can keep on\nadding to the validation library of this package!\n\n```\nTo summarize I highly recommend you don't use a regex validator, many of the common characters used in regexes will conflict with the built-in characters when the tags are parsed; in your specific case the | is a special character that represents and or.\nI have added the ability to work around such things, also in the docs:\nPipe (\"|\") is the 'or' validation tags separator. If you wish to have a pipe included within the parameter i.e. excludesall=| you will need to use the UTF-8 hex representation 0x7C, which is replaced in the code as a pipe, so the above will become excludesall=0x7C\ngo\ntype Test struct {\n    Field `validate:\"excludesall=|\"`    // BAD! Do not include a a pipe!\n    Field `validate:\"excludesall=0x7C\"` // GOOD! Use the UTF-8 hex representation.\n}\nbut then regexes don't look right and so forth\nI highly recommend you add a custom validation for each regex, even validator handles it this way internally:\n- the tag name will be clearer to those not as familiar with regexes\n- it will be more performant with the regex pre-compiled\n- the regexes will become reusable\n- the tags will be more readable, especially if you need a long regex, like for an email.. GitHub experienced a DDoS attack and was down for approx 10 minutes and is the most likely cause.\nIt is also likely that Gopkg.in experienced some issues around the same time.\nIt appears to be up and working now, if you could please try again to see if the problem is resolved.. Have you tried any of the following:\n- attempted to go get gopkg.in/go-playground/validator.v8 directly?\n- can you git clone the https://github.com/go-playground/validator directly\n- can you visit this page in your browser?, should look like:\n\n- What OS are you running?\n- what version of git are you using? pre 1.7.6(iirc) had problems with redirects which gopkg.in uses\nIt could be any number of factors such as an issue with glide, firewall, proxy issues, location in the world.\nWhat I can say is that it's working from my location and so must be an external problem as I have done nothing with the v8 branch and is fully intact.. >dial tcp: lookup gopkg.in on 127.0.0.53:53: read udp 127.0.0.1:42094->127.0.0.53:53: i/o timeout)\nThose addresses seem a little strange... why is it trying to lookup on port 53? I'd look into that first.. @vbmade2000 just curious, did you ever figure this out?. Thanks @fdelbos . Hey @frednomoon sorry about the delay I must admit this one slipped through the cracks.\nI'll try and give it a look next week, it is an interesting use case. @blackstar257 @frednomoon just to let you know I haven't forgotten, just really busy\noff the top of my head I would say a custom validation is probably best and unmarshal into map then\nvalidate.Var(<map>, \"custom validation\")\nand if all is well then unmarshal into the struct and run validation against the struct, it's not ideal but a workaround for now.\n. Thanks @afranioce !!!!. Thanks @kgeorgiou I'm out of town until next week, will try and merge when I get back. looks awesome! @kgeorgiou thanks!\nI will adjust the documentation ever so slightly letting people know it's RFC4648 base64 URL encoding. Hey @sudo-suhas \nYa when registering a struct level validation you should use a non-pointer struct, in your case User{}\nby the time the code checks the type whether it be a pointer or not it will have been derefferenced already so in your StructLevel validation you should cast to a non pointer as well. I probably need to add some docs on this explaining. The validation lib will work with both pointer and non-pointer structs though.\nThere are many reasons it works this way but a big reason I have to derefference is that I have to check against the type of struct and if I didn't deter it would be checking against pointer types instead of struct  types.. @sudo-suhas I will definitely add to the docs and see what I can't do about throwing an error. Thanks for the heads up @jeevatkm will endeavour to help anyone out.\nI saw in your examples about validating query params individually, if I could make a suggestion, I tend to unmarshall them into a struct and then validate which seems better than doing it one by one.\nP.S. if your interested I also have a fully complete form parser and encoder https://github.com/go-playground/form which handles pretty much anything including full support for maps(I think it's probably the most complete form parsing lib out there) and also https://github.com/go-playground/mold for trimming strings and applying transformations and/or scrubbing PII data.... Hey @gangstaJS \nNo this should not be strictly ordered at all, it uses Tag.Get https://golang.org/pkg/reflect/#StructTag.Get here https://github.com/go-playground/validator/blob/v9/cache.go#L135 to retrieve the tag information.\nI will check this morning to be sure though, would you be able to post some additional information about your OS and Go version and maybe an expanded version of the logic/example you gave to aid in debugging.. @gangstaJS finally found time to look at this, I can confirm that validator is working correctly, it's actually how you defined your struct tags.\nYou have a , comma in-between the separate tags validate and json and so the tag parse doesn't look past the first tag defined in the second case.\neg. json:\"password\",validate:\"required,alphanum,gte=6\"\nshould be json:\"password\" validate:\"required,alphanum,gte=6\"\nno comma between tags.   \u261d\ufe0f . They must parse the tag differently for some reason.\n. Thanks, if you could get 100% test coverage that would be great and I can merge :)\nIn a normal library it wouldn't matter that much to me, but because it's a validation library I like to keep the coverage at 100% if possible. Awesome! Thanks! Will try to get this merged before EOD. I'll try and take a look soon @insamo . @insamo corrected this behaviour in v9.17.0\nthis was originally only intended to be used on a string but makes sense when dealing with interface{}. Hey @ralekseenkov sorry for the lateness of my reply,\nThis library mostly intends for you the user to create your own error messages, and why FieldError contains so much detail; however, there it also allows you to register i18n translations.\nTo do what you looking for you can register a translation for your custom validation, please see the translation docs\nplease let me know if that helps :). @ralekseenkov I see what you mean now, yes currently there is no way to do this; but it would be a great enhancement!\nI will add it to the improvements for v10. Thanks @Ashtonian . @danielpoe thanks for reporting, I will try and get to this, but might take a little bit, PR's are welcome if you would like it sooner :). @jservice-rvbd merged your PR in v9.16.0. Thanks @jservice-rvbd I will try to get this merged today :). awesome @jadhub! thanks will merge asap!. Thanks for the PR @tengis617 . Hey, @syssam  to do this you'll have to register your own translations and either reference an external object to translate, like a map or use the translator already being used; below is an example of the latter.\n```go\npackage main\nimport (\n    \"fmt\"\n\"github.com/go-playground/locales/en_US\"\n\"github.com/go-playground/locales/fr_CA\"\n\"github.com/go-playground/universal-translator\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\nfunc main() {\n    english := en_US.New()\ntrans := ut.New(english, english, fr_CA.New())\n\nen, _ := trans.GetTranslator(\"en\")\nen.Add(\"MyField\", \"Field\", false)\n\nfr, _ := trans.GetTranslator(\"fr_CA\")\nfr.Add(\"MyField\", \"Champ\", false)\n\nvalidate := validator.New()\nvalidate.RegisterTranslation(\"required\", en,\n    func(ut ut.Translator) error {\n        return ut.Add(\"required\", \"{0} is required\", false)\n    },\n    func(ut ut.Translator, fe validator.FieldError) string {\n        fld, _ := ut.T(fe.Field())\n        t, err := ut.T(fe.Tag(), fld)\n        if err != nil {\n            return fe.(error).Error()\n        }\n        return t\n    },\n)\nvalidate.RegisterTranslation(\"required\", fr,\n    func(ut ut.Translator) error {\n        return ut.Add(\"required\", \"{0} est requis\", false)\n    },\n    func(ut ut.Translator, fe validator.FieldError) string {\n        fld, _ := ut.T(fe.Field())\n        t, err := ut.T(fe.Tag(), fld)\n        if err != nil {\n            return fe.(error).Error()\n        }\n        return t\n    },\n)\n\ns := struct {\n    MyField *string `validate:\"required\"`\n}{}\nerrs := validate.Struct(s)\n\nfmt.Println(errs.(validator.ValidationErrors)[0].Translate(en))\nfmt.Println(errs.(validator.ValidationErrors)[0].Translate(fr))\n\n}\n```\nlet me know if you have any questions.\n. although RegisterTagNameFunc could technically be used to affect the translation, that's not what it was designed for; it's more for being able to pass error information back to a caller, such as and HTTP API and used client side.\nfor example, if you were using this library in an HTTP API the field name could be used as the name of the test field which the javascript need to set an error in.\nI'm sure there are many other uses also.\nif you register your own translations, yes you can override the ones in gopkg.in/go-playground/validator.v9/translations/en, you just have to set the override flag to true, but if you're going to replace all of them I'd just copy-paste-modify the translations file into your own library/code/repo and. use it with whatever translations you require.\nunfortunately to achieve this, there is a little work required, but there's just no way I can make a single set of translations work for everyone's use case, the ones provided are just a general set and why you can register your own for your use case :)\nThis is also the first attempt at integrating translations into this library and I'm still gethering data on how people use them; I know it doesn't help now, but I intend to make it much easier to use translation in the next version.. @syssam it's not a bad idea, just not a direction I want to take the validation library in, I think this functionality should remain in the realm of the translator/translation engine.\nfor example universal-translator already provides similar functionality and handles l10n, which the above example does not account for.\nby no means does anyone have to use the translation logic that's built in, it's just a convenience for the majority, anyone can use FieldError, which contains almost all information anyone would need, to perform translations as they need.. Hey @syssam I think there's maybe some confusion about how this all works, the way you are seeing this is just the default error message this library uses see here and here\nYou are able to type cast to those error types and format any error message you wish, this also seems very related to #364  which I believe would also do what you're looking for.\nplease let me know if this clarifies things a bit.. Here is a quick example, have to start my day, will try to make a better full example later, but it's basically what was done in #364  in combination with this: (which can easily be hidden behind a reusable function. )\n```go\n// returns ValidationErrors ( []FieldError )\n    err := validate.Struct(user)\n    if err != nil {\n        for _, err := range err.(validator.ValidationErrors) {\n                    // from here you can create your own error messages in whatever language you wish using the below mothods and the translate method to create the structure you want.\n        fmt.Println(err.Namespace())\n        fmt.Println(err.Field())\n        fmt.Println(err.StructNamespace()) // can differ when a custom TagNameFunc is registered or\n        fmt.Println(err.StructField())     // by passing alt name to ReportError like below\n        fmt.Println(err.Tag())\n        fmt.Println(err.ActualTag())\n        fmt.Println(err.Kind())\n        fmt.Println(err.Type())\n        fmt.Println(err.Value())\n        fmt.Println(err.Param())\n    }\n\nreturn\n```. Hey @syssam sorry for my late reply, did you end up getting this working?. Thank you for your feedback, I'm recording it all to make the next version better :). @ryan-ju I will try and look into adding a better example and documentation, for now here is a brief overview and how this is set up for i18n:\nIt all starts with the locales which provides the various languages translation and formatting rules.\nI then have another package universal-translator which you can register locales with, which provides a way to coordinate locales and register actual text translations.\nNow when registering a translation in validator it is providing a function that actually registers the text translation for the validation tag (using universal-translator) and another function that will actually perform the translation which is then saved within validator.\nNow when translating a FieldError you have to pass in the translator, which will lookup the registered translator and then lookup/translate based on the validation tag that was registered earlier.\nSo in short validator's translations were designed for i18n usage and is setup to use/handle multiple locales; a good example would be a web application where a user makes a request to your site, and:\n- you determine the locale via the Accept-Languages http header and use universal-translator to get the Translator for the rest of your application\n- when validating a POST request using validator if you encounter errors, you can translate by passing in the Translator determined from the http header, which could be one of many locales.\nI hope this clarifies why it's done this way, there are a few things that even I would change, hindesight being 20/20, like having to provide the registering of the text translation; it was only done that way to not lose track of where your translation is registered vs translated, but has proven to be confusing.. @syssam as I stated this is designed for i18n and I don't intend to provide a way for validator to be locked into a single locale for translations; I believe it's that callers job to make that determination.. @ptcoda I will try to take a look this week.. Hey @ptcoda sorry for the delay, I was looking deep into the code and to make this work properly will definitely be a breaking change, I did not anticipate this specific use case; I will add this to the list of v10 improvements :)\nhowever, not to fret, all is not lost, this is actually a perfect use case for Struct Level validation; I would add a validation for your Record struct.\nPlease let me know if this will help :). @vpikulik could you explain what you expected to happen?\nI think, depending on your answer, you will be looking to use the required or omitemtpy tag preceding the max.. Hey @0xdevalias I haven't had time to prove it but I think it's because it gets into this block when it's a pointer and nil, most use cases incorporate required and omitempty which is probably why this hasn't come up before.\nI will look into correcting the logic this weekend to support your use case and thanks for bringing this to my attention.. @0xdevalias it's sounding like it's a more complex validation, usually, once it get's complex enough I recommend using a Struct Level validation, and that way you can do whatever you want and also combine with the built-in validations.\nStill looking into what else I can do with the initial problem, I'm a bit under the weather this weekend so not sure I'm going to get to it.\nDo you think that the Struct Level validation will work in your situation?. @0xdevalias glad that helped! I will look into incorporating this type of functionality into the next version \ud83d\ude04 . Thanks @heatwole will take a look when I get a chance :). @heatwole would you be able to document the new validations in  doc.go as well, so that they are easily discoverable by others :). @heatwole Thanks! will try to get it merged tonight. @heatwole any reason you closed?. \ud83d\udc4d \n. looks great @noibar!. @noibar I know I've already merged, but would you be able to add documentation to doc.go for your validation? \nI totally forgot to ask, will hold off on cutting the release until then :). Thanks!. Hey @lucasmundim I think the underlying reason this isn't working for you is because after the first call the validate.Struct it caches the parsed validation functions and uses the struct type as the key and so the second call would use the first cached values.\nThe library wasn't meant to change that value at runtime and will cause races, as you mentioned you could have 2 validations or use Context to pass to a single, however there is one more possibility, you could create 2 separate validator instances that are set to use different tags names and use each as needed.\nLet me know if that helps :). That I'll have to think about, initial thoughts are no because that logic is abstracted away from the end user, but there may be a better way if I can think on it a bit.. @beiriannydd Yes the Tag Name function is used in the caching layer and used only once pre-validation.\nI'll try to think of the best way to implement this, I'm wary about adding separate caches per tags for performance reasons.\nin the meantime though I'd recommend using 2 different validator instances one for each different tag name.\nAlternatively, you could probably achieve what you're looking for using a StructLevel validation; usually, these are used for more complex validations.. Thanks @foolin !. Thanks @dvic !!!!. Hey @veqryn , sorry for the late reply, been super busy lately.\nAlthough it is possible, it does seem like a complicated validation; I recommend either creating and using your own validation or use the StructLevel validation if this is a one-off.\nThe reason is that once the logic starts getting this complicated IMO, it shouldn't be added to the tags as it hurts readability of the code.. Hey again @veqryn ya I agree and it has been requested a couple of times it is something I will be considering for the next release.\nIf anyone wants to take a crack at it before then, I would consider adding it to this version but it will take a lot of thought because of all the indirection that occurs before getting to the error itself.. Hey @peddaswamy sorry for the late reply, been super busy\nI ran your test and it worked as expected, perhaps it's another aspect of your program? or an outdated version with a bug?\nhere is the code and output I ran and received\n```\npackage main\nimport (\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\nfunc main() {\n    validate := validator.New()\n    err := validate.Var(\"test\", \"required,email\")\n    fmt.Println(err)\n    err = validate.Var(\"test@gmail.com\", \"required,email\")\n    fmt.Println(err)\n}\noutput was:\nKey: '' Error:Field validation for '' failed on the 'email' tag\n\n```. Hey @youcandoit95 \ncan you confirm you have the latest version of the code, the validation was added recently?. @youcandoit95 did updating help?. closing due to no response.. Thanks @wesselvanderlinden !. Hey @golden0080 \nThis one's actually been asked  a bunch of times in different ways, it comes down to the way Go handles default values.\nThink of the required tag as ensuring that the data is not set as the default value for the datatype, because Go always assigns a default value, in your case for the enum is 0; there's no way to differentiate between a default value and an assigned values equal to a default value.\nThere are option however:\n1. you could use UserType as a pointer eg. UserType *UserType, that way the default value is nil and so 0 will pass.\n\n\nDon't use required and use another validation such as gte=0\n\n\nCreate a custom validation that handles the zero case for your enum specifically.\n\n\nRegister a CustomTypeFunc for your enum type that will evaluate and return a different value that will pass or fail based on that returned value.\n\n\nWhich one you choose is really up to you and what's best for your use case; please let me know if this helps :). Hey @droslean \nThere are two options:\n\n\nYou can create and register a custom validation function that does what you want, see here for the example. FieldLevel has access to the current and top level structs and so you can create a validation that looks at both fields.\n\n\nYou can use the StructLevel validation like the example here, which sounds more like what you're looking for. When validation use cases get complicated enough it usually warrants this type which will allow you to validate however you wish.\n\n\nPlease let me know if that helps :). Yes @droslean, as in the docs RegisterTagNameFunc\nhere is an example in the tests.. Hey @canhlinh \nIt's hard to tell exactly what you're trying to accomplish without an example, but I'll try my best.\nThe line you reference is past this line which brings you back to the top of the switch check and so if you return a nullable type from the custom type function, is will return true as nullable.. @canhlinh would it be possible to see the structure you're trying to validate and any custom type funcs registered? \nBefore having to make a breaking change I'd like to explore the options, I think this can be used in conjunction with the omitempty tag, just need and example use case.. @canhlinh glad that worked for you:). Hey @gitste \nsorry for the late reply, been super busy, I plan to leave it out as a hard dependency in the next version., but for now will have to stay.\nI'm not sure what you mean by too big for your program, the translations are optionally registered and the reference to the locales and universal-translator package should only be minimally compiled in, not the entirety of it.. @gitste \nSo it depends on how you're pulling dependencies of the packages via git clone or go get go get iirc will pull all dips from sub-packages as well.\nRegardless the fix is to change the ut.Translator references to an Interface to decouple it and that should get you what you want without breaking changes to the lib; I was planning to do this in v10 but wanted to also make a lot of other changes also at the same time.\nI would like to make the changes, but not sure when I'll be able to get to them as I'm quite busy lately, but would definitly accept a PR f you need it sooner :)\ndoes that make sense? if need be I can make an exception to make a premature v10, but would like to avoid that if at all possible, major updates can be very disruptive. . Hey @jlpellicer I'm not quite sure your use cases correctly about what you expect.\nCorrect me if I'm wrong but I think it's that you need to know the difference between a JSON null and en empty string which is usually solved by having the data type *string rather than string and when the value is null the variable will be nil.. oh I see, thanks for the clarification!\nomitempty should work for both null and empty string for how you want because the resulting struct for both should result in an empty string.\nI'm going to whip up a POC real quick to ensure it's behaving that way (because it should be) and if not there's a bug...will get back to you shortly.. Hey @jlpellicer so here's the POC I came up with:\n```go\npackage main\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\ntype Book struct {\n    ID    int    json:\"id\"    db:\"id\"\n    Title string json:\"title\" db:\"title\" validate:\"required,min=1\"\n    ISBN  string json:\"isbn\"  db:\"isbn\"  validate:\"omitempty,isbn\"\n}\nvar t1 = {\n    \"title\": \"Book title\",\n    \"isbn\": \"\"\n  }\nvar t2 = {\n    \"title\": \"Book title\",\n    \"isbn\": null\n  }\nvar t3 = {\n    \"title\": \"Book title\",\n    \"isbn\": \"9788416290437\"\n  }\nvar t4 = {\n    \"title\": \"Book title\",\n    \"isbn\": \"abcd\"\n  }\nfunc main() {\n    var b1, b2, b3, b4 Book\nerr := json.Unmarshal([]byte(t1), &b1)\nif err != nil {\n    log.Fatal(err)\n}\n\nerr = json.Unmarshal([]byte(t2), &b2)\nif err != nil {\n    log.Fatal(err)\n}\n\nerr = json.Unmarshal([]byte(t3), &b3)\nif err != nil {\n    log.Fatal(err)\n}\n\nerr = json.Unmarshal([]byte(t4), &b4)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"%+v\\n\", b1)\nfmt.Printf(\"%+v\\n\", b2)\nfmt.Printf(\"%+v\\n\", b3)\nfmt.Printf(\"%+v\\n\", b4)\n\nvalidate := validator.New()\nerrs1 := validate.Struct(b1)\nerrs2 := validate.Struct(b2)\nerrs3 := validate.Struct(b3)\nerrs4 := validate.Struct(b4)\n\nfmt.Println(errs1)\nfmt.Println(errs2)\nfmt.Println(errs3)\nfmt.Println(errs4)\n\n}\n```\nand the results were, if I'm not mistaken, what you're looking for:\nshell\n{ID:0 Title:Book title ISBN:}\n{ID:0 Title:Book title ISBN:}\n{ID:0 Title:Book title ISBN:9788416290437}\n{ID:0 Title:Book title ISBN:abcd}\n<nil>\n<nil>\n<nil>\nKey: 'Book.ISBN' Error:Field validation for 'ISBN' failed on the 'isbn' tag\njust checking that maybe this was a bug in the past, do you have the latest version of the lib and does this example produce the same output for you?. Hey @payuprashantg it looks like your tag syntax is incorrect and missing the double quotes eg.\ngo\n`validate:\"required\"` vs `validate:required`\nplease let me know if that solves it :). Hey @loeffel-io I think you are looking for the omitempty tag to be used with the email tag if a blank or nil value is ok in your application.\nTo address your comment about blank or nil passing without a required tag the built in validations won\u2019t pass in these cases and need to be told that blank is ok; I would say that it\u2019s working as expected as you asked it to ensure the field was a valid email and blank is not.. @loeffel-io you must reverse the omitempty and email tags, omitempty skips the rest of the validations and so having it last causes the email validation to still occur.\nPlease refer to the godocs linked to the README, they are pretty thorough and provide example usage.. As asked in the PR https://github.com/go-playground/validator/pull/403#issuecomment-432718271. @alexbilbie thanks for the PR!\nThe change makes perfect sense, however this would also be a breaking change.\nIf it were me I would ensure the values are lowercase before validating using mold or something.\nbut I can see how both would be useful, instead of modifying the existing ones what do you think about adding new ones with the suffix lax eg. uuidlax?\nthat way both are available without a breaking change.. @rssathe It's breaking in the fact that people may be relying on it to catch is it's not lowercase, I WILL NOT make a breaking change to people like that.\nI suggested a way to get it merged in and never heard back, @rssathe if you want to modify the code by adding the new validations with a new key eg. uuid_rfc4122 I'd be more than happy to merge.\nanyone who wants to still use uuid alias should work. @rssathe the trickey part is this statement\n\nRFC 4122 allows uppercase characters for input of functions but requires lowercase characters on output:\n\nif it allowed in and out I'd gladly make the change, but unfortunately it doesn't. \nThe idea behind the way it is now is that usually your validating before saving or persisting somewhere or forwarding somewhere else, so if it were me writing a program, to ensure that when it's output will always be correct, is lowercase before validation and what I encourage people to do to save any headaches.. @44px thanks for the PR!. @kanozec yes by all means please add, the underlying locales package should support that :). Yep, multiple ways in the Doc you can use:\n- https://godoc.org/gopkg.in/go-playground/validator.v9#hdr-Skip_Field\n- https://godoc.org/gopkg.in/go-playground/validator.v9#Validate.StructExcept\n- https://godoc.org/gopkg.in/go-playground/validator.v9#Validate.StructFiltered\n- https://godoc.org/gopkg.in/go-playground/validator.v9#Validate.StructPartial\nI think the first is what you're looking for given your scenario; let me know if that helps :). The documentation for this was recently updated in this PR\nhttps://godoc.org/gopkg.in/go-playground/validator.v9#Validate.RegisterTagNameFunc\nafter registering such a function then the json name will be used...it can also be customized any way you wish for BSON name, really anything.\nlet me know if that helps?. I\u2019m not sure I understand the question, could you provide more details?. I've seen issues like that before where it's the git version, that go get uses under the hood that doesn't follow redirects; IIRC it was 1.7.3\nwhat's your git version?. hmm @wongyinlok have you tried git cloning manually and using it? if that succeeds then it's something to do with the fetching rather than the package itself.. Hello @hxmhlt \nI'm not sure this will solve your problem as the resulting ValidationErros is also a map, and if multiple errors are returned, which this library supports.\nI'm also worried about the performance impacts of this as ranging, balding and array, sorting and then ringing again with a map lookup isn't a cheap operations.\nI curious if migrating to v9 wouldn't be a better option as the resulting errors are now an array rather than a map which should solve your issue; furthermore v9 is far more efficient and the interface vastly simplified.\ndo you think v9 would work for you better?. @hxmhlt oh so you're saying v9 doesn't work with sqlmock also? would you be able to provide an example?. Hey @dakait \nit's because the name is prefixed with the structs name, you'll want to do StructPartial(foo, \"Foo.Name\")\nthis is because this package supports multiple levels of nesting.\nplease let me know if this helps :). @Jwata A package can only view the unexported fields of types within its own package and so they must be ignored or there will be an exception; this is true of all packages using reflect even the son package.. Thanks @holyspectral I'll try and get this merged soon. Hey @andreiavrammsd sorry for the delay I responded a few days ago but I don't see it here, was having internet issues that day...anyways\nI'm curious how this is different from combining required and gt like so required,gt=0?\nif it's just that you want the nonblank tag as the error an alias can be registered for this.. Ah I see, I missed the TrimSpace in your validation; I'm not against this but also wanted to suggest an alternate approach; I too have seen that things like this are pretty common and so created another package to help sanitize the data prior to validation.\nmold which will allow you to trim and sanitize data in a number of ways, even trimming values of maps.\nMy only concern about adding this to the validation lib is that I can see a great number of additional cases eg. streaming map string values or map of map string values... and don;t think it would make sense to have all of them in the std validation package.\nWhat do you think about using the modifiers package of the mold lib prior to validation?. Sorry for the delay, super busy, my only concern is that the validation actually does more that one thing that corresponds https://github.com/go-playground/validator/pull/421/files#diff-e8dcd0f6e62fb5a9257bc99c0891f3f8R1197\neg. both len and required are being mixed together in this validation; the way I look at baked-in validations is that they are of singular purpose.\nbut I definitely see the value in this and other non-standard validations as well so I have a proposal, if we could create some sub-folders for this package non-standard/validators and non-standard/aliases\nThen we can add these sorts of validators here and people can easily register them if they desire, but won't be registered by default.\nWhat do you think?\n. @andreiavrammsd I like option #2 but I'd still want them in another package as described because there are still aliases and translations that can go along with the validation and I'm worried about cluttering up the validator namespace.. @andreiavrammsd apologies for the delay, trying to catch up after the holidays, I have not forgotten. @andreiavrammsd looking great! if you could add a note about non-standard then I can merge :). Awesome thanks!. Hey @IsSwm \nI think I know what you mean, you want all the errors in one object so you can pass it to app.MarkValidErrors(...), please correct me if I'm wrong.\nWhat I recommend doing is extracting the form data into a struct and then calling validate.Struct(...) and if there are errors it will be of type *validator.ValidationErrors which is an array of FieldError.\nThere are several ways to put the form data into a struct, manually or by using one of the many libraries available that decode form data into a struct much like json.Unmarshal; if you're interested in this approach I of course would recommend this one.\nlet me know if this helps :). Hey @fharding1 thanks for the PR!\nI just have one request, can it be renamed to fieldcontains and fieldexcludes?\nI was confused by the naming, I was reading it as if it was checking that the actual field was contained in the struct rather than containing the value.. sorry @fharding1 got sick after the holidays and now the family is sick, trying to catch up on all this, sorry for the delay. @fharding1 no worries, I do forget sometimes too ;). @vishal3152 @ianaz Unfortunately is no way in Go using reflection to get the variable name, I looked at everything trying to find a way when I wrote the lib.. @1011875777 if you know of a way to dynamically extract a variables name at runtime I\u2019d be happy to add it.. Hey @mastertinner thanks,\nI was considering this and once go modules are on by default in the next release I was going to convert this library and probably change stop using gopkg.in; it will require a version bump as it's a breaking change, but I have a few other things that also require breaking changes.\nI think the changes in this PR have already been fixed by another PR.. @leodido thanks for the PR!\nJust one ask, because there are multiple RFC\u2019s and this one is already obsoleted by \nhttps://tools.ietf.org/html/rfc814 can we rename it to urn_rfc2141?\nOne can always register an alias if they want to use the short name :). @leodido actually there is one more thing I noticed there was no license on the go-arn package used for the validation; I\u2019d need a compatible license added before I can include. Yep MIT is compatible . Merged the changes and released in https://github.com/go-playground/validator/releases/tag/v9.24.0 :). @akm thanks for the PR!. @ansel1 are you sure this has been posted to the correct place?. Hey @byrnedo, unfortunately, no and for a good reason too:\ntype Y struct {\n    Field string\n...\n}\ntype X struct {\n    Y\n    Field string\n}\nthis is perfectly valid and why Y is included in the names space in order to be able to differentiate between the 2.. @byrnedo sorry for the late response, but I think this may be outside of what the library should be responsible for.. Hey @mkadin so there are a few options, only 2 you really want though:\n1. Write a struct level validation where you can do the check to see if it's a director or normal person and validate from there.\n2. Write custom validations as you eluded to above, since validation function accept FieldLevel interface which has access to the direct and top level parent structs https://github.com/go-playground/validator/blob/v9/field_level.go#L10 you should also be able to check if it's a director or person.\nThe approach is up to you and depends on how you want to maintain the validations going forward, one struct level with multiple cases or multiple validations handling less.\nplease let me know if that helps.. Hey @IvanDelsinne as the documentation states I think you're looking for omitempty. Thanks, I'll take a look when I'm able.. @rssathe LGTM, I'll merge now, it would be great if you could add these to the docs also :). @fuxiangduan  The only way in go is by changing name to be a pointer eg.\n``go\ntype Form struct {\n    ID    stringform:\"id\" json:\"id\" binding:\"required\"Name  *stringform:\"name\" json:\"name\"`\n}\nThen when it's not passed the field will be nil, this is a common question and is in multiple other issues\n``. Hey @axopadyani this is because to handle any type the [Value()](https://github.com/go-playground/validator/blob/v9/errors.go#L136) function needs to return typeinterface{}` and so the value returned is actually an interface{} which points to the nil value and so not nil itself because of the extra indirection.\nif you tried casting to the underlying type before checking equality you can detect nil eg. valErr.Value().(*string) == nil. @thessem the validator currently only reports on the error that occurred, however, there are 2 options to achieve what you're looking for:\n\n\nYou can register an alias and then register your own translation for it.\n\n\nThere is no requirement to use the built-in translations or error messages in this library, it returns all the information needed to create your own messages as you see fit, see here for an example.. Hey @KlausBuchegger \n\n\nto achieve that you'd have to create your own custom validator or struct validation. There are some validations for cross-field comparison, but nothing that will do conditional.\nIf you could come up with a generic one I'd gladly accept a PR :)\nI had thought about adding more complex syntax support, however, I've found that if you need such complex logic you should be programming it in the language rather than the struct tags as it can become unreadable and combersome.. @tredoe at this point what would you not go the extra step and register it as a validation; it would be much clearer as to what it does via the validation tag also.\nThis is also dangerous as there's no compile-time checking you don't have a typo or that someone hasn't renamed your variable or removed it altogether unintentionally and it will blow up at runtime.. @tredoe I'm not sure I understand what you mean? could you elaborate with an example?. Tanks @rucas for the PR, will try to get it merged this week. @mh-cbon can you provide an example usage of the above validation? I'm curious to see how it's used and potentially add it to the built-in validations.. @mh-cbon I suppose a LeftTrim could fix this after the splitting of the tag, however, is definitely a breaking change, just in case someone has registered a validation containing a space already.\nwill add it to a v10 enhancement.. extra be\n. I will update this verbiage as the change isn't relaying the information intended\n. Usage is incorrect\n. Just minor but if can change stringato string. Also minor but if you could make the groups non-capturing that'd be great! eg. (?:. Is this going to work when it's multidimensional? eg your example is Model.Items[0].Items.Str\nWhat if it's two levels deep eg. Model.Model2.Items[0].Items.Str, this code looks like it will cut off Model2? perhaps this should be LastIndex?. thanks @tschaub I'll correct the docs; next time if you could create a new issue that'd be great as it's confusing to have a discussion in a closed or merge issue/PR :). I'm surprised this one fails, isn't this valid HTML? just an end tag.. Have you tried using Elem or Indirect to automatically downgrade instead of returning an error?. Hey @joshhsoj1902 thanks for the PR\nI think that only this addition is necessary. I'll take a closer look, sorry for the delay I'm extremely busy. @joshhsoj1902 would you be able to share your example, seems like the best place for me to start :). no worries I only get a couple hours at most to take care of my open source stuff lately, tis the holiday season.. like the change, it would be nice if you could add a type switch as it will allow the conversion from int to string to be much more efficient eg. https://github.com/go-playground/validator/blob/52ea44899849049e3ae9267ef1902c36807fe198/baked_in.go#L193. If you could add a note here about what Non standard validations are and that you have to register them manually that would be amazing :). ",
    "chrisscott": "Thanks! \n. ",
    "manucorporat": "If you want to merge it, please let me know, so I can fix the unit tests or restore the old error messages.\n. I am working in a complete integration with gin, this is a automatic generated error JSON.\njson\n{  \n   \"error\":\"Struct:JSON\\nField validation for \\\"Title\\\" failed on the \\\"required\\\" tag\\nField validation for \\\"Description\\\" failed on the \\\"required\\\" tag\\nField validation for \\\"Body\\\" failed on the \\\"required\\\" tag\\n\\n\\n\",\n   \"fields\":[  \n      \"title\",\n      \"description\",\n      \"body\"\n   ],\n   \"message\":\"title, description and body are required.\"\n}\nwhat do you think?\nsee! there are many end-lines in the error message.\n`` go\ntype JSON struct {\n    Title       stringbinding:\"required\"Description stringbinding:\"required\"Body        stringbinding:\"required\"`\n}\nfunc main() {\n    router := gin.Default()\n    router.Use(gin.ErrorLogger())\n    router.POST(\"/\", func(c *gin.Context) {\n        var json JSON\n        if c.BindJSON(&json) == nil {\n            // read json safely\n        }\n    })\n    router.Run(\":8080\")\n}\n```\n. @joeybloggs nice! \ncheck out my work in progress, maybe we should join efforts (but for now... I am going to sleep ;) )\nhttps://github.com/gin-gonic/validator/commit/474180a2dd22572102897e4db08c6fddbac5c767\nhttps://github.com/gin-gonic/gin/commit/784d73477d056308e8c6ea666d52048906e48a7c\n. offtopic: I love the new v5 API. nice work!\n. nice!\n. Awesome, here another advantage:\n- less code -> less possible bugs\n:smile: \n. @joeybloggs yes! I think it is ok to drop support for Go 1.2.\nGo 1.4.2 is the most stable version to date and it is the default one in Google App Engine, so...\n. ok... this is so weird. now it does not panic. I need to investigate as well.\n. @joeybloggs ok, never mind! yes it panics:\nthis HTTP request for example: \n```\nPOST /post HTTP/1.1\nContent-Type: application/json\nHost: localhost:8080\nConnection: close\nUser-Agent: Paw/2.2.2 (Macintosh; OS X/10.10.4) GCDHTTPRequest\nContent-Length: 22\n{\"A\":\"value\",\"C\":\"nu\"}\n```\n. @joeybloggs well, it is disappointing because there is not very stable validation library out there. yours is still improving and the rest are not good or abandoned.\n. @joeybloggs we are working in very a complete suite of unit tests. can you connect to Skype?\n. ",
    "pavlik": "Confirm! Working.\n. ",
    "sathibault": "Trying this another way I get:\n$ go get -v github.com/bluesuncorp/validator\ngithub.com/bluesuncorp/validator (download)\ncd /home/pico/go-packages/src/github.com/bluesuncorp/validator; git checkout master\nerror: pathspec 'master' did not match any file(s) known to git.\npackage github.com/bluesuncorp/validator: exit status 1\n. Problem solved.  It looks like it just doesn't work with older version of git.\n. ",
    "olurin": "\n\n\n\n. \n\n\n\n. ",
    "johnniedoe": "I'm currently using v5 w/gin, but I put together a test implementation for v6.  It's under:  https://github.com/johnniedoe/validator\nI was able to avoid the extra allocations, and it seemed to run the benchmarks w/o much noticeable performance impact.\nA lot of structs that interface w/SQL may have Valuer fields, so I thought it'd be handy to have.\nIf you want to keep the core validator free of cases like these though, I totally understand.\nThanks for the suggestion on the custom validator.\n. I'm starting to wonder if it would make more sense as a baked-in validator.\nHaving it automatically applied is handy in most cases, but may violate the\nprinciple of least surprise.  If someone happens to implement Valuer in a sub-struct,\nthey'd lose the ability do per-field validations on that struct.  Having it need to get\nexplicitly called or enabled during config might be the safer option.\n. I see your point that it is essentially a one-off.  It may be a fairly common use-case, but the solution is a one-off nonetheless.\nTaking a step back, it seems that the broader questions are:\n- Should the validator have the ability to directly validate types that the end-user cannot add tags to?\n- If so, what is the best mechanism for enabling such functionality?\nThe first is a question of scope, and is really up to you.\nIf you're interested in handling these use cases in general, I may try to come with a more generic mechanism.  At this point, I'm imagining an array of type-specific pre-filters that could be specified when configuring the validator.  That way, it's there if folks need it but incurs little/no overhead otherwise.\nYour supplied helper function looks like a nice way to be able to handle the type while still using the existing validators.  If I'm reading it correctly though, it seems like using it will require running the validator separately on each field of a struct though, which is a bit unfortunate.\nThanks again for the package, and for taking the time to look into this.\n. That seems like a pretty good solution.\nI'll need to list all of the concrete types of the Valuers when using it, but it's just done once at Config time.\nIf the typeOverride code in the validator checks that len(TypeOverrides) > 0 before doing the map lookup, it should incur essentially no cost unless it is actually used.\nI should probably mention that since reflect.Types are interface types, map lookups keyed on them won't be as quite as fast as a map[int]func lookup would be.  I'm seeing ~30ns/lookup on my machine, vs ~5ns/lookup for an int-based map lookup.  This seems good enough to me.  If this became an issue though, a per-validated structType cache would probably help.\n. ",
    "alioygur": "i am using v6, there is sample.\n```\npackage main\nimport (\n    \"fmt\"\n\"gopkg.in/bluesuncorp/validator.v6\"\n\n)\n// User contains user information\ntype User struct {\n    FirstName string validate:\"required\"\n    LastName  string validate:\"required\"\n}\nvar validate *validator.Validate\nfunc main() {\nconfig := validator.Config{\n    TagName:         \"validate\",\n    ValidationFuncs: validator.BakedInValidators,\n}\n\nvalidate = validator.New(config)\n\nvalidateStruct()\nvalidateStruct2()\n\n}\n// this not works\nfunc validateStruct() (err error) {\n    user := &User{\n        FirstName: \"Badger\",\n        LastName:  \"Smith\",\n    }\nerr = validate.Struct(user)\n\nif err != nil {\n    fmt.Println(\"validation failed\")\n}\n\nreturn\n\n}\n// this works\nfunc validateStruct2() (err error) {\n    user := &User{\n        FirstName: \"Badger\",\n        LastName:  \"Smith\",\n    }\nerrs := validate.Struct(user)\n\nif errs != nil {\n    fmt.Println(\"validation failed 2\")\n    err = errs\n}\n\nreturn\n\n}\n```\n. @joeybloggs so so thank you for your response. i will not use the named error.\n. @joeybloggs , can you review this code for me ?\n. Tank you so much dear. I am not on computer now.  I will reply to you\nlater.\nOn Jul 31, 2015 8:55 PM, \"Dean Karn\" notifications@github.com wrote:\n\nIt seems like you have a pretty good grip on go, code looks very good. And\nFINALLY! someone using the \"dive\" tag I worked so hard to have that work\nlike it does [image: :smile:]\nI would recommend a few things, but they are minor and some just pure\npreference.\n1. DeletePost possible issue, see comment in code\n// DeletePost delete post handlerfunc DeletePost(c *Context) error {\n    post := new(Post)\n    err := DB.Find(post, c.Param(\":id\")).Error\n    if err != nil {\n        return err\n    }\n```\n    // does DB.Find return an error when post is not found?\n    // if not the next line will probably error out\n// secondly is not finding a post for deletion an error, or is it ok?\nerr = DB.Delete(post).Error\nif err != nil {\n    return err\n}\nreturn c.NoContent(204)\n```\n}\n1. Functions that don't return a new parameter\nthis ones totally a preference, but when a function doesn't return a new\nvariable, save a reusable one like error, or I don't need the new variable\nbelow the current line, I tend to write it like this\nvar err error\nif err = BindAndValidate(c.Request, req); err != nil\n  return err\n}\nso your CreatePost could be rewritten in fewer lines, but just as readable\n// CreatePost create post handlerfunc CreatePost(c *Context) error {\n```\n    var err error\nreq := new(NewPostReq)\nif err = BindAndValidate(c.Request, req); err != nil {\n    return err\n}\npost := new(Post)\nif err = CopyTo(req, post); err != nil {\n    return err\n}\npost.UserID = 1\nif err = DB.Create(post).Error; err != nil {\n    return err\n}\npr := new(PostResource)\nif err = CopyTo(post, pr); err != nil {\n    return err\n}\nreturn c.JSON(201, pr)\n```\n}\n1. dynamic structs\nThis one may be because of how JSON is processed, so if so totally ignore\nthis. I usually take the time to create the sub structs that could be\ndynamic, which allows for reusability later down the line; but there are\ncaveats, see below:\n// so instead oftype NewPostReq struct {\n    Title       string validate:\"required\"\n    Description string validate:\"required\"\n    Body        string validate:\"required\"\n    Tags        []struct {\n        Tag string validate:\"required\"\n    } validate:\"min=2,dive\"\n}\n// I would do\ntype Tag struct {\n  Name string validate:\"required\"\n}\ntype NewPostReq struct {\n    Title       string validate:\"required\"\n    Description string validate:\"required\"\n    Body        string validate:\"required\"\n    Tags        []_Tag validate:\"min=2,dive\"\n}\n// NOTE: you will notice that I used []_Tag, note the * // although there is debate on this I tend to pass almost // all struct by reference internally within my code.// but there are times to lock it down, just take a look// at Config within my validator, it is passed by value// so that it gets copied and you can't manipulate it after\ninitialization.\nthe caveats are\n- the JSON would probably have to be formatted differently\n- my validators error key in the map, if it failed, would be\n  \"NewPostReq.Tags[0].Tag.Name\" instead of \"NewPostReq.Tags[0].Tag\" and the\n  field would be \"Name\" instead of \"Tag\"\nanyways @alioygur https://github.com/alioygur I thinks that's it, and\nagain, code looks great, hopefully you can star my repo if this\npackage/library works out for you.\nP.S. if the code your working on becomes a project, and it's ok with you I\nwould love to start listing some projects on my README that use my library.\nand be sure to check out some of my other projects here\nhttps://github.com/bluesuncorp I'm going to be adding more as time goes\non.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bluesuncorp/validator/issues/134#issuecomment-126771004\n.\n. @joeybloggs i agree with your all caveats. i will refactor my code by your caveats.\n\nthank you.\n. first of all, I think you should change list of changes to numeric list :) so I we can talk better\n. Allow Structs to be validated, just like fields, see #245\nI do not agree with this.\nChange required to nondefault or have both tags present? required makes more sense when reporting errors, but nondefault is clearer for those using the library. Thoughts?\nI do not agree with this.\nThere is awesome library that written with PHP.\nhttps://laravel.com/docs/5.2/validation\nI think go-playground/validator is best validation package in golang. but it is small.\nsorry for my bad english.\n. And, Please don't remove the \"dive\" tag!\n. Yes. about number of validations.\nSo I provide a package. https://laravel.com/docs/5.2/validation this package has a lot validations.\n. ",
    "ilgooz": "+1 https://github.com/ilgooz/stack\n. ",
    "davisford": "I was going to maybe take a stab at writing a custom validator that could just check if something exists, but I figured I'd ask here first in case I misread the situation.\n. Awesome!  thanks!\n. Awesome -- thank you.  I may have to make my own fork of gin and update to v6.  Might take a bit -- sounds like you tested it out...feel free to close the issue.  I appreciate the super immediate response time.\n. ",
    "codepushr": "Is this still supported in v9 ? I need the same behaviour for HTTP PATCH where I have to distinguish between ommited and set values - therefore the bool pointer. I'm getting the error that exists does not exist as a validator.\nEDIT: I found the exists validator in v8 - works like a charm there! No idea where it went in v9 lol.\n. Sure! This should demonstrate what I mean. Basically the validation fails although I'm using a pointer to a bool with false as the value. What I'm expecting is that if I use a pointer the validation only checks if it's not nil - but in this case it also checks the underlying value - which MAY work as expected but is different from exists in v8.\n``` go\npackage main\nimport (\n    \"log\"\nv \"gopkg.in/go-playground/validator.v9\"\n\n)\ntype Foo struct {\n    Bar *bool validate:\"required\"\n}\nfunc main() {\n    b := false\nmodel := Foo{\n    Bar: &b,\n}\n\nerr := v.New().Struct(model)\n\nlog.Println(err)\n\n}\n``\n. @joeybloggs  Looking good! Thanks for the amazingly quick response! :)\n. Hm, therequiredtag does not work the same way asexists` did with pointers! See https://github.com/go-playground/validator/issues/142#issuecomment-250163238\nE.g. using a false for a bool pointer results in a failed validation. Now using v8 where exists worked exactly as intended.\n. ",
    "FrankHitman": "thanks all. ",
    "jtriber": "Suggesting the following changes to make the behavior clear at the call level:\n// keep this as a single function but make it private\nstructPartial(current interface{}, exclude bool, fields map[string]struct{}) ValidationErrors  {...}\n// public interface\nStructPartial(current interface{}, fields map[string]struct{}) ValidationErrors\nStructExcept(current interface{}, fields map[string]struct{}) ValidationErrors\n. ",
    "ardan-bkennedy": "Wrong version number\n. This is great !!.  I am using the package in this code (https://github.com/ArdanStudios/gotraining/tree/master/13-http/api) which is part of my training material. I am giving a talk on dependency management and I am using the code to show for solutions. In vendoring your code and running tests, I came across the problem.\n. ",
    "gayanhewa": "Looks like it then. I am on 1.2.1 I will probably upgrade. :+1: \n. ",
    "flowonyx": "Thanks! I have no problem with you implementing it in any other way, I just thought it was an easy way to add some clarity.\n. ",
    "mattes": "My concern is that if someone changes Field to FieldNew or whatever and then uses FieldNew later in the code, thinking it must be fine, because validator.StructXX did not return anything, this will lead into vulns. In a perfect world, the developer would not forget to to update validator.Structxx of course ...\nSo from my perspective it should def panic or return an error. I think a panic works, an error might be nicer to handle. \nIt would be super awesome, if there is a way to let the compiler find these issues, but I doubt it's possible.\n. Besides this issue, kudos for this lib! Tried several ones. This one is by far the best I've seen!\n. > The real question is should StructExcept() panic as well?\nI think so.\n. I think we should differentiate between syntactically errors and actual value errors. The lib should first check, if the specified fields really exist and then in a second step apply all validation rules.\nSQL will also decline the operation if there is an invalid field name. \n\nPerhaps I can make it a configuration option \n\nI think the syntax check should be mandatory.\n. Sounds good. \n. ",
    "krhubert": "Already fix an error, hope is fine now.\n. Ok, i think it's done, can you review it?\nAlso I found possible ambiguity in golang (https://github.com/golang/go/issues/14037). The tests are aware of it.\n. Good question - I think it should :) but now i'm not 100% sure\nhttps://play.golang.org/p/3UUNtI7Cig => here validation of empty tcp addres => this one I think it's ok, becouse it means 0.0.0.0:0, but it can be error prone.\nI think you can leave it as it is, and maybe wait for some feedback. Also wait for go isssue to be solved\n. There is update on https://github.com/golang/go/issues/14037\n. No problem, I was busy too, I should be avaiable on monday, then I can help you with this.\n. Same for me ^^ :D, but I want to do this too!\n. Hey, great :), Sorry but I still lack of time :/\nFor me everthing seems fine and good:\n[root@debian $GOPATH/src/github.com/go-playground/validator (krhubert)] go test\nPASS\nok      github.com/go-playground/validator  0.009s\nI show your discussion about the UnixAddr, still I think it's strange.\n. @joeybloggs yes I have seen UnixAddr, TcpAddr, UpdAddr and all those funtions, but what can I say more :), I've also seen your lars project, seem interesting, if I will have chancen i will try to use it :)\n. ",
    "scisci": "awesome! yeah that totally works for me. I will look into implementing it as soon as possible. thanks @joeybloggs I had some more complex validation as well so using a validation function makes total sense.\n. no problem, i had omitempty on mjy json, but didn't know it was also a validator tag. Thanks!\n. ",
    "dennisfaust": "Tests 1 and 3 pass as expected. The second test fails but it does so before hitting the custom validator.\nhttps://gist.github.com/dennisfaust/a91af314b1ad06567c90\n. From @joeybloggs: \nComments & Solution\nOK @dennisfaust I must say this is definitely a unique case because the kind of null.StringFromPtr(nil) is invalid so you have a value that can be invalid, the default string value and an actual value; not many can be all three, but validator can handle it! :smile: and it's relatively simple just change your struct to the following\ntype testNotBlankStruct struct {\n    ID    string\n    Token null.String validate:\"gt=0,omitempty,notblank\"\n}\nomitempty handles the nil value and kind invalid\ngt=0 handles the blank value\nSide note\nYou can probably eliminate the custom validator and have the \"notblank\" tag removed like so:\ntype testNotBlankStruct struct {\n    ID    string\n    Token null.String validate:\"gt=0,omitempty\"\n}\n. ",
    "solher": "Awesome !\nI guess it wasn't a lot of work that's why I didn't pull request haha.\n. ",
    "odinliu": "I got same problem. It is ok under my macbook. But it got hanged under CentOS 6.7. My macbook and the server were under the same network. \nMy go version is 1.5.1. My console output is below.\n[work@spider0 xmspider]$ go get -v github.com/gin-gonic/gin\nFetching https://gopkg.in/bluesuncorp/validator.v5?go-get=1\nParsing meta tags from https://gopkg.in/bluesuncorp/validator.v5?go-get=1 (status code 200)\nget \"gopkg.in/bluesuncorp/validator.v5\": found meta tag main.metaImport{Prefix:\"gopkg.in/bluesuncorp/validator.v5\", VCS:\"git\", RepoRoot:\"https://gopkg.in/bluesuncorp/validator.v5\"} at https://gopkg.in/bluesuncorp/validator.v5?go-get=1\ngopkg.in/bluesuncorp/validator.v5 (download)\n^C[work@spider0 xmspider]$ go version\ngo version go1.5.1 linux/amd64\n. @joeybloggs thx a lot\n- I install go with the linux binary release. (https://storage.googleapis.com/golang/go1.5.2.linux-amd64.tar.gz)\n- I can download other packages, except from golang.org. because it can not visit directly in China.\n- I can't. Secondly I tried, it has been hanged.\n```\n[odin@namenode0 ~]$ go get -u -v gopkg.in/bluesuncorp/validator.v5\nFetching https://gopkg.in/bluesuncorp/validator.v5?go-get=1\nhttps fetch failed.\nimport \"gopkg.in/bluesuncorp/validator.v5\": https fetch: Get https://gopkg.in/bluesuncorp/validator.v5?go-get=1: net/http: TLS handshake timeout\npackage gopkg.in/bluesuncorp/validator.v5: unrecognized import path \"gopkg.in/bluesuncorp/validator.v5\"\n[odin@namenode0 ~]$ curl -v 'https://gopkg.in/bluesuncorp/validator.v5?go-get=1'\n About to connect() to gopkg.in port 443 (#0)\n   Trying 107.178.216.236... connected\n Connected to gopkg.in (107.178.216.236) port 443 (#0)\n Initializing NSS with certpath: sql:/etc/pki/nssdb\n   CAfile: /etc/pki/tls/certs/ca-bundle.crt\n  CApath: none\n SSL connection using TLS_RSA_WITH_AES_256_CBC_SHA\n Server certificate:\n   subject: E=gustavo@niemeyer.net,CN=www.gopkg.in,C=BR\n   start date: Mar 03 20:36:52 2015 GMT\n   expire date: Mar 03 07:12:49 2016 GMT\n   common name: www.gopkg.in\n   issuer: CN=StartCom Class 1 Primary Intermediate Server CA,OU=Secure Digital Certificate Signing,O=StartCom Ltd.,C=IL\n\nGET /bluesuncorp/validator.v5?go-get=1 HTTP/1.1\nUser-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.19.1 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2\nHost: gopkg.in\nAccept: /\n< HTTP/1.1 200 OK\n< Content-Type: text/html\n< Date: Wed, 16 Dec 2015 16:08:44 GMT\n< Content-Length: 402\n< \n\n\n\n\n\n\n\ngo get gopkg.in/bluesuncorp/validator.v5\n\n\n Connection #0 to host gopkg.in left intact\n Closing connection #0\n[odin@namenode0 ~]$ go get -u -v gopkg.in/bluesuncorp/validator.v5\nFetching https://gopkg.in/bluesuncorp/validator.v5?go-get=1\nParsing meta tags from https://gopkg.in/bluesuncorp/validator.v5?go-get=1 (status code 200)\nget \"gopkg.in/bluesuncorp/validator.v5\": found meta tag main.metaImport{Prefix:\"gopkg.in/bluesuncorp/validator.v5\", VCS:\"git\", RepoRoot:\"https://gopkg.in/bluesuncorp/validator.v5\"} at https://gopkg.in/bluesuncorp/validator.v5?go-get=1\ngopkg.in/bluesuncorp/validator.v5 (download)\n```\n- Just got hanged too.\n[odin@namenode0 ~]$ go get -u -v gopkg.in/go-playground/validator.v5\nFetching https://gopkg.in/go-playground/validator.v5?go-get=1\nParsing meta tags from https://gopkg.in/go-playground/validator.v5?go-get=1 (status code 200)\nget \"gopkg.in/go-playground/validator.v5\": found meta tag main.metaImport{Prefix:\"gopkg.in/go-playground/validator.v5\", VCS:\"git\", RepoRoot:\"https://gopkg.in/go-playground/validator.v5\"} at https://gopkg.in/go-playground/validator.v5?go-get=1\ngopkg.in/go-playground/validator.v5 (download)\n- A standard kernel with CentOS 6.7\n[odin@namenode0 ~]$ cat /etc/centos-release \nCentOS release 6.7 (Final)\n[odin@namenode0 ~]$ uname -a\nLinux namenode0 2.6.32-573.8.1.el6.x86_64 #1 SMP Tue Nov 10 18:01:38 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\n- some versions \n[odin@namenode0 ~]$ go version\ngo version go1.5.2 linux/amd64\n[odin@namenode0 ~]$ git --version\ngit version 1.7.1\n- I can get validator under my windows, either. And if I copy $GOPATH/src/gopkg.in/bluesuncorp/validator.v5 directly from my mac/win to centos, I can run go get then.\n[odin@namenode0 ~]$ go get -u -v gopkg.in/bluesuncorp/validator.v5\nFetching https://gopkg.in/bluesuncorp/validator.v5?go-get=1\nParsing meta tags from https://gopkg.in/bluesuncorp/validator.v5?go-get=1 (status code 200)\nget \"gopkg.in/bluesuncorp/validator.v5\": found meta tag main.metaImport{Prefix:\"gopkg.in/bluesuncorp/validator.v5\", VCS:\"git\", RepoRoot:\"https://gopkg.in/bluesuncorp/validator.v5\"} at https://gopkg.in/bluesuncorp/validator.v5?go-get=1\ngopkg.in/bluesuncorp/validator.v5 (download)\ngopkg.in/bluesuncorp/validator.v5\n[odin@namenode0 ~]$\n. @joeybloggs thanks! It works! I updated my git from 1.7.1 to 2.6.4, and it just works.\nCentOS 6 is really out of fashion, with gcc-4.4.7, kernel-2.6.x and so on.\n. ",
    "laeshiny": "In my case, it doesn't work though I have upgraded git (2.10.0) and go(1.7.1).\nOS is CentOS 6.3\nIt is still hanged like below.\nFetching https://gopkg.in/go-playground/validator.v8?go-get=1\nParsing meta tags from https://gopkg.in/go-playground/validator.v8?go-get=1 (status code 200)\nget \"gopkg.in/go-playground/validator.v8\": found meta tag main.metaImport{Prefix:\"gopkg.in/go-playground/validator.v8\", VCS:\"git\", RepoRoot:\"https://gopkg.in/go-playground/validator.v8\"} at https://gopkg.in/go-playground/validator.v8?go-get=1\ngopkg.in/go-playground/validator.v8 (download)\n. Answer is like below\n1. Can you confirm that the git version in your current terminal session is using git 2.10.0 using git --version maybe it's using another found earlier within the $PATH\n2. Confirm go version using command go version\n   $ go version\n   go version go1.7.1 linux/amd64\n   $ git version\n   git version 2.10.0\n3. If both 1 and 2 are ok can you do a regular git clone of the repo?\n   $ git clone https://github.com/go-playground/validator\n   Cloning into 'validator'...\n   remote: Counting objects: 1752, done.\n   remote: Compressing objects: 100% (19/19), done.\n   remote: Total 1752 (delta 7), reused 0 (delta 0), pack-reused 1733\n   Receiving objects: 100% (1752/1752), 756.42 KiB | 262.00 KiB/s, done.\n   Resolving deltas: 100% (1073/1073), done.\n4. Are you able to try with any other is besides CentOS? Issues like these seem to always happen with it.\n   It works with CentOS 7\n5. Perhaps try running command as root, I think that go get suppresses some of the git clone errors, but unlikely.\n   It doesn't work though I ran command as root\n. In CentOS 7, git cloning the gopkg.in doesn't works also in CentOS7.\nAs you mentioned, It may be an issue of GitHub or gopkg.in.\nThanks for your kind reply. :)\n. ",
    "donileo": "Thanks @joeybloggs. That clarifies some things yes. Whats the difference between the \"exists\" and \"required\" tag? Seems required implies exists....\n. ",
    "byrnedo": "Hi, I'll have a look soon, bit busy at the minute, thanks for doing this!\nOn 6 January 2016 at 15:51, Dean Karn notifications@github.com wrote:\n\n@byrnedo https://github.com/byrnedo I have completed the changes please\ncheck it out and let me know if it works for you.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/go-playground/validator/issues/227#issuecomment-169343636\n.\n. Will take a look today, sorry for the delay\n\nOn 18 January 2016 at 14:29, Dean Karn notifications@github.com wrote:\n\nany word @byrnedo https://github.com/byrnedo ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/go-playground/validator/issues/227#issuecomment-172527348\n.\n. Looks good Dean, that works for me!\n\nOn 18 January 2016 at 14:33, Donal Byrne byrnedo@tcd.ie wrote:\n\nWill take a look today, sorry for the delay\nOn 18 January 2016 at 14:29, Dean Karn notifications@github.com wrote:\n\nany word @byrnedo https://github.com/byrnedo ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/go-playground/validator/issues/227#issuecomment-172527348\n.\n. Hi @joeybloggs!\n\n\nThe \\p{L} thing seems to work, I added it to a simple wrapper I have for your library here: https://github.com/byrnedo/svccommon/blob/master/validate/validate.go\nThe (extremely) simple tests seem to pass (https://github.com/byrnedo/svccommon/blob/master/validate/validate_test.go)\nI agree with the name one, it's more up to each user to decide about.\nI could add it at some point with a fork if you're busy, no problem, good to discuss it here first :)\nEdit:\nI'd think that updating alphanum might surprise a lot of people, I would nearly always expect that to be a-zA-Z0-9\n. My use case is to have send a json response like this for validation errors:\n{\n    \"address.line_1\": [ \"required\" ],\n    \"address.city\": [ \"required\" ]\n}\nAnd namespace works fine until I've an anonymous struct in the path somewhere.\nMy hack right now is to snake case all json fields (and have a json field namer) and then remove any camel cased sections from the namespace. Works but sure will bit me in the ass at some point :p\nDo you think it'd be useful to implement some kind of JsonPath() function to do this? \nEdit: Just thinking about this I could probably just write my own helper that uses reflection to do this.... @joeybloggs If you think this isn't something that validator should care about then lets close this?\n. ",
    "whidbey": "verygood ,and fast resposne,thank youl\n. ",
    "goreorto": "I got an arbitrary amount of structs requiring validation using the very same services. I thought it might be possible using reflection.\nI'd like to do something like this\n``\ntype T1 struct {\n    Namevalidate:\"uniqueness\"}\ntype T2 struct {\n    Tagvalidate:\"uniqueness\"`\n}\nfunc UniquenessValidator(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param, fieldName string) bool {\n    topStructElem := topStruct.Elem()\n    return IsUnique(fieldName, field, topStructElem)\n}\n```\nI got a pull request ready if that makes sense.\nThanks\n. I'm trying to use this along with gorm as a way to prevent hitting the database for validation. In this case, I can't prevent such thing but I would like to keep validation in the same place. I don't want to let the DB handle validation, I need more control as I may need to store data somewhere else in the future(think a micro-service architecture)\nMake sense?\n. I think that would work for now.\nPlease consider adding field name as a parameter for the custom validator for future versions as it would help to do more complex and reusable functions\nThanks\n. ",
    "0fuzz": "Hey joey, yes sorry we use it in some other way and I hit pull request per accident ;) But this is quite custom and I did close it. Sorry! ;) Funny thing is that commits to master afterwards automatically go to this PR :S\n. ",
    "parveenkumar2308": "Thanks Dean Karn.\nI have gone through links in your reply. What i have gotten from that is i\nneed to write a new function like RegisterValidation which makes an entry\nin validater map. so, in my case it would be\nRequiredWithEmptyCheckValidation and UEmailValidation like you mentioned\nthat doing it this way i can have both flavours.But, i still didn't get\nthat where i need to make change in my codebase, where i would define a\nutil file and i would write the two new validation method or in the API\nfile itself. also, can you share example, how to define a new one with\nexact steps.\nI am using validator in my project in below way.i define a struct and give\nvalidation tag against fields and have defined a validation file where i do\nvalidation.\ntype Person struct{\nId string json:\"id\" validate:\"required,min=36,max=36\"\nName string json:\"name\"\n}\nin validation.go file\nif errs := validate.Struct(obj); errs != nil {\n        if err := errs.(validator.ValidationErrors)[\"Person.Id\"]; err !=\nnil {\n            if (err.Tag == constant.REQUIRED) {\n                errMsg = \"msg0\"\n            }else{\n-  if (!IsValidStr(obj.Id)) {//here i am checking white spaces in field if\n  present returning false else true                    errMsg = \"msg1\"\n      }*else {\n                       if(err.Tag == constant.MIN){\n                             errMsg =  \"msg2\"\n                       }else if (err.Tag == constant.MAX) {\n                            errMsg = \"msg3\"\n                      }\n}\n    }\nreturn errMsg\nHow to implement the new validation method which will cater my if\n(!IsValidStr(obj.Id)) {} function itself. Also, I have not used excludes\ntags \"excludes\", \"excludesall\" or \"excludesrune\". can you suggest where i\nfit this tags or new validation method in my solution without changing much.\nRegards,\nParveen Kumar\nOn Fri, May 20, 2016 at 5:35 PM, Dean Karn notifications@github.com wrote:\n\nThanks @parveenkumar2308 https://github.com/parveenkumar2308\nYes you can override required and email, in fact can override any that is\nnot part of this\nhttps://github.com/go-playground/validator/blob/v8/util.go#L22 map by\nRegistering a new validation see here\nhttps://github.com/go-playground/validator/blob/v8/validator.go#L270\nIt's totally up to you, but since you need to register a new validation to\noverride the old one anyway I would register the new email validation, but\nnot override, but instead use a new name like \"uemail\"(for underscore\nemail) that way you don't lose the functionality of the regular email too.\nand as for the white space in the required tag you could combine required\nwith any of the excludes tags \"excludes\", \"excludesall\" or \"excludesrune\",\njust so when someone reads your code(assuming someone else will) they can\nclearly see what's being validated.\nYou have many options \ud83d\ude04 the docs\nhttps://godoc.org/gopkg.in/go-playground/validator.v8 are pretty\nthourough if you need some code examples, I'd normally include some buy am\nout of town with no computer.\nHope this explains what you want, if not after I get back in town can\nprovide some examples.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/go-playground/validator/issues/240#issuecomment-220588340\n\n\nWarm Regards,\nParveen Kumar\n+91-9890333270\n. @joeybloggs i will try the three methods. though i have 1 query with option 2 and 3. \nIf in the Name field of Person struct, i want to validate for \"srequired\" tag then , does it allow Parveen Kumar value. because i just want to validate for empty string(if strToCheck == \"\" || len(strToCheck) == 0 || len(strings.TrimSpace(strToCheck)) == 0 {\n        return false\n    }).\nnot for each white space.\n. Hi Dean,\nThanks a lot. It worked like a charm.\nRegards,\nParveen Kumar\nOn Tue, May 24, 2016 at 9:21 AM, Dean Karn notifications@github.com wrote:\n\nOh I misunderstood, options 2 & 3 are for any whitespace you are correct.\nthen option1 would be your best bet with your code changes :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/go-playground/validator/issues/240#issuecomment-221159765\n\n\nWarm Regards,\nParveen Kumar\n+91-9890333270\n. @joeybloggs https://github.com/joeybloggs\nThanks for regex string. yes it is not working in Golang. i have updated it\naccording to my need.\nThe way you suggested is normal Golang way to validate password and then\nadd the func to validator list. i was thinking to check for regexp\nsolution.\nCan't it work with either one (updated regexp pattern):\n1) type Person struct{\n            Id string json:\"id\" validate:\"required,min=36,max=36\"\n            Password string json:\"id\"\nvalidate:\"upwd,regexp=^[a-zA-Z0-9_!@#$_%^&*.?()-=+]*$\"\n}\nor ,\n2) validate.RegisterAliasValidation(\"upwd\",\n\"min=8,max=20,regexp=^[a-zA-Z0-9_`!@#$%^&.?()-=+]_$\")\nFYI, your suggested solution worked.\nThanks!\nOn Fri, Aug 5, 2016 at 5:20 PM, Dean Karn notifications@github.com wrote:\n\nHey @parveenkumar2308 https://github.com/parveenkumar2308\nI can't see where the regex validation is being registered, it may be\nthat it's the undefined validation ( I will add a better error message with\nthe tag in question within the error message ).\nThere also seems to be an issue with your regex, Go does not support\nnegative lookahead's:\npanic: regexp: Compile(\"^(?=.[a-zA-Z0-9!@#$%^&.?/\\\\]).*$\"): error parsing regexp: invalid or unsupported Perl syntax:(?=`\nIt also looks like you're running an older version of validator, I've made\na few improvements to v8 ( all non-breaking changes ) that you should\nupdate; I don't think this is the problem but would help with the stack\ntrace.\nRegardless of all that, I highly recommend you do not pass regex's as a\nvalidation param,\nhere is an excerpt from the documentation\nregex\n    a regex validator won't be added because commas and = signs can be part\n    of a regex which conflict with the validation definitions. Although\n    workarounds can be made, they take away from using pure regex's.\n    Furthermore it's quick and dirty but the regex's become harder to\n    maintain and are not reusable, so it's as much a programming philosiphy\n    as anything.\nIn place of this new validator functions should be created; a regex can\nbe used within the validator function and even be precompiled for better\nefficiency within regexes.go.\nhere is the way I recommend once you correct your regex ( as a side note I\ninitially tried to use a regex for password validation, but because Go\ndoesn't support negative lookahead's so I just did the checks without the\nregex within a custom validation )\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"regexp\"\n\"gopkg.in/go-playground/validator.v8\"\n)\n// Person ...type Person struct {\n    ID       string json:\"id\" validate:\"required,min=36,max=36\"\n    Password string json:\"id\" validate:\"upwd\"\n}\nvar (\n    validate       = validator.New(&validator.Config{TagName: \"validate\"})\n    passwordString = \"^[a-zA-Z0-9]$\" // regex that compiles\n    passwordRegex  = regexp.MustCompile(passwordString)\n)\nfunc main() {\n```\nvalidate.RegisterValidation(\"validpasswd\", func(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {\n    return passwordRegex.MatchString(field.String())\n})\nvalidate.RegisterAliasValidation(\"upwd\", \"min=8,max=20,validpasswd\")\nvar errMsg string\nperson := Person{\n    ID:       \"36\",\n    Password: \"!!!!!!!!!!!!!!\",\n}\nif errs := validate.Struct(person); errs != nil {\nif err := errs.(validator.ValidationErrors)[\"Person.Password\"]; err != nil {\n    if err.Tag == \"upwd\" {\n        errMsg = \"invalid password!\"\n    }\n}\n\n}\nfmt.Println(errMsg)\n```\n}\nPlease let me know if this helps \ud83d\ude04\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/go-playground/validator/issues/251#issuecomment-237831312,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ANc3tygngf2fjYvZ3zyuEzhqfiunPE2_ks5qcyOcgaJpZM4JdU97\n.\n\n\nWarm Regards,\nParveen Kumar\n+91-9890333270\n. @https://github.com/joeybloggs\nThanks for the responses and clarifications. I do agree with you on the\nsame.\nOn Sun, Aug 7, 2016 at 7:28 AM, Dean Karn notifications@github.com wrote:\n\nHey @parveenkumar2308 https://github.com/parveenkumar2308 , sorry for\nthe lateness of my reply, busy day,\nyes it could work for either one, but there are several reasons I would\nnot.\n1.\nyou'd have to change all , within the regexes to 0x2C and all | to 0x7C\n   a mentioned in the documentation here\n   https://godoc.org/gopkg.in/go-playground/validator.v8 which makes\n   reading your regex harder.\n   2.\nputting regexes in tags quickly makes reading the tags harder and when\n   combining with DB tags and JSON tags, can get dirty quick.\n   3.\nregexes in the tags aren't reusable, if you wanted to reuse one you'd\n   have to copy and paste. If a regex ever needed to be updated, would have to\n   potentially update multiple locations and not forget one.... whereas\n   registering a validation you can fix all locations in one stroke.\n   4.\nif passing regexes in from the struct tags then you have to compile\n   the regex every time a regex validation is used before even using it, which\n   is allow of wasted CPU time. if added as a validation can precompile the\n   regex and reuse that compiled version.\nHope this clears some of the details up :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/go-playground/validator/issues/251#issuecomment-238058676,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ANc3t8GUuCtUjRo7DISO2w0TiwGewa5Xks5qdTvEgaJpZM4JdU97\n.\n\n\nWarm Regards,\nParveen Kumar\n+91-9890333270\n. ",
    "himanishk": "Hi @joeybloggs ,\nThanks for your prompt reply.I think that is in-line with the behaviour I had seen. Here is my code sample\n``` go\n// I needed custom unmarshalling for the Start_Date and End_Date fields\ntype UDateTime struct{\n    time.Time\n}\ntype TestForm struct {\n    Name string schema:\"name\" validate:\"required,alphanum\"\n    Start_Date models.UDateTime schema:\"start_date\" validate:\"required\"\n    End_Date models.UDateTime schema:\"end_date\"\n    Size uint schema:\"holdout\" validate:\"omitempty,numeric,max=99,min=1\"\n    Range string schema:\"target_range\"\n}\n//The Struct level validation function\nfunc TestFormStructLevelValidation(v validator.Validate, structLevel validator.StructLevel) {\n    ptf := structLevel.CurrentStruct.Interface().(TestForm)\n  if ptf.Start_Date.Before(time.Now().UTC()) { // FAILS here with nil pointer as Start_Date is nil\n        structLevel.ReportError(reflect.ValueOf(ptf.Start_Date), \"UDateTime\", \"UDateTime\", \"afterdatetime\")\n  }\n}\n// In the Http handler, I parse the form , decode it and then pass the struct to the validator\nform := TestForm{}\nrequest.ParseForm()\ndecoder.Decode(form, request.Form)\nvalidate.RegisterStructValidation(TestFormStructLevelValidation, TestForm{})\nvalidate.Struct(form)\n```\nMy expectation was when The Start_Date field is not provided, the validate:\"required\" will kick in before  invoking the TestFormStructLevelValidation and stop any further validation. Currently it invokes TestFormStructLevelValidation and results in a nil pointer exception.\nSo, the best option is removing the  validate:\"required\" from the Start_Date field and taking the logic into the TestFormStructLevelValidation function, right ?\nI wanted to avoid putting everything in the Struct level validation as it will become bloated , specially with the next two fields Size and Range for which I also need to check whether either one of them exists (similar to your firstName and lastName example in README) on top of few other baked-in validations ( like min, max etc). Appreciate your advice on the best approach to handle this scenario. \nThanks\n. Hi @joeybloggs \nThat works perfectly. Thank you so much.\n. ",
    "phenrigomes": "I have a gender field with values: \"M\" | \"F\" | \"O\". I need an way to validate choice values as: validate(FieldValue, ) - Choices allowed are: \"M\" | \"F\" | \"O\", but they could be \"MA\" | \"FE\" | \"OT\"...\n. ",
    "kenkouot": "Done!\n. ",
    "kujenga": "Gotcha, I was worried it might be looking at the actual value of the pointer or something of that nature, your explanation is much more sane. Thanks!\nSo is it true that if a pointer is non-nil then it is treated in the same way as a literal value of that type?\n. Perfect, that clears it up for me. Thanks so much!\n. ",
    "robbrockbank": "@joeybloggs   So I hadn't considered adding methods to the structs themselves rather that it would be akin to user-defined field validation where you register a validator and specify that as the validator for that field - exactly as other fields, but allowing the field to actually be a sub-structure such as field1 or field2in my example above.\nThe exact use-case I have for this is I some fields across different structures that may contain a string or an int - so i've defined a Int32OrString structure.   In each case I want to validate the integer or string values that have been specified (e.g. in one case the field is used to represent protocol - so it take a string of \"udp\" or \"tcp\" etc., or can take a numerical value 0-255.  I'd like to be able to define the field as:\ntype Foo struct {\n  ...\n  field1 Int32OrString \"validate:protocol\"\n  ...\nAnd have a validation function registered with name \"protocol\" invoked for the value of field1, rather than diving into the structure and validating the separate fields.\nI realize I could create separate structures for Protocol adding the Int32OrString as an anonymous field and then adding structure level validation for those types - but really I'd like to conceptually think of the sub-structure as a single field ... certainly the JSON from which it is parsed is a single field.\n. Thanks @joeybloggs.\nFor my use case I'm validating the sub-structure as if it were a single field so the details of which sub-field is at fault is not important.  I think that means it can be handled in the same way as a field validator in that it just returns true or false.\n. Hi @joeybloggs \nFunny - in the interest of opensourcedness, I was looking at this myself yesterday - and had an approximation working where I'd updated traverseField to just drop through after doing the traverseStruct  so it would effectively call the per-field registered validator on the nested struct field.\nI got a little unstuck though after running the UTs and realizing it was a little more complicated than I'd hoped :-)  For example, I think I had a field that was a struct pointer that had an required flag that had the HasValue() called on the structure rather than on the pointer....  I shelved it at that point to re-investigate when I had a little more time.\nFrom my perspective, I'd imagine a field that has a validator declared in the tag, that validator should be called against the field value - whether it is a structure or a map or a string etc.  From my limited understanding though - it doesn't feel like it's possible without special casing some of the existing builtins -- but I'm not too sure about that.\nI was wondering if a pragmatic solution would be to introduce another keyword like \"dive\" but this time to say - validate this structure as a field?  As with dive - you can add another validator entry to say and this is the validator to use.  The advantage of this is that it is a user buy-in and there shouldn't be any risk of existing structures that happen to \"accidentally\" specify a validator on a structure field failing validation suddenly (unless the keyword that is chosen conflicts with their validator name)\n. Hi @joeybloggs!  Wow, that was a fast turnaround, thank you!  Yes I've confirmed with my example above that solves that problem.  Please feel free to close :-)\n[probably not the right place to ask, but ... ] What's the timeline for updates to get into gopkg.in ?  I can pull from github, but all my imports in my code are pointing to gopkg.in ... of course perhaps the two are interchangeable in some golang magic that I'm not aware of (I'm a bit of a go novice I'm afraid).\n. ",
    "wenchma": "@joeybloggs any comment is appreciated.\n. @joeybloggs Awesome, :+1:  your options are very helpful for me, I think them will work, let me try.\nMuch thanks!\n. ",
    "gebv": "An excellent idea a create custom validation. It is an elegant solution. Thanks @joeybloggs \n. Looped here\nhttps://github.com/go-playground/validator/blob/v9/util.go#L47\nI'm not using the Var function correctly for custom type validation? Please advice @joeybloggs . I need to validate the lat lng coordinates\nCreated a custom data type\ngo\ntype NullPoint struct {\n    X     float64 `json:\"lng\"`\n    Y     float64 `json:\"lat\"`\n    Valid bool    `json:\"valid\"` // Valid is true if not NULL\n}\nAdded a custom validator, for example always returns false\ngo\nfunc ValidationInMoscow(fl validator.FieldLevel) bool {\n    // TODO: implement\n    log.Printf(\"DEBUG: check call validator, got data type %T\\n\", fl.Field().Interface())\n    return false\n}\nI want that here I got an error\ngo\nv := validator.New()\nv.RegisterValidation(\"inmsk\", ValidationInMoscow)\nv.Var(NullPoint{}, \"inmsk\")\nI look at the log, validator was not called. How do I validate a custom type?. So, i want got for the my custom object for custom validation.\n```go\nfunc ValidationInMoscow(fl validator.FieldLevel) bool {\n        // log.Printf(\"DEBUG: check call validator, got data type %T\\n\", fl.Field().Interface())\n    point := fl.Field().Interface().(NullPoint)\n\n    if point == nil { return false } // how to customize the validator 'required'?\n\nreturn inMSK(point) // check intersection in poligon\n\n}\n```\n@joeybloggs please any ideas . Yes, please attache your examples\nMeanwhile I'll see how StructLevel works. Thanks @joeybloggs for detailed response\nRight for me Custom Type. But I was in disarray PointValuer must return a simple type otherwise looped.. ",
    "MarcoVigna17": "First of all, thanks for the immediate response!\nI was starting to develop the first proposed solution, but after your answer, I agree that the second one is probably the best solution. I don't need this kind of validation on other struct, just on the one that I'm developing right now, so probably it's easier and safer!\nI'm using v8 cause was just on my package, I just noticed that you released the v9 and I shouldn't have compatibility problems, so I can update easily!\n. I did and it's working, thanks for your help!\nJust one question, cause I had to implement a workaround on a sub struct inside my main one, on which I created  the custom validator.\nLet me show you some code that it's easier...\nThose are my structs:\n``\ntype OuterStruct struct {\n    Values      []InnerStructjson:\"values\"ExtraValue   stringjson:\"additional_value\"`\n}\ntype InnerStruct struct {\n    ID string json:\"id\" validate:\"required\"\n}\n```\nand this is was my custom validator:\n```\nfunc StructArgsValidation(v validator.Validate, structLevel validator.StructLevel) {\n    fieldArgs := structLevel.CurrentStruct.Interface().(OuterStruct)\nif len(fieldArgs.Values) == 0 && fieldArgs.ExtraValue == \"\" {\n    structLevel.ReportError(reflect.ValueOf(fieldArgs.Values), \"Values\", \"values\", \"valuesOrExtraValue\")\n    structLevel.ReportError(reflect.ValueOf(fieldArgs.ExtraValue), \"ExtraValue\", \"additional_value\", \"valuesOrExtraValue\")\n}\n\n```\nThe expected behaviour to me was that the inner struct was validated on the calling of errs := validator.Struct(outerStruct), but it wasn't, cause this object was passing the validation:\nOuterStruct{\n                Values: []InnerStruct{\n                    {},\n                },\n            }\nI read about the \"dive\" tag, is that the case where I have to use it?\n. Perfect, I used the dive tag and now I can rid of that check from StructValidation custom function. \nI noticed a problem then (I will open a proper new issue when I have a little bit of free time, but I want to post it now so we can start discuss)\nWith this validation on different fields, the order of the errors returned when I call my validation.Struct(structToValidate) function is never the same.\nI noticed cause running my unit test in the same conditions, sometimes fails and sometimes not. In particular, I have my test to check this:\n{\n            arg: OuterStruct{\n                ExtraValue: \"\",\n            },\n            expectedError: \"Key: 'AudienceFieldArgs.Values' Error:Field validation for 'Values' failed on the 'valuesOrExtraValue' tag\\n\" +\n                \"Key: 'AudienceFieldArgs.ExtraValue' Error:Field validation for 'ExtraValue' failed on the 'valuesOrExtraValue' tag\",\n        }\nand the returned error says that has this object like response:\nKey: 'AudienceFieldArgs.ExtraValue' Error:Field validation for 'ExtraValue' failed on the 'valuesOrExtraValue' tag\n            Key: 'AudienceFieldArgs.Values' Error:Field validation for 'Values' failed on the 'valuesOrExtraValue' tag\nas you can see, I have that both the validation are failing (and this is correct) but in the wrong order, so my test doesn't work\nI promise I will create a gist later on today!\n. Ok I will try to update to v9 and I will say you if it fixes the problem all the time, cheers ;)\n. I converted to use v9, I thought was painless, but apparently you improved the code everywhere \ud83d\ude04 \nI figure out how to make my code working (and now every test is passing, which is great!), and I like how the code to register a custom struct validator become easier. I just have a doubt on the  new ReportError structure:\nstructLevel.ReportError(field, fieldName, altName, tag, param)\nWhat this param represents? How stable is this version? Can I use it in production without any problem?\n. Awesome, cheers for all of your support! \ud83d\ude09 \n. ",
    "adrian-sgn": "Hey @joeybloggs thanks for the lightning fast response! :zap: \nI appreciate your suggestion with ValidLangCode to support looping through the map keys\nMy only issue with it is that the error message back probably won't say which key(s) are failing validation\n. @joeybloggs I rewrote the eample using StructLevel validation -- seems to work! thanks!\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"gopkg.in/go-playground/validator.v9\"\n)\ntype LangCode string\ntype Label map[LangCode]string\ntype TestStruct struct {\n    Label Label validate:\"dive,required\"\n}\nvar validate *validator.Validate\nvar validLangCodes = map[LangCode]bool{\n    \"en\": true,\n    \"es\": true,\n    \"pt\": true,\n}\nfunc main() {\nvalidate = validator.New()\n\nvalidate.RegisterValidation(\"lang_code\", ValidLangCode)\nvalidate.RegisterStructValidation(TestStructLevelValidation, TestStruct{})\n\nlabel := Label{\n    \"en\": \"Good morning!\",\n    \"pt\": \"\",\n    \"es\": \"\u00a1Buenos d\u00edas!\",\n    \"xx\": \"Bad key\",\n}\n\nerr := validate.Struct(TestStruct{label})\nif err != nil {\n    for _, err := range err.(validator.ValidationErrors) {\n        if err.Field()[0:5]==\"Label\" {\n            if err.StructField()==\"mapkey\" {\n                fmt.Println(err.Field(), \"has invalid\", err.Tag(), \"\\\"\" + err.Param() + \"\\\"\")\n            } else if err.Tag()==\"required\" {\n                fmt.Println(err.Field(), \"is required\")\n            }\n        }\n    }\n}\n\n}\nfunc ValidLangCode(fl validator.FieldLevel) bool {\n    return validLangCodes[LangCode(fl.Field().String())]\n}\nfunc TestStructLevelValidation(sl validator.StructLevel) {\n    st := sl.Current().Interface().(TestStruct)\nfor k, _ := range st.Label {\n    if !validLangCodes[k] {\n        sl.ReportError(st.Label, \"Label\", \"mapkey\", \"lang_code\", string(k))\n    }\n}\n\n}\n```\n$.02 - perhaps a tag like dive but rather keys (or mapkeys) could be introduced later on, eg. keys,lang_code,dive,required\n. hi @joeybloggs - amazing work, I can't believe you turned that around so fast!\nAfter studying a little more the code, I understand why you introduced endkeys. The examples you presented are pretty clear, and definitely show how to dive into map keys now. Nice work!\nDrifting a little outside the original Issue, what seems to be missing now for map validation is the ability to validate key, value pairs together, and report errors to know which key/value had what error(s). \nI wonder about the possibility of a MapLevelValidation which could be similar to StructLevel in that you could add Errors for map keys, and also have the opportunity to validate the key and value together if needed.  If we had MapLevelValidation, how important would keys...endkeys be?\nFor example...\n``` go\n// validator.registerMapValidation(tag string, fn MapLevelFunc)\nvalidator.registerMapValidation(\"map_tag\", MyMapFunc)\n// ex. for a map of\nmap[string]string\n// tags could be\nvalidate:\"gt=0,map_tag,dive,required\n```\nnot sure what would happen if you used map_tag on a non-map type, though...\nThanks for being so attentive to this issue! \ud83d\udc4d\n. ",
    "23doors": "Any progress on this?. @joeybloggs thanks, I'll just go with StructLevel validation for now. Looks like a pretty clean solution.. One downside to using custom structlevel or fieldlevel validation, it seems that you cannot use govalidator checks anymore. E.g. I would like to validate map[string]string that:\neach key and value is printable ascii, key min/max length etc. Seems that I need to implement these checks by hand. Maybe consider exposing check functions like govalidator does?. @joeybloggs thanks! missed validate.Var(...) somehow. ",
    "jawher": "@joeybloggs Thanks for the detailed and prompt reply !\nI agree that wildcards will come with their fair share of unpredictability and possible surprises.\nRegarding the future on-steroids fieldLevel validators, I must be missing something but I'm not sure I see how they  can help with the issue at hand, i.e. partial validation filtering.\nI thought about this issue some more and I think I have a possible alternative: Expose a new top-level validation function, say validate.StructFiltered for example accepting a struct as its first argument and a function which returns true/false for whether to validate a given field or not, e.g.:\ngo\nvalidate.ValidateFiltered(user, func(fieldPath string) bool {\n    return !strings.Contains(fieldPath, \".Sex\")\n})\nThe accepted parameters are to be defined: the field path is the strict minimum, but could be extended to also accept other params (currentValue, ...)\nSuch a solution would require minimum modification to the library: reuse the same partial/except validation code, just check for the presence of a filtering function and use if that's the case, else fallback to the includeExclude map.\nSomebody else (me for example) can then provide a implementation of such a function in a separate package and use it to handle their use case:\n``` go\nimport \"github.com/jawher/validator/filter\"\nvalidate.ValidateFiltered(user, filter.Include(\"Child.*\"))\nvalidate.ValidateFiltered(user, filter.Exclude(\"Child.Hobbies[].*\"))\n```\n. @joeybloggs Nice ! You beat me to it, I was planning to create a PR for this \ud83d\udc4d \nI'll ping back once I get a working implementation for the wildcard filtering.\n. Wow, it's been 25 days already !\nI started working on it a while ago, but I'm afraid I overdone it a bit and ended up with something a touch too complex :D\nI'll try to get back to it the next weeks.\n. ",
    "YamiOdymel": "Sorry that I'm writing the front-end and the API documentation recently, I'll post the code once I back to develop the backend.\n. ",
    "mehdy": "it would be great to add validation for weekdays. hey @joeybloggs \nofc, I'm dealing with some sort of events which has some fields that determines the weekdays.\nI'm using this alias now. but I think it would be much better to be implemented with switch/case\ngo\nvalidate.RegisterAlias(\"isweekday\", \"eq=SAT|eq=SUN|eq=MON|eq=TUE|eq=WED|eq=THU|eq=FRI\"). ",
    "dkostenko": "I got it\nvalidationErrors := err.(validator.ValidationErrors)\nvalidationErr := validationErrors[0]\nfieldName := validationErr.Field()\nfield, ok := reflect.TypeOf(args).Elem().FieldByName(fieldName)\nfieldJSONName, _ := field.Tag.Lookup(\"json\")\nSorry for disturbing\n. ",
    "wanghq": "@joeybloggs , thanks for the quick response!\n1. Yes, that util.Int32 returns the a pointer to the pass in integer. Sorry for not including that.\n2. Yes, I was using an old version (https://github.com/go-playground/validator/tree/c193cecd124b5cc722d7ee5538e945bdb3348435)\n3. Yes, upgrading to https://github.com/go-playground/validator/releases/tag/v8.18.1 fixed the problem.\n. ",
    "jonmchan": "@joeybloggs - you work fast! Yes, I updated my gin validator to v9. I'll test release 9.2.2 tomorrow and close this bug if I can confirm that the order of errors remain static. Thanks!\n. The test assertions pass everytime! That did the trick! Thanks!\n. ",
    "justinclift": "Hmmm, there doesn't seem to be a validation for \"is this a valid Unicode character string?\" either, or am I not seeing something obvious?\n. Oohh thanks @joeybloggs, that definitely looks useful.  I'll give that a shot, most likely tomorrow (brain dead atm).. It turns out I was getting ahead of myself, so it'll probably be at least a few days until I can try this out properly. \ud83d\udc7c . Sorry for the delay.  Got distracted by other things.\nNo idea when I'll get around to testing this part of things myself. \ud83d\ude26 . ",
    "mrLSD": "Thank you for the response.\nExample:\n``\ntype Page struct {\n    Title              stringvalidate:\"required\"Published     stringvalidate:\"default=false\"`\n}\nfunc validateStruct() {\n    page := &Page{\n        Title: \"My page title\",\n    }\nerr := validate.Struct(page)\n// We have filled omitted field\n// page.publishe = false\nif err != nil {\n\n```\nor for variable:\npublished := \"\"\n    errs := validate.Var(published, \"default=false\")\n    // publishe = false. @joeybloggs Thank you for great answer and interesting idea. I'll try it.. ",
    "thessem": "I was using structonly to avoid recursing into the nested struct's fields.\nMy structs are a graph connected to each other by pointers where nodes can have properties (fields) and links to other nodes (represented by a pointer to another struct). I was hoping to avoid recursing through the structs because I already have a flat list of structs in an []interface{}.\nThis was a bit of a hack, but I figured if I appended every field with structonly while validating every struct in the array I would eventually fully validate my memory structure.\nThank you for the extremely fast response!. Being able to turn off recursive validation would be deeply appreciated since my structs are extremely circular and not necessarily connected, or at least a sketch of how to implement this so I can do it as a PR :). Sorry for leaving this open, it does work for me but I didn't like the idea of having to add nostructlevel all throughout my validation flags so I've been trying to find a way which I find more philosophically 'pure', I think might end up with me attempting to add some traversal logic configuration to the validator. \nThanks for the link, I'm closing this now since my use-case is quite different from the purpose of the validator and you've answered my question in a way which work for me! Thanks a lot for your help and your quick turn around on my previous issue :). ",
    "cbandy": "Resolved! Thank you.. ",
    "pipejesus": "Sorry, i found the answer in the closed issue here:\nhttps://github.com/go-playground/validator/issues/258\nThank you!. Hi Joey, huge thank you :-) I'll try to work something out with your insight !. So this isn't a very elegant way to do this for sure ; ) but i got what i needed by registering this StructLevel validation:\n```\nfunc FieldStructLevelValidation(sl validator.StructLevel) {\n    wholeStruct := sl.Current().Interface().(FieldModel)\n    sl.ReportError(wholeStruct.Name, \"Name\", \"name\", \"jsref\", wholeStruct.JSRef)\n}\ntype FieldModel struct {\n    ID           bson.ObjectId bson:\"_id,omitempty\" json:\"id\"\n    Type         FieldType     bson:\"type\" json:\"type\"\n    Name         string        bson:\"name\" json:\"name\" validate:\"required,ascii\"\n    Slug         string        bson:\"slug\" json:\"slug\"\n    Desc         string        bson:\"desc\" json:\"desc\"\n    DisplayOrder uint          bson:\"displayorder\" json:\"displayorder\"\n    Repeatable   bool          bson:\"repeatable\" json:\"repeatable\"\n    JSRef        string        json:\"jsref\"\n    Fields       []*FieldModel      bson:\"fields\" json:\"fields\" validate:\"dive\"\n}\n```\nThen, when i'm collecting the errors i check whether the \"error\" is  just actually a \"jsref\" type of error and add it to a map for later comparison, as now i have the value of the JSRef field spit out in the \"param\". From there i can  generate the final JSON error output . \nThanks a lot!!. ",
    "kwanso-junaidaziz": "yeah basically i am building a api which will receive file and process on image and i am new on golang so i am little confuse how to validate image presence and type i found this package really good to handle my params. @joeybloggs ok sure waiting for your response. ",
    "basilex": "@joeybloggs Yes, you're absolutely right regarding \"It looks like GitHub or Gopkg.in is having some problems\"...\nCurrently everything is ok! And I'm happy :)\nThanks!\n. ",
    "semir-karic": "That's it thanks a alot. I've just added if the name is \"-\" or \"-\" to display the field name from structure in case I don't have json tag set for any of the fields.. ",
    "theobouwman": "Thanks, I can not decode the URL.Values\nBut I throws an error:\n``\ntype ModuleRequest struct {\n    ModuleUUID uuid.UUIDvalidate:\"required\"`\n}\nvar request ModuleRequest\n\nfmt.Println(r.URL.Query())\n\ndecoder := form.NewDecoder()\nerr := decoder.Decode(&request, r.URL.Query())\nif err != nil {\n    fmt.Println(err)\n    http.Error(w, \"Could not decode Request Values\", http.StatusBadRequest)\n    return\n}\n\nfmt.Println(request)\n\nerr = config.Validator.Struct(&request)\nif err != nil {\n    errorString := \"Validation errors:\"\n    for _, err := range err.(validator.ValidationErrors) {\n        errorString += \" \" + err.Field() + \";\"\n    }\n    http.Error(w, \"Bad request data; \" + errorString, http.StatusBadRequest)\n    return\n}\n\nWhen I pas the `module-uuid` parameter the `ModuleUUID` field of the request object is still set to its zero-value. So I think something is going wrong during the decoding.. Thanks that worked.\nBut it throws this:\n2017/03/08 18:12:20 http: panic serving [::1]:56843: reflect: call of reflect.Value.IsNil on array Value\n``\n now.... @joeybloggs you are right, I have to registeruuid.UUIDas a type.\nThe documentation says that you need to register it on theDecoder`, however what is a good practice to do that, because you don't want to register it every single? (Golang is pretty new to me). @joeybloggs thanks. Could you mention me on that example?. @joeybloggs I have a Config package with a few variables that need to be accessed throughout the application. So whenever I need them I import that package.\nIs that inefficient?. ",
    "nicpottier": "Cool ya, mostly just flagging this as I imagine anybody else using glide is having trouble with it and the fix seems pretty easy. (though it is a weird convention)\nThanks for considering the change!. ",
    "james-maloney": "Good to know. \nThanks for answering my question, I appreciate the work you have put into your Go packages.. ",
    "s4l1h": "@joeybloggs \ncheck if record exists in database\nimportant problem\n```go\n// Group Models\ntype Group struct {\n    Name        string json:\"name\" validate:\"unique,required\"\n    Description string json:\"Description\" validate:\"required\"\n}\nvar valid = validator.New()\nvalid.RegisterValidation(\"unique\", ValidUnique)\nfunc ValidUnique(fl validator.FieldLevel) bool {\ncurrentField, _, _ := fl.GetStructFieldOK()\ntable := currentField.Type().Name() // table name\nvalue := fl.Field().String() // value\n    column := \"????\" // need this..\nsql := fmt.Sprintf(\"select count(*) from %s where %s='%s'\", table, column, value)\nif Count(sql) { // check database...\n    return false\n}\nreturn true\n\n}\n```\n. @joeybloggs thanks for reply and effort.I can help.\nPls check pr. . @joeybloggs pretty good .Maybe you can add another function direct return Struct Name. ",
    "bsed": "Concurrent read / write lock\n. I've changed it in step two, and the problem still happens. error :\n```\nfatal error: concurrent map writes\ngoroutine 18052 [running]:\nruntime.throw(0xc2ff86, 0x15)\n    D:/Go/src/runtime/panic.go:596 +0x9c fp=0xc043abe398 sp=0xc043abe378\nruntime.mapassign(0xb63640, 0xc042c38810, 0xc043abe4a8, 0xb96ce0)\n    D:/Go/src/runtime/hashmap.go:499 +0x66e fp=0xc043abe438 sp=0xc043abe398\nzhtj/vendor/gopkg.in/go-playground/validator%2ev9.(Validate).RegisterStructValidation(0xc042039380, 0xc4c820, 0xc043abe560, 0x1, 0x1)\n    E:/gocode/src/zhtj/vendor/gopkg.in/go-playground/validator.v9/validator_instance.go:188 +0x12a fp=0xc043abe4e0 sp=0xc043abe438\nzhtj/validator.GetNation(0xf66340, 0xc042110af0, 0x0, 0x0, 0x0)\n    E:/gocode/src/zhtj/validator/national.go:14 +0x158 fp=0xc043abe5d0 sp=0xc043abe4e0\nzhtj/handler.GetNationHandler(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/handler/national.go:51 +0x200 fp=0xc043abedc8 sp=0xc043abe5d0\nzhtj/vendor/github.com/labstack/echo.(Echo).add.func1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/echo.go:463 +0xee fp=0xc043abee38 sp=0xc043abedc8\nzhtj/vendor/github.com/labstack/echo/middleware.CORSWithConfig.func1.1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/middleware/cors.go:113 +0x4b5 fp=0xc043abf000 sp=0xc043abee38\nzhtj/vendor/github.com/labstack/echo/middleware.RecoverWithConfig.func1.1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/middleware/recover.go:82 +0x161 fp=0xc043abf080 sp=0xc043abf000\nzhtj/middleware/logger.Logger.func1.1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/middleware/logger/logger.go:139 +0xb21 fp=0xc043abf7f8 sp=0xc043abf080\nzhtj/vendor/github.com/labstack/echo/middleware.LoggerWithConfig.func2.1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/middleware/logger.go:111 +0x1af fp=0xc043abf930 sp=0xc043abf7f8\nzhtj/vendor/github.com/labstack/echo/middleware.StaticWithConfig.func1.1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/middleware/static.go:86 +0x55e fp=0xc043abfb60 sp=0xc043abf930\nzhtj/vendor/github.com/labstack/echo.(Echo).ServeHTTP.func1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/echo.go:551 +0x1b7 fp=0xc043abfc08 sp=0xc043abfb60\nzhtj/server.New.func1.1(0xf66340, 0xc042110af0, 0x0, 0x0)\n    E:/gocode/src/zhtj/server/server.go:35 +0xc7 fp=0xc043abfc68 sp=0xc043abfc08\nzhtj/vendor/github.com/labstack/echo.(Echo).ServeHTTP(0xc042036820, 0xf5bd80, 0xc0427cc620, 0xc044079900)\n    E:/gocode/src/zhtj/vendor/github.com/labstack/echo/echo.go:560 +0x236 fp=0xc043abfd10 sp=0xc043abfc68\nnet/http.serverHandler.ServeHTTP(0xc0423ce000, 0xf5bd80, 0xc0427cc620, 0xc044079900)\n    D:/Go/src/net/http/server.go:2568 +0x99 fp=0xc043abfd58 sp=0xc043abfd10\nnet/http.(conn).serve(0xc0431f3c20, 0xf5c800, 0xc042bdb480)\n    D:/Go/src/net/http/server.go:1825 +0x619 fp=0xc043abffc8 sp=0xc043abfd58\nruntime.goexit()\n    D:/Go/src/runtime/asm_amd64.s:2197 +0x1 fp=0xc043abffd0 sp=0xc043abffc8\ncreated by net/http.(Server).Serve\n    D:/Go/src/net/http/server.go:2668 +0x2d5\n```\nValidation of global validator.go\n```golang\npackage validator\nimport (\n    \"gopkg.in/go-playground/validator.v9\"\n)\nvar Validate = validator.New()\n/*\nfunc init() {\n}\n*/\nhere `is nation.go` codegolang\npackage validator\nimport (\n    \"github.com/labstack/echo\"\n    \"gopkg.in/go-playground/validator.v9\"\n    \"zhtj/model\"\n    \"zhtj/model/std\"\n    \"zhtj/utils\"\n)\nfunc GetNation(c echo.Context) (*model.NationReqParam, error) {\nValidate.RegisterStructValidation(getNationValidation, model.NationReqParam{})\n\nu := &model.NationReqParam{}\nif err := c.Bind(u); err != nil {\n    return u, err\n}\n\nreturn u, Validate.Struct(u)\n\n}\nfunc getNationValidation(sl validator.StructLevel) {\n    input := sl.Current().Interface().(model.NationReqParam)\n    if utils.String(input.Lang) == \"\" || input.Lang == 0 {\n        sl.ReportError(input, \"Lang\", \"LANG\", std.Msg[std.Code[\"LANG\"]], \"\")\n        return\n    }\n    if input.Lang != 1 {\n        sl.ReportError(input, \"Lang\", \"LANG_FORMAT_ERROR\", std.Msg[std.Code[\"LANG_FORMAT_ERROR\"]], \"\")\n        return\n    }\n}\n. i add sync.Mutex in Validate struct \nlike this:golang\n// Validate contains the validator settings and cache\ntype Validate struct {\n    tagName          string\n    pool             sync.Pool\n    hasCustomFuncs   bool\n    hasTagNameFunc   bool\n    tagNameFunc      TagNameFunc\n    structLevelFuncs map[reflect.Type]StructLevelFunc\n    customFuncs      map[reflect.Type]CustomTypeFunc\n    aliases          map[string]string\n    validations      map[string]Func\n    transTagFunc     map[ut.Translator]map[string]TranslationFunc // map[]map[]TranslationFunc\n    tagCache         tagCache\n    structCache      structCache\n    processMutex     sync.Mutex  // add sync.Mutex\n}\nStep 2 add `v.processMutex.Lock()` and defer `v.processMutex.Unlock()`golang\nfunc (v Validate) RegisterStructValidation(fn StructLevelFunc, types ...interface{}) {\n    v.processMutex.Lock()\n    defer v.processMutex.Unlock()\n    if v.structLevelFuncs == nil {\n    v.structLevelFuncs = make(map[reflect.Type]StructLevelFunc)\n}\n\nfor _, t := range types {\n    v.structLevelFuncs[reflect.TypeOf(t)] = fn\n\n}\n\n}\n```\nStep 3  execute the following command\nsh\nab -n 50000 -c 1000 -p ./postfile.json -T 'application/json' http://127.0.0.1:/api/\nIn that case, no error would have occurred\n. \n. But performance is beginning to decline\uff0c  What should I do?\n. @joeybloggs  thank you\uff0c  The problem has been solved and other partners are not expected to encounter such problems, buddy  ^.^\n. ",
    "0505gonzalez": "Got it, worked. Thanks.. ",
    "sudo-suhas": "@joeybloggs I have recently started using this library through gin. I just wanted to say that the way you handle issues and provide support is nothing short of amazing. Thank you! Don't mind the comment unrelated to the issue.. Thanks for the response @joeybloggs. As you mentioned, I think some docs calling this out would be great. And do you think it would make sense to panic/return an error in the case a pointer is used while registering the struct validation? I did not notice that some validation was being missed for a long time.. ",
    "Arnold1": "hi @joeybloggs i wonder if something has changed in the meantime? \nalso how can i define 2 ranges of allowed values or will i need to put all allowed vlues into validate:\"omitempty,oneof=1 2 3 4 5 6 ... 1000 && 10000 10001 ... 20000\". ",
    "bogh": "@joeybloggs Makes perfect sense. Thanks for clarifying. \nDon't have a problem that it's not out of the box :D. ",
    "phamduong": "My bad, it's documented.\nBut as in #142 you removed exists validation\nIs there any validation that check if value for field exists regardless of what it is?. it works.\nThanks. ",
    "mbn18": "Thanks @joeybloggs , no problem, will do it.\nAs a suggestion, maybe it could be beneficial to support something like this:\ngo\ntype UserEnrollRequest struct {\n    Name     string `json:\"name\" validate:\"required,alphanum=32+95+45,gte=3\"`\n}\nIn this example alphanum=32+95+45 I added the ascii value of space, dash, underscore.. Thanks. ",
    "zhsj": "Thanks. \nWe are packaging this library inside Debian[1][2], as it's the dependency of the current version of github.com/gin-gonic/gin.  I will cherry pick your fix to v8 if you don't want to. But wish you can fix it in v8 too.\n[1] https://ftp-master.debian.org/new/golang-gopkg-go-playground-validator.v8_8.18.1-1.html\n[2] https://bugs.debian.org/869369. Thanks! Close it now.. ",
    "nathanejohnson": "Then what is InvalidValidationError was for, if not a malformed validation:\"\" tag ?  To the caller, I'd argue it's all the same thing, whether it's an invalid \"function\" or just a specified validation that doesn't make sense.  One could also argue that it's never appropriate for a third party package to explicitly throw a panic that is leaked to the caller's context.  I can see your argument though, but to that end I have some tests that actually go through all structs where I put validation tags in, and then see if any InvalidValidationError type errors are returned, and also see if any panics are thrown.  Seems strange to have to check for both.. I guess I am misunderstanding then:  What is the InvalidValidationError actually for?  I was under the impression that ValidationErrors was returned if the input failed validation, and InvalidValidationError was returned if the specified validator tag was invalid?  Sorry if I'm being dense!\nEDIT - so I guess it's simply for validator tags on unsupported data types?  I guess I misunderstood.. https://github.com/myENA/radosgwadmin/blob/master/adminapi_test.go#L67\nHere is an example of where I'm testing for InvalidValidationError and recovering from panics.  (in pratice I hope neither of these trigger).  To my earlier point, I think InvalidValidationError would be a good way to flag I'm mis-using your package.  Regardless, I have to handle both cases, panic or InvalidValidationError, in order to have test coverage, and as a caller, I'd argue they're the same.. ",
    "senuphtyz": "That validator is a great help and great work of you.\nCode hygiene is very important also to me so i changed code according to your review.. ",
    "bokub": "Hi @joeybloggs\nThat is not my use case actually. \nI use the same struct for both the POST and PATCH requests, but I don't want some fields to be changed after they are set\nTo do that, I use two different custom tags so the validation rules are different, but the structure stays the same. \nWhen performing my database update, I tell mongo not to update nil or empty values,  so I want to ensure that some fields are actually set to their default. . Thanks @joeybloggs :+1:. Just replaced all my omitempty,lt=0 with isdefault, that's a lot easier to read and understand\nI can also write things such as \ngo\nCustomer *Customer `validate:\"isdefault\"`\nand be sure Customer is a nil pointer\nThanks for your work :+1:. ",
    "ipiao": "Thank you @joeybloggs . thank you @joeybloggs . ",
    "aaronlehmann": "I encountered the issue when I needed to wrap part of the validation of a struct to make the validation conditional. The data structures look sort of like this:\n``go\ntype Model struct {\n        Items []*Itemjson:\"items\"`\n        ...\n}\ntype Item struct {\n        Validate bool\n        Str1 validate:\"required\"\n        ...\n}\n```\nBasically, I only want to validate the items in Items that have Validate set to true. Because of this, I can't use dive. So what I'm doing is registering a struct validation with this logic:\n```go\nfunc init() {\n        validator.RegisterStructValidation(validateModel, Model{})\n}\nfunc validateModel(sl validator.StructLevel) {\n        model := sl.Current().Interface().(Model)\n        for i, item := range quote.Items {\n                if !item.Validate {\n                        continue\n                }\n            err := sl.Validator().Struct(item)\n            if errs, ok := err.(validator.ValidationErrors); ok {\n                    sl.ReportValidationErrors(fmt.Sprintf(\"items[%d].\", i), fmt.Sprintf(\"Items[%d].\", i), errs)\n            }\n    }\n\n```\nIn a request handler, I call validator.Struct() on a Model. I get back errors with namespace values like Model.Items[0].Item.Str1, but would expect Model.Items[0].Str1. The additional type name that gets inserted doesn't make sense and can't really be filtered out on my side.\nThe changes here check if there's a namespace prefix in ReportValidationErrors, and if there is, it strips out the struct name from the errors, so we don't end up with a namespace that contains an unexpected struct name in the middle.\nFor me it would be ideal to never include any struct names in the \"namespace\" value. I only want to report the fields with problems to my users, not my type names (which are internal). But it's easy for me to strip out the first item in the namespace string as a type, and with this change I can keep on doing that.. I don't think that multiple dimensions would cause any issues. Every time Struct gets called, it prepends the struct name. The code I've added undoes this prepending when those errors are bubbled up a level with ReportValidationErrors. If I understand your example correctly, that would involve multiple nested calls to Struct, which use ReportValidationErrors inside the validator function. I don't expect any problems from this, but I can write tests when I get a chance.\nOne thing I now realize this might break, though, is a nested call to Var. That wouldn't prepend a type name, so stripping out the first item from the namespace would be wrong.\nPerhaps Var would be a way to work around my original problem, without any of these changes? I suppose I could call Var instead of struct, and that would produce errors without a type name attached.. ",
    "mvrhov": "This is what also bothers me. The type information is redundant. Probably in almost all cases.\nE.g If you validate the struct that you fill from form. Then the easiest mapping of Errors to form fields is just the Field name.. There is no type info anywhere in the chain. Just the fieldds. If we take the structs from example simple, then I'd expect the following:\nI'll use json notation:\njson\n{\n\"FirstName\": \"error string\",\n\"Addresses[X].Street\":  \"error string\",\n\"Addresses[Y].Planet\":  \"error string\",\n}\nAnd not:\njson\n{\n\"User.FirstName\": \"error string\",\n\"User.Addresses[X].Address.Street\":  \"error string\",\n\"User.Addresses[Y].Address.Planet\":  \"error string\",\n}\n``go\n// User contains user information\ntype User struct {\n    FirstName      stringvalidate:\"required\"LastName       stringvalidate:\"required\"Age            uint8validate:\"gte=0,lte=130\"Email          stringvalidate:\"required,email\"FavouriteColor stringvalidate:\"iscolor\"// alias for 'hexcolor|rgb|rgba|hsl|hsla'\n    Addresses      []*Addressvalidate:\"required,dive,required\"` // a person can have a home and cottage...\n}\n// Address houses a users address information\ntype Address struct {\n    Street string validate:\"required\"\n    City   string validate:\"required\"\n    Planet string validate:\"required\"\n    Phone  string validate:\"required\"\n}\n```. ",
    "ghost": "Hi @joeybloggs,\nI think this is a good solution, thank you!. ",
    "denouche": "Hey @joeybloggs \nThis works with a struct containing a slice field, but how to validate a slice using validate.Struct(mySliceOfStructs)\u00a0?\nThanks!. Nice, it works great.\nSo fast to answer, great answers, nice library!\nThank you!. Sound great, I will try with this. Thank you very much!. Make sense, thank you. ",
    "vitorleal": "Sorry, i've tested again and it's worked, probably some typo on my side.\nThank's for the quick reply!. ",
    "yharish991": "Hi @joeybloggs , thanks for the immediate reply. Sorry my bad, it is my mistake. It worked after i changed the fields. Thanks. Closing this issue.. ",
    "yokanandCIC": "Hi @joeybloggs Yes, this approach helped me. Thank you for your message. But, I found that we could do the validation without custom validation function. My suggestion is:\nconst (\n  Val1 string = \"value1\"\n  Val2 string = \"value2\"\n   ...\n)\nm := map[string]struct{}{\n  Val1:struct{}{},\n  Val2:struct{}{},\n}\n_,ok := m[string]\n if ok == true\n  return ok\n. ",
    "ansel1": "There's a new validation added which could help.  \ngo\nGender string `validator=\"oneof=male female n/a\"`\nI'm actually not sure if the slash will work, not sure if that's a reserved character.  But may be useful anyway.  Works with strings or whole numbers.. I'll try out the RWMutex.  \nI didn't do floats because of the precision thing.  Wasn't sure you could reliably match floats to their string representations, unless I truncate them to the string's precision.  Which all seemed overly complicated for a questionable use case.  It didn't seem likely one would want to validate a float value against fixed values (again, because of the precision thing).\nRe the CI failure, I think there's an issue in the way you build.  I think the translator/en package is not being tested against the same commit of the validator.v9 package.   The build output shows that the go get command in the build sequence is fetching the master branch of gopkg.in/go-playground/validator.v9 into the GOPATH.  That will be a different version of code than that in /home/runner/workspace/src/gopkg.in/go-playground/validator.v9.  I'm guessing /home/runner/workspace is not on the GOPATH first.\nI can resolve by pushing this PR with the changes to translations/en, then push those in a second PR.  I believe that would build.. swapped out the mutex for rwmutex.  does seem to increase concurrent performance, with no perceptible penalty.. I'm sure it hasn't.  :)  Sorry about that.. ",
    "7fELF": "Thanks for the quick answer :smile: . ",
    "lbozza": "hey @joeybloggs , it has to do with golang itself, not the validator.. When I try to pass an int value to a string field on a struct, go loses it and won't fill the following struct fields.. \n. HEY @joeybloggs thanks for the tip.. ",
    "timakin": "Thanks for your clear explanation!\nI surely understood that json.Decoder is strongly related to this topic.\nIt works if I won't attach the required tag to boolean fields, so it's just the question.\nIf it's on the doc it'll save so many users of this package.. ",
    "FlamingTree": "govalidator use valid:required~Some error specify custom error https://github.com/asaskevich/govalidator/blob/ddb193b4c7bfa1d1c1923ae05a1ee8fb0cd45cf3/validator.go#L631-L650. ",
    "AlexMain": "Thanks, it's work.. ",
    "nikonor": "Thank you!! \nYou realy helped. \nEarly we reflected structs follow splited StructName. And it's was bad.. ",
    "sirakuzi": "Hey @joeybloggs \nYeah, that works, thank you! :). ",
    "jlpellicer": "this will do, thanks!. Hey @joeybloggs, thanks, but it's not about the storage, but the validation.\nWhat I want is to check if the value is a valid ISBN when there is a value present (other than empty string or null), but skip the validation if it is empty (as in empty string) or null.\nSo far, omitempty works if the value is null, and maybe it only works on nulls, that's fine, but I also want to accept an empty string as a \"valid\" value.\nSo, this should pass:\njson\n{\n  \"title\": \"Book title\",\n  \"isbn\": \"\"\n}\n This should pass:\njson\n{\n  \"title\": \"Book title\",\n  \"isbn\": null\n}\nThis should pass:\njson\n{\n  \"title\": \"Book title\",\n  \"isbn\": \"9788416290437\"\n}\nThis should NOT pass:\n{\n  \"title\": \"Book title\",\n  \"isbn\": \"abcd\" <-- not a valid ISBN\n}\nThis should NOT pass:\n{\n  \"title\": \"Book title\",\n  \"isbn\": \"1234\" <-- not a valid ISBN\n}\n. ",
    "kickroot": "Ah, thanks so much.  I had not seen the omitempty directive.. ",
    "gwan284": "Thank you for response!\nSo CustomTypeFunc function defines how to take underlying value from type for all values of that type met. \nWhat if I have different rules for usages of sql.NullFloat64 in another structs? Can this \"ValueTaker\" to be defined per object?\n. Thanks for response again. Now it's absolutely clear.. ",
    "skryja": "Thanks @joeybloggs for your answer, \nbut in the case of the test, attrpath and eq both return false so, as you said, it should stop the validation on the field and should return an error on the validation tag eq as I would like it to be in the test. Instead, the validation seems to continue and goes on Block2 and returns true because  of isfield=Op:replace and the test will fail.. Thanks @joeybloggs ...now it works! :)\nMeanwhile my colleague @leogr found this alternative solution:\nisfield=Op:add|isfield=Op:replace|required,omitempty,attrpath\nIf you want to take a look at what isfield and attrpath validators do; also you can check our repo here.\nThanks again for your time :smiley: . ",
    "moneyzmey": "Hi, @joeybloggs, Thanks for help!\n. ",
    "alexdor": "Hey @joeybloggs thanks for the response. Would you accept a pr that adds this feature? . ",
    "cch123": "@joeybloggs , thx a lot! This solves my problem.. ",
    "jpfluger": "This was a great example. Thanks! :+1: . ",
    "kerak19": "So i probably misunderstood this and thought it's default to take first existing tag name:\n// returns the fields name with the tag name taking precedence over the\n// fields actual name.\n//\n// eq. JSON name \"fname\"\n// see ActualField for comparison\nField() string\n\nThanks for your answer! :). ",
    "jkdf2": "I also understood that \"the tag name taking precedence over the fields actual name\" meant that err.Field() would give me the JSON tag name by default.. ",
    "pnicolcev-tulipretail": "The documentation definitely makes it look like it will pick something like the JSON tag name. I think it would be very useful to add a sentence to the documentation saying something like \"You must implement RegisterTagNameFunc if you want to use a tag rather than the struct field name.\". ",
    "trvsysadmin": "Nope that is all, thank you very much for your reply and thanks for your library! \nTeam here agrees 1 is subjective and may not be the job of the core library. Will try to submit a PR for as an example. \nIn general for 2, we also found out that for cases like len, we can't quite find out what the evaluation result was. For example: \n\"user_friendly_message\": \"{{fieldName}} - length (not value!) must be greater than 3. Your input: [[120]].\" \nis what we can get now but we would like to get:\n\"user_friendly_message\": \"{{fieldName}} - length (not value!) must be greater than 3. Your len: 1.\". ",
    "glb": "Thank you!. ",
    "JulienBreux": "```go\npackage validators_test\nimport (\n    \"testing\"\n\".../validators\"\n\n\"github.com/stretchr/testify/assert\"\nvalidator \"gopkg.in/go-playground/validator.v9\"\n\n)\nvar idItems = []struct {\n    have string\n    want bool\n}{\n    {\"1234567890qwertyuiop\", true},\n    {\"1234567890QWERTYUIOP\", false},\n    {\"@zerty\", false},\n    {\"azerty-\", false},\n    {\"_azerty\", false},\n}\n// TestValidateID ...\nfunc TestValidateID(t *testing.T) {\n    validate := validator.New()\n    validate.RegisterValidation(\"id\", validators.ValidateID)\nfor _, item := range idItems {\n    err := validate.Var(item.have, \"id\")\n    if item.want {\n        assert.Nil(t, err)\n    } else {\n        assert.Error(t, err)\n    }\n}\n\n}\n```. ",
    "lansana": "Ah, thank you for the explanation. In fact, I think the approach of making custom validators per regular expression is the better way to go, because it makes things more maintainable. \nI ran into the issue of having to copy/paste a regexp over to multiple validators, didn't think of the approach of adding a custom validator for a specific regular expression and referring to it by name.\nCheers!. This is super old, but I have my own solution for knowing that.\nBy looping through the validation errors, I can map a field to a validation tag and vice versa. I use that information here to map to friendly error messages:\n```go\npackage validator\nimport (\n    \"errors\"\n    \"reflect\"\n    \"fmt\"\n\"gopkg.in/go-playground/validator.v9\"\n\n)\n// Examples package usage:\n//\n// type Account struct {\n//     Name string validate:\"required,max=5\"\n// }\n//\n// func (a *Account) Validate() map[string]map[string]string\n//     return map[string]map[string]string{\n//         \"Name\": map[string]string{\n//             \"required\": \"Name is required\",\n//             \"max\":      \"Name cannot exceed 5 characters.\"\n//         }\n//     }\n// }\n//\n// messages, err := validator.Validate(&Account{Name: \"foobarbaz\"})\n// if err != nil {\n//     panic(err)\n// }\n// if len(messages) > 0 {\n//     fmt.Println(messages) // []string{\"Name cannot exceed 5 characters.\"}\n// }\nvar (\n    v = validator.New()\n)\n// Validatable is an interface representing objects that can be validated.\ntype Validatable interface {\n    Validate() map[string]map[string]string\n}\n// ValidationMessage is a string type alias that represents validation\n// a validation message.\ntype ValidationMessage string\nfunc (v ValidationMessage) String() string {\n    return string(v)\n}\n// Validate will validate a Validatable object and return a slice of\n// validation messages as well as an error if any is encountered.\nfunc Validate(obj Validatable) ([]ValidationMessage, error) {\n    return validate(obj)\n}\nfunc validate(obj Validatable) ([]ValidationMessage, error) {\n    messages := make([]ValidationMessage, 0)\n    err := v.Struct(obj)\nif _, ok := err.(*validator.InvalidValidationError); ok {\n    return []ValidationMessage{}, errors.New(err.Error())\n} else if _, ok := err.(validator.ValidationErrors); ok {\n    messageMap := obj.Validate()\n\n    for _, err := range err.(validator.ValidationErrors) {\n        f := err.StructField()\n        t := err.Tag()\n\n        if _, ok := messageMap[f]; ok {\n            if _, ok := messageMap[f][t]; ok {\n                messages = append(messages, ValidationMessage(messageMap[f][t]))\n            }\n        }\n    }\n}\n\nreturn messages, nil\n\n}\n```. ",
    "vbmade2000": "@joeybloggs Same issue again.\n\n[INFO]    --> Fetching gopkg.in/go-playground/validator.v8\n[WARN]    Unable to checkout gopkg.in/go-playground/validator.v8\n[ERROR]   Error looking for gopkg.in/go-playground/validator.v8: Cannot detect VCS\n. > attempted to go get gopkg.in/go-playground/validator.v8 directly?\nYes. Getting following output.\npackage gopkg.in/go-playground/validator.v8: unrecognized import path \"gopkg.in/go-playground/validator.v8\" (https fetch: Get https://gopkg.in/go-playground/validator.v8?go-get=1: dial tcp: lookup gopkg.in on 127.0.0.53:53: read udp 127.0.0.1:42094->127.0.0.53:53: i/o timeout)\ncan you git clone the https://github.com/go-playground/validator directly\nYes\ncan you visit this page in your browser?, should look like:\nYes\nWhat OS are you running?\nUbuntu 17 64 bit\nwhat version of git are you using? pre 1.7.6(iirc) had problems with redirects which gopkg.in uses\ngit version 2.14.1\nRunning Proxy\nNo\nFirewall\nDisabled\n\nMay my system has some issue.\n. Make sense. I'll check that. Thanks.. @joeybloggs Yes. It was issue with my system. . ",
    "coveralls": "\nCoverage remained the same at 100.0% when pulling 4dbd40f597c5666596205b1544780aa3229ab2e3 on fdelbos:french-translation into 150fe5b6a4ccc9cd6ffdbf5d184b67fbea75efcc on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 5186bfe8b5c27e92c6738780ec1c7f994ddbf743 on afranioce:v9 into 1b8c8e19cd250435025214492d9a08411d760fdd on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 073682ea75151552c065098c4b587321a16bc5d3 on QuestofIranon:patch-1 into ff1ee42e838f15a68230cebda8aaa21427506175 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 9f62099643d87d0c6c232be81cd22731bfc5e6e8 on Ashtonian:patch-1 into 14984d91328f9612b58443cbdf4a077d4fd71091 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling a0dec43aecdf026e4c1b83e1de8fd09a485fd22c on popsa-hq:v9 into e69e9a28bb62b977fdc58d051f1bb477b7cbe486 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 868936b86275559add42d114ca9e4cfe7f8ccae4 on 44px:patch-1 into 16a72ff827f8a0e46d665fdd26d3a67be113d44b on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 29b73202feec0eed620eb88799c5067ed73229e6 on frou:doc-registertagnamefunc into f8af4b15dbe132b53d3a53e7c3724271040e82e7 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 532cde1085aad0bfb8ae2a5fa41aab2493035528 on kanozec:v9 into f8af4b15dbe132b53d3a53e7c3724271040e82e7 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 8ed00e2e122ca07de1a5489b8f0b451fa9010af1 on suekto-andreas:v9 into 3be31424000e9263ddc36f27b1de4c18f657f02e on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling e8e32f111d31f763d0dca5632239423f9f5a920a on holyspectral:unique_translation into 1fa3c8d6336562f0a3f95c73593ee2b57ff4da11 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling df107f0184cc8babdd362cbe9ab238e8fde2652f on holyspectral:unique_translation into 1fa3c8d6336562f0a3f95c73593ee2b57ff4da11 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 4654fc2592c712ba95a9e2b1eb659533d35e6b44 on joshhsoj1902:patch-1 into 1fa3c8d6336562f0a3f95c73593ee2b57ff4da11 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling f2ac4efd5734abf0eb3151d3df94fd37f4895024 on andreiavrammsd:notblank into 774d09c3863ffb2e137ebe4c39ba27648d208f80 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling aaf2c06dbefb5a4f03aca9c515cbd22dda3cce69 on mitsuyoshi4:v9 into 1fa3c8d6336562f0a3f95c73593ee2b57ff4da11 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 80d96abe92e3ec84feef2a9206de3e50d5d77a67 on fharding1:baked-in-contains-excludes-field into 6079fcc1869c6e9491df9f02e3d1d9b6bff2939d on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 47e82867269701a70400f50aa4fb50a5f7b2d693 on mastertinner:v9 into 6079fcc1869c6e9491df9f02e3d1d9b6bff2939d on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 20357ae332952363c78f36d206f04859009ac84d on AGPDev:v9 into 6079fcc1869c6e9491df9f02e3d1d9b6bff2939d on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling d9610b90518c6cfba668d18feb3180d7dc7e667f on leodido:feat/is-urn into 6079fcc1869c6e9491df9f02e3d1d9b6bff2939d on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 0482874b86ffbffda291b855d8a77fe5021f5126 on leodido:feat/is-urn into 6079fcc1869c6e9491df9f02e3d1d9b6bff2939d on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 578166faf782b26e4ea6023200008efbce5b6f76 on akm:japanese_translation into 6079fcc1869c6e9491df9f02e3d1d9b6bff2939d on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 106b067c20eb275aa55e5c8588c3441f1418d939 on akm:fix_ja_translation into 0277b12d53df79c9dbf7311cb07fa9c81ed621bb on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling d1d2da5f7342a2e99db9628036af5330ac9b7947 on RaMin0:feature/numeric_geo_coords into cdd5c28d217804eec51fa694927e6c57465748f6 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling fdbd8ba577a9f330daeb9fb52dc0f21fec0e7600 on kszafran:patch-1 into 774d09c3863ffb2e137ebe4c39ba27648d208f80 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 891b7807f8d9d3d09dd5fc68593e3596095230d0 on Esslamb:v9 into 774d09c3863ffb2e137ebe4c39ba27648d208f80 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 94ba218708d36519fb048077914e5223e5225d72 on agalal:add-dir-validator into 774d09c3863ffb2e137ebe4c39ba27648d208f80 on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling dbd65cccbc6d38f6daa51ac39d8f97430d405988 on rucas:v9 into b199fa0642d29caca62b6a99d65cc981ba5edc3b on go-playground:v9.\n. \n\nCoverage remained the same at 100.0% when pulling 3945da16ee820591754b888b40b1361fb112ed66 on thcipriani:v9 into b199fa0642d29caca62b6a99d65cc981ba5edc3b on go-playground:v9.\n. ",
    "fdelbos": "@joeybloggs you are welcome, thanks for the great lib. Don't hesitate to let me know if you need some updates on the translation.. ",
    "blackstar257": "I just ran into this as well. . ",
    "suekto-andreas": "Hi @sudo-suhas @joeybloggs,\nI've created a PR in https://github.com/go-playground/validator/pull/413 for this issue, kindly help to review / feedback if it helps. \nIts my first pr in github ever, pardon me if making mistake, and feel free to feedback.. Thanks @joeybloggs, pushed a commit using Indirect to downgrade it. ",
    "jeevatkm": "@joeybloggs Thank you for your suggestions. Yes I agree your suggestion is good one.\nActually I given that choice to the aah users, aah has Auto bind module which maps any Path, Form, Query into struct fields and nested struct fields.\nIf user uses the struct to map values then aah applies the validation automatically and gives the errors to the user as part the request flow. \nIt seems I have to update the documentation to explain clearly with your suggested approach.\nCurrently I do not know about mold library. I will surely have a look and study.\nThank you for building flexible validator library \ud83d\udc4d \n. ",
    "gangstaJS": "Go version: go version go1.10 darwin/amd64. MacOS High Sierra 10.13.3\n```go\nfunc ResetPassword(writer http.ResponseWriter, request *http.Request) {\n    res := Payload{}\n    validate := validator.New()\ndata := struct {\n    UUID            string `validate:\"required,uuid\",json:\"uuid\"`\n    Password        string `validate:\"required,alphanum,gte=6\",json:\"password\"`\n    ConfirmPassword string `validate:\"eqfield=ConfirmPassword\",json:\"confirmPassword\"`\n}{}\n\nerr := json.NewDecoder(request.Body).Decode(&data)\n\nif err != nil {\n    res.Result = err.Error()\n\n    SetPayloadErr(writer, res)\n    return\n}\n\nerr = validate.Struct(data)\n\nif err != nil {\n    res.Result = err.Error()\n    SetPayloadErr(writer, res)\n    return\n}\n\nif !db.ResetPassword(data.UUID, data.Password) {\n    res.Result = \"Reset link has expired or was not created\"\n\n    SetPayloadErr(writer, res)\n    return\n}\n\nres.Result = \"New password was saved\"\n\nSetPayloadOk(writer, res)\n\n}\n``. Thanks! It is strangely cuz json annotation still works when I am doingvalidate:\"required,alphanum,gte=6\",json:\"password\"`. ",
    "QuestofIranon": "Fixed the coverage, it was because some of the validation steps I had were covered by other steps.. ",
    "insamo": "Thx @joeybloggs . ",
    "ralekseenkov": "We are already using translations and they are not going to help in this case. \nIf you look at the code snippet, field level validators only return true/false. There is no way to return a custom error. I.e. if I get an err from template.NewTemplate(fl.Field().String()), I can only check whether it's nil or not. There is no way to return the string of that err to an end user.\nWe we really want to achieve is to return Template is invalid (<underlying error message>) instead of generic Template is invalid message.\nWith struct-level validators it's possible to do so via sl.ReportError. Field-level validators don't seem to support that.\n. ok, thanks!\nif you want to take a look at how we are using the library:\n- https://github.com/Aptomi/aptomi/blob/master/pkg/lang/validation.go\n- https://github.com/Aptomi/aptomi/blob/master/pkg/lang/contract.go (one of the structs we are validating)\n. ",
    "jadhub": "I supplied a PR for this: https://github.com/go-playground/validator/pull/362. Wrong Mention i guess. You probably wanted @joeybloggs.. ",
    "syssam": "But I am using gopkg.in/go-playground/validator.v9/translations/en\",\nThis case will be replace it?. According my current understanding, I can using RegisterTagNameFunc to translations the field name, but it will be cause the json key also translated.\nIs my usage wrong?. um, I have an idea, load a json file, like lang/en/validation.json\nStruct below \n{\n    \"required\": \"The :attribute field is required.\",\n    \"len\": {\n        \"numeric\" : \"The :attribute must be :size.\",\n        \"file\"    : \"The :attribute must be :size kilobytes.\",\n        \"string\"  : \"The :attribute must be :size characters.\",\n        \"array\"   : \"The :attribute must contain :size items.\"\n    },\n    \"custom\" : {\n        \"User.FirstName\" : {\n            \"required\" : \"custom-message\"\n        }\n    },\n    \"attributes\": {\n        \"first_name\"    : \"First Name\",\n        \"last_name\" : \"Last Name\"\n    }\n}\nThe validator default will be load en, provide a function load another lang.\nThe user can be easy to change the custom message, and more clearly.\nchange Json content is easier then add or change validator function.\nBecause the json only will be load one time on the validataion Init, so I think the performance will not be afftect.. Yes, I know universal-translator already provides similar functionality.\nSometimes, we need translation from other people, but we do not send a \"golang\" file, because the translator do not know the program. JSON format is more common and easily to tell the translator how to do it.\nOn the other hand, useris more easily to understand and custom own error message and more normally.I saw many framework i18n also like this.\nI know you want this package is focus on the validation and user write a golang to translations as they need.\nBut I think more user are hoping you can provide a simple translation with validation and default different language package.\nIt can reduce the user a lot of time.. Hi @joeybloggs , Yes, I am really confused.\nI want to do a translations for error message, but I don't know how to do it.So, I open the issue #364 , then I read sample, I find out the RegisterTagNameFunc , I think this function is my need.\nWould you provide more clearly sample to using validator and locale, like the result\n\"error\":{\n\"email\": \"Email is a required field\",\n\"first_name\": \"First Name is a required field\",\n\"last_name\": \"Last Name is a required field\"\n}\n. um, I using this method before,\nlike https://github.com/syssam/go-playground-sample/blob/master/main.go. @joeybloggs Yes, I'm using https://github.com/syssam/go-playground-sample/blob/master/main.go\nIt seems not perfect.But it's fine. Great, keep going.\nexpected. e.Translate(trans) because the runtime program don't know what lang should use, so, you need pass the parameter to tell the program, oh, I need \"en\" or another lang.\nBut I think @joeybloggs can provide a Api for set locale. User don't need pass \"trans\" every times. Sorry, you have some misunderstandings. \nFor a example,\nIn gin middleware, I can using uni.SetTranslator(\"en\") or uni.SetTranslator(\"fr\") to determinate using which lang, I don't need e.Translate(trans) pass trans parameter every times.. ",
    "alecthomas": "I just hit the same problem, but I don't think this can be solved by Struct Level validation as far as I can tell. The problem is that the validator (in this case gteEpoch=ValidFrom) is set on the parent field, but struct level validators don't have access to this. Am I mistaken here?\nPS. Great library, thanks!. ",
    "0xdevalias": "Realised this morning that I was trying to join them with , rather than , my bad:\n* https://stackoverflow.com/questions/18635671/how-to-define-multiple-name-tags-in-a-struct. Sounds good, thanks :). Just wanted to add a little extra context here in case i'm likely to run into another issue from here. I think the basic flows I want to implement is going to be something like:\nIF customValidatorRequired THEN required\nIF NOT customValidatorRequired THEN omitempty ELSE otherCustomValidators\nI'm guessing I could probably build it up with the AND/OR operators, but not 100% how I would fit the omitempty part into it.. Oo.. I think I must have mentally skipped over those.. They definitely do sound like they would work for what I need. Will play around with them and see. Thanks :)\nEdit: Struct Level validation seems to have done the trick perfectly. Made all of the struct keys pointers, did the 'flow' validation at the StructLevel, and then can do omitempty + specific field validations for the ones that need it.. ",
    "vpikulik": "I expected, that my example should pass validation. Tag omitempty helps. But only if it stays as the first tag. Before we tested this with this tag at the end ((. The problem was solved, thanks!. ",
    "adnansinanovic": "Ignore my question. \nI just noticed there is oneof tag already  (I missed it in documentation first 29 times)\nSo, valid code for previous example would be:\nsh\ntype Request struct {\n    Country       string     `validate:\"required,oneof=us uk fr mv es de be\"` \n}. ",
    "czbaker": "Upon further research and asking around on Discord, apparently this is just how things work, as stated in the reflect package.   Whitespace is apparently important, I didn't know that.\nFeel free to close this, I just didn't read the docs all the way, my bad!. ",
    "aprilnops": "confuse too. ",
    "heatwole": "Sorry, I goofed up. I'm fixing it now.. ",
    "noibar": "Done :) . ",
    "beiriannydd": "This isn't working because of the parallel execution of my tests.  I need to create two different validations to make this work which are statically a particular tag name.  I cannot use a TagName function because it won't accept a context, which I could use to persist the manifest version under test, or allow me to see all the fields in the structure.. Thanks, I think I came to the same conclusion.  I actually think the TagNameFunctionCtx could be the best possible solution, since it would allow me to just execute the validation once per instance.\nWill Context be included in the cache key too?. So, I tried this:\ngo\n    ctx := context.Background()\n    validate := validator.New()\n    // add our custom validations\n    validate.RegisterTagNameFunc(func(field reflect.StructField) string {\n            // wrap our current context\n            return manifestSchemaVersionTagCtx(field, ctx)\n    })\n\u2026\n    // First Check the version\n    if err = validate.StructPartialCtx(ctx, manifest, \"ManifestVersion\"); err != nil {\n        return nil, errors.New(\"validate: invalid manifest_version.\")\n    }\n    // Now the version is valid, trim to Major and Minor only.\n    mfversion := manifestVersion(manifest.ManifestVersion)\n    ctx = context.WithValue(ctx, manifestSchemaVersionKey, mfversion)\n    // Validate the structure\n    if err = validate.StructCtx(ctx, manifest); err != nil {\n        return nil, errors.New(\"validate: basic validation failed: \" + err.Error())\n    }\nSo now there is only one call to StructCtx per validation, there is no global (each thread will add its own unique context based tag function), the debug code in the tag function tells me that the tag is consistent per validate instance but the test still fails.  I think if you can add uniqueness by tag to the cache that would be ideal.. ```go\nfunc getValidator(tagname string) *validator.Validate {\n    // create a new validator\n    validate := validator.New()\n    validate.RegisterValidation(\"manifestversion\", validManifestVersion)\n    validate.RegisterValidation(\"appversion\", validAppVersion)\n    validate.RegisterValidation(\"thornversion\", validThornVersion)\n    validate.RegisterValidation(\"hyphenunderscore\", hyphenUnderscore)\n    validate.SetTagName(tagname)\n    return validate\n}\nfunc (manifest *Manifest) Validate() (bool,error) {\n    validate := getValidator(\"validate\")\n    // First Check the version\n    if err := validate.StructPartial(manifest, \"ManifestVersion\"); err != nil {\n        return false, errors.New(\"validate: invalid manifest_version.\")\n    }\n    // Validate the structure\n    if err := validate.Struct(manifest); err != nil {\n        return false, errors.New(\"validate: basic validation failed: \" + err.Error())\n    }\n    // Now the version is valid, trim to Major and Minor only.\n    mfversion := manifestVersion(manifest.ManifestVersion)\n    // Validate version specific data\n    validate = getValidator(\"validate\"+mfversion)\n    // Validate the structure\n    if err := validate.Struct(manifest); err != nil {\n        return false, errors.New(\"validate: basic validation failed: \" + err.Error())\n    }\n    return true, nil\n}\n```\nThis code works, thank you.  I will tell you that when I used the tagname function, the initial call to StructPartial requested the tag for ManifestVersion and the two sub structures with no version number.  Then subsequently it was called for each field with a specific version, this is why I expected the code to work that way (without dissecting validator).  So you may be able to make some performance optimizations by dropping a tag name request that you're not going to use anyway :) . ",
    "IvRRimum": "Still stuck here, any ideas?. Forgot to initialise validator validate = validator.New(). ",
    "veqryn": "No problem. Thx!. ",
    "cwoodcock": "Doesn't look like this is the issue the OP is facing, but in case somebody searches and lands here it might save them a bit of head scratching.  You can get an 'Undefined validation function' panic if there's whitespace in the tag e.g. validate:\"required, foo\".. ",
    "adonese": "I'm encountering the same problem.\nHere is what I guess would be the problem\n- I'm updating my gin custom binding validator in init() method\n- in the program main function, I've var validator *validate.Validator, and from there I call\nvalidate.RegisterValidation(tag, customTag).\nHowever, my custom tag is not being recognized.\nAnd I'm using gin's binding.. I've fixed it.\nYou have to, which was clearly written in the validator.v8 -> v9 upgrade, to register your custom functions in func (v *defaultValidator) lazyinit() func.\n. ",
    "droslean": "@joeybloggs It seems that this solves my problem.. @joeybloggs Thanks a lot. This is what I was looking for.. ",
    "canhlinh": "@joeybloggs \nThank you for reply me.\nExample: \nI want to validate with sql.NullString.\nI leave the value of sql.NullString as empty. I don't want the column to be validated.\nBut the validator still validates the column.\nI go to the this line https://github.com/go-playground/validator/blob/e69e9a28bb62b977fdc58d051f1bb477b7cbe486/util.go#L51\nchange it to \nreturn current, current.Kind(), true\nIt works.. @joeybloggs You are right. Just use omitempty tag instead. Thank you\n. @joeybloggs One star for doing a very good job.. ",
    "gitste": "Hi @joeybloggs\nThanks for response, I am building a chaincode in golang for Hyperledger Fabric which will be loaded dynamically over the network, that is why I need it to be as small as possible. \nWhen I tried to compile my program with Validator I got an exception that I need Universal Translator which came with locales totally being ~60mb. The validator itself is ~3mb.\nMy usecase requires rather simple vadiations for structs which chaincode receives as parameters. eg. required, dive, omitempty and some custom tags with simple logic. \nCan you guide me how to trim validator?\nThanks\n. @joeybloggs \nI have taken asaskevich/govalidator, removed unnecessary files and it fulfils my needs without changes in the code. Thanks for help and good will.. ",
    "payuprashantg": "Thanks @joeybloggs ,\nIts working fine now.. ",
    "loeffel-io": "Hey @joeybloggs, thanks for your response. The omitempty tag is not working in combination with the email tag. Same result.\ngolang\nEmail  *string `json:\"email\" validate:\"email,omitempty\" structs:\"email,omitempty\". ```golang\npackage main\nimport (\n    \"log\"\n    \"gopkg.in/go-playground/validator.v9\"\n)\ntype info struct {\n    Email *string json:\"email\" validate:\"email,omitempty\" structs:\"email,omitempty\"\n}\nfunc main() {\n    info := &info{}\n    validate := validator.New()\n    err := validate.Struct(info)\nif err != nil {\n    log.Fatal(err.Error())\n}\n\nlog.Printf(\"Success\")\n\n}\n```. > you must reverse the omitempty and email tags\n\ud83d\ude48  thank you very much! . ",
    "rssathe": "What's the status on this @joeybloggs @alexbilbie ? Understood it's a breaking change but it seems like the validator doesn't comply with the RFC, so I'm not sure of the usefulness of having both. . @joeybloggs can we get this merged in?. @joeybloggs  It seems fairly deceptive to suggest something is validating a uuid when as according to the spec its actually not correctly doing so. In fact i'd suspect that most people have unexpected issues debugging what seemingly should be and looks like a valid UUID and is failing validation with this validator. My opinion would actually be the reverse if for some more peculiar reason you wanted to only validate lowercase uuids to have a validator called uuid_lowercase. But seeing as you have a strong opinion on this regarding a \"breaking change\" I can submit a pr with your suggestion. . @joeybloggs have a pr up for this!. @joeybloggs any chance you can look at this?. ",
    "wongyinlok": "I mean if this package can be run in Plan9. When I tried go get it said repository isn't supported.. I am using 2.2.0. @joeybloggs thanks for the reply, seems like the problem is with git. I tried git cloning manually and it didnt clone the package. Then I downloaded the zip and it seemed to work fine.. ",
    "hxmhlt": "@joeybloggs Yes,it's work for me. Go-sqlmock is only incompatible with validatorv9 in this respect, because it requires that all sql execution order must be certain. Now the code here makes the execution order of the validator undefined.So I have to modify here to slice. Or  should you consider allowing the user to specify the order of execution of the validators in different fields?\n. emmmm...\nex,I have a struct\ntype MemberRoleDTO struct {\nRoleId      int     json:\"roleId\" binding:\"required,validateroleid\"\nMemberId    int     json:\"memberId\" binding:\"required,validatememberid\"\nMemberType  string  json:\"memberType\" binding:\"required,validatemembertype\"\nSourceId    int     json:\"sourceId\" binding:\"\"\nSourceType  string  json:\"sourceType\" binding:\"\"\n}\nfunc validateroleid(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string)bool{\n    if targetField, ok := field.Interface().(int); ok {\n        if _,err := role.FindOne(&role.Role{Id:targetField});err==nil{\n            return true\n        } else {\n            return false\n        }\n    }\n    return false\n}\nfunc validatememberid(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string)bool{\n    if targetField, ok := field.Interface().(int); ok {\n        if currentStructOrField.Interface().(*MemberRoleDTO).MemberType == \"user\"{\n            if _,err :=users.FindOneUser(&users.User{Id:int64(targetField)});err==nil{\n                return true\n            }\n        }else if currentStructOrField.Interface().(*MemberRoleDTO).MemberType  == \"client\"{\n            if _,err :=auth.FindOneClient(&auth.Client{Tid:targetField});err==nil{\n                return true\n            }\n        }else{\n            return false\n        }\n    }\n    return false\n}\nAnd validateroleid,validatememberid  is my validater func,In this 2 func I have to do \"FindOne\" to access my db, so I wrote my mock:\nmock.ExpectQuery(SELECT (.+) FROM \"t_iam_role\").WithArgs(1).\n                WillReturnRows(sqlmock.NewRows([]string{\"id\", \"name\", \"code\", \"description\",\"level\",\"is_enabled\"}).\n                    FromCSVString(\"1,superAdmin,sysadmin,,user,1\"))\ncolumns := []string{\"id\", \"user_account\",\"user_name\",\"user_email\",\"user_phone\",\"dept\",\"pwd\"}\n            mock.ExpectQuery(SELECT (.+) FROM \"t_user\").WithArgs(1).\n                WillReturnRows(sqlmock.NewRows(columns).FromCSVString(\n                    1,admin,admin,admin@ctrip.com,110,,$2a$10$bCoOHdNZpLh3mIvzs19hJOOaBfegwosff5iOouyO7rhfDRy6s2aaW))\nSo the error is validateroleid and validatememberid func execute disordered.I can't sure the correct mock is written on the above, or is \ncolumns := []string{\"id\", \"user_account\",\"user_name\",\"user_email\",\"user_phone\",\"dept\",\"pwd\"}\nmock.ExpectQuery(SELECT (.+) FROM \"t_user\").WithArgs(1).WillReturnRows(\nsqlmock.NewRows(columns).FromCSVString(1,admin,admin,admin@ctrip.com,110,,$2a$10$bCoOHdNZpLh3mIvzs19hJOOaBfegwosff5iOouyO7rhfDRy6s2aaW))\nmock.ExpectQuery(SELECT (.+) FROM \"t_iam_role\").WithArgs(1).\n                WillReturnRows(sqlmock.NewRows([]string{\"id\", \"name\", \"code\", \"description\",\"level\",\"is_enabled\"}).\n                    FromCSVString(\"1,superAdmin,sysadmin,,user,1\"))\nSo the 2 func validateroleid and validatememberid must execute in order.\noh...I found I can't format my code in mardown....Maybe you can copy my code then format it ..... ",
    "dakait": "Thanks @joeybloggs  for your help. \nMy struct was failing at reflect.StructTag.Get. I didn't realize it earlier. I apologize for asking this question without thorough debugging. I feel silly now.\nI would like to add that StructPartial(foo, \"Name\") is working fine for simple structs.. ",
    "Jwata": "OK, so they must be exported to do validate using reflection.. ",
    "andreiavrammsd": "Hello,\nThe value \"\" (empty string) is caught by required,gt=0, but \"     \" (string made only of spaces) is not. In many situations, I need to make sure there is actually a value inside a string, not only spaces.\nI'm using a custom registered tag now, but I see the situation as quite common.\nThanks!. Regarding trimming, is it worth using a library for a simple built-in function?\nFor maps and slices, you could use \"dive\" in order to run the validation on everything.. If it feels too heavy for the standard library, no problem, we can close it.\nIt's just something I see as a standard for validations.. This could be something. How would you see the non-standard validators registration: (1) including tags or (2) leaving the user the choose a custom tag?\n\n\nNew register function: this would automatically register the validate function with the tag \"notblank\", so you'd use it as:\ntype User struct {\n    Username `validate:\"notblank\"`\n}\nv := validator.New()\nv.RegisterNonStd(validators.NotBlank) // please ignore the \"RegisterNonStd\" name, I'm just out of ideas for now\n\n\nAllow user to use the function with any tag:\ntype User struct {\n    Username `validate:\"customtag\"`\n}\nv := validator.New()\nv.RegisterValidation(\"customtag\", validators.NotBlank). Is it starting to look as you thought?. \n\n",
    "sun-wenming": "Hey\uff0c @jadhub \nFirst it is valid.Errors.\napp.MarkValidErrors(...)It's my encapsulated log record.Sorry.\ngo\n// A Validation context manages data validation and error messages.\ntype Validation struct {\n    Errors    []*Error\n    ErrorsMap map[string][]*Error\n}\nAnd I started to be at validate.Struct(...).Like this.\ngo\ntype DocEditTopic struct {\n    // Name topic name\n    Name string `json:\"name\" example:\"topicName\" validate:\"required\"`\n    // ModifiedBy modified id\n    ModifiedBy int `json:\"modified_by\" example:\"1\" validate:\"required\"`\n    // 0 can use, 1 not \n    State int `json:\"state\" example:\"0\" validate:\"oneof=0 1\" format:\"(0~1)\"\"`\n}\nDocEditTopic.State field is optional.But In struct initialization state default 0.(because int type) \nLike this map[name:topicName modified_by:1 state:0]\nI am not submit in http request body \n{\n  \"modified_by\": 1,\n  \"name\": \"topicName\"\n}\nCaused me to have to separate state field from the structure. Separate verification state field.\nSo i want like valid.Errors unified processing of error messages.\nBut now.\nI should not use the optional parameter defaults (with 0). So I can use the struct.And don't need  valid.Errors\nchange code ignore 0\n``go\nState intjson:\"state\" example:\"1\" validate:\"oneof=0 1 2\" format:\"(1~2)\"`\nif t.State != 0 {\n     data[\"state\"] = t.State\n}\n```\nI will continue use validate.Struct(...)\nDo you have any suggestions for default values of struct?\nThanks.. > Wrong Mention i guess. You probably wanted @joeybloggs.\nYes,i am so sorry to you.\n. ",
    "fharding1": "I considered making these validators panic on non-string types but it looks like that isn't the behavior of other validators so I decided against it. I also considered adding support for fmt.Stringer but did not for the same reason.. @joeybloggs thanks for the feedback, done.. bump @joeybloggs . No worries, I don't mean to be a bother, I just figured after a month you might have forgotten about it. Hope you and your family feels better soon! . ",
    "ianaz": "Same exact problem. ",
    "1011875777": "this is a very important feature. ",
    "nielskrijger": "Been struggling with the same problem too.\nI planned on working around this and specify the field manually in some custom Validate function; but keep using the tag validation & translation functionality from this lib.\nSadly I got stuck, mainly because most fields are private (e.g. transTagFuncs). Working around all that would require quite a bit of scaffolding. \nI'll probably validate these exceptions now manually, given most of the validation rules are struct-based.\n(my validation problem involves code-generated golang files which I don't want to change). ",
    "mastertinner": "Another discussion should be whether to move from importing from gopkg.in to directly importing from github.com.. ",
    "wcsiu": "Can someone please add the go.mod, go.sum? It shouldn't break anything and the library will be go module ready.. ",
    "offlinehacker": "Same issue here, i guess this is the only decent validation library in go, and can't even use it without forking. ",
    "leodido": "Hey @joeybloggs is a MIT compatible?\nRegarding the name I agree with you. Was thinking to do exactly the same, since the other RFC (8141) is in the making.\nEdit: done.. Could you please review PR #429 ? I updated it.. ",
    "mkadin": "Seems like maybe from #245 that I can't actually do the custom validator solution I mentioned above, as those validations can only be written for fields which aren't a next level of struct, is that right?. Thanks for getting back to me.  \nFor 1), that could definitely work, but while I find the struct level validation useful, being able to use simple tags when defining structs is what makes this package so useful.  I'd love to see if that's still possible somehow.\nFor 2), that could work but it would require the validation on the Person to be aware of its usage in other structs.  In other words, we could add a validator to person:\ntype Person struct {\n    FirstName string `validate:\"validateFirstName\"`\n    LastName string `validate:\"validateLastName\"`\n}\nwith functions like:\nfunc validateFirstName(fl validator.FieldLevel) bool {\n    if fl.Top().Type().Name() == \"Movie\" {\n            // Do something movie specific\n        } else {\n           // Do something else\n        }\n}\nThat would certainly solve the problem, but sort of ruins the abstraction for Person, since it might be embedded in lots of places.\nIf these are the only two possible options, we'll implement struct level validation and we can close this issue.  That said, I'd like to put in another vote for support of the ability to specify a struct-level validation via a tag on a field a la #245.. ",
    "axopadyani": "Ah, I  see. All that makes sense now. Thanks for your help.\n. ",
    "sssinsi": "Sorry, I mistook name of base branch.. ",
    "KlausBuchegger": "Hey @joeybloggs \nThanks for the reply, I created a struct validation function for this case. \nI thought about a tag like choice=groupname that checks all fields for this groupname tag and verifies that exactly one is non-empty. But this seemed rather inefficient, as it will be executed for every field with this tag.\nI'm closing this issue with the result that it's not part of the current implementation.. ",
    "tredoe": "The step attribute specifies the legal number intervals for an  element.\nhttps://www.w3schools.com/tags/att_input_step.asp. ",
    "mh-cbon": "for future readers, i have implemented a custom validation like this \ngo\n    app.Validator.RegisterValidation(\"iffalse\", func(f validator.FieldLevel) bool {\n            rv := f.Parent().Elem().FieldByName(f.Param())\n            if !rv.IsValid() {\n                log.Fatalf(\"field %q not found\", f.Param())\n            }\n            if rv.Kind() == reflect.Ptr {\n                rv = rv.Elem()\n            }\n            if rv.Interface().(bool) {\n                return true\n            }\n            rs := f.Field()\n            if rs.Kind() == reflect.Ptr {\n                rs = rs.Elem()\n            }\n            s := rs.Interface().(string)\n            return s != \"\"\n        }). ",
    "akamensky": "Never mind, my tired brain missed the issue in my code causing this.. Never mind, my tired brain missed the issue in my code causing this.. ",
    "gm42": "this one maybe needs to go?\n. ",
    "tschaub": "Was this paragraph supposed to replace the one above (\"NOTE2: comma is the default separator of validation tags\")?  Reading through the current docs, it is hard to understand which of , or | is the default separator.\n\nComma (\",\") is the default separator of validation tags. If you wish to\nhave a comma included within the parameter (i.e. excludesall=,) you will need to\nuse the UTF-8 hex representation 0x2C, which is replaced in the code as a comma,\nso the above will become excludesall=0x2C.\ntype Test struct {\n  Field `validate:\"excludesall=,\"`    // BAD! Do not include a comma.\n  Field `validate:\"excludesall=0x2C\"` // GOOD! Use the UTF-8 hex representation.\n}\nPipe (\"|\") is the default separator of validation tags. If you wish to\nhave a pipe included within the parameter i.e. excludesall=| you will need to\nuse the UTF-8 hex representation 0x7C, which is replaced in the code as a pipe,\nso the above will become excludesall=0x7C\ntype Test struct {\n  Field `validate:\"excludesall=|\"`    // BAD! Do not include a a pipe!\n  Field `validate:\"excludesall=0x7C\"` // GOOD! Use the UTF-8 hex representation.\n}\n  . \n",
    "joshhsoj1902": "Hey @joeybloggs, I might be doing something wrong on my end, But for me, it only works when I also change the *fieldError references to the interface. When I just add Error() string to the interface I still get this error thrown\n\npanic: interface conversion: validator.FieldError is validator.fakeFieldError, not validator.fieldError \n\n(that panic happens on line 51, fakeFieldError is my implentation of FieldError)\nMy understanding is that since line 51 is trying to cast to the private struct, the only way the casting will pass is if the object being cast was also made from that private struct. and since it's private, I have no way of actually doing that.. No problem at all. If there is anything you would rather I do instead, let me know. I think there are a few ways to solve this. . Hey Joey, sorry for the slow reply. I do plan on circling back and creating a small sample program for you. Time is always the issue. Things should slow down a bit for me after next week. . ",
    "RaMin0": "Did a small benchmark to compare and you're right. Check the latest commits.. "
}