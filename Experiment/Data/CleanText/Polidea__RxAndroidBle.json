{
    "mzgreen": "Code review fixes applied, now mocking client looks like this:\nrxBleClient = new RxBleClientMock.Builder()\n                .deviceMacAddress(\"AA:BB:CC:DD:EE:FF\")\n                .deviceName(\"TestDevice\")\n                .scanRecord(\"ScanRecord\".getBytes())\n                .rssi(42)\n                .addService(\n                UUID.fromString(\"00001234-0000-0000-8000-000000000000\"),\n                new RxBleClientMock.CharacteristicsBuilder()\n                        .addCharacteristic(\n                        UUID.fromString(\"00002a29-0000-1000-8000-00805f9b34fb\"),\n                        \"CharacteristicData\".getBytes(),\n                        new RxBleClientMock.DescriptorsBuilder()\n                                .addDescriptor(\n                                 UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\"), \n                                 \"DescriptorData\".getBytes()\n                                 ).build()\n                ).build()\n        ).build();\nPlease verify again.\n. This is added as a separate module. If someone wants to use it then he will need to add an additional dependency (exactly like MockWebServer from OkHttp https://github.com/square/okhttp/tree/master/mockwebserver).\n. Fixes have been applied.\n. Good points @dariuszseweryn. Thanks. Should be ok now.\n. I've implemented mocking characteristic notifications. API looks like this:\nrxBleClient = new RxBleClientMock.Builder()\n                //....\n                 .notificationSource(characteristic_UUID, observable)\n                 .build();\nYou can pass a subject as a notification source and then when you can call getNotification(characteristic_UUID), you will get a notification every time you call onNext() on your subject. See updated tests.\n. @dariuszseweryn could you check the logic in createCharacteristicNotificationObservable especially the cache and share operators at the end? I've mimicked the behavior of RxBleConnectionImpl implementation but it's quite confusing so I'm not completely sure if I did it right.\n. I've implemented mocking connection status. API looks like this:\nrxBleClient = new RxBleClientMock.Builder()\n                //....\n                 .connectionStateSource(Subject<RxBleConnection.RxBleConnectionState>)\n                 .build();\nYou can then subscribe to rxBleDevice.getConnectionState() to get notifications about connection state.  Subject that is being passed as a parameter allows to change current connection state - see updated test.\n. Such functionality has no sense. It will be changed in the future. You can ignore it.\n. I've added support for simulating device disconnection. Now you will get a CONNECTED status when you subscribe to RxBleConnection and you can simulate a situation when device has disconnected itself. You can do it by calling rxBleClient.disconnect() method. State will change to DISCONNECTED and BleDisconnectedException error will be emited.\n. Seems good :+1: \n. It's the same as autoConnect in BluetoothDevice. I think that it should be mentioned in the doc, do you agree @uKL ? \n. Yes it does. See https://github.com/Polidea/RxAndroidBle#change-notifications\n. What about adding an overwrite parameter to setupNoticication and setupIndication methods?\nWhen user would want to set a notification after setting indication to the same characteristic and overwrite is false then nothing happens, otherwise a notification is set. The same would apply in other direction (setting indication after setting notification to the same characteristic).\n. @cbodin Actually my idea with overwrite was wrong. It could lead to unexpected behavior. One way would be to not allow to set notification after setting indication and vice-versa. There is no perfect solution that would make it easier for developer I think.\n. I agree, we could try to backport as much as we can but for now we should call new API methods on Lollipop and above and fallback to old one's on previous versions of Android.\n. Ok I've added monitors and used AtomicBoolean because synchronized should be used with final fields. Scan is not a thing that will be called really frequently (like in a loop) so I think that performance is not such a big deal here.\n. You're right, it will be pushed along with next release. Thanks for reporting.\n. This error means that your Observable emits items faster than you consume them. For now you can try to use one of the backpressure operators like onBackpressureBuffer and we'll check what we can do about it internally.\n. You are right, it shouldn't be there in the first place. Thanks for your contribution!\n. @SkaveRat could you provide information about your device and Android version?\n. @pfives I'm not able to reproduce this issue. I tried to run your sample and both calls:\nrxBleClient.scanBleDevices().subscribe(testSubscriber);\nand\nrxBleClient.scanBleDevices(AD_UUID).subscribe(testSubscriber);\nreturn correct value. Please recheck if you can reproduce the issue in the newest version of the library.\n. Thank your for reporting. I've reproduced the issue and it's now waiting for the review https://github.com/Polidea/RxAndroidBle/pull/62\n. Done, also I've rebased to current master in order to avoid checkstyle fail due to an unused import in other part of the library.\n. Hi, thanks for your contribution and sorry for the delay! In general it looks good, the only thing that I don't like is exposing RxBleDeviceMock and RxBleConnectionMock classes. Is it really necessary? What is your use case?\n. Looks good to me \ud83d\udc4d . @RobLewis Are you subscribing to the Observable<RxBleDevice> returned from scanForAS() method? I wasn't able to reproduce the issue and I don't see a call to subscribe() in your sample code. Calling scanBleDevices with or without parameters doesn't do anything except creating an Observable. You have to subscribe to it in order to perform a scan operation.. @RobLewis please make sure that all of the services that you're searching for are added to RxBleClientMock. If your RxBleClientMock doesn't have all of them then it won't return anything. Android BLE API works the same way.. Seems like it is. See this post from android-apt creator: https://www.littlerobots.nl/blog/Whats-next-for-android-apt/. Actually mock was not written with unit testing in mind. It's purpose is to allow working on Bluetooth stuff without having the actual device, but I agree that it could be better and making it work in unit tests would be great :). Can this workaround: https://github.com/Polidea/RxAndroidBle/blob/0819183381f1a2f2ebf1dd37aa46d748a0a87810/rxandroidble/build.gradle#L46 be removed now?. Sure, good point!\n. Do you mean checking if values are not null or maybe something like full mac address validation with regexp? If checking if values are not null, then which of them should be mandatory in your opinion? I was thinking about deviceName and deviceMacAddress, anything else?.\n. Some of the fields were generated by an IDE and some by hand, I guess I should clean this up a little.\n. Yes. Do you see a better way?\n. Good point, thanks!\n. Yes it is.\n. Good point. What do you think about making status volatile instead of using a monitor?\n. It would ensure that status value is the same across different threads. Also it's more lightweight because we would avoid context switching.\n. But it's something different I guess. Calling stopLeScan and then startLeScan is not bad. The bad thing is calling stopLeScan after a call startLeScan but before startLeScan returns.\n. I think you're right but such window is so small that it's almost impossible to run into such edge case. I think that volatile or a monitor will be enough. What about you @uKL ?\n. Yup but synchronizer requires object (it doesn't work with primitive types). And lint suggests that it should be a final object so a Boolean can't be used too.\n. I wanted to reuse a status object. But introducing additional one is an option too.\n. No, just autoformatter. Do you want me to revert it to the previous state?\n. Why not 27.0.2 (newest one at the time of writing)?. ",
    "uKL": "Looks good to me. What do you think @dariuszseweryn?\n. Please configure publishing settings in gradle.properties.\n. LGTM, merging.\n. Yes, this may be true, we will take a look. However ConcurrentHashMap may not be enough. We should synchronize whole read/create operation.\n. Issue will be fixed by https://github.com/Polidea/RxAndroidBle/pull/6.\n. True, same meaning. Without auto connect the system will throw BleGattException with detail code 133. This will happen after some timeout, various on different devices.\nWith auto connect it will wait until the BLE device is available.\n. Are you talking about RSSI received in a scan or from a connected device?\n. Please have a look at the example. Simple as that.\nbleDevice.establishConnection(this, false)\n    .observeOn(AndroidSchedulers.mainThread())\n    .flatMap(rxBleConnection -> // Set desired interval.\n        Observable.interval(2, SECONDS).flatMap(sequence -> rxBleConnection.readRssi()))\n    .subscribe(this::updateRssi, this::onConnectionFailure);\nhttps://github.com/Polidea/RxAndroidBle/blob/master/sample/src/main/java/com/polidea/rxandroidble/sample/example5_rssi_periodic/RssiPeriodicExampleActivity.java\n. Hey!\nStarting from Android 6.0 it is required to hold ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION in order to get scan results of device mac address. This is to strengthen user privacy. Even more, it is required that the user will have location services enabled.\nYou can read more here.\n. We handle it internally (both permission and enabled state) and BleScanException is emitted with code LOCATION_PERMISSION_MISSING or LOCATION_SERVICES_DISABLED.\n. Yes, you should handle them by yourself. It would be hard to do it in the library because each application has it's own design. Making an universal one might not be the best idea.\nThere are libraries for Runtime Permissions that might be a good choice for you.\n. Please have a look at this example where ConnectionSharingAdapter is used. Does it answer your question?\n. Thanks, good point!\n. Thanks Tomek!\n. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. This is true, the library does not handle indications yet. You are welcome to open a pull request :)\n. If you'd use same code don't duplicate tests. Just test what is new. Also I'd review the pull request itself for any bugs.\n. The library notifies you that the connection has been lost but you need to call establish connection again to reconnect. Is that the case?\n. This is expected behavior. Once disconnected you need to establish the connection manually again. Why do you think that it should be anyway different?\n. Could you provide code sample and preferably logs from RxAndroidBle?\n. Or maybe we could backport some of them... Worth considering.\n. Not yet. We are currently under a heavy load in the company and there are some delays :( You can take that three classes and it should work.\nhttps://github.com/Polidea/RxAndroidBle/tree/master/mockrxandroidble/src/main/java/com/polidea/rxandroidble/mockrxandroidble\n. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. I'm not sure if I get it correctly. Are you trying to write some data to a characteristic in a given order? If yes, you can just flatMap write operations and the order will be preserved.\n. @DKKovalev @ardmn Could you follow up?\n. Thanks!\n. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Hey, are you using proguard?\n. Hmm, what is your compile sdk, target, min sdk, build tools version and java version in gradle?\n. I did quick test for this issue\n```\n def \"should return filtered BluetoothDevice\"() {\n        given:\n        def serviceUUID = UUID.fromString(\"00001234-0000-0000-8000-000000000000\")\n        def rxBleClient = new RxBleClientMock.Builder()\n                .addDevice(\n                new RxBleClientMock.DeviceBuilder()\n                        .deviceMacAddress(\"AA:BB:CC:DD:EE:FF\")\n                        .deviceName(\"TestDevice\")\n                        .scanRecord(\"some scan record bytes\".getBytes())\n                        .rssi(42)\n                        .addService(serviceUUID, emptyList()\n                ).build()\n        ).build();\n        def testSubscriber = TestSubscriber.create()\n    when:\n    rxBleClient.scanBleDevices(serviceUUID)\n            .take(1)\n            .map { scanResult -> scanResult.getBleDevice().getMacAddress() }\n            .subscribe(testSubscriber)\n\n    then:\n    testSubscriber.assertValue(\"AA:BB:CC:DD:EE:FF\")\n}\n\n```\nAm I missing something?\n1. Added service does not affect advertisement payload in the mock\n2. Advertisement payload is somewhat transparent for mock but required (see above)\n3. Mock supports filtering.\nCould you provide a code snippet with your mock?\n. Ok, fun fact. Mock was not released to central yet (strange, we will do a release soon then @dariuszseweryn gets back from WWDC).\nHow did you build mocking support? It looks like we had this issue in earlier version but in master it should be fixed already.\n. Master is the newest one and it should work. Those three files is everything you need.\nI ran your test and guess what... it's passing :) What's in your getScanRecord() method?\n. Bluetooth Low Energy generally does not require bonding/pairing and the library doesn't support that. Why do you need to create a bond with BLE device?\n. I'll keep this issue and we will discuss internally whether it is within the scope. Thank you for your feedback! :)\n. Could you provide a code snippet, Android version and device?\n. Could you also turn on logging and provide ADB Logs? Best will be without package filtering because we may see system bluetooth logs as well.\n. This is true. Name advertisement is optional.\n. This does not consume errors, they are passed to subscriber anyway. You should handle them in subscribe method or use one of onErrorReturn/onErrorResume\n. @farmazon3000 for further reference go to:\nhttp://stackoverflow.com/questions/30250467/rxjava-what-is-difference-between-callbacks-in-doonerrorcallback-and-subscr\n. #165 . As a result of this issue, there will be a report of write operation benchmark (16kB) with nRF based mock device:\n\nWrite with native Android APIs (write with BluetoothGatt and direct use of BluetoothGattCallback)\nWrite with LongWriteOperationBuilder\nLooped writeCharacteristic operation of this library\nCustom operation with write with BluetoothGatt and response with RxBleGattCallback.\nCustom operation with write with BluetoothGatt and direct use of BluetoothGattCallback.. Good to go, I'm merging.\n. Dear Contributor,\n\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. How does your device get the pin then? Standard Bluetooth implementation requires to pair the device in a PIN mode (binding process), which is currently unsupported. You can always bind the device yourself using BluetoothDevice object and continue with the library then. Although pull requests are kindly welcome!\n. Hey,\nyou can use RxBleDevice#getConnectionState() to get detailed information about the lifecycle.\n. A few thoughts from me. I think that status should reflect the library state of readiness when the DISCONNECTED is received it should be safe to establish the connection right away. \nI think the current implementation is a little bit too optimistic in terms when it is emitted.\nThe correct logic is implemented within theRxBleGattCallback which reacts on the status from the onConnectionStateChange. It may be a good idea to rework status reporting at all to have one consitent source.. Hey,\nthanks for the input, we will review and comment soon :)\n. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Hey!\nWe are internally investigating how to align RxAndroidBLE with RxJava 2. We will update you as soon as it is feasible.\n. Actually, a good news is that for a few days this is already in progress in my local branch! Please stay tuned :). We are targeting with Rx java 2 for a 2.0.0 as it is a breaking change. Unfortunately, I stopped the development for a few weeks but I plan to get back to it next week.. 1.5.0 is on maven with rxjava 2 support.. @HolySamosa Hey! Actually, there are! @dariuszseweryn took over the change and we have some initial commits in the pipeline. . What's super cool is that the library emulates most features on pre-21 platforms. @dariuszseweryn did a great job to support this, you can use the API in API 18+.. Hey!\nSorry for the delay, we are between projects now and trying to keep up with the library.\nFirst of all, could you paste the documentation where it stands that results are replayed? That may be a mistake.\nOur idea was to share scan operations, with respect of a passed filter. However we didn't plan to replay past results to any future subscriber. You can expect that when you'll subscribe with a new subscriber you will get an update, once there is a new scan result.\nDo you think such feature might be useful? Could you provide some scenarios?\n. Hey! :)\nCould you follow up with explanation why did you decided to change it?\n. Hey @nightscape, would you be so kind to do some follow up to the question?. Looks good to me either. . I will merge this pull request and then apply some small changes. Thank you for commitment! :). Yes, I noticed that. We will address that issue :). Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Hey Orbyt!\nFor questions please use stackoverflow.com with a #rxandroidble tag!\nCheers!\n. In general, your understanding is correct. You'd need to discover services then use RxBleDeviceServices#getCharacteristic and check if BleCharacteristicNotFoundException has been emitted.\n. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. I think it's still invalid. I think it should be Build.VERSION.SDK_INT < Build.VERSION_CODES.N && autoConnect\nDariusz, what do you think? The compatible should be applied to pre-made when autoConnect == true.. That's right. I didn't see whole file on my mobile. I thought that reflection is in the connectGattCompat. I'd merge this one.\nShouldn't we have some tests for this logic? . Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Hey,\nthanks for the report. Did you check https://code.google.com/p/android/issues/detail?id=189090?\nIf that's true what you say, could you provide a pull request with this one changed, still with scanning working as expected? Thanks.. Thanks, this has been fixed in master! Please let us know if you'll find anything else.. Hey Rob!\nThanks for the report. You are more than welcome to contribute with a menu in the example.\nThe comment means that there are clever ways to maintain single instance of the client. For example you can use the Dagger with a application scope component. For more information about dependency injection pattern please go to https://google.github.io/dagger/. As this requires some radio transfer and blocks the radio, I think it should be exposed as a separate operation.. Currently there is no such feature. Feel free to contribute :). You can add an example to the sample project. It's up to you to open another PR or add it to this one. I prefer the first one as we have another change waiting to be merged after yours. :). Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Hey! Thanks for trying the library on Android Wear. Frankly speaking, we didn't test in on the Wear. Validators you are mentioning are strictly for Android. We will talk about it internally how we can resolve the problem.\nIf you have any ideas please don't hesitate to mention them.. Hey!\nThe fix you've proposed seems to bo only a partial workaround. It won't behave correctly when autoConnect flag will be set to true as the connection may take very long time.\nAre you able to reproduce the issue? It would be helpful to get some ADB logs with log level set to debug\nRxBleClient.setLogLevel(RxBleLog.DEBUG);. Could you also paste how you use the RxBleClient instance?. For now, from the logs, I can see that after the connection is established (with device 00:07:80:EA:A3:89) you are setting up a notification and it is successful.\n02-27 14:50:06.893 23106-23118/com.my_app D/BluetoothGatt: onSearchComplete() = Device=00:07:80:EA:A3:89 Status=0\n02-27 14:50:06.893 23106-23118/com.my_app D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n02-27 14:50:06.895 23106-25327/com.my_app D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(44899208)\n02-27 14:50:06.896 23106-25327/com.my_app D/BluetoothGatt: setCharacteristicNotification() - uuid: d1b41cde-dbf5-4acf-8679-ecb8b4dca6fc enable: true\n02-27 14:50:06.897 28614-28624/? D/BtGatt.GattService: registerForNotification() - address=00:07:80:EA:A3:89 enable: true\n02-27 14:50:06.897 28614-28745/? I/bt_btif: HAL bt_gatt_callbacks->client->register_for_notification_cb\n02-27 14:50:06.898 28614-28745/? D/BtGatt.GattService: onRegisterForNotifications() - address=null, status=0, registered=1, charUuid=d1b41cde-dbf5-4acf-8679-ecb8b4dca6fc\n02-27 14:50:06.904 23106-25327/com.my_app D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(119800995)\n02-27 14:50:06.905 23106-24563/com.my_app D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(62693809)\n02-27 14:50:06.906 23106-24563/com.my_app D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(44899208)\n02-27 14:50:06.943 28614-28745/? I/bt_btif: HAL bt_gatt_callbacks->client->write_characteristic_cb\n02-27 14:50:06.943 23106-23193/com.my_app D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=1ed50000-dbf5-4acf-8679-ecb8b4dca6fc status=0\n02-27 14:50:06.944 23106-24563/com.my_app D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(44899208)\n02-27 14:50:06.945 23106-24563/com.my_app D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(119800995)\n02-27 14:50:07.041 28614-28745/? I/bt_btif: HAL bt_gatt_callbacks->client->write_descriptor_cb\n02-27 14:50:07.043 23106-23117/com.my_app D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n02-27 14:50:07.047 23106-24563/com.my_app D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(119800995)\nThen the adapter is being disabled and the disconnect operation never finishes. I'll investigate more.\nOne more question. Where does the \"My MyApp: DISCONNECTED\" log come from?. Hello ZhanR,\ncould you please update this issue with the template provided? Please provide preconditions and the steps to reproduce the issue.\nThe library supports android 4.3+ so you shouldn't have problems. Please feel free to reopen with updated description.. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Just to mention that the API may be shared with the mock #370 . Hey, we've introduced a new method, where you don't have to provide the context. You can remove asBleServiceRef.. Hey,\nthis is an implementation question which is more suitable to be posted on StackOverflow. Please post a question and tag with rxandroidble tag. \nThanks!. How do you see the connection to be established otherwise than by calling the establishConnection method? This question looks to be a good candidate to be posted to StackOverflow with rxandroidble tag.. This shows you the Classic Bluetooth connection status, which is independent of Bluetooth Low Energy. In this case, just use establishConnection.. 1. If you'd do this when another connection with the same device is active you'll get an error.\n2. Check ConnectionSharingAdapter and our example project.. This was my first idea, with a few assumptions:\n\nOnly one callback listener can be plugged in at time\nIt sticks to a custom operation paradigm\nThe callback listener is disposed (null) at the end of the custom operation automatically to prevent leaks.\n\nWhat do you think?. To simplify the whole thing and avoid list iteration. In the scope of a single custom operation, I think it will be enough. What's your opinion?. Nope, I'm thinking about some abstract class implementing BluetoothGattCallback providing default, empty methods as templates. The user would be able to implement whichever callback required and only that one.. Hey Rob,\nall you need can be found in RxBleGattCallback#setNativeCallback Javadoc. The BluetoothGattCallback interface is documented in Android\u2019s documentation.. We need more data. Did you try enabling logs? Please have a look at RxBleLog class and it's static methods.\nDo you mean that the data that is sent out is different that you provide to a write function?. Fixed in master.. Hey!\nAre you sure that the log is complete? I don't see any ClassCast you've mentioned.\nCould you also post your addRxBleScanResult method? It looks like it's throwing an exception.. Could you also post \nAeroscopeDevice and handleRxBleScanError. I'd say it's somewhere there. First, there is a failure in onNext handling, then another one in onError handling.. Well, I think it may be something with the lambdas. Are you using retrolambda?\nMy concern is the line addAeroscopeDevice( new AeroscopeDevice( device, this ) );\n\nCorrect me if I'm wrong, is this method within a service? this should be an AeroscopeDisplay. Is it?\nIf so, please try replacing this with an explicit ClassName.this or remove lambda at all (just to verify replace with an anonymous class). Well, I'm not sure but it looks like a problem with lambdas. Please replace\n\n.subscribe(\n                    this::addRxBleScanResult,           \n                    this::handleRxBleScanError,         \n                    this::completeRxBleScan              \n            );\nwith \n.subscribe(\nnew Action1<RxBleScanResult>() {\n                        @Override\n                        public void call(RxBleScanResult bleScanResult) {\n                            addRxBleScanResult(bleScanResult);\n                        }\n                    },           \n                    this::handleRxBleScanError,         \n                    this::completeRxBleScan              \n            );\nThe log should be more clear then.. Thanks a lot. Great job addressing this bug! :) \ud83e\udd47 . Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. #174 . Hey!\nThe connection observable unsubscribes itself when the Bluetooth device is disconnected. If it didn't it means that the Android system didn't recognize that fact, that the connection was lost. \nWhat's your connection supervision timeout on the device? Maybe it's too big.. It's enough to have .takeUntil(disconnectTriggerSubject) as a disconnect trigger. Alternatively you can store the subscription and call .unsubscribe() on it.\nThe connection is automatically closed once the observable is unsubscribed, inversely the observable is unsubscribed (with an error being emitted) when the system recognizes that the connection is dead.\nPlease post verbose logs from that situation.. What I see in the logs\n\nYou start the scan looking for the device\nOnce the device is found you establish connection\nUnder the hood, there is a service discovery leading to a write operation\nThere are two writes to a characteristic (6e400002-b5a3-f393-e0a9-e50e24dcca9e)\nAfter the second write, I see something strange, it looks like there is another scan turned on just before the connection is disconnected.\n\nAre you sure the code you've posted is complete? I don't see any scannings.\nMy other questions suggestions:\n1. Please post onWriteSuccessPass\n2. Please post complete code, including the scan.\n3. Does it work without retryWhen?\n4. Please add doOnError log between establishConnection and takeUntil. I'm sorry but I'm currently involved in some other tasks. If you'll find any issues in the library please submit an issue. I suggest that you can get more RxJava support from the community at StackOverflow.. Is there any reason for this change? Does it fix anything?. It's not likely that we will go into the alpha version unless it fixes something important. In this case:\n- Jack toolchain is deprecated\n- We want to have API support 18+\nLet's wait for more stable version.. Did you try compiling from the console?. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. I'll reopen it anyway, we'll document it more in the future.. ConnectionSharingAdapter is going to be deprecated. Related to #379 . I think this should be closed in favor of #370. Feel free to reopen if you think otherwise.. Does the device advertise both UUIDs?. Both in the Android's API and in our library it is required that all UUID are matched for each filtered device. This is a standard Android's behavior but may be not so clear, so maybe we should add it to the documentation. Thanks for pointing that out.\nFor now, I see some options for you:\n\nScan without filters and use RxJava's filter. Parse the scan record yourself. You can take a look at the UUIDUtil class but keep in mind that it's internal.\nAs a small spoiler, we'll soon introduce more advanced filtering with the API based on API 21 but with compatibility package, which may be more suitable for you.. Could you provide example UUIDs of your devices and your filter setting?. Well, extractUUID returns 00001810-0000-1000-8000-00805f9b34fb and your filter setting requires that both 00001808-0000-1000-8000-00805f9b34fb and 00001810-0000-1000-8000-00805f9b34fb are present, which are not.\n\nWhat's the problem then? :). Thanks!. Hey,\ncould you post logs in a verbose mode?. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. @6bangs no, it's not recommended. When the operation is completed we are releasing the radio lock. Having multiple bluetooth operations not synchronized may cause abnormal behaviors.\nAnyway, the native callback is automatically released when the operation is finished. Is there any reason you wanted to use it that way?. I don't think so, I think we'll postpone it. It looks like there will be 1.5.0, then RxJava2, then new API.\nAm I right @dariuszseweryn ?. Dear @mikolak ,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. It still requires some slight changes but you can expect it will arrive soon.. Thanks for letting us know! It will be added soon.. Hey!\nThank you for contacting us. This seams to be a general question rather than an issue. Please ask on stackoverflow.com and add tag rxandroidble. @dariuszseweryn as far as I know we already do that. BleConnectionCompat is enforcing TRANSPORT_LE on AndroidM+.\nWould you like to go further and use hidden API introduced by the https://android.googlesource.com/platform/frameworks/base/+/b88fa824ab6337684de9aa8437c4952df4f1a75e%5E%21/ ?. It looks like it was introduced with 5.0.0 here: https://android.googlesource.com/platform/frameworks/base/+/android-5.0.0_r1/core/java/android/bluetooth/BluetoothDevice.java\nAndroid L preview didn't have it.. Bonding has it\u2019s own, separate call. There is a hidden createBond method, allowing to force bonding over LE.. Also better messages will be provided by #303 . Fixed by #303, closing.. @Cierpliwy Looks like this is the one we were talking about. Mentioning just to remember about it.. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Thank you for your valuable comment.. Hey,\nthis is a general question to the library usage. Please head to stackoverflow and tag your question with #rxandroidble tag.. It seems that this PR is a subset of #303, isn't it? I'll close this one in favor of #303. If you disagree please comment :) Thanks! Good job!. I'm ok with changing buildToolsVersion to 27.0.0 in the same PR. Good idea.. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. Related to #367 on the API level.. This is a huge list with some magic behind. So-called Bonding/Binding/Authorization/etc was already mentioned in #35 and I hope it will be included someday.\nThis list indeed could be a helpful source of ideas for new features. Are there any you/community is especially interested in?. Hey, \nthanks for using the library!\nFor questions about usage please select one of the desired options\n\nnon-commercial \u2014 head to StackOverflow tag #rxandroidble\ncommercial \u2014 drop an email to hello@polidea.com for more info\n. :+1:. Unfortunately, I agree :)\n\nThe current implementation is not the best. Let's leave this issue open as an entry point to mock redesign.. I'd keep it as it is possible to use it in unit tests. Certainly, it would be helpful if the framework would have some mocking/assertion engine. For example\nxxx.assertCharacteristicValue(xxxxx) or similar.. I think this should be closed in favor of #370. Feel free to reopen if you think otherwise.. Good spot! Could you make a pull request bumping rxjava to 1.3.2?. Thanks!. Hey! This looks like a general usage question. Please ask it on StackOverflow with #rxandroidble tag. Other people may get some help as well :). Dear Contributor,\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. @dariuszseweryn Ready to be checked again.. @dariuszseweryn Ready to be checked again.. Hey,\nfirst, for notifications, you should be using a setupNotification API provided by the library.\nsecond, are you sure that your characteristic supports notifications?\nthird, this is a general usage question. Please follow up on stackoverflow with #rxandroidble tag or contact hello@polidea.com for commercial support.. Good spot, I'll remove it. Instead, I'll provide skipJavaC configuration (will do the same the workaround does). There are issues that subjectively are a good start for new contributors.  Feel free to discuss on htthttps://gitter.im/RxBLELibraries/RxAndroidBle. Could you make a snippet of code and post what does \nlocationManager.getAllProviders() will print out?\nThe library expects either NETWORK_PROVIDER or GPS_PROVIDER.. Please share:\nlocationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);\nlocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);\nAlso, what is your target SDK?. It's strange because in the menu you have \"Device only\" which corresponds to GPS, not the network.\nIn available providers though, you have only \"passive\" and \"network\".\nWhat are your options when you press \"MODE\"?. It looks like your provider settings are reversed.\n \"High accuracy\" should enable GPS\n \"Device only\" should enable coarse location (network).\nEnabling location is required only in certain scenarios where:\n You are not an Android Wear device\n Your target and device SDK is >= Android M\nThis is to control user's privacy better (you're getting device MAC address, which you can use as a location tip).. This is to be considered if verification should be a configuration parameter for a scan. @dariuszseweryn What do you think?. Not sure, AFAIK you cannot disable \"passive\" at all from a menu setting.. Thanks for a very descriptive issue.\nI've seen the same issue but after I press \"Synchronize with Gradle\" the problem has disappeared.\nIt looks like Android Studio has some problems importing projects from repo directly when rootProject.name = 'rxandroidble-parent' is specified in settings.gradle.\nIt will work perfectly if you check out your project to a rxandroidble-parent directory.\n... or just synchronize your project with Gradle again after accepting the dialog.\n. Related Android Studio issue created https://issuetracker.google.com/issues/70710141. Thanks for using the library. Error status 133 may have various reasons as it is a general error reported by the Android system.\nIt feels like it is a general question, if so please post a question on StackOverflow with #rxandroidble tag, otherwise feel free to reopen this issue with logs and more information.\nFor commercial support contact at hello@polidea.com. Hey. Thanks for updating us.\nThis is related to https://github.com/google/dagger/pull/950\nWe'll let you know when the snapshot will have a workaround.. https://github.com/Polidea/RxAndroidBle/pull/343\nThe PR has been merged hence you can expect that the snapshot (1.5.0-SNAPSHOT) will work for you soon. Could you test it?\n  . https://github.com/Polidea/RxAndroidBle#snapshot. Pretty strange, could you show your build.gradle regarding dependency configuration? Do you use multi dex?. This part related to rxandroidble. I'd like to be sure that you didn't exclude transitive dependencies. (or just confirm it). Having used a transitive dependency is an antipattern anyways. The same was with the rxandroid when we removed it.\nIn case of the dagger, there is a small chance that someone is using it this way due to the compiler dependency. It has to be added directly.. Just to be safe we can go forward to 1.5.0 (we have changes related to operation timeout). I'm gonna need them soon anyway so we can go with 1.5.0.. Hey @JiWenBo, this seems to be a general usage question and should be asked on StackOverflow (so others may benefit from answers). Please post it there with tag #rxandroidble. For commercial support, you can reach us at hello@polidea.com. It should be in the snapshot you've mentioned.. I merged it at 9:47 UTC\nThe build ran at 9:57 UTC https://travis-ci.org/Polidea/RxAndroidBle/builds/352249008\nThis is the artifact rxandroidble-1.5.0-20180312.095700-24.aar\nhttps://i.imgur.com/g5uoxGV.png\nI believe your cache is fooling around :). I suppose tomorrow :) We're getting close to a release od RxJava2. FYI, we have gitter for chats :) https://gitter.im/RxBLELibraries/RxAndroidBle. It may lead to some confusion if for some reason we'd need to add something to the modules. Maybe let's ignore build/* within those?\n  . Done with the changelog.. @dariuszseweryn, refactored a bit.. Let me check the delegation, you may be right.. Actually no, since it's a static method it works.\n01-16 12:19:59.817 19756-19756/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED ScanOperationApi21(123696767)\n01-16 12:19:59.818 19756-19786/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED ScanOperationApi21(123696767)\n01-16 12:19:59.820 19756-20062/com.polidea.rxandroidble.sample I/RxBle#QueueOperation: Scan operation is requested to start.\n01-16 12:19:59.933 19756-19786/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED in 115ms ScanOperationApi21(123696767)\n01-16 12:20:07.645 21313-21313/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED ScanOperationApi21(64820451)\n01-16 12:20:07.646 21313-21328/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED ScanOperationApi21(64820451)\n01-16 12:20:07.649 21313-21349/com.polidea.rxandroidble.sample I/RxBle#QueueOperation: Scan operation is requested to start.\n01-16 12:20:07.767 21313-21328/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED in 121ms ScanOperationApi21(64820451)\n01-16 12:20:08.700 21313-21349/com.polidea.rxandroidble.sample I/RxBle#CancellableSubscription: Scan operation is requested to stop.. Is this what you meant?\n01-16 12:37:17.492 24123-24123/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ScanOperationApi21(39162453)\n01-16 12:37:17.494 24123-24151/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ScanOperationApi21(39162453)\n01-16 12:37:17.503 24123-24416/com.polidea.rxandroidble.sample I/RxBle#QueueOperation: Scan operation is requested to start.\n01-16 12:37:17.623 24123-24151/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ScanOperationApi21(39162453) in 131 ms\n01-16 12:37:20.843 24123-24416/com.polidea.rxandroidble.sample I/RxBle#CancellableSubscription: Scan operation is requested to stop.\n01-16 12:37:23.275 24123-25202/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(101216245)\n01-16 12:37:23.276 24123-24151/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(101216245)\n01-16 12:37:23.282 24123-24416/com.polidea.rxandroidble.sample V/RxBle#BleConnectionCompat: Connecting without reflection\n01-16 12:37:23.532 24123-24136/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n01-16 12:37:23.534 24123-24151/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(101216245) in 259 ms. Hey @martiwi !\nCould you tick \"Allow edits from maintainers\" in your PR? I not able to contribute to unit tests.. Ok, I was doing it wrong. :). Great job @martiwi! \nI've added some tests and fixed two issues + a documentation update. \n\nAdded tests for retries during long write operations\nFixed issue that caused the last batch to be written with incorrect data (empty byte array)\nAdded support for errors that were occurring when the operation was started (not from the gatt callback)\nFixed documentation incorrectly stating that the particular batch is skipped. Dear Contributor,\n\nsimilar to many open source projects we kindly request to sign our CLA if you'd like to contribute to our project. This license is for your protection as a Contributor as well as the protection of Polidea; it does not change your rights to use your own Contributions for any other purpose.\nYou can find a link here: https://cla-assistant.io/Polidea/RxAndroidBle. I think this should be closed in favor of #370. Feel free to reopen if you think otherwise.. @dariuszseweryn Ready for round 2.. Please ignore failing tests for now.. I've merged master into this branch so we have a feature parity now. @dariuszseweryn, I'm positive about releasing it as a 1.5.0. What do you think?. Please have a look at http://reactivex.io/documentation/operators/amb.html and keep in mind that amb in rxjava2 has different parameters than in rxjava1. Use ambWith or provide an iterable.. #377 . Hey, \nthat's great!\nWe're planning future versions, we'll get back to you probably next week with some proposals.. I meant extensions.. Thanks for analyzing the code :)\nThe algorithm is following:\n1. For Android < N or if autoconnect == true => go with a reflection-based setup, this fixes race condition related to a connection setup. Therefore true is forcefully passed.\n\nOtherwise, use connectGattCompat and\n2.1. For Android M+, use new API to force connection over Bluetooth LE (the device may support LE and classic BT at the same time)\n2.2. For older devices use TRANSPORT_AUTO\n\nFeel free to reopen if you find anything else that is related.. 100% correct, the issue was related to autoConnect = true.. I guess you're the one behind this StackOverflow question https://stackoverflow.com/questions/48888247/getting-already-connected-devices-from-rxandroidble\nThis seems to be a general usage question, so let's leave it on the stack.. Hey,\nI'm aware that on some devices the BLE device needs to be scanned at least once to co able to connect. This is related to BLE addressing and exchanging address times (@dariuszseweryn knows more).\nWhat kind of error code do you receive?. This is not helpful that much. This may be a good idea to introduce some compatibility mode when we'll have a new, more flexible setup API (@dariuszseweryn is working on it in his free time). I think making this a default behavior may not be the best idea.\nUntil then you can do something so silly like a retryWhen\n1. If exception is a BleDisconnectedException\n2. Use client to scan for devices, filtering for our mac address\n3. On the first matching scan result, resubscribe to connection\nOr you can try \"autoConnect\" flag, that may work as well. \n. This od not yet production ready. I\u2019ll clean things up next week & add some tests.. This branch is going to be abandoned. Logging will be extracted to provide more verbose information about operations.. We are going to deprecate ConnectionSharingAdapter and suggest usage of ReplayingShare in the future version.. Updated documentation on a ReplyingShare.. Thanks, I'll follow up probably early next week. :). Hey @GuillaumeBo, first thing. Here's a morning read for you https://github.com/ReactiveX/RxJava/issues/4811 There is a slight difference between doOnDispose and doFinally. I suppose you should use the latter.\nUndeliverableException mentioned in the log comes from a fact that in RxJava2 you cannot emit errors when the subscriber is no longer subscribed. This may be either an issue in the library or in your code - I don't know yet, I'll update this issue.. I've seen something similar coming from the inside of the library, I'll try to investigate it. . You've got the point. However, we'd like to manage the error propagation to verify if emitted errors are in fact ignorable or this was a mistake. We'll issue an update with a fix soon.. @NitroG42 Does it happen everytime you process this scenario? What is the device you are testing on?. @NitroG42 Snapshot 1.6.0 is rolling (will be available soon). Could you try it out?. I really struggle to reproduce your issue. I've used exactly your code and it's working flawlessly. Are you able to prepare a minimum mode to reproduce the issue, so I can run it in my Android Studio? Can you also try without the ConnectionSharingAdapter?\n@GuillaumeBo @eimermusic How about you Guys? Do you still see it?  . Yes, the warning is expected, I wanted to see if it is handled correctly. I'll remove/mask it before a release. Great news!. In fact, I aligned your example to work with a SensorTAG. The issue seems to be still there. I'll try to chase it down.. Guys, I've pushed some changes. The error is no longer visible on my side. Could you test on a snapshot? It should be available as soon as it is built.. Just to confirm, you are on a 1.6.0-SNAPSHOT, correct?\n. I believe you're not looking at master branch. It's already tryOnError (which in fact does the same inside).\nBeen there :). @NitroG42 Could you post logs again with the newest snapshot?. I'm going to close this PR as this is a reproducibility sample. I'll follow up with an explanation in the issue.. Thanks for pointing that out. I was aware anyway. There are more places requiring an update, I'll update them once this is merged to master.. Hi, this is a general usage question. Please use StackOverflow with a tag #rxandroidble. The issue tracker is for bug and enhancements.. Correct is com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT\nKeep in mind that rxjava2 is not yet finished and we'll update the README soon, before the release ;). Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. I'm unable to reproduce your issue. Please make sure that everything is right with your IDE. \n\nI cloned the repo to a new folder\nOpened up Android Studio 3.0.1\nOpened project\nBuilt the project\n\nResult:\nProject build without issues.\nFeel free to reopen with more data on the reproduction.. This is auto pairing provided by Android. I've seen devices that were not sending any callback from the BLE stack if the popup wasn't accepted. For the library it is transparent and we treat it as a timeout. However, some more logs may be helpful.\nThe library does not support bonding you when you'd implement it on your side, you could listen for a broadcast that would tell you that the request was rejected by the user.\nHope it helps.. Related to #35. Well, that doesn't say much. Call callback wasn't executed at all so the timeout occurred.. How would you see it working? Just imagine your perfect solution :). When user rejects or instantly when the user is asked to make a bonding?. I was thinking about it. Pausing the timeout and an onError when the user rejects. . We have no control if the system starts auto bonding or not. We can only request (with a classic BT scanning hack) the notification to be displayed in a form of a dialog, not a notification.\nI've seen some phones that were failing the write after positive bonding, requiring it to be retried - so this is not as straightforward as one can think.\nI think for the MVP we could try to listen for bonding related broadcasts and emit meaningful errors. I'll think about it.. Yes, that's mostly the case why we didn't have bonding support from the beginning, it's tricky.\nLet's follow up in #35.. Anyway, I agree that we could add @throws BleAlreadyConnectedException with some description to the establishConnection method. . Good to know :). Do you observe it on a Huawei or Samsung? I've seen similar issues before, especially on BLE devices with complex characteristics.. Unfortunately, I do not have any solution for you yet. I've seen similar issues (on Huawei) and from the BLE Snoop Log, downloaded from the phone I was able to see that just after the connection is established, Android tries to do a service discovery, traversing all the services, characteristics and descriptors. \nIf I did any write operation just after during that period, the connection was no longer operational...\nonClientConnParamsChanged is automatically triggered by Android and we have limited control over it.\nIt would be hard to get any ideas without the device to test on. Maybe @dariuszseweryn will have some more thoughts.. Not really, as far as I remember your case was related to establishing the connection, not the connection becoming unresponsive.. Were you receiving a positive connection callback? AFAIK no, correct me if I'm wrong.. We suspect that this problem may be on a peripheral side or the Android side. We ran out of ideas. If you'd like to debug more, feel free. We'd be happy to introduce a fix if you open a PR.. The ScanActivity has some filters applied by default. Please have a look at the master branch where this filter has been disabled.\n. Could you elaborate more on it? I don't understand what you mean.. Closing due to inactivity. Feel free to reopen with a detailed information on your issue.. Discussed changes were applied.. Glad you did it :D. Thanks, I'll have a look at it.. @warko-san @michaelnimbs What is your RxJava2 version in a build.gradle?. I'm seeing this issue with RxJava 2.1.11 (https://github.com/ReactiveX/RxJava/commit/8a6bf14fc9a61f7c1c0016ca217be02ca86211d2) this commit changed how the queue is initialized. For now, I suggest staying with RxJava 2.1.10. I'll try to find out why it happens and submit an issue to RxJava repo.. I'll work around this. The issue is that some of our custom Observables do not call onSubscribe on an Observer in a specific order. According to a contract the onSubscribe call is optional. What's more\nAn Observable may begin issuing notifications to an observer immediately after the Observable receives a Subscribe notification from the observer.\nwhich assumes that the Observable may start emitting within the subscribeActual method.\n@dariuszseweryn I'm pushing it directly to master without a PR due to criticalness. Please have a look once you're back. :). @michaelnimbs Please retest with the most recent snapshot (currently building) and the newest RxJava.. https://oss.sonatype.org/content/repositories/snapshots/com/polidea/rxandroidble2/rxandroidble/1.6.0-SNAPSHOT/\nCorrect.. @dariuszseweryn I applied the required changes. Could you have a look?. Thanks!. Hey!\nThat's a good idea! \nI don't see any reason why we couldn't merge it. Just one small comment, please sign up out CLA, then we'll be able to merge it.. We are struggling with tests execution, so we'll merge it as it without the travis-cs/pr check.. Closing due to inactivity. Feel free to reopen.. That's not generally a mistake but some of Huawei's misbehave like that. I've experienced it before as well.. This is correct, in my case 250ms was enough for all devices that I had tested on. Worth noting, thanks!. LGTM, just as @dariuszseweryn mentioned.. Passing null here will effect in casting error (int) null.\n. There should be some validation of data provided to a builder.\n. What if I want to add more characteristics to the service?\n. Can we have something like:\nrxBleClient = new RxBleClientMock.Builder()\n                .deviceMacAddress(\"AA:BB:CC:DD:EE:FF\")\n                .deviceName(\"TestDevice\")\n                .rssi(42)\n                .addService(\n                        UUID.fromString(\"00001234-0000-0000-8000-000000000000\"),\n                        new RxBleClientMock.CharacteristicsBuilder()\n                                .addCharacteristic(\n                                        UUID.fromString(\"00002a29-0000-1000-8000-00805f9b34fb\",\n                                                \"SomeData\".getBytes(),\n                                                new RxBleClientMock.DescriptorsBuilder()\n                                                        .addDescriptor(UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\"), \"SomeDescriptor\".getBytes())\n                                                        .build()\n                                        ).build()\n                                ).build()\n                )\n                .addService(\n                        UUID.fromString(\"00001235-0000-0000-8000-000000000000\"),\n                        new RxBleClientMock.CharacteristicsBuilder()\n                                .addCharacteristic(\n                                        UUID.fromString(\"00002a29-0000-1000-8000-00805f9b34fb\",\n                                                \"SomeData\".getBytes(),\n                                                new RxBleClientMock.DescriptorsBuilder()\n                                                        .addDescriptor(UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\"), \"SomeDescriptor\".getBytes())\n                                                        .build()\n                                        ).build()\n                                ).build()\n                )\n                .build();\n?\n. We can go with snapshot version.\n. deviceName is actually optional but rssi, mac address, scan record looks like mandatory parameters.\n. +1\n. Needs to be removed before merging.\n. Change to 1.0.1.\n. duplicated dependency?\n. It'd be nice to have POM_DESCRIPTION\n. Dot at the end.\n. A mocked RxBleClient.\n. empty line\n. discoverableDevices?\n. Exception message should suggest which methods the developer should use.\n. How do you ensure that getAdvertisedUUIDs() won't return a copy of the list? I suggest adding dedicated method to RxBleDeviceMock.\n. @NonNull \n. @NonNull \n. White in the doc when the Observable will be subscribed.\n. @NonNull \n. empty line\n. Would be cool to see in the JavaDoc of each method it it's optional or not.\n. why not just \"int\"?\n. discoverableDevices\n. Why not:\nObservable.from(availableDevices)\n.filter....\n?\n. empty line\n. Why do you defer?\n. Throw IllegalState or UnupportedOperation if mock is not configured for a given device.\n. Why do you need a connector at all?\n. remove \"d\"\n. Missing @Override\n. We don't need synchronization for mocking purposes. Multiple observables can be created safely here. It will reduce mock complexity.\n. Use Observable#just\n. double space\n. You sometimes did finals sometimes didn't. Why?\n. Share is not required here.\n. I think what you want to defer is just discoverableDevices.value(), do you?\n. This is wrong, current implementation requires all filterServiceUUIDs to be contained by the advertised device not just one.\n`\nprivate boolean containsDesiredServiceIds(byte[] scanRecord) {\n        List advertisedUUIDs = uuidUtil.extractUUIDs(scanRecord);\n```\n    for (UUID desiredUUID : filterServiceUUIDs) {\n    if (!advertisedUUIDs.contains(desiredUUID)) {\n        return false;\n    }\n}\n\nreturn true;\n\n}\n```\n. Never mind, I misplaced the bracket :)\n. int here as well I think\n. Looks like whole doOnUnsubscribe block is a duplicate (look at dismissCharacteristicNotification and its use)\n. cache and share not required here, it is replayed and refCount later\n. ObservableUtil#justOnNext\n. Extract constant\n. Is this cast required?\n. Use .map instead\n. Error will never happen in this mock, can be removed.\n. empty line\n. Addapply from: rootProject.file('gradle/gradle-mvn-push.gradle'). What aboutisScanStarted?\n. Stopping and starting should be synchronized (on status), plus startLeScanStatus should be set to false after the scan is stopped.\n. If you are synchronizing whole block then atomicboolean seems to be not required anymore.\n. You can go with private final Object lock = new Object[0]\n. Is it possible that the MTU will be changed by the device?. Our checkstyle cries because of empty statement. In this case it's not relevant but please satisfy it either by adding some action, removing some code or adding checkstyle ignore as this is an example only.. As far as I understand it requires API Level >=21 to use it. I think it would be convenient if the documentation would state that plus there may be an exception likeApiNotSupportedException(int apiLevel)`. @dariuszseweryn what do you think?. That's why putting checkstyle ignore would fit in this case :). I'm asking because if that's possible then with cache the method may return old values, which is no longer valid.. One more thing. The method name suggests that this is one time operation, I mean that it will emit provided device and will not affect future scans. By use of a ReplaySubject each device is stored and then magically replied during following scan operations.\nMaybe we could have to separate configurations. Static - configured when the mock is instantiated (stored in discoverableDevices) and dynamic, on demand. You may use a PublishSubject instead and do following in line #291\ndiscoveredDevicesSubject\n.startWith(Observable.from(discoverableDevices)). That's a good idea :) What I'd do is to provide an observable to the mock. In the builder there would be two options:\n\npublic Builder addDevice(@NonNull RxBleDevice rxBleDevice)\npublic Builder setDeviceDiscoveryObservable(@NonNull Observable rxBleDevice)\n\nThen the builder with pass merged data feed to the mock. This would be really flexible and easy to use.. enqueued. The operation is a public API, I think we should validate whether it behaves as we expect and check if returned value in not null.\nResult of the assertion should clearly state the problem.. I think the default operation timeout should also apply to custom operations.. Remove blank line please.. Is there anything in terms of locking the radio permanently we should add to the JavaDoc then? Possibly if this observable wouldn't emit, we will get stuck. This is not so obvious for someone reading the documentation.. Why did you use flatRadio.semaphore.isReleased() >> true here? flatRadio is not a mock. I think you can skip >> true this part.. Shouldn't the semaphore be released as well?. Yeah, I think so as well :). - is not required here.. isIndication == withAck is not clear for me. If I'd be a new to this domain I wouldn't know when it will be true.. Observable#just should be enough. Called method is not nullable.. Oh, I'm sorry. I mixed up with justOrEmpty.. What do you think if the name would suggest what this class does? Basically that it's a pass through.. It's not obvious that the method returning a suggestion is also modifying the state of the checker. I think that this method should idempotent and there should be a method to alter the state.. Something like a fixed size stack seems to be cool https://stackoverflow.com/a/16206356. It's not really declarative that we inject Action1<RxBleConnection.RxBleConnectionState> here. Can we have it wrapped in a custom interface saying that this is a connection state dispatcher? \nLooking from a test/user perspective it wouldn't say much about this parameter.. I think it would be nice to inform on the nature of the checks. That they are related to permissions.. We need a documentation for public methods. (like in RxBleConnection). Missing JavaDoc?. I agree.. Redundant backet. I agree that there should be a model separation. The method should check whether preconditions are correct and the result should be described by the caller.. Moreover, the point where the check happens is inconsistent. Sometimes it happens even before the operation is enqueued and sometimes not (when it's required to perform discovery in order to get the characteristic object). I guess it's more like permited or allowed than possible, right?. or even supported if I'm reading correctly from the context.. More like an util. What do you think about extracting it?. I'd prefer the checker to return the model with the report, rather than to pass it to a method that needs to be overridden. @dariuszseweryn what do you think? It's easier to test then.. Small but pricy optimization. You can inline check from line 282 (and extract to a method) to avoid code execution when it's not required.\nIn this example the second check will be executed regardless the first one (even if deviceName matches).\n. Well, the first thought is \"Why do I need an int?! It's ugly.\". If we'd have an API to read properties more easily.. I think further optimization is out of scope for this pull request. We should have a separate PR for optimizations if you think they are necessary.. the name suggests a mock for mockUuid but it's null.. too many spaces. What stands for 0?. Is subscriber used anyhow?. Is subscriber used anyhow?. Is subscriber used anyhow?. Remove empty line. Please make attributes final, just in case.. I still think generating a message is not in scope of the checker, it should be a separate util class.. Why is there a space at the beginning?. Is it documented that the method may throw IllegalArgumentException? It will be passed to the public API.. In the ConnectionSetup it still says \"marker\". In fact it does not throw, it emits BleIllegalOperationException. Actually this is incorrect. Dagger will provide you a new instance of the executor each time you ask for it. You seems to be closing an instance that wasn't even started and you're leaving started service as is. \nProvided executors should be scoped.. You are correct, I missed the annotation @ClientScope. I'm not sure if synchronization is required here. The only thing this method does it creating an Observable instance. It doesn't have to be synchronized (no shared resources). +1. Scan is started when the Observable is subscribed and stopped when unsubscribed. I prefer like this.. +1. That's correct, there is a dependency between sentences.. Can we have the address only? We don't need the BluetoothDevice.. As a matter of fact, did we analyze if this observable is unsubscribed at some point of time? autoConnect is a risky operator.. Do we need replay & autoConnect at the observable here or just when listening for adapter state?. Is there any reason to accept BleException here? I can see that only two options are possible here. Maybe there should be a method to report:\n\nBleDisconnected\nBleGattException. Isn't a BehaviorRelay enough at the source?. BleException is a general purpose exception. Form interface point of view it's not consistent with the class role - to route disconnections. I suggest names like \"on ble disconnected\", \"handle gatt excption\".. Ok, agreed.. This is equivalent (i think better readable)\n\nrxBleRadio.queue(operationConnect)\n                        .map(new Func1<BluetoothGatt, RxBleConnection>() {\n                            @Override\n                            public RxBleConnection call(BluetoothGatt bluetoothGatt) {\n                                return connectionComponent.rxBleConnection();\n                            }\n                        }). At first, this is a good spot that the field is not updated properly, however, the proposed fix is a big NO-NO by design. I dislike the fact that there is some kind of logic in the constructor.. I'm thinking of a place, where we could put it and I think the ConnectorImpl layer is the best place. Its responsibility is to wire up the connection state.. Do we need retryWhen here? Isn't a retry enough?. The assumption on object lifecycle from within the object is generally not a good pattern, even if in this case it's true.. What is the reason of injecting an AtomicInteger rather than creating it in place? It seems to be only a container for a state. It's more like an implementation detail and should be hidden.. Does it have to be atomic? Do we expect concurrent updates from different threads?. What is the scenario for retry() is required at all?. Would it be updated if no one is listening to this completable?. This is acceptable but I'm thinking about some better way. This introduces API of a Completable that doesn't do anything but stays subscribed. Is there any good way to watch for connect/disconnect events and notify MtuWatcher to subscribe/unsubscribe from the MTU changes? This would be more descriptive that merging with a magicCompletable.. MtuWatcher or just MtuCache?. Why is manual state management bad? I think it might be more descriptive.\nIf you want to stick with this solution I would name the method some other way. It should clearly say that it is responsible for the watcher state.. ok. Do we need empty lines here? In other places, we don't keep them.. Good idea.. Please remove empty line.. Can we have it extracted to emitErrorWhenAdapterIsDisabled or similar?. Shouldn't it rely on the initial state as well?. What does it mean 'asExactObservable'? :) \ud83d\ude03  Could the method say something about the behavior?. Effectively volatile is not required here because of synchronization. Having synchronized access guarantees that the other thread will read the value after the previous has written it.. ok. Correct, I'll update in another commit.. Correct, I'll update in another commit.. No, a bug. Will revert.. It's ok for me. . ok. ok. ok. or other functions associated with device interaction.. I'm always hesitant when I see this. Is it a dependency or part of the logic? If a dependency then it's a good idea to inject, if a logic then not. \nI think that SDK_INT is a dependency here.. Do you know any good patterns to distinguish?. I think it deserves RequiresApi as it shouldn't be called on earlier APIs.. I believe this is equivalent to ObservableUtil.justOnNext(true). I'm okay with .v level. I'd go for an additional flag if this would require an operation to be performed for logging, so the user could decide about the flow. In this case (passive) I'd stick with verbose level. Would that be ok?. I believe that Darek meant putting a reset in a doOnNext. AFAIK you can safely reset the counter before the rx subscription (around line 86.). The biggest question here is to:\n1) Define what data one will need to decide on a retry\n2) Smart way to extend that data without breaking the API in the future (DTO? @dariuszseweryn). You're reading in my mind :). Good point, it was added at the point of first commit (3 months ago?). Will update.. Correct, this was to allow a temporary release of the snapshot.. ok, will remove this function and add a changelog entry.. I assume this is temporary and won't be on the master. I'll change it to a 1.5.0. In order to avoid unused parameters. I'll change it to a Consumer, equally fine.. I wouldn't be so sure. How would you get the data, given in a GATT callback after a write?\nThe documentation says\nIf this callback is invoked while a reliable write transaction is in progress, the value of the characteristic represents the value reported by the remote device. An application should compare this value to the desired value to be written. If the values don't match, the application must abort the reliable write transaction.\nWhat do you think about it?. ok. ok. ok. Observable. done. What do you mean?. Could you provide something more descriptive?. We can at least make it deprecated. I've never done it either.. It is however used internally.. True, I agree 100%. \nhttps://github.com/Polidea/RxAndroidBle/issues/378. ok. This is probably true but you have more knowledge about this. I'd put it in to another PR. Actually, that wouldn't be that much convenient.. I'd like to stick to the scope but I'll put a task for it. https://github.com/Polidea/RxAndroidBle/issues/379. https://github.com/Polidea/RxAndroidBle/issues/380. :+1:. Correct, my mistake. Removed due to some temporary compilation issues.. ok. ok. This is more like \"how to use Gradle\", isn't it?. I don't want to, be honest :) getCharacteristic is a Single now and this won't work I guess.. right. If I'd change it to completable then there wouldn't be any way to get the data back from the write.\nSomeone can currently use a custom operation and execute beginReliableWrite.\nI'd keep it and maybe rethink if in the new API.. Data size 5, batch size 2, failure at the last batch (3rd)\n(int) Math.ceil(5 / (float) 2) => 3\nData size 6, batch size 2, failure at the last batch (3rd)\n(int) Math.ceil(6 / (float) 2) => 3\nData size 5, batch size 3, failure at the last batch (2nd)\n(int) Math.ceil(5 / (float) 3) => 2\nIs this what you wanted to check?. It returns the \"number\" which I assumed starts from number one. LongWriteFailure also assumes \"number\". Do you think we should switch to zero-based indexes?. Oups, my mistake from permissions testing... \ud83d\udc4e . You're right.. Yes, should be status. Do you think that we should keep exception constructors as a part of the public API? If so, I can create a new one and deprecate the old one.. I like it how you've delayed subscription!. \ud83e\udd22 Better to have no tests than not working tests that you don't know they don't.. How about?\nThe operation was about to be run but the observer had been already disposed. Could you also extend the OperationConnectTest so it tests configurable timeouts? Currently it only has the should emit BluetoothGattCallbackTimeoutException with a valid mac address on CallbackTimeout. > Keep in mind that it will cancel the library's connection only and may leave Android's BLE stack in an inconsistent state.\nThis does not apply to connections. Each connection attempt is disconnected and then closed when the connection subscription is released. Please update the documentation.. I suppose that the @Override shouldn't be commented out. It applies to the method below which is related to the new API which is not yet public.. The only thing it does it that it returns an instance that was injected through a constructor. No other interactions. I think it's not worth testing.. I'm gonna revert this change anyway. This is not relevant to a change we're introducing.. This may be a good idea if we'll be introducing a new example dedicated to filters.. Sure. Sure it can. I'm wondering if you shouldn't mention why the default value oscillates around 30s. This is the duration after which Android would timeout internally anyway (in direct mode).. Maybe we could use AtomicReference instead?. Is it safe? If you cache you give up the possibility of disposing of the observable.. ",
    "dariuszseweryn": "I'm not really convinced that Mocking functionality should be introduced in this project. Maybe some kind of extension would be better (like rxjava and rxandroid -> rxandroidble and rxandroidblemock)\n. Lambdas are just a syntax sugar. You can read about them here: https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\nYou can find a lot of articles about lambdas on the Internet. ( https://blog.idrsolutions.com/2014/10/5-minutes-explanation-java-lambda-expression/ )\nLong story short - instead of writing boilerplate in anonymous implementation of the interfaces with only one method / function you use lambda which is shorter to write.\n. With Pawe\u0142 we will think how to handle situations where user would set a notification after setting indication to the same characteristic. Edge case - never the less needs to be addressed somehow. With your current proposal first setter would win and the second one would end up using the first one.\n. We will go with emitting an exception when the indication is being set after notification was already setup (or vice-versa). We are discussing the best API still though. The code should be available within this week.\n. The setupNotification would return an Observable that will emit BleCharacteristicNotificationOfOtherTypeAlreadySetException. (Long name...)\n. Added support for the indications with commit: https://github.com/Polidea/RxAndroidBle/commit/f69ce78b18f635d23efc9b71e06c3e6e7d87d1c9.\nA new release will be made after we will fix the bugs found. For the moment you can use the snapshot: compile 'com.polidea.rxandroidble:rxandroidble:1.1.0-SNAPSHOT'.\n. What I see is that you're trying to reuse a Subscriber here and that is a misuse as the Subscriber is stateful and therefore cannot be reused. It was already failed once and is probably unsubscribing automatically.\nYou can try either to create a new Subscriber for each subscription or to use an Observer instead - which is stateless.\n. We are aware of the new scanning API. Thank you for showing your approach - we will check it.\nPersonally I was thinking about more universal approach in the API and just omit the settings that are unavailable on API < 21.\n. Just added the new scanning API to 1.3.0-SNAPSHOT. Feel free to check it out.. Should be fixed in https://github.com/Polidea/RxAndroidBle/commit/4d92c4fc15bc97862c65cefcd76d9b3d33604dc7\n. Hello,\nExcuse me for a long response time. This bug is on top of my priority list and it should be fixed in the snapshot release next week. I am on WWDC at the moment and I almost have no time during the evenings.\nBest Regards\n. I am a bit strained with projects at the moment. I found out that on some devices it is possible to successfully call connectGatt() even when the Bluetooth is off. I am checking different approaches to this situation.\n. This issue should be fixed in the current Snapshot release.\n. Mock client is now available:\nhttps://oss.sonatype.org/#nexus-search;quick~rxandroidble\nBest Regards\n. @pfives - as @mzgreen has proposed - you should either use onBackpressureBuffer or any other operator that suits best your needs (checkout https://github.com/ReactiveX/RxJava/wiki/Backpressure ). If we would have implemented any specific handling of the backpressure in the library someone other's usecases would not be covered.\nHave I answered your question?\n. Should be possible to use RxBleDevice.getBluetoothDevice() in the next snapshot of the library.\n. Hello there,\nCan you share which BLE device you're connecting to?\nD/BluetoothGatt: onClientConnectionState() - status=8 clientIf=5 device=C4:xx:xx:xx:0A:9F -> status 8 is a timeout error as far as I know and it seems that your BLE device is stopping to keep the connection alive.\nThe error comes from the Android Bluetooth API and the RxAndroidBle cannot really do much about it.\nPerhaps you're forgetting to set some configuration on your BLE device that would make it to continue the connection?\nBest Regards\n. Correct me if I am wrong - you're not getting any notifications about the changes from the device even though you should. Am I right? If yes - could you also paste the code that you use for setting up the notification?\n. I was digging through the documentation and issues that people encountered. I have double checked and found out that I was wrong. Actually status 8 is \"Insufficient authorization\". Probably you should have bonded device.\nHere are some status codes that may be useful: https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-4.4.4_r2.0.1/stack/include/gatt_api.h\nCurrently RxAndroidBle doesn't help in support of bonded devices / encrypted connections. Pull Requests are encouraged though. ;)\n. Hello there,\nI have a few questions:\n1. is the issue reproducible?\n2. what device do you use?\n3. could you show the code snippet you execute?\nBest Regards\n. Finally I had some time to dig up your situation. I have checked Google for the java.util.concurrent.RejectedExecutionException and found this article: https://examples.javacodegeeks.com/core-java/util/concurrent/rejectedexecutionexception/java-util-concurrent-rejectedexecutionexception-how-to-solve-rejectedexecutionexception/\nAs I don't see in the stacktrace any indication that the exception is being thrown anywhere in the library itself I suppose that there is some problem with too many things happening on the Android main thread. Have you checked what would happen if you replaced yours runOnUiThread(this::notificationHasBeenSetUp) and this::onNotificationReceived, this::onNotificationSetupFailure with simple Log.d() statements?\n. I might have an idea what is the problem. in RxBleCallback the callbackScheduler is a Schedulers.newThread(). Changing it to Schedulers.computation() may solve the problem.\n@Stjerndal Do you work with the sources or do you use maven to get the dependency?\n. @Stjerndal @Reyurnible \nI have changed the Scheduler in RxBleCallback to Schedulers.computation() - this should fix the problem. The fix is in the current SNAPSHOT release. Could you take a look?\ncompile \"com.polidea.rxandroidble:rxandroidble:1.1.0-SNAPSHOT\"\n. Please give a feedback here so we will know what's the status.\n. Glad to help. It will be officially available in 1.0.3 release.\nThat's a known bug. In my opinion it's related to the wobbly Android BLE Stack - sometimes it happened to me if the gatt connections weren't disposed properly but it shouldn't be a problem now. If you will have any ideas - feel free to create an issue.\nIf you encounter this situation next time you can try switching off BT and Wifi then switching them on as BT and Wifi stacks on Android are partially shared.\nBest Regards\n. Hello there. Sorry for no response - we're discussing how to address this issue. Usually any error during communication means the connection is no longer active and usable. We will get back to you.\n. Hello @asmirsabanovic \nA workaround would be not to pass status to observables different than the one that emitted it.\n. You would need to make some changes in the RxBleGattCallback class. The point is not to pass the status error around via statusBehaviourSubject.\nI don't have any experience with bonded devices. Can you confirm that the RxBleGattCallback.onCharacteristicRead() is postponed after the user enters pin? Can you share what device are you using (or is it possible to get one to test the library myself). Could you be so kind and paste these two classes to your project:\n```\npublic class DeviceBondingResult {\npublic final BluetoothDevice device;\n\npublic final int previousBondState;\n\npublic final int currentBondState;\n\npublic DeviceBondingResult(BluetoothDevice device, int previousBondState, int currentBondState) {\n    this.device = device;\n    this.previousBondState = previousBondState;\n    this.currentBondState = currentBondState;\n}\n\nprivate String bondStateString(int bondState) {\n    switch (bondState) {\n        case 10:\n            return \"BOND_NONE\";\n        case 11:\n            return \"BOND_BONDING\";\n        case 12:\n            return \"BOND_BONDED\";\n    }\n    return \"UNKNOWN\";\n}\n\n@Override\npublic String toString() {\n    return \"DeviceBondingResult{\" +\n            \"device=\" + device +\n            \", previousBondState=\" + bondStateString(previousBondState) +\n            \", currentBondState=\" + bondStateString(currentBondState) +\n            '}';\n}\n\n}\nand an Observable\npublic class DeviceBondingObservable extends Observable {\nprotected DeviceBondingObservable(Context context) {\n    super(\n            new OnSubscribeFromEmitter<>(emitter -> {\n                final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {\n\n                    @Override\n                    public void onReceive(Context context, Intent intent) {\n                        final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);\n                        final int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1);\n                        final int previousBondState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, -1);\n                        final DeviceBondingResult result = new DeviceBondingResult(device, previousBondState, bondState);\n                        Log.d(\"TEST\", result.toString());\n                        emitter.onNext(result);\n                    }\n                };\n                context.registerReceiver(broadcastReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));\n                emitter.setCancellation(() -> context.unregisterReceiver(broadcastReceiver));\n            },\n                    Emitter.BackpressureMode.BUFFER)\n    );\n}\n\n}\n``\nSubscribe toDeviceBondingObservableand paste the logs from a bonding procedure that you execute? I then will have some material to think about how to integrate bonding support into the library.. Finally this should be fixed / available in1.3.0somewhere this week. Is available on1.3.0-SNAPSHOT` now.. I think this question should go to www.stackoverflow.com with #rxandroidble \nIf I understood you correctly - you just want to perform some data exchange between the device and the app before something else will happen. In this situation you can write your own connecting function like:\npublic Observable<RxBleConnection> establishConnectionToMySpecificDevice(RxBleDevice device) {\n  return rxBleDevice.establishConnection(this, false)\n    .flatMap(rxBleConnection ->\n        rxBleConnection.writeCharacteristic(uuid, bytes)\n        .flatMap(bytes -> rxBleConnection.readCharacteristic(uuid))\n        .map(bytes1 -> /*do something with read bytes*/ rxBleConnection)\n    );\n}\nAnd use it wherever you need in the code?\n. The answer is to unsubscribe from the scanning as soon as you're no longer interested in it. For instance if you're interested in connecting to a fixed amount of devices that are meeting your requirements:\n```\nCompositeSubscription compositeSubscription = new CompositeSubscription\nSubscription scanSubscription = rxBleClient.scanBleDevices()\n  .filter(scanResult -> / filter the devices you're interested in /)\n  .take(/ number of devices you want to scan /) // this operator will automatically unsubscribe from scanSubscription once the number of scanResults will be taken\n  .map(scanResult -> scanResult.getBleDevice())\n  .subscribe(bleDevice -> connectToDevice(bleDevice))\ncompositeSubscription.add(scanSubscription)\n```\nwhere:\nvoid connectToDevice(RxBleDevice device) {\n  Subscription connectFlowSubscription = device.establishConnection(context, false)\n    .flatMap(connection -> /* do what you need to do */)\n    .subscribe()\n  compositeSubscription.add(connectFlowSubscription)\n}\nand you should clear the compositeSubscription when you're no longer using the app. For instance onPause of the Activity.\n. Unsubscribing from connection subscription should take place once you're no longer interested in connecting.\nFor instance - sometimes you're interested in showing the device state in the Activity. In this situation you should unsubscribe from the conSubscription in onPause() method. \nSometimes the application needs to execute a specific flow when connecting to the device and then it's done - let's say we want to read a value from a characteristic and disconnect:\nrxBleDevice.establishConnection(context, false)\n  .flatMap(connection -> connection.readCharacteristic(characteristicUuid))\n  .take(1)\n  .subscribe(readBytes -> /* do your thing with readBytes */)\nIn this situation the establishConnection() subscription will be automatically unsubscribed by the take(1) operator. We can do it this way if we're not updating anything UI related inside an Activity which can be destroyed b the time the readBytes will be available,\n. @zzt93 - Excuse me but I cannot really follow you. Could you rephrase the question?\nThe RxAndroidBle library is for client side only. So the client knows what to read from the server or it waits for read notifications usually. The implementation of the server may vary greatly so it is hard for me to know what you have in mind.\nBasically .take(1) takes exactly one event from the above observable and unsubscribes from it. Unsubscribing from .establishConnection() closes the connection. .readCharacteristic() is returning an Observable that will emit only once.\nDoes it answer your question?\n. You cannot directly connect two Android devices to each other because the RxAndroidBle is a client library and BLE connection is a client-server connection. Android has introduced BLE server API though it is not covered in the library.\nEither way both readCharacteristic() and writeCharacteristic() are client initiated, one-time, actions.\n. In the first block what would happen is:\n1. rxBleConnection would be established\n2. once the rxBleConnection will be available the readCharacteristic() will trigger\n3. once the readCharacteristic() will finish the writeCharacteristic() will start\n4. subscribe() will get the writtenBytes\nWith the second block - with the current implementation (which will try to share the connection between both subscription) it is uncertain wether the readCharacteristic() or writeCharacteristic() will be triggered first. In such a simple example there is no big difference but if the communication would be stateful in some way the other subscription could change the state of the first one.\nMy suggestion is to use the first block as there you can execute the flow exactly as you want.\n. Usually if you can't read from a characteristic that means that the connection is broken and you have to establish a new one. So yes. If a readCharacteristic() would fail you won't be able to writeCharacteristic\n. I think that you should learn more about the Bluetooth Low Energy. \nThe characteristic is a kind of a property on the server device. What it will serve during readCharacteristic() is up to the server.\nI am sorry but this is not really question about the library itself but more about how the BLE works. I suggest you to check www.google.com or ask a question on www.stackoverflow.com .\nBest Regards\n. The observing action will be executed on arbitrary thread unless you will specify .observeOn(Scheduler). This is exactly in line of how rxJava works.\nMore information you can get here: http://reactivex.io/intro.html\nBest Regards\n. Version 1.2.0-SNAPSHOT is now compatible with Jack.. Since the issue was not reproducible by @mzgreen and there is no other information. I am closing this.\n. RxBleScanResult.getBleDevice().getBluetoothDevice()\n. Version 1.3.0-SNAPSHOT is no longer closing the RxBleConnection if an error happens during a connection operation (i.e. RxBleConnection.characteristicRead) which allows for a retry which may succeed as Android is sometimes reestablishing encryption semi-transparently (it errors only once). This should be enough for working with encrypted connections. The BluetoothDevice for .createBond() is already exposed.\nI do not have much access to peripherals that need bonding / encryption to work and I can only test these features by implementing them by myself on some dev boards. I am not a big fan of testing a library against my own implementation. I would be grateful if someone could explain the Android flow for bonding and establishing encryption which could be implemented in the library.. Thank you @lorenzowoodridge \nThing is that there is a tone of bugs on Android OS regarding bonding BLE devices. I have tried to bond Android 7.1.2 with Android 4.4 / 6.0.1 and one more that I cannot remember now. I have only encountered bugs:\n 4.4 was disconnecting after about 1.5 seconds of link inactivity (no reads/writes) and was loosing the bond on one of the sides randomly after several connections\n 6.0.1 could not connect until adapter off/on cycle when it started to connect but it also was disconnecting after 1.5 seconds of link inactivity\nThere is a quite significant list of bond related Android bugs. Until we will come up with some stable workarounds there is no point (in my opinion) to add this functionality to the library itself as it will only make more people complain that something is not working.\nEvery idea of how to workaround those issues is welcome. . Hello @RobLewis \nFrom what I know you are correct with the difference between pairing and bonding.\n@uKL is also right saying that BLE does not require pairing/bonding to communicate (as long as no encryption is needed).\nWhy the library does not support pairing/bonding? There is a ton of bugs related to it and most likely all questions and asking for help would end up as issues. These are hard to debug and would consume a lot of time to investigate as most of them are OS/model specific. Time is a scarce resource for me and I still have a lot of development to do not including support of pairing/bonding.\nI hope that this explains your doubts.. Hello there.\nDo you know to what device you're talking to? Do you know what characteristic you want to write?\nBoth of these statuses come from Android Bluetooth Stack and we cannot do much.\nStatus 133 is GATT_ERROR and status 10 is GATT_NOT_FOUND.\nPerhaps you're trying to write a characteristic that is read only?\n. In the next SNAPSHOT release there are added interface functions to use with raw Android BluetoothGattCharacteristic and BluetoothGattDescriptor which can be obtained from RxBleDeviceServices (RxBleConnection.discoverServices())\n. What would you suggest?\n. I see that in your code you do not handle .subscribe() onError(). From the Javadoc you can read that .establishConnection() may emit errors and thus in .subscribe() you should handle the error.\nPart of the .establishConnection() Javadoc.\n* @throws BleDisconnectedException emitted when the BLE link has been disconnected either when the connection was already established\n     *                                  or was in pending connection state. This occurs when the connection was released as a\n     *                                  part of expected behavior (with {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS} state).\n     * @throws BleGattException         emitted when the BLE link has been interrupted as a result of an error. The exception contains\n     *                                  detailed explanation of the error source (type of operation) and the code proxied from\n     *                                  the Android system.\nYou should use:\n.subscribe(\n  result -> {},\n  throwable -> { /*handle throwable*/ }\n)\n. No detailed tests were performed. \nUsually BLE is not about sending a bulk of data quickly but adding additional layers of abstraction and using RxJava obviously adds some computation work for the processor and memory allocation.\nIf I would have enough time I would perform some comparison test between specialised implementation of Android BLE API vs RxAndroidBle in firmware update scenario.\n. Now I finally made some performance tests for sending out as much data as possible using various approaches.\nSpecification\nPeripheral: nRF51822 with SoftDevice S110 8.0.0\nConnection Interval: 11.25 ms\nMTU: 23 (default\u2014nRF51 does not support different MTUs)\nLibrary version: 1.4.1\nTest Algorithm\n\nThe central (phone) is sending 19 packets with 20 bytes each to the peripheral. The first byte contains the index of the packet.\nAfter every 19 packets the peripheral sends a notification to the central with indexes of the packets it received. The first byte contains the index of the response. (i.e. the first response packet would contain [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], second [1, 19, 20, 21, ...])\nThe central receives the notification and repeats from the first step.\n\nSpeed calculation\nEvery response notification (2. step) is timestamped. All responses are buffered for 60 seconds. We take the last notification timestamp and the first notification timestamp and calculate the time difference. The resulting speed is ((number of received notifications - 1) * number of packets for each notification (19) * number of bytes in each packet (20)) / time difference\nCode:\n```\nObservable.concat(\n        perform(device, this::unoptimizedSendUuid).map(aFloat -> \"Unoptimized UUID: \" + String.valueOf(aFloat) + \" Bps\"),\n        Observable.empty().delay(1, TimeUnit.SECONDS),\n        perform(device, this::unoptimizedSendCharacteristic).map(aFloat -> \"Unoptimized Char: \" + String.valueOf(aFloat) + \" Bps\"),\n        Observable.empty().delay(1, TimeUnit.SECONDS),\n        perform(device, this::longWriteSend).map(aFloat -> \"Long Write: \" + String.valueOf(aFloat) + \" Bps\"),\n        Observable.empty().delay(1, TimeUnit.SECONDS),\n        perform(device, this::optimizedSend).map(aFloat -> \"Optimized: \" + String.valueOf(aFloat) + \" Bps\")\n)\n        .observeOn(AndroidSchedulers.mainThread())\n        .doOnUnsubscribe(this::clearSubscription)\n        .subscribe(\n                result -> Log.e(\"RESULT\", result),\n                e -> Log.e(\"ERROR\", \"Whoops!\", e)\n        );\nprivate Observable perform(RxBleDevice device, TestSetup testSetup) {\n    return device.establishConnection(false)\n            .flatMap(RxBleConnection::discoverServices,\n                    (connection, services) -> services.getCharacteristic(genericCommunicationCharacteristicUuid)\n                            .flatMap(\n                                    connection::setupNotification,\n                                    (characteristic, responseObs) -> {\n                                        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);\n                                        final Completable readyForTransmission =\n                                                responseObs.filter(bytes -> bytes[0] == 0x01).first().toCompletable();\n                                        final Observable speedTest = testSetup\n                                                .create(new TestConnection(connection, responseObs, characteristic, 19));\n                                        return readyForTransmission.andThen(speedTest);\n                                    }\n                            )\n                            .flatMap(observable -> observable)\n            )\n            .flatMap(observable -> observable)\n            .timestamp()\n            .buffer(1, TimeUnit.MINUTES)\n            .take(1)\n            .map(timestampeds -> {\n                final int bytesSent = (timestampeds.size() - 1) * 20 * 19;\n                final float timeSeconds = (timestampeds.get(timestampeds.size() - 1).getTimestampMillis() - timestampeds.get(0).getTimestampMillis()) * 0.001f;\n                return bytesSent / timeSeconds;\n            });\n}\ninterface TestSetup {\nObservable<byte[]> create(TestConnection testConnection);\n\n}\nstatic class TestConnection {\nfinal RxBleConnection connection;\n\nfinal Observable<byte[]> responseObs;\n\nfinal BluetoothGattCharacteristic characteristic;\n\nfinal int batchCount;\n\npublic TestConnection(RxBleConnection connection, Observable<byte[]> responseObs,\n                      BluetoothGattCharacteristic characteristic, int batchCount) {\n    this.connection = connection;\n    this.responseObs = responseObs;\n    this.characteristic = characteristic;\n    this.batchCount = batchCount;\n}\n\n}\n```\nI have compared three approaches to sending data (all of them with setting BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE):\n1. Using `RxBleConnection.writeCharacteristic(UUID, byte[])\nprivate Observable<byte[]> unoptimizedSendUuid(TestConnection testConnection) {\n    final RxBleConnection connection = testConnection.connection;\n    final BluetoothGattCharacteristic characteristic = testConnection.characteristic;\n    final UUID uuid = characteristic.getUuid();\n    return Observable.range(0, testConnection.batchCount)\n            .concatMap(frameIndex -> connection.writeCharacteristic(\n                    uuid,\n                    new byte[]{\n                            frameIndex.byteValue(), 0, 0, 0, 0, 0, 0, 0, 0,\n                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                    }\n            ))\n            .ignoreElements()\n            .repeatWhen(observable -> Observable.zip(observable, testConnection.responseObs, (o, bytes) -> o))\n            .mergeWith(testConnection.responseObs);\n}\n\n\nUsing `RxBleConnection.writeCharacteristic(BluetoothGattCharacteristic, byte[])\nprivate Observable<byte[]> unoptimizedSendCharacteristic(TestConnection testConnection) {\n    final RxBleConnection connection = testConnection.connection;\n    final BluetoothGattCharacteristic characteristic = testConnection.characteristic;\n    return Observable.range(0, testConnection.batchCount)\n            .concatMap(frameIndex -> connection.writeCharacteristic(\n                    characteristic,\n                    new byte[]{\n                            frameIndex.byteValue(), 0, 0, 0, 0, 0, 0, 0, 0,\n                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                    }\n            ))\n            .ignoreElements()\n            .repeatWhen(observable -> Observable.zip(observable, testConnection.responseObs, (o, bytes) -> o))\n            .mergeWith(testConnection.responseObs);\n}\n\n\nUsing RxBleConnection.createNewLongWriteBuilder()\nprivate Observable<byte[]> longWriteSend(TestConnection testConnection) {\n    final byte[] bytesToSend = new byte[20 * 19];\n    for (int i = 0; i < bytesToSend.length; i = i + 20) {\n        bytesToSend[i] = (byte) (i / 20);\n    }\n    return testConnection.connection\n            .createNewLongWriteBuilder()\n            .setBytes(bytesToSend)\n            .setCharacteristic(testConnection.characteristic)\n            .build()\n            .ignoreElements()\n            .repeatWhen(observable -> Observable.zip(observable, testConnection.responseObs, (o, bytes) -> o))\n            .mergeWith(testConnection.responseObs);\n}\n\n\nUsing RxBleConnection.queue(RxBleCustomOperation)\nPlease note that this implementation is not a example to follow\u2014it does not check for the disconnection of the peripheral or cancellation of the operation.\n```\nprivate Observable optimizedSend(TestConnection testConnection) {\n    return testConnection.connection.queue((bluetoothGatt, rxBleGattCallback, scheduler) -> Observable.create(\n            emitter -> {\n                Log.i(\"START\", String.valueOf(testConnection.batchCount));\n                final byte[] data = new byte[20];\n                testConnection.characteristic.setValue(data);\n                final AtomicBoolean writeCompleted = new AtomicBoolean(false);\n                final AtomicBoolean ackCompleted = new AtomicBoolean(false);\n                final AtomicInteger batchesSent = new AtomicInteger(0);\n                final Runnable writeNextBatch = () -> {\n                    data[0]++;\n                    if (!bluetoothGatt.writeCharacteristic(testConnection.characteristic)) {\n                        emitter.onError(new BleGattCannotStartException(bluetoothGatt, BleGattOperationType.CHARACTERISTIC_WRITE));\n                    } else {\n                        Log.i(\"SEND\", String.valueOf(data[0]));\n                        batchesSent.incrementAndGet();\n                    }\n                };\n                final BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {\n                    @Override\n                    public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n                        if (status != BluetoothGatt.GATT_SUCCESS) {\n                            emitter.onError(new BleGattException(gatt, status, BleGattOperationType.CHARACTERISTIC_WRITE));\n                        } else if (batchesSent.get() == testConnection.batchCount) {\n                            if (ackCompleted.get()) {\n                                batchesSent.set(0);\n                                ackCompleted.set(false);\n                                emitter.onNext(null);\n                                writeNextBatch.run();\n                            } else {\n                                writeCompleted.set(true);\n                            }\n                        } else {\n                            characteristic.setValue(data);\n                            writeNextBatch.run();\n                        }\n                    }\n            @Override\n            public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n                final byte[] bytes = characteristic.getValue();\n                Log.i(\"ACK\", Arrays.toString(bytes) + \"/\" + bytes.length + \"/\" + System.identityHashCode(bytes));\n                characteristic.setValue(data);\n                if (writeCompleted.get()) {\n                    batchesSent.set(0);\n                    writeCompleted.set(false);\n                    emitter.onNext(null);\n                    writeNextBatch.run();\n                } else {\n                    ackCompleted.set(true);\n                }\n            }\n        };\n\n        rxBleGattCallback.setNativeCallback(bluetoothGattCallback);\n\n        Log.i(\"SEND\", String.valueOf(data[0]));\n        if (!bluetoothGatt.writeCharacteristic(testConnection.characteristic)) {\n            emitter.onError(new BleGattCannotStartException(bluetoothGatt, BleGattOperationType.CHARACTERISTIC_WRITE));\n        } else {\n            batchesSent.incrementAndGet();\n        }\n    },\n    Emitter.BackpressureMode.NONE\n\n));\n}\n```\n\n\nResults (in Bytes per second)\n| central \\ implementation | unoptimizedSendUuid | unoptimizedSendCharacteristic | longWriteSend | optimizedSend |\n| --- | --- | --- | --- | --- |\n| Micromax Canvas A107 (5.0) | 2463.4 | 2544.2 | 3479.5 | 4604.4 |\n| Nexus 5 (6.0.1) | 2555.1 | 2593.2 | 2657.8 | 2759.1 |\n| Samsung Galaxy S6 SM-G920F (7.0) | 1631.9 | 1789.4 | 2290.3 | 3867.7 |\n| Motorola Droid XT1030 (4.4.4) | 1737.2 | 1960.8 | 2707.6 | 3010.1 |\n| Asus Zenfone 5 T00J (4.4.2) | 1589.2 | 1758.0 | 2450.2 | 4010.2 |\n| Google Pixel (8.0.0) | 2513.5 | 2646.9 | 2835.7 | 4602.5 |\nResults for Connection Interval = 100 ms\n| central \\ implementation | unoptimizedSendUuid | unoptimizedSendCharacteristic | longWriteSend | optimizedSend |\n| --- | --- | --- | --- | --- |\n| Micromax Canvas A107 (5.0) | 576.0 | 571.9 | 567.8 | 570.8 |\n| Nexus 5 (6.0.1) | 605.0 | 612.0 | 623.9 | 624.5 |\n| Samsung Galaxy S6 SM-G920F (7.0) | 629.0 | 619.9 | 623.2 | 632.3 |\n| Motorola Droid XT1030 (4.4.4) | 342.3 | 342.9 | 343.0 | 344.8 |\n| Asus Zenfone 5 T00J (4.4.2) | 546.7 | 542.9 | 560.7 | 545.7 |\n| Samsung Galaxy S3 GT-I9300 (4.3) | 579.2 | 585.6 | 577.3 | 568.7 |\n| Google Pixel (8.0.0) | 757.3 | 757.3 | 758.6 | 758.7 |\nConclusion\n\nWhen interacting with a low Connection Interval peripheral it may be worth to use native implementation or custom operation to mitigate the downturn that RxJava causes.\nWhen the Connection Interval grows the benefit from optimisations are less visible. It could need a detailed research but it seems that for Connection Interval > 50 ms every implementation should perform similarly.\nThe potential throughput of different Android handsets varies a lot (even in the same environment) because of the raw speed of the device (the route time of going through all the system layers from BluetoothGatt.writeCharacteristic() to BluetoothGattCallback.onCharacteristicWrite()) and number of buffers that it's Bluetooth Chip has.\n\nI hope this quick research helps you.\nBest Regards. Hello,\nBasically using enums in Android development is discouraged because #perfmatters -> https://www.youtube.com/watch?v=Hzs6OBcvNQE\nI was thinking if using @IntDef would solve the problem you have and it would kind of do but passing ints without any context is not very informative and cumbersome to get a human-readable meaningful value.\n. Finally done.. If the description is still unclear - please reopen the issue.\n. Hello,\nThank you for your report. \nI will check tomorrow this scenario. I think that it may be a bug in the library because it is listening for BluetoothAdapter's state changes and maybe when the connection is not yet established it's misbehaving.\n. I have tried to reproduce the issue today on Motorola XT1030 but apparently switching off the BluetoothAdapter while establishConnection(_, true) is making the connection never being established without any exceptions. I have waited for around 10 minutes.\nCould you paste the code you are using and which mobile phone model?\nApparently it would be best to make the library fail any connections that are in the process of establishing if the BluetoothAdapter will go off.\n. I don't see if you're unsubscribing the first connection (started before the off/on switch) and you shouldn't be able to call on the same device .establishConnection() again anyway because it would emit BleAlreadyConnectedException.\nIt would be great to see the logs from the library (use RxBleLog.setLogLevel(RxBleLog.VERBOSE))\nYou could also describe when do you unsubscribe from the first connection.\n. What do you refer to when saying I am using latest code committed in this repository.? The latest SNAPSHOT or the latest release? Maybe your SNAPSHOT is not up to date. Unfortunately I couldn't reproduce your problem and refreshing the BluetoothGatt is not the best idea to reproduce the behaviour as I think it may not be the cause of the original problem.\n. Actually last SNAPSHOT was from May since there was a styling issue which prohibited pushing to the maven repo. There is a new SNAPSHOT available since yesterday now.\n. The failing test should be fixed at the current top of the master branch.\n. Could you also add an appropriate test in RxBleClientTest.groovy?\n. Hello,\nCurrently the library doesn't help with binding the devices and you have to bind it yourself.\n. I am not an expert in binding the device just yet. The behaviour for binding may be different from vendor to vendor.\nWhen binding devices - with the \"Just Works\" solution it's a one time thing. Other types you need to check out by yourself. If you will do that - please share the info here. The library may benefit from it.\nBest Regards\n. There is a chance that soon the connection will not be closed automatically when there is an encryption error. It will enable users to workaround this issue.. I do not have much experience with devices that need bonding so I cannot really tell. I have read that usually Android shows a dialog / notification by itself.\nIf you will have a moment for investigation - feel free to look into it and report your findings or submit a PR :). Unfortunately when testing I could not get stable results with .createBond(). Once bonded \u2014 when canceled the bond \u2014 I could not make the device to bond again. Is that an issue for you?. As it is now possible to workaround this by either using BluetoothDevice RxBleDevice.getBluetoothDevice() and calling BluetoothDevice.createBond() or by retrying RxBleConnection.readCharacteristic()/RxBleConnection.writeCharacteristic()/RxBleConnection.setupNotification()\u2014closing.\nThere is already an issue for adding helpers.. Hello,\nstatus 133 is a GATT_ERROR\nstatus 19 if received from onConnectionStateChanged is GATT_CONN_TERMINATE_PEER_USER\nThat is according to: https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h\nSince I cannot recreate your problem it is quite hard to judge - it seems that the device you're connecting to drops the connection. Maybe it is possible to compare your framework and the RxAndroidBle to check out what is different in the framework and how you do use it?\nBest Regards\n. Hello, any news?\n. Could you share more info about this issue? Do you connect to a device that is changing it's services or something?\n. Long time no see. \nThe hanging discovery issue should be fixed (+ a workaround) #86 \nUhOh is a totally different topic.\nBest Regards\n. @farmazon3000 I am revisiting this issue and I have an idea.\nI do not think it will be possible to react on RxBle#Radio: FINISHED but it should be possible to modify the moment when .observeConnectionStateChanges() will emit RxBleConnectionState.DISCONNECTED (when the RxBleRadioOperationDisconnect would finish).\nThis change would cause a need for further changes. Things to consider:\n At what point the CONNECTING state should be emitted?\nI think that it should be emitted right after the subscription to .establishConnection() regardless of the execution of connect operation as this may be a distant operation in the queue and the user would like to know if the library acknowledged the intent.\n In the above case what should happen if user would like to establish a new connection after he unsubscribed from the previous .establishConnection() but the disconnect operation did not yet finished?\nMy opinion is that in this situation emitted sequence would look like: CONNECTING -> CONNECTED -> DISCONNECTING -> CONNECTING.\nThis is an invite for a discussion on how the feature should look like.\nFYI @uKL @Cierpliwy . Currently when the RxBleDevice emits DISCONNECTED it is safe to establish a new connection as that is the exact moment when the old RxBleConnection is freed \u2014 in terms that it is not yet closed but it will be closed before the next .establishConnection() will be able to start.\nThere is a difference between what RxBleGattCallback.getOnConnectionStateChange() is returning and RxBleDevice.observeConnectionStateChanges(). The former is reporting changes for a particular bluetooth connection as it is implemented in the Android BLE stack whereas the latter is emitting library state of connection \u2014 when the user will subscribe to .establishConnection() but there are other queued operations the library changes state for a particular RxBleDevice to CONNECTING even before the actual function BluetoothDevice.connectGatt() will be called. RxBleGattCallback and RxBleDevice states are actually in sync when the emission of CONNECTED state is happening.. Then we could have an opposite situation to:\n\nSo onNext: RxBleConnectionState{DISCONNECTED} happens more than 2s before RxBle#Radio: FINISHED.\n\nThe onNext: RxBleConnectionState{CONNECTING} could happen long time after the .establishConnection() is subscribed due to RxBleRadio being busy. Maybe it is acceptable and understandable by the user?. That is true. Though in some situations the time distance between subscribing to .establishConnection() and emission of CONNECTING may be significant. But I get your point. Maybe someone else would also share their point of view.. Should be available in 1.4.0-SNAPSHOT shortly.. Hello @nziyouren !\nThanks for the info. Could you show me the code you're using and the device log when the issue happens?\nBest Regards\n. It seems that the connection is somehow closed externally as first it is disconnected and after that the application is queueing disconnect operation. Maybe the glucose meter is turning off after some time of inactivity and that is why it doesn't advertise?\n. The issue with BluetoothGatt not being closed promptly was fixed some time ago. About the device not being scannable after closing the connection - I have no idea what could be done. Closing for now.. To be honest the order of calling is not that easy to control with the rxJava. The state is changed with onNext() when the RxBleConnection is emitted.\nobserveConnectionStateChanges() is emitting the state of the connection and that's it. It is not supposed to trigger any external actions other than showing the current connection state as it would introduce states to the application.\nActing upon the RxBleConnection should happen only when the establishConnection() emits.\n. Thank you for the suggestion. We will considerate it. Unfortunately we're currently occupied with different things.\nYou're always welcome to make a Pull Request. :)\n. @s1155030742 I did not had a need for using the refresh function. Could you describe or paste link to a place where the usage is described? Should the method be called when the connection is active/disconnected/closed? What exactly the method does?. @kenwdelong You could try to use <T> Observable<T> queue(RxBleRadioOperationCustom<T> operation); function.. To all interested people:\nWhat is the supposed scenario for calling BluetoothGatt.refresh()?\n\nCall it at the beginning of the connection\nCall it in the middle of the connection\nCall it at the end of the connection\n\nThe last option looks to be the most bulletproof in terms of implementation. The first one seems also to be doable and should not require a big amount of work. The second does look like a pain to implement as some Observables that could have beed created / subscribed before refreshing could stop working properly.\nAny information about the use-cases for this is valuable! :). The answer will be posted here: http://stackoverflow.com/questions/38902913/rxandroidble-keeping-a-persistant-connection-write-notification-handling\nBest Regards\n. Hello \nAs you can see the answer was added almost two years ago \u2014 at the time the library supported RxJava 1 only. You are now trying to use the same code for RxJava 2 version of the library \u2014 this will not work without some minor changes.\nI will try to find some time to update the answer in the future but I cannot commit to any particular time frame.\nYou can adjust the code by yourself as the general API of the library has not changed \u2014 it was just updated to RxJava 2. You should be able to find some tutorials on the topic.\nBest Regards. Your Patience has been rewarded. 1.3.0-SNAPSHOT now - 1.3.0 soon\u2122.. Hello @kexuejin \nI am currently working on the fix to close the connection asap. For the second issue it is by design that only one operation is being performed at the time and establishing the connection is an atomic operation if autoConnect == false. Once I will finish the fix scan should happen earlier.\nBest Regards\n. Fix is ready. It's waiting for our internal code review but unfortunately it is our holiday season and it may take up to two weeks. If you need it quicker you can always checkout the latest master branch and exchange RxBleRadioOperationConnect.java file code to:\n```\npackage com.polidea.rxandroidble.internal.operations;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothGatt;\nimport android.support.annotation.NonNull;\nimport com.polidea.rxandroidble.RxBleConnection;\nimport com.polidea.rxandroidble.internal.RxBleLog;\nimport com.polidea.rxandroidble.internal.RxBleRadioOperation;\nimport com.polidea.rxandroidble.internal.connection.RxBleGattCallback;\nimport com.polidea.rxandroidble.internal.util.BleConnectionCompat;\nimport rx.Observable;\nimport rx.subjects.BehaviorSubject;\nimport static com.polidea.rxandroidble.RxBleConnection.RxBleConnectionState.CONNECTED;\npublic class RxBleRadioOperationConnect extends RxBleRadioOperation {\nprivate final BluetoothDevice bluetoothDevice;\nprivate final RxBleGattCallback rxBleGattCallback;\nprivate final BleConnectionCompat connectionCompat;\nprivate final boolean autoConnect;\nprivate BehaviorSubject<BluetoothGatt> bluetoothGattBehaviorSubject = BehaviorSubject.create();\n@SuppressWarnings(\"Convert2MethodRef\")\nprivate final Runnable releaseRadioRunnable = () -> releaseRadio();\nprivate final Runnable emptyRunnable = () -> {\n};\nprivate final BehaviorSubject<Boolean> isSubscribed = BehaviorSubject.create(false);\nprivate final Observable<BluetoothGatt> asObservable = super.asObservable()\n        .doOnSubscribe(() -> isSubscribed.onNext(true))\n        .doOnUnsubscribe(() -> isSubscribed.onNext(false))\n        .share();\n\npublic RxBleRadioOperationConnect(BluetoothDevice bluetoothDevice, RxBleGattCallback rxBleGattCallback,\n                                  BleConnectionCompat connectionCompat, boolean autoConnect) {\n    this.bluetoothDevice = bluetoothDevice;\n    this.rxBleGattCallback = rxBleGattCallback;\n    this.connectionCompat = connectionCompat;\n    this.autoConnect = autoConnect;\n}\n\n@Override\npublic Observable<BluetoothGatt> asObservable() {\n    return asObservable;\n}\n\n@Override\nprotected void protectedRun() {\n    final Runnable onConnectionEstablishedRunnable = autoConnect ? emptyRunnable : releaseRadioRunnable;\n    final Runnable onConnectCalledRunnable = autoConnect ? releaseRadioRunnable : emptyRunnable;\n\n    getConnectedBluetoothGatt()\n            // when there are no subscribers there is no point of continuing work -> next will be disconnect operation\n            .takeUntil(hasNoSubscribers().doOnNext(noSubscribers -> RxBleLog.d(\"No subscribers, finishing operation\")))\n            .doOnCompleted(onConnectionEstablishedRunnable::run)\n            .subscribe(getSubscriber());\n    onConnectCalledRunnable.run();\n}\n\n@NonNull\nprivate Observable<Boolean> hasNoSubscribers() {\n    return isSubscribed.filter(aBoolean -> !aBoolean);\n}\n\n/**\n * Emits BluetoothGatt and completes after connection is established.\n *\n * @return BluetoothGatt after connection reaches {@link RxBleConnection.RxBleConnectionState#CONNECTED} state.\n * @throws com.polidea.rxandroidble.exceptions.BleDisconnectedException if connection was disconnected/failed before it was established.\n */\n@NonNull\nprivate Observable<BluetoothGatt> getConnectedBluetoothGatt() {\n    // start connecting the BluetoothGatt\n    // note: Due to different Android BLE stack implementations it is not certain whether `connectGatt()` or `BluetoothGattCallback`\n    // will emit BluetoothGatt first\n    return Observable.fromCallable(() ->\n            connectionCompat.connectGatt(bluetoothDevice, autoConnect, rxBleGattCallback.getBluetoothGattCallback())\n    )\n            .mergeWith(rxBleGattCallback.getBluetoothGatt())\n            // relay BluetoothGatt instance updates\n            .doOnNext(bluetoothGattBehaviorSubject::onNext)\n            // capture BluetoothGatt when connected\n            .sample(rxBleGattCallback\n                    .getOnConnectionStateChange()\n                    .filter(rxBleConnectionState -> rxBleConnectionState == CONNECTED))\n            // disconnect may happen even if the connection was not established yet\n            .mergeWith(rxBleGattCallback.observeDisconnect())\n            .take(1)\n            // finish relaying if there won't be more updates\n            .doOnTerminate(bluetoothGattBehaviorSubject::onCompleted);\n}\n\n/**\n * Obtain observable emitting most recent {@link BluetoothGatt instance}.\n * NOTE: Connection may be released and/or GATT may be closed in any point of time.\n *\n * @return Observable with BluetoothGatt. Most recent GATT will be emitted instantly after subscription if it is available.\n */\npublic Observable<BluetoothGatt> getBluetoothGatt() {\n    return bluetoothGattBehaviorSubject;\n}\n\n}\n```\nBest Regards\n. Fixed with https://github.com/Polidea/RxAndroidBle/commit/604853c4f39c5e8a19e02415c50b547b0befd0e7 \nShould be available in the SNAPSHOT shortly.\n. I believe this question should go on stackoverflow.com with the tag rxandroidble as it may possibly benefit more people.\nLong story short - you should filter out devices that were not scanned (seen) for a period of time.\n. Hello there,\nCurrently the library does not use scanning methods introduced in API 21. We have an issue created for the feature #16 \nSo as for now it is not recommended to do scanning in the background as prolonged scans using API 18 are sometimes causing the whole Android BLE stack to malfunction. But if you really have to do it - you have no other option than to use it.\nPull requests are always welcome. ;)\nBest Regards\n. Hello,\nWhen connecting with autoConnect flag the RxBleRadioOperationConnect finishes after registering the client. The reason is that with autoConnect flag set to true the connection usually is established quite a lot later even if the device you're trying to connect is near by and advertising. I have seen times even above 10 minutes for connecting where connection with autoConnect = false took 5 seconds.\nHow long have you waited for the connection to be established?\nFrom the logs I see that calling the connectGatt using reflection finished successfully - there are no errors with that.\nBest Regards\n. Since I do not own nor I do have access to the said model I do not think this issue will get tested/fixed. Closing.. Hello there.\nQuestion: Is possible to subscribe to multiple characteristic notifications at once?\nAnswer: It is possible to subscribe to notifications from multiple characteristics but not in one line.\nExplanation: There are almost infinite use cases for the BLE applications and it is impossible to cover them all. I feel that with the current state of the code it is quite easy to implement such a feature but baking it into the library won't benefit many people.\nFrom what I understand you would like to map characteristics values into a POJO model in this scenario either to manually assign a characteristic value to a property or have a model that is very generic (a Map<UUID, byte[]> perhaps). In the first situation you would need to either set notifications by hand or match the resulting byte[] by hand. In the second situation you will end up with something like:\n```\n    final UUID serviceUuid = // your service UUID\n    final Map genericModel = new HashMap<>();\n    final Observable connectionObservable = // your connectionObservable\nconnectionObservable\n        .flatMap(connection -> \n                connection.discoverServices()\n                        .flatMap(services -> services.getService(serviceUuid).map(BluetoothGattService::getCharacteristics)) // get characteristics you're interested in\n                        .flatMap(Observable::from) // deal with every characteristic separately\n                        .flatMap(characteristic -> connection\n                                        .setupNotification(characteristic) // setup notification for each\n                                        .flatMap(observable -> observable), // to get the raw bytes from notification\n                                Pair::new) // merge characteristic with byte[] to keep track from which characteristic the bytes came\n        )\n        .subscribe(\n                pair -> genericModel.put(pair.first.getUuid(), pair.second),\n                throwable -> { /* handle errors */}\n        );\n\n```\nI hope this answers your question.\nBest Regards\n. Just have in mind that Android allows to setup only a finite number of notifications.\n. Actually this kind of questions should go to stackoverflow.com with the tag rxandroidble as these are not questions about the library itself but use-cases.\n. Rebased and merged into master ( https://github.com/Polidea/RxAndroidBle/commit/f1a67da064d7874a9ae3cd67240792bc28094026 )\n. Hello there,\nI have been thinking how to address this issue. I currently have no possibility of test this scenario.\nI can give you the change I think would fix the problem - would you be so kind to test it?\nThe thing is to change the isDisconnected() function implementation in RxBleRadioOperationDisconnect class. It would go like this:\nprivate boolean isDisconnected(BluetoothGatt bluetoothGatt) {\n    return bluetoothManager.getConnectionState(bluetoothGatt.getDevice(), BluetoothProfile.GATT) == BluetoothProfile.STATE_DISCONNECTED\n            && rxBleGattCallback.getConnectionState() == RxBleConnection.RxBleConnectionState.DISCONNECTED;\n}\nand the whole implementation of RxBleGattCallback would be:\n```\npackage com.polidea.rxandroidble.internal.connection;\nimport android.bluetooth.BluetoothGatt;\nimport android.bluetooth.BluetoothGattCallback;\nimport android.bluetooth.BluetoothGattCharacteristic;\nimport android.bluetooth.BluetoothGattDescriptor;\nimport android.support.annotation.NonNull;\nimport com.polidea.rxandroidble.RxBleConnection.RxBleConnectionState;\nimport com.polidea.rxandroidble.RxBleDeviceServices;\nimport com.polidea.rxandroidble.exceptions.BleDisconnectedException;\nimport com.polidea.rxandroidble.exceptions.BleGattException;\nimport com.polidea.rxandroidble.exceptions.BleGattOperationType;\nimport com.polidea.rxandroidble.internal.RxBleLog;\nimport com.polidea.rxandroidble.internal.util.ByteAssociation;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicReference;\nimport rx.Observable;\nimport rx.Scheduler;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\nimport rx.subjects.BehaviorSubject;\nimport rx.subjects.PublishSubject;\npublic class RxBleGattCallback {\npublic interface Provider {\n\n    RxBleGattCallback provide();\n}\n\nprivate final Scheduler callbackScheduler = Schedulers.computation();\nprivate final BehaviorSubject<Void> statusErrorSubject = BehaviorSubject.create();\nprivate final BehaviorSubject<BluetoothGatt> bluetoothGattBehaviorSubject = BehaviorSubject.create();\nprivate final PublishSubject<RxBleConnectionState> connectionStatePublishSubject = PublishSubject.create();\nprivate final PublishSubject<RxBleDeviceServices> servicesDiscoveredPublishSubject = PublishSubject.create();\nprivate final PublishSubject<ByteAssociation<UUID>> readCharacteristicPublishSubject = PublishSubject.create();\nprivate final PublishSubject<ByteAssociation<UUID>> writeCharacteristicPublishSubject = PublishSubject.create();\nprivate final PublishSubject<ByteAssociation<UUID>> changedCharacteristicPublishSubject = PublishSubject.create();\nprivate final PublishSubject<ByteAssociation<BluetoothGattDescriptor>> readDescriptorPublishSubject = PublishSubject.create();\nprivate final PublishSubject<ByteAssociation<BluetoothGattDescriptor>> writeDescriptorPublishSubject = PublishSubject.create();\nprivate final PublishSubject<Integer> readRssiPublishSubject = PublishSubject.create();\nprivate final PublishSubject<Integer> changedMtuPublishSubject = PublishSubject.create();\nprivate final Observable disconnectedErrorObservable = getOnConnectionStateChange()\n        .filter(this::isDisconnectedOrDisconnecting)\n        .doOnNext(rxBleConnectionState -> bluetoothGattBehaviorSubject.onCompleted())\n        .flatMap(rxBleConnectionState -> Observable.error(new BleDisconnectedException()));\nprivate final AtomicReference<RxBleConnectionState> connectionStateAtomicReference = new AtomicReference<>();\n\nprivate boolean isDisconnectedOrDisconnecting(RxBleConnectionState rxBleConnectionState) {\n    return rxBleConnectionState == RxBleConnectionState.DISCONNECTED || rxBleConnectionState == RxBleConnectionState.DISCONNECTING;\n}\n\nprivate BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {\n\n    @Override\n    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n        RxBleLog.d(\"onConnectionStateChange newState=%d status=%d\", newState, status);\n        super.onConnectionStateChange(gatt, status, newState);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.CONNECTION_STATE)) {\n            return;\n        }\n\n        Observable.just(mapConnectionStateToRxBleConnectionStatus(newState))\n                .compose(getSubscribeAndObserveOnTransformer())\n                .doOnNext(connectionStateAtomicReference::set)\n                .subscribe(connectionStatePublishSubject::onNext);\n    }\n\n    @Override\n    public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n        RxBleLog.d(\"onServicesDiscovered status=%d\", status);\n        super.onServicesDiscovered(gatt, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.SERVICE_DISCOVERY)) {\n            return;\n        }\n\n        Observable.just(gatt)\n                .map(BluetoothGatt::getServices)\n                .map(RxBleDeviceServices::new)\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(servicesDiscoveredPublishSubject::onNext);\n    }\n\n    @Override\n    public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n        RxBleLog.d(\"onCharacteristicRead characteristic=%s status=%d\", characteristic.getUuid(), status);\n        super.onCharacteristicRead(gatt, characteristic, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.CHARACTERISTIC_READ)) {\n            return;\n        }\n\n        just(characteristic)\n                .map(associateCharacteristicWithBytes())\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(readCharacteristicPublishSubject::onNext);\n    }\n\n    @Override\n    public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n        RxBleLog.d(\"onCharacteristicWrite characteristic=%s status=%d\", characteristic.getUuid(), status);\n        super.onCharacteristicWrite(gatt, characteristic, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.CHARACTERISTIC_WRITE)) {\n            return;\n        }\n\n        just(characteristic)\n                .map(associateCharacteristicWithBytes())\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(writeCharacteristicPublishSubject::onNext);\n    }\n\n    @Override\n    public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n        RxBleLog.d(\"onCharacteristicChanged characteristic=%s\", characteristic.getUuid());\n        super.onCharacteristicChanged(gatt, characteristic);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        just(characteristic)\n                .map(associateCharacteristicWithBytes())\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(changedCharacteristicPublishSubject::onNext);\n    }\n\n    @Override\n    public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n        RxBleLog.d(\"onCharacteristicRead descriptor=%s status=%d\", descriptor.getUuid(), status);\n        super.onDescriptorRead(gatt, descriptor, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.DESCRIPTOR_READ)) {\n            return;\n        }\n\n        just(descriptor)\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(readDescriptorPublishSubject::onNext);\n    }\n\n    @Override\n    public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n        RxBleLog.d(\"onDescriptorWrite descriptor=%s status=%d\", descriptor.getUuid(), status);\n        super.onDescriptorWrite(gatt, descriptor, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.DESCRIPTOR_WRITE)) {\n            return;\n        }\n\n        just(descriptor)\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(writeDescriptorPublishSubject::onNext);\n    }\n\n    @Override\n    public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {\n        RxBleLog.d(\"onReliableWriteCompleted status=%d\", status);\n        super.onReliableWriteCompleted(gatt, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.RELIABLE_WRITE_COMPLETED)) {\n            return;\n        }\n\n        // TODO Implement reliable write\n    }\n\n    @Override\n    public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {\n        RxBleLog.d(\"onReadRemoteRssi rssi=%d status=%d\", rssi, status);\n        super.onReadRemoteRssi(gatt, rssi, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.READ_RSSI)) {\n            return;\n        }\n\n        Observable.just(rssi)\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(readRssiPublishSubject::onNext);\n    }\n\n    @Override\n    public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {\n        RxBleLog.d(\"onMtuChanged mtu=%d status=%d\", mtu, status);\n        super.onMtuChanged(gatt, mtu, status);\n        bluetoothGattBehaviorSubject.onNext(gatt);\n\n        if (propagateStatusErrorIfGattErrorOccurred(status, BleGattOperationType.ON_MTU_CHANGED)) {\n            return;\n        }\n\n        Observable.just(mtu)\n                .compose(getSubscribeAndObserveOnTransformer())\n                .subscribe(changedMtuPublishSubject::onNext);\n    }\n};\n\n@NonNull\nprivate Observable<ByteAssociation<BluetoothGattCharacteristic>> just(BluetoothGattCharacteristic bluetoothGattCharacteristic) {\n    final byte[] value = bluetoothGattCharacteristic.getValue();\n    return Observable.defer(() -> Observable.just(ByteAssociation.create(bluetoothGattCharacteristic, value)));\n}\n\n@NonNull\nprivate Func1<ByteAssociation<BluetoothGattCharacteristic>, ByteAssociation<UUID>> associateCharacteristicWithBytes() {\n    return pair -> new ByteAssociation<>(pair.first.getUuid(), pair.second);\n}\n\n@NonNull\nprivate Observable<ByteAssociation<BluetoothGattDescriptor>> just(BluetoothGattDescriptor bluetoothGattDescriptor) {\n    final byte[] value = bluetoothGattDescriptor.getValue();\n    return Observable.defer(() -> Observable.just(ByteAssociation.create(bluetoothGattDescriptor, value)));\n}\n\nprivate RxBleConnectionState mapConnectionStateToRxBleConnectionStatus(int newState) {\n\n    switch (newState) {\n        case BluetoothGatt.STATE_CONNECTING:\n            return RxBleConnectionState.CONNECTING;\n        case BluetoothGatt.STATE_CONNECTED:\n            return RxBleConnectionState.CONNECTED;\n        case BluetoothGatt.STATE_DISCONNECTING:\n            return RxBleConnectionState.DISCONNECTING;\n        default:\n            return RxBleConnectionState.DISCONNECTED;\n    }\n}\n\nprivate <T> Observable.Transformer<T, T> getSubscribeAndObserveOnTransformer() {\n    return observable -> observable.subscribeOn(callbackScheduler).observeOn(callbackScheduler);\n}\n\nprivate boolean propagateStatusErrorIfGattErrorOccurred(int status, BleGattOperationType operationType) {\n    final boolean isError = status != BluetoothGatt.GATT_SUCCESS;\n\n    if (isError) {\n        statusErrorSubject.onError(new BleGattException(status, operationType));\n        bluetoothGattBehaviorSubject.onCompleted();\n    }\n\n    return isError;\n}\n\nprivate <T> Observable<T> withHandlingStatusError(Observable<T> observable) {\n    //noinspection unchecked\n    return Observable.merge(\n            (Observable<? extends T>) statusErrorSubject.asObservable(), // statusErrorSubject emits only errors\n            observable\n    );\n}\n\npublic BluetoothGattCallback getBluetoothGattCallback() {\n    return bluetoothGattCallback;\n}\n\npublic Observable<BluetoothGatt> getBluetoothGatt() {\n    return bluetoothGattBehaviorSubject;\n}\n\n/**\n * @return Observable that never emits onNexts.\n * @throws BleDisconnectedException emitted in case of a disconnect that is a part of the normal flow\n * @throws BleGattException         emitted in case of connection was interrupted unexpectedly.\n */\npublic <T> Observable<T> observeDisconnect() {\n    //noinspection unchecked\n    return disconnectedErrorObservable;\n}\n\npublic Observable<RxBleConnectionState> getOnConnectionStateChange() {\n    return withHandlingStatusError(connectionStatePublishSubject);\n}\n\npublic Observable<RxBleDeviceServices> getOnServicesDiscovered() {\n    return withHandlingStatusError(servicesDiscoveredPublishSubject);\n}\n\npublic Observable<ByteAssociation<UUID>> getOnCharacteristicRead() {\n    return withHandlingStatusError(readCharacteristicPublishSubject);\n}\n\npublic Observable<ByteAssociation<UUID>> getOnCharacteristicWrite() {\n    return withHandlingStatusError(writeCharacteristicPublishSubject);\n}\n\npublic Observable<ByteAssociation<UUID>> getOnCharacteristicChanged() {\n    return withHandlingStatusError(changedCharacteristicPublishSubject);\n}\n\npublic Observable<ByteAssociation<BluetoothGattDescriptor>> getOnDescriptorRead() {\n    return withHandlingStatusError(readDescriptorPublishSubject);\n}\n\npublic Observable<ByteAssociation<BluetoothGattDescriptor>> getOnDescriptorWrite() {\n    return withHandlingStatusError(writeDescriptorPublishSubject);\n}\n\npublic Observable<Integer> getOnRssiRead() {\n    return withHandlingStatusError(readRssiPublishSubject);\n}\n\npublic RxBleConnectionState getConnectionState() {\n    return connectionStateAtomicReference.get();\n}\n\n}\n``\n. Thanks for sharing the code - I will try to recreate the issue locally.\nThere are two issues I want to address:\n1. Connection is not being properly closed because somehow the final callback comes after theRxBleOperationDisconnect` finishes like you can see here:\n09-08 19:48:19.361 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(176898444)\n09-08 19:48:19.375 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.376 26825-26825/de.tobiastrumm.bluetoothledmatrix D/BluetoothManager: getConnectionState()\n09-08 19:48:19.377 26825-26825/de.tobiastrumm.bluetoothledmatrix D/BluetoothManager: getConnectedDevices\n09-08 19:48:19.379 26825-26825/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: cancelOpen() - device: B8:27:EB:A7:1B:9D\n09-08 19:48:19.382 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(176898444)\n09-08 19:48:19.385 26825-26837/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=B8:27:EB:A7:1B:9D\n09-08 19:48:19.386 26825-26837/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\nThis situation prevent's closing the BluetoothGatt even when calling BluetoothGatt.close().\nThe second thing is to allow using BluetoothGatt.refresh() method via reflection. Calling this method should allow proper functioning of BLE devices that change their services / characteristics without putting the BluetoothAdapter through on/off cycle.\n. @lavenj @WIStudent Sorry for such a long wait. I have a possible bugfix for the situation where the BluetoothGatt.close() method is being called before the Android actually disconnects the BluetoothGatt.\nI could either push the possible fix to a branch for you to test or I will try to setup the test procedure myself.\nBest Regards\n. @lavenj can you share more info about the workaround?\nAbout the RxBleAdapterStateObservable I will think about mentioning it the docs. ;)\n@WIStudent I am trying to use your Raspberry Pi 3 script to recreate the issue. I have installed a fresh Raspbian on the RPi3 and commented out all interactions with the display from the source code. I have enabled the bluetooth by calling sudo systemctl enable bluetooth but still the script returns:\nGattManager1 interface not found\nLEAdvertisingManager1 interface not found\nTraceback (most recent call last):\n  File \"led_matrix.py\", line 216, in <module>\n    main()\n  File \"led_matrix.py\", line 194, in main\n    service_manager.RegisterApplication(app.get_path(), {},\nAttributeError: 'NoneType' object has no attribute 'RegisterApplication'\nI am not very experienced with linux and Raspberry Pi configuration so maybe you could point me in the right direction. Possible causes I can think off:\n- I should enable something in the system prior to running the script\n- I must update the BlueZ 5.23 -> 5.41 (rather a cumbersome process from what I have googled so far)\n- I lack of some dependencies with the DBus but the imports didn't failed so I don't think so\n  Any hints you could give me?\n. @WIStudent \nThank you for the instructions. I have updated the BlueZ according to the tutorial flawlessly. I have checked your code against current master branch using code:\nrxBleClient.getBleDevice(macAddress)\n                .establishConnection(this, false)\n                .flatMap(rxBleConnection -> Observable\n                        .interval(1, TimeUnit.SECONDS)\n                        .flatMap(i -> rxBleConnection.readCharacteristic(UUID.fromString(\"00002a38-0000-1000-8000-00805f9b34fb\")))\n                )\n                .subscribe(\n                        read -> Log.d(\"read\", \"read\"),\n                        error -> Log.e(\"XXX\", \"Error\", error)\n                );\nwhich connects to the RPi3 and every second it tries to read a characteristic. Then at some point I closed the gatt server script and got a proper closing of the BluetoothGatt.\n11-04 14:42:31.026 25628-26420/com.polidea.rxandroidble.sample D/read: read\n11-04 14:42:31.028 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(203958134)\n11-04 14:42:31.924 25628-30697/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(21262938)\n11-04 14:42:31.924 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(21262938)\n11-04 14:42:32.035 25628-25639/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=00002a38-0000-1000-8000-00805f9b34fb status=0\n11-04 14:42:32.036 25628-26420/com.polidea.rxandroidble.sample D/read: read\n11-04 14:42:32.036 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(21262938)\n11-04 14:42:32.924 25628-30697/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(86345726)\n11-04 14:42:32.925 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(86345726)\n11-04 14:42:32.995 25628-25658/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=00002a38-0000-1000-8000-00805f9b34fb status=0\n11-04 14:42:32.996 25628-26420/com.polidea.rxandroidble.sample D/read: read\n11-04 14:42:32.996 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(86345726)\n11-04 14:42:33.929 25628-30697/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(116747362)\n11-04 14:42:33.943 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(116747362)\n11-04 14:42:34.076 25628-25640/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=00002a38-0000-1000-8000-00805f9b34fb status=1\n11-04 14:42:34.076 25628-25640/com.polidea.rxandroidble.sample I/RxBle#RadioOperation: onError\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n11-04 14:42:34.077 25628-25640/com.polidea.rxandroidble.sample E/XXX: Error\n                                                                      BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                          at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                          at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                          at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                          at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                          at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                          at android.os.Binder.execTransact(Binder.java:453)\n11-04 14:42:34.077 25628-25640/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(149083612)\n11-04 14:42:34.078 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(116747362)\n11-04 14:42:34.078 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(149083612)\n11-04 14:42:34.078 25628-25628/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n11-04 14:42:34.078 25628-25628/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n11-04 14:42:34.080 25628-25628/com.polidea.rxandroidble.sample D/BluetoothGatt: cancelOpen() - device: B8:27:EB:B3:78:18\n11-04 14:42:34.085 25628-25639/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=B8:27:EB:B3:78:18\n11-04 14:42:34.085 25628-25639/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n11-04 14:42:34.086 25628-25641/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(149083612)\n11-04 14:42:34.086 25628-25628/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n11-04 14:42:34.086 25628-25628/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=5\nSo perhaps some recent fix has unintentionally fixed this issue as well. I was checking with Nexus 5 and Nexus 5X both with Android 6.0.1. Fun fact: I couldn't get any device with Android < 6.0 to connect to the Raspberry Pi 3 - always getting status=133 (GATT_ERROR) when connecting.\nIt would be awesome if you could re-check this issue using the SNAPSHOT release or the newest version if it will be available before.\nYet - I still need to add a refresh() function for clearing the BluetoothGatt state.\n. I wish I had written tests for RxBleGattCallback earlier. No disconnection when receiving status error is a behaviour planned for release 2.0.0 but it is a bug in 1.x.x.\n. @WIStudent Excuse me for asking again but I have fixed the behaviour to be inline with 1.x.x and it should be working fine now. (I hope... - it at least works as intended for me)\nThanks! Cheers!\n. So it seems that cause of this issue (that is in the topic) is resolved.\nThe error occurs because the handles had changed but the connection is disconnected and closed properly. Thank you for reporting and feedback. Cheers!\n. Hello @cpboyd \nFrom what I see in the code you have pasted - your code only does .setCharacteristicNotification(characteristic, true) where to get the notifications callbacks you need also enable the notifications by setting the so-called Client Characteristic Config which has UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\") with value of BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE. \nFrom what I see there is an error on writing the value to the descriptor with status=3 which corresponds to GATT_WRITE_NOT_PERMIT (check https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h ). It seems that your device is misconfigured or you're trying to set a notification on a characteristic that doesn't support it.\nYou can check it by yourself if alongside of .setCharacteristicNotification(characteristic, true) you can write BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE to the Client Characteristic Config.\nBest Regards\n. Glad I could help. If you could confirm if in this situation setupIndications() will work - I would be grateful.\nBest Regards\n. Hello,\nThis behaviour is expected. You have posted an approximated version of the code. Depending on how have you implemented the onConnectionSuccess() and reacting to the button clicks the previously sent operations will be sent again or not.\nFor instance if you have used a ReplaySubject it will reemit all onNext() on the next subscription that may have happened after retryWhen(). Too less info for me to tell. Either way it's connected strictly to how you use rxJava, not the library as every operation is executed only one time.\nBest Regards\n. Hello,\nThanks for the info - I haven't encountered a situation where there is a characteristic that supports notifications but doesn't have a Client Characteristic Config descriptor. I will try to find some more information about it.\nCan you tell which device is having this issue? \n. The standard configuration for BLE devices is that if a characteristic is supporting notifications / indications it is having a Client Characteristic Configuration descriptor which is the place where the client may turn on / off notifications.\nA bit more info is here: http://stackoverflow.com/questions/22817005/why-does-setcharactersticnotification-not-actually-enable-notifications\nAnd even more is in the Bluetooth Core specification: \n- Vol 3, Part G, 3.3.3\n- Vol 3, Part G, 3.3.3.3\n- Vol 3, Part G, 4.10\nMy personal opinion is that if there are specifications - everyone should stick to it. ;)\nBest Regards\n. Hello,\nCan you confirm that bluetoothGattCharacteristic that you use is obtained during the connection on which you are trying to use it?\n. Tell me what will happen if you do:\nbleDevice.establishConnection(this, false)\n    .flatMap(connection -> {\n        connection.discoverServices()\n            .flatMap(services -> /* get your bluetoothGattCharacteristic */)\n            .flatMap(bluetoothGattCharacteristic -> connection.writeCharacteristic(bluetoothGattCharacteristic, bytes))\n    })\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(\n        this::onWriteSuccess,\n        this::onWriteFailure\n    );\n. I haven't seen the whole of your code but I think you're trying to use a bluetoothGattCharacteristic that was obtained during some previous connection.\n1. first connection starts\n2. obtained bluetoothGattCharacteristic\n3. first connection ends\n4. first connection is cleaned up by the library\n5. second connection starts\n6. writing characteristic obtained on the first connection with the second connection\n7. error\nLifecycle of items that are emitted from the RxBleConnection are bound to the lifecycle of it. They shouldn't be persisted and used across connections.\nEdit: you can checkout this link http://stackoverflow.com/questions/38902913/rxandroidble-keeping-a-persistant-connection-write-notification-handling maybe it will help you\n. Sorry for such a long wait. As for now you have to chunk the data yourself. I am currently chasing bugs mostly and unfortunately don't have enough time to research the problem and possible use cases.\nFeel free to describe it to me in greater detail. :)\n. I have put somewhere what I do use for byte splitting but cannot find it for reference so I will put it here again:\npublic class ByteSplitter extends Observable<byte[]> {\n\n    protected ByteSplitter(@NonNull byte[] bytes) {\n        super(new SyncOnSubscribe<ByteBuffer, byte[]>() {\n\n            private static final int MAX_PACKET_LENGTH = 20;\n\n            @Override\n            protected ByteBuffer generateState() {\n                return ByteBuffer.wrap(bytes);\n            }\n\n            @Override\n            protected ByteBuffer next(ByteBuffer state, Observer<? super byte[]> observer) {\n                final int remainingBytes = state.remaining();\n                final int bytePackageLength = Math.min(remainingBytes, MAX_PACKET_LENGTH);\n                if (bytePackageLength > 0) {\n                    final byte[] bytesPacket = new byte[bytePackageLength];\n                    state.get(bytesPacket);\n                    observer.onNext(bytesPacket);\n                }\n                if (state.remaining() == 0) {\n                    observer.onCompleted();\n                }\n                return state;\n            }\n        });\n    }\n}. @nister Could you elaborate more on how did you managed to send more than 20 bytes of data using the Android BLE API? The topic on stackoverflow is describing a custom BLE protocol in order to introduce some flow control in the communication. It describes nothing that the library is not supporting.. And if you use 4.3 / 4.4 or your peripheral does not support larger MTUs - you can just make several writes one after another with the next batches of what you want to transmit. The bytesplitter just splits your large byte array into batches that can be written at once - one after another.\n\nI have finished a helper but it is still under a code review.. Functionality added with:\na2e85fc31cc2b4650e2240a1fbbb2e97d402ac12\nand\nb85fbf24552396bd724bb01dd15246a875322a68. Hello,\nTo be able to help you I would need to see the logs from the device (or both if possible) and the code you are using.\nI am also thinking if this question should not go to www.stackoverflow.com with rxandroidble tag\n. Glad to hear that you have resolved your issue. Thanks for the suggestion. I will probably also add a note that knowledge of rxJava is advised.\n. Hello there. Apparently we had some checkstyle errors in the master branch but you have also introduced one:\n:rxandroidble:checkstyle[ant:checkstyle] /home/travis/build/Polidea/RxAndroidBle/rxandroidble/src/main/java/com/polidea/rxandroidble/internal/connection/RxBleConnectionImpl.java:116: Line is longer than 140 characters (found 143).\n. @rwozniak Sorry for the delay - could you try merge the changes from the top of the master branch? I think the test should then pass and I will happily merge the changes and probably make the adequate changes in the other parts of the code.. Hello there.\nFirst of all, I think that this is a question for www.stackoverflow.com with the tag rxandroidble.\nSecondly - it's hard to reason about the problem if we have no info about what does repository.readRssi() do or what comes from model.getConnection()\nBest Regards \n. Could you also show model.getConnection() body?\n. I have just checked the minimal code test with:\nrxBleClient.getBleDevice(macAddress)\n                .establishConnection(this, false)\n                .flatMap(RxBleConnection::readRssi)\n                .delay(1, TimeUnit.SECONDS)\n                .take(1)\n                .subscribe(\n                        rssi -> Log.d(\"XXX\", \"RSSI: \" + rssi),\n                        error -> Log.e(\"XXX\", \"Error\", error)\n                );\nAnd got result:\n09-27 16:15:06.757 17362-17362/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.bluetooth.BluetoothGattCallback.onMtuChanged, referenced from method com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onMtuChanged\n09-27 16:15:06.757 17362-17362/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve virtual method 286: Landroid/bluetooth/BluetoothGattCallback;.onMtuChanged (Landroid/bluetooth/BluetoothGatt;II)V\n09-27 16:15:06.757 17362-17362/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x6f at 0x0016\n09-27 16:15:06.774 17362-17362/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(1107995200)\n09-27 16:15:06.777 17362-17376/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(1107995200)\n09-27 16:15:06.789 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: D0:5F:B8:3C:7C:7E, auto: false\n09-27 16:15:06.789 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n09-27 16:15:06.848 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=4f63adcb-073d-4a7d-b407-fa0855cf56b3\n09-27 16:15:06.851 17362-17375/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n09-27 16:15:34.650 17362-17373/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=D0:5F:B8:3C:7C:7E\n09-27 16:15:34.651 17362-17373/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n09-27 16:15:34.678 17362-18152/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationReadRssi(1108421000)\n09-27 16:15:34.681 17362-18152/com.polidea.rxandroidble.sample D/RxBle#RadioOperationConnect$$Lambda: No subscribers, finishing operation\n09-27 16:15:34.683 17362-17376/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(1107995200)\n09-27 16:15:34.683 17362-17376/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationReadRssi(1108421000)\n09-27 16:15:34.685 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: readRssi() - device: D0:5F:B8:3C:7C:7E\n09-27 16:15:34.689 17362-17375/com.polidea.rxandroidble.sample D/BluetoothGatt: onReadRemoteRssi() - Device=D0:5F:B8:3C:7C:7E rssi=-77 status=0\n09-27 16:15:34.690 17362-17375/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onReadRemoteRssi rssi=-77 status=0\n09-27 16:15:34.692 17362-17376/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationReadRssi(1108421000)\n09-27 16:15:35.692 17362-18153/com.polidea.rxandroidble.sample D/XXX: RSSI: -77\n09-27 16:15:35.697 17362-18153/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(1108010224)\n09-27 16:15:35.700 17362-17376/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(1108010224)\n09-27 16:15:35.705 17362-17362/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n09-27 16:15:35.706 17362-17362/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n09-27 16:15:35.721 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: cancelOpen() - device: D0:5F:B8:3C:7C:7E\n09-27 16:15:35.723 17362-17373/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=D0:5F:B8:3C:7C:7E\n09-27 16:15:35.724 17362-17373/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n09-27 16:15:45.723 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n09-27 16:15:45.725 17362-17362/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=6\n09-27 16:15:45.737 17362-17376/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(1108010224)\nWhich seems to be ok. I need more information about how you use the library. Are you familiar with rxJava? Maybe you're unsubscribing before the RSSI is read?\n. .take(1) is there only for unsubscribing from the .establishConnection() observable effectively closing the connection. Without it the output looks like:\n09-28 11:13:33.038 26924-26924/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(1107949800)\n09-28 11:13:33.038 26924-26944/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(1107949800)\n09-28 11:13:33.054 26924-26924/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: D0:5F:B8:3C:7C:7E, auto: false\n09-28 11:13:33.054 26924-26924/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n09-28 11:13:33.112 26924-26924/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=78705c47-7f83-46be-b7d7-639349c05806\n09-28 11:13:33.115 26924-26935/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n09-28 11:13:35.022 26924-26936/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=D0:5F:B8:3C:7C:7E\n09-28 11:13:35.023 26924-26936/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n09-28 11:13:35.031 26924-27199/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationReadRssi(1108362048)\n09-28 11:13:35.035 26924-27199/com.polidea.rxandroidble.sample D/RxBle#RadioOperationConnect$$Lambda: No subscribers, finishing operation\n09-28 11:13:35.037 26924-26944/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(1107949800)\n09-28 11:13:35.039 26924-26944/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationReadRssi(1108362048)\n09-28 11:13:35.045 26924-26924/com.polidea.rxandroidble.sample D/BluetoothGatt: readRssi() - device: D0:5F:B8:3C:7C:7E\n09-28 11:13:35.055 26924-26935/com.polidea.rxandroidble.sample D/BluetoothGatt: onReadRemoteRssi() - Device=D0:5F:B8:3C:7C:7E rssi=-79 status=0\n09-28 11:13:35.056 26924-26935/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onReadRemoteRssi rssi=-79 status=0\n09-28 11:13:35.058 26924-26944/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationReadRssi(1108362048)\n09-28 11:13:36.058 26924-27200/com.polidea.rxandroidble.sample D/XXX: RSSI: -79\nThe flow still works. There must be a different problem.\n. Of course it is possible this way but it is the only way currently possible. I am thinking about a more flexible approach to the library to use a mechanism similar to retrofit2 adapters. But it would take a lot of work and I don't know yet when I will have time for that.. Not necessarily - but we would need to switch the current RxJava1 implementation to some custom code.. There will be no impact yet for quite some time I am afraid. Remember that we are stuck with Java 7 still with no views for quick update.. Current plan is to introduce the new API in 1.5.0 which will be almost 1:1 in 2.0.0. I would like to test the new API before bumping the major version as it is the only moment when we are able to cleanup the deprecated APIs.\nI am a bit short of time now so I cannot really say when the new API will be ready.\nFor now you can use RxJava2Interop as @HolySamosa mentioned.. \nWe are finishing the migration to the RxJava 2. There is a snapshot release with the name com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT which you can try out!. I have just tested it and seems to work for me. In the projects build.gradle I have:\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" }\n    }\n}\nand in the module build.gradle:\ndependencies {\n    // ...\n    implementation 'com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT'\n    // ...\n}. Migration guide is not planned as for now. There is no functional difference in terms of the library API as far as I know and there are already plenty of migration guides for RxJava 1 -> 2 which can be checked out. There is no need to invent the wheel again. Hello @bobroalexandr \nThanks for your support. This is one of the features we are thinking about but in a bit different approach - it would be great to change the scanning interface to allow using the new API in it's full glory and backport to V18 as much of the functionality as possible.\nI was thinking on this some time ago but other projects distracted me.\n. It will be useful without any doubt.\nSorry for the lack of contact - I can only excuse myself with having several projects recently plus some holidays. I will try to be more responsive now.\n. I am evaluating possibility of using the BSD-3 license in our library. Incorporating Nordic Semiconductors library would save us a lot of work.\nI will check the fork from @gryffindor14 \nThe only thing I dislike about the scan compatibility library is that it lacks tests.\n. Thank you, great work!\nI think it would be good to have some non-happy tests. We have a different library (which internally uses RxAndroidBle) for React Native - you could find some inspiration there: https://github.com/Polidea/react-native-ble-plx/blob/master/android/src/test/groovy/com/polidea/reactnativeble/advertisement/AdvertisementDataSpec.groovy\nCheers!\n. Hello @aldoborrero !\nHappy New Year!\nDid you have some time to work on the topic? Any updates?\nBest Regards. Hello All. Writing just to give a heads up that I am still wrapping my head around how to best approach this functionality. I will try to write more tomorrow. Best.. I had more time recently for the library and I have tried both implementing a solution using the Nordic Semiconductor's library and a from-scratch-approach.\nI have a WIP internal branch with a fairly modularised approach in which ScanFilters and ScanSettings can be either handled by the hardware or emulated in the library which potentially could be used later for some fine-tuning later on. \nCurrently I was clearing some doubts about semantic versioning and how do I need to handle some braking changes under the internal package - but it seems that I do not need to do anything about it. There is a chance to get a release 1.3.0 quite soon\u2122. From scratch is my personal favour - less dependencies is always better and it is easier to change / tune later.. There is an initial implementation of this feature on our internal PR. It is different from this implementation. I hope to have it merged to the master branch this week.. Just added the new scanning API to 1.3.0-SNAPSHOT. Feel free to check it out.. Great! Give it a try. It is on develop branch.. @HolySamosa Great! All feedback is welcome. Just have in mind this bug: #194 It will be released in 1.2.3 as soon as possible and then merged into 1.3.0-SNAPSHOT.\n@chuks Do you want to achieve filtering with AND or OR with those service UUIDs?. As for #194 you would need to periodically stop the scan and start a new one.\nTo have a filtering of a device that is advertising you could add one ScanFilter with one UUID and then filter by using RxJava .filter() function for the second UUID. The library has embraced the default Android API. Maybe it is a good idea to be able to add multiple UUIDs to a single ScanFilter.. The method accepts client.startBleScan(ScanSettings, ScanFilter...). So if you add two ScanFilters the results will be emitted even if only one of them will match.. no, something like:\nScanFilter.Builder builder = new ScanFilter.Builder()\nrxBleClient.scanBleDevices(\n  scanSettings,\n  builder.setServiceUuid(uuid1).build(),\n  builder.setServiceUuid(uuid2).build()\n). @RobLewis answering your questions:\n\nDoes the library now automatically and transparently use the new scanning system when running on API 21 or later?\n\nNo. The old library API .scanBleDevices(UUID...) does not benefit from this feature. \n\nAre there new features available to RxAndroidBle users?\n\nThe new library API .scanBleDevices(ScanSettings, ScanFilter...) has a slightly different behaviour (it is not cached between calls that are using the same filters) so it is not possible to migrate the current userbase that is using the old library API. But that is an interesting idea.\n\nOr is this an \"under-the-hood\" improvement?\n\nYes - if you use the new library API you do not have to care on what Android API you are calling it. The library exposes a subset of the new Android scanning API in a backwards-compatible manner so it is possible to call it from API <21 and get almost the same behaviour.. Just pushed a change to the master branch. Now all BluetoothGattCallback invocations will happen on a single specific thread. Should be available shortly in SNAPSHOT release.\n. @zhangyud show me the logs please and your code - it will be easier to reason about the issue. Could you try changing this line:\nprivate final PublishSubject<ByteAssociation<UUID>> changedCharacteristicPublishSubject = PublishSubject.create();\nto this:\nprivate final SerializedSubject<ByteAssociation<UUID>, ByteAssociation<UUID>> changedCharacteristicPublishSubject = PublishSubject.<ByteAssociation<UUID>>create().toSerialized();. This issue should be now fixed - or so I hope. SerializedSubject and no deferring. Please check how does it work for you - if not good enough - feel free to reopen. Cheers!. It would be best to have the logs from the library - alternate the RxBleLog to log the data into a file and paste it here for reference. Would that be possible?\n. The above commit fixes an issue that may be the root cause of this problem as well. Could you re-test it with the newest snapshot release?\n. The \"No subscribers, finishing operation\" is for cancelling connection in case of user unsubscribing from connection before it was established. It shouldn't interfere with your problem.\nstatus=257 indicates GATT_FAILURE according to https://developer.android.com/reference/android/bluetooth/BluetoothGatt.html\nFor me this is a different issue than the original one as operations are correctly processed - it is the Android OS BLE stack which is returning 257\nI can recreate this issue myself - stay tuned.\n. I have reverted the previous changes. I have introduced a bug in which a BluetoothGatt was not closed. I have made additional tests for that and created a proper fix but it will wait till Monday for someone else's eyes.\n. Fix merged into the master\n. @shashanktomar Could you provide more information? It would be valuable to know where we can clarify the documentation or think about possible use cases.\n. I would prefer fixing the readme. ;)\n. Oh, my bad - excuse me. :)\n. Sorry for that - my consciousness is not always top notch ;)  \nThanks for your PR.\n. This question should go to the www.stackoverflow.com with tag rxandroidble\n. Hello. I was thinking about the problem. Actually it is not possible to cancel the current operation when it is executing because only establishing connection can be effectively cancelled. \nI was always thinking that rxJava is supposed to be used in a single flow describing all actions (from establishing connection, discovering services if needed, performing read / writes / notifies, etc.) with a single .subscribe(). Then the subscriber would be always informed about any error that happens during the connection.\nBut like in this situation when a disconnection would happen when an operation is in the middle of execution it won't be notified about anything and will effectively be frozen without any chance to resume. This may be actually the cause of a different issue #76 .\nI will definitely look into it as soon as possible.\n. I am starting with writing tests for RxBleGattCallback. I didn't checked it yet though inserting\nobserveDisconnect(),\nat line 256 of RxBleGattCallback could do the trick.\n. Another shot which theoretically should work:\nprivate <T> Observable<T> withHandlingStatusError(Observable<T> observable) {\n        //noinspection unchecked\n        return Observable.merge(\n                statusErrorSubject.asObservable(), // statusErrorSubject emits only errors\n                disconnectedErrorObservable,\n                observable\n        );\n    }\nwhere\nprivate final Observable disconnectedErrorObservable = connectionStatePublishSubject\n            .filter(this::isDisconnectedOrDisconnecting)\n            .doOnNext(rxBleConnectionState -> bluetoothGattBehaviorSubject.onCompleted())\n            .cache()\n            .flatMap(rxBleConnectionState -> Observable.error(new BleDisconnectedException()));\nI have quickly designed two test cases:\n```\n    def \".observeDisconnect() should emit error when .onConnectionStateChange() receives DISCONNECTED state\"() {\n    given:\n    objectUnderTest.observeDisconnect().subscribe(testSubscriber)\n\n    when:\n    objectUnderTest.getBluetoothGattCallback().onConnectionStateChange(null, 0, 0)\n\n    then:\n    testSubscriber.assertError(BleDisconnectedException)\n}\n\ndef \".observeDisconnect() should emit error if .onConnectionStateChange() received DISCONNECTED state\"() {\n    given:\n    objectUnderTest.getBluetoothGattCallback().onConnectionStateChange(null, 0, 0)\n\n    when:\n    objectUnderTest.observeDisconnect().subscribe(testSubscriber)\n\n    then:\n    testSubscriber.assertError(Throwable)\n}\n\n```\nThe first one passes and the second one fails with a somewhat funny message:\n```\njava.lang.AssertionError: No errors (0 completions)\nat rx.observers.TestSubscriber.assertionError(TestSubscriber.java:663)\nat rx.observers.TestSubscriber.assertError(TestSubscriber.java:528)\nat com.polidea.rxandroidble.internal.connection.RxBleGattCallbackTest..observeDisconnect() should emit error if .onConnectionStateChange() received DISCONNECTED state(RxBleGattCallbackTest.groovy:80)\n\nCaused by: com.polidea.rxandroidble.exceptions.BleDisconnectedException\n    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.lambda$new$1(RxBleGattCallback.java:49)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:152)\n    at rx.internal.operators.CachedObservable$ReplayProducer.replay(CachedObservable.java:407)\n    at rx.internal.operators.CachedObservable$CacheState.dispatch(CachedObservable.java:223)\n    at rx.internal.operators.CachedObservable$CacheState.onNext(CachedObservable.java:194)\n    at rx.internal.operators.CachedObservable$CacheState$1.onNext(CachedObservable.java:174)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:86)\n    at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SubjectSubscriptionManager.java:225)\n    at rx.subjects.PublishSubject.onNext(PublishSubject.java:113)\n    at rx.internal.util.ActionSubscriber.onNext(ActionSubscriber.java:39)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:227)\n    at rx.internal.schedulers.EventLoopsScheduler$EventLoopWorker$1.call(EventLoopsScheduler.java:172)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\nYou can give it a shot - I do not have any Android device at the moment and can only test with unit tests.\n. The above commit should fix the issue for good. In case of anything wrong - feel free to reopen the issue. Best Regards.\n. Reopening the issue as the fix introduced a different bug and was reverted. A proper fix is ready though it will wait till Monday for a code review.\n. I have just pushed branch fix/issue_81 which you can checkout. It's waiting for a code review.\n. Fix merged. Should be available in the SNAPSHOT.\n. Using reflection for autoConnect = true is no longer needed past Android 7.0.0. Fix is on it's way.\n. Just pushed to the master. Should be available in the SNAPSHOT release shortly.\n. Hello,\nI don't see a reason why it couldn't be possible. It should be possible. I hope that answers your question. :)\nBest Regards\n. Hello @lvzhongyi \nI am afraid that you forgot to handle an erroneous situation when Bluetooth adapter switches off and the scanning must be stopped.\nThe code should look like this:\n```\nSubscription scanSubscription = rxBleClient.scanBleDevices()\n    .subscribe(\n        rxBleScanResult -> {\n            // Process scan result here.\n        },\n        throwable -> {\n            // Handle error here.\n        }\n    );\n// When done, just unsubscribe.\nscanSubscription.unsubscribe();\n```\nYou can find more on error handling with rxJava here: https://github.com/ReactiveX/RxJava/wiki/Error-Handling\nBest Regards.\n. Thanks for the suggestion. Will do that. :) Cheers!\n. Hello,\nThanks for your report. This issue was already mentioned here: https://github.com/Polidea/RxAndroidBle/issues/75 and is (should be) fixed in the main branch so you could try the SNAPSHOT release.\nI plan to fix one more bug before making another official release.\nBest Regards\n. Hello,\nFirst of all I would like to thank you for your effort.\nI have some doubts about this PR unfortunately:\n- I don't think that adding only unbond feature is feasible - there should be a complex feature for whole bonding / unbonding that would fully cover the functionality (bonding, bonding with pin, ...)\n- The nomenclature in Bluetooth is to bond not pair\n- The javadoc doesn't match the style of the rest of the library\n- In the current implementation there is no value added by returning Observable - it could be a synchronous call that is really easy to wrap into an observable using Observable.fromCallable()\n  I have been fiddling with this feature for some time but wasn't able to achieve a standard behaviour among different devices. Now I am focusing on fixing bugs to stabilise the library and features will be worked on later. If you have time - feel free to work on it.\n  Best Regards\n. This PR will not make it to the master branch in the current form. Since the author did not add anything since the original commit I am closing this.\n\nOr can I simply call rxBleDevice.getBluetoothDevice.createBond()?\n\nSince the library does not support creating a bond you can use the above method or rely on the automatic process which is kicked off by Android usually when accessing encrypted characteristics.. Yes, that is it. Unfortunately I do not have any link to provide you with.. Hello,\nI have just tested against the recent SNAPSHOT this code:\nconnectedSubscription = bleDevice.observeConnectionStateChanges()\n        .subscribe(state -> Log.e(\"STATE\", state.toString()));\nscanSubscription =\n        bleDevice\n                .establishConnection(this, false)\n                .flatMap(rxBleConnection -> Observable\n                        .interval(1, TimeUnit.SECONDS)\n                        .flatMap(t -> rxBleConnection.readCharacteristic(philRxAvailableUuid))\n                        .take(1)\n                )\n                .subscribe(\n                        bytes -> Log.e(\"TEST\", \"bytes: \" + Arrays.toString(bytes)),\n                        throwable -> Log.e(\"TEST\", \"ERROR\", throwable)\n                );\nAnd then put the device into a Faraday's Cage. I got a log:\n11-09 17:37:02.370 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(1108013008)\n11-09 17:37:02.441 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: D0:5F:B8:3C:7C:7E, auto: false\n11-09 17:37:02.441 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n11-09 17:37:02.477 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=f6ff4013-2b52-4b1a-a48b-6a06905c14ca\n11-09 17:37:02.481 30125-30136/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n11-09 17:37:02.528 30125-30125/com.polidea.rxandroidble.sample I/Adreno-EGL: <qeglDrvAPI_eglInitialize:381>: EGL 1.4 QUALCOMM build: AU_LINUX_ANDROID_KK_2.7_RB1.04.04.04.007.066_msm8960_KK_2.7_RB1__release_AU ()\n                                                                             OpenGL ES Shader Compiler Version: 17.01.12.SPL\n                                                                             Build Date: 09/11/14 Thu\n                                                                             Local Branch: mybranch4451390\n                                                                             Remote Branch: quic/kk_2.7_rb1.43\n                                                                             Local Patches: NONE\n                                                                             Reconstruct Branch: AU_LINUX_ANDROID_KK_2.7_RB1.04.04.04.007.066 + 73685fa + 87c0666 + c4bc670 + 6154422 + 594ea9d +  NOTHING\n11-09 17:37:02.573 30125-30125/com.polidea.rxandroidble.sample D/OpenGLRenderer: Enabling debug mode 0\n11-09 17:37:02.633 30125-30137/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=D0:5F:B8:3C:7C:7E\n11-09 17:37:02.633 30125-30137/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n11-09 17:37:02.644 30125-30175/com.polidea.rxandroidble.sample E/STATE: RxBleConnectionState{CONNECTED}\n11-09 17:37:02.690 30125-30175/com.polidea.rxandroidble.sample D/RxBle#RadioOperationConnect$$Lambda: No subscribers, finishing operation\n11-09 17:37:02.691 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(1108013008)\n11-09 17:37:03.705 30125-30180/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(1108595112)\n11-09 17:37:03.722 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(1108595112)\n11-09 17:37:03.730 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: discoverServices() - device: D0:5F:B8:3C:7C:7E\n(... services, characteristics, descriptors ...)\n11-09 17:37:03.832 30125-30137/com.polidea.rxandroidble.sample D/BluetoothGatt: onSearchComplete() = Device=D0:5F:B8:3C:7C:7E Status=0\n11-09 17:37:03.834 30125-30137/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n11-09 17:37:03.839 30125-30175/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(1108717920)\n11-09 17:37:03.840 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(1108595112)\n11-09 17:37:03.841 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(1108717920)\n11-09 17:37:03.862 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: readCharacteristic() - uuid: a59bfff2-6343-4053-a67c-357cc7f8f1a9\n11-09 17:37:03.947 30125-30136/com.polidea.rxandroidble.sample D/BluetoothGatt: onCharacteristicRead() - Device=D0:5F:B8:3C:7C:7E UUID=a59bfff2-6343-4053-a67c-357cc7f8f1a9 Status=0\n11-09 17:37:03.948 30125-30136/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=a59bfff2-6343-4053-a67c-357cc7f8f1a9 status=0\n11-09 17:37:03.950 30125-30175/com.polidea.rxandroidble.sample E/TEST: bytes: [1]\n11-09 17:37:03.951 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(1108717920)\n11-09 17:37:20.871 30125-30137/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=D0:5F:B8:3C:7C:7E\n11-09 17:37:20.875 30125-30137/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n11-09 17:37:20.886 30125-30175/com.polidea.rxandroidble.sample E/TEST: ERROR\n                                                                       com.polidea.rxandroidble.exceptions.BleDisconnectedException\n                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.lambda$new$30(RxBleGattCallback.java:47)\n                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$$Lambda$3.call(Unknown Source)\n                                                                           at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n                                                                           at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:86)\n                                                                           at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n                                                                           at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SubjectSubscriptionManager.java:225)\n                                                                           at rx.subjects.PublishSubject.onNext(PublishSubject.java:113)\n                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1$$Lambda$1.call(Unknown Source)\n                                                                           at rx.internal.util.ActionSubscriber.onNext(ActionSubscriber.java:39)\n                                                                           at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n                                                                           at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:227)\n                                                                           at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n                                                                           at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:104)\n                                                                           at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n                                                                           at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n                                                                           at java.lang.Thread.run(Thread.java:841)\n11-09 17:37:20.888 30125-30175/com.polidea.rxandroidble.sample E/STATE: RxBleConnectionState{DISCONNECTED}\n11-09 17:37:20.897 30125-30175/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(1108027760)\n11-09 17:37:20.898 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(1108027760)\n11-09 17:37:20.899 30125-30125/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n11-09 17:37:20.900 30125-30125/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n11-09 17:37:20.902 30125-30145/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(1108027760)\n11-09 17:37:20.903 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n11-09 17:37:20.903 30125-30125/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=5\nAnd this looks correct. What version of the library are you using?\n. Since I cannot recreate the issue and the author doesn't respond - closing. Feel free to reopen and add comments when available.\nBest Regards.\n. Hello @iBotasky \nThe feature works as intended. It has the same behaviour as default filtering in Android 4.3 and 4.4. There is a plan to update the scanning to use 5.0 features.\nAbout how to implement the desired behaviour I encourage you to post a question on www.stackoverflow.com with tag rxandroidble so the knowledge will not be lost.\nBest Regards\n. Hello @Orbyt \nAd. 1. Setting up the notifications / indications is an asynchronous action and generally will finish at some point in the future. When the Observable<byte[]> is emitted then the setting up of the notification is completed. You can think of it as performing a read operation on a connection but instead of one value it will return an Observable that will emit actual values.\nAd. 2. You cannot have two concurrent connections opened for the same device. You can have two concurrent connections for two different devices.\nTo interact with the device you need to have a reference to the RxBleConnection wether it will be stored as mConnection or will be passed in a more \"reactive\" way.\nBest Regards\n. @Orbyt With lack of any comments in this topic I assume my response did answered you question. In case it did not - feel free to reopen.\nBest Regards\n. Will be fixed in the next build of SNAPSHOT release (around 10 minutes or so).\nThanks for the info!\n. I find the checkstyle slightly annoying... I will add it to my local build script.\nNow it works. Thanks for the info!\n. Thank you for the info. Fixed. \ud83d\udc4d \n. Version 1.2.0-SNAPSHOT. @RobLewis \nTo use the snapshot version you would need to add the Sonatype Snapshot Repository\nmaven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } in your build.gradle.\n1.2.0 Should be released soon\u2122 - No date yet though.\nCHANGELOG.md log is updated right before each official release. You can still check the commits that were merged after the last release to know what is in 1.2.0-SNAPSHOT and what would be in the official 1.2.0\nAndoid Lollipop has introduced a new API for BLE scanning. This library is still not using it. It uses the old BLE scanning API which is now deprecated but still works. I anticipate no problems until the deprecated API will be removed. The library will probably be in version 2.0.0 till that time and will use the new API.\nBest\n. Hello @nziyouren \nThank you for your idea and contribution. From what I see your changes are effectively an equivalent  of RxBleConnection.writeCharacteristic().delay(long, TimeUnit). \nThe possible problem is that your peripheral device is not managing to consume the sent data in time. The delay will be peripheral device dependent and therefore it cannot have a one-size-fit-all solution inside the library. \nSince there is no automatic splitting of bigger chunks of data when sending to a peripheral inside the library and it is managed in the application code - the needed delay may be added there as well and it is an easier / smaller change there than in the library.\nThe best solution would be to have some flow-control on the peripheral to know when it is ready to receive the next chunk of data.\n@uKL what do you think about this PR?\n@nziyouren Thank you for your effort but currently I do not see a reason to include this change.\nBest Regards. I would like to see some more information about this issue somewhere (from stackoverflow or other) - from my knowledge once the BluetoothGattCallback.onCharacteristicWrite() is invoked the BluetoothGatt should be able to handle next .writeCharacteristic() call. I may be wrong though - never had an issue like this before.\nSending a long byte[] can be easily made with a programmable delay with a kind of extension function on the application side:\nObservable<byte[]> writeCharacteristic(\n        RxBleConnection connection,\n        UUID characteristicUuid,\n        byte[] aLotOfBytes,\n        long delay,\n        TimeUnit timeUnit\n) {\n    return chunkify(aLotOfBytes) // splitting the byte array into smaller pieces\n            .flatMap(\n                    bytesChunk -> connection\n                            .writeCharacteristic(characteristicUuid, bytesChunk) // sending the bytes\n                            .delay(delay, timeUnit), // and waiting for a specific time after each operation\n                    1 // to make the flatMap executed sequentially\n            );\n}\n\nwhere chunkify(byte[]) could look like this:\nObservable<byte[]> chunkify(byte[] bytes) {\n    return Observable.create(new SyncOnSubscribe<ByteBuffer, byte[]>() {\n\n        @Override\n        protected ByteBuffer generateState() {\n            return ByteBuffer.wrap(bytes);\n        }\n\n        @Override\n        protected ByteBuffer next(ByteBuffer state, Observer<? super byte[]> observer) {\n            final int chunkLength = Math.min(state.remaining(), 20);\n            if (chunkLength > 0) {\n                final byte[] bytesChunk = new byte[chunkLength];\n                state.get(bytesChunk);\n                observer.onNext(bytesChunk);\n            }\n            if (chunkLength == 0 || state.remaining() == 0) {\n                observer.onCompleted();\n            }\n            return state;\n        }\n    });\n}\n\n. No problem. I am glad I could help. \nAs for now I don't see a good reason to use this PR - closing for now. Maybe in the future I will revisit my position. Anyway - if you will write some code you think will be feasible to use - feel free to create a Pull Request.\nCheers!. Hello @bmc08gt \nThank you for your pull request - it is a good idea to add the MTU negotiation to the library.\nIt would be best to not to bind MTU changes with writing to a characteristic but rather keep it as a separate function / operation as the user may want to do this prior to writing / reading. As the library is aiming to be fully tested - this should be tested as well.\nGood that you have picked up the idea - I will happily merge your changes when the changes will be done.\nBest Regards. FYI There is another PR about the MTU #102 which is a bit closer to what would fit into the library.. MTU negotiation PR #102 was merged today. Closing. Thank you for your effort.. Hello @CreaterXu \nUnfortunately it is not possible. At least not without a big amount of work.\nYou can try to get a reference to a proper RxBleDevice by calling RxBleClient.getDevice(String) and only store the device MAC address. I don't know your use case. You can ask a question on stackoverflow with a tag rxandroidble if you will need help with the code.\nBest Regards. @pregno could you find some information about the stalled negotiation somewhere on the stackoverflow or other place? I would like to read more about it.. In this situation how did you tested it? Using what code?\nSorry for so many questions - I would like to understand what is going on as I wasn't using this functionality yet and I cannot find anything interesting on the Internet.. The situation with device going out of range will be automatically handled by the library as RxBleGattCallback is reporting an error if the device is disconnected.\nAbout the case when the device is not bonded - I see no hint anywhere that negotiating MTU requires bonding. There are some issues regarding bonding in the Android OS but it's not directly connected with the MTU. If you know more about bonding / mtu - please say or direct me to a place where I can read more.\nI think that having a programmable timeout is not the best idea (differently to discovering services as it will be longer if a peripheral has a lot of services / characteristics) because MTU is a two-packet procedure and shouldn't take long. The simpler the API is the better in my opinion.. Thanks for re-adding the timeout as it is useful till we will deal with bonding related issues. I have added comments to the code.\nThings to do before I can merge the changes:\n\nFix checkstyle issues.\nAdd a test for timeouting MTU negotiation operation.\nAdd a RequiresApi on RxBleConnectionImpl.requestMtu(int mtu) call.\nRemove all changes that do not touch functionality of the mtu. (new lines in import).\nExtract changes regarding getting the permissions to a different pull request.\n\nOnce the above things will be addressed we should be there. \ud83d\udc4d . Three things left:\n\nThere are some obsolete changes with line breaks in RxBleConnectionImpl\nCheckstyle is whining about unused imports in RxBleRadioOperationMtuRequest you can check it here: https://travis-ci.org/Polidea/RxAndroidBle/builds/181702296\nThere is now unused line in ScanActivity -> public final static int PERMISSIONS_REQUEST_LOCATION = 16;\n\nI will mark them in the code to make it easier.. @pregno I hope that you are not taking my requests personally. Our current setup is currently not building artifacts if the checkstyle is complaining - thus the need of removing unused imports. And it doesn't look good if there are changes that are not relevant to the topic of a pull request - so removing unnecessary formatting and leftovers from parts that were already removed will boil down the code to easily understandable bare minimum. \nI am really thankful to you for committing your work towards what I hope will be the best android ble library. :+1:. Thank you for your effort @pregno - your changes are merged and will be available in the 1.2.0-SNAPSHOT release shortly. :) \ud83d\udcaf \nBest Regards. Hello @swilsonian \nI have posted an answer on the Stackoverflow.\nLong story short - the library works as intended. After the connection being established and closed it won't be reopened without a call to RxBleDevice.establishConnection().\nBest Regards. Hello. \nThanks for the info. I have incorporated rxJava Proguard configuration. Works for me. In case of problems - reopen this issue. (Change should be available shortly in 1.2.0-SNAPSHOT)\nBest Regards.. I think that @JlUgia is right.\nThe condition seems right. If the Build.VERSION.SDK_INT is newer than or equal to Nougat then we're not using reflection. If the autoConnect is false we are also not using reflection.. We could think about adding some tests but this one is ready for merge right away. Then we need to make a release of 1.1.1. Hello @mfatiga \nFirst of all I want to thank you for your report.\nUnfortunately some devices require location to be on and some do not. Unless it is possible to determine from the code if a specific device needs to have location turned on it will be a lot of burden to maintain a blacklist of devices that need it. Plus we will have a whole new set of issues about RxAndroidBle scan is not working. For now we plan to stick with the requirement for the location as we also do have different things on our plates. However - if you will have more time - you're welcome to dig into the topic and propose a solution.\nKind Regards. @mfatiga Could you share how have you tested the need of having Location Services being turned on? According to the topic that @uKL has mentioned - if you have tested with an app that was build for target SDK <=22 then it is possible that none of the devices needed the Services to be turned on.. I am building an app with SDK 25 and tested it with Location Services turned OFF:\n- Huawei ALE-L21, Android 6.0 - OK\n- Samsung SM-G900F, Android 6.0.1 - OK\n- Motorola Nexus 6, Android 7.0 - Not OK\n- LGE Nexus 5X, Android 7.0 - Not OK\nSo far it seems that the Nexus line needs to have Location Services turned ON. Though it may not be the only case. Unless it is somehow possible to determine wether that is needed during the runtime - I will not make the restriction more loose. I only plan to push a check wether the app was built for SDK <=22 - then in compatibility mode - the system doesn't require Location Services to be ON even on Nexus devices.\nIf you will have a moment - feel free to search wether runtime check for Location Services requirement is possible.. @mfatiga As it is not possible to currently distinguish at runtime which devices need Location Services to being turned on - I am closing. I could only add a check for the devices SDK and build SDK of the library - which I did.\nIf the situation will change - feel free to reopen.\nBest Regards. I have added an option to ScanSettings to disable Location Services check. You can try it out by using 1.9.0-SNAPSHOT version (see snapshots section of readme). @NitroG42 Should be available in the Snapshot release shortly.\nBest Regards. Hello!\nThank you for the report. Could you describe what is happening and / or paste the logs from the application? It would greatly help.\nBest Regards. Hello Rob,\nAll of the other Activities in the application need a bluetooth device to run. This device needs to be scanned in the Example 1 first and to access other screens you need to tap the device you want to use on the list.\nBest Regards. Maybe you have turned you BT adapter off and on again. It sometimes help.. Hello @lovedise\nIf I understood you correctly: When you connect to two devices and turn off one of them - both connections are stalled until the Android OS decides that the now-offline device is no longer connected and then queued operations are being processed normally, right?\nBest Regards. Unfortunately due to Bluetooth Stack being synchronous in meaning that it can only process one asynchronous radio operation at a time (read / write characteristic / descriptor, etc.) the library cannot continue with reading characteristic from the second device before the read from the first one will either succeed or fail. From my knowledge it is impossible to overcome this limitation.\nIn case you know something I do not - do not hesitate to comment / reopen this issue.\nAs for now - closing.\nBest Regards. Hello @svangsgaard \nThank you for your pull request - this is a great idea! Unfortunately I cannot merge it yet, there are few things that need to be clarified:\n\nSetting the connection priority may fail and your code does not inform the user about the result\nHave you tested wether requesting connection priority may be called at any time or does it have to be called when no bluetooth operation is executed at that time? If it is the case we would need to make the request asynchronous and create a RxBleRadioOperationRequestConnectionPriority and related tests\nIt may be also worth to discuss if a High Priority or Low Priority connection would have a lifecycle similar to normal connection and / or notifications. I.E. when user will request high priority connection it will be returned in Observable<RxBleConnectionHighPriority> which would have almost the same interface as RxBleConnection but would not be able to change the priority. When the user would unsubscribe from the Observable<RxBleConnectionHighPriority> the priority would be brought back to balanced state. What is your use-case?\nYour commit introduces formatting changes in JavaDoc which are not related to the topic and should be reverted.\n\nAfter all I am looking forward to have this feature after we will discuss and implement it in a proper way.\nBest Regards. I don't think that binding connection priority to setting up notifications is a good idea. I can imagine at least a situation where user would like to transmit data to the peripheral at increased rate.\nCould you describe your use case in greater detail? Does your peripheral transmit a lot of data via notifications to the phone?\nI am on the fence if introducing state to the connection via setting the connection priority is a good idea. Maybe it would be better to emit RxBleConnectionHighPriority but what if at the same time the user would also request low priority? Then an error should be emitted.\nEither way - if you could confirm the point number 2 from my previous post - it would be clear if we need a separate operation.. @svangsgaard Any hints you can provide?. Hello @cpboyd \nI do not exactly follow your use case. You could just create a flow of data that would give you a connection with MTU being set already. You could use code similar to one below:\n    Observable establishConnectionWithMtu = bleDevice.establishConnection(context, false) // establish connection\n        .flatMap(connection -> { // ... when it is established...\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { // ... if it is Lollipop or later...\n                return connection.requestMtu(BtHelpers.BLE_TI_MTU) // ... request MTU...\n                    .map(mtu -> connection) // ... and when the MTU is set return the RxBleConnection\n            } else { // ... if it is OS older than Lollipop...\n                return Observable.just(connection) // ... return just the RxBleConnection\n            }\n        });\nIf I didn't get your use case please elaborate more\nBest Regards. Everything depends on your use case. Observable pattern gives you a great flexibility. Your code is suitable if you want to just log the value negotiated.\nBest Regards. Hello @kexuebiao \nA quick question - do you hold reference to the RxBleClient? It seems that the Executor powering RxBleGattCallback Scheduler is stopped and it happens when the RxBleClientImpl is being finalized ( https://github.com/Polidea/RxAndroidBle/blob/master/rxandroidble/src/main/java/com/polidea/rxandroidble/RxBleClientImpl.java#L97 ). You have to persist RxBleClient. Use only one instance in the whole application. \nIn your code you're creating a new instance for every BleDevice and the RxBleClient is not referenced - so it will be garbage collected and the Executor will be stopped.. The autoConnect value depends mostly on the use-case. Usually I want to connect to a device as soon as possible so I use false because it either succeed or fail in limited time (30 seconds).\ntrue is better if you want to eventually connect to a device and it is not essential to the user to get the connection very soon.\nI hope this answers your question.\nBest Regards. Hello @lowwor \nCould you attach a log of what is going on?\nIt may be a good idea to think either about timeouting such operations or maybe it will be possible to cancel operation when it is unsubscribed.. That's true. The library should timeout read / write operations after a reasonable time. We should dig through the BLE specification to check what is the maximum delay after which a device needs to acknowledge the operation.\nBtw. as a temporary workaround - what would happen if you would make the delay bigger? Like 100 ms?. I think the issue may not lie in the BLE stack but in the peripheral you're talking to - perhaps it doesn't work fast enough to consume the next chunk of data. It lacks some flow control features. Maybe if it would inform the app by a notification that it is ready for the next chunk the problem could be solved.\n(But still the library should timeout operations after some time.). I am looking into the topic. I have found this: http://stackoverflow.com/questions/30420137/writecharacteristic-returns-true-but-does-not-call-oncharacteristicwrite\nIs it possible that on some occasions chunkify() fails to work correctly and the peripheral does not acknowledge a finished write? Have you tried to manually check (debug) what is being transferred? And could you paste what version of chunkify() you use?. @lowwor Sorry for a late response. So with a delay longer than 50 ms the code works without a problem?. I have a branch with added timeouts for all operations. It should be enough to keep the library working.. A fix was pushed to the master branch and should be available in the SNAPSHOT shortly. The library should no longer stop in case of the issue you have suffered. Best Regards.. I have digged through the Bluetooth Specification to check if it has a maximum time for a device response specified. Actually the time varies by two factors - the time between the activities of the device and the number of the activities the device may skip but still consider the connection open.\nIt roughly translates to a time between several milliseconds to 32 seconds (or so). The Android OS is considering a connection not being able to start after 30 seconds (BluetoothGatt.establishConnection(Context, false)) - I have used the same value.. Hello @kenwdelong \nThank you for your report. This is expected behaviour - although not in-line with what you would expect from a library using Observable pattern. Generally speaking Android BLE stack is behaving better (is more stable) when called from the main thread. The library is calling every BLE call from the main thread to achieve maximum stability.\nBest Regards. Library does it for you inside.. Thanks for noticing!. Hello,\nI am trying to reason about your code but it is hard as I do not see what exactly is the connectionObservable in your case. There is also no context about when your setup is run. When does your inputSubject emit? Can you confirm that the service discovery on a particular connection worked properly? (I have seen situations that the Android indicated that discovery ended but an empty list of services was returned) Your device, OS version?\nBtw. it would be better to call subList.unsubscribe(); in .onTerminate() of your raw Subscription. But when your code from the first post is executed? It still lacks the context (state).\nPoint is - it looks like you have some state in your code that is wrong after turning the bluetooth off / on. I am judging this because when you say that you reinitialize everything from scratch the problem is gone and even with the exception being emitted you say that the peripheral receives the data.\nI think I was not experiencing this issue when turning off / on the adapter. Will double check on Monday.. Glad to hear that you have solved your problem. Thing is that everything that is created in a context of a specific connection should be only used within the context. I will think of how to inform about it clearly.. Hello @RiverZhong \nCould you paste your code, logs, anything that can be useful to debug the issue?\nCurrently you cannot obtain the BluetoothGatt from the RxBleConnection in other way than force casting to RxBleConnectionImpl and getting the BluetoothGatt by reflection.. @RiverZhong Any update?. My colleague @uKL is working currently on this issue. Judging on the Bluetooth Specification the Client Characteristic Config descriptor is optional but it shall be set to appropriate value to make the notifications / indications work. It is not clearly described what should be the state in both scenarios in the Specification.\nThing is that in my understanding - if a characteristic supports notifications / indications the CCC descriptor must be present. Unfortunately some device vendors think different.\nWe will somehow allow to setup a notification without the CCC descriptor but the user will have to specifically set it this way.. Version 1.2.0-SNAPSHOT has an alternative way of setting the notifications / indications that do not need the descriptor. Check them out.. Hello @Dionysios \nCould you share your code and provide logs? Device, OS version, version of the library used. This could be helpful.. Which version of the library do you use? Could you provide a stacktrace for the ClassCastException?. I think that you may facing an issue with Retrolambda which is mixing some references -> you get a ClassCastException. Otherwise the compiler would whine.. you could try with 1.1.0 and expanding all lambdas / method references to anonymous classes.. @Dionysios Any news?. Yeah. Unfortunately the library is not compatible with Jack at this moment. We plan to migrate to Kotlin or just get rid of lambdas as it makes a great compatibility problem.\nThe problem is you have to use either our library or Jack. :/ Anyways - I am glad that you have it running.. I am sorry. This was an unintended consequence of using Retrolambda with the library. Unfortunately Jack does not support lambdas in library projects. Will definitely add that at the top of the Readme.md\nIf you only use Jack for the lambda expressions then changing to Retrolambda is quite easy - https://hackernoon.com/living-android-without-kotlin-db7391a2b170#.9s6aieeki - here you have a paragraph about lambdas and the difference between Jack and Retrolambda setup. I hope this will help you.\nThe problems with the compatibility are surfacing in the runtime when some generated lambdas are not matching what is expected.. Version 1.2.0-SNAPSHOT should be now compatible with Jack.. Yes - we have seen it. The library does not use lambdas anymore so we are unaffected by that change unless we decide to go back using lambdas. Thanks for info though. Best Regards.. http://lmgtfy.com/?q=dependency+injection ;). Of course it is possible to filter the devices with the manufacturer data. The thing is you have to do it manually as the library has no built-in feature. ;) This state will probably change once the Lollipop scanning API will be supported. You can still contribute to it! #74 Best Regards.. Just added the new scanning API to 1.3.0-SNAPSHOT. Feel free to check it out.. Hello @RobLewis \nThanks for the report - could you share a minimal code that is showing the issue? Thanks!. @RobLewis Have you encountered the problem when writing unit tests or while using the code on the actual device?. I think that it is related to #262 and in tests should work if used with Robolectric. The new API #239 that we work on should make it possible to use the mock library in the tests without Robolectric. Closing.. Hello all. \nCould you share the code that you are using? How many devices at once you try to connect? What phone / OS? etc.\nOn some devices / oses the BLE stack is not very stable and such errors (133 / 129) are happening more or less randomly. These errors come from the Android BluetoothGattCallback and have little to do with the library.\nBest Regards. If all of you have the same problem on the same device / os - I unfortunately cannot help you. This is already an outdated phone / system. And Galaxy S3 with Android 4.3 is particularly buggy in terms of BLE. On newer devices random BLE errors happen but S3 + 4.3 they happen a lot more. I have incorporated in the library all my knowledge of how to stabilise the stack. :(. Yup these sometimes happen. I have seen these errors even on 7.0. As you can see here: https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h status 133 is GATT_ERROR and 129 is GATT_INTERNAL_ERROR which are quite vague and do not tell a lot. \nKeep in mind that BLE operates on the same frequency as the WiFi. It is a wireless communication and it may suffer from interference.\nI have no more ideas of how to stabilise the system more than it is now. I am closing. If anyone here will get some more information on how to get Android 4.3 (especially on SGS3) to work better - feel free to comment.. Hello,\nCould you add the logs from your application?\nCould you add a log for doOnSubscribe for both prepareDeviceConnection() and the first block of code? It would be easier to debug what is happening. . You have only shown the cut parts of logs.\nAre you sure that once the user forgets the scale you do not resubscribe to the indications observable? I see that the doOnUnsubscribe is called properly so the underlying connections should be disposed. Never had a problem with that.\nUnfortunately there seems to be something more about managing the state in your application that is missing. With the provided code and logs I cannot pinpoint the issue.\nI would need to ask you for a minimal code sample that is reproducing the issue.. The error is truncated. I would need the full stacktrace to help you.. Still does not look full. Could you keep the RxBleClient as a property in your Activity?. Yeah, I forgot that you have not caught the error to print the log by yourself.\nCould you keep the reference to the result of RxBleClient.create(Context) in your Activity the same way you keep the private Subscription subscription;? Because now the RxBleClient is only referenced in the onCreate() method / scope and it needs to be persisted.. ```\nprivate static final int REQUEST_ENABLE_BT = 1;\nprivate RxBleClient rxBleClient;\nprivate Subscription subscription;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_kmov__historique);\nrxBleClient = RxBleClient.create(this);\n...\n\n}\n```\nTo get the place where the error is thrown you would need to put a brakepoint in Android Studio on throwing exceptions and check where and exactly what is the cause of the exception.\nEdit: detail about what device / os you use could be helpful as well.. http://stackoverflow.com/questions/24718958/android-studio-ide-break-on-exception. Could you elaborate more on what you have changed that made your code work? What is the strange type you are talking about?. True, I did not noticed it missing. \naBytes is a byte[]. So byte[].toString() will give you some odd result\nTry new String(bytes, \"UTF-8\");. Then apparently you are getting only one byte from the read.. I do not know what peripheral you are talking to. If the periperal provides only one byte then you get only one byte. No tricks here. This has nothing to do with the library.. Fixed with bd65d766bddc15742e9f8b1fbdd0dcb86e76a0e5. Hello,\nWhat version of the library do you use? How do you persist the instance of RxBleClient so it will not be garbage collected during you use the library?. In the above code you do not keep a reference to the RxBleClient after you create the RxBleDevice.\nYou have to keep the reference to RxBleClient at least as long as you plan to use anything that is obtained from it (RxBleClient, RxBleConnection, etc...). Any news? Has my last comment helped in your case?. Ok. Closing for now - feel free to reopen if the problem will persist.. Hello there!\nI am afraid that you may have a bug in your code or you found a bug in RxJava (which is unlikely). The Observable do not interact with each other in terms of changing their behaviour. Although I do not immediately see what may be the problem in your situation - I also do not see a reason why the issue could be in .map() function appears to break BLE device scanning.\nBest Regards. @RobLewis maybe you could provide a minimal sample project that would be a showcase for the issue? (this and another one for #128 if possible). Do you test with a real RxBleClient or with a mock?. Unfortunately - I cannot reproduce your issue - The .map() operator has nothing to do with scanning.\nYou could add a doOnNext() after each transformation starting at scanBleDevices() and log what is comming to debug. \nThere is no Long Read - it is Long Write. So I doubt it will be useful for you.. Since there is no way that Observable's along the chain can interact with each other - it could be a problem with RxJava but I highly doubt it. This code works perfectly for me:\nscanSubscription = rxBleClient\n                .scanBleDevices( ) // returns Observable<RxBleScanResult>\n                .observeOn( AndroidSchedulers.mainThread( ) )\n                .doOnNext( this::addRxBleScanResult )\n                .subscribe( scanResultSubscriber );\nGives result:\n02-22 17:39:06.166 7741-7741/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(1114574560)\n02-22 17:39:06.166 7741-7755/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationScan(1114574560)\n02-22 17:39:06.181 7741-7741/com.polidea.rxandroidble.sample D/BluetoothAdapter: startLeScan(): null\n02-22 17:39:06.291 7741-7752/com.polidea.rxandroidble.sample D/BluetoothAdapter: onClientRegistered() - status=0 clientIf=4\n02-22 17:39:06.296 7741-7755/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationScan(1114574560)\n02-22 17:39:06.361 7741-7753/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=33:05:AD:46:10:08 RSSI=-89\n02-22 17:39:06.381 7741-7741/com.polidea.rxandroidble.sample D/addRxBleScanResult: com.polidea.rxandroidble.RxBleScanResult@4273ff20\n02-22 17:39:06.391 7741-7752/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=65:4E:45:EF:E1:C5 RSSI=-61\n02-22 17:39:06.391 7741-7741/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:39:06.391 7741-7753/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=33:05:AD:46:10:08 RSSI=-88\n02-22 17:39:06.391 7741-7741/com.polidea.rxandroidble.sample D/RESULT\u00a0SUB: onNext: com.polidea.rxandroidble.RxBleScanResult@4273ff20\n02-22 17:39:06.396 7741-7741/com.polidea.rxandroidble.sample D/addRxBleScanResult: com.polidea.rxandroidble.RxBleScanResult@427407c0\n02-22 17:39:06.401 7741-7741/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(65:4E:45:EF:E1:C5)}\n02-22 17:39:06.401 7741-7741/com.polidea.rxandroidble.sample D/RESULT\u00a0SUB: onNext: com.polidea.rxandroidble.RxBleScanResult@427407c0\n02-22 17:39:06.401 7741-7741/com.polidea.rxandroidble.sample D/addRxBleScanResult: com.polidea.rxandroidble.RxBleScanResult@427411d8\n02-22 17:39:06.401 7741-7741/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:39:06.401 7741-7741/com.polidea.rxandroidble.sample D/RESULT\u00a0SUB: onNext: com.polidea.rxandroidble.RxBleScanResult@427411d8\n02-22 17:39:06.421 7741-7752/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=33:05:AD:46:10:08 RSSI=-91\n02-22 17:39:06.421 7741-7741/com.polidea.rxandroidble.sample D/addRxBleScanResult: com.polidea.rxandroidble.RxBleScanResult@42741f50\n02-22 17:39:06.426 7741-7741/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:39:06.426 7741-7741/com.polidea.rxandroidble.sample D/RESULT\u00a0SUB: onNext: com.polidea.rxandroidble.RxBleScanResult@42741f50\n02-22 17:39:06.441 7741-7753/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=98:5A:EB:8A:3A:A9 RSSI=-63\n02-22 17:39:06.446 7741-7741/com.polidea.rxandroidble.sample D/addRxBleScanResult: com.polidea.rxandroidble.RxBleScanResult@42742a38\n(...)\nAnd the second one using:\nscanSubscription = rxBleClient\n                .scanBleDevices( )// returns Observable<RxBleScanResult>\n                .observeOn( AndroidSchedulers.mainThread( ) )\n                .map( scanResult -> scanResult.getBleDevice() )\n                .doOnNext( this::addRxBleDevice )\n                .subscribe( scanDeviceSubscriber );\nGives result:\n02-22 17:41:07.731 9993-9993/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(1114599352)\n02-22 17:41:07.731 9993-10025/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationScan(1114599352)\n02-22 17:41:07.746 9993-9993/com.polidea.rxandroidble.sample D/BluetoothAdapter: startLeScan(): null\n02-22 17:41:07.816 9993-10006/com.polidea.rxandroidble.sample D/BluetoothAdapter: onClientRegistered() - status=0 clientIf=4\n02-22 17:41:07.826 9993-10025/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationScan(1114599352)\n02-22 17:41:07.841 9993-10005/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=33:05:AD:46:10:08 RSSI=-87\n02-22 17:41:07.856 9993-10061/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=4F:34:3A:32:A0:1F RSSI=-72\n02-22 17:41:07.861 9993-10006/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=60:43:07:68:43:A6 RSSI=-62\n02-22 17:41:07.866 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:41:07.866 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:41:07.866 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n02-22 17:41:07.871 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n02-22 17:41:07.871 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(60:43:07:68:43:A6)}\n02-22 17:41:07.876 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(60:43:07:68:43:A6)}\n02-22 17:41:07.876 9993-10005/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=33:05:AD:46:10:08 RSSI=-88\n02-22 17:41:07.881 9993-10061/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=4F:34:3A:32:A0:1F RSSI=-71\n02-22 17:41:07.881 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:41:07.886 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(33:05:AD:46:10:08)}\n02-22 17:41:07.891 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n02-22 17:41:07.891 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n02-22 17:41:07.901 9993-10006/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=98:5A:EB:8A:3A:A9 RSSI=-62\n02-22 17:41:07.906 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(98:5A:EB:8A:3A:A9)}\n02-22 17:41:07.921 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(98:5A:EB:8A:3A:A9)}\n02-22 17:41:07.926 9993-10005/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=65:4E:45:EF:E1:C5 RSSI=-63\n02-22 17:41:07.936 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(65:4E:45:EF:E1:C5)}\n02-22 17:41:07.941 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(65:4E:45:EF:E1:C5)}\n02-22 17:41:07.946 9993-10061/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=F4:D2:2B:5E:8A:A1 RSSI=-88\n02-22 17:41:07.951 9993-10006/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=4F:34:3A:32:A0:1F RSSI=-72\n02-22 17:41:07.956 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=StandUpMa+(F4:D2:2B:5E:8A:A1)}\n02-22 17:41:07.956 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=StandUpMa+(F4:D2:2B:5E:8A:A1)}\n02-22 17:41:07.961 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n02-22 17:41:07.961 9993-9993/com.polidea.rxandroidble.sample D/DEVICE\u00a0SUB: onNext: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n02-22 17:41:07.966 9993-10005/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=4F:34:3A:32:A0:1F RSSI=-75\n02-22 17:41:07.971 9993-9993/com.polidea.rxandroidble.sample D/addRxBleDevice: RxBleDeviceImpl{bluetoothDevice=null(4F:34:3A:32:A0:1F)}\n(...)\nThe rest of the code looks like:\n```\n    private void addRxBleScanResult(RxBleScanResult result) {\n        Log.d(\"addRxBleScanResult\", result.toString());\n        addRxBleDevice(result.getBleDevice());\n    }\nprivate void addRxBleDevice(RxBleDevice device) {\n    Log.d(\"addRxBleDevice\", device.toString());\n}\n\nprivate Subscriber<RxBleScanResult> scanResultSubscriber = new Subscriber<RxBleScanResult>() {\n    @Override\n    public void onCompleted() {\n        Log.d(\"RESULT SUB\", \"onCompleted\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(\"RESULT SUB\", \"onError: \" + e.toString());\n    }\n\n    @Override\n    public void onNext(RxBleScanResult result) {\n        Log.d(\"RESULT SUB\", \"onNext: \" + result.toString());\n    }\n};\n\nprivate Subscriber<RxBleDevice> scanDeviceSubscriber = new Subscriber<RxBleDevice>() {\n    @Override\n    public void onCompleted() {\n        Log.d(\"DEVICE SUB\", \"onCompleted\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(\"DEVICE SUB\", \"onError: \" + e.toString());\n    }\n\n    @Override\n    public void onNext(RxBleDevice device) {\n        Log.d(\"DEVICE SUB\", \"onNext: \" + device.toString());\n    }\n};\n\n```\nTest performed on Samsung Galaxy S3 with Android 4.3.\nClosing - if you will have more info - feel free to add.\n. Hello @maoueh \nThank you for your report. Could you explain a little bit more: what device / OS do you test on?\nI see one difference between using the long write operation and your PacketWriter - you use a delay and delayUnit which is not present in the long write - could you give more info about it?. It may be possible that that you are experiencing a race condition that happens inside the library. I have seen it though I could not find the cause.\nIf you could enable RxBleLog on VERBOSE and paste the logs I would get more info.\nAs a temporary workaround you could delay starting the next long write for about 10 milliseconds after the previous completed.. Uh, excuse me. You have already had the log. My mistake. If you could add a log in the writeData method and another one on each emission of completed event emission (around line 170) change\nreturn writeOperationAckStrategy.call(emittingOnBatchWriteFinished.map(bufferIsNotEmpty(byteBuffer)))\n                        .takeWhile(bufferIsNotEmpty(byteBuffer));\nto something like\nreturn writeOperationAckStrategy.call(emittingOnBatchWriteFinished\n                                                                                 .doOnNext(new Action1<Object>() {\n                                                                                     // I am writing this on a web interface, add a log here - it will be triggered after each batch write has finished\n                                                                                 })\n                                                                                 .map(bufferIsNotEmpty(byteBuffer)))\n                        .takeWhile(bufferIsNotEmpty(byteBuffer));. Yup. It seems that this is the exact problem with a race condition. The RxBleGattCallback recieves the notification about finished write but it is not transmitted to the observer (in this situation Long Write Operation). I will need to look into this tomorrow.. This issue with no callback from the Android BLE Stack I have heard of - that is why all operations which are expecting a callback have some sort of a timeout. For this you could add a delay between writes and check if that will help.. Could you confirm by printing out the number of the batch which the log is referring to?\nBack in 2014 when I was developing a FW update functionality for a device I thought I had a similar issue but it was a side-channel ACK as far as I remember - Android BT Stack responded correctly in terms of the sequence.\nHere the problem may lay in using the doOnSubscribe which is actually happening before the subscription taking place itself. I will look into creating doAfterSubscribe which could help.\nNeverthless could you add a simple counter to be sure about which log is for which batch of the transmission?. I have created one - straight forward implementation. The potential fixes are now in the process of code review. I hope to merge them into the master before the end of the day (shortly) so you could test it with a snapshot.. Most of the subjects used in the RxBleGattCallback are not subjects to rapid changes. bluetoothGattBehaviourSubject has no critical observers in terms of sequential delivery of events. Adding .toSerialized() on all subjects could add a non-negligible overhead - that is why it is not added everywhere.\nA new snapshot should be available. Could you try it out?. So it seems that we should somehow synchronise the subscription to the onCharacteristicWrite with writeCharacteristic. Only hackish solutions come to my mind at the moment.. I am not in the office anymore. What if you could synchronise this method on rxBleGattCallback:\nprivate void writeData(byte[] bytesBatch) {\n        bluetoothGattCharacteristic.setValue(bytesBatch);\n        final boolean success = bluetoothGatt.writeCharacteristic(bluetoothGattCharacteristic);\n        if (!success) {\n            throw new BleGattCannotStartException(bluetoothGatt, BleGattOperationType.CHARACTERISTIC_LONG_WRITE);\n        }\n    }\nand in the RxBleGattCallback add a synchronized block in the onCharacteristicWrite() callback?. The synchronized block would be needed to used on RxBleGattCallback.this ofcourse.. I think it may still be the same issue. Adding the sychronisation only made the window smaller than before. Ehhh... As a friend of mine said: You have to be this tall [points high in the sky] to write threadsafe code\nI will probably have to create some kind of a wrapper and old-fashioned callbacks for writing characteristic with no response setting.\nBtw. if you are able to write with response you probably will not face the problem.. An idea just popped inside my head when already in bed:\nYou could change:\nrxBleGattCallback.getOnCharacteristicWrite()\n                .lift(new OperatorDoAfterSubscribe<ByteAssociation<UUID>>(writeNextBatch(batchSize, byteBuffer)))\nto something like (exchange lambdas for anonymous classes ofc and pardon pseudocode):\nObservable.fromEmitter(emitter -> {\n    Subscription s = rxBleGattCallback.getOnCharacteristicWrite().subscribe(emitter);\n    emitter.setCancellation(() -> { s.unsubscribe() });\n    writeNextBatch();\n})\nThis could help in always subscribing to the notification before writing the batch of data.. @maoueh I have pushed a potential fix for the race condition. You could test it once you will have a moment.. Glad that one solution finally helped. I will revert all unneeded changes tomorrow.\nAs for the main thread versus background - I am a bit afraid that there may be more devices that are more stable while using the main thread than we know of. In this situation we would need to keep a list of devices that need a specific solution - which could be a burden.\nAbout the custom operation - I see no particular reason to do it like this. I was thinking about just exposing the RxBleGattCallback and BluetoothGatt for direct usage for optimisation purposes.\nCould you elaborate more on your use-case? We would then also have material for internal discussions.. I have added some optimisations to the long write operations. You can check it out. Should use a lot less allocations.\nBest Regards. Hello,\nI am thinking of advantages that may come from this change. I do not think that it is good to give this flexibility to the users. The purpose (and responsibility) of this library is to allow BLE interactions in a way that is most stable - with this change we could expect people trying to use a non main thread for all devices (because of the better performance) even with Samsung S3 API 18 and related bugs.\nI would imagine that it may be a good idea to restrict BLE operations to be run on the main thread only to Samsung and API 18. I wonder if on >API 18 devices this change would impact with a lower number of successful connections - this scenario would be hard to spot without A/B testing on a large number of devices.\nCould you give information what is the performance gain of changing the operation execution thread? Maybe with a custom operation support ( #137 ) this change is not that relevant?. @RobLewis You say that the data needs to be displayed on the screen as it arrives - so I assume that the central (phone) is receiving the data via notification mechanism - in this situation there is no real benefit of this issue as it only touches operations that are performed from the central side (explicit characteristic read, characteristic write, setup notifications, etc.). Getting the notifications is a totally different story as it is executed on a different thread all along.\n@maoueh Have you been able to check if this issue is still valid for you by any chance?. @maoueh Perhaps you have checked the difference between Write Long Op vs Custom Op? This info could be informative for people interested in #41 \nAnyway - closing this issue for now. If anyone would need this - feel free to ping me here.. Hello @maoueh\nSorry for a late response but I was on vacation since Thursday.\nI have thought about your case and I indeed agree that your proposal would fit nicely in the library. At the moment I do have some more important things on my plate (i.e. API 21 scans) but I would happily help by reviewing any PRs that you may provide.. Added with fb2eccc99ad18fccd45c72c8c366ebeff3ed121c. Q: Must the RxBleConnection be reestablished before every operation(...)?\nA: RxBleConnection must be established before any operation like read / write characteristic. That is why API for these operations is on the RxBleConnection interface. A RxBleConnection is an abstraction made for a single connection to a particular device (i.e. the time between the device connected and disconnected - wether it was by user unsubscribing from RxBleDevice.establishConnection() or by a connection error)\nQ: Can it be saved in a variable and reused for multiple operations?\nA: Yes, as long as the connection is valid [between the device is connected and disconnected (see above]. After that the RxBleConnection is useless [because the connection has already ended)] but it is not a recommended approach as it introduces state to manage.\nQ: Does a single connection serve all operations on a given device, or is a different connection required for accessing different BLE characteristics?\nA: A single connection can serve all operations on a given device as long as the connection is valid.\nQ: Is there any harm or excessive delay caused by calling .establishConnection() before each operation?\nA: Establishing a BLE connection is a rather long process and consumes power on both the phone and the peripheral. \nQ: What's the recommended practice?\nA: Use a single connection as long as it feasible to your use-case. Create a single Observable flow  that fits your requirements. You can check this for inspiration: http://stackoverflow.com/questions/40667038/emit-an-item-one-at-a-time-interact-with-it-until-a-condition-is-met-then-cont. device.establishConnection(context, false)\n                                .flatMap { connection ->\n                                    Completable.concat(\n                                            doSomething(connection), // Completable created here may be arbitratily long\n                                            setPairingData(connection)\n                                    )\n                                            .andThen(Observable.just(connection))\n                                }\n                                .take(1)\n                                .subscribe()\nIn the above example the connection is being established and after that first what will happen is the Completable doSomething(RxBleConnection connection) and after it Completable setPairingData(RxBleConnection connection will be called. Where both Completables may perform basically anything. And you are still sure that the connection will not be released until both will complete.\nIt is safe not to wait for the completion - operations are queued internally so two operations will not be executed at the same time.. s_noopy is my SO handle. \nSingles and Completables are not supported in the API of the library as the change would need a major version bump for it. But you can still use them in your part of the application.\nYour proposal should work but it is introducing state which may lead hard to find errors (such as race conditions).\nsetPairingData() could also be named doYourSecondThing(). The point is that everything that is using the connection is also plugged into Observable chain - so it is safe to create a single flow of data.\nIs a connection only desired at the moment that there is data to be exchanged? - false - you as a developer decide how long you want to keep the connection alive.. First of all you can use it the same way as with any other invocations:\n```\n        final Object object = new Object();\n    new Runnable() {\n        @Override\n        public void run() {\n            object.doSomething();\n        }\n    };\n\n``Runnableis not accepting any parameters - yet you can use references from the outside.\nAnd remember thatObservablehas a method.toCompletable(). So it is basically up to you how you will wire-up the flow usingObservables,Singles orCompletables.. @maoueh In this situation - merged. Feel free to add another pull request with a sample of firmware update. \ud83d\udc4d \nThank you for your great work!. Added with 29ad3526e24226cc6c0dc2a25e2d7ab1d3f4db8a. Thanks!. Hello @jcamins \nI think you that you have mixed the Location options available. The location needed (or supposed) to be on is under normal Settings - not under the Developer Options.\nThe application does not really use the Location Services - it only checks wether they are on.\nWhy commenting out the check has helped is described here #106 but for now we cannot be certain wether this check is needed or not for a particular device - so it is always on as this may lead to tracking app user's location. \nIf you will have an idea how to solve the problem without using whitelisting / blacklisting - feel free to speak up.\nBest Regards\n. I am @dariuszseweryn ;)\nI am developing on Sony SmartWatch 3 - quite old but that is the only one I have at the moment. When I go to the Settings - just under Bluetooth switch - I see Location - this one has to be on.\nSeems to work on Android Wear. I will check with other watches but I do not expect a different behaviour. Feel free to provide more information if you think that something is wrong.. @jcamins You could add what watch do you use so I could check what is your case..Sony SmartWatch 3is definitely Android Wear 1.5 (API 23)\nI am trying to get accessLG Watch Urbane- there is a chance to grab one tomorrow.\nI have also checked the emulator with API 23 - it indeed does not have theLocation` setting - need to dig deeper.. If it is not visible in the About Settings page - you can connect your watch to the computer and the Android Studio lists the current API level - then compare with wikipedia Android Wear topic.\nSony SmartWatch 3 does not require location services to be turned on to get BLE scan results though the situation is the same as in #106 and I did not found any official guides for BLE scanning on Android Wear yet.. It seems that Sony SmartWatch 3 is having a GPS receiver. It would explain why Location setting is available.\nStill - we should find some official guidelines about when we should allow scan on Android Wear - google groups discussion would be sufficient. @jcamins if you have a moment - you could try to find something. I have different project at the moment on my plate.\nBest Regards. I do not have an idea. I am trying to reach someone from Google to shed some light.. @jcamins I have just pushed a commit that should fix your issue with Android Wear. Feel free to give feedback and reopen if necessary.. The code you use would also be appreciated. For instance if you use autoConnect = true then it is possible that the callback will happen after several (unspecified) minutes or even never.. @skynet67 From the logs I see that the disconnect operation is started but never finished. It should timeout in about 10 seconds but you say that the connect operation is the faulty one. Could you elaborate?\nBtw. I wonder if using of the Gatt Server is messing with the BLE stack somehow.\n02-27 14:50:08.805 4216-21339/? D/BluetoothGattServer: onServiceAdded() - service=badbadba-dbad-badb-adba-badbadbadbadstatus=0. @skynet67 Current 1.2.0-SNAPSHOT release should have a fix for this issue.\nBest Regards. I have found a potential compatibility issue with projects using Dagger dependency injection. Once we will solve it - I will make a release. I would like to do it in the next two weeks.. Hello. \nIf you would check the BleGattException and read the javadoc you could then check what is the status=1 about at the page: https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h \nIt seems that the Android OS is caching services from the previous connection (which are not valid anymore after the reboot as the handles may have changed - no logs to confirm that though).\nWhat can you do in such a situation:\n1. Turn the bluetooth off and on again - it makes the Android clear all caches\n2. Tinker with a hidden method BluetoothGatt.refresh() - to get access to the raw BluetoothGatt you would need to use the 1.2.0-SNAPSHOT version of the library and create a custom operation or access it through reflection.\n3. Make the peripheral you are using to have exactly the same handles to services / characteristics after the reboot.\nThe snapshot version has a known bug at this moment - it does not work with projects that are using Dagger 2.. Checkout RxBleConnection.queue(RxBleRadioOperationCustom<T> operation) This gives you access to the BluetoothGatt. I do not think that having a run() abstract method would be a good idea since a lot of potential use-cases will be asynchronous and only a few synchronous. I would like to keep the API as simple (small) as possible. It may be a good idea to add your example of showing the synchronous use-case using Observable.fromCallable() in the readme.\nSince there was no further response from @lukasblue \u2014 I am closing.. 1. You can touch the UI only from the main thread.\n2. I see no error description apart of Error handler is called for second notification setup. Could you paste a stacktrace or at least what is the error?\nLogs could be helpful to diagnose.. If there is no error coming from RxBleConnection.setupNotification() then it seems that the problem lies on the application side.\nI suggest to print the stack trace of the error that is happening. I have skimmed through the logs and I do not see a problem with how the library is working \u2014 if you think otherwise \u2014 feel free to add more information.\nThe mac addresses come from the Android OS and are an implementation detail of the Android API -  cannot tell much about it.\nA well written RxJava data flow should work well and without problems. Subjects are discouraged - there are some articles about it on the Internet.. Looks like a NullPointerException somewhere. Possibly when creating the chain - maybe in some .flatMap() or .doOnNext().. From http://reactivex.io/documentation/operators/scan.html\nThe Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence. You have your null.\nBest Regards. Hello.\nFrom the readme: \n```\nObtaining the client\nIt's your job to maintain single instance of the client. You can use singleton, scoped Dagger component or whatever else you want.\n``\nYou have to persist a reference to theRxBleClient` object as long as you use anything related to the library.\nBest Regards. Hello,\nSorry for the delay - I was on vacation.\nThe status=133 exception is known as GATT_ERROR. It may happen in multiple situations:\n\nWhen the peripheral is out of range / turned off at the moment of establishing the connection\nWhen the Android BLE stack is not working correctly (sometimes turning off and on both Bluetooth Adapter and WiFi helps)\nWhen a peripheral does not conform correctly to BLE specification\nWhen the phone BLE drivers are not good enough\nOther (check google)\n\nThis error cannot be prevented on Android unfortunately \u2014 or at least I do not know how. \nBest Regards.. Thanks!. Add maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } under repositories.. And what do you mean by status?. Hello @brightredchilli \nThanks for your interest. I would definitely like a functionality like this wrapped in an reactive approach.\nThis idea would need a separate module in my opinion (i.e. rxandroidbleserver) as most apps would need either central or peripheral functionality but rather not both.\nIt is interesting tough how Android would handle both roles at once \u2014 but that is a different topic.\nEither way - a green light from me.. A good idea from @uKL: prepare the server module so it could be easily plugged in instead of an RxBleDeviceMock. To do that there will be a need for an Interface for all Android components used in the server.. Hello @kobronson \nWe have a plan (as you see this issue being opened) but it is not decided yet in what version of the library (or a different project) it will be available nor when will it arrive. There are things that have greater priority at the moment.\nExternal pull requests are welcomed though. :). Thank you for the proposal.\nFrom my experience there is not much trouble using the vanilla Android API for the BLE Server.\nThe general idea for the server functionality was about enabling an easy mocking experience for test purposes of this library. Unfortunately we are short on time/people to maintain the mockclient so we have not invested time into the topic \u2014 there are other things with greater priority at this moment.. After disconnect RxBleDevice.establishConnection(true)?. Closing since there is no response for over a week. Best Regards.. Please post this question on Stackoverflow instead of here as this is a question about how to implement a solution - not an issue in the library. The knowledge that will be in the answer will be easier to reach for other people when it will be available on Stackoverflow.. @AmitShah When posting on Stackoverflow - remember to add a tag rxandroidble. Hello @marcbaldwin \nCould you add what phone / OS you use?\nAdditionally please set RxBleLog.setLogLevel(RxBleLog.VERBOSE) and paste the logs from the application.. Since there is no contact and so far the described situation is working as designed (onError() invoked when the notification cannot be set) \u2013 I am closing.. Hello @liunewshine\n Excuse me if I did not understand you correctly. Do you have issue that RxBleDevice.establishConnection() does sometimes emit a BleDisconnectedException?\nI do not understand at what point .unsubscribe() is in the sequence and what does it change in your situation. Could you explain more?. Since there is no contact and the described situation is working as designed (onError() invoked when the connection cannot be established) \u2013 I am closing.. Hello @StanislavChumarin \nThis issue should be fixed in the 1.3.0-SNAPSHOT release.\nBest Regards.. Thanks for noticing!. Hello @blakopf \nTo be honest \u2014 I do not see a reason \u2014 this may be a bug. Why do you ask?. It seems so. The fix has just been landed and should be available shortly in 1.3.0-SNAPSHOT.\nBest Regards.. If the bleConnection got disconnected during the write - it is totally legit to emit BleDisconnectedException as the write cannot complete then.. A good idea is to have only a single .subscribe() in the flow related to BLE.\nYou can also monitor when the .establishConnection() will emit BleDisconnectedException\n.observerConnectionStateChanges() is rather for notifying the UI mostly - it was not meant to be used as an input to other actions..  Yes, this is what I personally do - I construct a chained flow of Observables with a single subscribe because then I am sure that I will get just a single notification that something went wrong.\n.observeConnectionStateChanges() is emitting only the connection states - It does not emit errors that may have triggered the disconnect.. Chaining should be fine as long as you try to establish only one connection at any given time.\nUnsubscribing from .establishConnection() is closing it. It is described in the javadoc:\n* The connection is automatically disconnected (and released) when resulting Observable is unsubscribed.\n     * On the other hand when the connections is interrupted by the device or the system, the Observable will be unsubscribed as well\n     * following BleDisconnectedException or BleGattException emission.\nGenerally a good idea is to unsubscribe from Subscriptions whenever you are no longer interested in the result.. First idea - add a callback listener for every possible callback of BluetoothGattCallback. Why 1. Only one callback listener can be plugged in at time?. Ah, one at a time in this meaning. That's reasonable. I first thought of a Callback Listener per callback type (one callback for onCharacteristicWrite() other for onCharacteristicChanged() and so on) and that one could not set both at the same time.. Is available in 1.4.0-SNAPSHOT. Hello @RobLewis \nThe library only wraps what it gets from the native Android API. If the Android API stopped to scan your device after a firmware update there is nothing the library can do. It seems that the firmware you have uploaded has changed the Advertisement Interval to a value that is not useful for your phone. Unfortunately I cannot find any guidelines for Android system in that matter.\nAs for the ClassCastException it looks like the problem lies somewhere in your code as these classes are nowhere in the library.. Jack / Retrolambda \u2014 this should not make any difference since the library if you use version 1.2.0. You can make a clean build just to be sure.\nThe device name is not the issue. Advertisement Interval is a value set on your peripheral (Aeroscope) in the firmware. Your firmware developer will know about it.. I don't expect a newer version of RxJava to cause problems \u2014 it is heavily tested.\nThe problem may be with how the RxBleScanResult is consumed in your code \u2014 I would look there.\nAs for the Advertising Interval I am no expert in how this should be set to get the best behaviour on Android devices. I have just seen that some settings are making specific phones to not scan the device at all. Every change in Advertising Interval should be tested in my opinion.. > However, I'm getting a new error in the log. Apparently I am trying to read and write the device too soon after attempting to connect with it. My write attempt came 7ms later. How long should a connection take to establish?\nCurrent architecture allows you to perform .writeCharacteristic() only after the RxBleConnection has been emitted - so it is safe to use.\n\nWhat does \"Are you missing a call to unregisterReceiver()?\" mean?\n\nIt means that the context that was used to register a BroadcastReceiver - which is internally used by RxBleAdapterStateObservable - has finished but the receiver was not unregistered (unsubscribed) creating a memory leak.. > So there's no information about how long it normally takes to establish a connection to a device found in a scan? No upper limit?\nGenerally there is no info - it will vary. .establishConnection(false) is guaranteed to fail in 35 seconds (usually 30).\n\nDoes it make sense to do a while( !isConnected() ) { }; wait loop (perhaps with a timeout)? Any advantage to a BlockingObservable? Other solutions?\n\nNo sense at all in my opinion, no and yes. RxJava is all about managing asynchronous code - learn to embrace it - http://www.grahamlea.com/2014/07/rxjava-threading-examples/ or tons of other learning sites available.\n\nCurrently I'm using .subscribeOn( Schedulers.io() ) for scanBleDevices(). Is this a good idea?\n\nDoes not matter to much as every BLE method is called on the UI thread in the end and callbacks are always on background threads. It is not a bad idea at least. ;). > The only thing I can relate this to is that I set up a subscription to observeConnectionStateChanges( ) in an Activity's onStart() method and don't unsubscribe it anywhere. Would this explain it?\nYes\n\nThis brings up a more general question: I'm not clear on how the various Observables should be managed over the Activity lifecycle. As I interpret Google's documentation, in onPause() you should pause tasks that have high CPU usage. Is it OK to leave low-demand operations like monitoring ConnectionStateChanges running? Any general guidelines would be appreciated.\n\nWhenever you are no longer interested in an Observable - unsubscribe. Android may kill background Activities at any time.\n\nAlso, what is the recommended technique for handling the loss of a BLE connection, such as by moving a peripheral device out of Bluetooth range?\n\nIt depends on the application.. Yup. Check RxBleDeviceImpl - it's encapsulated and easy to follow. TLDR; - never.. Hello @jaychang0917 - do you reuse your byte[] data?. No response - closing.. Hello @IgorGanapolsky \nThanks for the insight. I will add your request to my TODOs. Besides: which public methods do not have JacaDoc? I am trying to keep at least the API as documented as possible.. The interface of OperationPriorityFifoBlockingQueue is just a wrapper for a PriorityBlockingQueue intended to use with operations \u2014 it is a quite simple class. RxBleRadioImpl is basically a worker which is responsible for serializing operations and RxBleClientImpl is the implementation of the entry point to the library. Anything in particular is hard to comprehend? On which things should I concentrate describing?. Skip the flattery. ;) I know that diving into code that was written by others is not easy. I will try to add more comments and JavaDoc when I will have a moment.. @kenwdelong they are available in the .aar you get from the Maven repository.. Hello @passsy \nWell... Another thing to dig in. :) Currently I have a different project on my plate and after that I am going to finish the work on the API 21 scanning. \nFeel free to dig deeper into this as I am not sure when I will have a moment.. Hello. Could you call RxBleLog.setLogLevel(RxBleLog.VERBOSE) before your code and then paste the logs?. No response - closing.. Looks like you have opened another topic #176 \nClosing this one as it looks like a duplicate.. As it turned out - the cause was jack which was not regenerating lambdas as it should. Clean build solved the problem.. @BharathMG Thank you for your support :) \ud83d\udc4d . Hello @SsIDit \nPlease be so kind to show your code and call RxBleLog.setLogLevel(RxBleLog.VERBOSE) before capturing logs.. Then you are not posting logs from a debug build as there are clearly no logs from the library. Without it I cannot help you.\nI will also need your code that is touching all interaction with the library.. Force \u2013 currently not unless you will do it yourself in a custom operation.\nI see that you are not managing the state of the connection and you may be using an old RxBleConnection before new is established.. Glad to help.. Nice one. It seems to be a race condition in the RxBleRadioOperationConnect. I am writing a fix.. From connection observable you can unsubscribe at any moment and it should be handled by the library.. True. Another thing that did not manifest before.. Fix for the original cause is ready and waiting on a private PR to be reviewed by @uKL but he has a quite full plate at the moment. I hope that he will have a moment tomorrow to check it out. The fix for the manifestation (Disconnect) I will make tomorrow.. Unfortunately - There is no possibility to do this. You would have to compile your own version from the sources.. RxBleGattCallback is emitting onConnectionStateChange() before the subscription chain is fully established.. @kanat I have pushed fixes for all issues found by you. These should be available in the 1.3.0-SNAPSHOT artifact shortly. Could you give it a try?. See https://github.com/Polidea/RxAndroidBle\nSnapshot paragraph. Great news. I will try to publish 1.2.1 tomorrow. You are welcome.\nYour own version will be more bulletproof. SNAPSHOTs tend to change but regression is rarely an issue.. @kanat I have just released 1.2.1\nIt should be available shortly.. Hello @chuks \nIf you would check out other issues before posting you would see #16 and #74 \nThis feature has currently the highest priority.\nBest Regards. @ilya-payrange 1.2.0 or 1.3.0-SNAPSHOT?\nEdit: yeah - probably not relevant - master branch\nWhat version of the Android Studio?. Nothing that I can know from top of my head.. @KomoriWu currently the project uses annotationProcessor by default. If you have problems making it to work you can check out this topic or other similar. Hello @farmanvu \nHave you tried to google the problem?\nI once had to enable annotationProcessor in Android Studio 2.3 which I use (I am not on 3.0 yet because of incompatibility of groovy plugin #302)\nIf you solve the issue feel free to report back. As you can see the last started operation is: D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicLongWrite(19378408) which points to problem with the Long Write Operation. Your WriteOperationAckStrategy has a problematic implementation perhaps?. Maybe one of the deviceCallback0 or deviceCallback1 is not notifying?\nWhat is notify? Do you create two notifications with the exact same UUID?. First of all you should try to understand what you are trying to achieve and why (if) you want to use a custom ACK Strategy.\nTry using:\nmWriteSubscribe = mRxBleConnectionObservable\n                    .flatMap(rxBleConnection -> rxBleConnection.setupNotification(notify),\n                     (rxBleConnection, notificationObservable) -> { \n                        Log.d(\"XXX\", \"Creating Long Write Operation\";\n                        return rxBleConnection.createNewLongWriteBuilder() \n                                .setBytes(sendData) \n                                .setCharacteristicUuid(write)\n                                .setWriteOperationAckStrategy(booleanObservable -> Observable.zip(\n                                        notificationObservable.doOnNext(ignoredBytes -> Log.d(\"XXX\", \"notification\")), \n                                        booleanObservable.doOnNext(ignoredBytes -> Log.d(\"XXX\", \"chunk written\")),\n                                        (notification, aBoolean) -> aBoolean \n                                ))\n                                .build();\n                    })\n                    .flatMap(observable -> observable)\n                    .take(1) \n                    .doOnSubscribe(this::writeRunnable)\n                    .subscribe(\n                            bytes -> {\n                                onWriteSuccess(); \n                            },\n                            this::onWriteFailure\n                    );\nAnd check logs. It is most likely that there will not be any notification in the logs. In which case it is most likely that your peripheral is not notifying anything.. No further contact from @sycinsider. \nAssuming the problem was solved.\nBest Regards.. Hello\nWhy would you like to use UUIDUtil? It is in internal package and is not intended for public accesibility. @marciogranzotto I will think today how to properly address the issue. The UUIDUtil is in internal package and nothing from there should be used outside of the library. I will probably add some UUIDHelper and add it to the helper package.\n@lukevr The answer is provided in the SO post you have referenced. A custom filter.. I have just released 1.2.2 with this change and AdvertisedServiceUUIDExtractor helper which you should use instead of an internal UUIDUtil.\nIt should be visible shortly.\nBest Regards. Hello @RobLewis \nAs for what the ConnectionSharingAdapter does - it is a very simple class and well named. It is an adapter that shares the RxBleConnection between different Subscribers of an Observable<RxBleConnection> (which comes most probably from RxBleDevice.establishConnection(boolean). You can look into the sources and check it out yourself.\nWhen it is appropriate to use? I am against using it at all as any usage of reactive programming that needs more than one .subscribe() is introducing a state somewhere and it is harder to reason of what is actually going on. But you could potentially use it in a situation where you would want to perform more than one specific task independently and those tasks are independent of each other nor they can interfere (for instance reading two different characteristics).. Should work.. For reference \u2014 in this stackoverflow answer is a part regarding ConnectionSharingAdapter. Hello @streetsofboston \nThat is the intended behaviour for ConnectionSharingAdapter. It allows for sharing the connection but it is not persisting it if there are no subscribers. So depending on how you have written the flow with ConnectionSharingAdapter it would connect each time a read was about to happen or persist the connection. If you have a flow with a single .subscribe() (which should be the case) then the ConnectionSharingAdapter is not needed at all.. > If i'm understanding correctly, the ConnectionSharingAdapter shares connections as long as the subscription-count is larger than 0. As soon as all subscribers unsubscribe (either through a terminal state of the observable or through a un-subscribe), the connection will be closed and no longer shared. Is this correct?\nYes, correct.\nThe above example would never complete until the connection would get lost though. The .establishConnection() is not completing on it's own unless an error happens or the downstream will unsubscribe. So the .repeatWhen() would never been called in the above code.. Yes but still even if you would subscribe to it-it would never complete and the .repeatWhen() would not be executed.. There is a little bit of a difference between .flatMap { connection -> connection.readCharacteristic() }.repeatWhen() and .flatMap { connection -> connection.readCharacteristic().repeatWhen() } ;)\nEither way- good that you have managed to get your use case to work.\nTo not be completely offtopic: I will try to wrap up the documentation for the ConnectionSharingAdapter in the near future (as this may be the only thing I may have time for).\nBest Regards. As it turned out - the cause was jack which was not regenerating lambdas as it should. Clean build solved the problem.. Added in Readme.. Hello @misevcik \nUnfortunately this status is returned by the native Android BLE Stack and we can do nothing to fix it (or at least I do not know what could be done).\nBest Regards. Hello @RobLewis \nMultiple executions of setupNotifications() are using the same Observable so the notifications are setup only once.\nThe logs you see are from the native Android BLE stack and that is exactly as Android behaves. It is using multiple background threads for working with BLE. The library then moves all callbacks to a different thread so the Android threads won't be occupied for too long (which could break the BLE stack).\nDoes it answer your question?. As it turned out - the cause was jack which was not regenerating lambdas as it should. Clean build solved the problem.. Hello @kenwdelong \nActually your custom operation is finished successfully and the service discovery starts as intended as you can see here:\n05-09 12:08:08.748 9098-9173/com.hatchbaby.rest.qa D/RxBle#Radio: FINISHED (944499391)\n05-09 12:08:08.748 9098-9413/com.hatchbaby.rest.qa D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(675644243)\n05-09 12:08:08.758 9098-9173/com.hatchbaby.rest.qa D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(675644243)\n05-09 12:08:08.758 9098-9098/com.hatchbaby.rest.qa D/BluetoothGatt: discoverServices() - device: C8:E3:82:B1:4D:9E\n05-09 12:08:09.038 9098-9098/com.hatchbaby.rest.qa D/NightlightsActivity: [main] com.hatchbaby.rest.ui.NightlightsActivity@15c63b37 onDestroy\n05-09 12:08:28.758 9098-9173/com.hatchbaby.rest.qa D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(675644243)\n\nUnfortunately the Android BLE stack behaviour is not documented in regards to using of BluetoothGatt.refresh() function. That is the main reason why this functionality was not yet introduced to the library.\nAs you can see in the logs Android does not notify the app about the end of the process which is a bogus behaviour and is caused by improper usage of BluetoothGatt.refresh() function (as far as I know).\nIf you have time - feel free to investigate what is going on and post your findings here.. Unfortunately I cannot help much at this moment. I just remember that after refresh the ServiceDiscoveryManager should not check BluetoothGatt.getServices() for cached services.. @kenwdelong Any news? Were you able to overcome the difficulties?. @kenwdelong Could you describe the exact sequence of what you were doing? Maybe a log with the setting RxBleLog.setLogLevel(RxBleLog.VERBOSE);?. I see. And could you paste the logs from what you are actually using now and what works for you?. @kenwdelong If you have not moved on yet \u2014 could you check what would happen if you would use this:\n```\n@NonNull\n@Override\npublic Observable asObservable(BluetoothGatt bluetoothGatt,\n                         RxBleGattCallback rxBleGattCallback,\n                         Scheduler scheduler) throws Throwable {\nreturn Observable.fromCallable(() -> refreshDeviceCache(bluetoothGatt))\n        .delay(500, TimeUnit.MILLISECONDS, Schedulers.computation()) // << *** Add this line ***\n        .subscribeOn(scheduler)\n        ;\n\n}\nprivate Void refreshDeviceCache(BluetoothGatt gatt) {\n    // from http://stackoverflow.com/questions/22596951/how-to-programmatically-force-bluetooth-low-energy-service-discovery-on-android\n    try {\n        BluetoothGatt localBluetoothGatt = gatt;\n        Method localMethod = localBluetoothGatt.getClass().getMethod(\"refresh\", new Class[0]);\n        if (localMethod != null) {\n            boolean bool = ((Boolean) localMethod.invoke(localBluetoothGatt, new Object[0])).booleanValue();\n            Timber.i(\"Gatt cache refresh successful: [%b]\", bool);\n        }\n    }\n    catch (Exception localException) {\n        Timber.e(\"An exception occured while refreshing device\");\n    }\n    return null;\n}\n``. Yeah, that is the problem. ApparentlyBluetoothGatt.refresh()works as everything else - it's asynchronous but there is no callback to be sure when it is ready for next operations. This may be further complicated by how the Android OS works with bonded devices. Either way - adding a reference to the original issue #53 so the above code will be discoverable.\nI plan to add this functionality to the core library in1.4.0or1.5.0when the new API will be ready #239. The most simple to implement would be to refresh the gatt either right after the connecting is kicked off / connected or right after disconnection. Refreshing the gatt in the middle of communication would need significant refactoring and probably a totally new approach to the API to make it clear to the users of what is actually going on and how it should be handled.\nClosing for now as the issue is resolved by adding a delay. If you will have anything to add - post here #53 . I do not think that is related. Some devices are returning only one scanned advertisement per device address. Other devices have a really poor performance of BLE. It is hard to compare unless you have the same device type with two different OS versions.. Are you sure that you did not clone the advertisement innRF Connect` by an accident?. Looks like a development environment where people are mocking advertisement packets. Either way I do not think it is a library problem.. As far as I know on Android 5.0+ the old API is using the new scan under the hood anyway but give it a try. I expect to have the new API scan implemented in the library somewhere next week. At least in the Snapshot.. Unfortunately it does not look like something that the library may fix if it works on another device properly. I cannot do more than suggest you to open an issue on Google's issue tracker: https://issuetracker.google.com/issues?q=nexus%206p%20ble%20scan\nClosing for now. If you will have more info or an idea what we could do from the library side - feel free to comment / reopen.\nBest Regards. Fixed with b53d84065657af07e380e5aaf9b4a6d73b064000 \nShould be available in 1.2.3-SNAPSHOT shortly and in 1.2.3 later today.. Hello @gryffindor14 \nCould you elaborate more on your use case? When does it happen? Is the notification caused by the setup of the notification or is it a constant stream? Is it a big problem if the first notification is lost?. That is an unusual use case. Usually the notification is either triggered by a characteristic write or it is a constant stream of notifications in which situation it is not fatal if one of them is missed. \nTo be honest I do not have an idea how to implement your use case with the current contract which is Returned observable will emit Observable<byte[]> once the notification setup has been completed..\nSince your device is emitting the first value right after the notification is established \u2014 it may be missed due to a race condition. Unfortunately buffering of the notifications is not an option because then it is possible that the library would cause out of memory exceptions.. @gryffindor14 Feel free to add any thoughts you may have. I will think about your use case but I cannot tell when (or how) it will be possible to address it correctly. I do not consider it a top priority as it is quite easy to workaround.\nCuriosity \u2014 does something like this work for you?\nconnection.setupNotification(uuid)\n                .flatMap(observable -> Observable.merge(\n                        observable,\n                        connection.readCharacteristic(uuid)\n                ))\n                // ...\nSo after establishing the notification you would re-read the characteristic.. Not sure. Support for Xamarin was not intended when creating this library.\nMentioning @uKL so he will be aware of the issue.. Hello @mswokk \nFeel free to open a PR where we could discuss it. Here it is not very visible\u2014it is an old and already closed issue.\nBest Regards. Hi @RobLewis \nShow your code. @RobLewis Ping? Anything you could add?. Closing due to inactivity. Feel free to open when more information will be provided.. It is a complete copy of a class android.bluetooth.le.ScanResult so if you would use the original Android BLE API you would also end up with specifying a full package. :)\nRxBleScanResult is a class that was used in the old scan API. They are named different to indicate that they are different. Plus I am trying to drop the Smurf Naming Convention. ;). Hello @ZacharyTech \nCould you describe what would you need this feature for? You can now track state of individual RxBleDevices via .observeConnectionStateChanges().. AFAIK the Settings -> Bluetooth shows only Bluetooth Classic devices which is not directly related to BLE connection and you would still need to establish it.. Ok. Neverthless what would you expect from the suggested method? You can already get all connected devices via BluetoothAdapter.getDefaultAdapter().getConnectedDevices(). You can use BluetoothDevice.getAddress() which returns the Bluetooth Mac Address String and then use RxBleClient.getBleDevice(bluetoothMacAddressString). There is nothing more that can be done.. You must have already established the connection to your device via calling .establishConnection().\nYou have to manage your connection and unsubscribe from .establishConnection() when you want the connection to be closed.\nFor more information check out the samples, documentation and Stackoverflow for tag rxandroidble.. You are welcome. Closing.. Hello @baadillahnabil \nIf you would search this repository for phrase ACTION_STATE_CHANGED you would find a public class: RxBleAdapterStateObservable which should do exactly what you want.. No problem. :) I will give it more visibility by adding a hint on the Readme page. . Hello @edifangyi \nDoes your characteristic has a PROPERTY_NOTIFY?. Does your notify characteristic have a Client Characteristic Config descriptor?. I think that your characteristic (0003cdd1-0000-1000-8000-00805f9b0131) does not have a Client Characteristic Config descriptor (00002902-0000-1000-8000-00805f9b34fb) which causes the error.\nIf that is the case you could use function RxBleConnection.setupNotification(UUID, NotificationSetupMode.COMPAT) as a workaround. But it should be fixed by the manufacturer of your peripheral.. Hello @RobLewis \nI suggest you to look for the informations you need on the internet.\nRuntime Permissions: There are plenty of great articles to be found via Google on how to handle that.\nLocation Services: https://stackoverflow.com/questions/33045581/location-needs-to-be-enabled-for-bluetooth-low-energy-scanning-on-android-6-0 or other. Feel free to google up your questions.. As you can read in the link I have posted above - some devices using Android 6+ need to have Location Services enabled to return any BLE scans. It does not matter which provider is enabled as long as the Location Services are on. It does not matter on Android 6+ wether you use the old or the new API - you will not get any scans without Location Services being on.. What is CR or LF?. You would need to send the byte representation of the character you want.\nhttp://lmgtfy.com/?q=utf-8+carriage+return+code\nhttp://lmgtfy.com/?q=utf-8+newline+code\nhttp://lmgtfy.com/?q=java+string+to+utf+8+bytes. @baadillahnabil http://lmgtfy.com/?q=ble+send+more+than+20+bytes\nYour problem is not related to the library but is a general BLE question and there are many answers available on the internet. Closing.. Long Write is just performing multiple standard writes of 20 bytes each. Alternatively you can request a larger MTU but it is depending on your peripheral. Best Regards.. Hello @chuks \nPlease set RxBleLog.setLogLevel(RxBleLog.VERBOSE) and paste the logs from your application.. Everything is fine judging from the logs you have pasted in the comment above. Are you sure that battery notifications are being sent at all? It seems that the Android BLE Stack is not seeing them (no D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=00002a19-0000-1000-8000-00805f9b34fb anywhere to be seen.. In the logs you have pasted I do not see any logs from your part of the application. Are you sure that you have run the app from the code you have posted in the original post?. I cannot really tell. The logs from the library do look good. It seems that the Android BLE stack is not receiving the notifications from the battery. I wonder what would happen if you would switch the place of the characteristics when adding to the List.. FYI You can close it by yourself next time. :). Recognized and done. Should be available in 1.3.0-SNAPSHOT shortly.. Thanks!. I would like to make it somewhere this week.. @kenwdelong Feel free to test 1.3.0-SNAPSHOT in the mean time. I do not expect any changes to the API but it would be easier to fix bugs before the release.. Because that is not yet implemented in a backwards-compatible way. This is a place for pull requests from the community if anyone will need this functionality \u2014 from my experience implemented features are the most used ones.. Good to hear that. I plan to make an official release today.. Released.. Why do you believe so? Have you tried to manually change the write type of the characteristic? Did it helped?. @lorenzowoodridge Any news?. Have you changed anything?. Hello @baadillahnabil \nThis is a general android / rxjava architecture question \u2014 not an issue or a feature request with the library. \nI have seen that you have already posted the same question on stackoverflow (https://stackoverflow.com/questions/44353812/android-keep-bluetooth-connection-between-activities) which is a better place to ask. \nClosing.. Fix should be available in 1.2.4 shortly.. I wanted to play around with other stuff (like encryption and binding) which I do not have a lot to do before going to RxJava 2 because of the opportunity to drop unwanted APIs then. Do you think that RxJava 2 would be better to chase now?\nThis is quite an easy change once there will be a method returning the new interface.. Hello @chuks \nI think that you are mixing RxBleDevice.observeConnectionStateChanges() with BluetoothGattCallback.onConnectionStateChange().\nThe RxBleDevice.observeConnectionStateChanges() works as expected. It was designed as a convenience function for checking in what state is the specific device and use this information for i.e. displaying UI indication. \nIf you need the information about what went wrong with the connection you need to listen to RxBleDevice.establishConnection(boolean) which will emit information about statuses in the onError.\nThere is currently a discussion on how the RxBleDevice.observeConnectionStateChanges() should work in #50 \nBest Regards. Hello,\nHave you read the README? Recently we have added there a paragraph:\nPermissions\nRxAndroidBle already provides all the necessary bluetooth permissions for you. Recently, Google has started checking these when releasing to the Play Store. If you have ACCESS_COARSE_LOCATION set manually you may run into an issue where your permission do not merge with RxAndroidBle's, resulting in a failure to upload to the Play Store This permission is only required on SDK 23+. If you need this permission on a lower version of Android use:\n<uses-permission\n  android:name=\"android.permission.ACCESS_COARSE_LOCATION\"\n  android:maxSdkVersion=\"22\"/>\nEdit: Does it solve your problem?. Yup. Does it fix your problem?. @RobLewis The issue in the topic is related to uploading an .apk file to the Play Store which is checking the AndroidManifest.xml. Local builds are not affected.\nAs for your question What is the best way to solve this and maintain compatibility with different Android versions? you need to read about Runtime Permissions. There is a lot of good articles accessible via Google search for that so there is no sense in me trying to explain it here.. Good. Closing then.. Hello @RobLewis \n\nI note that the new ReadMe has introduced ScanSettings.Builder() in the scanning API. Is this required, and will it break code using earlier versions?\n\nNo (at least not yet). The library is using a Semantic Versioning and deprecated APIs will continue to work until version 2.0.0 when they will get removed.\n\nAlso, are constants like ScanSettings.CALLBACK_TYPE_ALL_MATCHES documented somewhere? And what form do the optional filters take?\n\nScanSettings and ScanFilter classes are copied directly from Android AOSP project and you can find the documentation for those classes using google.. ScanFilter filter = new ScanFilter.Builder()\n//  set wanted filters\n  .build()\nIt is copy-pasted from the original Android API. You can add zero or more ScanFilters to a scan. Unlike the old API the new one will emit ScanResults even if only one ScanFilter will match (in case you add many) which is inline with the original Android API behaviour. Does it answer your question?. As you can see in the interface of RxBleClient the .scanBleDevices(ScanSettings, ScanFilter...) function is accepting ScanFilters as varargs. You can add none or an arbitrary number of ScanFilters to the function after the ScanSettings\nIn the sample project you can see an example with ScanSettings and one ScanFilter:\nscanSubscription = rxBleClient.scanBleDevices(\n                    new ScanSettings.Builder()\n                            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n                            .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)\n                            .build(),\n                    new ScanFilter.Builder()\n                            // add custom filters if needed\n                            .build()\n            )\nbut you can add more:\nscanSubscription = rxBleClient.scanBleDevices(\n                    new ScanSettings.Builder()\n                            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n                            .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)\n                            .build(),\n                    new ScanFilter.Builder()\n                            // add custom filters if needed\n                            .build(),\n                    new ScanFilter.Builder()\n                            // add custom filters if needed\n                            .build(),\n                    new ScanFilter.Builder()\n                            // add custom filters if needed\n                            .build(),\n                    new ScanFilter.Builder()\n                            // add custom filters if needed\n                            .build()\n            )\nDoes it answer your question?. There are Javadocs, samples and the API is written in plain old java - nothing fancy. If you are using Android Studio - you can use keyboard shortcuts to peek Javadoc (cmd + j by default if I remember correctly) and what parameters a function accepts (cmd + p).\nYou're welcome. Closing.. Thanks for the report. Unfortunately as you have mentioned it is a bug in Android OS and there is nothing we could do on the library side. Maybe it would be possible to workaround this issue by using reflection and reworking the discovered items. May be worth investigating if someone has time. As for now \u2014 closing.. Yup, no doubts about it. Thanks again for the info! :). I will create a fix tomorrow and I will ask you to test it. ;). This is now fixed and should be available shortly in 1.3.1-SNAPSHOT. Please try it out and report back if it fixed the behaviour for you or not.. This is actually a more general problem with unsubscribing from operations while they were running. Should be fixed now but it may use a refactor later on. Please test it and share if it helped.\nBest Regards. Hello @Pascal66\nPlease read the disclaimer on your post and at least provide more information because in the current it is impossible to tell anything.. Unfortunately I cannot tell anything without more information from inside the application with RxBleLog.setLogLevel(RxBleLog.VERBOSE) being set.\nThe library supports the official Android BLE API. I do not know what exactly your custom ROM changes and how does it work with the Android API.\n\nWhat can i do ?\n\nYou can fork the library source and try to make it work with your setup. Alternatively you could try to use the vanilla Android API but I suspect that it will not work as well since the library relies on that.\nAs for now I close this issue since we only support official API. If you will get more relevant information that could shed some light on what is actually happening \u2014 feel free to comment \u2014 I will definitely read what you will add. I cannot promise more.\nBest Regards. From the log above I can only tell that BluetoothAdapter.startLeScan() happened to block the function call for 10 seconds. It is a custom ROM and this implementation seems to work differently than the original.. Thanks for spotting @RobLewis\nFixed.. Hello @lorenzowoodridge \nDoes this characteristic needs encryption? Can you give more information about properties / permissions it (and the descriptor) has?. It looks weird - none of the listed items have any permissions. Anyway so far it does not seem to be a problem with the library so far. Feel free to investigate further if you think otherwise.. It is not called twice but reverted after the descriptor write fails - then the whole .setupNotification() function fails and the notification is tear down to not saturate the limit of active notifications.. Maybe the peripheral is returning different permissions if it is already paired?. @Ezor Check what status=128 means. It is probably that you try to set too many notifications (Android has limits) or a notification of a wrong type. It is probably not related to the topic of this issue.. I think that you may have a bug on the peripheral side. I can see that your characteristic supports reads and notifies. What I do not see is that your Client Characteristic Configuration Descriptor supports writes. This may be causing the problem.\nEither way. Currently the library is not supporting encrypted characteristics so it is up to the user to work it out.. To sum up:\n Out of the box support for bonding and usage of encrypted characteristics is not yet available \u2014 there is an already opened issue for it though (#35 and #47) \u2014 Once a bulletproof solution will be developed we will add it to the library. If anyone would like to contribute \u2014 you are welcome. :)\n For user's that will try to perform an unsupported operation on a specific characteristic a warning log will be displayed (#224). When a new API (#239) will be introduced the check will throw an error by default (so people will not be surprised why they get an error if they try to i.e. read a characteristic that is not readable) but the user will be able to suppress it for a given connection.\nClosing.. Try version 1.3.1 and post the logs.. There was a bug in between 1.2.3 and 1.3.0 where unsubscribing from operations would cause the library to get stuck. It was fixed in 1.3.1. Good that it works now.. The viability check will result in a log warning in 1.4.0. With the new connection API #239 it will be emitting an error by default. . BleCannotSetCharacteristicNotificationException is quite accurate in this situation as that is actually what is happening. What can we do:\n\nEmit the exception that caused the disconnection. This could fit in a patch release (it would be either BleDisconnectedException or BleGattException) as it would be in line with how the library works on different requests. \nWrap BleGattException in BleDisconnectedException. It would be a change in the behaviour and should wait at least till 1.4.0 release.\n\nI can go with the first point now and the second for 1.4.0. Would that fit your idea?\nP.S. You should not use Observables derived from an RxBleConnection after that connection has been disconnected. It shows that you have more than one .subscribe() call. It is not a good idea when using RxJava as it may introduce state somewhere. While using BLE the connection is stateful and that is why a single .subscribe() should be used.. @kanat Yes. If the .establishConnection() will emit an error then no observable derived from the connection should be used - they will emit an error anyway. \nSo far it seems that your use case also could be fulfilled with only one .subscribe(). You can open a question on www.stackoverflow.com with a tag rxandroidble and rx-java and someone will answer on how to get the connection error there.\n@RobLewis Your question should go to www.stackoverflow.com as well as it is a general question about how to use rx-java. Do not close it. I will leave it be until I will better specify the behaviour.. @kanat Feel free to check and comment the above Pull Request wether it will be useful for your use-case.. Is available in 1.4.0-SNAPSHOT. Hello @leof23 \nYou are probably hitting this issue\nIf that is the case the library can do nothing to prevent this behaviour. It may be feasible to emit a new BleScanException in that case or the library would need to throttle scan requests on Android 7. I will think about possible solutions.. I will keep this issue opened as a reminder for me.. Is available in 1.4.0-SNAPSHOT. Feel free to add a feature request though I think it is simple to create it without bloating the library's code base by utilising .retryWhen() operator and triggering the retry when the time will pass. We have it in plans.\nDuplicate of #72 \nClosing. First of all you can create a ScanFilter with a name filtering. Secondly I do not see anything in the log from the Asus. No Stop Scan or any error. I do not have this device to check it by myself here either. Feel free to dig deeper.. It looks like a model specific Android BLE implementation bug. I do not have access to this model so unfortunately I can do nothing remotely. You can try to find a solution yourself and create a pull request or post your findings here.. Hello @lukevr\nNo \u2014 there is no such list.\nWe are doing our best to make the library as generic as possible without the need to maintain a model/vendor specific workarounds in the code.. What library version do you use?. No problem. So this was a duplicate of #218 \nGood to hear that it is solved.\nBest regards. @RobLewis No.. From Javadoc:\n/**\n * Returns an observable emitting state _changes_ of the RxBleClient environment which may be helpful in deciding if particular\n * functionality should be used at a given moment.\n *\n * @see #getState() for {@link State} precedence order\n *\n * Examples:\n * - If the device is in {@link State#READY} and the user will turn off the bluetooth adapter then {@link State#BLUETOOTH_NOT_ENABLED}\n * will be emitted.\n * - If the device is in {@link State#BLUETOOTH_NOT_ENABLED} then changing state of Location Services will not cause emissions\n * because of the checks order\n * - If the device is in {@link State#BLUETOOTH_NOT_AVAILABLE} then this {@link Observable} will complete because any other checks\n * will not be performed as devices are not expected to obtain bluetooth capabilities during runtime\n *\n * To get the initial {@link State} and then observe changes you can use: `observeStateChanges().startWith(getState())`.\n *\n * @return the observable\n */\npublic abstract Observable<State> observeStateChanges();\n\nTL;DR Yes.. There is an alternative on how to check for this error but it would need to parse the log on the device. Probably not the most performant but an interesting idea though.. It is possible but only to parse your own app logcat. Unfortunately the log about excessive scans comes from the system and is not reachable programmatically.. It looks like the service discovery fails on your Sony XPERIA L1. You can try the vanilla API but I expect the same result as the library does nothing fancy. It is weird that no other logs are available.. Hello @6bangs \nCould you explain in a bit more detail how do you achieve that? You want to have a constant stream of Heart Rate with a fixed interval - do you perform a read operation once every second (or a different amount of time) for that or do you use notifications? The library is implementing a priority queue but it is not available through the API. It would be possible to add for instance a low priority characteristic write to the next API.\nAgain if you would describe your use-case in greater detail - I will be able to think about how to make it possible.\nEdit: And to answer your question - it is only possible to have a single RxBleConnection to a specific device at any given moment. You will get BleAlreadyConnectedException if you will try to open a new connection to the same device when it is already established.. @6bangs The BleAlreadyConnectedException is a conscious decision to prevent people from interfering with their own interactions with the connection from different places in the code. This decision was taken because it is impossible to create BLE connections in the same stateless manner as HTTP.\nIt is possible to achieve what you want but you would need to put the OTA and updating the state of the peripheral in the same RxBleRadioOperationCustom and manage writes all by yourself.. This will not be included in 1.5.0. We currently have limited capacity and decided that support for RxJava 2 is of greater importance. The new API will get included once it is ready... Hard to say when.. Thank you very much. You have a great sight. \ud83d\udc4d . Hello @Esperanz0 \nFirst of all could you give info what device do you use, OS version, library version does your peripheral is changing services or you use BluetoothGatt.refresh() and how reproducible is this scenario? So far it seems that you are facing a native Android BLE bug.. 0x85 = 133 which is the dreaded GATT_ERROR. There is no difference in the discovery mechanism in between OS versions. Does your peripheral use Service Changed characteristic?. But you can check on the device that does not exhibit the bug if a Generic Attribute Service is discovered.. @Esperanz0 Any luck? Have you tried to postpone service discovery for at least 2 seconds after getting the connection?. Closing due to inactivity. Too small amount of info. Feel free to reopen if something new will appear.. Never seen this behaviour. Hey @prefanatic \nIt indeed looks like a bug in the library. But RadioReleasingEmitterWrapper was made exactly for this use-case - to always release the radio after completion. \nCould you add a synchronized keyword to onCompleted() and onError() of RadioReleasingEmitterWrapper? I think there might be a race condition there.\nI am off the office and I cannot perform the tests myself.. Yup it is still possible that the race condition could happen depending on what is the implementation of the Emitter. If you could add logs to onComplete(), onError(), onCancel() and paste a log with timestamps displayed to prove if this may be the cause.\nIt would need two synchronization flags to be sure that the RadioReleaseInterface.release() was called properly.\nAs a side thought I wonder what would happen if you would change this:\nObservable.combineLatest(dataOutSubject, control) {\n  o1, o2 -> o1\n}.first()\nto this:\nObservable.combineLatest(dataOutSubject.first(), control) {\n  o1, o2 -> o1\n}. @prefanatic Could you test this branch fix/issue_245_radio_release_race_in_operation if it would fix your use-case?. Should be available in 1.3.3-SNAPSHOT shortly and I will try to release 1.3.3 before the weekend.. Hello @Emeritus-DarranKelinske \nCorrect me if I am wrong. Your problem is that the logs are not showing in the logcat but if you put a breakpoint on them it fires properly?. Then it seems that you have some problem with your Android Studio. Have you tried searching Stackoverflow? For instance this may be helpful.. I did not encountered any problems with logging.. As this is not an issue with the library - closing.. Hello @ramanbranavitski \nAs far as I understand you are not reporting an issue with the library but you ask a question about the usage of scanning and filtering of Bluetooth Low Energy devices. \nThose questions and the knowledge held in the answers is easier to be found by other users on www.stackoverflow.com with a tag rxandroidble. Please post a question with appropriate tags there and someone will try to help you.\nBest Regards. Reference.. Hello @vibexie\nThis issue is a duplicate to #53\nYou can find there how you can use the .refresh() method there. You could also share there your exact use-case \u2014 when you would like to execute the method \u2014 if it would at the beginning of a connection, on end or in the middle.\nBest Regards. Hello @Jogosb \nThe single RxBleClient instance is recommended because it is serializing all bluetooth actions to make the experience more stable. It is possible that the library serializes too much when it comes to multiple connections but it was not tested and the experience may vary between implementations of the BLE stack from different phone vendors. This use-case is not defined / documented in any way.\n\nis there any way to handle two devices using one rxBleClient without problem I described before?\n\nUnfortunately no \u2014 currently it is not possible\n\nIf not, are there any crucial downsides of using two rxBleClients?\n\nIt is not tested in any way and you may experience weird behaviour / bugs.\nFor sure actions on a single BluetoothGatt are needed to be synchronized or the next action will not start (i.e. BluetoothGatt.readCharacteristic(BluetoothGattCharacteristic) will return false unless the previous action will finish with a corresponding BluetoothGattCallback). If you could test if actions on two or more BluetoothGatts have to be serialized in the same way as on a single BluetoothGatt if would be great and could make the library better.\nBest Regards. I have just merged a pull request that should make additional RxBleClient's obsolete \u2014 now the same behaviour should be possible to get with only just one. Handling of multiple connections should now be better \u2014 stalling of one connection should not interact with others.\nThe change should be available in 1.4.0-SNAPSHOT shortly.\nBest Regards. There are some minor things to finish. Maybe I will be able to release today. If not then early next week. Still waiting to clarify #275 :). Thanks @vpratfr , fixed.. Hello @vpratfr \nThis is intended. As you can see in the Javadoc of BluetoothAdapter.enable():\nTurn on the local Bluetooth adapter\u2014do not use without explicit user action to turn on Bluetooth.\nHaving a wrapper for BluetoothAdapter.enable() and BluetoothAdapter.disable() could encourage users to play with the adapter state by themselves whereas it is more polite to ask the application user to change the state of the adapter via an intent:\nIntent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\nint REQUEST_ENABLE_BT = 1;\ncontext.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);\nAlternatively if the library user does want to violate the application user's right to decide about the state of their phone it is possible to call:\nBluetoothAdapter.getDefaultAdapter().enable();\nBest Regards. With @uKL we have agreed that managing of the Bluetooth Adapter state is out of scope of this library. I have added a few words about turning the adapter on/off in Readme.\nBest Regards. Hello @dagi12 \nWhy do you think it is an issue with the library and not native Android BLE stack? The library just starts a scan and translates the result from the OS which in this case was SCAN_FAILED_INTERNAL_ERROR.\nCould you paste the exact code that you are using?\nI do not have access to the said phone with 5.0 so I cannot test it myself. It is possible that the other  applications use either the legacy API. Which other applications have you checked against?. Closing due to inactivity. Feel free to add more info when possible. Naturally this change will be described in the Changelog.. Hello @Esperanz0 \nUnfortunately I do not see anything at first glance and I am a little short on time to debug this code. Looks weird that even with .onBackpressureDrop() it still have this exception.\nYou can try to print the whole stacktrace and check it yourself.. Yeah, assembly tracking could be helpful. Plus the full stacktrace of the exception.. Yeah, I am monitoring stackoverflow for questions related to the library. :) TIL a new Thing\u2122. I would add it by myself if you would not link it.\nAnyway \u2014 I am closing this issue.\nI do not think that the library should handle back-pressure by itself as there are many possible ways of handling it (and each use-case could use a different way of handling) and it would need another knob in the interface. Maybe with the new API #239 I will add a back-pressure handling switch.. @TeemuStenhammar Hello\nI did not encountered this problem myself yet and I am a bit short on time at the moment. What you can do is to paste a full stacktrace with and without the RxJavaHooks.enableAssemblyTracking() and by the full stacktrace I mean not the one that is cut after 4000 characters \u2014 you can use Timber for instance which prints long logs without a problem.. @TeemuStenhammar Sorry for such a delay (I was on holiday)\u2014could you add on what phone did the problem surfaced? How quick and of what size the notifications are?. Finally I had time to dig into this issue. I have prepared a peripheral that sends out ~400 notifications per second and it worked as long as the consumer was quick:\ndevice.establishConnection(false)\n        .flatMap(connection -> connection.setupNotification(uuid))\n        .flatMap(observable -> observable)\n        .subscribe(\n                bytes -> Log.i(\"Received\", \".\"),\n                throwable -> Log.e(\"Error\", \"Whoops!\", throwable)\n        );\nThen I have made the consumer slower by adding a Thread.sleep(10) and I quickly got MissingBackpressureException. I have then started to play with .onBackpressureDrop() and adding it right before .subscribe() did not fixed the issue. I have checked the Javadoc of .onBackpressureDrop() and it says:\n* If the downstream request count hits 0 then the Observable will refrain from calling {@code onNext} until\n     * the observer invokes {@code request(n)} again to increase the request count.\nThen I have checked the Javadoc of .subscribe():\n*  <dd>The operator consumes the source {@code Observable} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).</dd>\nThis means that applying .onBackpressureDrop() just before .subscribe() does nothing as the .subscribe() is not applying backpressure to the upstream. .onBackpressure*() should be applied before an operator that applies backpressure to the upstream i.e. .observeOn(Scheduler) which Javadoc says:\n*  <dd>This operator honors backpressure from downstream and expects it from the source {@code Observable}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before</strong> applying {@code observeOn} itself.</dd>\ni.e. this will work:\ndevice.establishConnection(false)\n        .flatMap(connection -> connection.setupNotification(uuid))\n        .flatMap(observable -> observable)\n        .onBackpressureDrop()\n        .observeOn(Schedulers.computation())\n        .subscribe(\n                bytes -> {\n                    Log.i(\"Received\", \".\");\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                },\n                throwable -> Log.e(\"Error\", \"Whoops!\", throwable)\n        );\nbut this will not:\ndevice.establishConnection(false)\n        .flatMap(connection -> connection.setupNotification(uuid))\n        .flatMap(observable -> observable)\n        .observeOn(Schedulers.computation())\n        .onBackpressureDrop()\n        .subscribe(\n                bytes -> {\n                    Log.i(\"Received\", \".\");\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                },\n                throwable -> Log.e(\"Error\", \"Whoops!\", throwable)\n        );\nSummary: the behaviour of the library is correct. The aim of RxAndroidBle is to provide all BLE events to the user. Applying backpressure mechanisms inside the library would make it harder for the user to understand why they would not get all the notifications the device has sent if they consume them too slow.. Hello @vpratfr \nThe thing is that the built-in filtering may be offloaded to the native part. What you would like to have could not be offloaded and is easy to achieve by utilising the RxJava .filter() operator.. Hello @leof23 \nThis is a question about the usage of the library. As it was written in the disclaimer these questions should be addressed on the Stackoverflow with rxandroidble tag where the knowledge is more easily accessible for others.\nBest Regards. Hello @lukevr \nYou are probably testing on Android 5.0+. I cannot find the source right now but the Android considers BLE scanning to be a battery expensive operation and after a longer period of time it switches back to a more relaxed timings for scan or even stops the scan. It has nothing to do with the library itself.. https://stackoverflow.com/questions/43833904/android-bluetooth-le-scanner-stops-after-a-time/44488991#44488991\nThe degraded performance has nothing to do directly with the library and beacons use-case is out of scope to be honest. Closing.. Hello @jdrider \nIt is possible that your issue is related to #128 \nI am currently a bit constrained on my time and @mzgreen as well so I cannot give any estimates on when we will address this issue. If you have the time to dive into this \u2014 you are more than welcome.. Closed by mistake \u2014 missclick.. Unfortunately it is not possible to solve without fully wrapping the Android API in the library.\nCurrently the Android API is visible in the Library API \u2014 we have started internal discussion on wether / how to fully enclose the Android API.\nThe Mock Library was initially (at least by me) considered to be a drop-in replacement for in-app usage \u2014 not for using in tests but @uKL has memories that suggest it should work also in the tests.\nBottom line \u2014 in the current state the Mock Library will not work correctly if the Android sources are not available. A potential workaround is to use Robolectric in the tests. We are considering an API that will fully enclose the Android API and would make it possible to use the Mock Library virtually everywhere.. I agree - this is misleading. We will add the note and we are evaluating an idea to enhance the new API proposition #239 to wrap the Android API fully - it would allow to use the mock library in the unit tests without the need of Robolectric.. Should be available in 1.3.4-SNAPSHOT shortly.. Hello @toaderandrei \nI assume you have already managed to achieve what you need?. You would probably could use RxBleDevice.observeConnectionStateChanges() on version 1.4.0-SNAPSHOT which emits at almost exact moments when BluetoothGatt changes states.\nUnfortunately there will not be any explicit .disconnect() method / function.. > is there any plan to update to rxjava 2?\nYes\n\nwhen will you update to rxjava 2?\n\nDon't know yet \u2014 first we are developing a better suited API #239 to test it before major version update\nRxJava 2 related topic \nBest Regards. Reconnect function should be based on the RxBleDevice.establishConnection() as this is the point which is dealing with the connection. RxBleDevice.observeConnectionStateChanges() is just a shortcut if one would need to display the state (the only value that is emitted from this observable) in the UI. I do not get your use-case nor what you are trying to achieve unfortunately. Thanks for bringing it up. We are aware of this new standard and we will see if/when it will be available in the Android API\u2014we will evaluate this issue again then\u2014currently we have enough on our plate to deal with. :) \ud83d\udc4d . @evansherry the status=133 is a generic GATT_ERROR message. It is caused mostly by how the BLE stack works internally on your phone. The issue is most probably related to how your peripheral\u2014phone pair works.\nIf you would like to have more information you would need to get detailed HCI logs from a Xiaomi/Huawei device that shows the problem and another from a phone that works fine.. Is the annotationProcessor in a stable version already?. Great! \n@mapyo \u2014 could you merge the current top of the master branch so I could cleanly Squash and merge this PR?. Merged, thank you. \ud83d\udc4d . Thank you for spotting and the fix!. Hello @hoanglm4 \nAre you sure that all subscriptions to RxBleDevice.establishConnection() are unsubscribed? In the 1.3.x branch the connection state reporting is quite naive and report's DISCONNECTED state when the unsubscription happens.\nAnyways a good finding as this would be definitely a problem in 1.4.0. It was probably some kind of a race condition. Anyways \u2014 I'm glad that it works in the develop branch.\nBest Regards. Could you check against 1.4.0-SNAPSHOT version? The code related to reporting state has changed there.. @hoanglm4 I have just pushed a new version of 1.3.4-SNAPSHOT \u2014 it should now properly handle situation when BluetoothAdapter is turned off. Could you check it out?\nEdit: it is a new 1.3.4-SNAPSHOT version. @hoanglm4 my bad \u2014 just pushed a fix. There should be a new version of 1.3.4-SNAPSHOT available in around 10 minutes. Feel free to re-check.. I am happy to hear that. :) Thank you for your report.. @hoanglm4 I have just released an official 1.3.4 version :)\nBest Regards. I will probably try to release it tomorrow.. FYI\u2014it is released.. Thanks for pointing that. English is not my first language and I have added this issue quite late in the evening. ;). Yes\u2014that is what I had in mind\u2014it may fix some issues on <M. We would need to track on which Android SDK this method was introduced.. So it could be valueable to use the method by reflection on Android L even if autoConnect=false. It could help with service discovery and potentially bonding problems. But maybe it would help in situation when the Android OS does kick-off bonding after GATT_INSUF_AUTH response to read/write characteristic?. We are using TRANSPORT_LE whenever possible and it was a deliberate decision. Earlier versions of Android did pose difficulties when TRANSPORT_BREDR or TRANSPORT_AUTO was selected. In fact this is a BLE library hence the TRANSPORT_LE\nFrom my experience the GATT_INSUF_AUTHORIZATION should not disconnect the peripheral but only reject a characteristic write/read. I have seen disconnections (even Today in fact) with status 8 which were not connected with bonding as the peripheral did not support bonding at all (from my knowledge). So I think that this may be a misattribution.. @joaquinlateral You need to go deeper\u2122\nConnectionCompat is library's code. Hello @HolySamosa \nCould you give more context on how/when would you expect to use the value returned by .getMessage()?. @HolySamosa ping?. Closing due to inactivity. \nAll exceptions are typed and can be checked in the sources what they mean. Showing contents of the Exception.getMessage() in the UI is a bad thing to do as most of the time it contains some description that is not understandable for the user. For the development purposes one can use .toString() which is implemented in all BleExceptions for quick debugging.. Sorry to hear that.\nWe will evaluate the idea of adding messages. As a temporary solution you could map the RxAndroidBle exceptions to your own ones at the boundary of the layer that knows about the library. :). If you are mapping the exceptions then why the need for the messages? As far as I remember the library only uses exceptions that are declared in /exceptions.. Ping? :). I am thinking if this solution would be feasible?\n@Override\npublic String getMessage() {\n    return toString();\n}\nAll library errors print with as much details as possible.. Hello @Ezor \nThe status=133 is the generic GATT_ERROR. So far it looks like there is a bug in Xiaomi BLE stack (which probably will not be fixed without OS update) but it could be possible to fix it by changing interaction with your BLE peripheral or by changing the firmware of your peripheral.\nWhat you can do to gather more information is:\n\nCheck what properties the BluetoothClient.MODE_UUID has (BluetoothGattCharacteristic.getProperties()\nEnable the Bluetooth HCI snoop log and paste the output here so it would be possible to compare what Samsung does and what happens on Xiaomi. I would not consider this issue fixed but rather worked around. ;)\nIt may be because the peripheral is sending some packets at a particular time that makes the Xiaomi stack go nuts and changing the sequence makes it work.\nI am curious what exactly is causing the BLE stack to return GATT_ERROR on Xiaomi. If you could please upload the HCI logs that show the problem from this Xiaomi and the Samsung so I could examine them and learn.. Closing due to inactivity.. @RobLewis Since 1.4.0 operations that are requested but are not supported by the characteristic properties are logged as a warning. There is also an issue #259 which will be released with #239 - it will cause the above mentioned operation to emit BleIllegalOperationException with a explicit cause.. Hello @Mike-bel \nPlease try to conform to the template that is given when creating an issue.\nWithout btsnoop_hci.log file I cannot tell anything 100% sure but most probably it is a mobile BLE stack problem.. It is a file that contain low-level BT communication logs. You can find how to enable the log here. Please make sure that only one connection try is logged. Another file from another phone that is working ok would be good for comparison.. If I will have a moment next week I will look into the logs to see if I can spot the problem.. Hello @Mike-bel \n\nI have looked into both files and in the one that failed I do not see any indication that the connection was about to be established\u2014I see only logs related to the BluetoothAdapter being turned on.\nJudging from the Java logs however I see that the BluetoothGatt.close() was called right before the next BluetoothDevice.connectGatt(). If the previous connection was successful then maybe you should avoid establishing a new one for ~1 second.\nThere is nothing more I can say now unfortunately.. Closing due to inactivity. If new info will be available\u2014feel free to reopen.. Wireshark is reading the raw data that the BT controller sends. In this article there is a part about using Wireshark which may be useful to you. You could check for the HCI log documentation on Google and/or Bluetooth 4.2 Spec. . I see in the logs that eventually you have connected. It looks like the problem is on the Android BLE stack side. You could try to reboot your device/bluetooth adapter and see if it happens again. Just remember that after this you should first scan your device before trying to connect with autoConnect=false. There is a bug in resolving the address.. Are you sure that the activity is destroyed by the time LeakCanary fires? (I have not used id so I do not know).\nOne thing you can do is to put a log in .onDestroy() and check if it is available in the logcat before the LeakCanary statement.\nThe other possibility would be to move unsubscription to an opposite event of .onStart() -> .onStop().\nAnd as a matter of fact even calling .scan() makes a reference to your Activity. :). Ping?. Impatiently waiting. :) \ud83d\udc4d . I think that @streetsofboston comment may pinpoint the cause of the observed leak. Closing for now. If new information will be available\u2014feel free to reopen.. Hello @RobLewis \nThe library does not use Handlers in any way. It is emitting values on arbitarary Thread and it is not guaranteed to have a Looper (it does not have to be precise when it comes to using a RxBleConnection).\nScan related emissions (unlike connection) are not routed to any specific Scheduler - they use the default Android callback thread which apparently has a Looper. It is an implementation detail an may be changed in the future versions of Android so it should not be relied upon.\nToast class rely on being called from a Thread that has a Looper. To be sure that is the case you need to put .observeOn(AndroidSchedulers.mainThread() or any other Thread that has a Looper before you are using an instance (object) of the Toast class.. I am not sure how Toast works internally- I rarely use it. Best practice would be to use it on the main thread anyway.\n\nOffhand, are there any use cases where you might want to display a Toast from a different thread (with a Looper)?\n\nI don't think so.. Have you tried suggested stackoverflow solutions?. How about clean + rebuild?. It looks like a bug in your local build toolchain. The sources are a part of the distribution package of the library.\nYou can use the Invalidate caches and restart option from Android Studio menu.\nEither way this is not related to the library itself.\nBest Regards. Since there are no new posts here I assume that the problem is solved. Feel free to reopen if not.. As you can see in the logs:\nCaused by: BleGattDescriptorException{macAddress=F5:56:71:04:1B:60, status=3 (0x03 -> https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h), bleGattOperationType=BleGattOperation{description='DESCRIPTOR_WRITE'}}\nIt means that the BluetoothGattCallback.onDescriptorWrite() was called with status=3. Going to https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h and searching for 0x03 gives three results:\n #define  GATT_WRITE_NOT_PERMIT               0x03\n #define  GATT_RSP_MTU                        0x03\n* GATT_FORMAT_NIBBLE,         /* 0x03 nibble */\nOf which only the first has sense as writing a descriptor is not an MTU related operation nor it is related to format in any way.\nTL;DR\u2014the peripheral you are trying to update does not a permit to write the Client Characteristic Config Descriptor or it is some kind of Android BLE stack bug. Either way it does not seem to be possible to fix it from the library side.\nBest Regards. Hello,\nFrom the Javadoc:\n/**\n     * Returns an observable emitting state _changes_ of the RxBleClient environment which may be helpful in deciding if particular\n     * functionality should be used at a given moment.\n     *\n     * @see #getState() for {@link State} precedence order\n     *\n     * Examples:\n     * - If the device is in {@link State#READY} and the user will turn off the bluetooth adapter then {@link State#BLUETOOTH_NOT_ENABLED}\n     * will be emitted.\n     * - If the device is in {@link State#BLUETOOTH_NOT_ENABLED} then changing state of Location Services will not cause emissions\n     * because of the checks order\n     * - If the device is in {@link State#BLUETOOTH_NOT_AVAILABLE} then this {@link Observable} will complete because any other checks\n     * will not be performed as devices are not expected to obtain bluetooth capabilities during runtime\n     *\n     * To get the initial {@link State} and then observe changes you can use: `observeStateChanges().startWith(getState())`.\n     *\n     * @return the observable\n     */\n    public abstract Observable<State> observeStateChanges();\nIt clearly states: changes\nYou can use .startWith(rxBleClient.getState()).. Should be fixed with #294 . Have you requested the MTU before you have executed the above code? Are you sure that your peripheral supports higher MTU?. Could you add logs from the Android OS with RxBleLog.setLogLevel(RxBleLog.VERBOSE)?. Unfortunately in the above log there is no indication that BluetoothGattCallback.onMtuChanged() has been called so the Android application was not informed about the change of the MTU.\nRxBleLog.d(\"onMtuChanged mtu=%d status=%d\", mtu, status); does get called when the library is informed about the MTU change. There is no onMtuChanged string in the attached log. This seems to be a problem with Android BLE stack. What OS / phone model do you use?\nBtw. The LongWriteBuilder does use the maximum negotiated MTU by default if not specified otherwise so you could remove this line: \n.setMaxBatchSize(getMaxDataSize(connection))\nAlternatively you could try to specify .setMaxBatchSize(158-3) as a workaround. If the lower layers of the BLE stack would send the data appropriately. But it is not a bulletproof solution.. The library will pass the byte[] of length 155 down to the Android BLE stack. The Android BLE stack will handle it some way (it does truncate it from my experience)\nIf one does not specify .setMaxBatchSize() then the library sends batches of the MTU - 3 size by default. If the library is not informed by the Android BLE stack about MTU change it defaults to 23 - 3 bytes.. This issue was about a situation where peripheral initiated MTU change was not correctly handled by the library. Your problem is different though related to MTU as well. Please create a new issue if needed.. @petri-lipponen-suunto are you aware that you did not triggered the MTU change in the above example?\n```\nmSubscription = device.establishConnection(false)\n                .flatMap(new Func1>() {\n                    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n                    @Override\n                    public Observable call(RxBleConnection rxBleConnection) {\n                        Log.d(TAG, \"BLE connected to \" + bleDeviceAddr);\n                    // Request for a big MTU in case the device supports it\n                    Log.d(TAG, \"requestMtu GATT_MTU_MAXIMUM: \" + GATT_MTU_MAXIMUM);\n                    rxBleConnection.requestMtu(GATT_MTU_MAXIMUM);\n                    connMap.put(bleDeviceAddr, rxBleConnection );\n                    return rxBleConnection.discoverServices();\n                }\n            })\n\n`` \nThe result of therxBleConnection.requestMtu(GATT_MTU_MAXIMUM)is anObservable` which needs to be subscribed as any other observable to trigger the action.. I see that you have already posted a question on stackoverflow\u2014answering there.\nAs it is put in the disclaimer\u2014this question is not a bug nor a feature request but a question about usage and this is not a good place for answer. Closing.. Yup, this is just a verbose log in the console. It should not cause any problems. Does it?. @mbmc Ping?. Hello,\nThere are no plans for that yet. But PRs are welcome! :). Hello @connected-jallen!\nThank you for your pull request\u2014it looks promising!\nThere are two things that make me think:\n1. Now we loose the ability to call (BleScanException| BleCannotSetCharacteristicNotificationException|BleDisconnectedException).toString(). It would be a regression in terms of the funtionality\n2. The exception message is usually a sentence that is easy to read by a human. The former implmenetation of .toString() gives all relevant information but does not make too much sense for a user that is not into BLE. Maybe the message could be just a sentence? i.e. having a BleScanException with a reason LOCATION_SERVICES_DISABLED could have a message like Cannot start a scan due to Location Services being disabled\nWhat do you think? I look forward to discuss and merge your changes.. That's true, we already have an opened issue for the messages #279 \nI am thinking wether we should make the message more readable for non-tech savvy users. What do you think about it @connected-jallen ?\nThe class name indeed seems to be superfluous here.. Thanks for the PR @mapyo and @friederbluemle @passsy @piotrek1543 for review!\nI would like to have two things:\n1. Merge master to this branch so we could use Squash and merge when appropriate\n2. I agree with @uKL that tests should be working before merging this PR. Apparently the groovy/groovy-android-gradle-plugin#156 is blocking us\nWe should either wait for a plugin in version 1.3.0 or to workaround the issue somehow?. I have looked on the list quite some time ago already and I think that it is meant to be more a \"scareware\" than a list of issues. Though there are valid points there.\nA few thoughts about the features mentioned in the post above:\n\n--Use occasional bursts of scanning to simulate continuous scanning (which, according to the article, is guaranteed to fail eventually)\n\nThe scanning on Android is quite energy consuming and the settings are automatically managed by the OS. After a while even the LOW_LATENCY scan is turned into OPPORTUNISTIC mode. I do not think that fighting against the OS is a good idea. There is however a new  that could be fit for prolonged/background scanning.\n\n--Automatically re-establish dropped connections\n\nThis I think is very use-case dependent. Usually the connections are somehow stateful and restoring the state may be different for each project. Restoring the connection should be done on the RxJava layer above the library. The library itself should only make it possible to do.\n\n--Automatic management of the AutoConnect flag (determine what works best for a given pair of devices and remember it for the future)\n\nI think that this point is a bit misleading in the mentioned list. Some devices (i.e. Samsung) after turning on the BluetoothAdapter need to scan a BluetoothDevice before BluetoothDevice.connectGatt() call would succeed. Using autoConnect=true does just that\u2014it starts a periodic, low-powered scan in the background and connects after the peripheral is scanned. Although it would be a good idea to have this fixed somehow. The best solution would be to find out when a direct connection would fail and the start a scan before connecting.\n\n--Provide a global Bluetooth reset if things get completely screwed up\n\nCould be useful though I have not been in a situation where I would need to do such things for quite a long time now. This was the case mostly for devices with API 18, 19 which are a margin right now.\nBest Regards. Hello @hoanglm4 \nI have just pushed a fix for this issue. It should be available in 1.4.3-SNAPSHOT shortly. Could you give it a try?. I think this may be closed now with the plugin in version 2.0.0.. Hello @simonratner \nThis is a good idea! And at this moment it should be possible to make appropriate changes just to the NotificationSetup class on feature/issue_213_new_connection_api branch and make a PR to #239 \nThe same approach could be used for the setCCCDescriptor. Auto would set the descriptor by default if it exists and would not if it does not.. This issue is a part of #213 and #239. The new API aims for fully wrapping the Android OS objects.\nI am also thinking if there is really a need for the MockClient in the unit tests. It should be possible to inject your own mock implementations of RxBleDevice and RxBleConnection. As @mzgreen has mentioned above the MockClient was created as a quick drop-in replacement for the library if the peripheral you want to use is not available but still you would like to use mock it in the application.\nIt could be put up for a discussion if we should remove this part of Readme.md:\n```\nUnit testing\nUsing RxAndroidBle enables you to unit test your application easily. For examples how to use mocking head to MockRxAndroidBle.\nNote: Using MockRxAndroidBle in unit tests needs Robolectric.\n``. I think that this kind of a test would effectively test theMockClient` behaviour where the user's application logic should be the subject.. Hello,\nThanks for using our library!\nThis does not seem to be a bug in the library itself because as you have mentioned the code works on other devices. If you need support:\n non-commercial\u2014head to StackOverflow tag rxandroidble\n commercial\u2014drop an email to hello@polidea.com for more info. Hello @Esperanz0 \nI see a status=133 in your Actual result. Why do you think it is a problem with the library?. Try scanning the device after adapter off/on. Actually this question should go to the stackoverflow as this is a general usage question or rather an Android BLE stack quirk. Not an issue with the library. I was investigating the issue more deeply recently but unfortunately there is no good solution for the current state of the OS. I will probably create a blog post about the issue. Hello @Xinima \nThank you for using the library!\nThere are few things that come to my mind:\n1. Your code snippets do not seem to contain all the information about what do you do with the peripheral. In the first snippet there is a reference of writeCharacteristic which is not seen on the second snippet\n2. Using the library you can setup the notification by subscribing to RxBleConnection.setupNotification(BluetoothGattCharacteristic)\u2014you do not have to manually write the CCC Descriptor in most cases\n3. The log from 4.4 does not even establish a connection not to mention trying to write the descriptor\n4. The log from above 4.4 does not contain any information about the execution before the error\n5. status=17 means that the Gatt has no resources when writing the descriptor\u2014hard to say why without more informations\nAnyway\u2014I do not know what is the algorithm for the lock you are using. There is a lack of information on what actually you are doing with the connection. So far it does not seem that there is a bug in the library and as such this question should be posted on stackoverflow. RxBleLog.setLogLevel(RxBleLog.VERBOSE) without it there are no logs from the library.\nWhy do you use COMPAT mode of setting the notifications?. startOperation() returned success=true. Callback returned status=17 which is the final result of the operation. If this is a confusion to you I would encourage you to read some tutorials about BLE on Android.\nSo far it seems that your problem is in the BLE stack of the Android and/or the lock firmware. If you say that using the same phone/lock you were able to make it work- the only thing that comes to my mind is that the timing is bad in sense that the Connection Parameters are updated right before the descriptor is being written.\nYou could try postponing the notification setup/descriptor write a bit so they will trigger after the connection update.\nPosting logs from a successful unlock that you have mentioned at the beginning could also be useful to understand the problem with the connection.. In the log above there is no indication that the CCC descriptor is being written. Am I correct?. So this is not an issue with the library but rather with Peripheral Firmware or Android BLE Stack. In the case of this dongle none of the network or gps providers seems to be available. Could you check for the ~~fused and~~ passive?\n```\n    /*\n     * Name of the network location provider.\n     * This provider determines location based on\n     * availability of cell tower and WiFi access points. Results are retrieved\n     * by means of a network lookup.\n     /\n    public static final String NETWORK_PROVIDER = \"network\";\n/**\n * Name of the GPS location provider.\n *\n * <p>This provider determines location using\n * satellites. Depending on conditions, this provider may take a while to return\n * a location fix. Requires the permission\n * {@link android.Manifest.permission#ACCESS_FINE_LOCATION}.\n *\n * <p> The extras Bundle for the GPS location provider can contain the\n * following key/value pairs:\n * <ul>\n * <li> satellites - the number of satellites used to derive the fix\n * </ul>\n */\npublic static final String GPS_PROVIDER = \"gps\";\n\n/**\n * A special location provider for receiving locations without actually initiating\n * a location fix.\n *\n * <p>This provider can be used to passively receive location updates\n * when other applications or services request them without actually requesting\n * the locations yourself.  This provider will return locations generated by other\n * providers.  You can query the {@link Location#getProvider()} method to determine\n * the origin of the location update. Requires the permission\n * {@link android.Manifest.permission#ACCESS_FINE_LOCATION}, although if the GPS is\n * not enabled this provider might only return coarse fixes.\n */\npublic static final String PASSIVE_PROVIDER = \"passive\";\n\n/**\n * Name of the Fused location provider.\n *\n * <p>This provider combines inputs for all possible location sources\n * to provide the best possible Location fix. It is implicitly\n * used for all API's that involve the {@link LocationRequest}\n * object.\n *\n * @hide\n */\npublic static final String FUSED_PROVIDER = \"fused\";\n\n``. That is a good idea.\n~~I think that we should also extendCheckerLocationProviderwith theLocationManager.PASSIVE_PROVIDERcheck. It is not documented anywhere but so far it seems that it does not matter which provider is available if the user switched onLocation Services.~~. @ejbp Could you check the above?\nCould you run all location provider checks when theLocation Services` setting if off?. Hello @ejbp \nI have another trace on what could work for your case. Would you be so kind and check what does \nSettings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE) return when your location is being switched on and off?. @ejbp Ping? :)\nThe above info could potentially fix your use case but I would need to confirm that it works as I assume and I do not have access to the same Android Pen.\nP.S. Happy New Year!. You have written that you have three different values. Which one corresponds to when the Location (as shown is this picture) is switched on and which for off?. I think we have a winner. Could you just repeat the below test:\nLog.d(\"BluetoothCommManager\", \"Providers: \" + locationManager.getAllProviders());\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (Network): \" + locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (GPS): \" + locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (PASSIVE_PROVIDER): \" + locationManager.isProviderEnabled(LocationManager.PASSIVE_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (FUSED_PROVIDER): \" + locationManager.isProviderEnabled(\"fused\"));\nfor all cases from your above post? I would like to have those for comparison. Thank you \ud83d\udc4d . Perfect! Thank you\u2014your use-case should be addressed in 1.5.0 release :) \ud83d\udc4d . @ejbp this is already fixed in the 1.5.0-SNAPSHOT. Thank you for the help!. The official release should happen quite soon. In the meantime you can checkout the 1.5.0-SNAPSHOT. Closed by mistake. Closed by #332. Hello @ardmn \nFeel free to search the old issues. https://github.com/Polidea/RxAndroidBle/issues/203\nBest Regards. Hello,\nDo you say that the allocations are strange or the memory allocated is not released?. Well, yes- each notification received is packed into an object and emitted. If those objects are deallocated by the GC then everything is ok.. From the Javadoc of RxBleConnection.setupNotification():\n* Setup characteristic notification in order to receive callbacks when given characteristic has been changed. Returned observable will\n     * emit Observable<byte[]> once the notification setup has been completed.\nThis means that the emitted Observable<byte[]> is an object that will stream the notification byte arrays. But setting up the notification is also an asynchronous process and takes time.. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nYou should also search for NotificationSetupMode and related overload of setupNotification() function.\nBest Regards. This issue is solved since version 1.2.0. I have pointed you where is the solution you should look for. It is documented. What are your expectations? . There are few things to consider:\n\nThe user loses the ability to tell when is the exact moment the notification is successfully setup. There are cases where users need to wait for the notification to setup before proceeding with next BLE operations.\nThis exact behaviour is already possible to obtain by using NotificationSetupMode.COMPAT while setting the notification/indication. It makes the function to not write the Client Characteristic Config descriptor. Then the user just need to write the descriptor manually after they start observing notifications\nThere is an already merged PR Polidea/react-native-ble-plx#195 which enables this exact behaviour without changes in RxAndroidBle. As the issue is already fixed in react-native-ble-plx and there are doubts if the proposed solution should be integrated with the current API of the RxAndroidBle.\n\nThe proposed behaviour will probably get implemented with the new API as an alternative for the current one but it will need some work.\nThank you for your effort and have a happy new year using the libraries! ;). Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Hello @yusufonderd \nI would like you to give more information about this issue. Preferably conforming to the template. Logs, version of the library is a must\u2014without it I cannot do anything.\nBest Regards. Closing due to lack of information and inactivity of the original poster.\nWhen more data will be available\u2014feel free to add that information and reopen this issue.\nBest Regards. Hello again. We need logs from the library. RxBleLog.setLogLevel(RxBleLog.VERBOSE) and logs from the application. Raw bytes of the advertisement could also help to investigate if there was unable to parse scan record. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. stackoverflow question. Hello @recoverrelax \nThanks for using the library!\nYes, the approach you have taken is the one that I use myself. \nThe vanilla Android API allows for auto-reconnecting behaviour by using the autoConnect=true flag. Unfortunately there are some bugs connected with it so it is safer not to use it.\nThe library allows only for a single connection being established for a single RxBleDevice.establishConnection() subscription\u2014so you need to resubscribe. The easiest way is to simply use .retry() operator.\nI hope this clarifies it for you.\nBest Regards. Yup, indeed there is a problem. We will look on it Tomorrow.. The problem should be fixed now. You can check it by using the newest 1.5.0-SNAPSHOT. To get rid of the old one you can follow these instructions. 1.5.0-SNAPSHOT ;) Sorry for misunderstanding. I am thinking if this should land in 1.5.0 or 1.4.4... Thoughts?\nOn one hand the API does not change at all. On the other the we change the dependencies and someone could have used the transitive dagger dependency?. Antipattern or not-still it can be something that breaks builds.\nIf we agree that it is just a bugfix then we should go with 1.4.4 but I think we already have some additional changes towards 1.5.0 there. I am just thinking whether we should temporarily revert operation timeout changes, release 1.4.4 with the shaded dagger and then go back to 1.5.0 with the operation timeout changes applied again. Hello @hoanglm4 \nThank you for the report. Apparently there was an issue with DisconnectionRouter that prevented the RxBleAdapterStateObservable from being unsubscribed. It should now be fixed with #353 .\nYou can check out 1.5.0-SNAPSHOT if that is the case.\nBest Regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Hello @martiwi \nThank you for the idea. Definitely a nice to have! \ud83d\udc4d \nUnfortunately we do not have free workload at the moment so anyone interested could help us out and submit a PR :). It took some time but we have finally merged #357 \u2014 should be available in 1.5.0-SNAPSHOT already and in 1.5.0 in the upcoming days. \ud83c\udf89  Thank you for your effort \ud83d\udc4d . Just add the Changelog. I didn't find a moment Today to play with it. Tomorrow should be the day. Hello @martiwi - any news? Maybe I can help you with something?\nI see this feature just lacking some unit tests and it would be production ready for 1.5.0 release. Hello @martiwi \nYou can check if the whole chain has not failed at this point by using testSubscriber.assertNoErrors(). Additionally in the current test all batches after the first failed one will not be successfully completed as the subject is called with .onError(). Hello @streetsofboston \nActually for usage in the tests I would encourage you not to use MockRxAndroidBle but just to mock all of the interfaces of RxAndroidBle directly. It is easier to do than to wire in into the library mock (which is very neglected at this moment and is not high on the priority list). First of all mock-client was created as a simple replacement for the application when the actual peripheral is not physically accessible. It's functionality is limited at best.\nI have in mind an idea what could be done with it but it would be a complete overhaul of the current implementation. Unfortunately my time is limited.\nWill it be deprecated? In the long run\u2014I hope not. Currently this seems to be the case.. Hello @jayalfredprufrock \nThank you for using the library!\nAs you can see in the log above the native of BluetoothGattCallback.onCharacteristicChanged() has been called before BluetoothGattCallback.onCharacteristicRead(). It means that in this order the native Android BLE stack has processed those events. It is possible that those events have been transmitted on-air in different order but for that we would need to sniff the BLE packets.\nEither way there is no possibility for the library to tell what should be the correct order of the native callbacks.\nIt should be possible to handle this scenario on the application side. If you would need support you can find more info here.\nBest Regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Splendid! Thank you for the suggestions @RobLewis I have incorporated all of them \ud83d\udc4d . Hello @mohsenoid \nAs you have pasted: BleScanException: Scan failed because out of hardware resources (code 9)\nIt means that the hardware does not have enough resources to start a scan with the specified settings. It is not related to the library but the Android hardware limitations. It has an simpler implementation probably on the Bluetooth driver level?. You can check out the RxBleConnection.queue(@NonNull RxBleCustomOperation<T> operation);\u2014it should be possible to do whatever you want on the BluetoothGatt right after the connection is established.. No, the custom operation may be only executed when the device is connected. So the best idea is to execute it right after the connection.. It is not valid. The BluetoothGatt is closed by the library right after the disconnection. \nWhy it does not work when the device is connected?. Try this for refresh as a first operation after the connection. 1. Delay as the BLE stack is unstable after BluetoothGatt.refresh()\u2014you experience it as the service discovery exception\n2. Disconnect listener is to conform to the CustomOperation contract. But it should not matter in this situation\n3. Right after the connection is established before any other thing. You can see the implementation in the branch the link points. @GuillaumeBo Is there anything else I can help you with?. There is no info on when the stack stabilises so the 1 second is to be on the safe side. Usually a second of delay is not much since it is only needed sporadically (I see no reason to call BluetoothGatt.refresh() every time). Thanks for the info. Feel free to post your findings here. Do you want to keep this ticket opened? Or is this all and it can be closed for now?\nFor reference: #53. It is a BleGattCharacteristicException which you would know if you would use exception.toString() I think. The getters are available.. I have not yet done anything with the rx2 version\u2014if it is a compile error then probably some interfaces do not match in how you have implemented your operation. I don't have the full context to give you any hint yet. Hello @RobLewis \nIsn't it related to #328 ?\nWe have created an issue on the official tracker\nCurrently we have higher priority tasks on our list to take on. Any help is welcome.. According to the issue opened on AS tracker this should be already fixed. Closing.. Robolectric dependency is the issue for unit tests. Hello @TimoPtr \nYou can read more on the topic here: #318\nCurrently we have no solution that is bulletproof.... @TimoPtr \nwhen do you dispose your subscriptor?. So you have multiple dangling subscriptors because you create new here:\n```\n        button.setOnClickListener {\n        subscriptor = RxJavaInterop.toV2Observable(device?.establishConnection(false)?.doOnNext {\n            Log.i(TAG, \"connected RX\")\n        })?.subscribe({\n            Log.w(TAG, \"connected\")\n        }, {\n            Log.e(TAG, \"error\",it)\n        })\n\n    }\n\nTry changing to:\n        button.setOnClickListener {\n            subscriptor?.dispose()\n            subscriptor = RxJavaInterop.toV2Observable(device?.establishConnection(false)?.doOnNext {\n                Log.i(TAG, \"connected RX\")\n            })?.subscribe({\n                Log.w(TAG, \"connected\")\n            }, {\n                Log.e(TAG, \"error\",it)\n            })\n    }\n\n. I would always dispose if I am no longer interested in a subscription. The library checks if the flow was unsubscribed. Not really sure about it. Either way I expect that if you would call `subscriptor?.dispose()` before creating a new one everything should work just fine. I have tried to reproduce the same issue but failed. I have changed the sample's `ScanActivity` code to:\n    @OnClick(R.id.scan_toggle_btn)\n    public void onScanToggleClick() {\n        Log.w(TAG, \"click\");\n    if (scanSubscription != null) scanSubscription.dispose();\n    scanSubscription = RxJavaInterop.toV2Observable(\n            rxBleClient.getBleDevice(SENSOR_TAG_MAC_ADDRESS_1)\n                    .establishConnection(false)\n                    .doOnNext(rxBleConnection -> Log.i(TAG, \"connected RX\"))\n    )\n            .observeOn(io.reactivex.android.schedulers.AndroidSchedulers.mainThread())\n            .subscribe(\n                    rxBleConnection -> Log.w(TAG, \"connected\"),\n                    throwable -> Log.e(TAG, \"error\", throwable)\n            );\n}\n\nLogs:\n03-01 10:04:51.240 600-600/com.polidea.rxandroidble.sample W/MAIN: click\n03-01 10:04:51.302 600-660/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(1108935128)\n03-01 10:04:51.303 600-616/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(1108935128)\n03-01 10:04:51.308 600-661/com.polidea.rxandroidble.sample V/RxBle#BleConnectionCompat: Connecting without reflection\n03-01 10:04:51.314 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: 5C:31:3E:C1:1F:17, auto: false\n03-01 10:04:51.314 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n03-01 10:04:51.369 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=8aeb7178-e681-4534-9a65-93288e33f7ed\n03-01 10:04:51.372 600-612/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n03-01 10:04:51.652 600-613/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:04:51.653 600-613/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n03-01 10:04:51.656 600-660/com.polidea.rxandroidble.sample I/MAIN: connected RX\n03-01 10:04:51.658 600-616/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(1108935128) in 355 ms\n03-01 10:04:51.663 600-600/com.polidea.rxandroidble.sample W/MAIN: connected\n03-01 10:04:51.979 600-620/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:04:51.980 600-620/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n03-01 10:04:51.981 600-620/com.polidea.rxandroidble.sample I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (5C:31:3E:C1:1F:17)\n03-01 10:04:51.989 600-659/com.polidea.rxandroidble.sample D/RxBle#Executors$RunnableAdapter: Terminated.\n03-01 10:04:51.990 600-600/com.polidea.rxandroidble.sample E/MAIN: error\n                                                                   com.polidea.rxandroidble.exceptions.BleDisconnectedException: Disconnected from 5C:31:3E:C1:1F:17\n                                                                       at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:76)\n                                                                       at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:168)\n                                                                       at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n                                                                       at android.os.Binder.execTransact(Binder.java:404)\n                                                                       at dalvik.system.NativeStart.run(Native Method)\n03-01 10:04:51.994 600-660/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(1108948264)\n03-01 10:04:51.996 600-616/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(1108948264)\n03-01 10:04:51.996 600-661/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n03-01 10:04:51.996 600-661/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n03-01 10:04:52.001 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n03-01 10:04:52.001 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=5\n03-01 10:04:52.004 600-616/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(1108948264) in 8 ms\n03-01 10:04:57.107 600-600/com.polidea.rxandroidble.sample W/MAIN: click\n03-01 10:04:57.122 600-660/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(1109416080)\n03-01 10:04:57.123 600-616/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(1109416080)\n03-01 10:04:57.131 600-661/com.polidea.rxandroidble.sample V/RxBle#BleConnectionCompat: Connecting without reflection\n03-01 10:04:57.132 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: 5C:31:3E:C1:1F:17, auto: false\n03-01 10:04:57.132 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n03-01 10:04:57.133 600-661/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=4800cb0f-95bb-46bc-b232-85eb6b99904a\n03-01 10:04:57.135 600-612/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n03-01 10:04:57.402 600-613/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:04:57.403 600-613/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n03-01 10:04:57.404 600-660/com.polidea.rxandroidble.sample I/MAIN: connected RX\n03-01 10:04:57.406 600-616/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(1109416080) in 283 ms\n03-01 10:04:57.406 600-600/com.polidea.rxandroidble.sample W/MAIN: connected\n``\nI have usedJavainstead ofKotlin` but it should not make any difference.\nI suspect you have a different problem in your code\nI have also tested on a different phone and disabling the bluetooth adapter:\n03-01 10:15:23.006 11396-11396/com.polidea.rxandroidble.sample W/MAIN: click\n03-01 10:15:23.099 11396-11639/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(254680345)\n03-01 10:15:23.100 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(254680345)\n03-01 10:15:23.112 11396-11640/com.polidea.rxandroidble.sample V/RxBle#BleConnectionCompat: Connecting without reflection\n03-01 10:15:23.114 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: 5C:31:3E:C1:1F:17, auto: false\n03-01 10:15:23.114 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n03-01 10:15:23.118 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=00b8564f-f01b-4b8b-9d9d-0a555c81a398\n03-01 10:15:23.124 11396-11408/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n03-01 10:15:23.505 11396-11457/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:15:23.506 11396-11457/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=133\n03-01 10:15:23.512 11396-11457/com.polidea.rxandroidble.sample I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (5C:31:3E:C1:1F:17)\n03-01 10:15:23.513 11396-11638/com.polidea.rxandroidble.sample D/RxBle#Executors$RunnableAdapter: Terminated.\n03-01 10:15:23.522 11396-11396/com.polidea.rxandroidble.sample E/MAIN: error\n                                                                       com.polidea.rxandroidble.exceptions.BleDisconnectedException: Disconnected from 5C:31:3E:C1:1F:17\n                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:76)\n                                                                           at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:181)\n                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n                                                                           at android.os.Binder.execTransact(Binder.java:453)\n03-01 10:15:23.525 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(254680345) in 424 ms\n03-01 10:15:23.525 11396-11639/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(109187582)\n03-01 10:15:23.527 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(109187582)\n03-01 10:15:23.527 11396-11640/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n03-01 10:15:23.527 11396-11640/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n03-01 10:15:23.535 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n03-01 10:15:23.535 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=5\n03-01 10:15:23.538 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(109187582) in 11 ms\n03-01 10:15:27.614 11396-11396/com.polidea.rxandroidble.sample I/HwSecImmHelper: mSecurityInputMethodService is null\n03-01 10:15:27.682 11396-11396/com.polidea.rxandroidble.sample V/AudioManager: playSoundEffect   effectType: 0\n03-01 10:15:27.682 11396-11396/com.polidea.rxandroidble.sample V/AudioManager: querySoundEffectsEnabled...\n03-01 10:15:27.682 11396-11396/com.polidea.rxandroidble.sample W/MAIN: click\n03-01 10:15:27.687 11396-11639/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(39122606)\n03-01 10:15:27.688 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(39122606)\n03-01 10:15:27.690 11396-11640/com.polidea.rxandroidble.sample V/RxBle#BleConnectionCompat: Connecting without reflection\n03-01 10:15:27.691 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: 5C:31:3E:C1:1F:17, auto: false\n03-01 10:15:27.691 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n03-01 10:15:27.691 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=e9d60c9c-a897-48b1-9925-24449ec08df4\n03-01 10:15:27.694 11396-11408/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n03-01 10:15:27.889 11396-11408/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:15:27.890 11396-11408/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n03-01 10:15:27.894 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(39122606) in 206 ms\n03-01 10:15:27.908 11396-11639/com.polidea.rxandroidble.sample I/MAIN: connected RX\n03-01 10:15:27.908 11396-11396/com.polidea.rxandroidble.sample W/MAIN: connected\n03-01 10:15:37.272 11396-11396/com.polidea.rxandroidble.sample I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (5C:31:3E:C1:1F:17)\n03-01 10:15:37.274 11396-11638/com.polidea.rxandroidble.sample D/RxBle#Executors$RunnableAdapter: Terminated.\n03-01 10:15:37.276 11396-11639/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(16308031)\n03-01 10:15:37.278 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(16308031)\n03-01 10:15:37.279 11396-11640/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n03-01 10:15:37.279 11396-11640/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n03-01 10:15:37.280 11396-11396/com.polidea.rxandroidble.sample E/MAIN: error\n                                                                       com.polidea.rxandroidble.exceptions.BleDisconnectedException: Disconnected from 5C:31:3E:C1:1F:17\n                                                                           at com.polidea.rxandroidble.internal.connection.DisconnectionRouter$1.call(DisconnectionRouter.java:48)\n                                                                           at com.polidea.rxandroidble.internal.connection.DisconnectionRouter$1.call(DisconnectionRouter.java:45)\n                                                                           at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n                                                                           at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n                                                                           at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n                                                                           at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n                                                                           at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\n                                                                           at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onNext(OnSubscribeConcatMap.java:335)\n                                                                           at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n                                                                           at rx.internal.operators.OnSubscribeCreate$LatestEmitter.drain(OnSubscribeCreate.java:492)\n                                                                           at rx.internal.operators.OnSubscribeCreate$LatestEmitter.onNext(OnSubscribeCreate.java:425)\n                                                                           at com.polidea.rxandroidble.RxBleAdapterStateObservable$1$1.onReceive(RxBleAdapterStateObservable.java:57)\n                                                                           at android.app.LoadedApk$ReceiverDispatcher$Args.run(LoadedApk.java:962)\n                                                                           at android.os.Handler.handleCallback(Handler.java:743)\n                                                                           at android.os.Handler.dispatchMessage(Handler.java:95)\n                                                                           at android.os.Looper.loop(Looper.java:150)\n                                                                           at android.app.ActivityThread.main(ActivityThread.java:5621)\n                                                                           at java.lang.reflect.Method.invoke(Native Method)\n                                                                           at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:794)\n                                                                           at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:684)\n03-01 10:15:37.303 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: cancelOpen() - device: 5C:31:3E:C1:1F:17\n03-01 10:15:37.314 11396-11408/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:15:37.315 11396-11408/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n03-01 10:15:37.323 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n03-01 10:15:37.323 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=5\n03-01 10:15:37.326 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(16308031) in 48 ms\n03-01 10:15:44.846 11396-11396/com.polidea.rxandroidble.sample I/HwSecImmHelper: mSecurityInputMethodService is null\n03-01 10:15:44.847 11396-11396/com.polidea.rxandroidble.sample I/HwSecImmHelper: mSecurityInputMethodService is null\n03-01 10:15:53.490 11396-11396/com.polidea.rxandroidble.sample I/HwSecImmHelper: mSecurityInputMethodService is null\n03-01 10:15:53.561 11396-11396/com.polidea.rxandroidble.sample V/AudioManager: playSoundEffect   effectType: 0\n03-01 10:15:53.561 11396-11396/com.polidea.rxandroidble.sample V/AudioManager: querySoundEffectsEnabled...\n03-01 10:15:53.561 11396-11396/com.polidea.rxandroidble.sample W/MAIN: click\n03-01 10:15:53.567 11396-11639/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(59631334)\n03-01 10:15:53.568 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(59631334)\n03-01 10:15:53.571 11396-11640/com.polidea.rxandroidble.sample V/RxBle#BleConnectionCompat: Connecting without reflection\n03-01 10:15:53.572 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: 5C:31:3E:C1:1F:17, auto: false\n03-01 10:15:53.572 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n03-01 10:15:53.572 11396-11640/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=18cfb181-3116-435d-a7b5-08e8d90482c0\n03-01 10:15:53.578 11396-11407/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n03-01 10:15:54.373 11396-11407/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=5C:31:3E:C1:1F:17\n03-01 10:15:54.374 11396-11407/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n03-01 10:15:54.375 11396-11639/com.polidea.rxandroidble.sample I/MAIN: connected RX\n03-01 10:15:54.375 11396-11396/com.polidea.rxandroidble.sample W/MAIN: connected\n03-01 10:15:54.376 11396-11413/com.polidea.rxandroidble.sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(59631334) in 808 ms\nStill works. BleAlreadyConnectedException is not connected with permissions.\nUnfortunately I do not have access to Huawei Honor 8 to test this scenario but judging from the logs nothing should break. I cannot tell anything more... You could either paste the whole activity code or show the full logs with the mac addresses to which you are talking to. Good to hear that it is solved. You have incorrectly stated that the problem is on 1.4.3 version\nClosing. @RAM512 .firstOrError() is just a handy way to transform a Observable<T> to a Single<T>. For more information about Observable and/or Single I can encourage you to check for information directly on RxJava.\nReplyingShare is a helper (that should not be used imho) for using the same RxBleConnection in multiple places in the code while maintaining a single connection established (RxBleDevice.establishConnection() when unsubscribed closes the connection).\nBest Regards. nRF Connect has a bad habit of intercepting connections. I am not really sure how it is implemented but if it is in the background and a connection is established it holds it so it is not disconnected if the app disconnects. Test when the nRF Connect is not working (kill it so no notification is displayed). Closed by mistake. Mentioning @uKL. Could you two write a minimal code that would reproduce the error?. Hello everyone,\nI was investigating this issue recently.\nThe root cause of the problem is the threading of Android OS \u2014 callbacks may be called on arbitrary threads.\nThe library does not know how it will be used and thus it is routing errors to all listeners.\nBecause the errors sometimes may be routed through many merged observables they may appear more than once in an observable chain...\nOne of the differences between RxJava 1 and RxJava 2 is that the former did swallow exceptions that happened after the chain was unsubscribed whereas the latter is throwing an UndeliverableException in this situation.\nWith the current library architecture it is impossible to mitigate this behaviour and the suggested workaround is to add a code similar to what @thuytrinh wrote above:\nKotlin\nkotlin\nRxJavaPlugins.setErrorHandler({ error ->\n    if (error is UndeliverableException && error.cause is BleException) {\n        return // ignore BleExceptions as they were surely delivered at least once\n    }\n    // add other custom handlers if needed\n    throw error\n})\nJava\njava\nRxJavaPlugins.setErrorHandler(error -> {\n    if (error instanceof UndeliverableException && error.cause instanceof BleException) {\n        return; // ignore BleExceptions as they were surely delivered at least once\n    }\n    // add other custom handlers if needed\n    throw error;\n});. Basically anywhere. RxJavaPlugins.setErrorHandler() is a static method.. Hello @cuiti \nI do not know exactly what is the issue you are facing. Maybe your project does not use Kotlin and/or Java lambdas?. Thank you for the suggestion.\nUnfortunately this is not the case in this library since the wrapped error is usually BleDisconnectedException. It happens due to the exception being routed to every Observable/Single/Completable derived from RxBleConnection.\nIf the user creates a single Observable from multiple others derived from RxBleConnection \u2014 the BleDisconnectedException will get emitted from all of them and only one will get handled by the Subscriber. The rest will get routed as UndeliverableExceptions \u2014 I have an idea on how to mitigate this problem but it will make the library harder to use \u2014 the user would need to think on where they want to get the error routed in their chain of Observables. And it could potentially drastically alter the API where if error is not routed to a particular place then e.g. a Maybe would be returned instead of Single.\nThis approach needs to get evaluated.. Check readme for \"snapshot\". Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Yes. I suppose you have already asked a question on Stackoverflow and Rob is already looking on your case. It is, just there were some other minor changes in the code. You can see it in the commit list in the RxJava core PR. Could you paste the above log but with RxBleLog.setLogLevel(RxBleLog.VERBOSE)?. Maybe the library could monitor Bonding Changes and if it would find one it would not trigger the timeout?. Hello,\nThe error is documented in Javadoc. My stance is that having all potential errors that may be emitted from a particular Observable would clutter the description and would not provide help. This kind of error is usually easy to spot during an early stage of the development process\nIt was a deliberate decision not to provide this kind of a function as the communication patterns are usually stateful (sending a request, waiting for a response) and if two places in the code would execute requests at the same time the responses could get mixed which would lead to hard to spot bugs.\nIf the user will use .share() or .publish() or RxReplayingShare then they are aware that the connection is being shared. Hopefully.... Just a thought\u2014check if in Readme there are no mentions. Or in other places in the code. Hello,\nI have followed the log you have attached. Could you elaborate more on what is the actual problem, what would you expect to happen next? In the logs you have attached I see that the library is finishing the Long Write Op normally and there is no other action on it (no further requests nor any errors)\nThe connection params dance is an implementation of a particular BLE stack which is beyond the control of the library (or Android API)\nAre you sure sure that your peripheral is working correctly?. In RxJava 1.x there were helpers like OnSubscribeCreate. Unfortunately now they are unavailable (as far as I know) and the only way of creating a subclass of an Observable is the current approach. Creating a factory makes it also more cumbersome to use in the dependency injection, but it is not a show-stopper.\nThe thing is that we have two constraints we have to follow:\n1. The observer.onSubscribe() has to be called before observer.on*(any other)\n2. The context.registerReceiver() has to be called before context.unregisterReceiver()\nThe context.unregisterReceiver() is bound to observer.onSubscribe() so we have a chicken and an egg problem. What should be used is probably the defferred cancellation \u2014 correct me if I am wrong.\nOr maybe there is some other solution?. ...that allows subclassing? ;). Convenience I suppose. While using RxJava 1 I could do something like:\njava\nclass MyFancyObservable extends Observable<MyType> {\n  MyFancyObservable(SomeDependency someDependency) {\n    super(new OnSubscribeCreate<>(new Action<Emitter<MyType>>() {\n      // ... do my fancy stuff like I was using Observable.fromEmitter() but still having a subclass\n    }));\n  }\n}\nThe convenience was that I could then just inject MyFancyObservable instead of Observable<MyType> and wire it to a specific key in case there are many observables of that type.\nThe other reason is to learn on what should I be aware in the case of RxJava 2.. Probably that if you have:\nObservable<RxBleConnection> sharedConnectionObservable = device.establishConnection( false )\n    .replay(1).refCount();\nand do:\nDisposable disp1 = sharedConnectionObservable.subscribe( ... ); \n// wait until connection is established\nDisposable disp2 = sharedConnectionObservable.subscribe( ... );\nThen the second .subscribe() will never get the emitted RxBleConnection as it happened before the second subscription to .refCount().\n.refCount() makes only a single subscription to the upstream therefore .replay() will get subscribed only once. Doesn't matter if you use .cache() or .replay() before .refCount() \u2014 it will behave almost the same.\n.replay() without .refCount() and explicitly .connect() should do the trick but you're getting back to manually managing the connection.\n\nIf the last subscriber to .replay() disposes will the BLE connection be released?\n\nAfaik \u2014 no. To release (close) the connection one should dispose the result of connectionObservable.connect()\n\nI don't mean to beat this to death but it seems like there must be some way of handling this common situation straightforwardly.\n\nI would like to know how to handle such situation easily and bake it into the library so others would not need to tackle it on their own but since there is room for a ReplayingShare I do not think there is. It looks like the ReplayingShare in version 2.1.0 and above should do the trick now. I am closing this thread \u2014 hopefully everyone can workout their way with either ReaplayingShare or with replay(1).refCount() or however else they like. :). Hello,\nThanks for pointing that out!\nUnfortunately we currently have limited time for the development. If you could create a PR we would be happy to merge it in right away!\nBest Regards. Hello @martyglaubitz \nUnfortunately this library aims only at Bluetooth Low Energy hence RxAndroidBle\nBluetooth sockets are not supported at all\nBest Regards. Looks like a duplicate of #383 \nReopen if you think otherwise. Hello @kosancicivan \nThank you for the idea. We have evaluated it at the beginning of the project and decided to concentrate on handling the BLE stack the best possible way.\nConfiguration changes are easy to overcome once you will separate the connection lifecycle from the activity lifecycle (which is usually what you want to do anyway). You can do it by using a Service or creating a different lifecycle scope which will suit your needs.\nThis topic is not directly related to BLE and there are different approaches depending on the specific use-case.\nBest Regards. There is no code related to the UI in the library. Are you sure that the app does not get suspended and/or service killed?. Could you share a sample code which I could copy-paste to recreate the issue?\nAlso please write your setup (phone model/ os/ etc). Added a wiki page. There are currently no guidelines nor even too much tests with this library using bonding. It the terms of code expressiveness you approach is ok. You could also write it like this:\n```\nval device: RxBleDevice = bluetoothService.getBleDevice(selectedDevice.macAddress)\nObservable.defer {\n    device.bluetoothDevice.createBond() // it is a blocking function\n    device.establishConnection(false) // return Observable\n}\n.doOnNext {\n    Timber.e(\"Connection established.\")\n}\n``. Related [stackoverflow question](https://stackoverflow.com/questions/50039644/can-i-skip-location-permission-using-rxandroidble). Hi,\nI did not yet had time to dig into this. What if you would put.observeOn(schedulers.mainThread())just before.subscribe()?. @ardmn Any news?. Do you useRxJava 1orRxJava 2version?. So this is the correct behaviour. One must put.onBackpressure*()and.observeOn()in correct order. See [.observeOn()` Javadoc](http://reactivex.io/RxJava/1.x/javadoc/rx/Observable.html#observeOn-rx.Scheduler-):\n\nThis operator honors backpressure from downstream and expects it from the source Observable. Violating this expectation will lead to MissingBackpressureException. This is the most common operator where the exception pops up; look for sources up the chain that don't support backpressure, such as interval, timer, {code PublishSubject} or BehaviorSubject and apply any of the onBackpressureXXX operators before applying observeOn itself.\n\nThis is not the problem with the library but the usage of RxJava. Just rethink what you want and what you need to do and then dispatch the work accordingly among available Schedulers.\nBest Regards. Hello,\nYou need to add the error handler parameter to your .subscribe(onNext, onError) function\nBest Regards. Hello,\nThank you for the report \u2014 could you attach a log from the running application as the disclaimer suggests?\nBest Regards. Yup. The problem is in FIFORunnableEntry, apart from the log there should be a call to semaphonre.release() in FIFORunnableEntry:76.\nThe bug was introduced in #362 by a simple overlook I suppose. If you could check if adding the release there will fix the problem it would be great! I am a bit low on time now unfortunately (and I do not have access to Nexus 6P). Thanks! Going for the other PRs (not sure if I'll manage all Today). @bleeding182 Did you confirmed that this change indeed helps?. It's @dariuszseweryn ;)\nGreat to hear that. I think that we should add a test for FIFORunnableEntry to prevent such a situation in the future.\nThe test should be straightforward to write and just verify that the semaphore is either released or passed to an operation depending on ObservableEmitter.isDisposed() result.\nP.S. Maybe it would be a bit clearer if the code be something like:\nif (observableEmitter.isDisposed()) {\n  RxBleLog...\n  semaphore.release();\n  return;\n}\noperation.run(semaphore).... I am not convinced to this change as it will only make potential errors in the library to be found later than sooner.. @bleeding182 I wonder if it could be possible to catch this use-case with a test... Have you checked perhaps?. No, it is not possible as for my level of understanding. I do not expect to see any timing issues after/before activating the log. Random disconnections may happen because of external (non-library) reasons.\nBest Regards. Hello @braddodson \nThanks for the report. As far as I see we should have this use-case covered in the tests unless there is a bug in there as well.\nFeel free to check it out and provide a failing test case that could be fixed . Good spot! Thank you very much \ud83d\udc4d . Hello,\nCould you add a code snippet and / or reproduction scenario?. Additionally when from this 1.6.0-SNAPSHOT version was? 4 days ago we have fixed a similar crash in commit d3197ebf15044d8369763c385bea982253fcb0ff\nThe code that is using this observable can also be useful if this has something to do with threading.. It's @dariuszseweryn ;)\nHmmm... Apparently (if it is a clean build with no caches) then it is possible to determine from the timestamp. Anyway I have just released 1.6.0 so there will be no more confusion about 1.6.0-SNAPSHOT ;)\nClosing in this situation. Awesome! Thank you for the contribution.. Hello,\nWhy do you think it is an issue with the library?. Never had this kind of an issue. It seems to be a problem with implementation on the Peripheral side. It may be related to using BluetoothDevice.connectGatt(context, autoConnect, bluetoothGattCallback, TRANSPORT_LE). You're welcome. Feel free to report back if you will find something. I am closing for now.\nBest Regards. Have you tried to stop the scan before establishing connection?. Hello @saiimons \nIn a moment there should be a 1.7.0-SNAPSHOT available that has this issue fixed.\nBest Regards. Hello @ardmn \nI have looked thought the master-rxjava1 branch for every .subscribe() statements. Most of them are only passing the onError() to the observers/emitters. Otherwise they either have onError() handling or are subscribed to Observable's that are not able to emit errors.\nIt seems very unlikely that this is caused by the library.. Btw. the newest RxJava1 library version is 1.5.0. Revisiting \u2014 I still have no idea what has happened. I have no scenario for reproduction and I do not see other reports about this issue. It seems to be a marginal problem and I do not have time to investigate it further. Closing for now.\nFeel free to add more info when available or when other reports will be available. As @piotrek1543 already mentioned \u2014 we have gitter channels which are integrated with this git repository. I expect that it may be already confusing for people as there are: \n- git issues\n- gitter channel\n- stackoverflow\nAs for the moment I do not see added value in an additional Slack integration\nIf there will be more voices supporting this idea we can consider it. Closing for now\nBest Regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Duplicate of #446 . I have added a Connect right after scanning paragraph. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. I have finally added a Wiki page for this. Thank you @RobLewis !. I have just tested locally and it works as expected here. Maybe your device is not advertising the UUID you expect?. I did not used any beacon app. I just scanned a known peripheral that advertises a particular service UUID.. I do not know the iBeacon specification and cannot support you in this matter.\nYou may try some other library designed for specifically for beacons RxBeacon or may go to stackoverflow for help as this is more of a general usage question.\nI am closing this topic as it is not an issue with the library.\nBest Regards. I am not a fan of adding unsecure APIs. Users tend not to read the documentation frequently enough :(\nThe expert mode is the CustomOperation interface. One could actually create a CustomOperation that would make service discovery again and then start to use the part of the API that uses i.e. BluetoothGattCharacteristic instead of UUID. One can make an operation with RxBleCustomOperation<List<BluetoothGattService>> signature. In RxBleCustomOperation the user has access to both BluetoothGatt and RxBleGattCallback and can perform a service discovery that bypasses all library caching levels.\nThe only downside is that the user cannot use the API that takes UUID as the parameter as the lower levels will have no knowledge of what the custom operation performed. Usually the Observable is stateless without operators like .cache(). The deviceServicesObservable first checks BluetoothGatt if it has cached services. If there are none then it schedules a service discovery operation. If any of those will return only then the .cache() operator starts to work so next usages of the \"UUID API\" will not trigger this part of the code again.\n\nThat is more dangerous than refresh properly from the lib no?\n\nYes \u2014 most probably. I plan to add this feature at some point but not yet. My arguments:\n\nBluetoothGatt.refresh() seems to be already quite well tested \u2014 this is not a problem. The issue is that it should change the behaviour of other parts of the implementation like ServiceDiscoveryManager / RxBleConnection.discoverServices() (which is used by all UUID API under the hood)\nManaging of the ServiceDiscoveryManager state is not easy to get right. Ideally all RxBleConnection observables should work correctly even after performing BluetoothGatt.refresh(). With the current implementation it is not possible to guarantee that. It will even need a significant refactoring inside the library just to provide meaningful errors so the user would know what they have done wrong \u2014 this will also have an impact on the library performance\nSince the intended behaviour is possible to get via RxBleCustomOperation usage I do not see this feature to be needed just yet. It would need a lot of patching and introduce some bugs / performance degradation for a fairly large user base to help a fairly small amount of people. I feel that it is better to concentrate now on a new API and implementation that would fully cover the topic with the least possible negative impact. Unfortunately I didn't had time to properly handle this project in the recent months. My previous doubts still stand. To relieve your pain in awaiting a proper fix I am posting implementation on how one can refresh gatt on their own and then perform service discovery bypassing all caches\n\nFirst the BluetoothGatt.refresh() custom operation:\nRxBleCustomOperation<Void> bluetoothGattRefreshCustomOp = (bluetoothGatt, rxBleGattCallback, scheduler) -> {\n    try {\n        Method bluetoothGattRefreshFunction = bluetoothGatt.getClass().getMethod(\"refresh\");\n        boolean success = (Boolean) bluetoothGattRefreshFunction.invoke(bluetoothGatt);\n        if (!success) return Observable.error(new RuntimeException(\"BluetoothGatt.refresh() returned false\"));\n        return Observable.<Void>empty().delay(500, TimeUnit.MILLISECONDS);\n    } catch (NoSuchMethodException e) {\n        return Observable.error(e);\n    } catch (IllegalAccessException e) {\n        return Observable.error(e);\n    } catch (InvocationTargetException e) {\n        return Observable.error(e);\n    }\n};\nThen a BluetoothGatt.discoverServices() custom operation:\nRxBleCustomOperation<List<BluetoothGattService>> discoverServicesCustomOp = (bluetoothGatt, rxBleGattCallback, scheduler) -> {\n    boolean success = bluetoothGatt.discoverServices();\n    if (!success) return Observable.error(new RuntimeException(\"BluetoothGatt.discoverServices() returned false\"));\n    return rxBleGattCallback.getOnServicesDiscovered()\n            .take(1) // so this RxBleCustomOperation will complete after the first result from BluetoothGattCallback.onServicesDiscovered()\n            .map(RxBleDeviceServices::getBluetoothGattServices);\n};\nAnd usage example:\nconnection.queue(bluetoothGattRefreshCustomOp).ignoreElements()\n        .andThen(connection.queue(discoverServicesCustomOp))\n        .flatMapSingle(bluetoothGattServices -> {\n            BluetoothGattCharacteristic characteristic = null; // get your characteristic from bluetoothGattServices\n            return connection.readCharacteristic(characteristic);\n        });\nHope this help you for now. Thanks for report!. Hello,\nThere may be a multitude of causes of this behaviour starting with availability of Service Changed characteristic, attributes caching, scan settings (time window, frequency of windows), chip used and so on.\nThe topic is very broad and not connected to the library itself therefore I am closing.\nBest regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards\nP.S. If the other app has connected to your device it may no longer be advertising and thus not scannable. Hello\nThanks for using the library!\nIt looks that something is off with your peripheral if BLE stacks of Pixel 2 and OnePlus 3 are not handling normal writes\nBtw. The above code will repeat indefinitely as cPayload.getNextPacket(mtu) is called only once.. try to change this:\nthis.writeCharacteristic(characteristicUUID, cPayload.getNextPacket(mtu))\ninto this:\nSingle.defer { this.writeCharacteristic(characteristicUUID, cPayload.getNextPacket(mtu)) }\nThen each .repeatUntil { cPayload.isEmpty() } will actually be called with cPayload.getNextPacket(mtu).. Your peripheral is not properly responding for the write and then it disconnects (14307-14327 D: onConnectionStateChange newState=0 status=19)\nThis seems to be a business logic issue \u2014 not library. Hello,\nYour usage is fine. This is probably because of the Connection Interval of your peripheral.\nBest Regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. Could you add what exact model and OS version is causing the issues? This information could be valuable for future reference.\nUnfortunately I have no solution apart of not passing a ScanFilter to the scanBleDevices and filter the output via .filter() operator. This will unfortunately make the scan to be paused on newer OSes when the app goes background.. The ScanSettings.CALLBACK_TYPE_ALL_MATCHES is the default for using a BLE scan. I am almost sure that it will work if you will not provide any ScanFilters.\n\nAfter a lot of research on this topic I found out there are tons of problems with ble scanning on android devices and lot of articles suggested robust restart and reconnect strategy.\n\nIf you have the articles still opened could you also reference them here? I would also like to go through them as I do not recall any of such. Not much can be done on the library side. Closing. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. In this case \u2014 could you add logs from your application with RxBleLog.setLogLevel(RxBleLog.VERBOSE) and as many other data that is described in the issue template?\nThis will help understand what exactly is going on. This looks like a threading issue. The BluetoothGatt seems to be still busy even when the onCharacteristicWrite() callback was already called. Or there is an \"off-by-one\" mistake in the code... I'll try to prepare a snapshot release Tomorrow with more logs which would clarify the situation.\nIn the first situation the fix will not be made quickly, in the second \u2014 I should be able to address it quite shortly.\nIf you could also add as the issue template suggest the version of the library it would be nice. The info about on what phone model/OS version you have observed the issue may also be valuable.. There should be a snapshot release 1.7.0-SNAPSHOT available shortly \u2014 it contains additional logging. Please try to reproduce the issue using this release and paste the logs.. I think I found the culprit. I have just released a 1.7.0 library version. It should be available shortly and have the bug fixed.\nThank you very much for spotting and helping with tests. Hello,\nIf you have implemented the RxJavaPlugins.setErrorHandler() correctly this should not happen. Maybe it is overwritten somewhere?\nYou can check it by adding an additional log to the error handler and checking if in the new release the log will be visible\nFeel free to add more information when available. Closing due to lack of information and inactivity of the original poster.\nWhen more data will be available\u2014feel free to add that information and reopen this issue.\nBest Regards. Hello,\nThank you for using the library.\nYour post seems to be a bug report but it lacks some crucial information. Could you edit to contain information according to the issue template?\nBest Regards. Judging from the message of this commit and the original author silence I assume that the issue is already solved.\nClosing. Hello,\nThank you for using the library.\nYour post seems to be a bug report but it lacks some crucial information. Could you edit to contain information according to the issue template?\nBest Regards. Closing due to lack of information and inactivity of the original poster.\nWhen more data will be available\u2014feel free to add that information and reopen this issue.\nBest Regards. Thank you!. Hello,\nThanks for the suggestion. We were already evaluating the idea quite a long time ago and decided to reduce dependencies on outside libraries as we couldn't contact the original developers.\nBest Regards. Hello,\nThank you for using the library.\nYour post seems to be a bug report but it lacks some crucial information. Could you edit to contain information according to the issue template?\nBest Regards. In this case I am closing the issue. \nFYI I could not see what was happening because there are no logs in the original post (as asked by the issue template).. Hello,\nWhy do you think it is an issue with the library? From the logs it seems that the Android OS is returning an error code. Judging from the timings the request was sent via radio and the peripheral responded with an error code.. Hello,\nYour post has almost no actionable information. Closing for now.\nFeel free to reopen after providing appropriate description/code/logs\nBest Regards. What do you mean by:\n\nThis code works perfectly on 1.4.1 but not in 1.7\n\nIf it does not compile then the types do not match. The compiler will inform you specifically what is not correct. In this situation you should look into .flatMapObservable() or .flatMapCompletable() functions and put them in appropriate places where .flatMap() is currently used.\nIt is basically a \"General Usage Question\" and as such should go to stackoverflow\nTo answer the question:\n\nIs possible to subscribe to multiple characteristic notifications at once?\n\nYes \u2014 it is possible.\nBest Regards. Hello,\nThis looks like an Android API bug. While it is possible for the library to introduce some mitigations (i.e. retrying the discovery process in this situation) they are likely to fail and not desirable by every user.\nCould you add information about what device / OS you have encountered this bug?\nUnfortunately for now you have to embrace this Android flaw and create a workaround...\nI will leave this as a feature request and hopefully will have time for it once the new API will be available (as it will require more knobs in the API)\nBest Regards. Currently retry would need to be implemented in a RxBleCustomOperation on the RxBleConnection.queue() function as the internal logic treats an empty list of services as a valid result and caches it.. I have pushed fix/readme_observable_table branch which has an updated paragraph Observable behaviour. Feel free to check the readme on this branch and give feedback if it is now clear enough. 1. It is a cold Observable because the scan starts (is scheduled to start) emitting values after the subscription to this Observable. A hot Observable would emit values even if there are no subscribers\n2. Yes\n3. i.e. (which means that is afaik) is used for an example. There is a second example where I have put i.e.2. Reworded now for easier understanding \u2014 feel free to recheck. 1. As for the cold Observable it is to me that the producer inside the Observable in question is activated at the time of subscription. Which is also what can be read in a referenced site\n\nDoes scanBleDevices() cache previous ScanResults and deliver them to new Subscribers.\n\nNo, it does not cache previous results.. > which Observables support multiple Subscribers?\nAll of them. But they may behave differently i.e. cold will usually start something for each subscription, hot will just connect to something that is happening.\n\nHow can we identify them?\n\nHopefully hot/cold differentiation in the readme will do the trick for this library\n\ndoes this mean that multiple subscriptions create multiple instances of the scanner? Is this even possible?\n\nIt's depending on the implementation but I would expect that yes \u2014 it may be possible\n\nIs an error generated if you try to have multiple Subscribers?\n\nOnly when the user would try to subscribe to RxBleDevice.establishConnection() more than once\n\nCould you use .share()?\n\n.share() may be used at will even for RxBleDevice.establishConnection() as it will get then subscribed only once. Unfortunately I do not have time on every day to work on the library. It is mostly Fridays. I am currently working on issues and actually wanted to merge the changes Today.. What version of the library do you use?. 1.5.0 has an improved check for Location Services. If it still would not work then either one needs to enable Location Services (do not confuse with Location Permissions) on your Vive or make a fork that will suppress the Location Services check.. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users.\nBest Regards. This case should also be handled by the fix on fix/background_scanner_npe branch as it checks if adapter is on. I have created a different issue as potentially a SecurityException may also be thrown when specific settings will be passed to the scan.. Fixed in 1.7.0 RxJava1 release which should be used on the next react-native-ble-plx@1.0.0 release.. Hello,\nThis seems to be an Android BLE stack issue \u2014 could you share phone model / OS version?\nBest Regards. This may not be related to a specific phone/OS mix but a general Android BLE stack issue. I can recall a similar issue with autoConnect=true where a well timed disconnect/close creates a race condition which makes the OS keep the connection indefinitely without any signs on the surface.\nI think I have found a bug report for this exact case. In this situation calling BluetoothGatt.disconnect() before BluetoothGatt.close() could potentially workaround this issue.. Feel free to share how did you implemented the workaround and if it helped. I am afraid that if the device will get connected after the connectionSubscription will get unsubscribed the problem will surface anyway.\nA valid workarounds without changing the library internals would be:\n1. Use autoConnect=true \u2014 in this situation the mentioned bug does not surface. The other bug may happen though... Additionally the connection time may be longer than while using autoConnect=false\n2. When using autoConnect=false \u2014 do not unsubscribe from RxBleDevice.establishConnection() until it will throw (~30 second tops). Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users. Also feel free to check already posted questions as a similar one may be already answered.\nBest Regards. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users. Also feel free to check already posted questions as a similar one may be already answered.\nBest Regards. Hello,\nSo far it seems to be the correct behaviour. You have not included logs of what happened before but I suppose that Android API does not give a callback if you negotiate the same MTU that was already set. This may happen because the MTU may be persisted between reconnections when a device is bonded.. A good fix should be provided by Google as the contract here is not fulfilled. There is no callback in BluetoothGattCallback.onMtuChange() after calling BluetoothGatt.requestMtu().\nA workaround of asking for a slightly different MTU might work.\nYes, logs may be useful.. And it only happens after the device is bonded? Please write your phone model and OS version.. I have moved the logs from a comment to the original post to match the issue template and for clarity. This is an Android bug and I do not see what can be done inside the library to mitigate it. I have not found any bug related to this case on the google issue tracker but it may be worth to do so.. Out of curiosity \u2014 have you checked what would happen if you would just ignore the timeout error on the MTU change? I mean I know that it would make the connection unusable for 30 seconds but I wonder if it works for other things later.\n\nMaybe something is getting queued or started that shouldn't be when I first disconnect? Then when I abruptly disconnect the second time, some exception gets thrown putting the device in good state for reconnect?\n\nThere is a good chance that something is off inside the Android API that get's fixed. Or your device is getting silently unpaired in the process. You could observe broadcasts with filter BluetoothDevice.ACTION_BOND_STATE_CHANGED) to find out.. I mean: in your code snippet your connection is throwing error because the main chain does not handle the MTU request error. If you would replace:\nconnection.requestMtu(mtu).flatMap(request -> Observable.just(connection));\nwith something like:\nconnection.requestMtu(mtu)\n    .toCompletable()\n    .doOnError(throwable -> { Log.d(\"Error happened\", \"whoops!\", throwable) })\n    .onErrorComplete() // ignore error from mtu request (timeout)\n    .andThen(Observable.just(connection));\nYour connection could potentially live \u2014 though it is not sure what will happen with the MTU. Logs from this situation could also give some insight of what is going on. Pardon if I have failed to propose code that would compile (I am writing it from my head and RxJava1/2 API is mixing in my mind already) but you should get the idea. So now you know :'D\nCould you also add logs for this scenario \u2014 I would like to look on them. Unfortunately there is nothing known that the library can do about this issue. If anyone has an idea \u2014 feel free to post/reopen.. This ticket is invalid as this situation to happen needs a use of SystemApi or calling the API when the Bluetooth is not on which was fixed recently. Hello,\nThank you for using the library.\nYour post seems to be a bug report but it lacks some crucial information. Could you edit to contain information according to the issue template?\nBest Regards. Please attach logs when RxBleLog.setLogLevel(RxBleLog.VERBOSE) is set so the library logs will be present. 1. The log you have posted is not full\n2. Have you read about autoConnect flag? If not \u2014 please do\nEdit: so far it seems that everything is working ok. Try using autoConnect=false. > Be careful not to overuse the autoConnect flag. On the other side it has negative impact on the connection initialization speed. Scanning window and interval is lowered as it is optimized for background use and depending on Bluetooth parameters it may (and usually do) take more time to establish the connection.\nIt may take a really long time with autoConnect=true. If you want to do it with autoConnect=true then you need wait. Or you can create a logic that would retry with autoConnect=false but that could potentially eat up battery pretty quickly. Or you can scan on some low priority and start connecting only when scanned. Either way this does not seem to be a problem with the library. The status=133 is usually emitted when Android BLE stack does not handle something well. Unfortunately this is usually the case with bonded devices. Other libraries even encourage to clear bonding after each connection. There are quite a lot of BLE issues on the Google bugtracker about connecting to bonded devices.\nMy own experience with bonded devices is that it is not stable across devices to use. One may maintain a whitelist of tested devices/OS versions pairs but it is a rather cumbersome in the long term.\nI am afraid that the library cannot do anything on it's own but if you think otherwise please add more information.. Hello,\nWhat's the phone model and OS version you are testing? Have you read the Wiki? Have you tried with the newest version of the library?. Could you add more details of what should be migrated? I didn't have time yet to get to know androidx but as far as I know the only issue may be with the support annotations which are from the support library. Plus the sample app could be updated but I suppose this is not a big problem. 1.8.0-SNAPSHOT is already using AndroidX dependencies. Thanks!. Hello\nYou may use RxBleConnection.discoverServices() and then search the RxBleDeviceServices for the BluetoothGattCharacteristic you are interested in. Then you can set the BluetoothGattCharacteristic.setWriteType(int) method and start to use RxBleConnection.writeCharacteristic(BluetoothGattCharacteristic, byte[]).\nBest Regards. Since the OP has reacted to the answer I assume thing is sorted out. Closing\nIf mistaken feel free to add more info or reopen.. 1. 5 seconds is usually not enough -> check autoConnect description in readme\n2. There is a bug with mac address resolution which you may accidentally mitigate by using nRF Connect -> check Wiki Cannot Connect. Since the OP has reacted to the answer and no more info is available I am closing this issue. Feel free to reopen or add more info if you think otherwise.. That there was no callback to BluetoothGattCallback.onConnectionStateChange() but the disconnection happened anyway because of:\n\n4 Caused by:\n5 com.polidea.rxandroidble2.exceptions.BleAdapterDisabledException:. Ah, excuse me \u2014 I didn't catch that this is an UndeliverableException. In this case I encourage you to check the FAQ: UndeliverableException. Reason: the BT Adapter was turned off \u2014 this is the way Android BLE API works. Hello,\n\nI do not see how this is a library issue. I think that you should ask this question to the authors of Android Studio this is a project site of Android Bluetooth Low Energy library and we are not developing Android Studio.\nThere was however an issue with checking out the library and building it later but it is also an issue in Android Studio itself.\nAnyway I cannot help you with the lack of Github option when trying to checkout code in Android Studio.\nYou probably can simply use Git option as Github is using Git\nBest Regards. I cannot removeLukasz Kalnik from contributors as one of your commits (1a92c6e17d14751d60cfe1fc1ccf8972ff164f69) was made with that user who cannot be attributed to your github account. To fix this situation you would need to change this commit's author to the proper one (lukaszkalnik). @lukaszkalnik Sorry for the delay \u2014 I was on a conference and short holiday. Actually you may and should use a force push to get rid of the commit by Lukasz Kalnik from this PR (afterall this PR is from your fork and you do have full control over it which I probably have not). Alternatively you may close this PR and create another one with different commits in it. I have checkout your repo and I see this commit whose author is lukasz.kalnik@grandcentrix.net where the rest of your commits are from lukasz.kalnik@gmail.com so the history of your commits does not seem to be overwritten with via push -f. Quickly searched google and there seem to be a fairly straightforward instruction on how you can change the author \u2014 I hope this helps. Aaaaand done! Thank you! \ud83d\ude80 . What device/OS version you test on?\nThe library itself uses Context.getApplicationContext() inside on the Context passed into RxBleClient.create(Context). I doubt that this is the problem. I see in the logs that the BT adapter state has changed but you do not mention it anywhere. Could you add more info?. I am happy that you have solve the problem\n\nAnd when I fixed the process, a thing that you can make in miui\n\nCould you add a bit more info that I could learn from? I do not know what you mean by fixed. Weird... You're the first person who is mentioning this kind of a problem with Xiaomi devices. If you or someone else would find more information about the MIUI/Xiaomi implementation \u2014 feel free to share. \nI see no way in which the library could change to help in this situation so I am closing now. If more info or a path forward will be available \u2014 feel free to add it and reopen. Hmmm... I am actually thinking if the operation timeout should not be longer if bonding is in progress. If the OS will not callback the BluetoothGattCallback it will not be possible to call any more actions on BluetoothGatt anyway regardless of the library timeout. Thanks for the effort! I think it could be valuable to not to remove the java sample but simply add a kotlin one since we are in a kind of a transition period and people use both and users may not be accustomed to the new language yet. What do you think about the idea?\nP.S. Sorry for the delay \u2014 I was on vacation. Why do you think it is an issue with the library? The OS is informing the lib that it lost the connection.. Closing due to inactivity. Have you checked the FAQ?. Hello,\nThanks for using the library. iOS has a totally different implementation of BLE stack so it is working differently there. \nSome questions:\n1. Have you compared to the vanilla Android API usage? \n2. Have you checked the FAQ? It is related to scanning\n3. Have you checked against the newest version of the library?. Establishing connection and starting a scan are sharing the same queue. .establishConnection(false) is blocking so no scan will start until the connection is either a success or a failure. First starting the scan before establishing the connection is subject to potential issues as described in the FAQ.. Closing if that is all. Do you use RxBleConnection.writeCharacteristic(BluetoothGattCharacteristic, byte[]) API by any chance?. Then most probably you are obtaining the BluetoothGattCharacteristic during one connection and you try to write it on another connection. BluetoothGattCharacteristic is valid only for a single/same connection.\nA safer method (but a bit slower) is to use RxBleConnection.writeCharacteristic(UUID, byte[]) which will internally use the BluetoothGattCharacteristic from the given connection.\nOf course you may just fix the code so you would not try to use the BluetoothGattCharacteristic on a different connection than it was obtained from.. Closing due to lack of information and inactivity of the original poster.\nWhen more data will be available\u2014feel free to add that information and reopen this issue.\nBest Regards. Hmmm... Actually I would prefer to stick to disposing manually instead of using RxLifecycle. Even the author of this lib does not believe in it anymore.\nAnd getting rid of this dependency can make the app easier to understand for beginners. What do you think?. .establishConnection() does not complete on its own. You can read about it in the Observable behaviour part of Readme. > Requests in the library by default are not executed on the current thread?\nYes. Android BLE API is very sensitive (read poorly implemented) to threading so the library handles it on its own. The Android API is asynchronous anyway. Hello,\nThanks for using the library! Could you provide logs showing the issue?\nBest Regards. I see one mismatch between the logs and the code snippet you have posted:\n- There is no 2 seconds delay between retries\nThis may point to a different bug in the application code \u2014 the downstream is disposing right after subscribing to .establishConnection() and retrying immediately in a cycle.\nDisconnect operation has been executed but GATT instance was null - considering disconnected. will allways be logged whenever ConnectOperation will not be subscribed long enough to get a reference to BluetoothGatt.. Could you add a log of the exception in .retryWhen { it.delay(200, MILLISECONDS) }?\nSomething like .retryWhen { it.doOnNext(throwable -> Log.e(\"whoopsey\", \"bummer\", throwable)).delay(200, MILLISECONDS) } and show the logs?\nThe logs could start at the last successful try and the two failed tries. Besides \u2014 how/when do you enable BT?. I am a bit confused \u2014 could you describe the reproduction steps as in the issue template?. I have just made release 1.7.2 \u2014 it should have this issue fixed. Thanks! The develop branch is already using androidx so hopefully it will get easier to maintain. \ud83d\ude80 . I have added Work In Progress to the title as I have seen that there are some TODOs in the code. Feel free to rename when you finish\nHave a Happy New Year! :). In this case I will put it on top of my Open Source priority list. One last thing \u2014 I have just released version 1.8.0 which is now using androidx. I have migrated the java sample app already. Could you also update the kotlin one? From now on I do not expect more such changes. BT 4.0 devices are not able to be connected and advertise at the same time. If you do not disconnect you may not expect that you will be able to scan the device. Different Android phones have different performance in regards how they scan. It may be that they will not scan the HRM in 7 seconds window. This has nothing to do with the library. Why do you think the thing you experience is a library issue?. autoConnect has no effect on reconnections. The library (re)connects only if a new subscription to .establishConnection() is made. Closing due to lack of information and inactivity of the original poster.\nWhen more data will be available\u2014feel free to add that information and reopen this issue.\nBest Regards. This is an implementation detail of the library. When the user turns the BT adapter ON the predicted adapter changes are BluetoothAdapter.STATE_OFF -> BluetoothAdapter.STATE_TURNING_ON and BluetoothAdapter.STATE_TURNING_ON -> BluetoothAdapter.STATE_ON.\nCurrently rxBleClient.observeStateChanges() does not track the state at the subscription time and only relays changes. The first change is BluetoothAdapter.STATE_OFF -> BluetoothAdapter.STATE_TURNING_ON which translates to RxBleClient.State.BLUETOOTH_NOT_ENABLED (it is the same for BluetoothAdapter.STATE_OFF and BluetoothAdapter.STATE_TURNING_OFF as well)\nIf that is an issue for you \u2014 you can quickly workaround by using:\nrxBleClient.observeStateChanges()\n            .startWith(rxBleClient.state)\n            .distinctUntilChanged(). Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users. Also feel free to check already posted questions as a similar one may be already answered.\nBest Regards. Hmmm... that is an interesting idea you used to simply put Thread.sleep(). I would recommend using .retryWhen() instead where you can return an Observable that could be .delay()-ed in a non-blocking manner. I suppose this is the problem with 'already connected' exception.\nSome other issues with status 133 are described in the wiki . Btw. @aptly-io \u2014 could you post your updated code? In case someone will come here and ask. I see no particular advantages in updating gradle build script to kotlin \u2014 what is the motivation?. I believe this error is correct. You try to connect more than once to the same device.. > The problem is my connection method I added on top?\nYes\n\nand why it tries to connect twice? \n\nI believe that you would learn more if you would figure it out for yourself. To make it easier the below code will exhibit the same behaviour:\noverride fun connect() {\n        subscriptions += rxBleClient.scanBleDevices(scanSettings, scanFilter)\n            .flatMap { scanResult ->\n                rxBleDevice = scanResult.bleDevice\n                scanResult.bleDevice.establishConnection(false)\n            }\n            .subscribeBy(\n                onNext = { Timber.d(\"Connect to a device is next: ${it?.contentToString()}\") },\n                onComplete = { Timber.d(\"Connect to a device is completed.\") },\n                onError = { Timber.e(\"Error while connecting to a device: $it\") }\n            )\n}\nIf you would need more assistance please head to stackoverflow with a tags like rxjava and rxandroidble as it was described in the disclaimer because this is more a general usage question than an issue with the library\nBest Regards. Hello,\nIt seems to be an Android bug \u2014 have you tried to recreate the issue with the vanilla Android API?. From my experience the Android BLE stack does not always work well with bound devices.\nThe log you have provided is only the stacktrace without any information on what happened before unfortunately. There is no information about what peripheral you're talking to nor on what device model / OS version your app runs \u2014 too small amount of actionable info. I am closing until more info will be added\nBest Regards. Hello,\nThanks for using the library. I have some thoughts\n\nIf scanning without a filter on devices running Android 8.1 or newer, scanning will stop when the screen turns off (and resume when turned back on).\n\nIt is a behaviour change for newer Android OS systems, not a bug. Why do you think this should be worked around by this library?\nIn the suggested solution it is written that:\n\nEDIT 2: On the Galaxy Note 9 with Android 8.1 and perhaps other Samsung devices with 8.1, scans are blocked with the screen off even with an empty scan filter. Scans are allowed with the screen off with a non-empty scan filter as described above.\n\nSo it is not a bulletproof solution and in my opinion it may confuse users when on some devices the scan stops if the screen is turned off and on other not. Additionally the user may simply add an empty ScanFilter by themselves if they see it necessary (unless the app is a generic BLE tool app it should probably have a non-empty filter list anyway).. I tested and fixed a logic issue. Then I made some minor changes that I found to better describe the actual flow of data. Anyway it was a good PR, thank you!. Thanks for the feedback. A question for my understanding: wasn't the description on RxReplayingShare enough or is it hard to find?. Hmmm... Indeed. I thought the ConnectionSharingAdapter was put in the helpers but it is in utils package which may make it harder to find.\nPersonally I am against using any kind of sharing adapters \u2014 one should strive for using a single .subscribe() and just model the observable/operator chain correctly. Unfortunately there is no \"one size fits all\" solution for that.\nIf you wish \u2014 you can prepare points with what you would like to see in the Wiki as a newcomer. If you have already learned all you want you could help us all and write down a tutorial which I could then put on a Wiki page. That is true \u2014 it is deprecated. It has a message that points to RxReplayingShare. Thing is that it still may be hard to discover. I recommend this talk by Jake Wharton \u2014 I tend to post a link to it in many places on the web \u2014 it is really great in developing a good mindset for RxJava. This approach was evaluated at the very beginning of this library development. It has been deliberately rejected as it introduces state to something that is basically a signal processing communication.\nIn my experience having more state in the app may seem to be user-friendly at first but it does not model BLE connections well enough and tend to be the cause of many hard-to-debug issues. Additionally the code that has more state is harder to understand.\nIf you have overcome the obstacle and reintroduced state \u2014 you may share your results so others could benefit.\nBest Regards. Of course you can\nEven if I may be against some solutions to particular class of problems does not mean that other people could find it helpful. Depending on my time I try to work on Wiki pages and your gist may be at some point referenced there \u2014 it would be easier to find by others. Thanks for sharing the code. Could you provide some more background on how it should be used? I could then create a Wiki page that could be easy to understand for other developers. Make sure that the service UUID is available in the advertisement packet. I am glad you found the issue. Aaaaaand \u2014 It is done! Thank you! \u2764\ufe0f . I am glad to hear that :)\nOne question: what styling you use for the kotlin files? I found my Android Studio default (or so I think) config formats the kotlin code differently. Yup, thanks for the info!. I am afraid that what you are referencing has no connection to the library. You should ask the app developer.\nBest Regards. What phone / OS version you experience those toasts with? I have not seen them at all. Is the app you provided a screenshot from open sourced? If so could you add a link?. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users. Also feel free to check already posted questions as a similar one may be already answered.\nGenerally your code snippet does not show it but the code is disposing the CharacteristicLongWriteOperation before it is even started \u2014 this is why it gets removed.\nBest Regards\nP.S. I really admire the fact that you have conformed to the issue template \ud83d\udcaa \ud83d\ude80 . Hello,\nThanks for the report\nYou could add this library to have a better stacktrace. Just because there is no code referenced in the plain RxJava2 stacktrace does not yet mean that the error is in the library code.\nAdditionally the code provided is not purely functional/stateless and therefore is hard to debug. Having a code that uses a single .subscribe() would be easier to understand.\nBest Regards. There is nothing unusual at this point. You can add more logs with RxBleClient.setLogLevel(RxBleLog.VERBOSE) from before the actual stacktrace. I have a hunch that your usage of subjects may cause problems. Please add the full logs anyway \u2014 they may indicate whether the issue is on the library side. As for the RxJava state management there is a good talk to watch which I constantly recommend. Still the library seems to remain functional as you can see in logs from this below:\n2019-02-26 14:10:05.806 22298-22380/com.myapp.debug D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(143355081)\nTry rewriting the code to get rid of the subject or always have it subscribed with just a log message and see what will happen. The error comes from FIFORunnableEntry which is directly routed to all RxBleConnection functions. Can you confirm that in the code you use every .subscribe() has an on error part?\nIf yes \u2014 I will need a minimal application that would exhibit the problem which I could build locally. Glad to hear that you have found it. Feel free to give more details as it may be easier for me to spot those situations in the future. Hello!\nThank you for using the library.\nThis is a general usage question and as such should be posted on stackoverflow with rxandroidble tag\u2014it will be easier to find by other users. Also feel free to check already posted questions as a similar one may be already answered.\nBest Regards. Hey! Thanks for the report. I have pushed a branch that should fix the issue. I have removed the manual handling of subscribers \u2014 it should all be handled now by the RxJava implementation. Feel free to look on the PR before I merge to double check if it looks correct.. I have just released 1.8.2 which should address this problem. Feel free to integrate it and report back if it fixed the issue.. Why not just use int?\n. without subscribe that the code will not be executed\n. without subscribe that the code will not be executed\n. What would you want to achieve by using volatile here?\n. Still there is room for a race condition. When the radio will start executing the scan operation but will not yet call run() and the operation would be unsubscribed then.\nWe could check if the operation wasn't unsubscribed right before calling startLeScan() but it would still need some manual synchronisation.\n. We should have a test that is currently causing us problems. Something like def \"should not startLeScan() if stop() was called before\". Maybe it will be even easier.\n. I believe this line should look: Set<RxBleDevice> rxBleDevices = new HashSet(size);\nOtherwise the function will throw NPE in line 73 or I have missed where the rxBleDevices is set.\n. Please add a test scenario in RxBleClientTest.groovy as well.\n. is this change of places needed?\n. Yes, for pull requests these reorderings only make it worse to read. For refactorings that are not changing code but only reordering - you can push directly.\n. I am not really convinced if this functionality is a subject to a timeout - I have not seen any reports of a stalled negotiation of the MTU. It would be best not to have an overcomplicated interface if it is not needed.. I agree. It would be good to have the @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) annotation in the interface as well.. These formatting changes are not relevant to this commit.. This part is also not directly bound to the MTU functionality and could be extracted to a different PR as it will be a benefit even without the MTU.. Would be good to have this one also annotated with @RequiresApi. .cache is not used here basically. timeoutFallbackProcedure is not needed here. Timeouts after 10 seconds.. not relevant to the functionality. removed line :) And added one line below. From my experience any added / deleted line that is not directly connected to the change only obfuscates the code. Minimal changes are the best changes as it is easier to spot mistakes.. this change with line break is obsolete. and this change with line break is obsolete. and this change with line break is obsolete. and this change with line break is obsolete. and this change with line break is obsolete. and this change with line break is obsolete. line 31 and 32 are not needed as the permission request was extracted to a different PR. This import is unused according to https://travis-ci.org/Polidea/RxAndroidBle/builds/181702296 checkstyle.. This import is unused according to https://travis-ci.org/Polidea/RxAndroidBle/builds/181702296 checkstyle.. This import is unused according to https://travis-ci.org/Polidea/RxAndroidBle/builds/181702296 checkstyle.. This import is unused according to https://travis-ci.org/Polidea/RxAndroidBle/builds/181702296 checkstyle.. this comment is not needed (probably a copy-paste error). One line spacing between functions is enough. ;). this is not needed. As we talked. I am also thinking if it would not be good to add method simulateScanError(@NonNull Throwable throwable). But it is a different topic.. /agree - would be a great, and simple, addition. Would be best if it could support. If not I think that some exception should be thrown. @uKL what do you think?. I have few thoughts:\n\nIf we would additionally pass an Action0 releaseRadioAction - which would be a proxy to releaseRadio() method - it would be easier to explain that calling the releaseRadioAction is needed to resume a normal radio operations\nIf we would pass a Observer<T> observerProxy it would be easy to describe that everything that goes into the observerProxy will be available in the returned Observable<T>\nMaybe the builder pattern here is not needed indirection? Maybe it will be better to create an abstract class like RxBleRadioOperationCustom and only allow to run subclasses of it?. Mocking both BluetoothGatt and RxBleGattCallback should be totally doable. But adding proper support for it would take some time - I am not even sure how many users the mock library has to judge if it is worth the effort or not.\nUnsupportedOperationException should be fine for now.. Agree - better to use an interface instead.\nBest would be to have an interface with a single entry point as you have proposed because it could be lambdafied although then the custom operation would not be able to specify the Priority. A default implementation of a method from Java 8 would be a solution here but we need something different.. On the second thought it would be yet another method in the interface which I have imagined at the beginning to be as simple as possible.\nWe can stick with only normal priority for now. We can always add the additional function later when someone will signal such a need. That would only need a minor version bump and not too much other work anyway.. As for the try / finally - Interesting idea.\nUnfortunately I do not think it is a good idea since then it is not certain if other queued operations would not be executed while the custom operation is running. This could lead to clashes if the custom operation executes multiple calls on BluetoothGatt - like in your update firmware situation.\nGreat that you think about other possible solutions!. True. \nBut the queue is continuing to be processed when the releaseRadio() is called. In the above snippet - to be sure that releaseRadio() is not called before the custom operation is finished - the execute() would need to be synchronous. And most of the operations on Android BLE are asynchronous - this is not really convenient. Moreover blocking in the .execute() would be on the main thread - a no-no.. the javadoc is outdated. javadoc is outdated. will never really terminate and the operations queue will not continue to process next events.. this is no longer needed - I cannot see any usage of it.. We could have more tests:\n\"should release the radio if custom operation will throw out of RxBleCustomOperation.execute()\"\n\"should release the radio if observable returned from RxBleCustomOperation.execute() will emit error\"\n\"should release the radio when observable returned from RxBleCustomOperation.execute() will complete\"\n\"should pass error if observable returned from RxBleCustomOperation.execute() will emit error\"\n\"should pass items emitted by observable returned from RxBleCustomOperation.execute()\"\nMaybe there are even more scenarios that should be covered.. I agree that the timeout is highly dependent on a use-case. Same problem could be with the long write op which checks for timeouts internally. I would add Normal queue processing will be resumed after the Observable returned by {@link RxBleRadioOperationCustom#asObservable(BluetoothGatt, RxBleGattCallback, Scheduler)} will complete. Maybe add a @NonNull annotation?. when: should contain only one statement. In this situation scanObservable.subscribe(testSubscriber). The rest should go to given:.\nBesides \u2013 it is not possible to configure mocks and spies in when:.. Yes. This description does not seem to match the test. Here it is checking if bleAdapterWrapperSpy.isBluetoothEnabled() was not called in line 92. Could you rephrase it to be easier to understand? Maybe something like: \"should check if /condition/ is met at the time of each subscription\"\nIt could like like this: \n```\n        given:\n        def firstSubscriber = new TestSubscriber<>()\n        def secondSubscriber = new TestSubscriber<>()\n        bleAdapterWrapperSpy.hasBluetoothAdapter() >> true\n        bleAdapterWrapperSpy.startLeScan(_) >> true\n        def scanObservable = objectUnderTest.scanBleDevices(null)when:\nscanObservable.subscribe(firstSubscriber)\n\nthen:\n1 * bleAdapterWrapperSpy.isBluetoothEnabled() >> false\n\nand:\nfirstSubscriber.assertError {\n    BleScanException exception -> exception.reason == BLUETOOTH_DISABLED\n}\n\nwhen:\nscanObservable.subscribe(secondSubscriber)\n\nthen:\n1 * bleAdapterWrapperSpy.isBluetoothEnabled(_) >> true\n\nand:\nsecondSubscriber.assertNoErrors()\n\n``\nThen we would need to make the test exercise for other conditions (isLocationPermissionOk/isLocationProviderOk). It could be quite easily achieved by usingwhere:clause. This test is basically redundant to the one above and to the one at line 101. seems also to be redundant. Yup. That should do. We should have also the test that would first pass and then fail (the opposite scenario).. What is your suggestion? Should we changewithAcktoisIndication?.ObservableUtil.justOnNext(T item)==Observable.never().startWith(T item)I do not thinkObservable.just(T item)would be enough here. Could you clarify?. This one could be astaticfunction ifsuppressPropertiesCheckwould be passed to it. Play around and find a way that will introduce the lease amount of methods / functions to.dex`\n\n\nYou can see how many fields and methods there are by adding the following snippet below apply from: in rxandroidble/build.gradle:\n```\nbuildscript {\n    repositories {\n        mavenCentral() // or jcenter()\n    }\ndependencies {\n    classpath 'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.7.0'\n}\n\n}\napply plugin: 'com.getkeepsafe.dexcount'\ndexcount {\n    format = \"list\"\n    includeClasses = true\n    includeFieldCount = false\n    includeTotalMethodCount = false\n    orderByMethodCount = true\n    verbose = false\n    maxTreeDepth = Integer.MAX_VALUE\n    teamCityIntegration = false\n}\n. I am actually thinking wether or not it would be better to have something like:\nif (illegalOperationChecker.checkAnyPropertyMatches()) {\n  return ... // normal stuff\n} else {\n  return Observable.error(new IllegalOperationException(/ construct /));\n}\n``\nIt would be then consistent no matter how the user would call the functionRxBleConnection.setupIndication(UUID)/RxBleConnection.setupIndication(BluetoothGattCharacteristic). Because now callingRxBleConnection.setupIndication(BluetoothGattCharacteristic)` will just throw.\nIt would need a different abstraction though. @uKL any thoughts?. This should also have .setSuppressOperationCheck(false) to match the previous behaviour.. setSuppressIllegalOperationCheck()? Now it is not too informative in my opinion.. It should be now possible to get rid of the RxBleRadioOperationConnect.Builder as all dependencies could be passed through ConnectionComponent.Builder.. This part about autoConnect should go to ConnectionSetup javadoc as it will be the place to set.. Currently we have a IllegalOperationChecker which is checking and handling the result. We could have IllegalOperationChecker that would work with IllegalOperationHandler which would either log or throw/emit an IllegalOperationException. The checker part would be always the same (could be put directly in RxBleConnectionImpl or injected as a separate object). {@link com.polidea.rxandroidble.RxBleConnection#establishConnection(ConnectionSetup)} instead of #establishConnection. Add @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) and a javadoc that will tell people not to instantiate this class. Maybe it is worth to expose getters instead of public finals \u2014 just a thought.. This may be now optimised. if else only picks a MismatchDataHandler. I think that having a MismatchData here is superfluous and it only adds an allocation. The data could be passed directly to the MismatchDataHandler. Why not just a IllegalOperationHandler? And it can be put just in internal.connection package. Does not look like an util that is used all over the code.. thrown -> emitted. the annotation should be on the constructor only. the class is meant to be used in the API. Maybe it is possible to get rid of the @ConnectionScope here as the operation is used only once and it is not needed to be cached. It is worth checking.. Maybe it is possible to get rid of caching for other items as well. please check method counts / fields.. Maybe this should also be with other names in the ConnectionComponent?. True though here we have fields in the API and we cannot change that later on if we would decide to pass BluetoothGattCharacteristic in the constructor. But it is just an opinion. @uKL thoughts?. related to or connected with ;) Flag maybe?. after around 30 seconds timeout. Start the line with a capital letter. Maybe something like: Example of how to integrate with Timber:?. Maybe we could annotate the ints with @BluetoothGattCharacteristicProperty to make it more precise what is this int related to. BluetoothGattCharacteristicProperty would then be put on the public API.. It still needs proper annotations?. mark it with @Nullable. ...aaaaaand javadoc ;). From what I see the executors are scoped. And .shutdown() is executed in RxBleClient.finalize(). Or am I missing something?. At this very line it is set to true if the current state equals false. Maybe\n## [Contributors](https://github.com/Polidea/RxAndroidBle/graphs/contributors), thank you!?. must?. This should not be a problem as every connection related object is being garbage collected once the connection is no longer used. In my opinion yes as we would like to have it repeated to anyone who will subscribe later. One for each?\nDo you think it would be good to add another .route() methods if different exceptions will be applicable?. Actually disconnectionErrorRelay should be a PublishRelay.\nWith this .replay().autoConnect(0) we are sure that both the adapterStateObservable() and disconnectionErrorRelay will get unsubscribed when any error/emission will happen. I have extracted variables so maybe it will be better to read.\nI like that there is no need to create additional Func1<BluetoothGatt, RxBleConnection> \u2014 seems that .delaySubscription() is a perfect match. Agreed. True. Indeed. When the BluetoothGattCallback.onMtuChanged() would be called with status != GATT_SUCCESS. No. That is why it is subscribed in the ConnectorImpl. It is referenced in the new OnSubscribe() and it cannot be referenced there if it is a member of the MtuWatcher. The problem is that there is no easy way of extending a Completable. Maybe it is even an anti pattern as we can have independent Completable subscriptions and shared AtomicInteger. It has to be a reference so it could be referenced from the OnSubscribe. Currently it is watching the Mtu and providing the current value, name may be changed. I just try to avoid manual state management. I am thinking wether it should be an .i() level. We could also use the same level log at the moment of starting the scan.\nA .d() level log could be used in a specific scan operation (legacy, api18, api21) that was used. Was not an issue till now. The DisconnectionRouter would not get created (@ConnectionScope) if the adapter is off. We will use Squash and merge option when merging. I wanted to wait with the signature establishConnection(ConnectionSetup) till the new Connection API will be ready\nReasoning:\n establishConnection(ConnectionSetup) is the easiest possible entry point\n if we will use it with now\u2014we will not be able to introduce the new Connection API without coming up with a new name for the function\nMaybe we could use something like Observable<RxBleConnection> establishConnection(boolean autoConnect, TimeoutSetup timeoutSetup) for now?. is this relevant?. Please add @NonNull annotation. new line. Maybe just Timeout?. Fixed!. shouldn't it be .v(...) as well?. Yup.. Not really needed since it is under internal package. We should include the formatting configuration into the repository so these kind of changes would not happen.. This should be placed near WriteOperationAckStrategy. I think that we should go with the .retryWhen() function rather than with just .retry(). This is because the .retryWhen() is more flexible. It allows for differentiation of the retry behaviour i.e. one may want to retry the write after some time or depending on other external factor. I am not a big fan of variables that are changed as a side effect. This usually makes room for a mistake and makes the code harder to trace.. Yup, probably we should go for WriteOperationRetryStrategy with something like:\nclass LongWriteFailure {\n  final int batchNumber;\n  // final int retryCount; \u2013> this should not be needed as it is trivial for the user to manage\n  final BleException cause;\n}. If you could push another commit to this PR I could then comment on specific lines. This actually should be a BleGattCharacteristicException as disabling the BluetoothAdapter is not really retriable.... Both should be final.. Not an ideal solution since the writeOperationRetryStrategy will get called each time the a new failure will happen where is could be called only once per subscription. Checkout how the Observable.compose() function or bufferIsNotEmptyAndOperationHasBeenAcknowledgedAndNotUnsubscribed works.\nBasically this: \nfinal int failedBatchNumber = (byteBuffer.position() - batchSize) / batchSize;\n                         final WriteOperationRetryStrategy.LongWriteFailure longWriteFailure =\n                                 new WriteOperationRetryStrategy.LongWriteFailure(failedBatchNumber, (BleException) cause);\ncould be separated to a Observable.map() and the writeOperationRetryStrategy could be treated as a Observable.Transformer (see .compose()). This could be a simple .onNext() as it only passes the longWriteFailure. Yup. I must be tired.... No other than BleGattCharacteristicException can be retried... Again, new commit in this PR makes it easier to see the whole picture. :). Yup, I have seen\u2014just have a bit of work now. Will get back to you as soon as possible. \ud83d\udc4d . I have checked out your branch and I hope I will have a moment Tomorrow to play with it and see if I can make it a little bit nicer. I cannot think of how to explain this so I will try to show it ;). This calculation will be wrong if the last batch will not be equal size to default batchSize. Ideally we should be passing the batch size to this function from the writeBatchAndObserve().. Maybe repositionByteBufferForRetry()?. Maybe toLongWriteFailureOrError()? It would then look like .flatMap(toLongWriteFailureOrError()). This is what I have changed which makes it easier to read in my opinion. I will refactor the ACK strategy one day.... Maybe errorIsRetriableAndAccordingTo(...)? Then we could have .retryWhen(errorIsRetriableAndAccordingTo(writeOperationRetryStrategy,...)). Yes, as the the .map() contains a pretty straightforward logic. Maybe toLongWriteFailureIfRetryable() (not sure about the spelling). It was exactly more about using .compose(writeOperationRetryStrategy). Ideally we should emit the batches to write byte[] which should be indexed. Those pairs of bytes and indexes should then be written (and retried) accordingly to the strategy to be in line with in as immutable approach as possible. I am not sure how would the performance turn up.... (byteBuffer.position() / batchSize) - 1 seems slightly easier to understand for me :). This line should go to above the .compose() as the user could potentially emit a different LongWriteFailure than they were passed which could flaw the reposition of the buffer.. this may stick for now until we will release final Rx2 version. Removed deprecated characteristic write function?. Add info like // look on how to use snapshot repository: https://github.com/Polidea/RxAndroidBle#snapshot. Why not justnew Consumer<>(...)?. This should be aCompletable. remove?. This should be aCompletable. This should be aCompletable. This should be aCompletable. Woah... I thought that it would be more flexible to leave it asObservablebut it is internal so whatever\u2014we can change it later and now it is probably more precise :). :+1:\n. :+1:\n. SoSingleorObservable?. This should be aCompletable. <T>?. I am not sure if we need this convenience function\u2014never used it personally. I either useUUIDor want to do something withDiscoveredServices`. Idea for later - Make operations for\n\nObservable\nSingle\nCompletable\n\nWe could then remove firstOrError\u2014not sure that it is worth it anyway as it is purely internal. this seems to be inaccurate as it turned out that just all BLE operations must happen sequentially from a single thread. Maybe just add it to ByteAssociation?. As we have issues with this maybe we should switch to ReplayingShare?. Maybe we should test our TestSubscriberExtension? I am not convinced if it is 100% reliable having seen bugs before. .test() can be extracted. should this be extracted to another test?. Why removed? It was meant as a showcase for those who would like to see some more advanced usage. There are references to this file on Stackoverflow for instance.. =>private void dispose()?. dispose()?. Reliable write is a different topic\u2014I was thinking about a totally different API for that where Reliable.writeCharacteristic(...) would emit byte[] but there are some doubts if this actually works as intended. Currently there is little use of the emitted value.. Not used to RxJava2 syntax yet. Maybe splitting it in two/three lines and/or making an util would make it easier to understand (pardon kotlin):\nval disposableObserver = DisposableUtil.disposableObserver(observer)\nval disposable = locationServicesOkObsImpl.subscribeWith(disposableObserver)\nobserver.onSubscribe(disposable). Yup it is and it can still be. I am just thinking if it should be in the interface. actually now none of the operators are intended to use with nulls :). Better in terms of? :D\nWe could use two .flatMaps here:\n.flatMap(clickEvent -> rxBleDevice.establishConnection(false))\n.flatMap(\n  connection -> getCharacteristic(characteristicUuid, rxBleConnection),\n  connection, characteristic -> Pair.create(connection, characteristic)\n)\n...\nIf you would like to rearrange the code to make it easier to read / comprehand\u2014feel free to try :). so it would need here to have .toObservable() I suppose. couldn't it be cached?. check if it is attached?. check if it is attached?. check if it is attached?. check if it is attached?. Could you make the last batch to have an uneven number of bytes? I think we can have a wrong ByteBuffer positioning on the last batch if is not full. doesn't it return a failed batch number + 1?. Having a [1,2,3,4,5] and 2 bytes per batch\nIf the first batch fails the byteBuffer.position() would return 2\n2/2 == 1 and the failed batch index should be 0. calculateFailedBatchNumber is misleading in this situation, either we should return\n(int) Math.ceil(byteBuffer.position() / (float) batchSize) - 1\nor name the function differently?. Yup. This is user (developer) facing data\nI think we should switch to zero-based indexes and rename the function to calculateFailedBatchIndex and longWriteFailure.getBatchIndex() respectively. why commented out?. maybe emitter.tryOnError(e);?. Actually it could only be the BleGattException with BleGattOperationType==ON_MTU_CHANGED. Shouldn't it be status? And maybe STATUS_UNAVAILABLE?. status\nPlus this changes the public API :/. status, public api. status, public api. We could deprecate the current constructors and add a LIBRARY_GROUP annotation to the new one. Indent. Thinking wether this should be Completable or not... On one hand this may only throw and is a synchronous call. On the other hand having a Completable would make it more consistent. Thoughts?. RxBleLog?. scanStartResult != NO_ERROR?. survive => work \u2014 we should not use colloquialisms imo ;). wand => and. Shouldn't we also add tests for RxBleClient to call the BackgroundScanner?. afaik there is need to put at least one filters\u2014this could be mentioned here and in the docs. maybe add a spinner for filtering with HRM service/weight scales/dunno other?. I know it is probably deprecated long enough but it is still a breaking API change. Version 1.7.0-SNAPSHOT ;) + we should make appropriate changes in gradle.properties. Can we have consistent spaces?. No longer needed I suppose. We may end up leaking a context if this will get called before the subscribe finishes. Yup, but we should get rid of the try/catch in the Cancellable as it could only hide potential issues. This could be on the top level \u2014 not a nested class. Better sustainability I suppose.. Maybe setConnectingTimeout? Connection may be understood as a whole but Connecting is the process of establishing a Connection?. Not sure if this would be sufficient for this use-case as the race may if a new observer is subscribing to asValueOnlyObservable after the check for exceptionOccured is made. You could add @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP). This line is only valid for DEFAULT_CONNECTING_TIMEOUT because DEFAULT_OPERATION_TIMEOUT is valid regardless of the mode\nPlus we could add (in direct mode / autoConnect=false). I believe that something like this would be more precise:\nTimeout in seconds after which the connecting process will be considered as broken. This value is only taken into consideration in direct connection mode (autoConnect=false).. I have also spotted an imprecise description here. Could be something like:\nTimeout in seconds after which the operation will be considered broken. USE WITH CAUTION. If this value is changed to lower than the default 30 seconds the library's internal operation queue may get desynchronised with the actual Android OS state. This may lead to next operations being rejected by the system until the default timeout will be reached. Eventually the operation will be canceled and removed from the queue.. Add This value is taken into consideration only in direct connection mode (autoConnect=false). I would add here information that it is only taken onto account when used with autoConnect=false.. It is set on RxBleDevice level but ultimately it ends in ConnectOperation and should be tested properly in def \"should emit BluetoothGattCallbackTimeoutException with a valid mac address on CallbackTimeout\" test in OperationConnectTest:144 where there is a hardcoded value 35. It should be verified that the timeout will happen exactly as specified in OperationTimeoutConfiguration. A good question. Writing CCC descriptor is a one time operation so it should end quickly. This question inspired me to write another test to check if writing the CCC will not happen after the parent Observable<Observable<byte[]>> is disposed. ```suggestion\n}\nAdded a new line at the end of the file.suggestion\n    private static final int REQUEST_PERMISSION_COARSE_LOCATION = 9358;\n. An additional warning could be useful here as well I suppose.suggestion\n        compositeDisposable.clear();\nOtherwise the next time the activity will resume nothing will work.suggestion\n        compositeDisposable.clear();\n.suggestion\n                // unknown error - return default message\n                Log.w(\"Scanning\", String.format(\"No message found for reason=%d. Consider adding one.\", reason));\nI was actually thinking about giving a warning log that we got a `reason` that has no error message so it will be clear what to fix.suggestion\n        Log.w(\"Scanning\", text, exception);\nEveryone will know that this is an exception because of a stacktrace ;). This one does not seem to be properly disposed. It is possible that the `mtuDisposable` will get overwritten if user would tap the button more than once. May get overwritten due to user clicks. This seems not used?. Errors from `BluetoothAdapter` being switched off are now relayed through `bleExceptionBehaviorRelay`. The `bleExceptionBehaviorRelay` then passes the errors to `firstDisconnectionValueObs` and `firstDisconnectionExceptionObs` which are subscribed from the outside. Subscribers management is now done solely by RxJava. Yes, the `bleExceptionBehaviorRelay` should be subscribed to errors comming from turning off the BluetoothAdapter as soon as possible. It will also get unsubscribed at the first occurance of any error. The `bleExceptionBehaviorRelay` will keep the error for the future subscribers. `Timber` (which inspired the `RxBleLog`) has it's own `TAG` resolver \u2014 it's kinda hacky and not very performant but the trace should be clear. It does not reset other options. The new options are merged into old one. The implementation of `RxBleLog.setLogOptions(LogOptions)`:\npublic static void setLogOptions(LogOptions logOptions) {\n    LoggerSetup oldLoggerSetup = RxBleLog.loggerSetup;\n    LoggerSetup newLoggerSetup = oldLoggerSetup.merge(logOptions);\n    d(\"Received new options (%s) and merged with old setup: %s. New setup: %s\", logOptions, oldLoggerSetup, newLoggerSetup);\n    RxBleLog.loggerSetup = newLoggerSetup;\n}\n\npublic LoggerSetup merge(LogOptions logOptions) {\n    int logLevel = logOptions.getLogLevel() != null ? logOptions.getLogLevel() : this.logLevel;\n    int macAddressLogSetting =\n            logOptions.getMacAddressLogSetting() != null ? logOptions.getMacAddressLogSetting() : this.macAddressLogSetting;\n    int uuidLogSetting = logOptions.getUuidLogSetting() != null ? logOptions.getUuidLogSetting() : this.uuidLogSetting;\n    boolean shouldLogAttributeValues =\n            logOptions.getShouldLogAttributeValues() != null ? logOptions.getShouldLogAttributeValues() : this.shouldLogAttributeValues;\n    LogOptions.Logger logger = logOptions.getLogger() != null ? logOptions.getLogger() : this.logger;\n    return new LoggerSetup(logLevel, macAddressLogSetting, uuidLogSetting, shouldLogAttributeValues, logger);\n}\n. Maybe this function may have a better name?. `INFO` level is used here so most of the actions would get clear input and output in the logs on a pretty high level. I.e\nI/RxBle#ConnectionOperationQueue: RUNNING  CharacteristicWriteOperation{MAC='B4:99:4C:34:DE:77', characteristic=[uuid='f000aa12-0451-4000-b000-000000000000', hexValue=[01]]}\nI/RxBle#GattCallback: MAC='B4:99:4C:34:DE:77'    onCharacteristicWrite(), status=0, value=[uuid='f000aa12-0451-4000-b000-000000000000']\n```\nif (RxBleLog.isAtLeast(LogConstants.INFO)) is not used as here there are no \u2014 up-front \u2014 object creations \u2014 it is handled on the lower level. It is not needed as there is no object creation involved. I thought that it is the lowest value for most verbose logging. So the MAC_ADDRESS_FULL is like VERBOSE \u2014 it is an alias. Do you think this should be changed?. I am not sure if it would be visible on the private constructor. Added some docs\ncom/polidea/rxandroidble2/LogOptions.java:11\ncom/polidea/rxandroidble2/LogOptions.java:75\ncom.polidea.rxandroidble2.RxBleClient#updateLogOptions\nDo you think that here they also should be present?. ",
    "farmazon3000": "39 related.\n. So this is what I have to automatically try to connect to device after disconnect happens with 5 seconds delay:\nrxBleDevice.establishConnection(context, false) // <-- autoConnect flag\n    .doOnError(throwable -> {\n        Log.d(TAG, \"rxBleConnection doOnError: \" + throwable);\n    })\n    .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n        @Override\n        public Observable<?> call(Observable<? extends Throwable> errorNotification) {\n            return errorNotification\n                    .flatMap(new Func1<Throwable, Observable<?>>() {\n                        @Override\n                        public Observable<?> call(Throwable throwable) {\n                            Log.v(TAG, \"connect retrying...\");\n                            return Observable.timer(5, TimeUnit.SECONDS);\n                        }\n                    });\n        }\n    })\n    .subscribe(rxBleConnection -> {\n        Log.d(TAG, \"rxBleConnection: \" + rxBleConnection);\n    });\n. \"15 days ago\" \"snapshot release next week\" so where is it?\n. status 8 is a timeout error as far as I know where do you know that from?\n. @tatewaki I have the feeling you're mixing bonding with connecting, I believe those are not the same.\n. I think you are wrong, I DO handle onError in my snippet:\n.doOnError(throwable -> {\n        Log.d(TAG, \"connectionState doOnError: \" + throwable);\n    })\n. Thank you guys for pointing it out.\n. OK, enum was just an idea, you can also go Google style like https://developer.android.com/reference/android/bluetooth/BluetoothGatt.html#GATT_SUCCESS.\n. Even when I try to disconnect later it's queued but not proceeded (i.e. when I unsubscribe from connection subscription I see in logs RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(237327482) and then silence - it's not proceeded).\n. It (of course :)) seems to be some kind of problem with BT on Android itself as it does not occur always. And sometimes it may be fixed but switching off/on BT. Sometimes I have to reset whole device.\n. Do you connect to a device that is changing it's services or something? No, the device I am connecting to definitly does not change its services. It seems that I was so long messing around with BLE on my Moto G that it was the time when nothing works and you have to restart BT or restart Moto G. After 2 years working with BLE in Android I can tell that it happens every once in a while (especially when you make some stress tests and connect/disconnect to multiple devices very frequently). But it would be nice to have at least some way to try to solve this issue.\n. I was using RxBleDevice#getConnectionState but I was unsubscribing from subscription on RxBleDevice#getConnectionState as soon as I disconnect (i.e. unsubscribing from subscription on RxBleDevice#establishConnection).\nThis is why I was not informed by RxBleDevice#getConnectionState().\n. Anyway, when I removed unsubscribing from subscription on RxBleDevice#getConnectionState, on logcat I see:\n08-05 11:03:57.330 1736-1736/com.test.app D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a19-0000-1000-8000-00805f9b34fb enable: false\n08-05 11:03:57.332 1736-1736/com.test.app D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(177380646)\n08-05 11:03:57.333 1736-1736/com.test.app V/XXXBleXX:XX:XX:XX:XX:XX: establishConnection doOnUnsubscribeXX:XX:XX:XX:XX:XX\n08-05 11:03:57.335 1736-1795/com.test.app D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(177380646)\n08-05 11:03:57.336 1736-1736/com.test.app V/XXXConnStateSubscriber: onNext: RxBleConnectionState{DISCONNECTED} thread Thread[main,5,main]\n08-05 11:03:57.337 1736-1736/com.test.app D/XXXBleEngine: disconnected on thread Thread[main,5,main]\n08-05 11:03:57.338 1736-1736/com.test.app V/XXXBleXX:XX:XX:XX:XX:XX: observeConnectionStateChanges doOnUnsubscribeXX:XX:XX:XX:XX:XX\n08-05 11:03:57.339 1736-1736/com.test.app D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(177432340)\n08-05 11:03:57.339 1736-1736/com.test.app D/XXXBleEngine: syncWithStorage, onCompleted\n08-05 11:03:59.563 1736-1748/com.test.app D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n08-05 11:03:59.572 1736-1795/com.test.app D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(177380646)\n08-05 11:03:59.572 1736-1795/com.test.app D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(177432340)\n08-05 11:03:59.574 1736-1736/com.test.app D/BluetoothManager: getConnectionState()\n08-05 11:03:59.574 1736-1736/com.test.app D/BluetoothManager: getConnectedDevices\n08-05 11:03:59.580 1736-1736/com.test.app D/BluetoothGatt: cancelOpen() - device: XX:XX:XX:XX:XX:XX\n08-05 11:03:59.605 1736-1872/com.test.app D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=XX:XX:XX:XX:XX:XX\n08-05 11:03:59.605 1736-1872/com.test.app D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n08-05 11:03:59.610 1736-1736/com.test.app D/BluetoothGatt: close()\n08-05 11:03:59.610 1736-1736/com.test.app D/BluetoothGatt: unregisterApp() - mClientIf=5\n08-05 11:03:59.612 1736-1795/com.test.app D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(177432340)\nThe setCharacteristicNotification() - uuid: 00002a19-0000-1000-8000-00805f9b34fb enable: false goes just after I called disconnect (i.e. unsubscribing from subscription on RxBleDevice#establishConnection) and I had notifications enabled on Battery Level characteristic.\nSo onNext: RxBleConnectionState{DISCONNECTED} happens more than 2s before RxBle#Radio: FINISHED.\n. This refresh may be the last resort for problems like #49.\n. ",
    "tinybright": "I overlooked it.\n. ",
    "xmbb": "i can't understand lambda, can you help to transform to normal\n. ",
    "odmitriv": "From a connected device\n. ",
    "klemzy": "Hi,\nI see, was not aware of that. Thanks!\n--\u00a0\nKlemen\nSent with Airmail\nOn 7 April 2016 at 15:41:53, Pawe\u0142 Urban (notifications@github.com) wrote:\nHey!\nStarting from Android 6.0 it is required to hold ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION in order to get scan results of device mac address. This is to strengthen user privacy. Even more, it is required that the user will have location services enabled.\nYou can read more here.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\n. Is there planned snapshot release including this fix? Thanks!\n. I don't have it ready yet, I was just wondering if library already supports this, otherwise I can find I way to support this because I would really need this feature :) In my experience by using BluetoothDevice API with createBond then you get presented with popup dialog.\n. I see. Well we have a BLE device which requires pairing becase of security issues. And if initiating connection without specific bond request pairing is displayed as notification and not popup dialog. If this feature is not scope of this library I will just handle this internally. No problem.\n. I just noticed that in SHAPSHOT version, scan already exposes BluetoothDevice but it's not released yet. This actually solves my problem.\n. rxBleClient.scanBleDevices()\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .doOnUnsubscribe(() -> Timber.i(\"Scan unsubscribe\"))\n                        .subscribe((rxBleScanResult -> {                           \n                            }\n                        }), (throwable -> {\n                            if (throwable instanceof BleScanException) {\n                                String msg = getExceptionMessage((BleScanException) throwable);\n                                scanCallback.scanResult(new ScanResult(msg));\n                            }\n                        }))\nAndroid N Preview 4, Nexus 6P\n. Awesome. Had the same problem. This also fixed it for me.\n. I see. Also some more information. The weird thing is that in RxBleGattCallback onConnectionStateChange gets called but not onServicesDiscovered. Also another thing. When I debugged with breakpoints on bluetoothGatt.discoverServices() and onComplete inside RxBleRadioOperation getSubscriber then it worked.\n. I see, but did you try to connect again after turn off/on with device being discoverable? Because my problem is that when Bluetooth turns on I call establishConnection and then it hangs.\nI am using Nexus 6P, Android N Preview 4\ndevice.establishConnection(context, true)              \n            .flatMap(rxBleConnection ->\n                    rxBleConnection.getCharacteristic(CHARACTERISTIC)\n                            .flatMap(characteristic -> \n                                    rxBleConnection.writeCharacteristic(setValue(characteristic))\n                                            .cache()\n                                            .flatMap(characteristic1 -> readData(rxBleConnection))\n                            )\n            );\nThis is the code.\n. I am calling unsubscribe but I did not include the whole snippet. I am listening to the adapter on/off and unsubscribing appropriately. Also I unsubscribe when I finish reading from the device.\nI am using latest code commited in this repository. \nWhen I was debugging (I included library source into my project) the code worked?!?!?, services got discovered.\nI also found a way to simulate this by not turning on/off the adapter:\n.subscribe(bluetoothGatt -> {\n                        try {\n                            Method method = bluetoothGatt.getClass().getMethod(\"refresh\");\n                            if (method != null) {\n                                method.setAccessible(true);\n                                boolean result = (boolean) method.invoke(bluetoothGatt);\n                                RxBleLog.d(\"Refresh result \" + result);\n                            }\n                        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n                            e.printStackTrace();\n                        }\n                        bluetoothGatt.close();\n                    },\n                    throwable -> onError(throwable),\n                    () -> onCompleted()\n)\nBasically inside RxBleRadioOperationDisconnect I have added refresh function. This clears discovered services cache from the device (which also happens on adapter off). At least what the Google and internet says.\nSo at the moment I managed to fix this with the folling code inside RxBleRadioOperationServicesDiscover.\nHandler handler = new Handler(Looper.myLooper());\nhandler.postDelayed(() -> {\n    final boolean success = bluetoothGatt.discoverServices();\n    RxBleLog.d(\"Discover services \" + success);\n    if (!success) {\n        subscription.unsubscribe();\n        subscriber.onError(new BleGattCannotStartException(BleGattOperationType.SERVICE_DISCOVERY));\n    }\n}, 5000);\nMaybe there is a better solution to this problem.\nI have attached logs.logs.txt\n. Great. Thanks!\n. ",
    "mars3142": "And why don't you handle the \"permission request\" in your library? Do I have to handle by myself?\n. @klemzy \"...And if initiating connection without specific bond request pairing is displayed as notification and not popup dialog....\" - I also run into this issue and I found out, that I need to start and stop discovery on my device: BluetoothAdapter.getDefaultAdapter().startDiscovery() -> with a change receiver stop and after that, I do a connect, which always shows the popup and not the notification. . The biggest problem is the comment in the NordicSemiconductor (Android-nRF-Toolbox) repo (https://github.com/NordicSemiconductor/Android-nRF-Toolbox/blob/master/app/src/main/java/no/nordicsemi/android/nrftoolbox/profile/BleManager.java#L1050), which seems to also affected your app:\n/*\n* The onConnectionStateChange event is triggered just after the Android connects to a device.\n* In case of bonded devices, the encryption is reestablished AFTER this callback is called.\n* Moreover, when the device has Service Changed indication enabled, and the list of services has changed (e.g. using the DFU),\n* the indication is received few milliseconds later, depending on the connection interval.\n* When received, Android will start performing a service discovery operation itself, internally.\n*\n* If the mBluetoothGatt.discoverServices() method would be invoked here, if would returned cached services,\n* as the SC indication wouldn't be received yet.\n* Therefore we have to postpone the service discovery operation until we are (almost, as there is no such callback) sure, that it had to be handled.\n* Our tests has shown that 600 ms is enough. It is important to call it AFTER receiving the SC indication, but not necessarily\n* after Android finishes the internal service discovery.\n*\n* NOTE: This applies only for bonded devices with Service Changed characteristic, but to be sure we will postpone\n* service discovery for all devices.\n*/\n\nI ran into the issue with my BLE device, which can't reconnect and I think, it's because of the caching. Am I able to start this discovery by myself for bonded devices?. I don't want to bind the device. Just connecting, reading and writing.\n. I added a notification to a characteristic and in the StatusBar a \"binding notification\" pops up. This is really bad, because I expected a PIN dialog popping up.\nI'll check your advice with manual binding, but this way I had to know which characteristics are protected or is this a one time thing? How about PIN changes? Will I need to bind again?\n. ",
    "wanzi2016": "I always get the hint: Location services needs to be enabled on Android 6.0\nHow can I enable the location services? \nThanks\n. Oh, never mind, I just enable it (By enable GPS...)\nThanks for the source anyway.\n. ",
    "mgranberry": "How much testing do you want to see?  It looks like setupNotification is heavily-tested, but much of that seems like it would be redundant to replicate.\n. @dariuszseweryn that is correct, and the reason that I haven't made a PR yet.\n. ",
    "cbodin": "This is exactly what i'm needing. Your hack works great @mzgreen.\nIs the overwrite parameter really needed? It seems like an overwrite could always happen and leave it up to the developer to check if a notification/indication is already set to the same characteristic.\n. Emitting exception directly when subscribing or throwing an exception when the setupNotification method is called?\n. ",
    "dlykoits": "yes\n. Sorry, misunderstood you.\nI just call this code again when connection state change(disconnected) appear.\nand nothing happened.\n. Please look  at sources: https://github.com/dlykoits/RxAndtoidBLESample.git\nSteps to reproduce:\n1) press connect -> ble device connected\n2) then turn off ble device - > connection lost\n3) turn on ble device\n4) press connect\nActual result:\nconnection establishment doesn't work, \"disconnected\" status appear immediately after establish call \nExpected result:\nconnection established again\n. You right, Thanks a lot!!!\nP.S.: I started learning RX week ago.\n. ",
    "recoverrelax": "Yes Please support api 21+. The improvements on the api are so great, it will be a waste not to use the earlier APIs. I can tell you, devices >21, little to few able problems using the new API. The older API on the other hand ..\n. Hello! Thanks you for the fast reply and feedback.\n. ",
    "aldoborrero": "Why not to use the Android BLE Scanner Compat that NordicSemi has?\nIt allows you to abstract like the official android compat libraries does. The license is BSD clause 3 so it doesn't have to suppose a problem to use its codebase.\n. Or at least to warn the programmer like SweetBlue does with its UhOhListener:\n\nThe native stack's bluetooth service can sometimes get into states where it can't be turned on, or even can't be turned off. SweetBlue cannot fix this, but is does detect and report this issue through UhOhListener. Usually this means a phone restart is required.\n\nJust an idea (that unfortunately can't be translated directly). \n. Thanks! It helps! :)\nMy main concern is that as I'm learning RxJava I missed that.\n. Yeah I believe that are 4 for version below 4.4 and then incremented the value to 7 from 5.0! But thanks for the remainder :)\n. Hi @dariuszseweryn \nI have another related question with what you have shared yesterday:\nI can subscribe perfectly to the notifications and I can map those to a pair to latter transform the bytes[] values to meaningful data.\nThe same applies if I want to read those characteristics that allows reading with the following snippet of code:\nconnectionObservable.flatMap(connection ->\n        connection.discoverServices()\n            .flatMap(services -> services.getService(SERVICE_ID).map(BluetoothGattService::getCharacteristics))\n            .flatMap(Observable::from)\n            .filter(characteristic -> BleUtils.hasReadProperty(characteristic.getProperties()))\n            .flatMap(connection::readCharacteristic, Pair::new)\n            .compose(valueAdapterTransformer)\n    )\n        .subscribe(pair -> logger.d(TAG, \"Pair: \" + pair));\nI would like to upon the first connection: read an amount of characteristics that has the reading property and only after that subscribe to those notifications that have the notification property pretty much as you explained me yesterday.\nThe thing is that when I do the first part the reading observable won't emit a finish a doOnComplete call as is waiting for more, so I can't kickstart or compose the next operation which is subscribing and listening to changes. I know for sure the amount of characteristic that has the read property but I would like to do it in a generic fashion (i.e it doesn't matter if I have 7 or 15 characteristics that I want read, I only want to read them all, write the pojo values, and after that start listening the notifications).\n(Sorry to bother you again with more questions about RxJava than the library itself but I've been searching for examples and I can't find nothing valuable). \nMaybe the option is to use an observable that counts the emission of the first one and then after that chain through that to start listening notifications. \nHow is the best option to achieve that?\nBTW I think that this answers would be good to create a Wiki and explain advanced usage of the library (providing more examples to the sample app). I would gladly do it.\nThanks\nEdit 1: Updated the title to be more meaningful.\n. Yeah, you're right :)\n(I'm going to create the question there and I'll update this comment with the link).\nEdit:\nQuestion is asked in StackOverflow.\nI'll close this 'non issue' issue.\nThanks!\n. Hi @DariuszAniszewski thanks for your quick answer as always!\nI'm going to create then a question in StackOverflow (I'll update this comment with the link when is posted, for helping other newbies in RxJava).\nThanks a lot!!! :)\n. As far as I know there's no problem at all mixing Apache 2 and BSD.\nHere's the reason: http://programmers.stackexchange.com/questions/40561/is-bsd-license-compatible-with-apache.\nAs I remember, there was a bug with a particular version of the library with the scan filter (but maybe they have fixed it!).\n. Yeah that was indeed! I didn't check the version! Last time I used the lib was\npre 0.1.2!\nOn Oct 12 2016, at 10:37 am, Martin Mauch notifications@github.com wrote:  \n\n@aldoborrero I guess you are referring to\nthis one? NordicSemiconductor/Android-Scanner-Compat-\nLibrary#1\nThat should be fixed since 0.1.2. The fork uses 0.2.0, so that should be fine.\nI'm also using the fork and it seems to be working fine so far.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the\nthread.\n. I've added an issue asking if they plan to add it.\n\nhttps://github.com/NordicSemiconductor/Android-Scanner-Compat-Library/issues/6\nIf that doesn't happen I would do it myself and I'll send a PR.\nThe good parts are that we can reuse tests from Android source code and adapt it.\n. Just to keep informed this thread also, I did the very first attempt to add, at least, the same tests that Android AOSP has.\n. First batch of AOSP tests has been merged. I plan to add custom ones to the library in upcoming days.\n. For sure, I would like to add more test coverage beside those that AOSP has (which IMHO are a bit low and doesn't test too much).\nI'm in talks with @philips77 to increase the coverage of the code. I'll keep updating this thread with more news regarding this topic (bear in mind that I will try to add it ASAP, but with not commiting myself too much as these weeks I have a pretty busy agenda).\nThanks for sharing @dariuszseweryn :)\n. Hey @dariuszseweryn Happy New Year too!\nI've been busy this past two months. But I plan to start next week as soon as I come back to Barcelona :)\nI'll ping you again \ud83d\udc4d !!. Hi guys! I have back my Bluetooth device to test so I can try to move this forward also. \nPreviously, we were discussing of using the library from Nordic Semi to provide compatibility but I'll discard that and go forward with this PR (as is already being happening). I can help also to test.. I've noticed the same exact input. The operations are queued even if you specified the operation with retryWhen() on the connection observable. \n. To have more insight on this particular issue. I'll copy here the steps I'm doing to reproduce it:\nI have a class which is called BleDeviceManager:\n``` java\n@Override public void connect(@NonNull final String address) {\n      rxBleDevice = rxBleClient.getBleDevice(address);\n  // Setup observation of connectivity changes\n  connectionStateSubscription = rxBleDevice.observeConnectionStateChanges().observeOn(AndroidSchedulers.mainThread()).subscribe(this::onConnectionStateChanged);\n\n  // Start properly the connection to the device\n  connectionObservable = rxBleDevice.establishConnection(context, false)\n      .takeUntil(disconnectionTrigger)\n      .retryWhen(this::onShouldRetryConnectionOperation)\n      .compose(new ConnectionSharingAdapter());\n\n  // Subscribe to the observable\n  connectionObservable.subscribe(this::onConnectionSuccess, this::onConnectionFailure);\n\n}\nprivate Observable<?> onShouldRetryConnectionOperation(Observable<? extends Throwable> observable) {\n    return observable.delay(RECONNECTION_DELAY_TIME, TimeUnit.SECONDS).filter(throwable -> {\n      if (throwable instanceof BleDisconnectedException) {\n        return true;\n      }\n  if (throwable instanceof BleGattException) {\n    BleGattException bleGattException = (BleGattException) throwable;\n\n    switch (bleGattException.getStatus()) {\n      case BLUEDROID_GATT_ERROR:\n      case BLUEDROID_GATT_CONNECTION_TIMEOUT:\n        return true;\n    }\n  }\n\n  return false;\n});\n\n}\nprivate void onConnectionSuccess(RxBleConnection rxBleConnection) {\n        deviceSubscription = connectionObservable.observeOn(Schedulers.computation())\n            .flatMap(connection -> connection.discoverServices()\n                .flatMap(services -> services.getService(SERVICE_ID).map(BluetoothGattService::getCharacteristics)), Pair::with)\n            .flatMap(pair -> {\n              final RxBleConnection connection = pair.getValue0();\n              final List characteristics = pair.getValue1();\n              return readInitialValues(connection, characteristics).concatWith(setupNotifications(connection, characteristics));\n            })\n            .subscribe(ignored -> {\n            }, throwable -> {\n              logger.e(TAG, \"Error: \" + throwable);\n            });\n  }\nprivate Observable, byte[]>> readInitialValues(final RxBleConnection connection,\n      final List characteristics) {\n    return Observable.from(characteristics)\n        .filter(characteristic -> BleUtils.hasReadProperty(characteristic.getProperties()))\n        .flatMap(connection::readCharacteristic, Pair::with)\n        .observeOn(Schedulers2.singleThread())\n        .compose(valueAdapterTransformer)\n        .doOnNext(triplet -> {\n              // Do things with the values received\n        });\n  }\nprivate Observable, byte[]>> setupNotifications(final RxBleConnection connection,\n      final List characteristics) {\n    return Observable.from(characteristics)\n        .filter(characteristic -> BleUtils.hasNotificationProperty(characteristic.getProperties()))\n        .flatMap(characteristic -> connection.setupNotification(characteristic).flatMap(observable -> observable), Pair::with)\n        .observeOn(Schedulers2.singleThread())\n        .compose(valueAdapterTransformer)\n        .doOnNext(triplet -> {\n           // Do things with the values received\n        });\n  }\n```\nWhen I call the method connect() and the reading of the values characteristics starts (after the initial connection), then I switch off the Bluetooth toggle and reenable it:\nThis is the log I obtain:\n10-17 09:13:55.844 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(79890976)\n10-17 09:13:55.845 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(79890976)\n10-17 09:13:55.850 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{DISCONNECTED}\n10-17 09:13:55.850 26709-26709/com.test.bluetooth D/BleDeviceManager: Device has been disconnected!\n10-17 09:13:55.851 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{CONNECTING}\n10-17 09:13:55.854 26709-26709/com.test.bluetooth V/RxBle#BleConnectionCompat: Connecting without reflection\n10-17 09:13:55.855 26709-26709/com.test.bluetooth D/BluetoothGatt: connect() - device: D8:7A:09:F1:66:8E, auto: false\n10-17 09:13:55.856 26709-26709/com.test.bluetooth D/BluetoothGatt: registerApp()\n10-17 09:13:55.856 26709-26709/com.test.bluetooth D/BluetoothGatt: registerApp() - UUID=ee5193fa-1f7f-4d19-a314-25d76602dfd4\n10-17 09:13:55.858 26709-26722/com.test.bluetooth D/BluetoothGatt: onClientRegistered() - status=0 clientIf=7\n10-17 09:14:05.858 26709-26709/com.test.bluetooth D/BleDeviceManager: Device timeout while connecting!\n10-17 09:14:20.736 26709-26721/com.test.bluetooth D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=7 device=D8:7A:09:F1:66:8E\n10-17 09:14:20.739 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=133\n10-17 09:14:20.745 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{DISCONNECTED}\n10-17 09:14:20.745 26709-26709/com.test.bluetooth D/BleDeviceManager: Device has been disconnected!\n10-17 09:14:20.749 26709-26721/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(235196745)\n10-17 09:14:20.756 26709-26721/com.test.bluetooth D/RxBle#RadioOperationConnect: No subscribers, finishing operation\n10-17 09:14:20.758 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(79890976)\n10-17 09:14:20.761 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(235196745)\n10-17 09:14:20.768 26709-26709/com.test.bluetooth D/BluetoothManager: getConnectionState()\n10-17 09:14:20.770 26709-26709/com.test.bluetooth D/BluetoothManager: getConnectedDevices\n10-17 09:14:20.782 26709-26709/com.test.bluetooth D/BluetoothGatt: close()\n10-17 09:14:20.782 26709-26709/com.test.bluetooth D/BluetoothGatt: unregisterApp() - mClientIf=7\n10-17 09:14:20.782 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(235196745)\n10-17 09:14:25.763 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{CONNECTING}\n10-17 09:14:25.771 26709-27395/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(26606938)\n10-17 09:14:25.773 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(26606938)\n10-17 09:14:25.780 26709-26709/com.test.bluetooth V/RxBle#BleConnectionCompat: Connecting without reflection\n10-17 09:14:25.783 26709-26709/com.test.bluetooth D/BluetoothGatt: connect() - device: D8:7A:09:F1:66:8E, auto: false\n10-17 09:14:25.783 26709-26709/com.test.bluetooth D/BluetoothGatt: registerApp()\n10-17 09:14:25.783 26709-26709/com.test.bluetooth D/BluetoothGatt: registerApp() - UUID=7806f3d8-d304-440e-ad1a-ebd3e5eaf70e\n10-17 09:14:25.787 26709-26722/com.test.bluetooth D/BluetoothGatt: onClientRegistered() - status=0 clientIf=8\n10-17 09:14:28.045 26709-26721/com.test.bluetooth D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=8 device=D8:7A:09:F1:66:8E\n10-17 09:14:28.048 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n10-17 09:14:28.062 26709-27498/com.test.bluetooth D/DeviceManager: onConnectionSuccess: Successfully connected! Reading initial values and subscribing to updates!\n10-17 09:14:28.062 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{CONNECTED}\n10-17 09:14:28.079 26709-27505/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(202528343)\n10-17 09:14:28.079 26709-27498/com.test.bluetooth D/RxBle#RadioOperationConnect: No subscribers, finishing operation\n10-17 09:14:28.081 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(26606938)\n10-17 09:14:28.082 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(202528343)\n10-17 09:14:28.084 26709-26709/com.test.bluetooth D/BluetoothGatt: discoverServices() - device: D8:7A:09:F1:66:8E\n10-17 09:14:28.117 26709-26722/com.test.bluetooth D/BluetoothGatt: onSearchComplete() = Device=D8:7A:09:F1:66:8E Status=0\n10-17 09:14:28.118 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n10-17 09:14:28.130 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(216178149)\n10-17 09:14:28.133 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(78945131)\n10-17 09:14:28.135 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(119812961)\n10-17 09:14:28.137 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(234849095)\n10-17 09:14:28.139 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(126854301)\n10-17 09:14:28.141 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(203885795)\n10-17 09:14:28.143 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(189197721)\n10-17 09:14:28.145 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(196318271)\n10-17 09:14:28.146 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(93309525)\n10-17 09:14:28.148 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(257373531)\n10-17 09:14:28.149 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(240105169)\n10-17 09:14:28.151 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(147442743)\n10-17 09:14:28.152 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(206040845)\n10-17 09:14:28.153 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(56947923)\n10-17 09:14:28.155 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(118583049)\n10-17 09:14:28.156 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(202528343)\n10-17 09:14:28.157 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(216178149)\n10-17 09:14:28.474 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=11 Status=0\n10-17 09:14:28.475 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0013-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:28.479 26709-27395/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@b47453c | Byte: [0]\n10-17 09:14:28.480 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(216178149)\n10-17 09:14:28.481 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(78945131)\n10-17 09:14:28.654 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=14 Status=0\n10-17 09:14:28.656 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0014-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:28.660 26709-27499/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@8e17928 | Byte: [4]\n10-17 09:14:28.661 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(78945131)\n10-17 09:14:28.662 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(119812961)\n10-17 09:14:28.833 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=17 Status=0\n10-17 09:14:28.834 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0015-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:28.838 26709-27518/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@f9fb57d | Byte: [3]\n10-17 09:14:28.840 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(119812961)\n10-17 09:14:28.840 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(234849095)\n10-17 09:14:29.013 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=20 Status=0\n10-17 09:14:29.015 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0016-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.017 26709-27395/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@460fdbe | Byte: [0]\n10-17 09:14:29.018 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(234849095)\n10-17 09:14:29.019 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(126854301)\n10-17 09:14:29.104 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=23 Status=0\n10-17 09:14:29.105 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0017-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.107 26709-27499/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@ea27d3b | Byte: [1]\n10-17 09:14:29.109 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(126854301)\n10-17 09:14:29.110 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(203885795)\n10-17 09:14:29.193 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=26 Status=0\n10-17 09:14:29.195 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0018-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.197 26709-27518/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@8b60604 | Byte: [0]\n10-17 09:14:29.199 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(203885795)\n10-17 09:14:29.200 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(189197721)\n10-17 09:14:29.283 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=29 Status=0\n10-17 09:14:29.284 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0019-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.287 26709-27395/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@38f7e70 | Byte: [0, 2, 6, 0, 0]\n10-17 09:14:29.288 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(189197721)\n10-17 09:14:29.289 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(196318271)\n10-17 09:14:29.373 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=32 Status=0\n10-17 09:14:29.374 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001a-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.376 26709-27499/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@946119c | Byte: [0, 0, 3, 0]\n10-17 09:14:29.377 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(196318271)\n10-17 09:14:29.378 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(93309525)\n10-17 09:14:29.463 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=35 Status=0\n10-17 09:14:29.464 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001b-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.466 26709-27518/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@870ab88 | Byte: [-40, 122, 9, -15, 102, -114]\n10-17 09:14:29.468 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(93309525)\n10-17 09:14:29.468 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(257373531)\n10-17 09:14:29.553 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=38 Status=0\n10-17 09:14:29.554 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001c-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.556 26709-27395/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@28f834 | Byte: [0, 0, 0, 30]\n10-17 09:14:29.557 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(257373531)\n10-17 09:14:29.558 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(240105169)\n10-17 09:14:29.644 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=41 Status=0\n10-17 09:14:29.645 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001d-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.647 26709-27499/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@1f05b59 | Byte: [0, 0, 0, 47]\n10-17 09:14:29.648 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(240105169)\n10-17 09:14:29.649 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(147442743)\n10-17 09:14:29.733 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=44 Status=0\n10-17 09:14:29.734 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001e-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.737 26709-27518/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@6c25415 | Byte: [0, 0, 0, 25]\n10-17 09:14:29.738 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(147442743)\n10-17 09:14:29.739 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(206040845)\n10-17 09:14:29.823 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=47 Status=0\n10-17 09:14:29.824 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001f-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.826 26709-27395/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@f811c91 | Byte: [0, 0, 0, 0]\n10-17 09:14:29.828 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(206040845)\n10-17 09:14:29.829 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(56947923)\n10-17 09:14:29.913 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=50 Status=0\n10-17 09:14:29.914 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0020-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:29.916 26709-27499/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@489f0cd | Byte: [0, 0, 0, 4]\n10-17 09:14:29.918 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(56947923)\n10-17 09:14:29.918 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(118583049)\n10-17 09:14:30.003 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=53 Status=0\n10-17 09:14:30.004 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0021-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:30.006 26709-27518/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@cd1ccc9 | Byte: [0, 0, 0, 1]\n10-17 09:14:30.008 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(118583049)\n10-17 09:14:30.009 26709-27520/com.test.bluetooth D/BleDeviceManager: Device has been connected!\n10-17 09:14:30.009 26709-27520/com.test.bluetooth D/BleDeviceManager: Device is ready!\n10-17 09:14:30.014 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0013-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.018 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(72080038)\n10-17 09:14:30.019 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(72080038)\n10-17 09:14:30.019 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0014-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.023 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(40532537)\n10-17 09:14:30.026 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0015-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.031 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(71483018)\n10-17 09:14:30.033 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0016-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.037 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(166907351)\n10-17 09:14:30.038 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0017-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.042 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(127998768)\n10-17 09:14:30.044 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0018-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.047 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(132354405)\n10-17 09:14:30.049 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0019-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.052 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(122528774)\n10-17 09:14:30.053 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001a-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.058 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(185752675)\n10-17 09:14:30.059 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001b-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.064 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(105476748)\n10-17 09:14:30.065 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001c-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.072 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(57557585)\n10-17 09:14:30.074 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001d-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.078 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(25701442)\n10-17 09:14:30.080 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001e-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.083 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(51491503)\n10-17 09:14:30.085 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001f-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.088 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(137519784)\n10-17 09:14:30.090 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0020-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.094 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.094 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(18045181)\n10-17 09:14:30.096 26709-27520/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0021-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:30.099 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(72080038)\n10-17 09:14:30.100 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(40532537)\n10-17 09:14:30.101 26709-27520/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(161416522)\n10-17 09:14:30.184 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.188 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(40532537)\n10-17 09:14:30.189 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(71483018)\n10-17 09:14:30.274 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.278 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(71483018)\n10-17 09:14:30.278 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(166907351)\n10-17 09:14:30.410 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.417 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(166907351)\n10-17 09:14:30.418 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(127998768)\n10-17 09:14:30.499 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.503 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(127998768)\n10-17 09:14:30.504 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(132354405)\n10-17 09:14:30.589 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.593 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(132354405)\n10-17 09:14:30.593 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(122528774)\n10-17 09:14:30.679 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.683 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(122528774)\n10-17 09:14:30.683 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(185752675)\n10-17 09:14:30.769 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.773 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(185752675)\n10-17 09:14:30.774 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(105476748)\n10-17 09:14:30.861 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.868 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(105476748)\n10-17 09:14:30.868 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(57557585)\n10-17 09:14:30.949 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:30.953 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(57557585)\n10-17 09:14:30.953 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(25701442)\n10-17 09:14:31.039 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:31.043 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(25701442)\n10-17 09:14:31.044 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(51491503)\n10-17 09:14:31.129 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:31.134 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(51491503)\n10-17 09:14:31.136 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(137519784)\n10-17 09:14:31.219 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:31.224 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(137519784)\n10-17 09:14:31.225 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(18045181)\n10-17 09:14:31.309 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:31.313 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(18045181)\n10-17 09:14:31.314 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(161416522)\n10-17 09:14:31.400 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:31.405 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(161416522)\n10-17 09:14:39.829 26709-26721/com.test.bluetooth D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=8 device=D8:7A:09:F1:66:8E\n10-17 09:14:39.829 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n10-17 09:14:39.832 26709-27395/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(199113332)\n10-17 09:14:39.833 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{DISCONNECTED}\n10-17 09:14:39.835 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(199113332)\n10-17 09:14:39.835 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0015-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.839 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(146058211)\n10-17 09:14:39.840 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001a-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.843 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(16983193)\n10-17 09:14:39.844 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001b-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.855 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(217850687)\n10-17 09:14:39.857 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001f-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.859 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(5796181)\n10-17 09:14:39.860 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0013-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.865 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(236565595)\n10-17 09:14:39.865 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0019-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.867 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(175885777)\n10-17 09:14:39.868 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001c-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.870 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(179649335)\n10-17 09:14:39.871 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0020-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.873 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(77493773)\n10-17 09:14:39.874 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0016-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.876 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(169366483)\n10-17 09:14:39.876 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0017-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.878 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(197748233)\n10-17 09:14:39.879 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001d-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.881 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(76175919)\n10-17 09:14:39.882 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001e-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.883 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(177822149)\n10-17 09:14:39.884 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0014-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.886 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(90991179)\n10-17 09:14:39.886 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0018-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.888 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(247123265)\n10-17 09:14:39.889 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0021-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:39.892 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(51732519)\n10-17 09:14:39.892 26709-26709/com.test.bluetooth D/BleDeviceManager: Device has been disconnected!\n10-17 09:14:39.893 26709-26709/com.test.bluetooth D/BluetoothManager: getConnectionState()\n10-17 09:14:39.893 26709-26709/com.test.bluetooth D/BluetoothManager: getConnectedDevices\n10-17 09:14:39.895 26709-26709/com.test.bluetooth D/BluetoothGatt: close()\n10-17 09:14:39.895 26709-26709/com.test.bluetooth D/BluetoothGatt: unregisterApp() - mClientIf=8\n10-17 09:14:39.895 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(199113332)\n10-17 09:14:39.896 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(146058211)\n10-17 09:14:39.897 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(146058211)\n10-17 09:14:39.899 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(16983193)\n10-17 09:14:39.901 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(16983193)\n10-17 09:14:39.902 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(217850687)\n10-17 09:14:39.907 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(217850687)\n10-17 09:14:39.908 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(5796181)\n10-17 09:14:39.910 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(5796181)\n10-17 09:14:39.911 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(236565595)\n10-17 09:14:39.914 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(236565595)\n10-17 09:14:39.914 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(175885777)\n10-17 09:14:39.916 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(175885777)\n10-17 09:14:39.916 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(179649335)\n10-17 09:14:39.917 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(179649335)\n10-17 09:14:39.917 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(77493773)\n10-17 09:14:39.918 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(77493773)\n10-17 09:14:39.919 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(169366483)\n10-17 09:14:39.921 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(169366483)\n10-17 09:14:39.921 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(197748233)\n10-17 09:14:39.922 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(197748233)\n10-17 09:14:39.922 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(76175919)\n10-17 09:14:39.923 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(76175919)\n10-17 09:14:39.924 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(177822149)\n10-17 09:14:39.925 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(177822149)\n10-17 09:14:39.926 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(90991179)\n10-17 09:14:39.927 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(90991179)\n10-17 09:14:39.928 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(247123265)\n10-17 09:14:39.929 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(247123265)\n10-17 09:14:39.930 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(51732519)\n10-17 09:14:39.931 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(51732519)\n10-17 09:14:44.836 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{CONNECTING}\n10-17 09:14:44.840 26709-27395/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(51215156)\n10-17 09:14:44.841 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(51215156)\n10-17 09:14:44.843 26709-26709/com.test.bluetooth V/RxBle#BleConnectionCompat: Connecting without reflection\n10-17 09:14:44.844 26709-26709/com.test.bluetooth D/BluetoothGatt: connect() - device: D8:7A:09:F1:66:8E, auto: false\n10-17 09:14:44.844 26709-26709/com.test.bluetooth D/BluetoothGatt: registerApp()\n10-17 09:14:44.844 26709-26709/com.test.bluetooth D/BluetoothGatt: registerApp() - UUID=79ebce34-d22a-4246-8cd2-dc24fcd0a0f6\n10-17 09:14:44.847 26709-26721/com.test.bluetooth D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n10-17 09:14:45.049 26709-26722/com.test.bluetooth D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=D8:7A:09:F1:66:8E\n10-17 09:14:45.050 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n10-17 09:14:45.054 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{CONNECTED}\n10-17 09:14:45.054 26709-27499/com.test.bluetooth D/DeviceManager: onConnectionSuccess: Successfully connected! Reading initial values and subscribing to updates!\n10-17 09:14:45.059 26709-27518/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(152348802)\n10-17 09:14:45.061 26709-27499/com.test.bluetooth D/RxBle#RadioOperationConnect: No subscribers, finishing operation\n10-17 09:14:45.062 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(51215156)\n10-17 09:14:45.063 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(152348802)\n10-17 09:14:45.064 26709-26709/com.test.bluetooth D/BluetoothGatt: discoverServices() - device: D8:7A:09:F1:66:8E\n10-17 09:14:46.128 26709-26721/com.test.bluetooth D/BluetoothGatt: onSearchComplete() = Device=D8:7A:09:F1:66:8E Status=0\n10-17 09:14:46.130 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n10-17 09:14:46.138 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(231392730)\n10-17 09:14:46.141 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(251683048)\n10-17 09:14:46.143 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(136275366)\n10-17 09:14:46.146 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(183411604)\n10-17 09:14:46.149 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(164378162)\n10-17 09:14:46.152 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(14443776)\n10-17 09:14:46.154 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(218334078)\n10-17 09:14:46.156 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(153276716)\n10-17 09:14:46.158 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(181426570)\n10-17 09:14:46.160 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(109171736)\n10-17 09:14:46.162 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(266503254)\n10-17 09:14:46.164 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(97262020)\n10-17 09:14:46.166 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(35295202)\n10-17 09:14:46.169 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(206769712)\n10-17 09:14:46.170 26709-27519/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(47564846)\n10-17 09:14:46.171 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(152348802)\n10-17 09:14:46.172 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(231392730)\n10-17 09:14:46.252 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=11 Status=0\n10-17 09:14:46.254 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0013-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.256 26709-27498/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@5a27865 | Byte: [0]\n10-17 09:14:46.257 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(231392730)\n10-17 09:14:46.257 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(251683048)\n10-17 09:14:46.343 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=14 Status=0\n10-17 09:14:46.344 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0014-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.347 26709-27505/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@84735e1 | Byte: [4]\n10-17 09:14:46.349 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(251683048)\n10-17 09:14:46.350 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(136275366)\n10-17 09:14:46.432 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=17 Status=0\n10-17 09:14:46.433 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0015-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.435 26709-27519/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@8204f1d | Byte: [3]\n10-17 09:14:46.438 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(136275366)\n10-17 09:14:46.439 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(183411604)\n10-17 09:14:46.522 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=20 Status=0\n10-17 09:14:46.523 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0016-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.524 26709-27498/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@877c019 | Byte: [0]\n10-17 09:14:46.525 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(183411604)\n10-17 09:14:46.525 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(164378162)\n10-17 09:14:46.612 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=23 Status=0\n10-17 09:14:46.613 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0017-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.615 26709-27505/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@d3b44d5 | Byte: [1]\n10-17 09:14:46.617 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(164378162)\n10-17 09:14:46.618 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(14443776)\n10-17 09:14:46.702 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=26 Status=0\n10-17 09:14:46.704 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0018-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.706 26709-26714/com.test.bluetooth I/art: Do partial code cache collection, code=30KB, data=29KB\n10-17 09:14:46.706 26709-27519/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@1785951 | Byte: [0]\n10-17 09:14:46.707 26709-26714/com.test.bluetooth I/art: After code cache collection, code=24KB, data=25KB\n10-17 09:14:46.707 26709-26714/com.test.bluetooth I/art: Increasing code cache capacity to 128KB\n10-17 09:14:46.709 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(14443776)\n10-17 09:14:46.709 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(218334078)\n10-17 09:14:46.792 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=29 Status=0\n10-17 09:14:46.793 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0019-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.796 26709-27498/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@998398d | Byte: [0, 2, 6, 0, 0]\n10-17 09:14:46.797 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(218334078)\n10-17 09:14:46.798 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(153276716)\n10-17 09:14:46.883 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=32 Status=0\n10-17 09:14:46.884 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001a-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.887 26709-27505/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@d5be189 | Byte: [0, 0, 3, 0]\n10-17 09:14:46.889 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(153276716)\n10-17 09:14:46.889 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(181426570)\n10-17 09:14:46.972 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=35 Status=0\n10-17 09:14:46.974 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001b-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:46.975 26709-27519/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@5980d45 | Byte: [-40, 122, 9, -15, 102, -114]\n10-17 09:14:46.977 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(181426570)\n10-17 09:14:46.977 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(109171736)\n10-17 09:14:47.062 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=38 Status=0\n10-17 09:14:47.063 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001c-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:47.064 26709-27498/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@6062866 | Byte: [0, 0, 0, 30]\n10-17 09:14:47.065 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(109171736)\n10-17 09:14:47.065 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(266503254)\n10-17 09:14:47.152 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=41 Status=0\n10-17 09:14:47.153 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001d-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:47.155 26709-27505/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@2a4e743 | Byte: [0, 0, 0, 47]\n10-17 09:14:47.157 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(266503254)\n10-17 09:14:47.158 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(97262020)\n10-17 09:14:47.242 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=44 Status=0\n10-17 09:14:47.243 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001e-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:47.245 26709-27519/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@22389ec | Byte: [0, 0, 0, 25]\n10-17 09:14:47.246 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(97262020)\n10-17 09:14:47.247 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(35295202)\n10-17 09:14:47.332 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=47 Status=0\n10-17 09:14:47.333 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a001f-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:47.335 26709-27498/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@58d431 | Byte: [0, 0, 0, 0]\n10-17 09:14:47.335 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(35295202)\n10-17 09:14:47.336 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(206769712)\n10-17 09:14:47.422 26709-26722/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=50 Status=0\n10-17 09:14:47.423 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0020-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:47.425 26709-27505/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@c53eea2 | Byte: [0, 0, 0, 4]\n10-17 09:14:47.426 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(206769712)\n10-17 09:14:47.427 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(47564846)\n10-17 09:14:47.512 26709-26721/com.test.bluetooth W/BluetoothGatt: onCharacteristicRead() - Device=D8:7A:09:F1:66:8E handle=53 Status=0\n10-17 09:14:47.513 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=6e4a0021-a5a3-f393-e0a9-e50e24dcaa9a status=0\n10-17 09:14:47.515 26709-27519/com.test.bluetooth D/DeviceManager: ReadInitialValue - Characteristic: android.bluetooth.BluetoothGattCharacteristic@2aa038f | Byte: [0, 0, 0, 1]\n10-17 09:14:47.515 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(47564846)\n10-17 09:14:47.516 26709-28030/com.test.bluetooth D/BleDeviceManager: Device has been connected!\n10-17 09:14:47.516 26709-28030/com.test.bluetooth D/BleDeviceManager: Device is ready!\n10-17 09:14:47.519 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0013-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.524 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(26531207)\n10-17 09:14:47.525 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(26531207)\n10-17 09:14:47.526 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0014-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.531 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(163795870)\n10-17 09:14:47.532 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0015-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.535 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(18346907)\n10-17 09:14:47.537 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0016-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.541 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(173947620)\n10-17 09:14:47.542 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0017-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.545 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(202555209)\n10-17 09:14:47.547 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0018-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.551 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(64467802)\n10-17 09:14:47.552 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0019-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.555 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(203137895)\n10-17 09:14:47.557 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001a-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.560 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(117210752)\n10-17 09:14:47.564 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001b-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.568 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(166247285)\n10-17 09:14:47.569 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001c-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.573 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(174926294)\n10-17 09:14:47.574 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001d-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.577 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(252165875)\n10-17 09:14:47.578 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001e-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.581 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(134901468)\n10-17 09:14:47.582 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001f-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.585 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(61923681)\n10-17 09:14:47.587 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0020-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.591 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(120886034)\n10-17 09:14:47.592 26709-28030/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0021-a5a3-f393-e0a9-e50e24dcaa9a enable: true\n10-17 09:14:47.595 26709-28030/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(48280127)\n10-17 09:14:47.602 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:47.606 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(26531207)\n10-17 09:14:47.607 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(163795870)\n10-17 09:14:47.693 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:47.696 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(163795870)\n10-17 09:14:47.697 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(18346907)\n10-17 09:14:47.782 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:47.786 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(18346907)\n10-17 09:14:47.786 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(173947620)\n10-17 09:14:47.872 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:47.875 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(173947620)\n10-17 09:14:47.876 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(202555209)\n10-17 09:14:47.963 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:47.967 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(202555209)\n10-17 09:14:47.969 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(64467802)\n10-17 09:14:48.053 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.056 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(64467802)\n10-17 09:14:48.057 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(203137895)\n10-17 09:14:48.143 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.146 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(203137895)\n10-17 09:14:48.146 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(117210752)\n10-17 09:14:48.234 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.237 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(117210752)\n10-17 09:14:48.238 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(166247285)\n10-17 09:14:48.323 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.328 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(166247285)\n10-17 09:14:48.329 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(174926294)\n10-17 09:14:48.413 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.417 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(174926294)\n10-17 09:14:48.418 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(252165875)\n10-17 09:14:48.503 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.509 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(252165875)\n10-17 09:14:48.510 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(134901468)\n10-17 09:14:48.593 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.596 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(134901468)\n10-17 09:14:48.597 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(61923681)\n10-17 09:14:48.685 26709-26722/com.test.bluetooth D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n10-17 09:14:48.689 26709-26736/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(61923681)\n10-17 09:14:48.690 26709-26736/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(120886034)\n10-17 09:14:48.777 26709-26721/com.test.bluetooth D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=D8:7A:09:F1:66:8E\n10-17 09:14:48.777 26709-26721/com.test.bluetooth D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n10-17 09:14:48.781 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{DISCONNECTED}\n10-17 09:14:48.781 26709-27505/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(147496175)\n10-17 09:14:48.781 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001b-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.785 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(171417818)\n10-17 09:14:48.785 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001f-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.788 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(157561832)\n10-17 09:14:48.788 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0013-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.790 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(234811558)\n10-17 09:14:48.792 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001c-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.797 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(54306452)\n10-17 09:14:48.798 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0017-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.801 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(93942066)\n10-17 09:14:48.802 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0014-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.804 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(59217920)\n10-17 09:14:48.805 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0021-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.807 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(132738686)\n10-17 09:14:48.808 26709-26709/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationDescriptorWrite(48280127)\n10-17 09:14:48.808 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0016-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.817 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(114177068)\n10-17 09:14:48.820 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001e-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.822 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(95024266)\n10-17 09:14:48.822 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0020-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.824 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(117466904)\n10-17 09:14:48.824 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001d-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.826 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(238735190)\n10-17 09:14:48.826 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0019-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.828 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(186703044)\n10-17 09:14:48.828 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a001a-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.830 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(86805218)\n10-17 09:14:48.831 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0015-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.832 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(95486256)\n10-17 09:14:48.833 26709-26709/com.test.bluetooth D/BluetoothGatt: setCharacteristicNotification() - uuid: 6e4a0018-a5a3-f393-e0a9-e50e24dcaa9a enable: false\n10-17 09:14:48.834 26709-26709/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(76313390)\n10-17 09:14:48.835 26709-26709/com.test.bluetooth D/BleDeviceManager: Device has been disconnected!\n10-17 09:14:53.783 26709-26709/com.test.bluetooth D/DeviceManager: Connection state changed: RxBleConnectionState{CONNECTING}\n10-17 09:14:53.787 26709-27395/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(6119269)\nThis is the current state of the RxBleRadio queue (entries in the queue ranging from 2 to 15 are descriptor writes):\n\nIs there a way to clear the queue? Or maybe to add a timeout to the operations?\nThanks\n. Hi @dariuszseweryn thanks for your comment!\nIs there any possibility that we can have a \"hacky\" solution meanwhile? Even if is not the most elegant one?\n(I would like to help you to sort this out).\n. Bad luck:\n\n10-18 20:44:53.248 20817-20832/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(122289203)\n10-18 20:44:53.249 20817-20832/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(20002153)\n10-18 20:44:53.329 20817-20829/com.test.bluetooth D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=D8:7A:09:F1:66:8E\n10-18 20:44:53.330 20817-20829/com.test.bluetooth D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n10-18 20:44:53.333 20817-20817/com.test.bluetooth D/DeviceManager: Connection state changed: DISCONNECTED\n10-18 20:44:53.333 20817-20916/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(237186712)\n10-18 20:44:53.335 20817-20817/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicRead(43958053)\n10-18 20:44:53.335 20817-20832/com.test.bluetooth D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(20002153)\n10-18 20:44:53.335 20817-20832/com.test.bluetooth D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(90095275)\n10-18 20:44:53.337 20817-20817/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicRead(161360015)\n10-18 20:44:53.340 20817-20817/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicRead(84564003)\n10-18 20:44:53.342 20817-20817/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicRead(77670561)\n10-18 20:44:53.344 20817-20817/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicRead(71867015)\n10-18 20:44:53.345 20817-20817/com.test.bluetooth D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicRead(168209885)\n10-18 20:44:53.345 20817-20817/com.test.bluetooth D/BleDeviceManager: Device has been disconnected!\n10-18 20:44:58.336 20817-20817/com.test.bluetooth D/DeviceManager: Connection state changed: CONNECTING\n10-18 20:44:58.344 20817-20916/com.test.bluetooth D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(108345520)\n. With this change, it looks very promising! For now, it does the reconnection properly!!!\nI'll tell you if I detect something wrong, testing more :)\n. Thanks @dariuszseweryn for your great work! Worth mentioning how fast you solved this thing! :)\n. Can you share the new changes on the code? Or is already commited? I can test it on my device @dariuszseweryn Thanks!! :)\n. For now, working fine with my real device! \ud83d\udc4d \n. Hi @julien-fueled does this make sense to put this method here? I mean, when you \"unpair\" is for unboding a device. A device can be \"unbonded\" if the programmer has explicitly called \"bond\".\nThe problem itself is that bonding process is dependent on the device itself, for example when bonding with mine I didn't have to request any pin info while others BLE devices will ask you for a pin.\nMaybe for managing these use cases we can try to create an external helper class that will aid in the process of bonding/unbonding and leave this class only for connecting to the device.\nI have here a basic gist which implements this as a helper class (obviously it can be improved).\nWhat do you think @dariuszseweryn about this?\n. ",
    "cpboyd": "I would at least be interested to invert the exclusivity of the service UUID filter, so that I could find different devices with specific UUIDs that are contained in the list.\ne.g.:\n``` java\n    private boolean containsDesiredServiceIds(byte[] scanRecord) {\n        List advertisedUUIDs = uuidUtil.extractUUIDs(scanRecord);\n    for (UUID desiredUUID : filterServiceUUIDs) {\n\n        if (advertisedUUIDs.contains(desiredUUID)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n```\n. I've updated the code in the \"Preconditions\" section above.\nI tried writing to the specified descriptor and it seems to work there.\nThis is the output I get:\nBleDeviceActivity: Service 00001800-0000-1000-8000-00805f9b34fb\nBleDeviceActivity:   Characteristic 00002a00-0000-1000-8000-00805f9b34fb\nBleDeviceActivity:   Characteristic 00002a01-0000-1000-8000-00805f9b34fb\nBleDeviceActivity: Service 0000180a-0000-1000-8000-00805f9b34fb\nBleDeviceActivity:   Characteristic 00002a29-0000-1000-8000-00805f9b34fb\nBleDeviceActivity:   Characteristic 00002a24-0000-1000-8000-00805f9b34fb\nBleDeviceActivity:   Characteristic 00002a23-0000-1000-8000-00805f9b34fb\nBleDeviceActivity: Service e079c6a0-aa8b-11e3-a903-0002a5d5c51b\nBleDeviceActivity:   Characteristic b38312c0-aa89-11e3-9cef-0002a5d5c51b\nBleDeviceActivity:     Descriptor 00002902-0000-1000-8000-00805f9b34fb\nBluetoothGatt: setCharacteristicNotification() - uuid: b38312c0-aa89-11e3-9cef-0002a5d5c51b enable: true\nBleDeviceActivity: Test: true | true | true\nBleDeviceActivity: Status: 3\nAs you can see, the Toshiba SPP-over-LE characteristic appears to have the appropriate descriptor.\nAdditionally, I've been able to successfully subscribe to notifications in iOS as well and seem to be able to receive the notifications properly.\nEDIT: However, I am also getting the status 3 (GATT_WRITE_NOT_PERMITTED) from the onDescriptorWrite().\nI'm not really sure why it'd work on iOS, though, unless Apple does some sort of \"magic\" behind the scenes that makes it work anyway.\n. It turns out that the device allows indications, but not notifications.\niOS abstracts the distinction away from the developer, so that explains why I hadn't seen this there.\nThanks for the help!\n. setupIndications() does, in fact, get the correct status 0 (GATT_SUCCESS).\nThanks again!\n. @dariuszseweryn \nI can't believe I didn't think to just map back to the original connection.\nWith this method, is the best way to report/handle the MTU via doOnNext?\ne.g.:\njava\nreturn connection.requestMtu(BtHelpers.BLE_TI_MTU)\n    .doOnNext(i -> Log.d(TAG, \"Negotiated MTU: \" + i)).map(mtu -> connection);. @dariuszseweryn \nI've updated the code in the original post.\nconnectionObservable is an Observable<RxBleConnection> created by calling bleClient.getBleDevice(macAddress).establishConnection(context, true)\nI use inputSubject is simply a PublishSubject<byte[]> and I use it with the following function:\njava\npublic Observable<String> sendCmd(String data) {\n    Log.d(TAG, \"Writing data: \" + data);\n    inputSubject.onNext(data.getBytes());\n    return outputSubject.filter(s -> {\n        // Allow for potentially corrupted JSON response:\n        return s.startsWith(\"{\\\"CMD\\\":\\\"\" + data + '\"');\n    }).first();\n}\noutputSubject is a custom Subject that reassembles the individual packets into a full response.\nEdit:\nIf I reinitialize everything (including the RxBleClient) then everything seems to work fine after a bad disconnect.\nShould I not be reusing the same client for the life of the app?  Maybe it's breaking after Bluetooth is disabled and re-enabled?\nDevice: Nexus 6P\nAndroid 7.0\nAs I mentioned earlier, it seems to be able to write the \"test\" to the characteristic.  Just nothing sent using the sendCmd() and inputSubject. This was in a singleton that's passed the context but only initializes the RxBleClient once.\nUltimately, I found that I can re-initialize everything EXCEPT the RxBleClient and RxBleDevice and it seems to get rid of the error, so I don't think there's an issue with the library.. ",
    "bobroalexandr": "@uKL @dariuszseweryn I've created pull request for ble scan v21 support https://github.com/Polidea/RxAndroidBle/pull/74. Please check if that's helpful for your project\n. @uKL @dariuszseweryn any comments? should I continue? is it helpful for your project? \n. @dariuszseweryn thank you for response\nI want to do it the way you described. Just wanted to understand if that will be helpful for that library. \n. ",
    "leeyc09": "Who knows how to fix this bug ?\n. ",
    "lary-pipot": "Is mockrxandroidble available on gradle now?\n. ",
    "pfives": "@dariuszseweryn yes makes sense thank you. I have to dig into that a bit but seems pretty straightforward. Thanks for the help and the awesome lib!\n. Thanks for the quick response @uKL. Here's some code:\n```\nstatic final String DEVICE_MAC_ADDRESS = \"AA:BB:CC:DD:EE:FF\";\nstatic final UUID AD_UUID = UUID.fromString(\"cd336c84-0b2f-1136-b512-3e1d05defe78\");\nstatic final String DEVICE_NAME = \"test1236\";\nstatic final int RSSI = 42;\nRxBleDevice rxBleDevice = new RxBleClientMock.DeviceBuilder().deviceMacAddress(DEVICE_MAC_ADDRESS)\n                .deviceName(DEVICE_NAME).rssi(RSSI).scanRecord(getScanRecord()).addService(AD_UUID, Collections.emptyList()).build();\nRxBleClient rxBleClient = new RxBleClientMock.Builder().addDevice(rxBleDevice).build();\nTestSubscriber testSubscriber = new TestSubscriber<>();\n//test passes with this call\nrxBleClient.scanBleDevices().subscribe(testSubscriber);\n//THIS test will fail\n//rxBleClient.scanBleDevices(AD_UUID).subscribe(testSubscriber)\nList rxBleScanResults = testSubscriber.getOnNextEvents();\nAssert.assertTrue(rxBleScanResults.size() == 1);\n```\n. Shoot my bad. I just grabbed the files directly from the repo because I couldn't get them from the gradle script (eventually saw this issue https://github.com/Polidea/RxAndroidBle/issues/20). I am using these 3 files located here: https://github.com/Polidea/RxAndroidBle/tree/master/mockrxandroidble/src/main/java/com/polidea/rxandroidble/mockrxandroidble\nIs there maybe a newer branch than master with mock class updates on it?\n. It was a method that returned a specific byte[] that mimicked an actual scan record from a device. I replaced it with \"some scan record bytes\".getBytes() and still have the same issue. Passes with no UUID specified but fails when using one. When you ran the above it passed in both situations (using the commented out line)?\nI noticed there were some updates on the mock-indications branch that are newer than master, could those be helpful?\n. ",
    "tatewaki": "This would be nice :+1: \nmy Workaround is reflection:\n\ntry {\n    Field field = device.getClass().getDeclaredField(\"bluetoothDevice\");\n    field.setAccessible(true);\n    BluetoothDevice nativeDevice = (BluetoothDevice) field.get(device);\n} catch (Exception e) {\n     e.printStackTrace();\n}\n\n. The problem is: Bonding for BLE on Android is pain in the ass.\nEach producer (like htc, Samsung or Xiaomi) has implement this procedure on a different way. \nSome devices you can bond, others will bond automatically if you access an encrypted characteristic. If they will bond automatically, on some devices it works in background without you have to do something. Other devices throws an error (like status 137) and you have to repeat it. \nAnd I thought Bluetooth is a standard :-D.\nThanks for the good work so far. \n. I know that bonding and connection is not the same. And because of that, I reported the issue. \nRxAndroidBle will disconnect on an error relating to bonding. But there is no need to disconnect.\n. ",
    "Ibrahimhassan1": "The device that I connect is a BlendMicro (http://redbearlab.com/blendmicro/).\nBefore I try RxAndroidBle I used to enable notifications using the following snippet and it didn't have any affect on the connection; so i doubt that the problem is with the Ble device:\n// enable notifications\n                BluetoothGattCharacteristic characteristicRX = gatt.getService(Constants.UUID_BLE_SHIELD_SERVICE).getCharacteristic(Constants.UUID_BLE_SHIELD_RX);\n                setCharacteristicNotification(gatt, characteristicRX, true);\n/\n     * Enables or disables notification on a give characteristic.\n     \n     * @param characteristic Characteristic to act on.\n     * @param enabled        If true, enable notification. False otherwise.\n     /\n    public void setCharacteristicNotification(BluetoothGatt gatt,\n                                              BluetoothGattCharacteristic characteristic, boolean enabled) {\n        if (gatt == null) {\n            Log.w(LOG_TAG, \"BluetoothAdapter not initialized\");\n            return;\n        }\n```\n    if (characteristic != null) {\n    final int charaProp = characteristic.getProperties();\n    if ((charaProp | BluetoothGattCharacteristic.PROPERTY_READ) > 0) {\n        // If there is an active notification on a characteristic, clear\n        // it first so it doesn't update the data field on the user interface.\n        if (gatt.equals(mGatt)) {\n            if (mNotifyCharacteristic != null) {\n                gatt.setCharacteristicNotification(\n                        mNotifyCharacteristic, false);\n                mNotifyCharacteristic = null;\n            }\n        }\n        gatt.readCharacteristic(characteristic);\n    }\n    if ((charaProp | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {\n        if (gatt.equals(mGatt)) {\n            mNotifyCharacteristic = characteristic;\n        }\n        gatt.setCharacteristicNotification(characteristic, enabled);\n        if (Constants.UUID_BLE_SHIELD_RX.equals(characteristic.getUuid())) {\n            BluetoothGattDescriptor descriptor = characteristic\n                    .getDescriptor(UUID\n                            .fromString(Constants.CLIENT_CHARACTERISTIC_CONFIG));\n            descriptor\n                    .setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n            gatt.writeDescriptor(descriptor);\n        }\n    }\n}\n\n}\n```\nIs there a way to apply that snippet using the RxLibray?\nAs you mentioned Status 8 is a timeout error, what is the scenario that should happen after enabling the notifications?  does the remote device need to send something back to the app?\nWhat configuration are you suggesting to check?\n. ",
    "Reyurnible": "i sure\n1. yes. i communicate notificating device rate 90ms.\n2. Nexus6 and Sony SO-04F\n3. reproducing sample program when setup notification and leave few minute.\nconnectionObservable\n                    .flatMap(rxBleConnection -> rxBleConnection.setupNotification(characteristicUuid))\n                    .doOnNext(notificationObservable -> runOnUiThread(this::notificationHasBeenSetUp))\n                    .flatMap(notificationObservable -> notificationObservable)\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(this::onNotificationReceived, this::onNotificationSetupFailure);\n. ",
    "Stjerndal": "I'm getting the same problem. This is how i setup notifications.\ngetConnectionObservable()\n    .flatMap(rxBleConnection -> rxBleConnection.setupNotification(UUID_DATA_CHARA))\n    //.doOnNext(notificationObservable -> getRxAppCompatActivity().runOnUiThread(this::notificationHasBeenSetUp))\n    .doOnNext(notificationObservable -> notificationHasBeenSetUp())\n    .flatMap(notificationObservable -> notificationObservable)\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(this::onNotificationReceived, this::onNotificationSetupFailure);\nMy app has a set of devices and every 30 seconds, it connects to them, writes to a characteristic and subscribes to notifications. When a notification is received shortly after, the app disconnects from the device and waits another 30 seconds.\nThis can go on for several minutes, but sooner or later i get the RejectedExecutionException.\nFATAL EXCEPTION: RxNewThreadScheduler-143\nProcess: m.application, PID: 12147\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:154)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n    at java.lang.Thread.run(Thread.java:818)\nCaused by: java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@384aea9 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@246b230[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]\n    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2014)\n    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:794)\n    at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:302)\n    at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:527)\n    at java.util.concurrent.ScheduledThreadPoolExecutor.submit(ScheduledThreadPoolExecutor.java:626)\n    at rx.internal.schedulers.NewThreadWorker.scheduleActual(NewThreadWorker.java:239)\n    at rx.internal.schedulers.NewThreadWorker.schedule(NewThreadWorker.java:224)\n    at rx.internal.schedulers.NewThreadWorker.schedule(NewThreadWorker.java:216)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:82)\n    at rx.Subscriber.request(Subscriber.java:157)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:225)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\u00a0\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\u00a0\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:154)\u00a0\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)\u00a0\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\u00a0\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\u00a0\n    at java.lang.Thread.run(Thread.java:818)\u00a0`\nAre you suggesting that I should try disconnecting straight after setting up notifications, and not executing anything else after the setup (this::notificationHasBeenSetUp, onNotificationReceived, onNotificationSetupFailure?\n. Maven, but could potentially try to use the source with that change within the next few days.\n. Awesome, I will check it out!\n. Results are promising! The error has not occurred yet, and I've had the application running for a couple of hours as of now. This was however sometimes possible before the fix, where the app would occasionally be able to run an hour or two before crashing.\nI will keep it running during the day and report back.\n. The issue seems to be resolved. I've been able to have it running for many hours without it occurring. Thanks, really appreciate it!\nI did however run into another problem. The app did not crash or throw exceptions after that many hours, but suddenly it was just unable to connect to the BLE devices at all, instantly giving the GATT status 133 when attempting. I tried to connect to the same BLE devices with another Android device, and was successful. Only after a reboot of the first Android device, it could connect to the BLE devices again. A restart of the bluetooth adapter did not suffice.\nI have not have the time to investigate this new issue properly, it might not even be RxAndroidBle that causes it. I just thought I'd mention it in case you have heard of something like this before. I will come back and maybe create a new Issue once I've studied the problem a bit more.\nPS.\nRunning Android 6.0.1. \n. Some code for connecting etc.\n```\nprotected void prepareConnection(ConnectionSharingAdapter connectionSharingAdapter,\n                                     GattStatusListener gattStatusListener,\n                                     FinishedListener finishedListener) {\n        this.mListener = gattStatusListener;\n        this.mFinishedListener = finishedListener;\n        mConnectionObservable = mBleDevice\n                .establishConnection(mRxAppCompatActivity, false)\n                .takeUntil(disconnectTriggerSubject)\n                .compose(mRxAppCompatActivity.bindUntilEvent(PAUSE))\n                .doOnUnsubscribe(this::clearSubscription)\n                .compose(connectionSharingAdapter);\n    mConnectionStateSubscription = mBleDevice.observeConnectionStateChanges()\n            .subscribe(this::onConnectionChange);\n\n}\npublic void connect() {\n    if(mConnectionObservable == null) {\n        return;\n    }\n    mConnectionSubscription = mConnectionObservable.subscribe(rxBleConnection -> {\n                onConnected();\n            }, this::onConnectionFailure);\n            refreshDelayedDisconnect(DEFAULT_CONNECT_TIMEOUT);\n}\npublic void triggerDisconnect() {\n        disconnectTriggerSubject.onNext(null);\n}\nprivate Runnable disconnectRunnable = () -> {\n        LocalDebug.logE(getDeviceAddress() + \": Timeout operation! Disconnecting!\");\n        updateStatusListener(\"Operation timed out.\");\n        triggerDisconnect();\n    };\npublic void refreshDelayedDisconnect(int delay) {\n    LocalDebug.logE(getDeviceAddress() + \": Refreshing delayed disconnect\");\n    if(mExecutor == null|| mExecutor.isShutdown())\n        return;\n    clearPendingDisconnects();\n    pendingTimeouts.add(mExecutor.schedule(disconnectRunnable, delay, TimeUnit.MILLISECONDS));\n}\n```\n. Yes, I'll set it up.\n. The problem had not occurred since my last post, but interestingly enough this new update causes it (or something with similar symptoms)  to happen regularly after ~15 minutes of action (always after 26 successful connects or 52 characteristic writes etc).\nHere is a log excerpt: http://pasted.co/6064d801\nIn the program, basically, every couple of minutes ble device interactions occur. (1. ReadChara, 2. WriteChara, 3. ReadChara and depending on this value WriteChara, 4.  WriteChara and wait for notifications 5. When a certain indication is received, disconnect).\nAt about 15:08:45 in the log, things start to not work. (\"No subscribers, finishing operation\").\nBefore mentioned the commit, the exact same code worked fine (at least for several days).\n. ",
    "asmirsabanovic": "I have the same issue, is there any work around for now without needing to reconnect after bonding is successful? . @dariuszseweryn thanks for the fast response, but I don't follow completely. Here is how I do it now: \n//Read uuid that needs bonding\nRxBleConnection.readCharacteristic(AUTH_REQ_UUID)...subscribe(..);\nUser enters correct PIN -> Bonding Successful\nI get: BleGattException{status=137, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\nAnd this disconnects the connection. I do a reconnect and this time the read will work. \nHow can I do this with your suggestion to avoid the disconnect after bonding is successful? \nThanks again. \n. If I don't pass the status through statusErrorSubject the connection stays alive after a successful bond. \nYes, the onCharacteristicRead is postponed after the user enters pin or the pin entry is cancelled. I'm currently testing on Samsung S7 Edge and Sony Xperia Z4 . ",
    "ardmn": "It is topical issue for me too. With Every connecting to ble device i need send \"start\" commnad and after that i can send next commands. In my case the ble device store some data for 7 days . To obtain the all data for one day I need send 3 commands. Therefore to get the data in the last 7 days, need to send a list of 21 (+ start command). Please can you give advice how solve this problem ? May be you know nice solution for commands queue that can easily integrated with rxAndroidBle lib? Thanks.\n. Sorry, @uKL I will try it tomorrow :)\n. @misevcik Are You have solve your problem ?. Hello @dariuszseweryn. \nSometimes I get similar problem  . Can you explene how read, understend logs ? I try useing Wireshark but not understen what's what.(about reading btsnoop_hci.log). @dariuszseweryn Thank you! I will read it a little later :). Can I understend on what side problem with connection : android OS, my application, ble device ?\n(I use sgs7 with android v6)\nLog from application:\n```\n01-15 15:00:05.579 16648-16811/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:   QUEUED ConnectOperation(233924389)\n01-15 15:00:05.579 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:  STARTED ConnectOperation(233924389)\n01-15 15:00:05.599 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: connect() - device: 00:0B:57:1D:74:CB, auto: false\n01-15 15:00:05.599 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: registerApp()\n01-15 15:00:05.599 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: registerApp() - UUID=edf707ec-2e8b-40f8-9322-77ec81c860f5\n01-15 15:00:05.639 16648-16662/com.ayrlabs.ayr.qa D/BluetoothGatt: onClientRegistered() - status=0 clientIf=9\n01-15 15:00:10.679 16648-16662/com.ayrlabs.ayr.qa D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=9 device=00:0B:57:1D:74:CB\n01-15 15:00:10.689 16648-16662/com.ayrlabs.ayr.qa D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=133\n01-15 15:00:10.699 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(233924389)\n01-15 15:00:10.699 16648-16648/com.ayrlabs.ayr.qa W/System.err: com.polidea.rxandroidble.exceptions.BleDisconnectedException: Disconnected from 00:0B:57:1D:74:CB\n01-15 15:00:10.699 16648-16811/com.ayrlabs.ayr.qa I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (00:0B:57:1D:74:CB)\n01-15 15:00:10.699 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:76)\n01-15 15:00:10.699 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:228)\n01-15 15:00:10.699 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n01-15 15:00:10.699 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at android.os.Binder.execTransact(Binder.java:453)\n01-15 15:00:10.699 16648-16811/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:   QUEUED DisconnectOperation(59178154)\n01-15 15:00:10.699 16648-16810/com.ayrlabs.ayr.qa D/RxBle#Executors$RunnableAdapter: Terminated.\n01-15 15:00:10.699 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:  STARTED DisconnectOperation(59178154)\n01-15 15:00:10.709 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: close()\n01-15 15:00:10.709 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: unregisterApp() - mClientIf=9\n01-15 15:00:10.719 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(59178154)\n01-15 15:00:28.059 16648-16811/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:   QUEUED ConnectOperation(192550922)\n01-15 15:00:28.059 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:  STARTED ConnectOperation(192550922)\n01-15 15:00:28.059 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: connect() - device: 00:0B:57:1D:74:CB, auto: false\n01-15 15:00:28.059 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: registerApp()\n01-15 15:00:28.059 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: registerApp() - UUID=8a58ac78-25eb-4288-8320-9bb9a70c2f66\n01-15 15:00:28.109 16648-16662/com.ayrlabs.ayr.qa D/BluetoothGatt: onClientRegistered() - status=0 clientIf=9\n01-15 15:00:33.159 16648-16662/com.ayrlabs.ayr.qa D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=9 device=00:0B:57:1D:74:CB\n01-15 15:00:33.169 16648-16662/com.ayrlabs.ayr.qa D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=133\n01-15 15:00:33.169 16648-16648/com.ayrlabs.ayr.qa W/System.err: com.polidea.rxandroidble.exceptions.BleDisconnectedException: Disconnected from 00:0B:57:1D:74:CB\n01-15 15:00:33.169 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:76)\n01-15 15:00:33.169 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:228)\n01-15 15:00:33.169 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n01-15 15:00:33.169 16648-16648/com.ayrlabs.ayr.qa W/System.err:     at android.os.Binder.execTransact(Binder.java:453)\n01-15 15:00:33.169 16648-16662/com.ayrlabs.ayr.qa I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (00:0B:57:1D:74:CB)\n01-15 15:00:33.169 16648-16811/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:   QUEUED DisconnectOperation(49734735)\n01-15 15:00:33.169 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(192550922)\n01-15 15:00:33.169 16648-16810/com.ayrlabs.ayr.qa D/RxBle#Executors$RunnableAdapter: Terminated.\n01-15 15:00:33.169 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue:  STARTED DisconnectOperation(49734735)\n01-15 15:00:33.179 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: close()\n01-15 15:00:33.179 16648-16812/com.ayrlabs.ayr.qa D/BluetoothGatt: unregisterApp() - mClientIf=9\n01-15 15:00:33.189 16648-16666/com.ayrlabs.ayr.qa D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(49734735)\n```\nImage from Wireshark:\n\nbtsnoop_hci.zip - log file\nI see that from log in Wireshark that ble device create connection with android but in logs from application I see 'onConnectionStateChange newState=0 status=133' why it can happends ? And is this means that problem in Android ? . @dariuszseweryn Thank you so much. Time to time this problem happens and it is really solver by ble device rebooting or smartphone rebooting . Why I need scan my device before trying to connect with it? Is it some workaround ?. Thanks . @dariuszseweryn I think scaning on android it not good for user experience because we need enable location service . \u0415specially if application need restore connection in background or after starting application :( But It is what it is. I solve my issues.\nSorry , I am new in testing :( \nI have added robolectric annotation and after that all tests have been passed well.\n```java\n@Config(manifest = Config.NONE, constants = BuildConfig.class, sdk = Build.VERSION_CODES.LOLLIPOP)\n@RunWith(RobolectricTestRunner.class)\npublic class TestBle {\n@Test\npublic void test(){\n}\n\n}\n```. I'm not sure but when  I was try using createBond it not work well. @skykelsey Can you describe your case of bonding ? It is very interesting for me :)\n. @LinkOut  can u show stackTrace of error when ypu try \"connect back \" and whant does \"Main wont connect..\" means ? Can u show RxAndroidBle logs ?. Have any idei to solve this ?. @dariuszseweryn Ok, thanks, I check this.  . @dariuszseweryn I have find reproduce scenario and I will give you feedback today or tomorrow. My steps to reproduce on samsung galaxy s 7:\n1) Restart smatphon \n2) Open application and start for scaning with SCAN_MODE_LOW_LATENCY and UUID filter\n@dariuszseweryn  Your advice has help me. In first testing scenario I put .observeOn(schedulers.mainThread()) just before .subscribe() . - it works fine :) without MissingBackpressureException. Then I had tested more variants and I tink that .onBackpressureDrop() must be before observeOn and may be after scanBleDevices Observable.\nFull error log without proguard shrinking:\njava\nrx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:325)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:379)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:361)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n    at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext(OperatorSubscribeOn.java:74)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at com.polidea.rxandroidble.internal.operations.ScanOperationApi21$1.onScanResult(ScanOperationApi21.java:60)\n    at android.bluetooth.le.BluetoothLeScanner$BleScanCallbackWrapper$1.run(BluetoothLeScanner.java:413)\n    at android.os.Handler.handleCallback(Handler.java:739)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:158)\n    at android.app.ActivityThread.main(ActivityThread.java:7229)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\nBut I have UI lags with device scaning on UI thread... :).  RxJava 1. @dariuszseweryn  Thank you so match . . ",
    "KolinLoures": "@uKL Hi. I tried to find answer to this issue, but it still not work. May you give some helpful advice if it is not difficult for you :) \npublic void startWriteCommucation(final ArrayList<byte[]> b) {\n        if (isConnected()){\n                connectionObservable\n                        .flatMap(new Func1<RxBleConnection, Observable<Observable<byte[]>>>() {\n                            @Override\n                            public Observable<Observable<byte[]>> call(RxBleConnection rxBleConnection) {\n                                final List<Observable<byte[]>> list = new ArrayList<>();\n                                for (byte[]  bytes: b){\n                                    Log.e(\"MyTag\", Arrays.toString(bytes));\n                                    list.add(rxBleConnection.writeCharacteristic(BleDevice.characteristicWrite, bytes));\n                                }\n                                return Observable.from(list);\n                            }\n                        })\n                        .flatMap(new Func1<Observable<byte[]>, Observable<byte[]>>() {\n                            @Override\n                            public Observable<byte[]> call(Observable<byte[]> observable) {\n                                return observable;\n                            }\n                        })\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(\n                                new Action1<byte[]>() {\n                                    @Override\n                                    public void call(byte[] bytes) {\n                                        Log.e(\"MyTag2\", Arrays.toString(bytes));\n                                        view.setTextStatus(\"WRITE SUCCESS\");\n                                    }\n                                },\n                                new Action1<Throwable>() {\n                                    @Override\n                                    public void call(Throwable throwable) {\n                                        view.setTextStatus(\"!!!FAIL WRITE!!!\");\n                                        throwable.printStackTrace();\n                                    }\n                                }\n                        );\n            }\n    }\nThis code works, and writes that it was successfull, but device does't responed.\n. @dariuszseweryn we have detail description of this issue on stackoverflow. \nhttp://stackoverflow.com/questions/38250610/sending-the-list-of-commands-to-device-using-rxandroidble-rxjava\n. ",
    "zzt93": "\nWhat the best practice to unsubscribe connection if I want to connect to many devices and communicate ? in Activity#onDestory? or like the following code\n\n```\nObservable connectionSrc = rxBleScanResult\n        .getBleDevice()\n        .establishConnection(activity, false);\n// 6/8/16  when found the device, stop scanning\nsubscribe.unsubscribe();\n// TODO: 6/8/16 when un-subscribe this\nSubscription conSubscription = connectionSrc\n        .flatMap(new Func1>() {\n            @Override\n            public Observable call(final RxBleConnection rxBleConnection) {\n                return rxBleConnection.readCharacteristic(BLE.BLE_CHAT_UUID);\n            }\n        })\n        .subscribe(new Action1() {\n            @Override\n            public void call(byte[] bytes) {\n                // read bytes            \nconSubscription.unsubscribe();\n            }\n        });\n```\n. - read write combined vs simple read then simple write\n  The following code is blog's code for read/write combined.\ndevice.establishConnection(context, false)\n    .flatMap(rxBleConnection -> rxBleConnection.readCharacteristic(characteristicUuid)\n        .doOnNext(bytes -> {\n            // Process read data.\n        })\n        .flatMap(bytes -> rxBleConnection.writeCharacteristic(characteristicUuid, bytesToWrite))\n     ).subscribe(writeBytes -> {\n        // Written data.\n    });\nWhat is the difference between the following code:\nObservable<RxBleConnection> connectionSrc = device.establishConnection(activity, false);             \nconnectionSrc\n    .flatMap(rxBleConnection -> rxBleConnection.readCharacteristic(characteristicUUID))\n    .subscribe(characteristicValue -> {\n        // Read characteristic value.\n    });\nconnectionSrc\n    .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUUID, bytesToWrite))\n    .subscribe(characteristicValue -> {\n        // Characteristic value confirmed.\n    });\n. @dariuszseweryn \nThe take(1) corresponds to another device's one writeCharacteristic() invocation, no matter how big the characteristic is? In other word, if one device invoke writeCharacteristic twic, another device have to readCharacteristic() twice to read all info( or take(2) in this case)?\n. Say we have two devices all use RxAndroidBle to connect to each other. One device call writeCharacteristic() twice during connection, the other device then call  readCharacteristic() to read. Will the second device observe one event or two?\n. Ok, I know. Thank you.\n. In the first case, you mean if I can't read some characteristic from other device, I can't write?\n. But if the device in the other side doesn't write any characteristic, what will I read?\n. Thanks for your suggestion.\n. Thanks.\n. ",
    "6bangs": "\nThe observing action will be executed on arbitrary thread unless you will specify .observeOn(Scheduler). This is exactly in line of how rxJava works.\n\nIs this true? As far as I can tell, an Observable resulting from RxBleRadioImple.queue(RxBleRadioOperation) will not have OperatorObserveOn applied to it, and should execute on the same thread that calls subscribe. From the ReactiveX docs:\n\nBy default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its Subscribe method is called.\n. Note that the actual BLE operation will queue up on a new arbitrary thread and execute on the main thread (as required by Android) - but from an Rx perspective, observing and subscribing happens on the same thread that called subscribe.\n. That'll do it, thanks!\n. Cool! Can this be used for a long-running task concurrently with other usages of RxBleConnection (writing and reading characteristics, etc)?. Yep. We deliver OTA updates transparently to our users while the device is otherwise in use (reading heart rate, etc). It works great currently, but it takes 4-6 hours to complete.\n\nMaybe we could use this if we opened a second RxBleConnection to the device specifically for OTA. Is there any reason that wouldn't work?. Of course. Our device uses characteristics not defined in the BLE spec for both OTA and heart rate measurement (among other things). We set up notifications for heart rate measurement via the usual setupNotification method of RxBleConnection. Most traffic happens via notifications, but during OTA we do a lot of writing until the OTA process is complete. We also write occasionally to update the state of the device (set the heart rate monitoring interval, etc).\nWe can perform all of these operations concurrently, and it's working really well. OTA just takes forever due to RxJava overhead.\nWith regard to BleAlreadyConnectedException, is that a limitation of RxAndroidBle or the platform? I haven't actually tried connecting multiple BluetoothGatts to the same device with the same app, but I assumed it must be possible since multiple apps can connect to the same device at the same time.. Yep, exactly. Sorry, I forgot that detail; wrote that code almost a year ago. If I recall, I found it in an RxAndroidBle example. I bet it's something that's useful enough it should probably be called out in the README.md.. Ah, cool. Will look into that.. ",
    "SkaveRat": "@uKL no\n@mzgreen BlackPhone2 with 5.1.1, Kernel 3.10.49.\nCan later try with a different phone\n. Other devices have the same problem.\nAfter playing around some more, it appears that retrolambda is a required dependency.\nChanged around a lot of stuff, but only after adding retrolambda it finally worked:\n# app/build.gradle\n```\napply plugin: 'me.tatarka.retrolambda'\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\ndependencies {\n    classpath 'me.tatarka:gradle-retrolambda:3.2.5'\n}\n\n}\n```\n. I've tried pretty much any combination.\nThe versions I was on while discovering the retrolambda solutions were compile/build 23, min 18 and I think java 1.7.\nAfter it worked, I upgraded successfully to the following:\ncompile: 24\nbuildtools: 24\nminSdk: 18\nJava: 1.8\nAs soon as I remove retrolambda from these settings, the SDK tells me to enable Jack (which I also tried unsuccessfully)\nToday my phone updated to 6.0.1, so that should be considered, if I should test other things\n. I have similar problems. The device scans for half a second (sometimes even less) and stops.\nIf I mash the scan button multiple times I find the device I want, but it would be a lot more convinient to e possible to say \"scan for X seconds\"\nIf it's relevant: I have another BLE device connected already (my watch) \n06-25 21:41:03.523 17384-25926/? D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(239854725)\n06-25 21:41:03.524 17384-25942/? D/RxBle#Radio:  STARTED RxBleRadioOperationScan(239854725)\n06-25 21:41:03.538 6124-6365/? D/BtGatt.GattService: registerClient() - UUID=0b1fbda3-6807-4c82-8c4d-fb4b95d3ffbe\n06-25 21:41:03.541 6124-6224/? D/BtGatt.GattService: onClientRegistered() - UUID=0b1fbda3-6807-4c82-8c4d-fb4b95d3ffbe, clientIf=5\n06-25 21:41:03.541 17384-25936/? D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5\n06-25 21:41:03.541 6124-8778/? D/BtGatt.GattService: start scan with filters\n06-25 21:41:03.545 6124-6239/? D/BtGatt.ScanManager: handling starting scan\n06-25 21:41:03.546 17384-25942/? D/RxBle#Radio: FINISHED RxBleRadioOperationScan(239854725)\n06-25 21:41:03.563 6124-6224/? D/BtGatt.GattService: onScanFilterEnableDisabled() - clientIf=5, status=0, action=1\n06-25 21:41:03.563 6124-6224/? D/BtGatt.ScanManager: callback done for clientIf - 5 status - 0\n06-25 21:41:03.563 6124-6239/? D/BtGatt.ScanManager: configureFilterParamter 500 10000 1 0\n06-25 21:41:03.570 6124-6224/? D/BtGatt.GattService: onScanFilterParamsConfigured() - clientIf=5, status=0, action=0, availableSpace=15\n06-25 21:41:03.570 6124-6224/? D/BtGatt.ScanManager: callback done for clientIf - 5 status - 0\n06-25 21:41:03.570 6124-6239/? D/BtGatt.ScanManager: configureRegularScanParams() - queue=1\n06-25 21:41:03.570 6124-6239/? D/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=2 mLastConfiguredScanSetting=-2147483648\n06-25 21:41:03.570 6124-6239/? D/BtGatt.ScanManager: configureRegularScanParams - scanInterval = 8000configureRegularScanParams - scanWindow = 8000\n06-25 21:41:03.571 6124-6224/? D/BtGatt.GattService: onScanParamSetupCompleted : 0\n06-25 21:41:03.623 17384-25926/? I/MYAPP:DeviceScanActivity: 65:C6:F0:28:F6:F9\n06-25 21:41:03.626 6124-6365/? D/BtGatt.GattService: stopScan() - queue size =1\n06-25 21:41:03.626 6124-6239/? D/BtGatt.ScanManager: stop scan\n06-25 21:41:03.626 6124-8778/? D/BtGatt.GattService: unregisterClient() - clientIf=5\n06-25 21:41:03.639 6124-6224/? D/BtGatt.GattService: onScanFilterParamsConfigured() - clientIf=5, status=0, action=1, availableSpace=16\n06-25 21:41:03.640 6124-6224/? D/BtGatt.ScanManager: callback done for clientIf - 5 status - 0\n06-25 21:41:03.640 6124-6239/? D/BtGatt.ScanManager: configureRegularScanParams() - queue=0\n06-25 21:41:03.640 6124-6239/? D/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=-2147483648 mLastConfiguredScanSetting=2\n06-25 21:41:03.640 6124-6239/? D/BtGatt.ScanManager: configureRegularScanParams() - queue emtpy, scan stopped\n. Okay, here's how to reproduce (and a fix, at least for me)\n```\nfinal String deviceName = rxBleScanResult.getBleDevice().getName(); // this can be null!\nlogger.i(deviceName); // this stops the scan without stacktrace, if the name is null\nlogger.i(String.format(\"name: %s\", deviceName)); // this doesn't\n```\n. ",
    "lavenj": "@uKL love this project, but it seems like it's tied to RetroLambda. Any chance/timeline for Jack compatibility?\n. Hi @DariuszAniszewski -- I'm seeing the same output in my project. It seems like the disconnect callbacks are being fired before the connection actually closes. Is this a correct assessment? Any possibility for a bugfix?\n. @dariuszseweryn thanks for looking at this! We have a reasonable workaround implemented so are OK for now. This library continues to be a huge help. \nOff-topic but discovered RxBleAdapterStateObservable while digging through the source. So clean and easy! You should throw it in the docs if it's not already in there \ud83d\ude04 \n. ",
    "jssingh": "Didn't think we could control that? Or maybe I am wrong. I guess I am wrong since you have a PR ready for it :)\n. ",
    "jtomazin": "How does scan expose BluetoothDevice? I can't find it in 1.1.0-SNAPSHOT. As far as I can tell, scan returns RxBleScanResults, which don't expose BluetoothDevice. I'm trying to bond to a device and it would be nice if I didn't have to get a reference to the adapter. \n. ",
    "jeffreyliu8": "I need bonding/pairing because it gives secure/encrypted BLE connection.. ",
    "lorenzowoodridge": "Essentially when you are deciding to connect to the device you check to see if it is in the list of bonded devices, and if so you can immediately connect. If the device has yet to be bonded then you make the request to bond to the device and then register a BroadcastReceiver for specific Bluetooth intents to know when the device has been bonded so then you can connect to it.\nConnection:\n```\nBluetoothManager bluetoothManager = (BluetoothManager) context\n        .getSystemService(Context.BLUETOOTH_SERVICE);\nBluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();\nif (bluetoothAdapter.getBondedDevices().contains(device)) {\n    // connect to device\n} else if (device.createBond()) {\n    registerBluetoothIntents();\n}\n```\nRegister for receiver:\n```\nprivate void registerBluetoothIntents() {\n    IntentFilter intentFilter = new IntentFilter();\n    intentFilter.addAction(BluetoothDevice.ACTION_FOUND);\n    intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);  // really the only important one\n    intentFilter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);\n    intentFilter.addAction(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);\n    intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);\ncontext.registerReceiver(new BroadcastReceiver() {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        BluetoothDevice device;\n\n        switch (action) {\n            case BluetoothDevice.ACTION_FOUND:\n                break;\n            case BluetoothDevice.ACTION_BOND_STATE_CHANGED:\n                device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);\n                int prevState = intent\n                        .getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, 0);\n                int bondState = device.getBondState();\n\n                if (bondState == BluetoothDevice.BOND_BONDING) {\n                    // bonding\n                } else if (bondState == BluetoothDevice.BOND_BONDED) {\n                    // bonded\n\n                    if (prevState == BluetoothDevice.BOND_BONDING) {\n                        // connect to device\n                    }\n                } else if (bondState == BluetoothDevice.BOND_NONE) {\n                    if (prevState == BluetoothDevice.BOND_BONDING) {\n                        // error\n                    }\n                }\n\n                break;\n            case BluetoothAdapter.ACTION_SCAN_MODE_CHANGED:\n                break;\n            case BluetoothAdapter.ACTION_STATE_CHANGED:\n                break;\n            case BluetoothDevice.ACTION_PAIRING_REQUEST:\n                break;\n        }\n    }\n}, intentFilter);\n\n}\n```. I've tried to change the write type of the characteristic and that did not work, but I'm thinking I need to set the value of a descriptor.. I'll let you know if that is the issue.\nI'm also in contact with the firmware engineer to see if there is something else that I'm missing.. Not sure why it's working now but it is!. It was definitely something minor that I was doing wrong but I'm not sure what. Not an issue with the library!. Our firmware developer just reported this back actually:\n\"Looks like Android turns characteristics into descriptors after the first 30 characteristics!\nI moved the last characteristics up and sure enough, it just cuts off any after 30. Great.\"\nhttps://issuetracker.google.com/issues/37005408. I agree that this is not a bug with the library, but it is definitely worth bringing to everyone's attention :). From our gatt.xml specification:\n\nAnd my debug output:\n----- characteristic UUID: 362f71a0-6c96-11e3-981f-0800200c9a66\n----- characteristic properties: 18\n----- characteristic permissions: 0\n-------- descriptor UUID: 00002902-0000-1000-8000-00805f9b34fb\n-------- descriptor permissions: 0\n-------- descriptor UUID: 00002901-0000-1000-8000-00805f9b34fb\n-------- descriptor permissions: 0. It works perfectly if the device has already been paired previously.\nWhat I thought was interesting is that the logs indicate setCharacteristicNotification is called twice\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 362f71a0-6c96-11e3-981f-0800200c9a66 enable: true\nD/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(479503017)\nD/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(505411897)\nD/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(479503017)\nD/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(479503017)\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 362f71a0-6c96-11e3-981f-0800200c9a66 enable: false. The permissions are the same even when the device has already been paired before. ",
    "pregno": "I don't know if I could be helpful.\nWith my device I have got a lot of issues related to the bonding with Android, with the firmware team we didn't understand why it was asking a pairing code on Android but with iOS is working without. \nIn the firmware there is a \"Just Work\" implementation, so it shouldn't ask for a code, but for some unknown (yet) reasons the handshake with Android is different.\nSo I tried to manage with code in order to avoid to ask to the user the PIN and I came out with this (I've found on the net I don't remember where and I slightly edit it):\n```\npublic abstract class BondReceiver extends BroadcastReceiver {\n    private static final String TAG;\n    private WeakReference mContextWeakReference;\npublic abstract void onDeviceBonded(String str);\n\npublic abstract void onDeviceUnbonded(String str);\n\nstatic {\n    TAG = BondReceiver.class.getSimpleName();\n}\n\npublic BondReceiver(Context context) {\n    this.mContextWeakReference = null;\n    if (context == null) {\n        throw new IllegalArgumentException(\"'context' cannot be null!\");\n    }\n    IntentFilter intentFilter = new IntentFilter();\n    intentFilter.addAction(\"android.bluetooth.device.action.BOND_STATE_CHANGED\");\n    intentFilter.addAction(\"android.bluetooth.device.action.PAIRING_REQUEST\");\n    intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1);\n    context.registerReceiver(this, intentFilter);\n    this.mContextWeakReference = new WeakReference<>(context);\n}\n\npublic void onReceive(Context context, Intent intent) {\n    if (intent == null) {\n        return;\n    }\n    String action = intent.getAction();\n    if (\"android.bluetooth.device.action.BOND_STATE_CHANGED\".equals(action)) {\n        handleBondingEvents(intent);\n    } else if (\"android.bluetooth.device.action.PAIRING_REQUEST\".equals(action)) {\n        handlePairingRequest(intent);\n    }\n}\n\nprivate void handleBondingEvents(Intent intent) {\n    int prevBondState = intent.getIntExtra(\"android.bluetooth.device.extra.PREVIOUS_BOND_STATE\", -1);\n    int bondState = intent.getIntExtra(\"android.bluetooth.device.extra.BOND_STATE\", -1);\n    BluetoothDevice device = intent.getParcelableExtra(\"android.bluetooth.device.extra.DEVICE\");\n    Timber.v(\"device = \" + device.getAddress() + \" prev state = \" + prevBondState + \" new state = \" + bondState);\n    if (prevBondState == BluetoothDevice.BOND_BONDED && bondState == BluetoothDevice.BOND_NONE) {\n        onDeviceUnbonded(device.getAddress());\n    } else if (prevBondState == BluetoothDevice.BOND_BONDING && bondState == BluetoothDevice.BOND_BONDED) {\n        onDeviceBonded(device.getAddress());\n    } else if (prevBondState == BluetoothDevice.BOND_BONDING && bondState == BluetoothDevice.BOND_NONE) {\n        onDeviceUnbonded(device.getAddress());\n    }\n}\n\nprivate void handlePairingRequest(Intent intent) {\n    BluetoothDevice device = intent.getParcelableExtra(\"android.bluetooth.device.extra.DEVICE\");\n    if (device == null) {\n        Timber.w(\"handlePairingRequest: device is null\");\n    } else {\n        int type = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.ERROR);\n        Timber.d(\"Pairing type: \" + type);\n        if (type == BluetoothDevice.PAIRING_VARIANT_PIN) {\n            String pin = \"123456\";\n            device.setPin(pin.getBytes());\n            abortBroadcast();\n        }\n    }\n}\n\npublic void stopReceiving() {\n    Context context = this.mContextWeakReference.get();\n    if (context != null) {\n        try {\n            context.unregisterReceiver(this);\n        } catch (Exception e) {\n            Timber.e(e, e.getMessage());\n        }\n    }\n}\n\n}\n```\nBasically, as I understand in my case, the bonding process calls android.bluetooth.device.action.PAIRING_REQUEST two time, one for asking the PIN and the other one for asking confirm to the user. \nWith that class I intercept the PIN request and set it via code, the pairing confirmation it still redirect to the user (but I noticed that in a lot of cases is not requested).\n. this could be managed changing the MTU. If you are using Android 5.x or later you can set the MTU > 20 before sending the data. I've experienced some stalled negotiation when the device is not paired with the phone (or is not paired correctly). \nIn that case, sometimes, you will never get a response.. Unfortunately not, but during my tests I've experienced when:\n- device not paired\n- device appears in the bonded list, but actually is not paired\n- device goes out range when connecting. The tests has been done on my application, without using your library, so plain (and pain) Android BLE stack.The application is a companion app for our product, so we tested it intensely in every condition.\nI know it is a borderline situation, maybe it depends on the firmware implementations.\nIf you are not convinced about that we could remove the timeout from the request and add it lately if  happens again. ok. Don't worry :)\nI will close the various fixes soon. ok, done. thank you too!\nbest. As far as I know, it's not possible.\nThe device I'm using automatically negotiate the MTU with iOS devices, but on Android this didn't happen. I don't usually write empty statements :)\nI left it empty because I thought was not relevant for the sample.. Yes, probably I've put @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) in the wrong place.\nRight now is in the protectedRun method of the RxBleRadioOperationMtuRequest class. In that case we should put a listener (like the connection listener) on the callback onMtuChanged.\nBTW I'll ask to my firmware developer to test that case. what is not relevant?. oh c'mon man, Android studio added. ",
    "RobLewis": "Try as I may, I can't find a completely clear explanation of BLE pairing and bonding (complicated by the fact that many people apparently misuse the terms). \"Pairing\" seems to be part of the process that happens when 2 BLE devices connect, and involves the generation and exchange of encryption keys. True? \"Bonding\" involves the devices storing the keys for use later, so that on subsequent connections they can skip the initial pairing handshake. True? \nAnd yet @uKL says (above): \"Bluetooth Low Energy generally does not require bonding/pairing and the library doesn't support that.\" \nVery confused. I'd be very grateful if someone could point me to a full explanation. . I've used switch( connectionState.toString() ). Not the safest, but it works this week, anyway :-). I read that Java 9 has a new Reactive \"Flow\" paradigm, with classes Publisher, Subscriber, Processor, and Subscription. A Publisher seems to be equivalent to an Observable, and a Processor is an Operator (or perhaps a Subject). I wonder how this will impact the RxJava project. . Is there any tentative schedule for RxJava 2 support? I don't have an active project right now, but for my next one I'd like use v. 2 if possible. . Update: my issue was putting the maven URL in the buildscript:repositories block of the project build.gradle, not the allprojects:repositories block. \nAlso, I see that the 'compile' directive is now deprecated, replaced by 'api'. Alternatively you can use 'implementation', which is recommended for most cases as it can reduce build time. The difference is explained here but TBH I don't really understand it: https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html \n\nSorry, I have never understood how to use these snapshots, and the\nSonatype site isn't much help IMO. Can you point me to a step-by-step?\nHere's what I'm trying:\nIn the repositories block of the project build.gradle:\n        maven { url\n\"https://oss.sonatype.org/content/repositories/snapshots\" }\nIn the dependencies block of the module build.gradle:\n    compile 'com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT'\nThe error is: \"Failed to resolve:\ncom.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT\"\n--Rob\n\nDariusz Seweryn notifications@github.com\nFebruary 16, 2018 at 09:37\n\nWe are finishing the migration to the RxJava 2. There is a\nsnapshot release\nwith the name com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT\nwhich you can try out!\n\n\n. Ah, I was putting the maven URL in the buildscript:repositories block,\nnot the allprojects:repositories one. Thanks.\nSadly, Gradle remains a mystery to me. I really must learn more about it.\n--RL\nP.S. I know you have plenty of work to do, but was wondering if you\nmight be planning a migration guide for moving RxAndroidBle to RxJava2.\n\nDariusz Seweryn notifications@github.com\nFebruary 16, 2018 at 23:58\nI have just tested it and seems to work for me. In the projects\nbuild.gradle I have:\nallprojects {\nrepositories {\ngoogle()\njcenter()\nmaven { url \"https://oss.sonatype.org/content/repositories/snapshots\" }\n}\n}\nand in the module build.gradle:\ndependencies {\n// ...\nimplementation 'com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT'\n// ...\n}\n\n\n. I've re-read this whole discussion and don't understand what the issues are. What, exactly, is \"API 21 scanning\"? What's the practical impact for users of RxAndroidBle? Will there be code changes involved? Would appreciate a bit of explanation. . Thanks, @chuks. Still would like to know if there is any impact on the code I write. Does the library now automatically and transparently use the new scanning system when running on API 21 or later? Are there new features available to RxAndroidBle users? Or is this an \"under-the-hood\" improvement? . Thank you, but I still have not seen a statement of exactly what I need to do to my existing code to reap these benefits, and what, in fact, these benefits are. . Is there any progress on this? My new project is an app that connects to 3 different BLE devices. One of the devices must be \"paired\" to operate; it is optional on the others, apparently. \nI am still puzzling over the terminology of pairing vs. bonding, and can't find a definitive explanation. Some sources emphasize that the two are quite different things, and yet the Android documentation treats them as though they are synonyms (see here, for example). \nOn the assumption that when people say \"pair\", they really mean \"bond\", there seems to be a need to add this to RxAndroidBle. Or can I simply call rxBleDevice.getBluetoothDevice.createBond()? \nClarification appreciated. . @dariuszseweryn \n\n\u2026rely on the automatic process which is kicked off by Android usually when accessing encrypted characteristics.\n\nIs this what you mean? \n\nit seems Android attempts to handle authentication/permission issues on a trial and error basis. In other words, the framework always attempts a basic read/write, and if it fails for authentication reasons, it automatically tries again with MITM authentication requested. \n\nIf you have a link to more info, I'd appreciate it. . Sorry, I am new to this.\u00a0\nI have searched your GitHub site and cannot find any reference to 1.2.0-SNAPSHOT. Where is it, please?\u00a0\nCan it be added to my project by replacing this line in build.gradle:\u00a0\n\u00a0\u00a0\u00a0compile 'com.polidea.rxandroidble:rxandroidble:1.1.0'\nIf so, what would I use?\u00a0\nDo you have any idea when 1.2.0 will be officially released?\u00a0\nAre the fixes\u00a0you have recently made\u00a0incorporated in the current 1.1.0 version? Is there any sort of Change Log available?\u00a0\nI just discovered that there is apparently an open issue regarding API 21 compatibility. This is the API version that I have to write to. Am I going to have a problem?\u00a0\nThank you for any help you can give! I really appreciate the great work you are doing.\u00a0\n--Rob Lewis\nOn Feb 02, 2017, at 03:25 AM, dariuszseweryn notifications@github.com wrote:\nVersion 1.2.0-SNAPSHOT\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I don't know what changed, but the app seems to be working now. . Wait, am I reading this correctly? \nThough I have Java experience, I'm new to Android, Bluetooth, and Reactive programming. I went to a good deal of trouble figuring out how to set up Jack and use lambdas in Android Studio. Now you are telling me that I can't do this with your library? \nIf this is the case, wouldn't it have been a good idea to mention this in your documentation? \nIf retrolambda is an option, I didn't see any instructions on using it. Could you point me at them? What is the downside? And am I supposed to remove this from my app's build.gradle: \n       jackOptions { enabled true }\nHow about this? \ncompileOptions { sourceCompatibility JavaVersion.VERSION_1_8\n            targetCompatibility JavaVersion.VERSION_1_8 }\nAnything you can give me in the way of detailed and specific instructions on how to recover from what looks like a small disaster would be VERY MUCH appreciated. I've been compiling 1.8 code using RxAndroidBle and haven't noticed any special problems, though I have yet to actually try running anything except some simple JUnit tests with RxBleClientMock. . Did you see Google's recent announcement that Jack is being deprecated and Java 8 features will soon be added to the base system? Will this have any effect on this issue? . If it's not too dumb of a question, could you briefly explain what \"dependency injection\" is, and its benefits and practical implications? . These excerpts demonstrate what I'm seeing: \n```\nstatic final String AS_UUID_HEAD  =  \"F954\"; \nstatic final String AS_UUID_TAIL  =  \"-91B3-BD9A-F077-80F2A6E57D00\";\nstatic final String asServiceIdString    =  AS_UUID_HEAD + \"1234\" + AS_UUID_TAIL; // Service UUID\nstatic final UUID asServiceId = UUID.fromString( asServiceIdString ); \nstatic final UUID[] asServiceIdArray = { asServiceId }; // varargs argument to scanBleDevices\n// In the Mock Client Builder:\nrxBleClientMock = new RxBleClientMock.Builder( )\n                .addDevice( new RxBleClientMock.DeviceBuilder( )\n                        .deviceMacAddress( macAddress )\n                        .deviceName( deviceName )\n                        .scanRecord( scanRecordBytes )\n                        .rssi( rssiValue )\n                        .addService(\n                                asServiceId,\n                                new RxBleClientMock.CharacteristicsBuilder( ) \n                                        .addCharacteristic( \n                                                asDataCharId, asDataCharBytes,\n                                                new RxBleClientMock.DescriptorsBuilder() \n                                                        .addDescriptor(clientCharConfigID, asDisableNotifications) \n                                                        .build() // the Descriptor  ...  etc.\n// in the code\n  Observable scanForAS() { \n        System.out.println( \"Entering scanForAS\" );\n        return rxBleClientMock\n                .scanBleDevices( asServiceIdArray ) // supposed to return Observable \n                //.scanBleDevices(  ) // returns Observable\n```\nNote that the last, commented-out line works to find and return the scan result, while I get nothing back from the call with the asServiceIdArray parameter. And I get the same result if I use just the UUID alone, instead of putting it into a 1-element array. . Sorry, yes, I am subscribing. Here's the code that calls scanForAS(): \nscanSubscription = scanForAS() \n                .doOnSubscribe( () -> System.out.println( \"doOnSubscribe in connect_OK\") ) // Prints, so must be subscribing OK\n                .doOnNext( item -> System.out.println(\"doOnNext in Test connect_OK item: \" + item.toString() ) ) // Doesn't print!\n                .doOnUnsubscribe( () -> System.out.println( \"doOnUnsubscribe in connect_OK\") ) \n                .subscribe( \n                        this::connectToAS, // argument is RxBleDevice\n                        this::handleScanError );\nAs I mentioned, it does work to return the Mocked device if I leave out the argument in the call to scanBleDevices(). Also, I did remove a call to.first() in scanForAS(), since I am only trying to find one device. \n. Here's my complete call to the Mock Builder: \nrxBleClientMock = new RxBleClientMock.Builder( )\n                .addDevice( new RxBleClientMock.DeviceBuilder( )\n                        .deviceMacAddress( macAddress )\n                        .deviceName( deviceName )\n                        .scanRecord( scanRecordBytes )\n                        .rssi( rssiValue )\n                        .addService( \n                                asServiceId, \n                                new RxBleClientMock.CharacteristicsBuilder( ) \n                                        .addCharacteristic( \n                                                asDataCharId, asDataCharBytes,\n                                                new RxBleClientMock.DescriptorsBuilder() \n                                                        .addDescriptor(clientCharConfigID, asDisableNotifications)\n                                                        .build() \n                                        ) \n                                        .addCharacteristic(\n                                                asInputCharId, asInputCharBytes,\n                                                new ArrayList<BluetoothGattDescriptor>( 0 ) ) // (empty List)\n                                        .addCharacteristic(\n                                                asStateCharId, asStateCharBytes,\n                                                new ArrayList<BluetoothGattDescriptor>( 0 ) ) \n                                        .addCharacteristic(\n                                                asOutputCharId, asOutputCharBytes,\n                                                new RxBleClientMock.DescriptorsBuilder() // add Descriptor\n                                                        .addDescriptor(clientCharConfigID, asDisableNotifications) \n                                                        .build() // the Descriptor\n                                        ) \n                                        .build( ) // Characteristics\n                        ) // addService (the only one)\n                        .build( ) // Device\n                ) // addDevice\n                .build(); // Client\nOne thing I haven't been able to find: what is the content and format of a ScanRecord? Right now I'm just using a dummy byte[3] for scanRecordBytes in DeviceBuilder. \nIn any case, asServiceId is the only Service UUID I have defined in the Mock Client, and the only one I'm looking for. This same constant is used to build the Mock Client and to filter the scanBleDevices() call. I've tried using it directly and putting it into a single-item array. Same result: not found. . Update: when I switch from the mock client to a real one, the Service UUID filter in scanBleDevices( serviceUUID ) works correctly. . It has always worked fine with a real device. I can't really answer about unit tests because I haven't looked at them in quite a while and this project is pretty much done. The code excerpts I posted earlier should tell the story. . I don't know that I will have time to create a separate project, but let me add this: the complete code for the addRxBleScanResult method: \npublic void addRxBleScanResult( RxBleScanResult scanResult ) {\n        RxBleDevice device = scanResult.getBleDevice();\n        Log.d( LOG_TAG, \"addRxBleScanResult about to call addRxBleDevice with device \" + device.toString() );\n        addRxBleDevice( device );\n    }\nAs you can see, all it does is convert the scanResult into a device, and call the same addRxBleDevice method that the other version of the code uses to add the device to a Vector. There is no other difference. If the problem isn't in .map(), then I don't know where it could be. \nAs noted, I puzzled for days trying to make the original version work. As soon as I eliminated the call to .map(), I started getting results. \n. This is with a real device (HP tablet running Android 5.0.1). It is scanning for prototypes of a new hardware sensor peripheral. \nP.S. On a separate topic, the peripheral needs to send data frames of up to 4K bytes. Am I correct that the new Long Read option will be useful for this? I haven't looked closely at it yet. . Thanks. I will let you know if I discover anything. . This may become relevant to an app I'm developing to support a BLE peripheral data acquisition device. It sends blocks of data (up to 4KB) as fast as possible. The data needs to be graphed on the Android screen as it arrives, so there may be little or no benefit to receiving it on a different thread. I had been thinking to receive on an io thread, perhaps analyze and format the data on a compute thread, and hand off to the UI thread just to draw the graph. Any advice or comments appreciated\u2014and apologies in advance if I am misunderstanding the issue. . Thanks very much! I'm still a bit confused by one thing: \nYou say that it's not recommended to save the RxBleConnection in a variable because it introduces state to manage. Yet you also say to use a single connection as long as feasible because establishing a new one takes time and battery power. How do I reuse the connection without saving it somewhere? I need to interactively read and write several characteristics of the BLE device, and receive notifications from it. \nI was thinking of a method like refreshConnection() that would test the connection state and if necessary reconnect. It would be called before each operation. Am I on the wrong track? . Here's what I have in mind. Any comments? \nRxBleDevice bleDevice; \nvolatile RxBleConnection bleConnection;\nAtomicBoolean writeCommandInProgress;\n...\nprivate Observable<RxBleConnection> getConnectionObservable() {\n   if( bleDevice.getConnectionState() == RxBleConnection.RxBleConnectionState.CONNECTED ) { \n       return Observable.just( bleConnection );\n   } else return bleDevice.establishConnection( asBleServiceRef, true );\n}\n...\npublic boolean writeCommand( byte[] commandBytes ) {\n    if( writeCommandInProgress.compareAndSet( false, true ) ) { \n        inputSubscription = getConnectionObservable()\n            .doOnNext( rxBleConnection -> bleConnection = rxBleConnection ) // save the connection\n            .flatMap( rxBleConnection -> rxBleConnection.writeCharacteristic( asInputCharId, commandBytes ) )\n            .subscribe( inputSubscriber );  // onCompleted() resets writeCommandInProgress\n        return true;                        // command initiated\n    } else return false;                    // can't issue the command because a previous one hasn't completed\n}\nActually, this reminded me of another question: is it necessary to wait for the completion of a previous write operation before calling writeCharacteristic() again, or are these operations automatically queued for processing? \n. Thank you for that; I will investigate. But someone with the handle \"s_noopy\" answered my recent StackOverflow question about Singles in RxAndroidBle by saying that support for them and Completables wouldn't be available until your 2.0 release. See http://stackoverflow.com/questions/42280071/would-it-be-appropriate-to-use-singles-for-rxandroidble-reads-and-writes Is this wrong? \nWould still appreciate your comment on my proposed approach of saving the connection and reusing it as long as the status remains CONNECTED. \nAnd did you have something specific in mind for setPairingData()? Can I get more info about this? . It occurs to me I may have a misunderstanding about BLE. Is a connection only desired at the moment that there is data to be exchanged? In my use case I sometimes have a constant stream of data packets coming from a peripheral device. . Your example is very clever\u2014thanks! \nOne final question: doSomething(connection) and setPairingData(connection) look like simple method calls, but the docs say concat() arguments are Completables. Wouldn't I build each one with something like Completable.fromCallable( connection -> ??? ). But Callables don't accept parameters, so how do I pass the connection to them? Do I perhaps want an implementation of Completable.OnSubscribe? Could it be as simple as \nnew Completable( connection -> { <code using the connection> } ). Any idea when 1.2.0 official release might be?\u00a0\nOn Mar 03, 2017, at 06:02 AM, dariuszseweryn notifications@github.com wrote:\n@skynet67 Current 1.2.0-SNAPSHOT release should have a fix for this issue.\nBest Regards\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. By replacing the above code with the following, the Data characteristic notification works: \ndataNotifSub = selectedScope.getConnectionObservable()\n        .flatMap(rxBleConnection -> rxBleConnection.setupNotification( asDataCharId))\n        .doOnNext(notificationObservable -> runOnUiThread(this::dataNotificationHasBeenSetUp))\n        .doOnError(setupThrowable -> runOnUiThread(this::dataNotificationSetupError))  \n        .flatMap(notificationObservable -> notificationObservable)\n        .timestamp()  \n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(this::onDataNotificationReceived, this::onDataNotificationError);\nThis would seem to imply that there's something wrong with my original code, but I can't figure out what it is. I spent a lot of time studying the scan() operator and I believe I'm using it correctly. Everything else seems pretty straightforward. The runOnUiThread() was copied from code I found somewhere but I honestly don't understand why it's necessary. If all I want to do is log the information and possibly set some variables, do I really need it?. Thanks for fast response! \nLog is attached. \nlogs_2_03-08.txt\nComments: \nThe characteristic that fails is 0x1235; the one that succeeds is 0x1239. \n\nLine 154: Initial scan, finding 2 devices, completes. \nLine 246: connection to user-selected device finishes. In the next line, service discovery starts. \nLine 248: error message from the handleFrameError method (from the last line of the code I posted). I don't know why this method is being called here, especially since the messages advising of notification setup (line 6 in my code) or setup error (line 8) are not appearing. \nLine 249: \"Data Notification was unsubscribed\" message from the next-to-last line of my code. \nLine 323: Service discovery completes. \nLine 342: Notification is set up for the other characteristic (0x1239). In my code, the setup for this one actually comes before the setup for 0x1235. \nLine 400: First notification appears on characteristic 0x1239. Characteristic 0x1236 is written occasionally, and succeeds. \n\nI will post more info in a separate comment. . Since you have the log, can you tell me why the MAC address frequently appears on 4 consecutive lines? See, for example, lines 494-497. \nThere is no stacktrace since the program doesn't terminate. It just fails to set up notifications on one of the two characteristics. \nIf I can't make this work, my fallback position is to use something similar to the working code I posted above to collect the data packets, then process them into a data frame and send it to a BehaviorSubject, which the code to process incoming data frames can subscribe to. Does this seem feasible? Is there a better way? . Thanks. Can you help me understand how it could happen that NEITHER message (\"Notification has been set up\" or \"Error setting up notification\") is logged (lines 6 and 8 in my code)? It just jumps right to the end and says I'm unsubscribed. . Don't know if this is relevant, but my scan() function returns null most of the time; only when the packet buffer is full does it return non-null data. But these nulls are filtered out in the next step:  .filter( pBuf -> pBuf != null ). I got this idea from StackOverflow\u2014do you see a potential problem? . Just FYI: I read \"The Problem with Subjects\" http://tomstechnicalblog.blogspot.com/2016/03/rxjava-problem-with-subjects.html and none of the caveats seem to apply to my application, so I rewrote it using a BehaviorSubject and it appears to work well. Now experimenting with threading to try to increase performance. \nThanks again for your help. This will teach me not to believe everything I read on StackOverflow! . I'm seeing a writeCharacteristic() attempt cause an error/unsubscription and can't figure out why: StackOverflow. This sounds interesting. Is there any documentation of how it fits into the RxAndroidBle overall scheme? Usage example? . I should add that the \"Unknown scanning error\" message near the end comes from my adaptation of your code to handle scan errors. Which means that it is not a BleScanException. \nThe connection scanner code is: \npublic void scanForAeroscopes() { // entered here OK\n    Log.d( LOG_TAG, \"Entered scanForAeroscopes()\" ); \n    rxBleDeviceVector.clear( ); // empty the vectors of discovered devices\n    asDeviceVector.clear( );\n    scanSubscriber = new AsScanSubscriber<>( ); // subscriber to RxBleScanResult\n    scanSubscription = asBleClient\n            .scanBleDevices( asServiceIdArray ) // filter by Service UUID\n            .subscribeOn( Schedulers.io() )  \n            .observeOn( AndroidSchedulers.mainThread( ) )\n            .take( MAX_AEROSCOPES ) // have tried values of 2 and 1\n            .take( SCAN_TIME, TimeUnit.SECONDS )  // limit the length of the scan (initially 60L)\n            .doOnNext( this::addRxBleScanResult ) // put a found device in the Vectors\n            .subscribe( scanSubscriber ); \n    Log.d( LOG_TAG, \"Exiting scanForAeroscopes() after subscribing\" ); \n}\n\n. Thanks. \nAlso: I don't know if it could be relevant, but I just switched from retroLambda to Jack. . I don't know what the Advertisement Interval is or where to find it. \nCould the device name have anything to do with it? This new sample has a custom name (\"Jack's Aeroscope\") \nThe class cast exception is puzzling because it never used to happen, and I haven't made any relevant changes to the code that I can imagine. . It appears that the class cast exception is an irrelevant and unimportant bug, and the real problem seems to be this: \n```\n04-05 16:08:35.273 7947-7964/io.aeroscope.aeroscope D/BluetoothLeScanner: onScanResult() - ScanResult{mDevice=6B:CA:B3:49:12:E8, mScanRecord=ScanRecord [mAdvertiseFlags=26, mServiceUuids=null, mManufacturerSpecificData={76=[16, 2, 11, 0]}, mServiceData={}, mTxPowerLevel=-2147483648, mDeviceName=null], mRssi=-48, mTimestampNanos=1121088741861116}\n04-05 16:08:58.739 7947-7966/io.aeroscope.aeroscope D/BluetoothLeScanner: onScanResult() - ScanResult{mDevice=CC:C6:B5:9F:9A:F7, mScanRecord=ScanRecord [mAdvertiseFlags=6, mServiceUuids=[f9541234-91b3-bd9a-f077-80f2a6e57d00], mManufacturerSpecificData={}, mServiceData={}, mTxPowerLevel=-2147483648, mDeviceName=Jack's Aeroscope\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd], mRssi=-58, mTimestampNanos=1121112203939117}\n04-05 16:08:58.741 7947-7947/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n...\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: com.polidea.rxandroidble.RxBleScanResult.class\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:190)\n    at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onNext(OnSubscribeDoOnEach.java:98)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\u00a0\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\u00a0\n    at rx.internal.operators.OperatorTakeTimed$TakeSubscriber.onNext(OperatorTakeTimed.java:62)\u00a0\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:76)\u00a0\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\u00a0\n    at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\u00a0\n    at android.os.Handler.handleCallback(Handler.java:815)\u00a0\n    at android.os.Handler.dispatchMessage(Handler.java:104)\u00a0\n    at android.os.Looper.loop(Looper.java:194)\u00a0\n    at android.app.ActivityThread.main(ActivityThread.java:5576)\u00a0\n    at java.lang.reflect.Method.invoke(Native Method)\u00a0\n    at java.lang.reflect.Method.invoke(Method.java:372)\u00a0\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:956)\u00a0\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:751)\u00a0\n``\nThis scan found 2 BLE devices. The MAC addressCC:C6:B5:9F:9A:F7is the one we are interested in. But something went wrong when the Subscriber tried to emit the device viaonNext(), and insteadonError()was called. (There is also adoOnNext()` method in the Subscription, but it is not being called.) \nDoes this suggest anything? It seems unlikely, but could the garbage characters that follow the device name (\"Jack's Aeroscope\") be a problem? \n. Grasping at straws here: any chance the newer version of RxJava messed up something? \nThe hardware developers have informed me that the Advertising Interval is usually 220 ms, but increases to 1.5 sec after 48 hours of no connection (to save battery). After a connection it goes back to 220 ms for 48 hours. I believe this is a new feature of the recent firmware update. . I had been putting a 60-second timeout on the scan, but I increased that and found that in my trials the device was found\u2014the longest observed delay this time was 40 seconds, and sometimes the device was found quickly. I suspect what may have happened was that the device has been in its 1.5 second Advertising Interval low power mode, in which it seems to take a long time to scan. (Once connected, it reverts to the standard 220 ms Advertising Interval for 48 hours.) \nHowever, I'm getting a new error in the log. Apparently I am trying to read and write the device too soon after attempting to connect with it. My write attempt came 7ms later. How long should a connection take to establish? \nBut see what happens next: \n04-09 13:04:15.368 5129-5129/io.aeroscope.aeroscope D/AeroscopeDevice: Write error in Input message to Aeroscope: null\n04-09 13:04:15.675 5129-5156/io.aeroscope.aeroscope D/GraphicBuffer: register, handle(0xac184ee0) (w:800 h:1280 s:800 f:0x1 u:0x000f02)\n04-09 13:04:15.678 5129-5129/io.aeroscope.aeroscope D/ActivityThread: ACT-STOP_ACTIVITY_HIDE handled : 0 / android.os.BinderProxy@2effaaf1\n04-09 13:04:15.714 5129-5129/io.aeroscope.aeroscope D/AeroscopeBluetoothServc: Returned from super.onUnbind()\n04-09 13:04:15.715 5129-5129/io.aeroscope.aeroscope D/ActivityThread: SVC-UNBIND_SERVICE handled : 0 / BindServiceData{token=android.os.BinderProxy@3fb46635 intent=Intent { cmp=io.aeroscope.aeroscope/.AeroscopeBluetoothService }}\n04-09 13:04:15.716 5129-5129/io.aeroscope.aeroscope D/ActivityThread: SVC-Destroying service: io.aeroscope.aeroscope.AeroscopeBluetoothService@a0d163d\n04-09 13:04:15.716 5129-5129/io.aeroscope.aeroscope D/ActivityThread: SVC-STOP_SERVICE handled : 0 / android.os.BinderProxy@3fb46635\n04-09 13:04:15.719 5129-5129/io.aeroscope.aeroscope E/ActivityThread: Service io.aeroscope.aeroscope.AeroscopeBluetoothService has leaked IntentReceiver com.polidea.rxandroidble.RxBleAdapterStateObservable$1$1@3743daee that was originally registered here. Are you missing a call to unregisterReceiver()?\n    android.app.IntentReceiverLeaked: Service io.aeroscope.aeroscope.AeroscopeBluetoothService has leaked IntentReceiver com.polidea.rxandroidble.RxBleAdapterStateObservable$1$1@3743daee that was originally registered here. Are you missing a call to unregisterReceiver()?\n        at android.app.LoadedApk$ReceiverDispatcher.<init>(LoadedApk.java:944)\n        at android.app.LoadedApk.getReceiverDispatcher(LoadedApk.java:715)\n        at android.app.ContextImpl.registerReceiverInternal(ContextImpl.java:1742)\n        at android.app.ContextImpl.registerReceiver(ContextImpl.java:1722)\n        at android.app.ContextImpl.registerReceiver(ContextImpl.java:1716)\n        at android.content.ContextWrapper.registerReceiver(ContextWrapper.java:488)\n        at com.polidea.rxandroidble.RxBleAdapterStateObservable$1.call(RxBleAdapterStateObservable.java:61)\n        at com.polidea.rxandroidble.RxBleAdapterStateObservable$1.call(RxBleAdapterStateObservable.java:47)\n        at rx.internal.operators.OnSubscribeCreate.call(OnSubscribeCreate.java:72)\n        at rx.internal.operators.OnSubscribeCreate.call(OnSubscribeCreate.java:32)\n        at rx.Observable.unsafeSubscribe(Observable.java:10140)\n        at rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:45)\n        at rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:30)\n        at rx.Observable.unsafeSubscribe(Observable.java:10140)\n        at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n        at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.Observable.unsafeSubscribe(Observable.java:10140)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\n        at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.fastPath(OnSubscribeFromArray.java:76)\n        at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.request(OnSubscribeFromArray.java:58)\n        at rx.Subscriber.setProducer(Subscriber.java:211)\n        at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:32)\n        at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:24)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.Observable.unsafeSubscribe(Observable.java:10140)\n        at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n        at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.Observable.unsafeSubscribe(Observable.java:10140)\n        at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51)\n        at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n        at rx.Observable.unsafeSubscribe(Observable.java:10140)\n        at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)\n        at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)\n        at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n        at rx.internal.\n04-09 13:04:15.750 5129-5171/io.aeroscope.aeroscope D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=1 device=CC:C6:B5:9F:9A:F7\n04-09 13:04:15.750 5129-5171/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n04-09 13:04:15.751 5129-5171/io.aeroscope.aeroscope D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n04-09 13:04:15.762 5129-6259/io.aeroscope.aeroscope D/AeroscopeDevice: AsConnSubscriber made connection com.polidea.rxandroidble.internal.connection.RxBleConnectionImpl@33c070f6\n04-09 13:04:15.764 5129-5129/io.aeroscope.aeroscope D/AeroscopeDevice: getConnectionObservable used existing connection\n04-09 13:04:15.771 5129-5157/io.aeroscope.aeroscope D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(937594675)\nWhat does \"Are you missing a call to unregisterReceiver()?\" mean? After outputting this error the app seems to run OK, but I'd like to know what's going on. \n. So there's no information about how long it normally takes to establish a connection to a device found in a scan? No upper limit? Does it make sense to do a \nwhile( !isConnected() ) { }; \nwait loop (perhaps with a timeout)? \nA brief pause in the UI is acceptable, but a long one (more than a few seconds) isn't. \nAny advantage to a BlockingObservable? Other solutions? \n(I think I'd prefer to avoid restructuring my code to put all subsequent actions in establishConnection's onNext() handler.)  . Currently I'm using .subscribeOn( Schedulers.io() ) for scanBleDevices(). Is this a good idea? . Regarding this: \nWhat does \"Are you missing a call to unregisterReceiver()?\" mean?\n\nIt means that the context that was used to register a BroadcastReceiver - which is internally used by RxBleAdapterStateObservable - has finished but the receiver was not unregistered (unsubscribed) creating a memory leak.\n\nThe only thing I can relate this to is that I set up a subscription to observeConnectionStateChanges( ) in an Activity's onStart() method and don't unsubscribe it anywhere. Would this explain it? \nThis brings up a more general question: I'm not clear on how the various Observables should be managed over the Activity lifecycle. As I interpret Google's documentation, in onPause() you should pause tasks that have high CPU usage. Is it OK to leave low-demand operations like monitoring ConnectionStateChanges running? Any general guidelines would be appreciated. \nAlso, what is the recommended technique for handling the loss of a BLE connection, such as by moving a peripheral device out of Bluetooth range? . Again, trying to interpret Android docs: a \"paused\" Activity isn't really in the background, it's just suspended momentarily for things like answering an incoming phone call (and it can remain visible). In that case, I think I would like to leave things like ConnectionStateChange monitoring enabled. \nApparently it is possible for a paused Activity to be killed, but the app will first be notified by a call to onStop() (followed by onDestroy()). So it would appear that if I unsubscribe in onStop() I should be OK. True? . Under what conditions (if any) does ConnectionStateChange call the Subscriber's onError() and onCompleted() methods? . I sympathize. The project I'm on has involved simultaneously learning Android, RxJava, and BLE. I think \"drinking from a firehose\" is an apt way to put it :-)  Additional documentation is always a welcome thing. . Log attached. \nlogs_13_04-14.txt\nBelow is the method. However, I can't see in the log where it's being called. \nprivate void addRxBleScanResult( RxBleScanResult scanResult ) {\n        RxBleDevice device = scanResult.getBleDevice();\n        Log.d( LOG_TAG, \"addRxBleScanResult about to call addRxBleDevice with device \" + device.toString() );\n        // TODO: add each device to the displayed \"found\" list when it's found(?)\n        addRxBleDevice( device );\n    }\nThe method it calls is well tested and has never had a problem: \nprivate boolean addRxBleDevice( RxBleDevice device ) {\n        Log.d( LOG_TAG, \"Entering addRxBleDevice with device \" + device.getName() );\n        if( !rxBleDeviceVector.contains( device ) ) {\n            Log.d( LOG_TAG, \"Adding RxBleDevice \" + device.getName() + \" to Vector\" );\n            addAeroscopeDevice( new AeroscopeDevice( device, this ) ); \n            return rxBleDeviceVector.add( device ); // true\n        } else {\n            Log.d( LOG_TAG, \"RxBleDevice \" + device.getName() + \" already in rxBleDeviceVector\");\n            return false;\n        }\n    }. AeroscopeDevice attached (sorry it is a mess; I'm in the middle of redoing it)\nHere's handleRxBleScanError(): \n   private void handleRxBleScanError( Throwable scanError ) {\n        nowScanning.set( false );        // reset \"scan active\" flag (synchronized) (error ends scan)\n        errorScanning.set( true );       // set the \"scan error\" flag\n        Log.d( LOG_TAG, \"scanSubscription onError() received: \" + scanError.getMessage(), scanError );\n        handleScanError( scanError, callingContext ); // TODO: test\n    }\nOK, this is where I suspected the problem was days ago, but nothing is getting logged. As you will see below, handleScanError() is an adaptation of your own code, and I'm trying to send it a context so the Toast can be displayed. Since this method exists in the class AeroscopeBluetoothService, which doesn't have a UI, I am trying to send it the context of the MainActivity in the variable callingContext. In MainActivity, the onServiceConnected() routine has this: \nasBleServiceRef.setCallingContext( MainActivity.this );\nMaybe handleScanError() is trying to cast AeroscopeBluetoothService to MainActivity, causing the ClassCastException, but why isn't anything getting logged? \nHere's the routine: \n```\n    static void handleScanError( Throwable scanError, Context context ) {\n        Log.d( LOG_TAG, \"Entering handleScanError: \" + scanError.getMessage() );\n        Log.d( LOG_TAG, \"Context passed to handleScanError is: \" + context.getClass().getName() );  // debugging (pushed)\n        if (scanError instanceof BleScanException ) {\n            switch ( ((BleScanException) scanError).getReason() ) {\n                case BleScanException.BLUETOOTH_NOT_AVAILABLE:\n                    Log.d( LOG_TAG, \"handleScanError: Bluetooth is not available\" );\n                    Toast.makeText( context, \"Bluetooth is not available\", Toast.LENGTH_SHORT ).show( );\n                    break;\n                case BleScanException.BLUETOOTH_DISABLED:\n                    Log.d( LOG_TAG, \"handleScanError: Bluetooth is disabled\" );\n                    Toast.makeText( context, \"Enable bluetooth and try again\", Toast.LENGTH_SHORT ).show( );\n                    break;\n                case BleScanException.LOCATION_PERMISSION_MISSING:\n                    Log.d( LOG_TAG, \"handleScanError: Location permission missing\" );\n                    Toast.makeText( context,\n                            \"On Android 6.0 location permission is required. Implement Runtime Permissions\", Toast.LENGTH_SHORT ).show( );\n                    break;\n                case BleScanException.LOCATION_SERVICES_DISABLED:\n                    Log.d( LOG_TAG, \"handleScanError: Location services disabled\" );\n                    Toast.makeText( context, \"Location services needs to be enabled on Android 6.0\", Toast.LENGTH_SHORT ).show( );\n                    break;\n                case BleScanException.BLUETOOTH_CANNOT_START:\n                default:\n                    Log.d( LOG_TAG, \"handleScanError: Bluetooth cannot start\" );\n                    Toast.makeText( context, \"Unable to start scanning (reason unknown)\", Toast.LENGTH_SHORT ).show( );\n            } // switch\n        } else { // exception was not a BleScanException\n            Log.d( LOG_TAG, \"handleScanError: Unknown scanning error\" );\n            Toast.makeText( context, \"Error scanning for Aeroscopes: \" + scanError.getMessage(), Toast.LENGTH_SHORT ).show( );\n        }\n        Log.d( LOG_TAG, \"handleScanError Finished\" );\n    }\n```\nReally appreciate your help on this! \nAeroscopeDevice.txt\n. I was using retrolambda until you released 1.2.0 of the library, when I switched to Jack (which I know is deprecated and eventually will go away). . addAeroscopeDevice immediately follows in the code: \n```\n    private boolean addRxBleDevice( RxBleDevice device ) {\n        Log.d( LOG_TAG, \"Entering addRxBleDevice with device \" + device.getName() );\n        if( !rxBleDeviceVector.contains( device ) ) {\n            Log.d( LOG_TAG, \"Adding RxBleDevice \" + device.getName() + \" to Vector\" );\n            addAeroscopeDevice( new AeroscopeDevice( device, this ) ); \n            return rxBleDeviceVector.add( device ); // true\n        } else {\n            Log.d( LOG_TAG, \"RxBleDevice \" + device.getName() + \" already in rxBleDeviceVector\");\n            return false;\n        }\n    }\n// Add an Aeroscope device to the Vector (returns true if it was not already present)\n// static because there's just 1 vector\nprivate boolean addAeroscopeDevice( AeroscopeDevice asDevice ) {\n    Log.d( LOG_TAG, \"Entering addAeroscopeDevice with device \" + asDevice.bleDevice.getName() );\n    if( !asDeviceVector.contains( asDevice ) ) {\n        Log.d( LOG_TAG, \"Adding AeroscopeDevice \" + asDevice.bleDevice.getName( ) + \" to Vector\" );\n        return asDeviceVector.add( asDevice ); // true\n    } else { // don't think we should ever see this(?)\n        Log.d( LOG_TAG, \"AeroscopeDevice \" + asDevice.bleDevice.getName() + \" already in asDeviceVector\");\n        return false;\n    }\n}\n\nThey are both in `AeroscopeBluetoothService`. The `this` is there to pass a reference to the Service to the AeroscopeDevice constructor, which it saves in a variable to allow the Device to call the Service methods. As far as I know, this has been working. . I have now seen what may be another variation of this \"problem with lambdas\". First, could you elaborate on what you mean by this? Is it that the lambdas aren't being compiled correctly? Is Jack failing? Is there something wrong with my logic? With release 1.2.0 of your library? Explain please. \nIn any case, my code to scan for BLE devices has this:\n                .take( secondsToScan, TimeUnit.SECONDS )  \n                .take( numberToFind )    \nWhat seems to be happening is that `.take( numberToFind )` is satisfied, causing the Subscriber's `onCompleted()` to be called. Previously, this was a simple method reference: `this::completeRxBleScan`. AFAIK, it never had a problem until the recent 1.2.0 library update and/or the switch from retrolambda to Jack. Now I am seeing this in the log:\n04-24 13:56:39.015 22783-22783/io.aeroscope.aeroscope D/AeroscopeBluetoothServc: Adding AeroscopeDevice Jack's Aeroscope to Vector\n04-24 13:56:39.017 22783-22783/io.aeroscope.aeroscope E/AndroidRuntime: FATAL EXCEPTION: main\n                                                                        Process: io.aeroscope.aeroscope, PID: 22783\n                                                                        java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                                                                            at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:114)\n                                                                            at android.os.Handler.handleCallback(Handler.java:815)\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:104)\n                                                                            at android.os.Looper.loop(Looper.java:194)\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5576)\n                                                                            at java.lang.reflect.Method.invoke(Native Method)\n                                                                            at java.lang.reflect.Method.invoke(Method.java:372)\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:956)\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:751)\n                                                                         Caused by: java.lang.IncompatibleClassChangeError: Class 'io.aeroscope.aeroscope.-$Lambda$10' does not implement interface 'rx.functions.Action0' in call to 'void rx.functions.Action0.call()' (declaration of 'java.lang.reflect.ArtMethod' appears in /system/framework/core-libart.jar)\n                                                                            at rx.internal.util.ActionSubscriber.onCompleted(ActionSubscriber.java:49)\n                                                                            at rx.observers.SafeSubscriber.onCompleted(SafeSubscriber.java:79)\n                                                                            at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:281)\n                                                                            at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216)\n                                                                            at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\n                                                                            at android.os.Handler.handleCallback(Handler.java:815)\u00a0\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:104)\u00a0\n                                                                            at android.os.Looper.loop(Looper.java:194)\u00a0\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5576)\u00a0\n                                                                            at java.lang.reflect.Method.invoke(Native Method)\u00a0\n                                                                            at java.lang.reflect.Method.invoke(Method.java:372)\u00a0\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:956)\u00a0\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:751)\u00a0\n``\nThe key line would seem to be this:Caused by: java.lang.IncompatibleClassChangeError: Class 'io.aeroscope.aeroscope.-$Lambda$10' does not implement interface 'rx.functions.Action0' in call to 'void rx.functions.Action0.call()' (declaration of 'java.lang.reflect.ArtMethod' appears in /system/framework/core-libart.jar)`\nOf course I can't tell, but I suspect that -$Lambda$10 is the above method reference (I'm guessing that this is a system-created name for an inner class that implements the method reference.) \nI've replaced the method reference with an anonymous inner class and am now testing. So far it looks OK. \nCould you help me understand what's going on here? \n . Perhaps someone smarter than me can explain this, but it appears at least some of these errors were due to the fact that several of my Subscribers' onError( Throwable t ) methods were throwing RuntimeException, which I now understand is a no-no. . Thanks. I almost understand what you're saying. \nI've been using the following method to deliver Connection Observables to my various subscribers, and it seems to work: \nObservable<RxBleConnection> getConnectionObservable() {\n        if( isConnected() ) {\n            Log.d( LOG_TAG, \"getConnectionObservable used existing connection\");\n            return Observable.just( bleConnection ); // variable where I store connection\n        }\n        else {\n            Log.d( LOG_TAG, \"getConnectionObservable re-establishing connection...\");\n            return bleDevice.establishConnection( NO_AUTO_CONNECT ); \n        }\n    }\nI'm thinking to replace this method with: \n```\n    Observable getConnectionObservable() {\n        return sharedConnectionObservable;\n    }\nAnd this:\n    Observable sharedConnectionObservable = this.bleDevice\n            .establishConnection( NO_AUTO_CONNECT )\n            .retry( CONNECTION_RETRIES ) \n            .compose( new ConnectionSharingAdapter() ); \n``\nAm I on the right track? . As I noted in my OP, when I first obtain the BLE connection, I store it in a static variable and reference the variable when I need a connection. I use it to send data on 2 different characteristics, receive notifications on two others, and read the RSSI, all at the same time. It works across two different Activities and a bound Service. So I don't understand the need for a separate \"connection sharing\" component, though I would love to know the rationale for it! \nAt some point I will probably try inserting theConnectionSharingAdapter` to see its effect. But things seem to work fine without it. \nI wrote up an analysis of the ConnectionSharingAdapter code for my own education. Here it is, if you're interested: \n```\nObservable.Transformer is a class with a call() method that takes Observable as its argument and returns Observable\nHere, T and R are both RxBleConnection, so the Transformer implemented by ConnectionSharingAdapter \nis transforming Observable into another Observable. \nWhat it does: \n    Instance member connectionObservable is an uninitialized AtomicReference to Observable (so it's initially null). \n    Thus connectionObservable has atomic get() and set() methods. Also, the call() method is synchronized on it. Should be thread safe. \n    This call() method is supposed to transform one Observable (\"source\") into another when invoked by .compose(). \n        It starts by getting the current value of connectionObservable (initially null) and copying it to rxBleConnectionObservable. \n        If this rxBleConnectionObservable is not null, it is returned as the \"transformed\" Observable. \n        If it is null\n            it creates newConnectionObservable from the supplied source\n            adds .doOnUnsubscribe() that sets connectionObservable to null\n            adds .replay(1) that returns a ConnectableObservable (doesn't emit RxBleConnection until ConnectableObservable's connect() method is called)\n                (When connect() is called, all waiting Subscribers are served, but you can add more Subscribers later.)\n                Any new subscribers get \"replayed\" the last 1 item emitted, which in this case would be the RxBleConnection. \n            adds .refCount() that operates on a ConnectableObservable and returns an ordinary Observable: \n                when the first Observer subscribes, it connects to the underlying ConnectableObservable\n                when the last Observer unsubscribes, it disconnects (i.e., unsubscribes from the underlying ConnectableObservable)\n            sets the instance member connectionObservable to this newConnectionObservable\n            returns this newConnectionObservable\nNarrative: \nYou use .establishConnection() to establish the RxBleConnection, then .compose() a new ConnectionSharingAdapter. \nIt transforms the Observable into a different one: \nThe first Subscriber finds that the transformation hasn't taken place (connectionObservable is null), so \na new Observable is created that\n    automatically connects to the original Observable when the first Subscriber comes along\n    delivers the single RxBleConnection to the first and all subsequent subscribers\n    when the last subscriber unsubscribes, unsubscribes from the original Observable and sets connectionObservable null so it will have to be re-created\n```\nHonestly, I still don't understand why it's needed. Can anyone explain? . I guess there is no point in leaving this open.. Thanks, @yohanan\u2014I really appreciate the help. \nI actually have several onError() handlers in my code, for the various Subscribers I'm using. Many of them are lambdas or method references, and most don't do anything except log the error and maybe set a flag. A few re-throw the error as a RuntimeException (maybe I should be looking more closely at these?) I don't use the .propagate() construct as I'm not aware of it. \nAs I noted, Polidea responded to my earlier issue (@#173) by saying it was \"probably caused by a lambda\", but I haven't been able to find out what they mean by that. Are lambdas not compiled correctly (I'm using Jack)? Do I have a logic error? \nAnother head scratcher is the log saying the ultimate cause is a Class Cast Exception, because one of my classes can't be cast to a different one. \nI'm no expert at reading logs, but it seems to me that a line like this: \nat io.aeroscope.aeroscope.-$Lambda$13.$m$0(Unknown Source)\nis saying that the routine causing the error is known by the internally-generated name -$Lambda$13.$m$0, which isn't much help. (I'm guessing that the compiler is creating inner classes to implement the lambdas, and giving them names like this. It would be interesting if there was some kind of compiler output that listed stuff like this.) . OK, grasping at straws (or perhaps threads?) here, but the log indicates that the last operation on the thread that crashed (the main thread 30032-30032) was an attempt to write Characteristic 1237: \n05-01 12:55:01.906 30032-30032/io.aeroscope.aeroscope D/BluetoothGatt: writeCharacteristic() - uuid: 00001237-0000-1000-8000-00805f9b34fb\n05-01 12:55:01.906 30032-30032/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n05-01 12:55:01.999 30032-30051/io.aeroscope.aeroscope D/BluetoothGatt: onCharacteristicWrite() - Device=CC:C6:B5:9F:9A:F7 UUID=00001237-0000-1000-8000-00805f9b34fb Status=0 srvcType=0 srvcInstId=0 charInstId=0\n05-01 12:55:01.999 30032-30051/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n05-01 12:55:01.999 30032-30051/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n05-01 12:55:01.999 30032-30051/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n05-01 12:55:01.999 30032-30051/io.aeroscope.aeroscope D/BluetoothDevice: mAddress: CC:C6:B5:9F:9A:F7\n05-01 12:55:02.000 30032-30051/io.aeroscope.aeroscope D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=00001237-0000-1000-8000-00805f9b34fb status=0\n05-01 12:55:02.003 30032-30058/io.aeroscope.aeroscope D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(722505227)\n05-01 12:55:02.003 30032-30058/io.aeroscope.aeroscope D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(89438770)\n05-01 12:55:02.005 30032-30032/io.aeroscope.aeroscope E/AndroidRuntime: FATAL EXCEPTION: main\n                                                                        Process: io.aeroscope.aeroscope, PID: 30032\n                                                                        java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                                                                            at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:114)\n                                                                            at android.os.Handler.handleCallback(Handler.java:815)\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:104)\n                                                                            at android.os.Looper.loop(Looper.java:194)\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5576)\n                                                                            at java.lang.reflect.Method.invoke(Native Method)\n                                                                            at java.lang.reflect.Method.invoke(Method.java:372)\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:956)\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:751)\n                                                                         Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n                                                                            at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n                                                                            at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                                                                            at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n                                                                            at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\n                                                                            at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n                                                                            at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\n                                                                            at android.os.Handler.handleCallback(Handler.java:815)\u00a0\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:104)\u00a0\n                                                                            at android.os.Looper.loop(Looper.java:194)\u00a0\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5576)\u00a0\n                                                                            at java.lang.reflect.Method.invoke(Native Method)\u00a0\n                                                                            at java.lang.reflect.Method.invoke(Method.java:372)\u00a0\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:956)\u00a0\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:751)\u00a0\n(etc.)\nHere's that code: \nvoid copyFpgaRegisterBlockToAeroscope() {\n        try {\n            this.getConnectionObservable()\n                    .flatMap( rxBleConnection -> rxBleConnection.writeCharacteristic( AeroscopeConstants.asStateCharId, fpgaRegisterBlock ) )\n                    .observeOn( AndroidSchedulers.mainThread( ) )  // try removing\n                    // Insert following\n                    //.doOnNext( ( stateMsg ) -> Log.d( LOG_TAG, \".doOnNext() in copyFpgaRegisterBlockToAeroscope() got message: \"\n                            + HexString.bytesToHex( stateMsg ) ) )\n                    // could inclusion of onCompleted() cause a problem since Example doesn't have one? \n                    .subscribe( this::onWriteStateSuccess, this::onWriteStateError, this::onWriteStateCompleted ); \n        } catch( Exception e ) { \n            Log.d( LOG_TAG, \"Exception trying to write State Characteristic: \" + e.getMessage(), e );\n            e.printStackTrace( );\n        }\n    }\n    void onWriteStateSuccess( byte[] bytesWritten ) { // onNext() handler for write State characteristic success\n        Log.d( LOG_TAG, \"Message written to Aeroscope State: \" + HexString.bytesToHex( bytesWritten ) );\n    }\n    void onWriteStateError( Throwable writeError ) { // handler for write State characteristic error\n        Log.d( LOG_TAG, \"Write error in State message to Aeroscope: \" + writeError.getMessage( ) );\n    }\n    void onWriteStateCompleted( ) { // handler for write State onCompleted()\n        Log.d( LOG_TAG, \"copyFpgaRegisterBlockToAeroscope onCompleted() called\" );\n    }\nI'm going to try removing the .observeOn( AndroidSchedulers.mainThread() ) because it doesn't seem necessary. Also I'm adding the commented-out .doOnNext() to see if I can get it to log anything; currently none of the Log.d() statements are working. \nFinal thought: is catch( Exception e ) possibly a problem? (I only added it to try to find this problem). Is it possible that an error from writeCharacteristic() isn't an Exception but some other Throwable? Should I handle this differently? Or remove it? \n. This is very promising @yohanan -- thanks bigly! The StackOverflow post you referenced points to another one, which also looks helpful. . Very helpful\u2014thank you! . Sigh I have so much to learn. Thank you. . Just as an additional data point, I have now run several development versions of the app multiple times. As long as I Clean the project before each run, I don't have a problem. I'm still using Jack. The Clean operation is fairly quick, so it's not too burdensome. . I use the standard Java class ByteBuffer: it wraps a byte[] and does exactly this. . As I mentioned, I think I have handled the requesting coarse location permission issue. \nThe remaining question is what exactly does RxAndroidBle need enabled to scan for devices? The Google docs suggest that there isn't one single \"Location Services\" function that can be switched on or off, but rather a number of different functions that fall into that category: GPS_PROVIDER, NETWORK_PROVIDER, Google Play Services. Everything my research has found has to do with the Android device determining its own location, which would seem to have little to do with scanning for BLE peripherals. \nIs there no straightforward answer to my question? \nAnd is there another issue coming up when you switch over to API 21-style scanning? . Thanks, I believe that is the answer I needed. . What is the confusion? All normal Bluetooth packets are 20 bytes. Of course you must also be aware that some UTF-8 characters are more than 1 byte. If you want guaranteed 1-byte characters you can use .getBytes( StandardCharsets.US_ASCII ). It works for me. . I agree this would be a nice enhancement. Maybe as part of the change to RxJava 2? . Can I ask a question in concrete terms? \n\nI'm targeting API 21 and testing on an Android 5.0.1 tablet. I have not declared any permissions in the manifest. The app works OK. \nOn an Android 6 tablet, the app aborts with the permissions issue. \nWhat is the best way to solve this and maintain compatibility with different Android versions? . I see that ScanSettings.Builder is invoked with an anonymous inner class as the first (and perhaps only) argument to .scanBleDevices(). What is the syntax for adding ScanFilters? Is it a second argument to .scanBleDevices()? . Thanks, but no, it doesn't. My question is: where in the code does the filter definition go? I see how to create the filter object, but I don't see where to put it in the code. The ScanSettings object is shown as an argument to the .scanBleDevices() function. Is the ScanFilter object a second argument to this function (an overload)? I guess an actual code snippet using a filter would be the best way to resolve this. . Perfectly clear, thank you. I guess I should learn to examine your source code more closely. . Regarding @dariuszseweryn P.S.: apologize for off-topic; please let me know if I should open a separate issue or address this somewhere else: \n\nMy app writes to 2 different characteristics and receives notifications from 2 others. I don't see any realistic way of combining all these into a single .subscribe(), especially since one notification is a pretty constant data \"firehose\". \nNot knowing any better, I have been simply storing the RxBleConnection in a variable and using it in multiple .subscribe()s. As far as I can tell, this has been working OK. I've investigated the ConnectionSharingAdapter but as I discussed here, I don't understand what benefits it offers over my simplistic approach, though I would love to know. \nIn general, some elaboration on how multiple .subscribe()s introduce state, and the potential pitfalls, might be helpful. . I did, here: https://stackoverflow.com/questions/44637878/using-multiple-subscribe-statements-with-rxjava/44639493#44639493\nHope to try out the ConnectionSharingAdapter tomorrow. \nCheers, \n--Rob\n\nOn Jun 20, 2017, at 14:37 , Ken DeLong notifications@github.com wrote:\n@RobLewis https://github.com/roblewis Rob, did you post this question on SO? I am very interested in the answer as this fits my scenario as well.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/Polidea/RxAndroidBle/issues/225#issuecomment-309899162, or mute the thread https://github.com/notifications/unsubscribe-auth/AAJVYtrAxu1m7oVSzAVigJ7wu-x299Gtks5sGDuEgaJpZM4N-NrK.\n\n\n. Haven't thought this through, but will this fix require any changes to ConnectionSharingAdapter? . @6bangs Are you using the ConnectionSharingAdapter to multiplex your various reads and writes with a single RxBleConnection? I recently switched to this from my somewhat lame home-brewed solution and it seems to be working well. More here. . This was mentioned as being part of the 1.5.0 release. Is that still the plan? . FWIW, I'm using the following without seeing any exceptions: \nframeRelayerSubscription = frameRelayer\n                .observeOn( AndroidSchedulers.mainThread() ) \n                .onBackpressureLatest()\n                .subscribe( frameRelayerSubscriber );\n(frameRelayer is a BehaviorSubject). Small point, but I think the official Bluetooth term for these devices is \"dual-mode\". \nI wonder if we will see \"treble-mode\" devices that also support Bluetooth Mesh :-). Possibly irrelevant comment @ThunderThrash: I'm struggling right now with error 0x81, which is reportedly a \"generic Bluetooth error\", i.e., seems to have no diagnostic value whatever. Enlightenment appreciated! . Just to achieve a bit of \"closure\" with my previous comment: the \"generic Bluetooth error\" 0x81 turned out to be that I was attempting to enable notifications when I should have been using indications (or vice versa, forget which). Wouldn't it be swell if there were explicit causes given like this? Even something like \"unsupported operation\" would be better than \"generic error\"! . I should have clarified that the above error was in some Android-native (non-RxAndroidBle) code I inherited. Rewriting it now with Rx. What a difference! . Think I found the problem: rookie mistake. \nI needed an .observeOn( AndroidSchedulers.mainThread() ) to make it possible to display the Toast in onBpConnected(). \n(However that doesn't explain why the first (scanning) Observable chain was able to display a Toast and didn't have the .observeOn() operator.) . Thanks for the explanation. It sounds like Toast is a bit different from other UI elements, which (we are told) can only be operated on in the main thread. Offhand, are there any use cases where you might want to display a Toast from a different thread (with a Looper)? . Yes I looked there but everything I found seemed to involve maven. I will look some more. . clean: no\nrebuild: no\nrm -rf $HOME/.gradle/caches/  and rebuild: this gets rid of the message, but now when I command \"Go To Declaration\" it just decompiles RxBleConnection.class. There is an option to \"Choose Sources\" but I don't know where to find those, if they even exist on my computer. \nRe-launch Android Studio: no change. \nWhy is this happening? I've never seen anything like this before. . Bravo! Fantastic help for debugging. Would these be output to separate files, and/or logcat? I assume there would be an API for choosing options\u2014maybe just a bitfield? \nMaybe include connection state changes, if not already covered. . Update: today I am near cross-eyed from trying to plumb the mysteries of Android BLE Bonding (which is often called \"pairing\"\u2014even by Google\u2014though I think this is incorrect). I would give a lot for a clear, simple, complete, and correct explanation of these issues. I realize this may be impossible due to the discrepancies between implementations on Android devices, but it's something to hope for. . A few that come to mind: \n--Use occasional bursts of scanning to simulate continuous scanning (which, according to the article, is guaranteed to fail eventually)\n--Automatically re-establish dropped connections\n--Automatic management of the AutoConnect flag (determine what works best for a given pair of devices and remember it for the future)\n--Provide a global Bluetooth reset if things get completely screwed up. Great idea! (I just spent too much time tracking down a bug in some inherited (non-Rx) Android code, which was due to trying to enable indications for characteristics that only supported notifications.) As for what the default should be when a characteristic supports both, what are the pros and cons of each? . @simonratner Good logic, however in my case (low-traffic medical data collection) I'd opt for the most reliable method. So the preference should be user-settable. \nAs for the API, how about something like this: \nObservable<Observable<byte[]>> setupNotificationOrIndication(@NonNull UUID characteristicUuid, @NonNull NotificationSetupMode setupMode, boolean preferIndication);\nThe boolean would default to false if not specified. \nMight want to review the types of Exceptions generated, and perhaps setupMode values? . Am I missing something? The NotificationSetupMode enum has options DEFAULT and COMPAT. The docs don't say what these have to do with choosing indications over notifications.  And the only parameters I see in the ConnectionSetup class are autoConnect, suppressOperationCheck, and operationTimeout. . Update: tried cloning again to a new Android Studio project, with the just-released 1.5.0 version and first got the message \"Unsupported Modules Detected: Compilation is not supported for following modules: RxAndroidBle2. Unfortunately you can't have non-Gradle Java modules and Android-Gradle modules in one project.\" \nThen it logged \"Gradle sync started\", and a minute later \"Project setup started\". Then Gradle sync failed with a NPE. Then I tried a Clean and it synced a few more times and eventually seems to have resolved whatever difficulties it had. . Great information, thanks. Could the OP share the code that uses retryWhen() to look for BleDisconnectedException? \nMaybe something like: \n.retryWhen( failures -> failures.filter( failure -> failure instanceof BleDisconnectedException )). Sorry, I don't know how to edit the files directly, but I have a couple of style comments: \nIn ReadMe: \nI would change this: \nUnlike the native Android API if autoConnect=true while using this library there will be NO attempts to automatically reconnect if the original connection will get lost.\nto this: \nUnlike the native Android API, if autoConnect=true while using this library there will be NO attempts to automatically reconnect if the original connection is lost. \nIn RxBleDevice.java: \nI would substitute this: \nIf false, the connection will fail with {@link com.polidea.rxandroidble.exceptions.BleGattException} if\n+     *                    the device is not in range after a 30-second timeout. If true, the connection will be pending indefinitely.\n+     *                    Unlike the native Android API, if set to true and the connection is lost there will NOT be any attempt to\n+     *                    reconnect unless explicitly resubscribed.\n. Style comment: suggest changing this to (changes underlined):\nWhen the user clicks on the \"CONNECT\" button \u2026\n\u2026\nSubsequent clicks on the \"CONNECT\" button (whose name will change\naccording to\u2026\nPawe\u0142 Urban wrote:\n\n\n\n\nWhen the user will click on \"CONNECT\" button the connection is established and other buttons are enabled according to the properties\n\n\n\n\nof the characteristic.\n\n\n\n\nSubsequent clicks on \"CONNECT\" button (which name will change accordingly to the connection state) will close the connection.\n\n\n\n\n. Regarding your first point, I'd love to see coverage of running Observables in background Services. . This sounds great. Where can I get more information? . I have wondered whether Observable is the best type for establishConnection(), which can only produce either zero or one results, like a Maybe. I realize this would mean changing the \"unsubscribe to disconnect\" feature (which is nice), but might there be a better way? . I use ConnectionSharingAdapter. What are its issues? And I think you may have a typo: isn't it [ReplayingShare](https://github.com/JakeWharton/RxReplayingShare)? . @streetsofboston I looked briefly at ReplayingShare and didn't notice any attention to threading. Do you think it would have the same issues as ConnectionSharingAdapter? . Don't really know what I'm talking about here, but this says that RxJavaPlugins have been deprecated in favor of RxJavaHooks. The relevant one would seem to be onError( Action1<Throwable> ). Might note this in the wiki. . I checked and other classes have similar problems, including ClientScope, RxBleClient, RxBleClientImpl, and perhaps others. . Perhaps the difference is that I am using Android Studio to clone the project from GitHub, whereas you presumably used git? It could then be a problem with Android Studio. \nAttempting to reproduce it now: \n1. In Android Studio 3.0.1 (Mac), select File | New | Project from Version Control | GitHub and enter the URL (https://github.com/Polidea/RxAndroidBle.git) and click Clone. \n2. Android Studio reports \"Unsupported Modules Detected: Compilation is not supported for the following modules: RxAndroidBle2 [the name I gave the Project folder]. Unfortunately you can't have non-Gradle Java modules and Android-Gradle modules in one project.\" \n3. Then Android Studio logs \"Gradle sync started\", then \"Project setup started\", then the sync fails with a Null Pointer Exception. \n4. In the Project view sidebar (set to Android mode), the only folder that has a triangle (indicating it's not empty, I suppose) is mockrxandroidble. It contains subfolders manifests and java. \n5.  I select Build | Rebuild Project. It runs but there is no apparent change. \n6. I try File | Synchronize. Nothing happens. Same with Build | Clean Project. \n7. I try Build | Make Project. I get 200 errors: packages don't exist, or can't find symbol class (such as RxBleConnection). \n8. I close and reopen the project. Now the rxandroidble and sample folders show their contents, but not dagger-compiler-shadow or dagger-library-shadow. Opening up classes like ClientComponent in the editor gives the errors I originally described, I'm guessing because the dagger folders are apparently invisible. \n9. Closing and reopening the project again doesn't change anything. Neither does Clean Project. \n10. I try again to close the project. This time, it is now missing from the File | Open Recent menu. \nIt seems likely that the problem is Android Studio failing for some reason to recognize the two Dagger folders. But I don't know what to do about this. \nI'll try it using git and see what happens. \n. OK, I cloned the repo (using GitKraken) and opened it in Android Studio. I didn't have to ask it to build. I got some warnings, like removing RetroLambda (did that), remove the buildToolsVersion directive (did that). \nWhat remains is an error: \"android-apt plugin is incompatible with the Android Gradle plugin. Please use 'annotationProcessor' configuration instead.\"  . I found this in the Android docs: \nWhen using the Android plugin 3.0.0, you must add annotation processors to the processor classpath using the annotationProcessor dependency configuration, as shown below:\ndependencies {\n    ...\n    annotationProcessor 'com.google.dagger:dagger-compiler:<version-number>'\n}\nIs this applicable? What do I do? . Think I figured it out: in rxandroidble build.gradle: \nRemove the apply plugin: 'com.neenbedankt.android-apt'\nIn dependencies, remove the apt line and insert\nannotationProcessor 'com.google.dagger:dagger-compiler:2.15'\nThis gets rid of the last error; hopefully it works now. . @uKL OK, apparently my last clone somehow got an old version of the repo, missing the RxJava2 version. I tried again, using GitKraken to clone the repo\u2014I got the v.2 code, but I'm back to all the unrecognized things like @Inject, @Named, @Provides, @Module, @Component, @Scope, DaggerClientComponent, Lazy. \nCurrently I am only getting these errors in the following items: ClientComponent, ClientScope, RxBleAdapterStateObservable, RxBleClient, and RxBleClientImpl. There may be others that I haven't noticed. . Success? I'm hesitant to declare victory yet, but I just tried downloading the ZIP file and building the project from that, and it appears to have worked: v. 2 code is present, no errors. \nMysterious. . @uKL I would like to reopen this but apparently I can't since it was closed by you . Has anyone reported this to Jake? \nQuestion: It's my understanding that in RxJava2, sources aren't permitted to emit null. Does your solution violate this? \n. Half-baked idea: might it be possible to use the .retryWhen() operator to handle this situation? . I don't have time to work through it now (I'm still learning), but I think .retryWhen() might be able to handle this correctly. Took me quite a while just to figure out what it does, but it seems quite powerful. . I discussed this with Jake Wharton and he agrees there's a problem. He's mulling over the solution. . @streetsofboston Small point regarding your published fix: in the specific case of establishConnection(), since the resulting Observable never completes, it might be slightly clearer to replace doFinally() with doOnError(). . @streetsofboston Right, doFinally() covers those cases, too. . I touched base with Wharton recently and he said that he should soon have time to work on this. . OK, someone remind me why this isn't a good way to share a connection: \nObservable<RxBleConnection> sharedConnectionObservable = device.establishConnection( false )\n    .replay(1).refCount();\nand to use it: \nDisposable disp1 = sharedConnectionObservable.subscribe( ... ); \nDisposable disp2 = sharedConnectionObservable.subscribe( ... ); \netc. \nreplay(1) buffers the (sole) connection from upstream and re-emits it to new subscribers. refCount() kicks things off by connecting to the upstream, then maintains the connection as long as there is at least one subscriber. Presumably if establishConnection() signals an error (as when the connection is lost), it will be forwarded to all subscribers. And when the last subscriber disposes, the connection is ended. \nWhat am I missing? \n. @dariuszseweryn OK, I think I understand that, thanks. What about using the .cache() operator? Alternatively, use .replay(1) without .refCount() and make an explicit call to .connect() to get things started? (It's my understanding that a single .connect() invocation works for current and future subscribers.) If the last subscriber to .replay() disposes will the BLE connection be released? \nI don't mean to beat this to death but it seems like there must be some way of handling this common situation straightforwardly. . I took a stab at making a Java version. Please comment (in particular, is there a better exception type to use?): \npublic static Observable getBondedConnectionObservable( RxBleDevice device ) {\n        return Observable.defer( () -> {\n            if( device.getBluetoothDevice().createBond() ) {  // bonding will begin\n                return device.establishConnection( false );\n            } else {  // immediate error\n                return Observable.error( new IOException( \"Error initiating bonding of device \" + device.getName() ) );\n            }\n        });\n    }\n. @nateridderman Once again the \"pairing\" vs. \"bonding\" semantics confuse things. From everything I can determine, they are not the same thing, even though many people\u2014including Google in their official Android docs\u2014use the terms interchangeably. As explained fairly well here, pairing refers to a client-initiated exchange of security features, based on a temporary encryption key. Bonding means that these encryption keys are then remembered by the devices, so the next time they connect they can use those keys without exchanging any unsecured information. . I haven't delved deeply into this, but one problem could be that in v.2, discoverServices() returns a Single instead of an Observable, and the flatMap() operator for Single also returns a Single. You may need to use flatMapObservable() or some other function. HTH. . Comments: \n\n\nCan you explain why scanBleDevices() returns a cold Observable? Does this mean that a new subscriber receives the entire list of devices discovered since the scan began? \n\n\nI assume that all the items removed from the table for Rx2 have been converted into Singles and there is no need to further describe them? \n\n\nI'm having trouble parsing this where it says \"i.e.2\": \n\n\n\n** this Observable may complete i.e. observeStateChanges() does emit only a single value and finishes in exactly one situation \u2014 when Bluetooth Adapter is not available on the device. There is no reason to monitor other states as the adapter does not appear during runtime. i.e.2 Observables emitted from setupNotification / setupIndication may complete when the parent Observable is disposed.\n\nCould you clarify a bit? Are you meaning to say \"two Observables emitted\u2026\" . 1. My understanding is that a cold Observable emits the same set of items to every Subscriber. By contrast, a hot Observable \"joins the program in progress\" when a Subscriber subscribes. Is this wrong? It seems to me that subscribing to a scan would only deliver new ScanResults detected after the subscription. Does scanBleDevices() cache previous ScanResults and deliver them to new Subscribers. \n\n\"i.e.\" is used to clarify something by restating it in a different way. Examples are introduced with \"e.g.\". Your rewrite seems fine. [Interesting: in \"Write\" mode this item is numbered \"3\", but when I switch to \"Preview\" it is converted to \"2\".]. Thanks. I read the article, which seems to say that cold Observables are unicast, while hot ones may be multicast. This has been a source of some confusion to me: which Observables support multiple Subscribers? How can we identify them? Does scanBleDevices(), for example? Clearly its producer is activated at subscription; does this mean that multiple subscriptions create multiple instances of the scanner? Is this even possible? Is an error generated if you try to have multiple Subscribers? Could you use .share()? [sorry for too many questions]. Are you awaiting feedback from others? I'm OK with the update. . TBH I don't know enough about androidx to answer. My understanding is that most of the job consists of renaming packages, but I'm not sure. I just noticed that the work has apparently started on migrating Jake Wharton's RxBinding. . I was just reading about Google's Lifecycle-Aware Components and wonder if they might be applicable. Especially with regard to disposing subscriptions. . For those who may have dealt with this issue in the past and need catching up, Jake has updated RxReplayingShare so that any terminal event from upstream will cause the cached value to be nulled out. So, for example, if the RxBleConnection is lost, future subscribers won't be served a stale, invalid instance. . Wait\u2014ConnectionSharingAdapter is deprecated, right? (for reasons that were never clear to me). I thought you now recommend using RxReplayingShare instead. . As for the wiki, a concrete example of \"modeling the observable/operator chain correctly\" vs. sharing a connection would help this not-exactly-a-newcomer. . Thank you. And for us dummies, maybe mention which build.gradle to add this to? . NOTE: due to stateful nature of characteristics, if you call setupIndication() before setupNotification(). the notification will not be set up and will emit a BleCharacteristicNotificationOfOtherTypeAlreadySetException. \n",
    "tristandl": "~~Hi @RobLewis - i think pairing/bonding are the other way around - bonding is key exchange, pairing is saving keys~~. ",
    "maoueh": "We are currently using RxAndroidBle to flash the firmware of a device over the air. The firmware is about 300kb. Nice thing is that I also have a proof of concept app for the same flashing process using pure Android API.\nThese are not real experiments but simple rough estimate. Using RxAndroidBle, it takes up to 3 minutes to transfer everything as for native API, it's about 40s.\nThe big bottleneck in the library right now for heavy data transfer is that all write operations (in fact simply all operations) are done on the UI thread. This make the transfer process really longer than expected as it's fighting for the UI thread resources.\nWe noted a minimal 2x increase when just shutting down the screen of the device for example.\nI read in the code that you're doing this because Samsung 4.3 fails when connectGatt operation is not performed on the UI thread. Do you think it would be possible to make a conditional to only run the operations on the UI thread for a subset of all devices?  . If it can help others, here the code I use to do the split. I release this to public domain without restrictions. Use (and adapt) at your own risk (note this is a slightly modified version of the class I use in my own project):\nUsage:\nbleClient.establishConnection().flatMap(connection -> {\n  return new PacketWriter(connection).write(characteristic, bytes);\n});\n```\n// PacketWriter.java\npackage co.acme.ble;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.polidea.rxandroidble.RxBleConnection;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.UUID;\nimport rx.Observable;\npublic class PacketWriter {\nprivate static final int MAX_BLE_PACKET_BYTE_COUNT = 20;\nprivate RxBleConnection mBleConnection;\npublic PacketWriter(RxBleConnection bleConnection) {\n    mBleConnection = bleConnection;\n  }\n/*\n   * FIXME: Make this more efficient by keeping a 20 bytes buffer that is re-used for full packet send instead of\n   * copying to a new array over and over. We could even think about a specialized {@link Iterable} that would do the\n   * split and caching \"magically\" and we would simply need to iterate over it.\n   /\n  public Observable write(UUID characteristic, byte[] bytes) {\n    if (bytes == null || bytes.length <= 0) {\n      return Observable.just(null);\n    }\nreturn Observable.concat(computeWritePacketObservables(characteristic, bytes));\n\n}\n@VisibleForTesting\n  int computePacketCount(byte[] bytes) {\n    return (int) Math.ceil(bytes.length / (double) MAX_BLE_PACKET_BYTE_COUNT);\n  }\n@VisibleForTesting\n  List> computeWritePacketObservables(UUID characteristic, byte[] bytes) {\n    int packetCount = computePacketCount(bytes);\n    int lastPacketIndex = packetCount - 1;\nList<Observable<Void>> observables = new ArrayList<>();\nfor (int i = 0; i < packetCount; ++i) {\n  boolean isLastPacket = i == lastPacketIndex;\n\n  int dataStartIndexInclusive = i * 20;\n  int dataEndIndexInclusive = isLastPacket ? bytes.length : dataStartIndexInclusive + MAX_BLE_PACKET_BYTE_COUNT;\n\n  observables.add(writeToCharacteristic(characteristic, bytes, dataStartIndexInclusive, dataEndIndexInclusive));\n}\n\nreturn observables;\n\n}\nprivate Observable writeToCharacteristic(UUID characteristic,\n                                                 byte[] bytes,\n                                                 int startIndexInclusive,\n                                                 int endIndexExclusive) {\n    return Observable.fromCallable(() -> Arrays.copyOfRange(bytes, startIndexInclusive, endIndexExclusive))\n                     .flatMap(data -> {\n                       return mBleConnection.writeCharacteristic(characteristic, data);\n                     })\n                     .map(ignore -> null);\n  }\n}\n```\nAnd the test class I used:\n```\n// PacketWriterTest.java\npackage co.acme.ble;\nimport com.polidea.rxandroidble.RxBleConnection;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport rx.Observable;\nimport rx.Subscriber;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.BDDMockito.given;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.internal.verification.VerificationModeFactory.times;\npublic class PacketWriterTest {\n@Mock\n  RxBleConnection mBleConnection;\nprivate PacketWriter mPacketWriter;\n  private RecordingSubscriber mRecordingSubscriber = new RecordingSubscriber<>();\n@Before\n  public void setUp() {\n    MockitoAnnotations.initMocks(this);\ngiven(mBleConnection.writeCharacteristic(any(UUID.class),\n                                         any(byte[].class))).willReturn(Observable.just(new byte[]{}));\n\nmPacketWriter = new PacketWriter(mBleConnection);\n\n}\n@Test\n  public void testWriteSinglePacket() throws Exception {\n    writePacket(\"0102\");\nArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);\nverify(mBleConnection, times(1)).writeCharacteristic(any(UUID.class), captor.capture());\n\nassertThat(captor.getValue(), is(payload(\"0102\")));\n\n}\n@Test\n  public void testWriteSinglePacketFlush() throws Exception {\n    writePacket(\"0102030405060708091011121314151617181920\");\nArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);\nverify(mBleConnection, times(1)).writeCharacteristic(any(UUID.class), captor.capture());\n\nassertThat(captor.getValue(), is(payload(\"0102030405060708091011121314151617181920\")));\n\n}\n@Test\n  public void testWriteTwoPacket() throws Exception {\n    writePacket(\"010203040506070809101112131415161718192021222324252627282930\");\nArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);\nverify(mBleConnection, times(2)).writeCharacteristic(any(UUID.class), captor.capture());\n\nassertThat(captor.getAllValues().get(0), is(payload(\"0102030405060708091011121314151617181920\")));\nassertThat(captor.getAllValues().get(1), is(payload(\"21222324252627282930\")));\n\n}\n@Test\n  public void testWriteTwoPacketFlush() throws Exception {\n    writePacket(\"01020304050607080910111213141516171819200102030405060708091011121314151617181920\");\nArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);\nverify(mBleConnection, times(2)).writeCharacteristic(any(UUID.class), captor.capture());\n\nassertThat(captor.getAllValues().get(0), is(payload(\"0102030405060708091011121314151617181920\")));\nassertThat(captor.getAllValues().get(1), is(payload(\"0102030405060708091011121314151617181920\")));\n\n}\n@Test\n  public void testComputePacketCount() {\n    assertThat(mPacketWriter.computePacketCount(payload(\"01\")), is(1));\n    assertThat(mPacketWriter.computePacketCount(payload(\"01020304050607080910111213141516171819\")), is(1));\n    assertThat(mPacketWriter.computePacketCount(payload(\"0102030405060708091011121314151617181920\")), is(1));\nassertThat(mPacketWriter.computePacketCount(payload(\"010203040506070809101112131415161718192021\")), is(2));\nassertThat(mPacketWriter.computePacketCount(payload(\"0102030405060708091011121314151617181920\" +\n                                                    \"0102030405060708091011121314151617181920\")), is(2));\n\nassertThat(mPacketWriter.computePacketCount(payload(\"0102030405060708091011121314151617181920\" +\n                                                    \"010203040506070809101112131415161718192021\")), is(3));\n\n}\nprivate void writePacket(String hexadecimalValue) throws Exception {\n    mPacketWriter.write(UUID.randomUUID(), payload(hexadecimalValue)).toBlocking().subscribe(mRecordingSubscriber);\nif (mRecordingSubscriber.getOnErrorException() != null) {\n  throw (Exception) mRecordingSubscriber.getOnErrorException();\n}\n\n}\nprivate byte[] payload(String input) {\n    int length = input.length();\n    byte[] data = new byte[length / 2];\n    for (int i = 0; i < length; i += 2) {\n      data[i / 2] = (byte) ((Character.digit(input.charAt(i), 16) << 4) + Character.digit(input.charAt(i + 1), 16));\n    }\nreturn data;\n\n}\nprivate static class RecordingSubscriber extends Subscriber {\nprivate List<T> mEmittedElements = new ArrayList<>();\nprivate Throwable mOnErrorException;\nprivate boolean mIsCompletedCalled;\n\n@Override\npublic void onCompleted() {\n  mIsCompletedCalled = true;\n}\n\n@Override\npublic void onError(Throwable exception) {\n  mOnErrorException = exception;\n}\n\n@Override\npublic void onNext(T element) {\n  mEmittedElements.add(element);\n}\n\npublic List<T> getEmittedElements() {\n  return mEmittedElements;\n}\n\npublic T getFirstElement() {\n  return mEmittedElements.get(0);\n}\n\npublic Throwable getOnErrorException() {\n  return mOnErrorException;\n}\n\npublic boolean isCompletedCalled() {\n  return mIsCompletedCalled;\n}\n\n}\n}\n```\nGood luck.\nRegards,\nMatt\n. @DariuszAniszewski the delay is not used in \"production\", it's more when I have to debug stuff with the actual device.\nHere the core of the packet writer I usually use:\n```\nprivate Observable writeToCharacteristic(UUID characteristic,\n                                                 byte[] bytes,\n                                                 long delay,\n                                                 TimeUnit delayUnit,\n                                                 int startIndexInclusive,\n                                                 int endIndexExclusive) {\n    return Observable.fromCallable(() -> Arrays.copyOfRange(bytes, startIndexInclusive, endIndexExclusive))\n                     .flatMap(data -> {\n                       if (!Delay.isImmediate(delay) && startIndexInclusive == 0) {\n                         return Observable.timer(delay, delayUnit).map(ignore -> data);\n                       }\n                   return Observable.just(data);\n                 })\n                 .flatMap(data -> {\n                   Timber.d(\"Writing packetize data [%s] to NGMM device.\", Bytes.bytesToHex(data));\n\n                   return mBleConnection.writeCharacteristic(characteristic, data).doOnNext((result) -> {\n                     onPacketWritten(data);\n                   });\n                 })\n                 .map(ignore -> null);\n\n}\n```\nIn production code, the Delay.isImmediate(delay) is always true. So there is no delay usually, the \"delay\" is usually induced by the mBleConnection.writeCharacteristic(characteristic, data) observable onComplete event.\nThis is being tested on a LG G5 Android 7.0 phone. The receiving peripheral is backed by a Nordic nRF51822.\nI just tried adding a big delay (250ms and also 1s) just before each long operation:\nObservable.timer(250, TimeUnit.MILLISECONDS).flatMap(ignore -> {\n      return getBleConnection().getCharacteristic(characteristicUuid).flatMap(characteristic -> {\n        return getBleConnection().createNewLongWriteBuilder()\n                                 .setCharacteristic(characteristic)\n                                 .setMaxBatchSize(20)\n                                 .setBytes(bytes)\n                                 .build();\n      });\n    }).subscribe(ignore -> {\n    }, this::onError, this::onLineWritten);\nThe operation goes farther, I'm able to write about between 6 and 14 lines but at some point, operation hangs and transfer stops hitting the timeout exception.\nI know the transfer is happening since there is a LED blinking on the peripheral when transfer is in progress.\nJust not sure why the operation hangs like this.. I activated VERBOSE but the log was unchanged. There is only four occurrences of RxBleLog.v and none impact RxBleRadio. They are all in BleConnectionCompat class. \nI tried adding a delay (250ms and 1s), but this changed nothing. In fact, like mentioned, I make the whole process go a bit farther (between 4 an 14 lines) but it still hangs.\nDo you want me to add verbose statement somewhere in RxAndroidBLE code?. Nevermind, just understood that this is probably exactly what you wanted to check! Here the connect part of the log:\n02-13 14:08:59.577 21119-21119 D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(145097946)\n02-13 14:08:59.577 21119-23612 D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(145097946)\n02-13 14:08:59.579 21119-21119 V/RxBle#BleConnectionCompat: Connecting without reflection\n02-13 14:08:59.580 21119-21119 D/BluetoothGatt: connect() - device: C9:27:49:98:4B:E2, auto: false\n02-13 14:08:59.580 21119-21119 D/BluetoothGatt: registerApp()\n02-13 14:08:59.580 21119-21119 D/BluetoothGatt: registerApp() - UUID=36f37d3f-bd96-4b06-af12-6ce1a7f6ca5d\n02-13 14:08:59.582 21119-23617 D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n02-13 14:08:59.732 21119-23617 D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=C9:27:49:98:4B:E2\n02-13 14:08:59.735 21119-23617 D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n02-13 14:08:59.751 21119-23651 I/DeviceWrapper$OpenConnectionOnSubscribe: Connection to device [NAME (C9:27:49:98:4B:E2)] established, notifying subscriber about it.\n02-13 14:08:59.754 21119-23651 D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(188160369)\n02-13 14:08:59.760 21119-23612 D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(145097946)\n02-13 14:08:59.761 21119-23612 D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(188160369)\n02-13 14:08:59.763 21119-21119 D/BluetoothGatt: discoverServices() - device: C9:27:49:98:4B:E2\n02-13 14:08:59.782 21119-21131 D/BluetoothGatt: onSearchComplete() = Device=C9:27:49:98:4B:E2 Status=0\n02-13 14:08:59.782 21119-21131 D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n02-13 14:08:59.783 21119-23651 D/BluetoothGatt: setCharacteristicNotification() - uuid: b4520107-a308-4e56-8a52-536c2ad07147 enable: true\n02-13 14:08:59.787 21119-23651 D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(254820577)\n02-13 14:08:59.788 21119-23651 D/BluetoothGatt: setCharacteristicNotification() - uuid: b4520102-a308-4e56-8a52-536c2ad07147 enable: true\n02-13 14:08:59.795 21119-23651 D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(154966624)\n02-13 14:08:59.796 21119-23651 D/BluetoothGatt: setCharacteristicNotification() - uuid: b4520105-a308-4e56-8a52-536c2ad07147 enable: true\n02-13 14:08:59.800 21119-23651 D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(147424987)\n02-13 14:08:59.801 21119-23612 D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(188160369)\n02-13 14:08:59.801 21119-23612 D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(254820577)\n02-13 14:08:59.963 21119-21131 D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n02-13 14:08:59.967 21119-23612 D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(254820577)\n02-13 14:08:59.971 21119-23612 D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(154966624)\n02-13 14:09:00.156 21119-21135 D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n02-13 14:09:00.159 21119-23612 D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(154966624)\n02-13 14:09:00.159 21119-23612 D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(147424987)\n02-13 14:09:00.265 21119-21131 D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n02-13 14:09:00.270 21119-23612 D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(147424987)\n. I added the log and tried other kind of operation. The problem seems to happen way more frequently when a bunch of characteristic changed event arrives after the long write operation has started. Is it possible they are interfering with the way the library check if the characteristic was written correctly?\nTo add more context, here an overview of how of interact with the peripheral. We write some data to the peripheral and it responds through some notification. Here a different operation than flash that request some data from the device:\n02-13 14:48:40.955 17567-17567 D/StateMachine: Writing [AA01040BBB] to device.\n02-13 14:48:41.209 17567-18900 D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicLongWrite(253784101)\n02-13 14:48:41.211 17567-18663 D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicLongWrite(253784101)\n02-13 14:48:41.220 17567-17567 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [5 bytes] chunk to characteristic with success [true].\n02-13 14:48:41.221 17567-17582 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 14:48:41.256 17567-17582 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:41.262 17567-18786 V/StateMachine: Received notification data [AA060200BB].\n02-13 14:48:41.262 17567-18786 D/StateMachine: Processing complete packet [AA060200BB].\n02-13 14:48:41.264 17567-18786 D/StateMachine: Trying to transition from [START (0)] to [ACK_RECEIVED (1)].\n02-13 14:48:41.321 17567-17625 D/OpenGLRenderer: endAllActiveAnimators on 0x7d6baebc00 (MenuPopupWindow$MenuDropDownListView) with handle 0x7d6a11abc0\n02-13 14:48:41.911 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:41.912 17567-18786 V/StateMachine: Received notification data [AA3102FE04FFBB].\n02-13 14:48:41.913 17567-18786 D/StateMachine: Processing complete packet [AA3102FE04FFBB].\n02-13 14:48:41.931 17567-17581 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:41.932 17567-17581 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:41.933 17567-18786 V/StateMachine: Received notification data [AA3102FE046EF5040E024445492D424C45200000].\n02-13 14:48:41.934 17567-18786 V/StateMachine: Received notification data [0000BB].\n02-13 14:48:41.937 17567-18786 D/StateMachine: Processing complete packet [AA3102FE046EF5040E024445492D424C452000000000BB].\n02-13 14:48:42.064 17567-17582 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.070 17567-18786 V/StateMachine: Received notification data [AA3102FEDA1202000FBB].\n02-13 14:48:42.071 17567-17582 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.072 17567-18786 D/StateMachine: Processing complete packet [AA3102FEDA1202000FBB].\n02-13 14:48:42.074 17567-17582 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.074 17567-18786 V/StateMachine: Received notification data [AA3102FEFBFEB80F35F900B485101A5030CCCC2A].\n02-13 14:48:42.076 17567-18786 V/StateMachine: Received notification data [43AE5100000000BB].\n02-13 14:48:42.077 17567-18786 D/StateMachine: Processing complete packet [AA3102FEFBFEB80F35F900B485101A5030CCCC2A43AE5100000000BB].\n02-13 14:48:42.083 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.087 17567-18786 V/StateMachine: Received notification data [AA01023B00BB].\n02-13 14:48:42.088 17567-18786 D/StateMachine: Processing complete packet [AA01023B00BB].\n02-13 14:48:42.089 17567-18786 D/StateMachine: Trying to transition from [ACK_RECEIVED (1)] to [RESPONSE_RECEIVED (2)].\n02-13 14:48:42.090 17567-18786 D/StateMachine: Finishing with result [[B@77afbd].\n02-13 14:48:42.090 17567-18786 D/StateMachine: Emitting event [[B@77afbd].\n02-13 14:48:42.090 17567-18786 D/StateMachine: Unsubscribing from subscriber(s).\n02-13 14:48:42.910 17567-17582 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.928 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.932 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.936 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.938 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:42.962 17567-17581 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:48:45.815 17567-17584 D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 14:49:11.233 17567-18944 D/StateMachine: Finishing with error (Received onError without having requested it).\n02-13 14:49:11.233 17567-18663 D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicLongWrite(253784101)\nNote here that the data is written with success (WRITE_DATA) but the ACK never arrived. I validated that the log statements does print correctly when everything is working:\n02-13 14:53:42.016 17567-17567StateMachineD/OtherStateMachine: Writing [AA060103E80000BB] to device.\n02-13 14:53:42.271 17567-18900StateMachineD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicLongWrite(21173544)\n02-13 14:53:42.274 17567-18663StateMachineD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicLongWrite(21173544)\n02-13 14:53:42.287 17567-17567StateMachineD/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [8 bytes] chunk to characteristic with success [true].\n02-13 14:53:42.294 17567-17582StateMachineD/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 14:53:42.297 17567-18988StateMachineD/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 14:53:42.299 17567-18663StateMachineD/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicLongWrite(21173544). I added a log statement in writeResponseForMatchingCharacteristic.\nprivate Func1<ByteAssociation<UUID>, Boolean> writeResponseForMatchingCharacteristic() {\n        return new Func1<ByteAssociation<UUID>, Boolean>() {\n            @Override\n            public Boolean call(ByteAssociation<UUID> uuidByteAssociation) {\n                RxBleLog.d(\"MATCHING_CHAR: Checking if matching UUID [%s].\", uuidByteAssociation.first);\n                return uuidByteAssociation.first.equals(bluetoothGattCharacteristic.getUuid());\n            }\n        };\n    }\nWhen it's not working, even though the onCharacteristicWrite log appears, the writeResponseForMatchingCharacteristic matching function is not invoked somehow \nHere a log when not working:\n02-13 15:07:44.940 9074-11069D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicLongWrite(257835523)\n02-13 15:07:44.943 9074-10958D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicLongWrite(257835523)\n02-13 15:07:44.956 9074-9074D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [5 bytes] chunk to characteristic with success [true].\n02-13 15:07:44.956 9074-10982D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:07:44.987 9074-10982D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 15:07:44.988 9074-11032V/StateMachine: Received notification data [AA060200BB].\n02-13 15:07:44.989 9074-11032D/StateMachine: Processing complete packet [AA060200BB].\n02-13 15:07:44.989 9074-10982D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 15:07:44.990 9074-11032D/StateMachine: Trying to transition from [START (0)] to [ACK_RECEIVED (1)].\n02-13 15:07:44.991 9074-11032V/StateMachine: Received notification data [AA01023B00BB].\n02-13 15:07:44.992 9074-11032D/StateMachine: Processing complete packet [AA01023B00BB].\n02-13 15:07:44.993 9074-11032D/StateMachine: Trying to transition from [ACK_RECEIVED (1)] to [RESPONSE_RECEIVED (2)].\n02-13 15:07:44.994 9074-11032D/StateMachine: Finishing with result [[B@841ec62].\n02-13 15:07:44.996 9074-11032D/StateMachine: Emitting event [[B@841ec62].\n02-13 15:07:44.996 9074-11032D/StateMachine: Unsubscribing from subscriber(s).\n02-13 15:07:45.058 9074-9104D/OpenGLRenderer: endAllActiveAnimators on 0x7d6a1cfc00 (MenuPopupWindow$MenuDropDownListView) with handle 0x7d6ddff500\n02-13 15:08:14.949 9074-11084D/StateMachine: Finishing with error (Received onError without having requested it).\n02-13 15:08:14.952 9074-10958D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicLongWrite(257835523)\nAnd one when it works:\n02-13 15:07:37.149 9074-11069D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicLongWrite(202844953)\n02-13 15:07:37.150 9074-10958D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicLongWrite(202844953)\n02-13 15:07:37.153 9074-9074D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [5 bytes] chunk to characteristic with success [true].\n02-13 15:07:37.154 9074-9087D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:07:37.155 9074-11128D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR: Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n02-13 15:07:37.156 9074-11128D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 15:07:37.157 9074-10958D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicLongWrite(202844953)\n02-13 15:07:37.187 9074-9087D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=b4520102-a308-4e56-8a52-536c2ad07147\n02-13 15:07:37.188 9074-11032V/StateMachine: Received notification data [AA060200BB].\n02-13 15:07:37.188 9074-11032D/StateMachine: Processing complete packet [AA060200BB].. In fact, now that you talked about the observer not being notified, I think I might have hit a similar (same?) problem when I first did the \"flashing\" implementation. At first, what I tried to do was to \"subscribe\" multiple time to writeCharacteristic without never really waiting between \"write\" operation. \nMy idea was that this would fill the queue and the \"consumer\" thread (the one in RxBleRadioImpl) would slowly but steadily remove elements from the queue. However, the queue quickly (maybe after two or three writes) become stalled only queuing more and more operation without removing new entries.\nAt first I thought it was a problem with threading on my part and went with writing next chunk only previous one did answer. \nBut now that we talked about operation not being notified, I think that what happened at that time was the exact same problem as now. The notification was not making it's way to the observer (at that time the RxBleRadioOperationCharacteristicWrite). This was of course making the operation taking control of the \"consumer\" thread forever as there was no timeout on operation before. This was in return preventing the \"consumer\" thread from popping item from the queue.\nFeel free to ping me as I can easily reproduce the problem. I can try solution or give you some detailed log when working and when not working.\nThanks for looking into this.   . I think one of the problem (I say one, see below) is that RxBleGattCallback#bluetoothGattBehaviorSubject was not serialized causing it to fail when multiple thread were writing to it. I changed it to:\nprivate final SerializedSubject<BluetoothGatt, BluetoothGatt> bluetoothGattBehaviorSubject =\n            BehaviorSubject.<BluetoothGatt>create().toSerialized();\nAnd it did help since I now see all the ACK when onCharacteristicWrite is being notified. However, it still hangs at some point:\n02-13 15:46:54.609 16800-18734 D/FlashFirmwareStateMachine: Writing [AA06063A000000003C4D23343232C223304B802923304B10105CCBAB51EE8C05A6CDD6A0531246B6977D4B49808AE5A6F85A6016D4BFD1DF18A791D803E82330D765D789540F3DCA0B942F3A203D07D16540C306BE7C9C4783F1C3111D7DC9E6516873A4C71C6C876836B1A7E523341F9BEC86DFF644E407AE1963E37AAEF666C6E1DC87AF1C5381F17D0E8E2D9F4382CB1792C3077482233197E21EC36416E53281696CB520F25675F749AD7451326E919660F183C98A250B7E1F1A6D43F81D769481559EDC8FF87480918BFA316A42B969DE118FF1928AF88F7230571E8DE2626D233587A67660BE6EC45049B07BC9CEBC975E30518C8456137AA9B1372779BC2D5BCCBB89B5E3C6D07BBE743FD39C12F33EBB] to device.\n02-13 15:46:54.612 16800-18734 D/FlashFirmwareStateMachine: Emitting event [1 / 697 (0.14%)].\n02-13 15:46:54.863 16800-18768 D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicLongWrite(86038308)\n02-13 15:46:54.864 16800-18631 D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicLongWrite(86038308)\n02-13 15:46:54.868 16800-16800 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n02-13 15:46:54.870 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.871 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.872 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.874 16800-18736 D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR: Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n02-13 15:46:54.876 16800-18736 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 15:46:54.879 16800-16800 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n02-13 15:46:54.880 16800-16815 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.881 16800-16815 D/RxBle#BluetoothGatt: onCharacteristicWrite Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.883 16800-16815 D/RxBle#BluetoothGatt: onCharacteristicWrite Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.885 16800-18768 D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR: Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n02-13 15:46:54.886 16800-18768 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 15:46:54.890 16800-16800 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n02-13 15:46:54.892 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.893 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.894 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.897 16800-18736 D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR: Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n02-13 15:46:54.898 16800-18736 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 15:46:54.903 16800-16800 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n02-13 15:46:54.906 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.907 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.907 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.910 16800-18768 D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR: Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n02-13 15:46:54.911 16800-18768 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 15:46:54.923 16800-16800 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n02-13 15:46:54.923 16800-16815 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.924 16800-16815 D/RxBle#BluetoothGatt: onCharacteristicWrite Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.925 16800-16815 D/RxBle#BluetoothGatt: onCharacteristicWrite Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.926 16800-18736 D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR: Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n02-13 15:46:54.926 16800-18736 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n02-13 15:46:54.930 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.931 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.932 16800-16812 D/RxBle#BluetoothGatt: onCharacteristicWrite Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n02-13 15:46:54.932 16800-16800 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n02-13 15:47:24.932 16800-18631 D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicLongWrite(86038308)\n02-13 15:47:24.943 16800-18744 D/FlashFirmwareStateMachine: Finishing with error (Received onError without having requested it).\nI see the WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true]. but then never received a onCharacteristicWrite callback, weird.. I don't think it comes from the Android BLE stack. I think it's an event ordering problem. Let's check the last snippet of log more closely (lightly modified to make fit easier in the screen):\n15:46:54.926 18736 ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n15:46:54.930 16812 BluetootGatt: onCharacteristicWrite characteristic=<uuid> status=0\n15:46:54.932 16800 LongWriteOperation: WRITE_DATA: Wrote a [20 bytes] chunk to characteristic with success [true].\n15:47:24.932 18631 Radio: FINISHED RxBleRadioOperationCharacteristicLongWrite(86038308)\nHere, we see the last acknowledgement. Then, before WRITE_DATA has a chance to log, we see the onCharacteristicWrite callback being notified. Then 2ms later, we then see the actual WRITE_DATA log statement.\nSo, somehow, before the ACK checker has been set up correctly, the onCharacteristicWrite is already being notified. When the ACK checker is then ready to process event, the onCharacteristicWrite event has already been processed and thus, is missed.\nClearly some threading issue, not quite sure what is causing this however.. Here one log with batch sequence number. The INC_BATCH comes before the bluetoothGatt.writeCharacteristic(bluetoothGattCharacteristic) call while the WRITE_DATA comes after it.\nThe counter was added to RxBleGattCallback as a static AtomicInteger sCounter. It is incremented only between the two INC_BATCH log statements. Rest of logs are using the value currently set.\n08:24:59.604 8263-9045 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n 08:24:59.606 8263-8263 D/RxBle#RadioOperationCharacteristicLongWrite: INC_BATCH: Value before incrementing batch number is [22].\n 08:24:59.607 8263-8263 D/RxBle#RadioOperationCharacteristicLongWrite: INC_BATCH: Value after incrementing batch number is [23].\n 08:24:59.609 8263-8263 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA (23): Wrote a [20 bytes] chunk to characteristic with success [true].\n 08:24:59.611 8263-8276 D/RxBle#BluetoothGatt: onCharacteristicWrite (23) characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n 08:24:59.612 8263-8276 D/RxBle#BluetoothGatt: onCharacteristicWrite (23) Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n 08:24:59.612 8263-8276 D/RxBle#BluetoothGatt: onCharacteristicWrite (23) Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n 08:24:59.613 8263-9055 D/RxBle#RadioOperationCharacteristicLongWrite: MATCHING_CHAR (23): Checking if matching UUID [b4520101-a308-4e56-8a52-536c2ad07147].\n 08:24:59.615 8263-9055 D/RxBle#ActionObserver: ACKNOWLEDGE_LONG_CHUNK: Acknowledged!\n 08:24:59.616 8263-8263 D/RxBle#RadioOperationCharacteristicLongWrite: INC_BATCH: Value before incrementing batch number is [23].\n 08:24:59.617 8263-8263 D/RxBle#RadioOperationCharacteristicLongWrite: INC_BATCH: Value after incrementing batch number is [24].\n 08:24:59.621 8263-8275 D/RxBle#BluetoothGatt: onCharacteristicWrite (24) characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n 08:24:59.621 8263-8275 D/RxBle#BluetoothGatt: onCharacteristicWrite (24) Entering subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n 08:24:59.622 8263-8275 D/RxBle#BluetoothGatt: onCharacteristicWrite (24) Exiting subject characteristic=b4520101-a308-4e56-8a52-536c2ad07147 status=0\n 08:24:59.623 8263-8263 D/RxBle#RadioOperationCharacteristicLongWrite: WRITE_DATA (24): Wrote a [20 bytes] chunk to characteristic with success [true].\nIn last batch (i.e 24), we see that counter is incremented, the write characteristic is then called, but the onCharacteristicWrite is notified before the writeData function has finished yet.\nI will try the doAfterSubscribe, but I'm not sure it will solve the problem.. Well in fact, there is no doAfterSubscribe operator, so cannot use it.. @DariuszAniszewski I checked the subject change and I think you pick the wrong one. The one I think being called by multiple various thread is more likely the bluetoothGattBehaviorSubject which is used in all Gatt callbacks.\nOverall, I think all subject in this class should be reviewed as to where they are called by various different thread or not. If it's the case, they would need to be toSerialized also.. I agree, but as you know, they are not thread-safe. Not having rapid changes does not remove the chance that a race condition or dead clock happens in the subject, less likely if there are not much changes but quite possible.\nTo my eye, the bluetoothGattBehaviourSubject seems problematic as being called by all callbacks. That means that an onCharacteristicWrite and multiple onCharacteristicChanged happening rapidly in the same time window would call the bluetoothGattBehaviourSubject.onNext from various different thread which is an undefined behavior as of RxJava since subjects are not thread safe.\nThat's why I think this one (bluetoothGattBehaviourSubject) should be toSerialized to prevent problems when multiple stuff happens are the same time.\nI will test your branch and report.. Nop, it did not solve the issue (I changed a bit log statement since now we pinned point the problem):\n10:40:06.520 30341-30341 D/LongWriteOp: INC_COUNTER: Value just after increment is (10).\n 10:40:06.521 30341-30341 D/LongWriteOp: WRITE_DATA: Wrote value with counter (10).\n 10:40:06.522 30341-30459 D/BluetoothGatt: onCharacteristicWrite (10) characteristic=<uuid> status=0\n 10:40:06.524 30341-30341 D/LongWriteOp: INC_COUNTER: Value just after increment is (11).\n 10:40:06.526 30341-30459 D/BluetoothGatt: onCharacteristicWrite (11) characteristic=<uuid> status=0\n 10:40:06.526 30341-30341 D/LongWriteOp: WRITE_DATA: Wrote value with counter (11).. Yeah I know, I thought about using some replay or caching logic, so that the \"notification\" is held until it can be used, but they would probably prove problematic in some cases.\nTo work, we would need to cache event happening between just after the subscribe until they are processed ensuring no caching occurs outside the boundaries to avoid false positive.\nI tried a bit yesterday night but was not able to do so. I would need to dive deeper to understand at which moment stuff are being done.\n. That would probably work indeed, will test that later today and report.. It seemed it help as through various invocations, I never hit the event being out of order and execution goes farther (batch 109 was my best).  However, it still hang at some point, seems we are chasing multiple problems here :)\nLog:\n13:44:13.191 14397-14397D/LongWriteOp: INC_COUNTER: Value just after increment is (82).\n13:44:13.192 14397-14397D/LongWriteOp: WRITE_DATA: Wrote value with counter (82).\n13:44:13.193 14397-14409D/BluetoothGatt: onCharacteristicWrite (82) characteristic=<uuid> status=0\n13:44:13.194 14397-15081D/LongWriteOp: ACK_CHECK: Checking for characteristic (82).\n13:44:13.195 14397-15081D/LongWriteOp: ACK: Acknowledged (82)!\n13:44:13.196 14397-14397D/LongWriteOp: INC_COUNTER: Value just after increment is (83).\n13:44:13.199 14397-14397D/LongWriteOp: WRITE_DATA: Wrote value with counter (83).\n13:44:13.199 14397-14414D/BluetoothGatt: onCharacteristicWrite (83) characteristic=<uuid> status=0\nFor batch 83, even if the onCharacteristicWrite happens after the write data correctly, it seems the ACK_CHECK is not invoked as expected. \nI will need to dive deeper into Rx scheduler to understand what happen exactly. If you have ideas or want to try stuff, will be happy to check them out.. @dariuszseweryn Yup, that fixed the issue, good job! \nI also tested by removing our \"old\" fixes like the synchronized block and the serialized subject and they seems to be not required (I still think bluetoothGattBehaviourSubject should be made SerializedSubject, but that's another topic :)). \nSo, the code as in the repository right now seem to work correctly for my use case.\nOut of scope, but two questions while I have you.\nWould you guys accept a PR that would enable the library to execute radio operation out of the main thread? We have a fork where we execute off main thread for most phone (we kept main thread only when manufacturer is Samsung and Android version is 4.3)?\nWould you guys accept a PR that would enable to execute my own radio operation? The idea here would be to avoid going on & off of the RxRadio queue. The PR could look like:\nRxBleConnection {\n  <T> Observable<T> queue(Func3<Scheduler, BluetoothGatt, RxBleGattCallback, RxBleRadioOperation<T>> builder);\n}\nOf course, this a JavaDoc would explain that usage of the method should be made upon great care.\nAnyway, all in all, thanks for the great support! . @dariuszseweryn Ok good, I check the changes, don't see a reason for them not to work. But I will test the latest branch nonetheless.\nAs for the two questions, my use case is simply to optimize the flash firmware operation. With all optimizations in (scheduler off main thread, single operation in the queue), I was able to go from 140s in the worst case (heavy-lifted screen, balanced priority connection) to only 39s in my last try (high priority connection, scheduler off main thread, one operation in the queue).\nI will open two issues to keep discussion at the right place for them. I will provide my answer there.. @dariuszseweryn Copying your answer from a different thread (see here):\n\nI am a bit afraid that there may be more devices that are more stable while using the main thread than we know of. In this situation we would need to keep a list of devices that need a specific solution - which could be a burden.. I agree with that statement and I don't want to put to much burden on you guys about maintaining this list, mainly also because it means that we get aware of such problems when people report them.\n\nFrom our current tests on multiple different devices (nexus 4, nexus 5, LG g5, motorola, a Chinese phone, Samsung s3 mini, HTC tablet, another tablet I don't recall the model), we never had any issue running off the main thread yet. Note that we never tested on API 18 however, our lowest target was a Samsung S3 mini running API level 19.\nAn in-between could be to keep main thread only for API level 18 (or even more restricted).\nBut I understand it might difficult for you guys to maintain. As a first thing, you would guys allow a way for us, users of the library, to change the default scheduler? \nNot sure how it would look like, but if you agree, I would be happy to check some ways about doing this.. @dariuszseweryn When I first implemented the flashing, I did it in a debug screen that is doing little to no UI at all. Then, when I ported the code to the actual real UI screen, the performance was dramatically being impacted by I would say a 1.5x to 2x factor (going from 70s to around 130s depending on the run and device). \nIt was to such extend that we suggested to beta testers to actually close the phone screen when flashing to improve speed (no UI was giving the BLE operations almost full control of main thread).\nBut, indeed, a custom operation could resolve both of my issue. First, I would be able to schedule the operation off the main thread (doing it at my own risk) and also access lower level components for speed improvements.\nI will try to come up with some numbers once I integrated the changes we did last week into the project. At this point, I will test the impact of running the operation on & off the main thread (and only this change) and come up with some numbers for you.\nLike I say, the impact it not really important when we do minor operations (read & write a few characteristics). It was more painful when transferring lots of data and UI displaying some intensive graphics (progress, chart, etc.) . @dariuszseweryn On my side, since the addition of custom operations, I can do it on my own if needed. So for me, it's not relevant anymore.. @dariuszseweryn Copying your answer from another thread (see here):\n\nI see no particular reason to do it like this. I was thinking about just exposing the RxBleGattCallback and BluetoothGatt for direct usage for optimisation purposes.\nCould you elaborate more on your use-case? We would then also have material for internal discussions.. @dariuszseweryn No problem at all, hope you enjoyed them :)\n\nI will provide a PR for sure and we can discuss further at that point. I already have a branch with the change, but it build up on another one which is the move to choose a different scheduler than main thread which is more problematic. \nWill merge the two removing the main thread change and will send a PR for discussion.. @dariuszseweryn @uKL Ready for another round of review. I applied most discussed changes and added more tests.\nMost important is the rename from RxBleRadioOperationCustom#execute to RxBleRadioOperationCustom#asObservable. Tell me what you think about this.\nOnce we've settle everything down, before merging, I will do a last integration smoke test with the latest version.. Updated with latest comments. I'm going to test the PR in \"real situation\" really soon.. @dariuszseweryn @uKL Tested this branch (and long write along the way) in my app using an LG G5 (API 24) and a Samsung S4 Mini (API 19), both worked correctly and did not find any issue related to long write and custom operation.\nStill gathering numbers to show to you guys but it's taking more time as I'm being side-tracked by other things. So, I wanted to report back quickly at least that everything seems to be working great.\nI would like to provide a \"flash firmware\" custom operation snippet somehow, where do you propose me to put this?\nReady to merge from my perspective, thanks for all the help and great suggestions.. @lukasblue You need to return a valid Observable, simplest way is to use Observable.fromCallable(...):\n@NonNull\n@Override\npublic Observable<Void> asObservable(BluetoothGatt bluetoothGatt,\n                                     RxBleGattCallback rxBleGattCallback,\n                                     Scheduler scheduler) throws Throwable {\n    return Observable.fromCallable(() -> refreshDeviceCache(bluetoothGatt));\n}\nAt the moment asObservable is called, the library is not yet executing your operation. It simply want a way to do it later which is why you return an Observable, to defer execution.\nIn your previous code, you're refreshing when asObservable was called which is wrong. By using the construct above, the refresh is not perform when asObservable is called, it's being done later on when library decides it's now the first on the queue, meaning it's ready to execute.\n@dariuszseweryn Do you think we would need a simpler abstraction that would have a run and and who would implement asObservable as:\n@NonNull\n@Override\npublic Observable<Void> asObservable(BluetoothGatt bluetoothGatt,\n                                     RxBleGattCallback rxBleGattCallback,\n                                     Scheduler scheduler) throws Throwable {\n    return Observable.fromCallable(() -> run(...));\n}\n?. Was not sure what to do for this, should mock support custom operation?. This was done mainly so that custom operation can access the scheduler (via the builder). The LongWriteOperationBuilderImpl now also use RxBleRadio#scheduler instead of passing around AndroidSchedulers.mainThread().. I look at it a little but it seems hard to support it mainly because there is no BluetoothGatt nor RxBleGattCallback instances available that I could pass to custom operation.\nThis means we would need to some mock for them (which might be hard for BluetoothGatt) or pass null which would not exercise the custom operation.\nI think people should instead test them the way you guys do in the RxAndroidBLE code base.\nAs such, I would vote for throwing an exception, probably UnsupportedOperationException.. I'm all in for 1 and 2, I thought about passing them, but wasn't sure, will change.\nFor 3, do you see RxBleRadioOperationCustom as RxBleRadioOperationCustom extends RxBleRadioOperation or as a standalone class (would probably be an interface to me).\nI see it as this (I would like to come up with a better name than RxBleRadioOperationCustom however):\ninterface RxBleRadioOperationCustom<T> {\n        void execute(BluetoothGatt bluetoothGatt,\n                            RxBleGattCallback rxBleGattCallback,\n                            Scheduler scheduler,\n                            Observer<T> observerProxy,\n                            Action0 releaseRadioAction) {\n        } throws Exception\n    }\nThen the queue would adapt this interface to an RxBleRadioOperation:\n```\n    @Override\n    public  Observable queue(final RxBleRadioOperationCustom operation) {\n        return rxBleRadio.queue(new RxBleRadioOperation() {\n            @Override\n            protected void protectedRun() throws Throwable {\n                operation.execute(bluetoothGatt, gattCallback, rxBleRadio.scheduler(), asObserver(), new Action0() {\n                    @Override\n                    public void call() {\n                        releaseRadio();\n                    }\n                });\n            }\n        @Override\n        protected BleException provideException(DeadObjectException deadObjectException) {\n            return new BleDisconnectedException(deadObjectException, bluetoothGatt.getDevice().getAddress());\n        }\n    });\n}\n\n```\nThe gain I see here is that RxBleRadioOperation is not exposed to consumer of the library meaning you are still free to refactor it as you see fit. You only need to keep backward-compatibility on the RxBleRadioOperationCustom interface now.\nWhat do you think?\n. As for priority, what about:\n```\n     Observable queue(RxBleRadioOperationCustom operation);\n<T> Observable<T> queue(RxBleRadioOperationCustom<T> operation, RxBleRadioOperation.Priority priority);\n\n```\nWhere first version you defaults to NORMAL? Only drawback I see is that RxBleRadioOperation.Priority is kind of internal right now so, should I expose it publicly or keep it in internal package?\nThoughts?. Good, will do that.. @dariuszseweryn I think the Action0 releaseRadioAction is not needed anymore. Indeed, since I now control the RxBleRadioOperation class, we could release the radio once the operation has finished executed in a try/finally block:\n@Override\n            protected void protectedRun() throws Throwable {\n                try {\n                    operation.execute(bluetoothGatt, gattCallback, rxBleRadio.scheduler(), asObserver());\n                } finally {\n                    releaseRadio();\n                }\n            }\nThis seems even more fool-proof, what do you think?. > is not certain if other queued operations would not be executed while the custom operation is running\nHow come? If the releaseRadio is not called, no other queue operation can run. Unless I'm missing something, it's impossible to run other BLE operation while the custom one is running. It's the point of the queue, no?. Yep, I see what you mean now, I didn't think about this fact. Seems it's needed ... unless RxBleRadioOperationCustom#execute returns an Observable<T> where I could subscribe and know when it's finish. That would also remove the need for the Observer<T> variable.\nNot sure it's worth it however,  what do you think?. I updated the PR to show the Observable idea and I added an example of a custom operation in the sample project.\nNow that I think about it, not blocking the main thread might be a problem for people implementing custom operation. For example, let's assume my flashing firmware use case.\nIf I do flashFirmareObservable().subcribeOn(scheduler);, this will block the main thread for the whole flashing progress. To avoid this, I would need to at various interval to let a chance for the main thread to run something like:\n// The firmwareChunkWritters would be Observable<Observable<T>>\n  return firmwareChunkWritters().concatMap(writter -> writter.subscribeOn(scheduler));\nWe cannot do anything I guess except warning user in the RxBleRadioOperationCustom documentation and in the sample.\nAnyway, tell me what you think about the Observable approach. If you see a problem or you don't like it, will revert back to observerProxy/releasedAction way.. Sorry, should have warned you that I did not update everything because I didn't want to invest time updating everything if Observable<T> was \"rejected\". I will fix all issues.. This would be wrong IMO, I'm flashing a firmware, I don't want to have a maximum amount of time to perform the operation as the default timeout could not fit what I need to do. \nWe would need a rather larger timeout which would defeat the purpose.. Will do.. Ok. Yep, sure.. I was not very familiar with Spock and thought it was a way to do assertions, will remove.. Yeah, but it was already covered by another test case so I decided not to repeat. Will merge the two tests together I think.. Added + a sentence put emphasis on the fact the returned observable must complete.. The javadoc of both RxBleRadioOperationCustom#asObservable and RxBleConnection#queue (this is not pushed yet, I've just added it). I think it will be good now.. The previous thing was even more problematic as there was a double release bug and with the flatRadio.semaphore.isReleased() >> true, well it was not triggering correctly.\nThanks!\n. ",
    "fracturedpsyche": "Closing. Will re request after ensuring the code will pass.\n. The build appears to be failing because of an existing failing test.\n. No news. I have moved on from what I was doing with Android on to other things. Should I get back to evaluating RxAndroidBle I will dig more into it and provide an update. Thanks!\n. You are probably correct. I will make that change.\n. ",
    "ipodib": "Any updates on this item? It would be nice have binding devices feature built into library.. And what about functionality, that will automatically propose to pair device using pin number if it's required by device during connection (when invoking establishConnection)? For example how it's done from the Android's settings app. It's handled automatically there.. If I have a chance I will :) Since it's demand feature for me right now. \nThanks for update.. I figured out how we can bond device by prompting entering ping. Since RxBleDevice has a reference to BluetoothDevice we can simply call createBond() and Android will do everything else for us. \nReference:\nhttps://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#createBond(). I can't reproduce this issue. Everything works good for me. Small note, that I've checking for already bounded devices, and don't bond it when it's already bonded.. @uKL I'm not sure what do you mean. I have two different devices, in my case it's health devices (activity tracker and blood pressure). Each device has it's own service UUID. I want discover only those two devices. And when I specify those two service UUIDs it's not discovered at all.\nHope I answered to your question.. Thanks for information. First option may work for me for now. \nBut I keept debugging and found interesting thing in RxBleRadioOperationScan:\nif (!isFilterDefined || uuidUtil.extractUUIDs(scanRecord).containsAll(filterUuids)) {\n    RxBleRadioOperationScan.this.onNext(new RxBleInternalScanResult(device, rssi, scanRecord));\n}\nIt looks like uuidUtil.extractUUIDs(scanRecord).containsAll(filterUuids) always returns false in my case. Is that correct way of filtering devices? Or I'm looking in wrong direction?\n. Yes, sure. My filtering settings is:\n\"00001808-0000-1000-8000-00805f9b34fb\"\n\"00001810-0000-1000-8000-00805f9b34fb\"\nAnd device UUID device is:\n\"00001810-0000-1000-8000-00805f9b34fb\"\nI assume containsAll function that used in RxBleRadioOperationScan class will not work in this case.. Now I understand that feature. I was confused, so I assumed that it will discover all devices and make filtering automatically. Nevertheless I can achieve my goal by using RxJava's filter.\nThanks. . When 1.6.0 will be released, since fix that exist in 1.6.0 is critical for me, but I don't want to have SNAPSHOT version. Any thoughts? . ",
    "JohnnyJem": "According to Apple guidelines(which most devices should aim to fulfill):\n\"as explained in Apple\u2019s Bluetooth Accessory Design Guidelines. Instead, you should make sure to set the permissions as you want on your characteristics (see the usage of BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM() above), so that an error will be returned to the Central when it tries to do something that requires encryption. This error will then trigger most Central devices to automatically start bonding.\"\nBasically if you attempt to read a characteristic that requires \"authorization\" the device should return a \"ERROR_INSUFFICIENT_AUTHEN (0x41)\" error code that will prompt the android system to automatically begin bonding the device. As for the pin requirement:\nSee \nhttps://stackoverflow.com/questions/29204634/ios-bluetooth-ble-security-and-just-works-association-model\nfor a link to a table which explains the types of device configurations needed in order to have a pairing response needing \"passkey entry\" .. ",
    "Cierpliwy": "\nwhen the user will subscribe to .establishConnection() but there are other queued operations the library changes state for a particular RxBleDevice to CONNECTING even before the actual function BluetoothDevice.connectGatt() will be called.\n\nI don't like this behaviour at all. It is inconsistent with what is actually happening and it is a reason of a lot of edge cases which need to be handled. Every subscription is asynchronous by nature and I don't see any need to immediately apply CONNECTING state when .establishConnection() is called. Does it help with anything? User could do that by himself if he needs it? . For me it would be acceptable, but I would like to hear feedback from other developers.. Do we know which receiver is not registered? Previously there was a TAG.. Maybe we should document that this functions resets all log options to default values.. Describe in more detail that LogOptions are set to default values and actual log level is set to specified value.. Document merging behaviour?. if (RxBleLog.isAtLeast(LogConstants.INFO)) { ? \nWhy is this logOperation different then other ones (which are debug)?. RxBleLog.isAtLeast(LogConstants.DEBUG)?. This function should be defined in LoggerUtil?. I guess there should be documentation somewhere about default behaviour,. Why VERBOSE is assigned to it? I thought this was NONE/TRUNCATED/FULL option.. Similar to above comment at line 58.. Similar to above comment at line 58.. I think that set should be renamed to update or both functions should be available. I'm thinking only about setLogOptions methods.. Ok. That's fine.. It was misleading for me at the beginning. Initially, I thought that you could specify log level for each option (ex. truncated addresses are visible above Debug). I find it strange that these options are using values from Log.* pool.. Still not present?. ",
    "kenwdelong": "I think CONNECTING would best be when bleDevice.connectGatt() is called.  If I want to know when the library got the request, I can use doOnSubscribe(), can't I?\nFor DISCONNECTED, I'd like to get that after the disconnect radio operation finishes.  As noted, after RxBleRadioOperationDisconnect  would be fine.. Use of this method is discussed here: http://stackoverflow.com/questions/22596951/how-to-programmatically-force-bluetooth-low-energy-service-discovery-on-android\nBasically, some phones cache the list of services and characteristics between connections. So if the device has changed it's services or characteristics since you last connected, you can have fatal errors.  The refresh() method will clear the phone's cached list.\nBased on the code samples and how I understand that it works, I think refresh() would have to be called after connection but before service discovery starts.\nI just got bit by this this morning, connections are failing left and right.  Is there a way to get hold of the native BluetoothGatt so I can implement the fix described in the Stack Overflow until this feature can be implemented?. Yes!  Thank you!. For us, our device can be in normal \"application\" mode or in \"dfu\" (direct firmware upgrade) mode.  In dfu mode, the list of services and characteristics is a subset (generally) of what's available in application mode.  So, for example, if the device is scanned in dfu mode, and the phone caches the results of service discovery, then even if the device has returned to application mode it can't be accessed because the phone does not believe that the required characteristics exist (and vice versa).\nI really don't know when is the best time to refresh.  Just after connecting and before service discovery, or just before or after connecting.  I doubt that refreshing in the middle of the connection is a good idea.\nThe Nordic DFU Upgrade library, I think, disconnects but then before it releases the BluetoothGatt object it invokes the refresh() function.  That's probably a pretty safe option.. OK, thanks for the explanation.  I was afraid I was seeing things! :-). Does this mean that we should take care to always call RxAndroidBle on the MainThread, or is that something that you take care of, switching to MainThread inside the library if we use the wrong thread?. Sorry, but also, are the javadocs hosted anywhere?. Any suggestions on the best way to dig into this?  Logging is all the way up, but not much help.... No, I was not.  I put the cache clearing just after connecting, just before service discovery, and just before disconnecting.  In the first two cases, service discovery would hang.  In the last case, the error rate went way up for the subsequent connection.\nWe are using Nordic's DFU library for firmware upgrades.  I noticed in their code that they call this method after the upgrade completes (with comment noting that services and characteristics will be different after the DFU), so I tried clearing the cache just before doing a firmware upgrade.  That seems to have helped a lot.\nI have log levels all the way up but didn't see much useful.  I was going to see whether I could debug into it (although I suppose that would drastically change all timings), but ran out of time.  I suppose I could also look at the bluetooth hci log.  I'm not sure where else to look.. I was unable to solve it.  As noted above, I only clear the cache now just before a firmware upgrade, and that seems to be somewhat benign.  \nI wasn't sure how to debug further, except maybe the BLE HCI logs, but didn't have time for that.. Here is what I get on VERBOSE.  Service discovery just never returns.  We have a 15-second timeout in the app so customers don't hang; generally service discovery returns in 1-3 seconds without the cache clear operation.\n06-08 16:35:05.978 31163-31163/com.hatchbaby.rest.qa I/NightlightManager: [main] Created new nightlight, Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:05.978 31163-31163/com.hatchbaby.rest.qa I/NightlightManager: [main] NightlightManager.connect() to Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:05.980 31163-31163/com.hatchbaby.rest.qa I/Nightlight: [main] Nightlight.connect()\n06-08 16:35:05.992 31163-31163/com.hatchbaby.rest.qa I/SplashActivity: [main] Connecting to default nightlight: [C8:E3:82:B1:4D:9E]\n06-08 16:35:05.998 31163-31224/com.hatchbaby.rest.qa D/RxBle#Radio:   QUEUED RxBleRadioOperationScanApi21(115264771)\n06-08 16:35:05.998 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio:  STARTED RxBleRadioOperationScanApi21(115264771)\n06-08 16:35:06.001 31163-31163/com.hatchbaby.rest.qa I/BluetoothAdapter: getBluetoothLeScanner\n06-08 16:35:06.003 31163-31233/com.hatchbaby.rest.qa E/OpenGLRenderer: allen debug liyu Key: 5242945\n06-08 16:35:06.003 31163-31163/com.hatchbaby.rest.qa D/BluetoothAdapter: STATE_ON\n06-08 16:35:06.003 31163-31233/com.hatchbaby.rest.qa E/OpenGLRenderer: allen debug liyu Key: 34359738371\n06-08 16:35:06.022 31163-31178/com.hatchbaby.rest.qa D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5 mClientIf=0\n06-08 16:35:06.026 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio: FINISHED RxBleRadioOperationScanApi21(115264771)\n06-08 16:35:06.171 31163-31163/com.hatchbaby.rest.qa I/Nightlight: [main] Got state [RxBleConnectionState{DISCONNECTED}] in Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:06.171 31163-31163/com.hatchbaby.rest.qa I/Nightlight: [main] Scanned device\n06-08 16:35:06.174 31163-31163/com.hatchbaby.rest.qa I/Nightlight: [main] Got state [RxBleConnectionState{CONNECTING}] in Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:06.183 31163-31163/com.hatchbaby.rest.qa D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(156254365)\n06-08 16:35:06.184 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(156254365)\n06-08 16:35:06.189 31163-31163/com.hatchbaby.rest.qa V/RxBle#BleConnectionCompat: Connecting without reflection\n06-08 16:35:06.190 31163-31163/com.hatchbaby.rest.qa D/BluetoothGatt: connect() - device: C8:E3:82:B1:4D:9E, auto: false\n06-08 16:35:06.190 31163-31163/com.hatchbaby.rest.qa D/BluetoothGatt: registerApp()\n06-08 16:35:06.190 31163-31163/com.hatchbaby.rest.qa D/BluetoothGatt: registerApp() - UUID=a161ade6-480f-47d9-9861-43d0dd65c9b4\n06-08 16:35:06.200 31163-31177/com.hatchbaby.rest.qa D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n06-08 16:35:06.200 31163-31163/com.hatchbaby.rest.qa I/BluetoothAdapter: getBluetoothLeScanner\n06-08 16:35:06.205 31163-31163/com.hatchbaby.rest.qa D/BluetoothAdapter: STATE_ON\n06-08 16:35:06.575 31163-31178/com.hatchbaby.rest.qa D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=C8:E3:82:B1:4D:9E\n06-08 16:35:06.576 31163-31178/com.hatchbaby.rest.qa D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n06-08 16:35:06.591 31163-31279/com.hatchbaby.rest.qa I/Nightlight: [pool-2-thread-1] Got state [RxBleConnectionState{CONNECTED}] in Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:06.595 31163-31279/com.hatchbaby.rest.qa D/RxBle#Radio:   QUEUED (89878948)\n06-08 16:35:06.611 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(156254365)\n06-08 16:35:06.612 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio:  STARTED (89878948)\n06-08 16:35:06.629 31163-31163/com.hatchbaby.rest.qa D/BluetoothGatt: refresh() - device: C8:E3:82:B1:4D:9E\n06-08 16:35:06.632 31163-31163/com.hatchbaby.rest.qa I/GattCacheRefreshOperation: [main] Gatt cache refresh successful: [true]\n06-08 16:35:06.634 31163-31223/com.hatchbaby.rest.qa I/Nightlight: [RxIoScheduler-2] Starting service discovery (name is [Ken Batch 2])\n06-08 16:35:06.634 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio: FINISHED (89878948)\n06-08 16:35:06.640 31163-31288/com.hatchbaby.rest.qa D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(38437862)\n06-08 16:35:06.641 31163-31213/com.hatchbaby.rest.qa D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(38437862)\n06-08 16:35:06.648 31163-31163/com.hatchbaby.rest.qa D/BluetoothGatt: discoverServices() - device: C8:E3:82:B1:4D:9E\n06-08 16:35:20.995 31163-31269/com.hatchbaby.rest.qa W/NightlightManager: [RxComputationScheduler-4] Connection process failed! java.util.concurrent.TimeoutException\n06-08 16:35:20.995 31163-31269/com.hatchbaby.rest.qa I/NightlightManager: [RxComputationScheduler-4] NightlightManager.disconnect() for Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:20.996 31163-31269/com.hatchbaby.rest.qa D/NightlightManager: [RxComputationScheduler-4] Disconnecting from Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:20.996 31163-31269/com.hatchbaby.rest.qa I/Nightlight: [RxComputationScheduler-4] Disconnecting: Nightlight.disconnect()\n06-08 16:35:21.004 31163-31269/com.hatchbaby.rest.qa I/Nightlight: [RxComputationScheduler-4] Got state [RxBleConnectionState{DISCONNECTED}] in Nightlight{mName='Ken Batch 2', mMacAddress='C8:E3:82:B1:4D:9E', identity='9bb5505'}\n06-08 16:35:21.005 31163-31269/com.hatchbaby.rest.qa D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(58317343)\n06-08 16:35:21.009 31163-31269/com.hatchbaby.rest.qa I/Nightlight: [RxComputationScheduler-4] Nightlight state: RxBleConnectionState{DISCONNECTED}\n06-08 16:35:21.009 31163-31269/com.hatchbaby.rest.qa I/NightlightManager: [RxComputationScheduler-4] mDisconnectObservable set to null\n06-08 16:35:21.010 31163-31269/com.hatchbaby.rest.qa I/Nightlight: [RxComputationScheduler-4] Nightlight state: RxBleConnectionState{DISCONNECTED}. Wow.  That makes it work.  Without the delay, it reliably hangs.  With the delay, service discovery succeeds!. That was my plan for today!!  :-). I've integrated the SNAPSHOT build, and so far so good.  We'll do some more extensive testing tomorrow.\nBTW, why did you comment out setReportDelay() etc in ScanSettingsBuilder?. After a day of testing, so far everything is working fine.. Excellent, thanks!. @RobLewis  Rob, did you post this question on SO?  I am very interested in the answer as this fits my scenario as well.. Sorry, version 1.3.1. No, we were on 1.3.0.  I will upgrade immediately!. Also, we tried a workaround last night that worked:  we wrote the DFU Control Characteristic by using a RxBleRadioOperationCustom implementation like this:\npublic Observable<Void> asObservable(BluetoothGatt bluetoothGatt, RxBleGattCallback rxBleGattCallback, Scheduler scheduler) throws Throwable {\n\n    BluetoothGattService dfuControlSvc = bluetoothGatt.getService(UUID.fromString(Nightlight.Service.DFU_SERVICE));\n    if(dfuControlSvc != null) {\n        BluetoothGattCharacteristic dfuControlChar = dfuControlSvc.getCharacteristic(UUID.fromString(Nightlight.Characteristic.DFU_CONTROL));\n        if(dfuControlChar != null) {\n            dfuControlChar.setValue(new byte[] {0x01, 0x04});\n            boolean status = bluetoothGatt.writeCharacteristic(dfuControlChar);\n            Timber.i(\"Wrote bootloader start command: status [%b]\", status);\n            // No need to wait for callbacks or nothin', this kills the connection immediately\n        }\n        else {\n            Timber.w(\"No DFU Control Characteristic\");\n        }\n    }\n    else {\n        Timber.w(\"No DFU Control Service\");\n    }\n    return Observable.just(null);\n}\n\nUsing this method, the connection still dies a sudden death (because the device resets) but the RxBle#Radio queue continues to process requests correctly.. The bug is not there in 1.3.1, everything continues to work fine!\nSorry for the noise.. ",
    "nziyouren": "Hi @dariuszseweryn , sorry for the delay. I just use your sample code, nothing special. Device logs are below. I just remove some duplicate scan result logs\n08-14 21:23:25.810 6843-6843/? D/dalvikvm: Late-enabling CheckJNI\n08-14 21:23:25.870 6843-6843/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.bluetooth.BluetoothDevice.connectGatt, referenced from method com.polidea.rxandroidble.internal.util.BleConnectionCompat.connectGattCompat\n08-14 21:23:25.870 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve virtual method 263: Landroid/bluetooth/BluetoothDevice;.connectGatt (Landroid/content/Context;ZLandroid/bluetooth/BluetoothGattCallback;I)Landroid/bluetooth/BluetoothGatt;\n08-14 21:23:25.870 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x6e at 0x0011\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to find class referenced in signature (Landroid/view/SearchEvent;)\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.view.Window$Callback.onSearchRequested, referenced from method android.support.v7.view.WindowCallbackWrapper.onSearchRequested\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve interface method 18925: Landroid/view/Window$Callback;.onSearchRequested (Landroid/view/SearchEvent;)Z\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x72 at 0x0002\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.view.Window$Callback.onWindowStartingActionMode, referenced from method android.support.v7.view.WindowCallbackWrapper.onWindowStartingActionMode\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve interface method 18929: Landroid/view/Window$Callback;.onWindowStartingActionMode (Landroid/view/ActionMode$Callback;I)Landroid/view/ActionMode;\n08-14 21:23:25.910 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x72 at 0x0002\n08-14 21:23:25.950 6843-6843/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.content.res.TypedArray.getChangingConfigurations, referenced from method android.support.v7.widget.TintTypedArray.getChangingConfigurations\n08-14 21:23:25.950 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve virtual method 497: Landroid/content/res/TypedArray;.getChangingConfigurations ()I\n08-14 21:23:25.950 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x6e at 0x0002\n08-14 21:23:25.950 6843-6843/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.content.res.TypedArray.getType, referenced from method android.support.v7.widget.TintTypedArray.getType\n08-14 21:23:25.950 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve virtual method 519: Landroid/content/res/TypedArray;.getType (I)I\n08-14 21:23:25.950 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x6e at 0x0002\n08-14 21:23:26.050 6843-6843/com.polidea.rxandroidble.sample D/OpenGLRenderer: Enabling debug mode 0\n08-14 21:23:41.590 6843-6843/com.polidea.rxandroidble.sample E/BleCenterManager: >>>>>>actual do scan>>>>>>\n08-14 21:23:41.610 6843-6843/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(1101803368)\n08-14 21:23:41.610 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationScan(1101803368)\n08-14 21:23:41.610 6843-6843/com.polidea.rxandroidble.sample D/BluetoothAdapter: startLeScan(): null\n08-14 21:23:41.640 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onClientRegistered() - status=0 clientIf=4\n08-14 21:23:41.640 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationScan(1101803368)\n08-14 21:24:02.320 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.350 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.380 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:02.420 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.450 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:02.480 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:02.510 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:02.530 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.570 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.600 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-69\n08-14 21:24:02.630 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.650 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:02.680 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:02.740 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:02.770 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:02.800 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:02.880 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:02.910 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:02.940 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:02.970 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.000 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.030 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.070 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.090 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.120 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.150 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.190 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.210 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.250 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.270 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.310 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.340 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.360 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.390 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.420 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.450 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.480 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.510 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.540 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.570 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.600 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.630 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.690 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.730 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.760 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.790 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.820 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:03.850 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.880 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:03.910 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.940 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:03.970 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.030 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.060 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.150 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.170 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.210 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:04.240 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:04.270 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.300 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.330 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.370 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.400 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.420 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.450 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.480 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.510 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.540 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.570 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.600 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.630 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.650 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.680 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.710 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.740 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.770 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.800 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.820 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.850 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:04.880 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:04.940 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:04.970 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.000 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.030 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.060 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.090 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.120 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:05.140 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.180 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.210 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.230 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.320 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.350 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.410 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.440 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.480 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.510 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:05.540 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.570 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:05.600 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.630 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:05.670 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.690 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:05.720 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:05.790 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:05.850 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-73\n08-14 21:24:05.870 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:05.960 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-78\n08-14 21:24:05.990 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-77\n08-14 21:24:06.050 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-74\n08-14 21:24:06.080 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-74\n08-14 21:24:06.120 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-74\n08-14 21:24:06.150 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.180 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.200 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.230 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.260 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-74\n08-14 21:24:06.300 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-74\n08-14 21:24:06.390 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.420 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.440 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.480 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.510 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.550 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.570 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-76\n08-14 21:24:06.600 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.690 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.720 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.750 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:06.780 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-71\n08-14 21:24:06.810 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-76\n08-14 21:24:06.860 6843-6857/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-75\n08-14 21:24:06.870 6843-6843/com.polidea.rxandroidble.sample I/dalvikvm: Could not find method android.bluetooth.BluetoothGattCallback.onMtuChanged, referenced from method com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onMtuChanged\n08-14 21:24:06.870 6843-6843/com.polidea.rxandroidble.sample W/dalvikvm: VFY: unable to resolve virtual method 286: Landroid/bluetooth/BluetoothGattCallback;.onMtuChanged (Landroid/bluetooth/BluetoothGatt;II)V\n08-14 21:24:06.870 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: VFY: replacing opcode 0x6f at 0x0016\n08-14 21:24:06.880 6843-6843/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(1103167440)\n08-14 21:24:06.900 6843-6843/com.polidea.rxandroidble.sample D/dalvikvm: GC_FOR_ALLOC freed 1382K, 39% free 3646K/5924K, paused 17ms, total 17ms\n08-14 21:24:06.900 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(1103167440)\n08-14 21:24:06.900 6843-6858/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.900 6843-6843/com.polidea.rxandroidble.sample E/ScanActivity2: onDeviceStateChange SCGM5000_1503005103 state: BLE_DEVICE_STATE_DISCONNECTED\n08-14 21:24:06.900 6843-6843/com.polidea.rxandroidble.sample E/ScanActivity2: onDeviceStateChange SCGM5000_1503005103 state: BLE_DEVICE_STATE_CONNECTING\n08-14 21:24:06.910 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: connect() - device: DE:5F:D1:B2:CB:5C, auto: true\n08-14 21:24:06.910 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp()\n08-14 21:24:06.910 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onScanResult() - Device=DE:5F:D1:B2:CB:5C RSSI=-70\n08-14 21:24:06.910 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: registerApp() - UUID=60da4738-29d0-4b54-be17-2370a61d2e9c\n08-14 21:24:06.920 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n08-14 21:24:06.920 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(1103167440)\n08-14 21:24:06.950 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=DE:5F:D1:B2:CB:5C\n08-14 21:24:06.950 6843-6858/com.polidea.rxandroidble.sample E/RxBleGattCallback: onConnectionStateChange newState=2 status=0\n08-14 21:24:06.950 6843-6858/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n08-14 21:24:06.950 6843-6843/com.polidea.rxandroidble.sample E/ScanActivity2: onDeviceStateChange SCGM5000_1503005103 state: BLE_DEVICE_STATE_CONNECTED\n08-14 21:24:06.950 6843-8022/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(1102035064)\n08-14 21:24:06.950 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(1102035064)\n08-14 21:24:06.980 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: discoverServices() - device: DE:5F:D1:B2:CB:5C\n08-14 21:24:07.450 6843-6843/com.polidea.rxandroidble.sample E/BleCenterManager: >>>>>>actual stop scan>>>>>>\n08-14 21:24:07.450 6843-6843/com.polidea.rxandroidble.sample D/BluetoothAdapter: stopLeScan()\n08-14 21:24:10.060 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetService() - Device=DE:5F:D1:B2:CB:5C UUID=00001800-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.070 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetService() - Device=DE:5F:D1:B2:CB:5C UUID=00001801-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.070 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetService() - Device=DE:5F:D1:B2:CB:5C UUID=00001808-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.070 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetService() - Device=DE:5F:D1:B2:CB:5C UUID=00001e1e-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.080 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetService() - Device=DE:5F:D1:B2:CB:5C UUID=0000180a-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.080 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetService() - Device=DE:5F:D1:B2:CB:5C UUID=00001530-1212-efde-1523-785feabcd123\n08-14 21:24:10.080 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a00-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.080 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a01-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.080 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a04-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.080 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a18-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.080 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a34-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a51-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a52-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002d2d-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002e2e-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a29-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a24-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a27-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00002a26-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00001532-1212-efde-1523-785feabcd123\n08-14 21:24:10.090 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetCharacteristic() - Device=DE:5F:D1:B2:CB:5C UUID=00001531-1212-efde-1523-785feabcd123\n08-14 21:24:10.090 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetDescriptor() - Device=DE:5F:D1:B2:CB:5C UUID=00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetDescriptor() - Device=DE:5F:D1:B2:CB:5C UUID=00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.090 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetDescriptor() - Device=DE:5F:D1:B2:CB:5C UUID=00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.100 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetDescriptor() - Device=DE:5F:D1:B2:CB:5C UUID=00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.100 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onGetDescriptor() - Device=DE:5F:D1:B2:CB:5C UUID=00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.100 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onSearchComplete() = Device=DE:5F:D1:B2:CB:5C Status=0\n08-14 21:24:10.100 6843-6858/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n08-14 21:24:10.100 6843-8092/com.polidea.rxandroidble.sample D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a18-0000-1000-8000-00805f9b34fb enable: true\n08-14 21:24:10.100 6843-8092/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(1101743040)\n08-14 21:24:10.110 6843-8092/com.polidea.rxandroidble.sample D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a34-0000-1000-8000-00805f9b34fb enable: true\n08-14 21:24:10.110 6843-8092/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(1101590080)\n08-14 21:24:10.110 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(1102035064)\n08-14 21:24:10.110 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(1101743040)\n08-14 21:24:10.110 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: writeDescriptor() - uuid: 00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.210 6843-6892/com.polidea.rxandroidble.sample D/BluetoothGatt: onDescriptorWrite() - Device=DE:5F:D1:B2:CB:5C UUID=00002a18-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.210 6843-6892/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n08-14 21:24:10.220 6843-8098/com.polidea.rxandroidble.sample E/ScanActivity2: onInteractUpdate SCGM5000_1503005103 step: enableNotification 00002a18-0000-1000-8000-00805f9b34fb complete\n08-14 21:24:10.220 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(1101743040)\n08-14 21:24:10.220 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(1101590080)\n08-14 21:24:10.230 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: writeDescriptor() - uuid: 00002902-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.300 6843-6857/com.polidea.rxandroidble.sample D/BluetoothGatt: onDescriptorWrite() - Device=DE:5F:D1:B2:CB:5C UUID=00002a34-0000-1000-8000-00805f9b34fb\n08-14 21:24:10.310 6843-6857/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n08-14 21:24:10.320 6843-8100/com.polidea.rxandroidble.sample E/ScanActivity2: onInteractUpdate SCGM5000_1503005103 step: enableNotification 00002a34-0000-1000-8000-00805f9b34fb complete\n08-14 21:24:10.320 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(1101590080)\n08-14 21:25:37.420 6843-6858/com.polidea.rxandroidble.sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=DE:5F:D1:B2:CB:5C\n08-14 21:25:37.420 6843-6858/com.polidea.rxandroidble.sample E/RxBleGattCallback: onConnectionStateChange newState=0 status=0\n08-14 21:25:37.420 6843-6858/com.polidea.rxandroidble.sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n08-14 21:25:37.430 6843-6843/com.polidea.rxandroidble.sample E/SybercareMagicGlucoseDeviceAdapter: 00002a34 throwable: null\n08-14 21:25:37.430 6843-6843/com.polidea.rxandroidble.sample E/ScanActivity2: onDeviceStateChange SCGM5000_1503005103 state: BLE_DEVICE_STATE_DISCONNECTED\n08-14 21:25:37.430 6843-9432/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(1103171232)\n08-14 21:25:37.440 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(1103171232)\n08-14 21:25:37.440 6843-9432/com.polidea.rxandroidble.sample D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a18-0000-1000-8000-00805f9b34fb enable: false\n08-14 21:25:37.440 6843-9432/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(1103172768)\n08-14 21:25:37.440 6843-9432/com.polidea.rxandroidble.sample D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a34-0000-1000-8000-00805f9b34fb enable: false\n08-14 21:25:37.450 6843-9432/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(1102607936)\n08-14 21:25:37.460 6843-6843/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectionState()\n08-14 21:25:37.460 6843-6843/com.polidea.rxandroidble.sample D/BluetoothManager: getConnectedDevices\n08-14 21:25:37.470 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: close()\n08-14 21:25:37.470 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: unregisterApp() - mClientIf=5\n08-14 21:25:37.470 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(1103171232)\n08-14 21:25:37.470 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(1103172768)\n08-14 21:25:37.470 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: writeDescriptor() - uuid: 00002902-0000-1000-8000-00805f9b34fb\n08-14 21:25:37.470 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(1103172768)\n08-14 21:25:37.470 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(1102607936)\n08-14 21:25:37.470 6843-6843/com.polidea.rxandroidble.sample D/BluetoothGatt: writeDescriptor() - uuid: 00002902-0000-1000-8000-00805f9b34fb\n08-14 21:25:37.470 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(1102607936)\n08-14 21:25:37.930 6843-6843/com.polidea.rxandroidble.sample E/BleCenterManager: >>>>>>actual do scan>>>>>>\n08-14 21:25:37.940 6843-6843/com.polidea.rxandroidble.sample D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(1102461472)\n08-14 21:25:37.950 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio:  STARTED RxBleRadioOperationScan(1102461472)\n08-14 21:25:37.950 6843-6843/com.polidea.rxandroidble.sample D/BluetoothAdapter: startLeScan(): null\n08-14 21:25:37.950 6843-6892/com.polidea.rxandroidble.sample D/BluetoothAdapter: onClientRegistered() - status=0 clientIf=4\n08-14 21:25:37.960 6843-6884/com.polidea.rxandroidble.sample D/RxBle#Radio: FINISHED RxBleRadioOperationScan(1102461472)\n. @dariuszseweryn no, after turn on glucose meter again, it advertises. But my device can not find it. While another phone can find glucose meter in scan result. Maybe it is a bug of my phone, but I want to solve it in an elegant way while using your library.\n. @dariuszseweryn \nFirst of all, thank you all guys for this great library. I used it in my product. It saves me a lot of time.\nWhy I add this function in library, I have some reasons:\n1.  When I send long data, peripheral device can only receive part data. The essential reason is that , mobile phone drops some data, doesn't send it out,  even if GATT callback method: public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) reports it writes all data successfully. So the problem is mobile phone side, not on the peripheral. We have proved it with USB dongle and ble sniffer tool.\n\nApplication code and RXAndroidBle library are just like producer and consumer, application call writeCharacteristic() to produce send data actions and library consumers these write actions and execute them one by one. So I think the right solution is : control the consumer speed in this situation.\nlibrary execute write data->wait a little time-> release semaphore->execute next write data.\nIn my opinion, if add this function into library, it would save developers some time. He can set the delay time according to the device. If I'm wrong, please correct me. \n\nHere are part of my code in my library, I control the producer speed,  just as you said: add RxBleConnection.writeCharacteristic().delay(long, TimeUnit), but it doesn't work. But if I used the method in commits, it works\n@Override\npublic void writeCharacteristic(UUID uuid, byte[] data, BleStep step){\n    mRxBleConnection.writeCharacteristic(uuid,data)\n            .delay(50, TimeUnit.MILLISECONDS) //add here useless\n            .observeOn(AndroidSchedulers.mainThread())\n            .doOnNext(bytes -> notifyInteractUpdate(mBleDevice,new BleStep(\"Begin step \"+step.action,step.rawData,step.data)))\n            .subscribe(bytes -> notifyInteractUpdate(mBleDevice,new BleStep(\"Step \"+step.action+\" complete\",step.rawData,step.data))\n                    ,throwable -> notifyInteractError(mBleDevice,throwable,step));\n\n}\n\n@Override\npublic void writeCharacteristic(UUID uuid, byte[] data){\n    mRxBleConnection.writeCharacteristic(uuid,data)\n            .delay(50, TimeUnit.MILLISECONDS) //add here useless\n            .observeOn(AndroidSchedulers.mainThread())\n            .doOnNext(bytes -> notifyInteractUpdate(mBleDevice,new BleStep(\"Begin write data to UUID :\"+uuid.toString())))\n            .subscribe(bytes -> notifyInteractUpdate(mBleDevice,new BleStep(String.format(\"Step write data to UUID: %s complete\",uuid.toString())))\n                    ,throwable -> notifyInteractError(mBleDevice,throwable,new BleStep(String.format(\"Step write data to UUID: %s error\",uuid.toString()))));\n\n}\n\n. @dariuszseweryn \nSorry for the delay, I was busy on project. By the way, I'm new to rxjava. Thanks for your chunkify rxjava code. I use it in my project, it works .I agreen with you , it is more reasonable to add delay to application layer. Wish I can contribute some real valuable code to your project later.. ",
    "kexuejin": "I have same problem,i found it's have problem when turn off the device,then try to connect it,when we start scan ble, it's will scan noting.If exit app,the gatt not close immediately.When gatt closed,the scan will worked.\n. By the way,if device is try to connect, \nat the same time  to start scan(scanBleDevices),the scan will return nothing until device gatt close,please help me.\n. Thank you very much!\n. Maybe, but i don't want to reverting to rxjava version...\n. ",
    "s1155030742": "This refresh is essential for any kind of function that involve change of characteristic during reconnection. I believe the framework can be much more powerful if \"refresh\" is supported. ",
    "Rioner123": "Hi all, just ran into this problem now! The bluetooth connection on my device disables and I cannot re-enable it unless I flush the data/cache of the bluetooth process. The only way to do this is to call BluetoothGatt.refresh(); \nProblem 1. Bluetooth is currently disabled and I need to be able to run the refresh method first (because I don't have a valid connection)\nRegarding best scenario for calling BluetoothGatt.refresh(), I would personally prefer at the beginning of the connection.\nReasoning: It's the only predictable place where I can reliably call it. \n. ",
    "Maple-Ro": "Thank you very much!\nwith your guides, I get the answer, more detail see this https://stackoverflow.com/questions/49921894/write-notification-handling-with-rxandroidble?noredirect=1&lq=1\nhelp this is useful for somebody else. ",
    "s0nerik": "Hey guys, I suddenly found that reverting the RxJava version to 1.1.7 (previously was 1.1.9) seems to help with this problem. I'm gonna assume there were some changes in the way Subjects work in the later versions that made the library behave strangely.\n. ",
    "lkjh654": "Hi,\nthanks for the prompt response. I've been trying to connect for dozens of minutes without success.\nThe thing is that autoConnect flag works perfectly fine on the same device when:\n- using android-BluetoothLeGatt sample from Google\n- reflection based method in the library is replaced with the regular API\nI know this issue is weird especially because:\n- it happens only on one device among many I have used\n- the reflection based implementation seems to be identical to the inner Android implementation\nAnyways I've changed my app implementation so that autoConnect=false but still it would be cool if you could address the last part of my comment regarding why the reflection based workaround is used in the first place and which Android versions / devices are affected.\nthanks.\n. ",
    "wickedpygmy": "Reflection workaround is used to fix this bug: \nhttps://code.google.com/p/android/issues/detail?id=69834\nWhich affects the majority of Android devices, as it has only been fixed very recently. \n. ",
    "WIStudent": "Some additional infos: I am using a Nexus 5X with Android 6.0.1\n. I am not sure if I applied your changes correctly, but it seams that BluetoothGatt is still not closed\n09-08 19:48:18.962 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(25496177)\n09-08 19:48:18.966 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(116164036)\n09-08 19:48:18.970 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(254716787)\n09-08 19:48:18.972 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(1233966)\n09-08 19:48:18.974 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(43775077)\n09-08 19:48:18.976 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(202579784)\n09-08 19:48:18.978 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(27928007)\n09-08 19:48:18.981 26825-27052/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(171573650)\n09-08 19:48:18.982 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(266080148)\n09-08 19:48:18.984 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(25496177)\n09-08 19:48:19.039 26825-26869/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=12345678-1234-5678-1234-56789abc0000 status=1\n09-08 19:48:19.049 26825-26869/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(176898444)\n09-08 19:48:19.051 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(25496177)\n09-08 19:48:19.053 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(116164036)\n09-08 19:48:19.068 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.082 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.085 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(116164036)\n09-08 19:48:19.086 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(254716787)\n09-08 19:48:19.163 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.165 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(254716787)\n09-08 19:48:19.166 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(1233966)\n09-08 19:48:19.220 26825-26869/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=12345678-1234-5678-1234-56789abc0001 status=1\n09-08 19:48:19.259 26825-27055/de.tobiastrumm.bluetoothledmatrix V/RenderScript: 0x7f9611b000 Launching thread(s), CPUs 6\n09-08 19:48:19.294 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.296 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(1233966)\n09-08 19:48:19.297 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(43775077)\n09-08 19:48:19.315 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.317 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(43775077)\n09-08 19:48:19.318 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(202579784)\n09-08 19:48:19.326 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.327 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(202579784)\n09-08 19:48:19.328 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(27928007)\n09-08 19:48:19.342 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.344 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(27928007)\n09-08 19:48:19.345 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(171573650)\n09-08 19:48:19.353 26825-26851/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=12345678-1234-5678-1234-56789abc0003 status=1\n09-08 19:48:19.358 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.360 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(171573650)\n09-08 19:48:19.361 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(176898444)\n09-08 19:48:19.375 26825-26825/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:27)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:356)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:249)\n                                                                                           at android.os.Binder.execTransact(Binder.java:453)\n09-08 19:48:19.376 26825-26825/de.tobiastrumm.bluetoothledmatrix D/BluetoothManager: getConnectionState()\n09-08 19:48:19.377 26825-26825/de.tobiastrumm.bluetoothledmatrix D/BluetoothManager: getConnectedDevices\n09-08 19:48:19.379 26825-26825/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: cancelOpen() - device: B8:27:EB:A7:1B:9D\n09-08 19:48:19.382 26825-27049/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(176898444)\n09-08 19:48:19.385 26825-26837/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=B8:27:EB:A7:1B:9D\n09-08 19:48:19.386 26825-26837/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\nActually I am starting to belive that this isn't an issue with RxAndroidBle but with Android itself. I originally assumed that closing BluetoothGatt would clear the cache that holds the mapping between characteristic UUIDs and handles. I did some more tests and noticed that the following scenario still causes CHARACTERISTIC_READ errors despite closing BluetoothGatt:\n1. GATT service is created on the peripheral\n2. App connects to the peripheral\n3. App reads from/writes to characteristics\n4. App unsubscribes from connectionObervable -> Device disconnects, BluetoothGatt is closed\n5. On the peripheral the service is removed and added again. This causes the characteristics' handles to change\n6. The app connects to the peripheral again\n7. The app tries to read from a characteristic -> BleGattException(status=1, CHARACTERISTIC_READ), the device is disconnected, BluetoothGatt is not closed\nI did some research and found this issue: Android does not discover services if device supports Service Changed. It seams that Android assumes that handles won't change, even if the peripheral includes the \"service changed\" characteristic. This also explains why the issue is solved by disabling and re-enabling bluetooth on the Android device. \nFor me personally this isn't a big issue because all I wanted to do was to experiment with BLE and to control some LEDs with it. I just have to make sure that the handles don't change while I am using it, or I have to restart bluetooth on my Android device.\nBut if you want to look further into the issue of changing handles, I put the code that uses BlueZ to create the peripheral and the code for the app on Github a few days ago.\nhttps://github.com/WIStudent/Bluetooth-Low-Energy-LED-Matrix\nhttps://github.com/WIStudent/Bluetooth-LED-Matrix-App\n. I moved on to a different project so I can't test it at the moment.\n. I highly recommend updating Bluez to the latest version (which is currently 5.43) . Some of its BLE features are quite new and might not be impemented in an older version. I used this tutorial to compile and install Bluez from source on a Raspberry Pi. It should only take a few minutes. \nIf you don't want to update, you need to set at least the --experimental flag in the bluez service configuration in order to access the missing dbus interfaces. The process is described at the end of the tutorial. \nIf you have still issues accessing the dbus interfaces after that, make sure that you have the packages python-gi, python3-gi and python-dbus installed. \nsudo apt-get install python-gi python3-gi python-dbus \nThe first two will install the python 2 and 3 bindings for GObject, the third one will install the python-dbus library.\nIf you downloaded the bluez source directory, you can also try to run the example-gatt-server and the example-advertisement python script from the bluez-5.xx/test folder. The first one creates a heart rate GATT service and the second one creates the corresponding advertisement. They use the same libraries I used in my script.\n. I tested it again with the 1.1.0-SNAPSHOT. I used bluez-5.41 again on the Pi to rule out any changes on that side. But Unfortunately I have upgraded my Nexus 5x to Android 7.0 in the meantime so I can't tell if the problem is solved in Android 6.\nInterestingly the behavior changed in Android 7 again. Reading from and writing to an existing characteristic works as expected.\n11-06 22:01:59.785 28082-28082/de.tobiastrumm.bluetoothledmatrix D/LedControlActivity: Pressed button [0][0]\n11-06 22:01:59.794 28082-28082/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(90263684)\n11-06 22:01:59.795 28082-28082/de.tobiastrumm.bluetoothledmatrix D/LedMatrix: Old: Col 0 Color 1: 00000000 00000000\n11-06 22:01:59.796 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(90263684)\n11-06 22:01:59.796 28082-28082/de.tobiastrumm.bluetoothledmatrix D/LedMatrix: New: Col 0 Color 1: 01000000 00000000\n11-06 22:01:59.805 28082-28082/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(58975849)\n11-06 22:01:59.960 28082-28098/de.tobiastrumm.bluetoothledmatrix W/BluetoothGatt: onCharacteristicRead() - Device=B8:27:EB:A7:1B:9D handle=48 Status=0\n11-06 22:01:59.962 28082-28098/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=12345678-1234-5678-1234-56789abc0000 status=0\n11-06 22:01:59.965 28082-28214/de.tobiastrumm.bluetoothledmatrix D/LedControlActivity: read\n11-06 22:01:59.968 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(90263684)\n11-06 22:01:59.968 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(58975849)\n11-06 22:02:00.079 28082-28094/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=12345678-1234-5678-1234-56789abc0000 status=0\n11-06 22:02:00.081 28082-28214/de.tobiastrumm.bluetoothledmatrix D/LedControlActivity: write\n11-06 22:02:00.081 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(58975849)\nBluez on the Pi received and sent the following packets (Use sudo btmon see the packets in real time)\n```\n\nACL Data RX: Handle 64 flags 0x02 dlen 7                   [hci0] 1357.182785\n      ATT: Read Request (0x0a) len 2\n        Handle: 0x0030\n< ACL Data TX: Handle 64 flags 0x00 dlen 7                   [hci0] 1357.185679\n      ATT: Read Response (0x0b) len 2\n        Value: 0000\nACL Data RX: Handle 64 flags 0x02 dlen 9                   [hci0] 1357.302857\n      ATT: Write Request (0x12) len 4\n        Handle: 0x0030\n          Data: 4000\n< ACL Data TX: Handle 64 flags 0x00 dlen 5                   [hci0] 1357.312835\n      ATT: Write Response (0x13) len 0\n```\n\nThe next log shows the attempt to read and write the same characteristic after it was removed:\n11-06 22:04:49.168 28082-28082/de.tobiastrumm.bluetoothledmatrix D/LedControlActivity: Pressed button [0][0]\n11-06 22:04:49.171 28082-28082/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(229704388)\n11-06 22:04:49.172 28082-28082/de.tobiastrumm.bluetoothledmatrix D/LedMatrix: Old: Col 0 Color 2: 01010000 00000000\n11-06 22:04:49.172 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(229704388)\n11-06 22:04:49.172 28082-28082/de.tobiastrumm.bluetoothledmatrix D/LedMatrix: New: Col 0 Color 2: 10010000 00000000\n11-06 22:04:49.175 28082-28082/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(48455593)\n11-06 22:04:49.281 28082-28094/de.tobiastrumm.bluetoothledmatrix W/BluetoothGatt: onCharacteristicRead() - Device=B8:27:EB:A7:1B:9D handle=48 Status=1\n11-06 22:04:49.283 28082-28094/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=12345678-1234-5678-1234-56789abc0000 status=1\n11-06 22:04:49.286 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(229704388)\n11-06 22:04:49.286 28082-28094/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: Read: Error\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-06 22:04:49.287 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(48455593)\n11-06 22:04:49.288 28082-28082/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: Write: Error\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-06 22:04:49.289 28082-28105/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(48455593)\n11-06 22:04:49.402 28082-28095/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=12345678-1234-5678-1234-56789abc0000 status=1\n```\n\nACL Data RX: Handle 64 flags 0x02 dlen 7                   [hci0] 1526.505062\n      ATT: Read Request (0x0a) len 2\n        Handle: 0x0030\n< ACL Data TX: Handle 64 flags 0x00 dlen 9                   [hci0] 1526.505427\n      ATT: Error Response (0x01) len 4\n        Read Request (0x0a)\n        Handle: 0x0030\n        Error: Invalid Handle (0x01)\nACL Data RX: Handle 64 flags 0x02 dlen 9                   [hci0] 1526.625134\n      ATT: Write Request (0x12) len 4\n        Handle: 0x0030\n          Data: 9000\n< ACL Data TX: Handle 64 flags 0x00 dlen 9                   [hci0] 1526.625376\n      ATT: Error Response (0x01) len 4\n        Write Request (0x12)\n        Handle: 0x0030\n        Error: Invalid Handle (0x01)\n```\n\nThe BleGattExceptions are still thrown but instead of closing the connection automatically it is now kept alive.\n. I switched to the 1.2.0-SNAPSHOT and tested it again. Now I see the same behavior as you do.\n11-18 21:01:59.212 23273-23273/de.tobiastrumm.bluetoothledmatrix D/LedControlActivity: Pressed button [2][3]\n11-18 21:01:59.217 23273-23273/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(75725609)\n11-18 21:01:59.219 23273-23273/de.tobiastrumm.bluetoothledmatrix D/LedMatrix: Old: Col 3 Color 2: 00000001 00000000\n11-18 21:01:59.220 23273-23273/de.tobiastrumm.bluetoothledmatrix D/LedMatrix: New: Col 3 Color 2: 00000010 00000000\n11-18 21:01:59.220 23273-23627/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(75725609)\n11-18 21:01:59.226 23273-23273/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(57374650)\n11-18 21:01:59.355 23273-23285/de.tobiastrumm.bluetoothledmatrix W/BluetoothGatt: onCharacteristicRead() - Device=B8:27:EB:A7:1B:9D handle=35 Status=1\n11-18 21:01:59.357 23273-23285/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=12345678-1234-5678-1234-56789abc0002 status=1\n11-18 21:01:59.363 23273-23285/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: Read: Error\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-18 21:01:59.363 23273-23285/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: Write: Error\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-18 21:01:59.364 23273-23285/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: Read: Error\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-18 21:01:59.364 23273-23285/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: Write: Error\n                                                                                       BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-18 21:01:59.366 23273-23285/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicWrite(57374650)\n11-18 21:01:59.367 23273-23273/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(221169268)\n11-18 21:01:59.367 23273-23627/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(75725609)\n11-18 21:01:59.368 23273-23627/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(221169268)\n11-18 21:01:59.392 23273-23273/de.tobiastrumm.bluetoothledmatrix E/LedControlActivity: BleGattException{status=1, bleGattOperation=BleGattOperation{description='CHARACTERISTIC_READ'}}\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusErrorIfGattErrorOccurred(RxBleGattCallback.java:248)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$100(RxBleGattCallback.java:25)\n                                                                                           at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$1.onCharacteristicRead(RxBleGattCallback.java:97)\n                                                                                           at android.bluetooth.BluetoothGatt$1.onCharacteristicRead(BluetoothGatt.java:287)\n                                                                                           at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:117)\n                                                                                           at android.os.Binder.execTransact(Binder.java:565)\n11-18 21:01:59.398 23273-23273/de.tobiastrumm.bluetoothledmatrix D/BluetoothManager: getConnectionState()\n11-18 21:01:59.398 23273-23273/de.tobiastrumm.bluetoothledmatrix D/BluetoothManager: getConnectedDevices\n11-18 21:01:59.492 23273-23273/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: cancelOpen() - device: B8:27:EB:A7:1B:9D\n11-18 21:01:59.495 23273-23286/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=B8:27:EB:A7:1B:9D\n11-18 21:01:59.496 23273-23286/de.tobiastrumm.bluetoothledmatrix D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n11-18 21:01:59.497 23273-23627/de.tobiastrumm.bluetoothledmatrix D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(221169268)\n11-18 21:01:59.539 23273-23273/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: close()\n11-18 21:01:59.539 23273-23273/de.tobiastrumm.bluetoothledmatrix D/BluetoothGatt: unregisterApp() - mClientIf=5\n. ",
    "DariuszAniszewski": "No problem, but real credits should go to @dariuszseweryn  :)\n. @dariuszseweryn ^^. cc: @dariuszseweryn :) . ",
    "qqnp1100": "The device is still in development,In my previous app\uff0cit can connect the devices and setCharacteristicNotification\u3002set notification code:\n```\n    public boolean setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {\n        boolean ok = false;\n        if (mBluetoothGatt.setCharacteristicNotification(characteristic, enabled)) {\n            BluetoothGattDescriptor clientConfig = characteristic.getDescriptor(BleUUID.CLIENT_CHARACTERISTIC_CONFIG);//in my device clientConfig is null\n            if (clientConfig != null) {\n                if (enabled) {\n                    ok = clientConfig.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n                } else {\n                    ok = clientConfig.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n                }\n            if (ok) {\n                ok = mBluetoothGatt.writeDescriptor(clientConfig);\n            }\n        }\n    }\n    return ok;\n}\n\n```\nAlthough descriptor is null and void return false , but it has been run mBluetoothGatt.setCharacteristicNotification(characteristic, enabled)\nso the onCharacteristicChanged() callback success.\nbut use rxandroidble,it not run anything when descriptor is null.\nI want change the rxandroidble code make it not throw and continue run when descriptor is null. \nbut it was too complicated so I gave up.\nAt the end,I got on my knees and begged My Hardware Engineer to add descriptor in this device.\nnow,descriptor is not null,it's work (:3 \u300d\u2220)...\n. ",
    "Neogene": "Having same problem with keychain bluetooth, seems not so uncommon to find devices missing this feature.. Update, hard coding service and characteristic uuid reduces lines of code but there is no way to listen to notification, it reports always missing the descriptor (analyzing the characteristic there are no descriptor, but using another github project, itrack2, it manages to connect without descriptor without any problem).\n`\ndeviceSubscription = device.establishConnection(false)\n                    .flatMap(rxBleConnection -> rxBleConnection.discoverServices())\n                    .subscribe(\n                            discoveryResult -> {\n                                Log.d(TAG, \"startScan:discoverServices: \"+discoveryResult);\n                            discoveryResult.getService(serviceUUID).subscribe(\n                                    serviceValue -> {\n                                        // Read characteristic value.\n                                        Log.d(TAG, \"startScan: chars:\"+serviceValue);\n\n                                        BluetoothGattCharacteristic characteristic = serviceValue.getCharacteristic(clickCharacteristicUUID);\n\n                                        deviceSubscription.unsubscribe();\n\n                                        deviceSubscription = device.establishConnection(false)\n                                                .flatMap(rxBleConnection -> rxBleConnection.setupNotification(characteristic))\n                                                .doOnNext(notificationObservable -> {\n                                                    // Notification has been set up\n                                                    Log.d(TAG, \"startScan: \"+notificationObservable);\n                                                })\n                                                .flatMap(notificationObservable -> notificationObservable) // <-- Notification has been set up, now observe value changes.\n                                                .subscribe(\n                                                        bytes -> {\n                                                            Log.d(TAG, \"startScan: \"+bytes);\n                                                            // Given characteristic has been changes, here is the value.\n                                                        },\n                                                        throwable -> {\n                                                            Log.d(TAG, \"startScan: error:\"+throwable);\n                                                            // Handle an error here.\n                                                        }\n                                                );\n\n\n                                    },\n                                    throwable -> {\n                                        // Handle an error here.\n                                        Log.d(TAG, \"startScan: chars ERROR\"+throwable);\n                                    }\n                            );`\n\nError received:\nregisterApp() - UUID=23fc0b56-36e0-4820-b4f3-f0be67698ed2\n12-02 09:45:16.290 3520-3542/it.hartstudio.mcdelivery D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\nBluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=FF:FF:70:02:6A:EE\nRxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nD/RxBle#ClientOperationQueue: FINISHED ConnectOperation(104619256)\n D/BluetoothGatt: setCharacteristicNotification() - uuid: 0000ffe1-0000-1000-8000-00805f9b34fb enable: true\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 0000ffe1-0000-1000-8000-00805f9b34fb enable: false\nD/ClickManager: startScan: \nerror:com.polidea.rxandroidble.exceptions.BleCannotSetCharacteristicNotificationException: Cannot find client characteristic config descriptor (code 2) with characteristic UUID 0000ffe1-0000-1000-8000-00805f9b34fb. I found another thread/bug here which reported the problem of missing descriptor, seems not so uncommon to have devices which miss this information.. ",
    "vadstep": "Hi. Yes sure. I am obtaining it from:\nbleDevice.establishConnection(this, false)\n            .flatMap(RxBleConnection::discoverServices)\n            .first() \n            .compose(bindUntilEvent(PAUSE))\n            .observeOn(AndroidSchedulers.mainThread())\n            .doOnUnsubscribe(this::updateUI)\n            .subscribe(adapter::swapScanResult, this::onConnectionFailure);\n. It works!!!\n```\n    bleDevice.establishConnection(this, false)\n            .flatMap(connection ->\n                connection.discoverServices()\n                        .flatMap(services ->services.getCharacteristic(uid) )\n                        .flatMap(bluetoothGattCharacteristic -> connection.writeCharacteristic(bluetoothGattCharacteristic, getInputBytes155Increment())))\n\n.observeOn(AndroidSchedulers.mainThread())\n                .subscribe(\n                        this::onWriteSuccess,\n                        this::onWriteFailure\n                );\n```\nBut why i cannot use my code from first post(i did not do any transformations with bluetoothGattCharacteristic)\nAnd of course i can't use this example too because i can't establishConnection every time when i need to do write operation.\n. Ok thanks for an answer. And GREAT thanks for a RxAndroidBle!!!\n. ",
    "zhuozhibin": "now I face the same problem, any solution?\n. ",
    "lowwor": "@dariuszseweryn #99 Here comes the reference.. Great. But it seems the snapshot build failed for some checkstyle problems (travis), please check with that. Thanks!\n. Can we have a snapshot version of this feature, since it's really useful and I really need this feature.\nOr any other way I can achieve this function without compile the whole project as a dependency (It seems BluetoothGatt is not exposed).\nThanks in advance!. Great job! Thank you all for this nice feature.. ```\n01-18 17:19:31.949 D/BluetoothGatt(12331): writeCharacteristic() - uuid: 001120a2-2233-4455-6677-889912345678\n01-18 17:19:31.949 D/BtGatt.GattService( 1911): writeCharacteristic() - address=00:02:F7:00:5F:D2\n01-18 17:19:31.949 D/BtGatt.btif( 1911): btif_gattc_write_char\n01-18 17:19:31.949 D/BtGatt.btif( 1911): btgattc_handle_event: Event 1015\n01-18 17:19:31.949 D/BtGatt.btif( 1911): btif_gattc_upstreams_evt: Event 4\n01-18 17:19:31.949 D/BtGatt.GattService( 1911): onWriteCharacteristic() - address=00:02:F7:00:5F:D2, status=0\n01-18 17:19:31.949 D/BluetoothGatt(12331): onCharacteristicWrite() - Device=00:02:F7:00:5F:D2 UUID=001120a2-2233-4455-6677-889912345678 Status=0\n01-18 17:19:32.009 D/X-LOG   (12331):   \u251c com.bletest.BleTestApplication$XlogTree.log(BleTestApplication.java:153)\n01-18 17:19:32.009 D/X-LOG   (12331):   \u251c timber.log.Timber$Tree.prepareLog(Timber.java:541)\n01-18 17:19:32.009 D/X-LOG   (12331):   \u2514 timber.log.Timber$Tree.d(Timber.java:418)\n01-18 17:19:32.009 D/X-LOG   (12331): bytesChunk\n01-18 17:19:32.009 E/X-LOG   (12331):   \u251c com.bletest.BleTestApplication$XlogTree.log(BleTestApplication.java:162)\n01-18 17:19:32.009 E/X-LOG   (12331):   \u251c timber.log.Timber$Tree.prepareLog(Timber.java:541)\n01-18 17:19:32.009 E/X-LOG   (12331):   \u2514 timber.log.Timber$Tree.e(Timber.java:463)\n01-18 17:19:32.009 E/X-LOG   (12331): onNext sent oldSize 17420 newSize 17440\n01-18 17:19:32.009 D/BluetoothGatt(12331): writeCharacteristic() - uuid: 001120a2-2233-4455-6677-889912345678\n01-18 17:19:32.009 D/BtGatt.GattService( 1911): writeCharacteristic() - address=00:02:F7:00:5F:D2\n01-18 17:19:32.009 D/BtGatt.btif( 1911): btif_gattc_write_char\n01-18 17:19:32.009 D/BtGatt.btif( 1911): btgattc_handle_event: Event 1015\n01-18 17:19:32.009 D/BtGatt.btif( 1911): btif_gattc_upstreams_evt: Event 4\n01-18 17:19:32.009 D/BtGatt.GattService( 1911): onWriteCharacteristic() - address=00:02:F7:00:5F:D2, status=0\n01-18 17:19:32.009 D/BluetoothGatt(12331): onCharacteristicWrite() - Device=00:02:F7:00:5F:D2 UUID=001120a2-2233-4455-6677-889912345678 Status=0\n01-18 17:19:32.089 D/X-LOG   (12331):   \u251c com.bletest.BleTestApplication$XlogTree.log(BleTestApplication.java:153)\n01-18 17:19:32.089 D/X-LOG   (12331):   \u251c timber.log.Timber$Tree.prepareLog(Timber.java:541)\n01-18 17:19:32.089 D/X-LOG   (12331):   \u2514 timber.log.Timber$Tree.d(Timber.java:418)\n01-18 17:19:32.089 D/X-LOG   (12331): bytesChunk\n01-18 17:19:32.089 E/X-LOG   (12331):   \u251c com.bletest.BleTestApplication$XlogTree.log(BleTestApplication.java:162)\n01-18 17:19:32.089 E/X-LOG   (12331):   \u251c timber.log.Timber$Tree.prepareLog(Timber.java:541)\n01-18 17:19:32.089 E/X-LOG   (12331):   \u2514 timber.log.Timber$Tree.e(Timber.java:463)\n01-18 17:19:32.089 E/X-LOG   (12331): onNext sent oldSize 17440 newSize 17460\n01-18 17:19:32.089 D/BluetoothGatt(12331): writeCharacteristic() - uuid: 001120a2-2233-4455-6677-889912345678\n01-18 17:19:32.099 D/BtGatt.GattService( 1911): writeCharacteristic() - address=00:02:F7:00:5F:D2\n01-18 17:19:32.099 D/BtGatt.btif( 1911): btif_gattc_write_char\n01-18 17:19:32.099 D/BtGatt.btif( 1911): btgattc_handle_event: Event 1015\n01-18 17:19:32.099 D/BtGatt.btif( 1911): btif_gattc_upstreams_evt: Event 4\n01-18 17:19:32.099 D/BtGatt.GattService( 1911): onWriteCharacteristic() - address=00:02:F7:00:5F:D2, status=0\n01-18 17:19:32.099 D/BluetoothGatt(12331): onCharacteristicWrite() - Device=00:02:F7:00:5F:D2 UUID=001120a2-2233-4455-6677-889912345678 Status=0\n01-18 17:19:32.159 D/X-LOG   (12331):   \u251c com.bletest.BleTestApplication$XlogTree.log(BleTestApplication.java:153)\n01-18 17:19:32.159 D/X-LOG   (12331):   \u251c timber.log.Timber$Tree.prepareLog(Timber.java:541)\n01-18 17:19:32.159 D/X-LOG   (12331):   \u2514 timber.log.Timber$Tree.d(Timber.java:418)\n01-18 17:19:32.159 D/X-LOG   (12331): bytesChunk\n01-18 17:19:32.159 E/X-LOG   (12331):   \u251c com.bletest.BleTestApplication$XlogTree.log(BleTestApplication.java:162)\n01-18 17:19:32.159 E/X-LOG   (12331):   \u251c timber.log.Timber$Tree.prepareLog(Timber.java:541)\n01-18 17:19:32.159 E/X-LOG   (12331):   \u2514 timber.log.Timber$Tree.e(Timber.java:463)\n01-18 17:19:32.159 E/X-LOG   (12331): onNext sent oldSize 17460 newSize 17480\n01-18 17:19:32.159 D/BluetoothGatt(12331): writeCharacteristic() - uuid: 001120a2-2233-4455-6677-889912345678\n01-18 17:19:32.159 D/BtGatt.GattService( 1911): writeCharacteristic() - address=00:02:F7:00:5F:D2\n01-18 17:19:32.159 D/BtGatt.btif( 1911): btif_gattc_write_char\n01-18 17:19:32.159 D/BtGatt.btif( 1911): btgattc_handle_event: Event 1015\n```\nThis is the log before the process stop. We can see that after the last writeCharacteristic operation, no corresponding onCharacteristicWrite is invoked, so the lib do nothing because of that, no further operation, and no onError onNext or onComplete is invoked at all. It looks like the phones problem not invoking the onCharacteristicWrite, but I think I should do something to take care of this kind of weird situation as well. \n. Also, after that, further ble operation like writing or reading characteristic\u3001disconnecting from the ble device take no effect at all. Only turning off the phone's bluetooth and open it again can make the ble work again.. Yeah, tried that already. Everything is OK after increasing the delay ( like 200ms). But the minimum value  varies from different devices, so I can't really tell what a safe delay is. Considering the risk and speed, I am now using a higher delay for general case and a lower delay for the devices tested as a white list.. Yeah, the peripheral's processing capacity may be a factor for the problem of transfering data. But in this case, in fact, most phone don't have this kind of problem with the delay of 50ms and the peripheral can deal with the data correctly (tell from the ble device's serial port log) . So I blame the phone\u2018s (mostly Chinese OEM phone) poor ble stack for this problem. The flow control feature is a good idea and we have implemented it in another situation (say a different working mode of the ble device) like tranfering command data which may take time to process. But in this situation, the peripheral is more like a transparent proxy ( pass through data to elsewhere without doing anything), so to maximize the speed, we had decided to omit the flow control part. Anyway, I'm looking forward to the timeout feature and thanks for your kind support.. I have found that too when I searched for the topic.\nSo I have done the following check on the problem phone:\n- sending a single byte -> ok, onCharacteristicWrite is called, the peripheral can log the byte\n- sending a 21 bytes data -> ok, onCharacteristicWrite is called, the peripheral can log the byte\n- interval sending fixed 20 bytes data (51 51 51 ... 51 51 51) with a 50 ms delay-> problems still occurs and the last chunkified bytes is 20 bytes (51 51... 51).\nAnd after using higher delay, I do a few check too. \n- interval sending fixed 20 bytes data  (51 51 51 ... 51 51 51) with larger delay -> ok, onCharacteristicWrite is called, the peripheral can log the bytes, same as what we sent\n- interval sending a 21 bytes data  (51 51 51 ... 51 51 51) with larger delay -> ok, onCharacteristicWrite is called, the peripheral can log the byte, same as what we sent\nSo, I think it's not the same kind of problem. And I think it's really rare and abnormal that the phone can't even just send a single byte which I don't see on all the phone I tested.\nFollowing is the interval code and chunkify() code I use\n```\n  BleOperationUtil.startWriteWithChunk(rxBleConnection, UUID_SEND_DATA, bytes, delay, TimeUnit.MILLISECONDS)\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .repeatWhen(o -> {\n                                    return o.concatMap(new Func1>() {\n                                                           @Override\n                                                           public Observable<? extends Long> call(Void aVoid) {\n                                                               if (!isStopped) {\n                                                                   return Observable.timer(intervalTime, TimeUnit.MILLISECONDS)\n                                                                           .observeOn(AndroidSchedulers.mainThread());\n                                                               } else {\n                                                                   return Observable.error(new StopSignal());\n                                                               }\n                                                           }\n                                                       }\n                                    );\n                            }\n                    )\n\nchunkify()\nObservable chunkify(byte[] bytes) {\n    return Observable.create(new SyncOnSubscribe() {\n    @Override\n    protected ByteBuffer generateState() {\n        return ByteBuffer.wrap(bytes);\n    }\n\n    @Override\n    protected ByteBuffer next(ByteBuffer state, Observer<? super byte[]> observer) {\n        final int chunkLength = Math.min(state.remaining(), 20);\n        if (chunkLength > 0) {\n            final byte[] bytesChunk = new byte[chunkLength];\n            state.get(bytesChunk);\n            observer.onNext(bytesChunk);\n        }\n        if (chunkLength == 0 || state.remaining() == 0) {\n            observer.onCompleted();\n        }\n        return state;\n    }\n});\n\n}\n```. Yes, it is.. Thanks a lot for the great job! \nBut I was curious that how is the 30 second timeout coming from? Is it just a long enough time or is there any reference for that?. Understood, thanks!. ",
    "tahir9111": "Are we getting this support soon? Byte>20 transmit? How can we achieve it with current library, with bytesplitter . ",
    "nister": "@dariuszseweryn Thanks!. ",
    "kikermo": "Hi, \nYou are absolutely right, I should have created a thread in stackoverflow. I didn't do it I guess because it was a question related to an specific library outside the android framework, but now I've seen there are some question targeting concrete third party libraries, so I will do that way next time. \nAnyway, I have solved the problem. I didn't know until I saw it in the sample app, that you needed to create a ConnectionSharingAdapter for multiple writings within a connection. Before that, I was opening and closing the connection every time I was writing on a characteristic, but I was having problems with that. And before that I was using a single connection as described when I started this thread, but it was crashing, logging that there was a connection already established.\nI also have to say that the description of the issue is not accurate as in my mind I mixed up these two cases, having changed the code several times. \nIn my humble opinion, there should be an example in the main page for multiple writings using ConnectionSharingAdapter, in order to make it a bit more obvious. \nThanks a lot.\n. ",
    "rwozniak": "I have fixed the checkstyle issue, now the build fails during some tests\n. ",
    "jkwiecien": "I updated the issue with the missing methods. \n. It's just a getter returning RxBleConnection instance which was previously gotten from rxbledevice.connect();\n. Started working after adding take(1)\n. ",
    "trulsmag": "I think it is possible to create a wrapper around RxAndroidBLE using RxJava2Interop until RxJava2 is supported by RxAndroidBLE.. ",
    "nateridderman": "It seems that one problem with an adapter approach is that you still need to use one or the other under the hood. Then if a developer uses the other one, the total method count for rxjava 1 and 2 and rxandroidble is ~16-17k. . When you say it doesn't work well with unit tests, do you mean the dependency on Robolectric or are there additional things to be aware of?. Actually createBond returns immediately, and you need to create a broadcast receiver to listen for the updated bond states. https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createbond\nHere's an example: https://stackoverflow.com/questions/18197444/android-bluetooth-low-energy-pairing?rq=1 The receiver operates the same whether you initiate the bond request yourself or the system does in response to a GATT_INSUFFICIENT_AUTHENTICATION error.. Right, they are related but slightly different concepts. This site has a good explanation - https://eewiki.net/display/Wireless/A+Basic+Introduction+to+BLE+Security#ABasicIntroductiontoBLESecurity-PairingOverview:. ",
    "HolySamosa": "With RxJava 1's upcoming feature freeze in June, and then end-of-life in March 2018, perhaps just move  to RxJava 2?. @RobLewis In the interim, I've been successfully using RxJava2Interop to integrate into an RxJava2 project.. @dariuszseweryn @aldoborrero and others.  Thanks for the hard work.  I'm keenly interested in API 21 scanning.  Any updates?. @uKL That's good news!   I'm going to need to do extensive background scanning on Android 6 devices, so I really need to use API 21.  Looking forward to kicking the tires on the new commits.  @dariuszseweryn, so you happen to have a timeline for when we may see something?  Thanks!. Whatever approach is implemented, I'm happy to test it out!  @dariuszseweryn, how's your head-wrapping going? ;-)  . @dariuszseweryn Awesome, that's very exciting news!  \nJust curious: which approach do you think you'll go with for 1.3.0?  Nordic Semiconductor or from scratch?. I've also replaced my own API 21 scanning w/ the new implementation.  It looks like the RxAndroidBle implementation might also help with another issue I've been meaning to address (properly handling disabling the Bluetooth adapter during a scan, which throws no error during BluetoothLeScanner.scan()).  If all goes well with my initial testing in the next week, I may roll it out to a group of 50 testers.  This app does continuous background scanning, so it should be a great way to kick the tires on the new version.... @dariuszseweryn Sorry for disappearing on this.  We were hit by Hurricane Irma just after this was filed, knocking out power and internet for the better part of a week.  I missed the earlier notifications and I'm just now catching up...\nI ran into this issue w/ code for handling unexpected errors in my application.  While for the exception classes that most commonly occur the application provides a user-friendly message that doesn't make use of .getMessage(), in the event of unexpected errors there is an opportunity for the user to get more details about the error and in this case getMessage() is used. Also, this is a shared error handler at the presentation layer of my app, which knows nothing about RxAndroidBle.\nThanks for your patience and the great library. :-)\n. Mapping the exceptions is exactly what I am doing. :-)\nAnd thanks for the kind words. I was fortunate in that we only were without power-- no damage to our home, just a mess of small tree limbs to clean up.\n. I'm mapping the \"reason\" values of BleScanException, as that's the case where my application was seeing unexpected errors.  I'm not mapping the others, as I haven't really ran into unexpected errors outside of scanning.\nI completely agree with your assessment that it is not best practice to use getMessage() for generating common user-facing messages to the user, however there are cases where a developer may need to make use of them, such as my case of optionally provided additional detail of the cause of an unexpected error to a technical end user.\nI don't think this is pressing, but it would be welcome update.  Thanks!. Thanks for the suggestions.  I did some memory dumps and it seems that in some cases some of the Activities do eventually get garbage collected, but never all.  I'm going to experiment with moving the subscription / unsubscription to .onStart() and onStop() and will fill you in on the results.  . ",
    "PopTudor": "Kotlin is now a first class language for Android development as of yesterday's Google IO. They do port most of java 8 features but some will still be missing. As of Java 9, I think it won't come to Android anytime soon. Bear in mind that Java 8 has many more significant features than Java 9 and it took about 3 years to arrive and it's still not 100% backwards compatible. My guess is they will slowly drop support for it as the community will move on to Kotlin. But that's going to take some time, 2-5 years at most. ",
    "vpratfr": "Quite interested in this RxJava2 support too. We are using Kotlin as well here. Java 9 will never see Android ever (Kotlin came in because Java 8 never really got supported).. Hi,\nYes, in our application this is acceptable and I am calling BluetoothAdapter.getDefaultAdapter().enable() after getting user agreement from a dialog (avoids going to settings & all)\nI would have expected a method which avoids using BluetoothAdapter.getDefaultAdapter() but using your adapter wrapper instead. That seemed logical to me.\nI however fully agree with you that some warning should be shown in that method documentation, just like in the javadoc of BluetoothAdapter.enable() . Thanks for the insight. Indeed using Rx filter is a good choice.. ",
    "patrykpoborca": "\ud83d\udc4d to rx2. ",
    "onivas": "any update here?. ",
    "micHar": "Here's another soul craving for rxjava2 support. Sure! Just please don't close the issue too fast, because I may not find time for that in the upcoming holidays, I'll try to do it asap.. Alright, I have something interesting, I think.\nNormally the retries work and the cycle of connect / disconnect looks like this: \n2018-12-23 12:41:30.857 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 12:41:30.863 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 12:41:30.865 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 12:41:30.867 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(202777406)\n2018-12-23 12:41:30.870 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(202777406)\n2018-12-23 12:41:30.872 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@c16233e\n2018-12-23 12:41:30.874 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(202777406) in 3 ms\n2018-12-23 12:41:30.891 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(164797109)\n2018-12-23 12:41:30.893 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(164797109)\n2018-12-23 12:41:30.894 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 12:41:30.896 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(164797109) in 3 ms\nFull log: https://gist.github.com/micHar/57cad47b97c8d8c9193a17a9b1150424\nBut then there is one retry which does something different and it never works again. \n2018-12-23 12:41:34.987 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 12:41:34.994 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 12:41:34.997 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 12:41:34.999 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(61259073)\n2018-12-23 12:41:35.002 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(61259073)\n2018-12-23 12:41:35.005 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@3a6bd41\n2018-12-23 12:41:35.007 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(61259073) in 6 ms\n2018-12-23 12:41:35.018 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(127972052)\n2018-12-23 12:41:35.019 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(127972052)\n2018-12-23 12:41:35.021 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 12:41:35.026 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(127972052) in 4 ms\n---> THIS RETRY BREAKS THINGS UP, I THINK\n2018-12-23 12:41:35.236 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 12:41:35.242 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 12:41:35.245 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 12:41:35.245 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(163588160)\n2018-12-23 12:41:35.247 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(163588160)\n2018-12-23 12:41:35.265 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(11509023)\nhttps://gist.github.com/micHar/148ed623f68a4ce34531f7cb4784d6ba\nThe very obvious difference in the logs is that at one point it stops logging the warning Disconnect operation has been executed but GATT instance was null - considering disconnected..\nAnd the DISCONNECT operations are QUEUED but never STARTED and FINISHED.\nImportant note is that I can disable the BT again and it starts retrying with exactly the same logs, but the warning never appears again and it never connects again. I need to close the app (remove from recents) to make it connect again.. I've changed it since to 200ms, it was easier to reproduce, but earlier I could reproduce it with 7 seconds retry, too.\nMy snippet could be too simple, it also contains the replayingShare() at the end and generally there are several clients of this observable and they do connect and disconnect at different moments (mostly because of application's lifecycle).\n\nthe downstream is disposing right after subscribing to .establishConnection()\n\nI'm not sure about the specifics of replaying share, but if there was a moment where no observer was subscribed to this observable, it could cause this behaviour?\nAlso I'm pretty sure that in the last test I just left it for some time on a screen so it was subscribed all the time and at some points it just stopped working. Cannot reproduce it with 2s now, but will try different intervals. (EDIT: just confirmed that it happened again just with starting the app on disabled BT and waiting for a few (dozens;)) retries at 200ms intervals).\n. To rule out the possibility, that it's the replayingShare that messes things up, I just removed it and left just one subscriber. \nSee below for different intervals - the funny thing is it always happens around the 100th retry, no matter what the interval is.\n200ms\n2018-12-23 13:32:06.087 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:32:06.098 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:32:06.099 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:32:06.101 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(57844933)\n2018-12-23 13:32:06.102 V/RxBle#retriesCounter: Retry #149\n2018-12-23 13:32:06.105 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(57844933)\n2018-12-23 13:32:06.106 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(190995994)\n2018-12-23 13:32:06.106 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@372a4c5\n2018-12-23 13:32:06.108 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(57844933) in 4 ms\n2018-12-23 13:32:06.110 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(190995994)\n2018-12-23 13:32:06.112 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 13:32:06.114 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(190995994) in 5 ms\n2018-12-23 13:32:06.312 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:32:06.319 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:32:06.322 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:32:06.322 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(87572966)\n2018-12-23 13:32:06.324 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(87572966)\n2018-12-23 13:32:06.326 V/RxBle#retriesCounter: Retry #150\n2018-12-23 13:32:06.329 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(183259943)\n500ms:\n2018-12-23 13:29:23.530 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:29:23.541 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:29:23.544 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:29:23.553 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(153748133)\n2018-12-23 13:29:23.555 V/RxBle#retriesCounter: Retry #93\n2018-12-23 13:29:23.556 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(153748133)\n2018-12-23 13:29:23.557 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@92a02a5\n2018-12-23 13:29:23.559 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(153748133) in 3 ms\n2018-12-23 13:29:23.559 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(72324730)\n2018-12-23 13:29:23.561 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(72324730)\n2018-12-23 13:29:23.563 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 13:29:23.566 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(72324730) in 4 ms\n2018-12-23 13:29:24.074 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:29:24.086 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:29:24.088 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:29:24.089 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(238067782)\n2018-12-23 13:29:24.092 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(238067782)\n2018-12-23 13:29:24.093 V/RxBle#retriesCounter: Retry #94\n2018-12-23 13:29:24.097 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(128827911)\n2018-12-23 13:29:24.611 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:29:24.620 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:29:24.621 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:29:24.624 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(173701027)\n2018-12-23 13:29:24.630 D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(173701027)\n2018-12-23 13:29:24.631 V/RxBle#retriesCounter: Retry #95\n2018-12-23 13:29:24.641 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(67816096)\n1s\n2018-12-23 13:36:00.989 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:36:00.999 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:36:01.002 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:36:01.009 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(34184803)\n2018-12-23 13:36:01.011 V/RxBle#retriesCounter: Retry #97\n2018-12-23 13:36:01.012 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(34184803)\n2018-12-23 13:36:01.013 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@2099e63\n2018-12-23 13:36:01.016 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(267176544)\n2018-12-23 13:36:01.018 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(34184803) in 4 ms\n2018-12-23 13:36:01.021 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(267176544)\n2018-12-23 13:36:01.023 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 13:36:01.026 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(267176544) in 4 ms\n2018-12-23 13:36:02.030 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:36:02.043 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:36:02.047 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:36:02.052 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(197405836)\n2018-12-23 13:36:02.058 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(197405836)\n2018-12-23 13:36:02.059 V/RxBle#retriesCounter: Retry #98\n2018-12-23 13:36:02.063 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(140627925)\n2s\n2018-12-23 13:41:30.063 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:41:30.071 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:41:30.074 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:41:30.076 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(238033152)\n2018-12-23 13:41:30.078 V/RxBle#retriesCounter: Retry #98\n2018-12-23 13:41:30.079 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(238033152)\n2018-12-23 13:41:30.080 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@e301900\n2018-12-23 13:41:30.083 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(135845177)\n2018-12-23 13:41:30.086 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(238033152) in 5 ms\n2018-12-23 13:41:30.089 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(135845177)\n2018-12-23 13:41:30.091 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 13:41:30.093 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(135845177) in 4 ms\n2018-12-23 13:41:32.098 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:41:32.106 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:41:32.110 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(254315509)\n2018-12-23 13:41:32.111 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:41:32.112 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(254315509)\n2018-12-23 13:41:32.114 V/RxBle#retriesCounter: Retry #99\n2018-12-23 13:41:32.119 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(57044362). To rephrase the original code sample - this is enough to see the error on my device (Samsung Galaxy S8 and Huawei ane-lx1):\n```kotlin\n//1. disable the bluetoooth in the system\n//2. Run the following code.\n//3. Wait around 100 retries.\nbleClient\n            .getBleDevice(\"F9:56:A3:67:AC:F0\")\n            .establishConnection(false)\n            .retryWhen { it.delay(200, MILLISECONDS) }\n            .subscribe()\n``. Sure, but I didn't find anything interesting there, that's why I omitted them: https://gist.github.com/micHar/2faee160c431d89b0e60c34a8c26d4e2\n (theretry #19` breaks).\nAlso, I noticed that when I subscribeOn(Schedulers.io()) it takes a lot more retries to break so this may be some threading issue.\n\nBesides \u2014 how/when do you enable BT?\n\nIn the current tests i have the BT disabled when the app installs and runs and that's enough to reproduce it. But before I was just disabling and enabling it from the notification tray at random moments. And I'm almost 100% sure, that the first moment when connection cannot be re-established is when the retry logs change in the way I described, because I have tried that many times and it 100% DID work when the logs were OK and 100% DIDN'T connect when the logs started to show corruption in the connect / disconnect process.. OK, I have more details now, so it's probably a good idea.\nSummary\nLibrary version\n1.7.1\nPreconditions\nNone.\nSteps to reproduce actual result\n1. Disable bluetooth in system (e.g. from system tray).\n2. Run the app which runs the code below.\n3. Wait a little bit, it occurs after ~100 retries usually\nMinimum code snippet reproducing the issue\nbleClient.getBleDevice(macAddress)\n            .establishConnection(false)\n            .retryWhen { it.delay(200, MILLISECONDS) }\n            .subscribe()\nLogs from the application running with setting RxBleLog.setLogLevel(RxBleLog.DEBUG)\n2018-12-23 13:32:06.087 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:32:06.098 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:32:06.099 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:32:06.101 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(57844933)\n2018-12-23 13:32:06.102 V/RxBle#retriesCounter: Retry #149\n2018-12-23 13:32:06.105 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(57844933)\n2018-12-23 13:32:06.106 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(190995994)\n2018-12-23 13:32:06.106 D/RxBle#ClientOperationQueue: The operation was about to be run but the observer had been already disposed: com.polidea.rxandroidble2.internal.operations.ConnectOperation@372a4c5\n2018-12-23 13:32:06.108 D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(57844933) in 4 ms\n2018-12-23 13:32:06.110 D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(190995994)\n2018-12-23 13:32:06.112 W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n2018-12-23 13:32:06.114 D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(190995994) in 5 ms\n2018-12-23 13:32:06.312 D/RxBle#DisconnectionRouter: DisconnectionRouter\n2018-12-23 13:32:06.319 I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F9:56:A3:67:AC:F0)\n2018-12-23 13:32:06.322 D/RxBle#Executors$RunnableAdapter: Terminated.\n2018-12-23 13:32:06.322 D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(87572966)\n2018-12-23 13:32:06.324 D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(87572966)\n2018-12-23 13:32:06.326 V/RxBle#retriesCounter: Retry #150\n2018-12-23 13:32:06.329 D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(183259943)\nActual result\nAfter ~100 retries (in the above example it's the very moment at 13:32:06.312), the app stops properly retrying the connection to the BleDevice. When it fails once, it never recovers. There are two visible changes when it fails:\n\nThe logs change, i.e. both Connect operation and Disconnect operation are NOT STARTED and FINISHED anymore (according to logs).\nWhen I enable Bluetooth in that state, it never again connects to the device, i.e. bleClient.getBleDevice(macAddress).establishConnection(false) never emits onNext.\n\nExpected result\nRegardless of number of retries during the time when Bluetooth is disabled, when I enable it, the bleClient.getBleDevice(macAddress).establishConnection(false) should connect again.. Great news! Will check soon. Thanks for that, your support here is exceptional.. I have just checked and it works perfect, thank you!. ",
    "GuillaumeBo": "Any news about your progress @uKL ? Will be available with 1.5 ? :). I was trying to make a \"reconnect\" function based on the observeConnectionStateChanges, but the Close function is called by RxBle after Disconnected status (logical case).This cause force disconnection if we already relaunch a connection between the the Disconnected event and the close.\nThere is any workarround to be notified that RxBle lib has done every actions to close properly a connection ? Adding the Close state to the observeConnectionStateChanges maybe ?. I am agree with you and use also this function for ui :)\nWith a light delay to ensure close() was called before call reconnection it's working. It's not ideal but it's rare case (need to refresh gatt during a connection, the self method is not enough). I will switch if a better solution appears in the futur. Some time when the connection between the smartphone and the device is not closed properly, at the next connection, the smartphone is not able to write/read on the device (Generally this error : GATT_INVALID_HANDLE, and sometime these : GATT_READ_NOT_PERMIT, GATT_WRITE_NOT_PERMIT)\nThe only solution to fix it is to refresh BLEGatt and disconnect/reconnect. So i made this process at the run time when i meet this error to finally retry the write/read :)\n(I cannot know at the connection if it will be bugged or not, only when i trying write/read)\n. Just for information if anybody needs help about this , thread and answer here : stackoverflow. Sure, where can i find this snapshot ?. Offcourse i passed on it and missed it...\nSo i just tryed, it does'nt work\nRejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.DaggerClientComponent$1>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/javax/inject/Provider;\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.494 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.javax.inject.Provider\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.494 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.496 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.RxBleAdapterStateObservable_Factory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.496 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.497 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.497 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.RxBleAdapterStateObservable_Factory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.497 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.497 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.RxBleAdapterStateObservable_Factory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.497 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.497 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.498 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.500 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.ClientComponent_ClientModule_ProvideBluetoothManagerFactory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.500 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.500 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.501 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.ClientComponent_ClientModule_ProvideBluetoothManagerFactory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.501 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.501 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.ClientComponent_ClientModule_ProvideBluetoothManagerFactory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.501 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.501 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.502 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.internal.util.RxBleAdapterWrapper_Factory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.502 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.502 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.503 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.internal.util.RxBleAdapterWrapper_Factory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.503 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.503 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.internal.util.RxBleAdapterWrapper_Factory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.503 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.503 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.505 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.DaggerClientComponent$1>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/javax/inject/Provider;\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.505 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.javax.inject.Provider\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.505 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.506 17870-17870/my.app.id I/art: Rejecting re-init on previously-failed class java.lang.Class<com.polidea.rxandroidble.ClientComponent_ClientModule_ProvideApplicationContextFactory>: java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Factory;\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.DaggerClientComponent$Builder com.polidea.rxandroidble.DaggerClientComponent.builder() (DaggerClientComponent.java:179)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at com.polidea.rxandroidble.RxBleClient com.polidea.rxandroidble.RxBleClient.create(android.content.Context) (RxBleClient.java:51)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at int my.app.id.ble.BLEConnectionService.onStartCommand(android.content.Intent, int, int) (BLEConnectionService.java:69)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.handleServiceArgs(android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:3476)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.-wrap23(android.app.ActivityThread, android.app.ActivityThread$ServiceArgsData) (ActivityThread.java:-1)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1674)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:105)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void android.os.Looper.loop() (Looper.java:156)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6523)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:941)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:831)\n01-04 15:21:56.506 17870-17870/my.app.id I/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Factory\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\n01-04 15:21:56.506 17870-17870/my.app.id I/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\n01-04 15:21:56.743 17870-17892/my.app.id E/HW-JPEG-DEC: [HME_JPEG_DEC_Delete](3321): HME_JPEG_DEC_Delete: decoder_ctx=null\n01-04 15:21:56.766 17870-17870/my.app.id E/AndroidRuntime: FATAL EXCEPTION: main\n                                                               Process: my.app.id, PID: 17870\n                                                               java.lang.NoClassDefFoundError: Failed resolution of: Lbleshadow/dagger/internal/Preconditions;\n                                                                   at com.polidea.rxandroidble.DaggerClientComponent$Builder.clientModule(DaggerClientComponent.java:379)\n                                                                   at com.polidea.rxandroidble.RxBleClient.create(RxBleClient.java:52)\n                                                                   at my.app.id.ble.BLEConnectionService.onStartCommand(BLEConnectionService.java:69)\n                                                                   at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:3476)\n                                                                   at android.app.ActivityThread.-wrap23(ActivityThread.java)\n                                                                   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1674)\n                                                                   at android.os.Handler.dispatchMessage(Handler.java:105)\n                                                                   at android.os.Looper.loop(Looper.java:156)\n                                                                   at android.app.ActivityThread.main(ActivityThread.java:6523)\n                                                                   at java.lang.reflect.Method.invoke(Native Method)\n                                                                   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:941)\n                                                                   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:831)\n                                                                Caused by: java.lang.ClassNotFoundException: Didn't find class \"bleshadow.dagger.internal.Preconditions\" on path: DexPathList[[zip file \"/data/app/my.app.id-1/base.apk\"],nativeLibraryDirectories=[/data/app/my.app.id-1/lib/arm64, /data/app/my.app.id-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]\n                                                                   at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)\n                                                                   at java.lang.ClassLoader.loadClass(ClassLoader.java:380)\n                                                                   at java.lang.ClassLoader.loadClass(ClassLoader.java:312)\n                                                                   at com.polidea.rxandroidble.DaggerClientComponent$Builder.clientModule(DaggerClientComponent.java:379)\u00a0\n                                                                   at com.polidea.rxandroidble.RxBleClient.create(RxBleClient.java:52)\u00a0\n                                                                   at my.app.id.ble.BLEConnectionService.onStartCommand(BLEConnectionService.java:69)\u00a0\n                                                                   at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:3476)\u00a0\n                                                                   at android.app.ActivityThread.-wrap23(ActivityThread.java)\u00a0\n                                                                   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1674)\u00a0\n                                                                   at android.os.Handler.dispatchMessage(Handler.java:105)\u00a0\n                                                                   at android.os.Looper.loop(Looper.java:156)\u00a0\n                                                                   at android.app.ActivityThread.main(ActivityThread.java:6523)\u00a0\n                                                                   at java.lang.reflect.Method.invoke(Native Method)\u00a0\n                                                                   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:941)\u00a0\n                                                                   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:831)\nThe BLEConnectionService.java:69 line =>\nrxBleClient = RxBleClient.create(getApplicationContext());\n  . I am using multi dex yes, i have a lot of dependencies...\nWhat part do you want to see?. android {\n    compileSdkVersion 27\n    buildToolsVersion \"27.0.0\"\n    defaultConfig {\n        applicationId \"my.app.id\"\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        multiDexEnabled true\n        renderscriptTargetApi 21\n        renderscriptSupportModeEnabled true\n    }\n    buildTypes {\n        debug {\n            minifyEnabled false\n            buildConfigField \"boolean\", \"debugMode\", \"true\"\n        }\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            buildConfigField \"boolean\", \"debugMode\", \"false\"\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n```\n    ext.dagger = \"2.13\"\n    compile \"io.reactivex.rxjava2:rxjava:2.1.7\"\n    compile \"io.reactivex.rxjava2:rxandroid:2.0.1\"\n    compile 'com.trello.rxlifecycle2:rxlifecycle:2.2.1'\n    compile 'com.trello.rxlifecycle2:rxlifecycle-components:2.2.1'\n    compile \"com.github.akarnokd:rxjava2-interop:0.11.2\"\n    compile \"com.google.dagger:dagger:$dagger\"\n    compile \"com.google.dagger:dagger-android:$dagger\"\n    annotationProcessor \"com.google.dagger:dagger-compiler:$dagger\"\n    annotationProcessor \"com.google.dagger:dagger-android-processor:$dagger\"\n//Bluetooth\ncompile \"com.polidea.rxandroidble:rxandroidble:1.5.0-SNAPSHOT\"\n\n```\nAnd other extra dependencies as google, support, firebase etc...\n  . it's was ext.dagger = \"2.14.1\"  for the test, i missed to rechange for the copy/paste. It's working with the last Snapshot :). Thanks you for your answer, i try to use this method, but my operation is not executed cause the device is Disconnected. I need to execute BluetoothGatt operation after the \"BluetoothProfile.STATE_DISCONNECTED\". It seems you not authorized this, am i wrong ?\npublic class ClearBleConnectionCacheCustomOperation implements\nRxBleCustomOperation<Void> {\n    @NonNull\n    @Override\n    public Observable<Void> asObservable(BluetoothGatt bluetoothGatt, RxBleGattCallback rxBleGattCallback, Scheduler scheduler) throws Throwable {\n        return RxJavaInterop.toV1Observable(io.reactivex.Observable.create(emitter -> {\n            try {\n                Method localMethod = bluetoothGatt.getClass().getMethod(\"refresh\", new Class[0]);\n                if (localMethod != null) {\n                    boolean bool = (Boolean) localMethod.invoke(bluetoothGatt, new Object[0]);\n                    emitter.onComplete();\n                }\n            } catch (Exception localException) {\n                emitter.tryOnError(localException);\n            }\n        }), BackpressureStrategy.BUFFER);\n    }\n}. The operation consist to clear characteristics list cached on the device just after disconnection. \nIt's not working when the device is connected...\nWhat is reason to block operation on disconnected device ? BluetoothGatt is still valid at this moment. In my old app i made the refresh + close in the \"onConnectionStateChange\" with BluetoothProfile.STATE_DISCONNECTED status. Maybe we should add task for this moment ?\nI just try (after the connection) first time it fails (refresh work) but ble actions right after fail with the error : \"GATT exception from MAC address 01:02:03:04:05:06, with type BleGattOperation{description='SERVICE_DISCOVERY'\"\non every actions, write, read, notify\nOn second try it works...\nin the subscribe of the device connection :\nrxBleConnection.queue(new ClearBleConnectionCacheCustomOperation()).subscribe(o -> {\n                                rxBleConnection.discoverServices();\n                            }, throwable -> {\n                            });. Thanks for the link, can you explain briefly what your code do ? I do not understand the part pour with the delay and the disconnect listner ?\nAnd when you call it ?. Ok i see !\nNow the issue is that this lengthens a lot the time of connection where is about 100-150ms in my case.\nThe 1 second is for security without strong time constraints or it's following your tests ?. Yes i will try to use only when the stack is KO.\nFor information errors fired that obliges me to refresh the stack are : \nGATT exception from MAC address 01:02:03:04:05:06, status 1, type BleGattOperation{description='CHARACTERISTIC_WRITE'}. (Look up status 0x01 here https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h)\nand some time\nGATT exception from MAC address 01:02:03:04:05:06, status 3, type BleGattOperation{description='CHARACTERISTIC_WRITE'}. (Look up status 0x03 here https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h). You can close it, i will post messages if i found any informations about theses bug.\nAnd if anybody has infos about it, feel free to explain us :). @dariuszseweryn a last thing, can we get more details on throwable returned by writeCharacteristic, readCharacteristic etc ? Like errorCode, cause here we have only the string build by the lib and it's no really proper to parse it to obtain the code ?. Perfect, thanks you :). @dariuszseweryn Hello, i updated the lib to get only rx2 in my app, but i am facing issue. I am not able to make your customOperation for refreshBleGatt work with rx2. I got compile error\n\"amb(java.lang.Iterable<? extends io.reactivex.ObservableSource<? extends T>>) in Observable cannot be applied to (io.reactivex.Observable, io.reactivex.Observable)\ndid you know how to fix this ?\n. It's compilation/ide error on your file just after replace rx.java1 element to rx.java2 version, i did not make any other modification on it.\nthe error appear on the \"Observable.amb(\n                Observable.fromCallable(new Callable() {\" bloc. I tryed with nRF Connect totally killed, and it's working ! Thanks you, I did not think that nRF Connect was so intrusive !. Thanks @uKL , I had already asked myself the question of the difference between these two.\nThe logs paste here came from the (not modified) sample ap. In my app i have the same result. So maybe the implementation in the sample app and in my app are wrong ? i can not understand where the wrong call comes from.... I just tried with the last 1.6 Snapshot, it's seems to work better !\ni haven't get any crash following a bad disconnection. Sometime i get a \nD/RxBle#MtuWatcher: An error received when listening to MTU changes. but correctly handle :). I had a few time exception error on the disconnection with the last snapshot :\n03-21 15:26:46.430 29682-29750/fr.test.myapp D/BluetoothGatt: cancelOpen() - device: 00:00:00:00:00:00\n03-21 15:26:46.431 29682-29742/fr.test.myapp D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=00:00:00:00:00:00\n03-21 15:26:46.436 29682-29753/fr.test.myapp W/System.err: io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 00:00:00:00:00:00\n03-21 15:26:46.436 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n03-21 15:26:46.436 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onError(ObservableCreate.java:74)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at com.polidea.rxandroidble2.internal.util.QueueReleasingEmitterWrapper.onError(QueueReleasingEmitterWrapper.java:45)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onError(SingleToObservable.java:65)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.single.SingleTimeout$TimeoutMainObserver.onError(SingleTimeout.java:142)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onError(SingleMap.java:69)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onError(ObservableElementAtSingle.java:104)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.checkTerminated(ObservableObserveOn.java:276)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.drainNormal(ObservableObserveOn.java:172)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.run(ObservableObserveOn.java:252)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at java.lang.Thread.run(Thread.java:761)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err: Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 00:00:00:00:00:00\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:180)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at android.os.Binder.execTransact(Binder.java:565). I don't know if it's linked, but i noticed this error in log (not app crash, it's correctly handled) during a connection lost (ble device turned off)\n04-16 15:46:52.882 9815-9903/fr.my.app D/BluetoothGatt: close()\n04-16 15:46:52.895 9815-9829/fr.my.app W/BluetoothGatt: Unhandled exception in callback\n    java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.ObservableEmitter.onNext(java.lang.Object)' on a null object reference\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.notifySubscribersAboutException(DisconnectionRouter.java:125)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onExceptionOccurred(DisconnectionRouter.java:114)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onDisconnectedException(DisconnectionRouter.java:100)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:191)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:565)\nI have no more crash with latest update for this moment on my side. The rx2 1.6 Snapshot. Yes i implemented the bonding on my side and already with 2 differents devices (huawei and nexus, both Android 7) i got very different comportment... But that is not the issue here.\nhere are logs, not very helpfull :/\n03-15 15:10:15.963 30807-30807/fr.test E/BleManager: Connected to 00:00:00:00:00:00\n03-15 15:10:17.340 30807-30904/fr.test D/BLEConnectionService: writeCharacteristic on 00:00:00:00:00:00, with uuid : 00010000-0295-7A8B-1410-000000000000, and data : [B@4dd4042\n03-15 15:10:17.347 30807-30907/fr.test D/BluetoothGatt: discoverServices() - device: 00:00:00:00:00:00\n03-15 15:10:17.503 30807-30819/fr.test D/BluetoothGatt: onSearchComplete() = Device=00:00:00:00:00:00 Status=0\n03-15 15:10:47.512 30807-30972/fr.test E/BLEConnectionService: writeCharacteristic 00010000-0295-7A8B-1410-000000000000 Unknown Error, code : GATT exception from MAC address 00:00:00:00:00:00, with type BleGattOperation{description='CHARACTERISTIC_WRITE'}\n03-15 15:10:47.514 30807-30972/fr.test E/BleManager: writeCharacteristic failure on \"00:00:00:00:00:00\", error : GATT exception from MAC address 00:00:00:00:00:00, with type BleGattOperation{description='CHARACTERISTIC_WRITE'}\n03-15 15:10:50.574 30807-30820/fr.test D/BluetoothGatt: onClientConnectionState() - status=22 clientIf=6 device=00:00:00:00:00:00\n03-15 15:10:50.577 30807-30807/fr.test E/BLEConnectionService: Disconnection from 00:00:00:00:00:00, error : Disconnected from 00:00:00:00:00:00\n03-15 15:10:50.580 30807-30907/fr.test D/BleManager: registerDevicesConnectionStatus, new value : DISCONNECTING\n03-15 15:10:50.580 30807-30907/fr.test D/BluetoothManager: getConnectionState()\n03-15 15:10:50.580 30807-30907/fr.test D/BluetoothManager: getConnectedDevices\n03-15 15:10:50.584 30807-30907/fr.test D/BluetoothGatt: close()\nMaybe OS occults the write operation and returns only the timeout error, but it's not very clean.. we got an error that is not linked to the original operation.... @dariuszseweryn your answer on #277 seems to talk about it ?. Logs in verbose mode : \n```\n03-16 10:31:18.638 25897-26006/fr.test D/BLEConnectionService: writeCharacteristic on 00:00:00:00:00:00, with uuid : 00010000-0200-0000-0000-000000000000, and data : [B@7526f0\n03-16 10:31:18.645 25897-26006/fr.test D/RxBle#ConnectionOperationQueue: QUEUED   ServiceDiscoveryOperation(102613532)\n03-16 10:31:18.646 25897-26009/fr.test D/RxBle#ConnectionOperationQueue: STARTED  ServiceDiscoveryOperation(102613532)\n03-16 10:31:18.649 25897-26011/fr.test D/BluetoothGatt: discoverServices() - device: 00:00:00:00:00:00\n03-16 10:31:18.662 25897-25909/fr.test D/BluetoothGatt: onSearchComplete() = Device=00:00:00:00:00:00 Status=0\n03-16 10:31:18.663 25897-25909/fr.test D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n03-16 10:31:18.664 25897-26010/fr.test V/RxBle#ServiceDiscoveryOperation: Preparing services description\n03-16 10:31:18.688 25897-26010/fr.test V/RxBle#ServiceDiscoveryOperation: --------------- ====== Printing peripheral content ====== ---------------\n                                                                                PERIPHERAL ADDRESS: 00:00:00:00:00:00\n                                                                                PERIPHERAL NAME: myDevice\n                                                                                -------------------------------------------------------------------------\n                                                                            Primary Service - Generic Attribute (00001801-0000-1000-8000-00805f9b34fb)\n                                                                            Instance ID: 1\n                                                                            -> Characteristics:\n\n                                                                            Primary Service - Generic Access (00001800-0000-1000-8000-00805f9b34fb)\n                                                                            Instance ID: 64\n                                                                            -> Characteristics:\n                                                                                * Device Name (00002a00-0000-1000-8000-00805f9b34fb)\n                                                                                  Properties: [ READ ]\n                                                                                * Appearance (00002a01-0000-1000-8000-00805f9b34fb)\n                                                                                  Properties: [ READ ]\n\n                                                                            Primary Service - Device Information (0000180a-0000-1000-8000-00805f9b34fb)\n                                                                            Instance ID: 256\n                                                                            -> Characteristics:\n                                                                                * PnP ID (00002a50-0000-1000-8000-00805f9b34fb)\n                                                                                  Properties: [ READ ]\n\n                                                                            Primary Service - Immediate Alert Service 1.1 (00001802-0000-1000-8000-00805f9b34fb)\n                                                                            Instance ID: 512\n                                                                            -> Characteristics:\n                                                                                * Alert Level (00002a06-0000-1000-8000-00805f9b34fb)\n                                                                                  Properties: [ WRITE_NO_RESPONSE ]\n\n                                                                            Primary Service - Unknown service (000100ff-0200-0000-0000-000000000000)\n                                                                            Instance ID: 515\n                                                                            -> Characteristics:\n                                                                                * Unknown characteristic (00010000-0200-0000-0000-000000000000)\n                                                                                  Properties: [ WRITE ]\n                                                                                * Unknown characteristic (00010004-0200-0000-0000-000000000000)\n                                                                                  Properties: [ READ WRITE ]\n                                                                            --------------- ====== Finished peripheral content ====== ---------------\n\n03-16 10:31:18.694 25897-26010/fr.test D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicWriteOperation(177048570)\n03-16 10:31:18.697 25897-26009/fr.test D/RxBle#ConnectionOperationQueue: FINISHED ServiceDiscoveryOperation(102613532) in 50 ms\n03-16 10:31:18.698 25897-26009/fr.test D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicWriteOperation(177048570)\n03-16 10:31:48.710 25897-26012/fr.test E/BLEConnectionService: writeCharacteristic 00010000-0200-0000-0000-000000000000 Error 1 Unknown Error, code : GATT exception from MAC address 00:00:00:00:00:00, with type BleGattOperation{description='CHARACTERISTIC_WRITE'}\n03-16 10:31:48.713 25897-26009/fr.test D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicWriteOperation(177048570) in 30012 ms\n03-16 10:31:51.908 25897-26174/fr.test D/BluetoothGatt: onClientConnectionState() - status=22 clientIf=6 device=00:00:00:00:00:00\n03-16 10:31:51.909 25897-26174/fr.test D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=22\n03-16 10:31:51.911 25897-26174/fr.test I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (00:00:00:00:00:00)\n03-16 10:31:51.912 25897-26009/fr.test D/RxBle#Executors$RunnableAdapter: Terminated.\n03-16 10:31:51.919 25897-25897/fr.test E/BLEConnectionService: Disconnection from 00:00:00:00:00:00, error : Disconnected from 00:00:00:00:00:00\n03-16 10:31:51.920 25897-26174/fr.test D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(205977003)\n03-16 10:31:51.922 25897-25937/fr.test D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(205977003)\n03-16 10:31:51.924 25897-26011/fr.test D/BleManager: registerDevicesConnectionStatus, new value : DISCONNECTING\n03-16 10:31:51.925 25897-26011/fr.test D/BluetoothManager: getConnectionState()\n03-16 10:31:51.925 25897-26011/fr.test D/BluetoothManager: getConnectedDevices\n03-16 10:31:51.928 25897-26011/fr.test D/BluetoothGatt: close()\n03-16 10:31:51.928 25897-26011/fr.test D/BluetoothGatt: unregisterApp() - mClientIf=6\n03-16 10:31:51.929 25897-26011/fr.test D/BleManager: registerDevicesConnectionStatus, new value : DISCONNECTED\n03-16 10:31:51.931 25897-25937/fr.test D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(205977003) in 9 ms\n```. The 30sec timeout is due to my non action or cancel the pairing modal (same log for theses 2 case) yes. The ideal solution for me would the writeCharacteristic Single triggers onError with something like BleNotAuthorizedException or BleInsuffisantAuthorizationException (refer to Gatt API ) or simple BleEncryptedCharacteristicException instead of the timeoutException, no?. Only when user reject or ignore the bonding process. If user accept bonding, i think the write operation is done like normal case.\nOr to go further a param that allow either the \"auto bonding request\" or not. Ok :)\nBad to hear that \"some phones that were failing the write after positive bonding, requiring it to be retried\". There are still a lot of work to do :(. Thanks you, it's ok for CLA, i already signed it, but i commited with wrong email, now it's fixed :). Yes i am sure, my routine advertise scan is still on, the connection is effective.\nIf i deploy from AndroidStudio device On -> it's works\nif i deploy from AS device screen off -> no connection events emitted but everything else works well. Sorry i was busy, it's to difficult to extract this part of the code, but after many tests, the issue come from my code cause it appears randomly even if app is waked up.\nYou can close the ticket :)\n(And i confirm it's works also screen Off, thanks for answers). That's good comment, i understand your wish to carry the user/dev to avoid any possible mistake or oversight and i am totally ok with it ! \nMaybe we should add in the javadoc a sentence about this case ?\nI imagined this feature for developers who need more while controlling the subject (nobody will make a total refresh of his services without have this specific need i think).\nMaybe you should integrate an \"expert mode like\" to no bridle the library mostly if you go further on the follow of the connection ? i mean by \"expert mode\" just mark functions by a tag in the doc or something ?\nYour queue function for custom operation over the gatt is already a part of this in some way.. i do not see how today we can make this feature with customOperation...\nThere is cache on differents levels, we have to manipulate the ServiceDiscoveryManager.java to clears theses caches :/\n\"Users tend not to read the documentation frequently enough\" i agree with you. Here the little difference is to access to the refresh mode the user has to use the most complex version of the function. The basic user will use the simplier method first i think\n. Yes we can perform a discover from CustomOperation but in \"ServiceDiscoveryManager.java\" there are also 2 level of cache, the observable saved and the rx \".cache()\" on the other observable...\nSo the services will be refresh a the Gatt level but the lib will not follow the new state of Gatt. That is more dangerous than refresh properly from the lib no? . For me yes this may introduce miss understanding behaviour for basic use (where this feature don't aim). But at the opposite, not having it, may introduce the same for user who needs real discovers feature.\n- the user thinks to do a discover and in the reality nop\n- the user has his ble device hiding service or characteristic at the run time -> failure with the wrong error message cause the stack believe that char is already here but in reality anymore.\n- the user has his ble device showing service or characteristic at the run time -> he is forced to disconnect/reconnect with a refresh to perform read/write...\nI won't see how its possible through the RxBleCustomOperation..  May the solution for \"expert mode\" is to supply some feature like this with rxBleCustomOperation class ?\nApparently i am not the only one who has a need with this feature : @zcelaloglu , i am sure we can find other people :) . Any news about integrating this feature in this shape or another @dariuszseweryn ?. We worked on the service changed BLE feature (0x2A05) cause iOS needs it to be able to refresh services, it works fine with it. On Android we can see in HCI log the incoming command but the GATT does not refresh the services list and there is no event fired by the GATT to handle...\nSo the only possibility is to refresh the service list manually that is trivial in gatt direct access but locked here.... Hi,\nafter a lot of tests, this can be reproduce with the Android Gatt directly so it's not due to the rxAndroidBle lib.\nThe problem should be on the side of the BLE device where it is missing something but we still did not know.. We got an another BLE device (sample chip from another manufacturer) and no issue with it.... ",
    "markotron": "In the meantime, if you're using RxJava2Intreop check this issue: https://github.com/akarnokd/RxJava2Interop/issues/21. ",
    "Deemonser": "Here's another soul craving for rxjava2 support        +1. ",
    "nightscape": "There is another fork from @gryffindor14 which uses Android-Scanner-Compat-Library.\nAFAIS this uses the new APIs if available and has backports for older Android versions.\n@gryffindor14 is your fork ready for a PR?\n. @aldoborrero I guess you are referring to this one? https://github.com/NordicSemiconductor/Android-Scanner-Compat-Library/issues/1\nThat should be fixed since 0.1.2. The gryffindor14 fork uses 0.2.0, so that should be fine.\nI'm also using the gryffindor14 fork (exactly because of its use of Android-Scanner-Compat-Library) and it seems to be working fine so far.\nProbably @gryffindor14, @bobroalexandr and @dariuszseweryn should decide how to proceed and which fork/PR/commit to merge.\n. Because the dependency as stated in the README does not seem to exist on the official Maven repos:\nhttp://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.polidea.rxandroidble%22\nhttps://mvnrepository.com/artifact/com.polidea.rxandroidble\nhttps://oss.sonatype.org/#nexus-search;quick~rxandroidble\nAn artifact called mockclient does exist in the repos and it seems to contain the code that is described in the README.\n. That's what I'm trying to do in this PR :confused: \nNow you really got me confused...\n. I was doubting my sanity already :smile: \n. Our use case is that we start a device discovery and wait for a first device to be found. If after this first device a second device is found, we show a dialog to let the user choose between the two. If no other device is found, we wait for 5 seconds and then continue with the first device.\nA further test would then check that the connection to the chosen device was established correctly and thet we are reading from that device.\nI could hide the RxBleDeviceMock and RxBleConnectionMock behind interfaces that extend RxBleDevice and RxBleConnection and expose methods for stubbing data retrieval etc, but I guess that would only slightly improve things.. @mzgreen @uKL I just rebased my changes on the latest master branch.\nAre there any open questions or anything I can do to move this forward?. Hi @uKL, thanks for your support and merging!\nOne note about your  comment on PublishSubject vs ReplaySubject:\nCurrently the method createScanOperation and getBleDevice rely on the fact that the discovered devices are memoized and can be replayed to new observers (which I assume the filter and first methods create). Probably there is a nicer option to do this, I'm a relative Rx noob :wink:. Another maybe even nicer option would be to add a constructor that directly takes an Observable that gets assigned to the discoveredDevicesSubject field. That would give users complete freedom on when which devices appear and disappear (and maybe even the scan error stuff?).\nI just tried to stick close to the current implementation in order to increase the chances to get this in ;). ",
    "gryffindor14": "@nightscape It pretty much is. I am using it in a personal project and it seems to be working great. I have some Mock objects I wanted to create for MockRxAndroidBLE before the PR and I wasn't sure about the licensing with the Android-Scanner-Compat-Library. The library is BSD-3. \nKudos to @bobroalexandr. His start and this PR helped structure my fork quite a bit.\n. Hey @dariuszseweryn, thanks for taking a look at this. For us, yes, receiving the indication is important to the transmission. \nOur use case is that when we subscribe to the characteristic it fires a characteristic change event with a value. We then write to another characteristic which causes us to receive another characteristic change event with another value that we combine into a key. \nI have had better results when writing the client descriptor myself while starting to observe the change event from RxBleGattCallback.\nconnection.setupNotification(characteristic, NotificationSetupMode.COMPAT)\n    .flatmap(observable-> Observable.combineLatest(observable, writeClientDescriptor(connection), \n          return bytes; //from observable\n)\n. The characteristic doesn't have a read property associated with it so unfortunately that will not work. The workaround I mention in my last comment seems to be working very well.\nRelated to that workaround, is there any way to remove the dependency on dagger or a way to generate the classes from the command line. I am porting my library to Xamarin and getting ClassNotFoundExceptions for the generated dagger components. \nVersion 1.1.0 works with Xamarin fine, but the setCharacteristicNotification method with the NotificationSetupMode value is not available until version 1.2.0 which also bundles the Dagger components . Thanks very much for your help. I got the xamarin binding working, I was just missing a dependency jar. \nThe workaround is working for me and I will probably be using it as my base for setting up notifications and indications so I don't miss any in the future. I'm going to close this for now. It will require 1.2.0. I believe I posted how I got it to work in the\nthread. It requires setting up the notification with the NotificationCompat\noption.\nconnection.setupNotification(uuid, NotificationSetupMode.COMPAT)\n.flatmap { notification -> return\nnotification.mergeWith(connection.writeDescriptor(descriptor_uuid,\nBluetoothGattDescriptor.ENABLE_NOTIFICATIONS).ignoreElements())\nnote the ignoreElements() method at the end. This merges the notification\nbyte[] stream with the descriptorWrite byte[] stream but the write for the\ndescriptor is ignored.\ncombineLatest() also works as mentioned in the thread.\nconnection.writeDescriptor is a completeable in the rxjava2 version and\ntherefore does not emit any values. Good luck!\nGriffin\nOn Sat, Aug 11, 2018 at 7:44 AM SogoodIT notifications@github.com wrote:\n\n@gryffindor14 https://github.com/gryffindor14 @mswokk\nhttps://github.com/mswokk i'm meet the same issue on rxandroidble\nversion 1.1.0\uff0ccan you tell me how to fix this? preferably with 1.1.0, 1.2.0\nis also ok.That code is incomplete, i can't got u well, thanks.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Polidea/RxAndroidBle/issues/195#issuecomment-412269987,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABGR_wxNHRiL-XCZ9Qvpy0mEECVT408hks5uPsOagaJpZM4NfeUb\n.\n. Somewhat related, there is a different internal exception when trying to start scanning in the background while bluetooth is disabled. \n\njava.lang.SecurityException: Need BLUETOOTH_PRIVILEGED permission: Neither user 10188 nor current process has android.permission.BLUETOOTH_PRIVILEGED.\n        at android.os.Parcel.createException(Parcel.java:1942)\n        at android.os.Parcel.readException(Parcel.java:1910)\n        at android.os.Parcel.readException(Parcel.java:1860)\n        at android.bluetooth.IBluetoothGatt$Stub$Proxy.startScanForIntent(IBluetoothGatt.java:977)\n        at android.bluetooth.le.BluetoothLeScanner.startScan(BluetoothLeScanner.java:249)\n        at android.bluetooth.le.BluetoothLeScanner.startScan(BluetoothLeScanner.java:166)\n        at com.polidea.rxandroidble2.internal.util.RxBleAdapterWrapper.startLeScan(RxBleAdapterWrapper.java:57)\n        at com.polidea.rxandroidble2.internal.scan.BackgroundScannerImpl.scanBleDeviceInBackground(BackgroundScannerImpl.java:56). ",
    "philips77": "Hi,\nI'd gladly accept any PRs with tests or other features if required to Android Scanner Compat lib. We in Nordic are very happy that you find our libs useful.\nI have a lot of thing on my plate now and wouldn't be able to do it myself, at least not quickly.\n. ",
    "chuks": "Hi, was wondering if you got a chance to implement the API 21 scanning? Great library, otherwise.. Excellent...this is good news! I'm also trying this out today, and will let you know if I see any issues.. Did you figure out how to add multiple service UUIDs to the scan filter in this new API? On the platform's API, you can use a List to create the scan, but i can't figure out how to add multiple service UUIDs to this new API.. AND.  I'm working on a custom product with two very specific services. I only want to find this product in a scan. In the previous implementation (using AOSP), I just create a List containing with both UUIDs and use in the scan filter.. Also, just read up bug #194. What's the work around for that? I will also doing long/continuous background scanning.. Ok, for #194, that's what I currently do with the platform's default scan -- I do intermittent 10 seconds scans, with 5 seconds pauses. I'll transfer that implementation to this new API.\nAs for the scan filter, yes, it would be great to have filter created directly with multiple UUID in a List, just like how it's done in the default platform. If I add one Scan filter with a UUID, how does the next filter get to the second one? Can you share a code snippet on how I can achieve that? I'm basically trying to find all devices that's advertising either UUID 1 (the custom UUID) OR UUID 2 (the DFU UUID -- when the device is in DFU state). Sorry, I incorrectly stated AND, instead of OR, in my previous post.. Sorry, I mis-stated.  The custom devices I'm working with advertise either UUID 1 or UUID 2, so I'm trying to scan for any devices advertising either of both UUIDs. How do I achieve that in a single ScanSettings with this new API?. Thanks. So something like this:\nrxBleClient.scanBleDevices(\n                ScanSettings,\n                new ScanFilter.Builder()\n                        .setServiceUuid(ParcelUuid.fromString(UUID1))\n                        .setServiceUuid(ParcelUuid.fromString(UUID2))\n                        .build()\n        ). Ok --awesome, thanks!. @RobLewis here's a good explanation of the changes API 21 brought to BLE on Android - http://www.argenox.com/blog/android-5-0-lollipop-brings-ble-improvements/. This RxAndroidBle was using the older Android BLE implementation, pre-API 21. \"API 21 scanning\" basically means supporting the newer Android BLE API in this library. Hope that helps!. Great, just reading those! I'm also happy to help, if you need any help. This is a great library. I had written one myself for internal projects, and was looking to open source it when I found this one, and I figured instead of releasing of mine, I could help you with yours, if needed. Do you have a timeline on when you think you'll release the new 1.3.0 version?. @dariuszseweryn  thanks, here are the relevant logs with Verbose. Using this API, I am receiving the custom characteristic changes from the notifications but not the battery level changes.\n\n05-29 12:45:36.852 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationScanApi21(65643822)\n05-29 12:45:36.852 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationScanApi21(65643822)\n05-29 12:45:36.874 20244-20323/com.testapp.rxtestapp I/Adreno: QUALCOMM build                   : 6818200, Idb2b4cb785\n                                                                  Build Date                       : 11/18/16\n                                                                  OpenGL ES Shader Compiler Version: XE031.09.00.04\n                                                                  Local Branch                     : N25\n                                                                  Remote Branch                    : \n                                                                  Remote Branch                    : \n                                                                  Reconstruct Branch               : \n05-29 12:45:36.881 20244-20323/com.testapp.rxtestapp I/OpenGLRenderer: Initialized EGL, version 1.4\n05-29 12:45:36.881 20244-20323/com.testapp.rxtestapp D/OpenGLRenderer: Swap behavior 1\n05-29 12:45:36.890 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:45:36.894 20244-20257/com.testapp.rxtestapp D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5 mClientIf=0\n05-29 12:45:36.899 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationScanApi21(65643822)\n05-29 12:45:37.128 20244-20249/com.testapp.rxtestapp I/art: Do partial code cache collection, code=20KB, data=56KB\n05-29 12:45:37.128 20244-20249/com.testapp.rxtestapp I/art: After code cache collection, code=20KB, data=56KB\n05-29 12:45:37.128 20244-20249/com.testapp.rxtestapp I/art: Increasing code cache capacity to 256KB\n05-29 12:45:37.586 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class com.testapp.rxtestapp.broadcasts.NetworkBroadcast\n05-29 12:45:37.586 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n05-29 12:45:37.662 20244-20249/com.testapp.rxtestapp I/art: Compiler allocated 4MB to compile java.lang.String com.testapp.rxtestapp.utils.APIHelper.makeRequest(java.lang.String, java.lang.String, java.lang.String)\n05-29 12:45:41.788 20244-20278/com.testapp.rxtestapp V/FA: Inactivity, disconnecting from the service\n05-29 12:45:43.297 20244-20244/com.testapp.rxtestapp I/com.testapp.rxtestapp.app.Rxtestapp: getRxBleClient\n05-29 12:45:43.323 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(106250063)\n05-29 12:45:43.324 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(106250063)\n05-29 12:45:43.336 20244-20244/com.testapp.rxtestapp V/RxBle#BleConnectionCompat: Connecting without reflection\n05-29 12:45:43.337 20244-20244/com.testapp.rxtestapp D/BluetoothGatt: connect() - device: C5:82:E1:4D:93:32, auto: false\n05-29 12:45:43.337 20244-20244/com.testapp.rxtestapp D/BluetoothGatt: registerApp()\n05-29 12:45:43.338 20244-20244/com.testapp.rxtestapp D/BluetoothGatt: registerApp() - UUID=25978641-894b-49f8-b612-dbf167edf0ef\n05-29 12:45:43.340 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class com.testapp.rxtestapp.bus_events.RxtestappConnectionEvent\n05-29 12:45:43.340 20244-20257/com.testapp.rxtestapp D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n05-29 12:45:43.340 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n05-29 12:45:43.739 20244-20256/com.testapp.rxtestapp D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=C5:82:E1:4D:93:32\n05-29 12:45:43.742 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n05-29 12:45:43.769 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(106250063)\n05-29 12:45:43.769 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(64721463)\n05-29 12:45:43.770 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(64721463)\n05-29 12:45:43.774 20244-20244/com.testapp.rxtestapp D/BluetoothGatt: discoverServices() - device: C5:82:E1:4D:93:32\n05-29 12:45:44.747 20244-20257/com.testapp.rxtestapp D/BluetoothGatt: onSearchComplete() = Device=C5:82:E1:4D:93:32 Status=0\n05-29 12:45:44.749 20244-20257/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n05-29 12:45:44.753 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(64721463)\n05-29 12:45:44.754 20244-20244/com.testapp.rxtestapp I/com.testapp.rxtestapp.app.Rxtestapp: getRxBleClient\n05-29 12:45:44.760 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(185798987)\n05-29 12:45:44.761 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(185798987)\n05-29 12:45:44.761 20244-20244/com.testapp.rxtestapp I/com.testapp.rxtestapp.app.Rxtestapp: getRxBleClient\n05-29 12:45:44.776 20244-20244/com.testapp.rxtestapp D/BluetoothGatt: setCharacteristicNotification() - uuid: 0000fad4-0eea-45d1-a44a-bb3ce36fced6 enable: true\n05-29 12:45:44.789 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(93582144)\n05-29 12:45:44.792 20244-20244/com.testapp.rxtestapp D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a19-0000-1000-8000-00805f9b34fb enable: true\n05-29 12:45:44.797 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(28407242)\n05-29 12:45:44.807 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class com.testapp.rxtestapp.bus_events.RxtestappConnectionEvent\n05-29 12:45:44.807 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n05-29 12:45:44.816 20244-20249/com.testapp.rxtestapp I/art: Do full code cache collection, code=86KB, data=122KB\n05-29 12:45:44.817 20244-20249/com.testapp.rxtestapp I/art: Starting a blocking GC JitCodeCache\n05-29 12:45:44.817 20244-20249/com.testapp.rxtestapp I/art: After code cache collection, code=82KB, data=86KB\n05-29 12:45:44.895 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000fad8-0eea-45d1-a44a-bb3ce36fced6 status=0\n05-29 12:45:44.898 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(185798987)\n05-29 12:45:44.898 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(93582144)\n05-29 12:45:44.988 20244-20257/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n05-29 12:45:44.991 20244-20257/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:44.998 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(93582144)\n05-29 12:45:45.000 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(28407242)\n05-29 12:45:45.077 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n05-29 12:45:45.084 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(28407242)\n05-29 12:45:45.123 20244-20257/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:46.775 20244-20278/com.testapp.rxtestapp V/FA: Session started, time: 682322151\n05-29 12:45:46.782 20244-20278/com.testapp.rxtestapp I/FA: Tag Manager is not found and thus will not be used\n05-29 12:45:46.790 20244-20278/com.testapp.rxtestapp D/FA: Logging event (FE): _s, Bundle[{_o=auto, _sc=MainActivity, _si=-3766302981491032370}]\n05-29 12:45:46.824 20244-20278/com.testapp.rxtestapp V/FA: Using measurement service\n05-29 12:45:46.825 20244-20278/com.testapp.rxtestapp V/FA: Connecting to remote service\n05-29 12:45:46.832 20244-20278/com.testapp.rxtestapp D/FA: Connected to remote service\n05-29 12:45:46.832 20244-20278/com.testapp.rxtestapp V/FA: Processing queued up service tasks: 1\n05-29 12:45:46.853 20244-20244/com.testapp.rxtestapp I/com.testapp.rxtestapp.app.Rxtestapp: getRxBleClient\n05-29 12:45:46.858 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:45:51.870 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationScanApi21(500225)\n05-29 12:45:51.870 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationScanApi21(500225)\n05-29 12:45:51.871 20244-20278/com.testapp.rxtestapp V/FA: Inactivity, disconnecting from the service\n05-29 12:45:51.878 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:45:51.887 20244-20256/com.testapp.rxtestapp D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5 mClientIf=0\n05-29 12:45:51.896 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationScanApi21(500225)\n05-29 12:45:53.089 20244-20257/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:53.093 20244-20257/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:53.142 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class com.testapp.rxtestapp.bus_events.RxtestappUpdateEvent\n05-29 12:45:53.143 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n05-29 12:45:57.601 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:57.605 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:57.639 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class com.testapp.rxtestapp.bus_events.RxtestappUpdateEvent\n05-29 12:45:57.639 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n05-29 12:45:59.263 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:59.265 20244-20256/com.testapp.rxtestapp D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6\n05-29 12:45:59.295 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class com.testapp.rxtestapp.bus_events.RxtestappUpdateEvent\n05-29 12:45:59.296 20244-20244/com.testapp.rxtestapp D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n05-29 12:46:01.887 20244-20244/com.testapp.rxtestapp I/com.testapp.rxtestapp.app.Rxtestapp: getRxBleClient\n05-29 12:46:01.895 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:46:06.917 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationScanApi21(55743202)\n05-29 12:46:06.919 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationScanApi21(55743202)\n05-29 12:46:06.926 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:46:06.935 20244-20256/com.testapp.rxtestapp D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5 mClientIf=0\n05-29 12:46:06.940 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationScanApi21(55743202)\n05-29 12:46:16.929 20244-20244/com.testapp.rxtestapp I/com.testapp.rxtestapp.app.Rxtestapp: getRxBleClient\n05-29 12:46:16.940 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:46:21.949 20244-20302/com.testapp.rxtestapp D/RxBle#Radio:  STARTED RxBleRadioOperationScanApi21(51051310)\n05-29 12:46:21.950 20244-20244/com.testapp.rxtestapp D/RxBle#Radio:   QUEUED RxBleRadioOperationScanApi21(51051310)\n05-29 12:46:21.957 20244-20244/com.testapp.rxtestapp D/BluetoothAdapter: isLeEnabled(): ON\n05-29 12:46:21.966 20244-20257/com.testapp.rxtestapp D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5 mClientIf=0\n05-29 12:46:21.975 20244-20302/com.testapp.rxtestapp D/RxBle#Radio: FINISHED RxBleRadioOperationScanApi21(51051310)\n. @dariuszseweryn  See attached log file, couldn't find a way to format the logs into a readable format. I'm doing a scan, connecting to the device, discovering services, writing a custom value to a custom characteristic, and then setting notifications for battery level changes and the custom characteristic changes.  I can see that both notifications were set, from two entries like this: \nFINISHED RxBleRadioOperationDescriptorWrite however, I only receive the characteristic changes from the custom characteristic (UUID: 0000fad4-0eea-45d1-a44a-bb3ce36fced6), and not from the battery (UUID: 00002a19-0000-1000-8000-00805f9b34fb)\ntestlogs.txt\n. @dariuszseweryn Yes, that's the problem I'm seeing. It looks like both notifications are sent. I can see this line twice for after I send the notifications, indicating that both notifications have been sent:\nFINISHED RxBleRadioOperationDescriptorWrite\nBut I only receive the changes for the custom characteristic (I can see this line whenever I trigger a change onCharacteristicChanged characteristic=0000fad4-0eea-45d1-a44a-bb3ce36fced6), and not from the battery changes. . How else can I verify? This is the code I'm using to combine both characteristics:\n\n```\nprivate Observable> setupNotifications(RxBleConnection connection,\n                                                                                     List characteristics) {\n        Helper.getInstance().debug(TAG,\"setupNotifications\");\n    return Observable.from(characteristics) // deal with every characteristic separately\n            .filter(characteristic -> (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_NOTIFY) != 0) // filter characteristics that have notify property\n            .flatMap(characteristic -> connection\n                            .setupNotification(characteristic) // setup notification for each\n                            .flatMap(observable -> observable), // to get the raw bytes from notification\n                    Pair::new); // merge characteristic with byte[] to keep track from which characteristic the bytes came\n}\n\n```\nwhere the List is just \nList<BluetoothGattCharacteristic> characteristics = new ArrayList<>();\n            characteristics.add(mSwitchCharacteristic);             \n            characteristics.add(mBatteryLevelCharacteristic);\n. Yes, it's the same code. I had to clean up the logs and remove some proprietary info before posting the logs. Also, here's something I find interesting. If I set notifications for only the custom characteristic (i.e. without the battery), I get the custom characteristic changes notifications as expected. If I do the reverse, i.e. set notifications for only battery changes without the custom characteristics, I do not get anything. . Using the default Android API directly for the same process, I can set both notifications and receive changes on both, so I'm wondering if the code above is wrong, but why only battery level changes? Even if I swap the order in the List, I never receive the battery notification. \" I wonder what would happen if you would switch the place of the characteristics when adding to the List\"\nThat's what I did. I added battery first, then the other one, but got the same behavior.  Yes, the logs from the library do look good. What if I don't combine setting both notification, i.e. if I set them separately with two separate calls?. @dariuszseweryn ok --it is working now. It takes a very long time before the battery notifications start coming in. No code changes needed. I think the delay must be from the peripheral side, since the custom starts immediately. Can close this, thanks!. ",
    "sebirdman": "Are there any plans to continue forward with this PR or is there a plan to update outside of it? I've noticed when finding a single device (with a unique uuid) in an area with a ton of other devices (with their different uuid) i see a much longer search times when using this library vs searching myself with the updated >=21 search api.. Ah i see, ok that makes sense :P. ",
    "passsy": "\u2764\ufe0f  I'll check the code and add additional fixes/improvements I'm maintaining on my fork . accidentally opened it here. Not ready yet. It's not possible to parse Logcat from the app. Rebased, added to feature to CHANGELOG and README.md. It is stable since com.android.tools.build:gradle:2.2.2'. Furthermore the apt plugin will not work with the new 3.+ version of the android gradle plugin.\n\nandroid-apt plugin users: This behavior change currently does not affect the android-apt plugin. However, the plugin will not be compatible with future versions of the Android plugin for Gradle.\n\nvia Use the annotation processor dependency configuration. That's a normal behavior of the JVM. It's not possible to release objects without the GC. . the ScanSettings should be a parameter so we can use SCAN_MODE_LOW_LATENCY. use ./gradlew wrapper --gradle-version 4.1 --distribution-type all to upgrade gradle. You did not update the gradle-wrapper.jar. 4.3 is available, why have you picked 4.1? . ",
    "zhangyud": "I have same situation,  and I use 1.1.0. basically, same with origin code:\nmy code:\nconnection.setupNotification(serial_char)\n.subscribe(new Subscriber<Observable<byte[]>>() {\n    onCompleted(){\n    }\n    onError(Throwable){\n    }\n    onNext(byte[] result){\n        Log.d(TAG, \"result:%d\", result[0]);\n    }\n});\ndevice serial_char notify seq:\ntime: char: content\n0: serial_char, 0\n20: serial_char, 1\n40: serial_char, 2\n60: serial_char, 3\nmobile received serial_char notify seq:\nchar: content\nserial_char, 1\nserial_char, 0\nserial_char, 2\nserial_char, 3\nwhen I change RxBleGattCallback\n@NonNull\n    private Observable<ByteAssociation<BluetoothGattCharacteristic>> just(BluetoothGattCharacteristic bluetoothGattCharacteristic) {\n        final byte[] value = bluetoothGattCharacteristic.getValue();\n        //this is my changed code\n        return Observable.just(ByteAssociation.create(bluetoothGattCharacteristic, value));\n//        this is the origin code\n//        return Observable.defer(() -> Observable.just(ByteAssociation.create(bluetoothGattCharacteristic, value)));\n    }\nIt work always fine.. this is the real device log:\n12-12 12:16:08.046 18733-18756/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000aaa5-0000-1000-8000-00805f9b34fb status=0\n12-12 12:16:08.046 18733-18756/com.zmlock.zimalock D/RxBle#GattCallback: just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[-115, -96, 30, 28, 125, 17, -54, 95, 63, -90, 22, -121, -60, 45, 24, -98]\n12-12 12:16:08.051 18733-18761/com.zmlock.zimalock D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(65237909)\n12-12 12:16:08.106 18733-18806/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000aaa5-0000-1000-8000-00805f9b34fb\n12-12 12:16:08.106 18733-18806/com.zmlock.zimalock D/RxBle#GattCallback: just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[33, -17, -74, 65, -15, 7, 6, 83, 113, -70, 24, 83, -17, 5, 126, -4]\n12-12 12:16:08.106 18733-18806/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000aaa5-0000-1000-8000-00805f9b34fb\n12-12 12:16:08.111 18733-18806/com.zmlock.zimalock D/RxBle#GattCallback: just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[95, -111, -103, -92, -36, 50, -37, 42, -35, -98, -7, -18, 15, 6, -74, -37]\n12-12 12:16:08.111 18733-18794/com.zmlock.zimalock W/ProtocolQueue: content: 5F9199A4DC32DB2ADD9EF9EE0F06B6DB. I Suggest use this style:\n.java\nscheduler.createWorker().schedule(new Action0() {\n            @Override\n            public void call() {\n                //some code work in specificed scheduler\n                //and run it in order\n            }\n        }). I think the problem is that defer is not call in order\n2016-12-12 18:13 GMT+08:00 dariuszseweryn notifications@github.com:\n\nReopened #75 https://github.com/Polidea/RxAndroidBle/issues/75.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Polidea/RxAndroidBle/issues/75#event-890117528, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ACB1H9l5lM7rTznsyMOQ9M4xV3B7uoZFks5rHR5KgaJpZM4KHZyW\n.\n. I test this code, but problem is still there\nprivate final SerializedSubject<ByteAssociation<UUID>, ByteAssociation<UUID>> changedCharacteristicPublishSubject = PublishSubject.<ByteAssociation<UUID>>create().toSerialized();\n\nlog:\n12-13 10:33:06.116 19188-19493/com.zmlock.zimalock D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(759691432)\n12-13 10:33:06.116 19188-19235/com.zmlock.zimalock D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(759691432)\n12-13 10:33:06.126 19188-20104/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000aaa5-0000-1000-8000-00805f9b34fb status=0\n12-13 10:33:06.126 19188-20104/com.zmlock.zimalock D/RxBle#GattCallback: serialized just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[-104, 88, 108, 96, 41, 47, -113, -88, 124, -4, -11, 76, 90, -77, 100, -22]\n12-13 10:33:06.126 19188-19235/com.zmlock.zimalock D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(759691432)\n12-13 10:33:06.201 19188-20104/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000aaa5-0000-1000-8000-00805f9b34fb\n12-13 10:33:06.201 19188-20104/com.zmlock.zimalock D/RxBle#GattCallback: serialized just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[-2, 51, 110, 68, -100, 52, -22, -82, -107, -98, 16, 41, -54, 80, 82, -24]\n12-13 10:33:06.206 19188-20104/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000aaa5-0000-1000-8000-00805f9b34fb\n12-13 10:33:06.206 19188-20104/com.zmlock.zimalock D/RxBle#GattCallback: serialized just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[58, 109, 43, 77, -40, 14, -86, 93, -96, -51, 48, 15, -75, 90, 75, 105]\n12-13 10:33:06.211 19188-19494/com.zmlock.zimalock I/ProtocolQueue: send completed package: 068508000138160000005B9BC9F022F3C68890A543EBF5CC2B06164AEA6E0000 cmd:0008\n12-13 10:33:06.211 19188-20109/com.zmlock.zimalock D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(478862572)\n12-13 10:33:06.211 19188-19235/com.zmlock.zimalock D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(478862572)\n12-13 10:33:06.221 19188-19199/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000aaa5-0000-1000-8000-00805f9b34fb status=0\n12-13 10:33:06.226 19188-19199/com.zmlock.zimalock D/RxBle#GattCallback: serialized just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[49, 118, 89, -117, 65, -33, -37, 19, 36, -94, -120, -44, -124, -22, -34, -116]\n12-13 10:33:06.226 19188-19235/com.zmlock.zimalock D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(478862572)\n12-13 10:33:06.301 19188-19202/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000aaa5-0000-1000-8000-00805f9b34fb\n12-13 10:33:06.301 19188-19202/com.zmlock.zimalock D/RxBle#GattCallback: serialized just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[-43, 16, 62, 127, 111, -75, 23, -28, 126, 120, -10, -121, 69, -6, -26, 118]\n12-13 10:33:06.301 19188-19202/com.zmlock.zimalock D/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=0000aaa5-0000-1000-8000-00805f9b34fb\n12-13 10:33:06.301 19188-19202/com.zmlock.zimalock D/RxBle#GattCallback: serialized just uuid:0000aaa5-0000-1000-8000-00805f9b34fb content:[-73, 46, -123, -48, 124, 98, 4, -70, -26, -67, -62, 0, -105, 0, -97, -107]\n12-13 10:33:06.301 19188-19493/com.zmlock.zimalock W/ProtocolQueue: content: B72E85D07C6204BAE6BDC20097009F95. execute on specified scheduler\nObservable.just(1, 2, 3).map(new Func1<Integer, Integer>() {\n            @Override\n            public Integer call(Integer integer) {\n                Thread cur = Thread.currentThread();\n                System.out.printf(\"map:%d:%s:%d\\n\", cur.getId(), cur.getName(), integer);\n                return integer;\n            }\n        }).subscribeOn(Schedulers.io()).observeOn(Schedulers.newThread()).subscribe();. ",
    "Orbyt": "Will do.\n. Link: http://stackoverflow.com/questions/40031985/blegattexception-when-writing-to-a-particular-characteristic\n. This wouldn't be a suitable question for SO as there is no relevant code or examples to be presented, and it is more of a question of included functionality of this library. Please reconsider and let me know.\n. ",
    "golyu": "sorry,forgot to get back to you,you may need to update your Home 'README.md'\n. ",
    "sw-tt-rutulshah": "please define the difference of scanSubscription and connectedSubscription as I understand that it defined as Subscription and where to get the philRxAvailableUuid? main problem is to find the disconnect state..pl help. ",
    "iBotasky": "@dariuszseweryn OK\uff0cI got it ,Thanks for your help.\n. ",
    "bmc08gt": "Can gladly take care of that change. ",
    "mfatiga": "I have read through the issue in the link you provided and it seems this doesn't affect all Android devices or Android versions. I think the library should not explicitly require the Location Services to be on for all Android versions and devices, because the majority of the devices will scan normally without Location Services being turned on. I have tested BLE scanning on dozens of devices and have never encountered one that requires Location Services to be on to enable scanning.\nI currently don't have the time to do a pull request but it's a matter of removing one else if expression in the RxBleClientImpl.scanBleDevices method:\nelse if (checkIfLocationAccessIsEnabledIfRequired()) {\n    return Observable.error(new BleScanException(BleScanException.LOCATION_SERVICES_DISABLED));\n}. @dariuszseweryn I have been building all of the apps with target SDK 23 or greater, and none of the apps I work on currently require location so the location services are turned off on all of my test devices.\nDaily test devices (the apps are tested on those devices on a daily basis):\nLG G4 - Android 6.0\nSamsung Galaxy S5 neo - Android 6.0.1\nSamsung Galaxy S6 - Android 6.0.1\nSamsung Galaxy Tab A (7.0'') - Android 5.1.1\nSamsung Galaxy Tab 10.1'' - Android 6.0\nHuawei CAM-L21 - Android 6.0\nMe and my coworkers have also tested the apps on our personal devices and on many other devices from app users.. Thank you for all the effort!. ",
    "iLeafSolutionsPvtLtd": "Hi,  I just came across the same issue. Very few devices require location to be turned on for BLE callbacks and most of them are runs on Android Oreo. . ",
    "piotr-pawlowski": "I think you should not require location services to be enabled. On Samsung devices with Android 6+ BLE scanning works properly without location. In my app I inform users that location services should be enabled if there is no scan results, but this info disappears when first scan result occurs. I do not want to force users to enable location services.. ",
    "BudinMilk": "Hello!\nHere is my screen, the other buttons always disabled\n\nAnd here is my log, thank you!\nI/Timeline: Timeline: Activity_launch_request time:1395848\nV/BoostFramework: BoostFramework() : mPerf = com.qualcomm.qti.Performance@f6e496e\nV/BoostFramework: BoostFramework() : mPerf = com.qualcomm.qti.Performance@568f80f\nD/ActivityThreadInjector: clearCachedDrawables.\nD/OpenGLRenderer: endAllStagingAnimators on 0x55832f2350 (RippleDrawable) with handle 0x55832eee50\nD/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(222846792)\nD/RxBle#Radio:  STARTED RxBleRadioOperationConnect(222846792)\nD/BluetoothGatt: connect() - device: 18:7A:00:00:00:00, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=7059e136-3d1d-46ec-87b5-ff89b98333a3\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\nD/BluetoothGatt: onClientConnectionState() - status=133 clientIf=5 device=18:7A:00:00:00:00\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=133\nD/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(30052315)\nD/RxBle#RadioOperationConnect$$Lambda: No subscribers, finishing operation\nD/RxBle#Radio: FINISHED RxBleRadioOperationConnect(222846792)\nD/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(30052315)\nD/BluetoothManager: getConnectionState()\nD/BluetoothManager: getConnectedDevices\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=5\nD/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(30052315)\nD/AndroidRuntime: Shutting down VM\nE/AndroidRuntime: FATAL EXCEPTION: main\n                  Process: com.polidea.rxandroidble.sample, PID: 12309\n                  java.lang.NullPointerException: Attempt to invoke virtual method 'rx.Subscription rx.Observable.subscribe(rx.functions.Action1, rx.functions.Action1)' on a null object reference\n                      at com.polidea.rxandroidble.sample.example4_characteristic.CharacteristicOperationExampleActivity.onConnectToggleClick(CharacteristicOperationExampleActivity.java:116)\n                      at com.polidea.rxandroidble.sample.example4_characteristic.CharacteristicOperationExampleActivity_ViewBinding$1.doClick(CharacteristicOperationExampleActivity_ViewBinding.java:38)\n                      at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22)\n                      at android.view.View.performClick(View.java:5207)\n                      at android.view.View$PerformClick.run(View.java:21177)\n                      at android.os.Handler.handleCallback(Handler.java:739)\n                      at android.os.Handler.dispatchMessage(Handler.java:95)\n                      at android.os.Looper.loop(Looper.java:148)\n                      at android.app.ActivityThread.main(ActivityThread.java:5441)\n                      at java.lang.reflect.Method.invoke(Native Method)\n                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)\n                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628). ",
    "lovedise": "@dariuszseweryn yes, right\n. ",
    "mikolak": "Implemented. It is available as of now in 1.3.0-SNAPSHOT.. Now implemented. https://github.com/Polidea/RxAndroidBle/issues/111. I have modified IllegalOperationChecker.checkAnyPropertyMatches() to return Completable.fromCallable() and will upload it shortly.. Well, getters will increase the method count and all of these fields are immutable anyhow. Can be done, though I'm not sure if it should be.. I'm not sure. If it's supposed to be testable, then it would need to be instantiated. That would lead to increasing method count and I'm not that convinced that it would be useful anywhere else.. My fault for copy-paste without proof reading, not my grammar mistake. ;) Should I correct it elsewhere as well?. Should I correct it elsewhere as well?. For prettyness. [ ] looks better than [] if there are no properties and [ READ WRITE ] looks better than [READ WRITE ]. I decided to avoid tracking whether any property has already been matched or not. I admit that I wrote specifically for the message which puts the string in square brackets, so for the purpose of extracting it to a separate parser, maybe the brackets should be added to this function?. True, I'll extract it.. Just removed the exception in a refactor. ;). ",
    "svangsgaard": "Hi @dariuszseweryn \nYou're right. I need to change those things in the code.\nI have thought about how to implement it, maybe a better solution is to provide an extra parameter to setupNotification aka setupNotification(MY_UUID, CONNECTION_PRIORITY_HIGH), then the priority is automatically reverted when the notification is released.\nThat will solve my current problem. What do you think?\nRegards.\n. ",
    "kexuebiao": "Not all mobile phones will appear this problem,\nIn the HTC One A9 and XiaoMi Note find this problem\nthis is the main code i write,\nhttps://github.com/kexuebiao/bleDemo/blob/master/app/src/main/java/cc/ble/bledemo/module/BleDevice.java\n. Thank you reminded that I fix the code to see if i can solve this problem. ",
    "ClemMahe": "That's how i see it too but I got surprises with BLE & low-end devices. It seem that BLE does not like many connection/disconnection in a short interval : it makes serviceDiscovery fails sometimes.\nThanks @dariuszseweryn for your explaination.. ",
    "Ruifen9": "Thank you for your help, but now is China's Spring Festival, I'm on vacation, and had no device.. Google example requires UUID corresponding descriptors, in my test equipment is empty\uff0cbut using setNotification() is effective. Thanks very much. I also often encounter this problem when connecting the same device,you must call the \"BluetoothGatt.close()\" method of Google api. ",
    "Dionysios": "Hi! Here is the class.\n`\npublic class ConnectionActivity  extends RxAppCompatActivity  {\npublic static final String EXTRA_CHARACTERISTIC_UUID = \"extra_uuid\";\nprivate RxBleDevice mBleDevice;\nprivate Button mConnectToggleButton;\nprivate Button mReadButton;\nprivate Button mNotifyButton;\nprivate Button mWriteButton;\nprivate UUID characteristicUuid;\nprivate TextView mReadOutputView;\nprivate TextView mReadHexOutputView;\nprivate Observable<RxBleConnection> mConnectionObservable;\nprivate PublishSubject<Void> disconnectTriggerSubject = PublishSubject.create();\nprivate TextView mWriteInput;\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_example4);\n    characteristicUuid = (UUID) getIntent().getSerializableExtra(EXTRA_CHARACTERISTIC_UUID);\n    String macAddress = getIntent().getStringExtra(DeviceActivity.EXTRA_MAC_ADDRESS);\n    setTitle(getString(R.string.mac_address, macAddress));\n    mBleDevice = Application.getRxBleClient(this).getBleDevice(macAddress);\n\n    mConnectToggleButton = (Button) findViewById(R.id.connect);\n    mReadButton = (Button) findViewById(R.id.read);\n    mNotifyButton = (Button) findViewById(R.id.notify);\n    mReadOutputView = (TextView) findViewById(R.id.read_output);\n    mWriteButton = (Button) findViewById(R.id.write);\n    mReadHexOutputView = (TextView) findViewById(R.id.read_hex_output);\n    mWriteInput = (TextView) findViewById(R.id.write_input);\n\n    mConnectToggleButton.setOnClickListener(this::onConnectToggleClick);\n    mReadButton.setOnClickListener(this::onReadClick);\n    mWriteButton.setOnClickListener(this::onWriteClick);\n    mNotifyButton.setOnClickListener(this::onNotifyClick);\n    mConnectionObservable = prepareConnectionObservable();\n}\n\n\nprivate Observable<RxBleConnection> prepareConnectionObservable() {\n    return mBleDevice\n            .establishConnection(this, false)\n            .takeUntil(disconnectTriggerSubject)\n           // .compose(bindUntilEvent(PAUSE))\n            .doOnUnsubscribe(this::clearSubscription)\n            .compose(new ConnectionSharingAdapter());\n}\n\npublic void onConnectToggleClick(View view) {\n    if (isConnected()) {\n        Log.i(\"test\", \"we are here is \" + isConnected());\n        triggerDisconnect();\n    } else {\n        Log.i(\"test\", \"we are here new connection\");\n            mConnectionObservable.subscribe(rxBleConnection -> {\n                Log.d(getClass().getSimpleName(), \"Hey, connection has been established!\");\n                Log.d(\"test\", \"Hey, connection has been established!\");\n                //updateUI();\n                runOnUiThread(this::updateUI);\n            }, this::onConnectionFailure);\n\n\n    }\n}\n\npublic void onReadClick(View view) {\n    Log.d(\"test\", \"Calling read function\");\n    if (isConnected()) {\n        mConnectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.readCharacteristic(characteristicUuid))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    mReadOutputView.setText(new String(bytes));\n                    mReadHexOutputView.setText(HexString.bytesToHex(bytes));\n                   // mwriteInput.setText(HexString.bytesToHex(bytes));\n                }, this::onReadFailure);\n    }\n}\n\npublic void onNotifyClick(View view) {\n    Log.d(\"test\", \"Calling notifications\");\n    if (isConnected() && mConnectionObservable != null) {\n        Log.d(\"test\", \"Trying to set the notifivations\");\n        mConnectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.setupNotification(characteristicUuid))\n                .doOnNext(notificationObservable -> runOnUiThread(this::notificationHasBeenSetUp))\n                .flatMap(notificationObservable -> notificationObservable)\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(this::onNotificationReceived, this::onNotificationSetupFailure);\n    }\n}\n\npublic void onWriteClick(View view) {\n\n    if (isConnected() && mConnectionObservable != null) {\n        mConnectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUuid, getInputBytes()))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    onWriteSuccess();\n                }, this::onWriteFailure);\n    }\n}\n\nprivate boolean isConnected() {\n    return mBleDevice.getConnectionState() == RxBleConnection.RxBleConnectionState.CONNECTED;\n}\n\nprivate void onConnectionFailure(Throwable throwable) {\n    //noinspection ConstantConditions\n    updateUI();\n    Snackbar.make(findViewById(R.id.main), \"Connection error: \" + throwable, Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void onConnectionReceived(RxBleConnection connection) {\n    //noinspection ConstantConditions\n    Snackbar.make(findViewById(android.R.id.content), \"Connection received\", Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void onConnectionStateChange(RxBleConnection.RxBleConnectionState newState) {\n    //connectionStateView.setText(newState.toString());\n    updateUI();\n}\n\nprivate void onReadFailure(Throwable throwable) {\n    //noinspection ConstantConditions\n    Log.d(\"test\", \"Read failure\" + throwable);\n    Snackbar.make(findViewById(R.id.main), \"Read error: \" + throwable, Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void clearSubscription() {\n    mConnectionObservable = null;\n    Log.i(\"test\", \"Calling the ClearSubscription method\");\n    updateUI();\n}\n\nprivate void updateUI() {\n    mConnectToggleButton.setText(isConnected() ? getString(R.string.disconnect) : getString(R.string.connected));\n    mReadButton.setEnabled(isConnected());\n    mWriteButton.setEnabled(isConnected());\n    mNotifyButton.setEnabled(isConnected());\n}\n\nprivate void triggerDisconnect() {\n    disconnectTriggerSubject.onNext(null);\n}\n\nprivate void notificationHasBeenSetUp() {\n    //noinspection ConstantConditions\n    Snackbar.make(findViewById(R.id.main), \"Notifications has been set up\", Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void onNotificationReceived(byte[] bytes) {\n    //noinspection ConstantConditions\n    Log.i(\"test\", \"notifications\" + HexString.bytesToHex(bytes));\n    Snackbar.make(findViewById(R.id.main), \"Change: \" + HexString.bytesToHex(bytes), Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void onNotificationSetupFailure(Throwable throwable) {\n    //noinspection ConstantConditions\n    Snackbar.make(findViewById(R.id.main), \"Notifications error: \" + throwable, Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void onWriteSuccess() {\n    //noinspection ConstantConditions\n    Snackbar.make(findViewById(R.id.main), \"Write success\", Snackbar.LENGTH_SHORT).show();\n}\n\nprivate void onWriteFailure(Throwable throwable) {\n    //noinspection ConstantConditions\n    Snackbar.make(findViewById(R.id.main), \"Write error: \" + throwable, Snackbar.LENGTH_SHORT).show();\n}\n\nprivate byte[] getInputBytes() {\n    return HexString.hexToBytes(mWriteInput.getText().toString());\n}\n\n}\n`\nand the log also filtered by tag test\n01-26 18:03:07.506 6061-6061/com.semcon.ble.myapplicationble I/test: we are here new connection\n01-26 18:03:07.907 6061-6197/com.semcon.ble.myapplicationble D/test: Hey, connection has been established!\n01-26 18:03:09.217 6061-6061/com.semcon.ble.myapplicationble D/test: Calling read function\n01-26 18:03:09.355 6061-6061/com.semcon.ble.myapplicationble D/test: Read failurejava.lang.ClassCastException: rx.Observable cannot be cast to byte[]\n01-26 18:03:12.143 6061-6061/com.semcon.ble.myapplicationble D/test: Calling read function\n01-26 18:03:12.229 6061-6061/com.semcon.ble.myapplicationble D/test: Read failurejava.lang.ClassCastException: rx.Observable cannot be cast to byte[]\n. Library version should be \n`<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.polidea.rxandroidble\"\n\nandroid:versionCode=\"1\"\n\nandroid:versionName=\"1.1.0-SNAPSHOT\" >`\n\nGet stacktrace does not return a lot\n01-26 18:33:34.176 20278-20278/com.semcon.ble.myapplicationble D/test: Calling read function\n01-26 18:33:39.422 20278-20278/com.semcon.ble.myapplicationble D/test: Read failure[Ljava.lang.StackTraceElement;@3a01228\n01-26 18:33:39.423 20278-20278/com.semcon.ble.myapplicationble D/test: Read failurejava.lang.ClassCastException: rx.Observable cannot be cast to byte[]\nShould I try with another version of the library?. Hi! I managed to solve it by a number of things.\nUpdate android build tools from 2.1.3 -> 2.2.3\nimport the library straigh from gradle -> compile \"com.polidea.rxandroidble:rxandroidble:1.1.0\"\nadd the retrolambda plugin as you have it on the installation instructions\nand finally and most important remove  jackOptions I had before . ",
    "Kovartthan": "Yes, I also having this issue .....if anyone know how to fix it!!!! . I was trying to connect the beacon with Samsung S3 (Android 4.3 )  . I am getting success for read/ write operation but sometimes it throws the BleGatt Exception Status 133 at some point but i need result constantly . I need to know What is that exception ? Why it is occurring . I am agree with your above point and it s absolutely true Mr . dariuszseweryn  that BLE Stack is not very stable .. Above 5.0 android devices also sometimes i got that error .. :(  @dariuszseweryn \n. ",
    "Prethiviraj": "i  am having issue on 129  Discovery service  ,it does't constant service discovery sometimes read write faster but sometime  fires the error .... ",
    "fabiorodella": "Sure thing, here you go (the new doOnSubscribe logs start with Actually subscribing...):\nThis next block is the \"pairing process\" where I write to a characteristic in the scale and it turns off immediately after:\nD/BluetoothService: Subscribing connection state with ID bfaf7229-b764-4351-b861-df2be160d2c7\nD/BluetoothService: Creating connection observable for A&D_UC-352BLE_459997\nD/BluetoothService: Actually subscribing connection observable for A&D_UC-352BLE_459997\nD/BluetoothService: Connection state changed for A&D_UC-352BLE_459997: RxBleConnectionState{CONNECTING}\nD/BluetoothService: Subscribing write with ID d2407256-a1a5-4036-bf67-3ee43822e7c9\nD/BluetoothGatt: connect() - device: 6C:EC:EB:45:99:97, auto: true\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=25f1b2fb-e8b8-4ec0-b033-3f3eaa6051d2\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=6C:EC:EB:45:99:97\nD/BluetoothService: Connection state changed for A&D_UC-352BLE_459997: RxBleConnectionState{CONNECTED}\nD/BluetoothService: Device is alread bonded\nD/BluetoothGatt: discoverServices() - device: 6C:EC:EB:45:99:97\nD/BluetoothGatt: onSearchComplete() = Device=6C:EC:EB:45:99:97 Status=0\nD/BluetoothService: Unsubscribing connection observable for A&D_UC-352BLE_459997\nD/BluetoothService: Connection state changed for A&D_UC-352BLE_459997: RxBleConnectionState{DISCONNECTED}\nD/BluetoothService: Unsubscribing write with ID d2407256-a1a5-4036-bf67-3ee43822e7c9\nD/BluetoothManager: getConnectionState()\nD/BluetoothManager: getConnectedDevices\nD/BluetoothGatt: cancelOpen() - device: 6C:EC:EB:45:99:97\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=6C:EC:EB:45:99:97\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=6\nOnce I detect the device disconnected, I start the pending indication:\nD/BluetoothService: Starting pending connection for A&D_UC-352BLE_459997\nD/BluetoothService: Creating connection observable for A&D_UC-352BLE_459997\nD/BluetoothService: Actually subscribing connection observable for A&D_UC-352BLE_459997\nD/BluetoothService: Connection state changed for A&D_UC-352BLE_459997: RxBleConnectionState{CONNECTING}\nD/BluetoothService: Actually subscribing observation with ID 6C:EC:EB:45:99:97/23434100-1FE4-1EFF-80CB-00FF78297D8B/23434101-1fe4-1eff-80cb-00ff78297d8b\nD/BluetoothService: Subscribing observation with ID 6C:EC:EB:45:99:97/23434100-1FE4-1EFF-80CB-00FF78297D8B/23434101-1fe4-1eff-80cb-00ff78297d8b\nD/BluetoothGatt: connect() - device: 6C:EC:EB:45:99:97, auto: true\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=0f490655-fd02-4152-bb4f-deb0eabfc12f\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\nHere is when the user manually forgets the scale\nD/BluetoothService: Unsubscribing observation with ID 6C:EC:EB:45:99:97/23434100-1FE4-1EFF-80CB-00FF78297D8B/23434101-1fe4-1eff-80cb-00ff78297d8b\nD/BluetoothService: Unsubscribing connection state with ID bfaf7229-b764-4351-b861-df2be160d2c7\nAnd here is what happens when the scale becomes visible again\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=6C:EC:EB:45:99:97\nD/BluetoothService: Device is alread bonded\nD/BluetoothGatt: discoverServices() - device: 6C:EC:EB:45:99:97\nD/BluetoothGatt: onSearchComplete() = Device=6C:EC:EB:45:99:97 Status=0\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 23434101-1fe4-1eff-80cb-00ff78297d8b enable: true\nD/BluetoothService: Observation started for characteristic 23434101-1fe4-1eff-80cb-00ff78297d8b\nLet me know if I can help with anything else. Thanks!. This isn't clear because I left out the timestamps, but that is actually the whole log, I just split it into parts to be able to explain what each section is related to. And I'm pretty sure I'm not resubscribing anywhere, since I added log statements to every doOnSubscribe in my code.\nOne thing that looks odd to me is that the log from the doOnSubscribe block (Actually subscribing observation with ID...) is showing up before the log for when the whole chain is created (Subscribing observation with ID...), although RxJava is not really something I'm very familiar so this could be normal.\nI'll see if I can isolate a minimal code sample.. @dariuszseweryn after some more careful debugging I found that there was indeed a indication subscription still active. Sorry for the false alarm.. ",
    "larbirahmani": "Here it is, thank you \n```\n02/07 18:27:35: Launching app\n$ adb push C:\\Users\\Slash\\Desktop\\KMOV\\app\\build\\outputs\\apk\\app-debug.apk /data/local/tmp/com.example.kmov.kmov\n$ adb shell pm install -r \"/data/local/tmp/com.example.kmov.kmov\"\n    pkg: /data/local/tmp/com.example.kmov.kmov\nSuccess\n$ adb shell am start -n \"com.example.kmov.kmov/com.example.kmov.kmov.LoginActivity\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER\nConnected to process 1950 on device htc-0pja2-HT59CSV00879\nW/System: ClassLoader referenced unknown path: /data/app/com.example.kmov.kmov-1/lib/arm64\nI/InstantRun: Instant Run Runtime started. Android package is com.example.kmov.kmov, real application class is com.example.kmov.kmov.app.AppController.\nI/art: override thread count:-j3\nW/System: ClassLoader referenced unknown path: /data/app/com.example.kmov.kmov-1/lib/arm64\nI/FirebaseInitProvider: FirebaseApp initialization unsuccessful\nW/art: Before Android 4.1, method android.graphics.PorterDuffColorFilter android.support.graphics.drawable.VectorDrawableCompat.updateTintFilter(android.graphics.PorterDuffColorFilter, android.content.res.ColorStateList, android.graphics.PorterDuff$Mode) would have incorrectly overridden the package-private method in android.graphics.drawable.Drawable\nD/SQLiteHandler: Fetching user from Sqlite: {email=a, nom=a, created_at=2017-02-06 16:56:15, uid=58989c9faedc66.17771738}\nI/Adreno: QUALCOMM build                   : e8f6654, I8f3b63409d\n          Build Date                       : 12/16/15\n          OpenGL ES Shader Compiler Version: XE031.06.00.02\n          Local Branch                     : \n          Remote Branch                    : refs/tags/AU_LINUX_ANDROID_LA.BF64.1.2.2_RB4.06.00.00.180.011\n          Remote Branch                    : NONE\n          Reconstruct Branch               : NOTHING\nW/ample.kmov.kmov: type=1400 audit(0.0:46422780): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nD/SQLiteHandler: Fetching cl\u00e9 from Sqlite: {updated_at=2017-02-07 12:24:12, batterie=50, email=98:4F:EE:0D:17:0D, created_at=2017-02-07 12:24:12, etat=f, nom=98:4F:EE:0D:17:0D}\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/ample.kmov.kmov: type=1400 audit(0.0:46423251): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/ample.kmov.kmov: type=1400 audit(0.0:46423253): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nD/BluetoothGatt: connect() - device: 98:4F:EE:0D:17:0D, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=1138438a-41f4-49c6-9a1c-cfadf21a5087\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=98:4F:EE:0D:17:0D\nD/BluetoothGatt: discoverServices() - device: 98:4F:EE:0D:17:0D\nD/BluetoothGatt: onSearchComplete() = Device=98:4F:EE:0D:17:0D Status=0\nE/AndroidRuntime: FATAL EXCEPTION: pool-2-thread-1\n                  Process: com.example.kmov.kmov, PID: 1950\n                  java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n                      at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n                      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n                      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n                      at java.lang.Thread.run(Thread.java:818)\n                   Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n                      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n                      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n                      at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n                      at rx.internal.operators.OnSubscribeRefCount$2.onError(OnSubscribeRefCount.java:116)\n                      at rx.internal.operators.NotificationLite.accept(NotificationLite.java:132)\n                      at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(OperatorReplay.java:1085)\n                      at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:625)\n                      at rx.internal.operators.OperatorReplay$ReplaySubscriber.onError(OperatorReplay.java:452)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n                      at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:50)\n                      at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n                      at rx.Observable.unsafeSubscribe(Observable.java:10140)\n                      at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n                      at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n                      at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n                    at rx.internal.operators.OnSubscribeLift.call(OnSubscribe\nD/Error: ERR: exClass=java.lang.RuntimeException\nD/Error: ERR: exMsg=Can't create handler inside thread that has not called Looper.prepare()\nD/Error: ERR: file=Handler.java\nD/Error: ERR: class=android.os.Handler\nD/Error: ERR: method= line=200\nD/Error: ERR: stack=java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n             at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n             at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n             at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n             at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n             at java.lang.Thread.run(Thread.java:818)\n          Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n             at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n             at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n             at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n             at rx.internal.operators.OnSubscribeRefCount$2.onError(OnSubscribeRefCount.java:116)\n             at rx.internal.operators.NotificationLite.accept(NotificationLite.java:132)\n             at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(OperatorReplay.java:1085)\n             at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:625)\n             at rx.internal.operators.OperatorReplay$ReplaySubscriber.onError(OperatorReplay.java:452)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n             at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:50)\n             at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n             at rx.Observable.unsafeSubscribe(Observable.java:10140)\n             at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n             at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n             at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n             at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n             at rx.Observable.unsafeSubscribe(Observable.java:10140)\n            a\nD/Error: ERR: TOTAL BYTES WRITTEN: 49432\nD/Process: killProcess, pid=1950\nD/Process: com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException:113 java.lang.ThreadGroup.uncaughtException:693 java.lang.ThreadGroup.uncaughtException:690 \nApplication terminated.\n```. I didn't understand what you mean,\nhere it is again:\n. \n02/07 20:15:36: Launching app\n$ adb push C:\\Users\\Slash\\Desktop\\KMOV\\app\\build\\outputs\\apk\\app-debug.apk /data/local/tmp/com.example.kmov.kmov\n$ adb shell pm install -r \"/data/local/tmp/com.example.kmov.kmov\"\n    pkg: /data/local/tmp/com.example.kmov.kmov\nSuccess\n$ adb shell am start -n \"com.example.kmov.kmov/com.example.kmov.kmov.LoginActivity\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER\nConnected to process 16763 on device htc-0pja2-HT59CSV00879\nW/System: ClassLoader referenced unknown path: /data/app/com.example.kmov.kmov-2/lib/arm64\nI/InstantRun: Instant Run Runtime started. Android package is com.example.kmov.kmov, real application class is com.example.kmov.kmov.app.AppController.\nI/art: override thread count:-j3\nW/System: ClassLoader referenced unknown path: /data/app/com.example.kmov.kmov-2/lib/arm64\nI/FirebaseInitProvider: FirebaseApp initialization unsuccessful\nW/art: Before Android 4.1, method android.graphics.PorterDuffColorFilter android.support.graphics.drawable.VectorDrawableCompat.updateTintFilter(android.graphics.PorterDuffColorFilter, android.content.res.ColorStateList, android.graphics.PorterDuff$Mode) would have incorrectly overridden the package-private method in android.graphics.drawable.Drawable\nD/SQLiteHandler: Fetching user from Sqlite: {email=a, nom=a, created_at=2017-02-06 16:56:15, uid=58989c9faedc66.17771738}\nI/Adreno: QUALCOMM build                   : e8f6654, I8f3b63409d\n          Build Date                       : 12/16/15\n          OpenGL ES Shader Compiler Version: XE031.06.00.02\n          Local Branch                     : \n          Remote Branch                    : refs/tags/AU_LINUX_ANDROID_LA.BF64.1.2.2_RB4.06.00.00.180.011\n          Remote Branch                    : NONE\n          Reconstruct Branch               : NOTHING\nW/ample.kmov.kmov: type=1400 audit(0.0:46731200): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nD/SQLiteHandler: Fetching cl\u00e9 from Sqlite: {updated_at=2017-02-07 12:24:12, batterie=50, email=98:4F:EE:0D:17:0D, created_at=2017-02-07 12:24:12, etat=f, nom=98:4F:EE:0D:17:0D}\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/ample.kmov.kmov: type=1400 audit(0.0:46733020): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/ample.kmov.kmov: type=1400 audit(0.0:46740570): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nW/ample.kmov.kmov: type=1400 audit(0.0:46740941): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nI/art: Background partial concurrent mark sweep GC freed 19600(4MB) AllocSpace objects, 63(1788KB) LOS objects, 40% free, 17MB/28MB, paused 5.349ms total 57.069ms\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nD/BluetoothGatt: connect() - device: 98:4F:EE:0D:17:0D, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=aed15e11-f471-4c13-b0fb-3e5a8c4e9832\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=98:4F:EE:0D:17:0D\nD/BluetoothGatt: discoverServices() - device: 98:4F:EE:0D:17:0D\nD/BluetoothGatt: onSearchComplete() = Device=98:4F:EE:0D:17:0D Status=0\nE/AndroidRuntime: FATAL EXCEPTION: pool-2-thread-1\n                  Process: com.example.kmov.kmov, PID: 16763\n                  java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n                      at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n                      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n                      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n                      at java.lang.Thread.run(Thread.java:818)\n                   Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n                      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n                      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n                      at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n                      at rx.internal.operators.OnSubscribeRefCount$2.onError(OnSubscribeRefCount.java:116)\n                      at rx.internal.operators.NotificationLite.accept(NotificationLite.java:132)\n                      at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(OperatorReplay.java:1085)\n                      at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:625)\n                      at rx.internal.operators.OperatorReplay$ReplaySubscriber.onError(OperatorReplay.java:452)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n                      at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:50)\n                      at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n                      at rx.Observable.unsafeSubscribe(Observable.java:10140)\n                      at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n                      at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n                      at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n                    at rx.internal.operators.OnSubscribeLift.call(OnSubscrib\nD/Error: ERR: exClass=java.lang.RuntimeException\nD/Error: ERR: exMsg=Can't create handler inside thread that has not called Looper.prepare()\nD/Error: ERR: file=Handler.java\nD/Error: ERR: class=android.os.Handler\nD/Error: ERR: method= line=200\nD/Error: ERR: stack=java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n             at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n             at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n             at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n             at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n             at java.lang.Thread.run(Thread.java:818)\n          Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n             at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n             at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n             at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n             at rx.internal.operators.OnSubscribeRefCount$2.onError(OnSubscribeRefCount.java:116)\n             at rx.internal.operators.NotificationLite.accept(NotificationLite.java:132)\n             at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(OperatorReplay.java:1085)\n             at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:625)\n             at rx.internal.operators.OperatorReplay$ReplaySubscriber.onError(OperatorReplay.java:452)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n             at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:50)\n             at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n             at rx.Observable.unsafeSubscribe(Observable.java:10140)\n             at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n             at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n             at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n             at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n             at rx.Observable.unsafeSubscribe(Observable.java:10140)\n            a\nD/Error: ERR: TOTAL BYTES WRITTEN: 49432\nD/Process: killProcess, pid=16763\nD/Process: com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException:113 java.lang.ThreadGroup.uncaughtException:693 java.lang.ThreadGroup.uncaughtException:690 \nApplication terminated.\n. Sorry I don't understand how to do this.\nI have this activity that connects to the device (I have the MAC) and reads 2 characteristics.\nno matter where I declare the Rxbleclient I get the same error.. Ok, I've done that, and I get a similar error:\n02/07 20:56:48: Launching app\nCold swapped changes.\n$ adb shell am start -n \"com.example.kmov.kmov/com.example.kmov.kmov.LoginActivity\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER -D\nWaiting for application to come online: com.example.kmov.kmov.test | com.example.kmov.kmov\nConnecting to com.example.kmov.kmov\nW/ActivityThread: Application com.example.kmov.kmov is waiting for the debugger on port 8100...\nI/System.out: Sending WAIT chunk\nI/art: Debugger is active\nConnected to the target VM, address: 'localhost:8602', transport: 'socket'\nI/System.out: Debugger has connected\nI/System.out: waiting for debugger to settle...\nI/System.out: waiting for debugger to settle...\nI/System.out: waiting for debugger to settle...\nW/ample.kmov.kmov: type=1400 audit(0.0:47584337): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nI/System.out: waiting for debugger to settle...\nI/System.out: waiting for debugger to settle...\nI/System.out: waiting for debugger to settle...\nI/System.out: waiting for debugger to settle...\nI/System.out: debugger has settled (1423)\nW/System: ClassLoader referenced unknown path: /data/app/com.example.kmov.kmov-2/lib/arm64\nI/InstantRun: Instant Run Runtime started. Android package is com.example.kmov.kmov, real application class is com.example.kmov.kmov.app.AppController.\nI/art: override thread count:-j2\nW/System: ClassLoader referenced unknown path: /data/app/com.example.kmov.kmov-2/lib/arm64\nI/FirebaseInitProvider: FirebaseApp initialization unsuccessful\nW/ample.kmov.kmov: type=1400 audit(0.0:47585082): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nW/art: Before Android 4.1, method android.graphics.PorterDuffColorFilter android.support.graphics.drawable.VectorDrawableCompat.updateTintFilter(android.graphics.PorterDuffColorFilter, android.content.res.ColorStateList, android.graphics.PorterDuff$Mode) would have incorrectly overridden the package-private method in android.graphics.drawable.Drawable\nD/SQLiteHandler: Fetching user from Sqlite: {email=a, nom=a, created_at=2017-02-06 16:56:15, uid=58989c9faedc66.17771738}\nI/Adreno: QUALCOMM build                   : e8f6654, I8f3b63409d\n          Build Date                       : 12/16/15\n          OpenGL ES Shader Compiler Version: XE031.06.00.02\n          Local Branch                     : \n          Remote Branch                    : refs/tags/AU_LINUX_ANDROID_LA.BF64.1.2.2_RB4.06.00.00.180.011\n          Remote Branch                    : NONE\n          Reconstruct Branch               : NOTHING\nD/SQLiteHandler: Fetching cl\u00e9 from Sqlite: {updated_at=2017-02-07 12:24:12, batterie=50, email=98:4F:EE:0D:17:0D, created_at=2017-02-07 12:24:12, etat=f, nom=98:4F:EE:0D:17:0D}\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nW/OpenGLRenderer: Fail to change FontRenderer cache size, it already initialized\nD/BluetoothGatt: connect() - device: 98:4F:EE:0D:17:0D, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=8d03516d-7c57-4c07-9c91-e2fe55f0d8fb\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=98:4F:EE:0D:17:0D\nD/BluetoothGatt: discoverServices() - device: 98:4F:EE:0D:17:0D\nW/ample.kmov.kmov: type=1400 audit(0.0:47592131): avc: denied { getopt } for scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:r:zygote:s0 tclass=unix_dgram_socket permissive=0\nD/BluetoothGatt: onSearchComplete() = Device=98:4F:EE:0D:17:0D Status=0\nE/AndroidRuntime: FATAL EXCEPTION: pool-1-thread-1\n                  Process: com.example.kmov.kmov, PID: 10328\n                  java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n                      at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n                      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n                      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n                      at java.lang.Thread.run(Thread.java:818)\n                   Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n                      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n                      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n                      at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n                      at rx.internal.operators.OnSubscribeRefCount$2.onError(OnSubscribeRefCount.java:116)\n                      at rx.internal.operators.NotificationLite.accept(NotificationLite.java:132)\n                      at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(OperatorReplay.java:1085)\n                      at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:625)\n                      at rx.internal.operators.OperatorReplay$ReplaySubscriber.onError(OperatorReplay.java:452)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                      at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n                      at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                      at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n                      at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:50)\n                      at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n                      at rx.Observable.unsafeSubscribe(Observable.java:10140)\n                      at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n                      at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n                      at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n                    at rx.internal.operators.OnSubscribeLift.call(OnSubscrib\nD/Error: ERR: exClass=java.lang.RuntimeException\nD/Error: ERR: exMsg=Can't create handler inside thread that has not called Looper.prepare()\nD/Error: ERR: file=Handler.java\nD/Error: ERR: class=android.os.Handler\nD/Error: ERR: method= line=200\nD/Error: ERR: stack=java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n             at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\n             at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n             at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n             at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n             at java.lang.Thread.run(Thread.java:818)\n          Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n             at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:187)\n             at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n             at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n             at rx.internal.operators.OnSubscribeRefCount$2.onError(OnSubscribeRefCount.java:116)\n             at rx.internal.operators.NotificationLite.accept(NotificationLite.java:132)\n             at rx.internal.operators.OperatorReplay$BoundedReplayBuffer.replay(OperatorReplay.java:1085)\n             at rx.internal.operators.OperatorReplay$ReplaySubscriber.replay(OperatorReplay.java:625)\n             at rx.internal.operators.OperatorReplay$ReplaySubscriber.onError(OperatorReplay.java:452)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.observers.Subscribers$5.onError(Subscribers.java:230)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n             at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)\n             at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n             at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\n             at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:50)\n             at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n             at rx.Observable.unsafeSubscribe(Observable.java:10140)\n             at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n             at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n             at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\n             at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n             at rx.Observable.unsafeSubscribe(Observable.java:10140)\n            a\nD/Error: ERR: TOTAL BYTES WRITTEN: 49432\nD/Process: killProcess, pid=10328\nD/Process: com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException:113 java.lang.ThreadGroup.uncaughtException:693 java.lang.ThreadGroup.uncaughtException:690 \nDisconnected from the target VM, address: 'localhost:8602', transport: 'socket'\n. It works now ! thank you but the reading I'm getting is strange type, how can I cast it to a string? \n. I think it was the .observeOn(AndroidSchedulers.mainThread())\nbecause it wasn't in my code.\nand the strange type is caractest.setText(aBytes.toString());\nI get a code instead of the value of the characteristic\n. Yes it worked with it but it gives me only the first character, here's the code:\n```\n        subscription = device.establishConnection(this, false)\n                .flatMap(rxBleConnection -> Observable.combineLatest( // use the same connection and combine latest emissions\n                        rxBleConnection.readCharacteristic(mycara1), // sometimes IDE get's lost in what type is returned from an Observable - that's why I added \n                        rxBleConnection.readCharacteristic(mycara2),\n                        Pair::new // merge into a Pair\n                ))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(\n                        byteArrayPair -> {\n                            // here you get the latest values from notifications\n                            byte[] aBytes = byteArrayPair.first;\n                            byte[] bBytes = byteArrayPair.second;\n                            // do your thing\n                            try {\n                                caractest.setText(new String(aBytes, \"UTF-8\"));\n                                constate.setText(new String(bBytes, \"UTF-8\"));\n                            } catch (UnsupportedEncodingException e) {\n                                e.printStackTrace();\n                            }\n                        constate.setText(bBytes.toString());\n\n\n                    },\n                    throwable -> {\n                        Toast.makeText(this,throwable.toString(), Toast.LENGTH_LONG).show();\n                    }\n            );\n\n```. Yes, I'm getting only one byte, I search around and tried many tricks but non can do the work, any ideas would be very appreciated, thank you.. ",
    "cuihujun": "hello,\nthanks for the quick response\nthe one I used is 1.1.0.\nI just got the instance form RxBleClient.create()\nprivate RxBleDevice mRxBleDevice = null;\nmRxBleDevice = RxBleClient.create(mContext).getBleDevice(macAddress);\ncompile \"com.polidea.rxandroidble:rxandroidble:1.1.0\"\ncompile 'com.trello:rxlifecycle:1.0'\ncompile 'com.trello:rxlifecycle-components:1.0'\nOn Thu, Feb 9, 2017 at 12:07 AM, dariuszseweryn notifications@github.com\nwrote:\n\nHello,\nWhat version of the library do you use? How do you persist the instance of\nRxBleClient so it will not be garbage collected during you use the\nlibrary?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/Polidea/RxAndroidBle/issues/133#issuecomment-278573504,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADYGQbtkEuR5zy7fid5qgF8SSNttnarJks5raskvgaJpZM4L70co\n.\n. thanks for checking,\n\nI need to do BLE demo in short term, so I changed to Android BLE built-in\nlib.\nI will check it later.\nOn Mon, Feb 20, 2017 at 1:03 AM, dariuszseweryn notifications@github.com\nwrote:\n\nAny news? Has my last comment helped in your case?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/Polidea/RxAndroidBle/issues/133#issuecomment-281023102,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADYGQZcjvyP2eTyrCCtT3HC70S-NiCZqks5reVbvgaJpZM4L70co\n.\n. \n",
    "jcamins": "I confirmed that I could make the scan work by simply commenting out the location services check, but that doesn't really seem like something that should be upstreamed.. @DariuszAniszewski the only location option I can find on Android Wear is under Developer Options. Which makes sense, since Android Wear doesn't support location services at all.\nSo I guess the fact that you closed this means that you're officially not supporting Android Wear? That's a shame.. @dariuszseweryn sorry about that. GitHub autocompleted for me, apparently to the wrong person. My Asus ZenWatch 2 does not have a Location option in the main settings screen, and the one in the Developer Options doesn't seem to do anything (and doesn't seem like a reasonable thing to ask users to find, anyway). Your watch would seem to contradict the documentation, which says that location services are not available on Android Wear. Do you have Android Wear 2.0? Maybe support for location services is changing with AW 2.0.. How do I check the API version? I have Android Wear 1.5, but I don't know how to check API version.. Also, does your Sony SmartWatch 3 require location services? Maybe we could just check whether the user is on Wear when deciding whether or not to throw if the services are not enabled?. Ah, right. It wasn't in the settings, but according to Android Studio, ZenWatch 2 is also API 23.. I couldn't find anything about BLE on Android Wear online. Probably because AW 1 is intended to be used in concert with a phone.. @LadyViktoria the issue here is not location permissions, which I was able to grant, but rather location services, which are not necessarily available at all on Android Wear.. ",
    "LadyViktoria": "You need Location permission for scanning BT devices.\nMy advice is to use The Scanner from setting Men\u00fc. Boundcon BT device. And in your App get The bounded devices and Connect to Them. \nAppart from that habe a Look at this\nhttps://github.com/NightscoutFoundation/xDrip/blob/master/wear/src/main/java/com/eveningoutpost/dexdrip/LocationPermissionActivity.java\nMaybe ist is what you are looking for. repositories {\n        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }\n}\ndependencies {\n    compile 'com.polidea.rxandroidble:rxandroidble:1.2.0-SNAPSHOT'\n}. i am also interestd in that gatt things.\ni am still using 1.2.0 snapshot. \ni use a passive device that connects automatically to my phone.\nafter a while i get an error that GATT is null and cound not estab\u00f6ish the connection. ",
    "skynet67": "Hi there. \nI use 'autoConnect = false'. \nSimple log: https://gist.github.com/skynet67/9781916bd0f4ad02bc13ef183981e4d8\nFull log: https://gist.github.com/skynet67/372eaa1b55c260ab1650e32345f3f138. @Provides\n    @Singleton\n    RxBleClient provideRxBleClient(Application application) {\n        return RxBleClient.create(application);\n    }\n```\n  public Observable scan(UUID... services) {\n        return bleClient.scanBleDevices(services)\n                .doOnSubscribe(() -> lastFoundDevices.clear())\n                .map(result -> peripheralDeviceForMacAddress(result.getBleDevice().getMacAddress()))\n                .doOnNext(device -> lastFoundDevices.add(device))\n                .cast(Peripheral.class);\n    }\npublic PeripheralDevice peripheralDeviceForMacAddress(String macAddress) {\n        PeripheralDevice device = deviceHashMap.get(macAddress);\n        if (device == null) {\n            device = new PeripheralDevice(bleClient.getBleDevice(macAddress), context);\n            deviceHashMap.put(macAddress, device);\n        }\n        return device;\n    }\n```\nThan I try to connect.\nprivate Observable<RxBleConnection> getConnectionObservable(boolean isReconnect) {\n        return Observable.defer(() -> {\n            final AtomicReference<Throwable> receivedError = new AtomicReference<>(null);\n            return device\n                    .establishConnection(context, isReconnect)\n                    .compose(Rx.mainThread())\n                    // Set the device state to \"CONNECTING\" while connection isn't established yet\n                    .doOnSubscribe(() -> lastConnectionAttemptError = null)\n                    // If connection was successful - set the device state to \"CONNECTED\"\n                    .doOnNext(connectionSubject::onNext)\n                    ....\n                    .doAfterTerminate(() -> handleDisconnect(receivedError.get()));\n        });\n    }\n. This is our internal event that has nothing in common with BleState. So if device.getConnectionState() != RxBleConnection.RxBleConnectionState.CONNECTED and our currentState == CONNECTED, then we assume that device has been disconnected.. I don't know why disconnect operation is missing, but it should be there. \nanother logs:\n02-27 21:54:50.189 28285-28285/ D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(9103522)\n02-27 21:54:58.602 28285-28430/ D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(98404472)\n02-27 21:54:58.603 28285-28430/ D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(9103522)\n02-27 21:54:50.192 4216-4216/? D/BluetoothManager: getConnectedDevices\n02-27 21:54:50.192 28614-17457/? D/BtGatt.GattService: endServiceDeclaration()\n02-27 21:54:50.192 28614-17457/? D/BtGatt.GattService: continueServiceDeclaration() - srvcHandle=0\n02-27 21:54:50.192 28614-17457/? D/BtGatt.GattService: continueServiceDeclaration() - next entry type=1\n02-27 21:54:50.194 28614-28745/? D/BtGatt.GattService: onServiceAdded() UUID=badbadba-dbad-badb-adba-badbadbadbad, status=0, handle=46\n```\n02-27 22:51:27.011 19706-19706/ D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(248168893)\n02-27 22:51:27.013 19706-19814/ D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(248168893)\n02-27 22:51:27.042 19706-19706/ D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(160732205)\n02-27 22:51:29.025 19706-19706/ D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(256175985)\n02-27 22:51:31.483 19706-19706/ D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(174087640)\n02-27 22:51:37.056 19706-19814/ D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(248168893)\n02-27 22:51:37.056 19706-19814/ D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(160732205)\n02-27 22:51:37.060 19706-19814/ D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(160732205)\n02-27 22:51:37.060 19706-19814/ D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(256175985)\n02-27 22:52:31.486 19706-19824/ D/RxBle#Radio:  REMOVED RxBleRadioOperationScan(174087640)\n02-27 22:55:55.406 19706-19706/ D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(85307410)\n02-27 22:56:10.128 19706-19706/ D/RxBle#Radio:  REMOVED RxBleRadioOperationScan(85307410)\n----> here I turned bluetooth off from the settings\n02-27 23:00:15.389 19706-19706/ D/RxBle#RadioOperationConnect$$Lambda: No subscribers, finishing operation\n02-27 23:00:15.390 19706-19814/ D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(256175985)\n02-27 23:00:15.414 19706-19706/ D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(179183533)\n02-27 23:00:15.414 19706-19814/ D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(179183533)\n02-27 23:00:25.449 19706-19814/ D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(179183533)\n```\nAlso I have found only one reference to \"badbad\":\nBADBADBADBAD    \"Bad bad bad bad\", Burroughs large systems \"uninitialized\" memory (48-bit words). ",
    "ZhanR": ", please support the 6.0.1? I didn't run on 5.1.0 problems, running on the 6.0.1 appeared onNotificationReceived method is not called and writeCharacteristic write not to go out. ",
    "lukasblue": "Thank you very much for extremely quick response. \nYou have right, after turning off and on bluetooth on device everything works prefectly. Could you please tell me how can I get 1.2.0-SNAPSHOP. Maybe thats silly, but I cannot find such version. The last one is 1.1.0. From your answer I can suggest that this version (1.2.0-SNAPSHOT) will give me the access to BluetoothGatt and I will be able to refresh gatt via reflection. Is it possible to give me some example code for that (accessing gatt) ? . Thanks a lot. That's working property. \nCould you please give me any tip how to access BluetoothGatt - to refresh it ? . Thank you very much. That's working perfectly.. There is still one more issue in my code. To perform this custom method i have to subscribe on it. My code looks like this : \n`    private static class CustomGattRefreshOperation implements RxBleRadioOperationCustom\n    {\n        CustomGattRefreshOperation() {\n        }\n    @NonNull\n    @Override\n    public Observable<Void> asObservable(BluetoothGatt bluetoothGatt,\n                                           RxBleGattCallback rxBleGattCallback,\n                                           Scheduler scheduler) throws Throwable {\n        refreshDeviceCache(bluetoothGatt);\n        return null ;\n    }\n\n(...)\n}`\n_connection.queue(new CustomGattRefreshOperation())\n                .subscribe(result -> {\n                    Log.d(\"tag\",\"done\");\n                }, throwable -> {\n                    Log.d(\"tag\", \"error \"+throwable.toString());\n                });\nso obvious error in this case is : \njava.lang.IllegalArgumentException: The custom operation asObservable method must return a non-null observable\n. ",
    "gzhhong": "aha, you are right. Thank you so much!\n2017-03-10 20:40 GMT+08:00 dariuszseweryn notifications@github.com:\n\nHello.\nFrom the readme:\nObtaining the client\nIt's your job to maintain single instance of the client. You can use singleton, scoped Dagger component or whatever else you want.\nYou have to persist a reference to the RxBleClient object as long as you\nuse anything related to the library.\nBest Regards\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/Polidea/RxAndroidBle/issues/148#issuecomment-285659450,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAjv7larlxw7f_Cwf_MdLXf5VTFEOcgFks5rkUS9gaJpZM4MZUWc\n.\n. \n",
    "Xiadalei": "Version, location etc.\nI do believe this issue is resolved.. Just so you know, Jake update the repo for \"Clear cached value when upstream emits a terminal event\". ",
    "brightredchilli": "Alright, that sounds great - i imagine we'd need to maintain a separate dev branch while the server side stuff gets up to speed - its probably not going to have all of the layers and bells and whistles that the client side has for a bit. I'll start off with 'getWriteCharacteristic'(get all ble writes to a characteristic on this gatt server), in my opinion this has the least dependencies and is the easiest to understand.. ",
    "dustedrob": "Is there any ongoing work for this. Would love to collaborate?. ",
    "kobronson": "Hi @dariuszseweryn \nis there any plan to release RxAndroidBle version with server support? If yes, then when it is expected to arrive?. ",
    "EskelCz": "@DariuszAniszewski  I could really use this, how much work would a simple implementation take? Maybe I can fund a Bounty on it.. ",
    "blakopf": "Because it messes up my values.\nI setup my mock with various services and characteristics with values.\nIf I connect to the mock later and setupNotifications(...) for a UUID, the value of the characteristic for this UUID becomes 1 (and 0 if I unsubscribe from the notification):\nnew byte[]{(byte) (enable ? 1 : 0)}\nI think this is a bug and the value should not be overwritten.\n. That was fast, thank you very much.. ",
    "paulonova": "ok!. ",
    "jaychang0917": "In Settings -> Bluetooth -> Paired devices, it shows connected. oh, I get it! btw, if i call establishConnection two times, it will create two connections or reuse the existing connection?. Thanks!. So i need to monitor the connection state using observeConnectionStateChanges? is this method for checking ble or classic connection state?. What does single .subscribe() means?  Do you mean I need to chain establishConnection and writeCharacteristic when I want to write data? So observerConnectionStateChanges can't monitor ble connection state, right? \nIt is because BleDisconnectedException may be thrown when .establishConnection(), writeCharacteristic or readCharacteristic, is there any way that i can observe the ble connection state?. I have a method that will call writeCharacteristic several times in 1s, if i chain with establishConnection, is that ok?. And one thing i want to make sure, does unsubscribe the subscription created by establishConnection means closing the connection? Do i need unsubscribe the subscription created by writeCharacteristic as well?. Thanks your details explanation and advice. Thank you very much!. ",
    "IgorGanapolsky": "Thank you.  I am looking at OperationPriorityFifoBlockingQueue, RxBleClientImpl, and RxBleRadioImpl.. @dariuszseweryn Essentially putting what you just said in a JavaDoc comment for class declarations would be great.  The code may seem intuitive and straightforward to smart engineers like you :) , but believe me - this code is very non-trivial for newbies to BLE and those who are not experts in RxJava.  Additionally, each public method having a JavaDoc comment would make it a lot clearer to follow.. It adheres to:\nhttps://developer.android.com/studio/preview/features/java8-support.html\nand\nhttp://tools.android.com/tech-docs/new-build-system/2-5-alpha-gradle-plugin. ",
    "BharathMG": "Sure @uKL . I will add it.. @uKL My pleasure! Thanks for this wonderful library :) \nAdded a couple of tests. Let me know if I should change anything. . @dariuszseweryn  Got it. I will make the necessary changes.. Kindly check and let me know if anything is missing.. @dariuszseweryn Will this approach be fine? \n    given:\n    TestSubscriber testSubscriber = new TestSubscriber<>()\n    bleAdapterWrapperSpy.hasBluetoothAdapter() >> true\n    bleAdapterWrapperSpy.isBluetoothEnabled() >> true\n\n    when:\n    def scanObservable = objectUnderTest.scanBleDevices(null)\n\n    then:\n    0 * bleAdapterWrapperSpy.isBluetoothEnabled()\n\n    when:\n    scanObservable.subscribe(testSubscriber)\n\n    then:\n    1 * bleAdapterWrapperSpy.startLeScan(_) >> true. Got it. Do you think this would be fine using `where:` ?\n\n    def \"should check if all the conditions are met at the time of each subscription\"() {\n    given:\n    def firstSubscriber = new TestSubscriber<>()\n    def secondSubscriber = new TestSubscriber<>()\n    bleAdapterWrapperSpy.isBluetoothEnabled() >> bluetoothEnabled >> true\n    bleAdapterWrapperSpy.hasBluetoothAdapter() >> bluetoothAvailable >> true\n    locationServicesStatusMock.isLocationPermissionOk() >> locationPermissionsOk >> true\n    locationServicesStatusMock.isLocationProviderOk() >> locationProviderOk >> true\n    def scanObservable = objectUnderTest.scanBleDevices(null)\n\n    when:\n    scanObservable.subscribe(firstSubscriber)\n\n    then:\n    firstSubscriber.assertError {\n        BleScanException exception -> exception.reason == reason\n    }\n\n    when:\n    scanObservable.subscribe(secondSubscriber)\n\n    then:\n    secondSubscriber.assertNoErrors()\n    1 * bleAdapterWrapperSpy.startLeScan(_) >> true\n\n    where:\n    bluetoothAvailable | bluetoothEnabled | locationPermissionsOk | locationProviderOk | reason\n    false              | true             | true                  | true               | BLUETOOTH_NOT_AVAILABLE\n    true               | false            | true                  | true               | BLUETOOTH_DISABLED\n    true               | true             | false                 | true               | LOCATION_PERMISSION_MISSING\n    true               | true             | true                  | false              | LOCATION_SERVICES_DISABLED\n}.\n",
    "ingalvaror": "hi! thanks for your response! the time when the connections drops is around 1 minute, when i cancel the connection with triggerDisconnect  its ok, but when the connection drops itself i cant connect the device again, i have a question, in my observable i have this: \ntakeUntil(disconnectTriggerSubject)\n        .doOnUnsubscribe(this::triggerDisconnect)\nIs it necessary to use both methods or just use the takeuntil? do i have any error in the code that i wrote?. thanks for your response, i just want to be sure that the code is ok, this is running in a background service, i dont know if i have to write any additional code in this case, the proccess is: \n\ni start to scan\nwhen the device is detected, try to connect\nif gets connected i send a password through writecharacteristic  \nand then i send a command to turn on a light, then i send a command to turn off, \nthe device suddenly disconnect itself and i try to connect again, \nthis time the connection was done again but in some cases it seems that the connection is not closing. \n\nAnother thing is sometimes when i connect again, the method to send password is calling a couple of times, i dont know if this is related to the problem, if the observable is not closing or restarting or something, thanks, this is the code, please tell me if im doing something wrong or if there is a better method to do this, Thanks: \n///establish the connection\n```java\nconnectionObservable =  bleDevice\n        .establishConnection(getApplicationContext(), false)\n        .takeUntil(disconnectTriggerSubject)\n.retryWhen(new Func1, Observable<?>>() {\n                    @Override\n                    public Observable<?> call(Observable<? extends Throwable> errorNotification) {\n                        return errorNotification\n                                .flatMap(new Func1>() {\n                                    @Override\n                                    public Observable<?> call(Throwable throwable) {\n                                    return Observable.timer(10, TimeUnit.SECONDS);\n                                }\n                            });\n                }\n            })\n    .compose(new ConnectionSharingAdapter());\n    connectionObservable.subscribe(rxBleConnection -> {\n        Log.d(getClass().getSimpleName(), \"Hey, connection has been established!\");\n        sendPass();\n    }, this::onConnectionFailure);\n\nthe connection is done, so i send pass to be able to write\n    if (isConnected()) {\n\n        connectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUuid, password))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    onWriteSuccessPass();\n                }, this::onWriteFailure);\n    }\n\n```\nsend the command to turn off or turn on (this is called multiple times depending of the gps location)\n```java\n    public void changeLight(light) {\n        if (light.equals(\"on\")) {\n        sendCommand(on);\n\n    } else if (light.equals(\"off\")) {\n\n        sendCommand(off);\n    }\n}\n\npublic void sendCommand(byte[] bytesColor) {\n    if (isConnected()) {\n        connectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUuid, bytesColor))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    onWriteSuccessPermission();\n                }, this::onWriteFailure);\n    }\n}\n\n```\nso i dont know if calling the observable again to change the light or send the pass after reconnection is related with the problem, here is the logs:\n```java\n04-19 10:37:45.975 21669-21669/? D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(213265115)\n04-19 10:37:45.978 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationScan(213265115)\n04-19 10:37:46.072 1794-2350/? W/Conscrypt: Could not set socket write timeout: null\n04-19 10:37:46.173 21669-21669/? D/BluetoothAdapter: startLeScan(): null\n04-19 10:37:46.177 21669-21669/? D/BluetoothAdapter: STATE_ON\n04-19 10:37:46.183 9897-9953/? D/BtGatt.GattService: registerClient() - UUID=0c1cf0ea-9137-4576-969b-1613c5ab2cab\n04-19 10:37:46.183 9897-9914/? D/BtGatt.GattService: onClientRegistered() - UUID=0c1cf0ea-9137-4576-969b-1613c5ab2cab, clientIf=6\n04-19 10:37:46.184 21669-21681/? D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=6\n04-19 10:37:46.185 9897-9937/? D/BtGatt.GattService: start scan with filters\n04-19 10:37:46.197 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationScan(213265115)\n04-19 10:37:46.202 9897-9917/? D/BtGatt.ScanManager: handling starting scan\n04-19 10:37:46.211 9897-9914/? D/BtGatt.GattService: onScanFilterEnableDisabled() - clientIf=6, status=0, action=1\n04-19 10:37:46.211 9897-9914/? D/BtGatt.ScanManager: callback done for clientIf - 6 status - 0\n04-19 10:37:46.211 9897-9917/? D/BtGatt.ScanManager: configureFilterParamter 500 10000 1 0\n04-19 10:37:46.217 9897-9914/? D/BtGatt.GattService: onScanFilterParamsConfigured() - clientIf=6, status=0, action=0, availableSpace=15\n04-19 10:37:46.217 9897-9914/? D/BtGatt.ScanManager: callback done for clientIf - 6 status - 0\n04-19 10:37:46.217 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - queue=1\n04-19 10:37:46.218 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=2 mLastConfiguredScanSetting=-2147483648\n04-19 10:37:46.218 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams - scanInterval = 8000configureRegularScanParams - scanWindow = 8000\n04-19 10:37:46.218 9897-9914/? D/BtGatt.GattService: onScanParamSetupCompleted : 0\nandroid.support.v7.widget.ListViewCompat.lookForSelectablePosition(int, boolean) would have incorrectly overridden the package-private method in android.widget.ListView\n04-19 10:37:46.310 9897-9914/? D/bt_btif_gattc: btif_gattc_update_properties BLE device name=Smart Badge len=11 dev_type=2\n04-19 10:37:46.405 21669-21669/? E/RecyclerView: No adapter attached; skipping layout\n04-19 10:37:46.434 21669-21768/? V/RenderScript: 0x9c32e000 Launching thread(s), CPUs 4\n04-19 10:37:46.519 21669-21669/? D/BluetoothAdapter: stopLeScan()\n04-19 10:37:46.520 21669-21669/? D/BluetoothAdapter: STATE_ON\n04-19 10:37:46.520 9897-21357/? D/BtGatt.GattService: stopScan() - queue size =1\n04-19 10:37:46.520 9897-9917/? D/BtGatt.ScanManager: stop scan\n04-19 10:37:46.521 9897-13704/? D/BtGatt.GattService: unregisterClient() - clientIf=6\n04-19 10:37:46.527 9897-9914/? D/BtGatt.GattService: onScanFilterParamsConfigured() - clientIf=6, status=0, action=1, availableSpace=16\n04-19 10:37:46.527 9897-9914/? D/BtGatt.ScanManager: callback done for clientIf - 6 status - 0\n04-19 10:37:46.527 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - queue=0\n04-19 10:37:46.527 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=-2147483648 mLastConfiguredScanSetting=2\n04-19 10:37:46.527 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - queue emtpy, scan stopped\n04-19 10:37:46.556 21669-21669/? D/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(149583810)\n04-19 10:37:46.556 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationConnect(149583810)\n04-19 10:37:46.557 21669-21669/? I/System.out: RxBleConnectionState{DISCONNECTED}\n04-19 10:37:46.557 21669-21669/? I/System.out: RxBleConnectionState{CONNECTING}\n04-19 10:37:46.565 21669-21669/? D/BluetoothGatt: connect() - device: C8:A1:2F:4E:F7:03, auto: false\n04-19 10:37:46.565 21669-21669/? D/BluetoothGatt: registerApp()\n04-19 10:37:46.565 21669-21669/? D/BluetoothGatt: registerApp() - UUID=22373e8e-3501-41eb-8815-ac6ee0b83a25\n04-19 10:37:46.565 9897-9907/? D/BtGatt.GattService: registerClient() - UUID=22373e8e-3501-41eb-8815-ac6ee0b83a25\n04-19 10:37:46.566 9897-9914/? D/BtGatt.GattService: onClientRegistered() - UUID=22373e8e-3501-41eb-8815-ac6ee0b83a25, clientIf=6\n04-19 10:37:46.566 21669-21695/? D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n04-19 10:37:46.566 9897-9908/? D/BtGatt.GattService: clientConnect() - address=C8:A1:2F:4E:F7:03, isDirect=true\n04-19 10:37:46.566 9897-9914/? D/bt_btif_config: btif_get_address_type: Device [c8:a1:2f:4e:f7:03] address type 1\n04-19 10:37:46.566 9897-9914/? D/bt_btif_config: btif_get_device_type: Device [c8:a1:2f:4e:f7:03] type 2\n04-19 10:37:46.567 21669-21768/? V/RenderScript: Successfully loaded runtime: libRSDriver_adreno.so\n04-19 10:37:47.719 1794-15767/? I/PlaceInferenceEngine: No beacon scan available - ignoring candidates.\n04-19 10:37:48.414 1794-22549/? I/PlaceInferenceEngine: [anon] Setup for configuration 105:[]\n04-19 10:37:48.414 1794-22549/? I/PlaceInferenceEngine: [anon] Active modules after start(): 0\n04-19 10:37:48.532 9897-9930/? W/bt_smp: smp_br_connect_callback is called on unexpected transport 2\n04-19 10:37:48.532 9897-9930/? W/bt_btif: bta_dm_acl_change info: 0x0\n04-19 10:37:48.532 9897-9914/? D/bt_btif_dm: remote version info [c8:a1:2f:4e:f7:03]: 0, 0, 0\n04-19 10:37:48.533 9897-9914/? E/BluetoothRemoteDevices: state12newState0\n04-19 10:37:48.534 9897-9914/? D/BtGatt.GattService: onConnected() - clientIf=6, connId=6, address=C8:A1:2F:4E:F7:03\n04-19 10:37:48.535 21669-21683/? D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=C8:A1:2F:4E:F7:03\n04-19 10:37:48.535 21669-21683/? D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n04-19 10:37:48.567 21669-21669/? I/System.out: RxBleConnectionState{CONNECTED}\n04-19 10:37:48.568 21669-21782/? D/BlueCatsSDKInterfaceService: Hey, connection has been established!\n04-19 10:37:48.591 21669-21782/? D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(126905845)\n04-19 10:37:48.592 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(149583810)\n04-19 10:37:48.592 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(126905845)\n04-19 10:37:48.594 21669-21669/? D/BluetoothGatt: discoverServices() - device: C8:A1:2F:4E:F7:03\n04-19 10:37:48.594 9897-9908/? D/BtGatt.GattService: discoverServices() - address=C8:A1:2F:4E:F7:03, connId=6\n04-19 10:37:48.595 9897-9914/? D/BtGatt.GattService: onSearchCompleted() - connId=6, status=0\n04-19 10:37:48.596 21669-21690/? D/BluetoothGatt: onSearchComplete() = Device=C8:A1:2F:4E:F7:03 Status=0\n04-19 10:37:48.596 21669-21690/? D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n04-19 10:37:48.606 21669-21786/? D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(122766707)\n04-19 10:37:48.607 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(126905845)\n04-19 10:37:48.607 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(122766707)\n04-19 10:37:48.610 21669-21681/? D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=6e400002-b5a3-f393-e0a9-e50e24dcca9e status=0\n04-19 10:37:48.615 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(122766707)\n04-19 10:37:52.725 21669-21669/? D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(75657913)\n04-19 10:37:52.725 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(75657913)\n04-19 10:37:52.728 21669-21681/? D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=6e400002-b5a3-f393-e0a9-e50e24dcca9e status=0\n04-19 10:37:52.736 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(75657913)\n04-19 10:37:53.109 21669-21800/? D/BluetoothAdapter: STATE_ON\n04-19 10:37:53.111 9897-9908/? D/BtGatt.GattService: registerClient() - UUID=4f36e06f-e0c4-4522-9c8c-542e33e24ead\n04-19 10:37:53.111 9897-9914/? D/BtGatt.GattService: onClientRegistered() - UUID=4f36e06f-e0c4-4522-9c8c-542e33e24ead, clientIf=7\n04-19 10:37:53.111 21669-21683/? D/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=7\n04-19 10:37:53.112 9897-9953/? D/BtGatt.GattService: start scan with filters\n04-19 10:37:53.114 9897-9917/? D/BtGatt.ScanManager: handling starting scan\n04-19 10:37:53.116 9897-9914/? D/BtGatt.GattService: onScanFilterEnableDisabled() - clientIf=7, status=0, action=1\n04-19 10:37:53.116 9897-9914/? D/BtGatt.ScanManager: callback done for clientIf - 7 status - 0\n04-19 10:37:53.116 9897-9917/? D/BtGatt.ScanManager: configureFilterParamter 500 10000 1 0\n04-19 10:37:53.117 9897-9914/? D/BtGatt.GattService: onScanFilterParamsConfigured() - clientIf=7, status=0, action=0, availableSpace=15\n04-19 10:37:53.117 9897-9914/? D/BtGatt.ScanManager: callback done for clientIf - 7 status - 0\n04-19 10:37:53.117 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - queue=1\n04-19 10:37:53.117 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=2 mLastConfiguredScanSetting=-2147483648\n04-19 10:37:53.117 9897-9917/? D/BtGatt.ScanManager: configureRegularScanParams - scanInterval = 8000configureRegularScanParams - scanWindow = 8000\n04-19 10:39:35.252 9897-9897/? D/BluetoothMapService: onReceive\n04-19 10:39:35.252 9897-9897/? D/BluetoothMapService: onReceive: android.bluetooth.device.action.ACL_DISCONNECTED\n04-19 10:39:35.253 21669-21669/? I/System.out: RxBleConnectionState{DISCONNECTED}\n04-19 10:39:35.254 21669-21695/? D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(41044982)\n04-19 10:39:35.257 21669-21695/? V/OK: connect retrying...\n04-19 10:39:35.258 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(41044982)\n04-19 10:39:35.260 21669-21669/? D/BluetoothManager: getConnectionState()\n04-19 10:39:35.260 21669-21669/? D/BluetoothManager: getConnectedDevices\n04-19 10:39:35.262 21669-21669/? D/BluetoothGatt: close()\n04-19 10:39:35.263 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(41044982)\n04-19 10:39:35.263 21669-21669/? D/BluetoothGatt: unregisterApp() - mClientIf=6\n04-19 10:39:35.263 9897-9908/? D/BtGatt.GattService: unregisterClient() - clientIf=6\n04-19 10:39:35.298 21669-21832/? D/BluetoothAdapter: STATE_ON\n04-19 10:39:35.299 9897-9908/? D/BtGatt.GattService: stopScan() - queue size =1\n04-19 10:39:35.300 9897-9917/? D/BtGatt.ScanManager: stop scan\n04-19 10:39:57.148 9897-9914/? D/bt_btif_gattc: btif_gattc_update_properties BLE device name=BC Beacon len=9 dev_type=2\n04-19 10:39:57.562 9897-9930/? W/bt_smp: smp_br_connect_callback is called on unexpected transport 2\n04-19 10:39:57.562 9897-9930/? W/bt_btif: bta_dm_acl_change info: 0x0\n04-19 10:39:57.562 9897-9914/? D/bt_btif_dm: remote version info [c8:a1:2f:4e:f7:03]: 0, 0, 0\n04-19 10:39:57.563 9897-9914/? E/BluetoothRemoteDevices: state12newState0\n04-19 10:39:57.564 9897-9914/? D/BtGatt.GattService: onConnected() - clientIf=7, connId=7, address=C8:A1:2F:4E:F7:03\n04-19 10:39:57.564 21669-21680/? D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=C8:A1:2F:4E:F7:03\n04-19 10:39:57.565 21669-21680/? D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n04-19 10:39:57.573 21669-21669/? I/System.out: RxBleConnectionState{CONNECTED}\n04-19 10:39:57.576 21669-21851/? D/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(59864543)\n04-19 10:39:57.577 21669-21851/? D/BlueCatsSDKInterfaceService: Hey, connection has been established!\n04-19 10:39:57.591 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationConnect(191030222)\n04-19 10:39:57.593 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(59864543)\n04-19 10:39:57.604 21669-21669/? D/BluetoothGatt: discoverServices() - device: C8:A1:2F:4E:F7:03\n04-19 10:39:57.604 9897-9953/? D/BtGatt.GattService: discoverServices() - address=C8:A1:2F:4E:F7:03, connId=7\n04-19 10:39:57.605 9897-9914/? D/BtGatt.GattService: onSearchCompleted() - connId=7, status=0\n04-19 10:39:57.607 21669-21681/? D/BluetoothGatt: onSearchComplete() = Device=C8:A1:2F:4E:F7:03 Status=0\n04-19 10:39:57.607 21669-21681/? D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n04-19 10:39:57.612 21669-21855/? D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(86063017)\n04-19 10:39:57.622 21669-21855/? D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(70034789)\n04-19 10:39:57.624 21669-21855/? D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(106710088)\n04-19 10:39:57.626 21669-21855/? D/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(260918983)\n04-19 10:39:57.632 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(59864543)\n04-19 10:39:57.632 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(86063017)\n04-19 10:39:57.635 21669-21695/? D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=6e400002-b5a3-f393-e0a9-e50e24dcca9e status=0\n04-19 10:39:57.638 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(86063017)\n04-19 10:39:57.638 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(70034789)\n04-19 10:39:57.643 21669-21680/? D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=6e400002-b5a3-f393-e0a9-e50e24dcca9e status=0\n04-19 10:39:57.647 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(70034789)\n04-19 10:39:57.647 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(106710088)\n04-19 10:39:57.691 21669-21690/? D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=6e400002-b5a3-f393-e0a9-e50e24dcca9e status=0\n04-19 10:39:57.696 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(106710088)\n04-19 10:39:57.696 21669-21715/? D/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(260918983)\n04-19 10:39:57.711 21669-21695/? D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=6e400002-b5a3-f393-e0a9-e50e24dcca9e status=0\n04-19 10:39:57.715 21669-21715/? D/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(260918983)\n```. Thanks for your response! you are very kind! the retryWhen method is not really necessary, I use it to test the connection authomatically, but I just need to connect and send commands during certain changes in the position of the gps, so I dont need to be connected all the time, the problem that I have is the weird behavior of the disconnect sometimes and it seems that the observable keeps the state of what I have sent before because it calls the method onWriteFailure several times after it is disconnected by itself. I have two questions, do i need .observeOn(AndroidSchedulers.mainThread()) if this is running on a service? i change the ui but with a broadcast, the other question is, which must have the onError method ? this is my code of the service:\ncreation of the service:\n```\n    private PublishSubject disconnectTriggerSubject = PublishSubject.create();\n@Override\n    public void onCreate() {\n        super.onCreate();\n    characteristicUuid = UUID.fromString(characteristicID);\n    rxBleClient = MyApplication.getRxBleClient(this);\n    RxBleClient.setLogLevel(RxBleLog.DEBUG);\n    pairAndSendCommand();\n    listener = new LocationListener() {\n        @Override\n        public void onLocationChanged(Location location) {\n\n            if (!userGoesAway) {\n                float distance = location.distanceTo(placeLocation);\n                if (distance > radioPlace) {\n                    userGoesAway = true;\n                    turnOff();\n                }\n            }\n        }\n        @Override\n        public void onStatusChanged(String s, int i, Bundle bundle) {}\n\n        @Override\n        public void onProviderEnabled(String s) {}\n\n        @Override\n        public void onProviderDisabled(String s) { }\n    };\n\n    locationManager = (LocationManager) getApplicationContext().getSystemService(Context.LOCATION_SERVICE);\n}\n\n@Override\npublic int onStartCommand(final Intent intent, final int flags, final int startId) {\n    super.onStartCommand(intent, flags, startId);\n\n    Log.d(TAG, \"onStartCommand\");\n\n    if (intent != null && intent.getStringExtra(\"stop\") != null) {\n\n        triggerDisconnect();\n        if (isScanning())\n            scanSubscription.unsubscribe();\n\n        if (locationManager != null) {\n            locationManager.removeUpdates(listener);\n        }\n    }\n\n    return START_NOT_STICKY;\n}\n\n@Override\npublic void onTaskRemoved(Intent rootIntent) {\n\n    triggerDisconnect();\n\n    if (isScanning())\n        scanSubscription.unsubscribe();\n\n    if (locationManager != null) {\n        locationManager.removeUpdates(listener);\n    }\n    super.onTaskRemoved(rootIntent);\n    stopSelf();\n}\n\n**scan the device**\npublic void pairAndSendCommand() {\n        scanSubscription = rxBleClient.scanBleDevices()\n                .observeOn(AndroidSchedulers.mainThread())\n                .doOnUnsubscribe(this::clearSubscription)\n                .subscribe(new Action1<RxBleScanResult>() {\n                    @Override\n                    public void call(RxBleScanResult rxBleScanResult) {\n\n                        if (rxBleScanResult.getBleDevice().getName() != null) {\n                            if (rxBleScanResult.getBleDevice().getName().contains(\"BLE Device\")){\n\n                                mac_address_paired = rxBleScanResult.getBleDevice().getMacAddress();\n                                scanSubscription.unsubscribe();\n                                connect();\n                            }\n                        }\n                    }\n                }, new Action1<Throwable>() {\n                    @Override\n                    public void call(Throwable throwable) {\n                        onScanFailure(throwable);\n                    }\n                });\n    }\n}\n\nprivate void clearSubscription() {\n        scanSubscription = null;\n    }\n    private boolean isScanning() {\n        return scanSubscription != null;\n    }\nprivate void onConnectionStateChange(RxBleConnection.RxBleConnectionState newState) {\n    System.out.println(newState.toString());\n}\n\nprivate void onScanFailure(Throwable throwable) {\n    if (throwable instanceof BleScanException) {\n        handleBleScanException((BleScanException) throwable);\n    }\n}\n\n```\nprepare connection and connect \n```\n    private Observable prepareConnectionObservable() {\n        return bleDevice\n                .establishConnection(getApplicationContext(), false)\n                .takeUntil(disconnectTriggerSubject)\n                .compose(new ConnectionSharingAdapter());\n    }\npublic void connect() {\n\n    bleDevice = MyApplication.getRxBleClient(getApplicationContext()).getBleDevice(mac_address_paired);\n\n    if (stateObserve == false) {\n        bleDevice.observeConnectionStateChanges()\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(this::onConnectionStateChange);\n\n        stateObserve = true;\n    }\n\n    connectionObservable = prepareConnectionObservable();\n\n    connectionObservable.subscribe(rxBleConnection -> {\n        Log.d(getClass().getSimpleName(), \"Hey, connection has been established!\");\n        sendPass();\n\n    }, this::onConnectionFailure);\n\n}\n\nprivate void sendPass() {\n\n    if (isConnected()) {\n\n        connectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUuid, password))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    onWriteSuccessPass();\n                }, this::onWriteFailure);\n    }\n\n}\n\nprivate void onWriteSuccessPass() {\n    Toast.makeText(getApplicationContext(), \"Write password success\", Toast.LENGTH_SHORT).show();\n\nlight=\"green\";\nchangeLight();\n        }\nprivate boolean isConnected() {\n    return bleDevice.getConnectionState() == RxBleConnection.RxBleConnectionState.CONNECTED;\n}\n\n```\nsend commands to change light\n```\npublic void changeLight() {\n        if (light.equals(\"red\")) {\n        sendCommand(red);\n\n    } else if (light.equals(\"green\")) {\n\n        sendCommand(green);\n    }\n}\n\npublic void sendCommand(byte[] bytesColor) {\n    if (isConnected()) {\n        connectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUuid, bytesColor))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    onWriteSuccessPermission();\n                }, this::onWriteFailure);\n    }\n}\n\nprivate void onWriteSuccessPermission() {\n    Toast.makeText(getApplicationContext(), \"Write permission success\", Toast.LENGTH_SHORT).show();\n\n                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,10000, 0, listener);\n            }\n\n        }\n    }\n\n}\n\npublic void turnOff() {\n\n    if (isConnected()) {\n        connectionObservable\n                .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUuid, off))\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(bytes -> {\n                    onWriteSuccessOff();\n                }, this::onWriteFailureOff);\n    }\n}\n\nprivate void onWriteSuccessOff() {\n    Toast.makeText(getApplicationContext(), \"Write off success\", Toast.LENGTH_SHORT).show();\n\n    if (locationManager != null) {\n        locationManager.removeUpdates(listener);\n    }\n\n    userGoesAway = false;\n\n}\n\nprivate void onConnectionFailure(Throwable throwable) {\n    System.out.println(\"Connection error: \" + throwable);\n}\n\nprivate void onWriteFailure(Throwable throwable) {\n    System.out.println(\"Write error: \" + throwable.getMessage());\n}\n\nprivate void onWriteFailureOff(Throwable throwable) {\n    System.out.println(\"Write error: \" + throwable);\n    userGoesAway = false;\n}\n\nprivate void triggerDisconnect() {\n    disconnectTriggerSubject.onNext(null);\n}\n\n```. hi, could you review the code?. ",
    "SsIDit": "Hi, I did this before I posted this logs\nCode:\n@Provides\n    @Singleton\n    public RxBleClient provideBleClient(Context context) {\n        RxBleClient rxBleClient = RxBleClient.create(context);\n        if (BuildConfig.DEBUG) {\n            rxBleClient.setLogLevel(RxBleLog.VERBOSE);\n        }\n        return rxBleClient;\n    }. Sorry for being so noob. I didn't check VERBOSE filter flag while watching logs. Here's full log:\nD/BluetoothAdapter: stopLeScan()\nD/BluetoothAdapter: STATE_ON\nD/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(168601508)\nD/RxBle#Radio:  STARTED RxBleRadioOperationConnect(168601508)\nV/RxBle#BleConnectionCompat: Connecting without reflection\nD/BluetoothGatt: connect() - device: 04:A3:16:A7:AD:5D, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=df2acb44-52b4-4441-8cea-8aa69061a6f7\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=04:A3:16:A7:AD:5D\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nD/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(11251770)\nD/RxBle#Radio: FINISHED RxBleRadioOperationConnect(168601508)\nD/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(11251770)\nD/BluetoothGatt: discoverServices() - device: 04:A3:16:A7:AD:5D\nD/BluetoothGatt: onSearchComplete() = Device=04:A3:16:A7:AD:5D Status=0\nD/RxBle#BluetoothGatt: onServicesDiscovered status=0\nD/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(11251770)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(8621495)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(8621495)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(109083823)\nD/RxBle#Radio:  REMOVED RxBleRadioOperationCharacteristicWrite(109083823)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(119559651)\nD/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ffe9-0000-1000-8000-00805f9b34fb status=0\nD/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(119559651)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(41808438)\nD/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(41808438)\nV/BoostFramework: BoostFramework() : mPerf = com.qualcomm.qti.Performance@6a86e28\nV/BoostFramework: BoostFramework() : mPerf = com.qualcomm.qti.Performance@2374741\nD/RxBle#Radio:   QUEUED RxBleRadioOperationScan(266842456)\nD/BluetoothManager: getConnectionState()\nD/BluetoothManager: getConnectedDevices\nD/BluetoothGatt: cancelOpen() - device: 04:A3:16:A7:AD:5D\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=04:A3:16:A7:AD:5D\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=5\nD/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(41808438)\nD/RxBle#Radio:  STARTED RxBleRadioOperationScan(266842456)\nD/BluetoothAdapter: startLeScan(): null\nD/BluetoothAdapter: STATE_ON\nD/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=5\nD/RxBle#Radio: FINISHED RxBleRadioOperationScan(266842456)\nD/BluetoothAdapter: stopLeScan()\nD/BluetoothAdapter: STATE_ON\nD/RxBle#Radio:   QUEUED RxBleRadioOperationScan(45418503)\nD/RxBle#Radio:  STARTED RxBleRadioOperationScan(45418503)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationScan(108427424)\nD/BluetoothAdapter: startLeScan(): null\nD/BluetoothAdapter: STATE_ON\nD/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=6\nD/BluetoothAdapter: stopLeScan()\nD/BluetoothAdapter: STATE_ON\nD/RxBle#Radio: FINISHED RxBleRadioOperationScan(45418503)\nD/RxBle#Radio:  STARTED RxBleRadioOperationScan(108427424)\nD/BluetoothAdapter: startLeScan(): null\nD/BluetoothAdapter: STATE_ON\nD/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=6\nD/RxBle#Radio: FINISHED RxBleRadioOperationScan(108427424)\nD/BluetoothAdapter: stopLeScan()\nD/BluetoothAdapter: STATE_ON\nD/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(232084268)\nD/RxBle#Radio:  STARTED RxBleRadioOperationConnect(232084268)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(29412271)\nV/RxBle#BleConnectionCompat: Connecting without reflection\nD/BluetoothGatt: connect() - device: 04:A3:16:A7:AD:5D, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=70c2ac66-68f2-4146-bb05-696c14c2c50b\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=04:A3:16:A7:AD:5D\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nD/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(83457778)\nD/RxBle#Radio: FINISHED RxBleRadioOperationConnect(232084268)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(29412271)\nD/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(29412271)\nE/com.nsofta.resmartbulb.ble.SingleController: BleGattCannotStartException{macAddress=04:A3:16:A7:AD:5D, bleGattOperationType=BleGattOperation{description='CHARACTERISTIC_WRITE'}}\nD/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(83457778)\nD/BluetoothGatt: discoverServices() - device: 04:A3:16:A7:AD:5D\nD/BluetoothGatt: onSearchComplete() = Device=04:A3:16:A7:AD:5D Status=0\nD/RxBle#BluetoothGatt: onServicesDiscovered status=0\nD/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(83457778)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(128877050)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(128877050)\nE/com.nsofta.resmartbulb.ble.SingleController: BleGattCannotStartException{macAddress=04:A3:16:A7:AD:5D, bleGattOperationType=BleGattOperation{description='CHARACTERISTIC_WRITE'}}\nD/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(128877050)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(50847623)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(50847623)\nE/com.nsofta.resmartbulb.ble.SingleController: BleGattCannotStartException{macAddress=04:A3:16:A7:AD:5D, bleGattOperationType=BleGattOperation{description='CHARACTERISTIC_WRITE'}}\nFirst time I discover devices, connect to one of them. Then I do some operations (I removed logs, that repeat). Sometimes you can see - REMOVED, it's because I send many commands at a short period of time so I need to unsubscribe before send new command. Then I disconnect from device, start scan again and connect to it again. Trying to send command again gives me BleGattCannotStartException\nHere's code of my controller class:\n```\nimport android.bluetooth.BluetoothGattCharacteristic;\nimport android.bluetooth.BluetoothGattService;\nimport android.graphics.Color;\nimport android.util.Log;\nimport com.nsofta.resmartbulb.ApplicationLoader;\nimport com.nsofta.resmartbulb.Logger;\nimport com.nsofta.resmartbulb.database.model.Bulb;\nimport com.nsofta.resmartbulb.database.model.Function;\nimport com.nsofta.resmartbulb.database.model.Mood;\nimport com.nsofta.resmartbulb.database.model.Timer;\nimport com.nsofta.resmartbulb.utils.ByteUtils;\nimport com.nsofta.resmartbulb.utils.ColorUtils;\nimport com.polidea.rxandroidble.RxBleClient;\nimport com.polidea.rxandroidble.RxBleConnection;\nimport com.polidea.rxandroidble.RxBleDevice;\nimport java.lang.reflect.Field;\nimport java.util.Calendar;\nimport java.util.List;\nimport javax.inject.Inject;\nimport rx.Subscription;\nimport rx.functions.Action1;\nimport static android.R.attr.type;\npublic class SingleController implements BulbController {\npublic static final String LOG_TAG = SingleController.class.getName();\n\n@Inject\nprotected RxBleClient bleClient;\n\nprivate Bulb bulb;\nprivate RxBleDevice device;\nprivate RxBleConnection connection;\nprivate BluetoothGattCharacteristic dataCharacterisctic;\n\nprivate Subscription connSubscription;\nprivate Subscription connStateSubscription;\nprivate Subscription commandSubscription;\nprivate Subscription serviceDiscoverSubscription;\n\nprivate Action1<byte[]> onSuccess = o -> {\n};\nprivate Action1<Throwable> onThrowable = throwable -> Logger.logError(LOG_TAG, throwable);\n\npublic SingleController(Bulb bulb) {\n    ApplicationLoader.getBleComponent().add(this);\n    this.bulb = bulb;\n    this.device = bleClient.getBleDevice(bulb.address);\n}\n\n@Override\npublic void connect(boolean autoConnect, ConnectionListener listener) {\n    connStateSubscription = device.observeConnectionStateChanges().subscribe(connState -> {\n        String state = getConnectionState(connState);\n\n//            Log.d(LOG_TAG, \"State changed: \" + state);\n            switch (state) {\n                case \"DISCONNECTED\":\n                    break;\n            }\n        });\n        connSubscription = device.establishConnection(autoConnect)\n                .subscribe(\n                        rxBleConnection -> {\n                            Log.d(LOG_TAG, \"Got connection\");\n                            this.connection = rxBleConnection;\n                            serviceDiscoverSubscription = rxBleConnection.discoverServices().subscribe(\n                                    result -> {\n                                        Log.d(LOG_TAG, \"Got services: \" + result.getBluetoothGattServices().toString());\n                                        if (listener != null) {\n                                            listener.onConnected(bulb);\n                                        }\n                                        analyzeGat(result.getBluetoothGattServices());\n                                    },\n                                    t -> {\n                                        if (listener != null) {\n                                            listener.onError(t);\n                                        }\n                                    });\n                        },\n                        t -> {\n                            if (listener != null) {\n                                listener.onError(t);\n                            }\n                        });\n    }\n@Override\npublic void disconnect() {\n    if (serviceDiscoverSubscription != null && !serviceDiscoverSubscription.isUnsubscribed()) {\n        serviceDiscoverSubscription.unsubscribe();\n    }\n    if (connSubscription != null && !connSubscription.isUnsubscribed()) {\n        connSubscription.unsubscribe();\n    }\n    if (connStateSubscription != null && !connStateSubscription.isUnsubscribed()) {\n        connStateSubscription.unsubscribe();\n    }\n}\n\n@Override\npublic void setColor(int color) {\n    if (dataCharacterisctic == null) return;\n    if (type == Bulb.LED_STRIP) {\n        unsubscribeLast();\n        commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{0x56, 0, 0, 0, 0, (byte) 0x0F, (byte) 0xAA}).subscribe(\n                writeBytes -> setColorOld(color),\n                onThrowable\n        );\n    } else {\n        setColorOld(color);\n    }\n}\n\n@Override\npublic void setWarm(byte level) {\n    if (dataCharacterisctic == null) return;\n\n    if (type == Bulb.LED_STRIP) {\n        int color = ColorUtils.getColorWithBrightness(Color.BLACK, 0);\n        byte red = (byte) Color.red(color);\n        byte green = (byte) Color.green(color);\n        byte blue = (byte) Color.blue(color);\n        unsubscribeLast();\n        commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{0x56, red, green, blue, (byte) 255, (byte) 0xF0, (byte) 0xAA}).subscribe(\n                writeBytes -> setWarmOld(level),\n                onThrowable\n        );\n    } else {\n        setWarmOld(level);\n    }\n}\n\n@Override\npublic void turnOn() {\n    if (dataCharacterisctic == null) return;\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{(byte) 0xCC, 0x23, 0x33}).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic void turnOff() {\n    if (dataCharacterisctic == null) return;\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{(byte) 0xCC, 0x24, 0x33}).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic void askState() {\n    if (dataCharacterisctic == null) return;\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{(byte) 0xEF, 0x01, 0x77}).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n\n@Override\npublic void setFunction(Function function, byte speed) {\n    if (dataCharacterisctic == null) return;\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{(byte) 0xBB, function.data, speed, 0x44}).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic void setMood(Mood mood) {\n    if (dataCharacterisctic == null) return;\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, mood.data).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic void setTimers(List<Timer> timers) {\n    if (dataCharacterisctic == null) return;\n\n    byte[] data = new byte[(ByteUtils.TIMERS_IN_COMMAND * ByteUtils.TIMER_SIZE) + 3];\n    data[0] = 0x23;\n    for (int i = 0; i < timers.size(); i++) {\n        Timer timer = timers.get(i);\n        if ((type == Bulb.LED_OLD || type == Bulb.LED_STRIP) && timer.state.sun != null) {\n            ByteUtils.fill(ByteUtils.TIMER_DISABLED_BYTES, data, (i * ByteUtils.TIMER_SIZE) + 1);\n        } else {\n            byte[] timerBytes = ByteUtils.parseTimerToBytes(timer);\n            ByteUtils.fill(timerBytes, data, (i * ByteUtils.TIMER_SIZE) + 1);\n        }\n    }\n    for (int i = timers.size(); i < ByteUtils.TIMERS_IN_COMMAND; i++) {\n        ByteUtils.fill(ByteUtils.TIMER_DISABLED_BYTES, data, (i * ByteUtils.TIMER_SIZE) + 1);\n    }\n    data[(ByteUtils.TIMERS_IN_COMMAND * ByteUtils.TIMER_SIZE) + 1] = 0x0;\n    data[(ByteUtils.TIMERS_IN_COMMAND * ByteUtils.TIMER_SIZE) + 2] = 0x32;\n\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, data).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic void askTimers() {\n    if (dataCharacterisctic == null) return;\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{0x24, 0x2A, 0x2B, 0x42}).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic void setTime(Calendar calendar) {\n    if (dataCharacterisctic == null) return;\n    byte weekDayByte = 0;\n    byte dayOfWeek = (byte) ((calendar.get(Calendar.DAY_OF_WEEK) - 1));\n    if (dayOfWeek == 0) dayOfWeek = 7;\n    weekDayByte = ByteUtils.setBit(weekDayByte, 8 - dayOfWeek);\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{0x10, 0x14,\n            (byte) (calendar.get(Calendar.YEAR) - 2000), (byte) (calendar.get(Calendar.MONTH) + 1),\n            (byte) calendar.get(Calendar.DAY_OF_MONTH), (byte) calendar.get(Calendar.HOUR_OF_DAY),\n            (byte) calendar.get(Calendar.MINUTE), (byte) calendar.get(Calendar.SECOND), weekDayByte, 0x0, 0x01}).subscribe(\n            onSuccess, onThrowable\n    );\n}\n\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Bulb other = ((SingleController) o).bulb;\n    return other.equals(bulb);\n}\n\n@Override\npublic int hashCode() {\n    return bulb.hashCode();\n}\n\nprivate void analyzeGat(List<BluetoothGattService> bluetoothGattServices) {\n    for (BluetoothGattService bls : bluetoothGattServices) {\n        List<BluetoothGattCharacteristic> characteristics = bls.getCharacteristics();\n        for (BluetoothGattCharacteristic bch : characteristics) {\n            if (bls.getUuid().toString().contains(\"ffe5\")\n                    && bch.getUuid().toString().contains(\"ffe9\")) {\n                dataCharacterisctic = bch;\n                dataCharacterisctic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);\n            }\n\n            if (bls.getUuid().toString().contains(\"ffe0\")\n                    && bch.getUuid().toString().contains(\"ffe4\")) {\n                connection.setupNotification(bch);\n            }\n        }\n    }\n}\n\nprivate void setColorOld(int color) {\n    byte red = (byte) Color.red(color);\n    byte green = (byte) Color.green(color);\n    byte blue = (byte) Color.blue(color);\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{0x56, red, green, blue, (byte) 255, (byte) 0xF0, (byte) 0xAA})\n            .subscribe(onSuccess, onThrowable);\n}\n\nprivate void setWarmOld(byte level) {\n    unsubscribeLast();\n    commandSubscription = connection.writeCharacteristic(dataCharacterisctic, new byte[]{0x56, 0, 0, 0, level, (byte) 0x0F, (byte) 0xAA})\n            .subscribe(onSuccess, onThrowable);\n}\n\n//abort previous command\nprivate void unsubscribeLast() {\n    if (commandSubscription != null && !commandSubscription.isUnsubscribed()) {\n        commandSubscription.unsubscribe();\n    }\n}\n\nprivate String getConnectionState(RxBleConnection.RxBleConnectionState state) {\n    try {\n        Field field = RxBleConnection.RxBleConnectionState.class.getDeclaredField(\"description\");\n        field.setAccessible(true);\n        return (String) field.get(state);\n    } catch (IllegalAccessException e) {\n        Logger.logError(LOG_TAG, e);\n    } catch (NoSuchFieldException e) {\n        Logger.logError(LOG_TAG, e);\n    }\n    return \"undefined\";\n}\n\n}\n```. It seems to me, that problem is in discovering services. From documentation of library:\n\nResult of the discovery is cached internally so consecutive calls won't trigger BLE operation\n\nAre there any ways to force clearing services cache?. I just moved \nif (serviceDiscoverSubscription != null && !serviceDiscoverSubscription.isUnsubscribed()) {\n                        serviceDiscoverSubscription.unsubscribe();\n                    }\n                    if (connStateSubscription != null && !connStateSubscription.isUnsubscribed()) {\n                        connStateSubscription.unsubscribe();\n                    }\nin doOnUnsubscribe method of my establishConnection() subscription and everything worked.\nThank you so much! I could't solve this issue for a week. You've made me happy. Issue is solved.. ",
    "kanat": "Is it possible to configure timeout value for ble operation?\nNow it takes about 35 seconds to get BleGattCallbackTimeoutException.. Unsubscribing is not helping. \nThe result is even worse. \nWhen I try to unsubscribe and subscribe again I'm not getting BleGattCallbackTimeoutException and stuck with CONNECTING forever.. As I understand the problem occurs here in RxBleRadioOperationDisconnect (line 62):\nif (bluetoothGatt == null) {\n    RxBleLog.w(\"Disconnect operation has been executed but GATT instance was null.\");\n    onCompleted();\n}\nAfter calling onCompleted the method releaseRadio is never called.. Is there any way to push my own ConnectionModule into the RxAndroidBle Graph?\n(Just to provide fixed versions of operations, until official release will be published). What a pity.\nThat would be nice to have). > It seems to be a race condition in the RxBleRadioOperationConnect\n@dariuszseweryn could you tell me what was the problem at RxBleRadioOperationConnect?. @dariuszseweryn yes, sure, I can try it with real device. \nWhere/How can I get 1.3.0-SNAPSHOT artifact?. Actually I've tried it with my own fixes, seems it works :)\nAnyway I'll try 1.3.0-SNAPSHOT as well.. @dariuszseweryn It works, thanks. . @dariuszseweryn, is it possible to get frozen version of 1.3.0-SNAPSHOT, to avoid situation where my own app can be affected by new changes which can arrive with a modified SNAPSHOT?\nOr maybe it's better to compile RxAndroidBle by my own, until the new release version will be published?. @dariuszseweryn Great news, thanks!. > I can go with the first point now and the second for 1.4.0. Would that fit your idea?\nOk. \nThe Idea is to get what is the reason of BleCannotSetCharacteristicNotificationException. \nAdding getCause() could help as well.\nThe second problem is I cannot ask somewhere what is a current state. The only way is to susbscribe to RxBleDevice.\n\nYou should not use Observables derived from an RxBleConnection\n\nYeah, that's what I'm trying detect in onError branch, but Exception tells me nothing about Disconnection.\nMy logic is following:\n1) Scan selected device\n2) Get connection\n3) Subscribe to indication\n4) Communicate until Disconnection\n5) Restart from 1 if it was a Disconnection or from 2 otherwise\nAs I understand I need to restart subscription if I get any exception from RxBleConnection. Am I right?. Ok.\nThe only diff between knowing it's a disconnection or not is where I'll start again from point 1 (scan) or from point 2 (if it wasn't disconnection then I can try to reconnect without scanning)\nShould I close the issue? Or it will be opened until version 1.4.0?. @dariuszseweryn it's ok now, thanks. ",
    "timmiller17": "I think I am struggling with this as well.  How is the fix coming along?. I'm not sure that I made the right correction, but I wanted to at least highlight that it seemed broken the way it was.. Sounds good.  Hopefully it gets fixed soon.  It took me too much time to figure out that was the source of my problems trying to get the rxjava2.0 branch working.  :). ",
    "ilya-payrange": "Resolved.\nIt was on Android Studio 2.4 preview, with Java 8 enabled (as sample apps require Java 8 and Jack is deprecated).\nStudio 2.4 and toolchain barked at apt. I got it build ok replacing \napt rootProject.ext.libs.dagger_compiler\nwith \nannotationProcessor rootProject.ext.libs.dagger_compiler\nin RxAndroidBle build.gradle.\nI wonder if there's a way to do the same without messing with build.gradle (so updates/pulls will need no \npatching)?. ",
    "KomoriWu": "How do you solve this problem. ",
    "ghost": "@uKL and @dariuszseweryn. Thanks for your outstanding job of making RxAndroidBLE open lib.\nIssue: I have added the lib as a MODULE to my Android project but I am facing the error i.e DaggerClientComponent class is undefined and the class is not there in the lib files.\nI am using Android Studio 3.0\nand \n// Dagger dependencies\n    compile 'com.google.dagger:dagger:2.10'\n    annotationProcessor 'com.google.dagger:dagger-compiler:2.10'\nHow can I solve the issue, I need yours guidance in the respect?. @kenwdelong is there a way to implement this solution as soon as the first search/connection fails?\nAFAIS, you implement this after the connection is successful\nI want to be sure cache is cleared before trying to find a BLE device. having same issue too\n\nE/AndroidRuntime: FATAL EXCEPTION: pool-9-thread-1\n                                                                                  io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 44:2C:05:7A:3D:A9\n                                                                                      at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:310)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.dispose(ObservableObserveOn.java:146)\n                                                                                      at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n                                                                                      at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n                                                                                      at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n                                                                                      at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n                                                                                      at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n                                                                                      at io.reactivex.disposables.SerialDisposable.dispose(SerialDisposable.java:81)\n                                                                                      at com.polidea.rxandroidble2.internal.connection.MtuWatcher.onConnectionUnsubscribed(MtuWatcher.java:39)\n                                                                                      at com.polidea.rxandroidble2.internal.connection.ConnectorImpl$1$1.run(ConnectorImpl.java:71)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.runFinally(ObservableDoFinally.java:144)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:88)\n                                                                                      at io.reactivex.internal.observers.DisposableLambdaObserver.onError(DisposableLambdaObserver.java:64)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onError(ObservableFlatMap.java:288)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.tryOnError(ObservableCreate.java:85)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onError(ObservableCreate.java:73)\n                                                                                      at com.polidea.rxandroidble2.internal.serialization.FIFORunnableEntry$1.onError(FIFORunnableEntry.java:65)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableUnsubscribeOn$UnsubscribeObserver.onError(ObservableUnsubscribeOn.java:70)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onError(ObservableSubscribeOn.java:63)\n                                                                                      at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.tryOnError(ObservableCreate.java:85)\n                                                                                      at com.polidea.rxandroidble2.internal.util.DisposableUtil$3.onError(DisposableUtil.java:60)\n                                                                                      at io.reactivex.internal.operators.single.SingleDoFinally$DoFinallyObserver.onError(SingleDoFinally.java:81)\n                                                                                      at io.reactivex.internal.operators.single.SingleTimeout$TimeoutMainObserver.onError(SingleTimeout.java:142)\n                                                                                      at io.reactivex.internal.operators.single.SingleCreate$Emitter.tryOnError(SingleCreate.java:95)\n                                                                                      at com.polidea.rxandroidble2.internal.util.DisposableUtil$1.onError(DisposableUtil.java:24)\n                                                                                      at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onError(FlowableElementAtSingle.java:101)\n                                                                                      at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.checkTerminate(FlowableFlatMap.java:566)\n                                                                                      at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.drainLoop(FlowableFlatMap.java:374)\n                                                                                      at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.drain(FlowableFlatMap.java:366)\n                                                                                      at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.innerError(FlowableFlatMap.java:605)\n                                                                                      at io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.onError(FlowableFlatMap.java:668)\n                                                                                      at io.reactivex.internal.operators.single.SingleToFlowab\nstack=io.reactivex.exceptions.UndeliverableException: . @GuillaumeBo which version are u using?. waiting for this to be merged impatiently. \n",
    "sycinsider": "Here is the code that i write long data,Where is the problem?\nmWriteSubscribe = mRxBleConnectionObservable\n                    .flatMap(rxBleConnection -> Observable.combineLatest(\n                            rxBleConnection.setupNotification(notify),\n                            rxBleConnection.setupNotification(notify),\n                            Pair::new\n                    ), (rxBleConnection, callbackObservablePair) -> { \n                        Observable<byte[]> deviceCallback0 = callbackObservablePair.first;\n                        Observable<byte[]> deviceCallback1 = callbackObservablePair.second;\n                        return rxBleConnection.createNewLongWriteBuilder() \n                                .setBytes(sendData) \n                                .setCharacteristicUuid(write)\n                                .setWriteOperationAckStrategy(booleanObservable -> Observable.zip(\n                                        // so we zip three observables\n                                        deviceCallback0, \n                                        deviceCallback1, \n                                        booleanObservable,\n                                        (callback0, callback1, aBoolean) -> aBoolean \n                                ))\n                                .build();\n                    })\n                    .flatMap(observable -> observable)\n                    .take(1) \n                    .doOnSubscribe(this::writeRunnable)\n                    .subscribe(\n                            bytes -> {\n                                onWriteSuccess(); \n                            },\n                            this::onWriteFailure\n                    );. I have modified your sample about it and i create two notifications with the exact same UUID;What should I do?. ",
    "marciogranzotto": "I would like to use it's extractUUIDs method to get the UUIDs of a scanResult object. There's several StackOverflow answers that recommend using this method . Maybe this is related to #74 ?\n. The biggest problem is not really the number of scans, but the mac address that some times is wrong.\nBut I cannot figure out what is the problem, I've tested it on around 10 devices and only 2 or 3 had this problem. For example, on the Nexus 5X on 7.1.1 it works properly but on the Nexus 6P on 7.1.1 I get this problem.. Yes, the the wrong addresses are always different. Most of the time they show on nRF Connect as a nameless Apple device, but being in a office full of macs and iPhones, that can mean nothing.. Not really, I'm the only one dealing with bluetooth right now, I can guarantee that there's no mocking advertisement packets here.\nI'll test @gryffindor14 branch that implements Scan Compat and see if it fixes my problem. Unfortunately that branch didn't fixed my problem. I've also got the same problem using the sample scanning app provided in this repo.. ",
    "lukevr": "Hi,\nI am playing with RxAndroidBle 1.2.1 and have got an issue with scanBleDevices(UUIDArray), seems that if I have UUIDArray with several different UUID, scanning is not working. Well, at least no results for subscriber in this case. \nIf I add just one UUID, or same UUID several times to the UUIDArray then rxBleScanResult is present, and everything is ok.\nFound similar issue on stackoverflow:\nhttp://stackoverflow.com/questions/40447272/rxandroidble-the-method-scanbledevicesuuid-filters-is-not-support-for-two-t\nCustom filter and UUIDUtil are suggested to be used. And, yes UUIDUtil is not public in 1.2.1.\nWhat is the best way to solve the issue with scanning a set of different UUID?\nThanks in advance,\nVictor.\n. Hi, sorry for the late answer, I have tested with 1.3.1 and seems it works in background service again.\nHere are logs:\nD/RxBle#Radio:   QUEUED RxBleRadioOperationConnect(203378203)\nD/RxBle#Radio:  STARTED RxBleRadioOperationConnect(203378203)\nD/BluetoothGatt: connect() - device: B8:27:EB:B6:A2:34, auto: false\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: registerApp() - UUID=12c86bab-8c1c-48f2-bbce-073d1bc0bba3\nD/BtGatt.GattService: registerClient() - UUID=12c86bab-8c1c-48f2-bbce-073d1bc0bba3\nD/BtGatt.GattService: onClientRegistered() - UUID=12c86bab-8c1c-48f2-bbce-073d1bc0bba3, clientIf=11\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=11\nD/BtGatt.GattService: clientConnect() - address=B8:27:EB:B6:A2:34, isDirect=true\nD/bt_btif_config: btif_get_address_type: Device [b8:27:eb:b6:a2:34] address type 0\nD/bt_btif_config: btif_get_device_type: Device [b8:27:eb:b6:a2:34] type 2\nD/BluetoothAdapter: isLeEnabled(): ON\nD/BtGatt.GattService: stopScan() - queue size =3\nD/BtGatt.GattService: unregisterClient() - clientIf=10\nD/BtGatt.ScanManager: configureRegularScanParams() - queue=2\nD/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=0 mLastConfiguredScanSetting=2\nD/BtGatt.ScanManager: configureRegularScanParams - scanInterval = 8000configureRegularScanParams - scanWindow = 800\nD/BtGatt.GattService: onScanParamSetupCompleted : 0\nW/bt_smp: smp_br_connect_callback is called on unexpected transport 2\nW/bt_btif: bta_dm_acl_change info: 0x0\nD/bt_btif_dm: remote version info [b8:27:eb:b6:a2:34]: 0, 0, 0\nE/bt_btif: bta_gattc_cache_load: can't open GATT cache file /data/misc/bluetooth/gatt_cache_b827ebb6a234 for reading, error: No such file or directory\nE/BluetoothRemoteDevices: state12newState0\nD/BtGatt.GattService: onConnected() - clientIf=11, connId=11, address=B8:27:EB:B6:A2:34\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=11 device=B8:27:EB:B6:A2:34\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nI/TrustAgent.Tracker: [BluetoothConnectionTracker] Bluetooth connect broadast for PicPic B8:27:EB:B6:A2:34\nD/RxBle#Radio:   QUEUED RxBleRadioOperationServicesDiscover(193464282)\nD/RxBle#Radio: FINISHED RxBleRadioOperationConnect(203378203)\nD/RxBle#Radio:  STARTED RxBleRadioOperationServicesDiscover(193464282)\nD/BluetoothGatt: discoverServices() - device: B8:27:EB:B6:A2:34\nD/BtGatt.GattService: discoverServices() - address=B8:27:EB:B6:A2:34, connId=11\nW/bt_bta_gattc: bta_gattc_explore_srvc no more services found\nD/BtGatt.GattService: onSearchCompleted() - connId=11, status=0\nD/bt_bta_gattc: bta_gattc_get_gatt_db\nD/BtGatt.GattService: onGetGattDb() - address=B8:27:EB:B6:A2:34\nD/BtGatt.GattService: got service with UUID=00001800-0000-1000-8000-00805f9b34fb\nD/BtGatt.GattService: got characteristic with UUID=00002a00-0000-1000-8000-00805f9b34fb\nD/BtGatt.GattService: got characteristic with UUID=00002a01-0000-1000-8000-00805f9b34fb\nD/BtGatt.GattService: got service with UUID=00001801-0000-1000-8000-00805f9b34fb\nD/BtGatt.GattService: got characteristic with UUID=00002a05-0000-1000-8000-00805f9b34fb\nD/BtGatt.GattService: got descriptor with UUID=00002902-0000-1000-8000-00805f9b34fb\nD/BtGatt.GattService: got service with UUID=1d038ab3-45f4-4b96-9915-22ec29b75d58\nD/BtGatt.GattService: got characteristic with UUID=ffffffff-ffff-ffff-ffff-fffffffffff1\nD/BluetoothGatt: onSearchComplete() = Device=B8:27:EB:B6:A2:34 Status=0\nD/RxBle#BluetoothGatt: onServicesDiscovered status=0\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicRead(43664172)\nD/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(193464282)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicRead(43664172)\nI/bt_btif_gatt: set_read_value len = 21 \nW/BluetoothGatt: onCharacteristicRead() - Device=B8:27:EB:B6:A2:34 handle=12 Status=0\nD/RxBle#BluetoothGatt: onCharacteristicRead characteristic=ffffffff-ffff-ffff-ffff-fffffffffff1 status=0\nE/JetBeepLog: Read IV from ffffffff-ffff-ffff-ffff-fffffffffff1\nD/RxBle#Radio:   QUEUED RxBleRadioOperationCharacteristicWrite(152824366)\nD/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicRead(43664172)\nD/RxBle#Radio:  STARTED RxBleRadioOperationCharacteristicWrite(152824366)\nE/bt_att: value resp op_code = ATT_RSP_PREPARE_WRITE len = 22\nI/NuPlayerDecoder: [audio] saw output EOS\nE/bt_att: value resp op_code = ATT_RSP_PREPARE_WRITE len = 18\nD/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=ffffffff-ffff-ffff-ffff-fffffffffff1 status=0\nD/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(226994713)\nD/RxBle#Radio:   QUEUED RxBleRadioOperationScanApi21(118409100)\nD/RxBle#Radio: FINISHED RxBleRadioOperationCharacteristicWrite(152824366)\nD/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(226994713)\nD/BluetoothManager: getConnectionState()\nD/BluetoothManager: getConnectedDevices\nD/BluetoothGatt: cancelOpen() - device: B8:27:EB:B6:A2:34\nD/BtGatt.GattService: clientDisconnect() - address=B8:27:EB:B6:A2:34, connId=11\nE/bt_btif: bta_gattc_mark_bg_conn unable to find the bg connection mask for: b8:27:eb:b6:a2:34\nD/BtGatt.GattService: onDisconnected() - clientIf=11, connId=11, address=B8:27:EB:B6:A2:34\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=11 device=B8:27:EB:B6:A2:34\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=11\nD/BtGatt.GattService: unregisterClient() - clientIf=11\nD/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(226994713)\nD/RxBle#Radio:  STARTED RxBleRadioOperationScanApi21(118409100)\nD/BluetoothAdapter: isLeEnabled(): ON\nD/BtGatt.GattService: registerClient() - UUID=8ea31568-a7b7-4f09-8d14-9c0f36ba7d9b\nD/BtGatt.GattService: onClientRegistered() - UUID=8ea31568-a7b7-4f09-8d14-9c0f36ba7d9b, clientIf=10\nD/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=10 mClientIf=0\nD/BtGatt.GattService: start scan with filters\nD/BtGatt.ScanManager: handling starting scan\nD/RxBle#Radio: FINISHED RxBleRadioOperationScanApi21(118409100)\nD/BtGatt.ScanManager: configureRegularScanParams() - queue=3\nD/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=2 mLastConfiguredScanSetting=0\nD/BtGatt.ScanManager: configureRegularScanParams - scanInterval = 8000configureRegularScanParams - scanWindow = 8000\nD/BtGatt.GattService: onScanParamSetupCompleted : 0\nW/bt_btif: bta_gattc_conn_cback() - cif=3 connected=0 conn_id=3 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=4 connected=0 conn_id=4 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=5 connected=0 conn_id=5 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=6 connected=0 conn_id=6 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=7 connected=0 conn_id=7 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=8 connected=0 conn_id=8 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=9 connected=0 conn_id=9 reason=0x0016\nW/bt_btif: bta_gattc_conn_cback() - cif=10 connected=0 conn_id=10 reason=0x0016\nI/bt_btm_sec: btm_sec_disconnected clearing pending flag handle:64 reason:22\nE/BluetoothRemoteDevices: state12newState1\nD/BluetoothMapService: onReceive\nD/BluetoothMapService: onReceive: android.bluetooth.device.action.ACL_DISCONNECTED\nI/TrustAgent.Tracker: [BluetoothConnectionTracker] Bluetooth disconnect broadast for MyApp B8:27:EB:B6:A2:34\nScan starts..\nAnd I'm getting the folowing log from time to time while device is just scanning:\nD/BluetoothAdapter: isLeEnabled(): ON\nD/BtGatt.GattService: stopScan() - queue size =3\nD/BtGatt.ScanManager: configureRegularScanParams() - queue=2\nD/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=2 mLastConfiguredScanSetting=2\nD/BtGatt.GattService: unregisterClient() - clientIf=6\nD/BtGatt.GattService: registerClient() - UUID=b1aebcf2-8a1c-4711-8c9d-3e85585183a2\nD/BtGatt.GattService: onClientRegistered() - UUID=b1aebcf2-8a1c-4711-8c9d-3e85585183a2, clientIf=6\nD/BluetoothLeScanner: onClientRegistered() - status=0 clientIf=6 mClientIf=0\nD/BtGatt.GattService: start scan with filters\nD/BtGatt.ScanManager: handling starting scan\nD/BtGatt.ScanManager: configureRegularScanParams() - queue=3\nD/BtGatt.ScanManager: configureRegularScanParams() - ScanSetting Scan mode=2 mLastConfiguredScanSetting=2. Hi, is there a list of supported(tested) and unsupported devices/Android versions? . Hi @dariuszseweryn,\nI'm testing on Nexus 6P, Android 7.1.2 as the main device and also tried on other phones of different vendors and Android versions. \nSame behavior exists everywhere.. ",
    "NitroG42": "Hi, can we avoid using this class when we need to share the connection between multiple activity ? Let's suppose my app allows to control a ble device and there is multiple parameters (read battery stat, change a setting later, etc...)\nShoudln't the connection be kept (using the ConnectionSharingAdapter) for it to be more reactive ?\nThe other way around is to keep the RxBleConnection somewhere and unsubscribe when unneeded ?\n. I tried the 1.5.0 release and 1.6.0-SNAPSHOT and still get this issue: \nThis issue happens when the device is forcely rebooted. Is there any way to get around without settings a whole error handler ? (See post below for full error). I'm not using others schedulers unfortunatelly... Here's my code, It might help ! (or not):\n```kotlin\nconnectionObs = RxClientHolder.rxBleClient.getBleDevice(device.macAdress)\n                .establishConnection(true)\n                .retryWhen { errorNotification ->\n                    errorNotification.doOnNext { Timber.e(\"error during connection, retrying...\") }\n                        .delay(2, TimeUnit.SECONDS)\n                }\n                .compose(ConnectionSharingAdapter())\n                .doOnNext { DeviceEvents.connectionStatus.onNext(ConnectionStatus.CONNECTED) }\n        connectDisposable?.dispose()\n        connectDisposable = connectionObs!!.flatMap { rxBleConnection ->\n            val monitoringData = device.monitoringData!!\n            val configData = device.configData!!\n            Single.zip(\n                listOf(\n                    rxBleConnection.readCharacteristic(Device3UUID.MONITORING.CHAR_TEMP).doOnSuccess(\n                        monitoringData::updateTemp\n                    ),\n                    rxBleConnection.readCharacteristic(Device3UUID.MONITORING.CHAR_BATT).doOnSuccess(\n                        monitoringData::updateBatt\n                    ),\n                    rxBleConnection.readCharacteristic(Device3UUID.MONITORING.CHAR_USB).doOnSuccess(\n                        monitoringData::updateUsb\n                    ),\n                    rxBleConnection.readCharacteristic(Device3UUID.CONFIG.CHAR_LED).doOnSuccess(\n                        configData::updateLed\n                    )\n                ), { raw: Array<Any> ->\n\n                }).flatMapObservable {\n                Observable.combineLatest(\n                    listOf(\n                        rxBleConnection.setupNotification(Device3UUID.MONITORING.CHAR_BATT).flatMap { it }.doOnNext(\n                            monitoringData::updateBatt\n                        ),\n                        rxBleConnection.setupNotification(Device3UUID.MONITORING.CHAR_TEMP).flatMap { it }.doOnNext(\n                            monitoringData::updateTemp\n                        ),\n                        rxBleConnection.setupNotification(Device3UUID.MONITORING.CHAR_USB).flatMap { it }.doOnNext(\n                            monitoringData::updateUsb\n                        ),\n                        rxBleConnection.setupNotification(Device3UUID.CONFIG.CHAR_LED).flatMap { it }.doOnNext(\n                            configData::updateLed\n                        )\n                    ), { raw: Array<Any> ->\n                        Timber.d(\"received notification\")\n                        raw\n                    })\n            }\n        }\n            .doAfterTerminate { DeviceEvents.connectionStatus.onNext(ConnectionStatus.DISCONNECTED) }\n            .subscribe({\n            }, {\n                Timber.e(it, \"onErrorConnection\")\n            })\n\n```\nThe issue occurs because I plug my ble device (with usb), and it's triggers a forced reboot, then the crash occurs.\nI understand that the device shouldn't do that, but I think the establishConnection should trigger onError and not crash like this (if possible). My code might be wrong too.. Here's the log with the exception : \n03-14 17:09:03.491 4376-4656/fr.openium.Device3app V/RxBle#ServiceDiscoveryOperation: Preparing services description\n03-14 17:09:03.501 4376-4656/fr.openium.Device3app V/RxBle#ServiceDiscoveryOperation: --------------- ====== Printing peripheral content ====== ---------------\n    PERIPHERAL ADDRESS: D5:A5:72:34:43:7E\n    PERIPHERAL NAME: DW3_231A5732\n    -------------------------------------------------------------------------\n    Primary Service - Generic Access (00001800-0000-1000-8000-00805f9b34fb)\n    Instance ID: 0\n    -> Characteristics:\n        * Device Name (00002a00-0000-1000-8000-00805f9b34fb)\n          Properties: [ READ WRITE ]\n        * Appearance (00002a01-0000-1000-8000-00805f9b34fb)\n          Properties: [ READ ]\n        * Peripheral Preferred Connection Parameters (00002a04-0000-1000-8000-00805f9b34fb)\n          Properties: [ READ ]\n        * Central Address Resolution (00002aa6-0000-1000-8000-00805f9b34fb)\n          Properties: [ READ ]\n    Primary Service - Generic Attribute (00001801-0000-1000-8000-00805f9b34fb)\n    Instance ID: 0\n    -> Characteristics:\n        * Service Changed (00002a05-0000-1000-8000-00805f9b34fb)\n          Properties: [ INDICATE ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n    Primary Service - Unknown service (0000fe59-0000-1000-8000-00805f9b34fb)\n    Instance ID: 0\n    -> Characteristics:\n        * Unknown characteristic (8ec90003-f315-4f60-9fb8-838830daea50)\n          Properties: [ WRITE INDICATE ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n    Primary Service - Device Information (0000180a-0000-1000-8000-00805f9b34fb)\n    Instance ID: 0\n    -> Characteristics:\n        * Manufacturer Name String (00002a29-0000-1000-8000-00805f9b34fb)\n          Properties: [ READ ]\n    Primary Service - Unknown service (1b0d1200-a720-f7e9-46b6-31b601c4fca1)\n    Instance ID: 0\n    -> Characteristics:\n        * Unknown characteristic (1b0d1201-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1202-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1203-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1204-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1205-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1206-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1207-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1208-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ ]\n          -> Descriptors: \n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n    Primary Service - Unknown service (1b0d1400-a720-f7e9-46b6-31b601c4fca1)\n    Instance ID: 0\n    -> Characteristics:\n        * Unknown characteristic (1b0d1401-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ WRITE NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1402-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ ]\n          -> Descriptors: \n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1403-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ WRITE NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n        * Unknown characteristic (1b0d1404-a720-f7e9-46b6-31b601c4fca1)\n          Properties: [ READ WRITE NOTIFY ]\n          -> Descriptors: \n            * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n            * Characteristic User Description (00002901-0000-1000-8000-00805f9b34fb)\n    --------------- ====== Finished peripheral content ====== ---------------\n03-14 17:09:03.501 4376-4656/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicReadOperation(75548787)\n    QUEUED   CharacteristicReadOperation(64656176)\n03-14 17:09:03.501 4376-4402/fr.openium.Device3app D/BluetoothGatt: onClientConnParamsChanged() - Device=D5:A5:72:34:43:7E interval=39 status=0\n03-14 17:09:03.501 4376-4656/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicReadOperation(67730345)\n    QUEUED   CharacteristicReadOperation(158160174)\n03-14 17:09:03.511 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED ServiceDiscoveryOperation(6507746) in 1623 ms\n    STARTED  CharacteristicReadOperation(75548787)\n03-14 17:09:03.601 4376-4517/fr.openium.Device3app D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=1b0d1202-a720-f7e9-46b6-31b601c4fca1 status=0\n03-14 17:09:03.601 4376-4656/fr.openium.Device3app D/MonitoringData: update temp -5\n03-14 17:09:03.621 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicReadOperation(75548787) in 110 ms\n    STARTED  CharacteristicReadOperation(64656176)\n03-14 17:09:03.701 4376-4499/fr.openium.Device3app D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=1b0d1203-a720-f7e9-46b6-31b601c4fca1 status=0\n03-14 17:09:03.701 4376-4656/fr.openium.Device3app D/MonitoringData: update batt 21893\n03-14 17:09:03.721 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicReadOperation(64656176) in 97 ms\n    STARTED  CharacteristicReadOperation(67730345)\n03-14 17:09:03.801 4376-4555/fr.openium.Device3app D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=1b0d1206-a720-f7e9-46b6-31b601c4fca1 status=0\n03-14 17:09:03.801 4376-4656/fr.openium.Device3app D/MonitoringData: update usb false\n03-14 17:09:03.821 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicReadOperation(67730345) in 100 ms\n    STARTED  CharacteristicReadOperation(158160174)\n03-14 17:09:03.891 4376-4523/fr.openium.Device3app D/RxBle#BluetoothGatt: onCharacteristicRead characteristic=1b0d1404-a720-f7e9-46b6-31b601c4fca1 status=0\n03-14 17:09:03.901 4376-4656/fr.openium.Device3app D/ConfigData: update led false\n03-14 17:09:03.911 4376-4656/fr.openium.Device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1203-a720-f7e9-46b6-31b601c4fca1 enable: true\n03-14 17:09:03.921 4376-4656/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(117282362)\n03-14 17:09:03.921 4376-4656/fr.openium.Device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1202-a720-f7e9-46b6-31b601c4fca1 enable: true\n03-14 17:09:03.931 4376-4656/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(49387592)\n03-14 17:09:03.931 4376-4656/fr.openium.Device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1206-a720-f7e9-46b6-31b601c4fca1 enable: true\n03-14 17:09:03.931 4376-4656/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(203348998)\n03-14 17:09:03.941 4376-4656/fr.openium.Device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1404-a720-f7e9-46b6-31b601c4fca1 enable: true\n03-14 17:09:03.941 4376-4656/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(78377204)\n03-14 17:09:03.941 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicReadOperation(158160174) in 122 ms\n    STARTED  DescriptorWriteOperation(117282362)\n03-14 17:09:04.041 4376-4517/fr.openium.Device3app D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n03-14 17:09:04.041 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED DescriptorWriteOperation(117282362) in 101 ms\n03-14 17:09:04.051 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: STARTED  DescriptorWriteOperation(49387592)\n03-14 17:09:04.141 4376-4538/fr.openium.Device3app D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n03-14 17:09:04.141 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED DescriptorWriteOperation(49387592) in 94 ms\n    STARTED  DescriptorWriteOperation(203348998)\n03-14 17:09:04.241 4376-4499/fr.openium.Device3app D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n03-14 17:09:04.241 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED DescriptorWriteOperation(203348998) in 96 ms\n    STARTED  DescriptorWriteOperation(78377204)\n03-14 17:09:04.331 4376-4393/fr.openium.Device3app D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n03-14 17:09:04.341 4376-5682/fr.openium.Device3app D/RxBle#ConnectionOperationQueue: FINISHED DescriptorWriteOperation(78377204) in 96 ms\n03-14 17:09:06.841 4376-4402/fr.openium.Device3app D/BluetoothGatt: onClientConnParamsChanged() - Device=D5:A5:72:34:43:7E interval=24 status=0\n03-14 17:09:07.811 4376-4538/fr.openium.Device3app D/BluetoothGatt: onClientConnectionState() - status=8 clientIf=6 device=D5:A5:72:34:43:7E\n03-14 17:09:07.821 4376-4538/fr.openium.Device3app D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=8\n03-14 17:09:07.821 4376-4538/fr.openium.Device3app I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D5:A5:72:34:43:7E)\n03-14 17:09:07.821 4376-5682/fr.openium.Device3app D/RxBle#Executors$RunnableAdapter: Terminated.\n03-14 17:09:07.821 4376-4538/fr.openium.Device3app E/DeviceService$connect: error during connection, retrying...\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err: io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from D5:A5:72:34:43:7E\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err:     at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err:     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:310)\n        at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.dispose(ObservableObserveOn.java:146)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.disposables.SerialDisposable.dispose(SerialDisposable.java:81)\n        at com.polidea.rxandroidble2.internal.connection.MtuWatcher.onConnectionUnsubscribed(MtuWatcher.java:39)\n        at com.polidea.rxandroidble2.internal.connection.ConnectorImpl$1$1.run(ConnectorImpl.java:71)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.runFinally(ObservableDoFinally.java:144)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:88)\n        at io.reactivex.internal.observers.DisposableLambdaObserver.onError(DisposableLambdaObserver.java:64)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err:     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err:     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err:     at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)\n        at io.reactivex.Observable.subscribe(Observable.java:11442)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n        at io.reactivex.internal.util.NotificationLite.accept(NotificationLite.java:246)\n        at io.reactivex.internal.operators.observable.ObservableCache$ReplayDisposable.replay(ObservableCache.java:350)\n        at io.reactivex.internal.operators.observable.ObservableCache$CacheState.onNext(ObservableCache.java:225)\n        at io.reactivex.internal.operators.observable.ObservableElementAt$ElementAtObserver.onNext(ObservableElementAt.java:87)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmit(ObservableFlatMap.java:262)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onNext(ObservableFlatMap.java:559)\n        at com.jakewharton.rxrelay2.PublishRelay$PublishDisposable.onNext(PublishRelay.java:176)\n        at com.jakewharton.rxrelay2.PublishRelay.accept(PublishRelay.java:141)\n03-14 17:09:07.831 4376-4538/fr.openium.Device3app W/System.err:     at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onDisconnectedException(DisconnectionRouter.java:86)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:228)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:453)\n    Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from D5:A5:72:34:43:7E\n        ... 4 more\n03-14 17:09:07.841 4376-4538/fr.openium.Device3app E/AndroidRuntime: FATAL EXCEPTION: Binder_7\n    Process: fr.openium.Device3app, PID: 4376\n    io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from D5:A5:72:34:43:7E\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:310)\n        at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.dispose(ObservableObserveOn.java:146)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.disposables.SerialDisposable.dispose(SerialDisposable.java:81)\n        at com.polidea.rxandroidble2.internal.connection.MtuWatcher.onConnectionUnsubscribed(MtuWatcher.java:39)\n        at com.polidea.rxandroidble2.internal.connection.ConnectorImpl$1$1.run(ConnectorImpl.java:71)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.runFinally(ObservableDoFinally.java:144)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:88)\n        at io.reactivex.internal.observers.DisposableLambdaObserver.onError(DisposableLambdaObserver.java:64)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)\n        at io.reactivex.Observable.subscribe(Observable.java:11442)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n        at io.reactivex.internal.util.NotificationLite.accept(NotificationLite.java:246)\n        at io.reactivex.internal.operators.observable.ObservableCache$ReplayDisposable.replay(ObservableCache.java:350)\n        at io.reactivex.internal.operators.observable.ObservableCache$CacheState.onNext(ObservableCache.java:225)\n        at io.reactivex.internal.operators.observable.ObservableElementAt$ElementAtObserver.onNext(ObservableElementAt.java:87)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmit(ObservableFlatMap.java:262)\n        at io.reactivex.internal.o. It happens randomly when the device is disconnected, either by usb or sometime randomly when we are connected to it.\nThe device is a custom made by a company we works with. The chip is a Nordic one. \nIf worked around by catching the error with the RxJavaPlugin, sending a value in an observable to know it happens and restart connection with a delay of 5 seconds.. I will try, I'll update the thread when I have news.. I still got the issue, I can trigger it just by disposing my connectDisposable (see above, it's the result of the subscribe that connect using ConnectionSharingAdapter, and readChara):\n03-15 16:20:12.849 22277-22277/fr.openium.device3app D/deviceService: service stopped\n03-15 16:20:12.849 22277-22305/fr.openium.device3app D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(35906593)\n03-15 16:20:12.849 22277-22277/fr.openium.device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1203-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-15 16:20:12.849 22277-22305/fr.openium.device3app I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F1:13:65:7E:30:C3)\n03-15 16:20:12.849 22277-22304/fr.openium.device3app D/RxBle#Executors$RunnableAdapter: Terminated.\n03-15 16:20:12.849 22277-22297/fr.openium.device3app D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(35906593)\n03-15 16:20:12.849 22277-22306/fr.openium.device3app D/BluetoothManager: getConnectionState()\n03-15 16:20:12.849 22277-22306/fr.openium.device3app D/BluetoothManager: getConnectedDevices\n03-15 16:20:12.859 22277-22277/fr.openium.device3app D/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(726687814)\n03-15 16:20:12.859 22277-22306/fr.openium.device3app D/BluetoothGatt: cancelOpen() - device: F1:13:65:7E:30:C3\n03-15 16:20:12.859 22277-22277/fr.openium.device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1202-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-15 16:20:12.869 22277-22292/fr.openium.device3app D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=F1:13:65:7E:30:C3\n03-15 16:20:12.869 22277-22292/fr.openium.device3app D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n03-15 16:20:12.869 22277-22277/fr.openium.device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1206-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-15 16:20:12.869 22277-22292/fr.openium.device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1204-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-15 16:20:12.869 22277-22292/fr.openium.device3app D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1205-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-15 16:20:12.869 22277-22277/fr.openium.device3app E/device3Api$init: rx undeliverable error disconnected\n    io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from F1:13:65:7E:30:C3\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:310)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:276)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$DisposeTask.run(ObservableRefCount.java:219)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:30)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:20)\n        at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:43)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:151)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n03-15 16:20:12.879 22277-22277/fr.openium.device3app E/device3Api$init:     at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n03-15 16:20:12.879 22277-22277/fr.openium.device3app E/device3Api$init:     at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:583)\n03-15 16:20:12.879 22277-22277/fr.openium.device3app E/device3Api$init:     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:509)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:307)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:503)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:307)\n03-15 16:20:12.879 22277-22305/fr.openium.device3app D/RxBle#MtuWatcher: An error received when listening to MTU changes.\n    com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from F1:13:65:7E:30:C3\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:186)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:446)\n03-15 16:20:12.879 22277-22277/fr.openium.device3app E/device3Api$init:     at io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver.dispose(ObservableDoOnEach.java:80)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableCombineLatest$CombinerObserver.dispose(ObservableCombineLatest.java:321)\n        at io.reactivex.internal.operators.observable.ObservableCombineLatest$LatestCoordinator.cancelSources(ObservableCombineLatest.java:140)\n        at io.reactivex.internal.operators.observable.ObservableCombineLatest$LatestCoordinator.dispose(ObservableCombineLatest.java:126)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:583)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:509)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:307)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:583)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:509)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:307)\n        at io.reactivex.internal.observers.DisposableLambdaObserver.dispose(DisposableLambdaObserver.java:86)\n        at io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver.dispose(ObservableDoOnEach.java:80)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)\n        at fr.openium.device3lib.service.deviceService.onDestroy(deviceService.kt:79)\n        at android.app.ActivityThread.handleStopService(ActivityThread.java:3974)\n        at android.app.ActivityThread.access$2400(ActivityThread.java:219)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1838)\n        at android.os.Handler.dispatchMessage(Handler.java:102)\n        at android.os.Looper.loop(Looper.java:145)\n        at android.app.ActivityThread.main(ActivityThread.java:6939)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at java.lang.reflect.Method.invoke(Method.java:372)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1404)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1199)\n    Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from F1:13:65:7E:30:C3\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:186)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:446)\n. I can reproduce it, I have to fix some else and I will try to explain further in a few minutes/hours. Here's a minimal sample of code :\nIt's a service that start when we arrive on the activity. It connects to the device, read 2 values, and subscribe to multiple notifications.\nWhen i press back, i send stopService which call the onDestroy of my service, which dispose the connection observable.\nIt seems that having less notifications subscribed make the issue disappears. But when I do it on 6 characteristics, wait for the connection and press back, it crash almost everytime.\nWhich characteristics doesn't matter. ConnectionSharingAdapter doesn't seems to be the issue too.\nHere are the logs:\nlogs.txt\n```kotlin\npackage fr.openium.device3lib.service\nimport android.app.Service\nimport android.content.Intent\nimport android.os.Binder\nimport android.os.IBinder\nimport com.polidea.rxandroidble2.RxBleConnection\nimport fr.openium.device3lib.ble.device3UUID\nimport fr.openium.device3lib.ble.RxClientHolder\nimport fr.openium.device3lib.device.deviceDevice\nimport fr.openium.device3lib.events.deviceEvents\nimport fr.openium.device3lib.status.ConnectionStatus\nimport io.reactivex.Observable\nimport io.reactivex.Single\nimport io.reactivex.disposables.CompositeDisposable\nimport io.reactivex.disposables.Disposable\nimport io.reactivex.rxkotlin.plusAssign\nimport timber.log.Timber\nimport java.util.*\nimport kotlin.reflect.KFunction1\ninternal class deviceService : Service() {\n    var connectDisposable: Disposable? = null\n    var disposables = CompositeDisposable()\n    override fun onBind(p0: Intent?): IBinder {\n        return object : Binder() {\n    }\n}\n\noverride fun onCreate() {\n    super.onCreate()\n    Timber.d(\"onCreate\")\n}\n\noverride fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n    Timber.d(\"onStartCommand\")\n    if (intent?.hasExtra(\"disconnect\") == true) {\n        disposables.clear()\n    } else {\n        if (deviceDevice.hasDevicePaired()) {\n            connect()\n        }\n    }\n    return Service.START_NOT_STICKY\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n    Timber.d(\"service stopped\")\n    disposables.dispose()\n\n//        connectDisposable?.dispose()\n        deviceEvents.connectionStatus.onNext(ConnectionStatus.DISCONNECTED)\n    }\nprivate var connectionObs: Observable<RxBleConnection>? = null\n\nfun connect() {\n    Timber.d(\"connect\")\n    deviceDevice.getPaired().let { device ->\n        connectDisposable?.dispose()\n        connectDisposable = RxClientHolder.rxBleClient.getBleDevice(device.macAdress)\n            .establishConnection(true).flatMap { rxBleConnection ->\n                deviceEvents.connectionStatus.onNext(ConnectionStatus.DISCOVERING_SERVICE)\n                val monitoringData = device.monitoringData!!\n\n//                    val configData = device.configData!!\n                    Single.zip(\n                        listOf(\n                            rxBleConnection.read(device3UUID.MONITORING.CHAR_TEMP, monitoringData::updateTemp),\n                            rxBleConnection.read(device3UUID.MONITORING.CHAR_BATT, monitoringData::updateBatt)\n                        ), { raw: Array ->\n                            deviceEvents.connectionStatus.onNext(ConnectionStatus.CONNECTED)\n                        }).flatMapObservable {\n                        Observable.combineLatest(\n                            listOf(\n                                rxBleConnection.setupNotif(device3UUID.MONITORING.CHAR_TEMP, monitoringData::updateTemp),\n                                rxBleConnection.setupNotif(device3UUID.MONITORING.CHAR_BATT, monitoringData::updateBatt),\n                                rxBleConnection.setupNotif(device3UUID.MONITORING.CHAR_SOLAR, monitoringData::updateSolar),\n                                rxBleConnection.setupNotif(device3UUID.MONITORING.CHAR_USB, monitoringData::updateUsb),\n                                rxBleConnection.setupNotif(device3UUID.MONITORING.CHAR_ENERGY, monitoringData::updateEnergy),\n                                rxBleConnection.setupNotif(device3UUID.MONITORING.CHAR_GPS, monitoringData::updateGPS)\n                            ), { raw: Array ->\n                                Timber.d(\"received notification\")\n                                raw\n                            })\n                    }\n                }\n                .doOnSubscribe {\n                    Timber.d(\"starting connection\")\n                }\n                .doAfterTerminate {\n                    Timber.d(\"doAfterTerminate\")\n                    deviceEvents.connectionStatus.onNext(ConnectionStatus.DISCONNECTED)\n                }\n                .doOnDispose {\n                    Timber.d(\"doOnDispose\")\n                    deviceEvents.connectionStatus.onNext(ConnectionStatus.DISCONNECTED)\n                }\n                .subscribe(\n                    {\n                        Timber.d(\"toto\")\n                    }, {\n                        Timber.e(it, \"onErrorConnection\")\n                    }, {\n                        Timber.d(\"connection completed\")\n                    })\n            disposables += connectDisposable!!\n        }\n    }\nprivate fun RxBleConnection.read(charUUID: UUID, callback: KFunction1<ByteArray, Unit>): Single<ByteArray> {\n    return readCharacteristic(charUUID).doOnSuccess(callback).onErrorReturn { byteArrayOf() }\n\n}\n\nprivate fun RxBleConnection.setupNotif(charUUID: UUID, callback: KFunction1<ByteArray, Unit>): Observable<ByteArray> {\n    return setupNotification(charUUID).flatMap { it }.doOnNext(callback).onErrorReturn { byteArrayOf() }\n}\n\ncompanion object {\n    const val KEY_SEND_LED = \"KEY_SEND_LED\"\n}\n\n}\n. It seems to be random, but what I don't understand is that It seems to be propagated through a lot of different operator (when I was using combinelatest, for GuillaumeBo through a single/toobservable/timeout, etc...)\nBut unfortunatelly I don't know enough of the underlying behaviour of RxJava2 to help you on the subject. I just tried but unfortunatelly I still have the issue. I will investigate more.. @streetsofboston interesting find... \n@uKL Yes i double checked (because I was already on the snapshot and need to clean a few things to upgrade to latest snapshot version).. Of course, here it is :\n03-23 16:35:42.701 5311-5311/fr.openium.device3app.debug D/deviceService: service stopped\n03-23 16:35:42.701 5311-5722/fr.openium.device3app.debug I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D5:A5:72:34:43:7E)\n03-23 16:35:42.701 5311-5721/fr.openium.device3app.debug D/RxBle#Executors$RunnableAdapter: Terminated.\n03-23 16:35:42.701 5311-5311/fr.openium.device3app.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1202-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-23 16:35:42.701 5311-5722/fr.openium.device3app.debug D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(56480131)\n03-23 16:35:42.701 5311-5572/fr.openium.device3app.debug D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(56480131)\n03-23 16:35:42.701 5311-5723/fr.openium.device3app.debug D/BluetoothManager: getConnectionState()\n    getConnectedDevices\n03-23 16:35:42.701 5311-5311/fr.openium.device3app.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1203-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-23 16:35:42.701 5311-5723/fr.openium.device3app.debug D/BluetoothGatt: cancelOpen() - device: D5:A5:72:34:43:7E\n03-23 16:35:42.701 5311-5311/fr.openium.device3app.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1204-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-23 16:35:42.711 5311-5311/fr.openium.device3app.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1206-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-23 16:35:42.711 5311-5480/fr.openium.device3app.debug D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=8 device=D5:A5:72:34:43:7E\n03-23 16:35:42.711 5311-5311/fr.openium.device3app.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1205-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-23 16:35:42.711 5311-5480/fr.openium.device3app.debug D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n03-23 16:35:42.711 5311-5480/fr.openium.device3app.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1b0d1207-a720-f7e9-46b6-31b601c4fca1 enable: false\n03-23 16:35:42.711 5311-5311/fr.openium.device3app.debug W/System.err: io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from D5:A5:72:34:43:7E\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:314)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:276)\n03-23 16:35:42.721 5311-5311/fr.openium.device3app.debug W/System.err:     at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$DisposeTask.run(ObservableRefCount.java:219)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:30)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:20)\n        at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:43)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:151)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:514)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver.dispose(ObservableDoOnEach.java:80)\n        at io.reactivex.internal.operators.observable.ObservableOnErrorReturn$OnErrorReturnObserver.dispose(ObservableOnErrorReturn.java:56)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n03-23 16:35:42.721 5311-5311/fr.openium.device3app.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n03-23 16:35:42.721 5311-5311/fr.openium.device3app.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.dispose(ObservableDoFinally.java:99)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at fr.openium.device3lib.ble.tasks.TaskLiveInfo$start$1$1.cancel(TaskLiveInfo.kt:54)\n        at io.reactivex.internal.disposables.CancellableDisposable.dispose(CancellableDisposable.java:49)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.dispose(ObservableCreate.java:122)\n        at io.reactivex.internal.observers.DisposableLambdaObserver.dispose(DisposableLambdaObserver.java:86)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.clear(CompositeDisposable.java:183)\n        at fr.openium.device3lib.ble.tasks.TaskManager.stop(TaskManager.kt:87)\n        at fr.openium.device3lib.service.deviceService.onDestroy(deviceService.kt:72)\n        at android.app.ActivityThread.handleStopService(ActivityThread.java:4158)\n        at android.app.ActivityThread.access$2500(ActivityThread.java:229)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1929)\n        at android.os.Handler.dispatchMessage(Handler.java:102)\n        at android.os.Looper.loop(Looper.java:148)\n        at android.app.ActivityThread.main(ActivityThread.java:7325)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\n    Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from D5:A5:72:34:43:7E\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:228)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:453)\n03-23 16:35:42.721 5311-5723/fr.openium.device3app.debug D/BluetoothGatt: close()\n    unregisterApp() - mClientIf=8\n03-23 16:35:42.721 5311-5311/fr.openium.device3app.debug E/AndroidRuntime: FATAL EXCEPTION: main\n    Process: fr.openium.device3app.debug, PID: 5311\n    io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from D5:A5:72:34:43:7E\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:314)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:276)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$DisposeTask.run(ObservableRefCount.java:219)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:30)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:20)\n        at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:43)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:151)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:514)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver.dispose(ObservableDoOnEach.java:80)\n        at io.reactivex.internal.operators.observable.ObservableOnErrorReturn$OnErrorReturnObserver.dispose(ObservableOnErrorReturn.java:56)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.dispose(ObservableDoFinally.java:99)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at fr.openium.device3lib.ble.tasks.TaskLiveInfo$start$1$1.cancel(TaskLiveInfo.kt:54)\n        at io.reactivex.internal.disposables.CancellableDisposable.dispose(CancellableDisposable.java:49)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.dispose(ObservableCreate.java:122)\n        at io.reactivex.internal.observers.DisposableLambdaObserver.dispose(DisposableLambdaObserver.java:86)\n        at io.react\n03-23 16:35:42.721 5311-5572/fr.openium.device3app.debug D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(56480131) in 21 ms\n03-23 16:36:22.651 5311-5311/fr.openium.device3app.debug I/Process: Sending signal. PID: 5311 SIG: 9\n```\nEdit : added some more logs\n. I might be wrong but it seems to me that this merged commit is not in the 1.5.0 release, I am wrong ?\nAsking because I have the aforementionned issue.. ",
    "streetsofboston": "I had some issues using the ConnectionSharingAdapter when dealing with a Rx chain that re-subscribes over and over again (e.g reading a characteristic periodically).\nI had to use the following construct instead to prevent a re-connection to happen over and over again, when a characteristic is re-read. E.g:\n// Scan for myServiceUUID, connect to it, and then read myCharUUID every 5 seconds\nbleClient.scanBleDevices(settings)\n        .filter { scanResult -> isMyService(scanResult.scanRecord.serviceUuids, myServiceUUID) }\n        .take(1)\n        .flatMap { scanResult -> scanResult.bleDevice.establishConnection(false) }\n        .replay()\n        .autoConnect(1)\n        .flatMap { connection -> connection.readDescriptor(myCharUUID) }\n        .repeatWhen { completed -> completed.delay(5, TimeUnit.SECONDS) }\nI needed the replay and autoConnect(1) to make this happen. Using the ConnectionSharingAdapter, it kept reconnecting (kept calling establishConnection each time).\n. Hi Darius,\nIn my example, the subscription happens over and over again, each 5 seconds, through the repeatWhen statement.\nIf I were to replace the replay and autoConnect with the ConnectionSharingAdapter, the re-subscriptions of the repeatWhen don't share the connection:\n// Here, the myCharUUID is read every 5 seconds, \n// but the `establishConnection` is called each time as well.\nbleClient.scanBleDevices(settings)\n        .filter { scanResult -> isMyService(scanResult.scanRecord.serviceUuids, myServiceUUID) }\n        .take(1)\n        .flatMap { scanResult -> scanResult.bleDevice.establishConnection(false) }\n        .compose(new ConnectionSharingAdapter())\n        // Share the connection?\n        .flatMap { connection -> connection.readCharacteristic(myCharUUID) }\n        .repeatWhen { completed -> completed.delay(5, TimeUnit.SECONDS) }\nIf i'm understanding correctly, the ConnectionSharingAdapter shares connections as long as the subscription-count is larger than 0. As soon as all subscribers unsubscribe (either through a terminal state of the observable or through a un-subscribe), the connection will be closed and no longer shared. Is this correct?\n. Thanks! \nThe example I gave is just showing the creation of the Observable of that characteristic. It doesn't show any subscription to that Observable. If the code in the example is all the code that there is, none of those things would happen, indeed; no scanning, no connection, no reading \ud83d\ude04 . I modified the example somewhat, but the code is basically the same that I have in my project. \nThe code works; after subscribing, every 5 seconds the readCharacteristic is called..... Thank you, Dariusz! This library is great and makes working with BLE sooooooo much easier!. I agree with @RobLewis \nI would focus more on moving to using RxJava 2 while changing the code to use the correct observable-types at the same time.\nThe fact that there is no RxJava 2 version (yet) of RxAndroidBLE may become more and more a roadblock for folks that'll prevent them from using this great library.\n. Looking at this code snippet:\n```\n    @Override\n    protected void onStart() {\n        super.onStart();\n    subscription = scan()\n            .subscribe(\n                    // reference a field in the activity to create a reference to the Activity from the lambda\n                    deviceString -> someActivityField = deviceString,\n                    throwable -> Timber.e(throwable));\n}\n\n@Override\nprotected void onDestroy() {\n\n    if (subscription != null) {\n        subscription.unsubscribe();\n        subscription = null;\n    }\n    super.onDestroy();\n}\n\n```\nThe onStart can be called multiple times before the onDestroy is finally called.\nInstead of unsubscribing in the onDestroy, override the onStop instead and unsubscribe there.. I entered this test-enhancement, the removal of the need of RoboElectric, since we have a bunch end-to-end tests written as unit-tests (no need to start them on a device). In these tests, the MockRxAndroidBle client serves as a a dummy device/ble-server serving up responses for the ble-client code being under test. We use PowerMock to get around the need of RoboElectric and it all works great, but the tests are fragile if we ever change the version of MockRxAndroidBle.\nThank you all for looking into this!. Thank you for the quick response.\nWill the mock-client library be deprecated?. I'd love to work on this. It is actually one of my work goals :)\nFor our own library, we managed to create mocked remote BLE devices to be able to run end-to-end unit test and to monitor/test the BLE-requests received by remote BLE-devices. But it relies heavily on PowerMock and knowledge of the private internal implementation of the mockclient.\nThe code we have is in Kotlin only and not that pretty. \nWhich direction would you prefer? \n- Creating/updating the mockclient to make it work without the need for PowerMock (mockito only or through dependency injection) or \n- Remove the mockclient and modify the actual RxAndroidBle code to remove its dependency on classes such as BluetoothGattCharacteristic, etc., and replace those by interfaces whose implementations can be injected. . Sounds good! Thank you!. We had some issues with the ConnectionSharingAdapter in a multithreaded environment. We wrote an updated version. This updated version would obtain/emit shared connections on one thread, making sure the apply (or call) of this adapter is called on one particular thread only. \n. The way ReplayingShare is working, is quite differently from the ConnectionSharingAdapter. I wouldn't be able to tell you if it had the same issues or not.\nThe way we fixed it was by defer-ing the establishConnection Observable and subscribing the deferred Observable on a Scheduler that is single-threaded. . We've seen these BleDisconnectedExceptions wrapped in UndeliverableException in our projects for a while now, when using RxJava2.\nThis happens when you dispose of the subscription while a disconnect takes place. \nThe RxAndroidBle code delivers this exception just before your code disposes of the subscription but was about to reach your just-disposed error-handler just after your code disposes of it.\nWe worked around this by registering an uncaught-exception handler by calling RxJavaPlugins.setErrorHandler and handling the UndeliverableException appropriately. The handler we used just logged the uncaught-exception, but did not let the app crash.. @NitroG42 If you subscribe or observe on a different scheduler than the one that is used by the RxAndroidBle connection-handler, you still can get this error. After the fix of this issue, the error may be delivered properly all the way up to your code that calls the RxAndroidBle methods, but if you then continue your Rx-chain on a different Scheduler, you still may wind up with the UndeliverableException.. In the DisposableUtil.java, when an error is to be emitted, this code is called.\nif (!emitter.isDisposed()) {\n                    emitter.onError(e);\n                }\nWouldn't this still allow for an UndeliverableException when the subscription has been canceled/disposed right after the call to isDisposed but before the error e is being delivered in a multithreaded context?. Maybe the calls !isDisposed followed by an onError(e) can be improved by calling tryOnError(e) instead. Maybe this method doesn't exhibit the possible issues related to race-conditions.... @uKL If the tryOnError of that emitter does the exact some inside, the race-condition still exists, I think. \nIn multi-threaded contexts, where the subscriptions happen - including the disposals or cancellations in different threads than the emissions of items and errors, UndeliverableException are unavoidable. The use of RxJavaPlugins.setErrorHandler seems necessary since the RxAndroidBle library has no control of the threading model by the caller.. I have not reported this to Jake, since I think it is not an issue for the ReplayingShare itself. \nMy issue is that caution needs to be taken with the recommendation of using ReplayingShare for sharing RxBleConnections. \nWhen the lastSeen.value is null, a null item is not emitted; instead nothing is emitted (if you look at ReplayingShare's java-code, you see that onNext is not called when value == null). No Rx violation :). @RobLewis In answer to your second question.\nretryWhen would work only for the first observer and possibly fix it disconnection issue. \nIf you put the retryWhen before the composition with the ReplayingShare, you'll always retry for all subscribers.... and sometime you don't want to. \nAt some point, retries should be given up and you'll want to just let it fail. In this case, you'd have an invalid/stale RxBleConnection cached in the ReplayingShare. The next observer who then subscribes to this shared Rx chain of connections may then receive that stale connection, while it should instead just cause a re-subscription of the observable returned by establishConnection without a preceding replay from ReplayingShare.\nIf the RxBleConnection had a method like isConnected or isValid or something, one could use a filter or some other Rx chain of commands to ignore them and get a fresh RxBleConnection instead.. @RobLewis The code snippet I posted in in Kotlin, not Java. \nIn this case the Java Action is an interface with only one method, a so-called SAM (Single Abstract Method). Kotlin's Java interoperability allow lambdas to be assigned to SAMs, where Kotlin compiler does the necessary translation from lambda to Action instance in this case.\nIn my example, the Java Action is assigned a Kotlin lambda { lastSeen.value = null }. @RobLewis I chose to use the doFinally since, at least for our purpose, it has to be executed not only when an error takes place but also when all subscriptions to it are disposed of. \n. @BernhardReu You missed the case where the BleConnection that is emitted is severed (the connection becomes 'stale'); and this case isn't handled properly by the ReplayingShare either. See here as well: https://github.com/JakeWharton/RxReplayingShare/issues/25. @BernhardReu In our projects we tried such a solution and it is working for us quite well with the Ble-Connections. Here is the solution's gist:\nhttps://gist.github.com/streetsofboston/cf14543f0467af5cf990ac91b62b4606. ",
    "yohanan": "rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\ndo you have a line somewhere that calls onError?  in particular, do you have one that is something similar to the following?\nObserver.onError(Exceptions.propagate(throwable));. a colleague of mine was struggling last night with what appears to be the same issue; the stack traces look very similar.\nin our case, we were mistakenly calling onError(Exceptions.propagate(throwable)) because of a misinterpretation on how Exceptions.propagate() worked: we thought it returned an exception, but it actually throws one.  so, we were effectively throwing an exception in something designed to pass along one; hence, the error.\nthere is a good chance your issue has nothing to do with the RxAndroidBle library.  there is a posting on Stack Overflow that discusses this more generally --- not specific to Exeptions.propagate():\n RxJava: Error occurred when trying to propagate error to Observer.onError.\nthis all points to throwing an exception in an onError() method, so i'd focus on those in your code.\nas a suggestion related to the lambdas, if you're having trouble isolating the issue because of them, it might help to convert temporarily to anonymous inner classes.  this can easily be done in Android Studio by navigating to the lambda and pressing alt+return then selecting Replace lambda with anonymous class from the popup menu.  you can convert back in a similar manner.. ",
    "ivanlardis": "@kenwdelong, hello, i have same problem. Please can you show me an example of the code where you solved this problem. ",
    "mswokk": "Hi @dariuszseweryn \nI agree it's unusual that using BLE notification for important messaging.\nBut regardless it, registering some callback function before requesting data is much more make sense.\nSo I modified some part of rxandroidble and it fixed my App problem.\nI hope you to review my idea and please answer so that I can make a pull request.\nHere is my change (I'm quite new to RX programming, not so sure my change is best)\n\nAppendix: my problem was..\nI build an RN app with react-native-ble-plx.\nI expect to receive 5 characteristic change consequentially from BLE device by notification request.\nOn iPhone, it always works well. \nBut on Android, app always missed first change due to fails to check changedCharacteristicSerializedPublishRelay.hasObservers() in NotificationAndIndicationManager.java\nAfter that fix, now android also works well.\n\nThank you.\n. Close and will create a new request with error handling. ",
    "ZacharyTech": "Use the phone settings -> Bluetooth connection device (BLE device + Android phone), then it will not be able to scan this device.\nAs long as the standard BLE equipment can be used to connect the above way!\nThis question is actually a supplement to How to get an existing connection\n. I am sure it is BLE, using the device is  DJI OSMO Mobile + Samsung S6.\n. Although through the BluetoothAdapter.getDefaultAdapter (). GetConnectedDevices () can be obtained to the connected device\uff0cbut i don't know  how to associate it with RxAndridBle and operate it!\n. How to read or write, I use RxBleClient.getBleDevice (macAddress) .establishConnection (autoConnect)will appear BleAlreadyConnectedException. Okay, thank you very much. . ",
    "baadillahnabil": "oh ya i found it now, thank you, i wasn't able to find that (my bad), thanks again . cool, thanks for that too :). CR=Carriage Return , LF = Line Feed (Newline) \nbut i want to use only LF. okay i got it working now, thanks, but i got another problem, i can only send 20 characters only inside string that converted to bytes using string.getBytes() and the pass it to writeCharacteristic \ni have this string : \nString value = (\"thislineisstopatthisinthats \\n\");\nthen write it : \nif (isBluetoothConnected()) {\n            connectionObservable\n                    .flatMap(rxBleConnection -> rxBleConnection.writeCharacteristic(characteristicUUID, value.getBytes(StandardCharsets.UTF_8)))\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(bytes -> onWriteSuccess(), this::onWriteFailure);\n            }\nbut the string is only sent for first 20 characters only, that make me so confused\n. @RobLewis thanks for your answer. i confused because i don't know that, can bluetooth packets size be about 30-40 bytes ? i need to send a string that contains about 30-40 characters at one time. i'm very new about bluetooth :(. yeah, thanks for that, but i got it working using .createNewLongWriteBuilder() \nthanks again :). ",
    "edifangyi": "@dariuszseweryn yes\uff0c\uff0clook here\uff1a\nhttp://ww1.sinaimg.cn/large/648b709cly1fg2hlyd68vj20u01hcgrf.jpg\nhttp://ww1.sinaimg.cn/large/648b709cly1fg2hsqysj5j20u01hcmyt.jpg\n\nI clicked Notify  -> CONNECT - >REGISTER NOTIFICATIONS : \n\nBleCannotSetCharacteristicNotificationException{bluetoothGattCharacteristic=0003cdd1-0000-1000-8000-00805f9b0131}\nI clicked Write-> CONNECT - >  : Write 1234 \uff1a\nhttp://ww1.sinaimg.cn/large/648b709cly1fg2huwdb7qj20he09s0t5.jpg\n. @dariuszseweryn I'm sorry, I did not read your meaning. However, I use the Bluetooth manufacturers to provide the Demo can use the monitor\nhttp://ww1.sinaimg.cn/large/648b709cly1fg2i5uzpjsj20u01hcjsw.jpg. @dariuszseweryn  Thank you, the problem is solved. I will ask the Bluetooth chip manufacturers in this area related issues. ",
    "Andy4ward": "@dariuszseweryn I've been looking into how i can call the RxBleConnection.setupNotifcation method from my react native project with very little success.\nI can go into the android package and set all monitor notifcations to COMPAT but that just causes errors elsewhere.\nShould it be possible to get to the the setupNotification function by importing NativeModules from React Native?. ",
    "logalleg": "You probably want the Bluetooth actions occurring in a Service, and that Service using broadcasts for various activities, fragments, etc to listen in on.. ",
    "LordParsley": "@dariuszseweryn thank you \u2013 sorry, I see the warning added in https://github.com/Polidea/RxAndroidBle/commit/56854d9b2ca88fbb97053d8f1909c4fe31665e12. @dariuszseweryn Yes, thanks, I used the workaround to upload to Google Play successfully (didn't realise you had documented it already when I created the issue).. ",
    "DogsForArms": "Thanks for the quickness Darius!  Let me know if I can provide details or help provide more specific code to reproduce.. Thanks very much!  I'll update now and let you know what I see.  Great work!. moments after posting I found that adding \n    compile 'io.reactivex:rxandroid:1.2.1'\nto my build.gradle would give me the dependencies I need! . ",
    "Pascal66": "Ok I've a custom rom 4.4.4 with bluez stack for bluetooth.\nI need to use an app wich I know using your library, it unable to get the ble device.\nWhen I look at my bluetooth devices, I can saw all\nnot sure how to explain better. Logcat of my bluez stack on android 4.4.4 : \nThe ble device is well reconized as you see below\nThe problem seems to be is the use of your library wich cant talk with this ble device.\nUnfortunatly, I cant look at this proprietary app and cant watch wheress the problem.\n06-14 17:54:21.085 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:handle_device_found() \n06-14 17:54:21.085 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:device_props_to_hal() prop[0]: type=BT_PROPERTY_BDADDR len=6 val=00:xx:xx:xx:xx:xx\n06-14 17:54:21.095 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:device_props_to_hal() prop[1]: type=BT_PROPERTY_TYPE_OF_DEVICE len=4 val=BT_DEVICE_DEVTYPE_BLE\n06-14 17:54:21.095 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:device_props_to_hal() prop[2]: type=BT_PROPERTY_REMOTE_RSSI len=4 val=211\n06-14 17:54:21.095 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:device_props_to_hal() prop[3]: type=BT_PROPERTY_BDNAME len=14 val=Flipr 00xxxxxx\n06-14 17:54:21.125 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:handle_device_state_changed() \n06-14 17:54:21.125 4302-4356/? D/BlueZ: external/bluetooth/bluez/android/hal-bluetooth.c:device_props_to_hal() prop[0]: type=BT_PROPERTY_REMOTE_RSSI len=4 val=177\n06-14 17:54:21.135 28736-28736/? D/BluetoothEventManager: DeviceFoundHandler created new CachedBluetoothDevice: 00:xx:xx:xx:xx:xx. New logcat, hope it can give you some clues, because i'm near to an headache about this strange behaviour:\n```\n06-16 17:27:21.709 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method android.view.View., referenced from method com.wang.avi.AVLoadingIndicatorView.\n06-16 17:27:21.709 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve direct method 22391: Landroid/view/View;. (Landroid/content/Context;Landroid/util/AttributeSet;II)V\n06-16 17:27:21.709 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x70 at 0x0001\n06-16 17:27:21.709 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method android.view.View.drawableHotspotChanged, referenced from method com.wang.avi.AVLoadingIndicatorView.drawableHotspotChanged\n06-16 17:27:21.709 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve virtual method 22411: Landroid/view/View;.drawableHotspotChanged (FF)V\n06-16 17:27:21.709 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x6f at 0x0000\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method android.app.Activity.shouldShowRequestPermissionRationale, referenced from method com.tbruyelle.rxpermissions2.RxPermissions.shouldShowRequestPermissionRationaleImplementation\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve virtual method 141: Landroid/app/Activity;.shouldShowRequestPermissionRationale (Ljava/lang/String;)Z\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x6e at 0x000d\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method android.app.Activity.checkSelfPermission, referenced from method com.tbruyelle.rxpermissions2.RxPermissionsFragment.isGranted\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve virtual method 96: Landroid/app/Activity;.checkSelfPermission (Ljava/lang/String;)I\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x6e at 0x0004\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method android.content.pm.PackageManager.isPermissionRevokedByPolicy, referenced from method com.tbruyelle.rxpermissions2.RxPermissionsFragment.isRevoked\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve virtual method 704: Landroid/content/pm/PackageManager;.isPermissionRevokedByPolicy (Ljava/lang/String;Ljava/lang/String;)Z\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x6e at 0x0010\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method android.app.Fragment.onRequestPermissionsResult, referenced from method com.tbruyelle.rxpermissions2.RxPermissionsFragment.onRequestPermissionsResult\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve virtual method 254: Landroid/app/Fragment;.onRequestPermissionsResult (I[Ljava/lang/String;[I)V\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x6f at 0x0000\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr I/dalvikvm: Could not find method com.tbruyelle.rxpermissions2.RxPermissionsFragment.requestPermissions, referenced from method com.tbruyelle.rxpermissions2.RxPermissionsFragment.requestPermissions\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr W/dalvikvm: VFY: unable to resolve virtual method 44684: Lcom/tbruyelle/rxpermissions2/RxPermissionsFragment;.requestPermissions ([Ljava/lang/String;I)V\n06-16 17:27:21.829 32381-32381/com.goflipr.flipr D/dalvikvm: VFY: replacing opcode 0x6e at 0x0002\n06-16 17:27:21.959 32381-32441/com.goflipr.flipr D/dalvikvm: GC_FOR_ALLOC freed 1322K, 16% free 7361K/8756K, paused 54ms, total 54ms\n06-16 17:27:22.420 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n06-16 17:27:22.430 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551 Thread: main\n06-16 17:27:22.430 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n06-16 17:27:22.440 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551 LoadedApk$ReceiverDispatcher$Args.run  (LoadedApk.java:759)\n06-16 17:27:22.440 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551    ScanActivity$2.onReceive  (ScanActivity.java:138)\n06-16 17:27:22.440 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n06-16 17:27:22.440 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551 STATE_TURNING_ON\n06-16 17:27:22.440 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n06-16 17:27:23.020 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551 Thread: main\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551 LoadedApk$ReceiverDispatcher$Args.run  (LoadedApk.java:759)\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551    ScanActivity$2.onReceive  (ScanActivity.java:134)\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u2551 STATE_ON\n06-16 17:27:23.030 32381-32381/com.goflipr.flipr D/PRETTYLOGGER: \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n06-16 17:27:25.062 32381-32667/com.goflipr.flipr D/RxBle#Radio:   QUEUED RxBleRadioOperationScan(1104271904)\n06-16 17:27:25.072 32381-495/com.goflipr.flipr D/RxBle#Radio:  STARTED RxBleRadioOperationScan(1104271904)\n06-16 17:27:25.072 32381-32381/com.goflipr.flipr D/BluetoothAdapter: startLeScan(): null\n06-16 17:27:35.082 32381-495/com.goflipr.flipr D/RxBle#Radio: FINISHED RxBleRadioOperationScan(1104271904)\n06-16 17:27:35.092 32381-32381/com.goflipr.flipr I/Choreographer: Skipped 600 frames!  The application may be doing too much work on its main thread.\n06-16 17:27:35.112 32381-32381/com.goflipr.flipr D/EventBus: No subscribers registered for event class com.goflipr.flipr.model.ble.BleError\n06-16 17:27:35.112 32381-32381/com.goflipr.flipr D/EventBus: No subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent\n06-16 17:28:10.126 32381-32381/com.goflipr.flipr D/dalvikvm: GC_EXPLICIT freed 734K, 17% free 7312K/8756K, paused 6ms+8ms, total 80ms\n```. ",
    "Ezor": "Hi, i get the same things  (status code = 128) :\n06-18 17:44:56.316 19237-19258/com.mypackage D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n06-18 17:44:56.316 19237-19319/com.mypackage D/BluetoothGatt: setCharacteristicNotification() - uuid: 18cda784-4bd3-4370-85bb-bfed91ec86af enable: true\n06-18 17:44:56.321 19237-19319/com.mypackage D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(1110660456)\n06-18 17:44:56.321 19237-19250/com.mypackage D/RxBle#Radio: FINISHED RxBleRadioOperationServicesDiscover(1110487864)\n06-18 17:44:56.321 19237-19250/com.mypackage D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(1110660456)\n06-18 17:44:56.346 19237-19237/com.mypackage D/BluetoothGatt: writeDescriptor() - uuid: 00002902-0000-1000-8000-00805f9b34fb\n06-18 17:44:56.726 19237-19249/com.mypackage D/BluetoothGatt: onDescriptorWrite() - Device=EC:FE:7E:15:91:3A UUID=18cda784-4bd3-4370-85bb-bfed91ec86af\n06-18 17:44:56.731 19237-19249/com.mypackage D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=128\n06-18 17:44:56.736 19237-19250/com.mypackage D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(1110660456)\n06-18 17:44:56.736 19237-19319/com.mypackage D/BluetoothGatt: setCharacteristicNotification() - uuid: 18cda784-4bd3-4370-85bb-bfed91ec86af enable: false\n06-18 17:44:56.741 19237-19319/com.mypackage D/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(1110764936)\n06-18 17:44:56.741 19237-19250/com.mypackage D/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(1110764936)\n06-18 17:44:56.746 19237-19237/com.mypackage D/BluetoothGatt: writeDescriptor() - uuid: 00002902-0000-1000-8000-00805f9b34fb\n06-18 17:44:56.771 19237-19319/com.mypackage D/dalvikvm: GC_FOR_ALLOC freed 1369K, 30% free 6034K/8532K, paused 19ms, total 19ms\n06-18 17:44:56.771 19237-19319/com.mypackage E/TimeActivity: Error\n                                                                     BleCannotSetCharacteristicNotificationException{bluetoothGattCharacteristic=18cda784-4bd3-4370-85bb-bfed91ec86af, reason=CANNOT_WRITE_CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR (see Javadoc for more comment)}\n                                                                         at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$10.call(NotificationAndIndicationManager.java:215)\n                                                                         at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$10.call(NotificationAndIndicationManager.java:212)\n                                                                         at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onError(OperatorOnErrorResumeNextViaFunction.java:140)\n                                                                         at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)\n                                                                         at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)\n                                                                         at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)\n                                                                         at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n                                                                         at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:852)\n                                                                         at rx.internal.operators.OnSubscribeCreate$BaseEmitter.onError(OnSubscribeCreate.java:109)\n                                                                         at rx.internal.util.ObserverSubscriber.onError(ObserverSubscriber.java:39)\n                                                                         at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)\n                                                                         at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                                                                         at rx.internal.operators.OperatorUnsubscribeOn$1.onError(OperatorUnsubscribeOn.java:47)\n                                                                         at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onError(OperatorSubscribeOn.java:80)\n                                                                         at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87)\n                                                                         at rx.internal.operators.OnSubscribeCreate$BaseEmitter.onError(OnSubscribeCreate.java:109)\n                                                                         at com.polidea.rxandroidble.internal.util.RadioReleasingEmitterWrapper.onError(RadioReleasingEmitterWrapper.java:44)\n                                                                         at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)\n                                                                         at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                                                                         at rx.observers.SerializedObserver.onError(SerializedObserver.java:152)\n                                                                         at rx.observers.SerializedSubscriber.onError(SerializedSubscriber.java:78)\n                                                                         at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onError(OperatorTimeoutBase.java:147)\n                                                                         at rx.internal.operators.OperatorSingle$ParentSubscriber.onError(OperatorSingle.java:129)\n                                                                         at rx.internal.operators.OperatorTake$1.onError(OperatorTake.java:65)\n                                                                         at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                                                                         at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onError(OnSubscribeFilter.java:90)\n                                                                         at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:273)\n                                                                         at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216)\n                                                                         at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n                                                                         at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n                                                                         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n                                                                         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n                                                                         at java.lang.Thread.run(Thread.java:841)\n06-18 17:44:56.776 19237-19319/com.mypackage D/RxBle#Radio:   QUEUED RxBleRadioOperationDisconnect(1110319560)\n06-18 17:44:56.826 19237-19258/com.mypackage D/BluetoothGatt: onDescriptorWrite() - Device=EC:FE:7E:15:91:3A UUID=18cda784-4bd3-4370-85bb-bfed91ec86af\n06-18 17:44:56.826 19237-19258/com.mypackage D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n06-18 17:44:56.826 19237-19250/com.mypackage D/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(1110764936)\n06-18 17:44:56.826 19237-19250/com.mypackage D/RxBle#Radio:  STARTED RxBleRadioOperationDisconnect(1110319560)\n06-18 17:44:56.831 19237-19237/com.mypackage D/BluetoothManager: getConnectionState()\n06-18 17:44:56.831 19237-19237/com.mypackage D/BluetoothManager: getConnectedDevices\n06-18 17:44:56.831 19237-19237/com.mypackage D/BluetoothGatt: cancelOpen() - device: EC:FE:7E:15:91:3A\n06-18 17:44:56.836 19237-19248/com.mypackage D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=5 device=EC:FE:7E:15:91:3A\n06-18 17:44:56.836 19237-19248/com.mypackage D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n06-18 17:44:56.836 19237-19237/com.mypackage D/BluetoothGatt: close()\n06-18 17:44:56.836 19237-19237/com.mypackage D/BluetoothGatt: unregisterApp() - mClientIf=5\n06-18 17:44:56.836 19237-19250/com.mypackage D/RxBle#Radio: FINISHED RxBleRadioOperationDisconnect(1110319560)\nAny idea ?. @dariuszseweryn I just fixed the problem by using setupIndication instead of setupNotification. Thanks anyway. It seems you are right there is something wrong with the XPERIA L1...\nAnd for the log it seems i'm not the only one to have this issue : \nhttps://stackoverflow.com/questions/36554215/lodcat-not-displaying-debug-messages-when-using-specific-device\nI close the issue as it's probably only related to my device.\nThanks for your fast feedback anyway. . Well that's crazy, I just fixed the problem 2 minutes after sending this issue (I worked on it 4 hours...).\nAs you may notice in the log, the app is doing the following :\n\nConnect to device (establishConnection)\nSetup Indication for some \"READ\" Characteristic\nWrite some value on a \"WRITE\" Characteristic\nWrite & Read lot of data on both \"READ\" & \"WRITE\" Characteristic\n\nI switched 2 & 3 it's now OK !!!?\n\nConnect to device (establishConnection)\nWrite some value on a \"WRITE\" Characteristic\nSetup Indication for some \"READ\" Characteristic\nWrite & Read lot of data on both \"READ\" & \"WRITE\" Characteristic. You are probably right, it's just a workaround.\n\nI will post the HCI logs for the Samsung tomorrow but I'm not sure to be able to post the HCI logs for the Xiaomi because i don't have the device at home, it's the device of one of my client (working 500km far away). I will do my best.. ",
    "leof23": "yes, that was my issue, thanks for the answer. I implement the ScanFilter but is like you say I can't see any Stop Scan or something similar in the logs, I don't know why is not scanning correctly. ",
    "darrinps": "I'm seeing something similar to this:\nFailed to establish connection Undocumented scan throttle (code 2147483646), suggested retry date is Wed Jul 11 11:18:06 PDT 2018\n                                                                                         com.polidea.rxandroidble2.exceptions.BleScanException: Undocumented scan throttle (code 2147483646), suggested retry date is Wed Jul 11 11:18:06 PDT 2018\n                                                                                             at com.polidea.rxandroidble2.internal.scan.ScanPreconditionsVerifierApi24.verify(ScanPreconditionsVerifierApi24.java:51)\n                                                                                             at com.polidea.rxandroidble2.RxBleClientImpl$1.call(RxBleClientImpl.java:118)\n                                                                                             at com.polidea.rxandroidble2.RxBleClientImpl$1.call(RxBleClientImpl.java:115)\n                                                                                             at io.reactivex.internal.operators.observable.ObservableDefer.subscribeActual(ObservableDefer.java:32)\n                                                                                             at io.reactivex.Observable.subscribe(Observable.java:12051)\n                                                                                             at io.reactivex.internal.operators.observable.ObservableDoOnEach.subscribeActual(ObservableDoOnEach.java:42)\n                                                                                             at io.reactivex.Observable.subscribe(Observable.java:12051)\n                                                                                             at io.reactivex.internal.operators.observable.ObservableFilter.subscribeActual(ObservableFilter.java:30)\n                                                                                             at io.reactivex.Observable.subscribe(Observable.java:12051)\n                                                                                             at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java:37)\n                                                                                             at io.reactivex.Single.subscribe(Single.java:3310)\n                                                                                             at io.reactivex.internal.operators.single.SingleTimeout.subscribeActual(SingleTimeout.java:53)\n                                                                                             at io.reactivex.Single.subscribe(Single.java:3310)\n                                                                                             at io.reactivex.internal.operators.single.SingleDoOnError.subscribeActual(SingleDoOnError.java:35)\n                                                                                             at io.reactivex.Single.subscribe(Single.java:3310)\n                                                                                             at io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)\n                                                                                             at io.reactivex.Single.subscribe(Single.java:3310)\n                                                                                             at io.reactivex.internal.operators.single.SingleDefer.subscribeActual(SingleDefer.java:43)\n                                                                                             at io.reactivex.Single.subscribe(Single.java:3310)\nIt's happening on multiple devices running on various versions of Android up to and including those running Android Pie.  What I think would be nice, is if a flag could be set for RxAndroidBle that tells it to automatically scan at the suggested retry time. That time seems like it's around 10 seconds or so into the future most of the time.\n . ",
    "Jogosb": "I missed that Javadoc, thanks for a quick response! . ",
    "KarolMB": "Hello @dariuszseweryn.\nBUG: Sony Xperia Z5 - Android 7.0 ( Updated to 7.1 and still the same problem)\nOK: Sony Xperia Z5 Premium - Android 6.0.1\nBUG?: Nexus 5 - Android 6.0.1 I'm getting BleGattException 0x85\nLibrary:  'com.polidea.rxandroidble:rxandroidble:1.2.3'\nI'm not using BluetoothGatt.refresh().\nReproduction:\nConnect Phone with Ble device. Restart both ( app and ble device). Try connect again.\nAfter 15-20s its working again OK.\nLooks like phone issue? Not a platform?  Any idea how to handle this?. To be honest. I'm not responsible for peripheral device and don't know. . @dariuszseweryn Hey. Sorry have no time for this issue now. For now I'm just trying connect again and it takes more time for connection but works( for now its ok). But will check it soon.   \n. Hey @dariuszseweryn . \nBy print whole stacktrace You mean this? ->   RxJavaHooks.enableAssemblyTracking();\nOr logs from RxAndroidBle?. More logs :\n```\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":421}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=421, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 242559, \"ArrayAcc\": [{\"x\": -0.21315674483776093, \"y\": -0.30656251311302185, \"z\": 10.027947425842285}, {\"x\": -0.25387206673622131, \"y\": -0.23231691122055054, \"z\": 9.9441213607788086}, {\"x\": -0.24189698696136475, \"y\": -0.28740236163139343, \"z\": 10.027947425842285}, {\"x\": -0.18681153655052185, \"y\": -0.27782228589057922, \"z\": 10.030342102050781}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 242559, \"ArrayAcc\": [{\"x\": -0.21315674483776093, \"y\": -0.30656251311302185, \"z\": 10.027947425842285}, {\"x\": -0.25387206673622131, \"y\": -0.23231691122055054, \"z\": 9.9441213607788086}, {\"x\": -0.24189698696136475, \"y\": -0.28740236163139343, \"z\": 10.027947425842285}, {\"x\": -0.18681153655052185, \"y\": -0.27782228589057922, \"z\": 10.030342102050781}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nI/art: Background partial concurrent mark sweep GC freed 295544(11MB) AllocSpace objects, 0(0B) LOS objects, 40% free, 18MB/31MB, paused 6.197ms total 93.206ms\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":421}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=421, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 242636, \"ArrayAcc\": [{\"x\": -0.21076172590255737, \"y\": -0.29219239950180054, \"z\": 10.008787155151367}, {\"x\": -0.19878663122653961, \"y\": -0.34248781204223633, \"z\": 10.147698402404785}, {\"x\": -0.19878663122653961, \"y\": -0.28021728992462158, \"z\": 10.037527084350586}, {\"x\": -0.17723144590854645, \"y\": -0.27303224802017212, \"z\": 10.054292678833008}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 242636, \"ArrayAcc\": [{\"x\": -0.21076172590255737, \"y\": -0.29219239950180054, \"z\": 10.008787155151367}, {\"x\": -0.19878663122653961, \"y\": -0.34248781204223633, \"z\": 10.147698402404785}, {\"x\": -0.19878663122653961, \"y\": -0.28021728992462158, \"z\": 10.037527084350586}, {\"x\": -0.17723144590854645, \"y\": -0.27303224802017212, \"z\": 10.054292678833008}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":419}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=419, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 242713, \"ArrayAcc\": [{\"x\": -0.25626710057258606, \"y\": -0.25147706270217896, \"z\": 10.090217590332031}, {\"x\": -0.20597168803215027, \"y\": -0.25866213440895081, \"z\": 10.037527084350586}, {\"x\": -0.21076172590255737, \"y\": -0.26105713844299316, \"z\": 10.03513240814209}, {\"x\": -0.22034180164337158, \"y\": -0.26824221014976501, \"z\": 10.03513240814209}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 242713, \"ArrayAcc\": [{\"x\": -0.25626710057258606, \"y\": -0.25147706270217896, \"z\": 10.090217590332031}, {\"x\": -0.20597168803215027, \"y\": -0.25866213440895081, \"z\": 10.037527084350586}, {\"x\": -0.21076172590255737, \"y\": -0.26105713844299316, \"z\": 10.03513240814209}, {\"x\": -0.22034180164337158, \"y\": -0.26824221014976501, \"z\": 10.03513240814209}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":419}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=419, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 242790, \"ArrayAcc\": [{\"x\": -0.24668702483177185, \"y\": -0.31853762269020081, \"z\": 10.003996849060059}, {\"x\": -0.22992187738418579, \"y\": -0.30656251311302185, \"z\": 9.99920654296875}, {\"x\": -0.21794678270816803, \"y\": -0.31853762269020081, \"z\": 10.063872337341309}, {\"x\": -0.19878663122653961, \"y\": -0.31614258885383606, \"z\": 10.075847625732422}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 242790, \"ArrayAcc\": [{\"x\": -0.24668702483177185, \"y\": -0.31853762269020081, \"z\": 10.003996849060059}, {\"x\": -0.22992187738418579, \"y\": -0.30656251311302185, \"z\": 9.99920654296875}, {\"x\": -0.21794678270816803, \"y\": -0.31853762269020081, \"z\": 10.063872337341309}, {\"x\": -0.19878663122653961, \"y\": -0.31614258885383606, \"z\": 10.075847625732422}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":420}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=420, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 242867, \"ArrayAcc\": [{\"x\": -0.23471193015575409, \"y\": -0.33051270246505737, \"z\": 10.003996849060059}, {\"x\": -0.16046631336212158, \"y\": -0.27303224802017212, \"z\": 10.092612266540527}, {\"x\": -0.19878663122653961, \"y\": -0.30656251311302185, \"z\": 10.08063793182373}, {\"x\": -0.21076172590255737, \"y\": -0.32093262672424316, \"z\": 10.003996849060059}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 242867, \"ArrayAcc\": [{\"x\": -0.23471193015575409, \"y\": -0.33051270246505737, \"z\": 10.003996849060059}, {\"x\": -0.16046631336212158, \"y\": -0.27303224802017212, \"z\": 10.092612266540527}, {\"x\": -0.19878663122653961, \"y\": -0.30656251311302185, \"z\": 10.08063793182373}, {\"x\": -0.21076172590255737, \"y\": -0.32093262672424316, \"z\": 10.003996849060059}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":419}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=419, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 242943, \"ArrayAcc\": [{\"x\": -0.20357666909694672, \"y\": -0.3041674792766571, \"z\": 10.018366813659668}, {\"x\": -0.17962647974491119, \"y\": -0.31614258885383606, \"z\": 10.042317390441895}, {\"x\": -0.17962647974491119, \"y\": -0.35206788778305054, \"z\": 10.03513240814209}, {\"x\": -0.20836670696735382, \"y\": -0.31614258885383606, \"z\": 9.9752569198608398}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 242943, \"ArrayAcc\": [{\"x\": -0.20357666909694672, \"y\": -0.3041674792766571, \"z\": 10.018366813659668}, {\"x\": -0.17962647974491119, \"y\": -0.31614258885383606, \"z\": 10.042317390441895}, {\"x\": -0.17962647974491119, \"y\": -0.35206788778305054, \"z\": 10.03513240814209}, {\"x\": -0.20836670696735382, \"y\": -0.31614258885383606, \"z\": 9.9752569198608398}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/BleManager: Received data: \nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":414}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=414, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 243020, \"ArrayAcc\": [{\"x\": -0.19639161229133606, \"y\": -0.3041674792766571, \"z\": 10.061477661132812}, {\"x\": -0.21794678270816803, \"y\": -0.29937744140625, \"z\": 9.99920654296875}, {\"x\": -0.21555176377296448, \"y\": -0.29698243737220764, \"z\": 10.063872337341309}, {\"x\": -0.22992187738418579, \"y\": -0.31853762269020081, \"z\": 10.03513240814209}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 243020, \"ArrayAcc\": [{\"x\": -0.19639161229133606, \"y\": -0.3041674792766571, \"z\": 10.061477661132812}, {\"x\": -0.21794678270816803, \"y\": -0.29937744140625, \"z\": 9.99920654296875}, {\"x\": -0.21555176377296448, \"y\": -0.29698243737220764, \"z\": 10.063872337341309}, {\"x\": -0.22992187738418579, \"y\": -0.31853762269020081, \"z\": 10.03513240814209}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nD/BleManager: Received data: \nE/BleManager: dataAvailable() Error: rx.exceptions.MissingBackpressureException\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 34802252-7185-4d5d-b431-630e7050e8f0 enable: false\nD/RxBle#BluetoothGatt: onCharacteristicChanged characteristic=34802252-7185-4d5d-b431-630e7050e8f0\nE/MdsHeader: headerObj: {\"Content-Type\":\"application\\/json\",\"Status\":0,\"Reason\":\"CUSTOM_STATUS\",\"Uri\":\"MDS\\/EventListener\\/20\",\"Content-Length\":420}\nD/Mds:  Mds SDSInternalCallback()  taskId:20 sdsCallType:2 header:SdsHeader{status=0, uri='MDS/EventListener/20', reason='CUSTOM_STATUS', contentLength=420, contentType='null', location='', taskId=0} dataBody:{\"Body\": {\"Timestamp\": 243097, \"ArrayAcc\": [{\"x\": -0.19878663122653961, \"y\": -0.25626710057258606, \"z\": 10.097402572631836}, {\"x\": -0.19160157442092896, \"y\": -0.25387206673622131, \"z\": 9.9872322082519531}, {\"x\": -0.2442920058965683, \"y\": -0.32572266459465027, \"z\": 10.039922714233398}, {\"x\": -0.16765137016773224, \"y\": -0.33051270246505737, \"z\": 10.011181831359863}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/LinearAccelerationTestActivity: onSuccess(): {\"Body\": {\"Timestamp\": 243097, \"ArrayAcc\": [{\"x\": -0.19878663122653961, \"y\": -0.25626710057258606, \"z\": 10.097402572631836}, {\"x\": -0.19160157442092896, \"y\": -0.25387206673622131, \"z\": 9.9872322082519531}, {\"x\": -0.2442920058965683, \"y\": -0.32572266459465027, \"z\": 10.039922714233398}, {\"x\": -0.16765137016773224, \"y\": -0.33051270246505737, \"z\": 10.011181831359863}]}, \"Uri\": \"ECKI89CB9A98/Meas/Acc/52\", \"Method\": \"PUT\"}\nD/RxBle#Radio:   QUEUED RxBleRadioOperationDescriptorWrite(168985183)\nD/RxBle#Radio:  STARTED RxBleRadioOperationDescriptorWrite(168985183)\nD/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\nD/RxBle#Radio: FINISHED RxBleRadioOperationDescriptorWrite(168985183)\n.\nrx.exceptions.MissingBackpressureException\nat rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:325)\nat rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:379)\nat rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:361)\nat rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\nat rx.subjects.PublishSubject$PublishSubjectProducer.onNext(PublishSubject.java:304)\nat rx.subjects.PublishSubject$PublishSubjectState.onNext(PublishSubject.java:219)\nat rx.subjects.PublishSubject.onNext(PublishSubject.java:72)\nat rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\nat rx.subjects.SerializedSubject.onNext(SerializedSubject.java:67)\nat com.polidea.rxandroidble.internal.connection.RxBleGattCallback$3.onCharacteristicChanged(RxBleGattCallback.java:130)\nat android.bluetooth.BluetoothGatt$1.onNotify(BluetoothGatt.java:438)\nat android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:399)\nat android.os.Binder.execTransact(Binder.java:453)\nCaused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:\nat rx.Observable.unsafeCreate(Observable.java:162)\nat rx.Observable.lift(Observable.java:299)\nat rx.Observable.merge(Observable.java:2572)\nat rx.Observable.merge(Observable.java:2914)\nat rx.Observable.merge(Observable.java:2667)\nat com.polidea.rxandroidble.internal.connection.RxBleGattCallback.withHandlingStatusErrorAndDisconnection(RxBleGattCallback.java:247)\nat com.polidea.rxandroidble.internal.connection.RxBleGattCallback.getOnCharacteristicChanged(RxBleGattCallback.java:301)\nat com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.observeOnCharacteristicChangeCallbacks(NotificationAndIndicationManager.java:181)\nat com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.access$400(NotificationAndIndicationManager.java:30)\nat com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:107)\nat com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:104)\nat rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\nat rx.observers.Subscribers$5.onNext(Subscribers.java:235)\nat rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\nat rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\nat rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\nat rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\nat rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\nat rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\nat rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerScalarProducer.request(OnSubscribeConcatMap.java:366)\nat rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\nat rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:278)\nat rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)\nat rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.slowPath(OnSubscribeFromArray.java:100)\nat rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.request(OnSubscribeFromArray.java:63)\nat rx.Subscriber.setProducer(Subscriber.java:211)\nat rx.Subscriber.setProducer(Subscriber.java:205)\nat rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:32)\nat rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:24)\nat rx.Observable.unsafeSubscribe(Observable.java:10256)\nat rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94)\nat rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)\nat rx.Observable.unsafeSubscribe(Observable.java:10256)\nat rx.\n```. @dariuszseweryn I am not sure I can post SO link here. \nBut meybe it will also help You. \nhttps://stackoverflow.com/questions/45409986/missingbackpressureexception-even-onbackpressuredrop-is-added. @dariuszseweryn Hi.\nWhen I will kill app and run it again its working so I thought it is something with library. \nSo if it is no library problem do You have idea how to check where is problem / what failing after bt off/on. . ",
    "mahmoud-masmoudi-dev": "@dariuszseweryn Speaking of Generic Attribute Service, strangely, when I try to discover services, this one is not found on Nexus 5. But it is found on an Android 8. How could it be possible to find some services but not the Generic Attribute Service ?. ",
    "prefanatic": "@dariuszseweryn \nUnfortunately, adding synchronized to onCompleted() and onError() does not prevent the queue hanging.. @dariuszseweryn \nLooks good - working great now.  Thanks for the fast turn around!. ",
    "Emeritus-DarranKelinske": "yes sir. Will do. Does logging work for you on the latest builds?. ",
    "hoanglm4": "I using 4 RxBleClient for connect 4 device in the same time. Currently, I do see anything problem.. Dear @dariuszseweryn ,\nWhen is 1.4.0 released ?\nThanks\n. Dear @dariuszseweryn ,\n\nAre you sure that all subscriptions to RxBleDevice.establishConnection() are unsubscribed?\n\nYes. I'm sure. Because I call triggerDisconnect() before subscribe RxBleDevice.establishConnection()\nThank you so much. This issue is not occur in your fixed. Dear @dariuszseweryn,\nI have checked this issue in 1.4.0-SNAPSHOT, this bug is occur too. However, Bluetooth is crashed on Samsung Note II (rooted). I can not make bluetooth on Samsung J7(or HTC U11 because they are not rooted) is crashed.\nThanks. Dear @dariuszseweryn , thank you so much. I will check your fixed in tomorrow (currently, my country in midnight, so I don't have device for check it). Dear @dariuszseweryn,\n I can not connect to ble device. \"java.lang.NullPointerException: Cannot return null from a non-@Nullable @Provides method\" is thown when connect() method called\nVersion: 1.3.4-SNAPSHOT\nNote: I using 1.3.3, this issue is not occur\nThanks\n. Dear @dariuszseweryn,\nI have tested this issue. \"DISCONNECTED\" state is shown when bluetooth is crashed. I think your fixed is OK.\nThanks. Dear @dariuszseweryn,\nGreat! When you release 1.4.0?\nThanks. Great! Thank you so much :). I think BleDisconnectedException with a status value is great. . Thanks @dariuszseweryn \nI will follow it in fabric crashlytics.. Thank you so much!. ",
    "TeemuStenhammar": "@dariuszseweryn We are experiencing this same issue with RxAndroidBle. No matter what we do, we cannot have backpressure handled in such a way that it doesn't break after couple minutes. So, I do agree that handling of backpressure should not be done by the library, but to me it looks like the library is doing some internal subscription that I have no access to. This issue is beginning to be a blocker for us.\nWe have tried two approaches to circumvent the backpressure:\nSubscription notifySubscription = connection.setupNotification(notifyCharacteristic)\n        .flatMap(new Func1<Observable<byte[]>, Observable<byte[]>>() {\n            @Override\n            public Observable<byte[]> call(final Observable<byte[]> observable) {\n                return observable.onBackpressureDrop();\n            }\n        })\n        .subscribe(new Action1<byte[]>() {\n            @Override\n            public void call(byte[] bytes) {\n                dataAvailable(bytes);\n            }\n        }, new ThrowableLoggingAction(TAG, \"Error while receiving data\"));\nAnd:\n```\nSubscription notifySubscription = connection.setupNotification(notifyCharacteristic)\n    .flatMap(new Func1, Observable>() {\n        @Override\n        public Observable call(final Observable observable) {\n            return Observable.create(new Action1>() {\n                @Override\n                public void call(final Emitter emitter) {\n                    Subscription s = observable\n                            .subscribe(new Action1() {\n                                @Override\n                                public void call(byte[] bytes) {\n                                    emitter.onNext(bytes);\n                                }\n                            }, new Action1() {\n                                @Override\n                                public void call(Throwable throwable) {\n                                    Log.e(TAG, \"Emitter failure: \", throwable);\n                                }\n                            });\n                emitter.setSubscription(s);\n            }\n        }, Emitter.BackpressureMode.LATEST);\n    }\n})\n.subscribe(new Action1<byte[]>() {\n    @Override\n    public void call(byte[] bytes) {\n        dataAvailable(bytes);\n    }\n}, new ThrowableLoggingAction(TAG, \"Error while receiving data\"));\n\n```\nNeither approach works so any help with circumventing this issue would be welcome.. @dariuszseweryn We'll get those logs to as fast as possible, but that will most likely take until tomorrow.. @dariuszseweryn Here is the stacktrace. It came from MissingBackpressureException generated in the first case I described:\n```\nrx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:325)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:379)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:361)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.onNext(RelaySubscriptionManager.java:205)\n    at com.jakewharton.rxrelay.PublishRelay.call(PublishRelay.java:47)\n    at com.jakewharton.rxrelay.SerializedAction1.call(SerializedAction1.java:84)\n    at com.jakewharton.rxrelay.SerializedRelay.call(SerializedRelay.java:20)\n    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$4.onCharacteristicChanged(RxBleGattCallback.java:139)\n    at android.bluetooth.BluetoothGatt$1.onNotify(BluetoothGatt.java:438)\n    at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:399)\n    at android.os.Binder.execTransact(Binder.java:453)\nCaused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:\n    at rx.Observable.unsafeCreate(Observable.java:162)\n    at rx.Observable.lift(Observable.java:299)\n    at rx.Observable.merge(Observable.java:2572)\n    at rx.Observable.merge(Observable.java:2914)\n    at rx.Observable.merge(Observable.java:2637)\n    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.getOnCharacteristicChanged(RxBleGattCallback.java:311)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.observeOnCharacteristicChangeCallbacks(NotificationAndIndicationManager.java:18\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.access$400(NotificationAndIndicationManager.java:31)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:110)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:107)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n    at rx.observers.Subscribers$5.onNext(Subscribers.java:235)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerScalarProducer.request(OnSubscribeConcatMap.java:366)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:278)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.slowPath(OnSubscribeFromArray.java:100)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.request(OnSubscribeFromArray.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:211)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:32)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:24)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeSwitchIfEmpty$ParentSubscriber.onNext(OnSubscribeSwitchIfEmpty.java:121)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onNext(OperatorOnErrorResumeNextViaFunction.java:154)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n    at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext(OperatorSubscribeOn.java:74)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at com.polidea.rxandroidble.internal.util.RadioReleasingEmitterWrapper.onNext(RadioReleasingEmitterWrapper.java:45)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onNext(OperatorTimeoutBase.java:131)\n    at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.setProducer(OperatorTimeoutBase.java:115)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:110)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\nOriginal exception:\nCaused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:\n    at rx.Observable.unsafeCreate(Observable.java:162)\n    at rx.Observable.lift(Observable.java:299)\n    at rx.Observable.observeOn(Observable.java:7841)\n    at rx.Observable.observeOn(Observable.java:7767)\n    at rx.Observable.observeOn(Observable.java:7733)\n    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.getOnCharacteristicChanged(RxBleGattCallback.java:315)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.observeOnCharacteristicChangeCallbacks(NotificationAndIndicationManager.java:18\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.access$400(NotificationAndIndicationManager.java:31)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:110)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:107)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n    at rx.observers.Subscribers$5.onNext(Subscribers.java:235)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerScalarProducer.request(OnSubscribeConcatMap.java:366)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:278)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.slowPath(OnSubscribeFromArray.java:100)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.request(OnSubscribeFromArray.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:211)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:32)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:24)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeSwitchIfEmpty$ParentSubscriber.onNext(OnSubscribeSwitchIfEmpty.java:121)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onNext(OperatorOnErrorResumeNextViaFunction.java:154)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n    at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext(OperatorSubscribeOn.java:74)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at com.polidea.rxandroidble.internal.util.RadioReleasingEmitterWrapper.onNext(RadioReleasingEmitterWrapper.java:45)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onNext(OperatorTimeoutBase.java:131)\n    at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.setProducer(OperatorTimeoutBase.java:115)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:110)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\nOriginal exception:\nCaused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:\n    at rx.Observable.unsafeCreate(Observable.java:162)\n    at rx.Observable.filter(Observable.java:6542)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.observeOnCharacteristicChangeCallbacks(NotificationAndIndicationManager.java:18\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.access$400(NotificationAndIndicationManager.java:31)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:110)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:107)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n    at rx.observers.Subscribers$5.onNext(Subscribers.java:235)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerScalarProducer.request(OnSubscribeConcatMap.java:366)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:278)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.slowPath(OnSubscribeFromArray.java:100)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.request(OnSubscribeFromArray.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:211)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:32)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:24)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeSwitchIfEmpty$ParentSubscriber.onNext(OnSubscribeSwitchIfEmpty.java:121)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onNext(OperatorOnErrorResumeNextViaFunction.java:154)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n    at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext(OperatorSubscribeOn.java:74)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at com.polidea.rxandroidble.internal.util.RadioReleasingEmitterWrapper.onNext(RadioReleasingEmitterWrapper.java:45)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onNext(OperatorTimeoutBase.java:131)\n    at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.setProducer(OperatorTimeoutBase.java:115)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:110)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\nOriginal exception:\nCaused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:\n    at rx.Observable.unsafeCreate(Observable.java:162)\n    at rx.Observable.map(Observable.java:7650)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.observeOnCharacteristicChangeCallbacks(NotificationAndIndicationManager.java:19\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager.access$400(NotificationAndIndicationManager.java:31)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:110)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:107)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n    at rx.observers.Subscribers$5.onNext(Subscribers.java:235)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerScalarProducer.request(OnSubscribeConcatMap.java:366)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:278)\n    at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.slowPath(OnSubscribeFromArray.java:100)\n    at rx.internal.operators.OnSubscribeFromArray$FromArrayProducer.request(OnSubscribeFromArray.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:211)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:32)\n    at rx.internal.operators.OnSubscribeFromArray.call(OnSubscribeFromArray.java:24)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)\n    at rx.Observable.unsafeSubscribe(Observable.java:10256)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeSwitchIfEmpty$ParentSubscriber.onNext(OnSubscribeSwitchIfEmpty.java:121)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onNext(OperatorOnErrorResumeNextViaFunction.java:154)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n    at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext(OperatorSubscribeOn.java:74)\n    at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n    at com.polidea.rxandroidble.internal.util.RadioReleasingEmitterWrapper.onNext(RadioReleasingEmitterWrapper.java:45)\n    at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onNext(OperatorTimeoutBase.java:131)\n    at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.setProducer(OperatorTimeoutBase.java:115)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:110)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n    at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\nOriginal exception:\nCaused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:\n    at rx.Observable.unsafeCreate(Observable.java:162)\n    at rx.Observable.lift(Observable.java:299)\n    at rx.Observable.takeUntil(Observable.java:10918)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:110)\n    at com.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$1$1.call(NotificationAndIndicationManager.java:107)\n    at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n    at rx.observers.Subscribers$5.onNext(Subscribers.java:235)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n    at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n    at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)\n======================================================================\n\n\nrx.exceptions.MissingBackpressureException\n\nat rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:325)\n at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:379)\n at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:361)\n at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.onNext(RelaySubscriptionManager.java:205)\n at com.jakewharton.rxrelay.PublishRelay.call(PublishRelay.java:47)\n at com.jakewharton.rxrelay.SerializedAction1.call(SerializedAction1.java:84)\n at com.jakewharton.rxrelay.SerializedRelay.call(SerializedRelay.java:20)\n at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$4.onCharacteristicChanged(RxBleGattCallback.java:139)\n at android.bluetooth.BluetoothGatt$1.onNotify(BluetoothGatt.java:438)\n at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:399)\n at android.os.Binder.execTransact(Binder.java:453)\n```. ",
    "osmer": "Can someone merge this pull request?. Cool!!!\nThanks for your help.\nOsvaldo.\nOn Tue, Aug 15, 2017 at 4:06 PM, Pawe\u0142 Urban notifications@github.com\nwrote:\n\nIt still requires some slight changes but you can expect it will arrive\nsoon.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/Polidea/RxAndroidBle/pull/260#issuecomment-322589251,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAXiMtJ7c-5TyiL90dt2wWTGq4VHCJUmks5sYghrgaJpZM4Osmk0\n.\n\n\n-- \nOsvaldo Mercado Espinel\nMobile Developer Senior | Koombea\nT: + (57) 313 518 2756 - 300 393 7851\nskype: osmer_jr | twitter: @osvaldomercado\nW: www.koombea.com\nhttp://www.koombea.com/\n. were the code changes requested approved?. ",
    "mapyo": "@jdrider @dariuszseweryn \nI solved this issue.\nhttps://stackoverflow.com/questions/44894337/mocking-ble-characteristic-write-with-mockrxandroidble\n\njava.lang.RuntimeException: Method setValue in android.bluetooth.BluetoothGattCharacteristic not mocked.\n\nThis error seems that the mock of Android API is not working well.\nI made a pull request to reproduce this problem.\nhttps://github.com/mapyo/RxAndroidBle/pull/1\nAnd I fixed it.\nhttps://github.com/mapyo/RxAndroidBle/pull/2\nI setted up Robolectric.\nPlease confirm.\n. @dariuszseweryn \nThank you for your review. I merged!. Thanks for the review @dariuszseweryn @friederbluemle @passsy @piotrek1543 @uKL.\n\nI agree with @uKL that tests should be working before merging this PR. Apparently the groovy/groovy-android-gradle-plugin#156 is blocking us\nWe should either wait for a plugin in version 1.3.0 or to workaround the issue somehow?\n\nI committed a workaround to pass the test. Please confirm.. Thank you \ud83d\udc4d . I missed the latest version. to correct.. Oh, I haven't notice this too. Thank you.\nhttps://developer.android.com/studio/releases/build-tools.html\n\nIf you're using Android plugin for Gradle 3.0.0 or higher, your project automatically uses a default version of the build tools that the plugin specifies.\n\nI remove this.. I tried it locally. However, the test did not pass. I think that the change has not been uploaded in the snapshot yet.\nhttp://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-android-gradle-plugin/\n\n1.3.0-SNAPSHOT/      07-Jun-2017 17:25. When deleting buildToolsVersion, 26.0.2 was used.\nI think that it is better to use the latest version if possible. So I specify 27.0.0.. \n",
    "jdrider": "Thank you for investigating this issue @mapyo.  Ideally, I would like a solution that doesn't involve adding a dependency on Robolectric.. Thank you for the explanation @dariuszseweryn.  It would be nice to have the mock library support unit tests.  I will rethink how to perform my tests or use Robolectric as a workaround and consider this issue resolved.\nSide Note - The README for this project is misleading as it indicates that the MockRxAndroidBle module can be used for unit testing.  It would be good to add a note that Robolectric is required at this time.. ",
    "toaderandrei": "Hi, kind of, it would still be ok to have a method to disconnect, that returns an Observable or Flowable because my use case is to do a bit more as I have a custom bluetooth board. Your register to observableStateChanges.. Hi, thanks for the update, I already discovered this method and so far it fits my needs so to say. That is why I closed the issue.. @dariuszseweryn , side question, when will you update to rxjava 2?, or is there any plan to update to rxjava 2?. @craigzour , I did and it seems I had a code inside a flatMap that was missing the error block. This code was after establishConnection. In my case the crash was happening because of a device disconnect from bluetooth(turned off bluetooth on the device). I could catch the disconnect callback but, because of the missing error block, I had a crash. You can see in the logs the onErrorNotImplementedException.. @uKL , the bug that @GuillaumeBo  reported(below) we also have it from time to time(starting from version 1.4.1) and my goal for next sprint is to investigate this(starting today). \n\n03-21 15:26:46.430 29682-29750/fr.test.myapp D/BluetoothGatt: cancelOpen() - device: 00:00:00:00:00:00\n03-21 15:26:46.431 29682-29742/fr.test.myapp D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=00:00:00:00:00:00\n03-21 15:26:46.436 29682-29753/fr.test.myapp W/System.err: io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 00:00:00:00:00:00\n03-21 15:26:46.436 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n03-21 15:26:46.436 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onError(ObservableCreate.java:74)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at com.polidea.rxandroidble2.internal.util.QueueReleasingEmitterWrapper.onError(QueueReleasingEmitterWrapper.java:45)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onError(SingleToObservable.java:65)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.single.SingleTimeout$TimeoutMainObserver.onError(SingleTimeout.java:142)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onError(SingleMap.java:69)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onError(ObservableElementAtSingle.java:104)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.checkTerminated(ObservableObserveOn.java:276)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.drainNormal(ObservableObserveOn.java:172)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.run(ObservableObserveOn.java:252)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)\n03-21 15:26:46.437 29682-29753/fr.test.myapp W/System.err:     at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at java.lang.Thread.run(Thread.java:761)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err: Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 00:00:00:00:00:00\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:180)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n03-21 15:26:46.438 29682-29753/fr.test.myapp W/System.err:     at android.os.Binder.execTransact(Binder.java:565)\n. @uKL , is this the same issue I had?(ref: Huawei P9).. Well, technically yes, however there was a sequence of commands, one was connect, then discover services. Our cases was that connect was somewhat successful(in the sense no exception was received immediately) then we were doing the discover services call and after 20 seconds the connection was dropped. . Well, we were getting an exception after 20 seconds.. \n",
    "craigzour": "@toaderandrei Did you find a solution ? I encountered the same issue yesterday. It is related to the fact that I do a retry() on the establishConnection().. I am having the same issue with version 1.5.0 (every single time I turn off the BLE feature on my device my app crashes). It looks like 1.6.0-SNAPSHOT fixed it in my case too !. Hello,\nHere is a way to implement pairing/bonding with RxAndroidBle. It might be useful for people having to deal with that process.\nhttps://gist.github.com/craigzour/edf7f3bd8bef4b162887b4244e27dc1f. @skykelsey Well at least with all the devices I have tested my code on it worked pretty well. The only thing that is kind of random and depends on devices is the way Android prompts the Pairing alert. Sometimes it goes silently in the notification center and thus you can miss it.. ",
    "evansherry": "\u4e2d\u6587\uff1a\u6211\u4f7f\u7528\u7684\u662fRxAndroidBle\uff0c\u6ca1\u6709\u4f7f\u7528android api\uff0c\u6211\u65ad\u5f00\u8fde\u63a5\u662f\u8c03\u7528connectSubscription.unsubscribe()\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u5185\u90e8\u80af\u5b9a\u662fgatt.close\u4e86\u5427\uff1f\nenglish:\nI am using RxAndroidBle, do not use the android api, i disconnect is called connectSubscription.unsubscribe ();  is this method internally calling gatt.close?\n. This is the print log    // behind my comments\uff1a\n```\n08-22 14:12:00.777 31399-31399/com.evan.yeeuusample D/BluetoothAdapter: STATE_ON\n08-22 14:12:00.781 31399-31399/com.evan.yeeuusample D/BluetoothGatt: connect() - device: F0:65:A0:1A:20:16, auto: false                //mConnectingDevice.establishConnection(false)\n08-22 14:12:00.781 31399-31399/com.evan.yeeuusample D/BluetoothGatt: registerApp()\n08-22 14:12:00.782 31399-31399/com.evan.yeeuusample D/BluetoothGatt: registerApp() - UUID=58cec16e-bb91-4603-bd28-11da0e5e17c0\n08-22 14:12:00.785 31399-31410/com.evan.yeeuusample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n08-22 14:12:02.965 31399-31410/com.evan.yeeuusample D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=5 device=F0:65:A0:1A:20:16        // connectstatus 133\n08-22 14:12:02.969 31399-31399/com.evan.yeeuusample D/BluetoothManager: getConnectionState()\n08-22 14:12:02.970 31399-31399/com.evan.yeeuusample D/BluetoothManager: getConnectedDevices\n08-22 14:12:02.997 31399-31399/com.evan.yeeuusample D/BluetoothGatt: close()      // connect fail \n call connectSubscription.unsubscribe()\n08-22 14:12:02.997 31399-31399/com.evan.yeeuusample D/BluetoothGatt: unregisterApp() - mClientIf=5\n```\nContinue to try to connect:\n```\n08-22 14:17:35.278 31399-31399/com.evan.yeeuusample D/BluetoothGatt: connect() - device: F0:65:A0:1A:20:16, auto: false\n08-22 14:17:35.278 31399-31399/com.evan.yeeuusample D/BluetoothGatt: registerApp()\n08-22 14:17:35.278 31399-31399/com.evan.yeeuusample D/BluetoothGatt: registerApp() - UUID=b8fa445c-aab2-46d1-b2c2-e67bb475caf9\n08-22 14:17:35.280 31399-31411/com.evan.yeeuusample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n08-22 14:17:43.666 31399-31441/com.evan.yeeuusample D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=5 device=F0:65:A0:1A:20:16\n```\nFailed to connect again\uff01\nIs there any solution? i do not know why the connection status is 133, gatt has been closed! Now this state happens frequently, help me thank you .. ",
    "thuytrinh": "@dariuszseweryn We encountered a weird issue when the app and the BLE device were exchanged data back and forth and suddenly the connection was disconnected by \"BleDisconnectedException: Disconnected from 7C:**:**:**:**:** with status 8 (GATT_INSUF_AUTHORIZATION)\". This often happens if the app runs on the Moto G (4) phone.\nDoes GATT_INSUF_AUTHORIZATION mean that, bonding has just got lost in that case based on your understanding? Also, I saw this answer https://stackoverflow.com/a/48956494/2563009 (on the question that you guys mentioned on https://github.com/Polidea/react-native-ble-plx/wiki/Device-Bonding) claimed that if using TRANSPORT_BREDR for the transport option, it will somehow fix the random lost of bonding. What do you think about it? Did you guys ever try that transport option?. > I have seen disconnections (even Today in fact) with status 8 which were not connected with bonding as the peripheral did not support bonding at all (from my knowledge). \nThe peripheral which I tested does actually support bonding. We didn't encounter this GATT_INSUF_AUTHORIZATION on other phones such as some Samsung phones & Google Pixel 2 XL. So that makes me thinking that this is a problem of the bluetooth stack included in the Android OS of the Moto G phone.. Hi @uKL, I saw you added this issue into the 2.0.0 milestone. Is there anything you guys can do from the library side?. > some handy Kotlin extensions\n@uKL Do you mean Kotlin extension properties/functions? Or just convert some existing Java code into Kotlin?. Do you have any similar examples for that? I was thinking of a sort of like https://github.com/android/android-ktx/ and was wondering a port to https://kotlinlang.org/docs/reference/coroutines.html also belongs to scope of this issue.. I confirmed that this still happened w/ 1.6.0-SNAPSHOT. In my cases, it happened when I disposed explicitly via subscriptions.dispose() or via switchMap().\n05-16 15:04:42.322 32627-1379/bike.cobi.app.debug E/AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-6\n    Process: bike.cobi.app.debug, PID: 32627\n    io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 7C:57:4E:00:12:85\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:314)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:276)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$DisposeTask.run(ObservableRefCount.java:219)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:30)\n        at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:20)\n        at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:43)\n        at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:151)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:514)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.observers.BasicFuseableObserver.dispose(BasicFuseableObserver.java:152)\n        at io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver.dispose(ObservableDoOnEach.java:80)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:594)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:520)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:311)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:217)\n        at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.completable.CompletableCreate$Emitter.dispose(CompletableCreate.java:114)\n        at io.reactivex.internal.operators.completable.CompletablePeek$CompletableObserverImplementation.dispose(CompletablePeek.java:138)\n        at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n        at io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable$SwitchMapCompletableObserver$SwitchMapInnerObserver.dispose(ObservableSwitchMapCompletable.java:233)\n05-16 15:04:42.329 32627-1379/bike.cobi.app.debug E/AndroidRuntime:     at io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable$SwitchMapCompletableObserver.onNext(ObservableSwitchMapCompletable.java:116)\n        at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.drainNormal(ObservableObserveOn.java:200)\n        at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.run(ObservableObserveOn.java:252)\n        at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)\n        at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\n        at java.lang.Thread.run(Thread.java:764)\n     Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 7C:57:4E:00:12:85\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter$3.apply(DisconnectionRouter.java:58)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter$3.apply(DisconnectionRouter.java:55)\n        at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59)\n        at io.reactivex.internal.operators.observable.ObservableFilter$FilterObserver.onNext(ObservableFilter.java:52)\n        at io.reactivex.internal.operators.observable.ObservableConcatMap$ConcatMapDelayErrorObserver$DelayErrorInnerObserver.onNext(ObservableConcatMap.java:500)\n        at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:64)\n        at com.polidea.rxandroidble2.RxBleAdapterStateObservable$1.onReceive(RxBleAdapterStateObservable.java:62)\n        at android.app.LoadedApk$ReceiverDispatcher$Args.lambda$getRunnable$0(LoadedApk.java:1331)\n        at android.app.-$$Lambda$LoadedApk$ReceiverDispatcher$Args$_BumDX2UKsnxLVrE6UJsJZkotuA.run(Unknown Source:2)\n        at android.os.Handler.handleCallback(Handler.java:873)\n        at android.os.Handler.dispatchMessage(Handler.java:99)\n        at android.os.Looper.loop(Looper.java:164)\n        at android.app.ActivityThread.main(ActivityThread.java:6649)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:826)\nI temporarily set up an RxJava hook like below to workaround it:\n```kotlin\nclass SetUpRxJavaErrorHandler() {\n    operator fun invoke() = RxJavaPlugins.setErrorHandler({ error ->\n        when {\n            error is UndeliverableException && error.cause is BleDisconnectedException ->\n                workaroundRxAndroidBleIssue(error)\n            else -> throw error\n        }\n    })\nprivate fun workaroundRxAndroidBleIssue(error: Throwable) {\n    Log.e(TAG, \"Encountered https://github.com/Polidea/RxAndroidBle/issues/383\", error)\n}\n\n}\n``. That link seems to be relevant to RxJava 1.x only. The Java doc for RxJavaPlugins of RxJava 2.x has no depreciation on the class http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/plugins/RxJavaPlugins.html.. I also encountered this crash today w/ RxAndroidBle1.50and RxJava2.1.13`:\n05-17 07:59:52.448 32740-493/bike.cobi.app.debug E/AndroidRuntime: FATAL EXCEPTION: RxComputationThreadPool-1\n    Process: bike.cobi.app.debug, PID: 32740\n    java.lang.NullPointerException: Attempt to invoke interface method 'boolean io.reactivex.internal.fuseable.SimpleQueue.offer(java.lang.Object)' on a null object reference\n        at io.reactivex.internal.operators.observable.ObservableSwitchMap$SwitchMapInnerObserver.onNext(ObservableSwitchMap.java:372)\n        at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:64)\n        at com.polidea.rxandroidble2.internal.util.LocationServicesOkObservableApi23.subscribeActual(LocationServicesOkObservableApi23.java:35)\n        at io.reactivex.Observable.subscribe(Observable.java:12025)\n        at io.reactivex.internal.operators.observable.ObservableMap.subscribeActual(ObservableMap.java:33)\n        at io.reactivex.Observable.subscribe(Observable.java:12025)\n        at io.reactivex.internal.operators.observable.ObservableSwitchMap$SwitchMapObserver.onNext(ObservableSwitchMap.java:127)\n        at io.reactivex.internal.operators.observable.ObservableConcatMap$ConcatMapDelayErrorObserver.drain(ObservableConcatMap.java:464)\n        at io.reactivex.internal.operators.observable.ObservableConcatMap$ConcatMapDelayErrorObserver.onSubscribe(ObservableConcatMap.java:324)\n        at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:30)\n        at io.reactivex.Observable.subscribe(Observable.java:12025)\n        at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(ObservableConcatMap.java:54)\n        at io.reactivex.Observable.subscribe(Observable.java:12025)\n        at io.reactivex.internal.operators.observable.ObservableSwitchMap.subscribeActual(ObservableSwitchMap.java:51)\n        at io.reactivex.Observable.subscribe(Observable.java:12025)\n        at io.reactivex.internal.operators.observable.ObservableSkip.subscribeActual(ObservableSkip.java:29)\n        at io.reactivex.Observable.subscribe(Observable.java:12025)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:165)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n        at io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:82)\n        at io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)\n        at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)\n        at io.reactivex.internal.operators.observable.ObservableCountSingle$CountObserver.onComplete(ObservableCountSingle.java:83)\n        at io.reactivex.internal.operators.observable.ObservableTakeWhile$TakeWhileObserver.onNext(ObservableTakeWhile.java:86)\n        at io.reactivex.internal.operators.observable.ObservableInterval$IntervalObserver.run(ObservableInterval.java:83)\n        at io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:38)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\n        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:270)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n        at java.lang.Thread.run(Thread.java:818)\nHere comes a sample which I was able to reproduce the issue:\n```kotlin\nfun scan(): Observable = rxBleClient.scanBleDevices(\n        ScanSettings.Builder()\n                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n                .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)\n                .build()\n)\nfun scanWithOptionalTimeout(shouldTimeout: Boolean): Observable = when {\n    shouldTimeout -> scan().timeout(ScanTimeoutInSecs, TimeUnit.SECONDS, schedulerFactory.io)\n    else -> scan()\n}\nval scanSubscription = rxBleClient.observeStateChanges()\n        .observeOn(schedulerFactory.io)\n        .filter { it == RxBleClient.State.READY }\n        .switchMap {\n            scanWithOptionalTimeout(shouldTimeout = autoStop)\n                    .map { DeviceDiscovered(it) }\n                    .onErrorResumeNext { error: Throwable ->\n                        when (error) {\n                            is TimeoutException -> Observable.just(Timeout)\n                            else -> Observable.error(error)\n                        }\n                    }\n        }\n        .startWith(AwaitingToBeReady)\n        .doOnNext { Log.d(TAG, \"scanState -> $it\") }\n        .subscribeBy(onNext = {\n            when (it) {\n                is DeviceDiscovered -> printScanResult(it.scanResult)\n            }\n        })\n// ...\n// Then later we decide to dispose scanSubscription,\n// The crash will happen.\nscanSubscription.dispose()\n```. Hey @uKL, we encountered again this crash w/ v1.6.0:\n```\nAndroid: 8.1.0\nManufacturer: Google\nModel: Pixel\nDate: Tue Jun 05 15:38:18 GMT+02:00 2018\njava.lang.NullPointerException: Attempt to invoke interface method 'boolean io.reactivex.internal.fuseable.SimpleQueue.offer(java.lang.Object)' on a null object reference\n    at io.reactivex.internal.operators.observable.ObservableSwitchMap$SwitchMapInnerObserver.onNext(ObservableSwitchMap.java:372)\n    at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:64)\n    at com.polidea.rxandroidble2.internal.util.LocationServicesOkObservableApi23.subscribeActual(LocationServicesOkObservableApi23.java:54)\n    at io.reactivex.Observable.subscribe(Observable.java:12051)\n    at io.reactivex.internal.operators.observable.ObservableMap.subscribeActual(ObservableMap.java:33)\n    at io.reactivex.Observable.subscribe(Observable.java:12051)\n    at io.reactivex.internal.operators.observable.ObservableSwitchMap$SwitchMapObserver.onNext(ObservableSwitchMap.java:127)\n    at io.reactivex.internal.operators.observable.ObservableConcatMap$ConcatMapDelayErrorObserver.drain(ObservableConcatMap.java:464)\n    at io.reactivex.internal.operators.observable.ObservableConcatMap$ConcatMapDelayErrorObserver.onSubscribe(ObservableConcatMap.java:324)\n    at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:30)\n    at io.reactivex.Observable.subscribe(Observable.java:12051)\n    at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(ObservableConcatMap.java:54)\n    at io.reactivex.Observable.subscribe(Observable.java:12051)\n    at io.reactivex.internal.operators.observable.ObservableSwitchMap.subscribeActual(ObservableSwitchMap.java:51)\n    at io.reactivex.Observable.subscribe(Observable.java:12051)\n    at io.reactivex.internal.operators.observable.ObservableSkip.subscribeActual(ObservableSkip.java:29)\n    at io.reactivex.Observable.subscribe(Observable.java:12051)\n    at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:165)\n    at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n    at io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:82)\n    at io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)\n    at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)\n    at io.reactivex.internal.operators.observable.ObservableCountSingle$CountObserver.onComplete(ObservableCountSingle.java:83)\n    at io.reactivex.internal.operators.observable.ObservableTakeWhile$TakeWhileObserver.onNext(ObservableTakeWhile.java:86)\n    at io.reactivex.internal.operators.observable.ObservableInterval$IntervalObserver.run(ObservableInterval.java:83)\n    at io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:38)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:457)\n    at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:307)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:302)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n    at java.lang.Thread.run(Thread.java:764)\n```\nApparently you tried to fix that by moving context.registerReceiver() to the bottom in https://github.com/Polidea/RxAndroidBle/commit/1502ed62b4587627bfff402574e5b1739482bc5a. But https://github.com/Polidea/RxAndroidBle/commit/d3197ebf15044d8369763c385bea982253fcb0ff moved it back, thus causing regression right?. @uKL If that's right, I'm wondering we can compromise like you guys did in RxBleAdapterStateObservable:\njava\n         observer.onSubscribe(Disposables.fromAction(new Action() {\n             @Override\n             public void run() throws Exception {\n                 try {\n                     context.unregisterReceiver(receiver);\n                 } catch (IllegalArgumentException exception) {\n                     Log.d(TAG, \"The receiver is already not registered.\");\n                 }\n             }\n         }));\n         context.registerReceiver(receiver, createFilter());. @uKL Would you like me to open a new pull request?. @uKL I tried to revert back to your original change like below and also ignored the IllegalStateException:\njava\n        observer.onSubscribe(Disposables.fromAction(new Action() {\n            @Override\n            public void run() throws Exception {\n                try {\n                    context.unregisterReceiver(broadcastReceiver);\n                } catch (IllegalStateException ignored) {\n                }\n            }\n        }));\n        observer.onNext(locationProviderOk);\n        context.registerReceiver(broadcastReceiver, new IntentFilter(LocationManager.MODE_CHANGED_ACTION));\nHowever, the following test failed:\n```groovy\n    def \"should not register receiver again after unregister\"() {\n        given:\n        mockLocationServicesStatus.isLocationProviderOk() >> isLocationProviderOkResult\n    when:\n    objectUnderTest.take(1).test()\n\n    then:\n    1 * contextMock.unregisterReceiver(_)\n\n    then:\n    0 * contextMock.registerReceiver(_, _)\n\n    where:\n    isLocationProviderOkResult << [true, false]\n}\n\n```\nThat means registerReceiver() is still called again and thus we ended up having a receiver never being unregistered. Am I missing something?. @uKL I was tempted to check whether there's any subscriber before invoking context.registerReceiver() in the subscribeActual() body. However, apparently there isn't any way to perform that check. If the Observable.create() is used to create the Observable, I can check via the ObservableEmitter.\nI'm wondering implementing subscribeActual() like in LocationServicesOkObservableApi23 is a proper way to create the Observable in this case, rather than using Observable.create()?\n\nIf you don't write an operator, you don't have to worry about subscribeActual(). \u2013 akarnokd\n\nIn https://stackoverflow.com/q/46250673/2563009. LocationServicesOkObservableApi23 doesn't seem to create a new RxJava operator, so I guess we can replace it with the Observable.create() approach, right? BTW akarnokd is @akarnokd.. @uKL Here is my take on the Observable.create() approach:\n```java\n@TargetApi(Build.VERSION_CODES.KITKAT)\npublic class LocationServicesOkObservableApi23Factory {\n    private final Context context;\n    private final LocationServicesStatus locationServicesStatus;\n@Inject\nLocationServicesOkObservableApi23Factory(\n        final Context context,\n        final LocationServicesStatus locationServicesStatus) {\n    this.context = context;\n    this.locationServicesStatus = locationServicesStatus;\n}\n\npublic Observable<Boolean> get() {\n    return Observable.create(new ObservableOnSubscribe<Boolean>() {\n        @Override\n        public void subscribe(final ObservableEmitter<Boolean> emitter) throws Exception {\n            final boolean initialValue = locationServicesStatus.isLocationProviderOk();\n            final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final boolean newValue = locationServicesStatus.isLocationProviderOk();\n                    emitter.onNext(newValue);\n                }\n            };\n            emitter.setCancellable(new Cancellable() {\n                @Override\n                public void cancel() throws Exception {\n                    try {\n                        context.unregisterReceiver(broadcastReceiver);\n                    } catch (IllegalStateException ignored) {\n                    }\n                }\n            });\n            if (!emitter.isDisposed()) {\n                emitter.onNext(initialValue);\n                context.registerReceiver(broadcastReceiver, new IntentFilter(LocationManager.MODE_CHANGED_ACTION));\n            }\n        }\n    }).distinctUntilChanged();\n}\n\n}\n```\nWdyt?. @dariuszseweryn Sure. I'm trying to get more information on our QA side.. @DariuszAniszewski I think https://github.com/Polidea/RxAndroidBle/commit/d3197ebf15044d8369763c385bea982253fcb0ff has fixed this crash as well. Is there any way to determine which snapshot version is being used? Apparently all snapshot versions of 1.6.0 have the exact same 1.6.0-SNAPSHOT.. Good catch @dariuszseweryn \ud83d\udc4d There may be a case like that. For example, considering the following execution flow:\n\nThe program passes by line 51 at if (!emitter.isDisposed()) {. There's still at least a subscriber of this Observable, so the context.registerReceiver() is about to be executed.\nThen, somehow no subscriber subscribes to the Observable anymore. The code in setCancellable() gets invoked.\nThen context.registerReceiver() gets executed. Thus the leak has just happened.\n\nI'm thinking about doing another check if (!emitter.isDisposed()) right after context.registerReceiver() but it looks kinda weird. I never wrote such conditional flow before. Wdyt?. Or another idea is to move the setCancellable() into the isDispose() check. For example:\njava\nif (!emitter.isDisposed()) {\n    context.registerReceiver(broadcastReceiver, new IntentFilter(LocationManager.MODE_CHANGED_ACTION));\n    emitter.onNext(initialValue);\n    emitter.setCancellable(new Cancellable() {\n        @Override\n        public void cancel() throws Exception {\n            try {\n                context.unregisterReceiver(broadcastReceiver);\n            } catch (IllegalStateException ignored) {\n            }\n        }\n    });\n}\nWdyt?. I've changed the impl into below based on @akarnokd's suggestion link:\njava\n    public Observable<Boolean> get() {\n        return Observable.create(new ObservableOnSubscribe<Boolean>() {\n            @Override\n            public void subscribe(final ObservableEmitter<Boolean> emitter) throws Exception {\n                final boolean initialValue = locationServicesStatus.isLocationProviderOk();\n                final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {\n                    @Override\n                    public void onReceive(Context context, Intent intent) {\n                        final boolean newValue = locationServicesStatus.isLocationProviderOk();\n                        emitter.onNext(newValue);\n                    }\n                };\n                emitter.onNext(initialValue);\n                context.registerReceiver(broadcastReceiver, new IntentFilter(LocationManager.MODE_CHANGED_ACTION));\n                emitter.setCancellable(new Cancellable() {\n                    @Override\n                    public void cancel() throws Exception {\n                        try {\n                            context.unregisterReceiver(broadcastReceiver);\n                        } catch (IllegalStateException ignored) {\n                        }\n                    }\n                });\n            }\n        }).distinctUntilChanged();\n    }\nI think this impl is able to prevent the above leak from happening.. @dariuszseweryn Good call \ud83d\udc4d Done.. Very good find \ud83d\udc4d . ",
    "joaquinlateral": "Hi! I'm wondering if at the moment of the connection you're passing the Transport_le parameter to the connectGatt call. I've navigated to the connection operation in the library and I see that you're just passing three parameters:  f\ninal BluetoothGatt bluetoothGatt = connectionCompat\n                                .connectGatt(bluetoothDevice, autoConnect, rxBleGattCallback.getBluetoothGattCallback());\nHow can we add the fourth parameter there?\nThanks!. ",
    "Lloyd0577": "I meet same problem in xiaomi device,but i use android native connect method ,it can connect,so i wonder if there is any bug in this lib,thanks. hello!,how to receive notify data by RxBleCustomOperation. but why the exception throw out ,and how can I try catch it  ,my code is:\n        rxBleDevice = rxBleClient.getBleDevice(mac)\n    subscription = rxBleDevice!!.establishConnection(false)\n            .subscribe({ rxBleConnection ->\n                this.rxBleConnection = rxBleConnection\n                Logger.d(\"conn succ\")\n\n                shakeHand(userId, mac, success, failure)\n            }, { throwable ->\n                disConnectListeners.forEach {\n                    it.invoke(\"conn error\")\n                }\n                failure.invoke(\"conn error\")\n            })\n\n@dariuszseweryn . hello , thank you for help, but I wonder that is there any reasons that there was no callback to BluetoothGattCallback.onConnectionStateChange() when the disconnection happened?. ",
    "ThunderThrash": "Sorry for my English...\nI would like to know if new BleDisconnectedException can return the status 0x81 (GATT internal error) and 0x85 (GATT error) after closing this issue?. ",
    "XIANDONGZHI": "I solved this serious problem....I rewrote and reflected...\n`\n    public void disConnect() {\n        disconnectTriggerSubject.onNext(null);\n        if (subscribe != null) {\n            subscribe.unsubscribe();\n        }\n    bleDevice = null;\n    connectionObservable = null;\n}\n\npublic Observable<RxBleConnection> establishConnection(final boolean autoConnect) {\n    ConnectionSetup options = new ConnectionSetup.Builder()\n            .setAutoConnect(autoConnect)\n            .setSuppressIllegalOperationCheck(true)\n            .build();\n    return establishConnection(options);\n}\n\n//    @Override\npublic Observable<RxBleConnection> establishConnection(final ConnectionSetup options) {\n    return Observable.defer(new Func0<Observable<RxBleConnection>>() {\n        Connector connector = null;\n        AtomicBoolean isConnected;\n\n        @Override\n        public Observable<RxBleConnection> call() {\n            if (bleDevice==null) {//Here are the main sources of the solution\n                return Observable.error(new Exception(\"is disconnect!\"));\n            }\n            try {\n                Field connectorField = bleDevice.getClass().getDeclaredField(\"connector\");\n                final Field isConnectedField =  bleDevice.getClass().getDeclaredField(\"isConnected\");\n                connectorField.setAccessible(true);\n                isConnectedField.setAccessible(true);\n                connector = (Connector) connectorField.get(bleDevice);\n                isConnected = (AtomicBoolean) isConnectedField.get(bleDevice);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            if (isConnected.compareAndSet(false, true)) {\n                return connector.prepareConnection(options)\n                        .doOnUnsubscribe(new Action0() {\n                            @Override\n                            public void call() {\n                                isConnected.set(false);\n                            }\n                        });\n            } else {\n                return Observable.error(new BleAlreadyConnectedException(bleDevice.getMacAddress()));\n            }\n\n        }\n    });\n}\n\n\n\nprivate Observable<RxBleConnection> prepareConnectionObservable() {\n    Observable<RxBleConnection> rxBleConnectionObservable = establishConnection(false);\n    return rxBleConnectionObservable\n            .takeUntil(disconnectTriggerSubject)\n            .doOnUnsubscribe(new Action0() {\n                @Override\n                public void call() {\n                    connectionObservable = null;\n                }\n            })\n            .compose(new ConnectionSharingAdapter());\n}\n\n`. ",
    "Mike-bel": "Thanks for your reply. @dariuszseweryn \nI have tried for more times on my LG phone, and still failed to connect.\nBut other phones are OK.\nWhat is the btsnoop_hci.log file, Please?. btsnoop_hci.zip\nHello @dariuszseweryn \nI've saved two log files. btsnoop_hci.cfa is the successful connection on another phone, and btsnoop_hci.log is the failed connection on the LG phone.\n. But I can not see any usage problems.. ",
    "petri-lipponen-suunto": "I tried 1.4.3 with this and it still doesn't work.\nMy data send method ends with:\n```\n     {\n .... \n        // Do the writing\n        connection.createNewLongWriteBuilder()\n                .setCharacteristic(device.getWriteCharasteristic())\n                .setBytes(encoded)\n                .setMaxBatchSize(getMaxDataSize(connection))\n                .build()\n                .toSingle()\n                .subscribe(new Action1() {\n                    @Override\n                    public void call(byte[] bytes) {\n                        Log.d(TAG, \"Send complete\");\n                    }\n                }, new ThrowableLoggingAction(TAG, \"Data write failed\"));\n    return true;\n}\n\nprivate int getMaxDataSize(RxBleConnection connection) {\n    int currentMTU = connection.getMtu();\n    Log.d(TAG, \"getMaxDataSize: connection.getMtu: \" + currentMTU);\n    return currentMTU - 3; // 3 bytes of lower level header before GATT data\n}\n\n```\nI can see the _getMaxDataSize: connection.getMtu: _ in the log every time data is sent but the value printed stays at 23. \nI even tried to do requestMtu(GATT_MTU_MAXIMUM) (=517) but still nothing. Is there something I've missed? I'm using minSdkVersion 21 in my project.. @dariuszseweryn Yes, I can see in peripheral devices log that the MTU is degotiated to 158 before the data transfer starts. Here's the relevant portion of it:\n```\n00:12:53 BLE event: 10 - Connection established\n00:12:53 BLE GAP: onConnect to 5D:33:4C:E6:EF:C5 (Random private resolvable)\n:DEBUG:onConnectedImpl(), deviceId: 0\nBLE_GATT:INFO:EXCHANGE_MTU_RSP effective ATT MTU is 158 for conn_handle 0 \n00:12:53 BLE event: 3A - Exchange MTU Response event\nBLE_GATT:INFO:Data Length Extended (DLE) for conn_handle 0 \nBLE_GATT:DEBUG:max_rx_octets 27 \nBLE_GATT:DEBUG:max_rx_time 328 \nBLE_GATT:DEBUG:max_tx_octets 162 \nBLE_GATT:DEBUG:max_tx_time 2120 \n00:12:53 BLE event: 04 - Link layer PDU length changed\n00:12:54 conn_interval_configured\n00:12:54 BLE event: 12 - Connection Parameters updated\n00:12:54 BLE_GAP_EVT_CONN_PARAM_UPDATE. connection interval: 6\n00:12:54 conn_interval_configured\n00:12:54 BLE event: 12 - Connection Parameters updated\n00:12:54 BLE_GAP_EVT_CONN_PARAM_UPDATE. connection interval: 36\n:DEBUG:onDataReceivedImpl(), size: 20\n:DEBUG:onDataReceivedImpl(), size: 20\n:DEBUG:onDataReceivedImpl(), size: 4\n:DEBUG:Hello: ECSD00000000 #4 v(3.10.0-0000) -> 174430000320 #32 (v3.4.1-0000)\n:DEBUG:MTU change detected. new MTU: 158\n:DEBUG:onSendCompletedImpl()\n:DEBUG:onDataReceivedImpl(), size: 20\n:DEBUG:onDataReceivedImpl(), size: 8\n:DEBUG:onSendCompletedImpl()\n:DEBUG:onDataReceivedImpl(), size: 20\n:DEBUG:onDataReceivedImpl(), size: 6\n:DEBUG:onSendCompletedImpl()\n```\nas you can see there is limitation of 20 bytes (multiple :DEBUG:onDataReceivedImpl()'s). The other direction supports 158 byte MTU just fine and they arrive to mobile app correctly.. rxandroidble_mtu.log\n. I'm using Sony Xperia XZ Premium with Android 8.0. I'll try both your suggestions. How does the LongWriteBuilder work in case the MTU is 23 and I set MaxBatchSize(155)? Does it truncate or deal with it internally?. In Android BLE logs I found the following lines:\n12-11 15:18:50.872 3522-4021/? E/bt_att: MTU request PDU with MTU size 158\n12-11 15:18:50.872 3522-4021/? E/bt_btm: BTM_SetBleDataLength failed, peer does not support request\nLooks like there is something fishy there... I'll try with another phone and will update this bugreport later.\nThanks for your help.\n. Unfortunately this is not a phone issue, but something in the RxAndroidBle.\nI created a small sample app using pure android BLE classes and I can get the onMtuChanged callback if and only if I call requestMtu first (android Oreo issue, I created one in Android issue tracker: https://issuetracker.google.com/issues/70542026). However I don't get any when running the similar code via RxAndroidBle.\nI created a small sample app to demonstrate the issue. If I click the \"Test Pure\" the MTU change is detected, with \"Test Rx\" not. It could be something I do with RxAndroidBle (I'm not too fluent with Rx world) but I can't figure out what it would be. \nTested on both Samsung Galaxy A3 (8.0) as well as Sony Xperia XZ Premium (8.0)\nBLEMTUTest.zip\n. Ah, that might explain it, I'll give it a shot. I assumed that the current MTU (from getMtu()) would be updated regardless, since it is a connection parameter...\nTested: That did the trick! adding .subscribe() to it caused it to work. It is a bit counter intuitive that the request is not handled if it is not subscribed, at least for someone without any Rx background.... ",
    "mbmc": "All good, thanks!. ",
    "Josh-Allen-ConnectedLab": "@dariuszseweryn Look at the source to Throwable and you will see that toString() returns message. You can probably get rid of your classname in createMessage() because it's already included by Throwable toString. Did you not notice that whenever you logged your exceptions using Timber or Log that it always said \"BleScanException: null\"? The way you had it coded means we need a special case for all of your exceptions to include toString() as well as stacktrace.. ",
    "connected-jallen": "@dariuszseweryn I made the toString() messages cleaner.. ",
    "piotrek1543": "@passsy what about changing buildToolsVersion to 27.0.0. \nSupport library version is not updated in that pull request, it's 25.3.1.. Hi, \nI'm using now the latest version of Android Studio (3.1.3) with RxAndroidBLE project, since AS 3.1.0 I haven't noticed any problems with this project.\n@RobLewis does problem still occur?\n. @RobLewis  this repo has already Gitter channel: https://gitter.im/RxBLELibraries/. Maybe If the emitter is cancelled, a responsibility of the operation is to call or If the emitter is cancelled the operation is obligated to call?. I don't see where isConnected is set to true - it seems to be always false. I think that should be there BluetoothAdapter instead of Bluetooth Adapter.. Maybe ... BluetoothAdapter is not available on a device. There is no reason to monitor other states as the adapter does not appear during runtime. . Maybe Subscribe starts scan when unsubsribe stops it. Maybe Bluetooth adapter's state or BluetoothAdapter's state. missing semicolon after subscribed?. unnecessary formatting :-). I think that uuid should be used here with uppercase (I mean: UUID instead of uuid), as it is more frequent used version, you used it already in another class  and it relates to used there class name.. Really good piece of code. I like it :-). @friederbluemle well, I haven't noticed this... I definitely need to give a try this solution :-). @friederbluemle if @dariuszseweryn is right, maybe temporary changing to classpath 'org.codehaus.groovy:groovy-android-gradle-plugin:1.3.0-SNAPSHOT' would fix groovy compilation errors \n. what about setConnectionTimeout (as you have before setOperationTimeout())?. @dariuszseweryn you're right. setConnectingTimeout would be better as it is more accurate.. ",
    "friederbluemle": "Nice \ud83d\udc4d. You can remove this line, and all three occurrences of buildToolsVersion from the module's build.gradle files. Android Gradle plugin 3.0.0 will automatically pick the right build tools version.. Looks good now, can you squash the commits please @mapyo?. Good idea, you could definitely give it a try! Ultimately it's up to you and the maintainers of RxAndroidBle if a snapshot dependency on the master branch is acceptable.\nIf the update does fix the issue and this is the only problem, maybe we could nudge groovy-android-gradle-plugin to release an official new version soon.. Interesting. I'm all for using the latest version if possible, but to be honest I think since Google implemented (and recommends to use) this auto-chooser, they know best which version to use for a particular Android Gradle plugin and compile/target SDK version combination.. ",
    "simonratner": "When characteristic supports both, pros for defaulting to notifications:\n [This is a big one] That's what iOS does, in fact, with Core Bluetooth there is no way to subscribe to indications if a characteristic supports both. As someone who makes the hw side of this equation, consistency is always welcome.\n Notifications are more common, more people know and understand them.\n* Notifications are more lightweight on the traffic, as they don't generate an ack.\nCons:\n* Defaulting to a less reliable communication method when a device is clearly advertising that it supports a more reliable mode.. Whether you want to setup indications or notifications is specified in the setupMode in the new connection API. If you prefer indications, and your device supports them, just don't use the auto setting?. ",
    "mechatronik": "Probably later today. ",
    "geekShaw86": "Hi uKL,\nI did some research in the last few days, and I found that this problem is caused by writeDescriptor failed, and I successfully unlocked the same lock with my old code which use BluetoothGatt directly, I used the code below:\nBluetoothGattService service = gatt.getService(bltServerUUID);\nBluetoothGattCharacteristic readCharacteristic = service.getCharacteristic(readDataUUID);\nwriteCharacteristic = service.getCharacteristic(writeDataUUID);\ngatt.setCharacteristicNotification(readCharacteristic, true);\n\nBluetoothGattDescriptor descriptor = readCharacteristic.getDescriptor(clientUUID);\ndescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\ngatt.writeDescriptor(descriptor);\n\nMeanwhile the corresponding code I used with RxAndroidBle is as below:\nmRxBleConnection.getCharacteristic(READ_DATA_UUID)\n    .subscribeOn(AndroidSchedulers.mainThread())\n    .observeOn(Schedulers.computation())\n    .map(new Func1<BluetoothGattCharacteristic, BluetoothGattDescriptor>() {\n    @Override\n    public BluetoothGattDescriptor call(\n        BluetoothGattCharacteristic bluetoothGattCharacteristic) {\n            BluetoothGattDescriptor descriptor =\n                bluetoothGattCharacteristic.getDescriptor(DESCRIPTOR_UUID);\n        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n        return descriptor;\n  }\n})\n.flatMap(new Func1<BluetoothGattDescriptor, Observable<byte[]>>() {\n  @Override\n  public Observable<byte[]> call(BluetoothGattDescriptor bluetoothGattDescriptor) {\n      return mRxBleConnection.writeDescriptor(bluetoothGattDescriptor,\n          BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n  }\n})\n\nAnd additionally, I found that on different Android platforms the error is different, on Android 4.4, it reports the error below:\n11-21 14:26:51.127 3885-4009/? W/dalvikvm: VFY: unable to resolve virtual method 496: Landroid/bluetooth/BluetoothGattCallback;.onMtuChanged (Landroid/bluetooth/BluetoothGatt;II)V\n11-21 14:26:51.157 3885-4079/? D/BluetoothGatt: connect() - device: 50:F1:4A:4B:5B:1C, auto: false\n11-21 14:26:51.157 3885-4079/? D/BluetoothGatt: registerApp()\n11-21 14:26:51.157 3885-4079/? D/BluetoothGatt: registerApp() - UUID=7d9069e6-d1ff-49d5-b6fc-34d04cade854\n11-21 14:26:51.157 3885-3910/? D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\n11-21 14:26:57.657 3885-3909/? D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=5 device=50:F1:4A:4B:5B:1C\n11-21 14:26:57.667 3885-4079/? D/BluetoothManager: getConnectionState()\n11-21 14:26:57.667 3885-4079/? D/BluetoothManager: getConnectedDevices\n11-21 14:26:57.677 3885-4079/? D/BluetoothGatt: close()\n11-21 14:26:57.677 3885-4079/? D/BluetoothGatt: unregisterApp() - mClientIf=5\n11-21 14:26:57.677 3885-3885/? E/BleLib: connect result: Failed\n11-21 14:26:57.677 3885-3885/? E/BleLib: BleGattException{macAddress=50:F1:4A:4B:5B:1C, status=133 (0x85 -> https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h), bleGattOperationType=BleGattOperation{description='CONNECTION_STATE'}}\n                                             at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:78)\n                                             at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:168)\n                                             at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n                                             at android.os.Binder.execTransact(Binder.java:404)\n                                             at dalvik.system.NativeStart.run(Native Method)\nAnd on Android platforms above 4.4, it reports:\n11-17 16:26:30.243 26865-26865/ble.ubike.com.ble_demo E/BleLib: BleGattDescriptorException{macAddress=50:F1:4A:4B:5B:1C, status=17 (0x11 -> https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h), bleGattOperationType=BleGattOperation{description='DESCRIPTOR_WRITE'}}\n                                                                    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateErrorIfOccurred(RxBleGattCallback.java:242)\n                                                                    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$1200(RxBleGattCallback.java:32)\n                                                                    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onDescriptorWrite(RxBleGattCallback.java:169)\n                                                                    at android.bluetooth.BluetoothGatt$1.onDescriptorWrite(BluetoothGatt.java:484)\n                                                                    at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:165)\n                                                                    at android.os.Binder.execTransact(Binder.java:573)\nLooking forward to your reply, thanks in advance\n. Hi @dariuszseweryn\uff0cthanks a lot for your reply.\nabout the questions you mentions above, here are the explanations:\n1.I have attach the whole setup method below:\n private void setup() {\n    Subscription subscription = mRxBleClient.observeStateChanges()\n        .switchMap(\n            new Func1<State, Observable<?>>() {\n              @Override\n              public Observable<?> call(State state) {\n                switch (state) {\n                  case READY:\n                      if (mOnBleLockListener != null) {\n                          mOnBleLockListener.onBluetoothEnable(true);\n                      }\n                  break;\n\n                  case BLUETOOTH_NOT_ENABLED:\n                      if (mOnBleLockListener != null) {\n                          mOnBleLockListener.onBluetoothEnable(false);\n                      }\n                  break;\n\n                  default:\n                      return Observable.empty();\n                }\n                return Observable.empty();\n              }\n          }).subscribe();\n    mSubscriptionList.add(subscription);\n\n    Subscription subscriptionConnect = mRxBleDevice.observeConnectionStateChanges()\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(\n            new Subscriber<RxBleConnectionState>() {\n                @Override\n                public void onCompleted() {\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    LogUtils.e(\"observeConnectionStateChanges error\");\n                    LogUtils.e(Log.getStackTraceString(e));\n                }\n\n               @Override\n               public void onNext(RxBleConnectionState rxBleConnectionState) {\n                   LogUtils.d(rxBleConnectionState.toString());\n                  if (rxBleConnectionState == RxBleConnectionState.DISCONNECTED) {\n                      handleUnlockFailed(BleUnLockState.setupReady, UnlockException.CONNECT_FAILED);\n                     if (mOnBleLockListener != null) {\n                        mOnBleLockListener.onDisconnect();\n                      }\n                  }\n               }\n           });\n     mSubscriptionList.add(subscriptionConnect);\n\n    Subscription subscriptionNotify = mRxBleConnection\n        .setupNotification(READ_DATA_UUID, NotificationSetupMode.COMPAT)\n        .subscribeOn(AndroidSchedulers.mainThread())\n        .doOnNext(new Action1<Observable<byte[]>>() {\n            @Override\n            public void call(Observable<byte[]> observable) {\n                LogUtils.d(\"setupNotification done\");\n            }\n         })\n        .flatMap(new Func1<Observable<byte[]>, Observable<byte[]>>() {\n            @Override\n            public Observable<byte[]> call(Observable<byte[]> observable) {\n                return observable;\n            }\n         })\n        .subscribe(\n            new Subscriber<byte[]>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                LogUtils.e(\"characteristic changed error\");\n                LogUtils.e(Log.getStackTraceString(e));\n                handleUnlockFailed(BleUnLockState.setupReady, UnlockException.CONNECT_FAILED);\n            }\n\n            @Override\n            public void onNext(byte[] bytes) {\n                LogUtils.d(\"characteristic changed: \" + ByteUtils.bytesToHex(bytes));\n                requestResolveCommand(bytes);\n            }\n       });\n       mSubscriptionList.add(subscriptionNotify);\n\n      mRxBleConnection.getCharacteristic(READ_DATA_UUID)\n        .subscribeOn(AndroidSchedulers.mainThread())\n      //.observeOn(Schedulers.computation())\n        .observeOn(AndroidSchedulers.mainThread())\n        .map(\n            new Func1<BluetoothGattCharacteristic, BluetoothGattDescriptor>() {\n                @Override\n                public BluetoothGattDescriptor call(\n                    BluetoothGattCharacteristic bluetoothGattCharacteristic) {\n                        BluetoothGattDescriptor descriptor =\n                            bluetoothGattCharacteristic.getDescriptor(DESCRIPTOR_UUID);\n                        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n                        return descriptor;\n                    }\n                })\n        .flatMap(new Func1<BluetoothGattDescriptor, Observable<byte[]>>() {\n            @Override\n             public Observable<byte[]> call(BluetoothGattDescriptor bluetoothGattDescriptor) {\n                 Observable<byte[]> ob = mRxBleConnection.writeDescriptor(bluetoothGattDescriptor,\n                     BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n                 return ob;\n              }\n          })\n         .observeOn(AndroidSchedulers.mainThread())\n         .subscribe(\n              new Subscriber<byte[]>() {\n              @Override\n              public void onCompleted() {\n\n              }\n\n              @Override\n              public void onError(Throwable e) {\n                  LogUtils.e(\"setup getCharacteristic error\");\n                  LogUtils.e(Log.getStackTraceString(e));\n                  handleUnlockFailed(BleUnLockState.setupReady, UnlockException.CONNECT_FAILED);\n               }\n\n               @Override\n               public void onNext(byte[] bytes) {\n                   LogUtils.d(\"setup getCharacteristic next\");\n                   mUnlockException = UnlockException.TOKEN_REQUEST_RESOLVE_FAILED;\n                   write(ByteUtils.hexStringToByteArray(mDeviceInfo.getTokenRequest()),\n                       UnlockException.TOKEN_REQUEST_WRITE_FAILED);\n               }\n           });\n   }\n\n2.I did setup an notification by RxBleConnection.setupNotification(BluetoothGattCharacteristic), you can find that in the file, but I am not sure if I am doing right...\n3.The android 4.4 problem is resolve by calling the writeDescriptor method in the main thread, and after doing that, it just reported the same error(status 17) like the other platforms.\n4.The complete log is as below:\n11-20 15:48:25.584 22120-22120/? I/zygote64: Late-enabling -Xcheck:jni\n    11-20 15:48:25.637 22120-22127/? I/zygote64: Debugger is no longer active\n    11-20 15:48:25.771 22120-22125/? I/zygote64: Do partial code cache collection, code=30KB,        \n    data=20KB\n    11-20 15:48:25.771 22120-22125/? I/zygote64: After code cache collection, code=30KB, data=20KB\n    11-20 15:48:25.771 22120-22125/? I/zygote64: Increasing code cache capacity to 128KB\n    11-20 15:48:25.883 22120-22120/? D/NetworkSecurityConfig: No Network Security Config \n    specified, using platform default\n    11-20 15:48:25.918 22120-22137/? D/OpenGLRenderer: HWUI GL Pipeline\n    11-20 15:48:25.974 22120-22137/? I/Adreno: QUALCOMM build                   : 7142022, Ib5823dd10c\n                                           Build Date                       : 06/23/17\n                                           OpenGL ES Shader Compiler Version: EV031.18.00.00\n                                           Local Branch                     : O11A\n                                           Remote Branch                    : \n                                           Remote Branch                    : \n                                           Reconstruct Branch               : \n    11-20 15:48:25.974 22120-22137/? I/vndksupport: sphal namespace is not configured for this \n    process. Loading /vendor/lib64/hw/gralloc.msm8992.so from the current namespace instead.\n    11-20 15:48:25.985 22120-22137/? I/Adreno: PFP: 0x00000000, ME: 0x00000000\n    11-20 15:48:25.990 22120-22137/? I/OpenGLRenderer: Initialized EGL, version 1.4\n    11-20 15:48:25.990 22120-22137/? D/OpenGLRenderer: Swap behavior 2\n    11-20 15:48:26.024 22120-22137/? I/vndksupport: sphal namespace is not configured for this   \n    process. Loading /vendor/lib64/hw/gralloc.msm8992.so from the current namespace instead.\n    11-20 15:48:31.997 22120-22127/ble.ubike.com.ble_demo I/zygote64: Debugger is active\n    11-20 15:48:38.800 22120-22120/ble.ubike.com.ble_demo D/ble_demo: \u8bf7\u6c42token\n    11-20 15:48:38.868 22120-22125/ble.ubike.com.ble_demo I/zygote64: Do partial code cache    \n    collection, code=60KB, data=50KB\n    11-20 15:48:38.868 22120-22125/ble.ubike.com.ble_demo I/zygote64: After code cache collection, \n    code=60KB, data=50KB\n    11-20 15:48:38.868 22120-22125/ble.ubike.com.ble_demo I/zygote64: Increasing code cache    \n    capacity to 256KB\n    11-20 15:48:38.960 22120-22125/ble.ubike.com.ble_demo I/zygote64: Compiler allocated 8MB to    \n    compile void android.widget.TextView.<init>(android.content.Context, android.util.AttributeSet, int, \n    int)\n    11-20 15:48:39.305 22120-22120/ble.ubike.com.ble_demo D/ble_demo: \u8fde\u63a5\u84dd\u7259\u8bbe\u5907\n    11-20 15:48:39.310 22120-22162/ble.ubike.com.ble_demo I/BleManager: connecting to   \n    mac:50:F1:4A:4B:5B:1C\n    11-20 15:48:39.380 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: connect() - device:    \n    50:F1:4A:4B:5B:1C, auto: false\n    11-20 15:48:39.380 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: registerApp()\n    11-20 15:48:39.381 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: registerApp() -   \n    UUID=eb088d84-b6c5-481a-a05b-4de1d495ed95\n    11-20 15:48:39.384 22120-22133/ble.ubike.com.ble_demo D/BluetoothGatt: onClientRegistered() - \n    status=0 clientIf=6\n    11-20 15:48:44.022 22120-22132/ble.ubike.com.ble_demo D/BluetoothGatt:    \n    onClientConnectionState() - status=0 clientIf=6 device=50:F1:4A:4B:5B:1C\n    11-20 15:48:44.420 22120-22142/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onConnectionUpdated() - Device=50:F1:4A:4B:5B:1C interval=6 latency=0 timeout=500 status=0\n    11-20 15:48:44.462 22120-22120/ble.ubike.com.ble_demo D/ble_demo: \u8bbe\u7f6e\u84dd\u7259\u8bbe\u5907\n    11-20 15:48:44.606 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: discoverServices() -   \n    device: 50:F1:4A:4B:5B:1C\n    11-20 15:48:44.637 22120-22133/ble.ubike.com.ble_demo D/BluetoothGatt: onSearchComplete() = \n    Device=50:F1:4A:4B:5B:1C Status=0\n    11-20 15:48:44.649 22120-22164/ble.ubike.com.ble_demo D/BluetoothGatt: \n    setCharacteristicNotification() - uuid: 000036f6-0000-1000-8000-00805f9b34fb enable: true\n    11-20 15:48:44.697 22120-22132/ble.ubike.com.ble_demo D/BluetoothGatt: onConnectionUpdated() \n    - Device=50:F1:4A:4B:5B:1C interval=36 latency=0 timeout=500 status=0\n    11-20 15:48:50.272 22120-22142/ble.ubike.com.ble_demo D/BluetoothGatt: onConnectionUpdated() \n    - Device=50:F1:4A:4B:5B:1C interval=318 latency=1 timeout=300 status=0\n    11-20 15:49:00.107 22120-22125/ble.ubike.com.ble_demo I/zygote64: Do full code cache collection, \n    code=125KB, data=92KB\n    11-20 15:49:00.108 22120-22125/ble.ubike.com.ble_demo I/zygote64: After code cache collection, \n    code=109KB, data=62KB\n    11-20 15:49:01.095 22120-22120/ble.ubike.com.ble_demo I/BleManager: parsing changes from \n    device:DD27087110C50F136885969E4597DBF900000000\n    11-20 15:49:01.105 22120-22120/ble.ubike.com.ble_demo D/BleManager: got confirmation from \n    device:D406C4347E1B9E9DBF240BA13621A35C\n    11-20 15:49:01.119 22120-22120/ble.ubike.com.ble_demo I/BleManager: parsing changes from \n    device:FB017529A58E381544A9F41F9E36B16C00000000\n    11-20 15:49:01.296 22120-22120/ble.ubike.com.ble_demo D/BleManager: got from \n    device:DD27087110C50F136885969E4597DBF9\n    11-20 15:49:01.392 22120-22120/ble.ubike.com.ble_demo D/BleManager: got from \n    device:FB017529A58E381544A9F41F9E36B16C\n    11-20 15:49:01.574 22120-22120/ble.ubike.com.ble_demo I/BleManager: resolved \n    response:ResolveCommandResponse{code=0, msg=ok, \n    obj=BluetoothReturnTokenInfo{name=TOKEN_RESPONSE}}\n    11-20 15:49:01.742 22120-22120/ble.ubike.com.ble_demo D/ble_demo: \u89e3\u9501\u84dd\u7259\u8bbe\u5907\n    11-20 15:49:01.751 22120-22120/ble.ubike.com.ble_demo I/BleManager: resolved \n    response:ResolveCommandResponse{code=0, msg=ok, obj=BluetoothReturnTokenInfo{name=ACK}}\n    11-20 15:49:01.752 22120-22120/ble.ubike.com.ble_demo I/BleManager: ack from device\n    11-20 15:49:01.944 22120-22120/ble.ubike.com.ble_demo D/ble_demo: \u89e3\u9501\u84dd\u7259\u8bbe\u5907\n    11-20 15:49:01.959 22120-22167/ble.ubike.com.ble_demo D/BleManager: write \n    data:D53246DB60141BE1DFD0E59DA1385B1B\n    11-20 15:49:03.483 22120-22120/ble.ubike.com.ble_demo I/BleManager: parsing changes from \n    device:70337BAE5F98C65374C9049B0B72E03500000000\n    11-20 15:49:03.487 22120-22120/ble.ubike.com.ble_demo D/BleManager: got confirmation from \n    device:D53246DB60141BE1DFD0E59DA1385B1B\n    11-20 15:49:03.685 22120-22120/ble.ubike.com.ble_demo D/BleManager: got from \n    device:70337BAE5F98C65374C9049B0B72E035\n    11-20 15:49:03.890 22120-22120/ble.ubike.com.ble_demo I/BleManager: resolved \n    response:ResolveCommandResponse{code=0, msg=ok, obj=BluetoothReturnTokenInfo{name=ACK}}\n    11-20 15:49:03.890 22120-22120/ble.ubike.com.ble_demo I/BleManager: ack from device\n    11-20 15:49:04.680 22120-22120/ble.ubike.com.ble_demo I/BleManager: parsing changes from \n    device:81BB9192FE30AC94BC97EC953A44BAAB00000000\n    11-20 15:49:04.883 22120-22120/ble.ubike.com.ble_demo D/BleManager: got from \n    device:81BB9192FE30AC94BC97EC953A44BAAB\n    11-20 15:49:04.999 22120-22120/ble.ubike.com.ble_demo I/BleManager: resolved \n    response:ResolveCommandResponse{code=0, msg=ok,    \n    obj=BluetoothReturnTokenInfo{name=UNLOCK_RESPONSE}}\n    11-20 15:49:05.000 22120-22120/ble.ubike.com.ble_demo D/ble_demo: \u5df2\u5f00\u9501\n    11-20 15:49:27.375 22120-22120/ble.ubike.com.ble_demo E/BleManager: getDescriptor error\n                                                                    BleGattDescriptorException{macAddress=50:F1:4A:4B:5B:1C, \n    status=17 (0x11 -> \n    https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-\n    5.1.0_r1/stack/include/gatt_api.h), \n    bleGattOperationType=BleGattOperation{description='DESCRIPTOR_WRITE'}}\n                                                                        at \ncom.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateErrorIfOccurred(RxBleGattCallback.java:231)\n                                                                        at     \ncom.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$1100(RxBleGattCallback.java:34)\n                                                                        at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$4.onDescriptorWrite(RxBleGattCallback.java:163)\n                                                                        at android.bluetooth.BluetoothGatt$1$10.run(BluetoothGatt.java:529)\n                                                                        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:711)\n                                                                        at android.bluetooth.BluetoothGatt.-wrap0(Unknown   Source:0)\n                                                                        at         android.bluetooth.BluetoothGatt$1.onDescriptorWrite(BluetoothGatt.java:525)\n                                                                        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:172)\n                                                                        at android.os.Binder.execTransact(Binder.java:674)\n                                                                     Caused by: rx.exceptions.OnErrorThrowable$OnNextValue:   \n    OnError while emitting onNext value: \n    com.polidea.rxandroidble.exceptions.BleGattDescriptorException.class\n                                                                        at \n    rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:73)\n                                                                        at \ncom.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.onNext(RelaySubscriptionManager.java:205)\n                                                                        at \n    com.jakewharton.rxrelay.PublishRelay.call(PublishRelay.java:47)\n                                                                        at \ncom.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateStatusError(RxBleGattCallback.java:249)\n                                                                        at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateErrorIfOccurred(RxBleGattCallback.java:231)\u00a0\n                                                                        at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$1100(RxBleGattCallback.java:34)\u00a0\n                                                                        at com.polidea.rxandroidble.internal.connection.RxBleGattCallback$4.onDescriptorWrite(RxBleGattCallback.java:163)\u00a0\n                                                                        at android.bluetooth.BluetoothGatt$1$10.run(BluetoothGatt.java:529)\u00a0\n                                                                        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:711)\u00a0\n                                                                        at android.bluetooth.BluetoothGatt.-wrap0(Unknown Source:0)\u00a0\n                                                                        at android.bluetooth.BluetoothGatt$1.onDescriptorWrite(BluetoothGatt.java:525)\u00a0\n                                                                        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:172)\u00a0\n                                                                        at android.os.Binder.execTransact(Binder.java:674)\u00a0\n11-20 15:49:27.415 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt:      \n    setCharacteristicNotification() - uuid: 000036f6-0000-1000-8000-00805f9b34fb enable: false\n    11-20 15:49:27.429 22120-22120/ble.ubike.com.ble_demo D/BluetoothManager:    \n    getConnectionState()\n    11-20 15:49:27.429 22120-22120/ble.ubike.com.ble_demo D/BluetoothManager: \n    getConnectedDevices\n    11-20 15:49:27.467 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: cancelOpen() - device: \n    50:F1:4A:4B:5B:1C\n    11-20 15:49:27.470 22120-22142/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onClientConnectionState() - status=0 clientIf=6 device=50:F1:4A:4B:5B:1C\n    11-20 15:49:27.548 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: close()\n    11-20 15:49:27.549 22120-22120/ble.ubike.com.ble_demo D/BluetoothGatt: unregisterApp() - mClientIf=6. Hello @dariuszseweryn I have enable the Log printing and the log is as below:\n11-22 09:50:55.446 17034-17295/ble.ubike.com.ble_demo D/BleLib: Retorfit request url:     \n    https://api2test.ubike.cn/ls5/v2/ble/Rt9d07lomP/generate-auth?code=B000264806, body: \n    okhttp3.RequestBody$2@3f614d3, header: CLIENT-TOKEN: w80*X&3-=x234M\n                                                                geolocation: geo:121.0,31.0,0;mt=0;u=0\n    11-22 09:50:55.901 17034-17034/ble.ubike.com.ble_demo D/BleLib: GetTokenResponse{code=0,   \n    msg=ok, obj=DeviceInfo{imei=010250F14A4B5B1C, \n    auth=CC6E8EF0E6A2BFC893871E571CA06D7D, address=null, \n    tokenRequest=B7D32028531B4F70E30392206BD52C83}}\n    11-22 09:50:55.911 17034-17295/ble.ubike.com.ble_demo D/BleLib: connect to mac address:  \n    50:F1:4A:4B:5B:1C\n    11-22 09:50:55.961 17034-17303/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:   \n    QUEUED ConnectOperation(227886569)\n    11-22 09:50:55.962 17034-17108/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:     \n    STARTED ConnectOperation(227886569)\n    11-22 09:50:55.970 17034-17304/ble.ubike.com.ble_demo V/RxBle#BleConnectionCompat: \n    Connecting without reflection\n    11-22 09:50:55.975 17034-17304/ble.ubike.com.ble_demo D/BluetoothGatt: connect() - device: \n    50:F1:4A:4B:5B:XX, auto: false\n    11-22 09:50:55.975 17034-17304/ble.ubike.com.ble_demo D/BluetoothAdapter: \n    isSecureModeEnabled\n    11-22 09:50:55.975 17034-17304/ble.ubike.com.ble_demo D/BluetoothGatt: registerApp()\n    11-22 09:50:55.976 17034-17304/ble.ubike.com.ble_demo D/BluetoothGatt: registerApp() -  \n    UUID=5e5b3431-ef64-47aa-9160-41edc6f7dad8\n    11-22 09:50:56.082 17034-17301/ble.ubike.com.ble_demo D/BluetoothGatt: onClientRegistered() - \n    status=0 clientIf=4\n    11-22 09:50:56.825 17034-17047/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onClientConnectionState() - status=0 clientIf=4 device=50:F1:4A:4B:5B:XX\n    11-22 09:50:56.835 17034-17047/ble.ubike.com.ble_demo D/RxBle#BluetoothGatt: \n    onConnectionStateChange newState=2 status=0\n    11-22 09:50:56.839 17034-17108/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue: \n    FINISHED ConnectOperation(227886569)\n    11-22 09:50:56.841 17034-17034/ble.ubike.com.ble_demo D/BleLib: connect result: Connected\n    11-22 09:50:56.942 17034-17034/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:   \n    QUEUED ServiceDiscoveryOperation(104381195)\n    11-22 09:50:56.943 17034-17302/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:  \n    STARTED ServiceDiscoveryOperation(104381195)\n    11-22 09:50:56.946 17034-17304/ble.ubike.com.ble_demo D/BluetoothGatt: discoverServices() - \n    device: 50:F1:4A:4B:5B:XX\n    11-22 09:50:57.097 17034-17048/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onClientConnParamsChanged() - Device=50:F1:4A:4B:5B:XX interval=6 status=0\n    11-22 09:50:57.314 17034-17048/ble.ubike.com.ble_demo D/BluetoothGatt: onSearchComplete() = \n    Device=50:F1:4A:4B:5B:XX Status=0\n    11-22 09:50:57.320 17034-17048/ble.ubike.com.ble_demo D/RxBle#BluetoothGatt: \n    onServicesDiscovered status=0\n    11-22 09:50:57.346 17034-17303/ble.ubike.com.ble_demo D/BluetoothGatt: \n    setCharacteristicNotification() - uuid: 000036f6-0000-1000-8000-00805f9b34fb enable: true\n    11-22 09:50:57.353 17034-17303/ble.ubike.com.ble_demo D/BleLib: setupNotification done\n    11-22 09:50:57.360 17034-17302/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:    \n    FINISHED ServiceDiscoveryOperation(104381195)\n    11-22 09:50:57.368 17034-17034/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:   \n    QUEUED DescriptorWriteOperation(90984544)\n    11-22 09:50:57.370 17034-17302/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:  \n    STARTED DescriptorWriteOperation(90984544)\n    11-22 09:50:57.373 17034-17047/ble.ubike.com.ble_demo D/BluetoothGatt:    \n    onClientConnParamsChanged() - Device=50:F1:4A:4B:5B:XX interval=39 status=0\n    11-22 09:50:57.475 17034-17047/ble.ubike.com.ble_demo D/RxBle#BluetoothGatt: \n    onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=17\n    11-22 09:50:57.485 17034-17302/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue: \n    FINISHED DescriptorWriteOperation(90984544)\n    11-22 09:50:57.489 17034-17034/ble.ubike.com.ble_demo E/BleLib: setup getCharacteristic error\n    11-22 09:50:57.491 17034-17034/ble.ubike.com.ble_demo E/BleLib: \n    com.polidea.rxandroidble.exceptions.BleGattDescriptorException: GATT exception from MAC \n    address 50:F1:4A:4B:5B:1C, status 17, type BleGattOperation{description='DESCRIPTOR_WRITE'}. \n    (Look up status 0x11 here \n    https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-\n    5.1.0_r1/stack/include/gatt_api.h)\n    at com.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateErrorIfOccurred(RxBleGatt   \n    Callback.java:242)\n                                                                    at  com.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$1200(RxBleGattCallback.java:32)\n                                                                    at   com.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onDescriptorWrite(RxBleGattCallback.java:169)\n                                                                    at   android.bluetooth.BluetoothGatt$1.onDescriptorWrite(BluetoothGatt.java:484)\n                                                                    at   android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:165)\n                                                                    at android.os.Binder.execTransact(Binder.java:573)\n    11-22 09:50:57.497 17034-17303/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:      \n    QUEUED DisconnectOperation(141151298)\n    11-22 09:50:57.499 17034-17108/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:  \n    STARTED DisconnectOperation(141151298)\n    11-22 09:50:57.501 17034-17303/ble.ubike.com.ble_demo I/RxBle#ConnectionOperationQueue: \n    Connection operations queue to be terminated (50:F1:4A:4B:5B:1C)\n    11-22 09:50:57.502 17034-17304/ble.ubike.com.ble_demo D/BluetoothManager: \n    getConnectionState()\n    11-22 09:50:57.502 17\n And if use DEFAULT mode of setting, it reports error as below:\n11-22 10:09:47.135 22084-22304/ble.ubike.com.ble_demo D/BleLib: connect to mac address:     \n    50:F1:4A:4B:5B:1C\n    11-22 10:09:47.178 22084-22311/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:   \n    QUEUED ConnectOperation(227886569)\n    11-22 10:09:47.179 22084-22118/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:  \n    STARTED ConnectOperation(227886569)\n    11-22 10:09:47.184 22084-22312/ble.ubike.com.ble_demo V/RxBle#BleConnectionCompat: \n    Connecting without reflection\n    11-22 10:09:47.189 22084-22312/ble.ubike.com.ble_demo D/BluetoothGatt: connect() - device: \n    50:F1:4A:4B:5B:XX, auto: false\n    11-22 10:09:47.189 22084-22312/ble.ubike.com.ble_demo D/BluetoothAdapter: \n    isSecureModeEnabled\n    11-22 10:09:47.190 22084-22312/ble.ubike.com.ble_demo D/BluetoothGatt: registerApp()\n    11-22 10:09:47.190 22084-22312/ble.ubike.com.ble_demo D/BluetoothGatt: registerApp() - \n    UUID=66990901-7e08-45fa-87a7-511785be3233\n    11-22 10:09:47.299 22084-22097/ble.ubike.com.ble_demo D/BluetoothGatt: onClientRegistered() -    \n    status=0 clientIf=6\n    11-22 10:09:48.009 22084-22097/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onClientConnectionState() - status=0 clientIf=6 device=50:F1:4A:4B:5B:XX\n    11-22 10:09:48.023 22084-22097/ble.ubike.com.ble_demo D/RxBle#BluetoothGatt: \n    onConnectionStateChange newState=2 status=0\n    11-22 10:09:48.025 22084-22118/ble.ubike.com.ble_demo D/RxBle#ClientOperationQueue:   \n    FINISHED ConnectOperation(227886569)\n    11-22 10:09:48.028 22084-22084/ble.ubike.com.ble_demo D/BleLib: connect result: Connected\n    11-22 10:09:48.119 22084-22084/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:   \n    QUEUED ServiceDiscoveryOperation(159353562)\n    11-22 10:09:48.124 22084-22310/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:  \n    STARTED ServiceDiscoveryOperation(159353562)\n    11-22 10:09:48.128 22084-22312/ble.ubike.com.ble_demo D/BluetoothGatt: discoverServices() - \n    device: 50:F1:4A:4B:5B:XX\n    11-22 10:09:48.303 22084-22096/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onClientConnParamsChanged() - Device=50:F1:4A:4B:5B:XX interval=6 status=0\n    11-22 10:09:48.513 22084-22096/ble.ubike.com.ble_demo D/BluetoothGatt: onSearchComplete() = \n    Device=50:F1:4A:4B:5B:XX Status=0\n    11-22 10:09:48.516 22084-22096/ble.ubike.com.ble_demo D/RxBle#BluetoothGatt: \n    onServicesDiscovered status=0\n    11-22 10:09:48.523 22084-22311/ble.ubike.com.ble_demo D/BluetoothGatt: \n    setCharacteristicNotification() - uuid: 000036f6-0000-1000-8000-00805f9b34fb enable: true\n    11-22 10:09:48.532 22084-22311/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:   \n    QUEUED DescriptorWriteOperation(50774223)\n    11-22 10:09:48.534 22084-22310/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue: \n    FINISHED ServiceDiscoveryOperation(159353562)\n    11-22 10:09:48.534 22084-22310/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:  \n    STARTED DescriptorWriteOperation(50774223)\n    11-22 10:09:48.544 22084-22084/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:   \n    QUEUED DescriptorWriteOperation(40029662)\n    11-22 10:09:48.568 22084-22319/ble.ubike.com.ble_demo D/BluetoothGatt: \n    onClientConnParamsChanged() - Device=50:F1:4A:4B:5B:XX interval=39 status=0\n    11-22 10:09:48.620 22084-22096/ble.ubike.com.ble_demo D/RxBle#BluetoothGatt: \n    onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=17\n    11-22 10:09:48.628 22084-22310/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue: \n    FINISHED DescriptorWriteOperation(50774223)\n    11-22 10:09:48.630 22084-22310/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:  \n    STARTED DescriptorWriteOperation(40029662)\n    11-22 10:09:48.633 22084-22311/ble.ubike.com.ble_demo D/BluetoothGatt: \n    setCharacteristicNotification() - uuid: 000036f6-0000-1000-8000-00805f9b34fb enable: false\n    11-22 10:09:48.641 22084-22311/ble.ubike.com.ble_demo D/RxBle#ConnectionOperationQueue:   \n    QUEUED DescriptorWriteOperation(73912973)\n    11-22 10:09:48.642 22084-22311/ble.ubike.com.ble_demo E/BleLib: characteristic changed error\n    11-22 10:09:48.647 22084-22311/ble.ubike.com.ble_demo E/BleLib: \n    com.polidea.rxandroidble.exceptions.BleCannotSetCharacteristicNotificationException: Cannot write \n    client characteristic config descriptor (code 3) with characteristic UUID 000036f6-0000-1000-\n    8000-00805f9b34fb\n                                                                    at \ncom.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$6.call(NotificationAndIndicationManager.java:187)\n                                                                    at \ncom.polidea.rxandroidble.internal.connection.NotificationAndIndicationManager$6.call(NotificationAndIndicationManager.java:184)\n                                                                    at rx.Completable$26$1.onError(Completable.java:1742)\n                                                                    at rx.Completable$10$1.onError(Completable.java:579)\n                                                                    at  \n    rx.internal.operators.OnSubscribeCreate$BaseEmitter.onError(OnSubscribeCreate.java:109)\n                                                                    at \n    rx.internal.util.ObserverSubscriber.onError(ObserverSubscriber.java:39)\n                                                                    at \n    rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)\n                                                                    at \n    rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                                                                    at \n    rx.internal.operators.OperatorUnsubscribeOn$1.onError(OperatorUnsubscribeOn.java:47)\n                                                                    at \nrx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onError(OperatorSubscribeOn.java:80)\n                                                                    at \n    rx.internal.operators.OnSubscribeCreate$BaseEmitter.onError(OnSubscribeCreate.java:109)\n                                                                    at \ncom.polidea.rxandroidble.internal.util.QueueReleasingEmitterWrapper.onError(QueueReleasingEmitterWrapper.java:41)\n                                                                    at \n    rx.internal.util.ObserverSubscriber.onError(ObserverSubscriber.java:39)\n                                                                    at \n    rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)\n                                                                    at \n    rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\n                                                                    at \n    rx.observers.SerializedObserver.onError(SerializedObserver.java:152)\n                                                                    at    \n    rx.observers.SerializedSubscriber.onError(SerializedSubscriber.java:78)\n                                                                    at \nrx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onError(OperatorTimeoutBase.java:147)\n                                                                    at \n    rx.internal.operators.OperatorSingle$ParentSubscriber.onError(OperatorSingle.java:129)\n                                                                    at   \n    rx.internal.operators.OperatorTake$1.onError(OperatorTake.java:65)\n                                                                    at \n    rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)\n                                                                    at \n    rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onError(OnSubscribeFilter.java:90)\n                                                                    at \nrx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:273)\n                                                                    at \n    rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216)\n                                                                    at \n    rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n                                                                    at \nrx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n                                                                    at \n    java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n                                                                    at \n    java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n                                                                    at java.lang.Thread.run(Thread.java:762)\n                                                                 Caused by: \n    com.polidea.rxandroidble.exceptions.BleGattDescriptorException: GATT exception from MAC \n    address 50:F1:4A:4B:5B:1C, status 17, type BleGattOperation{description='DESCRIPTOR_WRITE'}. \n    (Look up status 0x11 here \n    https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-\n    5.1.0_r1/stack/include/gatt_api.h)\n                                                                    at \ncom.polidea.rxandroidble.internal.connection.RxBleGattCallback.propagateErrorIfOccurred(RxBleGattCallback.java:242)\n                                                                    at \ncom.polidea.rxandroidble.internal.connection.RxBleGattCallback.access$1200(RxBleGattCallback.java:32)\n                                                                    at \ncom.polidea.rxandroidble.internal.connection.RxBleGattCallback$2.onDescriptorWrite(RxBleGattCallback.java:169)\n                                                                    at \n    android.bluetooth.BluetoothGatt$1.onDescriptorWrite(BluetoothGatt.java:484)\n                                                                    at \n    android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:165)\n                                                                    at android.os.Binder.execTransact(Binder.java:573). Update:\nI found that in class DescriptorWriteOperation's startOperation method the value of final \" boolean success = bluetoothGatt.writeDescriptor(bluetoothGattDescriptor);\"  is true, \n@Override\nprotected boolean startOperation(BluetoothGatt bluetoothGatt) {\n    bluetoothGattDescriptor.setValue(data);\n\n    /*\n    * According to the source code below Android 7.0.0 the BluetoothGatt.writeDescriptor() function  \n       used\n    * writeType of the parent BluetoothCharacteristic which caused operation failure (for instance \n       when\n    * setting Client Characteristic Config). With WRITE_TYPE_DEFAULT problem did not occurred.\n    * Compare:\n    * https://android.googlesource.com/platform/frameworks/base/+/android-\n      6.0.1_r74/core/java/android/bluetooth/BluetoothGatt.java#1039\n    * https://android.googlesource.com/platform/frameworks/base/+/android-\n      7.0.0_r1/core/java/android/bluetooth/BluetoothGatt.java#947\n    */\n    final BluetoothGattCharacteristic bluetoothGattCharacteristic =    \n        bluetoothGattDescriptor.getCharacteristic();\n    final int originalWriteType = bluetoothGattCharacteristic.getWriteType();\n    bluetoothGattCharacteristic.setWriteType(bluetoothGattCharacteristicDefaultWriteType);\n\n    final boolean success = bluetoothGatt.writeDescriptor(bluetoothGattDescriptor);\n    bluetoothGattCharacteristic.setWriteType(originalWriteType);\n    return success;\n}\n\nhowever in the RxBleGattCallback class's onDescriptorWrite callback the status attribute's value is 17:\n@Override\npublic void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status)    \n{\n    RxBleLog.d(\"onDescriptorWrite descriptor=%s status=%d\", descriptor.getUuid(), status);\n    nativeCallbackDispatcher.notifyNativeDescriptorWriteCallback(gatt, descriptor, status);\n    super.onDescriptorWrite(gatt, descriptor, status);\n\n    if (writeDescriptorOutput.hasObservers()\n            && !propagateErrorIfOccurred(writeDescriptorOutput, gatt, descriptor, status, \n        BleGattOperationType.DESCRIPTOR_WRITE)) {\n            writeDescriptorOutput.valueRelay.call(new ByteAssociation<>(descriptor, \n                descriptor.getValue()));\n    }\n}\n\nI am a little confused about this, do you have any clue please?\n. @dariuszseweryn thanks a lot for your help, here is the log that I used the old code to unlock the same lock with the same phone:\n11-22 16:51:06.351 15730-15730/com.yl.ubike E/UBike: BlueTooth scan Device  \n11-22 16:51:06.352 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.353 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.354 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.355 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.355 15730-15730/com.yl.ubike D/BluetoothLeScanner: Start Scan\n11-22 16:51:06.356 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.356 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.358 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.358 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:06.465 15730-15742/com.yl.ubike D/BluetoothLeScanner: onClientRegistered() -   \nstatus=0 clientIf=4 mClientIf=0\n11-22 16:51:09.468 15730-15730/com.yl.ubike E/UBike: BlueTooth find Device~~~~~~~\n11-22 16:51:09.468 15730-15730/com.yl.ubike E/UBike: BlueTooth stop scan\n11-22 16:51:09.471 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:09.473 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:09.474 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:09.475 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:09.476 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:09.478 15730-15730/com.yl.ubike D/BluetoothAdapter: STATE_ON\n11-22 16:51:09.478 15730-15730/com.yl.ubike D/BluetoothLeScanner: Stop Scan\n11-22 16:51:09.489 15730-15730/com.yl.ubike D/BluetoothManager: getConnectionState()\n11-22 16:51:09.489 15730-15730/com.yl.ubike D/BluetoothManager: getConnectedDevices\n11-22 16:51:09.502 15730-15730/com.yl.ubike D/BluetoothGatt: connect() - device: \n50:F1:4A:4B:5B:XX, auto: false\n11-22 16:51:09.502 15730-15730/com.yl.ubike D/BluetoothAdapter: isSecureModeEnabled\n11-22 16:51:09.502 15730-15730/com.yl.ubike D/BluetoothGatt: registerApp()\n11-22 16:51:09.503 15730-15730/com.yl.ubike D/BluetoothGatt: registerApp() - UUID=c221825f-\n1638-4ccc-a01c-3adbb3fc6fa3\n11-22 16:51:09.607 15730-15742/com.yl.ubike D/BluetoothGatt: onClientRegistered() - status=0 \nclientIf=4\n11-22 16:51:12.049 15730-15982/com.yl.ubike D/BluetoothGatt: onClientConnectionState() -  \nstatus=0 clientIf=4 device=50:F1:4A:4B:5B:XX\n11-22 16:51:12.063 15730-15982/com.yl.ubike D/BluetoothGatt: discoverServices() - device: \n50:F1:4A:4B:5B:XX\n11-22 16:51:12.064 15730-15982/com.yl.ubike E/UBike: BlueTooth state : STATE_CONNECTED\n11-22 16:51:12.296 15730-15742/com.yl.ubike D/BluetoothGatt: onClientConnParamsChanged() - \nDevice=50:F1:4A:4B:5B:XX interval=6 status=0\n11-22 16:51:12.577 15730-15743/com.yl.ubike D/BluetoothGatt: onSearchComplete() = \nDevice=50:F1:4A:4B:5B:XX Status=0\n11-22 16:51:12.577 15730-15743/com.yl.ubike E/UBike: BlueTooth onServicesDiscovered\n11-22 16:51:12.577 15730-15743/com.yl.ubike D/BluetoothGatt: setCharacteristicNotification() - \nuuid: 000036f6-0000-1000-8000-00805f9b34fb enable: true\n11-22 16:51:12.581 15730-15743/com.yl.ubike E/UBike: BlueTooth state CONNECT\n11-22 16:51:12.581 15730-15743/com.yl.ubike E/UBike: BlueTooth state CONNECT\n11-22 16:51:12.662 15730-15742/com.yl.ubike D/BluetoothGatt: onClientConnParamsChanged() - \nDevice=50:F1:4A:4B\n5B:XX interval=39 status=0\n11-22 16:51:15.194 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n11-22 16:51:15.194 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n\n                                                    88B10FDF8C4507A578C95B357706DEE900000000\n11-22 16:51:15.208 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n11-22 16:51:15.208 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n\n                                                    691460BBA41B5CA1E768FE1C4AAE3EDD00000000\n11-22 16:51:15.828 15730-15742/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n11-22 16:51:15.828 15730-15742/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n\n                                                    3F100136A768CA656E29335998636A6F00000000\n11-22 16:51:17.194 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n11-22 16:51:17.195 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n\n                                                    FFA219C3338D7B23C2598D90A3257D9400000000\n11-22 16:51:18.709 15730-15743/com.yl.ubike D/BluetoothGatt: onClientConnParamsChanged() - \nDevice=50:F1:4A:4B:5B:XX interval=318 status=0\n\n11-22 16:51:21.491 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n11-22 16:51:21.491 15730-15743/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n\n                                                    DE5A3D7ED083F81A587A166FB74FF8E000000000\n11-22 16:51:21.497 15730-15982/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n11-22 16:51:21.497 15730-15982/com.yl.ubike E/UBike: BlueTooth return data~~~~~~\n\n                                                    3719EB5A9F4A22894FC4D23E41D66AAD00000000\n11-22 16:53:00.644 15730-15730/com.yl.ubike D/BluetoothGatt: close()\n11-22 16:53:00.649 15730-15730/com.yl.ubike D/BluetoothGatt: unregisterApp() - mClientIf=4\n11-22 16:53:00.656 15730-15730/com.yl.ubike E/UBike: mBluetoothGatt.disconnect()\n11-22 16:53:00.660 15730-15730/com.yl.ubike D/BluetoothGatt: cancelOpen() - device: \n50:F1:4A:4B:5B:XX\n\nI tried  postponing the setupNotification and writeDescriptor for several hundreds milliseconds, but still no luck, it reported the same error.. Yes, you are right. Actually I found that in my old code it also reports status=17, but I didn't handle it at all... And it just can unlock.... yes, my bad, a lot thanks for your help, have a nice day. ",
    "ejbp": "Result of : \nLog.d(\"BluetoothCommManager\", \"Providers: \" + locationManager.getAllProviders());\nis \n11-27 09:43:59.023 20336-20336/? D/BluetoothCommManager: Providers: [passive, network]\nWhen I run:\n```\nscanSubscription = rxBleClient.scanBleDevices(\n                new ScanSettings.Builder()\n                        .setScanMode(ScanSettings.SCAN_MODE_BALANCED)\n                        // .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY) // change if needed\n                        // .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES) // change if needed\n                        .build(),\n\n\n\n                new ScanFilter.Builder().setDeviceName(\"BTDeviceName\").build()\n\n\n        ).subscribe(\n\n                scanResult -> {\n                    // Process scan result here.\n\n                    Log.d(\"BluetoothComm\", \"ScanResult: \" + scanResult);\n\n                },\n                throwable -> {\n                    // Handle an error here.\n                    Log.d(\"BluetoothComm\", \"Bluetooth Scan Error: \");\n                    throwable.printStackTrace();\n                }\n\n        );\n\n```\nthe result is:\n```\n11-27 09:43:59.028 20336-20336/? D/BluetoothComm: Bluetooth Scan Error: \n11-27 09:43:59.028 20336-20336/? W/System.err: com.polidea.rxandroidble.exceptions.BleScanException: Location Services disabled (code 4)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.polidea.rxandroidble.internal.scan.ScanPreconditionsVerifierApi18.verify(ScanPreconditionsVerifierApi18.java:31)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.polidea.rxandroidble.internal.scan.ScanPreconditionsVerifierApi24.verify(ScanPreconditionsVerifierApi24.java:38)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.polidea.rxandroidble.RxBleClientImpl$1.call(RxBleClientImpl.java:114)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.polidea.rxandroidble.RxBleClientImpl$1.call(RxBleClientImpl.java:111)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:46)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at rx.Observable.subscribe(Observable.java:10352)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at rx.Observable.subscribe(Observable.java:10319)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at rx.Observable.subscribe(Observable.java:10159)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.xxx.comm.bluetooth.BluetoothCommManager.scanDevice(BluetoothCommManager.java:74)\n//Log started here:\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.xxx.gui.launcher.PairingScene.start(PairingScene.java:83)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at com.xxx.LauncherActivity.onResume(LauncherActivity.java:345)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1269)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at android.app.Activity.performResume(Activity.java:6786)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3407)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3470)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2733)\n11-27 09:43:59.028 20336-20336/? W/System.err:     at android.app.ActivityThread.-wrap12(ActivityThread.java)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1478)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:102)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at android.os.Looper.loop(Looper.java:154)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6121)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at java.lang.reflect.Method.invoke(Native Method)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:889)\n11-27 09:43:59.029 20336-20336/? W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:779)\n11-27 09:43:59.035 20336-20368/? W/System: ClassLoader referenced unknown path: /data/user_de/0/com.google.android.gms/app_chimera/m/0000000e/n/arm64-v8a\n```\n. Configuration:\ncompileSdkVersion 26\n    //buildToolsVersion '26.0.2'\n    buildToolsVersion '26.0.2'\n    flavorDimensions \"default\"\n    defaultConfig {\n        applicationId \"com.xxx\"\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 0\n        versionName \"0.2.8\"\n        multiDexEnabled true\n    }\nnote: I've recently upgraded to 26 but I've tested before with 25 which was giving the same error.\nI've changed the request permission from ACCESS_COARSE_LOCATION to ACCESS_FINE_LOCATION but it stills gives the same error.\n```\nLog.d(\"BluetoothCommManager\", \"Providers: \" + locationManager.getAllProviders());\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (Network): \" + locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (GPS): \" + locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER));\n11-27 10:00:25.993 21028-21028/? D/BluetoothCommManager: Providers: [passive, network]\n11-27 10:00:25.994 21028-21028/? D/BluetoothCommManager: isProviderEnabled (Network): false\n11-27 10:00:25.994 21028-21028/? D/BluetoothCommManager: isProviderEnabled (GPS): false\n```\n11-27 10:00:26.003 21028-21028/? D/BluetoothComm: Bluetooth Scan Error: \n11-27 10:00:26.003 21028-21028/? W/System.err: com.polidea.rxandroidble.exceptions.BleScanException: Location Services disabled (code 4)\n11-27 10:00:26.003 21028-21028/? W/System.err:     at com.polidea.rxandroidble.internal.scan.ScanPreconditionsVerifierApi18.verify(ScanPreconditionsVerifierApi18.java:31)\n11-27 10:00:26.003 21028-21028/? W/System.err:     at com.polidea.rxandroidble.internal.scan.ScanPreconditionsVerifierApi24.verify(ScanPreconditionsVerifierApi24.java:38)\n11-27 10:00:26.003 21028-21028/? W/System.err:     at com.polidea.rxandroidble.RxBleClientImpl$1.call(RxBleClientImpl.java:114)\n\n\n. Ok, so without any change on the configuration the result of:\n```\nLog.d(\"BluetoothCommManager\", \"Providers: \" + locationManager.getAllProviders());\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (Network): \" + locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (GPS): \" + locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (PASSIVE_PROVIDER): \" + locationManager.isProviderEnabled(LocationManager.PASSIVE_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (FUSED_PROVIDER): \" + locationManager.isProviderEnabled(\"fused\"));\n```\nis\n11-27 10:21:14.334 21756-21756/? D/BluetoothCommManager: Providers: [passive, network]\n11-27 10:21:14.335 21756-21756/? D/BluetoothCommManager: isProviderEnabled (Network): false\n11-27 10:21:14.335 21756-21756/? D/BluetoothCommManager: isProviderEnabled (GPS): false\n11-27 10:21:14.336 21756-21756/? D/BluetoothCommManager: isProviderEnabled (PASSIVE_PROVIDER): true\n11-27 10:21:14.336 21756-21756/? D/BluetoothCommManager: isProviderEnabled (FUSED_PROVIDER): false\nNow, changing mode from device (which was the default) to High Accuracy, the result is:\n11-27 10:32:15.011 22157-22157/? D/BluetoothCommManager: Providers: [passive, network]\n11-27 10:32:15.012 22157-22157/? D/BluetoothCommManager: isProviderEnabled (Network): true\n11-27 10:32:15.012 22157-22157/? D/BluetoothCommManager: isProviderEnabled (GPS): false\n11-27 10:32:15.012 22157-22157/? D/BluetoothCommManager: isProviderEnabled (PASSIVE_PROVIDER): true\n11-27 10:32:15.013 22157-22157/? D/BluetoothCommManager: isProviderEnabled (FUSED_PROVIDER): false\nAnd now it's working, meaning that I receive the ScanResults. \nMy question now is if this condition (about the providers) is really necessary cause, if permission ACCESS_COARSE_LOCATION is allowed, even with mode in \"device\" mode, the scan works. I know this cause I've tested to do it directly (with the android libs). This is will force to request the user to change this, which is one more barrier to use the app (or even not be able to use if it's a basic user).\nLooking forward for your thoughts. Anyway, thank you very much for your help and the Lib :). \n. \"This is to control user's privacy better (you're getting device MAC address, which you can use as a location tip).\"\nYes, I understand it. What I'm saying is that, using android libs, when I'm in device mode I also receive the ScanResult (Name of device + Mac address).  \nBut, you're probably right, it may be a device provider issue on this.\nThanks for your help.\nBest\n. \n\nResult:\n```\nLog.d(\"BluetoothCommManager\", \"Providers: \" + locationManager.getAllProviders());\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (Network): \" + locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (GPS): \" + locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (PASSIVE_PROVIDER): \" + locationManager.isProviderEnabled(LocationManager.PASSIVE_PROVIDER));\nLog.d(\"BluetoothCommManager\", \"isProviderEnabled (FUSED_PROVIDER): \" + locationManager.isProviderEnabled(\"fused\"));\n11-27 11:27:42.452 24704-24704/? D/BluetoothCommManager: Providers: [passive, network]\n11-27 11:27:42.453 24704-24704/? D/BluetoothCommManager: isProviderEnabled (Network): false\n11-27 11:27:42.453 24704-24704/? D/BluetoothCommManager: isProviderEnabled (GPS): false\n11-27 11:27:42.454 24704-24704/? D/BluetoothCommManager: isProviderEnabled (PASSIVE_PROVIDER): true\n11-27 11:27:42.454 24704-24704/? D/BluetoothCommManager: isProviderEnabled (FUSED_PROVIDER): false\n11-27 11:27:42.459 24704-24704/? D/BluetoothComm: Bluetooth Scan Error: \n11-27 11:27:42.459 24704-24704/? W/System.err: com.polidea.rxandroidble.exceptions.BleScanException: Location Services disabled (code 4)\n11-27 11:27:42.460 24704-24704/? W/System.err:     at com.polidea.rxandroidble.internal.scan.ScanPreconditionsVerifierApi18.verify(ScanPreconditionsVerifierApi18.java:31)\n11-27 11:27:42.460 24704-24704/? W/System.err:     at com.polidea.rxandroidble.internal.scan.ScanPreconditionsVerifierApi24.verify(ScanPreconditionsVerifierApi24.java:38)\n11-27 11:27:42.460 24704-24704/? W/System.err:     at com.polidea.rxandroidble.RxBleClientImpl$1.call(RxBleClientImpl.java:114)\n11-27 11:27:42.460 24704-24704/? W/System.err:     at com.polidea.rxandroidble.RxBleClientImpl$1.call(RxBleClientImpl.java:111)\n11-27 11:27:42.460 24704-24704/? W/Syste\n```. Sorry Darius. I was off during some days and I missed your post. I will try to answer asap. . ##Value for Device Only\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 1\nValue for Battery Saving\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 2\nValue for High Accuracy\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 3\nLet me know if you need any further debug. . \nWhen location is on && setting is Device Only\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 1\n\nWhen location is on && setting is Battery Saving\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 2\n\nWhen location is on && setting is High Accuracy\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 3\n\nWhen location is off\nDebugger for Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): value = 0\n\n. ```\nSettings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): 1\n\nProviders: [passive, network]\nisProviderEnabled (Network): false\nisProviderEnabled (GPS): false\nisProviderEnabled (PASSIVE_PROVIDER): true\nisProviderEnabled (FUSED_PROVIDER): false\n```\n```\nSettings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): 2\n\nProviders: [passive, network]\nisProviderEnabled (Network): true\nisProviderEnabled (GPS): false\nisProviderEnabled (PASSIVE_PROVIDER): true\nisProviderEnabled (FUSED_PROVIDER): false\n```\n```\nSettings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): 3\n\nProviders: [passive, network]\nsProviderEnabled (Network): true\nisProviderEnabled (GPS): false\nisProviderEnabled (PASSIVE_PROVIDER): true\nisProviderEnabled (FUSED_PROVIDER): false\n```\n```\nSettings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE): 0\n\nProviders: [passive, network]\nisProviderEnabled (Network): false\nisProviderEnabled (GPS): false\nisProviderEnabled (PASSIVE_PROVIDER): true\nisProviderEnabled (FUSED_PROVIDER): false\n```. Thanks @dariuszseweryn . You're guys are the best. Looking forward to have the release notes and available to import into gradle. . ",
    "oerjanti": "After updating Studio from 2.x to 3.0.1 I got it working by updating Gradle version manually in:\nFile > Project Structure > Project\nGradle version: 4.3\nAndroid plugin version: 3.0.1\nI did not get the error about module import but I hope this helps. ",
    "irshadbabar": "Try to see if you haven't installed the git on your PC. If not then install that would probably resolve your problem.. ",
    "Afaquejaya": "\nSummary\nCreating a new Android Studio 3 project from GitHub site doesn't work\nLibrary version\n1.4.3\nPreconditions\nAndroid Studio 3.0.1\nSteps to reproduce actual result\n\n\nIn the \"Welcome to Android Studio\" window, select \"check out project from Version Control\", selecting GitHub\n\n\nFor the Git Repository URL, use \"https://github.com/Polidea/RxAndroidBle.git\" (Test button reports success)\n\n\nClick \"Clone\" and select \"Yes\" to creating a studio project\n\n\nIn the \"Import Project\" window, leave \"Import project from external model\" selected, and leave the first \"Gradle\" selected in the window (there are 2 identical listings for \"Gradle\")\n\n\nClick \"Next\", and in the next window, leave the recommended \"Use default Gradle wrapper\" selected; click \"Finish\"\n\n\nAndroid Studio starts creating a project\n\n\nMinimum code snippet reproducing the issue\nN/A\nLogs from the application running with setting RxBleLog.setLogLevel(RxBleLog.VERBOSE)\nN/A\nActual result\nA message window appears: \"The modules below are not imported from Gradle anymore. Check those to be removed from the ide project too:\" (only RxAndroidBle is shown, with its box checked)\nExpected result\nA working project is created.\n\nUnable to get Gradle wrapper properties from:\n/root/Desktop/Android-App-for-e-notice-board/gradle/wrapper/gradle-wrapper.properties\n. ",
    "andyalbert": "I mean that the memory allocation keeps increasing without being released till it forces a GC action, is that usual ?. Hmm, so that's just a usual behaviour as the ble device is sending a lot of data, that describes the problem then, Thanks! , but regarding the notification itself, why is it passing Observable<Observable<byte[]>> instead of just Observable<byte[]>? I thought either the notification should send a stream of data, or either the data(byte[]) itself be streamed, but both?. Thanks a lot, it's all clear now.. ",
    "yusufonderd": "Hi again. \nI'm facing this issue on version 1.4.3.\nscanSubscription = rxClient.scanBleDevices(scanSettings)\n                .subscribe({\n                  val manufacturerData =   it.scanRecord.manufacturerSpecificData\n                  if(manufacturerData == null){\n                          Log.i(TAG,\"manufacturerSpecificData is null\")\n                 }\n                 },{\n                     it.printStackTrace();\n                 })\nLogs: \nBluetoothScanningService :  manufacturer data is null\n. ",
    "ened": "@uKL You probably already know but the sonatype snapshot repository (https://oss.sonatype.org/content/repositories/snapshots/com/polidea/rxandroidble/rxandroidble/) has a 1.6.0-SNAPSHOT version already, yet that is the incorrect one.\n. Done.. ",
    "JiWenBo": "When I turn off the bluetooth and then open it, it's READY to go back. ",
    "martiwi": "@dariuszseweryn I've opened a PR. Please feel free to comment.. Hi @dariuszseweryn, thank you!!! I don't see it in the 1.5.0-SNAPSHOT do you know when it will be available. I checked it from the version uploaded this morning: rxandroidble-1.5.0-20180312.055735-7.aar.. Hi @uKL from the source within the archive file, it is not unfortunately. Also this file has been generated before the branch being merged into master .. Ok, I've figured out, https://oss.sonatype.org/content/repositories/snapshots/com/polidea/rxandroidble2 instead of https://oss.sonatype.org/content/repositories/snapshots/com/polidea/rxandroidble. My bad! Any idea when this will be part of rxandroidble2 ? Thanks again for all your hard work guys!. I have pushed my latest modifications accordingly to your remarks.. Hi there,\nI didn't had enough time available to understand correctly how your unit test are designed and how they are working. I've been able to update the current unit tests to have latest changes of this feature. But to test that retry strategy is properly working, I did not managed to. Any help is welcome to speed up on this. Thanks.. Hey @uKL it was already selected, @dariuszseweryn was able to publish before. I've unselected it, and re-selected it. Is it better now ?. Hi @dariuszseweryn - I've added one unit test but I am not sure I am using it right as when running the test in debug mode, the second batch is failing to write but retryWhen Observable is triggered twice. Meaning Characteristic#setValue() is called with first batch number and not the second. Can you check what am I doing wrong? Thanks.. Ok.. You mean we should not have a separated counter in this Operation class at all?. Indeed, that makes sense.. I came up with the following retryWhen() function:\n```java\nprivate static Func1, Observable<?>> retryOperationStrategy(\n            final WriteOperationRetryStrategy writeOperationRetryStrategy,\n            final ByteBuffer byteBuffer,\n            final int batchSize) {\n        return new Func1, Observable<?>>() {\n            @Override\n            public Observable<?> call(Observable<? extends Throwable> observable) {\n                return observable\n                        .flatMap(applyRetryStrategy())\n                        .map(replaceByteBufferPositionForRetry());\n            }\n        @NonNull\n        private Func1<Throwable, Observable<WriteOperationRetryStrategy.LongWriteFailure>> applyRetryStrategy() {\n            return new Func1<Throwable, Observable<WriteOperationRetryStrategy.LongWriteFailure>>() {\n                @Override\n                public Observable<WriteOperationRetryStrategy.LongWriteFailure> call(Throwable cause) {\n                    if (!(cause instanceof BleException)) {\n                        return Observable.error(cause);\n                    }\n\n                    final int failedBatchNumber = (byteBuffer.position() - batchSize) / batchSize;\n                    final WriteOperationRetryStrategy.LongWriteFailure longWriteFailure =\n                            new WriteOperationRetryStrategy.LongWriteFailure(failedBatchNumber, (BleException) cause);\n\n                    return writeOperationRetryStrategy.call(Observable.just(longWriteFailure));\n                }\n            };\n        }\n\n        @NonNull\n        private Func1<WriteOperationRetryStrategy.LongWriteFailure, Object> replaceByteBufferPositionForRetry() {\n            return new Func1<WriteOperationRetryStrategy.LongWriteFailure, Object>() {\n                @Override\n                public Object call(WriteOperationRetryStrategy.LongWriteFailure longWriteFailure) {\n                    final int newBufferPosition = longWriteFailure.getBatchNumber() * batchSize;\n                    byteBuffer.position(newBufferPosition);\n                    return longWriteFailure;\n                }\n            };\n        }\n    };\n}\n\n. Sure, done!. Ok for `BleGattCharacteristicException` but they are already both final :). Ok.. How close am I with something like that :) :java\n            @Override\n            public Observable<?> call(Observable<? extends Throwable> emittedOnWriteFailure) {\n                return writeOperationRetryStrategy.call(\n                        emittedOnWriteFailure.map(mapToLongWriteFailureObject())\n                )\n                        .doOnNext(replaceByteBufferPositionForRetry());\n            }\nNo other `Throwable` than `BleException` can be emitted?. Sorry, I've pushed :). You mean merge those two?\n.flatMap(canRetryError())\n.map(toLongWriteFailureObject())\n. I've split them based on comment: https://github.com/Polidea/RxAndroidBle/pull/357#discussion_r162981644 :). Ok :). Ok.. Ok.. Indeed, but what advantage compared to something like that instead:\nif (byteBuffer.hasRemaining()) {\n    return (byteBuffer.position() - batchSize) / batchSize;\n} else {\n    return byteBuffer.position() / batchSize;\n}\n```. ",
    "mohsenoid": "Dear @dariuszseweryn \nThanks for your fast reply,\nDo you have any idea why the same phone without any changes works fine when I change setting back to CALLBACK_TYPE_ALL_MATCHES?. based on this doc\nhttps://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling\nit would be nice if the library avoid the exceptions like this\n// in some library\ntry {\n   doSomethingBlockingly()\n} catch (InterruptedException ex) {\n   // check if the interrupt is due to cancellation\n   // if so, no need to signal the InterruptedException\n   if (!disposable.isDisposed()) {\n      observer.onError(ex);\n   }\n}. ",
    "budius": "Thanks for the quick reply, I guess I missed the || !autoConnect part of the if statement.\nSo that means that for autoconnect = false it's just a matter of using or not the TRANSPORT_LE flag.\nThaks. ",
    "TimoPtr": "I'm able to reproduce the bug with other smartphone if I disable in setting Bluetooth scanning (which use to improve location by allowing system apps and services to detest Bluetooth devices at any time). Without the library, I investigate a fix where I first scan an use the objet return in the scan (it failed if I use getRemoteDevice) it works with my custom Gatt connection. I'm trying to do it with RxAndroidBLE. If It's works I will post the fix . So it's work if we use the RxBleDevice create by scanBleDevice, if using rxBleClient.getBleDevice() it's not working. Can we add something to automatically scan ?. From Gatt status Error code 133.\nFor now I was able to fix it by scanning. In onDestroy. The sample code doesn't handle it but in my code I have a boolean which avoid it and I keep only one subscription of the connection. Oh wait ! When an error occur I don't have to dispose or am I wrong ?. But if the onError is trigger you don't need to ? (If I power off the bluetooth it will trigger an exception catch inside the onError, I was assuming that when an error occur the subscription is disposed). Hum so I update my test case and I end up with a BleAlreadyConnectedException (on galaxy s8, on Honor I can't connect to the device if I don't scan before). \nThe scenario is \n- Connect to a device by its MAC\n- Power off the bluetooth (receive a BleDisconnectedException)\n- Power on the bluetooh \n- click on the button \n- Receive BleAlreadyConnectedException\nSample : \n```\n      val rxBleClient = RxBleClient.create(this)\n    val device = rxBleClient.getBleDevice(\"XXXXXXXX\")\n\n\n    button.setOnClickListener {\n        Log.d(TAG, \"click\")\n        button.isEnabled = false\n        Log.d(TAG, \"clear\")\n        subscriptor?.dispose()\n        subscriptor = null\n        subscriptor = RxJavaInterop.toV2Observable(device?.establishConnection(false)?.doOnNext {\n            Log.i(TAG, \"connected RX\")\n        })?.observeOn(AndroidSchedulers.mainThread())?.subscribe({\n            Log.w(TAG, \"connected\")\n        }, {\n            button.isEnabled = true\n            Log.e(TAG, \"error\", it)\n        })\n    }\n\n```\nTo fix it on every device I made this : \n```\n val rxBleClient = RxBleClient.create(this)\n    button.setOnClickListener {\n        button.isEnabled = false\n        Log.d(TAG, \"clear\")\n        subscriptor?.dispose()\n        subscriptor = null\n        subscriptor = RxJavaInterop.toV2Observable(rxBleClient.scanBleDevices(ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build())\n                .doOnSubscribe {\n                    Log.d(TAG, \"Start scan to find device because not present in bounded devices list\")\n                }.map { result -> result?.bleDevice }\n                .doOnNext { device ->\n                    Log.v(TAG, \"device found ${device?.name} (${device?.macAddress})\")\n                }\n                .filter { it!!.macAddress == \"XXXXXXXXX\" }\n                .flatMap { it!!.establishConnection(false) })?.observeOn(AndroidSchedulers.mainThread())\n                ?.subscribe({\n                    Log.w(TAG, \"connected\")\n                }, {\n                    button.isEnabled = true\n                    Log.e(TAG, \"error\", it)\n                })\n\n    }\n\n```\n. The problem after Bluetooth adapter disable, appear only on a specific phone Honor 8. It was working fine with Pixel and S8. I have the same code, so I assume maybe it's a location problem ? I only ask for COARSE permission.  . My bad ... In my test application I was on an old version of rxAndroidBLE 1.4.0 and interop 0.10.6 .... So for now I don't have BleAlreadyConnectedException but with the Honor it's just impossible to connect I after Bluetooth adapter off ... Except if I start a scan maybe it's a problem from the manufacturer. I will end up by always scanning before connected ... but it add times ... . ",
    "RAM512": "@uKL, can you add ReplyingShare and .firstOrError() information to Readme.md please?\nI'm new in ReactiveX and it's hard for me to understand use cases. For example in example4_characteristic/CharacteristicOperationExampleActivity you use .firstOrError() in onReadClick() and onWriteClick() but not in onNotifyClick().. ",
    "eimermusic": "Then I am not alone.\nI was just about to paste an almost identical stacktrace.\nI too have a call to connect again directly from my onConnectionFailure handler because I generally want to re-establish the connection ASAP. \nE.g. this is the meat of my connection method.\nkotlin\nval connectionSubscription = device.establishConnection(false)\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .doOnDispose({onDisposeConnectionSubscription(device)})\n                    .subscribe({ onConnectionReceived(device, it) }, { onConnectionFailure(device, it) })\nSide note: doOnDispose does not appear to be called in the way doOnUnsubscribe is called in rx1 land. It is in fact not called at all for me, but I have also not looked enough at the RXJava guides to know if it should be.\nJust in case my trace adds some value, here it is:\n```\n03-08 14:56:49.556 7264-7480 E/AndroidRuntime: FATAL EXCEPTION: pool-6-thread-1\n                                               Process: com.example.rxble, PID: 7264\n                                               io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 54:6C:0E:7B:3E:98\n                                                   at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:573)\n                                                   at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n                                                   at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)\n                                                   at io.reactivex.Observable.subscribe(Observable.java:11442)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n                                                   at io.reactivex.internal.util.NotificationLite.accept(NotificationLite.java:246)\n                                                   at io.reactivex.internal.operators.observable.ObservableCache$ReplayDisposable.replay(ObservableCache.java:350)\n                                                   at io.reactivex.internal.operators.observable.ObservableCache.subscribeActual(ObservableCache.java:85)\n                                                   at io.reactivex.Observable.subscribe(Observable.java:11442)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\n                                                   at io.reactivex.Observable.subscribe(Observable.java:11442)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n                                                   at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java:107)\n                                                   at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:36)\n                                                   at io.reactivex.Observable.subscribe(Observable.java:11442)\n                                                   at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\n                                                   at io.reactivex.Observable.subscribe(Observable.java:11442)\n                                                   at io.reactivex.internal.operators.observable.ObservableObserveOn.subscribeActual(ObservableObserveOn.java:45)\n                                                   at io.reactivex.Observable.subscribe(Observable.java:11442)\n                                                   at io.reactivex.internal.operators.observable.ObservableRetryPredicate$RepeatObserver.subscribeNext(ObservableRetryPredicate.java:111)\n                                                   at io.reactivex.internal.operators.observable.ObservableRetryPredicate$RepeatObserver.onError(ObservableRetryPredicate.java:92)\n                                                   at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.checkTerminated(ObservableObserveOn.java:276)\n                                                   at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.drainNormal(ObservableObserveOn.java:172)\n                                                   at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.run(ObservableObserveOn.java:252)\n                                                   at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)\n                                                   at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)\n                                                   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n                                                   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n                                                   at java.lang.Thread.run(Thread.java:762)\n                                                Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 54:6C:0E:7B:3E:98\n                                                   at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n                                                   at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:228)\n                                                   at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n                                                   at android.os.Binder.execTransact(Binder.java:573)\n. Maybe. I might try taking the project sample app and modifying it.\nFor me the crashes are not reliably reproducible. It most reliably happens when I:\n\u2022 Simply rip the battery out of the BLE device. \n\u2022 Wait for the eternity that Android seems to prefer before noticing this. \n\u2022 The app will not try to connect, fail, connect, fail... \n\u2022 Re-insert battery, powering up the device.\n\u2022 The re-establishing of the connection at this point can sometimes work just fine,  but more often than not it will throw this exception when calling establishConnection.\nRe-inserting the battery before the phone notices the lost connection can also cause some very \"interesting\" behavior.. Seems like you can also get this exception by simply attempting to connect and re-connect in this way to a MAC address that you cannot reach. No need to actually successfully connect first.. ",
    "Onkarn92": "rxandroidble2 v1.5.0\n@uKL Got the same error when trying to retry the connection. Any updates?. ",
    "bleeding182": "I just encountered the same error, but with a different stack trace (I'm on version com.polidea.rxandroidble2:rxandroidble:1.5.0) It appears pretty much randomly after some connecting and disconnecting.\nFATAL EXCEPTION: Binder:19392_4\n Process: com.some.project, PID: 19392\n io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from EF:65:4B:9C:9F:61\n     at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:310)\n     at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.dispose(ObservableFlatMap.java:583)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:509)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.dispose(ObservableFlatMap.java:307)\n     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.dispose(ObservableObserveOn.java:146)\n     at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n     at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n     at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n     at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\n     at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n     at io.reactivex.disposables.SerialDisposable.dispose(SerialDisposable.java:81)\n     at com.polidea.rxandroidble2.internal.connection.MtuWatcher.onConnectionUnsubscribed(MtuWatcher.java:39)\n     at com.polidea.rxandroidble2.internal.connection.ConnectorImpl$1$1.run(ConnectorImpl.java:71)\n     at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.runFinally(ObservableDoFinally.java:144)\n     at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:88)\n     at io.reactivex.internal.observers.DisposableLambdaObserver.onError(DisposableLambdaObserver.java:64)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onError(ObservableFlatMap.java:288)\n     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.tryOnError(ObservableCreate.java:85)\n     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onError(ObservableCreate.java:73)\n     at com.polidea.rxandroidble2.internal.serialization.FIFORunnableEntry$1.onError(FIFORunnableEntry.java:65)\n     at io.reactivex.internal.operators.observable.ObservableUnsubscribeOn$UnsubscribeObserver.onError(ObservableUnsubscribeOn.java:70)\n     at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onError(ObservableSubscribeOn.java:63)\n     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.tryOnError(ObservableCreate.java:85)\n     at com.polidea.rxandroidble2.internal.util.DisposableUtil$3.onError(DisposableUtil.java:60)\n     at io.reactivex.internal.operators.single.SingleDoFinally$DoFinallyObserver.onError(SingleDoFinally.java:81)\n     at io.reactivex.internal.operators.single.SingleTimeout$TimeoutMainObserver.onError(SingleTimeout.java:142)\n     at io.reactivex.internal.operators.single.SingleCreate$Emitter.tryOnError(SingleCreate.java:95)\n     at com.polidea.rxandroidble2.internal.util.DisposableUtil$1.onError(DisposableUtil.java:24)\n     at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onError(FlowableElementAtSingle.java:101)\n     at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.checkTerminate(FlowableFlatMap.java:566)\nat io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.drainLoop(FlowableFlatMap.java:374)\n     at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.drain(FlowableFlatMap.java:366)\n     at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.innerError(FlowableFlatMap.java:605)\n     at io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.onError(FlowableFlatMap.java:668)\n     at io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.onError(SingleToFlowable.java:68)\n     at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onError(ObservableElementAtSingle.java:104)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:495)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:571)\n     at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n     at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)\n     at io.reactivex.Observable.subscribe(Observable.java:11442)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n     at io.reactivex.internal.util.NotificationLite.accept(NotificationLite.java:246)\n     at io.reactivex.internal.operators.observable.ObservableCache$ReplayDisposable.replay(ObservableCache.java:350)\n     at io.reactivex.internal.operators.observable.ObservableCache$CacheState.onNext(ObservableCache.java:225)\n     at io.reactivex.internal.operators.observable.ObservableElementAt$ElementAtObserver.onNext(ObservableElementAt.java:87)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmit(ObservableFlatMap.java:262)\n     at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onNext(ObservableFlatMap.java:559)\n     at com.jakewharton.rxrelay2.PublishRelay$PublishDisposable.onNext(PublishRelay.java:176)\n     at com.jakewharton.rxrelay2.PublishRelay.accept(PublishRelay.java:141)\n     at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onDisconnectedException(DisconnectionRouter.java:86)\n     at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:229)\n     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n     at android.os.Binder.execTransact(Binder.java:573)\n  Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from EF:65:4B:9C:9F:61\n     at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\u00a0\n     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:229)\u00a0\n     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\u00a0\n     at android.os.Binder.execTransact(Binder.java:573)\n\nIt seems to me this may be caused due to the isDisposed() check being done prematurely, and that this could be fixed by additionally moving the check into the callback (onError etc) or replacing it with tryOnError instead. At least in my specific case.. Hello!\nSure can do\n05-17 14:33:10.291 21963-21963/? I/zygote64: Late-enabling -Xcheck:jni\n05-17 14:33:10.423 21963-21963/com.myapp I/MultiDex: VM with version 2.1.0 has multidex support\n    Installing application\n    VM has multidex support, MultiDex support library is disabled.\n05-17 14:33:10.688 21963-21968/com.myapp I/zygote64: Do partial code cache collection, code=30KB, data=24KB\n05-17 14:33:10.689 21963-21968/com.myapp I/zygote64: After code cache collection, code=28KB, data=23KB\n    Increasing code cache capacity to 128KB\n05-17 14:33:10.801 21963-21968/com.myapp I/zygote64: Do partial code cache collection, code=61KB, data=44KB\n    After code cache collection, code=61KB, data=44KB\n05-17 14:33:10.802 21963-21968/com.myapp I/zygote64: Increasing code cache capacity to 256KB\n05-17 14:33:11.109 21963-21968/com.myapp I/zygote64: Do full code cache collection, code=124KB, data=82KB\n05-17 14:33:11.110 21963-21968/com.myapp I/zygote64: After code cache collection, code=101KB, data=50KB\n05-17 14:33:11.174 21963-21968/com.myapp I/zygote64: Do partial code cache collection, code=124KB, data=74KB\n    After code cache collection, code=124KB, data=74KB\n    Increasing code cache capacity to 512KB\n05-17 14:33:11.470 21963-21968/com.myapp I/zygote64: Do full code cache collection, code=250KB, data=162KB\n05-17 14:33:11.471 21963-21968/com.myapp I/zygote64: After code cache collection, code=189KB, data=108KB\n05-17 14:33:11.543 21963-21968/com.myapp I/zygote64: Do partial code cache collection, code=193KB, data=130KB\n    After code cache collection, code=193KB, data=130KB\n    Increasing code cache capacity to 1024KB\n05-17 14:33:11.788 21963-21963/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ScanOperationApi21(67972662)\n05-17 14:33:11.792 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  ScanOperationApi21(67972662)\n05-17 14:33:11.799 21963-22007/com.myapp I/RxBle#QueueOperation: Scan operation is requested to start.\n05-17 14:33:11.802 21963-22007/com.myapp D/BluetoothAdapter: isLeEnabled(): ON\n05-17 14:33:11.809 21963-21976/com.myapp D/BluetoothLeScanner: onScannerRegistered() - status=0 scannerId=8 mScannerId=0\n05-17 14:33:11.819 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FINISHED ScanOperationApi21(67972662) in 29 ms\n05-17 14:33:12.243 21963-22019/com.myapp D/OpenGLRenderer: HWUI GL Pipeline\n05-17 14:33:12.277 21963-21968/com.myapp I/zygote64: Do full code cache collection, code=501KB, data=321KB\n05-17 14:33:12.279 21963-21968/com.myapp I/zygote64: After code cache collection, code=472KB, data=274KB\n05-17 14:33:12.323 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(58323852)\n05-17 14:33:12.325 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(58323852)\n05-17 14:33:12.334 21963-22007/com.myapp D/BluetoothGatt: connect() - device: D1:50:31:C8:CF:A0, auto: false\n    registerApp()\n    registerApp() - UUID=f632e66c-793e-42e8-a140-7c04d9702e82\n05-17 14:33:12.337 21963-21976/com.myapp D/BluetoothGatt: onClientRegistered() - status=0 clientIf=9\n05-17 14:33:12.370 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(58323852) in 45 ms\n05-17 14:33:12.370 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(225020629)\n05-17 14:33:12.371 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:33:12.372 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(225020629)\n05-17 14:33:12.372 21963-22023/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:33:12.374 21963-22007/com.myapp D/BluetoothManager: getConnectionState()\n    getConnectedDevices\n05-17 14:33:12.377 21963-22007/com.myapp D/BluetoothGatt: close()\n    unregisterApp() - mClientIf=9\n05-17 14:33:12.381 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(225020629) in 10 ms\n05-17 14:33:12.387 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(210321293)\n05-17 14:33:12.389 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(210321293)\n05-17 14:33:12.394 21963-22007/com.myapp D/BluetoothGatt: connect() - device: D1:50:31:C8:CF:A0, auto: false\n    registerApp()\n    registerApp() - UUID=2128571d-0176-4869-ae18-d22db1e4746c\n05-17 14:33:12.396 21963-21975/com.myapp D/BluetoothGatt: onClientRegistered() - status=0 clientIf=9\n05-17 14:33:12.399 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(149148485)\n05-17 14:33:12.485 21963-22019/com.myapp I/Adreno: QUALCOMM build                   : 8e59954, I0be83d0d26\n    Build Date                       : 09/22/17\n    OpenGL ES Shader Compiler Version: EV031.21.02.00\n    Local Branch                     : O17A\n    Remote Branch                    : \n    Remote Branch                    : \n    Reconstruct Branch               : \n05-17 14:33:12.485 21963-22019/com.myapp D/vndksupport: Loading /vendor/lib64/hw/gralloc.msm8994.so from current namespace instead of sphal namespace.\n05-17 14:33:12.494 21963-22019/com.myapp I/Adreno: PFP: 0x00000000, ME: 0x00000000\n05-17 14:33:12.506 21963-22019/com.myapp I/zygote64: android::hardware::configstore::V1_0::ISurfaceFlingerConfigs::hasWideColorDisplay retrieved: 0\n05-17 14:33:12.507 21963-22019/com.myapp I/OpenGLRenderer: Initialized EGL, version 1.4\n05-17 14:33:12.507 21963-22019/com.myapp D/OpenGLRenderer: Swap behavior 2\n05-17 14:33:12.634 21963-21968/com.myapp I/zygote64: Do partial code cache collection, code=499KB, data=315KB\n05-17 14:33:12.636 21963-21968/com.myapp I/zygote64: After code cache collection, code=498KB, data=315KB\n    Increasing code cache capacity to 2MB\n05-17 14:33:12.652 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:33:12.653 21963-22023/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:33:12.654 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(141613014)\n05-17 14:33:12.658 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(210321293) in 267 ms\n05-17 14:33:12.659 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(141613014)\n05-17 14:33:12.659 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(149148485)\n05-17 14:33:12.661 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(257116759)\n05-17 14:33:12.661 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D4:BC:3D:A1:75:D6)\n05-17 14:33:12.662 21963-22025/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:33:12.663 21963-22007/com.myapp D/BluetoothManager: getConnectionState()\n    getConnectedDevices\n05-17 14:33:12.666 21963-22007/com.myapp D/BluetoothGatt: close()\n    unregisterApp() - mClientIf=9\n05-17 14:33:12.671 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(141613014) in 11 ms\n05-17 14:33:12.672 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(257116759)\n05-17 14:33:12.675 21963-22007/com.myapp W/RxBle#QueueOperation: Disconnect operation has been executed but GATT instance was null - considering disconnected.\n05-17 14:33:12.678 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(257116759) in 6 ms\n05-17 14:33:12.682 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(166104284)\n05-17 14:33:12.683 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:33:12.684 21963-21982/com.myapp D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(166104284)\n05-17 14:33:12.684 21963-22025/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:33:12.685 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FIFORunnableEntry\n05-17 14:33:12.686 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(62757576)\n05-17 14:33:12.697 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(234373347)\n05-17 14:33:12.705 21963-22019/com.myapp D/vndksupport: Loading /vendor/lib64/hw/android.hardware.graphics.mapper@2.0-impl.so from current namespace instead of sphal namespace.\n05-17 14:33:12.706 21963-22019/com.myapp D/vndksupport: Loading /vendor/lib64/hw/gralloc.msm8994.so from current namespace instead of sphal namespace.\n05-17 14:33:12.711 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(64283916)\n05-17 14:33:13.000 21963-21968/com.myapp I/zygote64: Compiler allocated 4MB to compile void android.view.View.<init>(android.content.Context, android.util.AttributeSet, int, int)\n05-17 14:33:17.008 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(247340328)\n05-17 14:33:18.597 21963-21968/com.myapp I/zygote64: Compiler allocated 6MB to compile void android.view.ViewRootImpl.performTraversals()\n05-17 14:33:31.584 21963-21968/com.myapp I/zygote64: Do full code cache collection, code=1004KB, data=620KB\n05-17 14:33:31.592 21963-21968/com.myapp I/zygote64: After code cache collection, code=949KB, data=545KB\n05-17 14:33:52.361 21963-21968/com.myapp I/zygote64: Do partial code cache collection, code=1003KB, data=584KB\n05-17 14:33:52.363 21963-21968/com.myapp I/zygote64: After code cache collection, code=1003KB, data=584KB\n    Increasing code cache capacity to 3MB\n05-17 14:35:45.562 21963-21974/com.myapp I/zygote64: Background concurrent copying GC freed 201316(8MB) AllocSpace objects, 0(0B) LOS objects, 50% free, 12MB/24MB, paused 627us total 115.785ms\n05-17 14:36:00.449 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(234373347)\n05-17 14:36:00.452 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(100371455)\n05-17 14:36:00.462 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:36:00.463 21963-22025/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:00.470 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(64283916)\n05-17 14:36:00.474 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(117210572)\n05-17 14:36:00.474 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D4:BC:3D:A1:75:D6)\n05-17 14:36:00.479 21963-22023/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:00.486 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(247340328)\n05-17 14:36:00.490 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(262006805)\n05-17 14:36:00.490 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F2:CE:8F:20:BD:8A)\n05-17 14:36:00.491 21963-22041/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:00.506 21963-22007/com.myapp I/RxBle#CancellableDisposable: Scan operation is requested to stop.\n05-17 14:36:00.511 21963-22007/com.myapp D/BluetoothAdapter: isLeEnabled(): ON\n05-17 14:36:00.966 21963-21963/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ScanOperationApi21(121313488)\n05-17 14:36:00.990 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(53263165)\n05-17 14:36:00.991 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(53263165)\n05-17 14:36:00.993 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(7443587)\n05-17 14:36:00.993 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:36:00.994 21963-22041/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.006 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(61150453)\n05-17 14:36:01.020 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(221845730)\n05-17 14:36:01.021 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(61150453)\n05-17 14:36:01.021 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:36:01.022 21963-22041/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.022 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(129016947)\n05-17 14:36:01.023 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(221845730)\n05-17 14:36:01.024 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(205733680)\n05-17 14:36:01.025 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F2:CE:8F:20:BD:8A)\n05-17 14:36:01.026 21963-22023/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.037 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(241839851)\n05-17 14:36:01.051 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(5020701)\n05-17 14:36:01.068 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(152105438)\n05-17 14:36:01.174 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(241839851)\n05-17 14:36:01.174 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:36:01.175 21963-22023/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.176 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(38090177)\n05-17 14:36:01.177 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(5020701)\n05-17 14:36:01.179 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(35578214)\n05-17 14:36:01.180 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F2:CE:8F:20:BD:8A)\n05-17 14:36:01.181 21963-22041/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.181 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(152105438)\n05-17 14:36:01.182 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D4:BC:3D:A1:75:D6)\n05-17 14:36:01.183 21963-22025/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.185 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(179780775)\n05-17 14:36:01.205 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(142203897)\n05-17 14:36:01.207 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(142203897)\n05-17 14:36:01.209 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(29170079)\n05-17 14:36:01.210 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:36:01.214 21963-22025/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.220 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(140906801)\n05-17 14:36:01.230 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(228816802)\n05-17 14:36:01.232 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(140906801)\n05-17 14:36:01.233 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(106527795)\n05-17 14:36:01.234 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (D1:50:31:C8:CF:A0)\n05-17 14:36:01.236 21963-22024/com.myapp D/RxBle#ClientOperationQueue$2: REMOVED  ConnectOperation(228816802)\n05-17 14:36:01.236 21963-22024/com.myapp I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (F2:CE:8F:20:BD:8A)\n05-17 14:36:01.237 21963-22025/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.238 21963-22041/com.myapp D/RxBle#Executors$RunnableAdapter: Terminated.\n05-17 14:36:01.239 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(25998697)\n05-17 14:36:01.253 21963-21968/com.myapp I/zygote64: Compiler allocated 7MB to compile void android.widget.TextView.<init>(android.content.Context, android.util.AttributeSet, int, int)\n05-17 14:36:01.253 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(115228331)\n05-17 14:36:01.268 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(59387357)\n05-17 14:36:01.277 21963-22024/com.myapp D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(159034526)\n\nYou can see where it deadlocks\n\n05-17 14:33:12.685 21963-21982/com.myapp D/RxBle#ClientOperationQueue: FIFORunnableEntry\n\nand after that I put the app in the background and foreground once more, which triggered all those removals, and new queue entries afterwards, since I'd usually close everything while in background and reconnect on open.\nThanks for looking into this. @DariuszAniszewski Hey there!\nYes, been debugging today, can't reproduce it with this fix.. @DariuszAniszewski No, I did not look into writing any tests\nThe exception seems to be thrown when downstream is already disposed, hence it would immediately call unregister before we even registered.\nBy moving the unregister callback to the end this can't happen since we will always have registered by then. ",
    "biodroid": "Hello, \nI got the same undeliverable exception after deliberately disconnecting my connected object, using the 1.6.0-SNAPSHOT.\n```  \nio.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 00:00:00:00:00:00\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onError(ObservableFlatMap.java:294)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:506)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:335)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onError(ObservableFlatMap.java:292)\n        at io.reactivex.internal.operators.observable.ObservableFlatMapSingle$FlatMapSingleObserver.drainLoop(ObservableFlatMapSingle.java:239)\n        at io.reactivex.internal.operators.observable.ObservableFlatMapSingle$FlatMapSingleObserver.drain(ObservableFlatMapSingle.java:210)\n        at io.reactivex.internal.operators.observable.ObservableFlatMapSingle$FlatMapSingleObserver.onError(ObservableFlatMapSingle.java:124)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:87)\n        at io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver.onError(ObservableDoOnEach.java:119)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:87)\n        at io.reactivex.internal.operators.observable.ObservableUnsubscribeOn$UnsubscribeObserver.onError(ObservableUnsubscribeOn.java:70)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onError(ObservableSubscribeOn.java:63)\n        at io.reactivex.internal.operators.observable.ObservableDoFinally$DoFinallyObserver.onError(ObservableDoFinally.java:87)\n        at io.reactivex.internal.observers.DisposableLambdaObserver.onError(DisposableLambdaObserver.java:64)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:506)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:335)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:582)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:506)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:335)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:582)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:506)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:335)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:582)\n        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)\n        at io.reactivex.Observable.subscribe(Observable.java:12005)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:165)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n04-04 16:42:26.161 11440-11477/my.package E/MyClassTest:     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onNext(ObservableCreate.java:67)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.notifySubscribersAboutException(DisconnectionRouter.java:125)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onExceptionOccurred(DisconnectionRouter.java:114)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onDisconnectedException(DisconnectionRouter.java:100)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:249)\n        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:725)\n        at android.bluetooth.BluetoothGatt.-wrap0(Unknown Source:0)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:244)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:697)\n     Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 00:00:00:00:00:00\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\u00a0\n        at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:249)\u00a0\n        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:725)\u00a0\n        at android.bluetooth.BluetoothGatt.-wrap0(Unknown Source:0)\u00a0\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:244)\u00a0\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\u00a0\n        at android.os.Binder.execTransact(Binder.java:697)\u00a0\n. ",
    "szymonkozak": "I have the same problem, but in another place (ConnectionOperationQueueImpl.flushQueue)\n05-16 16:45:45.496 27429-27742/com.mypackage E/AndroidRuntime: FATAL EXCEPTION: pool-4-thread-1\n    Process: com.mypackage, PID: 27429\n    io.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from stripped device address\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable$FlatMapCompletableMainObserver.onError(ObservableFlatMapCompletableCompletable.java:130)\n        at io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable$FlatMapCompletableMainObserver.innerError(ObservableFlatMapCompletableCompletable.java:165)\n        at io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable$FlatMapCompletableMainObserver$InnerObserver.onError(ObservableFlatMapCompletableCompletable.java:183)\n        at io.reactivex.internal.operators.completable.CompletableFromSingle$CompletableFromSingleObserver.onError(CompletableFromSingle.java:41)\n        at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onError(ObservableElementAtSingle.java:104)\n        at io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther$DelayObserver$OnComplete.onError(ObservableDelaySubscriptionOther.java:99)\n        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.tryOnError(ObservableCreate.java:85)\n        at com.polidea.rxandroidble2.internal.serialization.ConnectionOperationQueueImpl.flushQueue(ConnectionOperationQueueImpl.java:92)\n        at com.polidea.rxandroidble2.internal.serialization.ConnectionOperationQueueImpl.access$200(ConnectionOperationQueueImpl.java:34)\n        at com.polidea.rxandroidble2.internal.serialization.ConnectionOperationQueueImpl$1.run(ConnectionOperationQueueImpl.java:83)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n        at java.lang.Thread.run(Thread.java:818)\n     Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from stripped device address\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:181)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:453)\nVersion 1.6.0-SNAPSHOT (but bug appears also in 1.5.0-SNAPSHOT). ",
    "jaesga": "@dariuszseweryn Where do you place that code for the workaround? Maybe inside your Applicatio class?. ",
    "cuiti": "@DariuszAniszewski I can't seem to compile the workaround, since throw error causes an UnhandledException error. Any ideas?. ",
    "rzetzsche": "@cuiti Yes that is right. You get an unhandled exception when you try to rethrow the error in Java. \nI'm using the folowing in my project:\n```java\nRxJavaPlugins.setErrorHandler(error -> {\n            if (error instanceof UndeliverableException && error.getCause() instanceof BleException) {\n                return; // ignore BleExceptions as they were surely delivered at least once\n            } else {\n                throw new Exception(error);\n            }\n        });. ",
    "Rishvanth-Rishi": "though I used com.polidea.rxandroidble2:rxandroidble:1.5.0-SNAPSHOT still, I'm getting the same error(failed to resolve).. ",
    "Lzxe92": "do you know the way?. ",
    "NiallBegley": "@uKL I have limited devices to test on but I've only seen it on my old Samsung Note 4.  Haven't seen it on a co-workers Nexus 6 or OnePlus Three.  I'm fairly new to BLE so i'm a little inexperienced, but I don't believe my GATT characteristics are particularly complex.\n@dariuszseweryn Sure, let me elaborate a little bit more.  The interaction between the phone and the microprocessor for this project is supposed to be a fairly long back and forth authentication process.  The phone has to perform a long write to the microprocessor to send some data for the microprocessor to authenticate and, when done, the microprocessor then has to send a similar amount of data back to the phone.  The phone and the microprocessor then do a few more writes and reads back and forth to generate a shared secret before the microprocessor sends over an encrypted payload.  Once the phone receives the payload the connection is automatically severed.\nSo you'll see in the log file that the first time I perform this flow (when it worked correctly) I wait a few seconds after the BLE scanning stopped before I initiated the connection to the microprocessor.  Once the connection is made the phone performs a long write (line 4771).  In this project I have to write out a quick 5 bytes indicating the length of the outgoing message to the microprocessor so it knows how much to expect, which is why you see a 5 byte write at line 4783 followed by the full long write at 4821.  After that you can see at line 4917 that the microprocessor sends back a message indicating it has finished processing what the phone had previously sent and we're free to move on to the next step.  I won't go through every step here, but you get the idea.  We go back and forth a few more times before you see the payload is sent and the connection is automatically disconnected (5598).\nNow, on the second run, I select the device to connect to from the phone before the BLE scanning is complete and you see that I unsubscribe from the scanning subscription before immediately launching into the same flow as described above (line 7095).  Even though I've requested the scanning stop and I've initiated the connection with the microprocessor, you can see that the BLE scanning appears to still be happening (7098, 7248).  Scanning appears to actually stop around line 7307, the first write out is requested at 7569 and starting at line 7668 you can see what I believe is causing an issue - some sort of change in what I assume is the connection interval:\n03-16 14:09:11.812 15563-15574/xyz.com.securitytagreader D/BluetoothGatt: onClientConnParamsChanged() - Device=00:A0:50:65:24:91 interval=6 status=0\n03-16 14:09:12.182 6292-6754/? D/BtGatt.GattService: onClientConnParamsChanged() - clientIf=9 address=00:A0:50:65:24:91, interval=39status=0\nAfter this happens the connection is completely dead in the water because it appears to have interrupted  the previous write out which I never see arrive on the microprocessor side.  I should quickly point out that this interrupt happened at this point in the back and forth flow but it can literally happen at any other point with similar results, it's all dependent on the timing of when the scan stops in the background.\nRegarding your comment about the peripheral causing this issue: that definitely occurred to me but based on the connection working fine with other phones and the fact that waiting for scanning to truly finish before initiating the connection seems to correct the issue makes me lean towards thinking it is an issue on the phone side of things.\nFinally to summarize a little bit, I'm not particularly expecting a fix to this issue since I'm feeling increasingly like it's specific to this phone but I figured I'd put it out there in case there is a more reliable way to detect the end of the scanning and/or if my hypothesis about that being the root of the issue is even plausible.. ",
    "CLAassistant": " All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  All committers have signed the CLA..  Thank you for your submission, we really appreciate it. Like many open source projects, we ask that you all sign our Contributor License Agreement before we can accept your contribution.2 out of 3 committers have signed the CLA.:white_check_mark: lukaszkalnik:white_check_mark: dariuszseweryn:x: Lukasz KalnikLukasz Kalnik seems not to be a GitHub user. You need a GitHub account to be able to sign the CLA. If you have already a GitHub account, please add the email address used for this commit to your account.You have signed the CLA already but the status is still pending? Let us recheck it.. ",
    "pfaffenrodt": "Sorry. Wrong import of ScanSettings.\nI am so stupid.. ",
    "standinga": "Had the same problem:) because of auto imported by Android Studio:) This is why I like my api classes prefixed.\n. ",
    "honey-system": "\nSorry. Wrong import of ScanSettings.\nI am so stupid.\n\nYou should have written how you solved the problem!\nSOLUTION:\nreplace \nimport android.bluetooth.le.ScanSettings\nto \nimport com.polidea.rxandroidble2.scan.ScanSettings. ",
    "warko-san": "@uKL I forgot to mention that ACCESS_COARSE_LOCATION previously was granted. Thanks for your answer!. ",
    "michaelnimbs": "I have exactly the same issue and it happens if I subscribe to observeStateChanges().\nThe NPE happens here for me: https://github.com/Polidea/RxAndroidBle/blob/506d98cd662fb81c9450c1574b28701539329071/rxandroidble/src/main/java/com/polidea/rxandroidble2/internal/util/LocationServicesOkObservableApi23.java#L35\nlocationProviderOk is true and location permission was granted before.. I can confirm this.\nWorks with RxJava 2.1.10 and breaks with 2.1.11.. I guess this would be 1.6.0-SNAPSHOT and not 1.5.0-SNAPSHOT?. Works with 1.6.0-SNAPSHOT and RxJava 2.1.11, thanks!. ",
    "akarnokd": "Calling  onSubscribe is mandatory in RxJava 2.x. Also the preferred way of creating bridges to no-rx sources is Observable.create() which has safeguards guarding against this type of mistakes.. http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#create-io.reactivex.ObservableOnSubscribe-. Why would you subclass it?. ",
    "jreehuis": "Any news here? In our project it really helped us to tackle some requirements.. Since Android 7 DP4 Google forces an Bluetooth scanning App into an Opportunistic Mode in two cases:\n1) When starting/stopping a BT scan more than 5 times in 30sec (https://stackoverflow.com/questions/45681711/app-is-scanning-too-frequently-with-scansettings-scan-mode-opportunistic)\n2) When scanning for more than 30min (https://android.googlesource.com/platform/packages/apps/Bluetooth/+/android-7.0.0_r1/src/com/android/bluetooth/gatt/ScanManager.java#72)\nIn this Opportunistic Mode the App will only get BT Advertisements if another App is also scanning for BT devices.\nI guess you are runnning into this trap.. Hi, I guess the issue is not in the lib.\nYou are subscribing to a long running RxJava chain and disposing it immediately after it. So the whole call gets canceled before it could be executed completely.. I already experienced the same issue. It is not connected to the library itself.\nSome smartphone vendors include this toasts upon BT errors.\nI think they can not be avoided without switching the phone/vendor.. E.g. on a Huawei P10, Android 8 or some Samsung Phones but I can not recall which ones. I also have in mind to have them seen on Sony devices aswell.\nIt is already some time ago when I had a closer look. By mind the toast came up in the case that the phone has still a BT bonding but the device has lost or invalidated the bonding key.. ",
    "BernhardReu": "We are using this library in one of our company projects and it is working great so far. Thank you for all your effort!\nI was also poring a lot over connection sharing. I think the great challenge with a shared connection observable are the error scenarios. After thinking through a lot of possible solutions (some with vanilla RxJava, some with helpers like ReplayingShare) I have recently started to validate them.\nFirst I was thinking about the mentioned drawback of simply using .replay(1).refCount(). I just could not believe that the second (late) observer would not get the replayed connection..\nThat's why I wrote the following little unit test which should reproduce this behavior (without actually including your library) - and it passes!\n```\n// Given\nObject connection = new Object();\nPublishSubject connectionSubject = PublishSubject.create();\nObservable sharedConnection = connectionSubject.replay(1).refCount();\n// When\nTestObserver observer1 = sharedConnection.test();\nconnectionSubject.onNext(connection);\nTestObserver observer2 = sharedConnection.test();\n// Then\nobserver1.assertValueCount(1);\nobserver2.assertValueCount(1);\n```\nDid I miss something?\nWhile I haven't figured out my ideal path for connection sharing (yet) I just wanted to share this information.. @streetsofboston I know that this does not handle stale connections. I just wanted to clarify the behavior of replay(1).refCount() . It was not meant to be a solution covering all cases.\nIf the previous discussion was meant to also cover the error case then I misread the answer from @dariuszseweryn and I am sorry.\nAnyway, I am currently experimenting with a solution similar to the ConnectionShareAdapter and the ReplayingShare using a Transformer and some internal (thread safe) state to handle the case of stale connections. I will definitely let you know if I make useful progress.. ",
    "martyglaubitz": "Alright, thank you! \ud83d\ude03 . ",
    "kosancicivan": "Best Regards. ",
    "Smbat888": "Hi @skykelsey \nCan you help me, please, with defining and using the transformer for larger MTU  using Java (or give me the same example with Java, if you can)\nThanks in advance.. ",
    "skykelsey": "@craigzour Were you actually able to get the BOND_BONDED Intent? I'm not seeing that. Seems like it's not always emitted.. ",
    "dglozano": "I came up with a slightly different helper class based on @craigzour solution. The main difference is that in Craig's solution, the completable completed successfully if the device was already bonded. In my case, that wasn't useful, because when I try to read or write the first characteristic to be encrypted, the operation failed anyway. To avoid that, I always unbond and bond again before establishing the connection, so I added an unbonding operation before. \nhttps://gist.github.com/dglozano/9b0ce38a558eeca16137909bd368698c. Finally, I found a better workaround for the just works bonding and operations on encrypted characteristics problem. I posted it in this comment..\nAnyway, maybe the timeout idea is still useful for something else.\nCheers.. ",
    "LinkOut": "Thanks for the answer, i've fixed this issue by abstracting the communication, so every activity can access one instance of the comunication layer.\nThanks . ",
    "akram-aq1": "Thanks for the feedback, jreehuis.\n\n\nVery familiar with this 'feature': it's not to blame, I can power down the phone leave it for a few hours and bring it back up, and it won't see the device. I can use a different device, and the same problem. I start to believe that it is actually the ESP32 or some quirk of how I'm using the scanning subsystem, since a phone that NEVER saw the device can't see it via my app AFTER the ESP peripherals get in this state. Does not explain why nrfConnect sees them, though!\n\n\nThese scans are for less than 30s at a time and are manually started/stopped, so again, I do not think this is related.\n\n\nI think I'm going to have to make a couple test apps that use the native scanner to see if that works in place of rxandroidble. . Turns out this was a bug in our code, have proven things are OK via the sample app. Sorry for the misreport!. Hola @freecats,\nThe problem I was having was not the undocumented Google feature - it was simply that I had naively cached a set of ScanResult records and my code was ignoring discovered devices in that cache (oops).\nAs for 'fixing' the 'feature': unfortunately I don't know of a true fix. Right now we wait for the problem to occur and warn the user that they can't scan until time X in the future. \nCheers,\nAkram\n. ",
    "freecats": "\nTurns out this was a bug in our code, have proven things are OK via the sample app. Sorry for the misreport!\n\nHi,  @akram-aq1 \nCan you share detail of this bug and solution, we are running into this trap too.\nThanks in advance\u3002. > Hola @freecats,\n\nThe problem I was having was not the undocumented Google feature - it was simply that I had naively cached a set of ScanResult records and my code was ignoring discovered devices in that cache (oops).\nAs for 'fixing' the 'feature': unfortunately I don't know of a true fix. Right now we wait for the problem to occur and warn the user that they can't scan until time X in the future.\nCheers,\nAkram\n\nThanks  for sharing!. ",
    "EFGeorgiMirchev": "The issue was caused by setting autoConnect to false, which is not OK with versions lower than Android N.. ",
    "jumpstreet13": "Hello, \nHonestly, i can not identify, is it issue with library, or with android sdk, or with remote ble device. Maybe in newer versions of android they changed package exchanging timeout and this is the cause of the problem. Just wanted ask if you had something similar in your experience ?. Thank you so much for advice, i will research :). ",
    "jensfrandsen": "Looked through my code and realised that you are right. Scanning is not stopped before connecting. That is obviously a mistake.\nThank you!. ",
    "saiimons": "Hey @dariuszseweryn !\nThanks for the quick reply and snapshot \ud83d\udc4d \nJust played around with it and the issue seems to have been resolved, great job !. ",
    "priyakar": "I can see it if I use the android BluetoothScanner though! Which app did you use to simulate the iBeacon, if you dont mind me asking?. Oh that works. I have it working for everything BUT the ibeacon.. ",
    "seasonyuu": "Why still not merged?. ",
    "JeanChristophePal": "Hello, \nSorry for posting this at the wrong place. On stackoverflow :\nhttps://stackoverflow.com/questions/51299418/rxandroidble-scanbledevices-android-6-device-are-invisible-after-another-app\nRegards,. ",
    "keithle888": "Hello!\nThanks for the prompt reply. cPayload.getNextPacket() will drop the bytes it returns, so the array will eventually empty out.\nI've implemented the same behaviour with the Native Android BLE library and it works fine with both phones. So the difference in behaviour is somewhat confusing. I'll put up the logs and more code from my implementation in a few hours.. Thanks alot for the heads up!\nHere is the logs for the error I'm receiving.\n14307-16162 D: QUEUED   CharacteristicWriteOperation(129362019)\n14307-16161 D: STARTED  CharacteristicWriteOperation(129362019)\n14307-14327 D: onCharacteristicWrite characteristic=#### status=133\n14307-14327 D: onClientConnectionState() - status=19 clientIf=6 device=ED:11:D4:AD:25:69\n14307-16161 D: FINISHED CharacteristicWriteOperation(129362019) in 311 ms\n14307-16162 E: Write failed.\n    com.polidea.rxandroidble2.exceptions.BleGattCharacteristicException: GATT exception from MAC address ED:11:D4:AD:25:69, status 133, type BleGattOperation{description='CHARACTERISTIC_WRITE'}. (Look up status 0x85 here https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback.propagateErrorIfOccurred(RxBleGattCallback.java:228)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback.access$800(RxBleGattCallback.java:33)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onCharacteristicWrite(RxBleGattCallback.java:122)\n        at android.bluetooth.BluetoothGatt$1$7.run(BluetoothGatt.java:407)\n        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:711)\n        at android.bluetooth.BluetoothGatt.-wrap0(Unknown Source:0)\n        at android.bluetooth.BluetoothGatt$1.onCharacteristicWrite(BluetoothGatt.java:403)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:136)\n        at android.os.Binder.execTransact(Binder.java:692)\n14307-14327 D: onConnectionStateChange newState=0 status=19\n14307-14327 I: Connection operations queue to be terminated (ED:11:D4:AD:25:69)\n14307-16161 D: Terminated.\n14307-16162 D: QUEUED   DisconnectOperation(266990873)\nAnd this is what I'm using to connect:\nfun connect(connectionType: ConnectionType): Observable<ConnectionState> {\n        val startTime = System.currentTimeMillis()\n        this.connectionType = connectionType\n        return rxBleDevice.establishConnection(false)\n                .doOnSubscribe { Timber.d(\"Attempting to connect to: ${this.name}\") }\n                .doOnNext {\n                    this.bleConnection = it\n                    Timber.d(\"BLE Connection to ${name} took: ${System.currentTimeMillis() - startTime}ms\")\n                }.flatMap {connection -> connection.discoverServices().toObservable().map { Pair(connection, it) } }\n                .doOnNext {\n                    Timber.d(\"Successfully discovered services. Took: ${System.currentTimeMillis() - startTime}ms\")\n                    if (disposableList.find { it.purpose == DisposableHolder.PURPOSE_NOTIFICATION } == null) {\n                        disposableList.add(DisposableHolder(\n                                DisposableHolder.PURPOSE_NOTIFICATION,\n                                it.first.setupNotification(getCurrentCharacteristicUUID(), NotificationSetupMode.COMPAT)\n                                        .mergeWith(it.first.writeDescriptor(serviceUUID.uuid, getCurrentCharacteristicUUID(), getCurrentDescriptorUUID(), BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE))\n                                        .doOnNext { Timber.d(\"Successfully setup notification. Took: ${System.currentTimeMillis() - startTime}ms\") }\n                                        .flatMap { it }\n                                        .subscribe({\n                                            handleBleNotification(it)\n                                        }, {\n                                            Timber.e(it, \"Error setting up notification.\")\n                                            teardownConnection()\n                                        })\n                        ))}\n                }\n                .flatMapCompletable { establishSecureConnection(connectionType) }\n                .andThen(Observable.just(ConnectionState.Connected))\n    }. Hello Darius, \nI found the issue. Was send the peripheral incorrect data, forcing the peripheral to disconnect. Thanks alot for your time and advice!. ",
    "balakzde": "Sony Xperia XZ1 Compact, model: g8441, build number: 47.1.A.12.235\nOS: 8.0.0\nI believe that what you are suggesting would not solve my problem either, there is simply problem with ScanSettings.CALLBACK_TYPE_ALL_MATCHES which is not problem of your library but different (probably incorect) implementation of android api on sonys side.\nAfter a lot of research on this topic I found out there are tons of problems with ble scanning on android devices and lot of articles suggested robust restart and reconnect strategy.\nI managed to resolve my issue by using ScanSettings.CALLBACK_TYPE_FIRST_MATCH and on every scan result I plan reset of scanning, which will act similar as ScanSettings.CALLBACK_TYPE_ALL_MATCHES, with only difference that the period can not be shorter that 6 seconds becouse of: https://blog.classycode.com/undocumented-android-7-ble-behavior-changes-d1a9bd87d983\nSince some devices can have problem with ScanSettings.CALLBACK_TYPE_ALL_MATCHES and some with ScanSettings.CALLBACK_TYPE_FIRST_MATCH the only option is to use both or let the user decide in settings according to his experience with app.\n. > The ScanSettings.CALLBACK_TYPE_ALL_MATCHES is the default for using a BLE scan. I am almost sure that it will work if you will not provide any ScanFilters.\nYou were right, if no filters is supplied it works. I may try this solution as well.\n\nIf you have the articles still opened could you also reference them here? I would also like to go through them as I do not recall any of such\n\nI think I got the idea of restarting scann from davidgyoung's answer https://stackoverflow.com/questions/29731176/ble-scanning-callback-only-get-called-several-times-then-stopped\n. ",
    "Kilnn": "After many tests, I found that it was not caused by the onCharacteristicChanged callback, but by LongWriteOperation. I think it might be that LongWriteOperation didn't end properly, and the Operation queue started the next operation. Using writeCharacteristic instead of LongWriteOperation will work fine. So I think this might be a bug. Sorry, I read the issue template, but I missed some details. \nThe library version is 1.6.0. I have used two ways to send instructions, mode A works normally, mode B will generate errors.\nMode A:\npublic void sendRawDataSync(@NonNull byte[] data) throws Exception {\n        RxBleConnection connection = getRxBleConnection();\n        if (WristbandApplication.isDebugEnable())\n            Log.d(TAG, \"Send Data :\" + BytesUtil.byte2HexStr(data));\n        final int mtu = MTU_SIZE;\n        // unpack the send data, because of the MTU size is limit\n        int length = data.length;\n        int unpackCount = 0;\n        byte[] realSendData;\n        do {\n            if (length <= mtu) {\n                realSendData = new byte[length];\n                System.arraycopy(data, unpackCount * mtu, realSendData, 0, length);\n                // update length value\n                length = 0;\n            } else {\n                realSendData = new byte[mtu];\n                System.arraycopy(data, unpackCount * mtu, realSendData, 0, mtu);\n                // update length value\n                length = length - mtu;\n            }\n            connection.writeCharacteristic(mWriteCharacteristic, realSendData).blockingGet();\n            // unpack counter increase\n            unpackCount++;\n        } while (length != 0);\n}\nMode B:\npublic void sendRawDataSync(@NonNull byte[] data) throws Exception {\n    RxBleConnection connection = getRxBleConnection();\n    if (WristbandApplication.isDebugEnable())\n        Log.d(TAG, \"Send Data :\" + BytesUtil.byte2HexStr(data));\n    RxBleConnection.LongWriteOperationBuilder builder = connection.createNewLongWriteBuilder();\n    builder.setBytes(data);\n    builder.setCharacteristic(mWriteCharacteristic);\n    builder.setMaxBatchSize(MTU_SIZE);\n    builder.build().blockingSubscribe();\n}\ntest code:\n```\npublic void set_user_info(View view) {\n    try {\n        mWristManager.sendRawDataSync(datas);\n    } catch (Exception e) {\n        Log.e(\"MainActivity\", \"sendRawDataSync Error\", e);\n    }\ntry {\n    mWristManager.sendRawDataSync(datas);\n} catch (Exception e) {\n    Log.e(\"MainActivity\", \"sendRawDataSync Error\", e);\n}\n\ntry {\n    mWristManager.sendRawDataSync(datas);\n} catch (Exception e) {\n    Log.e(\"MainActivity\", \"sendRawDataSync Error\", e);\n}\n\ntry {\n    mWristManager.sendRawDataSync(datas);\n} catch (Exception e) {\n    Log.e(\"MainActivity\", \"sendRawDataSync Error\", e);\n}\n\ntry {\n    mWristManager.sendRawDataSync(datas);\n} catch (Exception e) {\n    Log.e(\"MainActivity\", \"sendRawDataSync Error\", e);\n}\n\n}\n```\nBelow are all the logs with Mode B, but it looks like there are no process errors.\n07-30 22:57:00.291 8363-8363/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n07-30 22:57:00.294 8363-8363/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(13080428)\n07-30 22:57:00.296 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(13080428)\n07-30 22:57:00.386 8363-8381/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n07-30 22:57:00.483 8363-8377/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n07-30 22:57:00.487 8363-8363/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n07-30 22:57:00.488 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(13080428) in 193 ms\n07-30 22:57:00.489 8363-8363/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(226957462)\n07-30 22:57:00.491 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(226957462)\n07-30 22:57:00.496 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(226957462) in 5 ms\n07-30 22:57:00.496 8363-8363/com.htsmart.wristband2sample E/MainActivity: sendRawDataSync Error\n    com.polidea.rxandroidble2.exceptions.BleGattCannotStartException: GATT exception from MAC address 10:00:A1:12:09:AC, with type BleGattOperation{description='CHARACTERISTIC_LONG_WRITE'}\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.writeData(CharacteristicLongWriteOperation.java:177)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.access$200(CharacteristicLongWriteOperation.java:44)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation$2.subscribe(CharacteristicLongWriteOperation.java:155)\n        at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:40)\n        at io.reactivex.Observable.subscribe(Observable.java:12051)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\n07-30 22:57:00.497 8363-8363/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n07-30 22:57:00.498 8363-8363/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(248820205)\n07-30 22:57:00.500 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(248820205)\n07-30 22:57:00.506 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(248820205) in 6 ms\n07-30 22:57:00.508 8363-8363/com.htsmart.wristband2sample E/MainActivity: sendRawDataSync Error\n    com.polidea.rxandroidble2.exceptions.BleGattCannotStartException: GATT exception from MAC address 10:00:A1:12:09:AC, with type BleGattOperation{description='CHARACTERISTIC_LONG_WRITE'}\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.writeData(CharacteristicLongWriteOperation.java:177)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.access$200(CharacteristicLongWriteOperation.java:44)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation$2.subscribe(CharacteristicLongWriteOperation.java:155)\n        at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:40)\n        at io.reactivex.Observable.subscribe(Observable.java:12051)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\n07-30 22:57:00.508 8363-8363/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n07-30 22:57:00.510 8363-8363/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(113836144)\n07-30 22:57:00.511 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(113836144)\n07-30 22:57:00.516 8363-8363/com.htsmart.wristband2sample E/MainActivity: sendRawDataSync Error\n    com.polidea.rxandroidble2.exceptions.BleGattCannotStartException: GATT exception from MAC address 10:00:A1:12:09:AC, with type BleGattOperation{description='CHARACTERISTIC_LONG_WRITE'}\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.writeData(CharacteristicLongWriteOperation.java:177)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.access$200(CharacteristicLongWriteOperation.java:44)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation$2.subscribe(CharacteristicLongWriteOperation.java:155)\n        at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:40)\n        at io.reactivex.Observable.subscribe(Observable.java:12051)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\n07-30 22:57:00.516 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(113836144) in 5 ms\n07-30 22:57:00.516 8363-8363/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n07-30 22:57:00.518 8363-8363/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(103003919)\n07-30 22:57:00.520 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(103003919)\n07-30 22:57:00.524 8363-8363/com.htsmart.wristband2sample E/MainActivity: sendRawDataSync Error\n    com.polidea.rxandroidble2.exceptions.BleGattCannotStartException: GATT exception from MAC address 10:00:A1:12:09:AC, with type BleGattOperation{description='CHARACTERISTIC_LONG_WRITE'}\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.writeData(CharacteristicLongWriteOperation.java:177)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.access$200(CharacteristicLongWriteOperation.java:44)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation$2.subscribe(CharacteristicLongWriteOperation.java:155)\n        at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:40)\n        at io.reactivex.Observable.subscribe(Observable.java:12051)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\n07-30 22:57:00.525 8363-8945/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(103003919) in 5 ms\n07-30 22:57:00.581 8363-8452/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0. I used two mobile phones to test, and this problem will appear on both phones:\n  Samsung SM-G9300,Android 7.0\n  Smartisan OS105,Android 7.1.1\nI think this may be a common problem, but I don't have more mobile phones to test.. I have test many times with the release 1.7.0-SNAPSHOT on Smartisan OS105(Android 7.1.1). My test code send data with 30 bytes, and the LongWriteOperation maxBatchSize is 20. And i found the log has three batch write operation when error occur, maybe it is the problem caused by this place. When the log Long write batch #2 appear, the error occur.\n```\n08-01 05:56:16.093 8375-8728/com.htsmart.wristband2sample D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(156172013)\n08-01 05:56:16.094 8375-8394/com.htsmart.wristband2sample D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(156172013)\n08-01 05:56:16.098 8375-8396/com.htsmart.wristband2sample V/RxBle#BleConnectionCompat: Connecting without reflection\n08-01 05:56:16.102 8375-8396/com.htsmart.wristband2sample D/BluetoothGatt: connect() - device: 00:E0:12:34:56:87, auto: false\n    registerApp()\n    registerApp() - UUID=7ba0e6b7-0c0a-4940-9083-042c61b0ce19\n08-01 05:56:16.104 8375-8390/com.htsmart.wristband2sample D/BluetoothGatt: onClientRegistered() - status=0 clientIf=6\n08-01 05:56:17.541 8375-8389/com.htsmart.wristband2sample D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=6 device=00:E0:12:34:56:87\n08-01 05:56:17.543 8375-8389/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\n08-01 05:56:17.545 8375-8394/com.htsmart.wristband2sample D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(156172013) in 1451 ms\n08-01 05:56:18.049 8375-8730/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   ServiceDiscoveryOperation(78224617)\n08-01 05:56:18.050 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  ServiceDiscoveryOperation(78224617)\n08-01 05:56:18.052 8375-8396/com.htsmart.wristband2sample D/BluetoothGatt: discoverServices() - device: 00:E0:12:34:56:87\n08-01 05:56:18.385 8375-8390/com.htsmart.wristband2sample D/BluetoothGatt: onSearchComplete() = Device=00:E0:12:34:56:87 Status=0\n08-01 05:56:18.385 8375-8390/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onServicesDiscovered status=0\n08-01 05:56:18.386 8375-8728/com.htsmart.wristband2sample V/RxBle#ServiceDiscoveryOperation: Preparing services description\n08-01 05:56:18.392 8375-8728/com.htsmart.wristband2sample V/RxBle#ServiceDiscoveryOperation: --------------- ====== Printing peripheral content ====== ---------------\n    PERIPHERAL ADDRESS: 00:E0:12:34:56:87\n    PERIPHERAL NAME: HBracelet-687\n    -------------------------------------------------------------------------\nPrimary Service - Generic Access (00001800-0000-1000-8000-00805f9b34fb)\nInstance ID: 1\n-> Characteristics:\n    * Device Name (00002a00-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Appearance (00002a01-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Peripheral Preferred Connection Parameters (00002a04-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n\nPrimary Service - Unknown service (000001ff-3c17-d293-8e48-14fe2e4da212)\nInstance ID: 8\n-> Characteristics:\n    * Unknown characteristic (0000ff02-0000-1000-8000-00805f9b34fb)\n      Properties: [ WRITE ]\n    * Unknown characteristic (0000ff03-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ WRITE_NO_RESPONSE NOTIFY ]\n      -> Descriptors: \n        * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n    * Unknown characteristic (0000ff04-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ WRITE ]\n\nPrimary Service - Unknown service (0000fee7-0000-1000-8000-00805f9b34fb)\nInstance ID: 16\n-> Characteristics:\n    * Unknown characteristic (0000fec9-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Unknown characteristic (0000fea1-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ NOTIFY ]\n      -> Descriptors: \n        * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n\nPrimary Service - Unknown service (0000d0ff-3c17-d293-8e48-14fe2e4da212)\nInstance ID: 22\n-> Characteristics:\n    * Unknown characteristic (0000ffd1-0000-1000-8000-00805f9b34fb)\n      Properties: [ WRITE_NO_RESPONSE ]\n    * Unknown characteristic (0000ffd2-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Unknown characteristic (0000ffd3-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Unknown characteristic (0000ffd4-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Unknown characteristic (0000ffd5-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Unknown characteristic (0000fff1-0000-1000-8000-00805f9b34fb)\n      Properties: [ READ ]\n    * Unknown characteristic (0000fff2-0000-1000-8000-00805f9b34fb)\n      Properties: [ WRITE ]\n\nPrimary Service - Unknown service (00006287-3c17-d293-8e48-14fe2e4da212)\nInstance ID: 37\n-> Characteristics:\n    * Unknown characteristic (00006387-3c17-d293-8e48-14fe2e4da212)\n      Properties: [ WRITE_NO_RESPONSE ]\n    * Unknown characteristic (00006487-3c17-d293-8e48-14fe2e4da212)\n      Properties: [ WRITE NOTIFY ]\n      -> Descriptors: \n        * Client Characteristic Configuration (00002902-0000-1000-8000-00805f9b34fb)\n    * Unknown characteristic (00006587-3c17-d293-8e48-14fe2e4da212)\n      Properties: [ READ ]\n--------------- ====== Finished peripheral content ====== ---------------\n\n08-01 05:56:18.399 8375-8728/com.htsmart.wristband2sample D/BluetoothGatt: setCharacteristicNotification() - uuid: 0000ff03-0000-1000-8000-00805f9b34fb enable: true\n08-01 05:56:18.402 8375-8728/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(54762511)\n08-01 05:56:18.403 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED ServiceDiscoveryOperation(78224617) in 352 ms\n    STARTED  DescriptorWriteOperation(54762511)\n08-01 05:56:18.449 8375-8389/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:18.451 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED DescriptorWriteOperation(54762511) in 47 ms\n08-01 05:56:18.452 8375-8375/com.htsmart.wristband2sample D/GattLayer: onConnectionStateChanged(CONNECTED)\n08-01 05:56:37.022 8375-8375/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n08-01 05:56:37.024 8375-8375/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(264209018)\n08-01 05:56:37.025 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(264209018)\n08-01 05:56:37.029 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #0 - start\n08-01 05:56:37.029 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.123 8375-8389/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.124 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #0 - end\n08-01 05:56:37.126 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #1 - start\n08-01 05:56:37.127 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.213 8375-8390/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.215 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #1 - end\n08-01 05:56:37.216 8375-8375/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n08-01 05:56:37.216 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(264209018) in 191 ms\n08-01 05:56:37.216 8375-8375/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(13100754)\n08-01 05:56:37.217 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(13100754)\n08-01 05:56:37.218 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #0 - start\n08-01 05:56:37.219 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.302 8375-8389/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.302 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #0 - end\n08-01 05:56:37.305 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #1 - start\n08-01 05:56:37.306 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.392 8375-8390/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.393 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #1 - end\n08-01 05:56:37.394 8375-8375/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n08-01 05:56:37.395 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(13100754) in 178 ms\n08-01 05:56:37.395 8375-8375/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(108526796)\n08-01 05:56:37.396 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(108526796)\n08-01 05:56:37.397 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #0 - start\n08-01 05:56:37.398 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.526 8375-8389/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.527 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #0 - end\n08-01 05:56:37.529 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #1 - start\n08-01 05:56:37.529 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.617 8375-8390/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.619 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #1 - end\n08-01 05:56:37.620 8375-8375/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n08-01 05:56:37.620 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(108526796) in 225 ms\n08-01 05:56:37.621 8375-8375/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(118313718)\n08-01 05:56:37.621 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(118313718)\n08-01 05:56:37.624 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #0 - start\n08-01 05:56:37.624 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.707 8375-8389/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.708 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #0 - end\n08-01 05:56:37.710 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #1 - start\n08-01 05:56:37.710 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.799 8375-8390/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n08-01 05:56:37.800 8375-8728/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation$2: Long write batch #1 - end\n08-01 05:56:37.801 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #2 - start\n08-01 05:56:37.801 8375-8375/com.htsmart.wristband2sample D/GattLayer: Send Data :00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n08-01 05:56:37.802 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(118313718) in 180 ms\n08-01 05:56:37.802 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.802 8375-8375/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicLongWriteOperation(44984272)\n08-01 05:56:37.803 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: STARTED  CharacteristicLongWriteOperation(44984272)\n08-01 05:56:37.805 8375-8396/com.htsmart.wristband2sample D/RxBle#ObservableCreate: Long write batch #0 - start\n08-01 05:56:37.805 8375-8396/com.htsmart.wristband2sample D/RxBle#CharacteristicLongWriteOperation: Writing next batch\n08-01 05:56:37.807 8375-8727/com.htsmart.wristband2sample D/RxBle#ConnectionOperationQueue: FINISHED CharacteristicLongWriteOperation(44984272) in 5 ms\n08-01 05:56:37.807 8375-8375/com.htsmart.wristband2sample E/MainActivity: sendRawDataSync Error\n    com.polidea.rxandroidble2.exceptions.BleGattCannotStartException: GATT exception from MAC address 00:E0:12:34:56:87, with type BleGattOperation{description='CHARACTERISTIC_LONG_WRITE'}\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.writeData(CharacteristicLongWriteOperation.java:189)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation.access$200(CharacteristicLongWriteOperation.java:46)\n        at com.polidea.rxandroidble2.internal.operations.CharacteristicLongWriteOperation$2.subscribe(CharacteristicLongWriteOperation.java:166)\n        at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:40)\n        at io.reactivex.Observable.subscribe(Observable.java:12051)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:761)\n08-01 05:56:37.807 8375-8375/com.htsmart.wristband2sample I/Choreographer: Skipped 47 frames!  The application may be doing too much work on its main thread.\n08-01 05:56:37.931 8375-8390/com.htsmart.wristband2sample D/RxBle#BluetoothGatt: onCharacteristicWrite characteristic=0000ff02-0000-1000-8000-00805f9b34fb status=0\n```\n. Great, thanks for you help.. ",
    "MarcinDe": "@JoeSteven  The problem lies here\nYou try to connect to device\n08-07 18:02:43.469 3804-4055/com.joey.rxble D/BluetoothGatt: connect() - device: DC:2C:26:00:09:90, auto: false\n    registerApp()\n08-07 18:02:43.470 3804-4055/com.joey.rxble D/BluetoothGatt: registerApp() - UUID=2f04d40e-528b-469f-b03c-f37c1943405b\n08-07 18:02:43.471 3804-3830/com.joey.rxble D/BluetoothGatt: onClientRegistered() - status=0 clientIf=5\nThe connection is unsuccessful with error code 133\n08-07 18:02:44.124 3804-3830/com.joey.rxble D/BluetoothGatt: onClientConnectionState() - status=133 clientIf=5 device=DC:2C:26:00:09:90\nYou retry connection twice, first time im assuming it connects and the second will throw the error\n08-07 18:02:44.134 3804-3830/com.joey.rxble D/RxBleDemo: retry connection\n08-07 18:02:44.135 3804-3830/com.joey.rxble D/RxBleDemo: retry connection\nHere is the error\n08-07 18:02:44.136 3804-3804/com.joey.rxble W/System.err: com.polidea.rxandroidble2.exceptions.BleAlreadyConnectedException: Already connected to device with MAC address DC:2C:26:00:09:90. ",
    "JoeSteven": "@MarcinDe  thanks man ! I also found this problem and fixed after I changed the reconnect strategy.\n@dariuszseweryn sorry for I didn't reply immediately. ",
    "SoNep": "Thank you for your response. \nI found problem with ble device need to set up MTU.. ",
    "komuros": "Hello,\nThanks for you answer.\nI have encountered this bug with samsung galaxy S8 with android 8.0 and Huawei P9 lite with android 7.0.\nUntil the new version is released, do you have some  advices how to retry the discovering of services only when list is empty in my code ?\nBest Regards.. I have update my code to around this problem with actual version.\nfun getConnectionOrConnect(mac: MacAdress): Observable<RxBleConnection> {\n        synchronized(this) {\n            RxBleClient.setLogLevel(RxBleLog.VERBOSE)\n            Timber.d(\"$this $mac getconnectionOrConnect\")\n            connections[mac]?.disposableDisconnect?.dispose()\n            return connections.getOrPut(mac) {\n                val nbTryDiscoverServices = AtomicInteger(10)\n                val rxBleDevice = bleClient.getBleDevice(mac)\n                Timber.d(\"$this $mac creating connection\")\n                val obs = rxBleDevice.establishConnection(false).flatMap {\n                    Observable.just(it).zipWith(it.discoverServices().toObservable())\n                }.map { (connection, rxbleServices) ->\n                    if (rxbleServices.bluetoothGattServices.isEmpty()) {\n                        throw EmptyBleServices(rxbleServices)\n                    }\n                    connection\n                }.retryWhen {\n                    it.flatMap {\n                        Timber.d(it)\n                        if (it is EmptyBleServices) {\n                            if (nbTryDiscoverServices.getAndDecrement() < 0) {\n                                Events.eventNbTryForDiscoverServiceIsOut.set(true)\n                                Observable.error<Throwable>(it)\n                            } else {\n                                Observable.timer(500, TimeUnit.MILLISECONDS)\n                            }\n                        } else {\n                            Observable.timer(500, TimeUnit.MILLISECONDS)\n                        }\n                    }\n                }.compose(ReplayingShare.instance())\n                val disposable = obs.doOnDispose {\n                    connections.remove(mac)\n                }.subscribe({\n                    Timber.d(\"first Connection was created\")\n                }, { Timber.d(it) }).addTo(oneTimeDisposable)\n                RefConnect(obs, disposable)\n            }.obs\n        }\n    }. ",
    "Montross7": "We are using version 1.4.3.. Thank you! Updated the library and now everything is working.. ",
    "digitalstreamio": "Phone Model: Google Nexus 6P\nOS Version: Android 8.1.0  (Patch level: September 5, 2018)\nI'll have code snippet to repro the issue in a few minutes too.\n. \nHere is the code sample that reproduces the issue. You may have to vary the timeout based on how long it takes to establish connection with your BLE device.\nprivate void connect() {\n    Subscription sub = rxBleClient.getBleDevice(device.hwId)\n      .establishConnection(false)\n      .subscribeOn(Schedulers.io())\n      .observeOn(Schedulers.io())\n      .subscribe(\n        conn -> Timber.tag(\"BleTest\").v(\"BLE connected\"),\n        throwable -> Timber.tag(\"BleTest\").e(throwable, \"BLE connection failed\")\n      );\n    Observable.timer(250, TimeUnit.MILLISECONDS)\n      .subscribeOn(Schedulers.io())\n      .observeOn(Schedulers.io())\n      .subscribe(value -> {\n        Timber.tag(\"BleTest\").v(\"BLE cancelling connection\");\n        sub.unsubscribe();\n      });\n  }. If timeout is > then amount of time needed to establish connection, everything works properly. Here is the corresponding log output:\nCancel Subscription after 3000ms\nApp Log\n09-18 13:26:49.546 20164-20291/com.livindi.resident I/RxBle#CancellableSubscription: Scan operation is requested to stop.\n09-18 13:26:49.614 20164-20213/com.livindi.resident D/RxBle#ClientOperationQueue: QUEUED   ScanOperationApi21(165476656)\n09-18 13:26:49.616 20164-20211/com.livindi.resident D/RxBle#ClientOperationQueue: STARTED  ScanOperationApi21(165476656)\n09-18 13:26:49.619 20164-20291/com.livindi.resident I/RxBle#QueueOperation: Scan operation is requested to start.\n09-18 13:26:49.629 20164-20211/com.livindi.resident D/RxBle#ClientOperationQueue: FINISHED ScanOperationApi21(165476656) in 13 ms\n09-18 13:26:49.644 20164-20291/com.livindi.resident I/RxBle#CancellableSubscription: Scan operation is requested to stop.\n09-18 13:26:49.917 20164-20324/com.livindi.resident D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(61110714)\n09-18 13:26:49.918 20164-20211/com.livindi.resident D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(61110714)\n09-18 13:26:49.925 20164-20291/com.livindi.resident V/RxBle#BleConnectionCompat: Connecting without reflection\n09-18 13:26:50.381 20164-20287/com.livindi.resident D/RxBle#BluetoothGatt$1: onConnectionStateChange newState=2 status=0\n09-18 13:26:50.392 20164-20211/com.livindi.resident D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(61110714) in 472 ms\n09-18 13:26:50.411 20164-20289/com.livindi.resident V/BleTest: BLE connected\n09-18 13:26:52.892 20164-20321/com.livindi.resident V/BleTest: BLE cancelling connection\n09-18 13:26:52.901 20164-20324/com.livindi.resident I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (DC:C5:05:C6:9E:0E)\n09-18 13:26:52.903 20164-20323/com.livindi.resident D/RxBle#Executors$RunnableAdapter: Terminated.\n09-18 13:26:52.905 20164-20324/com.livindi.resident D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(247951482)\n09-18 13:26:52.909 20164-20211/com.livindi.resident D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(247951482)\n09-18 13:26:52.932 20164-20287/com.livindi.resident D/RxBle#BluetoothGatt$1: onConnectionStateChange newState=0 status=0\n09-18 13:26:52.952 20164-20211/com.livindi.resident D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(247951482) in 42 ms\nBLE Device Log\nINFO [env] Starting\nINFO [ble] on_ble_evt: CONNECTED\nINFO [main] on_ble_evt: CONNECTED \nINFO [ui] Setting led mode to 1 \nINFO [ui] Mode: OFF \nINFO [ble] on_ble_evt: evt_id 0x21\nINFO [ble] on_ble_evt: DATA_LENGTH_UPDATE_REQUEST\nINFO [ble] on_ble_evt: evt_id 0x22\nINFO [ble] on_ble_evt: DATA_LENGTH_UPDATE\nINFO [ble] on_ble_evt: SEC_INFO_REQUEST\nINFO [ble] on_ble_evt: CONN_SEC_UPDATE\nINFO [ble] on_pm_evt: CONN_SEC_SUCCEEDED\nINFO [ble] on_pm_evt: Connection secured: role: 1, conn_handle: 0x0, procedure: 0. \nINFO [ble] on_ble_evt: CONN_PARAM_UPDATE\nINFO [ble] on_conn_params_evt: SUCCEEDED\nINFO [ble] on_ble_evt: DISCONNECTED\nINFO [env] Stopping\nINFO [motion2] Stopping\nINFO [motion2] Stopping motion sensor ...\nINFO [ble] on_ble_evt: DISCONNECTED. Reason: 0x13 \nINFO [main] on_ble_evt: DISCONNECTED \nINFO [ble] Init adv, sec_mode 1\nINFO [ble] Whitelist set with 1 peers\nINFO [ui] Setting led mode to 3 \nINFO [ui] Mode: OFF \nINFO [ble] Starting adv\nINFO [ble] on_adv_evt: WHITELIST_REQUEST\nINFO [ble] on_adv_evt: FAST_WHITELIST. If timeout is < connection establishment time, then disconnect event is never received by BLE device\nCancel Subscription after 250ms\nApp Log\n09-18 13:28:15.620 20508-20637/com.livindi.resident I/RxBle#CancellableSubscription: Scan operation is requested to stop.\n09-18 13:28:15.668 20508-20559/com.livindi.resident D/RxBle#ClientOperationQueue: QUEUED   ScanOperationApi21(80771164)\n09-18 13:28:15.669 20508-20555/com.livindi.resident D/RxBle#ClientOperationQueue: STARTED  ScanOperationApi21(80771164)\n09-18 13:28:15.670 20508-20637/com.livindi.resident I/RxBle#QueueOperation: Scan operation is requested to start.\n09-18 13:28:15.684 20508-20555/com.livindi.resident D/RxBle#ClientOperationQueue: FINISHED ScanOperationApi21(80771164) in 14 ms\n09-18 13:28:15.698 20508-20637/com.livindi.resident I/RxBle#CancellableSubscription: Scan operation is requested to stop.\n09-18 13:28:15.948 20508-20664/com.livindi.resident D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(168945735)\n09-18 13:28:15.948 20508-20555/com.livindi.resident D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(168945735)\n09-18 13:28:15.954 20508-20637/com.livindi.resident V/RxBle#BleConnectionCompat: Connecting without reflection\n09-18 13:28:16.171 20508-20661/com.livindi.resident V/BleTest: BLE cancelling connection\n09-18 13:28:16.175 20508-20664/com.livindi.resident D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(53408412)\n09-18 13:28:16.178 20508-20664/com.livindi.resident I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (DC:C5:05:C6:9E:0E)\n09-18 13:28:16.178 20508-20663/com.livindi.resident D/RxBle#Executors$RunnableAdapter: Terminated.\n09-18 13:28:16.181 20508-20555/com.livindi.resident D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(168945735) in 232 ms\n    STARTED  DisconnectOperation(53408412)\n09-18 13:28:16.192 20508-20555/com.livindi.resident D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(53408412) in 11 ms\nBLE Device Log\nINFO [env] Starting\nINFO [ble] on_ble_evt: CONNECTED\nINFO [main] on_ble_evt: CONNECTED \nINFO [ui] Setting led mode to 1 \nINFO [ui] Mode: OFF \nINFO [ble] on_ble_evt: evt_id 0x21\nINFO [ble] on_ble_evt: DATA_LENGTH_UPDATE_REQUEST\nINFO [ble] on_ble_evt: evt_id 0x22\nINFO [ble] on_ble_evt: DATA_LENGTH_UPDATE\nINFO [ble] on_ble_evt: CONN_PARAM_UPDATE\nINFO [ble] on_conn_params_evt: SUCCEEDED. The same behavior can also be reproduced with RxJava2 and latest RxAndroidBle 1.7.0.\nHere is isolated and standalone repro code:\n```\npackage com.example.bletest;\nimport android.annotation.SuppressLint;\nimport android.os.Bundle;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.design.widget.Snackbar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport com.polidea.rxandroidble2.RxBleClient;\nimport com.polidea.rxandroidble2.internal.RxBleLog;\nimport java.util.concurrent.TimeUnit;\nimport io.reactivex.Observable;\nimport io.reactivex.disposables.Disposable;\nimport io.reactivex.schedulers.Schedulers;\npublic class MainActivity extends AppCompatActivity {\nprivate static final String TAG = \"BleTest\";\nprivate RxBleClient rxBleClient;\n@Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n    setSupportActionBar(toolbar);\n    rxBleClient = RxBleClient.create(this);\n    RxBleClient.setLogLevel(RxBleLog.VERBOSE);\nFloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);\nfab.setOnClickListener(new View.OnClickListener() {\n  @Override\n  public void onClick(View view) {\n    connect();\n    Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG)\n      .setAction(\"Action\", null).show();\n  }\n});\n\n}\n@Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    // Inflate the menu; this adds items to the action bar if it is present.\n    getMenuInflater().inflate(R.menu.menu_main, menu);\n    return true;\n  }\n@Override\n  public boolean onOptionsItemSelected(MenuItem item) {\n    // Handle action bar item clicks here. The action bar will\n    // automatically handle clicks on the Home/Up button, so long\n    // as you specify a parent activity in AndroidManifest.xml.\n    int id = item.getItemId();\n//noinspection SimplifiableIfStatement\nif (id == R.id.action_settings) {\n  return true;\n}\n\nreturn super.onOptionsItemSelected(item);\n\n}\n@SuppressLint(\"CheckResult\")\n  private void connect() {\n    Disposable sub = rxBleClient.getBleDevice(\"DC:C5:05:C6:9E:0E\")\n      .establishConnection(false)\n      .subscribeOn(Schedulers.io())\n      .observeOn(Schedulers.io())\n      .subscribe(\n        conn -> Log.v(TAG, \"BLE connected\"),\n        throwable -> Log.e(TAG, \"BLE connection failed\", throwable),\n        () -> Log.v(TAG, \"BLE completed\")\n      );\n    Observable.timer(250, TimeUnit.MILLISECONDS)\n      .subscribeOn(Schedulers.io())\n      .observeOn(Schedulers.io())\n      .subscribe(value -> {\n        Log.v(TAG, \"BLE cancelling connection\");\n        sub.dispose();\n      });\n  }\n}\n```. Here is application log corresponding to the most recent sample code:\n09-18 14:51:44.146 31075-31075/? I/zygote64: Late-enabling -Xcheck:jni\n09-18 14:51:44.190 31075-31082/? I/zygote64: Debugger is no longer active\n09-18 14:51:44.481 31075-31075/? I/InstantRun: starting instant run server: is main process\n09-18 14:51:44.806 31075-31101/? D/OpenGLRenderer: HWUI GL Pipeline\n09-18 14:51:44.873 31075-31101/? I/Adreno: QUALCOMM build                   : 8e59954, I0be83d0d26\n    Build Date                       : 09/22/17\n    OpenGL ES Shader Compiler Version: EV031.21.02.00\n    Local Branch                     : O17A\n    Remote Branch                    : \n    Remote Branch                    : \n    Reconstruct Branch               : \n09-18 14:51:44.876 31075-31101/? D/vndksupport: Loading /vendor/lib64/hw/gralloc.msm8994.so from current namespace instead of sphal namespace.\n09-18 14:51:44.885 31075-31101/? I/Adreno: PFP: 0x00000000, ME: 0x00000000\n09-18 14:51:44.891 31075-31101/? I/zygote64: android::hardware::configstore::V1_0::ISurfaceFlingerConfigs::hasWideColorDisplay retrieved: 0\n09-18 14:51:44.893 31075-31101/? I/OpenGLRenderer: Initialized EGL, version 1.4\n09-18 14:51:44.893 31075-31101/? D/OpenGLRenderer: Swap behavior 2\n09-18 14:51:44.949 31075-31101/? D/vndksupport: Loading /vendor/lib64/hw/android.hardware.graphics.mapper@2.0-impl.so from current namespace instead of sphal namespace.\n09-18 14:51:44.951 31075-31101/? D/vndksupport: Loading /vendor/lib64/hw/gralloc.msm8994.so from current namespace instead of sphal namespace.\n09-18 14:51:57.389 31075-31119/com.example.bletest D/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(219252011)\n09-18 14:51:57.391 31075-31100/com.example.bletest D/RxBle#ClientOperationQueue: STARTED  ConnectOperation(219252011)\n09-18 14:51:57.412 31075-31121/com.example.bletest V/RxBle#BleConnectionCompat: Connecting without reflection\n09-18 14:51:57.413 31075-31121/com.example.bletest D/BluetoothGatt: connect() - device: DC:C5:05:C6:9E:0E, auto: false\n    registerApp()\n    registerApp() - UUID=fb50d77f-10ea-4a1a-acdb-18f191cd0e90\n09-18 14:51:57.415 31075-31087/com.example.bletest D/BluetoothGatt: onClientRegistered() - status=0 clientIf=7\n09-18 14:51:57.600 31075-31123/com.example.bletest V/BleTest: BLE cancelling connection\n09-18 14:51:57.602 31075-31100/com.example.bletest D/RxBle#ClientOperationQueue: FINISHED ConnectOperation(219252011) in 211 ms\n09-18 14:51:57.603 31075-31119/com.example.bletest I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (DC:C5:05:C6:9E:0E)\n09-18 14:51:57.604 31075-31118/com.example.bletest D/RxBle#Executors$RunnableAdapter: Terminated.\n09-18 14:51:57.604 31075-31119/com.example.bletest D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(152628690)\n09-18 14:51:57.606 31075-31100/com.example.bletest D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(152628690)\n09-18 14:51:57.607 31075-31121/com.example.bletest D/BluetoothManager: getConnectionState()\n    getConnectedDevices\n09-18 14:51:57.609 31075-31121/com.example.bletest D/BluetoothGatt: close()\n    unregisterApp() - mClientIf=7\n09-18 14:51:57.611 31075-31100/com.example.bletest D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(152628690) in 5 ms\n09-18 14:54:05.746 31075-31080/com.example.bletest I/zygote64: Do partial code cache collection, code=30KB, data=27KB\n09-18 14:54:05.747 31075-31080/com.example.bletest I/zygote64: After code cache collection, code=30KB, data=27KB\n    Increasing code cache capacity to 128KB. > This seems to be an Android BLE stack issue \u2014 could you share phone model / OS \n@dariuszseweryn  I tested this issue on another Android device and was able to reproduce this behavior so the problem does not look to be specific to Phone/Android OS combination. \nHere is hardware I tested on:\nHardware: Asus Tablet Model P00C\nOS: Android 7.0\n. Google's bug report does indeed fit the pattern so at least on my side I will put in a workaround to mitigate this issue. It doesn't seem like Google is eager to fix the issue though based on when the issue was filed. Sigh...\nThanks for the clarification and help.. The workaround used is less than ideal but it works for my use case.\nBefore cancelling subscription (forcing disconnect), I added an optional delay of 1-2 seconds if the connection is still being established.\nSomething along the lines of:\nObservable.just(connectionSubscription)\n        .delay(1000, TimeUnit.MILLISECONDS)\n        .subscribe(sub -> sub.unsubscribe());. ",
    "AnDrOiD73dd": "I have the same issue on:\nimplementation 'com.polidea.rxandroidble2:rxandroidble:1.7.1'\nautoconnect=false\nGoogle Nexus 5 - Android 6.0.1, Build M4B30Z\nSamsung J5 (2016) - Android 7.1.1, Build NMF26x.J510FNXXS2BRA1\nXiaomi Mi5 - Android 8.0.0, Build OPR1.170623.032\nXiaomi MiA2 - Android 8.1.0, Build OPM1.171019.011.V9.6.15.0.ODIMIFE\nOnePlus 6 - Android 9.0, Build ONEPLUS A6003_22_181026. @aptly-io, another case is described here. There is no question of reconnection. But you are right that a delay is required when reconnecting, otherwise we will get a connection error.. ",
    "aptly-io": "@digitalstreamio @DariuszAniszewski @AnDrOiD73dd This makes me think about my case #530 . Maybe try adding a step waiting for the connection state to become DISCONNECTED, only then allow to reopen? It is more deterministic, then next you can still at a delay(1000) ... what I also might do .... After changes to my code, the error occurred less.\nTherefore I closed this myself .... @DariuszAniszewski Thank you for your attention and that suggestion, I'm a rx and ble freshman, flabbergasted by all these observable operations. I need to give some context to my use case.\nI open a connection, write configuration values to a BLE accelerometer's characteristic, then wait for the accelerometer notifications to stream in. At one point the observer no longer needs the accelerometer data and disposes his subscription. This triggers a doFinally which tries to write again to the BLE accelerometer characteristic to power its hardware down (conserve the IoT's battery).\nFrom the log traces I concluded that the new connection within this doFinally causes a race condition with the ongoing closing (in the background?) of the connection used before to receive the notification stream? I added a listen to connection state changes. Only once 'DISCONNECTED', I re-open to write the power-off values to the BLE's characteristic.\nSince adding this extra code (see below), the status 133 issue occurred less frequent.\n```kotlin\n        .doFinally {\n            debug { \"### doFinally\"}\n            device.observeConnectionStateChanges()\n                .skipWhile { state ->\n                    debug { \"### state: \" + state }\n                    state != RxBleConnection.RxBleConnectionState.DISCONNECTED\n                }.take(1)\n                .delay(1000, TimeUnit.MICROSECONDS)\n                .flatMap { state ->\n                    debug { \"### state: \" + state }\n                    device.establishConnection(false)\n                }.flatMap { connection ->\n                    MetaWear.disableAcceleroSensor(connection)\n                }\n                // todo how to dispose this subscription (a kind of mem. leak?) after onComplete?\n                .subscribe({\n                    debug { \"### all done but how to cleanup this subscription?\"}\n                }, { throwable ->\n                    warn { \"### createMetaWearSensorObserver not properly stopped: \" + throwable.message + throwable.toString()}}, {\n            })\n\n```\nI realise I still have work on this (like my todo for handling the leak; any suggestion is welcomed :-). I don't completely understand why most status 133 issues gone. I need a bit more debugging/testing to confirm this additional code caused the improvement (I didn't have for this to today).\nAnother assumption for the status 133 issue during development is that the running Android Activity is forcefully killed by Android Studio(?). The Underlying layers on the Android platform might have the connection still opened? Next restarting the simple Activity, trying to connect to the BLE device, cause a similar race condition as described above (or at least confuse the RxAndroidBle FW about the state of the underlying layers)(?)\nI hope this gives others some fresh inspiration :-). @dariuszseweryn Based on your suggestion I tried .retryWhen with a delay mechanism. The log traces indicate that the timer is executed but the actual retry never happens. When commenting out the delays, the retry happens! Strange but Luckily, after much trying, the delay seems unnecessary.\nI tried these:\nkotlin\n                    .retryWhen({\n                        val counter = AtomicInteger()\n                        warn { \"### retrying ${counter}\" }\n                        it.takeWhile { error ->\n                                warn { \"### takeWhile error: ${error}\" }\n                                counter.getAndIncrement() != 3\n                            }\n                        .flatMap { error ->\n                            warn {\"### delay retry by \" + counter.get() + \" second(s) for error: ${error}\" }\n                            Observable.timer(counter.get().toLong(), TimeUnit.SECONDS)\n                        }\n                    })\nand this variant\nkotlin\n                    .retryWhen({\n                        val counter = AtomicInteger()\n                        warn { \"### retrying ${counter}\" }\n                        it\n                            .takeWhile { error ->\n                                warn { \"### takeWhile error: ${error}\" }\n                                counter.getAndIncrement() != 3\n                            }\n                        .doOnNext { debug { \"### before delay on thread ${Thread.currentThread().getName()}\" } }\n                        .delay(1, TimeUnit.SECONDS)\n                        .doOnNext { debug { \"### after delay on thread ${Thread.currentThread().getName()}\" } }\n                    })\nI see status 133 occurs frequently but I've never seen in fail again after a first retry. I finally stick with this simple:\nkotlin\n                    .retry(4, { throwable ->\n                        warn { \"### within doFinally establishConnection() failed: \" + throwable.message}\n                        true    // force a retry\n                    })\nHope it will help others.\n. ",
    "padhur": "closing the issue, get back the device via client's getBleDevice() API and able to reconnect it back. Hi Dariuszeweryn,\nThanks for the quick response and input.\nPlease find the answers inline\nHave you compared to the vanilla Android API usage?\nNo.I believe the Vanilla and RxBle API interaction logically(w.r.t to scan, connection) remains the same except Rx way.Could you please give me an brief on the major difference if any\nHave you checked the FAQ? It is related to scanning\nyes.Its not exactly related the scanning.\nHave you checked against the newest version of the library?\nNo.I am using 1.6.0-RxJava2, i think the issue may present in the latest version as well, i can confirm it after testing with same.\nIssue:\nAs per my observation, on the below devices\n1.Pixel 2 - Android 8.1.0\n2. Pixel XL - Android 8.0\n3.Samsung S8,S9 - Android 8.1.0\n4. Samsung J7 Prime - Android 7.1.1\n5. Xiaomi Mi - Android 8.1.0\n1.Link 3 or more BLE devices to Android based Handsets\n2.Forcibly disconnect all the three Linked devices\n3.Now, try to link a new BLE device to same Android handset\n4.The scan takes very long time(more than 2 mins some times never) to get the successful scan result of the new BLE device\nIn the above case, when there is a disconnect we are immediately trying to reconnect to the disconnected devices( rxBleDevice.establishConnection(false) ) on the state-change callback.\nSo the request is queued and assume there are three rxBleDevice.establishConnection(false) request at a time and now a scan request has been issued. Until unless the above connection requests completes  either success or fail, the scan request never served.The issue is not observed when all the three devices are in connected state.\nSo, i have fixed it by, do not issue reconnect to the devices immediately on the state-change callback instead add a new scan thread with SCAN_MODE_LOW_POWER and if the bonded device is present in the scan-result go for the connection.\nNow, i don not see the scan delay issue.\nPlease advice if there is any best solution.\nThanks,\nPaddy\n. okay got it, thanks Dariusz.. ",
    "amharms795": "Hmm okay, so what do you think a good fix would be? Ask for a slightly different MTU on each connect? The MTU on the device I am connecting to gets reset on connection loss so I have to change it on each new connect. If you need me to provide logs I can.. Edited the original post with all the relevant information from the log.\nAlso requesting a different MTU didn't work.. Correct, this happens 100% of the time if the device is already bonded and works 100% of the time when it is not.\nModel: Galaxy S6\nOS: Nougat 7.0. I have a \"Hack Fix\" that will work, which is never keep the device bonded on the android OS. However, then the user will get the pair device message on every connect. I also have some more information I would like to show. I will show the logs in order of the following:\n1. Log of connecting while the device in unbonded/unpaired (which works).\n2. Log of when I disconnect.\n3. Log of when I reconnect (says its connected, but after 15 seconds throws the 'MTU Change' Exception).\n4. Log of when I disconnect before the exception happens (before the 15 seconds)\n5. Finally Log of when I reconnect. (which works)???\nAs you can see there is a pattern. While the device is bonded, I have to disconnect and reconnect twice before it works. Maybe something is getting queued or started that shouldn't be when I first disconnect? Then when I abruptly disconnect the second time, some exception gets thrown putting the device in good state for reconnect?\nLog 1\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTING}\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=7\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8C:EC\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nD/RxBle#ClientOperationQueue: FINISHED ConnectOperation(53828653) in 379 ms\nD/RxBle#ConnectionOperationQueue: QUEUED   MtuRequestOperation(212342132)\nD/RxBle#ConnectionOperationQueue: STARTED  MtuRequestOperation(212342132)\nD/BluetoothGatt: configureMTU() - device: B0:B4:48:DD:8C:EC mtu: 245\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTED}\nD/ViewRootImpl@ed17da5[BleDeviceActivity]: ThreadedRenderer.create() translucent=false\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8C:EC interval=6 status=0\nD/BluetoothGatt: onConfigureMTU() - Device=B0:B4:48:DD:8C:EC mtu=245 status=0\nD/RxBle#BluetoothGatt: onMtuChanged mtu=245 status=0\nD/RxBle#ConnectionOperationQueue: QUEUED   ServiceDiscoveryOperation(21897875)\nD/RxBle#ConnectionOperationQueue: FINISHED MtuRequestOperation(212342132) in 610 ms\nD/RxBle#ConnectionOperationQueue: STARTED  ServiceDiscoveryOperation(21897875)\nD/BluetoothGatt: discoverServices() - device: B0:B4:48:DD:8C:EC\nD/BluetoothGatt: onSearchComplete() = Device=B0:B4:48:DD:8C:EC Status=0\nD/RxBle#BluetoothGatt: onServicesDiscovered status=0\nV/RxBle#ServiceDiscoveryOperation: Preparing services description\nV/RxBle#ServiceDiscoveryOperation: --------------- ====== Printing peripheral content ====== ---------------\n-- SNIP --\n--------------- ====== Finished peripheral content ====== ---------------\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8C:EC interval=39 status=0\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 09b0d0a6-f374-4051-a819-67c235f31438 enable: true\nD/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(253023875)\nD/RxBle#ConnectionOperationQueue: FINISHED ServiceDiscoveryOperation(21897875) in 30 ms\nD/RxBle#ConnectionOperationQueue: STARTED  DescriptorWriteOperation(253023875)\nD/BluetoothAdapter: cancelDiscovery\nD/RxBle#BluetoothGatt: onDescriptorWrite descriptor=00002902-0000-1000-8000-00805f9b34fb status=0\nD/RxBle#ConnectionOperationQueue: FINISHED DescriptorWriteOperation(253023875) in 240 ms\nLog 2\nI/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (B0:B4:48:DD:8C:EC)\nD/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(136959590)\nD/RxBle#Executors$RunnableAdapter: Terminated.\nD/BluetoothGatt: setCharacteristicNotification() - uuid: 09b0d0a6-f374-4051-a819-67c235f31438 enable: false\nD/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(136959590)\nD/BluetoothManager: getConnectionState()\nD/BluetoothManager: getConnectedDevices\nD/RxBle#ConnectionOperationQueue: QUEUED   DescriptorWriteOperation(238790234)\nI/BtR100ConnectHandler: RxBleConnectionState{DISCONNECTING}\nD/BluetoothGatt: cancelOpen() - device: B0:B4:48:DD:8C:EC\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8C:EC\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=7\nI/BtR100ConnectHandler: RxBleConnectionState{DISCONNECTED}\nD/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(136959590) in 36 ms\nLog 3 (Exception would be thrown here after about 15 seconds)\nI/MAC-ADDRESS: B0:B4:48:DD:8C:EC\nI/BleManager: rawSubscription\nD/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(190237551)\nD/RxBle#ClientOperationQueue: STARTED  ConnectOperation(190237551)\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTING}\nV/RxBle#BleConnectionCompat: Connecting without reflection\nD/BluetoothGatt: connect() - device: B0:B4:48:DD:8C:EC, auto: false\nD/BluetoothAdapter: isSecureModeEnabled\nD/BluetoothGatt: registerApp()\n    registerApp() - UUID=21c46808-f072-4fda-b2ca-35f026f333a2\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=7\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8C:EC\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTED}\nD/RxBle#ClientOperationQueue: FINISHED ConnectOperation(190237551) in 859 ms\nD/RxBle#ConnectionOperationQueue: QUEUED   MtuRequestOperation(117404345)\nD/RxBle#ConnectionOperationQueue: STARTED  MtuRequestOperation(117404345)\nD/BluetoothGatt: configureMTU() - device: B0:B4:48:DD:8C:EC mtu: 216\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8C:EC interval=6 status=0\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8C:EC interval=39 status=0\nLog 4\n09-27 09:44:21.229 12561-12724/com.flir.radiation I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (B0:B4:48:DD:8C:EC)\n09-27 09:44:21.230 12561-12724/com.flir.radiation D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(241677555)\n09-27 09:44:21.230 12561-16550/com.flir.radiation W/RxBle#ConnectionOperationQueue: Queue's awaitRelease() has been interrupted abruptly while it wasn't released by the release() method.\n    java.lang.InterruptedException\n        at java.lang.Object.wait(Native Method)\n        at com.polidea.rxandroidble.internal.serialization.QueueSemaphore.awaitRelease(QueueSemaphore.java:15)\n        at com.polidea.rxandroidble.internal.serialization.ConnectionOperationQueueImpl$1.run(ConnectionOperationQueueImpl.java:70)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\n09-27 09:44:21.231 12561-12718/com.flir.radiation D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(241677555)\n09-27 09:44:21.232 12561-12725/com.flir.radiation D/BluetoothManager: getConnectionState()\n    getConnectedDevices\n09-27 09:44:21.232 12561-12561/com.flir.radiation I/BtR100ConnectHandler: RxBleConnectionState{DISCONNECTING}\n09-27 09:44:21.236 12561-12725/com.flir.radiation D/BluetoothGatt: cancelOpen() - device: B0:B4:48:DD:8C:EC\n09-27 09:44:21.241 12561-12574/com.flir.radiation D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8C:EC\n09-27 09:44:21.244 12561-12574/com.flir.radiation D/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\n09-27 09:44:21.247 12561-16550/com.flir.radiation D/RxBle#ConnectionOperationQueue: FINISHED MtuRequestOperation(117404345) in 8206 ms\n09-27 09:44:21.247 12561-16550/com.flir.radiation D/RxBle#Executors$RunnableAdapter: Terminated.\n09-27 09:44:21.247 12561-12725/com.flir.radiation D/BluetoothGatt: close()\n09-27 09:44:21.248 12561-12725/com.flir.radiation D/BluetoothGatt: unregisterApp() - mClientIf=7\n09-27 09:44:21.250 12561-12561/com.flir.radiation I/BtR100ConnectHandler: RxBleConnectionState{DISCONNECTED}\n09-27 09:44:21.250 12561-12718/com.flir.radiation D/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(241677555) in 20 ms\nLog 5 (Work)??\nI/MAC-ADDRESS: B0:B4:48:DD:8C:EC\nI/BleManager: rawSubscription\nD/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(186231241)\nD/RxBle#ClientOperationQueue: STARTED  ConnectOperation(186231241)\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTING}\nV/RxBle#BleConnectionCompat: Connecting without reflection\nD/BluetoothGatt: connect() - device: B0:B4:48:DD:8C:EC, auto: false\nD/BluetoothAdapter: isSecureModeEnabled\nD/BluetoothGatt: registerApp()\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=7\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8C:EC\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTED}\nD/RxBle#ClientOperationQueue: FINISHED ConnectOperation(186231241) in 132 ms\nD/RxBle#ConnectionOperationQueue: QUEUED   MtuRequestOperation(116007399)\nD/RxBle#ConnectionOperationQueue: STARTED  MtuRequestOperation(116007399)\nD/BluetoothGatt: configureMTU() - device: B0:B4:48:DD:8C:EC mtu: 215\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8C:EC interval=6 status=0\nD/BluetoothGatt: onConfigureMTU() - Device=B0:B4:48:DD:8C:EC mtu=215 status=0\nD/RxBle#BluetoothGatt: onMtuChanged mtu=215 status=0\nD/RxBle#ConnectionOperationQueue: QUEUED   ServiceDiscoveryOperation(138848138)\nD/RxBle#ConnectionOperationQueue: FINISHED MtuRequestOperation(116007399) in 599 ms\nD/RxBle#ConnectionOperationQueue: STARTED  ServiceDiscoveryOperation(138848138)\nD/BluetoothGatt: discoverServices() - device: B0:B4:48:DD:8C:EC\nD/BluetoothGatt: onSearchComplete() = Device=B0:B4:48:DD:8C:EC Status=0\nD/RxBle#BluetoothGatt: onServicesDiscovered status=0\nV/RxBle#ServiceDiscoveryOperation: Preparing services description\nV/RxBle#ServiceDiscoveryOperation: --------------- ====== Printing peripheral content ====== ---------------\n. Yes it works if I reconnect after the timeout error happens or if I disconnect before and reconnect.. With your suggestion, I am now getting a BleCharacteristicNotFoundException after the MTU_Changed exception gets caught. Which makes sense because the errors will just propagate down since nothing was fixed. Didn't know Android Bluetooth was this bugged.. Here is all the relevant info\n```\nD/BleManager: Constructing BleManager\nI/MAC-ADDRESS: B0:B4:48:DD:8A:60\nD/RxBle#ClientOperationQueue: QUEUED   ConnectOperation(212596467)\nD/RxBle#ClientOperationQueue: STARTED  ConnectOperation(212596467)\nV/RxBle#BleConnectionCompat: Connecting without reflection\nD/BluetoothGatt: connect() - device: B0:B4:48:DD:8A:60, auto: false\nD/BluetoothAdapter: isSecureModeEnabled\nD/BluetoothGatt: registerApp()\n    registerApp() - UUID=e19b44b6-daf6-483d-a733-fe56f3f9ba68\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTING}\nD/BluetoothGatt: onClientRegistered() - status=0 clientIf=7\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8A:60\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=2 status=0\nD/RxBle#ClientOperationQueue: FINISHED ConnectOperation(212596467) in 431 ms\nD/RxBle#ConnectionOperationQueue: QUEUED   MtuRequestOperation(219982610)\nD/RxBle#ConnectionOperationQueue: STARTED  MtuRequestOperation(219982610)\nI/BtR100ConnectHandler: RxBleConnectionState{CONNECTED}\nD/BluetoothGatt: configureMTU() - device: B0:B4:48:DD:8A:60 mtu: 202\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8A:60 interval=6 status=0\nD/BluetoothGatt: onClientConnParamsChanged() - Device=B0:B4:48:DD:8A:60 interval=39 status=0\nD/BluetoothAdapter: cancelDiscovery\nD/RxBle#ConnectionOperationQueue: FINISHED MtuRequestOperation(219982610) in 30007 ms\nD/Error\u00a0happened: whoops!\n    com.polidea.rxandroidble.exceptions.BleGattCallbackTimeoutException: GATT exception from MAC address B0:B4:48:DD:8A:60, with type BleGattOperation{description='ON_MTU_CHANGED'}\n        at com.polidea.rxandroidble.internal.SingleResponseOperation.timeoutFallbackProcedure(SingleResponseOperation.java:87)\n        at com.polidea.rxandroidble.internal.SingleResponseOperation.protectedRun(SingleResponseOperation.java:52)\n        at com.polidea.rxandroidble.internal.QueueOperation$1.call(QueueOperation.java:42)\n        at com.polidea.rxandroidble.internal.QueueOperation$1.call(QueueOperation.java:38)\n        at rx.internal.operators.OnSubscribeCreate.call(OnSubscribeCreate.java:72)\n        at rx.internal.operators.OnSubscribeCreate.call(OnSubscribeCreate.java:32)\n        at rx.Observable.unsafeSubscribe(Observable.java:10256)\n        at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.call(OperatorSubscribeOn.java:100)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n        at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\nD/RxBle#ConnectionOperationQueue: QUEUED   ServiceDiscoveryOperation(226472656)\nD/RxBle#ConnectionOperationQueue: STARTED  ServiceDiscoveryOperation(226472656)\nD/BluetoothGatt: discoverServices() - device: B0:B4:48:DD:8A:60\nD/BluetoothGatt: onSearchComplete() = Device=B0:B4:48:DD:8A:60 Status=0\nD/RxBle#BluetoothGatt: onServicesDiscovered status=0\nV/RxBle#ServiceDiscoveryOperation: Preparing services description\nV/RxBle#ServiceDiscoveryOperation: --------------- ====== Printing peripheral content ====== ---------------\n    PERIPHERAL ADDRESS: B0:B4:48:DD:8A:60\n    PERIPHERAL NAME: R100 L8A60\n    -------------------------------------------------------------------------\nPrimary Service - Generic Access (00001800-0000-1000-8000-00805f9b34fb)\nInstance ID: 1\n-> Characteristics:\n--------------- ====== Finished peripheral content ====== ---------------\n\nE/BleManager: Connection Error\n    com.polidea.rxandroidble.exceptions.BleCharacteristicNotFoundException: Characteristic not found with UUID 09b0d0a6-f374-4051-a819-67c235f31438\n        at com.polidea.rxandroidble.RxBleDeviceServices$2.call(RxBleDeviceServices.java:76)\n        at com.polidea.rxandroidble.RxBleDeviceServices$2.call(RxBleDeviceServices.java:67)\n        at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:48)\n        at rx.internal.operators.OnSubscribeFromCallable.call(OnSubscribeFromCallable.java:33)\n        at rx.Observable.unsafeSubscribe(Observable.java:10256)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\n        at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n        at rx.observers.Subscribers$5.onNext(Subscribers.java:235)\n        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:135)\n        at rx.internal.operators.CachedObservable$ReplayProducer.replay(CachedObservable.java:403)\n        at rx.internal.operators.CachedObservable$CacheState.dispatch(CachedObservable.java:220)\n        at rx.internal.operators.CachedObservable$CacheState.onNext(CachedObservable.java:191)\n        at rx.internal.operators.CachedObservable$CacheState$1.onNext(CachedObservable.java:171)\n        at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onNext(OnSubscribeDoOnEach.java:101)\n        at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onNext(OnSubscribeDoOnEach.java:101)\n        at rx.internal.operators.OnSubscribeSwitchIfEmpty$AlternateSubscriber.onNext(OnSubscribeSwitchIfEmpty.java:153)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\n        at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n        at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n        at rx.internal.operators.OperatorUnsubscribeOn$1.onNext(OperatorUnsubscribeOn.java:52)\n        at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onNext(OperatorSubscribeOn.java:74)\n        at rx.internal.operators.OnSubscribeCreate$NoneEmitter.onNext(OnSubscribeCreate.java:173)\n        at com.polidea.rxandroidble.internal.util.QueueReleasingEmitterWrapper.onNext(QueueReleasingEmitterWrapper.java:46)\n        at rx.internal.util.ObserverSubscriber.onNext(ObserverSubscriber.java:34)\n        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)\n        at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\n        at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\n        at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onNext(OperatorTimeoutBase.java:131)\n        at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n        at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n        at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.setProducer(OperatorTimeoutBase.java:115)\n        at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:110)\n        at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n        at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onNext(OnSubscribeDoOnEach.java:101)\n        at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n        at rx.internal.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:107)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:762)\nD/RxBle#ConnectionOperationQueue: FINISHED ServiceDiscoveryOperation(226472656) in 40 ms\nI/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (B0:B4:48:DD:8A:60)\nD/RxBle#Executors$RunnableAdapter: Terminated.\nD/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(256215346)\nD/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(256215346)\nD/BluetoothManager: getConnectionState()\n    getConnectedDevices\nI/BtR100ConnectHandler: RxBleConnectionState{DISCONNECTING}\nD/BluetoothGatt: cancelOpen() - device: B0:B4:48:DD:8A:60\nD/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=B0:B4:48:DD:8A:60\nD/RxBle#BluetoothGatt: onConnectionStateChange newState=0 status=0\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=7\nI/BtR100ConnectHandler: RxBleConnectionState{DISCONNECTED}\nD/RxBle#ClientOperationQueue: FINISHED DisconnectOperation(256215346) in 36 ms\n```. ",
    "amirziarati": "tried to edit the post to be according the template.. its already set to verbose and the whole log from the library side is added to post. since the library doesnt log when it send me a connecting state i put a log by myself printing when connecting state is emitted.\nill also add client and GAT source repo to my post.. I read about auto connect. obviously i dont want a exception after 30 seconds if the device was not found. i prefer it keeps searching and inform me whenever it finds the device. am i missing something ?. the code i sent you is just an example. i am sing this code in a background service and i need it to wait for te device to advertise. so i need to call establish with autoConnect=true. what should i do to make it work ?\n. anyway changing it to false works on android things but i have a problem with another hardware. it keeps giving me 133 GatError while trying to reconnect to a previously bonded device. it only happens on android version 7.\nI found that there is a method in android api that if i call it with four parameters sending 2 as last parameter this problem will e solved:\ncGatt.connectGatt(this, false, gattCallback, 2);\nsince i dont use android api directly and i use your library to conenct how can i acheive this ?. i just read the library code and i saw you are doing the same for android versions higher than M. but anyway this 133 error is happening to me. i dont know what to do.. this is the error:\nio.reactivex.exceptions.UndeliverableException: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from 88:D2:BF:01:05:B4 with status 133 (GATT_ERROR)\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\n        at io.reactivex.internal.operators.observable.ObservableUnsubscribeOn$UnsubscribeObserver.onError(ObservableUnsubscribeOn.java:67)\n        at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onError(ObservableSubscribeOn.java:63)\n        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.tryOnError(ObservableCreate.java:85)\n        at com.polidea.rxandroidble2.internal.util.DisposableUtil$3.onError(DisposableUtil.java:60)\n        at io.reactivex.internal.operators.single.SingleDoFinally$DoFinallyObserver.onError(SingleDoFinally.java:79)\n        at io.reactivex.internal.operators.single.SingleTimeout$TimeoutMainObserver.onError(SingleTimeout.java:142)\n        at io.reactivex.internal.operators.single.SingleCreate$Emitter.tryOnError(SingleCreate.java:95)\n        at com.polidea.rxandroidble2.internal.util.DisposableUtil$1.onError(DisposableUtil.java:24)\n        at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onError(FlowableElementAtSingle.java:101)\n        at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.checkTerminate(FlowableFlatMap.java:566)\n        at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.drainLoop(FlowableFlatMap.java:374)\n        at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.drain(FlowableFlatMap.java:366)\n        at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.innerError(FlowableFlatMap.java:605)\n        at io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.onError(FlowableFlatMap.java:668)\n        at io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.onError(SingleToFlowable.java:68)\n        at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onError(ObservableElementAtSingle.java:104)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:506)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:335)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onError(ObservableFlatMap.java:582)\n        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)\n        at io.reactivex.Observable.subscribe(Observable.java:12030)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:165)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\n        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onNext(ObservableCreate.java:67)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.notifySubscribersAboutException(DisconnectionRouter.java:124)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onExceptionOccurred(DisconnectionRouter.java:113)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onDisconnectedException(DisconnectionRouter.java:99)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:191)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:70)\n        at android.os.Binder.execTransact(Binder.java:565)\n        Suppressed: java.lang.Throwable: HERE SDK Version: 3.7.0.118\n        at com.nokia.maps.MapsEngine$l.uncaughtException(MapsEngine.java:378)\n        at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:1068)\n        at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:1063)\n        at io.reactivex.plugins.RxJavaPlugins.uncaught(RxJavaPlugins.java:429)\n        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:383)\nit happens only on Huawei p9 android 7.. ",
    "saramotiv": "Erasing app data and resetting the phone actually helped. I had the problem in 2 different devices: Google Pixel Android 7.1.2 API 25 and Samsung Galaxy S9 SM-G960U. I will update the library.. ",
    "hjh2881": "can you share the basic code ?i don't know how to send data with write type no_response. ",
    "Rogue899": "\nHello,\nI do not see how this is a library issue\n\ni do not know what is the issue but after googling the problem many people suggested that maybe it is a plugin issue so i screenshot it for clarification, the question is why isn't github showing in the VCS.... ",
    "lukaszkalnik": "I have entered my first and last name while signing the CLA and it seems to have been misinterpreted as a second contributor (Lukasz Kalnik). Could you please remove it? Thanks.. Actually this commit doesn't change anything in perspective of the whole PR (just changes two Strings in two Activities, which I later moved anyway to strings.xml in another commit).\nCan you remove it from history?\nI would remove it myself, but I probably cannot force push it, right?. I rebased and removed the commit (and force pushed) but the offending commit is still there... There is now just one merge remote commit on top.\nAlso when I created new PR from the same branch, the commit was still in the history, although I don't see it locally anymore.\nProbably the best would be to just create a new branch from cherry-picked commits.. Thank you for your suggestions. Seems like the rebase in Source Tree doesn't work so well. I did it from the command line now and it worked :). That's a great idea, I will modify my PR and add a sample-kotlin module.. Closing as the whole kotlin sample app has been moved to the sample-kotlin module.. @RobLewis theoretically you could use any MVP library, like ThirtyInch. Although like @dariuszseweryn wrote it's probably better to keep the examples simple and not mix too many concepts.\n@dariuszseweryn I will remove RxLifecycle then \ud83d\udc4d . I will just close this PR then and open another one.. This is ready for review. The TODOs in the code are only because I haven't added the appropriate classes yet. Otherwise the PR would grow too big.\nI wzajemnie, szcz\u0119\u015bliwego Nowego Roku! ;). It was just an excercise for me. You're right, the build script is not that complex that it would give an advantage to the project.\nAnd it seems to have caused different other inconveniences, so I think we could skip it.\nYou can close it :+1:. Thank you for your reviews! It was fun doing this conversion :)\nSo now there are equivalent Java and Kotlin samples in the project \ud83d\udc4d . https://github.com/grandcentrix/AndroidCodeStyle\nIt uses official Kotlin code style.\nAlso it sets line length to 118, so there are less wraps.. \ud83d\udc4d . This one does get disposed by calling triggerDisconnect() in onPause().. Just forgotten to remove it.. ",
    "marvson": "\nThe library itself uses Context.getApplicationContext() inside on the Context passed into RxBleClient.create(Context). I doubt that this is the problem\n\nThis helps a lot. I confirmed that it is OS related. It only happens in Miui 9.6.5, Android 7.1 Nougat. I tried in a Samsung with android 5.1 and it works just fine. And I found this explanation on stackoverflow link seems legit. And when I fixed the process, a thing that you can make in miui, it worked fine. Seems like it optimizes the process killing something important. No clue about what exactly happens but now I know how to fix it. Thank you.. I don't know the exact naming but \"lock the proccess\" is more like it. if you tap the button to show all opened apps and drag an app window down, then a lock appears in the top right of that window. It kind of protects the app from being optimized by miui, it also can't be terminated by android.\nThis actually was't what solved it to me. I just modified to not use dagger2 and to use the activity context, because I don't think it's a good thing asking the user to lock the app, since I can't do it programatically.. ",
    "rouddy": "Thanks for your reply. I have not checked yet. I will try the solution.. ",
    "cisekluke": "Yes, I'm using this method.. ",
    "EverSinceWWI": "\nHi, I guess the issue is not in the lib.\nYou are subscribing to a long running RxJava chain and disposing it immediately after it. So the whole call gets canceled before it could be executed completely.\n\nas soon as i moved the disposable.dispose() line everything worked perfectly! I feel so stupid for not having though about it earlier :P\nThank you so much!. ",
    "akhbulatov": "@dariuszseweryn thank you, I realized what was the problem and fixed it. Here's a solution if anyone else needs it:\n```\noverride fun connectDevice() {\n        rxBleClient.scanBleDevices(scanSettings, scanFilter)\n            .flatMap { scanResult -> scanResult.bleDevice.establishConnection(false) }\n            .flatMapSingle {\n                rxBleConnection = it\n                it.discoverServices()\n            }\n            .flatMapSingle { obtainCharacteristics(it) }\n            .subscribeBy(\n                onNext = {\n                    writeCharacteristic = it.second\n                    proceedConnectDevice(it.first)\n                },\n                onComplete = {},\n                onError = { Timber.d(\"$it\") }\n            )\n    }\nprivate fun proceedConnectDevice(readCharacteristic: BluetoothGattCharacteristic) {\n        writeDescriptor(readCharacteristic)\n            .andThen(Single.fromCallable { startConnection() })\n            .flatMap { it }\n            .flatMapObservable { setupAndObserveNotifications(readCharacteristic) }\n            .subscribeBy(\n                onNext = { keepConnection() },\n                onComplete = {},\n                onError = {}\n            )\n}\n``. @dariuszseweryn I would like to clarify one point: I haven't noticed use ofsubscribeOn` in sample. Requests in the library by default are not executed on the current thread?. Ok, thanks.. Okay, thanks for the answer). @dariuszseweryn and why it tries to connect twice? The problem in my connection method I added on top? . ",
    "KawtharE": "Thanks for your response @dariuszseweryn , well I have actually tried to disconnect from device after receiving data and even tried to close and disconnect from the Gatt and I always get the same result, it seems something (I think it's an observable) that force to always ends up with a default scenario which I have concluded it while debugging the app:\nThe library manage the close and disconnect of the Gatt but immediately the Gatt open a connection even if I set false to establishConnection function, below is what shown in Logcat:\n```\nD/BluetoothGatt: close()\nD/BluetoothGatt: unregisterApp() - mClientIf=7\nD/BleActivity: RxBleConnectionState{DISCONNECTED}\nD/BleService: bluetoothGatt.bonded devices RxBleConnectionState{DISCONNECTED}\n...\nD/BleActivity: RxBleConnectionState{CONNECTING}\nD/BleService: bluetoothGatt.bonded devices RxBleConnectionState{CONNECTING}\nD/BluetoothGatt: connect() - device: 00:13:43:5D:DE:B8, auto: false\n```\nI have been working with this library with more than 3 projects and i have notice that it keeps a kind of link between the mobile and the device that cannot be destroyed only if app is desintalled.\nAbout the time of scan, in my case it's perfect so no problem come from this configuration.. ",
    "desnyki": "Two reasons generally come to mind. Your advertisement interval is long so the scan and advertisements fail to be synchronized. \nScan with the ScanSettings.SCAN_MODE_LOW_LATENCY flag to see if this is true.\nSecond, you peripheral isn't advertising because it still thinks you are connected. Implement some sort of heart beat to see if the connection is valid and reset the ble state if it's not. You can quickly test for this by simply power cycling your peripheral.. ",
    "Steppschuh": "After thinking more about it I agree that the library should not work around this.\nHowever, I stumbled upon this issue because this behaviour change was not well documented / announced. It could save other developers some time if the library would print an informational message if it detects that someone is scanning without a filter on 8.1 or later. Maybe there's room for a section mentioning this change in the readme, too.\nJust for reference, this implementation works around this behaviour change:\njava\nrxBleClient = RxBleClient.create(context);\nscanSettings = new ScanSettings.Builder().build();\nscanFilter = new ScanFilter.Builder().build();\nrxBleClient.scanBleDevices(scanSettings, scanFilter).subscribe(\n    scanResult -> Log.v(\"BLE Scanner\", scanResult.toString())\n);. ",
    "davordev": "RxReplayingShare isn't mentioned anywhere in the docs. I literally had to go through samples to find out on how to properly set up connection sharing. It was hard to find, but once I found it, I had no idea is it going to let me share the connection. I fixed my issue by trial and error method. Personally, I am against using operator to preserve the connection or even putting the connection stream to Disposable (I had some real unlogic issues while applying this framework to Clean Architecture). The best, user-friendly way would be to have two functions on RxBleClient:\n- getConnection(): Observable throws RxBleDeviceNotConnected\n- closeConnection(cleanUpCode: () -> Unit): Unit\nThere may be some syntax errors, but generally, you get the idea.\nCheers. I could possibly make a gist. Is it okay if I post it here?. Sorry for the delay. Here's an example:\nBleSessionManager.kt\n```\n/*\n * Manages Bluetooth connection.\n * @property rxBleClient RxBleClient\n * @property mSchedulerProvider SchedulerProvider\n * @property eventStream CompositeDisposable\n * @property macAddress String?\n * @property disconnectTriggerSubject PublishSubject\n * @property _connection Observable?\n * @property connection Observable\n * @constructor\n /\nclass BleSessionManager(\n    val rxBleClient: RxBleClient,\n    val mSchedulerProvider: SchedulerProvider\n) {\nprivate val eventStream: CompositeDisposable = CompositeDisposable()\nprivate var macAddress: String? = null\nprivate val disconnectTriggerSubject: PublishSubject<Boolean> = PublishSubject.create<Boolean>()\nprivate var _connection: Observable<RxBleConnection>? = null\n\nvar connection: Observable<RxBleConnection>\n    get() {\n        return _connection ?: connectionFallback()\n    }\n    private set(value) {\n        this._connection = value\n    }\n\n/**\n * Fallback in case connection isn't valid.\n * @return Observable<RxBleConnection>\n */\nprivate fun connectionFallback(): Observable<RxBleConnection> {\n    return Observable.error(NotConnectedException())\n}\n\n/**\n * Used to set mac address.\n * @param macAddress String\n */\nfun setMacAddress(macAddress: String) {\n    this.macAddress = macAddress\n}\n\n/**\n * Configures connection. Called after `setMacAddress()`.\n * @throws NotFoundException May throw NotFoundException if mac address is not set.\n */\nfun setupConnection() {\n    val address = this.macAddress ?: throw NotFoundException()\n\n    val observable = rxBleClient.getBleDevice(address)\n        .establishConnection(true, Timeout(BLE_CONNECT_OPERATION_TIMEOUT, TimeUnit.SECONDS))\n        .takeUntil(disconnectTriggerSubject)\n        .compose(ReplayingShare.instance())\n\n    // Subscribe actions should be implemented even though they have no implementation.\n    val disposable = observable\n        .subscribeOn(mSchedulerProvider.io())\n        .retry(10)\n        .subscribe(\n            {},\n            {},\n            {}\n        )\n    eventStream.add(disposable)\n    connection = observable\n}\n\n/**\n * Shuts down the connection and clears event stream.\n */\nprivate fun closeConnection() {\n    disconnectTriggerSubject.onNext(true)\n    eventStream.clear()\n}\n\n/**\n * Nullifies connection. Triggered by End User.\n */\nfun disconnect() {\n    closeConnection()\n    _connection = null\n}\n\n/**\n * Nullifies connection, but executes the given code before. Triggered by End User.\n */\nfun disconnectButFirst(extensionCode: () -> Unit) {\n    extensionCode()\n    disconnect()\n}\n\n}\n```\nBluetoothService.kt\n```\nclass BluetoothService(\n    val bluetoothClient: RxBleClient,\n    val bluetoothScanSettings: ScanSettings,\n    val mSchedulerProvider: SchedulerProvider,\n    val bleSessionManager: BleSessionManager\n) : IBluetoothService {\nprivate fun observeConnection(device: RxBleDevice): Observable<ConnectionState> {\n    return device\n        .observeConnectionStateChanges()\n        .throttleLatest(500, TimeUnit.MILLISECONDS)\n        .subscribeOn(mSchedulerProvider.io())\n        .map { it.mapToConnectionState() }\n}\n\noverride fun connectToDevice(macAddress: String): Observable<ConnectionState> {\n    val device = bluetoothClient.getBleDevice(macAddress)\n    bleSessionManager.setMacAddress(macAddress)\n    bleSessionManager.setupConnection()\n    return observeConnection(device)\n}\n\noverride fun getDeviceShadow(): Single<HelixDeviceShadow> {\n\n    return bleSessionManager.connection\n        .subscribeOn(mSchedulerProvider.io())\n        .firstOrError()\n        .flatMap { it.readCharacteristic(MY_UUID) }\n        .map {\n            it.mapToMyResponse()\n        }\n        .doOnError { it.mapBluetoothGattOperationExceptions() }\n}\n\noverride fun disconnect() {\n\n    var disposable: Disposable? = null\n\n    disposable = bleSessionManager.connection\n        .subscribeOn(mSchedulerProvider.io())\n        .firstOrError()\n        .flatMap {\n            it.writeCharacteristic(SLEEP_UUID, putHelixToSleep())\n        }\n        .ignoreElement()\n        .onErrorComplete()\n        .doFinally {\n\n            disposable?.dispose()\n            otaUpdateDisposables.clear()\n            bleSessionManager.disconnect()\n        }\n        .subscribe()\n}\n\n```. ",
    "hyyu": "How do I check that? Using RxBleDevice? If I'm not wrong it's the class that represents it no?. I've used the filter function from RxJava, and it just appears that the UUIDS that my devices are sending weren't the ones I was waiting for.\nSorry for the ticket, you can close it.. Thanks for the answers, it seems that it's like jreehuis told, coming from the phone itself. . I've had it on Google phones. My personnal phone is a Pixel 3 XL, and had it on Nexus phones.. It's an app I'm currently developing, it is associated to a connected Ble device. It's a rework from an app you can find on the store, Enovap Connect. ",
    "dziubekUK": "Great tip with the lib, thanks! The outcome after integrating RxJava2Debug still does not point to my code, but shows a bit more info:\n2019-02-26 11:46:04.169 14490-14611/com.myapp.debug E/AndroidRuntime: FATAL EXCEPTION: pool-8-thread-1\n    Process: com.myapp.debug, PID: 14490\n    java.lang.Throwable: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:262)\n        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:770)\n        at android.bluetooth.BluetoothGatt.access$200(BluetoothGatt.java:39)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:257)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n        at android.os.Binder.execTransact(Binder.java:731)\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable: caused by com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS). Still no useful info in stacktrace. How should I go about setting up on notification in my case? I provided the snippets earlier. I know it's not optimal with subject, but it seems to be the only way. I want to setup notification once and pass info to caller when the notification is set up. Ok, below I'm pasting entire info I got with RxBleClient.setLogLevel(RxBleLog.VERBOSE) and RxJava2Debug integrated.\n2019-02-26 14:10:05.651 22298-22389/com.myapp.debug D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicWriteOperation(50389996)\n2019-02-26 14:10:05.655 1530-2214/? I/bt_btm_sec: btm_sec_disconnected clearing pending flag handle:9 reason:0\n2019-02-26 14:10:05.656 2195-2208/? D/BluetoothGattServer: onServerConnectionState() - status=0 serverIf=5 device=C5:C1:C4:74:61:88\n2019-02-26 14:10:05.657 1530-1603/? I/btif_av: btif_av_acl_disconnected: Peer c5:c1:c4:74:61:88 : ACL Disconnected\n2019-02-26 14:10:05.657 22298-22380/com.myapp.debug D/RxBle#BluetoothGatt$1: onCharacteristicRead characteristic=ea0b2b14-aafc-2890-e611-a6f3de55935b status=133\n2019-02-26 14:10:05.657 1530-2214/? I/btif_av: BtifAvPeer *BtifAvSource::FindOrCreatePeer(const RawAddress &, tBTA_AV_HNDL): Create peer: peer_address=c5:c1:c4:74:61:88 bta_handle=0x41 peer_id=0\n2019-02-26 14:10:05.657 1530-2214/? W/bt_btif: btif_av_get_peer_sep: No active peer found\n2019-02-26 14:10:05.657 1530-2214/? I/bt_btif_a2dp: btif_a2dp_on_idle: ## ON A2DP IDLE ## peer_sep = 1\n2019-02-26 14:10:05.657 1530-2214/? W/bt_btif: btif_av_get_peer_sep: No active peer found\n2019-02-26 14:10:05.657 1530-2214/? I/bt_btif_a2dp_source: btif_a2dp_source_on_idle: state=STATE_OFF\n2019-02-26 14:10:05.658 1530-2214/? W/bt_btif: btif_av_get_peer_sep: No active peer found\n2019-02-26 14:10:05.658 1530-2214/? I/bt_btif_a2dp: btif_a2dp_on_idle: ## ON A2DP IDLE ## peer_sep = 1\n2019-02-26 14:10:05.658 1530-2214/? W/bt_btif: btif_av_get_peer_sep: No active peer found\n2019-02-26 14:10:05.658 1530-2214/? I/bt_btif_a2dp_source: btif_a2dp_source_on_idle: state=STATE_OFF\n2019-02-26 14:10:05.658 1530-2214/? I/btif_av: DeleteIdlePeers: Deleting idle peer: c5:c1:c4:74:61:88 bta_handle=0x41\n2019-02-26 14:10:05.659 22298-22380/com.myapp.debug D/BluetoothGatt: onClientConnectionState() - status=0 clientIf=7 device=C5:C1:C4:74:61:88\n2019-02-26 14:10:05.659 22298-22389/com.myapp.debug D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicWriteOperation(195922506)\n2019-02-26 14:10:05.659 22298-22380/com.myapp.debug D/RxBle#BluetoothGatt$1: onConnectionStateChange newState=0 status=0\n2019-02-26 14:10:05.664 22298-22380/com.myapp.debug I/RxBle#ConnectionOperationQueue: Connection operations queue to be terminated (C5:C1:C4:74:61:88)\n2019-02-26 14:10:05.666 1530-1530/? D/BluetoothMapService: onReceive\n2019-02-26 14:10:05.666 1530-1530/? D/BluetoothMapService: onReceive: android.bluetooth.device.action.ACL_DISCONNECTED\n2019-02-26 14:10:05.667 22298-22425/com.myapp.debug W/RxBle#ConnectionOperationQueue: Queue's awaitRelease() has been interrupted abruptly while it wasn't released by the release() method.\n    java.lang.InterruptedException\n        at java.lang.Object.wait(Native Method)\n        at com.polidea.rxandroidble2.internal.serialization.QueueSemaphore.awaitRelease(QueueSemaphore.java:15)\n        at com.polidea.rxandroidble2.internal.serialization.ConnectionOperationQueueImpl$1.run(ConnectionOperationQueueImpl.java:71)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:458)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\n        at java.lang.Thread.run(Thread.java:764)\n2019-02-26 14:10:05.667 22298-22389/com.myapp.debug D/RxBle#ConnectionOperationQueue: QUEUED   CharacteristicWriteOperation(178693411)\n2019-02-26 14:10:05.673 22298-22389/com.myapp.debug W/System.err: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java:46)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onError(SingleOnAssembly.java:73)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback$FlatMapSingleObserver.onError(SingleFlatMap.java:116)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onError(SingleOnAssembly.java:73)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onError(ObservableElementAtSingle.java:102)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly$OnAssemblyObserver.onError(ObservableOnAssembly.java:60)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.mixed.CompletableAndThenObservable$AndThenObservableObserver.onError(CompletableAndThenObservable.java:70)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly$OnAssemblyObserver.onError(ObservableOnAssembly.java:60)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:38)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Observable.subscribe(Observable.java:12246)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly.subscribeActual(ObservableOnAssembly.java:41)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Observable.subscribe(Observable.java:12246)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.mixed.CompletableAndThenObservable$AndThenObservableObserver.onComplete(CompletableAndThenObservable.java:80)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.CompletableOnAssembly$OnAssemblyCompletableObserver.onComplete(CompletableOnAssembly.java:71)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.completable.CompletableFromAction.subscribeActual(CompletableFromAction.java:43)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Completable.subscribe(Completable.java:2302)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.CompletableOnAssembly.subscribeActual(CompletableOnAssembly.java:39)\n2019-02-26 14:10:05.674 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Completable.subscribe(Completable.java:2302)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.mixed.CompletableAndThenObservable.subscribeActual(CompletableAndThenObservable.java:45)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Observable.subscribe(Observable.java:12246)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly.subscribeActual(ObservableOnAssembly.java:41)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Observable.subscribe(Observable.java:12246)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java:37)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly.subscribeActual(SingleOnAssembly.java:41)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback.onSuccess(SingleFlatMap.java:84)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback$FlatMapSingleObserver.onSuccess(SingleFlatMap.java:111)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(SingleFromCallable.java:56)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly.subscribeActual(SingleOnAssembly.java:41)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback.onSuccess(SingleFlatMap.java:84)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleCache.subscribeActual(SingleCache.java:59)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly.subscribeActual(SingleOnAssembly.java:41)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap.subscribeActual(SingleFlatMap.java:36)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly.subscribeActual(SingleOnAssembly.java:41)\n2019-02-26 14:10:05.675 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap.subscribeActual(SingleFlatMap.java:36)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly.subscribeActual(SingleOnAssembly.java:41)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3575)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3561)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.Single.subscribe(Single.java:3480)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareRequestsServiceImpl.writeSegmentToPage(FirmwareRequestsServiceImpl.kt:88)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareManagerImpl.writeAllSegments(FirmwareManagerImpl.kt:146)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareManagerImpl.retry(FirmwareManagerImpl.kt:185)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareManagerImpl.handlePageBufferResponse(FirmwareManagerImpl.kt:165)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareManagerImpl.access$handlePageBufferResponse(FirmwareManagerImpl.kt:13)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareManagerImpl$writeSinglePage$1.apply(FirmwareManagerImpl.kt:132)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.myapp.myappcompanydevice.bluetooth.utils.firmware.FirmwareManagerImpl$writeSinglePage$1.apply(FirmwareManagerImpl.kt:13)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback.onSuccess(SingleFlatMap.java:76)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleDoOnError$DoOnError.onSuccess(SingleDoOnError.java:52)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleDoOnSuccess$DoOnSuccess.onSuccess(SingleDoOnSuccess.java:60)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleZipArray$ZipCoordinator.innerSuccess(SingleZipArray.java:119)\n2019-02-26 14:10:05.676 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleZipArray$ZipSingleObserver.onSuccess(SingleZipArray.java:170)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.single.SingleResumeNext$ResumeMainSingleObserver.onSuccess(SingleResumeNext.java:65)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.SingleOnAssembly$OnAssemblySingleObserver.onSuccess(SingleOnAssembly.java:68)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onNext(ObservableElementAtSingle.java:89)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly$OnAssemblyObserver.onNext(ObservableOnAssembly.java:55)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.util.HalfSerializer.onNext(HalfSerializer.java:107)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableTakeUntil$TakeUntilMainObserver.onNext(ObservableTakeUntil.java:79)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly$OnAssemblyObserver.onNext(ObservableOnAssembly.java:55)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:62)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly$OnAssemblyObserver.onNext(ObservableOnAssembly.java:55)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableFilter$FilterObserver.onNext(ObservableFilter.java:52)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.akaita.java.rxjava2debug.extensions.ObservableOnAssembly$OnAssemblyObserver.onNext(ObservableOnAssembly.java:55)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.drainNormal(ObservableObserveOn.java:201)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.run(ObservableObserveOn.java:255)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:288)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:253)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at java.lang.Thread.run(Thread.java:764)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err: Caused by: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS)\n2019-02-26 14:10:05.677 22298-22389/com.myapp.debug W/System.err:     at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:262)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:770)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt.access$200(BluetoothGatt.java:39)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:257)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err:     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err:     at android.os.Binder.execTransact(Binder.java:731)\n2019-02-26 14:10:05.678 22298-22389/com.myapp.debug W/System.err: Caused by: com.akaita.java.rxjava2debug.extensions.RxJavaAssemblyException\n2019-02-26 14:10:05.679 22298-22389/com.myapp.debug I/chatty: uid=10397(com.myapp.debug) pool-9-thread-1 identical 28 lines\n2019-02-26 14:10:05.680 22298-22389/com.myapp.debug W/System.err: Caused by: com.akaita.java.rxjava2debug.extensions.RxJavaAssemblyException\n2019-02-26 14:10:05.680 22298-22380/com.myapp.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 1f26b1a4-2b50-11e7-99a8-fcaa142b0bea enable: false\n2019-02-26 14:10:05.681 1530-2221/? E/BtGatt.GattService: registerForNotification() - No connection for C5:C1:C4:74:61:88...\n2019-02-26 14:10:05.689 10197-10316/? W/SearchServiceCore: Abort, client detached.\n2019-02-26 14:10:05.694 22298-22380/com.myapp.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 2e418704-2b50-11e7-b209-fcaa142b0bea enable: false\n2019-02-26 14:10:05.695 1530-2342/? E/BtGatt.GattService: registerForNotification() - No connection for C5:C1:C4:74:61:88...\n2019-02-26 14:10:05.704 22298-22380/com.myapp.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 00002a19-0000-1000-8000-00805f9b34fb enable: false\n2019-02-26 14:10:05.704 1530-2342/? E/BtGatt.GattService: registerForNotification() - No connection for C5:C1:C4:74:61:88...\n2019-02-26 14:10:05.713 22298-22380/com.myapp.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: 32daa188-2b50-11e7-bff1-fcaa142b0bea enable: false\n2019-02-26 14:10:05.714 1530-2342/? E/BtGatt.GattService: registerForNotification() - No connection for C5:C1:C4:74:61:88...\n2019-02-26 14:10:05.801 22298-22380/com.myapp.debug D/RxBle#ConnectionOperationQueue$2: REMOVED  CharacteristicReadOperation(177682079)\n2019-02-26 14:10:05.806 22298-22389/com.myapp.debug E/AndroidRuntime: FATAL EXCEPTION: pool-9-thread-1\n    Process: com.myapp.debug, PID: 22298\n    java.lang.Throwable: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:262)\n        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:770)\n        at android.bluetooth.BluetoothGatt.access$200(BluetoothGatt.java:39)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:257)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n        at android.os.Binder.execTransact(Binder.java:731)\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable\n     Caused by: java.lang.Throwable: caused by com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter$8.apply(DisconnectionRouter.java:167)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter$8.apply(DisconnectionRouter.java:164)\n        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\n        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onNext(ObservableCreate.java:66)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.notifySubscribersAboutException(DisconnectionRouter.java:123)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onExceptionOccurred(DisconnectionRouter.java:112)\n        at com.polidea.rxandroidble2.internal.connection.DisconnectionRouter.onDisconnectedException(DisconnectionRouter.java:98)\n        at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n        at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:262)\n        at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:770)\n        at android.bluetooth.BluetoothGatt.access$200(BluetoothGatt.java:39)\n        at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:257)\n        at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n        at android.os.Binder.execTransact(Binder.java:731)\n2019-02-26 14:10:05.806 22298-22380/com.myapp.debug D/RxBle#ClientOperationQueue: QUEUED   DisconnectOperation(143355081)\n2019-02-26 14:10:05.806 22298-22350/com.myapp.debug D/RxBle#ClientOperationQueue: STARTED  DisconnectOperation(143355081)\n2019-02-26 14:10:05.809 22298-22380/com.myapp.debug D/BluetoothGatt: setCharacteristicNotification() - uuid: f01d5b50-2b64-11e7-b85b-fcaa142b0bea enable: false\n2019-02-26 14:10:05.810 1530-2342/? E/BtGatt.GattService: registerForNotification() - No connection for C5:C1:C4:74:61:88...\n2019-02-26 14:10:05.810 22298-22360/com.myapp.debug D/BluetoothManager: getConnectionState()\n2019-02-26 14:10:05.811 22298-22360/com.myapp.debug D/BluetoothManager: getConnectedDevices\n2019-02-26 14:10:05.811 22298-22380/com.myapp.debug W/System.err: com.polidea.rxandroidble2.exceptions.BleDisconnectedException: Disconnected from C5:C1:C4:74:61:88 with status 0 (GATT_SUCCESS)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at com.polidea.rxandroidble2.internal.connection.RxBleGattCallback$2.onConnectionStateChange(RxBleGattCallback.java:77)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt$1$4.run(BluetoothGatt.java:262)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt.runOrQueueCallback(BluetoothGatt.java:770)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt.access$200(BluetoothGatt.java:39)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at android.bluetooth.BluetoothGatt$1.onClientConnectionState(BluetoothGatt.java:257)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at android.bluetooth.IBluetoothGattCallback$Stub.onTransact(IBluetoothGattCallback.java:71)\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err:     at android.os.Binder.execTransact(Binder.java:731)\n2019-02-26 14:10:05.812 1196-5014/? W/ActivityManager:   Force finishing activity com.myapp.debug/com.myapp.myappcompanydevice.ui.firmware.FirmwareActivity\n2019-02-26 14:10:05.812 22298-22380/com.myapp.debug W/System.err: Caused by: com.akaita.java.rxjava2debug.extensions.RxJavaAssemblyException\n2019-02-26 14:10:05.814 22298-22380/com.myapp.debug I/chatty: uid=10397(com.myapp.debug) Binder:22298_4 identical 55 lines\n2019-02-26 14:10:05.814 22298-22380/com.myapp.debug W/System.err: Caused by: com.akaita.java.rxjava2debug.extensions.RxJavaAssemblyException\n2019-02-26 14:10:05.814 22298-22380/com.myapp.debug W/System.err:   [CIRCULAR REFERENCE:com.akaita.java.rxjava2debug.extensions.RxJavaAssemblyException]\n2019-02-26 14:10:05.814 22298-22380/com.myapp.debug E/FirmwareRequestsServiceImpl$startResponsesListener: Error during notification setting: kotlin.Unit\n2019-02-26 14:10:05.815 22298-22360/com.myapp.debug D/BluetoothGatt: close()\n2019-02-26 14:10:05.815 22298-22360/com.myapp.debug D/BluetoothGatt: unregisterApp() - mClientIf=7. I'll try that rewrite and post more info, but I had checked the subject you're talking about before and no error was propagated on it. No more intel on this after suggested rewrite. Crash is still happening. I double checked - all .subscribe() methods in the entire project have an on error part. I'll check the feasibility of creating such minimal application and get back to you. I've turned off one of the service using bluetooth inside app and replicated crash scenario. App crashed, but more logs appeared this time pointing to my code. Closing the issue - thanks for help and ideas. ",
    "ihenchi": "@uKL the configurable connecting timeout is set at the RxBleDevice level. I am not sure how I can extend OperationConnectTest.. ",
    "offwhiite": "Do I have to replace notifySubscribersAboutException() with bleExceptionBehaviorRelay.accept (exception)?\nThere is nothing right now.. Thank you for reply! \nI'm sorry. If you look closely, you are streaming to bleExceptionBehaviorRelay in subscribe...\n. "
}