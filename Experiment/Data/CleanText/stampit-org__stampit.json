{
    "ericelliott": "Picky, picky...\n. See license.txt\n. I wish I could +1 Github comments.\n. That's intentional. It's a conditional shim for Array.prototype.indexOf() which is required by json-stringify-safe, which is used to safely clone state.\n. Done. Thanks for the help!\n. It's a bad practice to create side-effects during object initialization. So, if you take side-effects off the table, and recognize that you can set properties just by passing a map of keys and values into any stampit-generated factory, the primary use of .enclose() becomes easier to understand: Not as a do-anything constructor, but as a way to create data privacy via encapsulation.\nIn JavaScript, encapsulation happens as a result of a closure. A closure gives you access to anything that was within scope of a function at function define-time, even after that function has finished running. That means that when you pass a function into .enclose(), you are explicitly creating a closure around those variables so that you can access them later.\nIn the following code, the only way to get secret is to call foo.getSecret():\n``` js\nvar foo = stampit().enclose(function () {\n  var secret = 'hidden';\n  this.getSecret = function () {\n    return secret;\n  }\n}).create();\nfoo.getSecret(); // 'hidden'\n```\n. >  \"Or even yet, i'm designing the domain in some weird wrong way?\"\njs\nperson = model({resource: 'people'});\narthur = person({name: 'Arthur'});\nHere, it looks like you're trying to create a person object that is a model (inherits model properties).\nNext you're trying to create an instance of person named arthur (inherits person properties).\nThis has classical inheritance parent/child hierarchy stamped all over it. See the talk Classical Inheritance is Obsolete: How to Think in Prototypal OO to wrap your head around why you might want to think differently about the problem domain.\nAn alternative to this would be to create stamps for model and person independent of each other:\n``` js\nvar model = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar entity = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar person = stampit.compose(model, entity);\nvar arthur = person({name: 'Arthur'});\n```\nThis is assuming that Arthur really needs to inherit everything from model and entity.\nYour model really looks like a collection, however. In which case, you can do something like:\n``` js\n// create an actual collection instance\nvar myCollection = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /).create();\n// Specific stuff for people\nvar person = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar arthur = person({name: 'Arthur'});\n// This is a side effect. It's best NOT to have side effects mixed in with object instantiation.\nmyCollection.add(arthur);\n```\nDoes that clarify things a little?\n. As an answer to the callable object question, you actually do have access to object instantiation in the factory via .enclose(). You can return any arbitrary object from .enclose() (including a function with methods attached to it), and that will be what pops out of the factory.\n. One more time:\nIt looks like you're trying to subclass model, which is not what you want.\njs\nvar person = model(/* options_for_modules: */ { resource: 'people', route: '/profiles' });\nDo you see why this looks like a subclass? Compare to these alternatives:\n``` js\nvar resourcable = stampit().methods({\n    save: function () { return 'saved!';}\n  }).state({resource: 'default'});\n// What is base?\nvar base = stampit().state({base: 'base'});\n// Why does model need to know about resourcable\n// and base? Can't it just have the model-specific\n// functionality and let you mix-in resourcable and\n// base as-needed? I'd need to see more use-cases\n// to suggest a better design.\nvar model = stampit.compose(resourcable, base);\n// This multi-layer inheritance is a bit dangerous.\n// It's usually better to be explicit about what\n// pieces you're inheriting.\nvar person = stampit.compose(model).state({\n  resource: 'people',\n  route: '/profiles'\n});\n// A (perhaps better) alternative:\nvar person = stampit.compose(resourcable, base).state({\n  resource: 'people',\n  route: '/profiles'\n});\nvar arthur = person({name: 'Arthur'});\narthur.resource // people\narthur.save() // saved!\n```\nEssentially, any time you see multiple levels of inheritance, you should see this:\n\n\nMy problem is essentially that if i return a function object, it does not get the state and the methods. Because, on the factory definition, i do not have access to the object instantiation/creation, the stampit will always instantiate an object, not a function object, and then extend it and then replace by whatever i return.\n\nThere are some complications with returning a custom function from .enclose(). You can't create a function with a custom prototype in JavaScript (at least, not using any technique I am aware of). The corollary here is that you must copy all your methods to the instance, and not use stampit().methods(). Side-effect: You can't keep any prototype state using this technique.\nBecause of those limitations, it doesn't make a lot of sense to make special considerations for supporting it -- I'd have to make decisions which might be right for some use-cases, but wrong for others. If you want to try to roll your own support, yes, in fact, you can return anything you want from stampit().enclose():\n``` js\nvar stampit = require('stampit');\nvar foo = stampit().methods({\n    foo: function () { return 'foo'; }\n});\nvar bar = stampit().methods({\n    bar: function () { return 'bar'; }\n});\nvar baz = stampit().enclose(function () {\n  var factory = function () {\n    return stampit.compose(foo, bar).create();\n  }\n  factory.custom = function () {return 'custom';};\n  return factory;\n});\nvar a = baz();\na.custom(); // custom\na().foo(); // foo\na().bar(); // bar\n```\nThat said, to me, this reeks of potential side effects and quirks. Notice that my version is just returning an extended stamp. Just remember my warning when your custom object returns bite you in the end. When I allowed a custom return, I gave you just enough rope to hang yourself.\nNotably, baz knows about foo and bar, and when you call baz, it's not explicit that it knows about foo and bar (unless you make it generic and pass them in). So there's lots of magical mystery tour stuff happening here... it's not quite classical OO style (we have multiple ancestors here), but you might want a fish and get a fish and a walrus, and the whole yellow bus (too many Beatles references?). This is hidden multi-level inheritance. Ick.\nPoint is: be careful with this stuff.\nKeep it simple.\nWherever possible, keep your inheritance one level deep.\n. And be explicit about what you're inheriting! That's a major advantage that composition has over classical inheritance. Don't undo it.\n. If all of these things have everything in common, it's fine to consider the features of the model an implementation detail that the individual instances don't have to have knowledge of. Maybe that's what you're really looking for. In that case, model should be it's own module, and then you'd just do:\n``` js\nvar model = require('model'),\n  var myThing = model({name: 'thing a', otherstuff: 'foo'});\n// do stuff with myThing\n``\n. I noticed that in a lot of your examples, you're trying to call.compose()on the returned factory instances. That won't work..compose()is only exposed directly on thestampit` object.\n. ## EventEmitter\nNode's event emitter is super easy... if you look at util.inherits (which is commonly used to inherit from EventEmitter in node applications), it doesn't make any attempt to run the constructor... it just inherits the prototype methods. So, to inherit from EventEmitter, all you need is:\njs\nvar eventsPrototype = require('events').EventEmitter.prototype;\nvar collector = stampit().methods(eventsPrototype).methods({\n  // your methods here...\n});\nIf you absolutely must run a constructor, first convert it into a proper prototypal stamp:\n``` js\n// The old constructor / class thing...\nvar Constructor = function Constructor() {\n  this.thing = 'initialized';\n};\nConstructor.prototype.foo = function foo() { return 'foo'; };\n// The conversion\nvar oldskool = stampit().methods(Constructor.prototype).enclose(Constructor);\n// Now you can compose with it just like any other stampit factory...\nvar myThing = stampit.compose(oldskool).methods({\n  bar: function bar() { return 'bar'; }\n // your methods here...\n});\n```\nResults:\n``` js\n\nvar t = myThing();\nt.thing;\n'initialized'\nt.foo();\n'foo'\nt.bar();\n'bar'\n```\n\nTests\nSauce Labs has a free account level. If you want to contribute, you must ensure that the tests pass on all targeted platforms, and that means that you need to be able to run them on the Sauce Labs test fleet.\n. Got inspired by this thread and added stampit.convertConstructor(), so now you can do:\n``` js\n// The old constructor / class thing...\n  var Constructor = function Constructor() {\n    this.thing = 'initialized';\n  };\n  Constructor.prototype.foo = function foo() { return 'foo'; };\n// The conversion\n  var oldskool = stampit.convertConstructor(Constructor);\n// Now you can compose with it just like any other stampit factory...\n  var myThing = stampit.compose(oldskool).methods({\n    bar: function bar() { return 'bar'; }\n   // your methods here...\n  });\nvar t = myThing();\nt.thing; // 'initialized',\nt.foo(); // 'foo',\nt.bar(); // 'bar'\n```\n. Sortof, but it doesn't work as expected.\n. Interesting suggestion, but the args get fixed in the closure... May not work as desired...\n. Pushed again. This code now works great:\n``` js\n  // The old constructor / class thing...\n  var Constructor = function Constructor() {\n    this.thing = 'initialized';\n  };\n  Constructor.prototype.foo = function foo() { return 'foo'; };\n// The conversion\n  var oldskool = stampit.convertConstructor(Constructor);\n// A new stamp to compose with...\n  var newskool = stampit().methods({\n      bar: function bar() { return 'bar'; }\n     // your methods here...\n    }).enclose(function () {\n      this.baz = 'baz';\n    });\n// Now you can compose those old constructors just like you could\n  // with any other factory...\n  var myThing = stampit.compose(oldskool, newskool);\nvar t = myThing();\nt.thing; // 'initialized',\nt.foo(); // 'foo',\nt.bar(); // 'bar'\n```\n. > Oh also, while util.inherits doesn't directly call the super-constructor, it does make it accessible via this.constructor.super_. So it's up to the child class whether/how they want to call it.\nsuper is a code smell. I like this approach much better. It automatically calls the constructor for you, just like it would if you called the constructor directly -- well, almost. As you've already seen, there are unresolved issues... like, what happens if you need to pass parameters to the constructor?\n. I actually like your wrap approach. Maybe we should add it to the docs. =)\n. Take a look at v0.5.0 -- added the ability to chain .enclose(), pass multiple functions, an array of functions, or a hash of functions into .enclose().\nThat opens up a lot more expressive power with this stuff. Give it a try.\n. I'm afraid you're working around poor OO design in the stream classes themselves. Here's another example of how the design of streams shoot you in the foot, right from the docs:\n\nClass: stream.Duplex\nA \"duplex\" stream is one that is both Readable and Writable, such as a TCP socket connection.\nNote that stream.Duplex is an abstract class designed to be extended with an underlying implementation of the _read(size) and _write(chunk, encoding, callback) methods as you would with a Readable or Writable stream class.\nSince JavaScript doesn't have multiple prototypal inheritance*, this class prototypally inherits from Readable, and then parasitically from Writable. It is thus up to the user to implement both the lowlevel _read(n) method as well as the lowlevel _write(chunk, encoding, cb) method on extension duplex classes.\n\n* emphasis mine - obviously we know better. Stampit does this pretty well. =)\nThat said, there must be a way to do what you need.\n. > So... I discovered another issue with inheriting from the Stream classes. They explicitly disable calling their constructors on anything but an instanceof 'Class Foo'.\n\nhttps://github.com/joyent/node/blob/master/lib/_stream_readable.js#L96...L97\n\nAre you sure this causes problems? Duplex seems to do exactly that:\nhttps://github.com/joyent/node/blob/master/lib/_stream_duplex.js#L43-L44\n. > RE: Duplex, util.inherits must be modifying whatever property instanceof looks for. That code wouldn't work if the instanceof check failed.\nNo, the check doesn't fail -- it just doesn't matter. It's only running the constructor for side-effects... note that Duplex throws away the return values when it calls those constructors.\nAs far as I can tell, .convertConstructors() seems to work with the stream constructors... Have you tried it?\n. Yes, I'm aware of how to clime the prototype chain. However, the suggested use for super() is a bad idea, as I've already mentioned. I can't imagine how you'd apply this to passing a parameter to a constructor...\n. You want to try your hand at a PR for the .convertConstructor(Constructor, params...) syntax?\n. Pull 0.5.0 and try again.\n. Sorry.. make that 0.5.1\n. Still having trouble with that?\n. Here's a first pass at sending params to the constructor. Made a mistake, obviously, because the tests fail, but I have other pressing things on my mind right now... if you want to take a crack at making the tests pass, feel free!\nI made a few tests to clarify that .compose() should work in either direction, even with the instanceof check.\n. I'm not convinced this is worth spending much more time on. We're never going to achieve compatibility with every possible permutation of constructor. It's a big can of worms that probably isn't worth the trouble.\n. Can you give me some usage examples, and most definitely some tests... this won't get merged without tests. =)\n. I saw some timeout issues. Sauce Labs says timeouts are adjustable, and we should limit simultaneous runs to 2 at a time. Are you feeling brave enough to tackle that, too?\n. I really dislike the behavior inconsistency between the two different methods of setting up the prototype. My gut is telling me we haven't found the right solution to this issue, yet.\n. I don't want to preserve the inheritance chain. I think it's much better to flatten it, for a couple reasons:\n- performance: less work to do for method dispatch\n- debugging: less work to do if you want to examine all the properties of the prototype in a REPL (because they're all collapsed together on a single prototype)\nI grabbed your tests (and added a little to them) and rolled my own solution. Let me know if it works for you.\n. Creating many instances of any JS object constructor or factory won't duplicate the prototype. What stampit does is merge and flatten the delegate prototypes, so you end up with a single delegate prototype, and (intentionally) no hierarchical prototype chain.\n. BTW, this strategy has trade-offs. You can't use instanceof or .isPrototypeOf() with stampit instances. However, the object relationships are much easier to understand and debug (case in point: contrast to Node's streams) -- and JavaScript isn't strongly typed. I never use instanceof or .isPrototypeOf() anyway. I frequently substitute implicit duck typing, unless I'm doing data validations -- in which case, I use things like JSON schemas.  That seems like a better solution for data validations anyway, since it's data domain logic, it should be explicitly spelled out as such in the code, instead of looking like language type safety features...\n. RE: #8 \n. This is equivalent to:\n``` js\nvar stamp = stampit().enclose(function () {\nthis._ctx = this.ctx;\n  delete this.ctx;\n  // ...\n});\nvar myStamp = stamp({ ctx: 'hi' });\n``\n. Even better though.. you could use REAL private vars with the same.enclose()` method.\n. Not really. Stamps initialize object properties with name/value pairs. However, you could always have that init function handle that for you...\n``` js\nvar stamp = stampit({ init: function init(ctx, entityName, options) {\n  this._ctx  = ctx; \n  this._entityName = entityName;\n  // do something with options\n  return this;\n}});\nvar myThing = stamp().init('ctx', 'myentity', {option: 'opt1'}); // { _ctx: 'ctx', _entityName: 'myentity' }\n```\n. Yeah, I'm afraid this is the cost of being able to inherit an arbitrary number of init functions (via enclose). Each of those functions could potentially take different function signatures... so which parameters would you pass to which functions? \nIt just doesn't wouldn't make sense to open up that can of worms, especially since parameters are usually used to initialize object properties, anyway, and named parameters (key/value pairs) are a great way to make it explicit which keys are getting which values.\nNamed parameters also make your stamps more extensible.\n. Well, you can't just pass a string, but if you're ok with passing an options hash with the name, this is an easy way to get parameters into .enclose():\n``` js\nvar f = stampit().enclose(function() {\n  var name = this.name;\n  delete this.name;\nreturn stampit.mixIn(this, {\n    getName: function() {\n      return name;\n    }\n  });\n});\ng = f({name: 'george'});\ng.getName(); // 'george'\n``\n. For anybody else who is curious and stumbles across this, you can also define a setter in your.enclose()function, and then initialize with the setter after object instantiation. Note that if you returnthis` in the setter, you can make it chainable. This is my preferred method:\n``` js\nvar f = stampit().enclose(function() {\n  var name;\nreturn stampit.mixIn(this, {\n    // Getter and setter for name:\n    name: function (value) {\n      if (value) {\n        name = value;\n        return this;\n      }\n      return name;\n    }\n  });\n});\nvar thing = f().name('foo');\nthing.name(); // 'foo'\n```\n. :ghost: :thumbsup: \n. I'm pretty sure this was working before I added the chaining features. I should have had a test for this in the test suite. Thanks for the report. I'll get on it ASAP.\n. Fixed.\n. The state is instance safe. If it were not instance safe, they would be the same.\nState prototypes are deep-copied at instance creation time, which means that if you crate an instance, then change the state prototype, then create a new instance, the new instance will have different state than the first instance.\nThis is by design.\n. Well, they're always available on the stamp, but the stamp is not referenced in the object instances (by design).\nCould you supply a good use case for this?\n. My question is, why do you need that properties object at all? Inside .enclose(function () {});, this gives you access to everything that was passed into create, along with all of the .state() mixins...\nSo, what's the difference between your dream properties object, and this?\nAre you trying to make those properties private?\ncurrently, you can do that by running through them in an .enclose(function () {});, and assigning them to a private variable, and then deleting the properties from this.\nAre you asking for sugar to accomplish the same thing?\n. Yeah, basically, but remember I need to balance convenience for you vs reusability for the community at large. So, any proposed sugar would need to be generally reusable, keeping in mind that I can't just pass parameters willy-nilly into .enclose(fn), because functions designed for oldskool constructors might try to interpret them incorrectly...\nI also can't simply munge this with special keys. Users need to have full control over the instance objects that get created.\n. Maybe I could do this with a helper mixin. Here's some dream code that would let you specify the behavior of specific keys:\njs\nvar mutator = stampit.mutator('secret', 'secret2', function (properties) {\n  properties.private(); // make the properties private\n  this.get = function (key) {\n    return properties[key];\n  }\n  this.set = function (key, val) {\n    properties[key] = val;\n  }\n});\nThis could default to all keys:\njs\nvar vault = stampit.mutator(function (properties) {\n  properties.private(); // make ALL properties private\n  this.get = function (key) {\n    return properties[key];\n  }\n  this.set = function (key, val) {\n    properties[key] = val;\n  }\n});\nvault would be a stamp that you can compose just like any other stamp.\njs\nvar stamp = stampit.compose(base, mixin, vault);\nvar myThing = stamp({key: 'key to the kingdom'});\nmyThing.key; // undefined\nmyThing.get('key'); // 'key to the kingdom'\nThis is all dream code that hasn't been written yet, but it could be added to stampit. Would that be helpful?\n. Cool... If you're interested in implementing the mutator function as described, I'd be willing to accept a pull request. Otherwise it will have to wait a little bit. I have some things to wrap up on my book, first.\n. Yeah, I'll have to take a look a little bit later. Sometimes the tests fail because if you don't have a pro account, you can't run more than one test at a time reliably. I need to edit the config so that it won't try to run them all at once.\n. @koresar That is probably the cleanest proposal I have seen, yet, and it's better than my own proposed solution, as well.\nPlease submit a pull request, and make sure that all the tests still pass.\n. Stampit supports passing arbitrary parameters now, but please use with caution.\n. No. .methods() and .state() both represent two different kinds of prototypes. .methods() are for the delegate prototype, while state is for the exemplar prototype (clone source). It has not been known as a prototype in the past, but .enclose() functions can also be seen as prototypes for initializer functions: That is, functions that are applied to every new instance of an object.\nThey have specific names to clarify the best use-case for each.\n\nAfter all you can pass in other things than methods (e.g. getters, setters and values) and they will behave just like they would on a prototype.\n\nGetters and setters are methods, and using values on a delegate prototype is an anti-pattern, for two reasons:\n1. It's really easy to cause accidentally shared state (since mutating an array or object property on a delegate prototype will mutate that property for all instances).\n2. Making use of or mutating \"class variables\" from within a method can cause all sorts of timing-dependency bugs. For example, it can cause situations where methodA must be executed before methodB can work.\nStampit doesn't have class inheritance, but prototypal inheritance is not just a form of inheritance, it is a superior form of inheritance. For more on these topics, see the blog post, Fluent JavaScript: Three Different Kinds of Prototypal OO, and the corresponding talk, Classical Inheritance is Obsolete: How to Think in Prototypal OO.\n. I am aware of common convention in the JavaScript community. Unfortunately, a deep understanding of prototypal OO - even an understanding that there is more than one type of prototype - is uncommon. It is my hope that writing about it, speaking about it, and sharing this library will help change that.\nIs there a learning curve? Sure. Do I think changing 'methods' to 'prototype' will make it easier to learn how to use Stampit effectively? No.\n\nthe lack of support for multiple delegate prototypes in JS certainly limits the usefulness of having delegate prototypes in the first place\n\nThere is no useful difference between having multiple delegate prototypes and concatenating multiple prototypes into one, as Stampit does when stamps are composed. Stampit supports inheriting from multiple prototypes as is.\nStampit does support inheriting from multiple delegates, keeping all of them as delegates. That is impossible with classical inheritance, as it is currently implemented in any JavaScrpit library or specification. So by your own criteria, prototypal methods are superior to classical, if only to satisfy your desired capability.\nAs for \"other libraries sharing the same or similar concepts\", I'm not concerned because there are none that are popular. The only popularly implemented inheritance libs implement  concatenative (calling the method extend or mix in) OR classical.\nNeither of those supplies a useful model for a complete understanding of prototypal inheritance, so it doesn't make sense to follow their conventions to describe different semantics.\n. Thanks! =)\n. My favorite way to handle it is this:\n```\nvar f = stampit().enclose(function() {\n  var name;\nreturn stampit.mixIn(this, {\n    // Getter and setter for name:\n    name: function (value) {\n      if (value) {\n        name = value;\n        return this;\n      }\n      return name;\n    }\n  });\n});\nvar thing = f().name('foo');\nthing.name(); // 'foo'\n```\nI like that it separates instantiation from initialization.\n. For your situation, I think you're probably doing the right thing already. =)\n. Twitter flight's mixins are strictly functional inheritance, which means you don't get the free concatenative state or delegate prototypes. The functional mixin article suggestion has the same shortcomings. Stampit is functional mixins + delegate mixins + state mixins. Without all three, you don't have an API that expresses all of JavaScript's object capabilities explicitly.\nYou can technically do delegates and state mixins with functional mixins, but without a prescribed pattern built-in to the API, there's no predictable way to compose all three.\n. Any way we can do this without adding a .construct() function?\n. :thumbsup: On the .convertConstructor() observation.\n. Funny.. this is exactly the change that I was testing when you made your comment...\n. Well, it fails... we'll have to pick this up another time. It's my bedtime. I have to wake up for work in the morning. =)\n. Spoke too soon... That fail looks like it was my improper Saucelabs config. I'm going to need to track that down and fix it. =)\n. I'm OK... now let's get to it:\n1) probably not a good idea. Not only is it a breaking change, it would actually encourage people to write stamps that take arbitrary parameters (by making it dead simple to do so). This is actually directly counter to Stampit's goal, because the whole point of Stampit is to reuse and combine stamps.\nImagine you have stamp a with a signature:\na(firstName, lastName, email)\nAnd stamp b with signature:\nb(hostName, apiKey)\nThese can't be composed.\nHowever, if both stamps had just done it the stampit way and used named parameters for input options, they would easily combine. I'm afraid if we break backwards compatibility in this way, the only thing we'll make history for is failing to encourage good prototypal OO design.\n2) This won't fix the broken case, above, but is there a way we could just NOT pass in the options hash to constructors (it's available on this, anyway)? I believe I tried that, and some tests failed, but I haven't had time to take a deep look.\n3) is missing the point... if we can't turn it into a proper stamp and you have to run a separate .construct() method, how does this really play nice with the stampit way of doing things?\n. I want to make it very clear that creating stamps that take arbitrary parameters is an anti-pattern. It's a bad idea, because it creates stamps that are not composable. The problem with that is that a stamp (by virtue of being a stamp) makes an implicit promise that it is composable, and that it will play nice with other stamps.\nI agree that the existing API is not ideal. However, we should have a really good understanding of the problem domain and the pros and cons of possible solutions before we go making changes to a library that hundreds of other developers are already using.\nNote that it's already trivial to add methods that take arbitrary parameters. For example:\nvar myInstance = a().person(firstName, lastName, email).peopleApi(hostName, apiKey);\nThat is safe, and it is my recommendation if you just want to be able to take unnamed parameters when you construct some arbitrary thing from a stamp -- that way your stamp will be composable with other stamps.\nThe problem I would like to solve is the case where you would like to mix in a legacy constructor function. I don't think it's possible to support every constructor ever made, and that should probably not be a goal, but if we do pass arguments into the closures, that might be a fairly smooth solution to the problem.\nI have a strong feeling this feature will be abused. Maybe we should implement it and then not document it, and not provide any examples that show it being used?\nThis is a fundamental principle of API design:\nIf you make it super easy for people to do stupid things, people will do stupid things a lot. This is often referred to a pit of dispair -- creating traps that are easy to fall into.\nOn the other hand, if you make it hard to do stupid things, but super easy for people to do smart things, that creates a pit of success.\nI hope you all understand that I'm not just being hard-headed for the sake of being hard-headed. I genuinely want to come up with the right solution -- one that won't break existing work, and one that will also not encourage a lot of people to make bad choices while implementing stampit.\nI don't want people to blame stampit and prototypal OO in general when they inevitably paint themselves into corners.\n. I think option 2 is a winner. That does mean, however, that even if you don't want to pass any init vars, you will still have to pass a first param that represents the properties. However, that can be null:\njs\nvar myInstance = a(null, myArg, myArg2);\n. @koresar My principle concern with that approach is that it doesn't actually produce a composable stamp. Do you have a response to that concern?\n. Take a look at the updated PR. Implements Option 2. If you guys are satisfied with this, it'll be a release candidate for 1.0, and there will be no breaking changes going forward. We can let it bake for a little while before we push out the 1.0 release.\n. Sure, I suppose bumping to 0.7.0 makes sense. It will still be a 1.0.0 release candidate, version number aside. Please play with it, put it through its paces and we'll see how we like the new API.\nSpecifically, I'd love to see whether or not it really helps with the legacy constructors. :)\n. It's in!\n. 0.7.1 published\n. omg I'm an idiot. One second.\n. Done. Thanks!\n. I'm game. PR with tests, please! =)\n. Let's just call it isStamp? =)\n. Also, that implementation won't work. It will always return undefined, because of ASI. You'll need:\njs\nfunction isStamp(obj) {\n  return (\n    obj.fixed !== undefined && \n    obj.methods !== undefined && \n    obj.state !== undefined && \n    obj.enclose !== undefined\n  );\n}\n. Sorry... forgot to yank out your semicolon. Fixed!\n. Hmm.. why don't you make a Pull Request?\n. No worries. There's a button that you can press to open a PR. :)\n. Should be fine if all the tests are passing. But why switch from mout to Lo-Dash?\n. And what things in particular did you need to change to make it play nice with Meteor?\n. Please open a new ticket if you decide you want to try to merge your changes with the main line. Be sure to do so in a PR so that I can respond to changes in-line and we can have a thorough discussion about what changed, and what the justifications are.\n. Thanks. I'll fix that. =)\nFor clarity, it's not a bug that only arg2 on are passed in -- The first argument is always an object whose properties are copied over to the new object.\n. Fixed.\n. Thank you! =)\n. Tagged and published as v1.0.0\n. Hi,\nThanks again for more fantastic input. I like it.\nMethod names:\n1) Name the append method .composeWith() ?\n2) Name the prepend method .composeAfter() ?\nExample critique:\nDon't use initial caps on anything that isn't a constructor. This is a very common convention in JavaScript and many lint setups will complain about it.\nPlease submit a PR with:\n1. Docs\n2. Tests\n3. Added methods\nAnd:\nWould you like commit access to this project?\nWe should establish a formal process for commits:\n1) Proposal like this on issues page\n2) Never commit your own work. Submit a PR and ping me.\nI'll follow the same process from now on. That way every new change gets code eyes and code review before it makes it into the main branch.\n. PascalCase works for your project. Understood. For Stampit, we follow\nidiomatic JavaScript conventions, so please keep that in mind while writing\npull requests.\nThanks again for your thoughts and contributions. They're much appreciated.\nOn Aug 17, 2014 6:09 PM, \"koresar\" notifications@github.com wrote:\n\nHi Eric,\nRe the PascalCase. I am forced to reply. :)\nIn our project we tend to avoid classic constructors and use stamps only.\nWe do not like the idea of putting word 'Stamp' at the end of each stamp\nvariable. Consider:\nrestAuthServiceStamp.create();RestAuthService.create();\nIt is not only about being shorter, but also about consistency. Everything\nwhich creates objects should be PascalCased. The team agreed internally and\nliked it. So far so good.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/28#issuecomment-52440276.\n. I'm confident that you can handle it, and I promise it won't be a huge time\ncommitment.\n\nSince I will review all pull requests before they're committed, it's\nunlikely that your experience will be problematic.\nIt's fine if you can't make the commitment, but if it sounds like something\nyou want to be involved in, the offer stands.\n On Aug 17, 2014 6:23 PM, \"koresar\" notifications@github.com wrote:\n\nRe commit access.\nThat's a great honor to participate in maintaining the stampit\nI am an experienced dev and used to maintain few OSS projects, although\nthere is possibility I might screw things up because my JS experience is\nrather short (~1 year). I wouldn't trust myself. :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/28#issuecomment-52440687.\n. Great!\n. You are now an official collaborator on this project. Congratulations and welcome aboard! =)\n. @wonbyte If you have suggestions, please feel free to submit a PR! =)\n. OK @koresar -- check out v1.1.0 from npm.. kick the tires. I'm closing this thread. =)\n. This is a very good question. One that I don't have a clear answer to, yet.\n\nI'm open to suggestions... =)\n. Reviewing...\n. Looks like we're slowing down the common Stampit.compose() case. Do you want to swap it so that .composeWith() calls .compose()?\n. > Are you okay with the fact that composeWith() changes this instead of creating new stamp? I think composeWith() should create new stamp just because state(), methods() and enclose() are consistenly creating new stamps.\n\nYour opinion?\n\nAgreed. We should mention this in the docs for all of those methods. Could you do that, as well?\n\nsince there is not 'composeAfter' maybe we should rename 'composeWith' to just 'compose'?\n\nAgreed.\n. Thanks!\n. Hah! I'm critiquing your code for creating a new stamp instead of calling compose, but compose always created two new stamps. =)\n. Any progress on this?\n. :thumbsup: \n. Thanks!\n. Thanks Vasyl! I'll be really busy this week. Working on a big project. What\ntools will I need to see the context clues? Does Tern work?\nOn Sep 21, 2014 7:09 PM, \"Vasyl Boroviak\" notifications@github.com wrote:\n\nI have submitted the PR.\nborisyankov/DefinitelyTyped#2839\nhttps://github.com/borisyankov/DefinitelyTyped/pull/2839\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/33#issuecomment-56319672.\n. Hmm.. That's odd. Stamps aren't stamps?\n. Hi @foxaal,\n\nThis is currently an open question that I would love your feedback on.\nCurrently, you can get some benefits from annotating all your methods and enclose() functions, but when you're calling your stamp, automated tools don't have a good way to offer type hinting.\n@koresar had some success with his Definitely Typed approach using TypeScript annotations. I'm not sure how well it works.\nPlease let me know how your experiments go. I would love to have good type hints and hopefully even some decent static analysis. =)\n. I would rewrite the conjecture:\nJavascript / stampit is an order of magnitude closer to the sweet spot than the classical inheritance strait jacket.\nCorollary: All code (in any language) using classical inheritance should be rewritten to use alternatives such as delegation, concatenation, composition, or the language's modules (node style modules, etc...).\nStampit makes that easy in JavaScript, and any other language that can make use of JavaScript modules (CoffeeScript, etc...).\n\nAssuming that all javascript applications need to be rewritten from scratch\n\nThat's not usually the case, unless the apps have used very heavy classical inheritance throughout, in which case, they're probably due for a rewrite, anyway. ;)\n\nwhat would the first block of stampit factories combine into?\n\nI don't understand this question.\n\nA javascript interpreter ? Could these parts and pieces then be much more easily composed to produce an IDE and doc generator than trying to hack jsdoc, esprima, or what have you ?\n\nIf you want something that compiles to JavaScript, can auto-generate documentation, and has support for Stampit, try Literate CoffeeScript -- but be aware, you're still missing out on quality static analysis.\nSpeaking of static analysis, I wonder if Flow could help. I haven't decided whether or not I would actually like to annotate types with Flow, but Facebook claims that it can use type inference to detect type errors even in JavaScript programs which are not annotated. I'd love to test that out.\n. Thanks!\n. I've added you as a collaborator. Please continue to use the pull request process if you want to commit a change. =)\n. Thanks!\nThis project needs some build config love... It's a bit too obvious that I was being hasty when I threw it together. =)\n. Speaking of build config.. check out Cloverfield and weigh in.\n. I'm not sure I understand the question. Stampit already deep clones state.\n``` javascript\nvar b = { b: 'b' };\nvar foo = stampit().state({ a: b });\nvar bar = stampit().state({ c: b }); // => { a: { b: 'b' }, c: { b: 'b' } }\nexample.a.b = 'unique';\nexample; //=> { a: { b: 'unique' }, c: { b: 'b' } }\n. Oh yeah, you are right. =) I made a conscious decision not to traverse the entire object hierarchy so that you could pass along things like reference to request / response objects. I think we can open that for debate, but it will be a backward-breaking change, so we'd have to do a 2.0 release if we decide to change it... it's going to effect all the stamps that rely on reference behavior.\n. Oh wow. They should not be different! That's a bug.\n. @koresar You want to take a stab at a PR?\n. javascript\nvar stamp = require('stampit')();\nvar state = { a: { b : null } };\nstate.a.b = 1;\nvar obj1 = stamp.create(state);\nstate.a.b = 2;\nvar obj2 = stamp.create(state);\nconsole.log(obj1.a.b, obj2.a.b); // 2 2\n```\nRegardless of the deep or shallow question, this is definitely a bug.\n. :+1: \n. e.g., instead of:\njs\nvar stamp = stampit().state(state);\nYou should be able to do:\njs\nvar stamp = stampit.state(state);\n. I've interacted with a lot of Stampit users. Trust me when I say it sometimes bothers people. This was actually a feature request from Respond.ly, who recently started using Stampit.\nAlso, this is a non-breaking change. I'd like to hear your concerns, because I can't think of any reason not to do this. I've actually implemented it on my local computer just to demonstrate TDD, but never pushed it to the repo.\n. :+1: \n. @JosephClay Yeah, since we actually know that this causes bugs and inconvenience for our users without the convenience methods, I think we already have our answer on this. =)\n. Hey, is this feature in the Stampit 2.0 branch, yet?\nMaybe it should be. =)\n. Nope. I wrote it to make tests pass. I believe mixIn guards for against the prototype. mixInChain flattens the prototype chain. I wrote it a long time ago, so I'm not certain, but I think if you swap them out, tests will break.\n. Interesting. Maybe we changed something since I wrote it and it's no longer necessary. =)\n. :+1: \n. > The mixInChain copies not only methods but also properties. As the result a bit of confusion takes place. The stampit(methods) and stamp.methods(methods) shallow copy state (if present) of the given object. This is no good because our stamps should be immutable.\nThis is by design, so that you can have \"class variables\" such as instance counters. If we remove that capability, we'll definitely break a feature that people are using in production.\nI'm personally not a fan of shared class variables. I don't use them myself, but it was a feature request.\n. IMO, a better way to do things like instance counters is to add each new instance to a collection (which can be done even with immutable data structures).\n. From an idealistic point of view, I agree with you, but I don't think we have much choice here.\nI'm pretty sure that very common use cases like trying to inherit from EventEmitter with convertConstructor would break without mixInChain. Basically any constructor that inherits through the prototype chain will break if we remove mixInChain. I think enabling Stampit to work with commonly used constructors from Node and other popular libraries pretty much trumps any of the concerns you mentioned.\nWouldn't you agree?\n. If you're really concerned we can explicitly guard against inheriting from the base Object.prototype, but we still need to be able to inherit from parent prototypes for compatibility with old classical inheritance style libraries.\n. Good point. Does it break any tests?\n. Change 'stampit.compose() with inheritance' so that it uses .convertConstructor() to create the sn stamp. That test should still pass.\n. Thank you! =)\n:+1: \n. > Immutable stamps\nYeah! I've been thinking I should have done this from the start for about two years. I secretly had this in mind for a 2.0 release. It's like you're reading my mind!\n\nToday @raabbajam showed me his code snippets. He assumed the same!\n\nThis is a common question I hear, which is what got me thinking immutability should have been the plan in the first place.\nThe only reason I didn't do this was because I had an edge case that required a mutable stamp to work, but looking back, I think that the decision to bend my ideal API to fit one use case that I've never had again was an error.\ncombine vs / compose\nThe reason I chose compose is rooted in the famous GoF book, \"Design Patterns\", where they state two foundational principles on which the book was built. One of them being, \"Favor object composition over class inheritance.\"\nIn other words, I specifically chose the word to:\n1. Emphasize that .compose() does not suffer the same problems as class inheritance.\n2. Use a word that should be well-known to the OOP community.\n. OK. If you can get ten other people to vote for combine, we'll add it as an alias. Get 20 and we'll deprecate .compose (unless we hear lots of objections).\n. :)\n. Let's wait for resolution on which name will replace .compose() before we merge this work. =)\nSee https://github.com/ericelliott/stampit/issues/46\n. I can see using a separate commit, but I don't think a separate PR is warranted. The 2.0 API should be fleshed out when we merge it. There will be no more breaking changes in the 2.0 branch after it is merged. Otherwise, we'd have to increment to 3.0 right away in order to comply with semver.\n. =)\n. Don't trust instanceof in JavaScript. It does not do what the name implies that it does. It does not work across execution contexts. It doesn't work if the fn.prototype property gets changed after the object was instantiated. Basically, it's a completely broken concept in JS. It doesn't remotely make the guarantees that Java people expect it to make.\nNever require new (or suggest it, or imply that consumers can use it).\nhttp://ericleads.com/2013/01/javascript-constructor-functions-vs-factory-functions/\nhttp://ericleads.com/2012/09/stop-using-constructor-functions-in-javascript/\nhttps://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3\n. I appreciate the effort and enthusiasm, but I'm not going to encourage users to make mistakes.\n. Yeah. Ducktype. Checking instanceof is the opposite of ducktyping.\nDucktyping means that you check the object instance, and if it has the stuff you expect to have, you just assume it's a compatible type and use it.\n. Flow mostly relies on structural type checks, which is like automatic duck typing. I think Flow uses nominal checks in some situations, which is bad and not like duck typing. TypeScript uses all structural checks, AFAIK.. > Is this the way to do something like this? Any recommendations?\nYes, I write code like that frequently.\n\nHow would you implement something like this in plain JavaScript + stampit?\n\nYou don't. Super is a code smell. Any use of super tightly couples the child class to the parent class, which creates brittle code.\nInstead, flatten the hierarchy and use the same defaults / overrides pattern you listed above. That way, A, B, and C could all inherit from a common base, and you won't create super chains like you would if you had C inheriting from B instead of A.\nSee also The Two Pillars of JavaScript Pt 1.\n. About argument passing... the pattern I recommend is to create setter methods that are semantically named for the particular stamp the arguments are intended for.\nStampit does support argument passing, but due to the potential conflicts in composed stamps, I consider any arguments outside the ones that set properties on the object to be an anti-pattern.\n. You realize this means I have to post on social media to collect objections, right?\nDown with .combine()!\n;)\n. In this thread, .use() was suggested. I really like that, and no, I don't think we should modify the existing stamp, particularly if we spell out in the docs that stamps are immutable, and that you need an assignment when you call .use().\n. Why .join()?\n. > Eric, as long as we are trying to avoid classic OOP (see #44 you declined) let's also avoid classic OOP terminology.\nThe concept of object composition is not limited to classical OO, but this is a moot point, I think, since we've already agreed that it should be changed based on the poll results.\n\nMaybe we should invent our own terminology in order to emphasize that stamps are not alike classes?\n\nIt's usually better to reuse terminology that is compatible so that users can reuse some of their prior knowledge. This is a basic principle of good API design.\n\nSo, my new proposal is to avoid both compose and combine, but use somehting like join instead.\n\nI'm OK with this. So we should be asking, do we want to call it .use() or .join()? What are the pros and cons?\n. ## .join()\nPros\n- Terse\n- Descriptive\nCons\n- Might be confused with Array.prototype.join (I doubt it)\n- Not at all idiomatic\n.use()\nPros\n- Idiomatic to JS (e.g., Express, Meteor)\n- Terse\nCons\n- Might imply that the base object is mutated\n.compose()\nPros\n- Descriptive\n- Should be familiar to anybody with a background in OO design patterns, regardless of JavaScript experience\n- Descriptive of the fact that the function prototypes are also composed (via this, the output of prior applied function prototypes is used as the input of latter applied function prototypes).\nCons\n- Not at all idiomatic\n- Not a direct translation of the composite design pattern that the name may imply.\n.combine()\nPros\n- People seem to like it in the poll.\nCons\n- Not at all idiomatic\n- Not as descriptive as other options: \"When I combine ingredients in the kitchen, I no longer have the ingredients.\"\n. I'm OK with whatever the consensus is. =)\n. @dfkaye I'm definitely not afraid to say \"no\" if I feel strongly about something. See the closed issues for several examples. ;)\nBut I'm also open to input -- especially if it's input that might make the API easier to use.\n. > Might re-consider the \"issue\" that there are multiple methods for decorating or cough extending a stamp ~ for example, does it really make sense to add a method or two to a stamp via methods() rather than as a trait that contains those methods via compose()?\nThis question has come up before. I think it's important that we don't remove any of JavaScript's object-creation capabilities, and since there really are three different kinds of prototypal OO in JavaScript, and each one behaves in fundamentally different ways, I think it really is necessary to have three distinct ways to add behaviors to a stamp.\nI've experimented with different APIs that have fewer methods in the past. Stampit was definitely an evolutionary step forward because of the flexibility it affords in that respect.\nThanks for the mountaintop feedback. I hope the wine was tasty! =)\n. As I mentioned before, Stampit does both function composition (using this as input and output instead of arguments and return values), and object composition (using object concatenation).\n. Yeah, I'm cool with this. =)\nBTW, check out the build config in the npm implementation of todotasks.\nWe need to merge PRs 14 and 16 for you to try it out, but it's basically skipping Grunt and just doing all the build tasks with npm scripts. It accomplishes more than the Grunt config here, in a lot less code.\nFor example, it lints, builds, and tests, watches for changes, and reruns the QA measures on file changes. There's also a browsertests.js file that demonstrates how you can launch a test server to run functional tests against with Sauce Labs.\nPretty cool stuff.\n. I added you as a contributor on todotasks in case you want to check and merge those PRs.\n. :+1: \n. Cool, I'll be out of touch for a couple weeks. I'll look at this when I get back. Thanks!\n. Cool.. I'll check out the updated diff as soon as I can.\n. There are lots of test failures in this branch. Can you double check that you're not using any ES5 features without polyfills, etc...?\nPlease feel free to use Mout or Lodash functions instead of ES5 features.\nAll tests are broken on:\n- Internet Explorer 8\n- iPhone 5\nThe last test is broken on Android 4\n. I think the Sauce Connect config may be broken (or maybe I just don't have the environment variables set on my machine) but you can test manually using Sauce Labs.\n. Object creation and property access are lightning fast no matter which technique you use. These are micro-optimizations. I've never seen an application where this is the bottleneck. Don't optimize this unless you've profiled your app and proven that it's a problem. Read You're Optimizing the Wrong Things.\n. I'm not sure we want a strict mode, because it would prevent the very common defaults and overrides pattern.\n. I agree, RE: finalize the 2.0 branch.\nI also agree about making Stampit extensible.\nHowever, I also think that static analysis of stamps is essential to Stampit as a tool for building large applications, and a tool that could very easily tell you which stamps are likely to play nice with each other would be very useful, indeed. Integrating it into Stampit core so that you can easily interact with it in the console as you're building the application seems like a very valid use-case to me ...\nAnd it would only take a few lines of code to do it.\n. Clearly we'll want to include more detail in the message (like the key in question). This could happen one time per stamp, after the stamp is applied.\n. @koresar Each iteration of this loop.\n. Close in favor of https://github.com/stampit-org/stampit/issues/67\n. Absolutely agreed, and IMO should be a good thing to add to 2.0.\n:+1: \n. JS does not allow this sort of object metadata. Even using raw JS objects, instanceof isn't really type data. Instead, it simply checks the object's prototype identity against Constructor.prototype, which is very brittle.\nThe factory could keep an identity history of every stamp created, but that would create memory overhead that may not be appropriate for every use of Stampit (particularly games or event systems cranking out lots of objects).\nThe instances can't keep metadata without tacking properties onto the stamp that may interfere with the author's intentions.\nBarring those options, here is what we could implement:\n- A stamp method that runs through prototype properties and looks for those properties on the instance and makes a best guess about whether or not the stamp may have generated the instance based on ducktyping. Does this instance have all the expected properties based on the prototype? It might be an instance.\nSince that's not actually a strong guarantee, is it worth putting it in Stampit core?\nIf you actually need this kind of thing, here are options you could do in user space:\n1. Tag all instances with a list of stamps that contributed to the instance. e.g. stampit.compose(a, b, c).state({hasBehaviors: [a, b, c]});\n2. Keep a collection with references to every instance you've generated. Compare the identity of the instances to see if they're in the collection.\n3. Forget about trying to type your instances. Instead, ducktype. Just try to use them, and throw a descriptive error if they're missing a behavior needed by some function. This is what I do 99.9% of the time, and it usually works great. If it doesn't work great, that's usually an indication that I've designed something wrong.\n4. For me, a typical use-case for stamps is creating utility libraries. I don't actually use stampit much to represent business objects like users, etc... For that, I use functional programming.\nWhen you start getting into the need to identify the type of instance you're looking at rather than simply ducktyping, it may be a code smell that should push you in the direction of functional, reactive, or dataflow programming. See The Two Pillars of JavaScript Pt 2.\n. > Changing stampit core\n:+1: \n. Thanks!\nAbstract\nI don't create a lot of abstract stamps. Instead, I'll create a stamp that cranks out fully functioning instances that have sensible default behaviors. I have still created abstract stamps once in a while, when I really needed to throw an error if the inheriting stamp fails to override something.\nDelegate or .enclose()\nIf you need data privacy, you really don't have a choice. You must use .enclose().\nFor methods that can use this and store public state, you may prefer to delegate with .methods(), because it will save a little memory. But let's be honest --  memory isn't really a big bottleneck for most use cases these days. Encapsulation may take priority for you.\nProtected is an anti-pattern\nIn other languages, protected means that the member can be accessed from both the class itself, and the class descendants, but not from other functions outside the class.\nProtected members are an anti-pattern because they allow tight coupling between a child class and it's parent. Protected members are not possible with Stampit, and that is a good thing. If you need to share state with descendants, use modules to share access (make both abstract and descendants depend on a module that exports the private stuff you want to share between them).\n. Why? Stampit is already perfectly capable of producing the desired stamp with .enclose().\n. This seems really application specific, to me. The only use-case I can think of is to add a .clone() method to instances -- something you don't need if you have the stamp in-scope.\nYour .clone() method is also a bit awkwardly named, because it doesn't create a clone of the current instance -- instead, it creates a fresh instance based on the stamp -- without the current instance's state.\nAm I missing something that would make this more generally usable? Maybe specific use-cases? Why is the .clone() method you describe useful? Why not just use the stamp to create new instances, instead?\n. @koresar As a maintainer, you have the power to bring in other contributors to review your commits. You don't need to fork.\nDon't wait around for me. Have a buddy review your commits and merge them in.\n. My $0.02 -- the programmer should have 100% control over what the stamp creates. If we can make it easier to add a .getStamp() method to the object instances, that's cool, but Stampit shouldn't add it to the instances directly.\n. > We are definitely not adding the 'stamp' property to each created object. That's an unexpected explicit behaviour which might and would lead to hidden bugs.\n:+1: \n. For this to work, we'd need to polyfill .getOwnPropertySymbols for browsers that don't support symbols, yet.\n. var stamp = myObject.prototype.__stamp__;\n1. There is no myObject.prototype property unless you create one. [[Prototype]] is not a property on an instance. It is available on a constructor function, but Stampit doesn't use them.\n2. Authors need full control over the object being created. We should not add properties to the object instances, hidden or otherwise. If the author wants to add a reference to the stamp, they can do so with .enclose().\nAm I missing something?\n. > Maybe we should make stamps \"plugin-able\". We can allow people to hook into the function factory().\n``` js\nvar clonableStamp = stampit();\nclonableStamp.on(\"ctreated\", function (obj, stamp) {\n  obj.clone = function () { return stamp(obj); }\n});\n// and usage\nvar myShinyStamp = stampit({ whatever: 42 });\nvar myShinyClonableStamp = myShinyStamp.compose(clonableStamp); // merges 'on()' events\nvar myShinyObject = myShinyClonableStamp();\nvar IAmClone = myShinyObject.clone(); // we have clone() method in each object!\nassert(IAmClone.whatever === 42);\n```\nAll the suggestions so far have sounded pretty ugly to me. Lifecycle hooks are much better, but how is this different from .enclose()? You get stamp() passed in?\n. I see, and we can't just pass the stamp into .enclose() functions because we pass the args in. We should have just passed an options object in. My bad.\nI'm cool with it if you want to add a created lifecycle hook, but I think we should pass a named options hash into it and deprecate .enclose() (the name confuses people anyway).\nBasically make it the flexible method that .enclose() should have been. =)\nNamed options:\n- instance\n- stamp\n- args\nThanks to ES6 destructuring, using them is almost as convenient as using formal params:\n``` js\nfunction foo ({ param1, param2, param3}) {\n  console.log(param1, param2, param3);\n}\nfoo({param1: 'foo', param2: 'bar', param3: 'baz'}); // logs foo bar baz\n```\nThis way we leave the created hook open for extension like .enclose() should have been. ;)\nWe could also still make instance available as this.\nI'm cool with an .on() function for lifecycle hooks, but I think we should also have a .created() shortcut method that's just short for .on('created', /*...*/)\nThoughts?\n. My logic for avoiding .init() in the first place was that users might think that's the way to define initialization logic, and I was hoping we could train users to separate instantiation from initialization more. For example, my favorite way to initialize private vars is this:\n``` js\nvar f = stampit().enclose(function() {\n  var name;\nreturn stampit.mixIn(this, {\n    // Getter and setter for name:\n    name: function (value) {\n      if (value) {\n        name = value;\n        return this;\n      }\n      return name;\n    }\n  });\n});\n// f() instantiates and returns the instance.\n// .name('foo') initializes the private variable.\nvar thing = f().name('foo'); \nthing.name(); // 'foo'\n```\nNote that the initialization doesn't actually happen until you call the instance's .name() method.\nMaybe I was wrong, though, because .enclose() does seem to confuse users a lot more than I anticipated. );\n. So we don't have to deprecate yet another method, I'm going to insist that we pass an options hash instead of a list of formal params:\nNOT THIS\njs\nvar stamp = stampit().init(function(settings, stamp){ });\nAh, this is better...\njs\nvar stamp = stampit().init(function({instance, stamp, args}){ });\nIn ES5...\njs\nvar stamp = stampit().init(function(options){\n  /* instance, stamp, and args are available on options obj */\n});\n. There are a couple options:\n1. Port the tests to tape\n2. Keep the QUnit suite and use phantomjs to get the test results.\nOption 1 is probably best, but we'll need to bundle the test scripts for browsers so we can still run them on Sauce Labs, too.\n. Check out tape-run\n. Done. :+1: \n. :+1: \n. Yes.\n. > On the other hand, adding \"state\" values to prototype might break someone's code.\n:+1: \n\nThe stamp(obj) should deep merge the obj or shallow mix in the properties?\n\nI think shallow is better for 2 reasons: \n1. It's not a breaking change\n2. It's probably less surprising behavior\n. Really? Are you hoping to use this for a planned production deployment, or just floating the idea?\nLodash dependencies bundled is really inexpensive...\n. You don't need this feature. Browserify and Webpack automatically dedupe if you already have the same lodash version in your bundle.\n. I vote 1.\n. Cool!\n- My feelings wouldn't be the least bit hurt if we ditched Grunt in favor of npm scripts. =)\n- Do we have Travis-CI set up? (see https://github.com/ericelliott/stampit/issues/56)\n. :+1: \n. I think it should be a real array, for convenience. The arguments object sucks.\nAs for an example, IMO, they're all anti-patterns. I let it into Stampit by popular demand under protest. ;)\n. Stamps can take arbitrary arguments so that you can use them with legacy constructors.\nThe problem with that is constructor arguments can collide with each other. );\nThis issue has already been debated ad nauseam. After exactly ten billion requests, I relented and washed my hands of it.\nIt's going to be hard to change now. People are relying on the current behavior. I know that we're looking at a 2.0 release and breaking changes are OK, but we still don't want to make the migration path too steep.. =)\n. :+1: \n. Eventually I'd like to get Sauce Labs tests working, but go ahead and delete the files you don't need. We can recover old settings from version control if we need them.\nSince there is a new version of Sauce Connect with breaking changes, I don't think the old settings would be useful anymore, anyway. =)\n. @koresar if you can review this and merge, I'll be happy to set up the Travis CI GitHub integration.\n. No worries. I'm just glad you're willing to help. =)\n. @troutowicz nailed it. That's how I do it. :+1: \n. A .static() convenience method would be a nice addition to the 1.x line. We should also pull it into 2.x, of course. Do either of you want to do a PR?\n@koresar, you want to lead this? If @DylanPiercey or @troutowicz want to do a PR, do you have time to review & merge?\n. https://github.com/ericelliott/stampit/pull/65\n. @troutowicz I've added you as a collaborator and assigned the issue to you. Feel free to reassign to @koresar when you're ready for code review.\n. Oh crap, I edited @koresar's post instead of creating my own. It was an accident, and I am a clown.\nHere's my proper reply. I don't know how to undo my crappy edit:\n\nHowever, I probably should inform that we are going to have \"refs\" feature (see #60). Basically, these are object references added to each object instance (not stamp). Statics in the object so to say. May I wonder why you need statics for stamps but not object instances? I'd like to find how many people would need this feature.\n\nThere are already several ways to set properties on instances, and we definitely don't need another. A static is a property set on the factory itself (or the constructor in classical OO, or the class itself in some other OO languages).\n\nAlso, stampit main objective are objects, not stamps. I doubt people would use this feature extensively, if use at all. I believe modules (like stampit) should do single job and do it well.\n\nI disagree completely, not least because React components have some properties that are preferred as statics, including propTypes. Type specification is a really good use-case for factories, in fact, because they tell you exactly how to use the stamp, including the types of all the parameters and the return value. Among other things, this can be used to provide type hints in IDEs, or even automatic detection of which object types are composable in graphical dataflow systems like NoFlo.\n\nMoreover, I feel like introducing a whole new feature which saves people 15 characters\nstampit.extend(someStamp, { ... }); is not worth the hassle around it. As we would need to support it preferably forever.\n\nBecause a lot of people will likely end up using Stampit to create composable React components, and will likely create many components per day, I have to disagree again.\nThanks for pushing back. We definitely do need to justify new features to avoid bloating Stampit and avoid including features that are out of scope, but in this case, I think we need to do it. =)\n. js\nvar stamp = stampit({\n  refs: {},\n  methods: {},\n  props: {},\n  enclose: function () {}, // or an array of functions\n  static: {}\n});\nThis is great for the 2.x line.\nFor the 1.x line, only include the method form, not the parameter form. I don't want people to start using 5 params, and we can't make a breaking change to the 1.x line.\n. I just thought of another great use for a propTypes static property on stamps: Static analysis could automatically detect if composing stamps would cause a property name conflict, and warn if they do. We could create plugins for popular IDE's, and it's possible the React team might create custom tooling for Babel that stamps could automatically benefit from.\nStampit could also optionally warn about conflicting property names in the console when stampit.compose() is called, but we'd need to make stampit aware of a debug mode, possibly with two different builds, one for development, and one for production.\n. I'd prefer the singular, static (short for \"static properties\").\nWe'll also want to add documentation. =)\n. > So, method is the only thing implemented. The fourth parameter for stampit() will not be implemented. Is that correct?\nTrue for v1. For v2 I'd like to see all params collapsed into a single options arg, where static will be available.\n. > You might want to consider converConstructor statics support. See the sample unit test:\n:+1: \n. > stampit is not compatible with ES6 classes\nCan you write a test that demonstrates the problem with Stampit, specifically?\n. Could you file that as a bug in a new issue?\n. Hi @troutowicz, I'm definitely planning to use Stampit heavily for React components. I was initially thinking I would write a reusable stamp specifically designed to create React components, but now that I've been thinking deeper about it for a while, I'm thinking that some features of React components also make a lot of sense to support natively in Stampit. For instance, the propTypes that I've already mentioned in a couple other threads today.\nFor the people not following those discussions yet, those threads are:\n- https://github.com/ericelliott/stampit/issues/67 and\n- https://github.com/ericelliott/stampit/issues/64\nI will probably still create a specialized stamp for React, but that would be implemented in its own module that requires Stampit.\nI'm really glad you're already working on a React app with Stampit. I'm just beginning work on my first attempt. I wanted to take some time working with React directly in order to get a sense of which features are most important to support, and the most natural place to implement those features.\nWe should use this thread to connect about our findings, and the problems we need to solve for React users going forward.\nJust keep in mind, Stampit is in production use in a lot of apps that don't use React, so anything that is React-specific rather than generally usable, we won't be adding those to Stampit. I've created a separate repo for the React stamp project, but there's nothing there yet.\nIf you're working on something similar, please create a GitHub repo for it, and we can potentially merge our work.\n. For those who aren't aware, you don't need class to use React, even if you don't use the deprecated .createClass() method: https://gist.github.com/jquense/47bbd2613e0b03d7e51c\nIn this thread, we're discussing ways we can improve the experience of building React components using composable stamps, and it will likely result in a specialized library that sugars react component creation and composition.\nNot sure what we mean by composition? You could compare it to using React mixins that .createClass() enables, except that you can compose them without referencing the components you inherit from inside the new component declaration.\n. > I'll put together a repo in a bit.\n:+1: \n. It's a start. I made mine a factory that takes React as a parameter and uses stampit internally so that the user is never exposed directly to Stampit, for a couple reasons:\n1. Having multiple instances of React on the same page can cause a lot of problems. For instance, you can get errors if you try to use refs, and I imagine it would probably screw with context and some of the internal React type checking as well.\n2. You can focus on exporting an ideal API to create React components.\n. :+1: \n. I had a similar thought, but I think it should have propTypes for convenience, which gets set as a static.\n. Also, I'm not a fan of passing in mixins. I'd prefer it to offer a .compose() method like Stampit does.\n. =)\n. ONLY in debug: During compose, look at the propTypes of stamps being composed. If any propTypes conflict, warn.\n. We haven't even got typesystem specs, yet.\n. I'm OK with dropping IE8 support in version 2, but version 1 still needs it.\n. We should keep supporting IE9 in v2. There are still lots of people running old versions of Windows that don't support > IE9, unfortunately. );\n. Yep. IMO, our new targets should be IE11+ and all evergreens.\n. :+1: \n. Are we done with this? Please close the issue if it's done. =)\n. =)\n. Nice.\n. Let's skip phantomjs. If we want to test in-browser, we should just use Sauce Labs.\nYou should get all your errors if you run tape without Stampit. Does that work for you?\n. :+1: \n. :+1: \n. - fourth argument to stampit()\nDidn't we decide that we're switching to an options object in 2.0?\nI don't want 5 arguments in the API.\nI know this is a breaking change, but it's 2.0. This is our chance to improve the API. I'm more concerned about making sure that we can still compose with 1.x stamps, but I don't think we need the same API to create new stamps.\n. How could it be a non-breaking change?\n. I really think that's a bad idea. We've got a whole lot of reserved names that could collide with stamp properties.\n:frowning: \n. I think it's cool to do it in a different commit, but we can't cut a 2.0 release until the signature is finalized.\n. Break the function signature (so we can fix it).\nPreserve compatibility with 1.x stamps.\n. Here's an easy rule of thumb:\nWhat's right for our users is more important than what's convenient for us.\n. Yep, I noticed. Let's keep this issue open until that's done. I wanted some 2.0 documentation so others can start testing from repo clones. :)\n. > When will you have source.fixed.state and not source.fixed.refs ?\n\nThe same for all the other || fallbacks ?\n\nThis is support for legacy stamps.\n\nobjects is being listed as a parameter, but is not being used. The function is looping through the arguments Object.assign style. \n\nThis can be fixed after upgrading stampit 2.0 to use ES6 using rest params. Instead of specifying an unused formal param, we can just use ...args in the function signature, which will give us an array of all the objects.\n. I wouldn't worry too much about nitpicky implementation details unless you spot something that's really slow or just plain broken. What you should do is:\n1. Download it\n2. Test & lint\n3. Do all the tests pass?\n4. Look at all the tests. Do they really cover what they're meant to cover? Do the tests make sense?\n5. Look at the implementation. Does it look correct? (Note, correct and how you would implement it are two different things).\nIf you see something and there is clearly a better way, or a learning opportunity for the team, feel free to speak up.\nCode reviews shouldn't slow everything down and lead people into bikeshed discussions. They should be a basic code quality protection, just so we all have a bit more peace of mind that the code does what we say it does.\nThe only thing that matters in software development is that the users love the software. Does it look like it would work and you would love to use it? =)\n. Is there an .assign alias as well as .mixin and .mixIn?\n. Are there tests for the aliases? I didn't see them...\n. :+1: \n. :+1: \nAbsolutely. Named properties only for stamp creation in v2. No more multi-arg support.\nWe should keep the fluent methods, though. =)\n. Agreed, but I think a lot of people are using the fluent methods instead of the arg list, anyway, just because it's a more direct way of building the stamp they want.\n. Just to clarify, we can't put this off for 2.1 because it's a breaking change. If we do a 2.0 release before this is done, this would have to be 3.0, not 2.1 -- and that's awkward because users may worry that our API is too unstable to rely on.\nWe need to balance evolving user needs and  API stability. I think the best way to do that is to ship this change with 2.0.\n. :+1: \n. Fixed assert() ;)\n:+1: \n. Could be as simple as:\nimport debug from `./debug`\nWe could use a build step to write export default true or export default false to that file depending on which build is running at the moment.\nThen you could do if (debug) checks before warning.\n. I don't think we should fix this in the 1.x line, but we should see if it's possible to fix this in the 2.x line.\nThey're looking at letting you set a custom invoke function if a constructor is called without new for ES7, but I'm not sure whether or not you can dynamically add that property to a class outside of the class declaration, so I'm not sure exactly how we'll fix this issue.\nYet another reason to avoid the class keyword.\n. This issue is probably not going to get fixed anytime soon -- certainly not with our next minor update. Created 2.x as a \"we have no idea when we'll do this\" milestone. ;)\n. > if anyone knows why Map throws if not called with new (or if you can direct me to who might know), I'm all ears.\nAll ES6 constructors throw if you don't call them with new.\n. > reserved stamp 'static' properties: create, methods, state, enclose, compose, and fixed\nWe should explicitly test for those and warn about conflicts.\n. We shouldn't warn at all in the 1.x branch.\nIn the 2.x branch we should log to the console in the debug build only.\nOf course, that means we'll need to create a debug build in 2.x. ;)\n. @troutowicz For some use cases, deep merge makes sense. For others, shallow is better.\nI personally use statics for things like type declarations (e.g. React propTypes). I prefer deep merge for propTypes.\nWhat do you think, @koresar? Obviously this feature may be used for more than just React components. =)\n. Turn off the JSHint reserved keyword error. It hasn't been needed since ES5, since reserved words are now allowed as property names without quotes.\n. Ignoring the propTypes use case, I think assign behavior is probably what most people will expect.\n. I'm OK with it.\n. Done! 1.2 is now available on npm.\n. This is not a bug. The fat arrow creates a lexical binding. That's why there is a fat arrow in the first place. Similarly, the fat arrow in ES6 won't work, either.\n. > I'm removing node.js 0.6 and 0.8 support.\n:+1: \n. Haha, cool idea, but this is out of scope for this repository. Maybe create a separate one for a Babel plugin? =)\nBTW, while I think native support would be great, I'll probably continue to use stampit as a library until there is a real effort to standardize it in the language.\nIn order to gain support for language standardization, we need to get closer to 20k stars for Stampit, so spread the word. ;)\n. I'm cool with an org, but somebody else already has the \"stampit\" username but I just grabbed \"stampit-org\".\n. :+1: \n. > - /dist/ is now not committed to the repo but build only on the prepublish NPM hook.\nDo you have a link to a reference where I can learn more about this? Is the latest /dist/ build still available when people run npm install in their apps? IMO, it's a little weird that it won't be browsable in the repository on GitHub...\n\n\nExcluded /test/, travis, jshist, SauceLabs, etc. development files from NPM package via .npmignore.\n\n\nProbably a good idea.\n. @troutowicz Thanks for the reference. I was unaware of this part:\n\n\"(Also run on local npm install without any arguments.)\"\n\nI think that answers my question, so the dist build of stampit will be available if we add it as \"main\", right?\nI ask because I'd love to convert Stampit source to ES6 and compile it, but we'll still need to support require in ES5 projects. =)\n. > I want to see all stampit projects using ES6!\n:+1: \nLet's do that right after we land 2.0. =)\n. My comments are just minor nitpicks. I'm OK with landing this.\n1. Are there other PRs we need to merge first?\n2. Are the rest of the to-do items for 2.0 ready?\nPlease feel free to merge any pending PRs necessary to land 2.0. I'm excited to share all your great contributions with the world. =)\n. The io.js install is failing.\nLooks like Travis can't find lodash 3.9.1+ even though it's currently at 3.9.3. Am I reading that right?\n. This looks good to me. I'm happy to merge it but maybe we should hold off on npm publish until we sort out why the travis build is failing?\n. Oh, cool! Can you do that in a new PR? This one is already merged. =)\n. Nice.\n. haha, yeah. I'm crazy busy. Wasn't careful enough.\n. How's this? The headings are not ideal for Wikipedia, but I think the explanation is clear.\nWhat is a Stamp?\nA stamp is a composable factory function. Stamps allow you to inherit easily from multiple ancestors by composing multiple source stamps. You can combine properties, methods, and initializers (with closures) from any number of stamps to produce a new stamp. Stamps are more flexible than traditional factory functions or classical multiple inheritance. Traditional factory functions can't be composed together to produce new factory functions. Class inheritance does not provide a standardized mechanism for class composition.\nStamp composition takes advantage of three different kinds of prototypal inheritance:\n- Differential inheritance, aka delegation (e.g., JavaScript's [[Prototype]]),\n- Mixins/cloning with optional deep merge, aka concatenative inheritance (e.g., JavaScript's Object.assign()),\n- Functional / closure inheritance (for initialization or privacy/encapsulation)\nHow are Stamps Different from Classes?\n\nIt's easy to combine multiple stamps to create a new stamp with all of the source stamp capabilities\nStamps are factory functions, so they don't need to be invoked with new (which couples callers to the implementation of object instantiation)\nStamps don't create parent-child class hierarchies. Class hierarchies create \"is-a\" relationships between classes. Stamp composition creates \"has-a\" or \"uses-a\" relationships, instead. For that reason, stamp inheritance is less brittle than class inheritance.\n. ^^ I added quite a bit more detail. ^^ Is that better?\n. Yeah, I think it's important to get the README right first. We can take another pass and fix the tone for Wikipedia. I don't have time to do a tone edit right now, though. =)\n. If we want the Wikipedia article to remain, we need to find some credible third-party sources discussing stamps. I know of a couple slide shows, but nothing credible that I didn't have a direct hand in creating. (Multiple sources by the same author are considered the same source by Wikipedia).\n. @troutowicz You might like that real example link. Click it. =)\n. ## Learn about Reactive Programming\n\nVideo\n\nAsynchronous Programming at Netflix Jafar Husain\nWhat is Reactive Programming? Jafar Husain explains reactive programming\nImmutability: Putting The Dream Machine To Work by David Nolen\n\nReading\n\nIntroduction to Reactive Programming\nThe Dao of Immutability The Way of the Functional Programmer\nThe General Theory of Reactivity What is all this talk about reactive? Functional? Promises? This is the beginning of a reactive programming bible.\nReactive MVC and the Virtual DOM Great read, even if you're not a React user.\n. Nice.\n. Looks good to me. I don't have time to pull it down and test it myself.\n\n@koresar @troutowicz - feel free to merge if you beat me to it. =)\nMaybe I shouldn't be allowed to merge this week. Crazy busy and distracted.\n. @unstoppablecarl I've made you a repo collaborator, which means you can merge PRs from fellow collaborators. Please continue to use the PR process for contributions. =)\n. Writing stamps that take arguments is an anti-pattern. Stamps support arguments primarily to support legacy constructor arguments. When you're dealing with stamp composition, there is a high probability of argument collision which could create some very unexpected and frustrating results.\n. I wish I had time for more thorough and helpful feedback but I'm strapped for time today. Lucky, the other Stampit community members are amazing and wonderful people. I'm sure they'll be very helpful.\nWelcome to the community. We're glad to have you! =)\n. > @ericelliott no worries about the time thing, totally understand, thanks for responding. I'll keep playing and learning (learning loads every step of the way). @koresar asked me to share my thoughts and questions, so that's mainly all I'm doing.\nVery cool. Thanks for taking the time. It really helps us understand how we can flesh out the documentation to better orient beginners to using stamps. =)\n. Just to clarify: invoking the stamp and calling .create() should do the same thing. Want a deep clone method? Call it something else.\n. I should probably release a v2 release candidate on npm to make it easier to use v2, but you should be aware that v2 is still a little bit in flux, and there could be bug fixes in the v2 line that may change some of its current behavior in a way that could be a breaking change.\n. ```\nvar stamp = stampit().props({\n    connection: 'my connection',\n});\nvar instance = stamp({connection: undefined});\nconsole.log(instance); // { connection: 'my connection' }\n```\nThat is a confusing example. Normally you only want to override a property if the property is set in the override object. By passing in undefined, you're explicitly stating that the property is not set, so if there is a default value, as is the case here, then the default value should be used, which is exactly what happens.\nAs @koresar pointed out, if you want to override it with a null value, you should pass null instead of undefined. If you want to unset the key entirely, use an .init() function and the delete keyword, or compose from a stamp that doesn't contain the unwanted key in the first place. ;)\n. :)\n. I'm still seeing a ton of tests without descriptions. );\n. That sounds good to me.\n. Fixed.\n. :+1: \n. I think we should keep an open mind. @unstoppablecarl I did like the typeography and color choices.\nI do like the idea of basing the logo on a rubber stamp, but let's not shoot any ideas down at this stage. Let's just see what people come up with and make decisions later. =)\n. Thanks for these guys! It's starting to get interesting.\n@NinjaGrisen  I definitely like the lowercase \"it\" on the end of Stampit. Love \"composable factories\". Great tagline!\nI like the texture.\n@MarkAurel Interesting shape. =) I think I'd prefer a flat design look - it would probably scale and translate better to different design situations.\n. At least the \"Stampit\" part should be legible, yeah. We may want a mini version that's simplified and drops the surrounding text. =)\n. Nice work @unstoppablecarl!  \\o/\n:fireworks: \n. Good idea to add svg in a repo. Do SVGs preview properly in gists?\n. :frowning: \n. How would this one look in green?\n\n. Good logos aren't photo-realistic. They're very, very simple. See Nike, Audi, Mercedes, Uber, etc.. We need something that looks great at 100px x 100px that scales well (simple shape vector).\n. :)\n. Fixed.\n. I've got this one. Thanks!\n. I don't think so. Bower expects AMD or UMD. ./stampit.js is not either of those things.\n. I have no bower credentials to bestow. I'm not the one who managed the power package. If it's coming back, someone will need to create a new Bower package.\n:facepalm:\n. That totally needs to be an emoji.\n. Good times... ;)\n. Do we need to open a new issue and get some movement on this? @sethlivingston run with it. Getting Stampit to play nice with bower is all yours. =)\n. For small, non-breaking changes and minor bug fixes, the first reviewer should feel free to merge as long as the build is passing and they've looked over the code and feel confident.\nFor larger changes such as API additions or breaking changes where broader discussion is warranted, (like #96), I agree that other core contributors should have a chance to weigh in before it hits master. =)\nIn those cases, we should definitely leave it open for discussion for a few days and give other contributors a chance to weigh in.\n. cc @troutowicz let's get some eyes on these. =)\n. Thanks for the excellent work @koresar & @troutowicz!\n. Non-method delegate prototype props is a code smell. We should only add .proto() if there is loud demand from users (so far there hasn't been).\nEven if there is a surge in demand for it, I would insist that we include a strong warning against it in the docs.\n. Let's get this merge-ready ASAP. I'd like to have these ready for the 2.0 announcement. =)\n. Definitely ESLint. :+1: \nI've been experimenting with my own ESLint config, but I'll check out the Airbnb style.\n. https://github.com/stampit-org/stampit/issues/116\n. :+1: \n. Yes, we could add this. It would either return a new instance (if synchronous), or a promise if async. Question: How to determine whether it's sync or async?\n. I think there's a bit more to uncover. Let's get some unit tests going and find out.. :)\n. JS native Promises take a function as a param, so that wouldn't be the only step...\n. https://github.com/stampit-org/stampit/issues/116\n. :+1: \n. nsp is not much overhead at all, especially for a module with minimal dependencies -- and in the unlikely event that lodash is compromised, nsp will alert us to it so we can help push a fix upstream ASAP so stampit doesn't end up on the vulnerable modules list.\nExamples of \"benign\" utility modules exploited:\n- semver Regular Expression Denial of Service\n- libyaml - heap-based buffer overflow when parsing YAML tags\n- validator isURL Regular Expression Denial of Service\n- JS-YAML Deserialization Code Execution\n. This issue is a check to make sure that all the dependencies you've installed locally also exist in package.json, so when other people try to install it, they get all of the required dependencies installed. It also checks for dependencies that are required in package.json that are not used in the code (which sometimes results in false positives, so we don't count those ones as errors).\n. > Isn't it the way npm work by default?\nNot if it's missing from package.json, which is what this checks for.\n\nDo you think there is a possibility for that to happen in 100 lines code base of stampit? I doubt.\n\nHoping to get all my projects using the same standards so we don't have to reinvent the wheel for every new project. Think on the scale of stampit-org, instead of just Stampit. =)\n\nFor a utility module like stampit it's an overhead.\n\nThe dep check will run very fast, and only on Travis (since we won't make it a pre-commit requirement).\nSound fair?\n. Let's do a lint-only pre-commit hook here. Travis will catch the rest. =)\nIf anybody feels strongly that we should remove it after a week, we'll remove it.\nI like the lint hook because it actually saves me time. =)\n. We already spent too much time arguing about this.\n. I do want this in the prod-module-boilerplate. This thread has convinced me to make it lint-only.\n. :+1: @koresar \n. We need to answer \"what is stampit?\" and \"why should I care?\" in a short paragraph or two at the top of our README.\nThen move on to the https://github.com/zcei/standard-readme features.\nI have no objection to moving the detailed API docs to individual files in the docs folder.\n. How about something like this?\nWhat is Stampit?\nA library that helps you create composable factories for simple and powerful oo programming.\nWhat is a stamp?\nA stamp is a composable factory function. It creates object instances. You can compose multiple stamps together to create new stamps.\nGetting Started\n\nOne very basic example of install and use (a, b, compose)\nLink to advanced examples\n\nWhat can it do for me?\n\nFactory functions cause trouble because they require the new keyword, which couples all callers to the constructor. Classical inheritance causes trouble because it imposes arbitrary class hierarchies on your code. All continually evolving class hierarchies are eventually wrong for new use cases.\n\nWhere can I learn more?\n\nThe Two Pillars of JavaScript\nClassical Inheritance is Obsolete: How to think in Prototypal OO\n\"Programming JavaScript Applications\"\n\"Advanced Examples\"\n. Agreed on all counts. The only reason stampit.mixin() exists is because when I originally wrote Stampit, only the most in-the-know devs were actively using _.extend() and $.extend().\n\nThe world has changed a lot since then!\n:+1: \n. :+1: \n. > Reading something like that confuses people.\nSure, remove it from the README, but we should add a more detailed API doc and include it.\n\nI have never passed my init functions as properties of an object.\n\nI use these features all the time for more complex inheritance. Consider this a strong keep vote.\n\nLet's leave the multiple arguments feature but remove any mentioning of it from the README.\n\nAgreed, but we'll need to create a more detailed API doc. The README can serve as our \"welcome to Stampit, here's how to get started\" guide. =)\n\nOr, we can leave a small note in the README saying \"Any of the following accept multiple arguments.\" or alike.\n\nThat would be fine, as long as there's an example in the API docs somewhere. =)\n:+1: \n. We should start a checklist for the new README. And these should be on it:\n- [ ] Link to Fluent talk\n- [ ] Link to The Two Pillars of JavaScript Part 1\n- [ ] Link to Common Misconceptions About Inheritance in JavaScript\n. @ootoovak Thanks! :+1: \n. :+1:  We should always use the stampit.* shortcuts when we're not passing a param.\n\nthe difference between the two\n\nThere shouldn't be any. We should note in the API docs that stampit.* are just shortcuts for stampit().*\n. :+1: \n. Looking much better. =)\nSimple = good.\n. :+1: \n. https://github.com/cdnjs/cdnjs/pull/4776\n. :+1: \n. I didn't see any major issues here. Just a couple minor nitpicks. Feel free to merge, or fix and merge, at your discretion. =)\n:+1: \n. Nice! =)\n. Do we need to open a new issue to address the IDE problem? Or reopen this one?\n. :+1: \n. > I was just trying to think of a way to display a warning when the project is in development, not production.\nVery simple solution: Create a warning function and import it.\nDuring the build process, create two separate builds:\n- Dev build - warning logs\n- Prod build - warning is a no-op\n. Warning = runtime console.log()\n. One possible implementation of alternate build is to create two different build entry points and use dependency injection to pass the warn() function into stampit:\nDev build with live entry point:\n``` js\nimport warn from 'warn';\nimport main from 'main';\nexport default main(warn);\n```\nProd build with no-op entry point:\n``` js\nimport main from 'main';\nexport default main(()=>{});\n``\n. Do you think we should put them in their own repos? =)\n. [Hows this?](https://github.com/stampit-org/useful-stamps)\n. What's wrong with [the existing atmosphere package?](https://github.com/richsilv/meteor-stampit) \n. Oh, I see, the existing package depends on the./dist` folder that no longer exists in the repository. Is there any way to update the existing package instead of modifying this one? This is the first time I've seen a Meteor package wrapper add things to the original npm package instead of creating a wrapper package for atmosphere.\n. cc @philcockfield - Is there a better way to handle this?\n. > I believe it's more reliable for people to see stampitorg:stampit\nI am open to that, but I have no interest in maintaining a meteor package. Are you volunteering?\n. Move discussion to https://github.com/stampit-org/stampit-meteor/issues/1\n. I'm not convinced that this belongs in the Stampit repository. Maybe it should be in a separate repo that wraps this one?\n. See stampit-meteor\n. Personally, I don't care about property name collisions -- with the defaults/overrides pattern, that is a common and expected situation.\nWhat I want to be notified about is if propTypes conflict when I pass stamps into stampit.compose().\n. =)\n. Let's close this and open a new one later when requirements are fleshed out better. =)\n. Yay!\n. Feel free to remove \"help wanted\" and assign to yourself if you're tackling this. =)\n. :+1: \n. Warnings are a nice feature to warn people using it in prod that there will be a breaking change in an upcoming version. (3.0 in our case)\n. > Should we log to console when people are using state or enclose ?\nYes. I think that deserves a separate issue. =)\n. :+1: \n. :+1: \n. > Should I store the actual object properties in a sub property or in the root of my stamped object?\nThat depends on your needs. I do both, frequently. Many objects I compose are also event emitters. I frequently have someObject.events and a corresponding someObject.on that delegates to somObject.events.on. The reason I set up that delegation is because the EventEmitter uses several properties on the root object if you let it. I want to minimize the chance of property collisions.\nI also frequently namespace stamps. I often follow the jQuery plugin standard: Use only one namespace per plugin. In this case, you can think of stamps as plugins.\nFor example, I sometimes model things like this: db needs to keep track of contacts, who may or may not be users of the system. Some contacts are also users. Some users are also employees. Each of these entities has their own properties that they keep track of. Sometimes there are users who don't have contacts added to the system yet. These are all people, but there is no corresponding \"people/person\" entity type in the system, so there's no root object that all of these inherit from... instead, we do it with composition:\n- contact\n- user\n- employee\njs\n// Create a new user who is also a contact and an employee.\n// Don't init properties yet, use defaults.\nconst newUser = stampit.compose(user, contact, employee)();\ntypeof newUser.contact; // 'object'\ntypeof newUser.user; // 'object'\ntypeof newUser.employee; // 'object'\n\nDoes it make sense to separate the db layer and use static functions as kind of constructors?\n\nIMO, it makes sense to completely separate the db layer from your domain model. I wouldn't even mix the db access stuff into the same object. Instead, I model the entire application state together. For example, check out Redux or Facebook's Relay.\nIf you really want to simplify your app, model db access and domain models as completely separate concerns.\n\nCan I trust \"this\"? Will it always reference the stamped object?\n\nThat depends on what you mean by \"trust\". JavaScript has a dynamic this which you can manipulate from outside the object, so no, you can never really trust this, because anybody could do yourObject.yourMethod.call(anyObject, ...args);\nBut the default behavior when you invoke a method using dot notation (e.g. myObject.myMethod()) is to use the object that you invoke the method on as this. Stampit doesn't do anything fancy in that respect unless you explicitly model different behavior into your stamp (such as creating a differently-bound method with an initializer).\n. Using methods for data is an anti-apttern because you could accidentally mutate data for all instances that should only have been mutated for a single instance.\nThe \"hacking stamps\" section is demonstrating that properties you set on the delegate prototype can behave like default values that will appear to be set even if the object has no own property with that name.\n. @nathanmarks\nThe v8 optimization stuff is about virtual classes, which is about optimizing property lookup.\nThe cheapest Chromebook on the market can access millions of properties per second. I've said it before, and I'll say it again -- unless you're building a perf-critical general utility library like Lodash or RxJS, object creation and property access is not your bottleneck.\nGet your pageload under 2 seconds on 3G. Get your click responses under 100th of a second. Get all your animation frames under 16ms. ONLY THEN should you come and talk to me about the perf of Stampit vs new.\nAnd then guess what I'll tell you... The fastest way to instantiate objects and trigger virtual classes is not new -- it's an object literal. If you're worried about property access times, ditch the prototype chain altogether and just spit out fully formed object literals.\nNo matter what technique you use, there will be a tradeoff between flexibility and perf, but that tradeoff is so tiny as to be almost entirely insubstantial.\n\nCan you tell the difference between .0000000001 seconds and .000000001 seconds? Neither can I, but I sure can tell the difference between loading 10 small icons or loading one web font, instead! ~ \"Common Misconceptions About Inheritance in JavaScript\"\n. [Closes #142]\n. :tophat: \n. - [x] Stampit isn't just a library - it's a specification [mental note, add docs/stamp-specification.md] that allows you to create factories (called stamps) that can be composed together.\n- [x] Functional mixins force you to chose which bits are the \"base class\" and which bits are \"mixins\". Those choices can later be wrong for new use cases. Maybe you'd like to combine two base classes. Too bad. You can't! With Stampit, everything is a stamp, and you can compose almost any combination of stamps (as long as their features don't collide).\nYou can have only one initializator (aka constructor). In stampit you can have as many as you want.\n- [x] Additional point: You should never export constructors from modules because they couple all call sites to the constructor implementation.\nThe benchmarks are fast. Object creation is optimized because of using the new keyword and omitting _.extend for each object created.\n- [x] See \"Is There a Big Performance Difference Between Classical and Prototypal Inheritance?\"\n. I don't think we need to address functional mixins in our docs, and the wikipedia page has been deleted. Apparently we need to get more people writing about stamps so there are more sources than just my book. ;)\n\nCan we close this issue?\n. Thoughts?\n. :+1: \nI do want it to auto-fetch missing packages, but that's a different ticket. ;)\n. If we close the auto-fetch issue, we can change back to npm install -g cloverfield && cf build package.\n:grey_question: \n. :+1:\n. Updated to move -stamp to the end of the module name instead of the beginning. Reads better. =)\n. Did you try passing a stamp into a composition after the event emitter stamp? It should override the overridden .init() (restoring stampit's .init()). However, this raises an important issue: Should we really use a method name as generic as .init()? I guarantee that a lot of stampit users have methods called .init() on their legacy stamps. One of the benefits of .enclose() was that it was unlikely to conflict.\nIt also underscores the fact that we need to be careful not to expose too many built-in statics, because there is a higher potential to conflict with the stamp author's statics. In fact, now that we have the options object, maybe we should deprecate the built-in static methods?\n. Remember how I said it's a priority for the user to be able to produce exactly what they want with stamp instances, and we shouldn't get in the way of that? With the growing importance of statics, I think the same should apply to the stamp. Maybe we should create a separate module:  stampit/tools with things like the static shortcuts:\n``` js\nimport events from 'events';\nimport stampit from 'stampit';\nimport {\n  convertConstructor, props, compose\n} from 'stampit/tools';\nimport myProps from './props';\nimport stamp from 'stamp';\nconst emitter = convertConstructor(events.EventEmitter);\nconst defaults = props(myProps);\nconst enhancedStamp = compose(emitter, defaults, stampit(stamp));\n```\nThoughts :question: \n. > oh! I agree about stampit/tools. I'd move there the convertConstructor. But, please, not the props or compose. These are essential to each LOC I use stampit at. I literally use only stamp.props and stamp.compose.\nWouldn't it be even less typing to just use props and compose?\n. or compose(stampit({ props }), otherStamp); ?\nThis can even be simplified to compose(props(myProps), otherStamp);\n. I would argue this is MUCH more readable:\njs\nstampit({\n  props: {\n    body: {...}\n  },\n  methods: {...},\n  init: () => {...},\n}).compose(Prevalidable).prevalidate({put: {body: joi.required()}});\nor...\njs\ncompose(\n  props({body: {...}),\n  methods({...}),\n  init(() => {...}),\n  Prevaliable\n}).prevalidate({put: {body: joi.required()}});\n. Starting to really like the idea of that second syntax...\n. ``` js\nimport {\n  compose, props, methods, init\n} from 'stampit/tools';\ncompose(\n  props({body: {...}),\n  methods({...}),\n  init(() => {...}),\n  Prevaliable\n}).prevalidate({put: {body: joi.required()}});\n```\nI don't see a problem with this. Looks very readable to me, and was not much typing.\n. > Compare to:\nI am.. and that solution has lots more potential to collide with statics. :frowning: \n. See https://github.com/stampit-org/stampit/issues/149\n. :+1:  Added to description. =)\n. @troutowicz @unstoppablecarl @JosephClay Pretty big breaking change API discussion here.\nDefinitely want more eyes on this.\n. I'm seeing a pretty large growing list of cons for the workaround...\nAm I leaving anything out of either pros/cons argument?\n. > I was thinking to guard stamp's methods inside the stampit itself\nSo end-users don't have to know about GuardStatics? How will that work, exactly?\n. > That's not a workaround which @mdhooge was talking about. He's using .enclose() alias. Please rephrase this statement.\nThat statement is not related to the .enclose() workaround. I'm talking about GuardStatics - which is also a workaround.\n. Workaround = work you have to do to route around a problem.\nvs\nmodularization: problem disappears completely, so you don't have to write any special code to handle it.\nNoteworthy, the latter also has perf benefits, because the extra GuardStatics code does not have to be interpreted or invoked, ever.\n. Well, yes, I agree you should flip the 2nd and 3rd argument, but then you've just shifted the problem from one side of the equation to the other. It's still a problem. Statics still collide -- that just changes what happens when they do...\n. > Maybe the only problem is convertConstructor\u2026\nA necessary evil. Constructors suck, but there are lots of constructors because there are lots of people who don't know that constructors suck. ;)\n. > We can have refs, props, compose, init, methods as keywords, as a language syntax.\nIt would probably be Object.* and the names would almost certainly be changed due to design-by-committee.\nActually, maybe even Object.stamp.*.\n. > No, it is not.\nIt is if the user has to add code to work around static collision. We either override one or the other, and to avoid that override, the user will need to make a reassignment, and that's at minimum an additional line of code, and at worst a mapping reassign over several props.\nAnd that happens every time the stamp in question is composed with other stamps.\nWorst case scenario, 6 reassignments * n compositions.\n. js\nimport stampit from 'stampit'; // <- stampit v2 compatible\nimport {compose, init, props, methods} from 'stampit'; // <- the new functional way, v2 incompatible\nI'd add stamp which is stampit as a pure function without the statics:\njs\nimport { compose, init, props, methods, stamp } from 'stampit';\njs\nstamp composedStamp from StampName, SomeOtherStamp; // `from` instead of `composes`?\n. > import stampit from 'stampit'; // <- stampit v2 compatible\n:+1: :sunglasses: \n. > - ~~More chances to collide with users' variable names compose, props, methods, init, refs.~~ \nNo, because the user decides the names. ;)\n. > - ~~The import statement is required in every file the user wants to use stampit~~\nImport statement in every file is really part of \"larger import statement\" -- it's not a separate item because the smaller stampit import statement is also required in every file, so really, the only difference is that one is larger than the other. ;)\n. # New Hotness by @koresar\njs\nimport stampit from 'stampit'; // <- stampit v2 compatible\nimport {compose, init, props, methods, stamp } from 'stampit'; // <- the new functional way, v2 incompatible\nPros:\n- No static collision danger to worry about\n- Is functional\n- Probably faster\n- Not a breaking change\n- User has choice over import statement trade-off\nCons:\n- this space intentionally blank\n:+1: :clap: :sunglasses: :guitar: :fire:  :fire_engine: :cake: \n. One minor nitpick: Any stamp that uses the v2 compatible will infect any composed stamps with collision danger. We should mention in the doc that users should prefer the modular version if they're making a stamp that will likely be used as a general-purpose mixin.\n. # Action Items\n- [ ] New Hotness tests\n- [ ] Implement new hotness\n- [ ] Document mixin collision warning for v2 compat API\n@koresar Do you want to implement?\n. @JosephClay We've already been over this, and the solution is the best of both worlds. Updated issue description with \"New Hotness\" details.\n. We could rename it to stamp._stamp_.fixed, which is unlikely to collide with anything.\nOf course, we'll need to deprecate stamp.fixed. =)\n. > The proposed changes are too radical\nThat's why we'll use a deprecation process. Look at it as a long-term journey. We can deprecate now, offer old-stamp deprecation console warnings for a full year (maybe two), and then release a Breaking change to remove support for stamp.stamp.\nAFAIK, changing the name of stamp.fixed is the only radical breaking change being proposed. Am I missing something?\nToward an open-standard for Stamps\nEventually, I would like stamps to be an open standard implemented by potentially many libraries, not just stampit. Adoption will suffer if users can't use the properties they want to use.\n. > We should consider a separate package for that.\nWe can't have an open standard that not even we respect. I'm OK with keeping a chainable version going for people who prefer the legacy API because that is opt-in, but it should be possible to produce stamps that should never collide with userland libraries -- without forcing users to implement a hacky work-around.\nIn other words, both API's should use stamp._stamp_.fixed, or some alternative that is equally unlikely to collide.\n. Whoah. Mind. Blown. .create.* is a great solution to this problem.\n. @troutowicz @unstoppablecarl @JosephClay Thoughts?\n. # We are not changing the name, \"Stamp.\" So it is written. So it shall be.\n\nfunctional mixins\nWhat about \"composable factories\"?\n\nNO\nIf you think we have it tough explaining problem now, imagine a world where the name isn't:\n- Written about in a published O'Reilly Book\n- Installed and used in tens of thousands of apps\n- Evangelized for a couple solid years\n- Talked about in an influential fluent talk with 20k+ views (more than Brendan Eich's keynote from the same year)\n- Talked about in the seminal \"Two Pillars of JavaScript\" blog post that has been read over 100,000 times (that's more than most JavaScript books sell copies in their entire lifetime)\nIf you think it would be easy to reproduce the branding work that has already been done for stamps, you're sorely mistaken.\nBut they're so sparkly and new! :sparkles: :sparkling_heart: \n\nfunctional mixins\nWhat about \"composable factories\"?\n\nThese aren't names. They're descriptions. I'm happy to discuss alternative descriptions, but we're not changing the name, stamp. Of course people are asking \"WTF is a stamp?\" but we can't co-opt the already existing term \"functional mixins\" and try to make it mean something different, and \"composable factories\" is what stamps are, not what they're called. Nobody knew what a functor was before it was invented. Nobody knew what \"JavaScript\" was before 2006. ;)\nBranding starts with a brandable name, and \"stamp\" is a brandable name. Want people to stop asking what it is? Then we need to make stamps ubiquitous, and we need to make sure the community has a lot of great learning resources.\nAnybody know somebody who makes amazing explainer videos? ;)\n. Close in favor of implementing the spec.\n. Questions:\n- [x] What is the current official release? (should this be in the README?)\n- [x] What is the current published release on npm?\n- [x] What is the latest build available on CDNJS?\n- [x] Do we link prominently to the CDNJS releases in the README?\n. > IMHO it also just makes sense to have a committed copy of stampit.js and stampit.min.js included with every release we tag.\nBuild artifacts are usually not checked into source control, but I also don't see a problem with this for small library projects\n. > Before you use this distribution, consider using the NPM distribution instead; Bower usage is declining rapidly.\n<3\n. Let's get this issue closed. I think all we need to do now is link prominently to the dist options in the README.\n. @sethlivingston CDNJS should have a UMD, but aren't we already compiling a UMD for CDNJS? =)\n. Agreed. .create() should take an object to be augmented. Any type of extensible object should work.\n. @koresar:\n``` js\nimport {stamp, deepProps, statics} from 'stamp';\nconst Connection = stamp(\n  function({ stamp, instance }) { this.clone = () => stamp(instance); },\n  { url: { host: 'localhost', port: 80 } },\n  { connect() {...} },\n  statics({ printUrl: function () { console.log(this.url); } }),\n  deepProps({ url: { protocol: 'https' } }),\n);\n```\nIt's a clever idea, but code should be optimized for reading, not writing. This is definitely less readable than:\n``` js\nimport {stamp, deepProps, statics} from 'stamp';\nconst Connection = stamp(\n  init(({ stamp, instance }) => { this.clone = () => stamp(instance); }),\n  refs({ url: { host: 'localhost', port: 80 } }),\n  methods({ connect() {...} }),\n  statics({ printUrl: function () { console.log(this.url); } }),\n  deepProps({ url: { protocol: 'https' } }),\n);\n```\nI'm cool with the name statics and deepProps, and while we're on the subject of readability, with deepProps providing a more descriptive name, I think we should rename refs back to state.\nAlso, re: letting people hold state on the delegate prototype, is there a significant difference between doing that, and holding state in the statics?\nIMO, if you need shared state (which you should avoid), a static seems like a much better place to put it... doesn't it?\n. > Can someone put up an example that showcases the creatables in action?\nStampit is an example of createables in action. We're just talking about publishing a spec so that other libraries can implement standard createables, too.\n. # Stamp Standards in Two Parts\nThe stamp contract specifications\n\nSpecification (composable has a nice ring to it) - specifies what a stamp is, and how to turn a stamp description into a working stamp.\nCompose - composes stamps\nCreate - creates stamp instances based on the description and specification\n\nDefault exports\n\ncompose(baseObject, stamps...) is the default stampit export.\ncreate(baseObject, stamps...) take a base object and any number of stamps. Return a new baseObject instance with the capabilities of the composed stamps. If no arguments are passed, it uses an empty object as the base object.\n.compose(baseObject, stamps...) stamp method identical to compose(), except it prepends this to the stamp parameters. If no arguments are passed, it just uses an empty object as the baseObject, and the parent object as the stamp.\n\ncreate(baseObject, stamps...)\ncreate() should be able to take multiple types of objects and simply extend them, e.g., a function or an array. However, stamps with function or array base objects should not extend the built-in prototypes for Object or Array.\ncompose(baseObject, stamps...)\nCompose always takes any number of stamps as arguments and returns a new stamp composed from the passed in stamps. If no stamps are passed in, it returns an empty stamp.\nCore stamp creation utilities\n\ncompose(stamps): Composes stamps\nassign(objects...): Creates objects like object.assign, but always creates a new stamp rather than using the first param as destination. This will be familiar to anybody who uses ES6+ or lodash.assign()\nmerge(objects...): Like assign(), but merge deep properties\ninitialize(functions...): Functions to run during instance creation. Return value gets used as the current instance\ndescribe(propertyDescriptors...): See original post\nconfigure(options...): Creates a new stamp with stamp options. e.g. descriptor presets. Users can use this to implement custom stamp types via initializer.\n\nExtended utilities - Useful utilities not part of the standard specifications.\n\nset(pathString, value): Creates a mergeable stamp using a deep property setter string. e.g. set('obj.with.deep.properties', value)\nreactComponent(componentDescription): Creates a stamp that describes a react component. See react-stampit\nhtml(htmlString): Take a DOM node HTML string and returns a stamp that produces DOM nodes\nlegacyStampit(): Return an instance of the v2 legacy API for flunt chaining.\n. @koresar addressing some of your thoughts:\n\nIt's very important that we don't conflate the creation of stamps with the creation of instances. compose() returns a stamp. .create() returns an object instance as described by the stamp. These are two very different things.\n\nAny stamp can be extended/composed by simple MyStamp.stamp({ init: function() {} }) or alike.\n\nWe should only use one property on the created stamp. I strongly feel that property should be called .create() - implying that we're creating an object instance (not a new stamp).\nI have no argument against exposing myStamp.create.compose(), but I think most users will prefer just to import compose(), instead.\nI don't think we should call .compose() \".stamp()\". I like that .compose() is a verb, and it implies that you can compose stamps.\n. Ah, I see what you mean. Updated.\n:+1: \n. > One of the shortfalls that I've experienced with v2 has been with descriptors, as Object.assign() doesn't correctly copy over items like { get foo() {}, set foo() } whereas class does.\nYes, it would. The ability to add descriptors means that we will have full support for getters and setters, which are included in the descriptors API.\n\nAlso, would creating a stamp with a descriptor { writeable: false } be able to safely be composed with another stamp with the same descriptor?\n\nYes, provided that the other stamp's definition does not attempt to write to the property. I imagine it would throw the first time you try to write to it, so as long as your unit tests are thorough, you should be able to catch such collisions in your programs.\n\nIf only one stamp is passed to compose, should it noop instead of defaulting? Would it follow the principle of least astonishment for it to be a clone() if only one stamp is passed?\n\nNo, it will return a new stamp based on the stamp you passed in. Stamps are immutable since 2.0.\n\nIs merge the replacement for deepProps? I commonly refer to it as _.merge due to lodash.\n\nYes. I think it's a much less confusing name. =)\n\nI like @koresar's comparison to the Promise spec.\n\nMe too. He's full of good ideas lately. =)\n. You're missing descriptors & symbols in the tests.\nYou're composable function has an identity crisis. There is no parent object when not invoked as a method. It should use an empty composable. Otherwise, looking good!\nWe could start writing composable unit tests. We should host spec tests in a composable spec repo. I'll set it up later. :)\n. Typos from phone. :)\n. I've tried to capture discussion RE: terminology in the description above.\nI have not yet captured the parameters for initializers.\nThe more I see \"initializer\" used instead of \"init\" or \"run\", the more I like it, simply because it provides an obvious vocabulary. \"runners\" don't quite have the same ring, do they? =)\nI'd like to stick to verbs for utility function names, e.g. assignStatic() instead of statics(). Users are free to import them with whatever names they like, e.g.:\njs\nimport statics from 'stampit/utils/assignStatic';\n. I added a stamp descriptor section. Please look it over & comment.\n. @koresar You're right.\n. > There's one function name choice which will not lint in most projects. The set function name.\n\nAny better names you have in mind people?\n\nWhy won't set() lint? It should.\n. If we're going to do this, we should ignore the build directory in diffs.\nIgnore build directory in diffs\nYou can ignore build files in diffs.\nCreate a .gitattributes file in the repo root:\ndist    -diff\n. :+1: \n. > I believe we should:\n\n1) Create a new repo for bower packages.\n2) Give the full control to @sethlivingston and full freedom of implementing/maintaining it. :)\nHow about that?\n\nI'm OK with this solution as long as it gets auto-updated with git commit hooks. We've already had somebody set up Bower and then abandon it. If we offer it, we should make sure it's always current.\n. > Two UMD files in /dist/stampit.js and /dist/stampit.min.js?\nI'd also be OK with this solution.\n. > with Bower going away (a lot slower than most think...\nI think the real story is how much npm's growth is leaving bower users behind. Stampit was definitely not the first project to drop Bower support. I think a lot of the Bower ecosystem will soon be looking at very outdated modules, and only the most popular will have mirror repos in the Bower ecosystem to stay current.\n. @infiniteluke This is in progress as part of the official stamp specification. We're beginning to write prototype implementations now. It will be a little while before the API is officially settled.\n. Looks OK to me.\n. Sorry I merged the typos. I was in a hurry.\n. :+1: \n. Nice. :+1: \n. I also think the silly example is more clear. The problem with a real life example is that people have a harder time imagining how to apply it to their own problems. Real life examples should stay in the advanced examples, IMO.\n. I do like the ES6 updates, though. Want to remove the real life bit and just merge the ES6 upgrade?\n. @johnthad You have my permission to post whatever you want RE: \"Programming JavaScript Applications\" code samples.\n. @johnthad Come to think of it, if you would like to update all the code samples to 2.x, I'd love a pull request. Create a new file called pjabook_updated_examples.md (or something like that, I'm not picky) in the docs folder.\n. One little nitpick. Otherwise, good work! =)\n. > The .props(), .init(), .refs(), .methods() will be added by default to each stamp produced by stampit (but not by the utility functions).\nCould this be implemented as an optional mixin instead of default behavior? It would be great if the next version of Stampit actually followed the stamp specification, and allowed authors maximum control over both the stamp and object instances.\n. > Yeah, but what is \"optional mixin\"?\nA stamp.\n``` js\nimport { compose, compat } from 'stampit'; \n// compat is a stamp containing old stamp methods\nconst myStamp = compose(compat).props().refs().init().methods();\n```\nI think the whole point of the 3.0 release is so that we can abandon the old API that polluted the stamp with stampit utilities by default. Otherwise, we might as well stick with the 2.x line and just make it forward-compatible with the composables spec. 3.0 breaks things. On purpose. So it can make things better.\n. Yes.\n. In fact, we could make a simple shortcut for an API compat version that people can just drop in to replace their 2.0 calls:\n``` js\nimport { compose, compat } from 'stampit';\n// export a non-breaking version that adds composables support:\nexport default compose(compat);\n```\n. Now that I'm thinking about it, I think this would be fine:\njs\nimport stampit from 'stampit'; // 2.0 compat API\nAnd if you just want to use the composables API instead:\njs\nimport { compose } from 'stampit';\nSorry for the circular logic thread. =)\n. Yeah, I think your original idea is really the best of both worlds. Don't break old call sites, but still give people direct access to the utility functions (including compose).\nWe'll make the 2.0 compat stamp be the default export.\n. :+1: \n. If new and instanceof support is an optional mixin, I have no objection. I object strongly to making it core.\n. Done.\n. :+1: \n. > I fucking love this library\nI'll throw in another :+1: for the user community. You guys rock. :guitar: :fire: :notes: \n. This is the first time I've noticed seeing prototypal OO written as POO. I almost fell out of my chair.\nGlad to have you with us. I'm confident that once everything clicks, you'll never want to inherit from another class again.\nStamps have spoiled me. I wouldn't want to code a major app without them. =)\n. \n. haha\n. js\nfunction Foo() {\n   if (!(this instanceof Foo)) return new Foo();\n   // ...\n}\nThis effectively turns Foo() into a factory, as well, albeit with some weird side-effects related to this and instanceof.\n. Believe it or not: I write unit tests for all my example code when I write an article or a book. I think unit testing your docs is generally a good idea. ;)\n. :smile: )))))\n. Why are you rethrowing the error from Karma? Doesn't that just obscure the stack trace and the real source of the error?\n. @mdix have you tried bypassing the build completely?\n. @mdix Ah, I meant the whole system, including karma. I.e., just run the JS files and console.log() the results.\n. Delete all the stamp stuff. Does it still fail?\n. @mdix It isn't a problem in Stampit, and you can verify that for yourself. Pop open Node at the prompt, and type:\njs\nvar stampit = require('stampit');\nvar myStamp = stampit().methods({sayHello: function() { return 'Hello'; }});\nmyStamp().sayHello(); // Hello\nI just copied and pasted the body of your Stamp code.\n. I'm just gonna leave this here...\nWhy I use Tape instead of karma and so should you ;)\n. > IMO most of your points are wrong.\nI'm looking forward to reading your rebuttal post. =)\n. Thanks. =)\n. This is a perfectly valid composition, and there are use cases that may require it. Not a bug.\n. > You can create a stamp (aka behavior) which would remove duplicate initializers if you really need that kind of thing.\n:+1: \nI wouldn't consider this boilerplate that you should apply to all your stamps, though. It could introduce bugs instead of  avoid them, because some stamps may depend on the designed behavior.\n. Oops. Yeah, that's not coming back. We'll need to replace it. =)\n. PR is welcome.\n. Why would you want to prevent this from happening? This is expected behavior. This is the canonical way to override delegate prototype methods...\n. Related: \"Master the JavaScript Interview: What is a Closure?\"\n. We should probably add the symbols example to the docs, and link to \"Master the JavaScript Interview: What is a Closure?\" so people can easily read up on how data privacy works in JS.\n. Init functions run after assignments by design. Usually, you need the properties to be set to have data available for the init functions to do things with.\nThis use-case seems like a valid argument for propertyDescriptors to be attached to the instance prior to properties and deepProperties.\nHow far are we away from a 3.0 release, @koresar?\n. My bad.\n. You should prefer duck typing over checks like this. instanceof is not trustworthy (even if you use classes), and name-flagged checks can give you false negatives when an object is structurally compatible. Duck typing solves those issues.\n. I handle situations like this with dependency injection or shared module imports. You don't have to do everything with stamps.\n. My vote is the ES6 import.\n. =)\n. Build scripts are usually added via prepublish. Good call. \ud83d\udc4d \n. Maybe we should be able to optionally import isComposable and isStamp with:\njs\nimport isComposable from 'stampit/isComposable';\nimport isStamp from 'stampit/isStamp';\nThat way we can have a single stampit export.\n. Ava doesn't work in browsers, yet.\n. Apologies for being so short. I'm not trying to be rude, I just have limited time to review PRs between my other responsibilities. I shut this down quickly because Ava is a non-starter for browser testing, and our tests must be browser compatible so that we get get the browser tests running again. Stampit used to have browser tests that ran in the cloud on Sauce Labs, and we need to make sure we can easily do that again.\n. Getting Ava to work in browsers is not a small task. There is a long open Ava issue tracking the slow, not-a-top-priority progress. \n. I put a little time into trying to get browser tests working for stamp-utils. I felt like I was close, but I ran out of time to work on it. Getting the compose tests running from check-compose seems like the next logical step. =)\n. > Ok I see, but I believe that solution is simply running browser tests against bundle that is made to be executed in browser. With my rollup changes (#209) this should be a breeze.\nYep! I was looking at doing the same thing with stamp-utils yesterday.\n. Sadly, getting Ava to work would be a lot harder than rolling a bundle. Ava uses a bunch of Node features that aren't available in browsers. Exploring all the alternatives and deciding on a strategy will take time, and I want to make browser tests a higher priority so that people can trust stamps not to break their browser apps.\n. > bundle test code that references bundled stampit\nThis doesn't have to be a separate step from #1. Just use the test index as the entry point for the test bundle instead of the stampit index, and Rollup will take care of the rest.\nLast I looked, Test'em was local-only, and did not run on Sauce Labs for CI. Has this changed? I was looking at sauce-tap-runner. There's also Zuul, but it looked like a bunch of work manually hooking up the API.\n. Yeah... if you want to work on the Ava stuff, a lot of work needs to be done in the Ava issue I linked earlier. Until Ava releases a browser-compat version, our tests will stick with Tape. Further browser test discussions should happen in https://github.com/stampit-org/stampit/issues/68\nThanks! =)\n. BTW, feel free to re-open this issue when Ava supports browsers. Ava seems legit, and I've been wishing I could use it in a real project -- sadly... all my current work is universal JS, which means I need working browser tests. );\n. LGTM.\n. > Personally I wouldn't be dropping stamp-specification as dependency. It would make it only harder to maintain if something changes.\ncompose() is moving from stamp-specification to stamp-utils. I agree it's OK to keep it as a dependency -- but stamp-specification is going to stop serving the compose() function.\n. stamp-specification is just the spec, going forward. stamp-utils is a tiny collection of low level tools for working with stamps that other libs (like stampit) should feel free to depend on.\n. > stampit will need to implement spec on its own. Is that the plan?\nI thought it was interesting to have different people working from the spec writing independent stamp implementations just to test the spec and make sure the core team understood it well enough to write compatible implementations, but I don't care whether or not we actually keep a bunch of independent implementations of the spec going forward.\nWe're all busy people. Let's do the simplest thing that works. =)\n. ..rest vs .slice() is bikeshedding and premature optimization at this point. Flip a coin and move on. ;)\n. And by flip a coin, I mean if it ain't broke, don't fix it.\n. Did you intentionally use an arrow function in that example?\n. Why not use stamp-utils as the home for the core utilities like compose() and init(), then have stampit consume those? Extras can go in stampx, which could stand for \"stamp extras\".\nI have already discussed removing the export from the stamp specification. It never should have had an export to begin with.\n. > Daniel is correct saying that user's better not be faced with the choice: \"stampit or stamp-utils?\"\nThis part I disagree with. We have agreed since we decided to create the more functional micro-library functions that stampit is for people who want the convenience of the original chaining API.  I think that's easy to explain. And your suggestion would have the same problem anyway, except they'd be faced with \"stampx or stampit?\" instead.\nI still feel quite strongly that putting the core utilities in stamp-utils and extras in stampx would be a lot less confusing. Consider also that I've already started using stamp-utils for core functions in blog posts and in my book, and if you change the location now, it creates a lot of work for me -- and as far as I can see, creates zero benefit. =)\n. The way I see it:\n- stamp-specification = specification only, NO EXPORTS\n- stamp-utils = core utilities only (compose, init, isStamp, etc...)\n- stampx = eXtra (but still commonly used) utilities.. stuff you might write about in your stamp articles\n- stampit = original stamp chaining API + chain-enhanced utils\nIncidentally, with the exception of stampx and the stamp-specification export, this is how it's currently laid out, so we won't have to do a lot of explaining or change a lot of existing documentation.\n. @FredyC - what you're suggesting would deprecate a lot of existing code in a lot of software not controlled by us. It would also invalidate a lot of existing documentation.\nWhat are the benefits? What would we gain by doing that? I'm all for micro-libraries, but none of the stamp libraries are large enough to warrant breaking them into a bunch of even tinier pieces. This isn't Lodash, or jQuery, or React. All of compose is less than 100 LOC. Many utilities (like init()) are literally one-liners.\nYou're suggesting that we create tens of thousands of hours of work for people so we can split some one-liners into their own modules?\n. EVERY TIME we make a breaking change to our libraries, we create LOTS OF WORK that real people must do (quite a bit for me, personally). The work is multiplied by every use of our libraries.\nYou really need to make a STRONG CASE for that work. Put another way, programmers bill time at $50-$250/hour, and thousands of apps depend on stampit and other stamp APIs.\nImagine each necessary change takes 30 minutes and there are 3,000 changes required. Imagine the average hourly cost is $100/hour. ((30 * 3000)/60) * 100 = $150,000.\nIt's super easy to spend other people's money, but just imagine that you had to pay for the changes. Do you think these proposed changes are worth $150k?\n. So the current plan is:\n- stamp-specification = specification only, NO EXPORTS\n- stamp-utils = core utilities only (compose, init, isStamp, etc...)\n- stampit = original stamp chaining API + chain-enhanced utils\n- @stamp/modules = misc.. microlibrary modules\nFrankly, I don't really see the point of splitting compose() and init() into their own tiny microlibraries. As I mentioned before, compose() is less than 100 lines of actual code, and init() is literally a one-liner with a direct dependency on compose(), but if you guys insist that they be in their own microlibraries, I'm happy to aggregate those in stamp-utils.\n. @FredyC The main things I care about having in stamp-utils are compose() and init(). I honestly don't make much use of, nor do I care much about the rest of the utilities. I'd be fine if you want to split all other utilities into their own repos, though I'm not sure it's worth doing for one-liner is() functions....\n. Mono repo is fine.\n. > Because stampit v2 limits the methods to be only typeof function. Whereas stampit v3 allows anything in the methods, including generators.\nGenerators are not typeof function?\nThat's news to me:\njs\nfunction* foo () {}\ntypeof foo // 'function'\nThat's native code running in Node 6+.\n. Good detective work. =)\nMaybe you should open an issue in Lodash, as well?\n. init() is the correct solution in Stampit 3.0. It's basically the same as stampit().init() from 2.0:\n`` js\nconst Logger = init(({name='', level=1 }) => {\n  //Private\n  const newName = (''+name).toUpperCase();\n  const outputName =${newName} :`;\nconst showLog = level == 1;\n  const showWarn = level <=2 && level >=1;\n  const showError = level <=3 && level >=1;\n//Public\n  const log = (...args) => {\n    if (showLog) {\n      console.log(outputName, ...args);\n    }\n  }\nconst warn = (...args) => {\n    if (showWarn) {\n      console.warn('!', outputName, ...args, '!');\n    }\n  }\nconst error = (...args) => {\n    if (showError) {\n      console.error('!!!', outputName, ...args, '!!!');\n    }\n  }\nreturn {\n    log,\n    warn,\n    error,\n  }\n});\nexport default Logger;\n```\n. I don't think this plugin (or babel-eslint) is still required. eslint has added native support for ES6 modules. I'm successfully linting ES6 + JSX with no plugins:\n```\n  \"env\": {\n    \"browser\": true,\n    \"node\": true,\n    \"es6\": true\n  },\n\"parserOptions\": {\n    \"ecmaVersion\": 6,\n    \"sourceType\": \"module\"\n  },\n. @FredyC Class properties is still in the early proposal stage for a future version of JavaScript. It is not part of the current standard..js\ncids = () => this.prop('cids')\nlet foo = instance.cids\nfoo()\n```\n\nworks as one would hope, with this referring to instance.\n\nI have not read the class property spec, but if it works like object props, the transpiler is probably making a mistake. this can't be bound in real ES6 arrow functions because they don't have a slot for this -- in other words, they always delegate this to lexical scope.\n. Oops. didn't mean to close.. Arrow functions do not bind this -- in fact, they can't bind this because they don't have their own slot for binding this at all. Arrow functions always delegate this to the lexical scope.\nIn other words, if you want to declare a method that uses the instance, you should chose one of these options:\n\nDefine it in an init function (which gets the instance passed in).\nDefine it with a standard function or method syntax (which can access the instance as this).\n\nIf you want to avoid this, you should also completely shun instance state, and instead use closures for state -- which means you should be using initializers to define privileged methods.. @neverfox You can already avoid this -- simply define all your methods as privileged methods inside init functions, and you'll get the instance passed in. You can't do that with methods because by definition in JavaScript, methods use dynamic this binding. There's no way the library could assure that the instance is available without forcing some convention, double-delegating all method calls, and injecting an instance parameter.\nThat would be a breaking change, it would dramatically alter the behavior of all methods, cause a performance hit for every method call, and cause a TON of confusion. In other words, it's not gonna happen.. Some informative reading on the topic of new, prototype delegation, etc...\nWhy newing stuff is probably a bad idea... mixed codebase or no:\n* Factory Functions vs Constructor Functions vs Classes\nClass vs Prototypes vs Composition:\n What is the Difference Between Class and Prototypal Inheritance? - lots of details on problems with class inheritance, composition, different types of inheritance, etc...\n Three Different Kinds of Prototypal Inheritance \nEverything is Composition\nThe essence of software development is composition. You can't get away from composition even if you try. If you do try to get away from composition, you end up composing anyway -- but you'll do it badly.\n\nComposing Software: An Introduction\n\n. @koresar Have you read the rest of the series? There are a bunch of installments now.... I use closures in init functions for data privacy in stamps and functional mixins in general. It is the technique I recommend, and I find it much cleaner than privatize.. Hi @FredyC -- I'm not sure what you're getting at. JavaScript already supplies shortcuts for object composition, which is why we removed extend. Consider this form, coming soon to the JS spec. This already works in babel:\njs\ninit((\n  {passedVar},\n  { instance, stamp }\n) => {\n  const { myPrivateVar } = stamp.compose.configuration;\n  return {\n    ...instance,\n    myMethod() { return myPrivateVar + opts.passedVar }\n  };\n});. We could pass an extend utility fixed to the instance into init functions (which are basically functional mixins....) then you could do:\njs\ninit((\n  {passedVar},\n  { instance, stamp, extend }\n) => {\n  const { myPrivateVar } = stamp.compose.configuration;\n  return extend({\n    myMethod() { return myPrivateVar + opts.passedVar }\n  });\n});\nIt would be trivial to define the fixed extend like this:\n```js\nconst instance = { a: 'a' };\nconst extend = Object.assign.bind(null, instance);\nextend({b: 'b'}); // {a: 'a', b: 'b'}\n``\nDoing so would not be a breaking change.. Stamps really shouldn't be depending on the existence of other stamps. If you have to mix a stamp in to getextendpassed in, you introduce an implicit dependency on that stamp for every stamp that usesextend`.\nI'm really not sure this feature is needed, considering that {...instance, new: stuff}} is already on the standards track. IMO, best practice should be to favor object spread going forward. Which means that stamps should not count on extending an existing object, because other stamps may be returning a completely new object. =). Since ES6 allows us to fix the broken instanceof behavior, I think it's not actually a terrible idea.\nI'm open to discussing this as an addition to the specification. That said, the discussion should be in the specification repo, not here.. > Because Eric Elliott changed his mind on the instanceof topic? :)\nLet's not get crazy. instanceof's default behavior is deeply problematic, and I have not changed my mind about that.\nHowever, making instanceof work by looking up a string-based tag (NOT identity based) could work across execution contexts, could work even if a prototype changes (just declare that the new prototype satisfies some tag's contract), and basically has none of the problems with the original instanceof behavior.\nWhen circumstances change, we're allowed to adapt our stance. In fact, if you don't adapt your stance, you could get knocked over. ;)\nThat said, if it disables hidden class optimizations, that sucks. Which reminds me, engineering tradeoffs and stupidity are often indistinguishable if you're unaware of the tradeoffs. Turning off optimizations globally due to custom instanceof behavior in local objects strikes me as stupidity. Clearly I'm unaware of some tradeoffs in V8. ;). A single instance could belong to any number of stamp type classes. Just space separate them in the string tag. Then you'll get a list of type classes satisfied by the instance. Cool?. In the short term, we could update a generic is util to see if an instance satisfies a stamp contract based on string tag.. An instance is not made of a single stamp. An instance is made of a whole bunch of stamps which may allow that instance to conform to a lot of different interfaces. When looking at instances, we typically want to know \"does this thing support this interface I want to use to manipulate this thing?\"\nThe code in question usually doesn't know about or care about what particular stamp the thing popped out of.\nFor example... do we really need to know if the thing we're looking at is an array, or can we deal with anything that has a working .map(), .concat(), and .reduce()?\nUsually, it's the latter. Anything with a compliant version of those methods will satisfy the following interfaces:\n Functor\n Semigroup\n* Foldable\nLooking at the particular stamp that produced an object should generally be considered an antipattern.\nLooking at the interfaces satisfied by the object is a much more reliable way to program. Remember the Gang of Four advice: \"Program to an interface, not an implementation.\"\nLooking for the name of a particular stamp is equivalent to looking for a particular implementation.\nIn other words, it's not very useful to have instanceof look for === equality for a particular stamp name.\nInstead, we could have the string tag for the above say Functor Semigroup Foldable instead of MyArrayLikeStamp.\nThen our instanceof code could do:\njs\nconst hasInterface = interface => stringTag => stringTag.includes(interface);\n. I disabled instanceof in the design of stamps intentionally because instanceof lies across execution contexts, and when dynamic changes are made. You should not rely on it. Users of your factories and classes should not rely on it. A working instanceof is a liability, not a feature.\nOn that note, ES6 introduced a way to override broken instanceof behavior. It seems that using it disables a bunch of JS optimizations, though. Maybe in the future, that will change. For now, instanceof is a broken feature that should be avoided, not encouraged.\nclass composition using higher-order classes is cool, and if we can work out the problems with constructors and instanceof, maybe someday it will be a viable alternative to stamps. There are also lots of composition edge cases that users of class composition have not thought of that are solved problems in the stamp ecosystem. Here's just one example that stamps are immune to, because they're already factories:\nCurrently, switching from constructors to factories is a breaking change, and there are many reasons you might want to do so, including the need for dynamic abstract factories, object pools, proxies, etc... The change is so common, it's included a refactoring catalog in the book, \"Refactoring\" by Martin Fowler, Kent Beck, John Brant, William Opdyke, and Don Roberts.\nThat refactoring is not safe to do in JavaScript if you allow callers to use instanceof, or the new keyword.\nAs long as those problems exist, stamps should not enable instanceof, or encourage new in any way.. I disagree with the conclusion of this thread, and the logic behind it.\n\nEvery app should be responsible for supplying their own polyfills for functionality because this issue exists in every library. If every library tried to solve it for every app, it would significantly bloat every download bundle with redundant code. It isn't a big difference in this one library, but multiply that logic by thousands of libraries, and it's like one more bad person throwing old plastic containers on the highway -- eventually, the entire landscape is cluttered with superfluous code. Stampit should be a good citizen and refuse to add to the problem.\nYou don't have to \"pass the problem\" along to all your users if you are writing a library. If you like, you can decide to be a bad citizen and do the polyfill in your library -- but I don't recommend that. Instead, why not list known polyfill dependencies? That's a PR worth considering.\nPolyfills can be completely automated in an app with a single line to a polyfill service, with CDN capabilities and automatic browser caching baked in. Taking advantage of browser caching and CDN for polyfills is impossible if every library includes their own polyfill. Just add a couple lines to your docs, add a troubleshooting section documenting what to do if you get Object.assign is not a function errors, and call it a day.. Fine. It's small. Do it.\n\nFYI, mainstream support for IE11 ends on October 13, 2020. After that it goes into \"extended support\" and will only receive patches for critical vulnerabilities.. Fun bit of trivia: An earlier version of Stampit included a ponyfill for Object.assign() and we removed it because the community requested its removal.\nYou just can't win this game. ;). The best solution I know for this problem is a polyfill CDN service. Advantages include:\n\nThe polyfill is custom tailored to the browser making the request. Only the required polyfills are included.\nThe polyfill can be cached in a service worker so it's only ever requested once.\nThe polyfill bundle is automatically browser-cached from a popular, shared CDN & never expires. If the user has already requested the polyfill from another site/app, it doesn't even require a network request.\nIf it's already in the browser cache, it will be cached pre-parsed, so it won't block the application bundle processing in any measurable way.\n\nNo other solution can check all these boxes because other solutions require you to bundle the polyfills with your application code. Just to reiterate: That's a bad idea, and using polyfills/ponyfills in library code is littering.\n. @FredyC That's not how libraries work. Libraries are multipliers. They have a multiplying impact on everything they touch. If you add a line of code, that's a line of code for EVERY APP using your library. You also have to consider that there are other library authors facing the same choices.\nIf you are a library author, it's your responsibility to consider how your decisions scale if all the other library authors are faced with the same choices (because they often are). So let's take a closer look at how this scales in practice.\nImagine the case where every library using ES5+ features (read: most modern JS libraries) decides to use polyfills or ponyfills rather than assume that the feature exists in the app. I'm looking at a small app right now (started a few months ago). There are 695 dependencies in node_modules. Imagine for a moment that 25% decide to implement 20 lines of ponyfill. Now there are 3,500 lines of code that don't need to be there -- in a tiny app where the total LOC for the app source code itself is barely more than 10k lines. We've added 30% to our bundle size because some library authors thought, \"this is only 20 lines, I really should do this here\".\n(695 * .25) * 20 = 3475 WASTED LOC\nNow multiply that impact by the 10,000 apps using your code: You've unleashed 200,000 lines of wasted code on the world.\nNow imagine you're a large enterprise. You're building a flagship product. Your app has over 1 million lines of code. You have 15k dependencies. Your biggest problems are bundle processing and load times. You've worked very hard to carefully split your entire app into 200k bundles for fast loading and chunking. You decide to dig and discover that 25% of your library module authors thought, \"it's only 20 lines, let's just include this harmless ponyfill\":\n(15000 * .25) * 20 = 75,000 WASTED LOC\nYour litter is just one more plastic jug on the side of the highway, but if everybody thinks that way, pretty soon there will be garbage draping the sides of the highway as far as the eye can see.\nThis is what I mean when I talk about being a responsible citizen as a library author.\nImagine that for every star, there are 100 apps using your code. Imagine that our ponyfill is only 10 lines. Stampit has over 2,500 stars:\n(2552 * 100) * 10 = 2,552,000 WASTED LOC\nStarting to get the big picture?\nThis impact is the reason that library CDNs exist. It's the reason why polyfill CDNs exist.\nIf you want to just create a library that works, sure, polyfill the thing and forget about it.\nIf you want to be viewed as a good citizen by enterprise scale companies that really do have to worry about the impact of scale, and if you want to do your part to reduce wasted bandwidth and improve connection speeds for all the users of all the apps using your libraries, these are the facts you need to consider.. @jyboudreau You make a great counterpoint to my argument, but WebRTC is a special case because there are few implementations, and the specs are in flux.\nSomething as well established as Object.assign() is a completely different matter -- the specs are not in flux, and there's a standards-compliant implementation in every modern browser.\nIf you want to polyfill stuff in your library that's already filling in a lot of browser gaps, that's fine, but if every library using Object.assign decided to polyfill it, that would add significant wasted space and bandwidth to virtually every JS app everywhere.\nIn other words, it's important to look at your particular use-case, and we're not letting users do that for themselves if we include a ponyfill for everybody by default.. IMO, this is a bad idea.. Reminder: we're adding ~10 Megabytes of wasted code to the world with this PR, and the correct solution for Stampit users is to use a polyfill CDN.\nIt is not a library's responsibility to supply polyfills for application authors.\nObjection filed. My work here is done. I wash my hands of this.. It sounds like V8 implemented some optimizations that are not available for objects created with Object.assign(). Probably not a bug in v8 -- they just opened up a new fast path.\nA performance degradation would mean that something got slower between v7 and v8. Sounds like the opposite happened?. Oh, I see:\nBefore: Stampit x 90,346,971 ops/sec\nAfter:    Stampit x 19,520,623 ops/sec. Looks like the null prototype is the problem. Try it with {} as the prototype?. Did you test the {__proto__: descriptor.methods} : {}; vs descriptor.methods ? Object.create(descriptor.methods) : {}? Was there any perf difference?. Faster in Node v7, too?. I like the added readability, but the extra function call will slow this operation down.\n. Slower, not even a big readability boost.\n. Nope\n. No\n. No. Prefer the polyfill.\n. No -- adds a bunch of code that clients must download. Calling the native slice is much better.\n. This example can probably be simplified. =)\n. This will slow down compose because it has to jump through all the hoops to initialize a new stamp every time it runs. That's not necessary. .composeWith() could have called .compose() and passed this as the first parameter, right?\n. It looks like you're trying to clarify, but this just sounds more confusing. =)\n. None of these examples produce a stamp. They all produce an object, because they all call .create() at the end.\n. Poorly named. This implies that this function makes a copy of something, when it's really testing whether or not it's a function.\n. Also poorly named, and this is really just a duplicate of the previous function with reversed logic.\nI suggest merging these into one function called isFunction().\nWhat's worse though is that none of these are used in this module at all. They should be defined in the module that uses them, instead.\n. The whole point of this branch is to make stamps immutable, but then you hang public mutable state on an exported object. This doesn't make any sense to me, and feels like a potential source of bugs and confusion.\n. Why do I have to look at 3 different files to figure out the logic you're setting up in 3 lines of code? =)\n. This is all duplicated in mixer.js.\n. Yeah, I mean the shared module exports.\n. This function signature is a boolean trap. Possible solution: named options hash.\n. This is overly complicated. I'd prefer it if you just export all the various types of functions you need. Keep the DOT (Do One Thing) principle in mind when you write modules. DOT and DRY don't have to conflict. Each of the separate modules can share dependencies for code reuse. The point is that we shouldn't expose the complexity of configuring mixer functions to the main stampit module. It should be able to simply require the functions it needs by name.\nFor more on how to keep module interfaces simple, watch the talk Simplicity Matters by Rich Hickey.\n. This makes the previous line redundant, since calls will find everything on the instance and never look at the prototype chain.\n. Couldn't this whole thing be rewritten with no change in instance behavior as:\njs\n  return stampit().state(Constructor.prototype).enclose(Constructor);\n?\n. Why did you change this so it no longer uses .methods() for the initial setup? You realize now, you're not simply testing .methods()? You're also testing the parameter passing, which means you may get a failure during the .methods() test which is actually caused by the parameter functionality...\n. This is also now testing both the parameter form and the .state() form. Why are you introducing these test ambiguities?\n. Why did you delete this test?\n. Note that I replaced .methods() with .state().\nDoes .state() follow the prototype chain or only work for own properties?\n. What is the objective you're trying to accomplish by using a state stamp here?\nWould this still be necessary if we stopped filtering .methods() to prevent state from being stored on the prototype?\nShould we even be doing that?\n. :+1: \n. What's the point of this? Very few Constructor functions have properties attached to them, and even if they did, it would be more appropriate to copy them to the stamp function itself than it would be to copy it as instance state.\n. Isn't it true that this will still override any method copied to stamp.fixed.methods? So this makes line 196 useless?\n. Shouldn't we also support composing with legacy stamps that have fixed.state?\n. This will return false for legacy stamps.\n. Signature is stampit(methods, refs, enclose, props). You have props and refs swapped in the tests.\n. Signature is stampit(methods, refs, enclose, props). You have props and refs swapped in the tests.\n. Mention .props here and remind the user that it will merge?\n. There should still be @param annotations for each of:\noptions.methods, options.refs, options.init, and options.props.\nI wonder if it's possible to define an options type with JSDoc without it assuming that there's an options class?\nThen you could define the type elsewhere and just do @param {options} [options] desc...\n. :+1: \n. Good thinking. Just to clarify, these all result in stamps with no fixed methods, right?\n. Nice!\n. w00t. Shortcuts rock. :+1: \n. You mean \"advanced examples\"?\n. Maybe add a note, \"Similar to Object.assign()\"\n. It has an alias? =)\n. > \"no refs data will be overriden\"\nShould we merge props before adding the refs, and then allow refs to override props? What are the advantages or disadvantages?\n. :+1: \n. Typo? Should be \"merged from props.\"\n. Shouldn't this be under a \"Run the Examples\" header above this first example?\n. Just before ## object.getStamp(). 2 ways.\n. Use ES6?\njs\nvar SelfAware1 = stampit.init(function ({ stamp }) {\n  this.getStamp = () => stamp;\n});\n. How hard is it to run npm install?\n. :+1: \n. :+1: \nInternational standard = American English\n. Can we change this filename to .js? ES6 is the current standard. =)\n. Which example needs this change? I'd like to take a close look at it, because using the proto for non-methods is a strong code smell. Maybe the example can be improved, instead of changing stampit behavior...\nThe original version of Stampit did not filter out non-functions. We trusted that the name .methods() was good enough.\n. Good enough to start. Eventually I want to use the prod-module-boilerplate rules for all our projects. If there's something wrong with those rules, we should fix them.\nI've already invested significant time in fine-tuning those rules. AirBnB's rules are trying to be a standard for the whole world. We don't need a standard for the whole world, we need a standard that enforces our own coding standards. =)\n. We should use .assign() in examples - it'll be familiar to people who know the ES6 Object.assign().\n. This whole example seems... dangerous? Could be a bug magnet.\n. :+1: \n. Consider var deprecated. I can't think of a good reason to use var instead of const or let.\nPrefer const whenever possible.\n. Why did you insert a line break here? All viewers that aren't brain-dead automatically wrap lines based on the window viewport width. Inserting arbitrary line breaks just makes the doc look funny when you view it in plaintext with different window widths...\n. js\nfixed.init = fixed.enclose = [fixed.init, ...extractedInits];\n. Should this be in devDependencies?\n. Use the inline image format: ![Stampit](https://raw.githubusercontent.com/stampit-org/stampit-logo/master/stampit-logo.png):\n\n. No. =)\n. 'b\u201d should be 'b'.\n. Is there a way we could optimize with new? When I wrote the original code, I used Object.create() mostly for illustration. Objects created with new are (unfortunately still) optimized better than objects created with Object.create().\n. @FredyC - Because of V8's hidden classes optimization, using new can be up to 10 times faster for property access (not instantiation) than Object.create().\nOf course we should profile both instantiation and property access. We also need to run the check and loop about a million times to see all the optimizations kick in -- on modern CPUs, that shouldn't take terribly long.\n. Are we still maintaining the Bower version? Bower itself is no longer maintained.. ",
    "Niggler": "I am, after all, a niggler (http://wordsmith.org/words/niggler.html)\n. ",
    "angryobject": "Thanks!\n. ",
    "Pickachu": "On the first comment:\nLet me try to be clearer about my domain here\nI have and relatively old client side model library (https://github.com/indefinido/indemma), that i've made when i was learning about prototypal programming. I'm going to need to use it in another app, so i started a small rewriting and writing tests. I the meantime i saw your talk and really liked the approach that stampt have on the problem. So i'm trying to use it to help on this tasks.\nThe basic idea is that you can configure/require the composable modules to change the behaviour of the factory that is generated by the model factory (making a factory of records, thats made by a factory composed by factories lol). So, say if you require the restful module, now when you create a new factory with the model factory, the records will have the rest capability.\nSo in model will always be a composition, maybe sometimes with some state or methods\nIn one app, it might be:\n``` javascript\nvar resourcable = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar base = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar model = stampit.compose(resourcable, base).state(/ ... /);\nvar person = model(/ options_for_modules: / { resource: 'people' });\nvar arthur = person({name: 'Arthur'});\narthur.resource // people\narthur.save() // Undefined method 'save'\n```\nIn another app:\n``` javascript\nvar restfulable = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar resourcable = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar base = stampit().enclose(/ ... /).state(/ ... /).methods(/ ... /);\nvar model = stampit.compose(base, resourcable, restfulable).state(/ ... /);\nvar person = model(/ options_for_modules: / { resource: 'people', route: '/profiles' });\nvar arthur = person({name: 'Arthur'});\narthur.resource // people\narthur.save() // POST /profiles\n```\nSo in with this new information about the domain, i'm not trying to be prototypal enough? \nIf you have some advice i'd be very grateful.\nOn the second comment:\nthe object is created and extended, inside the stampit library: \n``` javascript\ninstance = mixIn(create(fixed.methods || {}), {extended here})\n```\nthen it gets fully replaced by whatever i return:\njavascript\n   if (typeof fixed.enclose === 'function') {\n        alt = fixed.enclose.call(instance);\n   }\nMy problem is essentially that if i return a function object, it does not get the state and the methods. Because, on the factory definition, i do not have access to the object instantiation/creation, the stampit will always instantiate an object, not a function object, and then extend it and then replace by whatever i return.\nI need to store some information on the model factory function, just as you do on the factories generated by stampit.\nCurrently i'm making two factories just to be able to compose then.\n``` javascript\nproto = stampit().state(/ ... /).methods()\nmodel = stampit.compose(stampit().enclose(function () {\n   return function () {}\n}), proto);\nperson = model({resource: 'people'});\n\u22ee\n```\nIs there any alternative to solving this specifically issue? \nThanks for the fine tailored answers, and for the good and rare presentation about good prototypal practices.\n. First of all, sorry for the late answer.\n\nOne more time:\nIt looks like you're trying to subclass model, which is not what you want.\nvar person = model(/* options_for_modules: */ { resource: 'people', route: '/profiles' });\nDo you see why this looks like a subclass? Compare to these alternatives:\nvar resourcable = stampit().methods({\n    save: function () { return 'saved!';}\n  }).state({resource: 'default'});\n// What is base?\n// In this case base was just a generic example for some generic composable functionality.\nvar base = stampit().state({base: 'base'});\n// Why does model need to know about resourcable\n// and base? Can't it just have the model-specific\n// functionality and let you mix-in resourcable and\n// base as-needed? I'd need to see more use-cases\n// to suggest a better design.\nvar model = stampit.compose(resourcable, base);\n// This multi-layer inheritance is a bit dangerous.\n// It's usually better to be explicit about what\n// pieces you're inheriting.\nvar person = stampit.compose(model).state({\n  resource: 'people',\n  route: '/profiles'\n});\n// A (perhaps better) alternative:\nvar person = stampit.compose(resourcable, base).state({\n  resource: 'people',\n  route: '/profiles'\n});\nvar arthur = person({name: 'Arthur'});\narthur.resource // people\narthur.save() // saved!\nEssentially, any time you see multiple levels of inheritance, you should see this:\n[bear thinking about ridiculous things]\n\nNice, i can see now where are the multiple levels of inheritance. And the absence of need for returning a callable object on the factory library. Thanks for the enlightment, Maharishi. (There is never too much beatles)\nOn my specific case on a common application i'll have a lot of models. I can try to make the inheritance level just one level deep, but it will take a lot of code:\n``` javascript\nperson = stampit.compose(associable, maid, resource, restfulable, scopable).state(resource: 'people', / lots of other factories settings here /);\nanimal = stampit.compose(associable, maid, resource, restfulable, scopable).state(resource: 'animal');\ngroups = stampit.compose(associable, maid, resource, restfulable, scopable).state(resource: 'groups');\n\u22ee // Maybe 10 or more composed factories\n```\nIs this an use case for the bit dangerous multi-level inheritance? (like you show down here). Do you need more info? Or there may be a better solution?\n\nvar resourcable = stampit().methods({\n    save: function () { return 'saved!';}\n  }).state({resource: 'default'});\n// What is base?\nvar base = stampit().state({base: 'base'});\n// This multi-layer inheritance is a bit dangerous.\n// It's usually better to be explicit about what\n// pieces you're inheriting.\nvar person = stampit.compose(model).state({\n  resource: 'people',\n  route: '/profiles'\n});\n\nThen i might do:\njavascript\nmodel = stampit.compose(associable, maid, resource, restfulable, scopable);\nperson = stampit.compose(model).state(resource: 'people' /* lots of other factories settings here */);\nanimal = stampit.compose(model).state(resource: 'animal');\ngroups = stampit.compose(model).state(resource: 'groups');\nBut ideally i would like to write the minimum of code with the maximum of clarity. \nAlso would like not to bother too much the other developers about the internal definitions (the composable factories) about another library more than once.\n\nThere are some complications with returning a custom function from .enclose(). You can't create a function with a custom prototype in JavaScript (at least, not using any technique I am aware of). The corollary here is that you must copy all your methods to the instance, and not use stampit().methods(). Side-effect: You can't keep any prototype state using this technique.\nBecause of those limitations, it doesn't make a lot of sense to make special considerations for supporting it -- I'd have to make decisions which might be right for some use-cases, but wrong for others. If you want to try to roll your own support, yes, in fact, you can return anything you want from stampit().enclose():\n\u22ee\n... but you might want a fish and get a fish and a walrus, and the whole yellow bus (too many Beatles references?). This is hidden multi-level inheritance. Ick.\nPoint is: be careful with this stuff.\n\u22ee\n\nOh, i didn't knew that it was not possible to keep prototype state with this technique.\nAnd if i really see the necessity to go down with the hidden multi-level inheritance, will be really really careful.\n\nKeep it simple.\nWherever possible, keep your inheritance one level deep.\nAnd be explicit about what you're inheriting! That's a major advantage that composition has over classical inheritance. Don't undo it.\n\nI'll try my best to keep it simple, and stay in a flat hierarchy always as possible.\nOnce again, thanks for the advice! And cheers for the small posts. \\o/\n. They have everything in common yep. I'll try to consider them as an implementation details, and post the results here just for the feedback. \nThanks for the help man!\n. Oh yep. My mistake.\nJust fixed the comments for future reference.\nThanks!\n. ",
    "bitmage": "Cool!\n. Hmm... you might consider supporting:\njavascript\nvar oldskool = stampit.convertConstructor(Constructor, arg1, arg2);\nWhich resolves the problem of needing to call 'super' with some args.\n. Ah, yeah good point.  I'm not sure how you'd deal with that.  Currently I'm using a shim:\njavascript\nwrapStream = function(Stream) {\n  var constructor = function() {\n    Stream.call(this, {objectMode: true});\n  };\n  return stampit(Stream.prototype, null, constructor);\n};\nSo, hard coding is sufficient for my use case.  But if I wanted to I could make my shim alter behavior based on the 'this' context.  I don't think this would transfer easily to a sugar method though... you need the closure.  I'm ok taking this approach... it gives me a lot of control over how I'm calling the super-constructor.\n. Oh also, while util.inherits doesn't directly call the super-constructor, it does make it accessible via this.constructor.super_.  So it's up to the child class whether/how they want to call it.\n. So... I discovered another issue with inheriting from the Stream classes.  They explicitly disable calling their constructors on anything but an instanceof 'Class Foo'.\nhttps://github.com/joyent/node/blob/master/lib/_stream_readable.js#L96...L97\nWith this in mind, the only way I was able to get a Stream fully operational after compose was this:\n``` javascript\nvar stampit = require('stampit');\nwrapStream = function(Stream) {\n  var constructor = function() {\n    var base = new Stream({objectMode: true});\n    return stampit.mixIn(base, this);\n  };\n  return stampit().enclose(constructor);\n};\n```\nSeems hackish to be certain.  Thoughts?\n. This doesn't work either.  It wipes out the prototype from methods().  Which makes sense... setting up the prototype is outside of the responsibility of enclose().\nI'm kind of at a loss here.  I think this is getting too complex.\n. RE: Duplex, util.inherits must be modifying whatever property instanceof looks for.  That code wouldn't work if the instanceof check failed.\nAlright, I finally found something that works:\njavascript\nwrapStream = function(Stream) {\n  var constructor = function() {\n    var base = new Stream({objectMode: true});\n    return stampit.mixIn(this, base);\n  };\n  return stampit(Stream.prototype, null, constructor);\n};\nThis approach almost works:\njavascript\nwrapStream = require(function(Stream) {\n  var base = new Stream({objectMode: true});\n  return stampit(Stream.prototype, base);\n});\nBut you're JSON serializing/deserializing the state, so it wipes out the 'onwrite' function inside _writableState.\n. And RE: your findings in Stream docs... yeah, I laughed when I read that.  Not to trivialize the problem... clearly we're jumping through hoops here to make things work.  But a highly composable type system can eliminate some major design headaches.\n. Also, John Resig to the rescue!  It looks like this is how you'd climb up the prototype chain:\nhttp://ejohn.org/blog/objectgetprototypeof/\nMight come in handy for other functionality down the road.\n. I just tried convertConstructor.  It works like this:\njavascript\nCollector = stampit.compose(stampit.convertConstructor(Readable), Collector);\nBut not like this:\njavascript\nCollector = stampit.compose(Collector, stampit.convertConstructor(Readable));\nIt looks like when I compose it, it mashes my enclose() in Collector where I am setting the _read property.\n. Yeah, that's what I'm running.  Sorry for all the attention btw... Didn't mean to disrupt whatever you were doing.  :-)\nYeah, I'm also distracted with some stuff.  Let's come back to it.\n. Yeah, roger that.  I read your comment on the other thread.  I'm setting that up now.\n. Does this test example help?\nRunning the tests I get 17/17 pass, but some environments don't seem to be running, due to \"failed uploading some assets\".\nhttps://gist.github.com/bitmage/6110477\nIt takes a long time (5-10 minutes) to run the tests.  Not sure if that's normal.  The actual code executes in a few milliseconds.\n. Interesting... so it's still maintaining a single instance of whatever merged prototype you end up with.  I.E. creating many instances of the composed object won't duplicate the prototype.\nSeems to work fine for me.\n. ",
    "RainerAtSpirit": "Got some oldskool code to convert that looks like \n``` javascript\nvar ctor = function( ctx, entityName, options ) {\n        ... // Can be handled with stampit.state();\n        this.init(ctx, entityName, options);\n    };\nctor.prototype.init = function(ctx, entityName, options){\n    this._ctx  = ctx; \n    ...\n}\n```\nWhat I'm struggling with is what would be the  recommend way deal with constructor params that get's passed on to ctor.prototype.init \n. Thanks. I'd like to have the option of real private vars, but at the moment that comes with a price. Instead of arguments you'd need to pass in one  object. Guess my question is is there a way to use the current arguments style and still get the benefits of .enclose.\n. Fair enough. I'll give the new school method a try in an upcoming project. \n. Still trying to get my heads around using the stampit factory/mixin approach. Let's take a typical Backbone.model extend like e.g. \njavascript\nvar Base= sp.Item.extend({\n    'site': 'sites/teamsite',\n    'list': 'Tasks'\n}),\nCustomItem = Base.extend({\n'params': {\n    expand: 'Status'\n},\ntask = new CustomItem ({ Title: 'MyTask', ... });\nI've created a small straw man sp.item stamp and use it like below. \n``` javascript\nvar base = sp.stampit().state({\n    site: 'sites/teamsite', \n    list: 'Tasks'\n}),\ncustom = sp.stampit().state({\n    params: {\n        expand: 'Status'\n    }\n}),\ntask = sp.stampit.compose(sp.item, base, custom);\ntask.create({ Title: 'MyTask'...});\n```\nI think this last step gives me some trouble. What I would like to accomplish is that everything that's passed into create  is accessible as one properties object. Instead all key/val pairs become instance properties.\nOne way to address this would be to tell end user to use .create({properties: {Title 'MyTask', ...}}) ... but that's hardly going to work. Another option would be to not passing in anything into create and have a dedicated properties getter/setter instead. Third option would be that I get access to the properties object during create. Not sure though  if that's a good use case or not... \n. Sugar, yeah probably.\nMaybe I'm mistaken , but it seems that only .create({properties: {Title: 'MyTask', ...}}) would provide access to ONE  properties property within .enclose. Pretty easy to deal with it that way in .enclose.\nIf using .create({Title: 'MyTask', ...}) instead .enclose would provide access to the Title  property in addition to an unknown number of other key/value pairs that have been passed in. Not that easy to deal with it as now you've to dissect passed in props from .state mixins.\n. Specifying specific behavior for one, multiple or all props would be benefical... at least for my use case. \n. I might have some time later this week to give it a shot. In the meantime can you take a look at the current status of the saucelabs tests. I'm not a saucelabs pro, but got most of the tests running/passing in Ubuntu and Windows 7. On both platforms Linux/Android failed and 2008/Firefox gave an error though.\nWould be great to have a all green situation before I start.\n. @ericelliott : You asked for it :). +1 for combine stamps\n. ",
    "asaf": "Good enough, closing.\n. ",
    "koresar": "I have almost created the same question. Good answer. Thanks.\n. Eric, as far as I understand all the people want is to make state(s) private when instantiating an object. Similar to classic constructors. Issues number 18, 15, 11, 10.\nI would like to propose following 5 lines of changes: http://screencloud.net/v/q0QE (untested)\nAs the result we retain compatibility with the already existing API. Also following syntax would be possible:\n``` JS\nvar factory = stampit.enclose(function (fooParam, barParam) {\n  var fooParam = fooParam, bar = barParam;\n});\nvar newObjectWithPrivateState = factory.construct('foo', 'bar');\n```\nI saw all your talks, read your book (thanks!), and I bet you likely to reject my idea. Anyways, what do you think?\n. Done.\n@jtenner Thank you, looks nice. However, I am fine with stampit for now.\n. I just noticed that with the proposed changes the convertConstructor can now accept parameters. No additional changes required (a unit test would be good though).\n``` JS\n  // The old constructor / class thing...\n  var Constructor = function Constructor(vehicle) {\n    var bumblebee = vehicle;\n    this.getBumblebee = function getBumblebee() { return bumblebee; };\n  };\n  Constructor.prototype.foo = function foo() { return 'foo'; };\n// The conversion\n  var oldskool = stampit.convertConstructor(Constructor);\n// A new stamp to compose with...\n  var newskool = stampit().methods({ bar: function bar() { return 'bar'; } });\n// Now you can compose those old constructors just like you could\n  // with any other factory...\n  var myThing = stampit.compose(oldskool, newskool);\nvar t = myThing.construct('chevrolet camaro');\n  t.getBumblebee(); // returns 'chevrolet camaro'\n```\n. This is simply perfect. However your code has a side effect. Sample:\n``` JS\nvar stamp = stampit.enclose(function (_options, connectionString, callback) {\n  ver options = _options; // keep it SECRET!\n  // whatever\n});\n// We assume this passes the parameters to the closure above. And it does.\nvar obj = stamp.create(\n  { keepAlive: true, userName: \"decepticon\", password: \"secret\" },\n  \"mongo://bla\",\n  aFunction\n);\n// But here goes the side effect\nobj.keepAlive <- exists\nobj.userName <- exists!\nobj.password <- EXISTS!!!\n```\nSee my point?\nSo if you want to keep .create(arguments) function you have to remove properties argument from it and  bump the library version to 1.0 if you wish to keep semver compatibility.\n. I vote for 1 too.\n. @dilvie , I know you are busy with your JS classes, but could you please express an opinion on the messages in this thread?\n. I disagree to minor points stated, but I do agree to the general thoughts and ideas of you both guys.\nSo far the only way I see is to extend API. Like so:\n``` JS\nvar stamp = stampit.ctor(function constructor(mustBeHiddenReadOnly) {\n  var secret = mustBeHiddenReadOnly;\n  this.authorize = function () { / uses secret / };\n});\nvar obj = stamp.construct('password');\n// Somewhere else\nobj.authorize();\n```\nWe should not allow more than one ctor per stamp.\nAlthough, the ctor() is not the perfect name. All I wanted to emphasize is that the only way (I see) to satisfy the need of multiple developers is to change the API.\n. I see what you mean. Ok, option 2. I'm buying.\nBTW. Do you know that according to SemVer you should increase second number with these changes? So the next version should be 0.7.0.\n. Would you mind releasing 0.7.0 to npmjs for even more extensive tests?\nOr the next planned npm version is 1.0.0 and you are waiting for some feedback?\n. You made me LOL :)\n. @ericelliott \nShould I just supply a PR?\n. Roger that.\n. Please, review and apply.\nCheers\n. Yes, I am kind of new here. I thought the issue would be converted to PR when I attach changes to it.\n. Hi Eric,\nRe the PascalCase. I am forced to reply. :)\nIn our project we tend to avoid classic constructors and use stamps only. We do not like the idea of putting word 'Stamp' at the end of each stamp variable. Consider:\nJS\nrestAuthServiceStamp.create();\nRestAuthService.create();\nIt is not only about being shorter, but also about consistency. Everything which creates objects should be PascalCased. The team agreed internally and liked it. So far so good. \n. Re commit access.\nThat's a great honor to participate in maintaining the stampit\nI am an experienced dev and used to maintain few OSS projects, although there is possibility I might screw things up because my JS experience is rather short (~1 year). I wouldn't trust myself. :)\n. Ok. I am in.\nExpect for PR in 24 hours.\n. Awesome news! Thank you.\n. This issue is rather old. I haven't seen users complaining about it too much.\nShould be reopened if any.\n. @ericelliott \nI just though it might not be a good idea to change 'this' stamp when doing\nstamp.composeWith(...);\nbut rather return a new stamp. What's your thoughts?\n. Hi @ericelliott \nI have few more improvements in my mind (in repository actually) which requires this PR reviewed and merged. Would you mind spending few minutes on it?\nP.S. The new ideas I have:\n1) Improve the file size a little bit.\n2) Provide context help for IDE's editors (like stampit... and stampit()... drop downs menus).\n. Ok. Swapping will be done shortly.\nAre you okay with the fact that composeWith() changes this instead of creating new stamp? I think composeWith() should create new stamp just because state(), methods() and enclose() are consistenly creating new stamps.\nYour opinion?\n. btw, since there is not 'composeAfter' maybe we should rename 'composeWith' to just 'compose'?\n. No worries. Will do.\n. I'll do my best to optimize stuff around these functions. I'd need your eye on that tomorrow probably.\n. Not really. Job is taking all my time and enthusiasm. :)\nBut please don't worry. I remember.\n. I am closing this pull request because the new one #32 is not based on this code. This PR was superseded so to say.\n. Any additional details?\nWhat kind of embedding? Browserify, AMD, else...?\nhttp://jsfiddle.net/ sample would be good to see in order to reproduce on other machines.\n. I tried in both latest Firefox and same Chrome. The CPU usage is minimal.\nDo you have any plugins/extensions installed in Chrome? Try disabling them for a while and test the CPU load again.\nCheers\n. @anhhh11 cheers, mate! Good to know you have found the cause.\nThank you for closing this issue.\n. Ok. No worries. Review is not that necessary.\nI'm opening a pull request.\nCheers\n. I have submitted the PR.\nhttps://github.com/borisyankov/DefinitelyTyped/pull/2839\n. Any IDE with TypeScript support should work. Here is the list: http://definitelytyped.org/directory/tools.html\n. The PR got merged. Testing integrity with (my) IDE now.\n. In WebStorm:\nThe stampit.func functions context help work. The returning objects are recognized as stamps. Whereas stampit() returned object is not recognized as stamp.\nI'll try Atom.io the next.\n. Stamps are stamps. :)\nI mean the context help for the stamps created by stampit() does not work. Whereas context help for the stamps created with stampit.combine() work fine.\n. Closing. This is partially solvable with DefinitelyTyped project and IDE support.\n. This issue is rather old. I'll close it for now. Please, yield at me if you need this opened back.\n. I also checked the new file with the same validator and it shows me warnings on h2 tags. Am I doing something wrong?\n. Well, as it passes the validation I believe there is no harm from this change.\n. Omg, the opening tag was link and the closing one was style. Big thanks!\n. @ericelliott you are wrong. If it does deep cloning then the following code should print '1 2'. But it prints '2 2'.\n``` js\nvar stamp = require('stampit')();\nvar state = { a: { b : null } };\nstate.a.b = 1;\nvar obj1 = stamp.create(state);\nstate.a.b = 2;\nvar obj2 = stamp.create(state);\nconsole.log(obj1.a.b, obj2.a.b); // 2 2\n```\nMoreover, that your statement contradicts with my code above.\nI first though that it is the issue of the mout/object/merge function. But actually it is not. See yourself.\n``` js\nvar merge = require('mout/object/merge');\nvar state = { a: { b: null } };\nstate.a.b = 1;\nvar obj1 = merge({}, state);\nstate.a.b = 2;\nvar obj2 = merge({}, state);\nconsole.log(obj1.a.b, obj2.a.b); // 1 2\n```\nLet me investigate further.\n. I found the cause of the unexpected behavior.\nThe state is deep cloned using merge function only when it is part of stamp (i.e. fixed.state).\nThe state is shallow copied using mixIn function when it is passed to the stamp function as an instantiation parameter (i.e. stamp(myState) or stamp.create(myState)).\nI propose to make them both deeply cloned. People expect it deeply cloned both times.\n. Let's discuss the best approach in the chat https://gitter.im/ericelliott/stampit\n. One more nasty bug with the state merging.\n``` js\nvar stamp = require('stampit')();\nvar stateOriginal = { a: { b : 'original', Y: 'original' } };\nvar stateOverride = { a: { b : 'override', X: 'override' } };\nvar obj1 = stamp.state(stateOriginal).create();\nvar obj2 = stamp.state(stateOverride).create();\nconsole.log(obj1.a); // { b: 'original', Y: 'original' } - OK\nconsole.log(obj2.a); // { b: 'override', X: 'override' } - UNEXPECTED\n// The expected value : { b: 'override', Y: 'original', X: 'override' }\n```\nThe bug is in this line. Again, we are using mixIn instead of merge for state(s).\n. Crap! Similar bug is in the stampit.compose() function. Same misuse of the mixIn. I reckon this is a copy&paste bug. I'll fix'em all.\n. Will be fixed with #43 in version 2.0. See branch v2_0.\n. What do you mean by \"convenience methods\"? A code sample would be nice.\n. I think this is not worth the change. Two characters () is not something what bothers people. :)\nLet me push a PR. I'll explain few my concerns there.\n. Then let's add them. :)\n\n. It can go to both 1.x and 2.x. What do you reckon?\n. As I mentioned, @ericelliott, I would implement every other feature in the world as soon as we merge the 'immutability' PR to the v2_0 branch. Otherwise, it will be just too many merge conflicts. Would you mind approving #48?\n. Implemented with #84.\n. Tests pass if I use mixIn instead of mixInChain. :)\n. I'll submit a PR to v2_0 branch.\n. I was wrong. mixInChain is the same as mixIn but it copies also properties from parent prototype chain. Hence is the name of the function.\nHowever, there are no comments explaining that. Reading code becomes time expensive (I'll fix that).\nAlso the only unit test for this function is named stampit.compose() with inheritance, whereas mixInChain used for methods only. I'll give it a better name, like 'methods must mix in prototype chain'.\n. The mixInChain copies not only methods but also properties. As the result a bit of confusion takes place. The stampit(methods) and stamp.methods(methods) shallow copy state (if present) of the given object. This is no good because our stamps should be immutable.\n@ericelliott is it by design?\n. Two ways to solve this:\n1. Mix in functions only.\n2. Merge in everything (assumes deep cloning).\n. So, option 2. Right? Deep clone state of the methods argument?\n. Object counter better implementation:\njs\nvar accountableStamp = (function() {\n  var number = 0; // Shared class variable.\n  return stampit().enclose(function(){ \n    number++;\n    this.getObjectCount = function () { return number; };\n  })\n})();\nCombine this with your stamp. Now you know the number of objects created. :) Same way you can collect all references.\n. Chain mixing the methods argument is a bad idea. And here is why.\n1. The mixInChain uses mout/object/forIn. All properties except the list of ES5 predefined 7 (like toString, hasOwnProperty, etc) are being copied over to the stamp.\n   1.1. If someone would extend Object then we'll be copying these extra function all the time for each stamp and new object.\n   1.1. ES6/ES7 might introduce new Object.prototype methods. These might be copied to each stamp too and we don't want the overhead.\n2. I have never used anything else besides the flat JS objects as methods parameter. I doubt other people pass there complex objects.\n3. The hidden behaviour of methods() function manipulates the state of each object created from the stamp.\n   3.1. The function named methods() should not add any state. Confuses a lot.\n   3.2. Objects created from a stamp should not share state. Otherwise people might change all the objects unintentionally by changing single value.\n   3.3. If someone would like to share state between some objects he must do that explicitly (see workaround code above).\nI recommend we copy only own functions of the methods argument. Thus we will:\n1. avoid all the potential problems described above;\n2. make stamps immutable.\n. Then mixInChain should be used for convertConstructor only. The methods() should be for methods only.\n. Yes. See above.\n. Correct. Will do. Thank you.\n. Done with #48.\n. Re combine/compose.\n\"Favor object composition over class inheritance.\" The GoF reference objects, not classes/stamp/factories. IMO we should compose objects, but combine stamps.\nI insist on voting among stampit community. :)\n. Re the immutability. Let me create a PR for the v2_0 branch.\n. ### Guys, there is the poll for combine/compose.\nI encourage you (and other stampit users you know) to vote.\nhttp://goo.gl/forms/O3yL2OYQsy\n. I didn't add combine alias with any of the existing PR's as I was waiting for the poll results. The alias(-es) should be added with a separate PR I reckon.\n. See #48. I am waiting you to review the mixInChain to v2_0 merge. master branch will stay untouched if you accept the #48.\n. For future references.\nRe the Compose/Combine dilemma. It was decided to leave the naming as is. No new aliases, no changes.\n. Immutability is done in branch v2_0.\n. Here are the changes. Please, take a look at the three new unit tests.\nhttps://github.com/ericelliott/stampit/compare/v2_0...instanceof\nAll the tests pass.\n. I see.\nAny recommendations on how to ducktype objects made by particular stamp?\n. Looking at the amount of code flow-runtime has and at the the code example it's probably implemented somehow different to just instanceof proposed above.. The approach Eric does not recommend looks like this:\n``` js\nvar stamp = stampit().enclose(function (arg1, arg2) {\n  var privateArg1 = arg1;\n  var privateArg2 = arg2;\n  // your code\n});\nvar obj = stamp(yourPublicState, yourPrivateArg1, yourPrivateArg2);\n```\nI would not recommend this either unless you are confident there will be no conflicts across multiple enclosures.\n. Cool! We are adding combine alias to the compose function.\nstampit.compose()   4   27%\nstampit.combine()   11  73%\n\n. Right. :)\nBTW, I used to compose music: http://promodj.com/ks\nSo, I am a composer. I compose the final product/result. This means that stamp.create should have been named stamp.compose from the very beginning.\nSometimes people combine music styles. A combined music style receives a new name occasionally. For example electro and house music styles resulted in electro house.\n. @jrf0110 good point. In this case the function should change this instead of creating and returning new stamp. Whereas current implementation returns new stamp on .compose() calls.\n. @zebulonj The stampit(m, s, e).compose(stamp2) call does not mutate state of the first stamp already. It's done.\nAll I wanted to say is that occasionally people would like to mutate the stamp. I already met two devs who did that on purpose.\n. Latest poll results.\nstampit.compose()   5   28%\nstampit.combine()   13  72%\n. Current state of poll.\nstampit.compose()   7   32%\nstampit.combine()   15  68%\nIt's time to end the poll I reckon.\n. Probably .join()?\n. See gitter.\ntijhaart January 16 2015\n\nWhat about stampit.join?\nvar stampD = stampit.join(stampA, stampB, stampC);\nThree letters less to write in comparison with compose. :laughing:\n. @foxaal suggested to take a look at Wikipedia.\n\nQuoting Class-based_programming\n\nIn this model, objects are entities that combine state (i.e., data), behavior (i.e., procedures, or methods) and identity (unique existence among all other objects).\n\nAnd quoting Class_(computer_programming)\n\nClasses can be composed of other classes, thereby establishing a compositional relationship between the enclosing class and its embedded classes.\n\nClearly, it is wrong to rename or give any aliases to the existing compose() method.\nHowever, people tend to like combine more.\nI'm confused. :)\n. Eric, as long as we are trying to avoid classic OOP (see #44 you declined) let's also avoid classic OOP terminology.\nThe factory of factories is Eric's invention (or not, doesn't matter). The 'stamp' concept is something very new and very unique. Maybe we shouldn't reuse the classic terminology at all? Maybe we should invent our own terminology in order to emphasize that stamps are not alike classes?\nSo, my new proposal is to avoid both compose and combine, but use somehting like join instead. \nOtherwise we might end up just like DB guys ended up with ACID and CAP. Where C is consistency but of the different kinds.\n. I agree that both join and use sound far from the best.\n. In many existing JS modules use is used to mutate the object. For example express.js. Whereas we agreed that stamps must be immutable.\n. It's time to end the debate. Let's leave the function naming as is. I.e. the only compose function should stay. No aliases.\nAgree?\n. Ok. Closing this issue.\nPersonal thanks to @foxaal , @zebulonj , @jrf0110 for the useful input. Cheers guys!\n. Wow! This is cool stuff indeed.\nHowever, that's too much for my small head today. Let's do the following:\n1) Merge this PR to v2_0 for now.\n2) I implement immutability.\n3) Then I take a look at the todotasks and think of replacing grunt with it, etc.\nPlease. :)\n. To simplify the review I will list changes:\n1. The stamp.fixed is not sharing anything with other stamps anymore. Plus unit tests for that.\n2. The merge and mixin functions of mout module as well as mixinchain.js function were replaced with enhanced (mostly copy&pasted) versions. Now we can control what's being copied/merged, and should it traverse prototype chain.\n3. The Object.create is reused (if present). Otherwise use the polyfil.\n4. The methods are now being copied from the given object own properties but not its prototype chain. Plus unit tests for that.\n5. convertContructor behaves exactly the same as in stampit 1.x regardless the changes inside the function. Plus unit tests for that.\n6. Unit tests were grouped (poorly).\nI am ready to do any changes you wish.\n. Ok, @ericelliott, check it out.\n. Implemented stamp immutability. Additionally I removed the triple copy&paste. The stamp.fixed modification code was in the: stamp(), compose() and methods()/state()/enclose() functions. Not any more.\n. @ericelliott I believe it's time to move on. Would you like to review the code?\nNB: the PR destination branch is 'v2_0' not the `master'.\n. @ericelliott I have just pushed changes which address most of your concerns.\nImproving tests DOT now.\n. Please see few more commits. Improved DOT and DRY of stampit.js file.\nCreated two more tests to improve DOT as suggested. They cover the bug #40.\n. I'll check it.\nOn Sun, Mar 8, 2015, 06:55 Eric Elliott notifications@github.com wrote:\n\nI think the Sauce Connect config is broken, but you can test manually\nusing Sauce Labs.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/pull/48#issuecomment-77706868.\n. iPhone passes fine.\n\nAndroid also fine. The last test is added by test driver. Not stampit related.\nIE8 issue \"Object doesn't support property or method\" can't fix myself. The Object.create shim is used but tests still fail. Digging in.\n. Ok, all fixed. The 'bind' function does not exist in IE8. That was my first ever IE8 development experience.\nI would need to join \"IE8 haters\" community now. Who's in charge?\n. Firstly, I believe all the new features should be introduced after we finalize the 2.0 branch (merge existing PR's, implement #41).\nThe proposed feature looks useful, although a rare developer would need it. Instead of implementing every feature in the world we could leave extensibility points. For example the three new upcoming functions addMethods, addState, and addEnclose are the very good candidate to be the first point. See possible code sample:\njs\nvar oldAddState = stampit._addState;\nstampit._addState = function (fixed, states) {\n  console.log(_.difference(fixed.state, _.merge.apply(null, [].concat(states))));\n  return oldAddState(fixed, states);\n};\nI haven't thought about the extensibility of stampit much. There got to be better ways to do it.\n. Would you please provide a code sample on how you see the\n\neasily tell you which stamps are likely to play nice with each other \n\n?\n. What's stamp is applied?\n. So, coming back to this issue. It looks alike the #67 \nStill, I need high level code samples (not the implementation details). How a stampit user would like to use this feature?\n. Implemented with #63 and #60.\n. ### instanceOf or obj.is(Stamp) method\n@jrf0110 I had a similar proposal. See #44. I know your pain. :)\nAlthough, I'd agree with @ericelliott that this only makes things worse when we try to mimic classical inheritance. See this funny tweet.\nIf you really need your object to be recognizable then the best way would be to use ES6 Symbols. Stampit does not support it (yet?).\nThe other way around would be to create one more function in either your stamp\njs\nmyStamp.hasCreated = function (obj) { /* ducktype it yourself */ };\nor add a method to your objects' prototype:\njs\nvar myStamp = myStamp.methods({\n  createdBy: function (stamp) { return stamp === myStamp; }\n});\nHowever, in last 18 months I haven't found myself needing anything of the above. Ducktyping was always more than enough.\nChanging stampit core\nI believe that we should move rarely needed functions out of stampit main file, but put them to a subfolder. For example stampit.isStamp and the proposed stampit.is(). And use them like so:\njs\nvar isStamp = require('stampit/is-stamp');\nor\njs\nrequire('stampit/has-created')(stampit);\nmyStamp.hasCreated(someObj);\n. @sheriffderek There will never be a standard way to identify an object origin. \nFirst of all, we think that's a bad thing. \nSecond, you can implement that yourself as a 3 lines composable behaviour (aka stamp). See here for inspiration - https://github.com/stampit-org/stampit/blob/master/docs/advanced_examples.md#attach-function-to-prototype-memory-efficient. That is by design. The state does not copy any .prototype properties from the given variable a. Moreover, it performs cloning of the variable a, i.e. not referencing.\n. @ericelliott Here is the third person who needs composing by reference.\nWe have to add it to v2.0 I reckon.\n. We might inbuild this feature into v2.x as it is very popular request. See #55 \nClosing this one as @jomido has found the proper solution. Well done, mate!\n. First of all, it is always interesting to understand why you need this?\nSecond, you what something similar to instaceof. Correct?\n. It is rather cheap to add one more reference per each stamp (aka prototype). I'd add this feature if I was the boss. :)\nI believe I will start my own fork of stampit. Not because of this feature, but because we do not iterate fast enough. Several months is too much to apply a PR to a non-master branch. @ericelliott, I beg your pardon. But I would like step out as a co-maintainer of this module.\n. I, actually, like the idea of having that function. There is little memory penalty, but, as Eric says, \"this is not your bottleneck\". :)\n. We are definitely not adding the 'stamp' property to each created object. That's an unexpected explicit behaviour which might and would lead to hidden bugs. \n. Nothing inbuilt, but there are many ways to implement it yourself for any particular stamp. \n. Maybe we should add an ES6 Symbol('stamp') to the prototype. Consider the following unit test:\n``` js\nlet myStamp = stampit();\nlet myObject = myStamp({ stamp: \"this is a regular property\" });\nlet stampSymbol = Object.getOwnPropertySymbols(myObject.prototype)[0];\nassert(myObject[stampSymbol] === myStamp);\n```\nAfter that, we can implement stampit.getStampOf(myObject). Something like this (I hope I got the syntax right).\njs\nstampit.getStampOf = (obj) => {\n  let symbols = Object.getOwnPropertySymbols(obj.prototype);\n  if (symbols.length === 1 && symbols[0] == \"stamp\") {\n    return obj[symbols[0]];\n  }\n};\n. True. I have just thrown an idea.\nOther than symbol we could use a \"very very hidden property\" so to say. :)\n``` js\nvar myStamp = stampit();\nvar myObject = myStamp();\nvar stamp = myObject.prototype.stamp;\nassert(stamp === myStamp);\n```\nAnd then:\njs\nstampit.getStampOf = function (obj) {\n  var = obj.prototype.__stamp__;\n  if (stampit.isStamp(stamp)) {\n    return stamp;\n  }\n};\n. update: heavily changed the comment above.\n. Let me workaround this. How about new utility method for each stamp?\njs\nstamp.hasCreated = function (obj) {\n  return obj.__proto__ === this.fixed.methods;\n};\nThis should work as we are using the fixed.methods property as a prototype for objects. Eric?\n. Maybe we should make stamps \"plugin-able\". We can allow people to hook into the function factory().\n``` js\nvar clonableStamp = stampit();\nclonableStamp.on(\"ctreated\", function (obj, stamp) {\n  obj.clone = function () { return stamp(obj); }\n});\n// and usage\nvar myShinyStamp = stampit({ whatever: 42 });\nvar myShinyClonableStamp = myShinyStamp.compose(clonableStamp); // merges 'on()' events\nvar myShinyObject = myShinyClonableStamp();\nvar IAmClone = myShinyObject.clone(); // we have clone() method in each object!\nassert(IAmClone.whatever === 42);\n``\n. @zaboco You can workaround current stampit limitations by hacking thestamp.fixed` object.\n``` js\nfunction makeClonable(stamp) {\n  stamp.fixed.methods.clone = function () { return stamp(this); };\n}\n// and usage\nvar SomeStamp = makeCloneable(stampit({ /state/ }, { /methods/ }));\n```\n. Yes. We got both stamp and the created object in the same function scope.\nThe function factory() is closed from an outside intrusion, but it is the only place where we have access to both stamp and object.\n. Eric, I was thinking of this solution but was afraid to break backwards compatibility. Although, the enclose() arguments is a rather new feature. There should be few people using it.\ninit() would be the good name for the new alias.\nthis and instance should be both available IMO.\n. Ok, let's implement the Eric's design in v2_0.\n. I've created #62 to address this. Eric, feel free to edit #62. Whatever name the enclose-init would have I agree to any one.\nIMO, init is a good name because this is actually what it's for - initialization of an instance. But, again. I'm happy with any name.\n. @zaboco I will close this issue as we are going to implement #62. Please, feel free to open a new one if necessary.\n. What's \"local tests\"? I run the tests locally by opening a html page. Do you mean something like npm test which would run mocha or something?\n. :+1: \n. I've split out issue #61. Let this one be travis only .\n. @ericelliott please connect stampit to Travis-CI.\nIt will run on every push for every branch.\nThanks!\n. It works!\n. You reckon we should add fourth parameter to the 'stampit' function to accept deep cloned \"props\" object? @ericelliott \n. @ericelliott Should I add the \"refs\" to the prototype, or to the object itself (as it is now)?\nI'm asking that because \"props\" are definitely are going to be merged to the object itself. But they might conflict with \"refs\". (I hope I'm clear here.)\n. On the other hand, adding \"state\" values to prototype might break someone's code.\n. Yeah, definitely the \"state\" (aka \"refs\") should go to each stamp. Discussion is over. :))))))\n. One more thing I am hesitating about. The stamp(obj) should deep merge the obj or shallow mix in the properties?\n. JFYI: It's shallow mixed-in in stampit@1.1.\npoke @ericelliott \n. All the good reasons. Thanks, guys.\nI'd need to update PR #60 then. I'll ping you when it's ready for review.\nCheers.\n. #60 was implemented and merged to v2_0 branch. Closing this issue.\n. :+1: Thank you!\nI did the same for v2_0 branch. Didn't push yet.\n. How is that possible that the PR is not mergeable? Which branch you coded it against @sethlivingston ?\n. It takes me 1 minute to reimplement the PR, but 30 minutes to merge yours. :) \n. Also a weird Github bug. The 3 commits from February got to this PR somehow...\n. The size of stampit.min.js using mout in 6928 bytes atm. If lodash is used the size increases to 23000 bytes. @sethlivingston what's your opinion on that?\n. You are correct.\nI doubt there are many people who are referencing \"stampit.min.js\" directly anyways.\nI'll close the PR and reimplement in \"v2_0\".\nThanks for the help!\nCheers.\n. 1. Branch 2_0 is rather different already. There are lodash 11 functions being used. (BTW, you implemented the PR against 'master' but submitted the it for v2_0.)\n2. This is a good idea. Would you create an issue on that please?\n. Done with https://github.com/ericelliott/stampit/commit/346be0e13394540131f06db21dad9baa1dbb6b0d\n. JFYI.\nstampit.min.js size in v2_0 is currently 32879 bytes. Whereas, stampit@1.1 same file size is 7000 bytes.\nBut that's maybe irrelevant.\n. Your 'lodash' will be reused if stampit targets the same version as you (^3.8.0). That's how NPM works.\n. The proposed feature is rather complicated to build. There is human resource shortage at the moment. The cake is not worth the effort IMO.\nHowever, as always, PR's are very welcome!\nClosing this issue as won't fix. I hope that's okay with you @sethlivingston.\n. I've just addressed the stampit@1.1 compatibility. See the PR please.\n. Fixed the mentioned issues. Thanks Eric.\nI'm merging this in. It's time. :)\n. Implemented with #63 by @JosephClay. Thank you mate,\nClosing this issue.\n. We are loosing convertConstructor parameters support because of this feature. This means that we are going back to the old days when stampit supported only parameterless constructors. We can always reimplement that feature in the future releases on stampit 2.0.\n@ericelliott JFYI ^^\n. Or, actually we are not. Disregard the message above. All good now. :)\n. Implemented for v2.0 with #72.\n. Hey, thank you mate!\nI wish you could start from #56 so that these changes could be already tested by Travis.\nWe are going to have multiple merge conflicts as I have changed the tests significantly here: #60 \nAlso, I migrated to lodash the entire codebase in the same PR (but forgot to change package.json). I should have fixed and merged my branch earlier so that you could migrate to tape the latest code base. Sorry for that.\nThere are not many changes in this PR, though. Thus, I'll merge it after #60 if that's okay.\nHow do you feel of implementing #56 (add the .travis.yml)?\n. :) I hope nothing bad will happen after adding a single file.\n. Let me check all the things on Sunday (American Saturday \u263a). Sorry for\ninconvenience. The life is busy recently.\nOn Fri, 22 May 2015 04:40 Eric Elliott notifications@github.com wrote:\n\n@koresar https://github.com/koresar if you can review this and merge,\nI'll be happy to set up the Travis CI GitHub integration.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/pull/63#issuecomment-104383336.\n. Merged to v2_0.\n. However, I probably should inform that we are going to have \"refs\" feature (see #60). Basically, these are object references added to each object instance (not stamp). Statics in the object so to say. May I wonder why you need statics for stamps but not object instances? I'd like to find how many people would need this feature.\n\nAlso, stampit main objective are objects, not stamps. I doubt people would use this feature extensively, if use at all. I believe modules (like stampit) should do single job and do it well.\nMoreover, I feel like introducing a whole new feature which saves people 15 characters\nstampit.extend(someStamp, { ... }); is not worth the hassle around it. As we would need to support it preferably forever.\n. Oh, that explains it all. Thank you so much.\nI saw the example of unwanted syntax in #65. Is the following the proper usage of the proposed API?\njs\nvar AuthButton = stampit({\n// methods\n}, {\n// state\n},\nfunction () {\n// enclose\n}, {\n// static\n});\nIf yes, then we have stampit v2.0 incompatibility issue. If you take a closer look at #60 changes (which I'm going to finish tomorrow) the stampit() function receives a fourth parameter for the deep cloned state. Thus, your PR is heavily conflicting with #60.\nIf we add the fifth parameter to the stampit() then we are introducing heavy code smell. :) Even fourth parameter is a code smell too. Someday someone would propose sixth, and so on. :)\nI believe stampit v2.0 should improve its core API - the stampit() main function.\njs\nvar stamp = stampit({\n  refs: {},\n  methods: {},\n  props: {},\n  enclose: function () {}, // or an array of functions\n  static: {}\n});\nThe implementation is trivial (ducktyping). Would that suffice your needs, guys?\n. So, the outcome of this issue are two issues.\nImplemented in stampit v1 under #76.\nThe v2 implementation to follow under #74.\nClosing this issue.\nBig thanks guys!\n. If we merge this then stampit v1 and v2 will have different fourth parameter. Moreover, this PR lacks tests. I'd implement this feature in v2 which I'm going to finish today. :)\n. I somehow missed the decision taking message.\nSo, method is the only thing implemented. The fourth parameter for stampit() will not be implemented. Is that correct?\nAlso README better be updated I reckon.\nWhat if someone would like to create a static called \"state\" or \"compose\" or \"methods\"?\njs\nvar stamp = stampit().static({ compose: () => console.log('hello') });\nstamp.compose ... ?\nWe should warn people that using reserved function names may and will lead to conflicts and unpredicted behaviours. Any ideas?\n. One more thing.\nYou might want to consider converConstructor statics support. See the sample unit test:\n``` js\nexport class Counter extends React.Component {\n  static defaultProps = { initialCount: 42 };\n}\nvar stamp = stampit.convertConstructor(Counter);\nassert(stamp.propTypes.initialCount === 42);\n```\n. I'll reimplement this in v2.0 branch after we merge #76 to v1, and #72 to v2. The idea and approach will be reused of course.\nThis PR is too incompatible. Easier to (re)implement than to merge. I can do that hopefully this week.  I'd close this PR for now. Are you alright with that @troutowicz?\nSorry I can't get much free time lately.\n. Cheers @troutowicz :)\n. To follow the discussion follow the link: https://github.com/troutowicz/react-stampit/issues/1\nClosing this issue as irrelevant.\n. The 2.0 Milestone should contain incompatible changes. This issue seems like can be implemented in a fully compatible way. I'll create 2.1 Milestone and assign the issue to it. I really want to release stampit 2.0 ASAP.\nRemoving this issue from 2.0 Milestone. \n. I can't understand how to implement that. @ericelliott can you show any code samples you have in mind?\nI just don't want to code something we'll through away just because it's useless.\n. Yes, Eric. I understand how to implement that. Can you scratch a high level code please? Like:\njs\nstampit.setup({ debug: ({ stampA, stampB, propA, propB, key }) => console.log(key) });\nstampA.compose(stampB);\nI cannot understand which exact way people age going to use this feature.\n. There is no requirment on this feature request. It's been opened for 2 months. /cc @troutowicz \nPlease, either provide code examples or I'm closing this tomorrow.\n. What about IE9?\nOn Mon, 25 May 2015 02:09 Eric Elliott notifications@github.com wrote:\n\nI'm OK with dropping IE8 support in version 2, but version 1 still needs\nit.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/68#issuecomment-105031349.\n. As long as IE 8, 9 and 10 are not supported anymore we should aim to test IE11, Chrome, Safary, and FF.\n. #326 contains significant simplification of stampit module code. Thus, I was able to make unit tests runnable in browsers.\nNo automatic tests though.. Implemented browser tests in v4. Manual tested in IE11. All good.\n\nIf someone would like to integrate stampit with SauceLab or similar - a PR is welcome.. It's not done. I believe we should go this path:\n- create a GitHub org for stampit (done).\n- Move stampit there.\n- Move the supermixer there too (convert to ES6 maybe). A new module name might be necessary.\n- Replace the mixer.js with the supermixer.\n- Move react-stampit if the author is okay with that.\n. I'm working on this now.\n. Done. See https://github.com/stampit-org/supermixer\nUsed in stampit with PR #107 \n. But even if you see the error message, you won't see the stack trace. Am I doing something wrong?\nI miss stack trace very much. It is really a time-consuming job if you don't have an exception call stack. :(\n. In fact, simple node test/stampit-specs.js runs tests smoothly even without phantomjs.\nI might not know something. But would someone explain me why we need phantomjs to run tests locally?\n. There are 171 tests in the init-making-stampit-flexible branch. Which is soon to be merged into v2_0. I've removed phantomJS there. So, as soon as in 12 hours all the issues mentioned here will be resolved. :)\n. The issue got resolved in branch 2.0 with node test/index.js instead of tape-run. :)\nI confirm exception stack traces are being printed. Tape assertions print the file name and line number on fails.\nAll good.\n. Everyone, who has write access, are welcome to edit the new README. Here is the direct link:\nhttps://github.com/ericelliott/stampit/edit/README_v2_0/README.md\nI encourage you to do it because, as you might have noticed, my English skill sometimes lack proper structure.\n. How about #81?\n. Okay.\nThe PR #83 is ready to be reviewed and merged into v2. Waiting for Eric for a day.\nThank you people for collaboration. It is so joyful to know I'm not alone. :) Cheers!\n. - Would you do that the way you see it, please?\n- I'm okay with any number of .md files, but I'm strongly against dev. docs in wiki. I usually open node_modules/module/README.md instead of going only for API documentation. Wiki is good for  non-development info (like proposals, drafts, or history tracking).\n- :+1: \n. Yes, Eric. We did. It'll be implemented as a non-breaking change to the 2.x line. Say in 2.1. Ok? \n. I kind of hoped we can ducktype the first argument. Do you think that's feasible?\n. Eric, I am getting confused...\n1) We were talking that compatibility with 1.x is what we should look at while releasing stampit v2.\n2) Now you are saying \"break the stampit main API\".\nWe have to select one of the two paths: try to have as less as possible differences with stampit v1 API, or break most of the stampit v1 API's.\nYou should keep in mind that options object implementation #73 will take weeks.\n. Please, review #84.\nIf anyone could update the README using the link above to reflect the changes that would be very helpful. The list of changes you can find in #84.\nThank you, my future helper!\n. Thank @ericelliott for merging. Although, the README still lack static descriptions, examples, and the rest. See the checkboxes on top. :)\n. @ericelliott you've committed the merge conflict! \nhttps://github.com/ericelliott/stampit#and-init-\n. The README is up to date. \u0414\u044f\u043a\u0443\u044e!\nP.S. Someday a better structured one(s) should be written IMO.\n. Sorry rushing you up. I intend to finalize v2.0 with few days time. This PR is what holds us down. Does anybody want to take a look? Run tests? Browse the code? I would prefer to run this project collectively if possible.\nCheers\n. Thanks mate. The main changes to stampit.js are around line 131. The corresponding tests are in the test/init.js.\n. I felt like having \"npm start\" is kind of misleading for a utility module. So I replaced it with more useful \"prepublish\" hook to make sure none publishes untested code. :)\n. Done.\n. I'll see what I can do about the comments above in 12 hours. \n. > I'm running into a jshint error \"cannot open test/\" with test/...seems to work passing test without the slash+wildcard.\nYou were probably running old JSHint. No worries. I've fixed that with last commit. jshint test/.\nUPD: actually it failed for me too. JSHint version doesn't really matter.\n. > I'm wondering the same @unstoppablecarl. What does the current implementation do differently than:\nAll the proposed implementations above simply break tests. Try it. :)\nThe tests are very comprehensive, my friends. Very. \n. > What about using a faster .apply ?\nI'd prefer later stage optimizations. Premature optimizations are general evil. (I specialize on application performance for few years now.)\nLet us think of performance when somebody hit bottleneck and claim it's because of stampit. ;)\nNevertheless, it would be awesome to see a performance optimizing PR after we release v2.0.\nIn fact, I did analyze performance of stampit. The only bottleneck is the function factory(). That's why you can find few if statements there. ;) \n. Changes:\n- Linting every JS file we wrote.\n- Fix linting.\n- Rename unusual mixIn to mixin. Leave alias for compatibility of course.\n- Add comments to those weird || operators. Hopefully, this will help future code readers.\n. Yes, there should be one. Thanks for the reminder. \n. There are no tests for stampit.method aliases as of yet. I wanted to add them though.\n. We should keep in mind that we want to have as much compatibility with v1\nas possible. Just reminding. :-)\nOn Mon, 25 May 2015 02:23 Eric Elliott notifications@github.com wrote:\n\n[image: :+1:]\nAbsolutely. Named properties only for stamp creation in v2. No more\nmulti-arg support.\nWe should keep the fluent methods, though. =)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/73#issuecomment-105033157.\n. I don't mind implementing the feature. It would take much time since there are many unit test to adjust.\n\nI'll do that over the weekend. But strict review would be necessary.\n. Please review #84. After the merge I'm closing this issue. Cheers :)\n. Implemented!\nThanks everyone. That was a great journey. :) Get ready for the next episodes.\n. Stampit must warn users if they are using \"reserved\" stampit names: create, methods, refs, state, init, enclose, compose, statics, and fixed.\n\nIn the 2.x branch we should log to the console in the debug build only.\n. How would a code detect if the stampit is running in the debug mode? @ericelliott ?\n. Done with #84\n. I've changed the milestone of this issue from 2.0 to 2.1. I'm shifting all v2.0 compatible issues further to speed up stampit v2 release. I suppose this can be implemented in a compatible way. Can it?\n. Gist is good, I even managed to run in with some modifications. But, could you please post more details to this issue? Like post the error, results, erroring line, etc? \n. Moreover, does ES6 support static properties? I heard that only static methods are allowed.\n\nMore on static members: http://sravi-kiran.blogspot.com.au/2015/01/StaticClassMembersInES6.html\n. Ok, I was running it locally via babel-node. Playground it something we would need to avoid as it is not final. We should consider only final ES decisions. Otherwise, it's just a waste of time and effort.\n. That's a pretty incredible ES6 class workarounds in your gist, btw. How did you manage to find those workarounds? :)\n. Oh, I was under an impression that you've found an obstacle we can't work around. But, actually, you've found a solution. :)\n. To properly implement the convertConstructor we would have to support both ES5 classes, babel-transplied classes, and ES6 native classes. As the result stampit will become multy purpose tool, which we don't want very much. Stampit should do single thing and do it good, - namely, compose stamps.\nWe better create a separate module for the convertConstructor utility function. We even have an issue for that: https://github.com/stampit-org/stampit/issues/137\nThoughts?\n. @boneskull http://www.ecma-international.org/ecma-262/6.0/#sec-map-constructor\nI'd need your assistance.\n. Thanks Daniel.\nBtw, Eric is right. The \"Promise()\" also throws.\nOn Thu, 2 Jun 2016, 06:41 Eric Elliott notifications@github.com wrote:\n\nif anyone knows why Map throws if not called with new (or if you can\ndirect me to who might know), I'm all ears.\nAll ES6 constructors throw if you don't call them with new.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/75#issuecomment-223118132,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ABjCL-rhBUhWkFZHbAqCHCe3WuTZ2_x3ks5qHe6LgaJpZM4EnolW\n.\n. Let me review this for you. :)\n. All good except for one little thing I'd like to clarify. As soon as we resolve that it should be fine to merge.\n\nCould you please also add few usage samples to the README? Also, it'd be good to warn people over reserved stamp 'static' properties: create, methods, state, enclose, compose, and fixed.\n. > We should explicitly test for those and warn about conflicts.\nWhich way of warning do you think of, Eliot?\n. Should we split the feature to \"staticProps\" and \"staticRefs\"?\n. All good. I'd merge in 6 hours or so if everyone is okay with that.\n. @ericelliott, we need you to bump version to 1.2 and publish. And we're done here.\n. Thanks! \n. I accidentally created this PR against the wrong branch. So I'm closing it. :)\n. Polluting Object prototype? :) Maybe next time.\n. Exactly. Stamps are object. Arrays are objects. Going further, classes in Java/C# are also objects of a special kind. Why stamps can't be one of them? :)\n. Having stampit, react-stampit, supermixer and, hopfuly, babel-stampit someday we should consider moving all that to an organization: github.com/stampit.\n. Done with #109 \n. That's a great addition! Thanks. :)\n. Ready to be merged to v2_0 I think. Check the latest changes please.\n. @ericelliott \n1. There are no outstanding PR's to my knowledge.\n2. I'm trying to keep the outstanding things in the Milestone 2.0. The only thing left is README.\nRE the prepublish and dist/. Each time you'll execute npm publish the dist/ will be generated and uploaded to the NPM registry.\n. @troutowicz I do not feel strong about files feature in package.json. I'll leave .npmignore for the time being. We'll see how it goes.\n. Updated the JSDoc of stampit() to describe argument. JSDoc docs: http://usejsdoc.org/tags-param.html\n. #74 got implemented as well (static stuff). Requires thorough review. @ericelliott ?\n. Correct. I have no idea why is that happening. I tried to use earlier lodash, but it fails with \"Can't download package from the HTTPS uri\". Might be an NPM issue (too old build).\n. You can fixing it. :) Just put the following into the travis yaml.\nyaml\nbefore_install\n  npm update npm -g\n. Btw, Travis-CI fixed their io.js+lodash bug. Builds are now green. :)\n. Merged to master. Have a good day/evening/night/polar-day!\n. Merged. :) Cheers!\n. thank you very much, @troutowicz!\n@ericelliott, merge rush, huh? :)\nAll good now.\n. Same length but better composed. Awesome, Eric!\nI'll put that to Wikipedia later today (with some history background of course). I'll share the link here for your further editions.\n. That's perfect for our README. But lacking some wikipedia-like seriousness. Wikipedia example: http://en.wikipedia.org/wiki/Liskov_substitution_principle\n. All good. Thanks.\n. @ericelliott , you'd like to edit this one I reckon. :)\nhttps://en.wikipedia.org/wiki/Stamp_(object-oriented_programming)\n. I believe this sentence requires more details:\n\nTraditional factory functions can't be composed together to produce new factory functions.\n\nBecause there is https://en.wikipedia.org/wiki/Function_composition concept.\n. Ok. Seems like the page is up. We might want to give a link to it on our README.\n. I'll copy&paste wikipedia article contents in here just for future reference in any.\n```\nIn [[object-oriented programming]], a '''stamp''' is a composable [[factory (object-oriented programming)|factory function]] (not to be confused with [[function composition]]). Stamps allows [[inheritance (object-oriented programming)|inheritance]] from multiple ancestors by [[object composition|composing]] multiple source stamps. Technically, they allow to combine properties, methods, and initializers (with [[closure (computer programming)|closures]]) from any number of stamps to produce a new stamp.\n==Motivation==\nStamps are more flexible than traditional factory functions or classical multiple [[inheritance (object-oriented programming)|inheritance]]. Traditional factory functions can't be composed together to produce new factory functions. [[class (computer programming)|Class]] inheritance does not provide a standardized mechanism for class composition.\nStamp composition takes advantage of three different kinds of [[Prototype-based programming|prototypal inheritance]]:\n\nDifferential inheritance, aka delegation (e.g., JavaScript's [[JavaScript#Prototype-based|Prototype]]),\n[[Mixin]]s/cloning with optional deep merge, as known as concatenative inheritance (e.g., JavaScript's Object.assign()),\nFunctional / closure inheritance (for initialization or privacy/encapsulation)\n\n===Difference from Classes===\n It's easy to compose (see [[composition over inheritance]]) multiple stamps to create a new stamp with all of the source stamp capabilities \n Stamps are factory functions, so they don't need to be invoked with the ''new'' [[Reserved word|keyword]] (which couples callers to the implementation of object instantiation)\n* Stamps don't create parent-child class hierarchies. Class hierarchies create \"is-a\" relationships between classes. Stamp composition creates \"has-a\" or \"uses-a\" relationships, instead. For that reason, stamp inheritance is less brittle than class inheritance.\n==History==\nThe word '''stamp''' for computer programming was [http://chimera.labs.oreilly.com/books/1234000000262/ch03.html#prototypal_inheritance_with_stamps originally used] by Eric Elliott in his book, \"Programming JavaScript Applications\" in 2013 and propagated via the Stampit JavaScript library. The concept started gaining wide popularity in 2015.{{Citation needed|date=June 2015}}\n[[Category:Object-oriented programming]]\n[[Category:Programming principles]]\n```\n. Closing this issue as done. See text in the previous comment.\nAnd let's hope wikipedia moderators won't remove it https://en.wikipedia.org/wiki/Stamp_(object-oriented_programming)\n. We can point to the two functional mixins articles and reddit discussions. What do you reckon?\n. @troutowicz Take the first one! :)\n. The only way to get the buggy v2 is to clone the repository. It's the\ncurrent master branch.\nOn Sun, 7 Jun 2015 11:45 tropet123456 notifications@github.com wrote:\n\nIs it possible to get this new version (v2) from Bower? and How?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/91#issuecomment-109671371.\n. @troutowicz It's the time. You can start converting stampit to ES6.\n\nPlease take a look at the link above: https://github.com/ericelliott/prod-module-boilerplate\nThe approach there suits us perfectly, IMO. Don't hesitate to strip parts you think we don't need. :)\n. Useful scripts will be added with #116\nSome were already added with #123 \nClosing this issue as outdated.\n. Ah, the missing tests. Thanks Carl. \n. > So create() would seem to be the way, but it looks like that is doing a deepcopy\nNope, it copies by reference. Moreover, Node.create() and Node() is exactly the same call.\nI believe we have that in the docs, but obviously that info is hidden in the pile of other \"very useful\" info.\nI'm seeing people are getting very confused of our readme. :( \n. There are many wrong things in this thread. Let me get to a computer in few\nhours. I'll explain where we were misguided.\nOn Sat, 6 Jun 2015 10:51 Jason Galea notifications@github.com wrote:\n\n8) hehe. I'm having trouble not believing what I'm seeing. It looks like a\nduck, and walks like a duck.. (and behaves like I want). I'm not sure how\nit's not making use of the stamp as it gives me an object which I can call\nmethods on to manipulate the data I want it to.\nArgs are an anti-patter, but isn't that exactly what create(properties)\ndoes? I'm just working around the fact that create deepcopies the\nproperties so I lose my reference.\nWhat if I expand the example to it's intended usage?\nimport stampit from 'stampit'\nimport map from 'lodash/collection/map'\nlet Node = stampit({\n  methods: {\n    setPaddingLeft(size) {\n      this.attr.padding.left = size\n    }\n  },\n  static: {\n    fromRef: function(args) {\n      return this.refs(args)()\n    }\n  }\n})\nlet Cell = Node.methods({\n  ima(){\n    console.log('== Ima Cell ==', this.attr.padding.left)\n  }\n})\nlet Row = Node.methods({\n  ima(){\n    console.log('== Ima Row ==', this.attr.padding.left)\n  }\n})\nlet doc = { kids: [\n  {attr: {padding: { left: 5, right: 10 } } },\n  {attr: {padding: { left: 25, right: 50 } } },\n]}\nlet node1 = Cell.fromRef(doc.kids[0])\nnode1.setPaddingLeft(18)\nnode1.ima()\nlet node2 = Row.fromRef(doc.kids[1])\nnode2.setPaddingLeft(28)\nnode2.ima()\nconsole.log('doc', JSON.stringify(doc, null, 2))\n== Ima Cell == 18\n== Ima Row == 28\ndoc {\n  \"kids\": [\n    {\n      \"attr\": {\n        \"padding\": {\n          \"left\": 18,\n          \"right\": 10\n        }\n      }\n    },\n    {\n      \"attr\": {\n        \"padding\": {\n          \"left\": 28,\n          \"right\": 50\n        }\n      }\n    }\n  ]\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/93#issuecomment-109492197.\n. I'll take a chance to answer later. For now I think @lecstor has found a bug.\n\nStampit v1 factories were mixin' (shallow copying) the first argument - stamp(someRefs).\nStampit v2 factories are deep merging/cloning the first argument - stamp(objToClone).\n@ericelliott in the January thread we decided to deep clone the factory argument: https://github.com/ericelliott/stampit/issues/40#issuecomment-70052358\nWas that a correct decision back then?\nIMO we should have two options:\nstamp(refs) or stamp.create(refs) - should shallow copy.\nstamp.createFrom(props) - should deep merge/clone. (Please, suggest better name.)\nOR\nstamp(refs) - for shallow copying.\nstamp.create(props) - for deep merging/cloning.\n. Few more thoughts.\nAnswering my own question:\n\nWas that a correct decision back then?\n\nNo, it was not. Because people cannot pass objects to factories anymore. :( Well, they can, but the object will be cloned entirely, which most of the people don't want. But, if someone want, he can do it manually stamp(clone(object)).\nI'd highly recommend us to make stampit v2 shallow copy it's argument. This is what people using ES6 would want because of new argument/object destructuring syntax.\nstamp({ database, userName, age: 42 })\nI'm starting the coding.\n. Thanks Carl!\nClearly, it's not even a bug but mis-implementation.\nI beg your pardon, people. My fault. I forgot what we agreed to at the #57.\nGood we haven't released the current master branch. \u263a\nIf anyone could edit the README to point out that stamps accept refs as an\nargument, that would be great. Thank you.\nOn Sun, 7 Jun 2015 02:14 Carl Olsen notifications@github.com wrote:\n\n@koresar https://github.com/koresar we talked about it here too #57\nhttps://github.com/ericelliott/stampit/issues/57\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/93#issuecomment-109608754.\n. PR fix #96 submitted. Please review.\n. @troutowicz correct. refs is for shallow copying, and props is for deep clone/merge.\n\nIn stampit v1 the state behaved like refs (most of the time though). So, @dwiyatci, with you should v2 continue using state as you were using in before with v1. props is a handy method for a very rare occasion.\nThis comment explains how stampit v1 works: https://github.com/ericelliott/stampit/issues/40#issuecomment-69848225\n. To be more correct, \"props\" is equivalent to \"merge\" (which also deeply\nclones if the destination object is empty).\nOn Sun, 7 Jun 2015 02:25 Carl Olsen notifications@github.com wrote:\n\nI just want to clarify for future reference.\nrefs() is equivalent to .extend() https://lodash.com/docs#assign\nprops() is equivalent to .cloneDeep() https://lodash.com/docs#cloneDeep\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/94#issuecomment-109612868.\n. @lwhorton Thanks mate!\nHere are few more: \n- https://github.com/stampit-org/stampit/blob/master/test/basics-refs.js\n- https://github.com/stampit-org/stampit/blob/master/test/basics-props.js\n\nAnd many more here: https://github.com/stampit-org/stampit/tree/master/test\n. Cheers @mark-rushakoff \nI'm closing this issue. I hope you're okay with that.\n. Fixed comments above. Thanks guys!\n. > I don't think ignoring existing properties is a good idea.\nWhat \"ignoring\" are you referring to? The code does not ignore anything. \n. @unstoppablecarl #50 might give you some insight maybe.\n. Please, do not use any new terminology to replace the existing. What do you mean by settings?\n. These are refs. Please, check the code - the variable name reflects the usage.\nAlso check the changes to the README. It also says refs or references literally everywhere.\n. > I assume this means properties matching refs will be ignored?\nNope, they will be not. \"props\" will be merged into an instantiated object which already has all the refs mixed in. Pseudo code:\njs\nvar instance = Object.create(...);\n_.mixin(instance, refs);\n_.merge(instance, props);\n. I'll merge this tomorrow if no objections.\n. @unstoppablecarl The strange behavior you found can be easily fixed.\nYour code:\n``` js\nvar stamp = stampit().props({\n    connection: 'my connection',\n});\nvar instance = stamp({connection: undefined});\nconsole.log(instance); // { connection: 'my connection' }\n```\nReplacing undefined with null fixes it:\n``` js\nvar stamp = stampit().props({\n    connection: 'my connection',\n});\nvar instance = stamp({connection: null});\nconsole.log(instance); // { connection: null }\n```\n. Since Eric has done his part I'm merging this in.\n@ericelliott, please publish to NPM.\nMeanwhile, I'll work on the Advanced Examples.\n. Yup, some of them are incorrect. But I'll correct them all after you finish. How does that sound?\n. I believe I'm the only one who can tackle the thing fast and most correct. I'm thinking of reassigning the issue to me. :) @unstoppablecarl Would you let me do that?\n. There is no reason to keep this issue open IMO.\nThis is a time consuming task. Two years past - no progress. Seems like the benefit from test descriptions is minimal.\nFeel free to reopen though.. @troutowicz proposed a stamp-like logo. This is an example (which should not be used due to copyrights obviously): \n\n. @elitenomad Hey, mate! Good evening. :)\nGreat work!\n. @unstoppablecarl it looks like another handlebars-like module. :)\n. Can I ask why you put braces? Why not stamps? :)\n. In JS world the braces are usually associated with Handlebars or Mustache frameworks.\nAs long as we are creating stamps here it would be pretty logical to see stamp-like logo. See two examples above.\nI cannot understand the logic behind your artwork. Sorry.\n. Stamp is the real physical thing. People use it to put special marks on paper.\nSee images\n. Well, I've seen plenty of JS modules with braces on their logos. I haven't seen any which represent stamp. :)\nMoreover, a picture of stamp would be highly recognisable alongside the other JS modules.\n. Postage stamp is okay, but it's not meant to be reproducible. Ink stamps are designed to be multiplied. :)\n. Thanks @MarkAurel !\nOne more thing we should keep in mind. Stampit logo will be displayed small in many places (of GitHub at least). Like here: https://github.com/stampit-org\nSo, probably it would be good if the text is readable when the picture is shrinked.\n. That's adorable, @NinjaGrisen !\nAnd also I like your github nickname!\n. The red one is simplistic. That's modern. I like it too.\nOn Sun, 14 Jun 2015 08:28 Joseph Clay notifications@github.com wrote:\n\nI like the red one\n[image: :clap:] @unstoppablecarl https://github.com/unstoppablecarl\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/102#issuecomment-111757548\n.\n. > Just using a rubber stamp is too literal.\n\nThat's exactly what we need! Explicit, obvious association. We don't want people confuse stampit with a templating module like handlebars or mustache.\n. @PhiLhoSoft that's clever!\n. @PhiLhoSoft would you share the Inkscape file?\n. @PhiLhoSoft decide for yourself. :) But there is no way to attach files on GitHub. You can try gist though: https://gist.github.com/\n. So many incredible options!\nLet me create a poll later today. :) We'll vote.\n. ## Logo submissions have ended. Please proceed to this poll, leave your opinion: https://gist.github.com/koresar/aca0ca81edc34f58462c\n. Tomorrow I'll publish the results. It might change by then but I think already have a clear winner. :)\n. And the winner is... Image 2 by @unstoppablecarl \nWe have created a repository for logo(s). Trying to make variations of this logo for different resolutions and screen sizes.\nThe second place (also by @unstoppablecarl btw) is rather far, so no second voting round is necessary.\nWe appreciate all the participants. These were great contributions. See you around!\n\n\n\n. ./dist/stampit.js should be ./stampit.js\n. Oh, we don't have this file regardless. Time to drop bower support?\n. @sethlivingston Hey, Seth, how are you?\nWould you help us to maintain the bower package?\n. :)))\nI believe, if you needed stampit v2 on bower, then more people would need it. I doubt Eric would be against.\n@ericelliott Can you pass on the stampit bower credentials to this handsome gentleman?\n. We got to find the person who published it to bower the first.\n. Do we have any progress on brew, @sethlivingston ?\n. no worries! Thanks for that!\n. @unstoppablecarl You have the powers to merge it. :)\n. Processes are good in big organisations. In open source projects processes are evil. :) They delay productivity.\nIf you have any process proposal - go ahead. We'd love to listen.\n. Sound okay. But each PR would take about 3 to 5 days to review because there are 4 collaborators here. :)\nLet's try be less burocratic. Small safe changes are fine to merge by a single person I think. If a change is significant then let's wait for few people to take a look. Just like I did with the #96 \nReasonable?\n. Good idea. Are we big enough to introduce this little complexity in sake of quality?\n. Sounds okay to me. We can try.\n. Click this link to see how the .md looks rendered: https://github.com/stampit-org/stampit/blob/advanced_examples/ADVANCED_EXAMPLES.md\n. @unstoppablecarl @ericelliott @troutowicz \nThis PR is ready to be merged. Please, review. Otherwise I'd merge it into master tomorrow.\nPlease, pay attention to the stampit.js and couple of tests were changes. A little history behind that:\n- When I was implementing stampit v2 I decided to limit fixed.methods to contain functions only. So, I used the mixer.mixinFunctions(fixed.methods, methods). Stampit v1 doesn't do that.\n- However, while I was implementing these Advanced Examples I realized that limiting the freadom is the worst idea. :) Within this PR I changed the code back to mixer.mixin(fixed.methods, methods).\n:tada: :smiley: \n. @troutowicz Don't stop! Correct more! :) Please.\n. Ok. Examples are ready to go. All issues corrected.\nMerging today soon.\n. > We aren't limiting freedom, we are enforcing an API that will not create unexpected behavior.\nThat's why I called the example Hacking stamps. Also, that's why the files is named Advanced examples. :)\nI'd love to hear your ideas about how to make the hacking.js not to print undefined. ;)\n. @troutowicz Truth is yours. I'll either remove or update the example if come up with something else.\n. Done. Ready to merge this time?\n. Ok. It all looks good to me now. I'm okay to merge. I'd wait for other guys to review though.\nPS: We'd need to replace jshint with eslint with a different PR someday.\n. Implemented. Please, review #123 and merge. :)\n. It works! https://cdnjs.cloudflare.com/ajax/libs/stampit/2.0.3/stampit.min.js\nClosing this one. Please, reopen if you think more work should be done.\n. Easy!\njs\ninstance = fn.call(instance, { args: args, instance: instance, stamp: factory }) || instance;\nif (isThenable(instance)) // <- like this :)\n. Added with #129 \n. I'll continues my example from above:\njs\nPromiseStamp((resolve, reject) => {\n});\nOur converted stamps can pass those arguments with ease. :)\n. Crappy idea.\n. Implemented with #123. Please, check and merge. Thanks.\n. Done.\n. ### Is it worth doing for stampit?\n- We have two dependencies only. Lodash is secure. supermixer is our own invention and is not being audited by NSP.\n- NSP was designed as a help tool for node.js services, but not for universal utility modules like stampit.\n- I believe NSP worth doing for big projects like Hapi: https://github.com/hapijs/hapi/blob/master/package.json#L20\n- Let's be pragmatic, @ericelliott. Stampit codebase is around 100 lines excluding comments. For small utility modules like stampit the NSP automation is an overhead. \nI believe we should not implement that.\n. Done. Thanks Eric.\n. I'm not getting. What's that and what's the point?\n. > when other people try to install it, they get all of the required dependencies installed.\nIsn't it the way npm work by default?\n\nIt also checks for dependencies that are required in package.json that are not used in the code\n\nDo you think there is a possibility for that to happen in 100 lines code base of stampit? I doubt.\nThe dependency check worth doing for large projects. For a utility module like stampit it's an overhead.\n. Yup. Sounds good.\n. See #132\n. Hello Eric,\nI'd like to share few stories from my experience with you.\nAs an experienced developer (12 years of commercial coding) I stand strongly against any git hooks. And here is why:\n- I often commit uncompilable changes just to switch branches.\n- I sometimes push broken tests and even uncompilable changes just to switch laptops/coding environments.\n- About 5 years ago we tried git precommit hooks in our team of 5. Removed it in about 30 minutes.\n- I often experiment using local branches. These never lint as you understand.\nPlease, do not introduce any pre-commit or pre-push hook to any projects, unless understand the devastating consequences.\n. @nkbt Unfortunately I'm using SourceTree and WebStorm to commit. Other people use various visual git tools which do not pass -n or alike to the git command line.\n. @nkbt \n\nIdeally all commits should be valid and working, so a case of non-completed job is a deviation, not a norm\n\nIdeal commits should be merged. That's true.\nI want freedom on my local machine(s). If I can't commit my own branches freely then let's get back to SVN. Git won't benefit us anymore. :)\n. @nkbt Thank you for the tip with the WebStorm. Is there a same for SourceTree?\nI'm not using changelists in WebStorm, disabled them intentionally. Any other workaround maybe?\nHowever, thinking of all the workarounds is making me anxious. It's simpler not to implement any git hooks, - no workarounds would be needed. :)\n\nI personally believe that committing broken code should be a rare exception.\n\nThat's is my personal opinion too, but only for the single developer projects. In my experience, if there are two or more people working on the same repository the git hooks suck. @nkbt try pre-commits in your team and let us know how it went.\n\nThough possible solution could be to utilize pre-push rather then pre-commit.\n\nThis brings same troubles as pre-commit hooks, just the troubles happen more rare.\n. > we are using pre-commit checks in our ~15 people team.\nWould you elaborate on that?\n- Every repository of every developer have the pre-commit hook which:\n  - Does linting and stops a dev from committing if linting fails.\n  - Runs tests before the commit and stops a dev from committing.\n  - Checks extra installed and missing modules like so:\njson\n    \"missing\": \"dependency-check package.json\",\n    \"extra\": \"dependency-check package.json --extra --ignore\",\n- Could you please show your pre-commit hooks themselves? What's being checked? For how many repositories?\n. @nkbt Thanks Nik. That's awesome to know that 15 people commit to the same repository and have such a great level of cooperation and clarity. Keep it up.\n. Today I switched between my local unlintable and test failing eslint branch (not pushed yet) and the edvanced_examples branch to fix up @troutowicz finds. \nJust sayin...\n. This is good to mentions react-stampit. But the placement of the text is rather too high. React is somewhat irrelevant to our main objective - the stamps. In my opinion, this text should go somewhere below \"What is a Stamp\" section.\n. @troutowicz You were too fast to merge. :)\nNevertheless, should we move the React mention lower?\n. I believe that making README worse just before publishing a large blog post about stampit is not wise. Can we at least minimize the bloating impact?\nJust use bold instead of h3. See below.\n\nReact Users. Stampit loves React. Check out react-stampit for composable components.\n. @troutowicz see #124 \n. Hello @wheresrhys \nI'd like to understand your concern in full. Would you please answer few questions?\n\nidentifying the type of the object in debug output\n\nIn JavaScript what do you mean by 'type of the object'? The typeof operator?\n(I'll be asking more questions later.) :)\n. How do you see the usage of the console.Symbols.INSPECT? Code samples maybe? \n. For anyone, who's not familiar with console.Symbols.INSPECT, please have a good time reading this: http://blog.keithcirkel.co.uk/metaprogramming-in-es6-symbols/\n. Hm, mate, I think we have solved the typeof \"issue\" with stampit v2.\nCheck this out: https://github.com/stampit-org/stampit/blob/advanced_examples/ADVANCED_EXAMPLES.md#self-aware-objects---instancegetstamp-2-ways\nHere is your business logic stamp:\njs\nconst User = stampit(/* bla bla bla whatever */);\nHere is the behavior you can compose to any other stamp (like the one above).\n``` js\nconst SelfAware = stampit.init(({ instance, stamp }) => {\n  instance.getStamp = () => stamp;\n});\nconst SelfAwareUser = User.compose(SelfAware);\n```\nAnd here is how it works now:\njs\nconst user = SelfAwareUser();\nassert.strictEqual(user.getStamp(), SelfAwareUser); // All good\nIs it the behavior you were looking for?\n. @wheresrhys Were your question answered? Please, feel free to express your concerns. We love to hear those.\n. Closing. The issue starter is not active.\n. :+1: Conciseness and examples!\n. Today a person in gitter was asking questions. He reminded me of the things in the README I stared at months ago understanding nothing. What I thought when I saw the examples in readme for the first time: wtf?\nBack then I had to go to the source code in order to understand what's going on. Also, nowadays, when I'm explaining stampit to others, I find that the only way they understand it fast is to explain stampit internals. Like that:\n\nThis is what stampit is doing to your refs, props, methods and inits. PSEUDO CODE:\njs\nvar instance = Object.create(methods); // methods is the prototype\n_.assign(instance, refs);\n_.merge(instance, props);\ninits.forEach(function (func) { func.bind(instance)(); }); // calling with `this` instance\n\n1. I strongly believe that the pseudo code above should be going just after the first examples in the README.\nThe other thing that the person in gitter was confused about is the stampit.mixin function. He thought it's kind of stampit's special purpose API function which is doing something smart. And, yes, he took idea that from our readme!!!\n\nBut that's boring. Let's see what else is on tap:\n...\njs\n// Some more privileged methods, with some private data.\n// Use stampit.mixin() to make this feel declarative:\nvar availability = stampit().init(function () {\n  var isOpen = false; // private\n  return stampit.mixin(this, {\n    open: function open() {\n      isOpen = true;\n      return this;\n    },\n    close: function close() {\n      isOpen = false;\n      return this;\n    },\n    isOpen: function isOpenMethod() {\n      return isOpen;\n    }\n  });\n});\n\nThe stampit.mixin() line above confused me very much 1.5 years ago. It still does to some extent. I believe the example (and few other examples) should be rewritten for newbie JS devs or even removed.\n2. We should teach people to use less confusing syntax:\njs\n// Some more privileged methods, with some private data.\nvar availability = stampit().init(function () {\n  var isOpen = false; // private\n  this.open = function open() {\n      isOpen = true;\n  };\n  this.close = function close() {\n      isOpen = false;\n  };\n  this.isOpen = function isOpenMethod() {\n      return isOpen;\n  }\n});\nAlso, I believe we\n3. should deprecate stampit.mixin()\nand ask people to use lodash, Object.assign or supermixer directly. This is not stampit's responsibility at the end the day. But if deprecating sounds too radical we can expose the supermixer's functions via stampit.mixer and use it like so: stampit.mixer.mixin().\n. I'd create an issue to eliminate mixin function mention everywhere in the docs we have. Also, the @deprecated JSDoc tag should be allied to all them. Agree?\n. One more close to useless feature which complicates stampit is \"multiple arguments to methods, refs, init\". Especially \"init\".\nReading something like that confuses people. Moreover, it complicates stampit source code (which we have to support unfortunately).\njs\nmyStamp = myStamp.\n...\n.init({\n  foo: function bar() {\n    this.b = true;\n  }\n}, {\n  bar: function baz() {\n    this.c = true;\n  }\n});\nI have never passed my init functions as properties of an object.\n4. Let's leave the multiple arguments feature but remove any mentioning of it from the README.\nOr, we can leave a small note in the README saying \"Any of the following accept multiple arguments.\" or alike.\n. Agree to all that, Eric. Cheers\n. :+1: \n. :+1: Carl. \n. Current stampit README is good. I'll leave this closed for now. Feel free to reopen if something is still bothering you or you feel the discussion should continue.\n. Pushed one more commit for code coverage.\nAs I expected it's 100% :)\nUsage:\n$ npm tun cov\nand maybe\n$ open coverage/index.html\n. Thanks mate! We know. It's not good. Although, good news!\nIt'll be fixed today. :)\n@troutowicz people need #109 merged. How do you think, should we do it now? :smiley: \n. Fixed @jorrit \nCheers\n. Looks very reasonable to me. Cheers\n. I'd wait for @troutowicz opinion before merging this PR.\n. Let me squash it now.\n. There is the only way to squash - this PR should be closed and a new one opened.\n. Oh, too late. :) Sorry. Next time I'll -f.\n. Ha, now the PR gis disabled by GitHub. It says The branch was force pushed or recreated.\n. The PR submitted. Awaiting review: https://github.com/borisyankov/DefinitelyTyped/pull/4764\nThis time I made it right. The stampit and stamp members are shown while you type.\nLast time it didn't pick up the syntax hints for code like stampit(). - didn't show up Stamp functions.\nI'll show screenshots after the PR get's merged.\n. The PR got merged, although my IDE didn't pickup the syntax to make predictions work. Oh, well.\n. Nah, I don't think we should run after each IDE integration. IDE's problem is IDE's problem.\n. There is one more likely scenario:\njs\nvar stamp = stampit().static({ fixed() { console.log('haha'); } });\nstamp.create(); // the `stamp.fixed` was overriden with the `static`\nWhat stampit should do in this case?\n. What's \"dev mode\"? How to check if stampit is in the mode?\n. That's something weird. Correct me if I'm wrong, but...\nWhen using our module, in order to see he did a bad thing to the fixed object the developer should:\n1) Install babel if not yet installed (many use CoffeeScript or TypeScript).\n2) Create the babelrc file, set it correctly up.\n3) Run his code using babel-node.\nIs that what you have just suggested?\n. Well, I think stampit should be as good as possible for the production needs. :) The two code samples above can potentially lead to numerous problems in production given that we talk about the stamp.fixed in the README: https://github.com/stampit-org/stampit#stampit-1\nThus, I really wanna make stampit as safe as possible to use regardless what people do with it.\n. I agree.\n\nI really think a warning is all that is needed.\n\nWhat sort of warning? a README warning? A runtime console.log warning? An exception in a debug mode?\n. > Create a warning function and import it.\nI'm confused. \"import\" mean the ES import keyword? And \"create function\" means \"have a file with function which warns to console\"?\nCorrect?\n. Also, Eric. \"two separate builds\" means \"two separate stampit.js files\"? Correct?\n. It's easier, simpler and more convenient to use a hook:\njs\nimport stampit from 'stampit';\nstampit.on('collide', console.log);\n// or\nstampit._collideHook = console.log;\n. Or the hook can be implemented on the stamp level (not involving the entire stampit to hold state):\njs\nconst stamp = stampit({ refs: { hello: 'me' }, onCollide: console.log });\nstamp({ hello: 'world' });\nThe code above would print:\nworld me hello\nI really don't want stampit the module to hold any state. Stamp is the best place to keep those.\n. In the chat we agreed to not implement stamp.fixed safety.\n. Published.\n. Yep. It works. Thanks for not forgetting about the Travis. :)\n. @ericelliott maybe sometime later. For now let's start from the simplest way - just like mout module.\n. It would be even more awesome if you can guide us. :)\nI know what Meteor is. Although, have zero experience with it. Do you have any Meteor experience?\n. Ok, here is the guide: https://atmospherejs.com/i/publishing\nOur package depends on two other packages. Will meteor grab those two from npmjs if any? @yasinuslu \n. Eric, will you take a lead on this meteor issue please as you are our publish-master. \ud83d\ude00\n. Agree on separate repo. Will you create one Eric? And maybe even give @yasinuslu the writing permission. \n. That's something new to me.\nOkay, again. How do you see an API? Without you answering this question I keen to abandon this task/feature. I literally do not know what you guys want. :)))))))\n/cc @troutowicz \n. I'll think about warnings. Thanks.\n. Agree.\n. Should we log to console when people are using state or enclose ?\n. :+1: \n. See #144.\n. 1. Scroll back through https://gitter.im/stampit-org/stampit and get few questions out of it.\n. I assume Michael is doing node.js. Right? I was experimenting for some time and found a best (yet) approach. So, I'll share my story.\nHere is my hapi.js handler:\njs\n    handler: (request, reply) => {\n      return reply(\n        Orders({\n          logger: request.logger,\n          credentials: request.auth.credentials\n        }).getOrder(request.params.id)\n      );\n    }\nThe Orders is a stamp:\njs\nconst Orders = stampit\n  .compose(DbClient.use('Order', OrderSchema), OrderPricingCalc, OrderSchemaConverter)\n  .methods({\n    getOrder(id) {\n      return this.db.findOne(id).then(this.applyPricing).then(this.convertFromDbToApi.bind(this));\n    });\nAs you can see:\n1) The HTTP and hapi.js contexts are abstracted away from the Orders implementation. This means I can change netwoking protocol at any time. Also, I can replace hapi.js with express.js easily. And also, by implementing a different DbClient the code can be reused on the frontend (browser) too.\n2) The this.db is part of DbClient. The this.applyPricing is taken from OrderPricingCalc. And this.convertFromDbToApi is the OrderSchemaConverter thing.\nAnswering your qeustions:\n\nShould I store the actual object properties in a sub property or in the root of my stamped object?\n\nIt's up to your will and needs.\n\nDoes it make sense to separate the db layer and use static functions as kind of constructors?\n\nYes, sure. It depends though. You can try few approaches and tell us the outcomes. It would be nice to hear one more opinion.\n\nCan I trust \"this\"? Will it always reference the stamped object?\n\nYou can trust \"this\" in any object method or static method whilst using \"dot notation\" (see Eric's answer above).\nSide things\n\nI'm not using callbacks. Promises ftw. (If you are using mongoose the promises are already inbuilt.)\nWhen you say \"recover from an OO background\" you probably wanted to say \"recover from classes and inheritance backgroud\". Beacuse OOP is about behaviour, not classes. See this tweet for example: https://twitter.com/awbjs/status/634753542998388736\n\nBon voyage! \n. I should probably elaborate on the implementation of those stamps:\n.compose(DbClient.use(OrderSchema), OrderPricingCalc, OrderSchemaConverter)\n``` js\nconst DbClient = stampit().static({\n  use(collectionName, mongooseSchema) {\n    this.fixed.refs.db = mongoose.model(collectionName, mongooseSchema);\n    return this;\n  }\n});\nconst OrderPricingCalc = stampit().methods({\n  applyPricing(order) {\n    ...\n    return order;\n  }\n});\nconst OrderSchemaConverter = stampit().methods({\n  convertFromDbToApi(order) {\n    if (...) {\n      this.logger.warn(User ${this.credentials.id} have bad order ${order.id});\n    }\n    ...\n    return order;\n  }\n});\n```\n. Q1 answer. See comments.\njs\nconst DbClient = stampit().static({ // static methods \"this\" context is stamp itself\n  use(collectionName, mongooseSchema) {\n    this.fixed.refs.db = mongoose.model(collectionName, mongooseSchema);\n    return this; // <- this is stamp, not an instantiated object!\n  }\n});\nDoes it answer your question? :)\n. We even have a doc for that (well hidden, far distant doc though)\nhttps://github.com/stampit-org/stampit/blob/master/docs/advanced_examples.md#hacking-stamps\n. The stampit v2 internal implementation should not be exposed, that's why the page says \"hacking stamps\".\nRead fixed.methods as obj.prototype. Take a closer look at the four bullet points by the link.\n. Not sure what you want. :) \n1) Define \"preset\".\n2) I implemented the DbLayer wrong. It should return new stamp, instead in mutates the existent. Sorry, totally my fault. Here you go:\njs\nconst DbClient = stampit().static({\n  use(collectionName, mongooseSchema) {\n    return this.refs({ db: mongoose.model(collectionName, mongooseSchema) });\n  }\n});\n3) Would you please shorten your question?\n. Avoid using static functions @michaelswe. Use regular stamps for do everything. This \"remove\" function looks misplaced and redundant as to my taste.\nThe sole idea of stampit is to be able to compose any behavior. Utilize \"stampit().methods()\" as much as you can. Answering your qestion: no, it is not.\n. @tcrosen I read it through, with comment. Confirming. You got the idea of stamps right. So very right!\nFew suggstions which you shouldn't blindly follow.\n- Maybe rename Customer to ConstomerDetails.\n- Modal is not necessary to have OK and Cancel buttons. I'd recommend moving these two handlers (ok and cancel) to a new stamp, like OkCancelModal.\nWhat elegant solution you are looking for the sendToApi? It should be straightforward IMO.\nNamespacing in JS is easy to google. :)\n\ncan I do something like this to avoid generic \"show\" properties on every object?\n\nI didn't get the question. Sorry.\nPlease, consider asking your questions here: https://gitter.im/stampit-org/stampit\nYou'll get faster responses.\n. Hi @nathanmarks\nGreat question. I did few benchmarks with stampit v1 and v2 in the past.\nBut first, let me remind few known statements:\n1) Premature optimization is the root of all evil. (D. Knuth)\n2) Fix performance only after you identified the bottleneck. (M. Fowler)\n3) This is not your bottleneck. (E. Elliott)\nFew months ago I did the \"Performance in JS\" presentation at a large meetup. Here are the very descriptive slides.\nAnswering your question.\nThis is how stampit creates objects (roughly):\njs\nconst instance = Object.assign({}, stamp.properties); // 1\ninstance.__proto__ == stamp.methods; // 2\nstamp.initializers.forEach(initializer => { // 3\n  instance = initializer.call(instance, { instance, stamp, args }) || instance;\n});\nNo magic. :)\nAs you can see\n- step 2 is very fast.\n- step 1 can be slow if there are many properties (aka state, aka refs/props).\n- step 3 can be slow if there are many initializers.\nThus, the fewer state and fewer initializers you have - the faster the object creation. Number of methods does not influence object creation performance at all.\nThe last time I did a performance measurement of the stampit v2 it was significantly (x10 times or more) slower than the new keyword of a similar class. So, if you are creating millions of objects per second  then you should consider not using stampit. But, if it is thousands or less then stampit is the right choice.\nFor more live communication please ask your following questions here: https://gitter.im/stampit-org/stampit\n. @davewallace Sound like you read that article. \ud83d\ude04 \nSo, basically @FredyC said everything I wanted to say. \ud83d\udc4d \nIt is very interesting to me to see what you (will) come up with as a result. Please, keep us updated. Cheers!\n. Also, we have few advanced examples here. They are for stampit v2. But can be easily converted to the stampit v3.\nI'll fantasize a bit below:\n``` js\nconst HaveAbilities = stampit()\n.methods({ \n  addAbility(name, value) { ... }, \n  getAbility(name) { ... }\n})\n.init(function (opts, {stamp}) {\n  // Iterating over the abilities which the character can actually have\n  stamp.compose.configuration.abilities.forEach((ability) => {\n    this.addAbility(ability, opts.getAbility(ability));\n  });\n})\n.statics({\n  predefined(abilityNames) {\n    // storing the abilities in configuration\n    return this.configuration({ abilities: abilityNames.filter(_.isString) });\n  }\n});\nconst Elven = HaveAbilities.predefined(['archer']);\nconst Mage = HaveAbilities.predefined(['spell-caster']);\nconst SpellBook = stampit()\ndeepProps({ spells: {} })\n.methods({ \n  addSpell(name, value) { this.spells[name] = value; }, \n  getSpell(name) { return this.spells[name]; } \n})\n.init(function (opts) {\n  // The character never looses any known spell (unlike abilities)\n  this.spells = opts.spells;\n})\n.statics({\n  predefined(name, value) {\n    // storing the spells in deepProps because these CAN be accumulated\n    return this.deepProps({ spells: { [name]: value } });\n  }\n});\nconst Ice = SpellBook.predefined('ice-arrow', ...).predefined('freeze', ...);\nconst Fire = SpellBook.predefined('fireball', ...).predefined('sparks', ...);\nconst Hero1 = stampit(Elven, Ice, Mage);\nlet hero = Hero1();\nconst Hero2 = stampit(Elven, Fire, Mage);\nhero = Hero2(hero);\n```\nHave never tested that. :)\nTell me if you need any explanations.\n. Closing this for now. Not visited for a year.\nFeel free to open any new issues.. Done. See #155\n. We can reference those functional mixins in stamp wikipedia page. Huh?\n. Functional mixins got continuation. With ES7 decorators it looks very much alike composables but with a different syntax. Read here: http://raganwald.com/2015/06/26/decorators-in-es7.html\nThe composition syntax looks like this:\njs\n@BookCollector @Author\nclass BookLover extends Person {};\nWhere BookCollector, Author are composable behaviors (mixins) and the Person is ES6 class.\nI see several downsides of this approach. Anyone else see them?\n. Let me start with a quote:\n\nsocial networks rank strategies prioritize the popular and habitual\n\nI would rephrase to:\n\npeople prefer the popular and habitual\n\nClasses are habitual. Decorators are popular in C# and Java (and few other languages). It's logical to see people (re)implementing the same in all other new languages like JavaScript.\nThe downsides listed by Eric above are pretty much applicable to the decorators too.\n- You won't be able to compose two classes, and you won't be able to compose two decorators only (without a class, or method, or else). You'd have to decide which behavior would be a class, and which is a decorator. \nIt is a very, very hard choice. Trust me. I did that for years in C#.\nAlso, stampit deliberately avoid class, constructor, new and instanceof keywords applications to stamps. These are antipatterns in JS (see Eric's link above).\nAdditionally, while applying decorators you need to know which object they are applicable to: class, method, data, etc. Whereas in stampit you just .compose().\nThe JavaScript property descriptors (aka Object.defineProperty) with all the bells and whistles are coming to stampit v3. And they are already implemented and described here: https://github.com/stampit-org/stamp-specification\nSaying all that I am thinking of using decorators and stamps together. They can be a good match!\n. +1\n. Can you please paste a code sample? Otherwise, I'm not quite getting what's wrong. \nThanks \n. Hold on. I think I know what you mean. Checking it now.\n. I cannot reproduce your issue. The following works as expected.\n``` js\nconst stampit = require('../src/stampit');\nconst EventEmitter = require('events').EventEmitter;\nconst EventEmittable = stampit.convertConstructor(EventEmitter).init(() => {}); // added init here!\nconst User = stampit.refs({ name: { first: \"(unnamed)\", last: \"(unnamed)\" } });\nconst EmittableUser = User.compose(EventEmittable).init(() => {}); // added init here!\nconst user = EmittableUser({ name: { first: \"John\", last: \"Doe\" } });\nuser.on('name', console.log); // Does not throw exceptions like \"user.on() has no method 'on'\"\nuser.emit('name', user.name); // correctly handled by the object.\n```\nCould yuo please paste your code?\n. Code, mate!!! I need your code!!! :)))\n. Thanks for the info. node v0.12 fails. But node 0.10 does not.\nI'll fix that today asap.\n. Yes. That's the issue I have found so far too. Let me dig in few more minutes. I'll get back to you shortly.\n. Sigh. Run this:\njs\nconst EventEmitter = require('events').EventEmitter;\nconsole.log(EventEmitter);\nIt prints\n{ [Function: EventEmitter]\n  EventEmitter: [Circular],\n  usingDomains: true,\n  defaultMaxListeners: 10,\n  init: [Function],            <--\n  listenerCount: [Function] }\nAs you can see they introduced the new init \"static\" function. :) Bummer! It's not referenced in the docs. This function overrides the stamp's init function (that's by design).\n@mdhooge Do have a proposal how to fix the example?\n. > It should override the overridden .init() (restoring stampit's .init()).\nNope. It won't help. statics are applied to any new stampt the last.\n. > maybe we should deprecate the built-in static methods?\nNo! Never! I use it a lot. A huge lot. :)\n. @mdhooge if you're okay to read code then this is where it happens: https://github.com/stampit-org/stampit/blob/master/src/stampit.js#L256\nAnd the fixed.static is being filled here https://github.com/stampit-org/stampit/blob/master/src/stampit.js#L278\n. oh! I agree about stampit/tools. I'd move there the convertConstructor. But, please, not the props or compose. These are essential to each LOC I use stampit at. I literally use only stamp.props and stamp.compose.\n. See my prod code:\nRestClientFactory\n  .compose(Prevailable)\n  .props({body: {...}})\n  .methods({...})\n  .init(() => {...})\n  .prevalidate({put: {body: joi.required()}});\nPlease, rewrite it with your proposal syntax. :)\n. @mdhooge You can use enclose() function instead of init() function. These are aliases. The first code I've written above will work easily if you replace init with enclose.\n. Eric, there is a way to solve stamp static name collision with...\nanother composable stamp! ta-dam, dshhhhh...\n. Your first code sample, Eric, loses whole point of composability. :)\nWhereas the second one looks fine, however you are missing the looong import statement on top. :)\n. Compare to:\n``` js\nimport stampit from 'stampit';\nRestClientFactory\n  .compose(Prevailable)\n  .props({body: {...}})\n  .methods({...})\n  .init(() => {...})\n  .prevalidate({put: {body: joi.required()}});\n```\n. @mdhooge sorry mate we are spamming you here. Have a good day. :)\n. As I said, we can compose one more stamp.\njs\nRestClientFactory\n  .compose(GuardStatics, Prevailable)\n  .props({body: {...}})\n  .methods({...})\n  .init(() => {...})\n  .prevalidate({put: {body: joi.required()}});\n. @mdhooge Warning! PSEUDO CODE! Not tested I mean :)\njs\nvar GuardStatics = stampit().static({ static: function(staticProps) {\n  return this.static(_.omit(staticProps, ['init', 'props', 'refs', 'methods', 'compose', 'create']));\n});\n. The possible GuardStatics implementation (warning, it's not complete!):\njs\nvar GuardStatics = stampit().static({ static: function(staticProps) {\n  return this.static(_.omit(staticProps, ['init', 'props', 'refs', 'methods', 'compose', 'create']));\n});\n. > Introduces _.omit dependency\nRemove this line please. :) This was a pseudo code. Not a real code. The real code will have no dependencies.\n. > Doesn't mix invisibly with functional programming\nThe entire stampit philosophy is not about functional programming. It's about objects which have both state and methods.\nPlease, remove this statement as irrelevant.\n. > Now we have a user education problem -- a gotcha users must avoid that requires somewhat advanced knowledge of stampit\nI was thinking to guard stamp's methods inside the stampit itself, so this problem would never arise. However, that's the way @troutowicz implemented statics.\n. > Work-around is much less intuitive (it's a work-around, not a solution)\nThat's not a workaround which @mdhooge was talking about. He's using .enclose() alias. Please rephrase this statement.\n. > So end-users don't have to know about GuardStatics? How will that work, exactly?\n:)))\nI'll flip 2-nd and 3-rd argument in this mixin function call. And done! :)\nhttps://github.com/stampit-org/stampit/blob/master/src/stampit.js#L189\n. js\ncompose(\n  props({body: {...}),\n  methods({...}),\n  init(() => {...}),\n}).prevalidate({put: {body: joi.required()}});\nOn top you are missing 'Prevalidable` stamp to be composed with. \n. This all comes to #80.\nWe can have refs, props, compose, init, methods as keywords, as a language syntax.\n. > Probably faster\nNo, it is not. \nI know stampit internals. :) It'd be same. The main performance bottlenecks are various mixin and forEach functions.\n\nProbably slower\n\nNo it is not by the same reason.\nPlease, remove both. Thanks.\n. I'd rather be lodash like.\njs\nimport _ from 'lodash'; // <- imports entire module\nimport {map, forEach, pick, filter} from 'lodash'; // <- imports few methods only\nstampit:\njs\nimport stampit from 'stampit'; // <- stampit v2 compatible\nimport {compose, init, props, methods} from 'stampit'; // <- the new functional way, v2 incompatible\nHow about that?\n. Maybe even have something like \"babel/register\" but:\n``` js\nrequire('stampit/register');\nObject.compose;\nObject.init;\nObject.props;\nObject.methods;\n// or maybe even as global variables :)))\ncompose;\ninit;\nprops;\nmethods;\n```\n. This talk is coming to class-like syntax support. (Eric, this is a pseudo code, not something well-though and tested.)\n``` js\nstamp StampName {\n  init() {} // .init\n  method1() {} // .methods\n  static method2() {} // .static\n  get reference1() {} // .refs\n  set reference1() {} // .refs\n  property1: { deep: 'value' } // .props\n}\nstamp ComposedStamp composes StampName, SomeOtherStamp; // like \"extends\" in classes\n```\n. > Less modular approach\n@ericelliott would you elaborate on that? How more modular stampit can be? (I'm really curious.)\n. The discussed functional approach does not solve the static collision of the .fixed property.\n. The proposed changes are too radical. Every bit of the new module will be incompatible with both v1 and v2. We should consider a separate package for that. \"stampit-functional\" or alike.\n. I like the idea of Open Stamps Standard.\nTake a look at promises: https://promisesaplus.com/\nIt operates the so-called \"then-able\" objects. Should we come up with \"create-able\"?\njs\n_.isFunction(someObject.create); // true\n_.isArray(someObject.create.inits); //true (we should rename the \"init()\" somehow.\n_.isObject(someObject.create.refs); //true\n_.isObject(someObject.create.props); //true\n_.isObject(someObject.create.methods); //true\n_.isObject(someObject.create.statics); //true\n. In the Open Standard the word \"stamp\" is not going to be understood straight enough. Take promises/futures for example. They are widely known concepts.\nIn the Open Standard we should call our stamps \"functional mixins\". It will be easier to understand, and also there is a widely known concept.\n. > What about \"composable factories\"?\nAlso good. Even better I think. :)\n. Thinking of Open Standard.\nFunctions are the first class citizens in JavaScript. I was worried all the time that stamps cannot produce functions as object instances.\nThere is always a workaround via .init(() => { return function () {}; })\nBut as Eric says \n\nit's a work-around, not a solution. Now we have a user education problem\n\n\nI believe that the .create() function should accept not refs object, but the object itself.\n``` js\nMyStamp(); // creates new object\nconst plainObject = { key: value };\nMyStamp(plainObject); // returns the plainObject object\nconst myFunc = function whatver() {};\nMyStamp(myFunc); // returns the myFunc object\n```\nThoughts?\n. More thinking about Open Standard.\n- If stamp.create() argument is not an object (lodash check should be used _.isObject) then no refs or props should be added obviously. But all the init() functions should be called regardless.\nIn other words, stamps should flawlessly process any object. No exception, no warning, nothing. The type of the processed object should be up to the user. (Just like promises do.)\nIn the following example I'm using sound processing terminology:\n``` js\nconst Cutoff = compose(\n  refs({ min: 5, max: 250 }), \n  init(function({ instance }) { \n    return instance < this.min ? this.min : \n      intance > this.max ? this.max :\n      instance; })\n);\nconst Aplify = compose(\n  refs({ factor: 2.5 }), \n  init(function({ instance }) { return this.factor * instance; })\n);\nconst Amplificator = compose(Aplify, Cutoff);\nAmplificator(200); // returns 250 because 2002.5 is more than 250 cutoff upper limit\nAmplificator(20); // returns 50 beacuse 202.5 is within the cutoff range 5-250\nAmplificator(0); // returns 5 because 0 is less than 0 cutoff lower limit\n```\n. Yep. In the gitchat we all agreed that there's no need to change the name.\n. This issue was overtaken by the repo. I'm not seeing the original idea implemented.\nI propose to close this issue. Any objections?\n. Wonderful! Thank you very much.\nOn Thu, 23 Jul 2015 03:27 Eric Elliott notifications@github.com wrote:\n\nBefore you use this distribution, consider using the NPM distribution\ninstead; Bower usage is declining rapidly.\n<3\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/150#issuecomment-123799259\n.\n. I believe @sethlivingston made a rational proposal. CDNJS better contain UMD modules, not the CommonJS as it is now.\n\nOr CDNJS better be CommonJS thing?\n. @sethlivingston Can you address the posting the bower disctibution to CDNJS please?\nWe'd be happy to have this finally sorted. :)\n. Wonderful ending!\n. It was superseded with stampit, and incorporated into stampit repo.\nWhy?\nOn Thu, 2 Mar 2017, 23:22 Harm van der Werf notifications@github.com\nwrote:\n\nThe Bower release repo\nhttps://github.com/stampit-org/stampit-bower/issues is down/no longer\nsupported?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/150#issuecomment-283639509,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABjCLxnlnGJ8H3T083YBr_61FPHo0Pdvks5rhrSUgaJpZM4FVISg\n.\n. Could you please explain what does that output mean? I'm not a bower user. . Since you're specifying the strict stampit version (\"3.0.0\"), would copying a dist file help? \nhttps://unpkg.com/stampit@3.1.2/dist/. Ok. I'll try reregister in 24. It's midnight here. . Personally, I would encourage to use npm over bower.\n\nThanks for reporting. I'll fix asap.\nOn Thu, 2 Mar 2017, 23:41 Harm van der Werf notifications@github.com\nwrote:\n\nSure thing. I took your advice and used it like this:\n\"stampit\": \"git://github.com/stampit-org/stampit.git#3.1.2\"\nThis works!\nWithout the repo link it doesn't, even with a version of 3.1.2\nSo I'm pretty sure a re-registering will work. Doesn't seem a bower.json\nin the repo is required, but I'm not sure about that.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/150#issuecomment-283643281,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABjCLysTaDdbR5KP55iBbrl5P9b3nrKfks5rhrjegaJpZM4FVISg\n.\n. Hi @harm-less \nSorry for the late reply.\n\nI'm thinking of staying off bower specific repo/support because bower is so cool that you can install any package like this: https://github.com/reactjs/redux/pull/1181#issuecomment-167361975\nIn stampit's case it's like this: \n$ bower install stampit=https://npmcdn.com/stampit@3/dist/stampit.umd.js\nor\n$ bower install stampit=https://npmcdn.com/stampit/dist/stampit.umd.min.js\nOr maybe like this (I didn't try yet):\n$ bower install stampit=https://unpkg.com/stampit@3/dist/stampit.umd.js\nor\n$ bower install stampit=https://unpkg.com/stampit/dist/stampit.umd.min.js\nAFAIK bower is mostly used for the browser side package management. Is it your case too?. Created an anniversary PR #300 to explain how to install stampit via bower.. @harm-less Looks like I fixed bower. Now bower install stampit will download latest stampit version. :). I revived the bower stampit at ~ 2017-03-05T13:00:00Z UTC\nHave you tried bower install stampit after that time?\nIf you want me to publish all the previous stampit versions (including v2.0.3) to bower - tell me.\n\n\nIt would of course be best if the Bower repo also natively supported the most used/stable versions of Stampit there\n\nAFAIK it does now (starting yesterday).\n\nWe have a build system via rollup which generates few kind of builds. Check these out: https://unpkg.com/stampit@3.1.2/dist/\nAnd we have the build script which is used to create bower releases.\nSo, it's pretty automated and easy to do bower releases for me.. Ah, I see what you mean. Sorry!!! I forgot to push the git tags. :(\nShould be good now :)\nHere is the list of bower versions:\n```sh\n\ngit push --follow-tags\nCounting objects: 7, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (7/7), done.\nWriting objects: 100% (7/7), 1.14 KiB | 0 bytes/s, done.\nTotal 7 (delta 0), reused 0 (delta 0)\nTo https://github.com/stampit-org/stampit-bower.git\n * [new tag]         v1.0.2 -> v1.0.2\n * [new tag]         v1.1.0 -> v1.1.0\n * [new tag]         v1.2.0 -> v1.2.0\n * [new tag]         v2.0.2 -> v2.0.2\n * [new tag]         v2.1.0 -> v2.1.0\n * [new tag]         v3.0.6 -> v3.0.6\n * [new tag]         v3.1.2 -> v3.1.2\n```\n\nNow this works fine: bower install stampit@2.0.2\nPlease try again.\nSorry again. I'm so new to this bower thing :). Glad to hear!\nCheers mate\nOn Tue, 7 Mar 2017, 07:27 Harm van der Werf notifications@github.com\nwrote:\n\nAwesome! Now it works like Bower (and I) expects ;)\nI'm only missing 2.0.3, but I'll use 2.0.2 instead, that's probably no\nproblem.\nSo far my experience with Stampit has been great! In practice it luckily\nmakes a lot of sense as it seemed like it had a steep learning curve when I\nwas reading about it. So thanks for this awesome library, you've gained a\nprototypal enhousiast ;)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/150#issuecomment-284521567,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABjCL4geDzzi8cqRFg-UMaZaHbz5MjcLks5rjGwZgaJpZM4FVISg\n.\n. Thinking of Open Standard.\n\nFunctions are the first class citizens in JavaScript. I was worried all the time that stamps cannot produce functions as object instances.\nThere is always a workaround via .init(() => { return function () {}; })\nBut as Eric says \n\nit's a work-around, not a solution. Now we have a user education problem\n\n\nI believe that the .create() function should accept not refs object, but the object itself.\n``` js\nMyStamp(); // creates new object\nconst plainObject = { key: value };\nMyStamp(plainObject); // returns the plainObject object\nconst myFunc = function whatver() {};\nMyStamp(myFunc); // returns the myFunc object\n```\nThoughts?\n\nMore thinking about Open Standard.\n- If stamp.create() argument is not an object (lodash check should be used _.isObject) then no refs or props should be added obviously. But all the init() functions should be called regardless.\nIn other words, stamps should flawlessly process any object. No exception, no warning, nothing. The type of the processed object should be up to the user. (Just like promises do.)\nIn the following example I'm using sound processing terminology:\n``` js\nconst Cutoff = compose(\n  refs({ min: 5, max: 250 }), \n  init(function({ instance }) { \n    return instance < this.min ? this.min : \n      intance > this.max ? this.max :\n      instance; })\n);\nconst Aplify = compose(\n  refs({ factor: 2.5 }), \n  init(function({ instance }) { return this.factor * instance; })\n);\nconst Amplificator = compose(Aplify, Cutoff);\nAmplificator(200); // returns 250 because 2002.5 is more than 250 cutoff upper limit\nAmplificator(20); // returns 50 beacuse 202.5 is within the cutoff range 5-250\nAmplificator(0); // returns 5 because 0 is less than 5 cutoff lower limit\n```\n. What about the following idea.\nTake a look at this stamp:\njs\nconst Connection = compose(\n  refs({ url: { host: 'localhost', port: 80 } }), \n  init(function({ stamp, instance }) { this.clone = () => stamp(instance); }),\n  methods({ connect() {...} })\n);\nI see that refs, init, and methods are repetitive.\n- init always receives a function.\n- refs always receives an object with data.\n- methods always receives an object with functions.\nWhy won't we simply ducktype those? The order and number of the arguments should not matter. The following should produce the same stamp as above. \njs\nconst Connection = compose(\n  function({ stamp, instance }) { this.clone = () => stamp(instance); },\n  { url: { host: 'localhost', port: 80 } }, \n  { connect() {...} }\n);\nSuch a nice shortened syntax gives the idea that the compose is not the best name for the function.  I believe stamp would serve better.\nThoughts?\n. Another proposal which I strongly believe is for the best.\nRename methods to proto.\njs\nsomeObject.create.proto\nWhy?\n- Because essentially the methods object becomes the prototype of instantiated objects.\n- Becuase people would like to attach a RegExp, or a plain object, or a bunch of constants to the proto. The standard must not constrain developers' creativity.\n. Take this code\njs\nconst Connection = compose(\n  function({ stamp, instance }) { this.clone = () => stamp(instance); },\n  { url: { host: 'localhost', port: 80 } }, \n  { connect() {...} }\n);\nIt looks very much alike class declaration: constructor, property url, method connect.\nBut what if we had only single function stamp which does it all - creates new stamps, composes existing?\njs\nconst Connection = stamp(\n  function({ stamp, instance }) { this.clone = () => stamp(instance); },\n  { url: { host: 'localhost', port: 80 } },\n  { connect() {...} },\n  SecondStamp\n);\nAnd then the stamps can be composed:\njs\nvar ComposedConnection = stamp(Connection, ThirdStamp);\nI like this syntax very much. :)\nP.S. Ducktyping rocks. :)\n. ##### Statics and deep properties.\nProposal syntax.\n``` js\nimport {stamp, deepProps, statics} from 'stamp';\nconst Connection = stamp(\n  function({ stamp, instance }) { this.clone = () => stamp(instance); },\n  { url: { host: 'localhost', port: 80 } },\n  { connect() {...} },\n  statics({ printUrl: function () { console.log(this.url); } }),\n  deepProps({ url: { protocol: 'https' } }),\n);\n```\nAlternatively, statics can be added directly to a stamp. It should be identical to the statics above:\n``` js\nConnection.printUrl = function () { console.log(this.url); };\nconst ComposedConnection = stamp(Conneciton, SecondStamp);\nComposedConnection.printUrl(); // <-- should not throw\n```\n. @ericelliott descriptors should be implemented using decorators I believe. \n. https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841\n. Eric, I agree to all your suggestions. Especially \n\ncode should be optimized for reading, not writing\n\nBut this one I tend to disagree with because it ruins readability you've just mentioned:\n\nI think we should rename refs back to state.\n\n\"refs\" is explicitly saying that \"I'm going to shallow copy your data\".\n\"state\" doesn't say if it gets shallow copied or deep copied.\n. Take promises for example. They just work. The only global variable which got introduced is Promise solely to create new promise chains.\nYou don't need to import Promise from 'Promise' if all you need is to continue execution:\njs\ndb.getById(123).then( bla bla bla ); // <-- See? No need to import stuff\n\nWe also don't want people to import stamp each the time they need to extend a stamp with one more method.\nMoreover, \"createable\" should sound like \"I can create\", but actually sound like \"I can be created\". Confusing a little. Right?\nSo, maybe we should rename \"creatable\" to \"stampable\", i.e. an object which can be stamped?\nBenefits:\n1) Any stamp can be extended/composed by simple MyStamp.stamp({ init: function() {} }) or alike.\n2) No need to extra import stamp.\n3) I feel that functionality is duplicated by MyStamp() and MyStamp.create() calls. We don't need both. One is enough.\n4) People familiar with promises will understand the idea of stamps easier.\n5) The create word is used in programming more often than stamp. There'll be less collisions.\nIMO this would be an ideal world if such thing would exist.\nThoughts?\n. Another good name for \"stampable\" could be \"composable\". This one is even better!\nAnalogies:\n- Promise ~ Stamp\n- Thenable ~ Composable\n- somthing.then() ~ something.compose()\n. Eric, please hear me.\nFunctionality is duplicated by MyStamp() and MyStamp.create()\nThat's why we should drop the .create and have a .compose instead.\n\"Less is more\" you said in your recent tweet.\n. I'm confused with the Tim examples.\nWhat's \"base object\"? AFAIK there's no such thing as base or parent object.\nI'll get home and will post a complete set of examples as I see it.\nOn Sun, 12 Jul 2015 14:59 Eric Elliott notifications@github.com wrote:\n\nTypos from phone. :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/151#issuecomment-120687335\n.\n. #### The complete Open Composables Standard as I see it.\n\nStamp()\n\nA function.\nCreates stamps, aka composables.\nAccepts any number of arguments in any order. They can be either composables or stamp-description objects.\n\n`` js\nimport Stamp from 'stamp'; // alternatively the Stamp can be global likePromise` in ES6\nconst composable = Stamp(\n  { // a stamp-description object with the following properties (names are far from final)\n    methods: ... \n    assign: ...\n    run: ...\n    merge: ...\n    statics: ...\n  },\n  anotherComposable // a composable. There can be more arguments\n);\n```\ncomposable()\n\nA composable factory function.\nCreates (or mutates base) objects using its stamp-description object.\nAccepts a base object as the first parameter. Following parameters are passed as args. to the run() functions.\n\n``` js\n_.isFunction(composable); // true\nconst obj = composable(baseObject, args...); // creates objects.\n```\ncomposable.compose()\n\nA function, as well as the stamp-description object.\nCombines multiple composables and stamp-description objects into a new composable.\nAccepts any number of arguments in any order. They can be either composables or stamp-description objects.\n\n``` js\n_.isFunction(composable.compose); //true\nvar combinedComposable = composable.compose(\n  anotherComposable, // a composable\n  { // a stamp-description object\n    methods: ... \n    assign: ...\n    run: ...\n    merge: ...\n    statics: ...\n  },\n  thirdComposable // one more composable, etc. etc. etc.\n);\n// stamp-description properties (far from final list and names)\n.isArray(composable.compose.initializers); //true - optional (format of the object is yet to decide)\n.isObject(composable.compose.references); //true - optional (format of the object is yet to decide)\n.isObject(composable.compose.properties); //true - optional (format of the object is yet to decide)\n.isObject(composable.compose.methods); //true - optional (format of the object is yet to decide)\n_.isObject(composable.compose.statics); //true - optional (format of the object is yet to decide)\n```\n----- The end. Finita. Basta. Fin. -----\n\nThe above is the entire Standard. Do you see how short the Open Composables Standard can be? \n\nLess is more (C) Eric Elliott\n\nThe things described in the initial top message of this thread are handy ecosystem utilities similar to Promise.all() or Promise.reject() or Promise.resolve() etc. And I actively like it and support it very much! Although, they should not be part of the core specs.\n. @troutowicz \n\nI think we should drop any uses of \"stamp\" from the spec and use \"composable\"\n\nThink of an analogy: Stamp=Promise, Composable=Thenable.\n(Also \"composable\" is too long word as for me.)\n. @JosephClay \n\nDefine how assign/merge/statics are merged. Which are deep, which are not, which use Object.assign and which use Object.defineProperties etc...\n\nI have most of that in my head. Should be written down instead though.\n\nDefine what happens if \"invalid\" configurations are passed. What happens to foo in .compose({ foo: 'bar' }).\n\nTypeError should be thrown in most (if not all) cases.\n. @JosephClay \n\nWhat's the context of initializers?\n\nThe initializer function binding:\n1) If the object instance _.isObject then the initializer will be bound to it.\n2) If the object is not _.isObject then the initializer will be bound to the mergeUnique(Object.assign({}, references)) temporaty object (the mergeUnique is the supermixer function).\n\nWhat parameters are passed?\n\nInitializers receive the same thing as they receive in stampit v2 - { stamp, instance, args } object.\n. @JosephClay \n\nI believe we have to define the terms we use in the spec, otherwise the interpretation is arbitrary (e.g. merge, references vs properties etc...).\n\nDefinitely! Any proposals?\n\nTerminology\n(please, speak if you don't like)\nThe word composable is we mutually agreed with I believe.\nI strongly like the word Stamp. Firstly, because it's short. Secondly - because it's a brand name.\nI propose to use stamp-description object or simply stamp descriptor. Ok?\nI like assign and merge words because they imply what will be done to my data. How do you feel about it?\nI'm okay with the methods word. We all agreed on that. (Although, I secretly like proto.)\nI'm okay with statics. I doubt someone might find a better name for it.\nI'm still thinking of better name for the initialize. That's why in my above examples you can see run.\n\nDid I miss anything?\n. The factory implementation pseudocode (not taking into account the defineProperty stuff, because it's hard):\njs\nfunction factory(instance, args...) {\n  const context = _.isObject(instance) ? instance : {};\n  _.merge(context, this.compose.merge);\n  _.assign(context, this.compose.assign); // references are taking over deep props\n  context.__proto__ = this.compose.methods;\n  this.compose.initializers.forEach((init) => {\n    const result = init.call(context, { instanace, stamp: this, args });\n    if (!_.isUndefined(result)) {\n      instance = result;\n    } \n  });\n  return instance;\n}\n. @JosephClay I believe you are largely confused on what stamp is. :)\n\ncomposable: a factory function that creates stamp instances.\n\nComposable and Stamp are essentially the same thing. Have you heard of Thenable and Promise? It's the same.\nComposable is a function which have property .compose which is also a function.\nStamp is a Composable with predefined structure (which we are discussing here).\n\ncompose: a function that combines stamps and plain objects into a new stamp descriptor.\n\ninto a new stamp, but not descriptor.\nIMO stamp descriptor is a part of stamp, but not the stamp itself.\n\nstamp: an object returned from a composable factory using a stamp descriptor.\n\nI didn't quite caught this sentence.\n\nassign: a shallow map of property name and values attached to the stamp on stamp creation.\n\nattached to the stamp, but assigned to new instance objects created by the stamp. Correct?\nSame goes for merge.\n\nmethods: a map of property name and function values that are added to the stamp's prototype on stamp creation.\n\nWrong. Stamps do not have prototypes. Object instances created by the stamp do have prototypes.\n\nstatics: a map of property name and values attached to the composable.\n\nattached to a stamp (aka composable).\n\ninitialize: a function to be executed against the stamp's scope on stamp creation.\n\nVery wrong. :) Stamp is a factory function, it creates objects!\na function to be executed against the stamp's scope on object instance creation.\n\ninstance: the current context of the initializer.\n\nNope. Instance is the object being created (stamped). Most of the time instance is the initializer's binding context.\n\n{writeable: false} will throw an exception on merge when x\n\nI'm hugely against any exceptions. Long to explain, but this is to implicit. Sometimes object creation will throw, sometimes will not... Inconsistency sucks. Better skip conflicting properties.\n. @ericelliott we need to discuss this radical and largely confusing method.\nstamp(baseObject, stamps...) => objectInstance\nHow come we pass both user data and composables one next to another? \nWhat about easy private state (arguments passed to the init functions)? \n. I went through the top message of this issue. I think I like every part of it. \nThere's one function name choice which will not lint in most projects.  The set function name.\nAny better names you have in mind people? \n. Let's move our discussions to the special repo: https://github.com/stampit-org/stamp-specification/issues\nPlease, create new issues to disccus each particilar topic.\n. > Why won't set() lint? It should.\nYep. Double checked with couple of linters intalled on my machine. They all accept such properties. Good.\n. Seems like we have migrated all the idea we had here. Closing this one in favour of the new repository. Initial post updated accordingly.\nTahnks people for the productive discussion. Cheers.\n. Should we add the .gitattributes to .npmignore?\nP.S. This is a \".ignore hell\". :)\n. 1. We have \"browserify\" in devDependecies. Why not reuing it?\n2. We should not store dist/ files in the git repo.\n3. The bower should be published with an npm command, like npm run bower. It should generate the bower-ready files, publish them.\n4. The dist/ files should be ingnored in both .gitignore and .npmignore.\n. I beg your pardon.\n\nThe dist/ files should be ingnored in both .gitignore and .npmignore.\n\nI meant not the entire directory, but just the newly generated files.\nBy putting the dist directory into the .npmignore we are breaking npm publishing process. The thing is stampit is traspiled from ES6->ES5 so that other projects could use the module. The ES5 files are stored in the /dist directory. See the package.json line:\n\n\"main\": \"./dist/stampit.js\",\n\nBut knowing how bower works I understand why people are creating separate repositories for package management.\nThe /dist/stampit.js and /dist/stampit.min.js files are standard CommonJS files which are published to NPM. People expect them to remain CommonJS.\n. I believe we should:\n1) Create a new repo for bower packages.\n2) Give the full control to @sethlivingston and full freedom of implementing/maintaining it. :)\nHow about that?\n. Thanks @sethlivingston !\nI'm closing this one. Have a good fun with the new repo. :)\n. Hello there! Timely request my friend.\nWe do plan to have this in the following stampit release. Like:\njs\nvar myAwesomeObject = ...whatever...;\nif (myAwesomeObject === MyStamp(myAwesomeObject)) { // comparing by reference\n  console.log('Yes, baby!'); // this should be printed.\n}\nIs that the feature you're looking for?\n. @rektide hey?\n. Closing as the person is not contacting back.\n. Sure we can an we will with the following PRs. One thing at a time Tim.\nAlso, you can merge this one and create a new one with the changes you've\njust proposed.\nIs this API.md okay to merge?\nOn Wed, 15 Jul 2015 01:43 Tim Routowicz notifications@github.com wrote:\n\nCan we remove this documentation from the README and add a link to this\nAPI doc? It might be better to include the example in the README, and link\nto the API doc for more information.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/pull/154#issuecomment-121285759.\n. Sorry for the numerous typos. I was in a hurry. :)\n. :) The typos are in this issue. But the changes got not typos (hopefully). :)\n. Ready to review and merge. Please, check.\n. @troutowicz Done\n. Thanks mate! Appreaciate the speed. :)\n. @JosephClay Good to hear that! I appreciate your honesty. :)\nCan you try and scrub your feelings regarding the two and tell us why silly is better?\n. I'm merging this in 8 hours. :) Alright?\n. Ok. Sure.\n\nOn Thu, Jul 30, 2015, 21:54 Tim Routowicz notifications@github.com wrote:\n\nReal life examples should stay in the advanced examples\nAgreed. :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/pull/158#issuecomment-126292312.\n. Looks like all good. :) \n. Thanks mate. Keep it up!\n. Hello.\nStampit is written in ES6 but compiled down to ES5. So when you are doing import satmpit you are actually getting the ES5 code, not ES6. This is done for backward compatibility. As many other projects do btw.\n\nCheers\n. No worries @michaelswe \nYou're always welcome asking any questions.\nCheers\n. Yeah, but what is \"optional mixin\"?\nThe aim is to strictly follow specs, Eric. Although, I would also like to presereve some compatibility. See the code.\nCompatible stampit v2 and v3 syntax:\njs\nimport stampit from \"stampit\";\nlet stamp = stampit().props().refs().init().methods();\nIncompatible syntax:\n``` js\nimport stampit from \"stampit\";\nlet stamp = stampit().statics({ init: () => console.log(\"created\") });\n// stampit v2\nstamp.init(); // does not print anything!\n// stampit v3\nstamp.init(); // prints \"created\"\n```\nSo, I plan to implement those \"props, refs, init, methods\" chaning methods as simple overridable statics. \nPros: We would brake as less code as possible.\nCons: the only way to get pure stamps is via utility methods: \njs\nimport {compose, merge, initialize} from \"stampit\"\nHow does that sound, @ericelliott ?\n. So, basically, in stampit v3 we change the stampit API significantly again?\n. I'll change the original post of this issue to reflect our decision then.\nGimme 5 minutes please.\nThanks!\n. Sure. I'll reflect it too in the top mesasge.\n. So, we are going back to my original version. :)\nI'm okay with any of the solutions.\n. For better compatibility of stampit with other modules/frameworks it's better stampit to support the new and instanceof operators. The compatibility will allow stampit to be used in a wider range of (legacy?) code bases. See #187 for example.\nAlthough, like it is now, we would discourage JS dev to use the new and instanceof operators as we are doing it now.\nAny objections?\n. What I mean is that #44 \n``` js\nvar Stamp = stampit(bla, bla, bla);\nvar obj = Stamp(ble, ble, ble);\nif (obj instanceof Stamp) {\n // true\n}\nobj = new Stamp(ble, ble, ble);\nif (obj instanceof Stamp) {\n // true\n}\n``\n. Yeah. I would need to show an example. So, in the #187 a person would like to replace classes with stamps and supply them to the Aurelia framework. But he can't, becausenew AStamp()` returns rubbish.\nThis is the Aurelia's code which creates instances of those classes: https://github.com/aurelia/dependency-injection/blob/master/src/container.js#L83\nI wish stampit supported the new keyword, it could have gained wider usage.\n. @BerkeleyTrue Sure. But the world is biased towards the new. I don't think Aurelia and AngularJS will support factory functions just because of stampit.\n. Worlds maybe not compatible. But stampit can be easily made compatible with Aurelia.\n. At the first glance it is doable. Good idea.\n. Stampit Release Candidate v3-rc.0 was just released. npm i stampit@rc\n. Mostly done.\nSome things are looking for an implementer. . Bummer! @ericelliott could you please publish the current stampit master branch as v2.1.1? That'd fix the problem.\n@michaelswe thank you very much!\n. Tested. It works.\n. You probably did missed something.\nShow us the DbLayer.use function contents. It returns garbadge in the second case.\nP.S. To debug I'd recommend you to insert the following into your init function:\njs\nconsole.log(context.stamp.fixed);\n. Okay, then could you please show us the loadFromDb function contents? \n. The issue can be this line:\nreturn this.props({dbSchema: dbSchema});\nThe props will deep copy the dbSchema to each new object. You probably wanted to use refs?\n. Side note: you don't need Promise.resolve(). Simple return instance.setData(data); does the same job.\n. Is there a chance something overwrites the loadFromDb function at some point?\n. Re the Promises: yes you need in in the .catch() handler because you have some code using the error object before moving it forward.\n. IMO your stamp understanding it right. It is a simple concept. What you lack is some JS debudding skills.\nWhy don't you put console.log(app) and see what it prints just before the crash?\nI wanted to tell that before but hesitated. Please, do not take it as an offence, but you have overcomplicated your code.\n0) This sounds like OMG:\n\nI \"ported\" the stamps to a hierarchical ES6 class structure where App extends DbLayer.\n\nPeople are usually doing vice-versa.\n1) You don't need the DbLayer stamp at all. Make it a pure function: getStampForSchema(Schema).\n2) You are nesting the composition instead of making it flat. This code is complicated too much:\njs\nreturn db.one(sql).then(function(data) {\n   return Promise.resolve(instance.setData(data));\n})\n3) Make your behaviours having minimum logic. For example:\n``` js\nlet SecretValidator = stampit().methods({ checkAppSecret(data) { ...\nlet DbUserCredentials = stampit().props(dbUtil.getMasterCredentials());\nlet DbReader = WhereClauseGenerator.methods({ loadFromDb(options) { ... return data; });\nlet DbInstance = DbUserCredentials.init(({instance}) => { instance.pgp = pgp(instance.db); });\nlet Else...\n// in the passport callback\nlet app = model.App();\napp.loadFromDb({id: appId}).then((data) => {\n  if (!app.checkAppSecret(data)) { return false; }\n  return PassportDropInReplacement(data); // <- object the Passport requires\n}).nodeify(done); // <- assuming you are using Bluebird promises implementation\n``\n. Re the nvm. Try:$ nvm install 4`\nSee here: https://github.com/creationix/nvm/issues/821#issuecomment-139025122\n. Also, people are not using pure node but babel to run ES6 code:\n$ npm i babel -g\n$ babel-node my-app.js\n. @michaelswe if you have any questions and you want the answers fast ask them in the gitter: https://gitter.im/stampit-org/stampit\n. This can be anything. Most likely you did nvm use ... but didin't reinstall modules (you should wipe node_modules if you change node version). Am I correct?\n. Babel JS implemented more ES6 features than V8 v4.5 (node v4).\nhttp://kangax.github.io/compat-table/es6/\n. Could be request.js bug fix. Who know! :)\n. No worries. :) Keep it secret.\n. Feel free to close this issue any time. Cheers\n. Could you please elaborate a little. What is \"values in constructors\"?\n. @tcrosen There is no \"construtors\" in stampit. There can be \"intitializers\". The only difference is that a stamp can have multiple initializers, which addup during composition (see .compose() functions).\nAnswering your question: take a look at the .compose(Logger, DefaultConnectionConfig) piece. As you can see we compose the DbConnection stamp with two more stamps. The latter one have single purpose - to set the connectionConfig string property to the instantiated objects: https://github.com/stampit-org/stampit/blob/master/docs/API.md#example\nThus, each time we create an object - DbConnection() - the object will have the connectionConfig set.\nDoes that answer your question?\n. omg. :) Thank you.\n. @tcrosen I've just merged @BerkeleyTrue fix. Take a look now:\nhttps://github.com/stampit-org/stampit/blob/master/docs/API.md#example\nDoes it look right to you now?\n. @tcrosen You probably would like this effort as well: https://github.com/stampit-org/stamp-specification\nWe are trying to make the \"stamp\" a universal concept, so that other stamps from other libraries could be compatible with stampit v3 stamps.\n. Sorry guys. I had to tweet that. :)\nhttps://twitter.com/kore_sar/status/645793395957338112\n. @tcrosen This proves that even if a PR is being twice reviewed one will always have issues.\nThank you for the fix Terry.\n. :+1: \n. @skaapgif I wouldn't say that there is a prefferred way. Both ways work. We need to show them both in the examples.\nP.S.\nAlthough, for stampit v3 we are thinking of removing the instance support from the first agument, and move it to the second argument of the init() functions. :) Sorry for much confusion.\n. > it might be better to introduce that as a separate code sample so that each code sample in the readme only introduces one concept at a time.\n100% agree. PR's are welcome. :)\n. Thank you Rudolf.\n. @astanciu \nHey, mate. WTF?\n. haha! GitHub keyboard shortcuts rock :)\n. Hello.\n1. I'm pretty sure it's not stampit related error. Could you show full error? With the stack trace.\n2. In this file you are exporting not a stamp but an object. Maybe export stamp to match the file name?\n3. In your test the expect(myStamp.sayHello()).toEqual('Hello'); line might fail. I don't see an assetion module in the karma conf, or package.json, or gulpfile.\n4. You put stampit as a devDependency for some reason. Although, you are importing it in src/.\nI believe, questions like this should be asked at Stackoverflow. :) I'd be gald to answer them there.\nCheers!\n. Something is wrong with the build system. gulp build fails exactly the same way.\n. Is the build system config runs browserify twice? Browserifying a browserified code?\n. Is there a reason to not run the tests against the just built build.js?\n. In my opinion the build system is broken. Stampit was tested by thousands of different setups and environments. Have never had an issue.\n. Taking the logs above, @mdix, could you show us this file?\n/var/folders/jf/00gb7hd17yl853ww6sw44pqh5r01xc/T/b452d365a5cb034f23637b1beaf0a743.browserify\nThanks \n. Also, I believe this can be an issue of build babelifying. Stampit is wirtten in ES6, but the main: file is an ES5 babel generated output. Running babel twice on the same file might be causing issues.\n. All we need is the build result of this part:\n``` js\n    preprocessors: {\n        'src/**/*.js': ['browserify'],\n        'spec/**/*.js': ['browserify']\n    },\n\n    browserify: {\n        transform: ['babelify']\n    },\n\n```\nYou can try running the appropriate set of commands manually.\nP.S.\nOne of the reasons I don't like grunt/gulp/karma/etc is because of this bloody maaagic happening behind the scenes.\n. I found the way to keep the temp files.\nComment out the rimraf at the bottom:\nnode_modules/karma/lib/temp_dir.js\n. Yes. I'm browsing it now. :) (Looks legit though.)\n0) In karma.conf.js replace LOG_INFO with LOG_DEBUG.\n1) Comment out the rimraf line in node_modules/karma/lib/temp_dir.js.\n2) Run gulp. The karma should run but not quit.\n3) Take a look at the only file in this folder. It should look like this in the output:\nDEBUG [temp-dir]: Cleaning temp dir /var/folders/zy/c7yfqxq11qz3715xx20h_rrm0000gn/T/karma-70559475\n4) There will be URL. Open it in a browser. Open dev tools -> source. Find there the generated file.\n;)\n. Yes, Eric. It looks like a bug somewhere in PhantomJS, or Karma, or Babelify, or Browserify, or else.\n. I'm closing this issue as not related to stampit.\n@mdix Feel free to create a new one after you find the cause of the problem is actually stampit.\nCheers\n. @mdix Thanks for the followup. I really appreciate that.\nAs usual, any further questions are welcome.\n. Oh. Thanks Terry!\nOn Tue, 20 Oct 2015 01:12 Terry Rosen notifications@github.com wrote:\n\nThe problem is PhantomJS is missing Function.bind.\nInclude the polyfill\nhttps://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind#Polyfill\nand it will work.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/175#issuecomment-149224759\n.\n. You can create a stamp (aka behavior) which would remove duplicate initializers if you really need that kind of thing.\n\n``` js\nconst RemoveDuplicateInitializers = stampit().init(({stamp}) => {\n  stamp.fixed.init = _.uniq(stamp.fixed.init);\n});\nconst C = RemoveDuplicateInitializers.compose(A, B); // it must be composed the first\n```\n. I'm sorry for the typo. Thank you kind person. \n. Oh, wow.\nCan you please help us to reproduce the bug?\nWhat's the version of the node/browser, stampit version, supermixer\nversion, and most importantly the code which lead to this.\nThanks\nOn Wed, Oct 28, 2015, 04:42 sggt notifications@github.com wrote:\n\nI have created a stamp and need two objects from it. But wenn i create the\nsecond one i get a \"Uncaught RangeError: Maximum call stack size exceeded\"\nException in Chrome.\nThe problem from my sight is in that two lines:\n172   var instance = (0, _supermixer.mixin)(create(fixed.methods), fixed.refs, refs);\n 173  (0, _supermixer.mergeUnique)(instance, fixed.props); // props are safely merged into refs\nOn the second call 'fixed.refs' is already merged with fixed.props.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/180.\n. @sggt Hey, thanks for closing it.\nWould you please share what has happened? We need that info in case someone else steps on the same problem. :)\nCheers\n. You are using props. These are for deep copying. If you want to keep references use refs instead (stampit v2 only). See API for more details.\n\nI believe this will solve all your problems.\nPS: in stampit v3 props will be an alias to refs, i.e. it will work as you expected from the beginning.\n. Also, your code can be shortened and optimised. Poke me if you are interested. :)\n. > I thought it would be references shared between all the object created by a given stamp.\n\nThat is correct. Although, (in stampit v1 and v2) you can pass the refs to the stamp.\n\nI'll rewrite some code using ES6. I'm surprised some people are still using ES5. :)\n``` js\nimport {methods, init} from 'stampit';\n// Behaviour which demands the \"this.items[]\" reference to be set from the beginning\nconst ItemsContainer = init(function () {\n  if (!Array.isArray(this.items)) throw new Error('this.items[] was not supplied');\n});\n// Behaviour which makes the items selectable.\nconst SelectableItemList = ItemsContainer.methods({\n          getSelectedItems() { return this.items.filter(i => i.isSelected); },\n      isAllSelected() { return this.items.every(i => i.isSelected); }\n    });\n\nconst ToggleSelectableItemList = SelectableItemList.methods({\n          toggleSelectAll() {\n            const isAllSelected = this.isAllSelected();\n            this.items.forEach(item => {\n              item.isSelected = !isAllSelected;\n            });\n          },\n      toggleSelectItem(item) {\n        const foundOne = this.items.find(i => i === item);\n        if (foundOne) {\n          foundOne.isSelected = !foundOne.isSelected;\n        }\n      }\n    });\n\n// Behaviour which refreshes the the items list with the new customers list from server\nconst RefreshCustomerList = methods({\n        refreshList() {\n          return callServerForRefresh().then(newList => {\n              this.items = newList;\n          })\n        }\n      });\nconst SelectableCustomers = ToggleSelectableItemList.compose(RefreshCustomerList);\nconst selectableCustomers = SelectableCustomers({ items: [{name:'Bob'}, {name:'Ed'}] });\n``\n1. Premature optimisation is the root of all evil. I've removed thethis.isAllSelectedproperty.\n2. I split items container, selection logic, and toggling logic onto different stamps/behaviours.\n3. I removed thecustomers` property. Can't find any reason to keep it.\n4. Most importantly, I remove the \"stubs\" you introduced for methods and properties.\nQuestions? :)\n. Here are the stubs: \n\n. Lately Angular started to promote one-way binding. I think it's better to bind to functions that to properties. :) Although, it's up to you to decide.\nIf you struggle with anything - feel free to ask here. Or even in the gitter chat: gitter.im/stampit-org/stampit\n. I forgot to add. :)\ncustomerList.customers - are saying \"customers\" word twice. I think customerList.items would read better. Same for productList.products -> productList.items.\n. > Although I still feel frustrated that behaviours remain coupled due to property naming, it somehow breaks the beauty of composition.\nFully agree. Any ideas how to avoid that?\n. 1) Object.observe was dropped from ES7. :)\n2) You could use ES6 getter.\n. Yep. :) In stampit v3 this is going to be even simpler. :)\n. Please review and merge #186 fix.\nCheers\n. @b-barry I tried hard to find Aurelia code samples. :) No luck.\nCan you provide few link on the \"Class components\" you've mentioned?\n. I am not aware of \"stampit React for Aurelia\".\nLooking at this code\nhttps://github.com/aurelia/dependency-injection/blob/master/src/container.js#L83\nI thnk that stampit v2 won't work with Aurelia. Simply because stampit discourages using the new keyword.\nHowever, for interoperability sake I believe stampit v3 would need to support the new keyword. People could easily use stamps in the same places they use classes. This means that more people would use stampit. @ericelliott I think have to add the new keyword support to stampit v3. It's beneficial for stampit wider usage.\n. @b-barry looks like stampit v2 stamps can be easily used as a drop-in replacement of classes. The new Stamp() works as expected - creating a new object.\nAlthough, I have never tried that. You could the first. Try it.\n. I had a proposal to accept ES6 classes as stamps to the \"compose\" function:\njs\nclass C {};\nconst Foo = SomeStamp.compose(C);\nBut that's a hard task.\n. First of all, I really-really like the thru idea. I will add up my thoughts later.\nBut first, I'd like to say that stamp specs. should support Symbols out of the box. I.e. Symbols should be treated as usual properties. @troutowicz your thoughts?\n. thru can be useful in some scenarios. I met so far:\n1) debugging, understanding which stamps my object consists of (I got very confused once, accidentally composed same stamp twice).\n2) debugging, finding out which stamp overrode my property and why (solves some other people \"complains\").\n3) statistics - finding out how many times a stamp gets composed.\n4) deprecation warnings (ability to detect that someone is composing a deprecated stamp)\n5) validation (incompatibility warnings/errors, etc).\nThis is what composables specs. lack. I truly believe that thru has to be part of the specs.\nProposed syntax.\nAnother more readable name for the thru method can be postCompose.\nSimilar to the init methods, the postCompose should be able to override the resulting stamp.\n``` js\nconst FooStamp = compose({ postCompose({left, right, result}) { // all three are stamps\n  // logic goes here\n  console.log(left, right, result);\n  // ...\n  return thisWillOverwiteTheResultingStamp;\n} });\nconst AStamp = compose({ methods: { a(){} } });\nconst ResultStamp = FooStamp.compose(AStamp); //prints all: FooStamp, AStamp, ResultStamp\n```\n@troutowicz @unstoppablecarl @JosephClay @sethlivingston @yasinuslu @zebulonj thoughts?\n. I believe the node v5 is working according to the standard\nhttps://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nOn Tue, 29 Dec 2015 09:03 Christopher Hiller notifications@github.com\nwrote:\n\nI am curious about just what the hell Object.assign() is up to in v5,\nhowever.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/188#issuecomment-167665469\n.\n. > why are they specifically excluded from Object.getOwnPropertyNames() and Object.keys(obj) and for(var key in foo).\n\nBecause TC39 do not want to break the web. In other words: because compatibility\n. yep. Quoting the link above about the Object.assign:\n\nBoth String and Symbol properties are copied.\n. This is being further discussed (and then implemented in stampit v3) here: https://github.com/stampit-org/stamp-specification/issues/63\n\nFeel free to discuss if any.\n. The same goal can be achieved using this new feature: https://github.com/stampit-org/stamp-specification/pull/71\njs\n  let counter = 0;\n  function newCompose(...args) {\n    counter++;\n    return compose({staticProperties: {compose: newCompose}}, this, ...args);\n  }\n  newCompose().compose().compose();\n  console.log(counter); // 3\n. Easy! will you submit a PR?\n. Feel free to create new issue. Thanks for the attempt Christopher\n. Hello.\nWe do usual \"github way\". Just create an issue. :)\n. If you feel the contribution protocol should be reflected somewhere then a PR is fine. Somewhere at the end of README is the proper place to have it I think.\n. Hey, you can use \"static\" feature to compose that behavior into your stamps. No need to change stampit. :)\ne.g.:\njs\nstampit(foobar).compose(Adhere).adhere(myInterface).compose(someComponent)\nor even\njs\nAdhere.compose(foobar, someComponent).adhere(myInterface)\n. We call stamps like that \"an utility stamp\". We even have a early stage project for them: https://github.com/stampit-org/stamp-utils\n. A sample composable stamp could look like this (please, feel free to expand it):\n(stampit v2 only)\njs\nconst Adhere = stampit()\n.static({\n  adhere(myInterface) {\n    this.fixed.refs.nyceSchema = myInterface;\n  }\n}).init(() => {\n  if (this.nyceSchema && !nyce.validate(this, this.nyceSchema)) {\n    throw new Error(\"Bad object :(\");\n  }\n});\nIt will be even better in stampit v3.\nMore insight in the advanced examples.\n. Thanks! :+1: \n. I'd love to read an article on: \"Several ways to implement privacy in ES2015\".\n@ericelliott I reckon it'll get a lot of traffic. It's a very hot topic currently.\n. Hi @lorenzofox3 \nThat's an extraordinary new finding!\nDo you have a code sample on how one would improve the merge strategy? The PR would be ideal, but a tip on how you see it implemented would work too.\nBtw, looks like stampit v3 will have that issue solved in a bit different way. Here is the LOC related.\n. The code is ready. It's working. It lacks couple of tests for some corner cases.\nAlso, it lacks utility functions like convertConstructor, and the rest from #163.\nI want to publish first beta (but do not tag it as @latest). Then make sure it's stable. Then publish stampit v3.0. Then add the utility functions one by one and publish 3.1, 3.2, 3.3, and so on.\n. The only way to achieve that is via custom init() logic. Do you need code example?\n. Looks alright! :+1: \n. You have submitted that change to the master branch, which is stampit v2.\nStampit v3 is going to be the standard compatible. Which could be different.\nLet's not merge this yet until that issue discussion is finalized: https://github.com/stampit-org/stamp-specification/issues/63\n. Thanks Carl.\nFor reference. This idea is addressed in stamp-specifications. Stampit next version will be specs compatible.\n. stampit is using _.merge not _.clone.\n```\n$ node\n\nfunction F(){}\nundefined\n.merge({}, {foo: F});\n{ foo: { [Function: F] } }\nvar f = new F();\nundefined\n.merge({}, {foo: f});\n{ foo: {} }\n```\n\nAnything you believe can be improved in this regards?\nP.S. Sorry for the late reply. Was on a business trip.\n. Oh, bloody wording! I'll fix that doc. \u263a\nOn Mon, 7 Mar 2016 05:06 Christopher Hiller notifications@github.com\nwrote:\n\n@koresar https://github.com/koresar from the API docs:\n@param https://github.com/param {Object} [options.props] An object to\nbe deeply cloned into each newly stamped object.\nSo, yeah, it should do what it says it does. [image: :smile:]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/198#issuecomment-192950497\n.\n. @ericelliott while you are online, could you please jump to the Gitter chat or Twitter DM? There is a question for you there. Thanks!\n. It's a deep merge as in _.merge.\n. Fixed https://github.com/stampit-org/stampit/blob/master/docs/API.md\n. @BauchBeinePoe hello there.\nVery good idea. I like it!\n\nI'm actively working on stampit v3 which is going to be stamp-specification compatible. And your idea would perfectly fit the specification IMO.\nThe name should be protected because the object will be shared across several initializers. The \"private\" data already exist, it's the closure variables inside the initializers.\nThe initializer signature would be like that:\njs\nconst Stamp = compose({\n  initializers: [(options, { stamp, instance, args, protected }) => {\n    protected.log('Some log method');\n  }]\n});\nIn stampit v3 the API would be this:\njs\nconst Stamp = stampit.init((options, { stamp, instance, args, protected }) => {\n  protected.log('Some log method');\n});\nLet's move this conversation here: https://github.com/stampit-org/stamp-specification/issues/84\n. Thank you for the idea @BauchBeinePoe. As you know the community voted to not implement it. Although, a workaround using stampit v2 could be this:\n``` js\nvar log = stampit.init(({ instance }) => {\n   instance.log = console.log; // First, temporary assign the private state to the instance.\n});\nvar a = stamp.compose(log).init(({ instance }) => {\n    const log = instance.log;\n    log('Some log method');\n    delete instance.log; // Later, delete private state form the instance.\n});\n```\nWith the future stampit v3 (or the existing module stamp-specification) it could be implemented simpler:\n``` js\nvar log = compose({initializers: [(options) => {\n  options.log = options.log || console.log;\n}]});\nvar a = compose({initializers: [(options) => {\n  options.log('Some log method');\n}]});\n```\nAlthough, stamps developed with stampit v2 and v3 will (most likely) be incompatible. :(\n. Protected properties are now implemented as a separate stamp - https://www.npmjs.com/package/@stamp/privatize\nBut please note, the @stamp/* modules are compatible with @stamp/it (or @stamp/compose) only.. Hello mate.\nBad news - latest stampit does not support Property Descriptors.\nGood news - it is possible with stampit v3 (not yet released). Even though v3 is not released, you can have all features of it using the stamp-specification module. Few words about it.\nStampit will be based on the small 60 LOC code core which is called stamp-specification. And stampit itself will be \"stamps on steroids\" bringing nice end-user API similar to the current.\nUsing the stamp-specification you can implement the Car today:\n``` js\nimport compose from 'stamp-specification';\nconst Car = compose({\n    initializers: [function({engine}) {\n        this._engine = engine;\n    }],\n    propertyDescriptors: {\n        engine: {\n            get() {\n                return this._engine;\n            }\n        }\n    }\n});\nconst car = Car({engine: 'ENGINE!'});\nconsole.log(\"Engine OK: \" + car.engine);\n```\nStampit v3 future API:\njs\nimport stampit from 'stampit';\nconst Car = stampit\n    .override({_engine: 'engine'})\n    .defineProperties({\n        engine: {\n            get() {\n                return this._engine;\n            }\n        }\n    });\n. Ah, I see. Sorry for the confusion.\nThe converContructor of the stampit v3 is going to support Property Descriptors.\nAnother way to convert the Car to a stamp using v2 would be this:\n``` js\nvar Car = (function () {\n    function Car(engine) {\n        this._engine = engine;\n    }\nObject.defineProperty(Car.prototype, \"engine\", {\n    get: function () {\n        return this._engine;\n    }\n});\nreturn Car;\n\n})();\nvar stampit = require('stampit');\nvar carConstruct = stampit.convertConstructor(Car).init(function () {\n    Object.defineProperty(this, \"engine\", {\n        get: function () {\n            return this._engine;\n        }\n    });\n});\nvar constructCar = carConstruct(null, {power: 15});\nconsole.log(constructCar.engine);\n``\n. There was a similar problem a while ago. https://github.com/stampit-org/stampit/issues/148\nThe issue was that with node 0.12 they introduced theinit()static function to theEvenEmitterclass which collides with stampit'sinit()` static method.\n@eddyLazar can you show us your error?\n. Hello @namirsab. Eric is correct. The best way is to do ducktyping. Like:\njs\nif (rabbit.run) rabbit.run();\nAlthough, I understand it's very hard to do that kind of mind shift from instanceof to ducktyping. You might find few examples for yourself in Advanced Examples: https://github.com/stampit-org/stampit/blob/master/docs/advanced_examples.md\n. Feel free to ask further questions mate. :) \nI'll close this issue now since this repo is not the best place to ask that kind of questions.\nCheers\n. The best and fastest way would be the gitter chat: https://gitter.im/stampit-org/stampit\nI'm closing this one. Feel free to open new issues in https://github.com/stampit-org/stampit though.\n. Hi Daniel. Sorry for the late reply.\nThere was a proposal to remove duplicate initializers. Although, removing duplicate initializers have side effects.\nThat's how I do it currently:\n``` js\nconst HaveAdapter = init(({ instance, args: [adapter]}) => {\n    instance.adapter = instance.adapter || ensureAdapter(adapter);\n});\nconst Tree = stampit()\n  .compose(HaveAdapter)\n  .methods(...);\nconst Subject = stampit()\n  .compose(HaveAdapter)\n  .methods(...);\n```\n. @FredyC One last thing.\nOn that \"initializers which are not supposed to store anything on instance\" do you have any real world example? If so, could you please share it? We'd love to solve it in one of our future releases.\n. In stampit (all versions 1, 2, and 3) if an initializer returns a value then this value overrides the instantiated object. See this example:\n``` js\nconst Stamp = stampit()\n.refs({ a: 1 })\n.init(function () {\n  return \"1234\";\n});\nconsole.log(Stamp()); // Prints the string \"1234\", but not a usual object\n```\nOne can override the instantiated object by retuning a Promise from an initializer. So, the example you have in mind can be implemented like this:\n``` js\nconst ComposeMeMultipleTimes = stampit().init(function() {\n  if (typeof this.then === 'function') return;\n  return new Promise(function (resolve, reject){ ... });\n});\nconst Stamp = stampit().compose(ComposeMeMultipleTimes, ComposeMeMultipleTimes, ComposeMeMultipleTimes, ComposeMeMultipleTimes);\nStamp().then(...).catch(...);\n```\nIf you have any other example of \"initializers which are not supposed to store anything on instance\" I'd be glad to hear it. Thanks!\n. > Hm, if I understand correctly, this won't work if there is actually more initializers where each runs its own async operation and returns promise, right? With that condition it would just run first one, am I correct? Unfortunately I will surely need multiple async initializers.\nApologies. I should have mentioned that stampit v2 actually natively supports Promises in multiple initializers (here is the API link). See these tests for example: https://github.com/stampit-org/stampit/blob/v2.1.1/test/promise-init.js\nBut, upcoming stampit v3 won't support Promises natively due to following reasons:\n1) None is using that async feature of stampit v2. So we're dropping the support and removing that huge chunk of useless code.\n2) In stampit v3 one can easily overcome the missing feature with few additional lines of code. Show me your example, I'll show you how to easily implement the limitation using few different approaches. :)\n3) Classes do not natively support multiple promises in constructor. Let's know the difference between chalk and cheese. Sync is sync, async is async.\nI am eager to see your real world example of \"more initializers where each runs its own async operation and returns promise\". Your example could help us to shape up the stampit's future. Thanks for your help!\n\nIn regards to the instance.then vs this.then.\nActually, the instance and this is the same object reference. See examples on the API page.\n. > If they are truly the same, why to have the instance there?\nFor convenience with ES6 fat arrow syntax.\n\nIs there any chance to support that functionality through the stamp?\n\nEasy.\nI'll add this to the feature requests list I have. Your example proved that the feature is actually needed. Thank you very much.\n. @rickmed it can definitely be a composable behaviour. But I have no free cycles to implement that in the coming month or so. Sorry about that.\n. @rickmed if you need that feature, please tell people about it here: https://github.com/stampit-org/stamp-specification/issues/109\nThe more opinions we have there the better. Thanks!\n. Done. Well done! \ud83d\udc4d \nHere is another way to implement it: https://github.com/stampit-org/stampit/blob/master/docs/advanced_examples.md#attach-function-to-prototype-memory-efficient\n. I would highly recommend to avoid instanceof checks in your code altogether. This is an often asked feature, we deliberately not implementing instanceof. Every time people ask it - we suggest duck typing as more robust solution. And here is why.\nIf you really-really sure you need it, then you can implement a simpler isInstanceOf static function without any need for Symbols.\nstampit v2:\njs\nconst IsInstanceOf = stampit({ static: {\n  isInstanceOf(obj) {\n    return this.fixed.methods === obj.__proto__;\n  }\n}});\nstampit v3:\njs\nconst IsInstanceOf = stampit({ static: {\n  isInstanceOf(obj) {\n    return this.compose.methods === obj.__proto__;\n  }\n}});\n. Thanks for the explanation.\nStampit v3 was the matter of weeks few months ago. I can an RC0 any day now though.\n. Stampit Release Candidate v3-rc.0 was just released. npm i stampit@rc\nhttps://github.com/stampit-org/stampit/tree/v3_0\n. Closing this one as not an issue.\nBasically, \n for news please follow stampit_org on Twitter.\n for new development news and some examples follow Fun With Stamps (my medium.com blog)\n* for some variety of examples read the official API doc. . Released in stampit v3 RC9.\n. Initializers must be an array. The specs should mention that though.\nThis will work:\njs\ninitializers: [() => console.log('ok')]\n. I've just quickly put a PR.\nDo you think this change is enough?\nhttps://github.com/stampit-org/stamp-specification/pull/87\nWhere else we should state that it must be an array?\n. Instead of the function you wrote yourself you can use stampit.init(initializers).\nAlso, if you use \"statics\" feature:\njs\nconst SetupPropertyName = stampit().statics({\n  setupPropName(...propNames) {\n    return this.compose(...); // I need to see the Property func. to implement this line\n  }\n});\nyou can implement the following syntax:\njs\nexport default Model('Tree').compose(\n    Initialize(initializeTreeModel),\n    SetupPropertyName\n)\n.setupPropName('name', 'description');\nOr ever better (you don't need the Initialize function):\njs\nexport default Model('Tree')\n  .init(initializeTreeModel)\n  .compose(SetupPropertyName).setupPropName('name', 'description');\n. Btw, this is a bug!\n\nI tried this, but initializer is never invoked.\n\nThanks for finding it \ud83d\udc4d \n. stampit v3 rc1 just got published. The bug got fixed. New test added.\ncheers :)\n. > I don't want to expose a way how to add more properties to the model from outside.\nYou shouldn't worry. All stamps are immutable. None will add properties to your model. :)\nBut only if you make the \"setupPropName\" to always return a new stamp instance. Like in the example above.\nPlease remember! All stamps are immutable.\n. > I tried this in RC1 and still not working, the build method is not available.\nOh, crap. That's another bug. Sorry.\nUPD: you can use staticProperties instead of statics. That will always work because that name is part of the specification. Whereas statics is something stampit introduces for simplicity.\n. Fixed and published as part of RC3. See this unit test. If you have free cycles then feel free to check.\nAlso, new shortcut methods were added: conf, deepConf, deepStatics.\nI'll close this issue in a day or so.\nThanks!\n. Sounds great!\n@ericelliott you'd love this happened I believe. :)\n/cc @boneskull\n. > Can I add build script there too?\nYes please! \ud83d\udc4d \n. @FredyC btw, are you doing that in the v3_0 branch?\n. @FredyC sure thing Dan. I was going to do it myself in few days. Thanks\n. The #209 merged. Closing this one. Great job @FredyC !\n. @FredyC yeah, I agree. We should drop io.js. It was added at the time when io.js was the newest coolest thing. :)\n. Please, allow me some time to review the PR. Busy life Getting ready for the upcoming conference here in Sydney.\n. @ericelliott good point. We should do it as a different PR.\n. I'm not sure what I did wrong, but stampit v2 full minified took 13K.\nThe stampit v3 full minified is 44K.\nWe are using _.mergeWith in both stampit v2 and v3. But stampit v2 uses lodash v3, and stampit v3 uses lodash v4.\nLooks like lodash v4 is a bulky thing unlike lodash v3.\nOverall, LGTM.\n. Ok. I pulled your fork, solved the merge conflicts. Done!\n. Hey, Daniel. Thank you so much for the initiative. I believe ava is a better tool than tape.\nSame time Eric is correct. We have plans to revive the browser tests. Here is the long living opened issue for it: https://github.com/stampit-org/stampit/issues/68\nI really feel this PR is a great coding art. Tomorrow I'll investigate the ava usage inside browsers, there might be workarounds (via polyfills, or PhantomJS, or else). Will do my best and come up with more info sometime Friday or Saturday.\n. There was a time when stampit tests were failing in IE8. Simply because i used a language construct not available in IE8. IE11 could become the new IE8.\nAs you suggested earlier, stampit will support Promises in the future. But IE11 and old Android <4.4.4 Browser do not support Promises natively.\nIt's just one of the possible scenarios. There might be other things, like iOS Safary, IE11, and Android browsers <5.0 do not support arrow functions.\netc. etc. etc.\nI wish I would ditch that IE11 and Android old crap. But people rely on us.\n. @FredyC Do you know that you can create branches in stampit-org repos? No need to implement things in your forks. You're a collaborator. :)\n. It's just more complex for the rest of the people to collaborate. I.e. we can't fix up your branch on a fly. The conflict resolution becomes a pain in the neck too. Also, it's longer to pull the fork and test it then a branch.\nBut, as long as you prefer forks we all can leave with that for sure.\n. @JosephClay this might sound weird, but \njs\nconst _ = require('lodash');\ngenerates smaller distributive files than the\njs\nconst mergeWith = require('lodash/mergeWith');\nAFAIK the magic is cast by this line: https://github.com/stampit-org/stampit/blob/9bd809b55d872c91736641820851e9abfa35ee50/package.json#L35-L35\n. > Um so stamp-specification would be just written manual how to do it?\nThat would be ideal. But sounds complicated. :)\n. There is already a \"manual\": https://medium.com/@koresar/fun-with-stamps-episode-4-implementing-stamps-in-30-loc-e52f5c17dcfe\n\nHowever that means stampit will need to implement spec on its own. Is that the plan?\n\nYes.\n. > it was interesting to have different people working from the spec writing independent stamp implementations\nOh, yeah!\nBtw, I already found problems in the check-compose module. Will talk about it later. :)\n. Removed lodash, polyfills, unused helper methods, etc. Now the minified stampit is 5.7K\n$ ls -l dist/\n-rw-r--r--  1 vasyl  staff  12784 Jun 12 22:23 stampit.es5.js\n-rw-r--r--  1 vasyl  staff  18529 Jun 12 22:23 stampit.es5.js.map\n-rw-r--r--  1 vasyl  staff  13682 Jun 12 22:23 stampit.full.js\n-rw-r--r--  1 vasyl  staff  21246 Jun 12 22:23 stampit.full.js.map\n-rw-r--r--  1 vasyl  staff   5874 Jun 12 22:23 stampit.full.min.js\n-rw-r--r--  1 vasyl  staff   9872 Jun 12 22:23 stampit.js\n-rw-r--r--  1 vasyl  staff  18244 Jun 12 22:23 stampit.js.map\n-rw-r--r--  1 vasyl  staff   9788 Jun 12 22:23 stampit.mjs\n-rw-r--r--  1 vasyl  staff  18241 Jun 12 22:23 stampit.mjs.map\nLodash.\n- Reimplemented isFunction and isObject. As the result no lodash dependencied in the src/stampit.js file.\n- The src/compose.js were using lodash/assign and lodash/mergeWith.\n  - The assign was easy to replace. I copy-pasted the Sindre Sohus implementation proposed by @FredyC.\n  - The merge was copy-pasted form deepmerge module found by @FredyC. It is implemented almost as we need it. But not exactly. There are tests still failing. Working on them now.\nI'm pretty happy with 44->5.7 KB file size improvement. :)\nWe can squeeze 1KB more I think.\nLet me know what you think. https://github.com/stampit-org/stampit/tree/v3_0\nI'd like to thank @FredyC for doing all that rollup initial work. Very helpful!\n. I'm wasting too much time on that babel, lodash, ES6, etc. This pushes me to the conclusion that using ES6 for stampit is a bad idea.\nTake a look at the React or lodash for instance. Their source code is ES5.\nI'm tempting to rewrite stampit v3 using ES5.\nP.S.\nSorry for the quite a negative post. I've just calculated that I spend ~80% on fixing/improving the ES6 build system, and ~20% on the stampit roadmap.\n. Which exactly utility functions?\n. - The stamp-specification code was written in the most readable and easy to understand way. It is very important to keep it like that. So, I'm going to supply a PR which improves the readability but degrades the performance.\n- The stampit is our main module. It should be as performant as possible unlike the stamp-specification.\n- The stamp-utils is the small \"utility belt\" module for those people who don't want to bloat their (browser?) apps with all the powers of stampit, but wishes to write pretty code. So, stamp-utils would need the stamp-specification dependency to be replaced with something more optimized.\n. @FredyC true. My bad. Will fix that. Thanks\n. Talked with @FredyC in the gitter chat. As the result build system:\n- Works on all node.js and npm versions.\n- The minified browser version of stampit is 6K. The gzipped is 3.1K.\n- Things to do:\n  - Support for Symbols.\n  - Move files from root to src directory.\n. Closing this as Done.\n. I believe it will be fixed in v3_0 branch. No source code changes are expected to the stampit@2, so let those tests fail. We'd need to fix them though if we are going to cut a new stampit@2 release.\n. Well spotted! I thought we have tests for the create. Sorry.\nRemoving ... saved about 1K of the minified stampit.\nI'm surprised it works on Windows. I wonder though why this line doesn't work well on Windows?\n\"test\": \"babel-node --presets es2015 ./node_modules/.bin/tape test/index.js\",\n. One more thing. The ... syntax is slower than the .apply(this, arguments) because each ... is transpiled to a for loop.\n. Thank you for the fix. Will publish new RC in a moment.\n. Please, try the latest v3_0 branch on Windows. Does it work? If not, I'm happy to help fixing it.\n. You are correct. This code is less readable. This is the price we pay for performance and bundle size.\nUnfortunately babel is somewhat stupid.\nThis ES6\njs\n  methods(...args) {\n    return (this.compose || compose).call(this, {methods: assign({}, ...args)});\n  },\ngets transpiled to:\n``` js\n    methods: function methods() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n  return (this.compose || compose).call(this, { methods: assign.apply(undefined, [{}].concat(args)) });\n},\n\n```\nCheck yourself.\nStampit has about a dozen functions which accept ...args. So, we are avoiding this repetitive for loop a dozen times.\n. I could be wrong about the performance thing though. But I'm definitely correct about the bundle size.\n. We can reimplement slice ourselves because it is in a separate file now (src/slice.js).\n\nFrankly it seems ridiculous trying to save bytes on size in times of fast internet.\n\nThat is true. I'd rather ask more opinions on what people would prefer: more readable stampit source code, or smaller bundle size.\n. Hey, don't change my words please. Quoting myself:\n\nI could be wrong about the performance thing though. But I'm definitely correct about the bundle size.\n\nAnd\n\nRemoving ... saved about 1K of the minified stampit.\n. I clearly see\nObject.defineProperty(exports, '__esModule', { value: true });\nin dist/stampit.js, dist/stampit.full.js, and dist/stampit.es5.js. It's not present in the .mjs file, which is correct.\n\nNode v0.10\n```\n\u250cvasyl@192-168-1-52 ~/c/stampit (v3_0 $)                            \n\u2514> nvm use 0\nNow using node v0.10.40 (npm v2.15.6)\n\u250cvasyl@192-168-1-52 ~/c/stampit (v3_0 $)                            \n\u2514> node\n\nvar s=require('./');\nundefined\ntypeof s.default\n'function'\ntypeof s\n'object'\ns.__esModule\ntrue\n```\n\nAnd node v6.\n```\n\u250cvasyl@192-168-1-52 ~/c/stampit (v3_0 $)\n\u2514> nvm use 6\nNow using node v6.2.0 (npm v3.8.9)\n\u250cvasyl@192-168-1-52 ~/c/stampit (v3_0 $)                            \n\u2514> node\n\nvar s=require('./');\nundefined\ntypeof s.default\n'function'\ntypeof s\n'object'\ns.__esModule\ntrue\n``\n. Side note. I'm starting to be more convinced of ditching the ES6 from the stampit source code. This is getting ridiculous. :(\n. So, I've just pushed few more commits.\n- Fixed the coverage I broke. It's weird, but the only way to fix it was the.babelrc` file I removed earlier.\n- As the result we don't need to pass babel presets anywhere.\n- Also I upgraded every devDependency to the latest possible.\n- Travis is green.\n\nNow, it's time to think of the browser tests. Any ideas?\n. So, this issue is fixed. Feel free to close. \n. This is rather a pain point of stamps currently.\nWe used to say \"deep merge as in _.deepMerge\", but lodash merging algorithm is somewhat bulky and doesn't concat arrays.\nAnother solution to the deep merging can be the user defined callback.\njs\nconst customMetadataMerger = compose({mergers: [function (dstDescriptor, srcDescriptor) {\n  const {defaults} = srcDescriptor.deepConfiguration;\n  if (defaults) {\n    defaults.openNodes = []\n      .concat(srcDescriptor.deepConfiguration.defaults.openNodes)\n      .concat(defaults.openNodes);\n  }\n}]});\nBut that's a too deep debris, although a powerful feature.\n. I'm pretty sure I understood you correctly. It's just my thoughts are to broad, trying to catch every possible issue.\nThere is a problem with function referencing. Here:\njs\nfunction F() {}\nconsole.log(F); // [Function: F]\nlet Stamp = compose({deepProperties: { foo: F } })\n  .compose({deepProperties: { foo: { bar: 42 } }});\nconsole.log(F); //  [Function: F] foo: { bar: 42 } }\nIf we copy by reference then the compose merging algorithm can \"damage\" (add properties) to the referenced objects (in this case the function F).\nStamps are immutable. They should not change a third party state.\nP.S. There are ways to clone functions in JS. (For example F.bind() creates the function copy).\n. > However using bind comes with problem of rebinding context of that function\nNope.\n```\n\nfunction F() { console.log(this); }\nvar f = F.bind({a:1})\nf()\n{ a: 1 }\nf.bind()()\n{ a: 1 }\n``\n. If you want to preserve functions in the \"deepConfiguration\" I'd recommend storing it in an array. As it is declared in the spec that we concat arrays.\n. Implemented. Released as stampit v3 RC9.\n. Done. Published asstampit@rc`\n. We have witnessed several people coming to stampit Gitter chat asking basic questions. This PR is a good move. It might help people to get started faster.\n\nI'd love to merge this. Although, I need to tweak the article before merging. Namely, as @unstoppablecarl suggested, add the TOC to the top of the article(s). Will do that today.\n. Oh! The fat arrow. :) I didn't notice.\nHey @pdavidow \nChange the line to be\nmyName() { return this.myId },\nand it will just work. :)\n. There are few complications here.\nStampit adds multiple new static methods to each stamp it generates (like .props() or .methods(), etc). So, people would expect:\njs\nimport {init} from 'stampit';\ninit(() => {}).props // MUST EXIST\ninit(() => {}).props({foo: 'bar'});\nstamp-utils does not (and should not) do that.\njs\nimport {init} from 'stamp-utils';\ninit(() => {}).props // must NOT exist\nMoreover, it's better stampit to not depend on a module which can be re-implemented in 45 characters: const init = f => compose({initializers: [f]})\nAlso, @ericelliott please reread the quoted.\n\nJust think of a new user coming to stamps which are already mind blowing on its own. That user has to face decision what module to pick: stamp-specification, stampit or stamp-utils? Studying what are differences and what he might actually need.\n\nYou are correct saying that stamp-specification better not be a module. Also, Daniel is correct saying that user's better not be faced with the choice: \"stampit or stamp-utils?\"\n. I feel we're going to have a good outcome from this conversation. I agree to both of you to some extent.\n- @FredyC is right. We need a performant implementation of compose. Anywhere. Any new or existing module is fine to me. Maybe not today, but some day we would definitely need that.\n- @ericelliott is right too. stampit is a trademark already. We should maintain it as long as we can.\nHowever,\n- The idea to have all these @stamp/* modules/repos is great but requires a lot of effort. I welcome anyone to do it. (I've just parked and started paying for the npm private user ~stamp to make scoped modules a thing.)\n- At this point I don't see why we need that \"stampx\" at all. I made a mistake reserving that module. Let's forget about it existence please. :) Sorry about bringing it up.\nI'd resume:\n- Eric would continue to work on stamp-utils.\n- I'd continue to work on stampit.\n- Someone might start creating micromodules at @stamp/.\nEVERYBODY HAPPY! DANCE! :)\n\n. I support the plan. It's good.\nI have no strong feelings about that init being a micromodule. We'll see how it goes.\nNow, let's try answering the question:\n- How we can ease newcomers' choice on which library to use? What should we recommend?\n. The mono repo was created: https://github.com/stampit-org/stamp\nAll the unanswered questions, planning, and discussions should be moved there.\nFeel free to reopen this issue if there are more to discuss.\nClosing.\n. It makes total sense mate. :)\nImagine if it was a class:\njs\nclass MyBar {\n  getMember() { return this.members[name]; }\n}\nThe context won't be bound too:\n``` js\nconst myBar = new MyBar();\nconst toPassItSomewhere = myBar.getMember;\ntoPassItSomewhere('Homer');\n```\nYou can do regular binding though:\njs\nconst toPassItSomewhere = myBar.getMember.bind(myBar);\ntoPassItSomewhere('Homer');\n. Well, you can easily create one more stamp, call it \"BindAllMethods\" and merge it with any of your existing stamps. Look:\njs\nconst BindAllMethods = stampit().init(function () {\n  Object.keys(Object.getPtototypeOf(this))\n  .filter(key => typeof this[key] === 'function')\n  .forEach(key => {\n    this[key] = this[key].bind(this);\n  });\n});\nAnd you're done!\nWARNING. The code above is not tested. I have just typed it. :)\n. Thank @hoschi for taking this issue here.\nYeah. It's just bad API naming. In stampit v2 props are deeply cloned/merged. Whereas refs are object references.\nI'd recommend using stampit v3. It has this problem solved, props and refs are the same thing.\nTo install stampit v3 run npm i stampit@rc. It's pretty stable. Just lacks some documentation atm.\nFeel free to post any other questions in the gitter chat: https://gitter.im/stampit-org/stampit\nPeople are pretty fast responding there.\nCheers\n. If no other objections arise in couple of days we would go this direction.\n. Ok. 3 days. No objections.\nIt's decided!\nStampit v3 is dropping support for environments which do not have Object.assign function or polyfil.\n. Great workaround!\nCould you please elaborate on this:\n\nThis works only for normal functions and not for generator functions.\n\nWhat does not work?\n. I know why it does not work. Because stampit v2 limits the methods to be only typeof function. Whereas stampit v3 allows anything in the methods, including generators.\nHere is the problematic LOC.\nThe proper workaround in stampit v2 would be:\n1) Leave the DefaultHooks as is.\n2) Replace methods with refs in LoggerHooks like so:\njs\nlet LoggerHooks = DefaultHooks.refs({\n  preHook: function *() {\n    yield console.log(arg);\n  }\n});\nAnd done!\n. v3 is stable. Not released though. :) Working on it as we speak.\n. @FredyC you are correct!\n```\n\u250cvasyl@192-168-1-11 ~/c/stampit (v3_0 $)                                         \n\u2514> nvm use 6\nNow using node v6.3.0 (npm v3.10.3)\n\u250cvasyl@192-168-1-11 ~/c/stampit (v3_0 $)                                         \n\u2514> babel-node --presets es2015\n\nconst g = function* (){}\n'use strict'\ntypeof g\n'function'\ng()\nGeneratorFunctionPrototype { _invoke: [Function: invoke] }\n```\n\n@hoschi you might want to double check your code.\n. Okay, so stampit is using lodash/isFunction to check values.\nLodash is not using typeof value === 'function'. Instead, it is using value.toString() === '[object Function]'.\n``` js\n\nvar g = function* (){};\nObject.prototype.toString.call(g);\n'[object GeneratorFunction]'\nvar f = function (){};\nObject.prototype.toString.call(f);\n'[object Function]'\n```\n\nI believe stampit v2 need a fix to allow generators, as well as stampit v3.\nRight?\nTo fix stampit v2 we need to patch the supermixer module. Any volunteers?\nI'll fix stampit v3.\n. Review needed: https://github.com/stampit-org/supermixer/pull/7\n. Oh, wait. I was wrong. Stampit v3 does not need a fix because it does no checks at all. :) One can put anything as \"methods\".\n. @hoschi thanks for reporting the bug. stampit v2.1.2 was just published.\n. They fixed flow type for Windows just yesterday AFAIK.\nThe /* flow */ comment is not necessary for FlowType declarations. Just like our TypeScript declarations.\nWe can support both declarations if anyone is willing to contribute.\nPS: thanks for typings link!\n. Tested with the 'check-compose':\n```\n$ check-compose ./\nok\n```\nTested against both ES5 and ES6 distributables:\n```\n$ babel-node ../check-compose/bin/check-compose dist/stampit.full.js\nok\n$ babel-node ../check-compose/bin/check-compose dist/stampit.mjs\nok\n```\nSimply maaagic!\n. There are various ways you can do that in JS.\n1) Use WeakMap \n``` js\nconst myWeakMap = new WeakMap();\nexport default stampit().methods({\n  accessingPrivateData() {\n    const privateData = myWeakMap.get(this); // getting the private data\n  }\n});\n```\n2) Another approach (for JS environments without WeakMap):\n``` js\nlet numUsers = 0;\nexport default stampit().init(() => { \n  const userID = ++numUsers;\nconst myProto = Object.getPrototypeOf(this);\n  if (!myProto.accessingPrivateData) { // key line\n    myProto.accessingPrivateData = () => {\n      return userID;\n    }\n  }\n});\n```\nA side note on that \"userID\". It's generally recommended to avoid numeric IDs for anything. UUIDs are much better in many ways.\n. 3) ES6 Symbols. :)\n. - Sorry, I surely meant myProto. Corrected.\nI'm using the approach myself. It worked last time. :)\nBasically, the JS engine creates new closure, but does not create a new copy of the function.\n- Yes, the WeakMap uses references.\n- Here is my favourite introduction to Symbols - http://www.2ality.com/2014/12/es6-symbols.html\n  Although, I must mention that this is a semi-private approach. Symbols of an object can be iterated through.\n. Number 1: \nNot sure what you mean.\nNumber 2:\nI would need to double check my code then. :\\\n. Feel free to have more real time chat here: https://gitter.im/stampit-org/stampit\n. A new stamp was developed - https://www.npmjs.com/package/@stamp/privatize\nThis is how it works:\n```js\nimport Privatize from '@stamp/privatize';\nlet accessPassword, accessSetPassword;\nconst Original = compose({\n  properties: {password: '123'},\n  methods: {\n    setPassword(value) { this.password = value; },\n    checkAccess() {\n      accessPassword = this.password;\n      accessSetPassword = this.setPassword;\n    }\n  }\n});\n// Add Privatize behavior, additionally protect the 'setPassword' method\nconst Stamp = Original.compose(Privatize).privatizeMethods('setPassword');\n// All properties and the method 'setPassword' are undefined \nconst instance = Stamp();\nexpect(instance.password).toBeUndefined();\nexpect(instance.setPassword).toBeUndefined();\n// But the 'checkAccess' method have access to the properties and 'setPassword' \ninstance.checkAccess();\nexpect(accessPassword).toBe('123');\nexpect(accessSetPassword).toBe(Original.compose.methods.setPassword);\n```. @eladchen great and sneaky one. Thanks mate\n. I'll add your proposal to the list above as Solution 5.\nBtw, I personally like Solution 1.\n. Yeah. That's what I meant saying \"Little harder to maintain the module.\" :)\nThe issue with \"pureCompose\" is that only you and me (and maybe few more people) know what that is. Most people would be confused and would need to learn \"infected\" and \"pure\" concepts we have invented. :)\nThus, I would better take some time implementing Solution 1. Hope that's fine.\n. Implemented as #233\n. Solved.\n. Pushed few more minorish changes. Will merge that in few hours if no reviewers come.\n. Thanks @dpatte \nJust click this link and edit the file. We'd be very grateful for the improvement you can do!\n. Oops! ESLint v3 dropped support of node 0.12.\nShould we also drop support of node 0.12?\n. I admire your memory! Dropping it now (because I dropped only the 0.10). :)\n. @FredyC thanks for keeping an eye :)\n. AFAIK the latest eslint supports only the node v4 and later, which have the Object.assign inbuilt. Thus babel-eslint dropped it too.\nI believe we should warn about that stampit v3 also requires Object.assign present (maybe as a polyfil). Created the issues: https://github.com/stampit-org/stampit/issues/243\nThis PR can be merged now.\n. Will be fixed with #251 \n. Found the cause. Version conflict.\neslint-config-airbnb-base requires peer dependency \"eslint-plugin-import\": \"^1.16.0\".\nThus we can't depend on v2 of eslint-plugin-import in npm v2.\n. Found a proper solution.\nSince eslint-plugin-import is a peer dependency then we don't need to depend on it explicitly. The AirBNB eslint configuration already lints import/exports for us.\nSo, by removing that dependency we kill two birds with one shot: less dependencies to manage, merge this PR.\n. Closing this one is favour of #249\n. Thanks! Fixed in v3.0.2\n. Looks like two bugs collided and annihilated. @FredyC thanks for the PR with the proper test.\nI pushed two more commits:\n1) Fix the Travis exit code (removed the tap-dot completely)\n2) Export the right compose function as we designed\n. Easy. Let me get to a computer.\nOn Thu, 6 Oct 2016, 03:16 Daniel K. notifications@github.com wrote:\n\n@koresar https://github.com/koresar Can you please make a new release\nwith this? Thanks :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/pull/248#issuecomment-251723126,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABjCLw22ny9Nnw3DO902zJkf1z6A3EC-ks5qw811gaJpZM4KL93e\n.\n. Done. I'm so sorry about forgetting to do it earlier.\n. Okay. Another way. \nThis page https://www.npmjs.com/package/eslint-config-airbnb-base says to run the little shell script.\nIt upgraded eslint, set the new version for the eslint-config-airbnb-base and eslint-plugin-import. See the last commit.\n. Thanks for fixing the second link! \nBut the first link must be left intact please \nhttps://github.com/stampit-org/stampit/releases/tag/2.0\n\nThose breaking changes links. This is important. \n. Awesome! I'm going  measure the performance of this and merge sometime today. \nThanks! \n. My perf measurements.\nRun them from here: https://github.com/koresar/bench-node\nThese tests run the transpiled ES5 code, not the ES6 shown above.\nFLATTEN 1 - the previous implementation (.min.gz file size 1.59KB)\nFLATTEN 2 - the implementation from this PR (.min.gz file size 1.62KB).\nLODASH FF - is this: _.filter(_.flatten(args), isFunction\n- If there is no recursion then both variants are similar.\n```\n\nnode flatten/2\nv4.6.0 1 item with undefined\nFLATTEN 1   107660.1  | malloc: >= 14.69  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   110704.73 | malloc: >= 16.47  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   114341.72 | malloc: >= 14.73  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\n```\n- If case the incoming arguments are complex, like array of arrays, then both implementations are identical in CPU, but the second one takes slightly more memory.\n\n```\n\nnode flatten/1\nv4.6.0 10 items\nFLATTEN 1   87161.47  | malloc: >= 15.67  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   87590.96  | malloc: >= 30.49  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   100668.87 | malloc: >= 14.73  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\n```\n\nP.S. @abhisekp, you probably wanna apply the \"loose\" changes to this PR to minimize the output bundle. It might even speed things up. Feel free to run the test above yourself. :)\n. @abhisekp proposed a third implementation of the function.\n``` js\nimport isFunction from './isFunction';\nconst concat = Array.prototype.concat;\nexport default function () {\n  const fns = concat.apply([], arguments).filter(isFunction);\n  return fns.length === 0 ? undefined : fns;\n}\n```\nHere are the perf. results across all node.js versions on my laptop.\n10 items array.\n```\n\n./all_nodes.sh flatten/1\nv0.10.47 10 items\nFLATTEN 1   65773.45  | malloc: >= 28.74  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   65356.04  | malloc: >= 28.52  MB | GC calls: >= 2   | Mem/cycle: >= ~ 0     \nFLATTEN 3   64799.63  | malloc: >= 21.64  MB | GC calls: >= 2   | Mem/cycle: >= ~ 0     \nLODASH FF   69509.9   | malloc: >= 6.84   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\n\nv0.12.16 10 items\nFLATTEN 1   48955.46  | malloc: >= 29.71  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   47523.45  | malloc: >= 12.72  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 3   48458.25  | malloc: >= 1.97   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   53024.4   | malloc: >= 2.95   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\nv4.6.0 10 items\nFLATTEN 1   88213.83  | malloc: >= 16.65  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   92537.16  | malloc: >= 16.72  MB | GC calls: >= 1   | Mem/cycle: >= ~ 0     \nFLATTEN 3   95071.15  | malloc: >= 6.89   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   104188.03 | malloc: >= 5.87   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\nv5.12.0 10 items\nFLATTEN 1   87573.79  | malloc: >= 16.65  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   96284.76  | malloc: >= 18.68  MB | GC calls: >= 1   | Mem/cycle: >= ~ 0     \nFLATTEN 3   96540.67  | malloc: >= 5.91   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   104437.3  | malloc: >= 5.87   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\nv6.7.0 10 items\nFLATTEN 1   62318.56  | malloc: >= 15.00  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   65788.09  | malloc: >= 22.00  MB | GC calls: >= 1   | Mem/cycle: >= ~ 0     \nFLATTEN 3   68186.61  | malloc: >= 6.00   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   75645.36  | malloc: >= 6.00   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF\n```\n2 items array\n```\n\n./all_nodes.sh flatten/2\nv0.10.47 1 item with undefined\nFLATTEN 1   76882.66  | malloc: >= 12.75  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   62167.34  | malloc: >= 38.61  MB | GC calls: >= 2   | Mem/cycle: >= ~ 0     \nFLATTEN 3   62201.21  | malloc: >= 16.73  MB | GC calls: >= 2   | Mem/cycle: >= ~ 0     \nLODASH FF   74590.92  | malloc: >= 4.87   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is FLATTEN 1\n\nv0.12.16 1 item with undefined\nFLATTEN 1   52772.96  | malloc: >= 30.69  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   49348.26  | malloc: >= 11.75  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 3   48268.43  | malloc: >= ~ 0       | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   53110.37  | malloc: >= 1.97   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF,FLATTEN 1\nv4.6.0 1 item with undefined\nFLATTEN 1   113933.3  | malloc: >= 14.68  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   87618.49  | malloc: >= 22.59  MB | GC calls: >= 1   | Mem/cycle: >= ~ 0     \nFLATTEN 3   86366.92  | malloc: >= ~ 0       | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   108488.16 | malloc: >= 5.87   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is FLATTEN 1\nv5.12.0 1 item with undefined\nFLATTEN 1   107333.9  | malloc: >= 16.65  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   88726.87  | malloc: >= 21.62  MB | GC calls: >= 1   | Mem/cycle: >= ~ 0     \nFLATTEN 3   87040.05  | malloc: >= 4.89   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   108251    | malloc: >= 5.87   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is LODASH FF,FLATTEN 1\nv6.7.0 1 item with undefined\nFLATTEN 1   88129.24  | malloc: >= 23.00  MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFLATTEN 2   66571.43  | malloc: >= 18.00  MB | GC calls: >= 1   | Mem/cycle: >= ~ 0     \nFLATTEN 3   68384.86  | malloc: >= 6.02   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nLODASH FF   84992.47  | malloc: >= 7.00   MB | GC calls: >= 0   | Mem/cycle: >= ~ 0     \nFastest is FLATTEN 1\n```\nP.S. The file size:\nCurrent stampit impl.: Estimating dist/stampit.umd.min.js: 4.58 KB, GZIP : 1.59 KB\nThe code from above: Estimating dist/stampit.umd.min.js: 4.5 KB, GZIP : 1.56 KB\nThe new code uses much less memory than any other implementation. The perf is about the same to some extent. The file size is a bit smaller. Code is more readable. I like it in general. :)\nAlthough, I'd rather avoid discussions about micro benchmarking.\n. Yeah. I thought of removing flattening sometime next major release. We need that flattening at least for this line to work.\nSurely, none passes arrays of arrays as initializers. It won't even work in the current code base. However, the \"2 items array\" test is the real world test. That's exactly how the extractFunctions is called most of the times.\n. Okay. @FredyC has some bright ideas. So, here what we'll do.\n- I'll apply the proposed code because of the single reason - it's shorter.\n- Than, if time allows, @FredyC will supply a new PR brining all the great ideas together.\nI'll close this PR and apply @abhisekp's code separately.\n. I should mention that in the current state this change might not decrease the distribution size. Although, chances are that will be helpful in the future. \n. Moreover, I don't understand why we are even using ES6 if we are limiting ourselves to certain set of ES6 features? We could ditch babel altogether. :)\n. Totally agree with everything you say.\nThere's just one \"but\". We have to support older environments. In other words, we have to transpile down to ES5.\n. So... We have a problem.\nI examined the ES6.\nHere is what we should implement in order to convert ES6 classes in a fully compatible way.\nThis code should produce the picture below:\n``` js\n    class Point {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y);\n        this.color = color;\n    }\n}\n\nlet cp = new ColorPoint(25, 8, 'green');\n\n```\n\nStamps do not allow prototype chaining. By design. Deliberately.\nThis means there is no way we can write a fully fledged convertConstructor.\n\nOk. but we can try supporting single level (no inheritance) classes. Right?\nNo. We can't do that either. ES6 classes throw exception if you try calling its constructor without the new keyword: Cannot call a class as a function\n\nOk, but we can try supporting the \"class-like functions\". Can we? Yes we can. The same way as before.\nBut we must make sure people are not using convertConstructor for ES6 classes. I would better rename the convertContructor to convertClassLikeFunction to make sure there is no confusion.\n\nSee that branch and that file if you wanna play around with it:\nhttps://github.com/stampit-org/stampit/blob/convert-constructor/test/convert-constructor.js\nJust run npm test\n. After a long chat we decided to go this way:\n1) The convertConstructor will be used for the ES5 class-like functions.\n2) The new convertClass will be used for ES6 classes:\n2.1) In the API docs we'll warn that only the non-inherited classes are fully supported\n2.2) and the classes inherited at least once are loosely supported (list the limitations).\n\nHere is a rough WIP implementation (run it here):\njs\nconst convertClass = ctor => stampit.default({\n    init: function (_, {args, instance}) {\n        return Reflect.construct(() => instance, args, ctor);\n    },\n    methods: ctor.prototype,\n    statics: Reflect.ownKeys(ctor)\n        .reduce((statics, k) => {\n            if (k !== 'length' && k !== 'name' && k !== 'prototype')\n                statics[k] = ctor[k];\n            return statics;\n        }, {})\n});\n. Hi @Sigfried \nThanks for the question. The work has stuck at some point of time: https://github.com/stampit-org/stampit/compare/convert-constructor?expand=1\nThis requires more unit tests. And probably implementation improvements...\nI'm planning to implement it as the @stamp/convert-constructor module later. If you really need stamps - your only option atm is to convert classes to stamps manually. Sorry about that.. @Sigfried could you please show us some code regarding\n\nMy ES6 classes use arrow functions for methods\n\nI am not sure there is such syntax in ES6.. @FredyC I can clearly see that @Sigfried is using ES6 classes, not ES-Next or something:\n\nMy ES6 classes use arrow functions. So, Daniel was right - you are actually using Babel! I must mention, that this keyword in the following code is VERY misleading.\njs\ncids = () => this.prop('cids')\nAccording to ECMAScript standard in this case this should not point to the object instance, but to the upper scope - likely the window or global scope in your case.\n\nI assume that Babel compiles it wrong. :) Not sure.\nP.S.\nThis is more readable to me, my colleagues, and non JS developers. Also, it is part of ES2015:\njs\ncids() { return this.prop('cids') }\nCompare to yours:\njs\ncids = () => this.prop('cids')\nP.P.S.\nI am starting to hate transpiling more\u2757\ufe0f . Thanks for the info @Sigfried \nJust a quick note. The approach is memory heavy. This attaches methods not to the prototype, but to the instance itself.\njs\nexport class ConceptSet {\n  cids = () => this.prop('cids')\n}\nIf you are creating a lot of these objects - you are wasting CPU and memory and GC etc.. @FredyC you are right. But Sigfried do not need method binding and private props. . Sigfried, you can surely do the same using stamps.\n``js\nimport {init} fromstampit`;\nexport const ConceptSet = init(function () {\n  // ... constructor code here ... //\nthis.cids = () => this.prop('cids')\n  this.concepts = (cids=this.cids()) => concepts(this.conceptState.loaded).filter(c=>_.includes(cids,c.concept_id))\n  this.concept_ids = (cids) => this.concepts(cids).map(d=>d.concept_id)\n  this.cidCnt = () => this.cids().length\n  this.conCnt = () => this.concepts().length\n});\n```\nIt is exactly the same implementation as the Babel transpiled code you referenced above.. Correct.\nBut I still would recommend using methods() if you are creating a lot of these objects. \nAlways glad to help!. Sorry, what do you mean exactly when saying \"blown away\"?\nHere is your code (I've shortened it a bit) running in node.js:\n```js\nconst {init} = require('stampit');\nfunction PubSubModel () {\n  this.a = 1;\n}\nPubSubModel.prototype.foo = function () {\n  console.log('foo')\n}\n// The conversion\nconst oldskool = init(function() {\n  Object.setPrototypeOf(this.proto, new PubSubModel());\n});\n// Now you can compose with it just like any other stampit factory...\nconst myThing = oldskool.methods({\n  bar() { return this; },\n  // your methods here...\n});\nmyThing().bar().foo()\n```\nThis code prints foo to the console as expected.. A tip.\nIf you're looking to add EventEmitter (aka PubSub) to your objects then you might want to take a look at the @stamp/eventemittable package.\n```js\nimport stampit from 'stampit'\nimport EE from '@stamp/eventemittable'\nconst MyStampThing = stampit(EE, {\n  init...\n  props...\n  methods...\n  etc...\n});\n```\nThe implementation of the @stamp/eventemittable is very simple. Here is the full source code:\n```js\nimport {EventEmitter} from 'events';\nexport default stampit({\n  statics: {\n    defaultMaxListeners: EventEmitter.defaultMaxListeners,\n    listenerCount: EventEmitter.listenerCount\n  },\n  methods: EventEmitter.prototype\n});\n```. I see what's the issue in your case. Here is a 6 minutes article I would highly recommend you to read: https://medium.com/@koresar/fun-with-stamps-episode-1-stamp-basics-e0627d81efe0\nEspecially see the Breaking down a stamp into pieces part.\nIt explains that every object instance you create from a stamp (stamps are the myThing or oldskool in your case) have a __proto__, and stampit puts all your methods to the proto.\njs\nconst Stamp = stampit().methods({ myMethod() {} });\nconst objectInstance = Stamp();\nconsole.log( Object.getPrototypeOf(objectInstance).myMethod );\nprints [Function: myMethod]\nSo, this line overwrites all the methods of your object instances:\njs\nObject.setPrototypeOf(this, new PubSubModel());. There is no \"best practice\". Every case is different. Here is a new version of a (non fully tested) implementation:\n```js\nfunction classStaticProperies(ctor) {\n  return Reflect.ownKeys(ctor)\n  .reduce((statics, k) => {\n    if (k === 'prototype') {\n      Object.assign(statics, classStaticProperies(ctor.prototype))\n    } else {\n      if (k !== 'length' && k !== 'name' && k !== 'constructor') statics[k] = ctor[k];\n    }\n    return statics;\n  }, {});\n}\nfunction convertClass(ctor) {\n  return stampit({\n    initializers: [function (_, {instance, args},) {\n      Object.assign(this, Reflect.construct(ctor, args));\n    }],\nmethods: ctor.prototype,\n\nstaticProperties: classStaticProperies(ctor),\n\nstaticPropertyDescriptors: {\n  name: {\n    value: ctor.name\n  }\n}\n\n});\n}\n```\nPlease, report bugs. :)\nUsage:\n```js\nimport stampit from 'stampit';\nimport PubSubModel from './pub-sub.model';\n// The conversion\nconst oldskool = convertClass(PubSubModel);\n// Now you can compose with it just like any other stampit factory...\nwindow.myThing = oldskool.methods({\n  bar: function bar() { return this; },\n  // your methods here...\n});\nexport default oldskool;\n. Sorry, I didn't test `methods` properly.js\nfunction classStaticProperties(ctor) {\n  if (ctor === Function.prototype) return {};\n  return Reflect.ownKeys(ctor)\n  .reduce((statics, k) => {\n    if (k !== 'length' && k !== 'name' && k !== 'prototype') {\n      statics[k] = ctor[k];\n    }\n    return statics;\n  }, classStaticProperties(ctor.proto));\n}\nfunction classMethods(ctor) {\n  if (ctor.proto === Function.prototype) return {};\n  return Reflect.ownKeys(ctor.prototype).reduce((methods, k) => {\n    if (k !== 'constructor') {\n      methods[k] = ctor.prototype[k];\n    }\n    return methods;\n  }, classMethods(ctor.proto))\n}\nfunction convertClass(ctor) {\n  return compose({\n    initializers: [function (_, {instance, args},) {\n      Object.assign(this, Reflect.construct(ctor, args));\n    }],\nmethods: classMethods(ctor),\n\nstaticProperties: classStaticProperties(ctor),\n\nstaticPropertyDescriptors: {\n  name: {\n    value: ctor.name\n  }\n}\n\n});\n}\n```\n=====\nRegarding your suggestion.\nUsually an object instance created form stamp have this chain: objectInstance -> methodsProto.\nYou are suggesting to break into the prototype chain:\nobjectInstance -> instanceOf_PubSubModel -> methodsProto.\nYou've suggested to make the prototype chain longer. This is exactly what stamps are trying to solve - long prototype chains. Stamp philosophy is to avoid that.\nWhy? Just imagine you want to add one more class into the mix:\nobjectInstance -> instanceOf_PubSubModel -> instanceOf_UserModel -> methodsProto.\nAnd one more:\nobjectInstance -> instanceOf_PubSubModel -> instanceOf_UserModel -> instanceOf_ConfigModel -> methodsProto.\netc.\nThat is very bad long term, although looks like an acceptable solution at the moment.\nMy code actually converts a class to a stamp. It preserves the objectInstance -> methodsProto philosophy.\nI hope that answers.. @gajewsk2 I have implemented and published the official convert-class module: https://www.npmjs.com/package/@stamp/convert-class\nnpm i @stamp/convert-class\nIt fixes one bug in the code example above. So, you might want to use that npm package. :). Since none is creating ES5-style \"classes\" any more, I propose to not implement the convertConstructor at all. The ES6 convertClass is enough nowadays I reckon.\nWDYT?\nIf no objections I'd close this issue in few days.. @FredyC have just told the reasoning why stampit is ES5. Also, few other reasons are listed here: https://github.com/stampit-org/stampit/releases/tag/v4.0.0\nIf someone would rewrite stampit in ES6 it'd be awesome. There are few requirements though:\n Same <1.5kB gzipped size.\n The min.js bundle is ES5 compatible (including Object.assign polyfil).\n All tests still pass (this is the hardest part).\n And have the similar build dist(s) as Preact has:\n\"main\": \"dist/preact.js\",\n  \"jsnext:main\": \"dist/preact.esm.js\",\n  \"module\": \"dist/preact.esm.js\",\n  \"dev:main\": \"dist/preact.dev.js\",\n  \"minified:main\": \"dist/preact.min.js\",\n  \"types\": \"dist/preact.d.ts\",\nFrankly, that's a lot of work! And the benefits are rather small. Tiny modules like stampit do not need all that project infrastructure complexity. Ask Sindre Sorhus :) He was able to develop that myriad or modules because he does not transpile any of them. No transpilation saves time!\nPS: I'd focus efforts on better documentation :) Because the hardest part about stampit is the mind shift from classes.\nLook what I have just started!\nhttps://stampit-org.gitbooks.io/docs/content/ (auto synced to https://github.com/stampit-org/docs)\nI invite anyone to contribute to that gitbook. It's empty atm. Ask me for write access. :). @gajewsk2 probably I need to note that convertContructor is not cancelled. :) Going to make it soon.. Took a read. Thought a lot.\nWhy stampit need ES6 exports?\nThe only useful feature I see is the tree-shaking. However, it's not beneficial for a small module like stampit to provide tree-shaking. There is no gain.\nMy proposal: Ditch the ES6 exports syntax. And simply module.exports = stampit. As the result:\n- CJS (node.js) will work\n- UMD will work\n- ES import statement will work\n- No PITA for us\nBut! We would need to revive ES6 exports in the future @stamp/stamp project.\nWhat do you think?\n. Oh. You mean import init from 'stampit' won't work any more if we leave this line only?\nmodule.exports = assign(stampit, allUtilities);\n. Surely I meant {init} :)\n. In the README.md we say about unpkg.com a\nhttps://unpkg.com/stampit@latest/dist/stampit.umd.min.js\nand cndjs.com\nhttps://cdnjs.com/libraries/stampit\nDid those UMD bundles worked for you?. No worries.. I tested. UMD work now. Here is the installation instructions: https://github.com/stampit-org/stampit#install\nI'm closing this issue. It looks done long ago :). Thanks mate!\n. No worries :)\nThis is not a valid code. Here I fixed it:\njs\nconst stamp = stampit().methods({\n  error: console.error,\n  incorrect(value) { // < -THAT LINE\n    this.error(`value ${value} is incorrect`);\n  }\n});\nNow the this is pointing to the object instance. Basically, that's how JavaScript works.\nCheers!\n. So, yeah. Daniel is correct. \nIf you want to use stamp and args in the other methods you'd need to attach them to the object instance. And then use them as this.stamp or this.args in your methods. \nAlso, don't put arrow functions everywhere. \u263a\ufe0f It's not a silver bullet. \n. We can't use arrow functions as methods because arrow functions bind the \"this\" context to the upper scope. In your case it's the \"undefined\". \nYou need to remove that arrow function as I suggested and you'll be get access to the \"instance\" as the \"this\"  context inside your methods. \n. @neverfox could you please show us code example of the proposed syntax? Otherwise, I struggle to understand code not seeing code. :). Node 4,  npm 2. In the first gist. \nSeems like Dave ran npm test inside the stampit. Which is wrong from user's perspective. But correct from the stampit developer point. \nTell me, why you are running test and eslint inside stampit? Are you gonna help us develop it? \n. Hello again @davewallace \nI'll close this issue for now as not a bug.\nFeel free to reopen if you think stampit can be improved in this regards. Also, this issue is open for discussions regardless of the closed status.\nCheers :)\n. Looks like your eslint issue was a yarn bug. Not sure though.\nCurrently, I'm thinking of improving the infected stamps a bit. I feel the need for more.\nBut looks like you'r doing great atm. :) Have fun!\n. @davewallace here is the proposal. https://github.com/stampit-org/stamp-specification/issues/109\n. Wow. Awesome! \nWe had to put all that code for a reason probably not relevant anymore. \nLet me test it back and forth. There might be caveats. \nWill publish ASAP. \nCheers \n. First of all, thank you very much @Piroro-hs for that cool deep techy contribution. \nI checked the final resulting bundle.\n1) The new bundle now has this code:\njs\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? \nfunction (obj) { return typeof obj; } : function (obj) { return obj && \ntypeof Symbol === \"function\" && obj.constructor === Symbol && \nobj !== Symbol.prototype ? \"symbol\" : typeof obj; };\nwhich replaces the typeof used in the isObject() and isPlainObject(). It's done to support symbols I assume.\nAFAIK we don't need Symbols support in these two methods.\n2) The second issue is that the code above is repeated twice, which increases bundle size for no gain.\nIs there a way to get rid of that \"symbol\" support in those functions?\n\nP.S.\nAgain, this happened again! Bloody ES6, bloody babel, bloody transpiling! I wanna my ES5 days back!\nI'm certain that if the code was ES5 from the beginning we won't ever need PR's like that. :)\n. It would be great is React-native-packager would behave same as node.js - use the main file from package.json.\nI'm liking the Buble approach very much. @Piroro-hs would #267 resolve your issue?\n. Great! Closing this one. :)\n. @Piroro-hs published stampit v3.0.4\n\ud83d\ude03 \n. Wow. Cool! Can we kill package.json->babel too? Please :)\n. Looks like this PR needs to be improved because the folder still contains the bloody .babelrc file. That's one of the issues with the react-native.\n. Good! I need:\n1) stampit version\n2) stamp source code\n3) your benchmark code\n:)\nCheers!\n. Reproduced. This suck! I found the cause. Sorry about that mate!\nHere, I fixed it:\n```\n$ npm start\n\nstampit-benchmark@1.0.0 start /Users/vasyl/code/stampit-benchmark\nnode ./index.js\n\nRunning benchmark...\nStampit x 14,445 ops/sec \u00b11.80% (78 runs sampled)\nPlain object x 10,127 ops/sec \u00b16.99% (77 runs sampled)\nFastest is Stampit\n```\nCould you please allow me 24-48 hours to fix that? (It's Saturday 1 am here.)\nMeanwhile, if you need a workaround see my PR to your repo.\n. It's horrible! The behavior of the fix I found is too different on different node.js versions!\nI copied the test case from above to stampit. Wanted to have a benchmark test in stampit. Here are the results:\n``` sh\n\u250cvasyl@192-168-1-7 ~/c/stampit (master +$)                              \n\u2514> nvm use 6\nNow using node v6.9.1 (npm v3.10.8)\n\u250cvasyl@192-168-1-7 ~/c/stampit (master +$)                              \n\u2514> ./node_modules/.bin/babel-node  --presets=es2015 test/benchmark/\nTAP version 13\nbenchmarking property access\nStampit x 26,613 ops/sec \u00b11.08% (82 runs sampled)\nPlain object x 12,512 ops/sec \u00b11.30% (82 runs sampled)\nok 1 object instances property access must be as fast as plain object\n1..1\ntests 1\npass  1\nok\n```\n``` sh\n\u250cvasyl@192-168-1-7 ~/c/stampit (master +$)                              \n\u2514> nvm use 4\nNow using node v4.6.0 (npm v2.15.9)\n\u250cvasyl@192-168-1-7 ~/c/stampit (master +$)                              \n\u2514> ./node_modules/.bin/babel-node  --presets=es2015 test/benchmark/\nTAP version 13\nbenchmarking property access\nStampit x 517 ops/sec \u00b11.29% (81 runs sampled)\nPlain object x 13,979 ops/sec \u00b11.26% (76 runs sampled)\nnot ok 1 object instances property access must be as fast as plain object\n\noperator: ok\nexpected: true\nactual:   false\nat: Suite.<anonymous> (/Users/vasyl/code/stampit/test/benchmark/property-access.js:76:9)\n\n...\n1..1\ntests 1\npass  0\nfail  1\n```\nYou read it right! Object instances access is twice faster for stamps, but only in latest node.js (v6 and v7). But in node 4 it's horribly slow regardless!\nI'm trying to find the best workaround to fix the thing for all VMs.\n. Okay. Here is the story.\nTL;DR V8 runtime optimizations depends on too many things.\n\nNode.js v4 and v5 kick the \"class-object\" optimization somewhat differently to v6 and v7. They've changed something internally at some point.\nSo I changed the benchmark a little. Made sure it behaves the same on all node.js versions we support.\nI made the benchmark as a tape test under test/benchmark/.\nI fixed the slow performance issue. Property access should now be almost as fast as plain objects.\nThe bugfix PR is here: #270\nWill publish the new release as soon as PR gets merged.\n\nThank you very much @tdzienniak for the issue. Consider creating new issues if you find something similar.\n. Travis CI has these benchmarking results:\nv4\nStampit x 16,229 ops/sec \u00b10.93% (82 runs sampled). Plain object x 13,175 ops/sec \u00b11.71% (86 runs sampled)\nv5\nStampit x 9,167 ops/sec \u00b13.73% (76 runs sampled). Plain object x 10,101 ops/sec \u00b14.31% (77 runs sampled)\nv6\nStampit x 20,973 ops/sec \u00b10.55% (83 runs sampled). Plain object x 10,199 ops/sec \u00b19.37% (87 runs sampled)\nv7\nStampit x 16,355 ops/sec \u00b110.86% (84 runs sampled). Plain object x 11,150 ops/sec \u00b12.12% (87 runs sampled)\nThe code for the test is here.\n. v3.0.5 was just published. Enjoy!\n. Thanks @FredyC !\n. lol\n. Published.\n. After trying it out I found that the simplest and the most universal API would be this:\njs\nconst HaveComposer = stampit.composers(function ({stamp, composables}) {\n  console.log('Resulting stamp:', stamp);\n  console.log('Was made of composables:', composables);\n});\nThe implementation will still be specification compatible. The \"composers\" will be attached to the deepConfiguration as the .composers array. It will be deduped just like initializers array is.\nThe provided composers will be invoked immediately after being passed to the compose():\njs\nstampit.compose(AnyStamp, {composers({stamp, composables}) {\n  assert(composables[0] === AnyStamp);\n  assert(typeof composables[1] === 'object');\n}});\n. Providing the use case scenarios as a Fun with Stamps. Episode 11. Interfering composition\nhttps://medium.com/@koresar/fun-with-stamps-episode-11-interfering-composition-7abc44ac1f99\n/cc @FredyC @amelon. Done. Every time it upgrades - something breaks. :(\n. I did not. Greenkeeper doesn't do it's job good enough.\n. > Does it classify as a bug?\nNope.\nThere are few ways to solve that.\n1) The default actionName should be undefined instead of null. Then it will work as expected.\n2) I'd have HaveTrigger stamp instead of the EngineAction. Because EngineAction just too bulky and duplicates Action.\n3) ...\nI see statics abuse in your code. Have you considered configuration/properties instead?\n. Anything to discuss here? Can you consider closings this one @fredyc?. Thanks @gfot\nCongrats on your first pull request! \ud83d\udc4d . At least API.md better be reviewed.\nOn Fri, 9 Dec 2016, 00:09 Daniel K. notifications@github.com wrote:\n\nHm, not sure why you want review from me. I am big fan of this change\nreally :) I will try to have a look later on. You consider this merge-ready\nthen?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/pull/283#issuecomment-265736018,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABjCL3life_m-NunJZK9E0xB32dQRn5tks5rGAF9gaJpZM4LHyFk\n.\n. Will merge the PR in 24h.. Thanks mate! I'm writing a new Fun With Stamps now to give an example of the feature.. That sounds like a PR. Eh?. @iamgollum PR is ready. Here you go: #296 \nCan you check if anything is missing from the examples? Or anything should be added?. Done. I shall try. Thanks for bringing the attention.. I HATE TRASNPILATION!\n\nIf you run it like so:\nbabel-node test/benchmark/property-access.js\nAll good. Stampit objects are even faster than plain objects.\nBut if you run it like so (under node v7.4)\nbabel-node --presets=es2015 test/benchmark/property-access.js\nit fails!!! Stampit prop access is 10x slower.\nSource code of the file is below:\n\nClick to expand\nconst Benchmark = require('benchmark');\nconst newObj = () => ({components: {position: {}, velocity: {vx: 10, vy: 10}}});\nconst COUNT = 5000;\nconst stampitEntities = Array.from(Array(COUNT)).map(() => Object.assign(Object.create(null), newObj()));\nconst normalEntities = Array.from(Array(COUNT)).map(() => ({\n  components: {\n    position: {\n      x: 10,\n      y: 10,\n    },\n    velocity: {\n      vy: 10,\n      vx: 10,\n    },\n  },\n}));\nfunction runArray(arr) {\n  const DELTA = 16;\n  for (let i = 0; i < COUNT; i += 1) {\n    const entity = arr[i].components;\nentity.position.x += (DELTA / 1000) * entity.velocity.vx;\nentity.position.y += (DELTA / 1000) * entity.velocity.vy;\n\n}\n}\nconst suite = new Benchmark.Suite();\nconst results = [];\nsuite\n  .add('Stampit', () => {\n    runArray(stampitEntities);\n  })\n  .add('Plain object', () => {\n    runArray(normalEntities);\n  })\n  .on('cycle', (event) => {\n    results.push(String(event.target));\n  })\n  .on('complete', function () {\n    console.log(results.join('. '));\n  })\n  .run();\n. @FredyC ready to merge.. There were few breaking changes in the recent stampit v3\nhttps://github.com/stampit-org/stampit/releases/tag/v3.0.0\nPlease check if any of those relate to your code. \nOtherwise, I can investigate. \nWaiting for your investigation. \nCheers . I found the bug. Here is the breaking change described on this page: https://github.com/stampit-org/stampit/releases/tag/v3.0.0\n\n\nThe factory first argument properties are no longer automatically assigned to the instance.\n\nStampit v2:\njs\nconst Stamp = stampit({ init({instance, stamp, args}) {\n  console.log(this); // {foo: \"bar\"}\n}});\nStamp({foo: 'bar'});\nStampit v3:\njs\nconst Stamp = stampit({init(arg, {instance, stamp, args}) {\n  console.log(this); // {}\n}});\nStamp({foo: 'bar'});\nA workaround can be implemented as a separate behavior (stamp).\njs\nconst AssignFirstArgument = stampit({ init(opts) {\n  Object.assign(this, opts);\n}});\nStamp = AssignFirstArgument.compose(Stamp);\nStamp({foo: 'bar'}); // {foo: \"bar\"}. I'd recommend sticking with stampit v2. npm install stampit@2 instead of the latest.\nCheers. Thanks @amelon !\nI'll put some code examples for @giper45 \n```js\nconst outerObject = {\n  name: \"outerObject\",\nf1: function() { // <---------- regular function\n    console.log(this); \nconst innerObject = {\n  name: \"innerObject\",\n  f2: () => { // <---------- arrow function\n    console.log(this);\n  }\n};\n\ninnerObject.f2();\n\n}\n};\nouterObject.f1();\nThe code above will print:\n{ name: 'outerObject', f1: [Function: f1] }\n{ name: 'outerObject', f1: [Function: f1] }\n``\nIt prints the same object! Why? Because arrow functions (f2) [INHERIT](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions) thethiscontext of the running function (f1`).\n\nThere is a way to use arrow functions as initializers. Here it is:\n```js\nconst Availability2 = stampit().init((_, {instance}) => {\ninstance.open = function open() { }; // See this instance variable?\n  // ...\n});\n```\nIf any questions feel free to ask.. Thank you for reporting.\nIt requires some investigation. Are you in the position to help?\nOn Fri, 28 Apr 2017, 23:35 Michael H. notifications@github.com wrote:\n\nHello everyone,\nsorry, but am I just blind/an idiot/dumb or aren't the examples found in\nthe readme working?\nI installed stampit via bower via \"bower install stampit\" an have the\nfollowing code:\n\n",
    "jtenner": "@koresar I had to deal with this limitation myself, so I wrote something similar to stampit for my own personal use.\nStarShine does something similar.\nAccepting parameters inside the closures is definitely useful.\n. Why isn't this syntax possible?\njavascript\nfunction func(a, b) {\n   //do something with a/b\n}\nvar stamp = stampit().enclose(func);\nvar obj = stamp(1,2);\n. @dilvie Please see https://github.com/dilvie/stampit/pull/20\nThis is how my library does it and I would be more than happy to help make more changes to ensure API coverage.\n. @dilvie It adds SOOOOO much value though. Let me know how the testing goes, or if I can help!\n. # Caching Slice is a good idea\nFirst, definitely cache the slice function as a local variable for sure, (this makes it slightly faster with minimal size increase.)\n``` javascript\n//in another context\nvar slice = [].slice;\n//inside factory definition\nvar args = slice.call(arguments);\n```\nAwkward parameter mixin problem\nThe behavior that @koresar is talking about is correct and is a really weird (and expected) side effect.  Another example that I tried (straight out of node console output):\n``` javascript\n\nstampit().enclose(function(a){this.a = a;})({}, 1)\n{ a: {} }\nstampit().enclose(function(a){this.a = a;})(1)\n{ a: 1 }\nstampit().enclose(function(a){this.a = a;})({blah:'bleh'})\n{ blah: 'bleh', a: { blah: 'bleh' } }\n```\n\nThis is definitely not expected behavior because it could be VERY misleading.\nTry changing this line:\njavascript\n +        args = slice.call(arguments);\nto this line:\njavascript\n+      args = slice.call(arguments, 1);\nNow the syntax reads like this (backwards compatible):\njavascript\nstampit().enclose(func)(props, params....);\nThis syntax works and doesn't break anything in production. One could still argue that this is misleading, because now the API consumer now has to remember that the first parameter gets mixed into the object itself (not a bad idea, but misleading nonetheless.)\nMy votes (in order of desired behavior):\n1. Actually remove the awkward properties mixIn parameter (because those can be added later via manual mixin) and break backwards compatibility. (this is very violent, but I like it better and has more uses)\n2. add parameters onto the factory constructor function definition to keep backwards compatibility (this is probably the safer option, but well behaved programmers rarely make history)\n3. use the optional stamp.construct function outlined above by @koresar. (I think this idea isn't EXACTLY in the spirit of factory construction along the lines of what @dilvie had in mind when he created stampit.)\n. Hope @dilvie is okay.\n. Alright!  The master has spoken.\nI fundamentally disagree with @dilvie on number 1. (It's certainly okay to disagree, in fact that's why I wrote my own factory library in the first place.)\nRevisiting option 2\nI'm not exactly sure what you mean by saying Number 2 won't fix the problem.\nThis will not break backwards compatibility\nOn line 77:\n``` javascript\n  #/stampit.js\n  //cache slice at the top of the file...\n  var slice = [].slice;\n  //then do this:\n  factory = function factory(properties) {\n      var state = merge({}, fixed.state),\n        instance = mixIn(create(fixed.methods || {}),\n          state, properties),\n        closures = fixed.enclose, params = slice.call(arguments, 1);\n  forEach(closures, function (fn) {\n    if (typeof fn === 'function') {\n      instance = fn.apply(instance, params) || instance;\n    }\n  });\n\n  return instance;\n};\n\n```\n\nIn fact, if I managed to miss something, please let me know! This increases your code coverage by adding a really scalable feature, that only adds 2 lines of code to your project (and modifying one more!)\nBest of all, it doesn't break any of your older tests.\nI can re-fork the entire project, write the test scripts for you, AND you won't have to lift a finger.\nOnce again, craving @dilvie and @koresar 's thoughts.\n. Thanks for clarifying. I just wanted to make sure that I didn't come off as \"attacking\" in any way.\nSo given my ideas don't mesh with the vision of the project, I have no suggestions to follow, nor do I feel like I can be constructive to help move this project forward, because I think this particular pull request has the potential to be dangerous for the exactly the same reasons you stated above.\nI am convinced that it is dangerous to do more than one thing with the factory parameters.\nWith that in mind, I'm seriously considering making time to fork Stampit and maintain a different repo for those who want factory constructor parameters, and pulling everything downstream from your repo.\nThe question is, which direction are you going to take it @dilvie?\n. ",
    "pluma": "Thanks for your response.\nI'm aware of your articles and talk. I did not mean to imply stampit had class inheritance, I was just noting that it did not have delegating inheritance, i.e. if you try to derive one stamp from another, the result will be a concatenation of both stamps' prototypes, so changes to either stamp will not be reflected on the \"child\" stamp.\nFor clarification: I am using the term \"prototype\" to refer to what is passed to Object.create, i.e. the resulting object's [[Prototype]] (or in your explanation, the \"delegate prototype\"). I'm not familiar with the term \"exemplar prototype\", but stamp.fixed.state is (if only in implementation) de facto equivalent what is called defaults in most JS libraries. Based on your response in the issue about the naming of enclose I understand why you decided against naming it something like initialize even if that seems descriptive (initializePrivateState would probably be even more correct, but a bit unwieldy).\nI understand that the naming is intentional, but because it differs from the naming used by other JS libraries sharing the same or similar concepts, I don't think their naming clarifies their intent without sufficient background knowledge or an explanation like the one you provided.\nDespite having read several articles on the issue, I'm still not entirely convinced that prototypical inheritance is necessarily superior to classical inheritance -- the lack of support for multiple delegate prototypes in JS certainly limits the usefulness of having delegate prototypes in the first place (especially in a library like stampit that wants to provide a mechanism for \"type\" composition -- I wrote a dummy that uses harmony direct proxies but I'm not happy with that either, nor with the simplified version that only deals with delegation).\n. ",
    "dannyfritz": "I see #11 is already about this. And it uses the same method.\n. Basically, I'm trying to create a controls library: http://jsbin.com/jonuz/8/edit?html,js,output\n\nIt seems kind of annoying to pass in each value individually with a setter after instantiation.\njavascript\nvar thing = f().name('foo').element($control).label('jellyfish').value(10);\nAs opposed to using an options object:\njavascript\nvar thing = f({\n  name: 'foo',\n  element: $control,\n  label: 'jellyfish',\n  value: 10\n});\n\nI am passing an $element into the stampit factory to create the control on instantiation. I suppose it wouldn't be the end of the world to write a this.initialize function. But it does require one extra line for the controls developers to write that doesn't seem necessary. But I suppose also adds a little bit more flexibility.\n\nAny feedback appreciated! :smile: \nJS really does beg me to use this sort of pattern as opposed to classical inheritance. Thanks for your work on stampit!\nEDIT: I found a really interesting article on creating controls with mixins:  http://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/\nEDIT2: Twitter Flight also has an intriguing mixin API: https://github.com/flightjs/flight/blob/master/doc/mixin_api.md\n. Yeah, functional mixins seem to miss out on the flyweight pattern without making them ugly. Thanks for the c+c. :+1: \n. ",
    "wonbyte": "@ericelliott Please let me know if you need any help with optimization. \n. ",
    "anhhh11": "I use browserifyI and just run and see task manager CPU usage.\nMy test here: http://jsfiddle.net/4pjec0bv/\n. Thanks, stampit work well; I've add large Source Mapping to workspace.\n. ",
    "foxaal": "Thanks for that.  For some reason, the idea of a switch to pop source code out of stampit factories is intriguing...  But now that I have learned to get stampit working wherever, node, meteor, client, server, the stampit black box is the gift that keeps on giving...\n. Stampit \"properly\" organizes and simplifies how you code, and so should its generated documentation.  This should just work.  Jsdoc does not fit the bill because it must be coerced to fit the stampit pattern.  This seems backward.  I don't think it is the way forward, even though it can sort of work using @instance, @memberof, @enum, and other stuff.  But then again, I don't even know the naming conventions, or if there are naming conventions, for the factory style, nor have I looked at the jsdoc source code. \nConjecture: there exists a sweet spot between human readability / usability ( high level language and pattern ) and what is really going on under the covers ( think Turing complete, BF language, etc. ).  Javascript / stampit is an order of magnitude closer to that sweet spot than the classical inheritance strait jacket.\nQuestion 1 :  If the conjecture is true, all code using pure javascript needs to eventually get rewritten according the the stampit pattern ( unless an even better pattern is made usable ) .  Assuming that all javascript applications need to be rewritten from scratch, then from a reasonably coarse grain perspective, what would the first block of stampit factories combine into ?   A javascript interpreter ?  Could these parts and pieces then be much more easily composed to produce an IDE and doc generator than trying to hack jsdoc, esprima, or what have you ?\nQuestion 2 : Am I smoking too much javascript / stampit crack? \n. On the conjecture muse, here is another way to phrase my question:  You have an editor and a browser that runs javascript. What is the first piece of code to write?  Let's say it's stampit.  A very high ratio in terms of utility to number of lines of code.  An interesting question might be: what piece of code would have the next highest ratio?  And would it use stampit?  The Flow thing looks most interesting -- thanks for the pointer to that, and to Literate CoffeeScript.  There's like a renaissance out there...\n. Took a look at Docco -- shows me how crappy some of the comments littering my code really are...  (I see underscore.js makes good use of it:  http://underscorejs.org/docs/underscore.html )  But I want more.  I am using stampit in a project, and the code seems so organized and easy to work with that so too should be its \"self\" documentation piece...maybe could be a namespace / refactoring tool as well...\n. If you start hunting around Wikipedia regarding the terms \"compose\" and \"combine\", you quickly come to the realization that \"compose\" makes more sense against the past. The term \"aggregate\" also come up, but \"combine\" seems to be nowhere. Is the objection to \"compose\" that it might get confused with matrix composition? \n. Here are some interesting references that seem relevant:\nhttp://en.wikipedia.org/wiki/Composition_over_inheritance\nhttp://en.wikipedia.org/wiki/Object_composition#Aggregation\nIt is very important to get the naming to be consistent with the art.  I'm not sure an opinion poll is the way to go.  Better to see reasoned conversation leading to a higher ground for all -- best reasoning wins for everyone.\n. \"join\" sounds like a relational database.\n. Meteor uses \"use\" to throw packages into the same app:  api.use(\"jquery\") for example.  But the old \"compose\" seems well-suited to what stampit is trying to accomplish -- and less nebulous.\n. I would agree.  After all, \"Composable object factories\" is the original hook for stampit. \n. Yes, and then the term found its way into computer science. \nhttp://en.wikipedia.org/wiki/Function_composition_%28computer_science%29\nFunction composition versus object composition:\nhttp://en.wikipedia.org/wiki/Object_composition\nStampit's compose function seems more like what is called \"aggregation\" in the link above on object composition...\n. @Owen -- whoops, sorry for my confusing comment -- so you are saying \"composition\" as a term in computer science entered in the days of moving beyond goto.  @Eric -- got it.  \"Function composition\" seems to exactly match the mathematical composition.  \"Object composition\" maybe has some flavors ranging from concatenation at the most elemental, to something like lodash 3.0's merge function, at another level.  Merge superimposes or projects one object onto another.\n. ",
    "backspaces": "Is there any reason not to just use Docco?  I find the jsdoc approach less useful than a simple description  of what the code is doing.\nI guess it's important to distinguish between \"dev\" docs (how it all works) and \"api\" documentation (what the inputs and outputs are).  For teams, the dev docs are more important, for users, api.\nFor stampit, I'd prefer dev, thus docco.\n. Sorry to be late to the show.  \"compose\" is a term used in mathematics when one function wraps around another.  It was used in the early days of \"structured programming\" (remember \"goto considered harmful?) to prove that only a few primitive control constructs were needed in languages, and to prove goto was not needed.\nLet f(x) = ... and g(y) = .... then f(g(x)) is the composition of f & g.\n-- Owen\n. ",
    "talon": "Thanks will do!\n. This seems like a useful feature. When reasoning about an application the developer can more easily keep track of unwanted side-effects. It might also be helpful to have an optional \"strict\" mode of sorts that prevents prop collision by throwing an error.\n. Could be a per stamp setting maybe to provide a sort of constant prop? I'm only conceptually speaking here, just thought it would be worth considering.\n. Rough prototype of how it might work\njavascript\nfunction checkClashes(objOne, objTwo) {\n  var props = Object.keys(objTwo)\n  Object.keys(objOne).forEach(function(key) {\n    if (props.indexOf(key) !== -1) {\n       console.warn('Merge overrides props.')\n    }\n  })\n}\nAllows developer to keep track of overrides therefore identifying unwanted overrides.\n. Yeah this would be nice. Perhaps something like stampit.is(stamp, obj) then the original stamp becomes the \"type\"?\n. Looks like probably your best bet is using this if you must: https://www.npmjs.com/package/is \n-1 for putting it in stampit core\n. Good stuff. Great discussion, my only concern is documentation but it looks like #83 incapsulates that. :+1: \n. ",
    "JosephClay": "My only concern is that stampit.state(state) implies that state is being configured on stampit and not the returned stamp; but the docs are pretty clear on stampit returning factory functions. Convenience over explicitness?\n. I've ported the QUnit tests to tape.\nThings of note: \n- I had to install lodash as a dependency in order to build (#51)\n- tape-run requires phantomjs to be installed globally\n- browserify has a conflict with grunt-browserify, so I was unable to install it in the package.json to follow tape-run's convention. There is, however, a tape script that can be run if you have browserify installed globally: npm run tape\nI'm not familiar enough with Sauce Labs to know how to integrate it with tape-run.\n. Merge away.\nI'll try my hand at #56 ...what's the worst that can happen? \n. I added the .travis.yml and configured npm test to run the tape tests. Travis will still need to be setup via sign in and webhooks.\nIn order for browserify/tape-run to work (and not conflict with grunt-browserify), I moved the grunt tasks to npm scripts. I have left the gruntfile and test html file in the project for posterity, as it has the saucelabs configuration. \nIs the intent to get both travis and sauce integrated? If not, I can remove a couple more files.\n. Done\n. Testing locally, if I force a test to fail, I'm seeing:\n```\ntests 114\npass 113\nfail 1\n```\nIf I put in a TypeError, e.g. stampit.doesNotExist(), it does hang. Not sure why.\n. Awesome.\nI'm running into a jshint error \"cannot open test/*\" with test/*...seems to work passing test without the slash+wildcard.\nmixer.js also has some lint errors. \n. @unstoppablecarl Would be possible if the arguments were known for .mixIn, but I don't think it would be worth duplicating the function for an optimization.\n. @troutowicz No, objects is being listed as a parameter, but is not being used. The function is looping through the arguments Object.assign style. see: https://github.com/ericelliott/stampit/blob/init-making-stampit-flexible/mixer.js#L25\n. @ericelliott Agreed\n@troutowicz I think we're both saying the same thing\n. I like the red one\n:clap: @unstoppablecarl \n. Sorry guys, just getting to this now.\nIRL, I use stampit much like @koresar does. The immutable chaining makes composition clearer and (most importantly) easy to learn.\nAny terms of what is \"faster\" should be ignored as a pro. Object construction isn't/shouldn't be a pain point in an application and the current version performs well.\nI'm fine with the workaround as long as there's still the option to use v2 as is. Modularization to the point of importing 5+ functions works, but puts the burden of setting up the libs' surface area on the user every time. To me, it feels like an extreme and so is still a workaround.\nAlso, stampit is offered over a CDN, so the ES5 equivalent code to the above functional import version would be:\njs\nvar stampit = window.stampit; // do not use!\nvar compose = stampit.compose;\nvar init = stampit.init;\nvar props = stampit.props;\nvar methods = stampit.methods;\nvar stamp = stampit.stamp;\n. @troutowicz I'd argue that the example is not cleaner. I would rather import a validator stamp and, if I'm not composing multiple stamps, use stampit's immutability to create a new stamp. \n``` js\nimport validator from './validator';\nconst validatedStamp = validator\n    .init(function() { ... })\n    .props({ body: { ... } })\n    .methods({ ... })\n    .prevalidate({ put: { body: joi.required() } });\n``\n. I'm not arguing that the fix won't work. It just feels like a hefty solution to a problem I don't see occurring often.stampit` doesn't have a ton to protect (7 properties?).\nIf we implement a warning when passing a colliding static and not overwrite stampit's static, then the user can work around the issue.\n``` js\n// pseudo code\nimport stampit from 'stampit';\nimport { EventEmitter } from 'EventEmitter';\nconst EventEmittable = stampit.convertConstructor(EventEmitter)\n    .init(() => {\n        EventEmitter.init.call(this);\n    });\n```\nPros:\n- Easy to catch collisions\n- Puts the power in the user's hands\n- No change to API\nCons:\n- It's hacky, but converting a constructor is already hacky.\n. Sample warning logic (not tested)\n. ### descriptors:\nOne of the shortfalls that I've experienced with v2 has been with descriptors, as Object.assign() doesn't correctly copy over items like { get foo() {}, set foo() } whereas class does. Would descriptors solve this and how would it solve this (in both ES5 and ES6)?\nAlso, would creating a stamp with a descriptor { writeable: false } be able to safely be composed with another stamp with the same descriptor?\nother stuff:\n\nIf only one stamp is passed to compose(), should it noop instead of defaulting? Would it follow the principle of least astonishment for it to be a clone() if only one stamp is passed?\nIs merge the replacement for deepProps? I commonly refer to it as _.merge due to lodash.\nI like @koresar's comparison to the Promise spec. I don't believe we will be able to make the spec shorter or more concise than A+ simply because object/factory creation is a broader scope...but it should be a goal.\n\nEdits: spelling, pronouns, derps\n. I believe we have to define the terms we use in the spec, otherwise the interpretation is arbitrary (e.g. merge, references vs properties etc...). \nAlso, initializers must be described in the spec to remove ambiguity. Any guesswork here by the implemenation will mean that different composable libs won't work together. For example, all A+ compliant Promise libs must conform to .then()'s specification...so everyone can:\n``` js\n// dummy code\n(new Promise()).then(function(onFulfilled, onRejected) {});\nvar Promise = require('promise');\n(new Promise()).then(function(onFulfilled, onRejected) {});\nvar Promise = require('bluebird');\n(new Promise()).then(function(onFulfilled, onRejected) {});\nvar Promise = require('q');\n(new Promise()).then(function(onFulfilled, onRejected) {});\n```\nEven if the answer is \"nothing/you decide\" we should answer:\n- What's the context of initializers?\n- What parameters are passed?\nOutside of that:\n- Define how assign/merge/statics are merged. Which are deep, which are not, which use Object.assign and which use Object.defineProperties etc...\n- Define what happens if \"invalid\" configurations are passed. What happens to foo in .compose({ foo: 'bar' }).\n. ## Terminology\n- composable: a factory function that creates stamp instances.\n- compose: a function that combines stamps and plain objects into a new stamp descriptor.\n- stamp: an object returned from a composable factory using a stamp descriptor.\nstamp descriptor:\nA map containing the following properties and values:\n- assign: a shallow map of property name and values attached to the stamp on stamp creation.\n- merge: a deep map of property name and values attached to the stamp on stamp creation.\n- methods: a map of property name and function values that are added to the stamp's prototype on stamp creation.\n- statics: a map of property name and values attached to the composable.\n- initialize: a function to be executed against the stamp's scope on stamp creation.\nTODO: find a place for this to sit\ninitializers\n\nIf the object instance is a plain object, then the initializer context will be the plain object.\nIf the object instance is not a plain object, then the initializer will be bound a temporary references object.\nThe initializer always receives an object as a first parameter containing:\nstamp: the current state of the composable factory.\ninstance: the current context of the initializer.\nargs: the arguments passed to the composable on invokation.\n\nmerge, assign, statics\nTODO: define the expectation of the end result of each object. e.g.\n- {writeable: false} will throw an exception on merge when x\n- Use Object.defineProperties for assign\n- Use Object.assign for statics\n- Use _.merge for merge\n- Use Object.assign to combine merge and assign into properties.\n. ^ please correct if anything is amiss\n. > I believe you are largely confused on what stamp is. :)\nI am! After reading through your comments and re-reading this thread and the stampit README, I'm starting to see where I'm going wrong. My brain is tangled :smile:.  I'm using stamp and object instance in the wrong places (or worse, interchangably).\n\nIMO stamp descriptor is a part of stamp, but not the stamp itself.\n\nI see. I was seeing them as the same thing due to the specifics of the descriptor being accessible from the stamp.\n\nComposable and Stamp are essentially the same thing. Have you heard of Thenable and Promise? It's the same.\n\nI can see the relationship you're trying to define here. They're not quite 1:1, but pretty close concept.\n\nI'm hugely against any exceptions. Long to explain, but this is to implicit. Sometimes object creation will throw, sometimes will not... Inconsistency sucks. Better skip conflicting properties.\n\nI'm not on either side of this one...but it shouldn't be an idle decision. Seems that it could work either way.\n\nThe rest of your comments are spot on. Between your comments and EE's updates above, I think I'm on track.\n. ES6 looks good, but I find the silly example is more clear to me than the real life. Personal preference.\n. @unstoppablecarl What I understand of symbols is that they're a way to make properties \"private\" in javascript's class-ish-based programming, since privacy via encapsulation is lost. It's privacy via obscurity.\n. We have an example of using EventEmitter with convertConstructor here. \nThere is also stampit-event-bus as an alternative.\n. Do we get significant savings if we change all usages of lodash to lodash/function so that we're not bundling the entire library?\ne.g.\n``` js\n// not this\nconst _ = require('lodash');\n// _.mergeWith\n// this\nconst mergeWith = require('lodash/mergeWith');\n```\n. @FredyC I've done the same. Powerful features are easy to abuse.\n. @pdavidow  It is documented:\n\nAn arrow function expression has a shorter syntax compared to function expressions and lexically binds the this value\n\nMDN\nScoping of this is a feature of the language.\n. Awesome use of Reflect. I always wondered how to get around the new problem with arguments. Here's the pertinent line of code from a reflect shim.\njs\nreturn new (Function.prototype.bind.apply(newTarget, [null].concat(args)));\n@FredyC Tried it, can't get it to break. Are there edge-cases where this won't work?\n. UMD = Universal Module Definition\nUsed to expose code to different module systems. Those are some impressive gains. ",
    "StevenPerez": "\ud83d\udc4d\ud83c\udf89\ud83c\udf8a\n. ",
    "FredyC": "Found a reference to this on gitter and I am just curious if duck typing is sort of the same thing as type checking? I mean there are things like flow-runtime which can turn static types to runtime checks, so is there any actual difference?. I don't care about instanceof, I agree with @ericelliott that it's misleading. The flow-runtime just turns static typings into runtime code.\n```js\nconst MyStamp = methods({\n    convert(input: string): number {\n        return Number(input)\n    }\n})\nfunction myFunctionExpectingStamp(obj: { convert: (string) => number }) {\n    // everything is cool, the obj.convert is what we need\n}\nmyFunctionExpectingStamp(MyStamp())\n```\nYou can try here what is produced: https://codemix.github.io/flow-runtime/#/try. > Flow uses structural typing for objects and functions, but nominal typing for classes.\nhttps://flow.org/en/docs/lang/nominal-structural/\nHonestly these are new terms for me :) \nAnyway in the example above it's clearly a structural check, so it can be considered same thing as duck typing. From my understand the duck typing is something like this, right ?\njs\nfunction myFunctionExpectingStamp(obj) {\n    if (!(obj && typeof obj.convert === 'function') {\n        throw new Error('missing convert method');\n    }\n}\nUsing type checker it looks much more clean, readable, reusable and much more robust in my opinion. So my question could be: \"Is duck typing obsolete?\". I agree with @koresar. People running software that no longer has any support are just shooting themselves in the leg. I mean why open source should support them when Microsoft itself doesn't?\nBtw, don't forget about the Edge. If you don't know about it, it's a Microsoft browser in Windows 10 with much faster release cycles. They are are almost done implementing whole ES2015 in it, even modules.\n. I suppose this is no longer valid here since convertConstructor is planned to be moved to stamp-utils eventually. Feel free to reopen if I've missed something here.\n. @davewallace I think that such RPG game is definitely great use case for stamps. \ud83d\udc4d \nDecomposing is no easy matter. There are no internal records of what stamps were used in composition. Essentially you would need to do such tracking by yourself with infected compose.\nHowever in the end you will have to create fresh new stamp based on information you have collected before. In my opinion it might be somewhat easier to actually compose from the scratch if you have a list of things you want to compose together. I assume you store entity data in regular properties. Then you can easily compose necessary stamp and do stamp.props(oldEntity) which would copy properties of the old entity to a new one. \nUnfortunately there will probably some leftover data when from its previous specialization. That could be solved by actually passing props to a factory function call and every initializer in those small stamps could grab whatever it needs and store it on the instance.\nEdit: Perhaps I should also mention one important thing. Once you have actual instance of some stamp, you cannot essentially compose more stamps into it dynamically. I am not saying it's impossible, but will be rather hacky because you would need to modify prototype of that object in runtime. That might have unforeseen side effect that all instances coming from that stamp would be affected too.\n. So I essentially tried to do this:\nconst Tree = compose(Persist);\nconst Subject = compose(Persist);\nEach in separate file so I can clearly see in that file dependencies. However there is a problem with init.\nconst Persist = init(({ instance, args: [adapter]}) => {\n    instance.adapter = ensureAdapter(adapter);\n});\nThis causes it to be run twice or even more times when required in other stamps. How else I can solve it? It doesn't make much sense to me to have everything in entry point stamp only. It even makes tests harder as I have to add dependent stamps into the mix when testing them separately.\n. Thanks, I guess that will work, although it's gonna be ugly for initializers which are not supposed to store anything on instance. It will create unnecessary clutter.\n. @koresar For example initializer which does asynchronous call and returns a promise. You don't need to store anything on instance in that case.\n. Hm, if I understand correctly, this won't work if there is actually more initializers where each runs its own async operation and returns promise, right? With that condition it would just run first one, am I correct? Unfortunately I will surely need multiple async initializers.\nBtw, shouldn't that condition be typeof instance.then ?\n. > None is using that async feature of stampit v2. So we're dropping the support and removing that huge chunk of useless code.\nAnd who is actually using stampit that you can say with such certainty that nobody is using that feature? I mean I don't see much of traffic here, it's still yet to discover thing so removing something based on how much it's used doesn't seem relevant.\nI kinda like an idea of calling a factory, obtaining promise that will tell me when everything is ready and giving me the actual API object that way. This is great as you cannot actually use any methods till init promises are finished. You can easily avoid any checking in those methods as you know that they wont be used till data are loaded. That's simply brilliant and in my opinion much less error prone approach than creating object with factory and then calling some manual init method to start async operations. \n\nI'll show you how to easily implement the limitation using few different approaches. :)\n\nFor now it's quite simple. Bunch of separate stamps like Tree, Subject, Node and each one wants to load it's data from the persistence adapter upon initialization. It will be memory first approach, so it will load everything, work with data in memory and persist in background. Thus it's only needed to wait during initialization, not anytime later.\n\nClasses do not natively support multiple promises in constructor. Let's know the difference between chalk and cheese. Sync is sync, async is async.\n\nAnd is that wrong ? These are not classes, so why it cannot offer something extra that classes cannot possibly offer? Is there any chance to support that functionality through the stamp? If not, I strongly object against removing it unless you convince me there is 'easy' way how to do it with all that requirement I have.\n\nActually, the instance and this is the same object reference.\n\nWell so this is the most confusing part. Some examples are using this and other instance. If they are truly the same, why to have the instance there?\n. Alright, I've got it. Luckily I noticed that v2 supports statics too, that helped a lot. Now I can simply write invariant(SubjectModel.isCreatorOf(subject), 'subject model expected') and it works like magic :) Here it's implemented\n. Thanks, but I am not sure how could that help me. At first I was thinking in that direction too, storing stamp reference in init and adding instance method to check it. However usually I just have an object which might be even null or something different. That would become too bloated if I would need to do subject && subject.isInstanceOf && subject.isInstanceOf(SubjectModel) for every check.\nIn the end I had to go with static method. That doesn't have access to final stamp object thus creating private Symbol to identify this was only good way to go. That's also the spot where I found out about supermixer issue and instead simple refs({ [mySymbol]: true }) I had to go with that ugliness init(({ instance }) => { instance[mySymbol] = true; }).\n. I like my approach with Symbol because it's universal. With so much changes coming in v3, I don't want to end up rewriting everything. Actually how close are you to releasing v3? Is it matter of weeks or something much longer?\nDuck typing is nice - sometimes, but in my case would be horrible. Since all my models have the \u02d9id\u02d9 property, I would need to check for some other property. I would need to do something like obj && obj.getTreeId. Anybody looking at that code would think all but nice things about me :) Since I am doing this check purely for validating input into method, there isn't really any relevant method or property to check.\n. That would be nice, I am more willing to change to v3 now before I write most of stuff in v2 so I can help out with polishing it.\n. Um, I am confused now, why it needs to be an array? This has never been a need in v2 and I can even do this and that works correctly. Wrapping to array just seems completely unnecessary step.\n``` js\nexport default Model('Tree').compose(\n    Property('name'),\n    Property('description'),\n    stampit({\n        initializers: initializeTreeModel,\n    })\n);\n```\n. Or perhaps it will be less misleading since it's plural, not singular. I just realized I can do fancy stuff like this and avoid hassle of typing explicit array there. I am really starting to love this :)\n``` js\nfunction Initialize(...initializers) {\n    return stampit().initializers(initializers);\n}\nexport default Model('Tree').compose(\n    Initialize(initializeTreeModel),\n    Property('name'),\n    Property('description'),\n);\n``\n. I tried this in RC1 and still not working, thebuild` method is not available.\nconst NodeModel = Model('Node').compose(\n    Getter('name'),\n    Getter('description'),\n    { statics: { build }}\n);\n\n\nexport default Model('Tree').compose(\n    Initialize(initializeTreeModel),\n    SetupPropertyName\n)\n.setupPropName('name', 'description');\n\nFrankly this looks terrible :) I don't want to expose a way how to add more properties to the model from outside.\n. > You shouldn't worry. All stamps are immutable. None will add properties to your model. :)\n\nBut only if you make the \"setupPropName\" to always return a new stamp instance. Like in the example above.\nPlease remember! All stamps are immutable.\n\nAlright, I missed that part, that's very good indeed :)\n. Ok so I have tested this for my library and truly works like a breeze. Normally I would use webpack, but that's uncessarily complex. Rollup seems indeed better choice for library packages, so I am going to give it a try for stampit.\nI am wondering. You have a prepublish script there which only runs some checks. Can I add build script there too? It's kinda safe option to make sure that you are publishing truly latest build. Or do you have a different workflow I am not aware off?\n. Yes, of course I will do it there, most probably during weekend, I had to sort out some other stuff first.\n. Sorry, I got bit sick over weekend, so I could not do this. Anyway now looking more closely, would you mind actually to update babel to version 6?\n. Do you think it's actually necessary to support iojs for travis check? It existed for a very brief moment, people either stayed on 0.12 or went to 4.0 afterwards.\n. Sure no worry, it's obviously still kinda broken, so I wont stop till there are green lights :)\n. Alright, almost there, only 0.10 is failing because of the rollup-plugin-node-resolve is expecting native Promise. I will try to create issue there, but I have doubt's about it.\nUnfortunately without that plugin there is problem of bundling dependencies...\nTreating 'lodash/assign' as external dependency\nTreating 'babel-runtime/core-js/object/values' as external dependency\nTreating 'lodash/isObject' as external dependency\nTreating 'babel-runtime/helpers/toConsumableArray' as external dependency\nTreating 'lodash/isFunction' as external dependency\nTreating 'stamp-specification' as external dependency\nNo name was provided for external module 'babel-runtime/core-js/object/values' in options.globals \u2013 guessing '_Object$values'\nNo name was provided for external module 'babel-runtime/helpers/toConsumableArray' in options.globals \u2013 guessing '_toConsumableArray'\nNo name was provided for external module 'lodash/assign' in options.globals \u2013 guessing 'assign'\nNo name was provided for external module 'lodash/isObject' in options.globals \u2013 guessing 'isObject'\nNo name was provided for external module 'lodash/isFunction' in options.globals \u2013 guessing 'isFunction'\nNo name was provided for external module 'stamp-specification' in options.globals \u2013 guessing 'compose'\nNo name was provided for external module 'babel-runtime/core-js/object/values' in options.globals \u2013 guessing '_Object$values'\nNo name was provided for external module 'babel-runtime/helpers/toConsumableArray' in options.globals \u2013 guessing '_toConsumableArray'\nNo name was provided for external module 'lodash/assign' in options.globals \u2013 guessing 'assign'\nNo name was provided for external module 'lodash/isObject' in options.globals \u2013 guessing 'isObject'\nNo name was provided for external module 'lodash/isFunction' in options.globals \u2013 guessing 'isFunction'\nNo name was provided for external module 'stamp-specification' in options.globals \u2013 guessing 'compose'\nPR created: https://github.com/rollup/rollup-plugin-node-resolve/pull/41\nEdit: This is solved now with proper use of polyfill.\n. Alright, we are all green lights now. I have added some summary to the initial comment.\nI am not entirely sure how to verify that those bundles are working correctly. I mean first ones are not that different from source, that should be just fine. The ES5 bundle is bit more tricky as it would need to run through some other bundler. I did some manual test of the Full bundle http://codepen.io/FredyC/pen/yJyYaR?editors=0010\nYou might notice that there is one another slight problem. Since we are exporting stampit as default alongside with isComposable & isStamp, consumer on ES5 environment will need to use require('stampit').default.  Is it actually necessary to export these two separately since they are already included in default export? Exporting only default means rollup can handle it properly. More about it here.\n. I had it prepared already, it was just waiting for push, but thanks I guess. There was also one issue I have noticed that build is actually run twice, in precheck and then in prepublish. It's not big deal I guess, but I wanted to remove that, oh well.\n. @ericelliott  I don't see any browser tests in stampit, so how does that relate?\nEdit: I am just trying to help here. If you want to be like that, I might just stop and you can be happy on your own... I totally hate this arrogant behavior, you know\n. I don't see reason why it could not run in browser as well. If the problem is running in parallel, it possible to change it to serial execution. Otherwise I cannot imagine what would be difference. \n. Ok I see, but I believe that solution is simply running browser tests against bundle that is made to be executed in browser. With my rollup changes (#209) this should be a breeze. \n. Ok let's review what should actually happen to have those tests running in a browser.\n- bundle stampit code with all polyfills and stuff ... done\n- bundle test code that references bundled stampit\n- execute that bundle in the browser\nBack in days I used tool Test'em which is essentially test framework agnostic runner which runs tests in browser natively. If we give that bundle from second step, it should work quite ok.\n. Ok I see what you mean although for ava there is no actual index.js because of the parallel running, but that can be added simply for sake of this. \nThere is this example for testem ... https://github.com/testem/testem/tree/master/examples/saucelabs so apparently it should be possible.\n. Ok I will certainly try this, but the #209 should be merged first anyway to have rollup at hand.\n. I know, but I am more used to forks and I have set of git aliases for that. It seems bit cleaner way to me too.\n. - Dropping transform-runtime alone it went down to 30K minified. That's 14K for just polyfills.\n- Dropping mergeWith alone it went down to 20K minified. That's 24K just for lodash stuff!\n- Thus dropping both of these produces minifed bundle of 5K :astonished: \nConsidering that transform-runtime is harder to replace. Finding alternative for mergeWith is indeed step in a right direction. If we use something else for merge then there isn't a reason to remove lodash as it will be using only isObject and isFunction which are quite small.\nPersonally I wouldn't be dropping stamp-specification as dependency. It would make it only harder to maintain if something changes.\n. @JosephClay Yea unfortunately lodash is not ready for real tree shaking yet, so it has to be hacked through that babel plugin.\n\ncompose() is moving from stamp-specification to stamp-utils. I agree it's OK to keep it as a dependency -- but stamp-specification is going to stop serving the compose() function.\n\nUm so stamp-specification would be just written manual how to do it? I hope that stamp-utils don't become dependency of stampit, that sounds kinda weird to me.\n. I am confused now, what would be complicated? There is already written manual of specification. By removing functional code from there makes it \"written manual of how to do it\". \nI meant more like that making stamp-utils seems like bloating stampit package bit more with stuff that some people might not ever use. If they want it, they can use that dependency itself. However that means stampit will need to implement spec on its own. Is that the plan?\n. Alright, fair enough. Anyway that got bit side tracked here from main issue of size, but that needs to be tackled mainly in stamp-specification / stamp-utils first.\n. I am sorry you had to go through with that, I could have helped me as I have much more experience with build systems and how it works.\nI see you got rid of stamp-specification as well. I am still not convinced about this step as it could make things easier for changes to spec. Anyway I think those utility function should perhaps go to stamp-utils?\n. Those you created instead of using lodash, but I guess that depends on if I can convince you of getting stamp-specification back into the mix. In case you want to keep it this way, it's not probably necessary.\n. Ok I see, that makes sense. :+1: \n. I am thinking if it's actually necessary to place code for all these functions to the root. I placed the isComposable and isStamp there because they might want to be used separately, but are you sure that other function will be used also? I would to say to move them to src and lower a clutter there.\n. Do we need to fix those tests failing here? Last merge was already failing, so I suppose it's not relevant.\n. > One more thing. The ... syntax is slower than the .apply(this, arguments) because each ... is transpiled to a for loop.\nThis simply isn't true, Babel isn't that stupid. It has seen that you are just passing all arguments to function call and it did exactly same thing this(undefined, arguments). On this particular call you haven't saved anything, just made it less readable.\n. Yea I think that slice is definitely much slower than using for loop, I remember I was investigating these things in past quite heavily. Perhaps it is different now but I wouldn't bet much on it. \nFrankly it seems ridiculous trying to save bytes on size in times of fast internet. It is surely difference to have 60K vs 5K, but having 5K or 6K is really a minor difference that nobody will care about.\n. Let's do optimizations properly based on benchmarks, no point trying to make it faster when we don't know how fast it actually is. I just recall from old days that there are some arguments related optimizations delivered by engine and that it actually runs slower if you fiddle with arguments incorrectly. Even passing them somewhere else makes that function deoptimized. I would like to believe it's different these days, but seeing that Babel does loop instead of slice, I am not convinced about it.\n. There is also very nice library called fast.js which focuses on reimplementing native functions in most performant way. There is nothing for treating arguments, but it's surely very interesting show case.\n. Yea I agree. As @koresar likes to say \"premature optimization is way to hell\" (or something like that) and then he goes and does premature optimization to save couple of bytes :) I guess it doesn't matter now since it's already done like this, but it was completely unnecessary for sure.\n. >  It is surely difference to have 60K vs 5K, but having 5K or 6K is really a minor difference that nobody will care about.\nYea well, I still don't agree that 1K matter really ;) But as I said, it's done so let's leave it. I am sure there will be couple more rewrites anyway once we start focusing on performance.\n. Hmm strange, so that line with __es6module was gone when I rebuilt it by myself to try the #215 fix. Your published version has it indeed. Another related issue is #217\n. Well you misunderstood me here. One thing is concatenating array for sure, but also if you have just function as a value, it gets deeply cloned and you get a following. Function is simply gone, only properties of stamp are there.\njs\n  submemories:\n   { tree:\n      { refs: {},\n        props: {},\n        init: {},\n        deepProps: {},\n        statics: {},\n        deepStatics: {},\n        conf: {},\n        deepConf: {},\n        create: {},\n        compose: [Object],\n        methods: {},\n        properties: {},\n        initializers: {},\n        deepProperties: {},\n        staticProperties: {},\n        staticDeepProperties: {},\n        configuration: {},\n        deepConfiguration: {},\n        withSubmemory: {},\n        withDefaults: {} } } }\nActually I don't think there was even a problem with concatenating the array.\nCustom merger function is surely powerful, but also annoying to implement every time you need something specific as this. We can solve this simply by giving couple of exceptions that functions should not be cloned.\n. Ah I see, you are right, such side effect could be rather harmful. However using bind comes with problem of rebinding context of that function (unless lexical scope with fat arrow) which is also something unwanted. I am wondering how is lodash doing it actually...\n. Ok I think that lodash way is kinda best way to solve this. It doesn't try to merge functions with another properties, it simply ditch whole function there ... see http://jsfiddle.net/ybem606s/3/\nIt's side effect free and consumer needs to decide if that property should have function or something else. I am more than fine with such solution.\n. Ah I see, so you can even omit to specify context in bind call, did not know about that, cool :) Hope it works in all engines like that.\n\nIf you want to preserve functions in the \"deepConfiguration\" I'd recommend storing it in an array. As it is declared in the spec that we concat arrays.\n\nUhh, that sounds totally silly, I surely don't want to allow multiple stamps for a single submemory.\n. Thanks @troutowicz, I've applied your tweak :)\n. Fat arrows seem like ugly monsters for stamps unless used inside another functions. I had same problem with initializer once and I couldn't figure out till I could...\n. I like would propose rather different approach. First we shall use scoped modules in NPM. Then we can have modules like @stamp/specification along with @stamp/compose package with universal and most performant implementation of a core idea which will be reused in all other packages. Those other packages can be then split by some common idea, eg @stamp/chain (currently stampit) or @stamp/check (isStamp, isComposable) and @stamp/classes (eg. convertConstructor) and finally also @stamp/react.\nLet's avoid using names like utils. It's terrible generic name that doesn't say anything specific about its uses. It feels like dumpster full of things that could not fit anywhere else.\nI think it's really important for people learning about stamps to know where to begin. Which package to grab to start using it. Don't burden them with a choice of various packages right from the beginning.\nFun with Stamps articles should be focused around compose only and stop referencing stamp-utils randomly. Instead there could be article for these helper modules explaining what they bring on the table in comparison to core compose.\nEdit: Of course for a smoother transition from current state, we would simply deprecate current packages with information where to find a new one and eventually people would switch there.\n. Well if you want to relate it to money, then why do you actually create and maintain stamps? It has surely cost you some dollars too. I don't agree with recalculating it like that. Open source is not about money, it's a journey how to make things better, not about sticking to couple of bad decisions because of some strange fear of change.\nNobody is talking about deleting those packages and forcing people to rewrite. Those packages can be alive for quite some time, but for sake of new projects, maintainability and less painful entry, there could slowly emerge what I've suggested to have a solid foundations for something amazing.\n. Completely agree @koresar, that's very good way to go for sure. Eventually it could even be like having those scoped modules together with stampit which would essentially have those scoped ones as dependencies to create a full package for head start. Then when people will understand what they need, they can create their own \"bundle\" of micro packages.\n. By the way, for those scoped modules, we certainly don't need multiple repos. I would go the way Babel makes it's plugins. They even extracted that functionality as a reusable module lerna. And here is some reasoning with cons/pros. I will eventually take care of setting this up.\nEdit: I've created a new repo for this purpose and added preliminary branch with structure: https://github.com/stampit-org/stamp/tree/setup-lerna\n. @ericelliott Point of spliting compose is to have a single most performant implementation that can be shared and reused. I said it many times, trying to keep multiple copies is maintenance hell.\nNobody said that init should be in a single package, that's definitely too much. Goal is to have only single init not like now same function with different functionality, that surely confuses people. So there would be that function along with others in some reusable module too.\n\nHow we can ease newcomers' choice on which library to use? What should we recommend?\n\nI would surely speak about stampit as a main module. It will be full featured with everything that is needed to start with it. It can reference specification for sure. Also stamp-specification could back reference stampit, but nobody is going to find spec first before module I suppose.\nWhat we need the most is definitely documentation and meaningful examples. I believe those examples should be in some codepen so they can be executed and played with. We could also have one official codepen playground with updated stampit.\nPossibly we should also create small static website. People tend to use modules that are presented nicely instead of just bunch of MD files.\n. @ericelliott We are going more likely with mono repo, so everything will be in a single repo just published to separate packages. One liners were already separated in stampit, so there isn't much of difference except that they can be reused, especially isStamp and isComposable instead of redefining those all over different packages.\n. Well IE11 is still sort of used as not many user has migrated to Windows 10 yet, but I don't have any actual stats of how many users actually use it on Win7.\nI do like more this polyfill: https://cdn.polyfill.io/v2/docs/features/ as it provides automatic detection of missing features and serves only those, but obviously it cannot be used in NodeJS environment so your recomendation is fine as well.\n. > I use Babel, perhaps it transpiles it to something which has type object.\nThat doesn't sound right because generator is essentially just a function, but returning iterator. With Babel that function just has this in a body return _regenerator2.default.wrap(function... which handles magic of \"pausing\" the function.\nMore likely it's some other issue or you may have missed something perhaps?\n. Lodash v4 does consider generators as functions, so it's merely problem of v3, so it's not necessary to report that.\nI've merged pull request, lodash does too sofisticated checks for our needs.\n. Yea I was bit confused what do you want to check there. We even dropped lodash there some time ago :)\n. You got that pretty much right with using stampit().init. As far as you need access to those private variables, you have to define methods in a same closure. Stamps don't provide any magic for private stuff.\nAlternatively you can use WeakMap for private state. \n``` js\nconst privates = new WeakMap();\nconst Logger = stampit.init({name = '', level = 1} => {\n    const newName = (''+name).toUpperCase();\n    const outputName = ${newName} :;\n    privates.set(this, { level, outputName });\n}).methods({\n    log(...args) {\n        const { level, outputName } = privates.get(this);\n        if (showLog(level)) {\n            console.log(ouputName, ...args);\n        }\n    },\n    warn(...args) ...\n    error(...args) ...\n});\nconst showLog = (level) => level == 1;\nconst showWarn = (level) => level <=2 && level >=1;\nconst showError = (level) => level <=3 && level >=1;\n``\n. Well I am not really sure what is currently better way of static type checking. I haven't get into any of those yet. From what I remember, when I tried flow last time, it wasn't working on Windows. I am not sure if that's still a true. Also what I don't like much about Flow is a need to add that/ flow /` comment there.\nLately I am hearing more and more about Typescript as a more robust solution. From what I seen out there, there is also ability to keep types in separate file. There is also the typings tool that can manage these files.\nI am not sure if we should combine both of these mechanics really, might add uncessary complexity in maintenance.\n. Very nice idea. I tried the build myself and indeed it's working quite nicely. Thank you!\n. Good catch, thanks!\n. I would surely go with number 2 and perhaps include number 3 with modification that could be exported as stampit.pureCompose just to prevent confusion. And I think that number 4 is rather ugly breaking change, I am certainly using those separate exports all over the place and most probably I am not alone.\n. I guess that number 1 has it's charms too, I just hate to keep source files floating in root directory. Although this could be solved by changing build process slightly and instead of publishing from root, it's possible to publish from subdirectory. Those files could then be just copied there, otherwise they could be kept in src.\n. @dpatte Ok, thanks for correction.\n. @koresar Thanks, I still have a trouble with articles obviously :)\n. I thought we already agreed on dropping support for 0.12. You even made issue for it :) https://github.com/stampit-org/stampit/issues/224\n. It took me a while to find it, I only vaguely knew, we talked about it.\n. https://github.com/airbnb/javascript/blob/master/packages/eslint-config-airbnb-base/CHANGELOG.md\nSome new rules enabled, but it shouldn't influence us, so I am merging.\n. I like the way it includes a changelog and list of commits. That's very helpful. Anyway doesn't look like anything seriously breaking there.\nI am bit curious about deprecating lodash.assign thou. I've seen it popping up lately, but I am failing to find any reasoning behind it. The Object.assign is still not available everywhere, eg. IE11. Why are they recommending to use it then? Unless of course there is expectation to use polyfills.\n. I would go with warning on this since it's a single browser and adding polyfill is very easy with service https://cdn.polyfill.io/v2/polyfill.js. Enabling tests for 0.12 doesn't seem about right because it is missing also whole bunch of other ES6 features and would bring only issues. Also I would like to remind your your #224 once again, you keep forgetting about it ;)\n. Well that's rather strange, it's failing on Node v4 only saying that eslint-plugin-import is not installed. Not sure why really...\n. @ericelliott Yea, babel-eslint isn't probably required as long as we don't use any features that are missing from espree parser. However eslint-plugin-import is something different. It helps to discover when you try to import file that doesn't exists and many other rules related to imports/exports. \n. I confirm it's working now. Great work, @koresar \n. Huh, that's strange. Test appears to be passing here, but in log there is test fail clearly... https://travis-ci.org/stampit-org/stampit/jobs/164304698\n. @koresar Can you please make a new release with this? Thanks :)\n. @koresar Umm...bump? :)\n. Thanks, it's fine :)\n. I don't think you can remove the import plugin, it's required by airbnb. Also this statement of yours isn't correct:\n\nAirBNB eslint configuration already lints import/exports for us.\n\nThat's the plugin which does linting of import/exports, nothing else.\n\nOops! Something went wrong! :(\nESLint couldn't find the plugin \"eslint-plugin-import\". This can happen for a couple different reasons:\n1. If ESLint is installed globally, then make sure eslint-plugin-import is also installed globally. A globally-installed ESLint cannot find a locally-installed plugin.\n2. If ESLint is installed locally, then it's likely that the plugin isn't installed correctly. Try reinstalling by running the following:\n   npm i eslint-plugin-import@latest --save-dev\nIf you still can't figure out the problem, please stop by https://gitter.im/eslint/eslint to chat with the team.\n. Yes this should be alright. I run into same problem with my library. I suppose that airbnb will get updated soon to support import plugin 2.x. Greenkeeper will let us know.\n. @koresar I've renamed the PR as change to unpkg is gone :) Better to change commit message when squashing as well.\n. Interesting, I don't know why I thought that both links are broken :) Good catch, it's reverted\n. I kinda think that we are hunting performance in wrong places here. In practice I had no need so far to use a complex structure when specifying initializers. I don't see use case why would anyone pass array of arrays down there... Perhaps it might be better to optimize by actually excluding whole flattening completely. I know, it's breaking change and should have come before V3 probably, but maybe we can think of it for V4 in a future.\n. Yea I agree, but extracting only functions from flat array is as simple as initializers.filter(isFunction), no need for extra file with additional code for that.\n. Personally I don't understand why we are even listing all those plugins there when we are not using all of them. It might even give us faster builds if we are more selective about features we actually need.\n. I would not ditch ES6 modules a probably some spread or destructuring make things more readable. I am wondering. Check out the result of loose transpilation of stampit.js \n. I would say it's kinda endless debate on rewriting stuff to ES5, but I still don't think it's a good idea. There is more environments that can actually support ES6 than there is those that don't support it. I don't have any proof for it, but I would say that some constructs will be faster executed natively. For example this simple line of code: \n\ndescriptor[propName] = action({}, ...arguments);\nEven in \"loose\" mode it is transpiled to: \ndescriptor[propName] = action.apply(undefined, [{}].concat(Array.prototype.slice.call(arguments)));\nThat looks like hell kinda. However it's essentially correct by ES5 capabilities. In ES6 engine it's possible that this would be optimized differently.\n. Yes we do transpile. Currently it's necessary step to make everyone happy. But eventually this might not be needed anymore and I doubt we will be rewriting back from ES5 to ES6 after it. I see it like supporting the future this way. The more modules in ES6 there is, faster will people leave behind obsolete platforms in my opinion.\n. I am probably missing something in my brains, but I don't see a problem here.\n``` js\nconst convertConstructor = ctor => stampit({\n    init: function (_, {args}) {\n        return Reflect.construct(ctor, args);\n    },\n    methods: ctor.prototype,\n    statics: ctor\n});\nconst ColorPointStamp = convertConstructor(ColorPoint);\nconst cp = ColorPointStamp(25, 8, 'green');\n```\nWhat's the catch here? The init gets called, constructor gets all necessary arguments and prototype chain will work from there. We don't need to do anything about that really.\nMaybe you are missing the piece with Reflect.construct? It's exactly made to create instances of ES6 classes dynamically. \n. Here is a codepen with this simple use case working like magic \u2728 \ud83d\ude09 \nSee the Pen Playground for stampit by Daniel K. (@FredyC) on CodePen.\n\n. I haven't actually tried to run it against those test cases from above: https://github.com/stampit-org/stampit/blob/convert-constructor/test/convert-constructor.js\nCan someone else try that please?\n. @Sigfried I wouldn't be so negative about it as @koresar. Yes, there is no official support for it, but if you go through comments here, you can just as easily make an implementation that suits your needs. With stamps there is no need to wait for maintainers to finish something as long as specification stays same. You can just create your own stamp and use it in your project.. @koresar You can actually use fat arrow in classes with class properties, just like...\njs\nclass MyClass {\n  myBoundMethod = () => {\n  }\n}\nIt's ugly as hell, but it works.\n@Sigfried Unfortunately, you cannot really do this with stamps because of there no such support from the language. There is a more extensive discussion in this issue.. And why does that matter? It's more of the question if person/company is comfortable using Babel. As long as they keep a version that supports that feature, it will just work no matter the standard. I don't want to flame about it, but it's kinda ridiculous to stop at things that are standardized only.. Eh, what? :) He said that he is using arrow functions in classes, that kinda means that he is using these non-standardized class properties or am I missing something here? :)\nEdit: \nAlso, the term \"ES6 classes\" is just so inaccurate and most of the time it just refers to classes generally, not to some feature set that is used. Nobody is talking about ES8 classes or ES2017 classes. Most of the people are not really watching when was what feature standardized.\nEdit2:\nYou are discussing here something completely irrelevant, I just wanted to point that such syntax exists because you were confused about it.. It's really strange. I wasn't able to actually find the specs of this experimental feature. Babel has it implemented and people are using it. There is short mention in a Babel blog which reasons about it like...\n\nThe body of ES6 arrow functions share the same lexical this as the code that surrounds them, which gets us the desired result because of the way that ES7 property initializers are scoped. \n\nIt almost looks like that it's just a feature that Babel came up with and it's not standardized actually. \ud83d\ude16 \nThere is also this comment on StackOverflow that kinda makes sense to me...\n\nI think this is because it would create a new weird part in the language: you would have class methods whose execution context is the context the class is declared in. Class methods are, by definition, to be called on the instance as a context. If you want a method that does not care about context, create a static one, which can be declared as an arrow function directly in the class definition\n\nBtw to make things even more confusing, there is a proposal for private fields ... \ud83d\udce2 . @koresar And isn't that what we are doing in stamps whenever we need to bind method, make it private or access stamp configuration? In those cases, we also have to attach to the instance.  I don't see why you should warn about it for classes.. I would assume that since not many people are really asking for a way of converting ES5 classes, it's no longer a pressing issue. In fact, stampit was written in ES6, but then @koresar got annoyed by a Babel and rewritten it :D There isn't much of reason today why to stay with ES5 except to support IE 11. But looking at these global stats I wouldn't be worried that much really :)\nIn my opinion, if you have an older project written in ES5, it's unlikely it's build using stamps and even more unlikely, stampit would be added there ad-hoc just for the kicks of it. The newer project will be likely written with ES6 or it might be just a small project which doesn't really care about composition. In overall there doesn't seem to be much of userbase of ES5 stampit imo.. To be honest (and its way OT), I am not using stampit for the last year or so. It cannot be used with React functional components and for a business logic I am using mobx-state-tree which is somewhat similar to stamps, but reactive on top of that.\nThat being said, I don't really feel motivated to help with anything on this project right now. Sorry.. Not possible right now till Airbnb is updated to use this version\n. Ok, based on comment in linked issue we will need to add extra entry point that will be used solely for UMD builds and export stampit as default only. Anyone wants to learn something new? Should be probably fairly easy.\n. Well I am using named exports in my project, it just feels better if I can write directly init(...) instead of stampit.init(...) :) It's also breaking change, so I wouldn't really go that way anytime soon. Extra entry point is lesser evil.\n. import init from 'stampit' is same as import stampit from 'stampit', just different name for a default export. You will always get stampit function so I would need to do init.init() :D\nYou cannot really use import to retrieve only one property of default export, that's not how it works because ESM are completely lexical, they cannot statically analyze what you are exporting.\n. Yea, that wont work either obviously :) You can check it out here\n. Why did you even try to remove that plugin? Aibbnb needs it :) We just need to update config little I guess.\n. Yea right, airbnb merged dependency on 2.x import plugin...\n. @koalabz You really like that better than what @koresar showed you? It's terribly verbose :) Personally I don't use fat arrows with stampit at all to avoid confusion and errors.\nEither way it's not really possible because in the time when you are calling methods, there is yet no instance to refer to. These methods are attached to descriptor and used for any future instance of that stamp. You could only solve this by using configuration and creating these methods within initializer dynamically, but that's hardly a same thing.\nIf you are familiar with AST and writing Babel plugins, you can perhaps make the one that can handle this properly\n. @koalabz Check this out :)\njs\nconst stamp = stampit().methods({\n  oldStyle: function() { ... },\n  fatStyle: () => { ... },\n  newStyle() { ... },\n});\nSo regarding your quote about arrow function bringing simplicity, I am sure you can see that in this case it only brings chaos :)\nClosing as it's not possible to solve this on library level.\n. So let me get clear. You just run npm install stampit and this is the error you got? What is your version of Node/NPM, please?\nAnd little advice, don't install eslint globally, that isn't going to solve a thing.\n. Looks good to me as well. I remember (although bit foggy) that we had to do it like this because of ES2015 preset transpiling those ES modules and babel-preset-es2015-rollup wasn't working that well.\nIt's bit problematic, that build might actually pass, but don't have exactly tools to automatically verify that those builds are really working properly.\n. Babel is obviously over complicated, let's check out Bubl\u00e9 :) #267\n. Ok, got rid of Babel, although we still need babel-cli to actually run the build because Buble apparently doesn't have alternative to babel-node :(\n. Yea right, I've missed that :)\n. That's cool flag, did not know about that :) \n. Good catch, thanks! Would you mind creating the PR?\n. Thanks!\n. Can you perhaps provide some real use case scenario? I still have a hard time to realize what this is good for actually. Even after rereading proposal couple times :) Consider me as the outside user on this and if there will be big barrier to understand this, not many people is actually going to use it.\nEdit: My understanding is surely limited by fact that I had no need for infection just yet.\n. Annoying dependency? I don't get it. It contains many useful rules you have simply disabled with this. Also import plugin was used and configured with airbnb.\n. That's not true. There was this incompatibility with import plugin, but that's fixed for some time now.\nAlso I don't understand how could there be so many outdated dependecies, I thought greenkeeper is watching it or did you disabled it?\n. > 1) The default actionName should be undefined instead of null. Then it will work as expected.\nThis kinda sounds like a bug or at least it's not documented? Since it's undefined by default I rather use null so I can easily distinguish if it was set or not at all.\n\n2) I'd have HaveTrigger stamp instead of the EngineAction. Because EngineAction just too bulky and duplicates Action.\n\nThe reason why I am composing the Action into the EngineAction is because I am calling a static method of it. \n``` js\nconst Action = stampit.statics({\n    setupAction(app) {\n        const { setupListeners } = this.compose.deepConfiguration\n        // here I am composing stamp from results of all listeners\n        return setupListeners.reduce((stamp, listener) => listener.call(stamp, app), this)\n    },\n    addSetupListener(listener) {\n        return this.deepConf({ setupListeners: [listener] })\n    }\n})\nconst EngineAction = Action.addSetupListener((app) => {\n    const engine = app.engine\n    return this.methods({\n        trigger() {\n            this.log('triggering')\n            engine.triggerAction(this.name, this.payload)\n        },\n    }).statics({ engine })\n}).statics({\n    onTrigger(cb) { ... }   }\n})\n```\nDeclaring actions happens way before the app is available. I am aware it's not pretty, but if you have an idea for better solution...\n\nI see statics abuse in your code. Have you considered configuration/properties instead?\n\nThe point is that final API should look like actions.Character.onTrigger(cb) and actions.Character(actionData).trigger(). So I need static methods and instance methods as well.\n. Yea, I don't really remember how I actually solved it and it's kinda abandoned thing in general so I am closing it.. Hm, not sure why you want review from me. I am not big fan of this change really :) I will try to have a look later on. You consider this merge-ready then?. Obsolete due to #291 . @koresar Can you eventually have a look why would that single test be failing on Node 7? My guess is that it is taking too long there for some reason...\n```\nbenchmarking property access\nnot ok 231 object instances property access must be as fast as plain object.\n\noperator: ok\nexpected: true\nactual:   false\nat: Suite.<anonymous> (/home/travis/build/stampit-org/stampit/test/benchmark/property-access.js:71:9)\n\n...\nStampit x 11,255 ops/sec \u00b11.21% (70 runs sampled). Plain object x 27,200 ops/sec \u00b10.89% (91 runs sampled)\nstampit().compose()\n``. LGTM, thanks for handling it.. Had to rerun one test, it just timed out for some reason.... Looks like something is failing intest/convert-constructor.js`, but since this test is not used it may as well be deleted instead :). @Mika83AC  Where do you have these script tags? Both in the head? In case you include both at the same spot, chances are that your \"app code\" is executed before stampit script is loaded and parsed. However accessing it later in the console works ok. You can investigate this behavior in Network tab of developer tools.\nThe safest path is load external scripts in head tag and your logic at the end of the body.. @Mika83AC Where did you actually get that stampit script? Is it freshly installed from bower or did you made a copy from somewhere? Can you please try this live URL instead? https://npmcdn.com/stampit@3.1.3/dist/stampit.umd.min.js. I see, there seems to be some issue unrelated to your code indeed. Quick workaround is simply to call stampit.init instead of stampit().init\n@koresar Once again there is exported object with default instead of a function being exported. I though we solved this before, not sure if you were doing some changes there.. Just for a clarification. Babel alone is not doing anything about missing Array.prototype.includes. That's job for babel-polyfill which is included with babel-node that is used to run tests. This could have been avoided by simply doing node -r babel-register instead and tests would fail.\nI did not check composers that closely to notice this ES6 feature used there. It's essentially same problem we were solving with Object.assign before and then we added our own implementation. A similar solution should have been applied for Array.prototype.includes or not use it all.\nIn my opinion, it would be preferable to actually use indexOf in this case. This feature is just about sugar and it's not really worth it till we need to drag the dead weight of old environments not supporting it.\n@koresar Sorry, but that's just your mindset that these are bad tools. Blame user, not the tools :). I am not sure it's a good idea to actually add a test bundle to dist folder which should really contain only files for distribution. Or at least delete it when the test run is successful.\nTests are actually failing on v5 as well because Array.prototype.includes is available only with --harmony flag there... check http://node.green/\nAs I've said in #305 I would replace this with indexOf, it's not worth it to use this feature at all cost.\nOtherwise it looks good to me, so thanks for the effort @boneskull . @koresar These changes are not really touching dist bundles, it's about changes for tests only, so don't worry.. Well, spread operator is a language feature. That should be certainly transpiled by a Babel, however, es2015 preset does not include required plugins. Can you try switching to https://babeljs.io/docs/plugins/preset-env/ instead ?\nI wouldn't really spend much more time in rewriting building & bundling, it's not worth it since we are going to throw this away eventually.. Ah I see, Buble does not support rest spread. I guess the easiest path is not to use this feature too. Can you handle it @boneskull please?. @koresar I don't see how this PR increases complexity really. If anything it is lowering it because using same transpiler solution for tests & source is something that should be taken seriously. The results of tests are somewhat useless if there is another layer. Can you elaborate more where is the complexity you talk about?\nUnit tests fail simply because the use of rest spread which is not supported by Bubl\u00e9. It's either about removing that feature from source or go other way around and bundle source with Babel again which I don't exactly remember why we have replaced. Leaving things as they are now is dangerous for sure.. @boneskull Do you think it's a big problem to do those two points @koresar asked for?\nI will be repeating myself, but since future of this repo is rather unsure, I don't think it's worth it to spend more time on it than it's necessary. Even if means ditching \"rest&spread\" from source.. Ok, let's close this then and worry about it when the real issue coming from different bundling solution arises.. Hey, @nachocab. since you are just \"copying\" reference, not a whole object, you don't really need to worry about memory efficiency.\nMore likely you should ask yourself why do you want to use statics in this case. It's paradigm from OOP, but you don't really need it here. In case you don't want anyone to change your grading table from the outside, it would be even recommended to store it just as a closure variable. \nIf you want your grades to be changeable for the stamp, you might as well go with deepConfiguration.\nEdit: I wouldn't recommend the way in your second comment, it's rather messy in my opinion adding something on the stamp object like this.. @nachocab Yea, it's rather undocumented feature. It's sort of similar to statics. You can check out package @stamp/configure I've made recently for some example.. Unfortunately, you cannot use multiple arguments for stamps like this. I guess this can be seen as a disadvantage of stamps. It's recommended to wrap all arguments in a single object that is passed in a first argument. There is a good reason for that as when you are composing from various other stamps, you shouldn't make any assumption that there are more arguments available. It needs a kinda different mindset then you are probably used to from OO.\nHowever, if you insist, it's possible to access other arguments like init(myArg, { args }) { ... } where args is an array of all arguments (including first one).. Just want to share a neat way of adding methods within initializer. \njs\ncompose({\n  init(opts, { stamp }) {\n     const { myPrivateVar } = stamp.compose.configuration\n     Object.assign(this, {\n       myMethod() { return myPrivateVar + opts.passedVar }\n     })\n  }\n})\nI am thinking that it would be lovely being able to avoid the use of Object.assign, but keeping the simplicity of the solution. For example returning an object that gets assigned to the instance methods. Otherwise, if you want a method to have its proper display name, you have to do this.myMethod = function myMethod() or const myMythod = () => {} followed by this.myMethod = myMethod. Going simply with \u02d9this.myMethod = () => {}\u02d9 doesn't work.\nIt could be an actual candidate for a stamp specification grow. It's not possible to provide such solution with a stamp, am I right?. @koresar I am not sure how that's relevant. It's surely great there was some possibly similar feature, but it's not there now. Can you express your opinion on the idea instead? :). Ok, I guess that @ericelliott comment is closer to what I meant. Although I am not sure that using ...instance is a good idea because some people may be using eg. Symbols stored on the instance and \n with this, it would be lost.\njs\ncompose({\n  privateInit(opts, { stamp }) {\n     const { myPrivateVar } = stamp.compose.configuration\n     return {\n       myMethod() { return myPrivateVar + opts.passedVar }\n     }\n  }\n})\nIt's the same signature as an initializer, but different name (WIP) so it can be used only to return new methods that would be added to the stamp. It's just an idea, probably not that critical.. Ah ok, wasn't aware of that. I still don't particularly like this feature of returning a different instance object, but I see that you don't like my idea, so let's forget about it :). @ericelliott That sounds like a good idea. Actually wouldn't it be nicer if stamps would allow customizing that second object that's passed into initializer? That way we could add this functionality as another composable stamp instead of hard coding there. I am not sure how to call that yet, but it could be similar to configuration and deep merged there when an instance is created.. @far-blue https://github.com/stampit-org/stampit/issues/44#issuecomment-70051741. @far-blue And did you ask yourself a question if it's actually needed? Stamps are so different concept than classes, that instanceOf is more of misleading than being helpful. If anything, it should be stampOf to denote the difference, but going with the same naming is just for confusing people.. Anyway, you are surely welcome to create a PR in our monorepo that would handle that. It's a kinda beauty of stamps that not everybody needs to use all crazy ideas someone has :). Well, so I don't understand why are you seeking this since it doesn't impact you :) Either it's something you want to use with stamps or you just don't want to bother to make a small contribution? Something like this doesn't need to be in a core of stampit nor as a part of the specification. It is a completely separated idea that is optional.\nIt's possible that what I find as a \"crazy idea\", it might actually make a transition to stamps easier for other people coming from Java-like languages that are used to this. Later they might realize it's not needed, but that's another story.. @koresar It surely is possible to do it as stamp, but as @ericelliott said here  it would be another implicit dependency you would need to add to every stamp to expect instanceOf working. Especially in this case if you don't compose with that stamp you would get the nasty surprise of instanceOf working differently. So yea, it should be probably part of spec.\nOn other hand it increases memory footprint for every stamp, so including it by default would influence everyone which doesn't seem that good.. In my opinion, stamps are more about the ecosystem. You have some standardized descriptor that can be used to create stamp even without any supporting library since it's just POJO. Our monorepo is still at the beginning, but eventually, there could be many useful stamps that can be just composed together.\nOn the contrary, your solution with multiple lacks such opportunity as you cannot easily do these multiple inheritances without supporting library, can you?. > Having to import something or even copy/paste it is not really a huge problem!\nI did not really try to imply it's a problem, but doesn't that mean you will be creating another kind of ecosystem similar to stamps? What is the benefit then? If classes would support multiple inheritances out of box then hell yea, it would be awesome, but they don't...\nAlso, it seems to me that classes can be rather limited in many ways and often you have to end up with various hacks (I personally consider Proxy a hack kinda). For example look at our privatize stamp. You cannot really do something that easy with classes if I am not mistaken.\nAnd I am not sure about inheriting static properties/methods on classes. I did not dive into your solution, but can you like mixin together classes along with its statics? There is of course question of the need and if it's antipattern or not, but with stamps it definitely feels more natural and wanted.. @kellypacker Please see the install section in readme, especially that warning there :) This is actually what's your problem there.\n@koresar It's coming from here: https://github.com/stampit-org/stampit/blob/master/src/utils.js#L41 because Object.assign is not defined :) I think we should add a warning to stamp/core about this just to avoid these weird errors.. Closed by comment. Thanks for the effort, but we have decided a long time ago that polyfill for this won't be bundled with stampit, especially since only the IE11 is affected by it. In the install section there is an explanation how to handle this.\nFurthermore, stampit itself is slowly getting deprecated and replaced by modularized approach residing in  repo https://github.com/stampit-org/stamp/tree/master/packages. Not that it would solve your problem in any way, but there is not much of the point to send PR to this one.. I think that even on library level it makes sense to include this ponyfill that simply checks if Object.assign is available and if not, it would include it. I wouldn't consider that polluting globals as you are only adding functionality by spec, nothing that shouldn't be there. Or do it configurable and allow a user of your library decide if they want to use it or they have own solution in place.\nWe wanted stampit as small in size as possible, so even including 20 lines just for a single use case feels like unnecessary evil.. @jyboudreau Such configurability is not that easy on our level as we would need to create separate bundles that would include it. Sorry, but IE11 is not worth the effort :) If you really want it that way, you can try to create PR, but I doubt it would be useful.\nComparing goals of your library and stampit doesn't seem right. On one hand, you would want your library to be small (if I understood correctly?), but at the expense of increasing the size of its dependencies? Including the fact that size would be bigger for everyone even people who don't need it. I fail to find the logic in it :). @koresar You have some good points too, but I am not convinced that we should include something that has native support in many other environments. Doing this means that you will never be able to use any optimizations coming from native implementations.\nWhy it's a problem to do what I outlined above? Just have a separate bundle that would include dependencies and be exposed as stampit/compat. People can easily alias that in Webpack in case of need and it won't influence others.. @koresar I don't want to make any promises right now, I have enough stuff on my plate right now :)\n@Mustack transform runtime can bloat the code quite a lot if not treated carefully. If you are using it for a lib transpilation a lot of code can be duplicated across various dependencies. It's probably not a solution I would go for.. @ericelliott I agree with you ... when you are developing an app. If you are lib author, then you can either include ponyfill by yourself or document that people need to use mentioned service. It's not exactly win-win scenario.. I think we can merge this for now and later we can try the approach through compat if needed. Question is, should we do something similar in @stamp/it also?. Phew, sorry @koresar, but I don't have a space to review this bulk of changes.\nHonestly, I am not even sure why to bother with another stampit release when there is stamp monorepo. Why not to just have a stampit@v4 to reference @stamp/it instead? Why two different code bases?. Sorry, but that still does not explain why to keep two almost identical implementations. When I started the idea about monorepo I thought that eventually, stampit module will be just a redirect to this monorepo and after a while it might be even deprecated and removed.\nRight now it's kinda unclear where is the difference. Is it possible to use extra modules from the monorepo with stampit? That's an example of a user question, I know they are both up to spec including composers, but in my opinion, it just makes things worse.\nI can imagine it wasn't easy to accomplish size reduction you wanted, but it feels kinda OCD :) Do you know someone who actually complained that this lib is couple bytes larger than it could be? I am probably living in a different world where a size of the libs is so much higher and it does not really matter in overall.\nPersonally, I have kinda lost interest in stamps in overall. Perhaps I've never understood it that well to use it efficiently and without losing grasp over my codebase. In complex scenarios, it was just too messy for my taste. Not even mentioning adoption when working on the team and explaining everyone how it works.\nIf you feel like you want to go this direction then go ahead and merge and release it. I am not best to judge this anymore. Sorry friend.. I think this needs some sort of automation as a part of release process or at least document it somewhere. But that's just my point of view. It's up the @koresar who is making releases if he will be able to remember updating that number there manually.. This is unrelated to stamps, it's a basic behavior of JS engine. You are causing infinite loop there. By setting a value to this.parent it calls set which again sets this.parent and then it loops till stack is full. I believe you should avoid defining that setter there, it's an implicit behavior to set the value of that property. Otherwise, you would need to add a check there for equality and not to set a value that's already there to break the loop.. I don't know man, I never had this need for naming stamps really. It kinda feels weird that resulting name depends on the last named stamp composed in there. How can that be a good thing? . Ok sure, since this far from a breaking change, then go ahead :)\nBtw, I am still unsure why you are actually maintaining this package when there is the @stamp/it one which you even introduced in your blog as new way to do things. You should probably do the same change there if you want them to be the same although I don't see the point really. I thought that eventually, the stampit will just a be a redirect to @stamp/it to have a sane codebase. Your call.. Yea, full-blown Typescript support missing for stamps is something that forced me to leave this concept when I started using TypeScript. Unfortunately, I am not that well versed in these advanced and dynamic types to figure out how it should work. Perhaps there might be some inspiration in mobx-state-tree which is written in TypeScript and does these kinds of crazy compositions. It's not perfect either, but it mostly works.. Exactly reason why I removed it,there is no hidden magic in it that cannot be added when needed.\n. Perhaps instead of stating that v1 & v2 are not compatible with specs, might be better to say that v3 IS compatible. I think that positive attitude is better :)\n. No mention of what is the first argument. It's probably understandable from example below, but might be good to say: \"Each function receives first argument of called factory function and second object argument like this:\"\n. Perhaps mention what is this good for - ES6 fat arrows. I remember I was confused about it a lot.\n. initializers\n. You are missing instance in arguments\n. Might be worth mentioning here that result is accessible in stamp.compose.deepConfiguration. That's another difference and might cause confusion people wondering why they don't see configuration correctly.\n. \"and return a new stamp\" ?\n. console.log(...args) to get the desired output\n. I would say \"creates new stamp\" at least, otherwise it might look confusing for people looking at examples first.\n. Uhh, how these number are helping to explain anything? Since there is no reference to these in the example, it's just bogus and useless here ;)\n. Typo: isComposable ;)\n. Silly me. I hope it's all now :)\n. Is it really necessary to disable this rule for a whole project? I see only occurrence in test file, you can either disable there or I simply prefer to use counter += 1. The ++ operator just looks weird.\n. Should be stampit.umd.js if I am not mistaken...\n. Scratch that only occurrence, it's also in some for loops. But still I don't like that operator :)\n. Sorry, but performance is relative till you introduce actual performance tests. I would prefer clarity of code till we know this is a bottleneck...\n. I would leave docs in npm package. Many times I've been out of reach of internet and I just wanted to lookup something, but I couldn't.\n. Thanks :)\n. I would direct the polyfill service directly to actual file that can be served: https://cdn.polyfill.io/v2/polyfill.min.js?features=Object.assign. It's not very easy to find information how to make such request. However if you open that in chrome, you will get (almost) empty file as polyfill is not needed there, so that might be misleading bit.\nAlso I don't think it's relevant to use ponyfill link there. It won't help consumer because ponyfill is just module that is used directly in the code, it's not used globally. And for Object.assign it will lead you to already mentioned sindresorhus's module anyway.\n. I don't think this is a good way to show everything as it may confuse people what to use actually. CDNJS is also providing UMD build only.\nAnd there is no point in serving anything else but UMD bundle for a browser. Those other two are using require which would not work without bundler and in that case people can probably use NPM directly as well. \n. It should stay as it was ;)\n. Perhaps instead of pushing empty array it might be better to actually check its length before doing so. It's probably micro optimization and could use some measurement. Also it might be more readable. I had to read this line 3 times to actually understand what's happening there. \n. Why to rename to fns? I would say that result is much better to mark something that will be returned.\n. I am aware that this was there before, but I am actually wondering why we are returning undefined here when no functions are found. It's not against spec and returning empty array will simply cause no iteration. \nIt would also make the above recursive call better in the sense it wont need to create empty array knowing that this function always returns array.\n@koresar ?\n. So tests are badly written, I see :D No seriously, I am wondering how this became a rule that it should return undefined when empty.\n. Ok you have beaten me with thumbs :)\n. I am wondering, have you actually tried to avoid using Object.create itself if methods are not set? You could do something like descriptors.methods ? Object.create(descriptor.methods) : {};. I do remember from some benchmarks I was running like 2-3 years ago that this function itself was terribly slow. Also I don't actually see amy point in executing it if you just want a new object\n. Using new would mean something like this if I am not mistaken, but I would be surprised if it would be really faster.\njs\nfunction createFactory(descriptor) {\n  function Stamp(options, ...args) {\n    merge(this, descriptor.deepProperties);\n    assign(this, descriptor.properties);\n    Object.defineProperties(this, descriptor.propertyDescriptors || {});\n    ...\n  }\n  if (descriptor.methods) {\n    Stamp.prototype = descriptor.methods;\n  }\n  return (...args) => new Stamp(...args)\n}\n. I am fairly certain that it can be just [propName], why to write it like this ?. Is it actually necessary to use reify? You are making a test bundle with CommonJS so it wont do anything here.. Care to elaborate more ? :). ",
    "meandmax": "I`m about to refactor lots of old classes written in CoffeeScript by translate them in pure JavaScript and using stampit for object composition instead of classical inheritance. Your answer is exactly what I was hoping to hear, just wasn\u00b4t sure if I\u00b4m still on track.\nAbout argument passing:\njs\nvar d = factory({\n    link: link,\n    obj: obj,\n    node: node\n});\n... for setting public properties to something different then defaults, right?\n``` js\nvar b = stampit().enclose(function () {\n    var b = 'b';\nthis.setB = function(val) {\n    b = val;\n};\n\nthis.getB = function () {\n    return b;\n};\n\n});\n```\n... and something like this for setting private properties, right?\nThis is so much fun, think I got it ;-).!\nI will let you know how it goes with the refactoring.\nThanks so much, cheers Max\n. ",
    "jrf0110": "I'm a little late to this game, but may I suggest the name .use(...)? Seems to be fairly idiomatic for this sort of thing.\njavascript\nvar factory = stampit()\n  .use( behaviorA )\n  .use( behaviorB )\n  .use( behaviorC );\nJS folks would immediately see the similarities to other libs and might digest stampit's api more quickly\n. Oh and I was simply commenting on naming convention, not necessarily behavior :)\n. ## .join()\nPros\n- Terse\nCons\n- Might be confused with Array.prototype.join\n- Not at all idiomatic\n.use()\nPros\n- Idiomatic to JS\n- Terse\nCons\n- Might imply that the base object is mutated\n. Not sure who your'e agreeing with, but if it's me, I'd like to clarify that I think .use() is the best method name ( I mean, I suggested it after all :D )\n. right.\nMaybe even with some extra sugar:\njavascript\nvar factoryA = stampit({ ... });\nvar a = factoryA();\na.is( factoryA );\nfactoryA.didStamp( a )\n. ",
    "zebulonj": "@koresar I have doubts about whether a call such as .use() should mutate the state of a stamp, due to the risk that such a call could later change the behavior of a previously shared stamp. By generating a new stamp with each such call, the library aligns more closely to the functional paradigm.\n. Fair enough.\n\u2014\nSent from my mobile device.\nOn Thu, Jan 22, 2015 at 6:02 PM, Vasyl Boroviak notifications@github.com\nwrote:\n\n@zebulonj The stampit(m, s, e).compose(stamp2) call does not mutate state of the first stamp already. It's done.\nAll I wanted to say is that occasionally people would like to mutate the stamp. I already met two devs who did that on purpose.\nReply to this email directly or view it on GitHub:\nhttps://github.com/ericelliott/stampit/issues/46#issuecomment-71136106\n. My two cents:\n1. I don't have a horse in the alias race, but I strongly prefer compose. To me, it conveys the behavior... something new is created. I don't like combine. When I combine ingredients in the kitchen, I no longer have the ingredients.\n2. More important than the alias, I do strongly believe that stamps should be immutable once created.\n\nRegarding the poll... where is this poll located? How has response been solicited? I've voiced my opinion here, but I've never participated in a poll. With such low response, I say its results are meaningless. I agree with the poster who said they'd prefer the result come of rational debate.\n. ",
    "dfkaye": "@ericelliott Just back from the mountaintop and this is what it said:\n\nIgnore the community ~ this is your project, not theirs ~ if they're unhappy they can fork it and rename at will \n\nIt was convincing at the time...\n. @ericelliott OK ~ my vote is don't change the name ~ yet.\nFrom what I've read, compose() acts as a mixin method for other stamps, treating them as traits, so mixin() might be more accurate.\ncombine() sounds like it does what methods() does but others may hear it as mixin().\nuse() is well-intentioned but its use in other libraries (notably express) is to insert capabilities into a kind of call stack which is not what's happening here.\nMight re-consider the \"issue\" that there are multiple methods for decorating or cough extending a stamp ~ for example, does it really make sense to add a method or two to a stamp via methods() rather than as a trait that contains those methods via compose()?\nLike the mountaintop said earlier, it's your baby ~ mountaintop may have had some red wine, though...\n~ my two cents.\n. ",
    "sheriffderek": "One and a half years later... What is the conclusion here? I'm not seeing how to tell if something is an instance of a particular stamp. Kindly point me to the right doc? : ). ",
    "jomido": "OK, thanks. The stampit API docs do mention that:\n@param {Object} [state] A map of property names and values to clone for each new object.\nI apologize for missing this. To compose by reference, then, the options are either\na) enclose(), or\nb) assignment after instance creation\n. It seems to me that enclose() can be used conceptually the same as a constructor or init method. Instead of passing in the initial data as arguments, one grants the function passed to enclose access to the initial data via scope (or closure).  Like so:\n```\nvar refInstance = stampit().state(...).methods(...)();\nvar init = function () {\n    this.ref = refInstance\n};\nvar myInstance = stampit().state(...).methods(...).enclose(init)();\n```\nThis not only works but feels good, too. :)\n. ",
    "zaboco": "Well, not really instanceof, more like constructor. I think it's useful to have access to the factory method of an instance, so you can create another similar instance (as in my example). But, if this is not in the spirit of the library, I can understand.\n. @ericelliott I was thinking of cases when you don't have the stamp in scope (such as when getting an instance as a parameter in another function, in another module), and you don't want to mutate the received instance, instead you want to return a new instance.\nMy .clone method works, since it does stamp(this) which copies the state from this instance (and also any overridden methods).\nAnyway, maybe I rushed a little, I should use the library more, so I can find a relevant use case. So far I've just played with it, and I really enjoy it.\n. @koresar ok, #62 sounds nice\n. ",
    "unstoppablecarl": "I think something equivalent to setting a constructor property on a prototype in vanilla js would be very useful. The .clone() described has limited functionality as it doesn't give you direct access to the stamp and it copies overridden methods. Also the name clone is somewhat deceptive as it does not deep copy. I think it would be much more useful to have access to the stamp that created the object instance. Then you could check what stamp created the instance or create another instance using the same stamp.\nI propose adding a stamp property with the same purpose as the constructor property commonly used in vanilla js (not sure exactly what the property key would be, maybe something stronger like 'STAMP'). \n``` js\nvar thing = stampit()\n  .state({ ... })\n  .methods({ ... })\nvar myThing = thing();\nvar myThingsStamp = myThing.stamp;\nmyThingsStamp === thing; // true\nvar myOtherThing = myThingsStamp();\n// in the case of copying instance properties you could simply do\nvar myModifiedThing = myThingsStamp(myThing);\n``\n. Are there any alternative ways to figure out the stamp that created an object instance?\n. I can see the problems it would cause. I would be happy with any solution that lets you easily set a function that gets the stamp from the instance.\n. This is exactly what I recommended and you said was not a good idea.\n. I thinkinitorinitializewould be a good names. Technically therefsandpropsare for initializing as well but this is where initialization code would go right?\n. I am not sure if a full event system is necessary. What cases other thancreated` are there? \nA very simple solution would be:\njs\n// .init() aka .enclose()\nvar stamp = stampit().init(function(settings, stamp){ });\nThis would break backward compatibility though. I don't remember if it was decided to make the factory args a settings hash or not.\n. I think it should shallow merge. I don't think you would need to deep clone for init. \n. Also: if you do need to make a clone you can do that before passing it in, or as part of your factory code. If it clones by default and you need to set by ref, you just can't.\n. Will args be an array? or an arguments object? can you provide an example of its use?\n. Personally I would prefer stampit factories to accept a single object hash param, and you could always assume that to be the case. I think an object of sufficient complexity to use stampit would likely accept enough arguments to necessitate a single settings object (this is how I tend to do it at least). This would also remove the need to have to handle the arguments object that can hurt performance and cause headaches.\n. I think there needs to be something explaining that stampit().init() can be used to enclose private data and as an initializer/constructor. I am not sure where this should go though.\n. There is a lot of content needed to fully explain and document stampit. I think the current readme has too much for one file. \nI propose:\n- README.md description, table of contents type list of links to other info, very basic code examples with links to more in depth descriptions/examples of methods in other files or wiki pages\n- examples.md/wiki in depth examples and explanations of methods and specific cases see #81 \n- api.md the api section of the README.md\n@koresar if you can get on gitter I would like to discuss.\n. Breaking this will have little consequence as I think few people used it in 1.x anyway. If someone was using this the arguments in 1.x it would be pretty painless to adapt to the new api anyway.\n. Why is mixer.mixIn designed to need to use .apply?\nhttps://github.com/ericelliott/stampit/blob/init-making-stampit-flexible/stampit.js#L54\nNever mind I misread what it was doing.\n. What about using a faster .apply ?\nEspecially when not using any context.\nhttps://github.com/codemix/fast.js/blob/master/function/applyNoContext.js\n. @lecstor if you get on the gitter channel I can walk you through it https://gitter.im/ericelliott/stampit?utm_source=share-link&utm_medium=link&utm_campaign=share-link\n. @koresar we talked about it here too #57 \nI am not sure if having stamp() and stamp.create() behave differently is wise. I think shallow copy should be the default behavior and if you need to deep copy you can do that in an init().\n. Correct. refs assigns values \"by reference\" and props makes a deep copy. props is more for initializing properties with things like objects or arrays that you want to be unique to each object instance.\nNote that props is a deepClone https://lodash.com/docs#cloneDeep it is not like _.extend() which merges one level deep.\n. I just want to clarify for future reference. \nrefs() is equivalent to _.extend() https://lodash.com/docs#assign\nprops() is equivalent to _.cloneDeep() https://lodash.com/docs#cloneDeep\n. I don't think ignoring existing properties is a good idea.\n- It breaks backward compatibility\n- does not follow our consistent 'last in' behavior\n- I think most would be surprised to find properties ignored when creating an object instance with a stamp.\nWe need a name for this arg. It should be referred to as settings (or something else) to avoid confusing it with props, it is difficult to talk about it and compare it to props if it is also called props.\nI am starting to question if the settings in var instance = myStamp(settings) should be merged at all. It may be making too many assumptions about usage. I would rather see it passed to the init functions and let the developer decide how it is used. init({ args: args, instance: instance, stamp: factory, settings: settings } (where settings is the refs arg above). I don't think we can make the same assumptions of purpose or intent with settings as we can with refs, init, props, and static.\nI realize this would be a serious breaking change to backward compatibility and therefore probably not wise but I wanted to see what others thought. Would this make sense if backward compatibility were not an issue ?\nI would like to see a way to circumvent the settings merge behavior. I have some ideas I will put in a PR.\n. > \"Safely\" means that no refs data will be overridden, but props will be merged to the existing properties where possible\nI assume this means properties matching refs will be ignored?\n. We discusses this here and agreed that the settings object should be shallow merged #57\nhttps://github.com/ericelliott/stampit/issues/57#issuecomment-99593363\n. var instance = myStamp(settings) what should I call it to differentiate from props?\n. I didn't completely understand the intended behavior. I get it now that I did some testing.\nThis is the only strange behavior I found but I think it is acceptable given the way js works.\n``` js\nvar stamp = stampit().props({\n    connection: 'my connection',\n});\nvar instance = stamp({connection: undefined});\nconsole.log(instance); // { connection: 'my connection' }\n```\n. I understand all of that. As I said before I think it is acceptable given the way js works.\n. I started working on this https://github.com/stampit-org/stampit/tree/test-descriptions\n. Some of them I am not sure how best to describe can someone please look over the stuff I wrote?\n. good\n. \nJust a general concept. Font and details need to be refined.\n. \nJust came up with this one. Font is Open sans. I fine tuned the spacing and weight. Not sure about colors but I think it works well. \n. What do you mean?\nTrying some colors.\n\n. What do you mean by stamp-like?\n. I think making it an actual stamp is boring and generic.\n. These are good points. What do you think about a postage stamp?\n. \n. \n. Larger image. I don't know why I uploaded a small one.\n\n. > How would this one look in green?\nWhat kind of green were you thinking?\n. :thumbsup: agreed\n. We should decide on an approval process.\n. Maybe something like 3 people should review before merging?\n. I think examples should go in a different repo but that is just my preference.\n. > @unstoppablecarl @ericelliott @troutowicz \n\nThis PR is ready to be merged. Please, review. Otherwise I'd merge it into master tomorrow.\nPlease, pay attention to the stampit.js and couple of tests were changes. A little history behind that:\nWhen I was implementing stampit v2 I decided to limit fixed.methods to contain functions only. So, I used the mixer.mixinFunctions(fixed.methods, methods). Stampit v1 doesn't do that.\nHowever, while I was implementing these Advanced Examples I realized that limiting the freadom is the worst idea. :) Within this PR I changed the code back to mixer.mixin(fixed.methods, methods).\n\nI agree with this completely. I think calling it methods is misleading though. It seems the intent now is that fixed.method will be used as the object instance prototype via Object.create(fixed.methods) . Thoughts?\n. @troutowicz You disagree with the change to allow non-functions to be set in fixed.methods ? or my assertion that methods is misleading if it is not limited to methods?\n. I can see both arguments. To be honest I don't feel that strongly one way or the other, but I believe if non-functions are allowed methods is not a good name.\n. Maybe we should have methods only allow methods, and add proto (suggested alias for methods by @koresar) allow all. ?\n. Im with @koresar I prefer to commit progress even unfinished when I have to stop working so that it is in the repo instead of only the machine I was last using.\n. I think these primary questions need to be answered at the start of the file as concisely as possible.\n- What is stampit?\n  - A library with tools to assist in the creation of composable factories that leverage prototypal OO.\n- What is a stamp?\n  - A stamp is a composable factory function.\n- Why is this better than traditional factory functions and Classes?\n  -  Stamps can be composed to make new stamps with merged behavior.\nMaybe we should have an image that shows a tree representing classical inheritance and 4 stamps side by side with arrows down pointing to a new composed stamp? I think that would quickly communicate the concept. \n. > moving the detailed API docs to individual files in the docs folder.\nAgreed\n. > We need to answer \"what is stampit?\" and \"why should I care?\" in a short paragraph or two at the top of our README.\nI think we should answer them as concisely as possible in 1 or 2 sentences at the top and elaborate later in the readme. Maybe a link in the short answers to the detailed explanations. I think the lack of conciseness at the start of the file is what is leading to the inability to get what stampit is after skimming the top.\n. > A stamp is a composable factory function. It creates object instances. You can compose multiple stamps together to create new stamps.\nI think this needs to explain what it means to compose multiple stamps.\nFactory functions require the new keyword? Is that a typo?\nI think we should add a file that explains our philosophy and what anti-patterns we are avoiding with stampit. thoughts?\n. I think it would be better to always use stampit() so it is clear that there is a step where you are creating a new stamp then adding things to it.\n. What is stampit?\n- A library with tools to assist in the creation of composable factories that leverage prototypal OO.\nWhat is a stamp?\n- A stamp is a composable factory function [link to factory function definition].\nWhat is a composable factory?\n- Stamps can be composed to make new stamps with merged behavior.\nImage that shows a tree representing classical inheritance and 4 stamps side by side with arrows down pointing to a new composed stamp.\nIs stampit a framework?\n- No\n- Multiple codebases using stampit and making stamp objects can be used to compose new stamps with merged behavior.\nHow does stampit work?\n- When creating an object instance in javascript properties on the resulting object instance will be one of the following types:\n  - Immutable primitives such as string or number\n  - Objects by reference (objects or arrays referenced elsewhere)\n  - Objects created specifically as part of the object instance creation process\n  - Functions\nJuggling these properties when creating an object in javascript can be tricky. \n@TODO add an example of implementing all of these types of properties using a function constructor in js, then how it would be done using stampit\nthoughts?\n. ### Symbols\nI have not used symbols much so I am not very familiar with the way they are used by others. Not knowing of a universal intended use, my first thought is that symbol assignment should be left up to the user. The fact that classes in js inherit symbols (including statically) should probably not be relevant in our decision to include them automatically when composing. If it is decided that they are included automatically when composing, there should be a way to disable this behavior. How much performance overhead would including symbols cause?\nHow should symbols be handled when creating a stamp from a constructor (are we still supporting that?). That object may have symbols that you may or may not want to carry over. \nThe most strait forward solution that covers all use cases:\n- Add an (inheritable?) way to set a stamp to copy all symbols as if they were enumerable\n- Add .symStatic() .symProps() .symRefs() for a way to directly specify and control which symbols are set\nWith these two things users can use symbols in an inclusive or exclusive way.\nI don't feel strongly about the symbol stuff. I have not used them extensively. Just sharing my thoughts. I do think symbols should have their own tools and not have a composition function be the only way to handle them.\nStamp Composition Functions\nI could see many use cases for this and it is worth including in the spec. The name thru is not very communicative of what it does postCompose is much better but I would prefer .initStamp() or .afterComposed()\nIn the examples given so far the .postCompose() method is not composable itself right? It is only called on the first stamp in the list to be composed. So you would not be able to compose or inherit that behavior. Is this intended? Maybe I am not understanding.\nWhat would the before / after functions do exactly? I can only think of use for a function that has a chance to make changes to the stamp before returning it when creating / composing stamps.\nComposable Stamp Composition Functions (Proposal)\nAdd .initStamp() method to stamps. It behaves exactly the same as .init() as far as setting, storing, and composing goes (internally stored as an array of functions, these arrays are concatenated when composing stamps). When a stamp is composed / created, after all other composition behavior (including merging the initStamp array), each function in the initStamp array is called on the resulting composed stamp. Each function is expected to return the same or new stamp to be passed to the next function in the array etc. No intermediate stamp objects are created maintaining non-enumerable properties on the stamp.\n. I just did some experimenting. In node v5.0.0 Object.assign() does merge symbol properties. \nNot sure how this will effect stampit behavior.\n. @boneskull \n\nIf the purpose of stamps is to allow you to use them wherever you would otherwise use ES2015 classes, then what ES2015 classes do with objects (including how they handle Symbols) is relevant to the conversation.\n\nI do not know if that is the intent or not. I do not have a strong opinion one way or the other to be honest. The intent should be decided and written in the docs somewhere to keep everyone on the same page and be consistent.\nAs I said above I am not sure what the universal / general intended use case for symbol properties is (static or instance). I suppose if it is intended to be inherited when extending classes, and copied when using Object.assign(); it would seem the intent is for them to behave the same as normal properties as far as object creation is concerned. Then again if that were the intent, why are they specifically excluded from Object.getOwnPropertyNames() and Object.keys(obj) and for(var key in foo). The more I dig into symbols the less I understand how you would use them. I get that they are a unique key which is nice but why do they behave differently from string property keys?\n. Is this correct? shouldn't it be return priv ?\n. \"memory leak risky\" is not good grammar. Can you explain what you mean by memory leak risky? \n. Would it be more clear to use ctx.instance instead of this?\n. 'the last' should be 'last.\n. authorise should be authorize.\n. any not aby\n. change 'in that order' to 'in the following order'\n. Shouldn't this be ForcedDefaults.props ?\n. Couldn't this be accomplished using props or refs?\n. Can you show which examples require it?\n. Just curious, does using let instead of var do anything here? \n. ",
    "sethlivingston": "It's telling me that it can't be merged because I don't have write access. Sorry I don't have a more helpful answer on that.\nPersonally I would make lodash an external dependency, that way stampit only contains the stampit code itself. Those who use stampit will likely be bundling or including lodash through a different approach, anyway. Browserify lets you specify which libraries are external dependencies, and it will leave them out of the final .js file.\nDoes that help?\n. Regarding the three extra commits -- maybe there was some way to assign my PR to a branch of the same name (feature-lodash) in this repository? I'm not sure. Feel free to just take the changes and ditch the PR.\n. Thanks, @koresar! \n. Wow I didn't know those existed... very cool. Not sure how to make that friendly for stampit users, though. For example, I'm already using the full lodash library in the app I'm building, so I don't need the function modules. I could see how the function modules would be very attractive to other app developers, though.\n. As long as we're discussing options, there are two more (that could be combined):\n1. Yank the implementations out of mout or lodash and put them in stampit. There are only six I think, and two of them are forIn and forOwn. Do the extra bytes justify the simplicity that comes with zero dependencies?\n2. Build separate libraries (pseudo-names): stampit-standalone, stampit-lodash-external, stampit-lodash-functions-external, stampit-underscore..........\n. Oh duh, that explains it.\nAnd yes, I will...\n. Yes I'm using this for a production app under development. For me, a dependency on lodash is fine, but I don't want it bundled inside stampit (and can't imagine others would, either).\nBut yes I was also just floating the idea. \n\nOn May 5, 2015, at 10:32 PM, Eric Elliott notifications@github.com wrote:\nReally? Are you hoping to use this for a planned production deployment, or just floating the idea?\nLodash dependencies bundled is really inexpensive...\n\u2014\nReply to this email directly or view it on GitHub.\n. Yep, that's what I meant. I think we're on the same page. \nOn May 5, 2015, at 10:43 PM, Vasyl Boroviak notifications@github.com wrote:\nYour 'lodash' will be reused if stampit targets the same version as you (^3.8.0). That's how NPM works.\n\u2014\nReply to this email directly or view it on GitHub.\n. Understandable.\n\nOn Thu, May 28, 2015 at 9:21 AM, Vasyl Boroviak notifications@github.com\nwrote:\n\nThe proposed feature is rather complicated to build. There is human\nresource shortage at the moment. The cake is not worth the effort IMO.\nHowever, as always, PR's are very welcome!\nClosing this issue as won't fix. I hope that's okay with you\n@sethlivingston https://github.com/sethlivingston.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ericelliott/stampit/issues/59#issuecomment-106347107.\n. The unfortunate side effect of this is that it prevents libraries that still use bower from listing stampit as a dependency. Bower support is best dropped from apps -> frameworks -> libraries, not the other way around.\n. I'd be happy to, but I know @ericelliott is wanting to push the universal javascript message (no bower)--which I respect. If you guys decide you want to keep it for now, I'd be happy to maintain it.\n\nEric after reading this:\n\n. Haha okay I'm on it. I'll pass along an update tomorrow...\n. Not yet, but I will get this submitted. I need it. Few more days...\nOn Wed, Jul 1, 2015 at 11:32 PM, Vasyl Boroviak notifications@github.com\nwrote:\n\nDo we have any progress on brew, @sethlivingston\nhttps://github.com/sethlivingston ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/stampit-org/stampit/pull/106#issuecomment-117902257.\n. This is working fine as it is, guys.\n\nbower install stampit\ninstalls stampit 2.1.0 (the latest as of this writing), and\nbower install stampit#1.2.0\ninstalls stampit 1.2.0. I honestly could not tell you why it wasn't working for me before, but it works fine now.\nWe do need to restore the bower.json file, though. I will submit a PR momentarily for that...\n. ...https://github.com/stampit-org/stampit/issues/150 needs to be resolved first.\n. And to clarify an earlier comment on this thread, Bower doesn't care what type of module you publish--AMD, UMD, globals, ... doesn't matter. Bower's main goal is to make it easier for developers to get the files they need quickly and (presumably) bundle them.\n. Current release is 2.1.0 (https://github.com/stampit-org/stampit/releases).\nCurrent published release on NPM is 2.1.0 (https://www.npmjs.com/package/stampit)\nLatest available build on CDNJS is 2.0.3 (https://cdnjs.com/libraries/stampit)\nWe do not link prominently to CDNJS in the README.\nWe do need to provide a /dist/ folder, at the very least for bower. Bower was built to prevent developers from having to fetch files from all over the planet, including from CDNJS. IMHO it also just makes sense to have a committed copy of stampit.js and stampit.min.js included with every release we tag.\n. The Bower distribution is up and running with all of the releases: https://github.com/stampit-org/stampit-bower, and we have re-registered our Bower package to point there.\n. Let's get this wrapped up by addressing CDNJS:\n1. Who is doing this right now?\n2. It seems to make sense that we post the Bower distribution (UMD) to CDNJS, no?\n3. Would you like me to take over this, too? I'd be happy to.\n. I created a PR with CDNJS (https://github.com/cdnjs/cdnjs/pull/5201) that tells CDNJS to pull from stampit-org/bower. When the PR has been approved, I will (finally!) close this issue.\n. The PR has been merged. The UMD version of stampit 2.1 will be available on CDNJS in the next 24 hours, and no further action is required for CDNJS. When we update stampit-bower, CDNJS will be updated within an hour. \n. Glad to hear, @dwiyatci, and thank you for testing that. \n. @koresar At least it's a one-time thing and not even something we need to automate. :)\n. Welp, we have another problem-o. Stampit depends on supermixer, which also does not support Bower. Further, both projects would really need to provide a UMD wrapped file to support Bower well.\nSooooo.... do we still want to do this?\n. OK I'll take a look at that -- hold this PR for now, though.\n. 1. In progress.\n2. Bower retrieves the dist/ files from our GitHub repo; they have to be stored there. (1)\n3. In progress.\n4. In progress.\n(1) If you're like me and about 43 years old, then yes we were brought up to never commit output files (back then, large binaries) in a repo. Times have changed, though. Many depend on our output file being there, and it's just a small script, so there's really no harm. Another alternative is to handle it like John-David Dalton has for lodash: he has created separate GitHub projects for his distributions, but I don't think we need to.\n. OK, this commit includes:\n- We were not using browserify, so I removed it in favor of webpack since we're already using it on the react side. Let me know if this is incorrect, but all of the checks worked out.\n- npm run bower which packages stampit for the web (Bower) and puts it in the /dist folder.\n- Added npm run bower to the npm run prepublish script.\n- Added the /dist folder to .npmignore\n- A few other supporting changes.\nBower retrieves everything it needs, on demand, from our GitHub repo. There is no need (or capability) to \"publish\" to Bower. These are the only requirements for being published on Bower:\n1. bower.json is set up the way we want it.\n2. Our distributables for Bower are in the repo.\n3. We tag our releases--this is how Bower discovers available versions.\nOne more thing: The Bower files are dist/stampit.web.js and dist/stampit.web.min.js.\n. 1. Let's do build-web. It's not a UMD package.\n2. We do need different file names in the /dist folder, because they are different files. stampit.js can only be consumed by node modules. stampit.web.js can be consumed by browsers. In this way we are adding support for Bower/web clients, but we aren't modifying the core node build--no UMD needed or wanted.\n3. I can remove it from the prepublish step and simply add it to the build step. As long as the .web files are in the /dist folder when we commit to the repo, we're good with Bower.\n. Nobody uses AMD and we already have a proper nodejs build... so the only thing we need for browsers is build with \"stampit\" as a global.\n. OK, is that what we want to do? Two UMD files in /dist/stampit.js and /dist/stampit.min.js?\n. I think with Bower going away (a lot slower than most think, mind you), a separate repo makes good sense. The current stampit-org/stampit is a \"pure\" node module; it would be nice to keep it that way.\nI need 1) someone to set up stampit-org/stampit-bower (or somesuch), or 2) someone to give me permissions to do that, or 3) if you want to make this \"third party\", then I'll put it underneath my GitHub. \n. > I think a lot of the Bower ecosystem will soon be looking at very outdated modules, and only the most popular will have mirror repos in the Bower ecosystem to stay current.\nI agree, and that will probably speed Bower's decline.\n. I think we are done with this PR - time for it to meet its spirit horse.\n. Sounds like your next article, Eric. Good stuff.\n. ",
    "ahdinosaur": "if it makes sense, i recommend using the modularized lodash modules instead of the monolithic module, as that way it's possible to de-duplicate common lodash dependencies with other modules.\n. ",
    "troutowicz": "I don't think so. The way I have been doing this is:\njs\n...\n// create stamp\n...\nexport default stampit.extend(someStamp, {\n  // static methods/vars here\n});\n. @ericelliott I can work on the PR :)\n. Hi @koresar.\nSo refs is just the new state, and state binds to the stamp instance. That feature has it's uses, but some libraries, like React, look at the constructor object for certain properties. And this is where a declarative static convenience method would be super cool.\nAt the end of most React components, you will find several objects being assigned to the class declared earlier in the component.\nExample from my project's auth button:\n``` js\n...\n// AuthButton class/stamp declared\n...\n// add several objects to class/stamp\nAuthButton.contextTypes = {\n  muiTheme: React.PropTypes.object\n};\nAuthButton.propTypes = {\n  label: React.PropTypes.string,\n  onTouchTap: React.PropTypes.func,\n  style: React.PropTypes.object\n};\nAuthButton.defaultProps = {\n  label: 'Login',\n  style: {}\n};\n...\n```\nThis imperative step of designing a component could be done away with if we could declare these objects inside our stamp. I realize that these property assignments could be made more declarative using a helper function like mixIn/extend/Object.assign, but that still doesn't do away with the unnecessary extra step.\nI should also mention that class property initializers, like static, are being discussed for ES7.\nDoes that clear up the need for this feature?\n. Yes, that would be the proper usage.\nWe could improve the core API like you describe, or just not support the passing of a static arg. Although we probably want to support all use cases.\n. :+1: \n. That would be awesome.\n. @koresar It was decided in #64 that v1 should only get the method form of this feature.\nI can probably write up the tests in the next 24 hours, I got sidetracked with #66 today.\n. From what I've experienced, stampit is not compatible with ES6 classes.\nhttps://github.com/babel/babel/issues/682\n. ``` js\ntest('stamp from ES6 class', (t) => {\n  t.plan(1);\nclass Foo {}\n  const fooStamp = stampit.convertConstructor(Foo);\nt.ok(\n    stampit.compose(fooStamp)(),\n    'should create instance'\n  );\n});\n```\nTypeError: Cannot call a class as a function\n. Sure. #75 \n. Updated with docs and tests.\nI am going to create another PR for the 1.x branch. @ericelliott I know you prefer static over statics, however jshint will puke complaining about static and it being a reserved keyword. Do we disable jshint reserved keyword checks?\n. I'll close it for you :) \n. I'll put together a repo in a bit.\n. @ericelliott react-stampit\n. I started thinking of abstracting stampit as I created the repo. I just wanted to get something basic put together while we discuss. I'll start making these changes when I'm back at a computer.\n. @ericelliott So I'm thinking of an API that's somewhat analogous to React.createClass.\n``` js\nimport React from 'react';\nimport stampit from 'react-stampit';\nexport default stampit(React, {\n  mixins: { },\n  state: { },\n  statics: { },\n// lifecycle methods\n  render() { }\n});\n```\nThoughts?\n. Sure thing.\n. @ericelliott I reworked the library, take a look :)\n. Let's continue discussion here.\n. @ericelliott Thanks for the mention on your social media profiles!\n. > Move the supermixer there too (convert to ES6 maybe). A new module name might be necessary.\nLast time I checked, I did this already :p\n\nMove react-stampit if the author is okay with that.\n\nI created react-stampit for the community, I am OK with this.\n. I have experienced the same problems with tape-run/phantomjs. But yeah, there really is no need for stampit tests to be ran in a browser. I'm just executing tests directly over at react-stampit.\n. > If someone was using this the arguments in 1.x it would be pretty painless to adapt to the new api anyway.\n:+1: \n. @koresar Been busy, I can look over it later today.\n. The tests are organized much nicer :+1: \n. I'm wondering the same @unstoppablecarl. What does the current implementation do differently than:\njs\nfunction addRefs(fixed, states) {\n  fixed.refs = fixed.state = mixer.mixIn(fixed.refs || fixed.state, states);\n  return fixed.refs;\n}\nAnd why are we returning fixed.refs?\n. Actually, is this not doing the same?\njs\nfunction addRefs(fixed, states) {\n  mixer.mixIn(fixed.refs || fixed.state, states);\n}\nIn which case, is this wrapper needed? ;)\n. @JosephClay If you look at the mixIn function, objects is never used... arguments is actually whats being used in the loop. And as far as I can see, stampit never passes in more than two objects (destination and source). Am I missing something?\n. Ah, I see why we are setting fixed.state or fixed.refs then returning.... its for chaining. \n. @JosephClay wow, I totally misread your post. glad we saw the same things though :p\n. We should deprecate the current arg format in favor of this... too much code smell.\n. It's worth the effort. :)\n. :+1: \n. > Yet another reason to avoid the class keyword.\n:+1: \n. Yeah, the problem here lies with the class spec, if the custom invoke function proposed in ES7 can be added after class declaration, then that would just be an extra step before passing the class into convertConstructor.\n. @ericelliott @koresar \nTurns out another part of the class spec makes this difficult. The class's prototype is not enumerable.\nI came up with a solution as I was working on a feature for react-stampit. Take a look at this gist. The gist uses babel's playground feature for property initializers, use stage 0 when transpiling.\n. No, as I said above, the gist is using one of babel's playground features for statics. It was really just to make my example simpler.\n. Never meant to give the idea that I wanted playground features in stampit. :p\nI'm not sure what you want detail wise for this bug, more information about the constructor issue is discussed here.\nThanks, it was a mix of trial and error and MDN.\n. I still need to add the ability to inherit static properties during composition.\n. Sure thing.\n. @ericelliott @koresar How should static composition work? deep merge? override last in?\n. Agreed. Over at react-stampit, that is exactly what I proposed.\nhttps://github.com/troutowicz/react-stampit/pull/2\nBut ignoring React, how should core stampit handle statics? I don't see a reason to use core stampit for React components when react-stampit exists.\n. Added sample and more docs to README. All that is left is to determine how to handle static inheritance during composition and what to do about JSHints reserverd keyword error when trying to use static instead of statics.\n. I think that's overdoing it, and kind of confusing. All statics are props, props of the factory.\n. @ericelliott @koresar Made the changes, cleaned up the commits. Should be ready to merge :)\n. Great. I'll let it sit while I sleep and merge in the morning if no objections arise.\n. :+1: \n. ``` js\nimport stampit from 'stampit';\nObject.prototype.stampit = stampit;\nObject.prototype.isStamp = stampit.isStamp;\nlet StampA = {\n  myMethod() {},\n  myState: \"a state\",\n  static staticVar: \"static var\",\n  init({instance, stamp, args}) { ... }\n}.stampit();\nlet StampB = {\n  static staticMethod() {}\n}.stampit();\nlet StampC = StampA.compose(StampB).props({ X: \"y\" });\nObject.prototype.isStamp.call(StampC);\n```\n\\o/ This feels hot.\n. You wanted stampit built into the language... stamps are objects. :) \n. :+1: \n. @ericelliott \n\nDo you have a link to a reference where I can learn more about this? Is the latest /dist/ build still available when people run npm install in their apps? \n\nhttps://docs.npmjs.com/misc/scripts\nFirst bullet point. There's really no need to have dist/ in the repo, noone looks at it. It's just for compatibility. I do it the way @koresar describes for react-stampit.\n@koresar We should use the files key of package.json instead of .npmignore.\nhttps://docs.npmjs.com/files/package.json#files\njs\nfiles: {\n  stampit.js,\n  mixer.js,\n  ... other files to include\n}\n. Exactly.\njs\n\"main\": \"dist/stampit.js\"\nI can help out with the ES6 conversion. I recently submitted a PR to @koresar's supermixer repo doing just that. I want to see all stampit projects using ES6!\n. #89 \n. #89 \n. Made a few changes to your summary.\n\nA stamp is a factory function with an ability to compose with other stamps. The ability to combine fields, methods, and initializers (object initialization behaviors) to create a new stamp is what sets stamps apart from the typical factories or classes. Classic factories can not be combined, and classic class inheritance is substituted with simple composition.\n. I'll take the first one. \\o/\n\n@ericelliott Looks like I need to take a crash course in RP ;)\n. :grinning: Should be able to start this over the weekend.\n. Thanks @unstoppablecarl \n. I think you are trying to do something like this?\n``` js\nlet doc = { kids: [ {attr: {padding: { left: 5, right: 10 } } } ] };\nlet Node = stampit()\n  .refs(doc.kids[0])\n  .methods({\n    setPaddingLeft(size) {\n      this.attr.padding.left = size;\n    }\n  });\nlet node = Node();\nnode.setPaddingLeft(18);\nconsole.log(doc.kids[0].attr.padding.left);\nnode.setPaddingLeft(5);\nconsole.log(doc.kids[0].attr.padding.left);\n```\n. I didn't turn your example around, I corrected it.\nIn your example let node = Node(doc.kids[0]) does not set refs. As @ericelliott said above, passing arguments is an anti-pattern and should be avoided.\nYou don't need to create a new instance for each node, just create one doc instance.\n``` js\nlet src = { kids: [ {attr: {padding: { left: 5, right: 10 } } } ] }\nlet Doc = stampit()\n  .refs({ kids: src.kids })\n  .methods({\n    setPaddingLeft(node, size) {\n      this.kids[node - 1].attr.padding.left = size;\n    }\n  });\nlet doc = Doc();\ndoc.setPaddingLeft(1, 18)\nconsole.log(src.kids[0].attr.padding.left);\ndoc.setPaddingLeft(1, 5)\nconsole.log(src.kids[0].attr.padding.left);\n```\n. I'm not sure if you are understanding how an instance is created with stampit. In your previous example\njs\nlet node1 = Node(doc.kids[0])\nlet node2 = Node(doc.kids[1])\nlet node3 = Node(doc.kids[2])\nYou just created 3 separate instances. stampit is a factory that returns a factory.\n. You're welcome!\n. Yeah, you aren't understanding. Let's step through your code.\njs\nlet Node = stampit({ ... });\n- You are still using args when we have said it's an anti-pattern.\n- What do you think Node is at this point?\n  - Hint 1: console.log(typeof Node);\n  - Hint 2: it's not a stamp instance\njs\nfromRef: function(args) {\n  return this.refs(args)()\n}\nYou have declared fromRef a static function. this will be equal to Node, which is not an object instance and does not have access to object instances and their state.\njs\nlet node1 = Node.fromRef(doc.kids[0])\nWhat do you think this is doing? What it is actually doing is returning a shallow copy of doc.kids[0]. It is in no way related to a stamp instance (since Node is a factory not an instance).\nIn the end all you did was go in a big circle, never actually making use of your stamp.\n``` js\nlet copy = doc.kids[0];\ncopy.attr.padding.left = 18;\nconsole.log(doc.kids[0]);\n``\n. I guess I am totally lost now as to why no one else is seeing what I am seeing. @lecstor is not using stamps correctly at all. He doesn't understand the difference between a factory and a stamp instance and doesnt understand the behavior ofstatic` methods.\nAFTER you call stampit(), ANOTHER factory is returned.\njs\nlet Node = stampit() // <---- Node is a factory NOT a stamp instance\n  .refs({})\n  .methods({});\nAt this point the contents of refs and methods are stored internally by the stamp factory, they CANNOT be used. Before trying to access or mutate state or call stamp methods, Node must stamp out a stamp instance!\n``` js\nlet nodeInstance = Node({ any refs to override });\nnodeInstance.someRef;\nnodeInstance.someMethod;\n```\nStampit will be impossible to use if you cannot understand the above.\nEverything @koresar has  said though still stands. The behavior of stamp factory args may need to be rethought. \n. Wow.... I apologize @lecstor! I never noticed the extra pair of parenthesis... my last couple comments can be scratched out and mostly forgot about.\nWhat I now do not understand is why you think you need the static convenience method? What is wrong with\n```\nimport stampit from 'stampit'\nimport map from 'lodash/collection/map'\nlet Node = stampit({\n  methods: {\n    setPaddingLeft(size) {\n      this.attr.padding.left = size\n    }\n  },\n})\nlet doc = { kids: [\n  {attr: {padding: { left: 5, right: 10 } } },\n  {attr: {padding: { left: 20, right: 20 } } }\n]}\nlet node1 = Node.refs(doc.kids[0])();\nlet node2 = Node.refs(doc.kids[1])();\nnode1.setPaddingLeft(18)\nnode2.setPaddingLeft(16)\nconsole.log('doc', JSON.stringify(doc, null, 2))\n```\nThis way you are explicitly making two stamp instances and removing confusion. :p\n. I guess its your way of working around create() unexpected behavior. Makes sense.\nKeep checking in here @lecstor as you have found a possible bug as @koresar mentioned.\n. Closing this, feel free to reopen if the PR did not satisfy you.\n. @koresar can correct me if I am wrong, but I believe props is really what state used to be and refs is replacing the previously known behavior of state. refs data is a shallow copy, props is a deep merge.\n. v2 is expected to officially land this weekend. I would suggest becoming familiar with the new API of v2.\n. #104 \n. Another idea is a classic stamp, with a sort of cartoonish look. The rubber lettering on the bottom of the stamp should spell \"stampit\". The rubber should have some color, as if it was just used. Here is an example.\n\n. @NinjaGrisen I like that! Can I see what it would look like if you replaced \"Open Source\" with \"Composable Factories\"  and made \"IT\" lowercase?\n. I like that @unstoppablecarl !\n. Creative, I like it!\nEdit: With @marcelopereirascmspain's logo, we could use the korean stamp portion as the smaller logo (organization icon), and his full logo for places like the README.\n. @elrumordelaluz I like your color choices. Do you have any designs in mind that relate to a stamp? I don't really see the relationship of brackets with stamps.\nI'd love to see your interpretation of @marcelopereirascmspain's korean stamp design.\n. Keep up the imaginative ideas, these are looking great so far.\n. Travis seems to be working now. Travis URI in README needs to be updated, along with other URIs. :)\n. We can do something similar to what FB does for React. Make a tag GH Review: review-needed and one for when reviewers feel it is good to merge GH Review: accepted.\n. I would say that once you have more than two collaborators on a project, a simple change like this would make PR reviews easier to manage. First person to see the PR adds GH Review: review-needed and could cc someone else to handle the review. Or they could review right away by themselves. Once the reviewer thinks things check out they can add the GH Review: accepted tag and cc someone to handle the merge, or possibly handle the merge themselves.\ncc @unstoppablecarl @ericelliott \n. I'll sift through some of these as soon as I can :)\n. I'm going to stop there for now. These examples are nice @koresar . :+1: \n. @unstoppablecarl, fixed.methods has always been used as the object instance prototype. See here.\nI disagree with this change. The reason the property is named methods is because functions are the only data type safe to include on a prototype. (changes to a non-primitive may affect all instances with that prototype). We aren't limiting freedom, we are enforcing an API that will not create unexpected behavior.\n. I disagree with allowing non-functions in fixed.methods. :)\n. @koresar If you are talking about the first example in hacking.js then I would say that example should not exist. No point in showing a 'hack' that is considered a code smell, not to mention changing stampit's internal behavior just to support a clever example.\n. Did a first pass for ES6 changes, will go over again soon.\n. Cool. Yeah, let's let the PR sit for a bit.\n:+1:  eslint\n. :+1: \n. > Ideally all commits should be valid and working, so a case of non-completed job is a deviation, not a norm\nReally? You've never commited broken commits during development to record some kind of logical progression? This is extremely common. \n. Nice!\n. I merged simply because everyone has pretty much agreed the README needs a rewrite. Figured just having the mention for now wherever was fine.\n. I don't consider the placement bad to be honest. The placement should be close enough to the top and noticeable enough for anyone to see without having to scroll through API related docs.\nBut your change would probably be noticeable enough. \n. I agree with all 3 points. Stampit does not need to provide a wrapper to Object.assign.\n. The idea is to make the README as straight forward as possible. I think shortcuts should be mentioned in a tips & tricks doc.\n. @unstoppablecarl Looks good. Under Is stampit a framework? I would add that stampit is an implementation of EE's specification for composable factory functions.\n. Less in your face, I like it.\n. This is cool. :+1: \n. Before this gets merged, I would like to strongly recommend that PRs with this many commits should get squashed into one commit before being merged. It makes master's commit history easier to follow.\n. Nah, you can still use this PR. Squash, then git push -f origin stamps-as-promised\n. I restored the branch, try it now :)\n. Try now @koresar \n. Cleaned up PR over at #133 \n. :+1: \n. I don't know. I think fixed is fine as long as the API docs mention that fixed is an internal prop. No need to add complexity if it can be avoided.\n. I'd say that might merit some sort of warning in dev mode.\n. I've never tried myself, but I think Babel can handle environment checks for us.\nhttps://babeljs.io/docs/usage/babelrc/\n. Yeh my mind is gone. :p I was just trying to think of a way to display a warning when the project is in development, not production.\n. The README does mention it, but it does not make it clear that fixed is internal and should not be modified by the developer. I really think a warning is all that is needed. Developer's should be aware of the public API, and know what should be left alone.\n. The README should mention fixed is internal, and some sort of runtime log warning should be introduced.\n. :+1: A repo to share useful stamps would be cool.\n. I like the new hotness. :+1: Better to fix the problem (static collision) then to implement workarounds.\nI don't really consider the import statement trade-off a big deal. If the developer wants to type less:\n``` js\nimport * as stampit from 'stampit';\nconst validatedStamp = stampit.compose(\n  stampit.props({body: { ... }),\n  stampit.methods({ ... }),\n  stampit.init(() => { ... }),\n  Validator\n}).prevalidate({ put: { body: joi.required() } });\n```\nThat does not look pretty when using lots of shortcut methods but may be fine in situations where only one or two shortcut methods are used.\nTo be honest, with this new API, @koresar's production example is better off being rewritten:\n``` js\nimport * as stampit from 'stampit';\nconst validatedStamp = stampit.compose(\n  stampit.stamp({\n    init() { ... },\n    props: { body: { ... } },\n    methods: { ... }\n  }),\n  Validator\n).prevalidate({ put: { body: joi.required() } });\n```\nThis would perform faster and is cleaner.\n. That's fine, I'm not arguing against the usefulness of stampit's current immutable shortcut methods. This issue is about static collisions, your example does the exact same thing as @koresar's and does nothing to prevent static collisions.\nIssue #148 is why this issue was created. It shows, despite how useful they are, why stampit's statics can cause unexpected problems.\n. > it should be possible to produce stamps that should never collide with userland libraries\n:+1: \n. I like .create.*. It would fix static collisions while, I think, making everyone happy.\n\nfunctional mixins\n\nWhat about \"composable factories\"?\n. > These aren't names. They're descriptions. \nI thought @koresar WAS talking about an easy to understand description for the specification. Oops.\n. The distributables are available through cdnjs, is there a particular reason you need them in the projects repo?\nhttps://cdnjs.com/libraries/stampit\n. The distributables on cdnjs are supposed to be updated automatically at npm publish iirc. Looks like something is broken.\n@nkbt any ideas?\n. CDNJS needs to host the UMD modules.\n. Can someone put up an example that showcases the creatables in action?\n\nRename methods to proto.\n\nThis was brought up in another issue. I voted no. Putting anything other than functions on the prototype is a code smell. We should not encourage it.\n\nDucktyping rocks. :)\n\nI like ducktyping, but your proposal doesn't sit well with me. The structure is too loosey goosey. :/\n. This is looking good, lots of discussion. With the recent ideas, does the below look accurate?\n``` js\n/ composable === some object /\n.isFunction(composable); // true\n.isArray(composable.initializers); //true - optional \n.isPlainObject(composable.references); //true - optional \n.isPlainObject(composable.properties); //true - optional \n_.isPlainObject(composable.methods); //true - optional\n``\n-compose(baseObject, composables...)`\nTakes a base object and any number of composables.\nReturn a new composable with the capabilities of baseObject and the passed composables. If no arguments are passed, it uses an empty object as the base object.\n- composable(baseObject, composables...)\nTakes a base object and any number of composables.\nReturn a new baseObject instance with the capabilities of the passed composables. If no arguments are passed, it uses an empty object as the base object, and the parent object as the composable.\n- composable.compose(baseObject, composables...)\nTakes a base object and any number of composables.\nIdentical to compose(), except it prepends this to the composable parameters. If no arguments are passed, it just uses an empty object as the base object, and the parent object as the composable.\nNote: Am I thinking too much about stampit specific implementation? What should be included in the actual specification?\n. > You're composable function has an identity crisis.\nI'm not sure I understand what you mean.\n\nWhat's \"base object\"? AFAIK there's no such thing as base or parent object.\n\n\"base object\" is your \"stamp-description object\". \"description object\" does sound better. \"parent object\" is just that, the parent from which the .compose method is attached. (aka \"parent description object\")\nYour write-up looks good, but I think we should drop any uses of \"stamp\" from the spec and use \"composable\". Also composable() returns object instances, we should clarify that.\n. > Think of an analogy: Stamp=Promise\nOK, fine with me. I just wasn't sure how much stampit lingo we were wanting to use in a spec.\n. The distributables should be packaged with webpack, similar to react-stampit. This will ensure they will work in browser environments.\n. Here is the webpack config for react-stampit.\n``` js\nvar path = require('path');\nvar minify = process.env.MINIFY || false;\nmodule.exports = {\n  entry: {\n    'react-stampit': ['./src/index'],\n    'react-stampit-with-addons': ['./src/addons'],\n  },\noutput: {\n    path: path.resolve('./dist'),\n    filename: minify ? '[name].min.js' : '[name].js',\n    library: 'stampit',\n    libraryTarget: 'umd',\n  },\nmodule: {\n    loaders: [\n      { test: /.js$/, loader: 'babel-loader' },\n    ],\n  },\n};\n``\n. I think the build step should be calledbuild-browserorbuild-umd. The distributables are not specific to bower. Also, the files should be namedstampit.jsandstampit.min.js`, no need to include 'web' in the name.\nI'm not sure about adding this build step to the prepublish step. The distributables need to be tracked with git, prepublish does not do that on it's own.\n. Sorry, I forgot that the dist/ folder gets populated at prepublish time. The way react-stampit tackles this is using a lib/ folder for the node build during prepublish, and using the dist/ folder for the web build that is tracked by git. This allows the file to be named properly.\nIs there a reason that the webpack build is not being packaged as umd?\n. Our current nodejs build is just a transpiled version of src/. It isn't a really a 'build'. It does not package all src files into one distributable. The src just happens to be one file at the moment. Packaging with umd provides what the transpile step already does while ensuring a single file.\n. :+1:  for me, lets see what @ericelliott and @koresar have to say.\n. Can we remove this documentation from the README and add a link to this API doc? It might be better to include the example in the README, and link to the API doc for more information.\n. > One thing at a time Tim.\n:scream_cat: \n. bower should be capitalized I think.\n. :+1: \n. :+1: \n. > Real life examples should stay in the advanced examples\nAgreed. :) \n. Looks good guys. I am planning on making react-stampit spec compliant as well. :)\n. I thought getting away from using new and instanceof was one of the reasons stampit was created. If a code base insists on using these operators, perhaps that code base should be made more flexible?\n. Yes, it is reasonable. You don't even need to assign the stamp to a variable.\njs\nexport default stampit({})...\nAnd yes, they function the same.\n. It's personal preference. Api is a factory function, there should be no misinterpretation. Classes get instantiated with the reserved word new.\n. You shouldn't account for other people's shortcuts. Stick with the language's specifications. :)\n. Good catch.\n. Agreed. :+1: \n. I think a post-compose method could be useful. A use that comes to mind is logging/debugging. Right now, composition is a black box. We throw some stamps in and a new stamp might pop out if used correctly. Being able to step through each step of the composition process could make the process more verbose and easier to troubleshoot. I don't particularly care for thru, postCompose is more readable IMO.\nI don't see a problem with supporting Symbols in the stamp spec.\n. Thanks @paulfalgout!\n. Couple grammar tweaks.\n\nCheck out Fun with Stamps, a series of articles explaining the basics of stamps along with some advanced topics.\n. Not intentional, it should be mixin.\n. just make this:\n\nnode test/stampit-specs.js\n. algorithm \n. Would it be better to throw a merge conflict here instead of silently skipping the dupe keys?\n. by passing references -> by passing a references\n. I don't think these additions are needed. We only care about the data types of the returned values.\n. If I interpreted it correctly, the way you had it before arg was the first argument passed in. Now, args is all possible arguments.\n. js\nvar addMethods = (fixed, methods) => mixer.mixinFunctions(...[fixed.methods].concat(methods));\nAs long as things stay readable...\n. const means cannot be mutated after declaration.\n. I don't think my logic is wrong. supermixer and other mixin/merge functions iterate arrays the same as regular objects. So why should we treat an array as something special here?\n. Why?\n. :+1: \n. Yep.\n. Ah, yeah. I'll make the changes.\n. Sorry, I read your question wrong. Yes, I am making this change to all relevant locations.\n. I'll take a closer look. :)\n. isObject returns true for all types of objects, including arrays.\n. Why? How do we ensure that passed in values are functions?\n. memeory -> memory\n. Where is ctx declared in this example?\nEdit: Nvm, the passed in object is ctx. But this line is confusing. It should be changed to stamp.fixed since the user will never directly refer to ctx.\n. Why is this if statement used?\n. I think for the doc, we should not append a number to variables, it makes for easier reading.\nSelfAwareUser1 -> SelfAwareUser\nuser1 -> user\nThis applies to all advanced examples using this naming scheme.\n. This is -> This is a\n. No need for the extra parenthesis\n({ instance, stamp }) -> { instance, stamp }\n. ({ instance, stamp }) -> { instance, stamp }\n. If we are going to make these examples ES6, lets use ES6 everywhere :)\nlog(obj) {\n. ({ instance, stamp }) -> { instance, stamp }\n. ({ instance, stamp }) -> { instance, stamp }\n. For the same reasons as above:\nctx.stamp.fixed -> stamp.fixed\n. ({ instance, stamp }) -> { instance, stamp }\n. // check if prototype  already has the clone() method\n. getEntity(id) {\n. ({ instance }) -> { instance }\n. I just meant that the variables should be renamed in this file, ADVANCED_EXAMPLES.md. This file is what explains the advanced use cases, it should be as clear as possible. The example files can be left as is I think.\n. I guess I expected that to just work heh. Oh well. \\o/\n. I see both spellings in this doc, lets stick with one.\nbehaviour -> behavior\n. behaviour -> behavior\n. This belongs one line up.\n. No. But let is basically a replacement for var, no real reason to use var.\n. What is the purpose of running npm outdated here. It won't prevent publishing afaik, looks to be just some extra info for the developer.\n. make any existing stamp to return promise\n->\nmake any existing stamp return a promise\n. I don't find this necessary. It actually makes it confusing for me, makes it seem like new paragraphs which leads me to expect a change in topic.\n. No one is supposed to be reading the ES5. Does this decrease performance? If not I would say we should go the ES6 route whenever possible.\n. This comment is confusing. By definition, return prevents proceeding.\n. I should not have to horizontally scroll to read comments. :(\n. We need to stay consistent with our arrow function formatting. The rest of the library excludes parenthesis around single parameters.\n(newInstance) -> newInstance\nThis PR has a few other places doing this as well.\n. Well, implementing these changes in this unrelated PR could be considered bikeshedding. ;)\nThe formatting of the raw text does not need to be any different than the resulting rendered text IMO.\n. Considering stampit is now an ES6 project, we shouldn't need to worry about what a developer does not know about ES6. But if performance is actually a noticeable thing here, then by all means stick with concat. :)\n. OK :)\n. Hmm, are you confusing spread and rest? ... in this case is spread, which is just sugar for concat.\n``` js\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\nlet arr3 = [...arr1, ...arr2];\n```\nis equal to this ES5\n``` js\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nvar arr3 = [].concat(arr1, arr2);\n``\n. For more examples see the [API](docs/API.md) and the [advanced](docs/advanced_examples.md) examples.\n. I think this line can be removed.\n. I see a few variables being declared withvar. Should do another pass and fix those. :)\n. These examples are still usingvar`.\n. > One thing at a time Tim. I'm not changing text at this point of time. Just moving.\nYou have introduced several new examples in this PR, this is not just a \"moving\" commit. I'm not asking for anything that you have not already started to do already.\n\nDone\n\n:+1: \n. ",
    "dcollinsf5": "I agree. Even though I used the args list method for all of my stamps... Since upgrading to 2.0 will require a code audit anyway, I'd really like to get any syntax conversions out of the way at the same time.\n. ",
    "rektide": "\nYet another reason to avoid the class keyword.\n\nAnd all JavaScript code you might want to consume using it? That's going to get pretty difficulty pretty fast now.\n. initial link is moved, now https://github.com/stampit-org/stampit/blob/master/docs/advanced_examples.md\n. ",
    "boneskull": "I'm struggling with wanting to compose from Map right now; whatever solves this issue from userland is going to be helpful.  If I can be of assistance, please let me know.\nAlso, if anyone knows why Map throws if not called with new (or if you can direct me to who might know), I'm all ears.\n. Please provide an example of unit testing a Stamp which is composed.\n``` js\nconst A = stampit({\n  init() {\n    // stuff\n  },\n  methods: {\n    // some methods\n  }\n});\nconst B = stampit({\n  init() {\n    // other stuff\n  },\n  methods: {\n    // other methods\n  }\n}).compose(A);\n```\nI've been hung up on this in one way or another for awhile.  How can I avoid test code duplication (or simply running the same assertions multiple times) and avoid tight coupling at once?\nty @koresar for your help on Gitter.\n. fwiw, I was not able to get @koresar 's pseudocode to work, or any other general solution.  I ended up just hacking around this specific issue:\njs\nconst EventEmittable = stampit.convertConstructor(EventEmitter);\nEventEmittable.init = EventEmittable.enclose;\nThis seems to work.  Hopefully this can get someone else w/ the same issue back on track.\n. :+1: \n. @troutowicz Sometimes that codebase happens to be the EcmaScript specification.  For example, you can't:\njs\nstampit.convertConstructor(Map)\nMap expects itself to be called with the new keyword; it will throw an exception otherwise.\n. @koresar that said, I'm behind supporting it\n. @troutowicz though, I'm unsure if we're talking about the same thing.\n. I'm not sure I understand why supporting that is necessary \n. @koresar I think I understand what you mean.  AngularJS does this as well.  You should be able to say, use a Stamp as a controller, but since they are instantiated with new, no such luck.\nThis makes sense.  new should be supported; it should not do anything, but it shouldn't make the stamp blow up.\n. fair enough\n. @ericelliott will probably spit up his coffee at this idea, but the most direct route from A to B might actually be to leverage ES2015 classes in some capacity under-the-hood to ease working with non-enumerable properties.  :imp: \n. If the purpose of stamps is to allow you to use them wherever you would otherwise use ES2015 classes, then what ES2015 classes do with objects (including how they handle Symbols) is relevant to the conversation.  \nHowever, it's not really about Symbols per se--it's about any non-enumerable property.\n. I am curious about just what the hell Object.assign() is up to in v5, however.\n. I haven't looked at the spec there, but I imagine that's what Object.assign() is supposed to do.  \njs\nconst obj = {\n  [Symbol.iterator]: function *() {\n    // ..\n  }\n}\nObject.assign({}, obj) // I would expect the iterator to work\n. @JosephClay That is one thing that you can (sort of; see below) use a Symbol for, but they also allow you to define the iteration behavior of an object (the for ... of syntax), among other things.  I think that may be the \"main\" purpose of a Symbol.\nIf an object has a Symbol property, it can be accessed via Object.getOwnPropertySymbols(), so it doesn't really make anything private.  \nAFAIK, the only way to achieve privacy is still via scope, whether that be a closure or use of a WeakMap.\n. k\n. I think I'm going to pass on this.  I was trying to get rollup to work for me, but it was too painful.\n. > If it is for the purpose of Tree Shaking with Rollup/webpack 2, then it will need to be more than just point to original ES2015 code. You'll need to create a new directory were all the ES2015 code is transpiled with the exception of ES2015 modules.\nAnyway, if I did look at this, I'm not understanding what @BerkeleyTrue is saying here.   Create a new directory? Put what there? There's only one source file.\n. @koresar from the API docs:\n\n@param {Object} [options.props] An object to be deeply cloned into each newly stamped object.\n\nSo, yeah, it should do what it says it does. :smile: \n. Lame.  I wanted it to deeply clone.  Maybe move any further chatter to stampit spec org?\n. (is it a shallow clone at this point?)\n. If I did this correctly, Travis CI should break on Node.js v4.. I notice there are spread operators everywhere.  This also breaks Node.js v4, etc.\nI am not really familiar with Buble/Rollup; the few times I've tried to use this combination, I couldn't make it do what I wanted.  I'm also unsure what prompted the switch from Babel.... We should publish no more than:\n\nA module consumable by Node.js v4 or greater.\nMaybe a browser-ready, CDN-able bundle, if that's something people actually need.\nThe source files.\n\nI'm going to assume others disagree.  I saw some rumblings about bad tooling...\n. ...but we're not using Babel here.  It appears Buble should take care of it, but it doesn't, and I don't know why.. (This isn't really about fussing with tooling; it's that any version of stampit published since the switch to Buble is likely broken in 4.x).. My preferred solution would be to revert to using Babel. This will increase the number of dev deps. I'm not sure why that's a problem... . @FredyC Yes. It's non-trivial using the existing tooling. I would have to use Babel because I don't know how to make Buble work. . There are also many places using spread parameters and it seems rather silly to me to replace them with whatever the ES5 alternative looks like. . Yes. . The bundle is CJS but it doesn't matter since we don't export anything anyhow. But this would be the export of the bundle; it doesn't go thru and replace all the import statements in the tests. . ",
    "jptcnde": "Is it possible to get this new version (v2) from Bower? and How?\nI put this  stampit\": \"git://github.com/ericelliott/stampit#v2_0 in my bower config but it did not create a compiled / dist from new version.\n(ignore this one please. thanks) got the answer through stampit gitter  (they responded quickly)\n. ",
    "lecstor": "and having a play for a couple of hours it's great and it doesn't need to be as complex as it seems the first time you read the readme.. I was so confident I thought I'd write a little example that might have helped me.. just writing this I learned a few more things, but I have to admit the init args still has me a bit perplexed..\n```\nimport stampit from 'stampit'\nimport assign from 'lodash/object/assign'\nlet Thing = stampit({\n  init: ({self, stamp, args}) => { assign(this, args) },\n  methods: {\n    myReverse(arg1, arg2) {\n      return [arg2, arg1]\n    }\n  }\n})\nlet OtherThing = Thing\n  .init(\n    function ({self, stamp, args}){\n      console.log('init', args)\n      this.arg2 = args\n    }\n  )\n  .methods({\n    myMultiplier(arg1, arg2) {\n      return [arg1, arg2, arg1, arg2]\n    }\n  })\nlet thingInstance = OtherThing({ key: 'value' }, 'arg2')\nconsole.log('instance', thingInstance)\nconsole.log('reverse', thingInstance.myReverse('three','four'))\nconsole.log('multiplier', thingInstance.myMultiplier('three','four'))\n\ninit [ 'arg2' ]\ninstance { key: 'value', arg2: [ 'arg2' ] }\nreverse [ 'four', 'three' ]\nmultiplier [ 'three', 'four', 'three', 'four' ]\n```\n. wow, ok, I totally missed that one. Thank you. I'm now looking at refs() and my mental model has just flipped to where I'm attaching stamps to the nodes in my object (created by parsing an xmlish document).\nok, that's not right either, I'me still creating stamps there of course so don't want to set the instance data that way. So create() would seem to be the way, but it looks like that is doing a deepcopy so I can't rely on update by reference behaviour. I know that's not the done thing, but is it achievable if that's what I want to do, or am I forced to work with/around that?\n@ericelliott no worries about the time thing, totally understand, thanks for responding. I'll keep playing and learning (learning loads every step of the way). @koresar asked me to share my thoughts and questions, so that's mainly all I'm doing.\n. possibly a better example.. I think I know what I need to do (build up a tree of node objects) but it's not what I'd like to do (load a node into a stamp, access/modify and have modifications reflected in the main object).\n```\nimport stampit from 'stampit'\nimport map from 'lodash/collection/map'\nlet Node = stampit({\n  methods: {\n    setPaddingLeft(size) {\n      this.node.attr.padding.left = size\n    }\n  }\n})\nlet doc = {\n  kids: [\n    {\n      attr: {\n        padding: { left: 5, right: 10 },\n        margin: { left: 3, right: 6 }\n      }\n    }\n  ]\n}\nlet node = Node.create({ node: doc.kids[0] })\nnode.setPaddingLeft(18)\nconsole.log('doc', JSON.stringify(doc, null, 2))\nconsole.log('node', JSON.stringify(node.node, null, 2))\n``\n. so what am I doing wrong then, or how am I explaining myself incorrectly? 8)\nUsing refs() achieves my goal of setting thepadding.leftvalue indoc`, but creating another stamp for each instance is not what I'd want to do.\n```\nimport stampit from 'stampit'\nimport map from 'lodash/collection/map'\nlet Node = stampit({\n  methods: {\n    setPaddingLeft(size) {\n      this.attr.padding.left = size\n    }\n  }\n})\nlet doc = { kids: [ {attr: {padding: { left: 5, right: 10 } } } ] }\nlet node = Node(doc.kids[0])\nnode.setPaddingLeft(18)\nconsole.log('doc', JSON.stringify(doc, null, 2))\nnode = Node.refs(doc.kids[0])()\nnode.setPaddingLeft(18)\nconsole.log('refdoc', JSON.stringify(doc, null, 2))\n\n\n\n\n\n\n\ndoc {\n  \"kids\": [\n    {\n      \"attr\": {\n        \"padding\": {\n          \"left\": 5,\n          \"right\": 10\n        }\n      }\n    }\n  ]\n}\nrefdoc {\n  \"kids\": [\n    {\n      \"attr\": {\n        \"padding\": {\n          \"left\": 18,\n          \"right\": 10\n        }\n      }\n    }\n  ]\n}\n```\n. yes, that's turning my last example around a bit. It achieves the result of updating the main doc by reference but involves creating a new stamp for each instance which doesn't seem right. I'll be creating hundreds of instances where only the kid is different.\nIdeally I would be able to do\nlet node1 = Node(doc.kids[0])\nlet node2 = Node(doc.kids[1])\nlet node3 = Node(doc.kids[2])\nnode1.setPaddingLeft(18)\nnode2.setPaddingLeft(10)\nnode3.setPaddingLeft(15)\nand have the doc object updated accordingly.\n. sorry, I was referring to the last example in that post..\nnode = Node.refs(doc.kids[0])()\nnode.setPaddingLeft(18)\nconsole.log('refdoc', JSON.stringify(doc, null, 2))\nwhich I think does what you're doing there (with a bit of short-hand).\nI'll try to give a better example, but keep it as concise as possible.\nHere is an example doc for which I would like to use different \"classes\" to handle the different node types as each node type has different behaviour.\nlet doc = {\n    attr: {\n      padding: { left: 5, right: 10 },\n      margin: { left: 3, right: 6 }\n    },\n    kids: [\n      {\n        tag: 'row'\n        attr: { padding: { left: 5, right: 10 }, },\n        kids: [\n          {\n            tag: 'cell',\n            attr: { padding: { left: 5, right: 10 }, },\n            kids: 'Hello'\n          },\n          {\n            tag: 'cell',\n            attr: { padding: { left: 5, right: 10 }, },\n            kids: 'Goodbye'\n          }\n        ]\n      }\n    ]\n  }\nso what I'm hearing is that to do what I want to do I need to create a new stamp for each node, then instanciate a single instance from that stamp which to me feels like creating a class & instance for each node.\n. so, yeh, you're confirming what I said about Node.create() which is the same as Node() \n\nSo create() would seem to be the way, but it looks like that is doing a deepcopy\n\nThe notation Node.refs({ ba: 'boom' })() does what I want, but feels like it's doing extra work just to get the instance created to contain a reference to the main doc compared to Node({ ba: 'boom' }).\nchecking out for a bit, thanks for your help.\n. Yeh, looks like I'm definitely missing something somewhere, will keep at it, thanks again.\n. > stampit is a factory that returns a factory\nBut at some stage you need an object instance, my goal isn't to build factories, it's to do useful stuff 8)\nAnd the idea of a class is that you use it to create object instances that have different properties but shared behaviour.\nMy conundrum here is that I wish for the properties of my objects to be references to a larger object.\nTo do that with stampit I need to use refs() which means creating another class with my refs attached and then instantiating an instance of that class rather than having a class that I can create all of my objects from. I could do this with Node.create() if I didn't want the properties to be a reference.\nSo if that's just something stampit wont do, then cool, fair enough. If it will, then I'm hoping someone can tell me how as I can't get it to comply.\ncheers\n. ok. the bottom line.. Is this considered a bad or a waste of cycles?\n(no different to earlier code, but does what I want with a convenience method)\n```\nimport stampit from 'stampit'\nimport map from 'lodash/collection/map'\nlet Node = stampit({\n  methods: {\n    setPaddingLeft(size) {\n      this.attr.padding.left = size\n    }\n  },\n  static: {\n    fromRef: function(args) {\n      return this.refs(args)()\n    }\n  }\n})\nlet doc = { kids: [\n  {attr: {padding: { left: 5, right: 10 } } },\n  {attr: {padding: { left: 20, right: 20 } } }\n]}\nlet node1 = Node.fromRef(doc.kids[0])\nlet node2 = Node.fromRef(doc.kids[1])\nnode1.setPaddingLeft(18)\nnode2.setPaddingLeft(16)\nconsole.log('doc', JSON.stringify(doc, null, 2))\n```\n. 8) hehe. I'm having trouble not believing what I'm seeing. It looks like a duck, and walks like a duck.. (and behaves like I want). I'm not sure how it's not making use of the stamp as it gives me an object which I can call methods on to manipulate the data I want it to.\nArgs are an anti-pattern, but isn't that exactly what create(properties) does? I'm just working around the fact that create deepcopies the properties so I lose my reference.\nWhat if I expand the example to it's intended usage?\n```\nimport stampit from 'stampit'\nimport map from 'lodash/collection/map'\nlet Node = stampit({\n  methods: {\n    setPaddingLeft(size) {\n      this.attr.padding.left = size\n    }\n  },\n  static: {\n    fromRef: function(args) {\n      return this.refs(args)()\n    }\n  }\n})\nlet Cell = Node.methods({\n  ima(){\n    console.log('== Ima Cell ==', this.attr.padding.left)\n  }\n})\nlet Row = Node.methods({\n  ima(){\n    console.log('== Ima Row ==', this.attr.padding.left)\n  }\n})\nlet doc = { kids: [\n  {attr: {padding: { left: 5, right: 10 } } },\n  {attr: {padding: { left: 25, right: 50 } } },\n]}\nlet node1 = Cell.fromRef(doc.kids[0])\nnode1.setPaddingLeft(18)\nnode1.ima()\nlet node2 = Row.fromRef(doc.kids[1])\nnode2.setPaddingLeft(28)\nnode2.ima()\nconsole.log('doc', JSON.stringify(doc, null, 2))\n\n\n\n\n\n== Ima Cell == 18\n== Ima Row == 28\ndoc {\n  \"kids\": [\n    {\n      \"attr\": {\n        \"padding\": {\n          \"left\": 18,\n          \"right\": 10\n        }\n      }\n    },\n    {\n      \"attr\": {\n        \"padding\": {\n          \"left\": 28,\n          \"right\": 50\n        }\n      }\n    }\n  ]\n}\n```\n. 8) cool, back to my chores then.. have a good day @koresar!\n. for my 2c worth I ++ @koresar there. I can see benefit of \"safety first\" and protecting from effects from afar but I think most would expect references to remain intact. A convenience method for cloning wouldn't be a bad thing, maybe even if create() did the deep copy while stamp() remained shallow. Create kinda hints at creating a new thing. On the other hand, the simplicity of cloning before handing over the object as @koresar said negates the necessity of the deep clone option.\nIf I had gone the path I did with a little less stubbornness I likely would have bailed on stampit earlier without questioning it, accepting it wasn't the tool for my task at hand.\n. You did notice that I was calling the function returned by refs?\nthis.refs(args)()  <-\nso the same as\nnewStamp = stampit.refs()\nnode = newStamp()\nand the issue is that\nlet nodeInstance = Node({ any refs to override });  <- these \"refs\" are deepcopied\nthe code above that I posted runs as-is. You can copy/paste to a file and babel-node it.\n. 8) no worries @troutowicz\nNo reason other than it bugs me. Both do exactly the same thing, one's just prettier in use.\nLecstor out. \n. ",
    "dwiyatci": "Got it. Thanks a lot guys! =)\n. I checked the cdnjs earlier. Not all versions (including the latest) available there. No particular reason; just to keep my lib always updated to the latest.\n. Cool! Many thanks to @sethlivingston, @ericelliott, and the guys. OK, from now on: npm FTW!!\nI guess the link to cdnjs would be pretty much useful if someone (like me) wants to fiddle around with Stampit in some JS playground like https://jsfiddle.net/. :+1:\n. Works like a charm in JSFiddle now. Many thanks! :metal:\n. Done. =)\n. I guess you're right. This behaviour should be expected. I think I got mixed up a bit between concatenative and delegative prototyping. Thanks for the justification.\n. I identified it already before I submitted this issue (it was 2.x \ud83d\ude01). Just want to make sure it won't happen again in the future. PR been created.. Right. Automation FTW! \nAnd yes, please. Feel free to decline this PR and take it over, Vasyl. I don't think I have too much spare time these days \ud83d\ude43  . ",
    "lwhorton": "I found this confusing when it cropped up in a project... so to prove it to myself I wrote up a quick spec. Hope this helps someone else too:\n``` javascript\nvar stampit = require('stampit')\n    , chai = require('chai')\n    , expect = chai.expect\nchai.should()\ndescribe('testing stampit', function() {\n    var sut\n    describe('when using refs', function() {\n        var stamp\n        beforeEach(function () {\n            var refs = {\n                a: 'is a'\n                , b: {}\n                , c: {\n                    nestedObject: {}\n                }\n            }\n            stamp = stampit()\n                .refs(refs)\n        })\n        it('should not reference the same atom across multiple instances', function() {\n            var one = stamp.create()\n            var two = stamp.create()\n            one.a = 'is another a'\n            two.a.should.equal('is a')\n        })\n        it('should reference the same object across multiple instances', function() {\n            var one = stamp.create()\n            var two = stamp.create()\n            one.b.cat = true\n            two.b.cat.should.equal(true)\n        two.b.dog = true\n        one.b.dog.should.equal(true)\n    })\n    it('should reference the same nested object across multiple instances', function() {\n        var one = stamp.create()\n        var two = stamp.create()\n        one.c.nestedObject.cat = true\n        two.c.nestedObject.cat.should.equal(true)\n\n        two.c.dog = true\n        one.c.dog.should.equal(true)\n\n        two.c.nestedObject.dog = true\n        two.c.nestedObject.dog.should.equal(true)\n    })\n})\ndescribe('when using props', function() {\n    var stamp\n    beforeEach(function () {\n        var props = {\n            a: 'is a'\n            , b: {}\n            , c: {\n                nestedObject: { }\n            }\n        }\n        stamp = stampit()\n            .props(props)\n    })\n    it('should reference a different atom across multiple instances', function() {\n        var one = stamp.create()\n        var two = stamp.create()\n        one.a = 'is another a'\n        two.a.should.equal('is a')\n    })\n    it('should reference a different object across multiple instances', function() {\n        var one = stamp.create()\n        var two = stamp.create()\n        one.b.cat = true\n        expect(two.b.cat).to.be.undefined\n\n        two.b.dog = true\n        expect(one.b.dog).to.be.undefined\n    })\n    it('should reference a different nested object across multiple instances', function() {\n        var one = stamp.create()\n        var two = stamp.create()\n        one.c.nestedObject.cat = true\n        expect(two.c.nestedObject.cat).to.be.undefined\n\n        two.c.dog = true\n        expect(one.c.dog).to.be.undefined\n\n        two.c.nestedObject.dog = true\n        expect(one.c.nestedObject.dog).to.be.undefined\n    })\n})\n\n})\n```\n. ",
    "elitenomad": "\n(Learnt to use another Software Sketch 3 :+1: )\n. ",
    "NinjaGrisen": "A lot of talk about a stamp inspired logo so gave it a try, can change it up if I get some feedback.\n\n. There we go, some simple text changes. Is there anything else like more/less details, another texture or no texture at all, colors and so on give me a shout \n\n. Made the text bigger to increase legibility on Stampit. 100x100 px example on the side, one with the surrounding text and one without it. \n\n. @koresar Hehe thanks man :>\n. I love this one yeeyang! \n. ",
    "MarkAurel": "\n. \n. ",
    "marcelopereirascmspain": "A riff on the ideas of @unstoppablecarl and an attempt to incorporate the aesthetics of korean stamp seals - https://en.wikipedia.org/wiki/Seal_(East_Asia)\n\n. ",
    "elrumordelaluz": "\n. - variations \n  \n. @troutowicz the initial idea is { + some baseline = {\u20d2 , graphic synthesis of rubber stamp\n. ",
    "mjmcclain": "Stamp logo, over the top of braces. Just using a rubber stamp is too literal.\n. I said, \"literal.\" When something is too literal, it can be very generic. By combining the two: braces and a stamp over it (X'ing it out the braces) you add a layer of meaning.\n. ",
    "yeeyang": "@marcelopereirascmspain Reminds me of Jade's logo with the red box\n\n. Idea that I've been pondering about for a while.\n\n. ",
    "nkbt": "Stampit is about composition, so let's compose some post stamps\n\nOr use round ink stamp with square paper post stamp... you got the idea\n. @juanmnl like yours, but the stamp shape. It is factually incorrect and should be the other way around. Compare:\n\n\n. Nah, very simple shape, it just should be correct. There are heaps of\nvector post stamp templates, so you don't need to do it yourself, unless\nyou really want to.\n. @koresar use -n (aka --no-verify) in that case. In this case you explicitly pass through precommit check, saying \"I know what I am doing\"\n. Ideally all commits should be valid and working, so a case of non-completed job is a deviation, not a norm\n. @troutowicz That happened maybe, umm, twice. And I used -n then.\n@koresar on your local machine you can always mess with package.json (and add it to a separate Local changelist in Webstorm to not commit it accidentally) in this case to disable pre-commit hook.\nI personally believe that committing broken code should be a rare exception.\nThough possible solution could be to utilize pre-push rather then pre-commit.\n. @koresar we are using pre-commit checks in our ~15 people team.\n. 1. Yes. Does linting and stops a dev from committing if linting fails.\n2. Yes. Runs tests before the commit and stops a dev from committing.\n3. No deps checks since we freeze dependencies via npm-shrinkwrap and rarely update them.\n``` sh\n!/bin/bash\nPATH=\"/usr/local/bin:$PATH\"\nValidate code, use --silent to avoid NPM errors shown.\nnpm run validate --silent\nRESULT=$?\n[ $RESULT -ne 0 ] && exit 1\nexit 0\n```\njson\n\"validate\": \"npm run lint && npm run test:validate\",\n\"lint\": \"eslint *.js app/assets/javascripts/psa app/assets/javascripts/utils ./app/assets/javascripts/react\",\n\"test:validate\": \"node ./node_modules/karma/bin/karma start ./karma.conf.js --single-run --reporters progress > /dev/null\",\n. We have one project we are working on, so one repo.\n. https://github.com/cdnjs/cdnjs/pull/4778 this one is correct. Until you publish npm, tool cannot pick correct package.json. I made changes manually, so the submission is valid.\n. Took ages to apply those changes in such a massive cdnjs repo.\n. Little fix: npm install -g cloverfield cf-package && cf build package. Unless you want Cloverfield to automatically fetch missing packages.\nRest seems good for me\n. Exactly. Should work like that.\n. Maybe it takes some time for cdnjs to crawl and update packages?\n. ",
    "PhiLhoSoft": "@NinjaGrisen commented on 12 juin 2015 22:05 UTC+2:\n\n\n\nI always disliked this kind of design (which is classical, I reckon) because I tend to read \"Open StampIT Source\", ie. I just read from top to bottom. Confusing.\nThat said, the design is nice, like most propositions here.\n. Variation on the rubber stamp theme, stamping over the JS logo.\n\n. A variant, enforcing the idea of stamp (postal & rubber).\n\n. @koresar commented on 16 juin 2015 15:01 UTC+2:\n\n@PhiLhoSoft that's clever!\n\nThanks. I chose simplicity (no \"noise\" effect) so it can scale better, and can even be readable in B&W.\nThe design is made with Inkscape, so you can scale it as you want.\nJS logo: The MIT License (MIT)\nCopyright (c) 2011 Christopher Williams chris@iterativedesigns.com, Manuel Strehl boldewyn@gmail.com\n. Of course! What is the best way to do this, here?\n. Better / simpler: I realised I have lot of SVG files without version control (made a looong time ago...), so I grouped them, and created a Git repository for them.\nSo now you can find this logo there: https://github.com/PhiLhoSoft/SVG/blob/master/Inkscape/Stampit-logo.svg\n. Good question. The simplest way to answer is to try... Answer is, alas, no.\n. ",
    "julienetie": "Most of these logos are decent, there's a time and place for detailed logo design, too much details & textures can be a little overkill for this scenario IMHO. But also oversimplification can be way too boring for such a simple word.\nFrom a professional POV I would go with unstoppablecarl's 2nd design (in color). 2nd to that MarkAurel's does a nice job. \nIronically they both have \"class\" ;)\n. I would love to design a logo for Stampit but, from a realistic POV there's no point as I know after going though lots of crazy ideas I would probably have ended up with something similar to:\n\nIt's on the same wavelength as:\n\nPersonally I think unstoppablecarl's logo is excellent, but if you're not feeling it, it could be better to let people build off unstoppablecarl's format & font style and maybe just experiment with the {it} symbol. \n(Just a thought)\n. ",
    "juanmnl": "Hey there! a little late, but here is a first draft of an idea i had. I think a simplified version will be better, but i had to take it out of my head.\nLet me know what you think.\n\n\nCheers from Ecuador!!\n. Don't know why i forgot to upload the dark and light versions. Sorry :tongue: \n\n\n\n. As the other one was very complex, i decided to make a simple draft about a stamp with classy montserrat typography.\nWhile the previous one is about what stampit does, this is solely based on the name.\nFlat\n\nWith Photo filter so it gives a nice paper texture and color.\n\nCheers.\n. @nkbt I know, i tried to make some random edges, but the asymmetry wasn't good. I tried straight. Wasn't good. It's late and got a bit tired, so i didn't put the best effort on the edges. If you are talking about the broken/teared paper shape at the edges, that will require lots (hundreds, even thousands) of vector points to achieve. If it's about the inversion of the circles, inward instead of outward, that's quickly achievable (and a nice observation).\nThis is a first draft so everything can be refined or changed. \nCheers and thanks for the remark :smile: \n. ",
    "wheresrhys": "About 35:50 in to this https://vimeo.com/69255635 it's the issue raised by the audience member - I think he does a better job of outlining the problem than any typing by me would. I just happened to be reading the blog you linked to just before watching the video so it jumped out as a very appropriate way to address his concern (not that I know for sure it'd work)\n. ",
    "ootoovak": "Copied from the Gitter chat by request:\n\n@ericelliott I have been reading your book which is great for many reasons. When it comes to Stampit though and learning new material a lot of hand holding really helps (as well I think with adoption). The book at the moment has the Stampit v1 API. And the blog posts are what got me interested in prototypical OO in the first place but they are at too high a level to hook them into day-to-day usage of Stampit.\nI think there almost needs to be the hook, like:\n- This is why prototypical OO is great [link to video or blog post for more info].\n- This is why Stampit is great.\n- Here is a quick easy example of a common Stampit use case.\n- Click here to see more (one concept and use case step at a time) examples [best practices link].\n- Here are some of the really cool advanced things you can do with Stampit [advanced examples link].\n- If you want to read/watch more about why prototypical OO is so cool check out these links [link to blogs/book/videos]\n. > Classical OO is so pervasive I think there will be a lot more work involved in education that most open source libs. As I said I think the hooks (blog posts, video) are already in place. Now having an easy way to get people (especially pre-existing classical OO programmers) using Stampit in their pet project could really help boot it's usage (which will be great for a shift to prototypical OO).\n. In the ReadMe Stampit uses both uninvoked stampit. and invoked with no parameters stampit().. Would be good to either have consistency and maybe a small note about it being optional (if it is) or having some place to explain the difference between the two.\n. \n",
    "netaisllc": "+1 for 'better to always use stampit()\"\nBTW, this is a great project and deserves much wider notice, much like EE's more conceptual views on OOP. \nWhat you guys are tussling with is the age-old challenge of docs written by the Authors. Don't fret. The key is to gain/forge/force consensus on the purpose of a doc or page. (Think DOT.)  After that, content and style micro decisions become much easier. \nAnd always true is: if the reader gets interested, then will gladly click deeper and deeper in the content.  (Google Adwords pretty much proved this.)  What I mean is: ignore the lazy devs who want it all on the same page and modularize your content like you would an app. Because it is.\n. Ok, here's a couple of really basic ones:\n1. Duh, I'm new, conceptually what is the difference between refs and props?\n2. Gee, using Backbone, I am used to an explicit Events module. Where do I register events on  y stamps?\n. ",
    "yasinuslu": "Hi, there is an api to mark your npm dependencies but than the package wouldn't provide stampit on browser. I'm trying to implement a basic package for it, i'll write here when i complete it. Then we can discuss if it's a good way or not, how to automate it :) momentjs provides official package and here is their implementation https://github.com/moment/moment/tree/develop/meteor\n. I used browserify package to make it available on client. On server the package simply exports stampit to global from npm.\n. @ericelliott I believe it's more reliable for people to see stampitorg:stampit :)\n. Wrapper packages for both bootstrap and moment (only official packages i recall) resides in the original repo so i thought it was logical.\nhttps://github.com/twbs/bootstrap/blob/master/package.js\nhttps://github.com/moment/moment/tree/master/meteor\nPackage doesn't use any files from this repository so there is no problem separating it if you want to do it that way.\n. ",
    "msageryd": "I have a newbie question for the faq. I'm really interested in the answer =)\nJust found Stampit. I seems really useful. I'm trying to recover from an OO background. Please tell me if I'm in the right direction here. I'm building the model for an API.. Some thoughts:\n- Should I store the actual object properties in a sub property or in the root of my stamped object?\n- Does it make sense to separate the db layer and use static functions as kind of constructors?\n- Can I trust \"this\"? Will it always reference the stamped object? \n``` js\nDbLayer = stampit().static({\n  findOne: function(id, callback) {query db... return this(result)}  //stamp a new object from the query result\n}\nUser = stampit().methods({\n  checkPassword: function(password) {return password === this.password}\n}\nDbUser = stampit().compose(DbLayer, User)\nDbUser.findOne(123, function(user) {\n  if user.checkPassword('abc')\n  ...\n})\n```\n. Thank you both.\nIt's great to see real life examples. I see a golden shimmer over the composition concept vs inheritance. I feel free, not locked in by a class model. This is going to be awesome! I had a hunch that the prototype model had more to give, but I really needed Stamps to get going.\nUsing a static function to load a stamp with presets at composition time is a great solution. Fits my needs perfectly. This was a missing piece in my setup.\nQ1: Why are you using fixed.refs to reference Mongoose? Could it as well be stored in props or refs?\nI know Eric is a promise kind of guy. It seems like Vasyl is as well.. One day I'm going to try some promising. I've used Async everywhere until now.\nBtw, I'm using Postgres for this project (converting to PG from a Mongoose spike). 99% of the access will be through an Express API from apps. Only some admin functions will be on a web site for now.\n. Yes, the comment about this is the stamp in static functions was a good point, thanks. But why \"fixed\"? Why not just this.db or this.refs.db?\n. From the example in the doc:\nStamp.fixed.methods.data = 1;\nUnfortunately, this makes it more unclear to me what to use. I get the fixed part now. But why does the example use methods to store state-like information. I thought methods should be used for methods.\n. Wouldn't the instance look exactly the same if I used \"fixed.refs.data = 1\" instead?\n. @Vasyl, I'm using your concept with a static use() function to load my DbLayer with presets. I'm storing the presets in this.fixed.refs.dbPref. How can I reach those values from another static function?\nI would like my DbLayer to have a static remove() function. I don't want want to make user instance just to be able to remove a user from the database. dbPref is populated in the instances as it should, but I need to reach it from the stamp as well.\n. Thanks!\nYour correctly implemented method made it work better for me.\nNow I can have another static function which has access to this.fixed.refs. If I'd used mongoose it could look like this (simplified):\nconst DbClient = stampit().static({\n  use(collectionName, mongooseSchema) {\n    return this.refs({ db: mongoose.model(collectionName, mongooseSchema) });\n  },\n  remove(id) {\n    this.fixed.refs.db.remove(id)\n  }\n});\nWould this be an ok way to reach db from within another static function?\n. But of course..\nI suspected that I'd make a fool out of myself =)\nThank you!\n. Here is DbLayer.use:\n```\nconst DbLayer = stampit().\n  static({\n    use(dbSchema) {\n      //dbSchema = {tableName: 'xyz', idField: 'id'}  //idField can be a string or array\n  if(!Array.isArray(dbSchema.idFields)) {\n    dbSchema.idFields = [dbSchema.idFields];\n  }\n\n  if(!dbSchema.selectFields) {\n    dbSchema.selectFields = ['*']\n  }\n\n  if(Array.isArray(dbSchema.selectFields)) {\n    dbSchema.selectFields = dbSchema.selectFields.join(', ');\n  }\n\n  return this.props({dbSchema: dbSchema});  \n}\n\n}).\n```\n. I changed to refs.. same problem.\nHere is loadFromDb\n```\nloadFromDb: function(options) {\n  var instance = this;\n  var db = pgp(instance.db);\n  var whereClause = instance.generateWhereClause(options);\nlet sql = \n  SELECT ${instance.dbSchema.selectFields}\n    FROM ${instance.dbSchema.tableName}\n    ${whereClause};\nreturn db.one(sql).then(function(data) {\n   return Promise.resolve(instance.setData(data));\n  }).catch(function(err) {\n    console.log('loadFromDb, err')\n    console.log(err)\n   return Promise.reject(err);\n  });\n},\n```\n. No, I did a search to be sure. LoadFromDb is called from a couple of places, but only defined once.\nAbout the promise.. I wanted to be sure to return a promise even after an error. I did the same thing at resolve to be sure. I do need it at error, don't I?\n. I \"ported\" the stamps to a hierarchical ES6 class structure where App extends DbLayer. A factory function makes the class work as a drop in replacement for the stamp. Everything works as it should when I use the \"class\" instead of the stamp. I don't quite understand the inner workings of stamps, which increase the risk of me using them wrongly. Maybe they are too complicated for me..\n. This is NOT taken as an offence!  I take it as a great source of knowledge. I really appreciate you writing this up for me. Thank you for your time!\nI fight day and night to learn proper Java Script (Last couple of years has been all SQL for me and before that, Delphi). My biggest problem with Java Script is that there are so many ways to do one thing and every blogg/book says to do it differently. \nAbout the OMG :)\nI wasn't actually resorting to hierarchical, but did it as a test to make sure I hadn't made a mistake elsewhere.\nAt the first glance I don't quite follow you on 1-3. I'll make a cup of coffee and look closer. Also, I'd love to use arrow functions, but I'll wait until I can install node v4 with nvm. Don't want to fiddle with a global node install on my dev machines. iojs 3.3 for now..\n. Supermystierium solved. Unfortunately I don't know how.\nI develop locally, but have all changes sent directly via SSH to a development server (with Sublime SFTP). I decided to wipe the server and reinstall. Made a copy of the old version at the server and sent all files to a new directory. Npm install to get the modules... And then everything worked :-/\nI diffed the old and new directory and found no differences in my source code.\nI diffed npm ls to find differences in module versions. The biggest differences where that Mongoose was still installed on the server, and some small version differences. Also Supermixer is installed separately in the new version, but it's the same version as used by Stampit. I can still reproduce the error in the old directory. I'd rather not leave this without understanding what happened. Do you have any ideas of how to understand the differences?\n```\n105,127c105\n< \u251c\u2500\u252c mongoose@3.9.7\n< \u2502 \u251c\u2500\u2500 async@0.9.0\n< \u2502 \u251c\u2500\u2500 hooks@0.3.2\n< \u2502 \u251c\u2500\u2500 kareem@0.0.4\n< \u2502 \u251c\u2500\u252c mongodb@1.4.12\n< \u2502 \u2502 \u251c\u2500\u252c bson@0.2.22\n< \u2502 \u2502 \u2502 \u2514\u2500\u2500 nan@1.8.4\n< \u2502 \u2502 \u251c\u2500\u2500 kerberos@0.0.4\n< \u2502 \u2502 \u2514\u2500\u252c readable-stream@2.0.2\n< \u2502 \u2502   \u251c\u2500\u2500 core-util-is@1.0.1\n< \u2502 \u2502   \u251c\u2500\u2500 inherits@2.0.1\n< \u2502 \u2502   \u251c\u2500\u2500 isarray@0.0.1\n< \u2502 \u2502   \u251c\u2500\u2500 process-nextick-args@1.0.3\n< \u2502 \u2502   \u251c\u2500\u2500 string_decoder@0.10.31\n< \u2502 \u2502   \u2514\u2500\u2500 util-deprecate@1.0.1\n< \u2502 \u251c\u2500\u2500 mpath@0.1.1\n< \u2502 \u251c\u2500\u2500 mpromise@0.5.4\n< \u2502 \u251c\u2500\u252c mquery@1.0.0\n< \u2502 \u2502 \u2514\u2500\u2500 debug@0.7.4\n< \u2502 \u251c\u2500\u2500 ms@0.1.0\n< \u2502 \u251c\u2500\u2500 muri@0.3.1\n< \u2502 \u251c\u2500\u2500 regexp-clone@0.0.1\n< \u2502 \u2514\u2500\u2500 sliced@0.0.5\n\n\n\u251c\u2500\u2500 UNMET DEPENDENCY mongoose@^3.8.23\n172c150\n< \u2502 \u251c\u2500\u252c request@2.62.0\n\n\n\n\u2502 \u251c\u2500\u252c request@2.61.0\n209c187\n< \u2502 \u2502 \u2502 \u251c\u2500\u2500 hoek@2.16.2\n\n\n\n\u2502 \u2502 \u2502 \u251c\u2500\u2500 hoek@2.15.0\n221c199\n< \u2502 \u2502 \u251c\u2500\u2500 qs@5.1.0\n\n\n\n\u2502 \u2502 \u251c\u2500\u2500 qs@4.0.0\n232c210,211\n< \u251c\u2500\u2500 stampit@2.1.1\n\n\n\n\u251c\u2500\u252c stampit@2.1.1\n\u2502 \u2514\u2500\u2500 supermixer@1.0.2\n234c213\n< \u251c\u2500\u2500 validator@4.0.6\n\n\n\n\u251c\u2500\u2500 validator@4.0.5\n```\n. Yes, you are probably right. It was a long time ago, but I don't recall wiping node_modules when I switched iojs version. Big lesson learned.. Thanks!\n\nAt last I can get back to some productive work.. \nBtw, why would I need Babel when I can use most of ES6 in v4?\n. Hmm. I wiped node_modules in my faulty project and did npm install. Problem is still there. Is there anything else to wipe, but node_modules?\n. I found it.. But I'm too ashamed to tell you what it was :)\n. There was actually a diff between the directories that I missed (yes, it was reported by the diff command).\nI had a really old version of my app stamp file laying around at the server without the .js extension. I usually don't include .js when I require files, so the old file was picked up by require.\nLesson #2 learned: If a file is renamed in Sublime the new file is sent of to the server via SFTP, but the old file still remains at the server. \n. ",
    "tcrosen": "Hey guys, I'm trying to use Stamps to build my Angular views and having trouble figuring out how to structure my objects.  I'll list out as much detail as I can, hopefully you can provide some direction if you have the time.  If not, no worries.  \nHere's a very simple example of what I'm trying to convert to stamps:\n`` js\n// If you don't know Angular -$scope` is just the view model that exposes things to the DOM.\n$scope.customer = {\n  // These capitalized properties are what the server cares about.\n  // They are 2-way bound to the UI.\n  // Eg. \n  FirstName: null,\n  LastName: null,\n  State: null,\n// A list of States needs to be available for a dropdown in the UI.\n  // The user selects from this list to fill in the State property above.\n  // I don't want this property to be sent to the server. \n  stateOptions: ['AL', 'NY', 'OH', ...],\n// Customer information is edited in a modal dialog. \n  // This is bound to the DOM to indicate where or not the modal is shown\n  // Eg. ...\n  modalShown: false,\nshowModal: function() {  \n    // TODO: Need to store the current \"state\" of the property values in case the user cancels and we need to revert\n    // Something like: this._original = { ... }\n    this.modalShown = true;\n  },\nmodalSaved: function() {\n    // TODO: Send data to the server.\n    // Payload should be only this:\n    // {\n    //   FirstName: 'Bob',\n    //   LastName: null,\n    //   State: 'AL'\n    // }\n// customerApi.save(/* what goes here? */)\n\n},\n  modalCancelled: function() {\n    // TODO: Revert any changes made \n  }\n};\n```\nI'm trying to achieve the following:\n1. Expose primitive properties for 2-way binding in the DOM\n2. Attach methods for meta-data (eg. list of states) and some actions (eg. show/hide editing form modal)\n3. Retrieve only the primitive properties when it's time to send to the server\nPossible stamps (not sure if I'm structuring these correctly):\n``` js\n// There are other modals in the same page, so I want to be able to compose customizable modal methods.\nvar Modal = stampit()\n  .init(function() {\n    this.shown = false;\n  })\n  .methods({\n    show: function() {\n      this.shown = true;\n    },\n    ok: function() {  ...  },\n    cancel: function() {  ...   }\n  });\nvar Customer = stampit()\n  .props({\n    FirstName: null,\n    LastName: null,\n    State: null\n  });\nvar CustomerView = stampit()\n  .methods({\n    sendToApi: function() { \n      // This is the part I'm really hoping for an elegant solution to   \n    },\n    showEditModal: function() {\n      // @ericelliott has mentioned his namespaces his Stamps, how is that done?\n      // can I do something like this to avoid generic \"show\" properties on every object?\n      // this.modal.show();\n     }\n   })\n  .compose(Modal, Customer);\n$scope.customer = CustomerView({ stateOptions: ['AL', 'NY', 'OH', ...] });\n// As I mentioned earlier, there are other objects on the same page I need to handle in very similar ways.  For example:\n$scope.order = OrderView({ ... });\n```\nHopefully that isn't too much of a mess and you can understand what I'm asking.\nCheers.\n. Wow thanks guys, I guess it was a simple typo.  I think I grok the whole concept. @koresar when I was writing \"constructor\" it crossed my mind I'd get yelled at :)  I loosely used it to describe an object \"creator\" or \"initializer\" method.\nThanks @BerkeleyTrue for clarifying my question.\n. PS. I fucking love this library :+1: \n. > I'll throw in another  for the user community. You guys rock.\nI discovered this from reading your articles, @ericelliott.  I tried implementing raw POO in a real application and quickly found it difficult to manage the subtleties -  instantiation, privatization, etc. and boilerplate code started to pile up.  This library solved most of my problems, to me it's become a necessity to use stamps seriously.\nI'm planning on going full steam ahead with it and will be tackling real-world business problems.  I'll keep you guys posted with progress, contribute fixes and hopefully new documentation (eg. recipes/examples) I might discover.  \nThanks again.\n. > This is the first time I've noticed seeing prototypal OO written as POO\nDude I've been totally referring to it as POOP(rogramming) since I read about it in your articles.\n. Thanks for the prompt reply.  Are there any recommendations for using () vs. .create()?  Personally I like the simplicity of Api() but it seems too easily misinterpreted as a class.  Using Api.create() makes it pretty clear you are dealing with a factory.\nJust as an aside, after re-reading the DbConnection() example I should probably have done this instead:\njs\nimport Api from 'api'\nexport default const usersApi = Api({ ... });\nsince usersApi would be the final static object, it should probably not be a new Stamp (I may be misunderstanding this).\n. > Classes get instantiated with the reserved word new\nTotally fair point.  I guess I always have this in my mind as something people currently do to avoid/protect against omitting new for standard function-based classes.\njs\nfunction Foo() {\n   if (!(this instanceof Foo)) return new Foo();\n   // ...\n}\n. > You shouldn't account for other people's shortcuts. Stick with the language's specifications. :)\nTouch\u00e9\n. The problem is PhantomJS is missing Function.bind.\nInclude the polyfill and it will work.\n. ",
    "jordidiaz": "Hi @tcrosen! I'm very interested in your 'Angular Views with Stamps' aproach. I'm going to try it for sure. Thanks for the idea!\n. ",
    "nathanmarks": "@koresar @ericelliott \nWhen researching stamps vs other JS object design techniques (constructor, etc), there is a lot of negativity directed towards stamps and anything anti-language-construct-that-masks-prototype-behaviour in general.\nAn example of a frequently seen argument is that V8 is now being optimized for the use of class (along with contrived jsperf setups benchmarking Stampit() or Xyz = Object.create(); Xyz.init() vs new Xyz(). Is the scare based on conjecture? Are there actually real world implications with the direction V8 is going or just arguments over micro-optimizations?\nI don't have the time to setup and instrument an example that would simulate any real world implications but reading the back and forth is tiring. I much prefer using stamps as it lets me take advantage of certain design patterns and features that js is capable of more easily than pseudo-class syntax without having to write a lot of my own boilerplate. But I want to understand the performance arguments better so that I can make an educated decision.\nOn that note, are there any important best practices to follow when using stamps for optimal performance in V8? I don't know quite enough about the engine (working on it!!) which is why I am unable to draw a proper conclusion myself on the matter.\nedit edited my explanation slightly to improve the description of what I'm looking to find out\n. @ericelliott Those were my thoughts exactly -- it's hard to know what to believe with so much contradictory material. \nIn all my performance debugging I've never identified object instantiation as a bottleneck in my applications. It's just confusing when there are so many people insisting that new vs Object.create is an argument worth having due to performance.\nPersonally, until finding Stampit I've stuck to a lot of Object.create + Object.assign.\nI'm not worried about property access times, it's honestly just the fear mongering that got me worried. I've spent the last 7 days doing a lot of reading and setting up some of my own basic tests -- my takeaway is that it was all a bit of a waste of time as I've never run into performance issues related to object instantiation :)\n. ",
    "davewallace": "@koresar @ericelliott \nHey fellas.\nI am currently experimenting with stamps to construct types of character objects for a hobby RPG rebuild, I have what is probably a simple use case: I want to be able to create a Character that is composed of a Race (eg Elf, with props), a Type (eg Mage, with props) and a Type specialisation (eg Ice-Mage, with props). I'd like to be able to switch out that type spec or type, or even Race, with another. They should all be discrete. I looked at stamps because they've made encapsulating each set of associated props reusable.\nSo yeah, I can very easily compose all sorts of objects which is awesome, but how do I decompose so that an Elven Ice Mage can become an Elven Fire Mage, or Human Barbarian Fighter at the click of a few buttons?\nI am sure there's lots of things that could pollute the example above and I'm sure this isn't the code heavy example you're probably used to - I'm no JS master but I see the value in what's going on here. So to keep things generic so I can understand, how could this be achieved using stamps?\nFinally, am I even approaching this correctly? \n. You guys are awesome, thank you :)\n@koresar I hadn't read that article, but I'd read yours as part of the Fun with Stamps on medium.com: https://medium.com/@koresar/fun-with-stamps-episode-8-tracking-and-overriding-composition-573aa85ba622#.m3tvahswy\nI am going to try out your approach above this weekend hopefully.\nAlso, I was actually thinking of making this game ultra flexible since I'm rebuilding it, I always liked the idea of being able to pick and choose game mechanics from a UI to construct my own flavour of a game, for example switching from turn-based to real-time at the flick of a switch. I figure using stamps and having very flexible mechanics will hopefully allow this.\nWhen I've finished choosing the technologies to rebuild, as  am learning in the process, I will publicise the repo and post a link here, you're all free to pick it apart and smack me for getting stamps wrong until I get them right \ud83c\udfb1 :)\n. Hi folks, sorry didn't get a chance to reply a bit quicker.\n@koresar My gist omitted the actual command I ran, I was running npm install and then tried yarn, not actually npm test. The test was something I presume was part of the install process. I'd love to pitch in and help, I'm probably not quite at your level though - I just felt the whole idea of stamps was a really good one, in particular infected stamps, and wanted to give them a test run.\n@FredyC Unfortunately installing eslint globally has been the only way I've been able to successfully get it working for a couple of prototyping efforts with React, and now Stampit. I know it's not ideal. I hear it's possible to refer to the binaries directly inside node_modules, post install, and although outside the scope of this issue maybe - I'd appreciate any solid leads for local installation of eslint when using an IDE like SublimeText 3 on Windows 10.\nFWIW i've got an alternative dev environment now, Sierra, and everything worked flawlessly :P\n. Great, if you don't mind sharing, what did you have in mind for the infected stamps?\nWhen I looked at stamps first and saw the \"last wins\" approach to functional composition, my first reaction was to think of optional controlled queueing, but really that seems very brittle & likely over-complicating things.\n. I'm about to jump into Vue and stampit, wish me luck, I like both concepts independently so let's see if they play well :). ",
    "acao": "Ok so I'm new to ESNext and very very new to the stamps concept, but I can't seem to find how any of this can't be accomplished without decorators (and maybe also Reflection and Proxies which I know very little about), save for being able to instantiate a stamp without using new.  So to answer your question, I don't think I can see any downsides immediately but I'm probably overlooking something.\nhttps://github.com/wycats/javascript-decorators has some examples showing how to decorate classes not only in the way your example gives above, but with arguments, and also to decorate methods and properties by using decorators inside a class.  This repo is the spec used by Babel's 'experimental' (used widely) implementation of decorators.\nI'll grab a few examples from there for reference:\n``` js\n@isTestable(true)\nclass MyClass { }\nfunction isTestable(value) {\n   return function decorator(target) {\n      target.isTestable = value;\n   }\n}\n```\nPassing an argument - factories here we come!\n``` js\nclass C {\n  @enumerable(false)\n  method() { }\n}\nfunction enumerable(value) {\n  return function (target, key, descriptor) {\n     descriptor.enumerable = value;\n     return descriptor;\n  }\n}\n```\nSo it seems that you can use decorators as factories and also to enumerate classes. This allows you to avoid class inheritance with an incredible degree of flexibility, and leverage the power of javascript's prototypical inheritance powers very similarly to what stamps achieves.\nAlso, because decorators use Object.defineProperty in a way that precedes your defined class, you could use this to backfill and overwrite class properties in your constructor() method. For example:\n`` js\n@annotation\nclass MyClass {\n  // override the decorator-provided property at the constructor() level so your class can do things with it after instantiation\n   constructor(){\n     this.isMyClass = true;\n   }\n   // or you could even override a property at the getter level!\n   get annotated(){\n     returnwe don't need no annotation`;\n   }\n }\nfunction annotation(target) {\n   // Add properties to target\n   target.annotated = true;\n   target.isMyClass = false;\n}\n```\nLastly, the descriptor argument in a decorator function has some niceties.\njs\nlet descriptor = {\n  value: specifiedFunction,\n  enumerable: false,\n  configurable: true,\n  writable: true\n};\n(To be honest I don't totally understand this yet but the spec has some nice examples)\nAnd one last thing - because stamps are a specification, it is quite possible that a set of convenience decorators/etc could be used to create stamps!\nI wonder if someone could create a minimalist ESNext implementation of the stamp concept with all the desired bells and whistles, using as much of the es6/7/etc spec that is available to, say, Babel, as is possible.\nOnce 'desugared' it would probably look similar to this library!\nLooking forward to someone proving me wrong, because I've only scratched the surface with all of this yet! \n. ",
    "mdhooge": "Hello.\nThis is getting stranger, because your sample code doesn't work for me!\nI get the following stack dump:\nadvanced-examples/event-emitter.js:29\nuser.on('name', console.log); // Does not throw exceptions like \"user.on() has\n     ^\nTypeError: undefined is not a function\n    at Object.<anonymous> (/home/michel/dev_3rd/stampit_NoBackup/advanced-examples/event-emitter.js:27:6)\n    at Module._compile (module.js:460:26)\n    at normalLoader (/usr/lib/node_modules/babel/node_modules/babel-core/lib/babel/api/register/node.js:166:5)\n    at Object.require.extensions.(anonymous function) [as .js] (/usr/lib/node_modules/babel/node_modules/babel-core/lib/babel/api/register/node.js:179:7)\n    at Module.load (module.js:355:32)\n    at Function.Module._load (module.js:310:12)\n    at Function.Module.runMain (module.js:501:10)\n    at Object.<anonymous> (/usr/lib/node_modules/babel/bin/_babel-node:112:12)\n    at Module._compile (module.js:460:26)\n    at Object.Module._extensions..js (module.js:478:10)\n    at Module.load (module.js:355:32)\n    at Function.Module._load (module.js:310:12)\n    at Function.Module.runMain (module.js:501:10)\n    at startup (node.js:129:16)\n    at node.js:814:3\nI use node v0.12.5, I'm on Debian Unstable.\nI checked out your repo yesterday, and I npm install-ed the dependencies.\nThis isn't babel or ES6, because I also have the problem on \"real\" code that I tried to upgrade to stampit v2.\nSomething must be different\u2026 :-/\n. I copied/pasted your code (in your 3rd comment) in a file: it doesn't work for me, with the above stack dump. My sample code is similar.\nExplanation of the dump: The method .on() is undefined because EventEmittable is also undefined.\n. Thanks for your analysis, and sorry for the wasted time about the source code\u2026\nI recently switched to node 0.12 because npm kept yelling at me that I was using an outdated version. Not sure it was a smart move! :'-(\nI tried to debug the problem with node-inspector but I get a blank page.\nAnd when I try from the CLI, it seems it is the wrong .init method that is called:\n```\nbreak in issue148.js:8\n  6 \n  7 debugger;\n\n8 EventEmittable = EventEmittable.init(function() {});\n  9 console.log(EventEmittable);\n 10 \ndebug> s\nbreak in events.js:44\n 42 \n 43 EventEmitter.init = function() {\n44   this.domain = null;\n 45   if (EventEmitter.usingDomains) {\n 46     // if there is an active domain, then attach to it.\n``\n. What I don't understand is when this.init()` method gets added.\n\nThe following code works as expected (as long as you leave the 3 lines commented out). Normally I removed all ES6 code to be able to debug with node.\n```\nvar stampit = require('./dist/stampit');\nvar EventEmitter = require('events').EventEmitter;\nvar EventEmittable = stampit.convertConstructor(EventEmitter);\nvar User = stampit.refs({ name: { first: \"(unnamed)\", last: \"(unnamed)\" } });\nUser = User.init(function() { console.log('User.init()'); });\nvar EmittableUser = User.compose(EventEmittable);\n//console.log(EmittableUser);\n//EmittableUser = EmittableUser.init(function() {});\n//console.log(EmittableUser);\nvar user = EmittableUser({ name: { first: \"John\", last: \"Doe\" } });\nuser.on('name', console.log); // Does not throw exceptions like \"user.on() has no method 'on'\"\nuser.emit('name', user.name); // correctly handled by the object.\n```\n. OK, just understood the problem -- well, I guess ;-)\n. This code works:\n```\nvar stampit = require('./dist/stampit');\nvar EventEmitter = require('events').EventEmitter;\nvar EventEmittable = stampit.convertConstructor(EventEmitter)\n.enclose(function() { console.log('EventEmittable.enclose()'); });\nvar User = stampit.refs({ name: { first: \"(unnamed)\", last: \"(unnamed)\" } });\nUser = User.init(function() { console.log('User.init()'); });\nvar EmittableUser = User.compose(EventEmittable)\n.enclose(function() { console.log('EmittableUser.enclose()'); });\nvar user = EmittableUser({ name: { first: \"John\", last: \"Doe\" } });\nuser.on('name', console.log); // Does not throw exceptions like \"user.on() has no method 'on'\"\nuser.emit('name', user.name); // correctly handled by the object.\n```\nBut I still don't understand when/where the EvenEmitter.init() method is copied into the stamp.\nMaybe we could add a paramter to convertConstructor with a list of static methods to copy/exclude...\n. @koresar Thanks for the lines, it's getting clearer.\nI don't see how moving the methods into a subpackage will solve the name collision.\nIf I understand well the problem is with name collision between the converted constructor and stampit. Maybe stampit should provide 2 names for its methods: a short, convenient one  when all is in control; and a longer, unique-guaranteed one when one receives a stamp from unknown origin.\n. OK, I leave it to you to find the best solution ;-)\nI have a workaround for the time being.\nThanks\n. What will you put in your GuardStatics? Aliases?\n. Still thinking about it\u2026\nEric's solution sounds really better to me because it puts all stampit methods into a separate namespace. So there is no risks, if a stamp is handed to someone else, that he will gets confused. Because, as I see it, we can't expect one .init() method to be \"more important\" than the other (to re-use #148 issue).\n. Maybe it's already time to introduce stampit v3 ;-)\nAs I see it, it is still possible to inject the extracted methods into a stamp. So the existing code base is still valid.\n. I don't know the purpose of EventEmitter.init() method. But how can we be sure that it will still operate properly if we put stampit method instead?\nMaybe the only problem is convertConstructor\u2026\n. ",
    "bekos": "We could use the dist folder if we are using stampit through bower instead of cdnjs.\n. ",
    "harm-less": "The Bower release repo is down/no longer supported?. Not according to Bower it seems. Bower dependency line in bower.json: \n\"stampit\": \"3.0.0\"\nResult in cmd:\nC:\\CRS>bower install\nbower stampit#3.0.0         not-cached https://github.com/stampit-org/stampit-bower.git#3.0.0\nbower stampit#3.0.0            resolve https://github.com/stampit-org/stampit-bower.git#3.0.0\nUsername for 'https://github.com':\nPassword for 'https://github.com':. Sure. It seems like the \"stampit\" package is linked to the wrong repo.\nI'm not sure if I'm right, but it seems you need to unregister/re-register to the https://github.com/stampit-org/stampit repo.. Sure thing. I took your advice and used it like this:\n\"stampit\": \"git://github.com/stampit-org/stampit.git#3.1.2\"\nThis works!\nWithout the repo link it doesn't, even with a version of 3.1.2\nSo I'm pretty sure a re-registering will work. Doesn't seem a bower.json in the repo is required, but I'm not sure about that.. Yeah, I hear that more often, but I'm working often with tasks like https://github.com/stephenplusplus/grunt-wiredep.\nSo maybe I need to switch to an NPM variant, but I don't really see why Bower is such a bad thing actually.. @koresar Thanks a bunch, Bower has been revived (somewhat)!\nI'm indeed using Stampit within a browser. So Bower is a more logical choice indeed.\nHowever, when I temporarely started using 3.1.2 with NPM, I ran into a few problems this weekend (mostly the compatibility with Karma and the polyfill for Object.assign I couldn't get to work). I didn't have time to figure it all out, but it made me look at previous versions of Stampit which are less modern. Using Stampit 2.0.3 (the latest 2.* had most of the same issues I was having already) all my problems vanished. But I now realise 2.0.3 isn't in the Bower repo you brought back to live :(\nIt would of course be best if the Bower repo also natively supported the most used/stable versions of Stampit there (like Angular does), but I think that will not be handy for your guys to maintain.\nI used your advice and came up with this solution:\n\"stampit\": \"https://npmcdn.com/stampit@2.0.3/dist/stampit.js\"\nThis works and I'm getting the result I expect.\nJust an FYI, at one of my own repos I have a Grunt task (task info) that does the releasing including the necessary changes for NPM and Bower automatically. Maybe an idea for the future if you want to keep it a bit easier to maintain.\nLast question, why is 2.0.3 much bigger in size than 3.1.*? A large optimization?\n2.0.3 = 7.0KB\n2.1.0 = 1.5KB\n3.1.2 = 1.9KB\nP.s.: Congrats on the anniversary \ud83d\udc4d . The master works fine, but you can't get another version:\nC:\\CRS>bower install stampit#2.0.3\nbower stampit#2.0.3         not-cached https://github.com/stampit-org/stampit-bower.git#2.0.3\nbower stampit#2.0.3            resolve https://github.com/stampit-org/stampit-bower.git#2.0.3\nbower stampit#2.0.3       ENORESTARGET No tag found that was able to satisfy 2.0.3\nNice build script! So if you can make some versions available as tags in the Bower repo, Bower will be able to pick it up for you.\n. Awesome! Now it works like Bower (and I) expects ;)\nI'm only missing 2.0.3, but I'll use 2.0.2 instead, that's probably no problem.\nSo far my experience with Stampit has been great! In practice it luckily makes a lot of sense as it seemed like it had a steep learning curve when I was reading about it. So thanks for this awesome library, you've gained a prototypal enhousiast ;). ",
    "infiniteluke": "Hi - I'm also interested in this. Any word on when it will be available? Thanks!\n. ",
    "johnthad": "I'm glad this helps, +koresar. I'm getting a lot out of the book, and I've managed to run all the examples (in Chrome) up to this point. Maybe I'll post more, but I want to stay within the bounds of O'Reilly and Eric's copyrights.\n. ",
    "ghost": "Nevermind. The problem is that babel (by default) doesn't reach into node_modules, so your code simply wasn't getting transpiled to es5. For those who run into a similar problem:\nbabel-hook.js\nrequire('babel/register)({\n  ignore: false // stop ignoring node_modules by default\n})\nAnd then mocha -r babel-hook tests/**\n. But then I'm forced to write behaviour methods in what is supposed to be analougous to a 'constructor', if I'm correct. \n. Wow, thanks! The Symbols thing is really good for this.\n. @koresar Agreed. To a lot of people, it's still not clear. And the class keyword just adds more confusion to the mix.\n. ",
    "joshdmiller": "I'm not sure what you mean by \"doesn't work\", but if you mean that user is not a stamp instance, that's because you didn't return this (or anything, for that matter) in your setUserData method.\nIf it's not this, can you provide more info?\n. ",
    "BerkeleyTrue": ":+1: for not breaking things :shipit: \n. Avoiding the new keyword is the point of stamps.\n. Would it be easier to add support for factory functions in Aurelia?\n. That is a good point but I don't think these two worlds are compatible. It really should be one way or the other.\n. The confusion lies around this line:\njs\nthis.connection.open(this.connectionConfig);\nthis.connection is never defined and in the creation of conn connection is not passed in the refs argument.\nThere are two typos in this document.\nThe line above should be this.dbConnection.open(this.connectionConfig);\nAnd the following:\njs\nconst conn2 = DbConnection({ connection: conn.dbConnection }); // reusing existing\nShould be:\njs\nconst conn2 = DbConnection({ dbConnection: conn.dbConnection }); // reusing existing\n. That was fast. You're welcome! \n. @tcrosen I'm glad I could help.\n. You are composing A in twice, so the init function would happen twice. Is there a use case that this is causing an issue for you?\n. If it is for the purpose of Tree Shaking with Rollup/webpack 2, then it will need to be more than just point to original ES2015 code. You'll need to create a new directory were all the ES2015 code is transpiled with the exception of ES2015 modules.\n. @eshansingh \njs\nvar someObj = stampit().init(function() {\n    var privateVar = true;\n}).create();\nThis variable is private, but it is also completely isolated. Once the init function is called, it will be lost. \njs\nvar someObj = stampit().init(function() {\n    var getIt = function privateMethod() {\n        return \"Stamp{it}\";\n    }\n}).create();\nSame goes for this function. It is lost because its reference is not assigned to anything other then a scoped variable inside the init function.\nTo create a private variable accessible to a method do something similar to the following:\njs\nconst a = stampit().init(function() {\n  const priv = 'a'; \n  this.getA = () => { // method is assigned to the instance of this stamp\n    return priv; // now variable is part of the closure of this method\n  };\n});\nYou can extend this example to include private methods:\njs\nconst a = stampit().init(function() {\n  let count = 0;\n  function resetCount() {\n    count = 0;\n  }\n  this.incCount = () => {\n    count = count + 1;\n    if (count > 10) {\n      resetCount();\n    }\n    return count;\n  };\n});\nIf you're feeling fancy, you can use ES2015 Symbols to create private variables:\njs\nvar count = Symbol('count');\nvar a = stampit({\n  init: function() {\n    this[count] = 0;\n  },\n  methods: {\n    incCount: function() {\n      this[count] = this[count] + 1;\n    },\n    printCount: function() {\n      console.log(this[count]);\n    }\n  }\n});\nor ES2015 WeakMaps:\njs\nvar count = new WeakMap();\nvar a = stampit({\n  init: function() {\n    count.set(this, 0);\n  },\n  methods: {\n    incCount: function() {\n      count.set(this, count.get(this) + 1);\n    },\n    printCount: function() {\n      console.log(count.get(this));\n    }\n  }\n});\nHere is a JSBin\nShowing both of this methods in action. I wrap them in IIFE's there so that the variable holding the count symbol/map is inaccessible but you could do without if you use CJS/ES2015 modules.\nHere is a great article on private data using these new methods http://www.2ality.com/2016/01/private-data-classes.html\n. @ericelliott I'm happy to add it. Where in the docs do you want it added? Do you also want to include the WeakMap version?\n. ",
    "skaapgif": "Which is the preferred way of using the API? If using this is preferred perhaps the other examples should be changed to also use it? Since the example which uses instance doesn't have any specific requirement for using instance instead of this it might only cause confusion?\n. I've changed those examples back to using this. I've kept my change in favour of using ES6 function declaration instead of ES5 since I think it's bad style to use both in the samp code sample (the anonymous function being declared as ES5 and getA being declared with ES6).\nI haven't used stampit enough to run into every use case, but if there's no real advantage for using instance I would suggest that this becomes the official preferred way. Giving people two ways to do the same thing without any trade-offs or advantages just makes it harder to get started. If we want to show both ways of using it, it might be better to introduce that as a separate code sample so that each code sample in the readme only introduces one concept at a time. Just my 2c :+1:\n. ",
    "astanciu": "oh man, my bad... I accidentally mashed the keyboard and didn't even catch that this happened. :(\n. Amazing, so simple.. thank you.. Quick followup, if obj was instantiated from a Stamp, its methods are on proto, which means neither .props nor .methods will pick them up:\n```js\n  const Bar = stampit.methods({\n    bar() {\n      console.log('bar');\n    }\n  });\nconst obj = Bar();\nconst a = stampit.props(obj)(); // a.bar() undefined\n  const b = stampit.methods(obj)(); // b.bar() undefined\n  const c = stampit.methods(obj.proto)(); // bcbar() exists\n```\nIs this recommended if you want to enhance an existing Instance:\nconst d =  stampit.props(obj).methods(obj.__proto__).compose(Something)(). ",
    "mdix": "1 (and we won't get more, even with karmas log level set to DEBUG)\n```\n[22:28:04] Starting Karma server...\nINFO [framework.browserify]: bundle built\nINFO [karma]: Karma v0.12.37 server started at http://localhost:9876/\nINFO [launcher]: Starting browser PhantomJS\nINFO [PhantomJS 1.9.8 (Mac OS X 0.0.0)]: Connected on socket 6izvHPLccA5QZymyShp2 with id 70500136\nPhantomJS 1.9.8 (Mac OS X 0.0.0) ERROR\n  TypeError: 'undefined' is not a function (evaluating 'shortcutMethod.bind(null, addMethods)')\n  at /var/folders/jf/00gb7hd17yl853ww6sw44pqh5r01xc/T/b6ed61688795a1cd4f8fe9f953283a1b.browserify:369\n/Users/marc.dix/projects/setups/babel_karma_gulp/gulpfile.js:38\n            throw err;\n            ^\nError: karma exited with code 1\n    at done (/Users/marc.dix/projects/setups/babel_karma_gulp/node_modules/gulp-karma/index.js:56:30)\n    at ChildProcess. (/Users/marc.dix/projects/setups/babel_karma_gulp/node_modules/gulp-karma/index.js:82:7)\n    at emitTwo (events.js:87:13)\n    at ChildProcess.emit (events.js:172:7)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:200:12)\n```\n2 \nI already did that. Same error.\n3 \nSame line works when asserting in the spec where I used ES6 class. Even if it would fail, it would be a different error.\n4 \nYeah, I accidentally added everything as devDependency. Will change that. Thanks.\nBest\nMarc\n. @ericelliott Not really, running directly with karma (& log level to DEBUG):\n```\n...\nDEBUG [web-server]: serving (cached): /Users/marc.dix/projects/setups/babel_karma_gulp/node_modules/karma-jasmine/lib/adapter.js\nDEBUG [web-server]: serving (cached): /Users/marc.dix/projects/setups/babel_karma_gulp/spec/stamp/StampSpec.js\nDEBUG [phantomjs.launcher]: Hello\nPhantomJS 1.9.8 (Mac OS X 0.0.0) LOG: 'Hello'\nPhantomJS 1.9.8 (Mac OS X 0.0.0) ERROR\n  TypeError: 'undefined' is not a function (evaluating 'shortcutMethod.bind(null, addMethods)')\n  at /var/folders/jf/00gb7hd17yl853ww6sw44pqh5r01xc/T/b452d365a5cb034f23637b1beaf0a743.browserify:369\nDEBUG [karma]: Run complete, exiting.\nDEBUG [launcher]: Disconnecting all browsers\nDEBUG [framework.browserify]: cleaning up\nDEBUG [launcher]: Process PhantomJS exited with code 0\nDEBUG [temp-dir]: Cleaning temp dir /var/folders/jf/00gb7hd17yl853ww6sw44pqh5r01xc/T/karma-90092623\n...\n.\ngulp.task('default', ['build']);\n```\nmight be the reason for that. Running gulp is the same as gulp build because of the line above.\nEdit: If you want to eliminate the build system as moving part, just run karma directly: \n./node_modules/.bin/karma start karma.conf.js\n. @ericelliott Yes, I did. Mind reading this again?\n. @koresar No. The build system is only running all the stuff once to build (build.js). The whole stuff runs again when karma is executed. But both work with fresh source files, so we're not browserifying browserified code here.\n. @ericelliott Just as an attempt to save me some work: Would your question be answered with \n\nIf I run build.js, it logs out 'Hello' twice and no error is shown.\n\nIf this doesn't answer your question, I have to somehow browserify and babelify the source file on the console. Never did that, as we have nice build tools in 2015. So?\n. @koresar I'm unittesting, so I'm not interesting in how the components work together, means I'm not interested in what app.js does at all and I don't want to get problems with whatever sideffects might occur when implicitly running app.js (as it's part of build.js). We drift off a bit, don't we?\n. @koresar Well, at least I can try. Please wait a few seconds, I gotta check how to keep the temp file created by karam.\n. @koresar I'm sorry, but I'm not able to quickly find a way how to keep the browserify temp file. Other suggestions? (Still trying to figure it out) Sorry, but... what main: file are you talkin about?\n. @koresar Yea, and I'd love to provide you with the output of this. Seems there's no configuration option in browserify to keep the temp file.\nConcerning the build tools: Thanks for your opinion on this, but you know that discussions on that tend to get pretty long (and I just want to get my problem solved).\n. @ericelliott No. Works fine without stamp.\n. @koresar Thanks, unfortunately it's not working (the file is not in the mentioned directory). Are you sure that karma is creating the file?\nEdit: I guess it's somewhere in node_modules/karma-browserify/lib/bundle-file.js.\n. @koresar Ok, please stand by. Gotta give my baby some milk, hope to be back in 5 min.\n. @ericelliott @koresar Thanks for helping me to identify the direction. Now it'll be a long road to finding the root cause. \nThe funny thing is: I did not mention this, but earlier in this discussion I ran karma with build.js (and disabled all the transforms) and still had the same error. Based on this discovery I should probably check karma or phantom, as it proofs that the *ifys are working fine.\n. @ericelliott I read it. Mulitple times. I also read the comment from the mocha guy. IMO most of your points are wrong. (But please don't get me wrong, I really ~~like~~ adore you & your writings on medium - but tape is something I'll definitely not use in production).\n. I think the next step is to replace gulp-karma with karma, because the development of the gulp-karma wrapper has been stopped a long time ago. Let's see if this fixes the problem.\n. @ericelliott @koresar Just in case you're interested: Looks like it's a phantomjs (or karma-phantomjs-launcher) issue. It works fine with Chrome (using the karma-chrome-launcher). Big thanks to both of you for helping me to identify the cause.\nEdit: And I think this issue is related.\n\nAurelia written with ES6 and ES7. PhantomJS 1.x doesn't support neither ES6 nor ES7. I think you should try 2.x version.\n- Vitallium\n\nEdit2: And everything is fine when using karma-phantomjs2-launcher. Now I'm puzzled... \nEdit3: \n\n\nIMO most of your points are wrong.\n\nI'm looking forward to reading your rebuttal post. =)\n\nJust grant me some time to do it properly... ;-)\n. ",
    "lorenzofox3": "Yes, please go ahead :), show me how you would do that. \nActually I don't understand what refs are, I thought it would be references shared between all the object created by a given stamp. \n. > Premature optimisation is the root of all evil. I've removed the this.isAllSelected.\nIt is actually required: this code is for UI (using Angular) and isAllSelected is boolean which is bound to a control. I could use the method isAllSelected() method but it is easier for debug purpose and testability to have a boolean that reflect the state.\n\nI split items container, selection logic, and toggling logic.\n\ngreat, more readable\n\nI removed the customers property. Can't find any reason to keep it.\n\nThat was actually the purpose of my initial question. But you lack a bit of context:\nFirst I had a customers list, products list, etc holding \"items\" as \"customers\", \"products\" which make in more explicit than a generic \"items\" especially for binding in the views. So important to realise is that theses properties are bound to view:\nMarkup\n<h2> Customer list </h2>\n<ul>\n   <li ng-repeat=\"customer in customerList.customers>{{customer.name}}</li>\n</ul>\n<h2> Product list </h2>\n<ul>\n   <li ng-repeat=\"product in productList.products>{{product.sku}}</li>\n</ul>\nLater I want to add selectable behaviour to this list. This behaviour is actually independent and can work on generic items so it could be reused . \nBut with your solution I have introduced a coupling between customers (and products, and offers, and bank account, etc) related behaviour and the more abstract selectable behaviour.\nSo \n1. I have first to update CustomersStamp to use this.items instead of this.customers etc\n2. I have to update all the binding in the views.\nAnd again if later I decide to rename \"items\" to \"itemsList\" in the generic selectable behaviour then again I have to re do 1) and 2) ...\nSo this coupling can be very painful at the end. \n\nMost importantly, I remove the \"stubs\" you introduced for methods and properties.\n\nI don't understand, can you be more specific\n. yes you are right, thanks a lot ! \nForcing the abstraction by \nJavascript\nconst ItemsContainer = init(function () {\n  if (!Array.isArray(this.items)) throw new Error('this.items[] was not supplied');\n});\nis a smart move.\nAlthough I still feel frustrated that behaviours remain coupled due to property naming, it somehow breaks the beauty of composition.\nAnd for the side notes :\ncustomerList.customers was only for the issue readability, behaviours are actually blended to a controller ctrl.customers. \nisAllSected is a one way binding (readonly). just make it easier when in debugger the var is evaluated directly and when comparing states in assertions  \nBut thanks again for the tips I really appreciate. Nice library to work with (a pity it keeps a big size when used in the browser)\n. Nope, hence my question :) . Maybe with Object.observe when creating object from a stamp you could say\nJavascript\n   var customerSelectableList = stampit\n    .compose(customerStamp, selectableStamp)\n    .share('customers', 'items')\n    ({customers:['bob']});\nwhich would basically tells to update \"items\" whenever the \"customers\" reference changes. But yet, watchers and eventListeners can be tricky to deal with\n. you are right. \n``` Javascript\nvar selectableCustomers = stampit.compose(customers, selectable)\n  .init(function(){\n       var customers = [];\n   Object.defineProperty(this,'customers',{\n       get:function(){\n             return customers\n       },\n       set:function(values){\n            this.items = values;\n            customers = values;\n       }\n   }\n\n})\n```\nmade the job :+1: \n. looking forward !\n. yes you are right it is actually more about assignment and merge timing rather than the merge strategy.\nGiving the ability of defining property descriptors on a stamp (ie before any instance is created) could solve the problem. Maybe by defining getter/setters on the methods object although I am not sure defining properties on the prototype is a good idea. \nI'll give a try with stamp v3.0 \n. ",
    "b-barry": "Hello,\nYou can use the aurelia skeleton below :\nhttps://github.com/aurelia/skeleton-navigation\nIn Aurelia, we use also class like React and I am wondering if there is a library like stampit React for Aurelia.\n. Thank You for the quick answer.\nI am looking forward stampit v3.\n. @koresar Interesting, I will check it with the Aurelia skeleton\n. ",
    "recursivefunk": "Haha cool just wanted to make sure. Thanks :+1: \n. Very cool! Yep that's definitely a better approach than hacking at core. Thanks for the feedback! @koresar I'll close this out!\n. Ah that's very helpful! :+1: \n. ",
    "maiermic": "Only privileged methods have access to private variables or functions. A privileged method is a function that is assigned to this in init. For further information see What's the Point. I recommend to read Private Members in JavaScript by Douglas Crockford to get a better understanding.\n. ",
    "namirsab": "I think i've done it :D\nJust attach data on init. For example, generating defaults if no props are given as arguments.\njavascript\nconst hasValues = QuestionBuilder({\n    init({instance}) {\n    var getDefaults = () => (\n        {\n        values: {\n            key1: Representable({ \n            label: 'Value1', \n            shortLabel: 'v1', \n            order: 0\n          })\n        }\n      }\n    );\n    if (!instance.values) {\n        instance.values = getDefaults().values;\n    }\n  },\n  methods: {\n    getValue(valueKey) {\n        return this.values && this.values[valueKey];\n    },\n    addValue(value) {\n        var key = Math.random().toString(32).substring(2,9);\n        if (this.values) {\n        this.values[key] = value;\n        return key;\n      }\n      return false;\n    },\n    removeValue(valueKey) {\n        return delete this.values[valueKey];\n    }\n  }\n});\nIs that ok?\n. @ericelliott @koresar thanks  a lot. I was wondering if there was any \"duck typing\" check for stampits (I mean internally using duck typing checks or something like this). Anyway, thanks for your answers\nPS: I will be using your library sooner than later in my company, so i would like to know where is the best place to ask some (i hope not many) questions :smile: \n. ",
    "wladimiiir": "Hi,\nthanks for the answer, but I didn't make it clear enough. \nThe Car constructor from the Fiddle is example of Scene object from BabylonJS. So that means I cannot change the Car in a way of using stampit :(\nThat`s why I relied on convertConstructor function. The question is if convertConstructor in v3 will also be able to support Property Descriptors or maybe there is some other way?\nThanks.\n. Thank you.\n. ",
    "eddyLazar": "It seems i've been using some other emitter library, with node 'events' everything works properly. Thanks for reply.\n. ",
    "rickmed": "@koresar I'm having similar needs. Maybe adding an asyncInit descriptor to keep things explicit/lean? or providing a plugin that \"infects\"/overrides the standard sync init?\ncheers\n. @koresar thanks for the quick response!\nShouldn't stamp it make this behavior by default? binding this in all methods to the instance (I don't think there are any cases in which you would want to this refers to something else other than the instance, right?) \n. ",
    "pdavidow": "This should be documented.  Please clarify the \"abuse\".\n. ",
    "hoschi": "I can't upgrade to a RC version at the moment, if this is fixed in your eyes, you can close this issue.\n. > I know why it does not work. Because stampit v2 limits the methods to be only typeof function.\n\nI thought about something like that ;)\nWhereas stampit v3 allows anything in the methods, including generators.\nGreat! I make a local ticket for me to upgrade to v3 when it is released.\n\nThanks for your workaround, this is makes composition easier, I use that one till v3 is released and stable.\n. I use Babel, perhaps it transpiles it to something which has type object.\nEric Elliott notifications@github.com schrieb am Mi., 27. Juli 2016 21:49:\n\nBecause stampit v2 limits the methods to be only typeof function. Whereas\nstampit v3 allows anything in the methods, including generators.\nGenerators are not typeof function?\nThat's news to me:\nfunction* foo () {}typeof foo // 'function'\nThat's native code running in Node 6+.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/225#issuecomment-235699116,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJ9OPzLSvgJYVMehgnIuO_TROn_NYP6ks5qZ7YtgaJpZM4JWHXt\n.\n. ```\ntest.only('stampit generators - fails', t => {\n    let b = function* () {\n            return 'bar'\n        }\n    let s = stampit.methods({\n        a:() => 'foo',\n        b\n    }).create();\n\nt.truthy(typeof s.a === 'function')\nt.truthy(typeof b === 'function')\nt.truthy(typeof s.b === 'function')\n\nt.truthy(s.a() === 'foo');\nt.truthy(s.b().next().value === 'bar');\n\n})\n```\nb is a 'function', but s.b is not defined.\nWith ref it works:\n```\ntest('stampit generators - works', t => {\n    let s = stampit.refs({\n        a:() => 'foo',\n        b:function* () {\n            return 'bar'\n        }\n    }).create();\nt.truthy(typeof s.a === 'function')\nt.truthy(typeof s.b === 'function')\n\nt.truthy(s.a() === 'foo');\nt.truthy(s.b().next().value === 'bar');\n\n})\n```\nI noticed that all code work with node 5.4.1 but not with node 6.2.1\n. In Chrome it never works with methods.\n. Great you found it! I wait for v3.\nVasyl Boroviak notifications@github.com schrieb am Fr., 29. Juli 2016,\n05:26:\n\nReview needed: stampit-org/supermixer#7\nhttps://github.com/stampit-org/supermixer/pull/7\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/225#issuecomment-236085752,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJ9ONMiSTr-aLetTs03MHlPXHkWHesQks5qaXLKgaJpZM4JWHXt\n.\n. \n",
    "JVMartin": "Thank you - those are both very innovative, @koresar!  :+1:\nA couple of questions for you:\n- Did you mean to put myProto.accessingPrivateData = () => { on approach 2?  This approach is tripping me out... so the fist time I create an instance, it will add that method to its prototype... won't then all future objects be referring to the first object's userID (and all return 1)?  I'm going to try this and report back.\n- Will WeakMap return the same value for a given object even after you change that object's properties?  I would guess it just uses the reference/pointer and not the value of the object... (I suppose I can do a quick test to find out!)\n- Could I perhaps coerce you into giving an example with ES6 Symbols?  :)\n. I'm afraid approach 1 doesn't work because when the garbage collector collects an object, it will leave all of its private data behind...\n. And unfortunately approach 2 fails since all new users will just point at the original user's private data:\n``` javascript\nimport User from './User';\nconst user_a = User();\nconst user_b = User();\nconsole.log(user_a.getUserID()); // 1\nconsole.log(user_b.getUserID()); // 1\n```\n. If anyone else stumbles across this issue:\n@koresar pointed out in chat that WeakMap actually doesn't cause any memory leaking because it will let go of the private data when there are no other references to the given object.  I'm going to go with that approach for now!\n. ",
    "eladchen": "@FredyC @koresar My pleasure.\n. ",
    "dpatte": "Grammatically, it should be 'all ... create', not 'all ... creates'\nOn 2016-09-20 10:38, Daniel K. wrote:\n\n@FredyC requested changes on this pull request.\n\nIn docs/API.md \nhttps://github.com/stampit-org/stampit/pull/233#pullrequestreview-760301:\n\n## Chaining methods\n\n-Chaining stamps always creates new stamps.\n+All the methods always create new stamps.\n\"All these methods /always/ creates new stamps.\" ... not sure why \nyou've removed \"s\", but that was correct actually ;)\n\nIn docs/API.md \nhttps://github.com/stampit-org/stampit/pull/233#pullrequestreview-760301:\n\njs\n-const MyStamp = stampit()\n-.methods({\n+const MyStamp = stampit() // new stamp\n+.methods({ // new stamp\n\nI would say \"creates new stamp\" at least, otherwise it might look \nconfusing for people looking at examples first.\n\nIn docs/API.md \nhttps://github.com/stampit-org/stampit/pull/233#pullrequestreview-760301:\n\n@@ -526,14 +547,16 @@ const obj = stampit()\n    bar: 'bar'\n  })\n  .compose(concreteStamp, additionalStamp, utilityStamp)\n-.create();\n+.create(42, 511, 3.14);\n\nUhh, how these number are helping to explain anything? Since there is \nno reference to these in the example, it's just bogus and useless here ;)\n\nIn docs/API.md \nhttps://github.com/stampit-org/stampit/pull/233#pullrequestreview-760301:\n\n\nimport {statics} from 'stampit'\nconst {statics} = require('stampit')\n    -* New utility function isComposalbe. Can be imported in any of the above ways.\n    -* New methods on stamps, as well as new shortcut methods on stampit, as well as new options to stampit(): initializers, properties, deepProps, deepProperties, deepStatics, conf, configuration, deepConf, deepConfiguration, propertyDescriptors, staticPropertyDescriptors\n    +* New utility function isComposalbe. Can be imported separately: require('stampit/isComposable').\n\n\nTypo: isComposable ;)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub \nhttps://github.com/stampit-org/stampit/pull/233#pullrequestreview-760301, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/AKTA1_doprtRtGqGixWsNYK4aGUAqvToks5qr-_agaJpZM4KBlat.\n\n\n. Everybody has a few :)\nA few issues remain, that I can help with on a later release. Please \ncontact me at that time.\nOn 2016-09-21 08:16, Daniel K. wrote:\n\n@koresar https://github.com/koresar Thanks, I still have a trouble \nwith articles obviously :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub \nhttps://github.com/stampit-org/stampit/pull/234#issuecomment-248593839, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/AKTA13Em5JIaRaFdHB2492-7Awia7Wgqks5qsSAMgaJpZM4KCr5U.\n\n\n. ",
    "abhisekp": " :sparkles:  :smile_cat:  :+1: LGTM :smiley: :+1:   :sparkles:  \n. # TODO\nExplain the algorithm in comments\n. refs are deprecated too\n. huh?\n2 stamp.props()\nand only 1 stamp.properties()? :expressionless: \n. diff\n- Previously in the `stamp.fixed`.\n+ Previously it was stored in `stamp.fixed` object.\n. Move the heading to the top before ToC\n. ...and also that the statement is two lines.\n. Isn't that statement applicable for apps and not libraries? :smirk: \n. fns seems like a nice self documented identifier which would hold an array of functions :wink: \n. ",
    "Sigfried": "Can you tell me where this stands? I just ran across stampit a couple hours ago. It looks like it solves some problems I'm having very nicely. Unfortunately I have a tight deadline and need to mush together a number of classes. Do I have to rewrite them all as stamps?. Thanks for the quick replies!\nI'm seeing there's not much work to manually converting my classes to stamps (though I'd rather not since some old code will still use the class versions), so I'm able to move ahead, and stampit is saving me from making a much bigger mess than I would have otherwise.\nAnother dumb question: there's no way to write stampit methods as arrow functions, right? My ES6 classes use arrow functions for methods (which nicely binds them to their instances), so the main work in converting them to stamps is changing arrow functions to the regular kind.  ...So now I'm wondering, are stamp methods bound to instances? (I.e., detached=instance.foo; detached() only works with this===instance for arrow methods.). Sorry for the delay. Yeah, I was doing stuff like:\ncids = () => this.prop('cids')\nconcepts = (cids=this.cids()) => concepts(this.conceptState.loaded).filter(c=>_.includes(cids,c.concept_id))\nconcept_ids = (cids) => this.concepts(cids).map(d=>d.concept_id)\ncidCnt = () => this.cids().length\nconCnt = () => this.concepts().length\n\nI like the arrow methods, but it's not a big deal. I've already converted everything.. Sorry, I wasn't clear. All that stuff I quoted was in the context of a class definition:\nexport class ConceptSet {\n  constructor() {\n    ...\n  }\n  cids = () => this.prop('cids')\n  concepts = (cids=this.cids()) => concepts(this.conceptState.loaded).filter(c=>_.includes(cids,c.concept_id))\n  concept_ids = (cids) => this.concepts(cids).map(d=>d.concept_id)\n  cidCnt = () => this.cids().length\n  conCnt = () => this.concepts().length\n  ...\n}\n\nI'm not going to defend transpilers, but I like this experimental feature: https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&targets=&browsers=&builtIns=false&debug=false&code_lz=MYGwhgzhAEAKD2EAuBJAdgM3tApgDyRzQBMYAlHMYJAOgGF4BbAB3jSKWgG8AoASAAWYEiBwB5ZkgCWbCACEArkiRs6IKcADW0ALzQAFDgCUugHzce0K9CQCpEGhBxIAykjCF9XCAPgB3CWlZAFl4YjAQAC4bACcFHABfIwBuS2gEngSgA&experimental=true&loose=false&spec=false\nThe this is not misleading. It does refer to the instance. And, the great thing (besides saving me a few keystrokes) is, whereas in your version,\ncids() { return this.prop('cids') }\nlet foo = instance.cids\nfoo()\n\nwill fail unless you attach foo to an object, like:\nlet foo = instance.cids.bind(instance)\n\nBut\ncids = () => this.prop('cids')\nlet foo = instance.cids\nfoo()\n\nworks as one would hope, with this referring to instance. . But it's defined inside the class definition, so can that make the lexical scope be the instance?. I don't have time to mess with it right now, but I was thinking I could do\nthe same with stamps by using props instead of methods.... Can't recall if\nI had an idea of where 'this' would come from.....\nsending from phone. please pardon terseness, typos, incoherence, etc.\nOn Jun 18, 2017 5:52 AM, \"Vasyl Boroviak\" notifications@github.com wrote:\n@FredyC https://github.com/fredyc you are right. But Sigfried do not need\nmethod binding and private props.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/stampit-org/stampit/issues/257#issuecomment-309267428,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABg2850Y8h4g2HB2OHGOCkzu5F5Atrz0ks5sFPNWgaJpZM4KTjy9\n.\n. Totally extra cool!!!\nI was just being dumb wondering out how to shoehorn those into methods or properties.\nI may not need to use methods or properties at all, right? The important work (at least for me) that stampit is doing is composing without inheritance insanity.\nSo, if I put everything in init like your example, it'll all get merged correctly, right? (Assuming I don't put crazy nested stuff in there...)\nThanks!. ",
    "gajewsk2": "So I have to figure out how to do a conversion of an old model to stampit. This seems... bad, but does do the behavior I would want w/ ES6 classes stop-gap-until-converted + stampit: \n```\nimport stampit from 'stampit';\nimport PubSubModel from './pub-sub.model';\n// The conversion\nconst oldskool = stampit().init(function() {\n  Object.setPrototypeOf(this.proto, new PubSubModel());\n});\n// Now you can compose with it just like any other stampit factory...\nwindow.myThing = stampit.compose(oldskool).methods({\n  bar: function bar() { return this; },\n  // your methods here...\n});\nexport default oldskool;\n``\nIf you just use Object.setPrototypeOf(this, new SomeES6Constructor()), then everything that stampit composed (bar in the case above) gets blown away. Is what I'm doing really that dangerous sinceprotoandsetPrototypeOf` are both in the ES2015 spec?\nIs there a better way to do this currently?. > Sorry, what do you mean exactly when saying \"blown away\"?\nTry taking off the .__proto__ on this.__proto. The stamped methods no longer are present. So yes, our code works as expected. myThing().bar().foo()\nMy question is, is this a good way to deal with es6 class to stamps until this feature is fully implemented?. Thanks for the responses. I definitely plan on going through that whole tutorial set.\nHowever, I'm actually not saying that the code I posted is an issue or that I don't understand why it's working how it's supposed to. It's doing exactly what I expect and want (i think, I don't mess with proto directly often).\nMy question/issue is:  According to the api notes eventually we'll have a standard stampit way to handle this. Removed convertConstructor(). We plan to revive it and support the ES6 classes.\nSo what do we do for now? Writing to this. __proto__, even if it works, is it OK to do this? What is the best practice to convert es6 classes to stampit? . Ok, I played around with this a bit more.\u3000And I'll be able to sleep better at night knowing I'm not directly accessing the __proto__ property, and instead leveraging my new best friend Reflect.\n```javascript\nclass PubSubModel {\n  constructor(){this.a = 1;}\n  foo(){console.log('foo')}\n  get b(){return this.a;}\n  set c(x){this.a = x}\n  static d(){return 'baz'}\n}\n// The conversion\noldskool = stampit.init(function() {\n  // Ought to do the trick\n  Reflect.setPrototypeOf(Reflect.getPrototypeOf(this), Reflect.construct(PubSubModel, []));\n});\n// Now you can compose with it just like any other stampit factory...\nmyThing = oldskool.methods({\n  bar() { return this; },\n  // your methods here...\n});\n``\nWouldn'tReflect.setPrototypeOf(Reflect.getPrototypeOf(this), Reflect.construct(ctor, []));instead ofObject.assign(this, Reflect.construct(ctor, args));be better? Object.assign won't iterate __proto__ methods and will lose access tofoo` in my example, if I were to use convertClass.\n. Thanks @koresar that seems like a very useful addition to stampit adoption. I'll be sure to try it out soon. \nAs to your other point, do we need convertConstructor if we have convertClass: \nI've gathered that stampit is trying to be friendly to the ES5 ecosystem, since it's written in ES5. But if you don't support convertConstructor, then who is stampit targeting? \nPeople with build-systems that already convert their es6+ classes to ES5? But then people's build system would be able to transpile stampit if it was written in ES6+ syntax.\nPeople who use native ES6+ without any transpiling? But then why code stampit in ES5? \nPersonally, I would still benefit from a convertConstructor as I'm using stampit as a way to bridge both the old and new code in my code base, which has both ES6 and old \"class\", but I can write something to hold myself over indefinitely. I'm curious what breaks if I pass a plain old constructor w/ prototype chain (old school classes) to the new convertClass. Time to dig in and find out :). Honestly, I'm wondering what a good entry point for stamps are, so nothing specific. I'm thinking I would be using Vue.component frequently and would need a good way to add more functionality to base level Vue instances. Vue seems to heavily use Vue.extend, which is the same as class inheritance, so do you manage to avoid that with the use of stampit? \nLike I said, I'm more just curious how you or anyone has effectively utilized stamps + Vue.js. Do you happen to have any code samples or repos?. ",
    "anhuiliujun": "So, if i am not using any bundle system, how should i use stampit now?. Thank you very much, and sorry for the noise, I forgot the object.assign polyfill.. ",
    "koalabz": "Thanks @koresar for your quick answer but why not use the same approach than init() for methods() func like this : \njavascript\nconst stamp = stampit().methods(({ instance, stamp, args }) => ({\n   error: console.error,\n   incorrect: (value) => {\n      instance.error(`value ${value} is incorrect`);\n   }\n));\nmethods() accept also a function with the same init() options object and return methods, but we can use ES6 Arrow Func \n. > @koalabz You really like that better than what @koresar showed you?\nI don't prefer one or the other i just try to understand why we can't use ES6 Arrow in other methods than init function.\n\nEither way it's not really possible because in the time when you are calling methods, there is yet no instance to refer to.\n\nIt's the same when you call initmethod right ?\nAs reference in doc API: create(), object is created when you invoke createor execute your stamp.\n\nWithout doubt the arrow function is a great addition. When used correctly it brings simplicity in places where earlier you had to use .bind() or trying to catch the context. It also makes the code lighter. \nAdvantages in some situations brings disadvantages in others.\n\n:)\n. Thanks @koresar @FredyC for your answers i will use the old style this as mentioned above \ud83d\ude04 \nTry to understand deeper stamp-specification when have more time .\n. ",
    "neverfox": "I just wanted to second @koalabz's suggestion because I would prefer never to use this and I'm willing to pay a price in verbosity to avoid it. I'm curious why, @FredyC, it's not possible on a library level to allow that form. Wouldn't it just be a matter of seeing if the argument to methods is a function and, if it is, use the returned value?. ",
    "Piroro-hs": "I've just tried the https://github.com/stampit-org/stampit/pull/267 repo and it works perfectly!(^^)\n. ",
    "tdzienniak": "stampit version is 3.0.4. Stamp and my benchmark code is in the repo: https://github.com/tdzienniak/stampit-benchmark/blob/master/index.js\nI'm using this tool for benchmarking: https://github.com/bestiejs/benchmark.js\n. Thank you mate. Take your time. :)\n. ",
    "kurtpeters": "No problem! Here's the PR - https://github.com/stampit-org/stampit/pull/274\n. ",
    "gfot": ":) Thanks @koresar !. ",
    "iamgollum": "Thank you!. ",
    "greenkeeper[bot]": "Version 0.38.2 just got published.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits .\n\n4b6b6f7 -> v0.38.2\ne1e9eaf Merge pull request #1191 from rollup/gh-1011\nd08a805 prevent irrelevant warning in test\naefbed6 warn if exporting an IIFE that looks like a function declaration, and wrap in parens if necessary (#1011)\n1d83cbf Merge branch 'master' of https://github.com/rollup/rollup\n0d3ab7b use Set rather than Map for deshadowing\nb287370 Merge pull request #1188 from rollup/gh-997\nd249c7e preserve var declarations in dead branches\n\nSee the full diff.\n\n. ## Version 0.40.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits .\n\nbe76a1f -> v0.40.2\ncebc300 Merge pull request #1224 from rollup/gh-1217\n46f5dbf Merge pull request #1223 from rollup/gh-986\n502e58d omit globals for empty imports (#1217)\ne4f995e remove unused files\n1032e75 add file property to sourcemaps with plugins\n7e71777 put test where it belongs\na9bcf45 Merge branch 'master' into gh-986\n8290e11 test that file property is being added to sourcemap (#986)\n\nSee the full diff.\n\n. ## Version 0.41.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits .\n\ne938d86 -> v0.41.1\nb0a83b8 Merge pull request #1234 from rollup/gh-1233\n585bde0 test for #1233\n766e91d include new expressions where callee is a class (#1233)\n\nSee the full diff.\n\n. ",
    "Ephs05msm": "Thanks so much for the help (and the quick reply).  I'll review and revise on my end, and will spend more time with the change log going forward.. ",
    "amelon": "arrow functions are some kind special.\nThey are bound to their outside context and cannot be bound to your stamp instance.\nDon't use fat arrow function with init method.. ",
    "giper45": "Thanks very much for the explanation !!! I've learned something more about Javascript in general :) ! . ",
    "Mika83AC": "@koresar  Hm... I think I'm not in a position to help as I'm a JS and StampIt newbie ... :( Really have no idea what might be wrong.\n@FredyC Even this is not working for me. Here is my example done as I understood your advice:\n```\n<!doctype html>\n    \n\n    <script src=\"bower_components\\stampit\\stampit.js\"></script>\n</head>\n<body>\n    Test\n</body>\n<script>\n// Some privileged methods with some private data.\nconst Availability = stampit().init(function() {\n  var isOpen = false; // private\n\n  this.open = function open() {\n    isOpen = true;\n    return this;\n  };\n  this.close = function close() {\n    isOpen = false;\n    return this;\n  };\n  this.isOpen = function isOpenMethod() {\n    return isOpen;\n  }\n});\n\n// Here's a stamp with public methods, and some state:\nconst Membership = stampit({\n  methods: {\n    add(member) {\n      this.members[member.name] = member;\n      return this;\n    },\n    getMember(name) {\n      return this.members[name];\n    }\n  },\n  properties: {\n    members: {}\n  }\n});\n\n// Let's set some defaults:\nconst Defaults = stampit({\n  init({name, specials}) {\n    this.name = name || this.name;\n    this.specials = specials || this.specials;\n  },\n  properties: {\n    name: 'The Saloon',\n    specials: 'Whisky, Gin, Tequila'\n  }\n});\n\n// Classical inheritance has nothing on this.\n// No parent/child coupling. No deep inheritance hierarchies.\n// Just good, clean code reusability.\nconst Bar = stampit(Defaults, Availability, Membership);\n\n// Create an object instance\nconst myBar = Bar({name: 'Moe\\'s'});\n\n// Silly, but proves that everything is as it should be.\nmyBar.add({name: 'Homer'}).open().getMember('Homer');\n</script>\n\n\n```\nStill the error \"Uncaught TypeError: stampit is not a function at index.html:12\".. @FredyC I freshly installed it via bower as described in the readme: \"bower install stampit\".  This morning (before posting here) I performed a \"bower update\" to be sure to be on the latest version.\nUsing the CDN link you posted results in the same error. I've put my \"example\" on my server so you can have a direct look at it: http://divelop.de/stampit/\nAs I'm using the latest Chrome, I don't think it can/will be a browser compatibility issue.. ",
    "nachocab": "Although, now that I think of it. I guess I could just do this:\n```js\nGrade = stampit({\n  init(percentage) {\n    this.percentage = percentage\n    this.grade = this.grade(percentage)\n  },\nmethods: {\n    grade(percentage) {\n      return Grade.grades.find(x => percentage >= x.minimumPercentage) // access explicit instance variable\n    }\n  }\n})\nGrade.grades = [\n  {letter: 'A', minimumPercentage: 0.9, passing: true},\n  {letter: 'B', minimumPercentage: 0.8, passing: true},\n  {letter: 'C', minimumPercentage: 0.7, passing: true},\n  {letter: 'D', minimumPercentage: 0.6, passing: true},\n  {letter: 'F', minimumPercentage: 0,   passing: false}\n]\n``. Thanks @FredyC! I'm having trouble trying to understand whatconfanddeepConf` are used for (I'm reading the API, but I don't really get their purpose). Thanks @koresar . Got it, thank you both!. ",
    "far-blue": "Great to know I can still use 'new' if needed to work with older libraries that don't use Object.create() etc.\nWhether we like it or not, a lot of js code expects 'new' to work and so saying \"Don't use new\" isn't overly helpful.\nI certainly wouldn't be surprised if I was missing something here as I'm pretty new to all this but to my understanding 'new' is effectively just creating a new object, setting its prototype and then running the content of the constructor function in the new object's context (i.e. 'this' is the new object). So, really, it is allowing for a form of delegation inheritance through the prototype chain. As such, is it really a bad thing? Certainly when creating thousands of objects with the same methods delegation inheritance is recommended.\nI assume using 'new' with a stamp function correctly uses delegation on the prototype chain to prevent copying of methods each time. Or is that assumption wrong?. Thank you :)\nIn your 'fun with stamps' article you mention, in the section 'Objects created by stamps', that the prototype for the objects created by the stamp function is the .methods object from the stamp descriptor which is itself a property of the stamp function. This would suggest my assumption is correct and all objects created by the stamp function use prototype based delegation and the methods are not copied. So it won't be a problem to create thousands of objects from the stamp function.\nIf I understand the code in ep4 of 'fun with stamps', properties are copied, methods are delegated via the prototype and initializers are run as part of the createFactory() method as described in the section 'Factory function internals'.\nMaybe I worded my initial assumption incorrectly. I'm not interested in a hierarchy of chained prototypes. I'm interested in correct use of delegation so that when I create thousands of objects from the same stamp function I'm not creating thousands of copies of all the methods on the objects at the same time. I've seen examples of mixin- and extend-style code that do exactly this and it's a huge memory hog and performance killer :)\nI am surprised 'new stampFunction()' works but pleased and although the use of 'new' is discouraged I think people new to stamps and working with mixed codebases would like to know it is possible and what, if any, differences exist between 'stampFunction()' and 'new stampFunction()'.. thank you for all your help :). that's great, thanks :) I'm starting to understand how all the bits fit together now!. My suggestion is to reuse a broken element of js to turn it into a helpful facility by replacing the original broken behaviour with well defined stamp-compatible behaviour without having to invent a new interface :) wouldn't rescuing instanceof and recycling it be a good thing?. shrugs It doesn't impact me either way as it's easy enough for me to implement myself for my own use. I'm just suggesting ideas - such as extending what instanceOf actually does (rather than what people think it does) to cover multiple prototypal delegation using new capabilities in ES6 others may not be aware of.\nBut if you want to dismiss the idea and then categorise it as crazy I'll bow out and go back to my life :). Well, the details of which entities were used in the creation of a factory function would be stored in the factory function, not the objects it creates. Each factory would have a method each object it creates then references. The factory could hold (possibly weak) references to the factories or propertyDescriptors themselves and allow a recursive search or, alternatively, some form of uuid could be used and each factory could gather an array of all the uuid strings. The first likely uses less memory if you have thousands of stamps. The second is likely faster. A third option would be something like immutable.js's trie structure which could be shared and extended but that introduces a dependency.. When all the additional memory use, little as it is, and cpu time is only consumed in the creation of the factories then the impact is going to be small.\nSorry, yes, you are right. It's a stamp descriptor object, not a propertyDescriptor. To be absolutely clear for everyone, I mean objects that look like this: https://github.com/stampit-org/stamp-specification#the-stamp-descriptor. ",
    "eggyal": "Hi @koresar, thank you for that answer.  If I might just respond to each point in turn:\n\nStamps do use prototype, but only one level. No second or more level chaining.\n\nAgreed, but this is the very point I was responding to.  :)\n\nStamps consist not only of other stamps, but also stamp descriptors. These are POJO. Some of the descriptors contain methods property, some don't. I have no idea what the chain would look like in this case.\n\nThere could either be an object in the chain that contains no own properties or one could optimise that object out and directly link child prototype to parent.\n\nStamps are composed of multiple other stamps (and descriptors). So, a single stamp can have a dozen of \"parent\" stamps. I have no idea what the chain would looks like in this case.\n\nYet the incumbent merge operation effectively linearises such compositions already.  It's no different.\n\nVertical hierarchy of prototypes is hard to reason about when you have, say, 10 prototypes down the chain. That's one of the main reasons stampit was born.\n\nI thought the driving issue was to provide multiple inheritance, though I readily admit I need to watch Eric's talk again.  I'm not convinced a chain of 10 prototypes is any more difficult to reason about than a composition of 10 stamps?\n\nPerformance wise it is always better to have only one prototype in an object chain.\n\nThis is a fair point, and one could certainly give developers the choice of inheritance methodology so that merge can be preferred over prototype chaining where performance is an issue.\n\nYou might want to read this discussion on instanceof implementation, and the referenced issues.\n\nThanks, will do.\n\nAnd last, but not list. In production my stamps are composed of 20 other mini stamps. \n\nAs above, the incumbent merge operation is effectively linearising your composition already.. @koresar: Surely it depends on the order of your existing composition?. But I mean, how are siblings currently composed?  Isn't stampit(a,b,c) analogous to the prototype chain null <-- a <-- b <-- c?. ",
    "trusktr": "\nI eager to see your linearisation algorithm. \n\nIt is called class-factory mixins, as alternative to concatenation.. ES6 let's you do\n```js\nclass Foo {...}\nclass Bar {...}\nclass Baz extends Bar {...}\nclass Blah {...}\nclass Lorem extends multiple(Foo, Baz, Blah) {...}\n// or, depending on the prototype chain ordering that you want\nclass Lorem extends multiple(Baz, Foo, Blah) {...}\nfunction multiple () {\n  // ... I leave you to imagine the implementation ...\n}\n```\nThis is what Stampit seems to be purposed for, but it can also be done with ES6 classes and prototype chaining rather than with concatenation.. Here's an example of multiple inheritance with class factory mixins in practice: https://github.com/trusktr/infamous/blob/master/src/motor/Sizeable.js#L26\nES6 classes are not limited by arthritic problems cause by single inheritance.. As bonus, here's two multiple() implementations (with examples), but each one currently fails in certain more complex cases:\n\nhttps://gist.github.com/trusktr/05b9c763ac70d7086fe3a08c2c4fb4bf\nhttps://gist.github.com/trusktr/8c515f7bd7436e09a4baa7a63cd7cc37\n\nThe non-failing solution can be made with Proxy, but at the time of writing (and even still) not all engines have it in production, so I decided to come back to it later.\nI don't really see a good enough reason to use Stampit when I can achieve the same with ES6 classes. Am I missing anything?. Also note in my above linked example of the Sizeable class, the mixins can be used as classes.\nF.e. , it could be\n```js\nclass Sizeable extends TreeNode {}\n// or\nclass Sizeable extends TreeNode.mixin(Observable) {}\n// or\nclass Sizeable extends TreeNode.mixin(Observable.mixin(AnyOtherClass)) {}\n// and, in the last case\nconst s = new Sizeable\ns instanceof TreeNode // true\ns instanceof Observable\u200b // true\ns instanceof AnyOtherClass // true\n``\n. If you mean that themultiple()` function is the supporting library, then yeah. It's easy to import with ES6 import/export. :)\nIn the very near future, it will be as simple as\njs\nimport multiple from 'http://some-cdn.com/path/to/multiple/vXXX'\nStampit is also library support. Object.assign is also built-in library support.\nHaving to import something or even copy/paste it is not really a huge problem!. ",
    "Brian151": "IDK how i missed those...\nYou might want to make them a bit more noticeable since some people see console commands and quit reading...\nhowever, i do get THIS problem, now\nstampit()\nTypeError: stampit is not a function [Learn More]\ntypeof stampit\n\"object\"\ni also did a toSource() , but other than confirm it's an object, nothing of note.\nSo, how am I supposed to create a new stamp, then? your documentation all says to call stampit()\ndo i just use stampit.something() , now? //github needs to ignore brackets... \nanother question, can i define the methods like \n{\nmethodName:function(){}\n}\n?\nI'm certainly not willing to trust certain ES6+ syntax to be supported just enough to be safe to use everywhere, also... I might use either typescript or haxe, and i have to use not so exciting things as-is to do what I'm planning to do.. All you need really to do is put \"download compiled version\" or something\nOr note that Bower and whatever else aren't mandatory\nI don't feel comfortable editing an MD file... I generally don't use them, thus never bothered to learn their syntax\nAlright... As long as it still works\nNeat!\nProbably... we'll just see further down the road. kinda? i started a few years ago and was only writing things by hand. eventually was made aware that there are tools to build JavaScript from much nicer-looking code, Like the Haxe compiler and VS:Code. I still have quite mixed feelings about using it to build entire programs, though. I am aware it's not \"true\" compilation... lol. Definitely heard permutations of \"trans\" + \"piled\" , as well. Just don't use them because I rarely see any reason to.\nThere is one totally pointless one I forgot multiple times now...\nwhat's the \"umd\" stand for in the filename?\nand yes, thanks for the help. . Alright\nWell, I'll let you know if I have any other problems/questions\nShould be safe to close this now.. most of them won't need to be initalized, but yep... \nthx!. ",
    "fpoumian": "Sure! :) . Invite accepted. Thanks a lot!. ",
    "kellypacker": "@FredyC ah, I missed that. That was the issue. Thank you for the response!. ",
    "jktravis": "Sure. \nTypeError: __WEBPACK_IMPORTED_MODULE_0_stampit___default.a(...).props is not a function\nat Object.defineProperty.value (http://localhost:63342/Webpack3StampIt/build/main.js:24:4)\nat __webpack_require__ (http://localhost:63342/Webpack3StampIt/build/commons.js:55:30)\nat Object. (http://localhost:63342/Webpack3StampIt/build/main.js:7:66)\nat __webpack_require__ (http://localhost:63342/Webpack3StampIt/build/commons.js:55:30)\nat webpackJsonpCallback (http://localhost:63342/Webpack3StampIt/build/commons.js:26:23)\nat http://localhost:63342/Webpack3StampIt/build/main.js:1:1\n\n. It appears to still throw. I tried it with stampit@3.0.6. I received a reply on the webpack issue. Am I using it wrong now? \nhttps://github.com/webpack/webpack/issues/5241#issuecomment-313846314. Thanks, @koresar. Yes. The workaround will do. . ",
    "jyboudreau": "Hi @FredyC,\nI agree that this can be fixed via a polyfill and this is likely a valid use case for application developers. However, using a polyfill is not a valid use case for library developers such as yourself and others. \nAs such any library developer wanting to use stampit or @stamp packages have to either pollute globals or pass along this problem up the dependency chain. \nWhen such a simple solution exists (~20 lines of code) why restrict your audience to people who:\n- Don't want to support older browsers.\n- or, Don't mind telling their users they need a polyfill.\n- or, Don't mind polluting globals.\n. I also think these are valuable goals. They are valuable goals for my own libraries as well, but now if I want to use \\@stamp\\stampit I have to pass along that problem.\n\nOr do it configurable and allow a user of your library decide if they want to use it or they have own solution in place.\n\nWhy not provide this configurability in \\@stamp\\stampit then? I.e. Allow users to provide their own assign function.\n. @FredyC Good points. We'll look at our options and might provide a PR for configuration.\nRight now since we're bundling with WebPack and Babel I believe we are able to transform the global assign polyfill into a non-global one. Thanks for your help.. Great write up @ericelliott. I agree with others about this making a good blog post. I always like your articles.\nWith that said, I'm still only partially convinced. \nIn my case i'm developing a WebRTC library. WebRTC is still very much a moving thing. I can't exactly develop this library to the standard and then tell my users to fill in the gaps, I would have no users. A big part of any WebRTC library's responsibility at this point is to remove the difficulty of filling the gap from the user.\nSince we take so much care to fill these WebRTC gaps for each browser it's then easy to extend that mentality to smaller things like Object.assign that have known and easy polyfills.\nIn other words, if we're going to advertise to our users that our library supports Chrome, Firefox, IE11 and Safari as a selling point then we'd better make sure it does work in all those browsers. It's already difficult enough to use WebRTC across different browsers without us making it slightly more difficult for our users.\nSome parallels could be drawn to other libraries.  Like JQuery, which I don't think would have been very popular if it just implemented everything to the standard at the time.\nIn the end I don't think being a good web citizen is as black and white as you paint it. There will always be some compromise between idealism and pragmatism.\n. Noticed this was published as 3.2.0 on NPM but docs here refering to 3.1.3. Probably not a big deal however.. ",
    "Mustack": "Thanks to all for your consideration on this issue. I can tell you that after further troubleshooting, I found another dependency of my lib used native promises. This meant I needed a more scalable solution than opening PRs in each project. I ended up using babel transform runtime to solve this. I've also been able to remove the ponyfills that I was using in my own code.\nIf Stampit were the only dependency, using a \"compat\" version of stampit would probably be the most simple solution and I think I would have used that. I'm just sharing my experience for your consideration.\nThank you for the work you guys are doing on this project. It helps a lot.. ",
    "MarcLoupias": "Oooookayyyyy ;)\nIt's crystal clear now.\nIt imply that factory function have to takes an object as param.\nWe cannot do that const myInstance = FactoryFn(val1, val2 ...)\nWe have to do that const myInstance = FactoryFn({prop1: 'val1', prop2: 'val2', ...})\nTo be honest the rtype spec to describe stamps add a step in the library adoption. You want to learn stamp but you have to learn rtype + stamp. Javascript executable examples in addition to the rtype def in the stamp-specification repo would be valuable.\nThanks !\nEDIT : In fact it is obvious when thinking about it. Should be really obvious for seasoned functional programming developpers which is not my case, everything is new to me.. ",
    "AlexxNica": "@koresar Little tip: You could have rebased your commits before pushing and merging to avoid polluting the history.\nTake a look at:\nhttps://git-scm.com/docs/git-rebase\nhttps://git-scm.com/book/en/v2/Git-Branching-Rebasing. Here. ",
    "pendenaor": "Did you use vuex store ? Is stamp can be mixed with it?. Nice design, thanks for sharing some stampit enlightment!. Sorry for re-opening this issue, are we agree that the HasLogger stamp cannot be composed with several stamps with their own prefixed log?\nBelow a sample to show what i mean :\n```js\nimport stampit from '@stamp/it';\nimport {argOverProp} from '@stamp/arg-over-prop';\nconst Logger = stampit(argOverProp('prefix'), {\n    methods: {\n      log(...args){ console.log(this.prefix, ...args); },\n      error(...args){ console.error(this.prefix, ...args); },\n      warn(...args){ console.warn(this.prefix, ...args); }\n    }\n  }\n);\nconst HasLogger = stampit.statics({\n  hasLogger(name) {\n    return this.conf({HasLogger: {name}});\n  }\n})\n.init(function (_, {stamp}) {\n  const {HasLogger} = stamp.compose.configuration;\n  if (HasLogger) {\n    this.logger = Logger({prefix: HasLogger.name});\n  }\n});\nconst Stamp1 = stampit(HasLogger.hasLogger('Stamp1'), {\n  methods: {\n    fn1: function fn1(...args) {\n      this.logger.log('fn1')\n    }\n  }\n})\nconst Stamp2 = stampit(Stamp1, HasLogger.hasLogger('Stamp2'), {\n  methods: {\n    fn2: function fn1(...args) {\n      this.logger.log('fn2')\n      this.fn1()\n    }\n  }\n})\nconst Stamp3 = stampit(Stamp2, HasLogger.hasLogger('Stamp3'), {\n  methods: {\n    fn3: function fn1(...args) {\n      this.logger.log('fn3')\n      this.fn2()\n    }\n  }\n})\nconst s3 = Stamp3();\ns3.fn3()\n// Results\n// Stamp3 fn3\n// Stamp3 fn2 => Should be Stamp2 fn2\n// Stamp3 fn1 => Should be Stamp1 fn1\n```\nCan i correct this behavior within HasLogger?\n. Ok, make me feel a little stupid \ud83d\ude44 \nThanks for your time.. ",
    "benjiboi214": "Fixed!. ",
    "GeorgeGkas": "Oh yes just find out what cause it. I came to close this issue, but you already replied. Thank you that took time to answer my question. :). ",
    "kuncevic": "That is the tricky one but you can try to talk on that matter at https://gitter.im/Microsoft/TypeScript . ",
    "moranje": "I've updated the example because figured out that stampit() returns a factory function and the factory function returns an instance. That only partly solves my problem it seems.... I've figured it out, I'm closing this but I have adjusted the example for future reference.\nMartien. "
}