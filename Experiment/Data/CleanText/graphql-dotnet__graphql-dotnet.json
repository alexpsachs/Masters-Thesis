{
    "PeteDuncanson": "Hi Joe,\nI was tempted to go with ANTLR with our version of this but I just don't think it was a good fit. The JS reference version of GraphQL will continually get updated with any fixes so I went the route of porting their parser. My thinking was it would be easier for people to read that and translate it into C# fixes in a parser so we've have more eyes on it.\nYou've done such a great amount of work on this I'm happy to bring my code to the table and add it to this project and put our heads together as you said on twitter ;)\nI'll create a fork and see about getting my stuff added. Not got too much but the parser is about 40% done I think. If I focus on that bit we could swap it out for Antlr once its up and running assuming you are happy with it.\nCheers\nPete\n. Adding XML Documentation seems like a no brainer. I'm reading through the examples but its damn hard to get your head around some of the concepts. Allowing me to explore the API along with the examples with good intellisense it invaluable I think. I've started having a poke around in the source some more and see if I can't get some added (assuming I can make any sense of it!)\nAlso of note if you are worried about comment bloat (I don't think you should be as long as we avoid GhostDoc auto generated bollocks thats there just to pass some style cop rules) you could include the comments separately in a separate xml file if needed (https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/include)?. ",
    "joemcbride": "Hey Pete, thanks for offering to help!\nMy thinking with going with ANTLR was so that I could get something working fairly quickly, and overall I think they do a good job at solving the lexer/parser problem.\nI think going with a custom solution would be fine, though from experience that can be hard to get right.  As you said though, that could possibly elicit more help if it is all in .NET.\nI'll add in some hooks to make it easier to swap out the Document builder.  That way you can run the existing tests to see if its working.\n. Added some interfaces to make it easier to replace existing classes.\nImplement IDocumentBuilder which takes in the query data and returns a Document.\n``` csharp\npublic interface IDocumentBuilder\n{\n    Document Build(string data);\n}\npublic class MyCustomBuilder : IDocumentBuilder\n{\n    ...\n}\n```\nYou can then replace the builder in the Tests by making this change:\ncsharp\npublic class StarWarsBasicQueryTests\n    : QueryTestBase<StarWarsSchema, MyCustomBuilder>\n{\n    ...\n}\n. How about Facebook's C++ parser?  https://github.com/graphql/libgraphqlparser\n. Worth a look for sure.\n. Closed with the merging of #127 \n. Closing this.  Design issue resolved with the 3.0 release.  https://github.com/joemcbride/graphql-dotnet/releases/tag/v0.3.0\n. Hey, thanks for the feedback.  I'm traveling this weekend though can write a proper response on Monday.\n. Again, thanks for your feedback.  I was hoping once this was out there someone would come along and say \"hey, this this has some issues, maybe we can do it better?\".  Let me see if I can explain some of my original reasoning and hopefully we can come up with better ways to do it.\nRequirements\n1. There only ever needs to be a single instance of any given \"base\" type in the entire schema.  A base type would be scalar types and user-defined types.\n2. Collecting distinct type data for introspection.  For introspection to work, you need to know what distinct low-level types are available in your system.  In addition, you need to know what types \"implement\" which interfaces.\n3.  Resolving dependencies through a IOC container.  You may have a service that needs to fetch data in your resolve method.  Typically you would inject this dependency in the constructor of your class.\nFor req 1, this is a little easier in JavaScript since making globals is \"on by default\", and you can easily import instances of classes from other files.\nFor req 2, this is where the GraphTypesLookup originally came into play in conjunction with req 1.  Have a place for the code to just say \"give me this type\" and it hands it over.\nFor req 3, I was originally thinking of just constructor injection.  Thinking more on this, it probably would have been better to go with a service location pattern, adding  a GetService<T> on the ResolveFieldContext.\nThe change to Types vs. instances lead me to TypeCollectionContext, which I really don't like.  I would be happy to get rid of it.\nDynamic DSL\nFor this to work I think you would create an object and pre-register it with the type lookup.  Creating a generic type in code is pretty easy, so I think we would need to add an overload for field registration that took just the Type.  Having all instances could maybe make this a little easier, though doing it with with Types shouldn't be terribly hard.  I think we're talking about a difference of Field(obj, \"name\") vs. Field(obj.GetType(), \"name\").\nUnions\nFor unions specifically, I probably wouldn't suggest a UnionGraphType<T1, T2>.  This is how they do it in the JavaScript project:\nvar PetType = new GraphQLUnionType({\n  name: 'Pet',\n  types: [ DogType, CatType ],\n  resolveType(value) {\n    if (value instanceof Dog) {\n      return DogType;\n    }\n    if (value instanceof Cat) {\n      return CatType;\n    }\n  }\n});\nIn .NET, with the current design of GraphQL.NET I would probably do something like:\npublic class PetType : UnionGraphType\n{\n  public PetType()\n  {\n    Types.Add(typeof(DogType));\n    Types.Add(typeof(CatType));\n  }\n  ...\n}\nThen when you register the field:\nField<ListGraphType<PetType>>(\"pets\");\nA Better Way\n- Use service location with ResolveFieldContext.\n- I like the idea of having a strongly typed result on field resolution, will take some updates to FieldType (putting in a generic and non-generic interface I think), though can probably do that.\n- What pattern do you see being used to resolve req 1 with user-created types?  Have a \"schema builder\" class where the instances are contained and passed around?  Static instances on the type itself like I had on the Scalar types?  Static instances on the Schema? Schema builder + type builder?  I'm going to take a look at the Java project and see if I can discern how they went about doing this.\n```\npublic class SchemaBuilder\n{\n  public Schema BuildSchema()\n  {\n    var humanType = new HumanType(...);\n    var humanType = ObjectGraphType.Build(\"Human\", ...);\nvar query = new QueryType(humanType);\n\nreturn new Schema\n{\n  Query = query\n};\n\n}\n}\n```\npublic class SomeType : ObjectGraphType\n{\n  public static SomeType Instance = new SomeType();\n  protected SomeType()\n  {\n    ...\n  }\n}\n. @moserware @scmccart Feedback welcome ^^\n. I'm liking that syntax.\nHow would the field\nbuilder.Field<Foo>(\"foo\", resolve: (context) => fooLoader.GetItem(context.args[\"id\"]));\nget resolved to the fooType?  Would that be\nbuilder.Field<Foo>(\"foo\", fooType, resolve: (context) => fooLoader.GetItem(context.args[\"id\"]));\ninstead?\n. List/NonNull syntax:\nfields: _ =>\n{\n    _.Field(\"name\", new GraphQLNonNull(GraphQLScalars.GraphQLString), f => f.Name);\n    _.Field(\"friends\", new GraphQLList(GraphQLScalars.GraphQLString), f => f.Friends);\n});\n. I'm not an expert on DDD though I understand the aggregate concept.  That pattern would certainly resolve the IoC issues I was thinking of.  It also allows you to split up the schema definition so you don't have one massive definition in a single file.\nI like the idea of having simplified registration to get going quickly, which then you could build upon.\nIGraphQLFieldResolver - perfect.\nI setup that sample code locally and played with it a bit, really liking it.  I think the one suggestion I have so far is to make the fields required.  I don't think creating a GraphQLObjectType without fields is valid.\nAs a side note, I also think it is probably a good idea to switch to the same names as the reference implementation, as you have done.  Makes looking at examples easier to understand I think as well as comparing to the reference implementation code.  That will be unfortunate for anyone who has used the project so far (which isn't huge), though shouldn't be terrible.  Better to do that now rather than later.\n. I'm not terribly familiar with Relay yet, though looking at the relay-starter-kit I think you want the introspection queries.\nIs this what you're looking for?  Getting the schema in json format?\nI just added additional support for introspection on Friday (it should be pretty close to complete).  Check out the StarWars introspection tests.\n. Note that those changes aren't on NuGet yet, there are a couple issues left to fix before I want to push an update.\n. @michshat Pushed up some changes that may fix your issues.  Give it a go again?\n. @michshat Added a bunch of fixes, plus a project that runs the GraphiQL interface.  Give it a try!\n. Awesome, I'm going to push a new Nuget version.  Let me know if you find any issues. \n. 1. isDeprecated should be a boolean.  Which are you getting?  In the sample you posted it looks like a boolean.\n2. Hm, yes perhaps you have an issue in your schema?  Is your User object defined as an Object or an Interface?\n. 1. Yeah that's fine I think.\n2. What name did you give the UserInterface?  I'm guessing it is also marked as User.  Those two names need to be unique.\n. I'm not sure I'm fully following, though are you able to just add more to your introspection query to get the data you need?  My first thought is you may need the tripple ofType definition listed below in the TypeRef fragment.\nI added a \"full introspection query\" here that the graphql-js project is using, which seems to include a bit more information than the introspection query you posted above.  Does using that help?\nPosting the query here for posterity:\nquery IntrospectionQuery {\n  __schema {\n    queryType { name }\n    mutationType { name }\n    types {\n      ...FullType\n    }\n    directives {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      onOperation\n      onFragment\n      onField\n    }\n  }\n}\nfragment FullType on __Type {\n  kind\n  name\n  description\n  fields {\n    name\n    description\n    args {\n      ...InputValue\n    }\n    type {\n      ...TypeRef\n    }\n    isDeprecated\n    deprecationReason\n  }\n  inputFields {\n    ...InputValue\n  }\n  interfaces {\n    ...TypeRef\n  }\n  enumValues {\n    name\n    description\n    isDeprecated\n    deprecationReason\n  }\n  possibleTypes {\n    ...TypeRef\n  }\n}\nfragment InputValue on __InputValue {\n  name\n  description\n  type { ...TypeRef }\n  defaultValue\n}\nfragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n      }\n    }\n  }\n. You are saying it should not export the INTERFACE type IUser?\n. Okay I understand.  In the sample repo it is using an Interface type Character, which is getting returned.  I'm not sure why your interface isn't, sounds like a bug.  It is getting all the types from here if you can run under debug and want to see all of the available types being returned.\n. I think I figured out the issue.  An interface object would not be registered in the type lookup if it is not used somewhere as a field.  I pushed a change to master that registers the interface object.  It seems like you would want to use that interface type as a field type somewhere though.\n. 1. errors:[] - your GraphQL endpoint can return whatever, it doesn't need to return the ExecutionResult directly.  You can easily return an object with a data property and resulting object from the ExecutionResult class.\n2. The field names provided are just static, however when checking objects for those values it ignores the casing.  When data is returned from the API it returns the field named exactly as it was defined in the field.  You can use a CamelCasePropertyNamesContractResolver with JSON.NET to force all returned field names to camel case, though then you could have a mis-match between the Introspection query and the output.  I could certainly add something to force camel case, though just naming the fields that way when registering is pretty easy.\n3.  I have been able to see an integer come through as that type.  Did you perhaps send the value as a string in the GraphQL query?  This is what works for me:\n``` javascript\nField(\n  \"human\",\n  arguments: new QueryArguments(\n    new [] {\n        new QueryArgument> {\n          Name = \"id\", Description = \"id of the human\"\n        }\n    }),\n  resolve: context =>\n  {\n    var id = (int)context.Arguments[\"id\"];\n    return data.GetHumanById(id.ToString());\n  }\n);\n/////////////////////////////////\n// correct\nquery AQuery {\n  human(id: 1 /sending as number/) {\n    name\n  }\n}\n/////////////////////////////////\n// incorrect\nquery AQuery {\n  human(id: \"1\" /sending as string/) {\n    name\n  }\n}\n```\n. > and if empty array of errors is present \"errors\":[] the relay-graphql complains\nRight, so you need to change your Executer class to not just serialize the ExecutionResult class.  Manually removing the errors in the string is working around the problem.  Change it so it creates a different object vs. just serializing what is returned from the DocumentExecutor.  I would also suggest to not just return a string and instead return an object that gets serialized to JSON.  Something like:\n``` csharp\n[HttpPost]\npublic JsonResult ExecuteGraphQL(string query)\n{\n    MyResult result = Execute(_schema, null, query);\n    return Json(result); \n}\npublic class MyResult {\n  public object data {get;set;}\n}\npublic MyResult Execute(\n  Schema schema,\n  object rootObject,\n  string query,\n  string operationName = null,\n  Inputs inputs = null)\n{\n    var executer = new DocumentExecuter();\n    var executeResult = executer.Execute(schema, rootObject, query, operationName);\n    if (executeResult.Errors.Count() == 0) {\n      return new MyResult { data = executeResult.Data };\n    }\n    return new MyResult { data = new { error = \"An error has occured\" } };\n}\n```\n. A connection class is now included in the core library.  I do think it could be helpful to add some of the other Relay classes.  I'm going to close this issue and create a new one to track that.\n. At first thought, I don't think transpiling would be a good way to go.  I have been using the JavaScript source as a reference, though not auto-generating the code.  I think C# offers us some options that I don't think would come through just by trying to auto-generate.  That said, I haven't seen code samples of what that would look like.  Feel free to post some.\nAs of right now, there is a \"roadmap\" of current features/missing features.  The biggest missing feature is Validation.\nThere is still a bit of a flaw in the design of some type registration (for introspection #3), though I'm working through it.  I've been a bit busy on another side project so haven't come back to this yet.\n. Closing this as this is not the route I would like to go (transpiling).\n. Certainly welcome, thanks!  I know @james-andrewsmith was also working on something like this.\nI agree that in almost every scenario you would need/want both sync and async.  I'm partial to the idea of keeping a single resolve though.  I'll pull this down and play with it a bit.\n. Opened #8 \n. :+1: I like that change from Task<T> to Task.  Can you rename the Execute in IDocumentExecutor to ExecuteAsync?  After that I think we can pull this in.\n. Created #16 to track cancellation/timeout\n. Added in #7 \n. Thanks for taking a stab at this, I'll take a closer look.  Note that this project uses Fixie for Unit testing, so the references to NUnit would need to be removed and tests should follow the defined conventions.\n. I'm a resharper user as well - unfortunately the fixie runner only works with ~8.0.  I use a combo of the built-in testing and testdriven.net.\n. @SaltyDH Thanks for your initial work on this.  I'm going to close this issue as mutations themselves do work, as verified in #29 / 3760633.  I'm going to use some of your ideas for work on Input Objects #12\n. @Henrik-R Indeed I would.  Items without a checkmark are available to work on.  I have been using the JavaScript project implementation and test suite as examples.\n. The master branch has all of the latest validation infrastructure and rules, so you can just create a PR branch off of master.  A lot of work had to go into creating the infrastructure for the rules, though now that that base is there most of the other rules should go fairly quickly.  There could however be more work needed in the TypeInfo or ValidationContext classes, though it should be fairly minimal compared to the previous work.\nI can only commit to personally writing 1-2 rules a week right now.\n1. Post here what rule is being worked on.  Provide a separate PR per rule, if possible.\n2. Create new rule, naming it the same as the JS project, add it to the Validation folder.\n3. Add the rule to the list of CoreRules in the DocumentValidator.\n4. Translate all of the JS tests for the given rule to their C# equivalent.\nI would start with the rules that are most important to you, I personally have no preference.\nIf you have a rule completed, though other tests are failing and you're not sure why, feel free to push up what you have and we can figure it out.  There are some core tests that purposefully are sending invalid queries which we may have to \"turn off\" rules for.\nThere is a ValidationTestBase that includes helper assertions for passing/failing rules.\n```\npublic class ScalarLeafTests : ValidationTestBase\n{\n    private readonly ScalarLeafs _rule;\npublic ScalarLeafTests()\n{\n    _rule = new ScalarLeafs();\n}\n\n[Test]\npublic void valid_scalar_selection()\n{\n    var query = @\"\n        fragment scalarSelection on Dog {\n          barks\n        }\n        \";\n\n    ShouldPassRule(_ =>\n    {\n        _.Query = query;\n        _.Rule(_rule);\n    });\n}\n\n[Test]\npublic void interface_type_missing_selection()\n{\n    var query = @\"{\n          human {\n            pets\n          }\n        }\n        \";\n\n    ShouldFailRule(_ =>\n    {\n        _.Query = query;\n        _.Rule(_rule);\n        _.Error(\n            message: _rule.RequiredSubselectionMessage(\"pets\", \"[Pet]\"),\n            line: 3,\n            column: 21);\n    });\n}\n\n}\n```\n. Awesome!  I go off of the list from the JS project:\nhttps://github.com/graphql/graphql-js/blob/master/src/validation/specifiedRules.js#L90-L115\n. I decided to create a new issue for the \"Overlapping fields\" rule so I can pronounce this one complete.  All rules save that one are merged to master!\nOverlapping Fields: https://github.com/graphql-dotnet/graphql-dotnet/issues/160\n. Last of these were published in https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.10.3.478\n. @mwilliamson-firefly As far as I'm aware, no work has been started on this.  There are a few things that could potentially cause issues, though I think its a few days of work.\n. @AdamLynamFirefly I pushed up a start to union support, https://github.com/graphql-dotnet/graphql-dotnet/pull/51.  The route I have been taking is copying over the test cases from the JS project and then altering the document executor until the tests pass.  If you pull down that branch and run the tests it should give you a better idea on what needs to be accomplished.  Looks to be a bug or two in fragment support.  Will also need to be a few changes to __Type's possibleTypes to support Unions (for introspection).  That's all I'm seeing so far ...\n. I was able to fix up the last of the Union support.  I'll pull this in tomorrow and push out a refreshed nuget.\n. Merged to master and pushed to nuget.  https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.5.0\n. Marking this as done for now.\n. I agree that I think just having one ExecuteAsync keep things simple.\n. @james-andrewsmith Thanks for your work on this!  Going to close this as we pulled in the other PR.\n. I think this is a pretty good idea and I think there will be a demand for this.  Are you thinking the wrapper would just build up a traditional Schema and pass that to the Executor?\n. @tlil87 Thinking on this, I'm not sure if I want the convention-based approach in the core repo.  I was thinking that could be a separate Nuget package in it's own repo.  I can create a new repo for that project under the graphql-dotnet org and give you access to it.  I'm sure there needs to be changes to the core project for it to work, though I'm hoping it can be an \"add on\".  This is thinking to the future of also having a MS-SQL centric one, Postgres, etc.  Thoughts on that?\n. @tlil87 Do you have a suggestion for repo name?  Hardest part - naming things.  conventions?\n. @tlil87  Sounds good on the name.\nAs per the Relay items ... I'm much more comfortable with those being in the core repo since I think a high percentage of people who use GraphQL will also use Relay.  I do think having those in a separate namespace though is helpful - GraphQL.Relay.  Perhaps even moving those to a different project inside the core project would be good.  Could break Relay into a separate NuGet if it gets too big though just ILMerge it for now.  As for Date, I for sure want to keep that in the core repo.  That is such a common type I think it makes sense to be there.\nCreated conventions and added you as a team member.  Should have read/write access.\n. > is it set up with AppVeyor at all?\nIs now!\n. @zhech2 The team is GraphQL.\n. @jusefb Here is a sample: https://github.com/graphql-dotnet/conventions/tree/master/samples. I'm going to close this as there are some projects out there that do this now.. Marking this as done with the changes made.\n. I think this looks good.\n. I'm traveling this weekend, will take a look on Monday.  Relates to #10 \n. This has now been superseded by https://github.com/graphql-dotnet/graphql-dotnet/pull/90 - thanks for your initial work @bryanerayner !\n. > I think that some of these optimizations need to happen for GraphQL to be adopted in large-scale production systems that use SQL as a backend store.\nAgreed, very interested.  I've added a few hooks such as the query batching example, though its kind of a stop gap.\nI'm very interested in supporting Dapper and Marten.\nI'm very open to doing a refactor so you could have different types of \"executors\" or plugins.  I can facilitate creating additional projects in the org.. Created a dataloader repo.  https://github.com/graphql-dotnet/dataloader\nIf it turns out that code is super small, I would be fine with it being in the core repo.. Thanks for this report.  Have you verified that nulling out the errors property makes relay happy?\n. Instead of removing it from the json, can you just null out the property?  I need to know if we need different return objects for error vs. non error or if just nulling out the property works.\nvar result = executer.ExecuteAsync(schema, null, request.Query, null, null).Result;\nresult.Errors = null;\nvar resultJson = writer.Write(result);\n...\n. Awesome, thanks!\n. Good catch, thanks!\n. Thanks for this ... can you add a test to verify this behavior?  Then I think we can pull this in.\n. I added a test for the scenario you proposed above in  98c0834.  This appears to be working without this change.  Did you perhaps have a more complicated registration?  Can you provide a code sample of what was not working?\n. Have added some additional changes to master.  Can you re-test and see if there is still an issue?  Going to close this, though feel free to re-open if you find an issue.\n. I haven't tried DateTime object yet so that could certainly be an issue.  As for strings, it doesn't look like those values are getting passed as string values to the API.\nsearchFrom and searchTo values should be wrapped in quotes to be considered valid strings.\n{\n  \"Query\": \"{articles(iql:hund, startIndex:0, pageSize:12, searchFrom:'2013-04-05T23', searchTo:'2013-04-05T23'){name}}\"\n}\n. Was considering this and what I thought I remembered - the core GraphQL spec does not specify a Date object.  You can however define your own custom scalar (as is shown in this example JavaScript implemenation).  Can do the same in this project, something like:\n```\npublic class DateGraphType : ScalarGraphType\n{\n    public DateGraphType()\n    {\n        Name = \"Date\";\n    }\npublic override object Coerce(object value)\n{\n    DateTime result;\n    if (DateTime.TryParse(value.ToString(), out result))\n    {\n        return result;\n    }\n    return null;\n}\n\n}\n``\n. I'm not sure if it is an issue with your application or something else, though the examples you gave are not valid requests.  Thehundvalue foriqlneeds to be surrounded with quotes.  You are also missing an ending)` in the argument list.\nIt looks like the ANTLR grammar does have an issue with 2015-04-05T23:52:05.568Z when using single-tic quotes.  If you change the ' to \" it will work.  This branch/commit shows it working.  The official GraphQL spec calls for double-tic quotes so that was me miss-leading you there.  Sorry about that!\n. > you can see that the full value of Query is embedded in \" \" thus represents a full string\nYes, that Query property is a string, though I am speaking of GraphQL syntax, which is the string of data inside the Query property.\n{\n  \"Query\": \"{articles(iql:hu-nd, startIndex:0, pageSize:5{\nheading\n}\"\n}\nThat query is not valid GraphQL syntax and will not work.  Besides the missing ) again, there is also a miss-match of brackets.  The main issue:  hu-nd needs to be surrounded in quotes to represent a string in GraphQL syntax.\nHere is your GraphQL query which is invalid:\n{\n  articles(iql:hu-nd, startIndex:0, pageSize:5 {\n    heading\n  }\nThis would be your query as valid GraphQL:\n{\n  articles(iql:\"hu-nd\", startIndex:0, pageSize:5) {\n    heading\n  }\n}\nHere is the JSON representation of the query which is expected in the sample project:\n{\n  \"Query\": \"{articles(iql:\\\"hu-nd\\\", startIndex:0, pageSize:5) {heading}}\"\n}\n. I should also mention that your argument setup is also has some issues.\nnew QueryArgument<NonNullGraphType<StringGraphType>>\n{\n  Name = \"startIndex\",\n  Description = \"The Index to start paging from\",\n  DefaultValue = 0\n},\nSince you are setting the startIndex as a StringGraphType the DefaultValue should also be a string value.  You have given it a DefaultValue of 0 which is an integer.\nWith your setup this is still technically invalid:\n{\n  articles(iql:\"hu-nd\", startIndex:0, pageSize:5) {\n    heading\n  }\n}\nAnd should be changed to:\n{\n  articles(iql:\"hu-nd\", startIndex:\"0\", pageSize:\"5\") {\n    heading\n  }\n}\nIf you want to use integers for startIndex and pageSize you can update the arguments to this:\n```\npublic ArticleSearchQuery()\n{\n    Name = \"Query\";\nField<ListGraphType<ArticleType>>(\"articles\",\n    arguments: new QueryArguments(\n        new QueryArgument[]\n        {\n            new QueryArgument<NonNullGraphType<StringGraphType>>\n            {\n                Name = \"iql\",\n                Description = \"The Iql Query\",\n                DefaultValue = string.Empty\n            },\n            new QueryArgument<NonNullGraphType<IntGraphType>>\n            {\n                Name = \"startIndex\",\n                Description = \"The Index to start paging from\",\n                DefaultValue = 0\n            },\n            new QueryArgument<NonNullGraphType<IntGraphType>>\n            {\n                Name = \"pageSize\",\n                Description = \"The size of the page you want to received\",\n                DefaultValue = 10\n            },\n            new QueryArgument<NonNullGraphType<StringGraphType>>\n            {\n                Name = \"searchFrom\",\n                Description = \"The datetime to search from. Format\",\n                DefaultValue = \"searchFrom_FOO\"//DateTime.Now.AddDays(-14).ToString(CultureInfo.InvariantCulture)\n            },\n            new QueryArgument<NonNullGraphType<StringGraphType>>\n            {\n                Name = \"searchTo\",\n                Description = \"The Index to start paging from\",\n                DefaultValue = \"searchTo_BAR\"//DateTime.Now.ToString(CultureInfo.InvariantCulture)\n            }\n        }),\n    resolve:\n        context =>\n            Search((string) context.Arguments[\"iql\"], int.Parse((string) context.Arguments[\"startIndex\"]),\n                int.Parse((string) context.Arguments[\"pageSize\"]),\n                (string) context.Arguments[\"searchFrom\"],\n                    (string) context.Arguments[\"searchTo\"], context));\n}\n\n}\n```\nI think the design of the code for these things can and should be improved so that you get compile-time errors when you miss-match types.  Query validation should also help when that is worked on.  As this project is pretty new (and mostly a one-man-show) there are issues like this.\n. Thanks for this!  I have been working on Input Objects myself (https://github.com/graphql-dotnet/graphql-dotnet/pull/30), though you have some additional items besides that.  I have been going off of tests from the JS project to ensure the same behavior.  Lots of bug fixes.  I did some things a little differently than you.\nWhat I propose is getting my branch into master first then merging / fixing yours.  Will add some other comments inline.\n. Merged my branch to master.\n. @tlil87 I'm fine with the code, though would really like to see some added tests (especially around DateGraphType).\nI think it would also be nice to show some example usages of the new types in the README.  Only the tests holding me up though.\n. Thanks!\nThat is for uploading the test results to AppVeyor for CI.  If you want to run the tests locally through commandline/powershell you can use test-local.ps1 directly or just npm test.\n. That would be a problem!  It seems I recall seeing an issue like that before.  Interesting that CI passed though ...\n. :tada: :shipit:  Thanks for the updates!  Going to merge this unless you have something else coming.\n. The example you show is possible.  The types will get resolved through the Schema.ResolveType func.  Replace that property with a call to your container.\n. Something like that, yes.  Instead of using your container directly you can use a \"service locator\" instead, though it is essentially the same idea.\nInstead of having a func on the Schema that could be changed to a service locator that is injected, though it is basically the same outcome (and that service locator would still need to be registered with your container).\nOpen to suggestions on how to make it better.\n. I am aware of the dislike of service location patterns.  I didn't want dependency injection to be required to use the library, though I did want to support it.  This is why the property is a System.Func.  Having an overloaded ctor that accepted the func would be easy to add.\n. I'll add the ctor overload.  I had thought about putting a Get<T> on the resolve context you are given, though that is closer to that service locator pattern which is considered bad.  With the func as is, you can just add your dependencies to the ctor of your GraphType as you demonstrated.\n. I agree on the interfaces thing.  In #14 there may be a fairly big re-name of types, which is when we'll add in some additional interfaces.\n. @ManishTrivedi There is only one root query object per schema.  You can setup multiple schemas in your GraphQL server and send additional metadata as per which schema should be used.\nInstead of injecting the data class directly into the top level object, you can still have child graph types use dependency injection.  Both the DroidType and HumanType do this.\n. @ManishTrivedi Please do not post on closed issues with questions not related to those specific issues and commits.  Please create a new issue with your question.  You may also get a faster reply if you post on stackoverflow with questions about general programming topics.\n. Today!\nhttps://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.4.0\nhttps://www.nuget.org/packages/GraphQL/0.4.0\n. The following should work for you:\n```\npublic class GraphQLQuery\n{\n    public string Query { get; set; }\n    public Dictionary Variables { get; set; }\n}\nvar request =\n    \"{\\\"query\\\":\\\"query RouteQuery { viewer { routes{ createdOn, machine } } }\\\",\\\"variables\\\":{\\\"one\\\":\\\"two\\\"}}\";\nvar query = JsonConvert.DeserializeObject(request);\n```\n. Closing this, feel free to re-open if you are still having an issue.\n. @mattferrin Inputs, or Input values, and Arguments are different.\n\nField and directive arguments accept input values of various literal primitives; input values can be scalars, enumeration values, lists, or input objects.\nIf not defined as constant (for example, in DefaultValue), input values can be specified as a variable. List and inputs objects may also contain variables (unless defined to be constant).\n\nIn this case, id is an Argument, which has an Input value of type StringValue.\nquery {\n    human(id: \"1\") {\n      name\n      homePlanet\n    }\n }\nIn this case, id is still an Argument and idValue is a variable which also has an Input value type of StringValue.\nquery getHuman($idValue: String) {\n    human(id: $idValue) {\n      name\n      homePlanet\n    }\n }\nYou can use the ToInputs to convert json to an Inputs class.\nUsing the sample GraphQLController using ToInputs should look something like:\n```\npublic class GraphQLController : ApiController\n{\n    private readonly ISimpleContainer _container;\n    private readonly ISchema _schema;\n    private readonly IDocumentExecuter _executer;\npublic GraphQLController()\n{\n    _executer = new DocumentExecuter();\n\n    _container = new SimpleContainer();\n    _container.Singleton(new StarWarsData());\n    _container.Register<StarWarsQuery>();\n    _container.Register<HumanType>();\n    _container.Register<DroidType>();\n    _container.Register<CharacterInterface>();\n    _container.Singleton(() => new StarWarsSchema(type => (GraphType) _container.Get(type)));\n\n    _schema = _container.Get<StarWarsSchema>();\n}\n\npublic async Task<ExecutionResult> Post(GraphQLQuery query)\n{\n    var inputs = query.Variables.ToInputs();\n    return await Execute(_schema, null, query.Query, query.OperationName, inputs);\n}\n\npublic async Task<ExecutionResult> Execute(\n  ISchema schema,\n  object rootObject,\n  string query,\n  string operationName = null,\n  Inputs inputs = null)\n{\n    return await _executer.ExecuteAsync(schema, rootObject, query, operationName, inputs);\n}\n\n}\npublic class GraphQLQuery\n{\n    public string OperationName { get; set; }\n    public string Query { get; set; }\n    public string Variables { get; set; }\n}\n```\nHope that helps, here's the official spec links:\nhttp://facebook.github.io/graphql/#sec-Language.Arguments\nhttp://facebook.github.io/graphql/#sec-Input-Values\nhttp://facebook.github.io/graphql/#sec-Language.Variables\n. I haven't implemented Relay yet myself, though I have heard from others that they have.\n\n1 Any idea of why the relay query fails ?\n\nCan't say without a bit more info.  There are tests that work with fragments, though it is certainly possible you found a bug.  Can you post your full schema?  Do you have a root query object with a node field?  Can you write a failing test in the core project?\n\n2 Do we still need to implement an \"id\" field if the interface defines it ?\n\nYes, just like in C# the interface defines what is available though not the implementation.  In the ResolveType func on the interface you are defining the \"real\" GraphType for GraphQL to use to get the data.\nResolveType = obj =>\n{                                \n    if (obj is DataLayer.User)\n        return userType;\n    throw new Exception(\"Not handeling type: \" + obj.GetType().Name);\n};\n. Closing this.  Feel free to re-open or post a new issue if you can verify a bug.\n. Yes, this is a problem with me bringing in features without tests or examples.  I wouldn't think you would be returning a GraphType.  In every case I can think of you should be returning your actual object.  I don't know that Relay would be different.  @tlil87 do you have a basic example of creating a Relay Schema?\n. Gong to close this, let us know if you have any other questions.\n. Are you just trying to create a basic GraphQL server endpoint?  There is a sample in the codebase which runs GraphiQL.  Have you seen the GraphQLController?\nPictured in the README.\n. Thanks for the feedback.  From your questions it seems you would like more of a \"start from scratch\" guide on how GraphQL works and how to get it configured with this project.  The README shows everything you should need to get started (creating a schema and executing a query), with the code in the tests/sample project showing a fully working solution with dependency injection.  Some answers inline.\n- create a class that implements IDocumentExecuter.\n  You can technically do this, though there is a DocumentExecuter implementation class.  This is all of the core GraphQL logic so doubtful you would ever want to implement this yourself.\n- create a schema class\n  Yes\n- create a query class (only one for all queries?)\n  Yes, your Schema has only one Query object and only one Mutation object.  This is the design of the GraphQL spec.\n- define the graph types that represents our internal schema.\n  Yes\n- Do i need to create a a class that implements ISimpleContainer, or can I use SimpleContainer from the test project?\n  No, you don't need to use ISimpleContainer at all.  ISimpleContainer represents a dependency injection container.  Using dependency injection is optional.\nThere are some other resources out there for learning GraphQL itself, though I found this video a nice example of using the JavaScript implementation.  Of course that is JavaScript, though a lot of the concepts apply to the .NET implementation.\nSome more detailed docs would certainly be nice, though are not on my radar at the moment.  PRs welcome!\nFeel free to post issues with any specific items you run into though.\n. @sachinnshah As mentioned above, have a look at the GraphQLController and GraphiQL project in the codebase.  GraphiQL is a javascript project by the creators of GraphQL that allows you to query a GraphQL api.  https://github.com/graphql/graphiql\n. This blog series has a good introduction walkthrough for getting started.  http://fiyazhasan.me/tag/graphql-dotnet/. Don't need to do this now, though thoughts on moving the Relay specific types to a Relay namespace?\n. Sounds good.  I think it would help people realize what is core GraphQL and what is Relay (including the builders and such).\n. I would certainly like to support DNX.  I haven't tried it yet.  The main dependency that could hold things up is the Antlr runtime.\n. :+1: Right now my highest priorities are:\n- Failing CI when tests fail due to test runner crashing\n- Adding validation\nGoing to update this issue title to reflect this request.  You're welcome to take a stab at it!\n. Have an alpha nuget up on the AppVeyor feed for .NET Core support if anyone wants to give it a whirl.\n0.12.0-alpha-510\nhttps://ci.appveyor.com/nuget/graphql-dotnet\nhttps://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/0.12.0.510/artifacts\nI've tried it with a .NET 4.6.1 console app and a .NET Core console app.\n/cc @tlil87 @baluubas @jquense \n. I went ahead and published 0.12.0-alpha-511 to nuget as well.\n. For simple types you can use a generic, which is a little nicer:\nvar id = context.Argument<string>(\"id\");\nFor complex types, there isn't any specific helper for arguments.  There is however a ToObject<T> extension available on Dictionary<string, object>.  An example test shows it in action.\n```\npublic class MyInput\n{\n    public int A { get; set; }\n    public string B { get; set; }\n    public List C { get; set; }\n}\nvar obj = context.Argument>(\"input\");\nvar myInput = obj.ToObject();\n```\nYou can create an extension method that combines those two together.\n```\npublic static class ResolveFieldContextExtensions\n{\n    public static TType ArgumentAsObject(this ResolveFieldContext context, string name)\n        where TType : class, new()\n    {\n        if (context.Arguments.ContainsKey(name))\n        {\n            var dict = context.Arguments[name] as Dictionary;\n            if (dict != null)\n            {\n                return dict.ToObject();\n            }\n        }\n    return null;\n}\n\n}\nvar myInput = context.ArgumentAsObject(\"input\");\n```\nThat won't help with nested complex types however, the current form of ToObject isn't smart enough for that.  For that, since there isn't anything built-in, your best option is probably to create a model class that represents that data and use JSON.NET to convert it.\n```\npublic class MyDataObject\n{\n  public MyOtherDataObject Property { get; set; }\n}\npublic class MyOtherDataObject\n{\n  ...\n}\nvar json = JsonConvert.SerializeObject(context.Arguments[\"input\"]);\nvar input = JsonConvert.DeserializeObject(json);\n```\nA little dirty but it should work.  You can do the extension method trick with JSON.NET too to make it cleaner.\n. The suggestion above should work. You may also try the ToInputs extension method on string, which tries to handle nested complex objects.\n. @LogikBlitz That sounds pretty good.  The wiki is enabled if you want to add some pages - https://github.com/graphql-dotnet/graphql-dotnet/wiki\n. Closing this as ResolutionArguments now exposes ResolveFieldContext.\n. Are you talking about the Controller in the example?  Use a \"real\" dependency container such as structuremap which can handle all of the container registration in an easier manner.\n. Closing this.  Let me know if that didn't answer your question.\n. Is this not the same as #43 ?\n. You create ObjectGraphType's for non-scalar fields.\n```\npublic class SizeType : ObjectGraphType\n{\n  public SizeType()\n  {\n    Name = \"Size\";\nField<NonNullGraphType<IntGraphType>>(\"height\", \"The height of the size.\");\nField<NonNullGraphType<IntGraphType>>(\"width\", \"The width of the size.\");\n\n}\n}\n```\nYou could also create your own custom scalar.\n```\npublic class SizeScalarType : ScalarGraphType\n{\n  public SizeScalarType()\n  {\n    Name = \"Size\";\n  }\npublic override object Coerce(object value)\n  {\n    var size = (Size)value;\n    return string.Format(\"{0},{1}\", size.Height, size.Width);\n  }\n}\n```\nFor a dictionary it depends on how you want the values output.  All in one field?  Key/Value pairs?  Just the values?  You can create custom ObjectGraphType's or ScalarGraphType's to output whatever you want it to look like.\n. > But I should not be knowing the key of the dictionary in advance. Is there a way to return the dictionary in a generic manner?\nYou are the only one that can answer this question.  With the information you provided I don't know what you're trying to do.  Why are you using a dictionary?  What is in the dictionary?  What are you trying to get out of the dictionary?  What is the key?  Where does the key come from that you're trying to use?  What is the value?  I can't help you without an example of what you're trying to do.\n\nOne thing I have noticed that the HumanType and DroidType need to have all the fields that are present in the CharacterInterface. Is there a better way to do this? Not duplicate fields present in the interface.\n\nYou can create an abstract base class that implements the common properties.\n. Dictionaries aren't specifically supported in the GraphQL spec (only arrays), though there are plans for something in the future.\nDo you want to return everything in the dictionary?  If you want to return all versions I would suggest creating an object that represents the values and convert the dictionary to that object.  Something like this:\n```\n    public class Image\n    {\n        public Dictionary Versions { get; set; }\n    }\npublic class ImageVersion\n{\n    public string Version { get; set; }\n    public string Url { get; set; }\n}\n\npublic class ImageType : ObjectGraphType\n{\n    public ImageType()\n    {\n        Name = \"Image\";\n        Field<ListGraphType<ImageVersionType>>(\"versions\",\n            resolve: context =>\n        {\n            var dict = context.Source as Dictionary<string, string>;\n            return dict.Keys.Select(key =>\n                new ImageVersion\n                {\n                    Version = key,\n                    Url = dict[key]\n                });\n        });\n    }\n}\n\npublic class ImageVersionType : ObjectGraphType\n{\n    public ImageVersionType()\n    {\n        Name = \"ImageVersion\";\n        Field<StringGraphType>(\"version\");\n        Field<StringGraphType>(\"url\");\n    }\n}\n\n```\nThis will allow you to do a query like this:\nquery ImageQuery {\n  versions {\n    version\n    url\n  }\n}\nYou can create a more generic KeyValuePairType (with key and value fields) if you want to have a generic type to use with all dictionaries, though I would probably suggest a specific type.\nIf you don't want every version though only the \"latest\" version or something like that, you can just select the \"first\" item in the dictionary sorted as you like.\nIf you want a specific version you can add an Argument to the field and use that to filter the dictionary.\n. I haven't had a chance to dig into this yet, though I'll see if I can get to it over the weekend.\nI spent entirely too much time investigating a switch to xunit since I thought that would help with some of the build server issues.  It didn't.  I did finally figure out how to properly get it to fail a build with fixie though.\nIn short - I (and everyone else) should be able to trust AppVeyor for branches that are off of the latest master.\n. @tlil87 Would be good to see what you have, I would prefer it in a separate PR though.  Easier to tell what the changes are and easier to review.\n. You can also use context.Argument<T> to avoid additional parsing.\n```\npublic static User CreateUser(ResolveFieldContext context)\n{\n    var gender = context.Argument(\"gender\")\n    var profileImage = context.Argument(\"profileImage\");\nreturn new User { Gender = gender, ProfileImage = profileImage };\n\n}\n```\n. Validation has not yet been implemented.  There is some basic validation in the core engine, though overall validation isn't in yet.  Thats the last major feature left.  https://github.com/graphql-dotnet/graphql-dotnet/issues/10\n. Going to close this.  Thanks!\n. This library does not have a feature like this.  https://github.com/graphql-dotnet/graphql-dotnet/issues/14 is similar, though is convention based on .NET types.  There is currently no plans to add support for generating a schema based on a JSON schema.\nIf I were to add something like this I would probably base it off of the short-hand schema definition that Facebook has provided, as shown here.\n. Input Objects do not have a defined polymorphism as provided by the GraphQL spec.\nhttp://facebook.github.io/graphql/#sec-Input-Objects\nhttp://facebook.github.io/graphql/#sec-Input-Object-Values\nFor shared fields you should be able to do traditional inheritance though.  Does that help?\n```\npublic class NamedInput : InputObjectGraphType\n{\n  public NamedInput()\n  {\n    Field(\"name\");\n  }\n}\npublic class DogInput : NamedInput\n{\n  public DogInput()\n  {\n    Field(\"barks\");\n  }\n}\n```\n. Are you able to provide an example of how you would like to use polymorphic inputs?\n. I've got all of these issues fixed, will be pushing that up soon.  \ud83c\udf89 \n. 0.6.0 published with those changes.\n. Thanks for catching this!\nAntlr4.Runtime.dll and Newtonsoft.Json.dll are embedded for a few reasons:\n- Avoid the need for binding redirects (this is on purpose) - this shouldn't cause any versioning issues - I've been using a framework with a similar setup for years\n- The version of Antlr referenced is a \"pre-release\" version, which some companies have policies against using - embedding it avoids that issue\n- Convenience of having only a single DLL to reference\nIDocumentWriter is not depended on by anything in the framework so it is provided as a convenience only.  I will fix it so it doesn't expose those internal types though and still provide a way to configure indents.  We can add more settings in the future if needed.\nI could perhaps see an argument for not ILMerging Newtonsoft, though I definitely want to ILMerge Antlr.\nI will look into the potential license issue with IL merging.\n. Published 0.6.1 with that updated.\n. Does this happen on startup or after it has been running for a while?\nIt is currently intended for the GraphTypesLookup to be fully populated before execution, though I could see the case of this happening.  I don't think we are explicitly \"warming up\" the lookup cache before execution.\n- I don't think each thread needs its own copy.\n- There could be a bug where the types aren't getting populated during the normal EnsureLookup phase in the Schema class.\n- Assuming you don't have the above issue, you can \"warm up\" the GraphTypesLookup cache before executing any queries.  Perhaps the easiest way to do this now would be to call ISchema.FindType(\"someType\"), or Schema.EnsureLookup().  EnsureLookup is currently public, though it should probably be private or internal.\nYou can use the new SchemaPrinter or an introspection query to print out what the \"default\" registration is.\n. I should mention, the JS project has a way to \"pre-register\" custom types.  We don't have that feature yet, though it would be fairly simple to add.\n. I like the Lazy route as well, will make that change.\n. It looks like this tracks back to ofType on __Type.  It is resolving the generic argument.  It looks like this is currently used to expose QueryArgument<T> types.  Not sure how we want to solve that yet, though that looks like the issue.\nPerhaps we can check if the generic type is of GraphType and return null if not, as an initial thought.\n. I was able to fix this with https://github.com/graphql-dotnet/graphql-dotnet/pull/69\nAll the tests pass at least.\n@tlil87 Let me know if you fixed it differently.\n. The introspection error is probably the same issue.  I will go ahead and merge my change and push out a release.\n\nI had hoped c.GetArgument(\"p\") would work\n\nThis is a separate issue.\n\nHere or in the conventions project\n\nYou would have to be explicitly depending on the conventions project for issues to be from there.  As far as I'm aware, there are no current releases of the conventions project.\n. Published v0.6.4 with that introspection change.\n. Is the type or types that it is failing on the same Enum type?  All of the existing tests we have pass with that change so perhaps we're missing a scenario.\n. @MartinLorensen Thanks for catching this.  I have https://github.com/graphql-dotnet/graphql-dotnet/pull/71 which fixes this and adds a test to ensure there are no further regressions.\n. Made some comments inline.  The other issue is the merge commit.  This branch needs to be rebased on the master branch vs. having a merge commit.\n. Looks like you got this figured out.  \ud83d\udc4d \n. Fixed this in the above while I was in there.  Added a type check in the ctor of QueryArgument so that should be easier to track down if someone hits it again.\n. Fixed with 0.7.0.\n. With my latest changes, I am able to successfully get an enumeration argument.  This is using the Argument<T> off of the ResolveFieldContext.  I think we need to update the logic in GetArgument<T> on ResolutionArguments though.\n. @tlil87 One thing I notice in GetArgument<T> is that it is doing some DefaultValue checking.  The core engine also attempts to populate the Arguments collection if a value isn't provided.  I think that is duplicate logic.\n. This is where that happens: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/DocumentExecuter.cs#L323\n. This should be fixed in 0.9.2.\n. @MartinLorensen Can you see if v0.9.0 fixes this issue for you?\n. Going to go ahead and close this one.\n. I've added https://github.com/graphql-dotnet/graphql-dotnet/pull/77 with the following api:\npublic class MySchema : Schema\n{\n  public MySchema()\n  {\n    RegisterType<MyOtherType>();\n    RegisterType(typeof(MyOtherType));\n    RegisterTypes(new [] { typeof(MyOtherType) });\n    AdditionalTypes = new [] { typeof(MyOtherType) };\n  }\n}\nThink that will work for you?\n. This was published in 0.6.6.\n. That was an oversight, thanks!\n. I recall looking at this previously now.  One of the issues is how the DocumentExecutor is trying to validate Enumerations.  That solution will \"work\", though it hides that issue.  I'm working on fixing that.\n. This should be fixed in v0.8.0 - please re-open if you find an issue.\n. Hey, to have this parsed as a string you need to add quotes around the value.\nmutation { Graph { removeEmployeeFromWorkDay(workDayEmployeeId: \"00000000-0000-0000-0000-000000000000\", workDayId: 10409737, employeeId: 34081, employeeType: Primary) { WorkDayId, WorkDayEmployees { RowId, } } } }\n. Good deal. Indeed that is part of the spec.  StringGraphType maps to a StringValue which requires quotes.  https://facebook.github.io/graphql/#sec-String-Value\n. https://facebook.github.io/graphql/#sec-String may be the better link in this case I guess.\n. Closing this as that fixed your issue. \ud83d\udc4d \n. That is intentional.  You should be able to use UnionGraphType or InterfaceGraphType for dynamic types.\n. Going to close this, let me know if you have any other issues or questions.\n. Sounds reasonable to me. Providing line/column of the query is not yet possible, though will be once I complete the \"language\" updates branch.\n. Got the project updated to the latest GraphiQL and added a JsonConverter for the ExecutionResult.  Think that will work for you?  That will allow us to keep the Exception strategy though then project the error however we want.  I'm thinking this would also allow us to provide a \"debug\" mode which could include a stacktrace and such.\n\n. Published 0.7.0 with this update.\n. That does indeed seem to be a problem, so perhaps switching to a different class structure is still preferable if people want to use their own json serializer.  I was able to get this working using the included DocumentWriter since that references the same types.\n```\npublic async Task Post(HttpRequestMessage request, GraphQLQuery query)\n{\n    var inputs = query.Variables.ToInputs();\n    var result = await Execute(_schema, null, query.Query, query.OperationName, inputs);\nvar httpResult = result.Errors?.Count > 0\n    ? HttpStatusCode.BadRequest\n    : HttpStatusCode.OK;\n\nvar json = _writer.Write(result);\n\nvar response = request.CreateResponse(httpResult);\nresponse.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\nreturn response;\n\n}\n```\n. This should not be an issue now that JSON.NET is not being ILMerged.  Going to close.\n. Did you restore the Nuget packages?  What version of Visual Studio are you using?  The other projects load/compile fine?\n. Here are the options in Visual Studio if you don't have them set:\n\n. \ud83d\udc4d  There is also a visual studio extension that can help with that, but that works.\n. This is superseded by https://github.com/graphql-dotnet/graphql-dotnet/pull/65\n. The deprecatedReason and isDeprecated values will be sent through introspection.  It currently appears that GraphiQL doesn't provide an error if a field is deprecated.\n\nField spec: http://facebook.github.io/graphql/#sec-Object-Field-deprecation\n\nFields in an object may be marked as deprecated as deemed necessary by the application. It is still legal to query for these fields (to ensure existing clients are not broken by the change), but the fields should be appropriately treated in documentation and tooling.\n\nIntrospection spec: http://facebook.github.io/graphql/#sec-Deprecation\n\nTo support the management of backwards compatibility, GraphQL fields and enum values can indicate whether or not they are deprecated (isDeprecated: Boolean) and a description of why it is deprecated (deprecationReason: String).\nTools built using GraphQL introspection should respect deprecation by discouraging deprecated use through information hiding or developer\u2010facing warnings.\n. I'm not sure about in the past, though they're showing up currently for me.  Possibly related to https://github.com/graphql/graphiql/issues/34\n. Closing this for now.. @JarnoNijboer I figured I would break more than what I realized.  \ud83d\ude09  - Published fix in 0.8.1.\n. Fixed in v0.8.2\n. This has to be a particular query.  I'm guessing perhaps your query has the enum value sent as a string vs. just text.  \"Male\" vs. Male?\n\nThere is an example \"enum as input objects\" test here: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Execution/EnumAsInputsTests.cs\nAre you able to verify it is getting sent to the parser correctly and write a failing test?\n. That would do it!  I'll add a test and a fix.\n. Fixed in v0.8.2\n. Thanks for the report!  Indeed it should be an easy fix.  Just need to check if the Value has been created yet on the lazy type before clearing it.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/Schema.cs#L133\n. At least that's what I'm thinking is the problem.  ;]\n. Thanks for the feedback.\n1. The ctor is just an overload.  The Schema class has a ResolveType property that the provided func gets assigned to.  You can re-assign that property on the class and pass it a class function.\n2. The engine requests the type that the particular field needs, which can often be a non-null or a list.  Unfortunately, the current design requires all permutations of those types to be registered, which is kind of dumb.  I Agree with you here.\nAs per more generic dependency injection, let me talk a little about the purpose of the ResolveType func.\nThis is framework stuff.  The GraphQL engine is looking to get an instance of a type to work with.  In other GraphQL implementations, the types are new'd up right away vs. just registering the Type.  Since we're not doing that, we have to have some way to create the type, hence the ResolveType func.  In this framework sense, GraphQL only ever cares about GraphType instances - it won't ever care about anything else.\nPart of the reason to have the resolver though is so you can provide dependencies in the ctor of your GraphType classes that will get resolved.  The engine always wants a GraphType in the end, though that GraphType may have other dependencies.\nI have plans to move away from declaring and tracking Type's and move to instances.  This can be seen in this spike branch https://github.com/graphql-dotnet/graphql-dotnet/pull/91 PR.  Doing so will eliminate the need for any type resolving from the framework and put that onus on the user.\nOne thing to keep in mind is that a GraphQL system only ever needs a single instance of a given GraphType in the system.  What happens right now is when the system \"boots up\" for the first time, it walks the dependency graph and creates a cached list of all of the types in the system.  It only does this once and then pulls the types from the cache.\nNow that all that is said - do you have a scenario where you want some sort of dependency injection that is not constructor based on the GraphType?  Are you looking to do service-location in a field resolve method?\n. If I'm understanding it all, I'm agreeing with @drobertson123 .  We're moving towards an \"instanced\" based api instead of a type-based api (https://github.com/graphql-dotnet/graphql-dotnet/pull/91, https://github.com/graphql-dotnet/graphql-dotnet/pull/181, and I have a new PR in the works as well).  Moving towards an instanced-api will make it easier to build schemas on the fly and would alleviate the GraphQL lib from any type-building concerns.  In short, the core GraphQL engine will not be building any types.  Those would need to be created by the user of the library and passed to the GraphQL engine.\nThat being said, I would expect there to be some other library classes provided that could help building a schema from either C# types or perhaps the defined schema language, plugging in the resolvers.  Those other classes could have some DI hooks.\nExamples of what I'm thinking:\n- https://github.com/matthewmueller/graph.ql\n- makeExecutableSchema from http://dev.apollodata.com/tools/graphql-tools/generate-schema.html\nHere's a spike of a \"Schema Creator\" I made that can take in list of C# types.  Going the opposite route of using the text-schema and adding resolvers is not currently possible with the type-based system as we have it.\n``` csharp\npublic interface IPerson\n{\n    Guid Id { get; set; }\n    string Name { get; set; }\n}\npublic class Person : IPerson\n{\n    public Guid Id { get; set; }\n    public string Name { get; set; }\n}\npublic class Query\n{\n    public IPerson Person()\n    {\n        return new Person { Id = Guid.NewGuid(), Name = \"Quinn\"};\n    }\n}\nvar types = new[] { typeof(IPerson), typeof(Person), typeof(Query) };\nvar schema = TypedSchema.For(types);\nvar printer = new SchemaPrinter(schema);\nConsole.WriteLine(printer.Print());\nvar result = await _runner.ExecuteAsync(schema, @\"\n    query {\n      person {\n        id\n        name\n      }\n    }\n\");\nConsole.WriteLine();\nConsole.WriteLine(result);\n```\n```\ninterface IPerson {\n  id: ID!\n  name: String!\n}\ntype Person implements IPerson {\n  id: ID!\n  name: String!\n}\ntype Query {\n  person: IPerson\n}\n{\n  \"data\": {\n    \"person\": {\n      \"id\": \"e86547f6-d77a-48c3-8849-6f205b5a38cc\",\n      \"name\": \"Quinn\"\n    }\n  }\n}\n``\n. Made a few updates related to this in #362 . Going to close this.  An interface was added in #362 and is available in the 2.0 alpha.. I have been meaning to do this, thanks!\n. PR #100 \u2728 \n. @cable729 Yes, that is correct.  X number of instances ofListGraphType.  TheMyNodeTyperetrieved byListGraphType` will always be the same instance, as was the previous behavior.\nThis alleviates the requirement of having ListGraphType<MyNodeType>, NonNullGraphType<MyNodeType>, ListGraphType<NonNullGraphType<MyNodeType>>, NonNullGraphType<ListGraphType<NonNullGraphType<MyNodeType>>>, etc. all as registered and \"known\" types.\n. This appears to be working on the latest version.  Which version are you currently running?  Can you upgrade and re-test?  Thanks.\n. \ud83d\udc4d \n. I'm not able to duplicate this issue, though I am able to duplicate the opposite - attempting to get an int.  How are you passing the variables to the DocumentExecutor?  Are you using ToInputs?  This tracks back to AstFromValue in the DocumentExecutor.  Whatever value type is passed in as Inputs creates either a IntValue or a LongValue.  ToInputs uses Newtonsoft.Deserialize to convert to a Dictionary, which defaults numbers to longs.\n. It looks like this is also probably related to boxing, discussion on stackoverflow here: http://stackoverflow.com/questions/3541680/strange-casting-behaviour-cannot-cast-object-int-to-long\nI think I found a fix for this and will push it up soon.\n. That would fit then.  Right now, the Argument<T> code just returns default(TType) if an argument key doesn't exist, so that is expected behavior.  I could see how throwing an exception there would make more sense though.\n. Sorry, I did misread.  I'll look at that.\n. Found and fixed a bug in the parser for that one.\n. These should be fixed in 0.9.1, let me know if you find any other issues.\n. \ud83d\udc4d  Please open new issues if you find them!\n. I added a number of tests when I fixed that, though that wouldn't come through with validation errors.  I think that type of validation should be covered by VariablesInAllowedPosition, found here in the JS project, example tests found here.  I can slate that one as the next one to tackle, once I finish the ScalarLeaf tests.\n. Related to https://github.com/graphql-dotnet/graphql-dotnet/issues/74\n. This should be fixed in 0.9.2.\n. @tlil87 Can you tell me if this is what you envision as expected behavior for GetArgument<T> when an \"overriding\" default value is provided?  I'm guessing not ...\nThe overriding default value will only be used if there wasn't a value found in Arguments.  So, if a default value was provided during the Argument creation, then the overriding default value would never be used.\n. A params ctor was added to the QueryArguments class.  That is what is probably giving Autofac trouble.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/QueryArguments.cs#L8-L11\n. That I'm not sure off-hand, I can take a closer look.\n. The StarWars tests use the DI feature, granted with just my SimpleContainer.  As per supporting specific DI frameworks, I will leave that up to PRs since I don't want to guess at (nor support) what people aren't actually using.\nAre you able to post your graph config where you think it is failing?\n. Adding a little logging, this is what I see when executing a query that uses arguments.  This example uses only built-in types - QueryArgument<StringGraphType> - do your arguments include an object that wants injected data perhaps?\n```\n------ Test started: Assembly: GraphQL.Tests.dll ------\nQuery:\n{\n  human(id: \"1\") {\n    name\n    homePlanet\n  }\n}\nBegin Resolving: GraphQL.StarWars.StarWarsSchema\nBegin Resolving: GraphQL.StarWars.StarWarsQuery  <-- contains arguments, using each of params and the IEnumerable ctors\nBegin Resolving: GraphQL.StarWars.StarWarsData\nEnd Resolving: GraphQL.StarWars.StarWarsData\nEnd Resolving: GraphQL.StarWars.StarWarsQuery\nEnd Resolving: GraphQL.StarWars.StarWarsSchema\nBegin Resolving: GraphQL.StarWars.Types.CharacterInterface\nEnd Resolving: GraphQL.StarWars.Types.CharacterInterface\nBegin Resolving: GraphQL.StarWars.Types.EpisodeEnum\nEnd Resolving: GraphQL.StarWars.Types.EpisodeEnum\nBegin Resolving: GraphQL.StarWars.Types.HumanType\nBegin Resolving: GraphQL.StarWars.StarWarsData\nEnd Resolving: GraphQL.StarWars.StarWarsData\nEnd Resolving: GraphQL.StarWars.Types.HumanType\nBegin Resolving: GraphQL.StarWars.Types.DroidType\nBegin Resolving: GraphQL.StarWars.StarWarsData\nEnd Resolving: GraphQL.StarWars.StarWarsData\nEnd Resolving: GraphQL.StarWars.Types.DroidType\nResult:\n{\n  \"data\": {\n    \"human\": {\n      \"name\": \"Luke\",\n      \"homePlanet\": \"Tatooine\"\n    }\n  }\n}\n1 passed, 0 failed, 0 skipped, took 0.79 seconds (Fixie 1.0.0.33).\n``\n. Tested with anInputObjectGraphTypethat used DI and that worked fine.  Either I don't have the right setup or it is Autofac specific.\n. I haven't seen this before and it is working for me locally (F5 through Visual Studio).  Can you provide a bit more info?\n- The full stacktrace\n- Did you restore the nuget packages?\n- How did you run the web project?\n. Ah, no worries.  I'll perhaps change that wording to be \"at the root of the repo\".\n. Currently, this project ILMerge's its own version of Json.NET, so thoseJsonPropertyattributes will only apply if you use theDocumentWriter`.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Http/DocumentWriter.cs\nThose values should always be lowercase to conform to the GraphQL spec.\n. That would be expected if you're not using the DocumentWriter.  You will also have issues with the formatting of errors if you're not using the DocumentWriter.\n. I didn't realize you were using the source code directly and not the Nuget package.  Though my statements still apply. I don't know why its not working in your specific case - I don't know what version you're running or what changes you have made.  You are running an older version of the source.\nThe latest source relies on the formatter settings configured in the DocumentWriter combined with a custom converter on the ExecutionResult class.  An older version of the GraphiQL sample didn't use the DocumentWriter and didn't have the custom converter.\nI would suggest to get the latest source.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/ExecutionResult.cs\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/ExecutionResultJsonConverter.cs\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.GraphiQL/Controllers/GraphQLController.cs\n. You would have to remove the formatter in the DocumentWriter class.  That is not currently possible with the Nuget package.\nNote that the GraphQL spec requires certain properties to be lowercase, such as the errors and data.  There could be others that I haven't ran into due to the use of the formatter.  The errors and data should be taken care of with ExecutionResultJsonConverter though.\n. You could possibly work around this issue by doing:\n1. Create your own DocumentWriter class without the formatter settings\n2. Create a new object with the same properties as ExecutionResult\n3. Create a local copy of the ExecutionResultJsonConverter\n4. Apply that converter to your new object\n5. Use your local DocumentWriter to serialize the result\nThis is currently an issue because JSON.NET is ILMerged with the Nuget.  I will probably stop doing ILMerging sometime in the future to fix this issue and because .NET Core doesn't support it.\n. That is how I built it.  I always try to use camelCase on all of my Apis since they are typically being used by JavaScript.\nI'm willing to review a PR if you want to make it configurable.\n. No, I purposefully set it up so it would always output camelCase.  My opinion is they should always be camelCase.  I would consider registering a field name as PascalCase a bug in my API.  I understand that you want that to behave differently so I'm willing to accept a PR to make that behavior configurable, keeping the current default behavior.\n. > My point is that forcing the response to be camelCase doesn't prevent you from having casing bugs in your API.\nFrom my previous response:\n\nI would consider registering a field name as PascalCase a bug in my API.\n\nAs for Aliases, no, everything should be camelCase.  When you have the requirement that everything should be camelCase, none of those issues apply.\nI've known about this for a long time.  I even went as far as starting to enforce it on field name registration on the vNext spike to ensure uniformity.\nIf you want that feature, write the code and submit it.  Its as simple as that.  That is what Open Source is about.  Collaboration and helping each other.  However, you are exactly right.  If I don't want that feature in this project I have every right to refuse it.  In this case, I would accept code for that feature.\nAll the time you've spent trying to convince me otherwise you probably could have written the code.\n. If I'm understanding you correctly, yes you can manually map field names.\n``` csharp\npublic class PersonEFObject\n{\n  public string FirstName { get; set; }\n  public string LastName { get; set; }\n}\npublic class PersonObjectGraphType\n{\n  public PersonObjectGraphType()\n  {\n    Field(\n      \"name\",\n      resolve: ctx =>\n      {\n        var person = (PersonEFObject)ctx.Source;\n        // or\n        var person = ctx.SourceAs();\n        return string.format(\"{0} {1}\", person.FirstName, person.LastName);\n      });\n  }\n}\npublic class RootQuery\n{\n  public PersonObjectGraphType()\n  {\n    Field(\n      \"person\",\n      resolve: ctx => new PersonEFObject { FirstName = \"Fred\", LastName = \"Flinstone\" }\n  }\n}\n```\nQuery / Result:\n```\nquery {\n  person {\n    name\n  }\n}\n{\n  \"data\": {\n    \"person\": {\n      \"name\":  \"Fred Flinstone\"\n    }\n  }\n}\n```\n. This should be supported - can you also post the GraphQL mutation you are using?  The query language portion of it.\n. The actual GraphQL mutation text that is being sent from the application to the server.\nex:\nmutation M {\n  first: immediatelyChangeTheNumber(newNumber: 1) {\n    theNumber\n  }\n}\n. Thanks, you may have indeed found a bug.  I believe I've been able to duplicate this, will see if it is a quick fix.\n. I don't see a quick fix, though I do believe I see what is happening.  I'll post here once I find a fix.  No ETA for when that will be.\n. @baluubas I just realized what the issue is.\nName = \"MyInput \";\nThe name is defined with a space in it.  If you remove that space, it should be fixed.  I'll see if I can make sure to fix that, though that is probably your issue.\n. This should be fixed with https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.10.0.325\n. Here is the test I wrote to try to try to reproduce: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Bugs/Bug118SpacesInTypeNameTests.cs\n. $input_0:MyInput! is the culprit.  There may be some bad logic there.  Relay likes to add ! everywhere, though seems like that should still be valid in this case.\n. I believe I squashed this.  Can you give v0.10.0.332 nuget a try?\nDownload direct here:\nhttps://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/0.10.0.332/artifacts\nDownload via nuget feed:\nhttps://ci.appveyor.com/nuget/graphql-dotnet\n. Basically just what @JarnoNijboer mentioned.  There isn't a client api, though its as simple as making an http request to the endpoint.  The exact structure of that request depends on the implementation of that endpoint.\nThe sample GraphQL endpoint expects a structure like the above.\n. Down to 20 failing tests.\n. All tests passing with the new parser!  \ud83c\udf89 \n. Unfortunately, there is quite the perf difference parsing the following query.  Thoughts?\n```\nquery SomeDroids {\n   r2d2: droid(id: \"3\") {\n     ...DroidFragment\n   }\nc3po: droid(id: \"4\") {\n     ...DroidFragment\n   }\n}\nfragment DroidFragment on Droid {\n  name\n}\n```\nParse times:\n```\n(100) AntlrDocumentBuilder Time elapsed: 00:00:00.1060146\n(1000) AntlrDocumentBuilder Time elapsed: 00:00:00.0719086\n(10000) AntlrDocumentBuilder Time elapsed: 00:00:00.7042157\n(100) SpracheDocumentBuilder Time elapsed: 00:00:00.2949347\n(1000) SpracheDocumentBuilder Time elapsed: 00:00:01.6270808\n(10000) SpracheDocumentBuilder Time elapsed: 00:00:16.5569542\n```\n. Doing some research last night, this new GraphQL project has its own parser/lexer in C#.  I don't know if its fully implemented, though it looks like it may be.  Comparable perf to Antlr, even faster.  That is running on dotnet core, so perf could be a little different on the full .NET framework.  License for that project is MIT, so hopefully he won't mind if we use it.\n(100) Time elapsed: 00:00:00.0044104\n(1000) Time elapsed: 00:00:00.0496866\n(10000) Time elapsed: 00:00:00.4506858\n. Comparison after @randyridge changes.\n``` diff\n(100) AntlrDocumentBuilder Time elapsed: 00:00:00.1108924\n(1000) AntlrDocumentBuilder Time elapsed: 00:00:00.0848008\n(10000) AntlrDocumentBuilder Time elapsed: 00:00:00.7402738\n-(100) SpracheDocumentBuilder Time elapsed: 00:00:00.2949347\n-(1000) SpracheDocumentBuilder Time elapsed: 00:00:01.6270808\n-(10000) SpracheDocumentBuilder Time elapsed: 00:00:16.5569542\n+(100) SpracheDocumentBuilder Time elapsed: 00:00:00.2610134\n+(1000) SpracheDocumentBuilder Time elapsed: 00:00:00.9174769\n+(10000) SpracheDocumentBuilder Time elapsed: 00:00:09.0484814\n```\n. > Did you try to benchmark that parser explicitly with this use case?\nI used the same query if that is what you mean, and it appeared it was fully populated.\n. I've brought in the code from the other project and it does run crazy fast.  I wrote a converter from its AST to our AST to track down issues.  The parser/lexer suffers from similar issues that we once had, this is what I've found so far:\n- Line numbers are not being tracked directly but are expected to be calculated later, this can be slow and requires the original string to calculate\n- Groups of types such as arguments/directives/object values are not tracking location, so you cannot accurately report location in errors (when compared to the JS project)\n- using float instead of double\n- does not support long numbers\nCurrently 73 tests failing, mostly around validation, due to the line/column issue.\n// this includes converting between ASTs\n(1) GraphQLDocumentBuilder Time elapsed: 00:00:00.0648309\n(10) GraphQLDocumentBuilder Time elapsed: 00:00:00.0008090\n(100) GraphQLDocumentBuilder Time elapsed: 00:00:00.0054521\n(1000) GraphQLDocumentBuilder Time elapsed: 00:00:00.0516097\n(10000) GraphQLDocumentBuilder Time elapsed: 00:00:00.5676733\nI've reached out to the owner of that project to see if he would be interested in a shared nuget that is just the lexer/parser.  So each of our projects could use it and we would have a centralized place to fix bugs and add features.\n. Little bit of elbow grease and I got all the tests passing.  The build needs to be updated and the nuget will be broken, though happy to have a super fast parser.\n. Nice - would be good to look at. We pulled the parser/lexer into its own Nuget and project.\nhttp://github.com/graphql-dotnet/parser\n. @wesamco re C++ - that would be a good idea, though I'm not a C++ dev myself.  I had the same suggestion about a year ago (to the day)  https://github.com/graphql-dotnet/graphql-dotnet/issues/2#issuecomment-134047350 with no takers yet.  My last foray into C/C++ wrappers created scary code.\nHaving it be in C# includes more opportunity for contributors, though I'll still be open to targeting the C++ wrapper if someone makes one.\n. @dNetGuru Using this new parser or the C++ one would mean not using Antlr.  Antlr is a generic language parser/lexer framework.\nLooking at the C++ project again, it looks like it excludes parsing Schema definitions (and won't ever include it according to the author), which this new parser includes.  I'm not doing anything with that right now, though that has me leaning towards this one because of that.\n. @dNetGuru Thanks for taking a stab at it!  I think it would be nice to have a repo up for it.  I would be interested to see it working.  If nothing else it can be revisited once c/cli is supported in .NET Core.  For now sounds like we stick to the C# parser.\n. Thanks for these fixes!\n. \ud83d\udc4d Thanks for these!\n. Thanks for this!\n. Can you update the README.md to include this validation as completed?\n. Also need to add this rule to the DocumentValidator class so that the rule gets applied at runtime.  Should be added after the NoUndefinedVariables rule.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Validation/DocumentValidator.cs#L61\n. Perfect!  Thanks!\n. What @tlil87 and I talked about in https://github.com/graphql-dotnet/graphql-dotnet/issues/14 was having the \"conventions\" as a separate project/nuget.  That way if you're not using those conventions then they're not a part of your project.  Mostly because I can also see conventions for say MSSQL, or Postgres, etc.  We've made changes to the core project to support the scenarios that @tlil87 was facing.  If you need changes to support the enhancements you're making I'd welcome the changes.\n. Going to go ahead and close this.. Thanks, yes that is an issue right now, in that we are not tracking the name as a separate entity.  I have started to fix that with the new parser branch, so we can go back and update these when that is available.\n. Seeing if I can write a unit test to confirm this.\n. @alexmcmillan Test I wrote is passing, so I may have something different than your setup.  Couple questions for you:\n1. What version you are using?\n2. How are you passing the input variables to the executor?  Are you using the .ToInputs() extension method?\n3. Are you able to write a unit test that exhibits this behavior?\n. Yes, that doesn't fail for me.  Are you sure you are running the latest master?\nThis seems similar to https://github.com/graphql-dotnet/graphql-dotnet/issues/118\n. I didn't go through GraphiQL, so I will test it that way.\n. That would do it, and would explain why it doesn't fail for me - I'm running in PST.\n. That works in my time zone as well, so seems like that should be acceptable.  Thanks for tracking that down!\n. Thanks for the report - this is a bug in the Antlr GraphQLVisitor.  It is parsing the number as a float, though then it is getting auto-cast to a double since that is what FloatValue expects.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Language/GraphQLVisitor.cs#L48\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Language/GraphQLVisitor.cs#L112\nChanging those to double.Parse(...) fixes the bug.\n. Thanks - another good find.  I think the StringValue will still need to be handled in the DateGraphType because it would be possible to pass the date directly as an argument parameter and not through a variable.  Such as:\n{\n  something(date: \"2016-06-27T00:00:00.000Z\")\n}\nIn such a case it does not get serialized with JSON.NET.\n. Dates are fun aren't they!  \ud83d\ude2e \n. \ud83d\udc4d :shipit: \n. Can you please provide use cases and unit tests for the enum changes?  Thanks.\n. There is a QueryTestBase which accepts a Schema.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Bugs/Bug138DecimalPrecisionTests.cs\n. You and I have a little bit different take on this.\n\nSchema with every known complicated setup for testing\n\nAlready kind of have this \"acceptance test\" setup elsewhere in the tests, though it is a bit more targeted.\nI have that enum setup already with the StarWars data.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.StarWars/Types/EpisodeEnum.cs\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/StarWars/StarWarsBasicQueryTests.cs#L100-L126\nWhat I would like to see is a more focused test (all in the same file) on why the change is needed, since its not very clear.  Is this actually a bug with how enums are handled with query arguments?\nAdding a test case to the StarWars tests with the setup required to reproduce the issue would also be acceptable.\n. Lets add it to https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Execution/EnumAsInputsTests.cs\nThat has other enum specific tests.  There is a GenderEum setup like:\npublic class GenderEnum : EnumerationGraphType\n    {\n        public GenderEnum()\n        {\n            Name = \"Gender\";\n            Description = \"User gender\";\n            AddValue(\"NotSpecified\", \"NotSpecified gender.\", Gender.NotSpecified);\n            AddValue(\"Male\", \"gender Male\", Gender.Male);\n            AddValue(\"Female\", \"gender female\", Gender.Female);\n        }\n    }\nLets keep that one and add another, or use the existing Star Wars one, that has the values as the actual numbers.\n. @holm0563 CI failed on your branch for some reason, which is why I haven't looked at this too closely yet.  Can you ensure the project builds and the tests pass?  You can run the build/test script locally with npm run build.\n. This PR has been superseded by  https://github.com/graphql-dotnet/graphql-dotnet/pull/177\n. @holm0563 Let me clarify a bit.\nI have no plans to bring in @tlil87 conventions project to the core project.  Way back when, I created that as a separate repo that he could commit to, since I think conventions are a good idea.\nI also have no plans to bring in this new \"convention\" code to the core project.\nWhy?  Once its in this repo, I have to support it.  Please don't take offense, though I've been working on this project for a very long time and you've just started contributing (and thank you by the way!).  Though I have no idea how long you're going to stick around.  I don't want to have to support your code yet.  That is a reality of Open Source, especially on a project that only has 1-2 main contributors.\nSo - this is a perfect thing to have as an add-on to the core project, with a separate nuget package.  I said the same thing to @tlil87 when he was building his last year.\n. I'm going to go ahead and close this now as we have links to your project in the docs.  Thanks for your work!. Hm, maybe those nulls are a bug?  Will take a look.\n. Looks like there is a bug / missing feature.\n... {\n  name\n}\nIs not a currently supported fragment.\n. Got that fixed.  Mind rebasing on master and removing that SelectionSet change?  Thanks!\n. \u2764\ufe0f \n. Thanks for watching the project!\nAs per timeline, I don't have an exact answer for you unfortunately.  The last part of what I would would think of a 1.0 release would be the completion of validation.  There are 5 validation rules left out of 24.  4 of those should take an hour or less each (PRs welcome!).  The 5th could take several days of dev time (merge overlapping fields).  After those 4 rules are done I would basically consider that 1.0.\nI have plans for a new parser.  That will probably get merged before the overlapping fields validation.\nI also have plans for a drastic api change.  That won't happen anytime soon, maybe next year sometime.  Maybe never.\nI do know that some people have this in production already (some for 8+ months).  You'll have to make the choice yourself on when it is ready enough for you.\nNow (over the next month)\n\n4 remaining validation rules\n\nNear future (2-3 months)\n\nNew Parser (dropping Antlr)\ndotnet core support\nPCL support\n\nEnd of year, early next year\n\nOverlapping fields validation\n\nFar into the future, maybe never\n\nInstance-based vs. Type-based api\n. Good news for you, you can use the new parser today with a nuget built from the branch!  I have been keeping the new parser branch up to date with master.\n\nPoint your nuget package file or Visual Studio to:\nhttps://ci.appveyor.com/nuget/graphql-dotnet\nAnd choose a nuget from that branch.  Latest version for that branch is 0.10.2.444.\nOr, you can download the nuget directly: https://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/0.10.2.444/artifacts\n. One thing of note - the project currently ILMerge's the Antlr runtime, so you pretty much shouldn't notice a difference between the two packages.  You would only notice a difference if for some reason you were using the AntlrDocumentBuilder directly.  The current New Parser branch ships with both Antlr and the new one, for compatibility for a release or two.\n. Going to close this as this is pretty out of date.  Thanks!. Thanks for the report - I think perhaps we should be using Trim here.\nprivate string ProcessString(string value)\n{\n    value = value.Replace(\"\\\\\\\"\", \"\\\"\");\n    return value.Trim('\"');\n}\n. That would probably remove the single occurrence of \" ... so would need to include that length check.\n. It looks like this is due to a change in GraphiQL css.\nhttps://github.com/graphql/graphiql/pull/153\nOur example will need to be updated to compensate.\n. Updated our sample to just pull the css from the node module, so this should be less-likely to happen next time.\n. I think you're spot on.  This is the fluent api vs. the non-fluent api.  Once upon a time they had more differences (which caused other issues) and I agree they should come together.\n. Closed in #166 \n. Looks good to me.\n. The Source will stay consistent and that is the route we want to take I believe.  I was spiking on things like that in https://github.com/graphql-dotnet/graphql-dotnet/pull/91.  These updates will make it easier to move to that.\n. @alexmcmillan Interested in giving this version a test in your locale?  Can download the alpha nuget.  https://www.nuget.org/packages/GraphQL/0.12.0-alpha-511\n. @alexmcmillan I know the feeling!  Thanks!\n. Hm, so I think the end goal is to get typed expressions in field declarations and the field resolution.  Can you think of another reason for having the generics?\nI ended up solving that in #91 with using configuration objects and an interface for the field resolution.  I still had a top level ObjectGraphType<T> though it was fairly lightweight and mostly just dealt with the IConfig<T> object.  ObjectGraphType<T> then passed IConfig<T> to ObjectGraphType's constructor, which accepted a IConfig.  IConfig<T> : IConfig.\nWhere it mainly came into play was with the IFieldResolver interface I added.  The FieldResolvers were smart enough to do the type conversion.  Right now the resolve on FieldType is just a Func<ResolveFieldContext, object>.  Switching it to an interface may make some of those issues you're seeing go away.\nSo a fist step towards #91 may be adding that interface to FieldType and seeing where that takes us.\n```\npublic class GraphQLTypeFieldConfig\n{\n    ...\n// with a few more overloads of Field() to create different\n// IFieldResolver instances\npublic void Field<T>(\n    string name,\n    IGraphQLOutputType type,\n    string description = null,\n    string deprecationReason = null,\n    Func<ResolveFieldContext, T> resolve = null)\n{\n    var def = new GraphQLFieldDefinition\n    {\n        Name = name,\n        Description = description,\n        DeprecationReason = deprecationReason,\n        Type = type,\n        Resolver = new FuncFieldResolver<T>(resolve)\n    };\n\n    _fields.Add(def);\n}\n\n}\n// This was the new FieldType in the spike\nvar def = new GraphQLFieldDefinition\n{\n    Name = name,\n    Description = description,\n    DeprecationReason = deprecationReason,\n    Type = type,\n    Resolver = new FuncFieldResolver(resolve)\n};\npublic class GraphQLFieldDefinition\n{\n    public GraphQLFieldDefinition()\n    {\n        Arguments = new GraphQLArgument[0];\n    }\npublic string Name { get; set; }\npublic string Description { get; set; }\npublic string DeprecationReason { get; set; }\npublic IGraphQLOutputType Type { get; set; }\npublic IEnumerable<GraphQLArgument> Arguments { get; set; }\npublic IFieldResolver Resolver { get; set; }\n\n}\n```\n```\npublic interface IFieldResolver\n{\n    object Resolve(ResolveFieldContext context);\n}\npublic interface IFieldResolver : IFieldResolver\n{\n    new T Resolve(ResolveFieldContext context);\n}\npublic class FuncFieldResolver : IFieldResolver\n{\n    private readonly Func _resolver;\npublic FuncFieldResolver(Func<K, ResolveFieldContext, T> resolver)\n{\n    _resolver = resolver;\n}\n\npublic T Resolve(ResolveFieldContext context)\n{\n    return _resolver(context.SourceAs<K>(), context);\n}\n\nobject IFieldResolver.Resolve(ResolveFieldContext context)\n{\n    return Resolve(context);\n}\n\n}\npublic class FuncFieldResolver : IFieldResolver\n{\n    private readonly Func _resolver;\npublic FuncFieldResolver(Func<ResolveFieldContext, T> resolver)\n{\n    _resolver = resolver;\n}\n\npublic T Resolve(ResolveFieldContext context)\n{\n    return _resolver(context);\n}\n\nobject IFieldResolver.Resolve(ResolveFieldContext context)\n{\n    return Resolve(context);\n}\n\n}\npublic class ExpressionFieldResolver : IFieldResolver\n{\n    private readonly Expression> _property;\npublic ExpressionFieldResolver(Expression<Func<TObject, TProperty>> property)\n{\n    _property = property;\n}\n\npublic TProperty Resolve(ResolveFieldContext context)\n{\n    return _property.Compile()(context.SourceAs<TObject>());\n}\n\nobject IFieldResolver.Resolve(ResolveFieldContext context)\n{\n    return Resolve(context);\n}\n\n}\n```\n. Superseded by https://github.com/graphql-dotnet/graphql-dotnet/pull/171\n. Yes, the root \"data\" and \"errors\" must be camelCase and that is part of the spec.  Some of the other introspection may need to be camelCase for GraphiQL to work, though I'm not sure if that's part of the spec.  Right now there could be other issues with the json serialization because in all versions besides the .NET Core alpha Nuget I'm ILMerging JSON.NET.  That could be another issue unless you're using that alpha Nuget.\n. Right now this project has been relying upon the camelCase property names, so additional changes may have to be made to support other property name styles.\n. > the spec does not dictate that the property names of my domain models fields names are camelCased\nAs far as I'm aware, yes that is correct.\n\nWouldn't it be best if GraphQl for .NET could make sure that the property names of the important properties like \"errors\" and \"data\" are always camelCased (as the spec dicates), while just leaving the names of the Fields just as the user of the library entered them\n\nThat is a fine goal though could be harder than it sounds.  Mostly, I'm not sure what the best route to take yet is, as well as ensuring which properties are required to be camelCased and which ones are not.  I am also biased towards camelCase so that is not helping you.  I can sympathize that you want to go that route though it is just not a high priority feature currently.  With the move to .NET Core it is easier to make changes like you did (before it was impossible with the ILMerging).  As other updates progress I have been keeping this feature request in mind (you're not the first to ask), though I can't say when it will be a fully supported feature.\n. I'm going to close this as there are a few libraries that offer this now.. I'm liking this at first look. I would like to pull down the code and play with it a bit, but looking good. \ud83d\udc4d \n. As you've seen, I haven't been able to get to this yet.\nI'm okay with leaving the ToCamelCase for now, as other changes will be required for PascalCase to be fully supported.   I opened an issue on the graphql spec project to clarify their stance on what should be camelCase and what can be PascalCase and still be considered spec.  I say we can wait to do anything further to support PascalCase until I get a response.\nI'll be honest, I don't like the fluent api as much as the other route of just parameters or a configuration object.  I can see how that is messy with dealing with types vs. instances though.\nI want to move to instances eventually.  The major thing I wasn't sure how to solve initially was referencing a type that you may not have an instance of yet.  The Java project solved this by having a special \"named reference\" which gets resolved when the graph is initially built.\nWhat I think the plan should be:\n- get these changes in\n- get the .NET Core changes in\n- move to an instance-based API\n. I have to say I'm not as familiar with Relay in that regard.  I'll have to look at that more myself to know what is needed.\n. \ud83d\udc4d  That is kind of the beauty of the instance-based api.  Since the api will require instances, the responsibility is on the user to provide those instances.  The library doesn't have to deal with resolving them.\nThe way I saw the Java project solve the recursion issue is with something like this:\n```\n    public class GraphQLReference\n    {\n      public GraphQLReference(string name)\n      {\n        Name = name;\n      }\n      public string Name { get; }\n    }\n```\nThen the framework replaces those references after the graph has been built.\n. var DroidType = new ObjectGraphType<Droid>(_ =>\n{\n    _.Name = \"Droid\";\n    _.Description = \"Droid type\";\n    _.Field(new ListGraphType(new GraphQLReference(\"Droid\")), \"friends\");\n});\n. This is what I added for the vNext branch:\n```\n/// \n/// A special type to allow an object/interface to reference itself.\n/// It is replaced with the real type object when the schema is built.\n/// \npublic class GraphQLTypeReference : GraphQLType, IGraphQLOutputType\n{\n    public GraphQLTypeReference(string typeName)\n    {\n        Name = $\"ref({typeName})\";\n        TypeName = typeName;\n    }\npublic string TypeName { get; set; }\n\n}\n```\n. I believe the main purpose would be to allow the creation of classes vs. inline instances.  Otherwise your schema has to be all in one place.\ncsharp\npublic class DroidType : ObjectGraphType<Droid>\n{\n  public DroidType(/* inject dependencies here */)\n  {\n    Name = \"Droid\";\n    Field(new ListGraphType(new GraphQLReferenceType(Name)), \"friends\");\n  }\n}\n. Well, maybe you can just use this there?\n. I think it will still be needed if you want to combine both inline instances with classes.\n``` csharp\npublic ISchema BuildSchema(DroidType droid)\n{\n  var characterInterface = new InterfaceGraphType(=> {\n    .Name = \"Character\"\n    ...\n  });\nvar query = new ObjectGraphType(=> {\n    .Field(characterInterface, \"hero\", () => new Droid());\n  });\nreturn Schema.For(new { Query = query, AdditionalTypes = new [] { droid });\n}\npublic class DroidType : ObjectGraphType\n{\n  public DroidType(IStarWarsData data)\n  {\n    Name = \"Droid\";\n    Field(new ListGraphType(new GraphQLReferenceType(\"Character\")), \"friends\",\n      droid => data.FriendsFor(droid.id));\n  }\n}\n```\n. @jquense Any objections to me pushing these changes combined with the .NET Core support?\n. @jquense Let me rephrase - would you like a different nuget than one that is also for .NET Core.  I'm going to push one for .NET Core that has these changes.\n. The nuget supports multiple frameworks.  The minimum would be 4.5.1 though.\nhttps://www.nuget.org/packages/GraphQL/0.12.0-alpha-536\nOnce I merge the .NET Core code to master (which I want to do here pretty soon), you will also need to have .NET Core installed to develop the project.\n. https://www.nuget.org/packages/GraphQL/0.12.0-alpha-538\nThat one should work with base 4.5.\n. @randyridge Hah, good points.  Being a net standard newb I was just going with the defaults.  It looks like perhaps we can bump netstandard down to 1.1.\n. @holm0563 My apologies that this has lingered here so long.  I want to make sure this works in 2.0. \n Is this still an issue with the latest parser + StringGraphType?. This appears to work, so I'm going to go ahead and close this.\n_.Query = \"query { something(input: { a: \\\"c:\\\\\\\\windows\\\\test\\\", b: 1 }) }\";. I tried 0.7.6 and 0.7.8 on the dotnet-core branch.  Both seemed to work ...\n. Ah, perhaps you upgraded the graphql dependency as well?  It looks like 0.7.0 of graphql does have some breaking changes.\n. Seem like this is an issue with having a wrong GraphType specified in the schema introspection.  #176 \n. I was able to fix the bug that was causing the issue with GraphiQL.  The dotnet core project has been updated to reflect that and I bumped the versions of graphql-js and GraphiQL as well.\nI like this idea.  Were you thinking these would be code samples, ship with the core lib, or ship as a new nuget?\n. I'm going to close this now as some middleware has been made available as a Nuget.. Is that on the GraphQLDeprecatedDirective?  Can you list what version of graphql-js you are using?  That was added to mirror the following in the JS project, though it does seem to have an issue.  Either I did it wrong or something else is up.\nhttps://github.com/graphql/graphql-js/blob/549a2fd1c3cb8acccb4dd0f82eb8e70b2b23346e/src/type/directives.js#L143-L169\n. \ud83d\udc4d  Makes sense, that is probably the bug.\n. Just to clarify for my future self, I added the reason argument on GraphQLDeprecatedDirective as a BooleanGraphType instead of a StringGraphType.\n. Crazily enough, that seemingly innocuous change led to a whole slew of changes that were needed to fix the behavior.  Think I got them all squashed though.\n. This is intended. You have to register those types manually with the Schema. There is a RegisterType method on the Schema class.\n. I want to keep the example in the README super small.  I don't think all of this is needed on the front page.  I'm okay with adding the usings, though I don't want to add more classes.\n. I think it can be updated so that you can just copy-paste the code and have it work.  So having a Droid class and removing the StartWarsData references.\n. ```\nnamespace ConsoleApplication\n{\n    using System;\n    using System.Threading.Tasks;\n    using GraphQL;\n    using GraphQL.Http;\n    using GraphQL.Types;\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n      Run();\n    }\n\n    private async static void Run()\n    {\n      Console.WriteLine(\"Hello GraphQL!\");\n\n      var schema = new Schema { Query = new StarWarsQuery() };\n\n      var result = await ExecuteQuery(\n        schema, @\"\n        query {\n          hero {\n            id\n            name\n          }\n        }\n      \");\n      Console.WriteLine(result);\n    }\n\n  private static async Task<string> ExecuteQuery(\n    Schema schema,\n    string query,\n    object rootObject = null,\n    string operationName = null,\n    Inputs inputs = null)\n  {\n    var executer = new DocumentExecuter();\n    var writer = new DocumentWriter(indent: true);\n\n    var result = await executer.ExecuteAsync(schema, rootObject, query, operationName, inputs);\n    return writer.Write(result);\n  }\n}\n\npublic class Droid\n{\n  public string Id { get; set; }\n  public string Name { get; set; }\n}\n\npublic class StarWarsQuery : ObjectGraphType\n{\n  public StarWarsQuery()\n  {\n    Name = \"Query\";\n    Field<DroidType>(\n      \"hero\",\n      resolve: context => new Droid { Id = \"1\", Name = \"R2-D2\" }\n    );\n  }\n}\n\npublic class DroidType : ObjectGraphType\n{\n  public DroidType()\n  {\n    Name = \"Droid\";\n    Field<NonNullGraphType<StringGraphType>>(\"id\", \"The id of the droid.\");\n    Field<StringGraphType>(\"name\", \"The name of the droid.\");\n    IsTypeOf = value => value is Droid;\n  }\n}\n\n}\n```\nI also just updated the readme to have that code sample, which can just be copy-pasted into a project and ran.\n. Yes, so if you want to support constructor dependency injection, you can't use the default dependency resolver.  You would have to have  a DI container to figure that out for you.  The StarWars samples uses a SimpleContainer for DI so that is why they work.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.GraphiQL/Bootstrapper.cs#L19-L33\n. Going to close this now as there are some docs!\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/docs. @neooleg I would not suggest that example as it is not properly using the .NET Core container.  There is a .NET Core sample in this repo now.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.GraphiQLCore/Startup.cs#L26. @etombi if you have an ObjectType that only takes parameters you will have to use a DI container that knows how to construct it.. Yes, I ended up attempting to keep the same api though still have the core engine rely on instances vs. types.  So right now, you should be able to use both types and instances.  The major piece missing is the self-referencing which I was planning to cherry-pick from here.. This is probably related to https://github.com/graphql-dotnet/graphql-dotnet/issues/176\nThis should be fixed in the latest https://www.nuget.org/packages/GraphQL/0.12.0-alpha-538\nIf you don't want to move to 0.12, you can use this version: https://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/0.11.0.524/artifacts\n. Closing this.  Let me know if it didn't work.\n. The way it currently works follows the reference implementation.  https://github.com/graphql/graphql-js/blob/master/src/type/introspection.js#L241-L253\nYou need to use inputFields to get info about input objects.\nhttps://github.com/graphql/graphql-js/blob/master/src/type/introspection.js#L287-L294\nInputObjectGraphType should not need IsTypeOf since it should not be used as a return type.\n. You can't use fields to query the fields for an input object.  You have to use inputFields.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Introspection/__Type.cs#L109-L113\ndiff\n{__type(name:\"\"InputExample\"\"){\n    name\n    kind\n-    fields{\n+    inputFields{\n        name\n        type{\n            kind\n            ofType{\n                kind\n            }\n        }\n    }\n}}\n. That then returns a list of __InputValue.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Introspection/__InputValue.cs\n. https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Introspection/SchemaIntrospection.cs\nThat file contains an example using fragments and such for introspection.\n. Awesome!  Going to close this.\n. I'm not sure I want to support that behavior in the core engine directly as it seems to contradict the spec.\nThat being said, you should be able to do what you are asking without too much trouble.\n- You can create your own IDocumentBuilder that caches the same document if requested twice (this caching behavior could arguably be in the core project).\n- Your GraphQL endpoint can use IDocumentBuilder to get the Document and IDocumentValidator to validate it. You can then loop over each of its Operations passing the name to the DocumentExecuter.\n- Since you already pre-validated the document, you can pass an empty list for Validation Rules so the document isn't validated a second time.  If null is passed it WILL be validated.\n. Thanks for this!  I'm swamped with a few things currently, will take a closer look at this next week but looking good at first glance.\n. Added with https://github.com/graphql-dotnet/graphql-dotnet/pull/209\n. No, there is not currently an example that uses those.  The subscription type has been added fairly recently, so it should now be possible to add one.\n. @neooleg No, I am not aware of an example yet.. @neooleg Yes you can use the engine outside of a HTTP endpoint.  The GraphQL engine does not rely on any specific transport, so you can use the DocumentExecuter and the DocumentWriter with a WebSocket connection.. Just a note that the official spec does have info about how subscriptions should work now, so that should be implemented execution engine, which it currently isn't.  http://facebook.github.io/graphql/#sec-Subscription. @neooleg my first thought is that the underlying transport would be pluggable, so you would still need something like SignalR for it to work.  The core engine would provide the behavior described in the spec though.. @OneCyrus No, I am not currently working on it.. @lbrolinz This issue will be closed when there is.  It is still Open.. As a small update, #428 by @pekkah has a new SubscriptionExecutor which will provide a basis for subscriptions.  Once that is merged, building an example with websockets should be fairly easy. \ud83c\udf89 . The test can stay where you put it I think.\nIt looks like this tracks back to the __InputValue type, specifically the type field.  It returns the Type property from QueryArgument and FieldType types (which implement IHaveDefaultvalue) which is just a regular ol' .NET Type.  I think what we should probably do is return the \"resolved type\" for that field.\nThat should look something like:\ncsharp\nField<NonNullGraphType<__Type>>(\"type\", resolve: ctx => ctx.Schema.FindType(ctx.Source.Type));\nI think the change you made in the NameFieldResolver is still a potential bug though.  It would be nicer if there was a more clear exception.  Thinking on that, the GraphQL validation should probably catch where a property doesn't exist, so maybe that is not a big issue.  Would you mind adding that exception to NameFieldResolver?\nSo if the property could not be found, throw an ExecutionError with a message like: Expected to find property \"<property name>\" on \"<type name>\" but it does not exist.\n. Thanks for finding/reporting this btw!\n. :+1: Will merge when CI completes. \n. Waiting on rebase. ;]\n. Published a new version which I think should fix this.  Let me know if not.  https://www.nuget.org/packages/GraphQL/0.12.1-alpha-545\n. @rwg0 Thanks for the catch!  Will get that fixed.\n. 0.12.2 should fix that\n. There is a version with .NET Core support on Nuget, it is just marked as pre-release.\n. https://github.com/graphql-dotnet/graphql-dotnet/pull/175 Also has a bit of middleware that you could take inspiration from.\n. Indeed I think that would be a good feature to have.  I haven't quite figured out how we want to go about it yet since that code will be .NET Core specific.  Just as another DLL in the netstandard folder of the nuget sounds the easiest.  I'm hoping the dotnet packager supports that.\n. I'm going to go ahead and close this as this middleware is now available in its own Nuget.. I think the issue is the use of EventsType.  ListGraphType should be sealed.\n. Going to go ahead and close this.  Thanks!. Thanks for this - yes, the issue is .NET Core compatibility.  I think the fix you have is pretty close to what we want.  I think one step further would be to check if the existing DateTime object is UTC and if not to convert it to it instead of just keeping the existing kind.  Can you think of a use case where you wouldn't want it to be UTC?\n. I can see wanting to not force to UTC on input like this.  The DateGraphType does currently force to UTC on output, though if someone needs different behavior they can create their own custom scalar so I guess that is covered.\n. Initial fix with https://github.com/graphql-dotnet/graphql-dotnet/pull/198 - I want to look at this closer though.\n. What I'm thinking the best solution would be is to provide hooks so that you guys, or anyone else, could provide the behavior you want for any type.  Couple that with a custom scalar type and you're good to go.. @rolfwessels This issue is nearing 2 years old.  Have you tried the latest 2.0 pre-release version?  Lots of changes around dates.  It may work as you expect now.. @rolfwessels Are you able to provide a failing unit test, or push an example project to github that demonstrates the issue?  Also a few questions:\n\nWhat GraphType are you using?  DateTimeGraphType or DateTimeOffsetGraphType?\nWhat value are you sending to the server?\nWhat culture is the site running under?. If the .NET type of CreateDate is DateTime then it should be using DateTimeGraphType.  It should always serialize to UTC so that would be expected.  Of course it shouldn't be dropping the time zone though.  DateTimeOffsetGraphType would display the +02:00 format.\n\nSee the examples in #662. That converter should show line numbers with the AST values.  I think we probably just need to add some line numbers for when the exception is thrown, which is outside that Document parser.  We should probably be able to get the numbers from the associated AstNode.\n. Tracking them down.  I think there are a few places - essentially anywhere there is a try/catch.\n. Here are the places I've found where it could be a problem.  Not all of them have access to a Node that would have a specific line/column though.  In that case we may just want to default to 1/1.\n- https://github.com/graphql-dotnet/graphql-dotnet/blob/b35e118f2d9e2a6154bb39498a55bf17d94af16a/src/GraphQL/Execution/DocumentExecuter.cs#L93\n- https://github.com/graphql-dotnet/graphql-dotnet/blob/b35e118f2d9e2a6154bb39498a55bf17d94af16a/src/GraphQL/Execution/DocumentExecuter.cs#L116\n- https://github.com/graphql-dotnet/graphql-dotnet/blob/b35e118f2d9e2a6154bb39498a55bf17d94af16a/src/GraphQL/Execution/DocumentExecuter.cs#L430\n- https://github.com/graphql-dotnet/graphql-dotnet/blob/b35e118f2d9e2a6154bb39498a55bf17d94af16a/src/GraphQL/Execution/DocumentExecuter.cs#L433\n. Yes, the intent was it would only be calculated when an error occurred.  There is some awkwardness there that happened with the move to the new lexer/parser.  I would eventually like to update the lexer/parser to keep track of the line/column so it wouldn't have to be calculated.\nThere is a Location class from GraphQL-Parser that will do the line/column calculation, which is being used in the ValidationError class.  I missed updating the ExecutionError class when that change happened.\nThere is an OriginalQuery property on the Document class that can be used to get the Query.  It may be useful to add that to the ExecutionContext if needed.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Validation/ValidationError.cs#L32-L33\nvar location = new Location(new Source(originalQuery), n.SourceLocation.Start);\nAddLocation(location.Line, location.Column);\nThe WithLocation is currently used to just add a SourceLocation object to a Node.  For exceptions there are two AddLocation methods.\n. Looking at the usages, I think if you add a OriginalQuery property to ExecutionContext, or just add the Document to the ExecutionContext, I think that would make it a little less cumbersome.\n. \ud83d\udc4d This is a case where I wish it could be done with less code but I think it's the right decision performance wise.\n. Not automatic, but you can choose squash and merge or rebase and merge when merging a PR. \n. I am currently adding some instrumentation code, though you won't be able to use that yet.\nHave you checked for any inner exceptions in debug mode?  That sounds like some null references or something like that.\n. The DocumentExecuter runs the DocumentValidator and does not execute if it is invalid.\nAre you running into parse exceptions parsing a Query or errors trying to resolve a field?\nThe ExecutionResult has a list of exceptions that should have full stack traces.  Those stacktraces are not shown when serialized to JSON.\n. Going to close this, let me know if you have further questions.. Sorry about that, yes it appears there are some reference issues in the GraphiQL web project.  I recently did a couple updates that broke this with a clean clone of the project.  It still worked on my machine due to how Visual Studio was referencing old DLLs in the bin folder.  I'll get this fixed.\n. This should be fixed on master now.\nhttps://github.com/graphql-dotnet/graphql-dotnet/commit/3bc2f811d1f16f0e4e473cb3551ac11586c187d5\nThat is normal on windows with Yarn currently.  fsevents still fails if you use npm install it just doesn't give such a big error in the output.\n. @geocine This looks like the related Yarn bug.  https://github.com/yarnpkg/yarn/issues/1285\n. You could probably write your own extension method to allow this.\nHere's an example of what one may look like.\n. Something like:\nvar root = new ObjectGraphType();\n            root.Name = \"Root\";\n            root.FieldAsync(\"\", null, resolve: async context =>\n            {\n                await Task.Run(()=> {});\n                return new SomeObject();\n            });\npublic static void FieldAsync(\n            this IObjectGraphType obj,\n            string name,\n            IGraphType type,\n            Func<ResolveFieldContext, Task<object>> resolve = null)\n        {\n            var field = new FieldType();\n            field.Name = name;\n            field.ResolvedType = type;\n            field.Resolver = resolve != null ? new FuncFieldResolver<object>(resolve) : null;\n            obj.AddField(field);\n        }\n. Sorry, that would be the \"instance\" based API I'm currently working on.  The following should work with what is currently published on Nuget.\ncsharp\nthis.FieldAsync<StringGraphType, SomeObject>(\"name\", resolve: async context =>\n{\n    await Task.Run(() => { });\n    return context.Source.Name;\n});\ncsharp\npublic static FieldType FieldAsync<TGraphType, TSourceType>(\n    this IObjectGraphType obj,\n    string name,\n    string description = null,\n    QueryArguments arguments = null,\n    Func<ResolveFieldContext<TSourceType>, Task<object>> resolve = null,\n    string deprecationReason = null)\n    where TGraphType : IGraphType\n{\n    return obj.AddField(new FieldType\n    {\n        Name = name,\n        Description = description,\n        DeprecationReason = deprecationReason,\n        Type = typeof(TGraphType),\n        Arguments = arguments,\n        Resolver = resolve != null\n            ? new FuncFieldResolver<TSourceType, Task<object>>(resolve)\n            : null,\n    });\n}\nIt may not be apparent in the API, but you can return a Task from a resolver and the framework will await it.\ncsharp\npublic class SomeObjectGraphType : ObjectGraphType<SomeObject>\n{\n    public SomeObjectGraphType()\n    {\n        Field<StringGraphType>(\"name\", resolve: context =>\n        {\n            // this Task will get awaited\n            return Task.Run(() => context.Source.Name);\n        });\n        this.FieldAsync<StringGraphType, SomeObject>(\"name\", resolve: async context =>\n        {\n            await Task.Run(() => { });\n            return context.Source.Name;\n        })\n    }\n}\n. > exceptions will be swallowed\n@xplatsolutions  That doesn't sound good, I'll take a look at this.\n. FieldAsync has been added to the project.. With what is on Nuget and the master branch, no, there is not a way to do that.\nI do have a branch where I believe you can do what you want though.  https://github.com/graphql-dotnet/graphql-dotnet/pull/192  That PR makes a core change to the engine to allow more dynamic types.\nDoes this test look like what you're trying to do?\n. The graph type still needs to be registered with the Schema, though you can create an instance of a type and register that with the Schema, vs. a concrete .NET Type.\n. Right now it adds an additional field called ResolvedType in places that need it.  The core engine then uses that ResolvedType instance instead of the .NET Type.  Overall, it works just like it did before.  It still supports using .NET Types, the core engine is just smart enough to work with instances directly now.\nI am pretty close to getting it merged, though you can use the nuget generated from CI:\nDirect:  https://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/0.13.0.573\nNuget feed: https://ci.appveyor.com/nuget/graphql-dotnet\n. Closing this as the instance support is now in master.. Yes I haven't pushed a version to Nuget with these changes yet.  I will push a new nuget tomorrow.  It will be labeled 0.14.. I'm not sure I'm understanding what you're asking.  Can you elaborate and/or provide some code?\nWould an InterfaceGraphType or UnionGraphType fit your needs?\n. ResolveType may work for you.  IsTypeOf is preferred in most cases since that makes it easier.  When you need more detailed logic, ResolveType may be a better choice.  The caveat is that ResolveType has to be exhaustive, so your Union or Interface has to know every possible type that it can be returned.\n. Going to close this, let me know if you have further questions.. I don't have any strong opinions on the algorithm so I think this is looking great.  I did however just merge a bunch of changes that created some merge conflicts for you.\nI added a new overload to DocumentExecutor which allows you to pass a configuration object to the executor.  This will help us move away from adding just another optional parameter to the execution method.  I would like to add that ComplexityConfiguration to that ExecutionOptions class instead of adding it as an optional parameter.\nSorry about creating conflicts for you!  I think this will be better in the long run though.  Thanks for this work!\n. New execution pattern looks something like this:\n``` csharp\nvar result = await executer.ExecuteAsync( =>\n{\n    .Schema = _schema;\n    .Query = queryToExecute;\n    .OperationName = query.OperationName;\n    .Inputs = inputs;\n    _.Complexity = ... /// your new config\n_.FieldMiddleware.Use<InstrumentFieldsMiddleware>();\n\n}).ConfigureAwait(false);\n``\n. This looks good to me, I like the updates you added.  I did have concerns about performance but those numbers look good to me.  Thanks again for this addition!\n. Closes #185 \n. Thanks!\n. \ud83d\udc4d Looks like CI is failing, possibly related to a newer version of yarn.  Will take a look at that.\n. Not sure what is up with CI but this looks good.\n. Published 0.13.1 with that feature.  https://www.nuget.org/packages/GraphQL/0.13.1.601\n. This seems to be an issue with the new Yarn version, perhaps in combination with the latest node?  How did you install Yarn?  Was it vianpm install -g yarn`?\nThis setup currently works for me:\nnode v6.9.1\nnpm v3.10.6\nyarn v0.17.2 (installed via msi)\n. Thanks for doing some investigation!  Yes, there were some optional dependency issues with Yarn 0.16.1 on windows.  My next guess would be the node version?  I'm honestly not sure.  Our CI build started to fail with the latest version of Yarn as well, so there is some combination of versions that node + yarn + windows aren't playing nice together.\nYou can also download the latest 0.17.2 msi from from the project directly - https://github.com/yarnpkg/yarn/releases\nEither way, Yarn is not required to be used.  You should be able to use npm install and npm start instead of Yarn and be okay.\n. I vaguely recall there being an issue with inheriting from ObjectGraphType<T> and that is why there is duplication.  I could be wrong.\n. @dNetGuru Yes that would be great!. @tlil87 I kind of do want those debug statements, though I can add a different flag for that if/when I need them again.  They helped immensely with the Validation rules.\n. Not currently, no.  That behavior would need to be added here.\n. #222 has been merged. Nice find!  I'm guessing we have that same problem in the DocumentExecuter.. \ud83d\udc4d That sounds good to me.  I created this repo and invited you to it.  https://github.com/graphql-dotnet/relay. Also setup AppVeyor for it - https://github.com/graphql-dotnet/graphql-dotnet/blob/master/appveyor.yml. Those variables get passed through to the field resolver as arguments, so you can just access the value as an argument in your field resolver.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Execution/EnumAsInputsTests.cs#L236\nField<DroidType>(\n  \"hero\",\n  arguments: new QueryArguments(new QueryArgument<Episode> { Name = \"episode\" })\n  resolve: context => {\n    // direct access to the value\n    context.Arguments[\"episode\"];\n    // this will attempt to coerce the from the original to the type given\n    context.GetArgument<MyEpisodeClassOrEnum>(\"episode\");\n    context.GetArgument<int>(\"episode\");\n  }\n);. Welcome!. Closes #208 . Yes you can use DI with a Schema.  Here are two examples:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.GraphiQL/Bootstrapper.cs#L30\nhttps://github.com/joemcbride/marten/blob/graphql2/src/DinnerParty/Bootstrapper.cs#L62-L66. Yes, it is .NET Core compatible.  It currently targets NetStandard 1.1.\nhttps://www.nuget.org/packages/GraphQL/\nHudl has been using a fork of this project in production for close to a year.  The conventions project that @tlil87 recently released is based off of what they are currently using in production.. This project supports any DB or backend.  Here is an example that uses NancyFX + Marten.\nhttps://github.com/joemcbride/marten/tree/graphql2/src/DinnerParty\nhttps://github.com/joemcbride/marten/blob/graphql2/src/DinnerParty/Modules/GraphQLModule.cs. Yep, GraphQL .NET is just a library that you can use with anything.  I'm not sure why you would want to use both FeathersJS (node + REST) + GraphQL .NET?  If you're using node, you can also use GraphQL for node?\nGoing to close this.. Closing after the #238 merge.. Can you add your code for your GraphType?  One issue may be - PascalCase is currently not supported, all fields must be camelCase.. There are no built-in arguments in the core project so first would not exist there.  There does appear to be a bug here since you shouldn't be getting a null reference exception, though the issue probably is that first doesn't exist.. If you can post some sample code that reproduces the null reference that would be appreciated.. Hah, looks like I was able to reproduce this null reference so I'll get that fixed.. I'm just making this example up, though you would need to add those Arguments to the field definition of images.  This is using the core project of course and not that wrapper.\ncsharp\npublic class ImagesQuery : ObjectGraphType\n{\n  public ImagesQuery(IImagesLoader loader)\n  {\n    Field<ListGraphType<ImageGraphType>>(\n      \"images\",\n      arguments: new QueryArguments(new QueryArgument<IntGraphType> { Name = \"first\" }),\n      resolve: context =>\n      {\n        var first = context.GetArgument<int>(\"first\");\n        return loader.LoadImages().Take(first);\n      }\n    );\n  }\n}. That first, last, skip seems to be related to paging.  There is nothing built-in to the GraphQL spec about how that is implemented.  Those are fairly closely related to Relay though.  So if you're planning on perhaps using Relay, you can look at the Relay types provided in the core project and these addtional ones: https://github.com/graphql-dotnet/relay. I do not currently have plans to provide strongly named assemblies.  Perhaps what @jeremydmiller suggested would work?. GraphQL is database/data agnostic.  EF is not required at all and there is nothing in this project that is EF specific.  You can get your data from anywhere and however you want.  That means Sharepoint IS supported.  I'm guessing Sharepoint has some sort of REST api?  Make that API call in your field resolver.. That test does not exist in this project.  I think you meant to post in this other GraphQL project.\nhttps://github.com/ckimes89/graphql-net/blob/981a6edb63726863a1a5d2acf727c5d683080d21/Tests.EF/EntityFrameworkExecutionTests.cs\nThey should be able to help you with that specific project.. Hey, the instance-based dynamic schema is a new feature and you may be running into a limitation.\nOne thing I do notice is that you didn't give a name to fieldGraphType.  Maybe that is the issue?\nfieldGraphType.Name = \"Field1\";\nCan you post your introspection result and your printed schema?\nvar printedSchema = new SchemaPrinter(schema).Print();. One other thing may be that the dynamic type may need to be registered with the Schema directly.  This test shows a dynamic schema being created:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Execution/RegisteredInstanceTests.cs#L111. Part of why I kept this issue open is because I think when the schema is \"built\", it should be looking at the ResolvedType property and make sure it has a valid name and is registered with the Schema.  Since its not currently that is part of the awkwardness.\nThere is no \"validate schema\" behavior currently.  With the previous api it was pretty difficult to create an invalid one.  Until that new behavior I mentioned above is in, the best route to find issues is probably using that SchemaPrinter I mentioned above.\nAs per accessing a \"context\" - you can use the UserContext to inject user-specific data.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#user-context. Sorry for taking so long on this!  \ud83d\udc4d . @JarnoNijboer suggestion appears to be correct.  I think you need to pass an id in your query.  That should fail validation though since the code you posted shows a required argument.  So perhaps there is a bug with that validation rule?\nYou can see a stack trace and the inner error if you run the application in Debug mode and check the Errors on the ExecutionResult.  When the errors are serialized to JSON it currently excludes the inner exception and the stack trace.. :+1: I've had the same frustration of needing to dig deep to figure out what the \"real\" error was.  @tlil87 I'm thinking perhaps a \"debug\" mode that would send full error/stack trace?. @fbrier there is now an ExposeExceptions property on the ExecutionOptions, version 17.3+.. I would look at the http request response.  I would guess the server is returning a non-json result.. This is not an issue with this project but an issue with your setup.  I can't be of much help, especially without you posting more information.. Look at the http response in the browser developer tools.  You are most likely getting some error or html page as a response instead of JSON.\n\n. This was missed with the initial \"instance\" behavior.  Just needs to be fixed!. Published a version with this fix\nhttps://www.nuget.org/packages/GraphQL/0.14.1.638. I currently do not have plans to provide signed assemblies. Can you try the same solution as https://github.com/graphql-dotnet/graphql-dotnet/issues/234 ?. Thanks for this, though Autofac is not preferable to me as the maintainer.  I would welcome a PR to add an example of using Autofac to the docs though.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#dependency-injection. We have a new DI docs section which this could be simplified a bit and added to:  https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs2/site/docs/getting-started/dependency-injection.md. Types need to be registered with the Schema for them to be properly resolved.  There should only ever be a single instance of a given type within the Schema.  AddPossibleType(new UserGraphType()); and var userGraphType = new UserGraphType(); are creating a new instance of the same type.  This should never be done.\nuserGraphType.Fields.Apply(m => m.ResolvedType = Activator.CreateInstance(m.Type));\nYou do not need to write that code if you properly register your types with the Schema.\nIf you need access to a type you should use Dependency Injection.  https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#dependency-injection  You can then use constructor-injection to retrieve the type that you need.\nAlso, instead of using ResolveType on the InterfaceGraphType I would highly suggest using IsTypeOf. That is correct.  If there is no other field that returns the type then you will need to call RegisterType on the Schema.. Right now only lower-case fields are supported.  There are some response fields that are required to be lower-case according to the spec and I haven't designed a way to keep those lower-case while allowing users to define other fields how they want.\nhttps://github.com/facebook/graphql/issues/209. Going to close this as you can now use a IFieldNameConverter.  https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.15.0.671. \ud83d\udc4d  Glad you were able to figure it out!  I believe once upon a time that function was public though looks like it got moved to private.  I would be fine with making it public once again.. @ashleydw I don't believe so, no.. The helper methods are public once again in 0.14.7.  Let me know if that helps!. return new TestComplextOutputType() {Id = \"123\"};\nThat code is not valid.  You need to be returning a DTO class, not a GraphType.\nHow are you passing the variables to the execution engine?  Are you just trying to access the argument variables?\n```\npublic class MyInput\n{\n  public string Name { get;set; }\n  public List Values { get; set; }\n}\npublic class MySubInput\n{\n  public string Label { get;set; }\n  public string Value { get;set; }\n}\ncontext => context.GetArgument(\"testInput\");\n```\nThat should get you your arguments into DTO classes.\nThese tests show a similar scenario.. I think I'm perhaps noticing what the issue is here.  Can you try with the following mutation?  It wraps the values with the list syntax [].  There is code that attempts to wrap a single value in a list, if there is only a single value, though that may be getting tripped up with complex types.\nmutation medirect {\n  createTest(testInput: {name: \"1234\", values: [{label: \"1234\", value: \"4321\"}]}) {\n    id\n  }\n}. The fix for this looks like is more complicated than I thought.  Not sure how to \"properly\" fix it yet.  Thanks for the report!. > Is there a problem with this solution?\nOnly in that there is no DecimalValue in the spec only FloatValue.  So that starts to muddy the waters, which we've kind of already done with LongValue.  We can probably add DecimalValue in the short term.  Long term I would like to provide hooks so that anyone who wants to add custom scalar types could override these behaviors.. > \"Types that translate to the GraphQL spec are handled out of the box. For the rest of the .Net types use this separate library (or turn on this flag)\"?\nThat has kind of been the thinking from the start.  We've just hit a few of these types of \"bugs\" so far so it would be nice if even these \"core\" types were just pluggable.  Turned \"on\" by default but still just pluggable.\n\nWant a PR?\n\nSure thing!. Fix published in https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.14.6.657. Can you post a code example?  I have been using this without issue.  Perhaps it is related to how your system is setup?. @ManuelDeLeon Thanks for taking a look at this!  I think if you only check that the resolver is null, then your middleware (such as metrics) won't get applied to ones that already have a custom resolver which I don't think is what we want.  We could move the ApplyTo to the initialization check.  So it would only apply the middleware upon initialization (which was really the original intent).\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/DocumentExecuter.cs#L94-L100. I'm not sure that I'm following what you're asking for.\nInputObjectGraphType is used with arguments, not with the Source type.  They are not related.  I don't see that an InputObjectGraphType<T> would be helpful other than generating the fields for you.  You can access the arguments via context => context.GetArgument<MyClass>(\"argName\") which gives you a concrete MyClass class.\nIs there something I'm missing?  Can you provide a code example of what issue you're having?. > Can this issue be solved by making the InputObjectGraphType generic?\nYes that can.   My previous comment was to point out that the Source was not related to the Arguments.  Taking your code example that would be InputObjectGraphType<IEnumerable<DataPoint>>, or something like that, if it used the Source. Which is highly unlikely what someone would want.. type QueryRoot {\n  droids: [Droid] //is this a List type? Is it a function that returns a list? does the schema denote how items will be fetched?\n  humans: [Human]\n}\ndroids: [Droid] is a function that returns a List.  The easiest way to think about it is that ALL fields on a Graph type are a function.  GraphQL .NET just makes it easy on you that you don't need to provide a function for just basic properties.  It provides a \"default\" function for you in that case.\nYou can't add a function directly to the Schema.  You can only add functions to a Graph Type.  At the root of your Schema is either a Query, Mutation, or Subscription.  So you could create your own AddGraphQlFunc<List<Droid>>(\"Droids\", Func<Droid>); extension method, though that would need to map to 1 of those 3 \"root types\".\nThis unit test shows an example of dynamically building types and making a query.  It uses an extension method defined in the tests.  Does that help?. Oh, one other note.  GraphQL .NET doesn't do any fetching.  You the developer are responsible for all of your data fetching in the resolve methods for the field.  For a list, you fetch the list of DTOs and return it in your resolve method.  Those DTOs should have the same \"shape\" as your defined Graph type.\n```\nclass Droid // existing DTO\n{\n    public string Id { get; set; }\npublic string Name { get; set; }\n\n// ...\n}\nclass DroidType : ObjectGraphType\n{\n  public DroidType()\n  {\n    Field(\"id\");\n    Field(\"name\");\n  }\n}\n// or\nvar str = new StringGraphType();\nvar droidType = new ObjectGraphType();\nperson.Name = \"Droid\";\nperson.Field(\"id\", str);\nperson.Field(\"name\", str);\nperson.IsTypeOf = type => type is Droid;\nvar root = new ObjectGraphType();\nroot.Name = \"QueryRoot\";\nroot.Field(\n  \"droids\",\n  new ListGraphType(new NonNullGraphType(droidType)),\n  resolve: ctx => new[] {new Droid { Id = \"R2-D2\", Name = \"R2-D2\"}, new Droid { Id = \"K-2SO\" Name = \"K-2SO\"}});\nvar schema = new Schema();\nschema.Query = root;\n```. Going to close this, re-open if needed.  Thanks!. See this example:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/0dc0443ffd9d21673583901d534d47e3fefc3d7e/src/GraphQL.Tests/Execution/RegisteredInstanceTests.cs#L19\nAnd this extension method:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/0dc0443ffd9d21673583901d534d47e3fefc3d7e/src/GraphQL.Tests/Execution/RegisteredInstanceTests.cs#L291\n. Thanks for the unit tests, that makes bugs much easier/faster to fix!\nThis should be fixed in 0.14.4.  https://www.nuget.org/packages/GraphQL/0.14.4.649. Thanks for the report!  I'll take a look.. Published 0.14.3 with this fix.  https://www.nuget.org/packages/GraphQL/0.14.3.646. Btw, the need to register every type with the schema up front should also be fixed.. Going to close this, re-open if needed. Thanks!. \ud83d\udc4d  Will merge once you have that fixed up.. AppVeyor seems to not be happy today ... going to pull it down locally.. Merged and got the version bumped, waiting game on AppVeyor now ... if it doesn't clear I'll get a manual release out.. Finally got a build out. https://www.nuget.org/packages/GraphQL/0.14.5.654. I think the other major part will be possibly needing to upgrade the build process to not use dotnet.exe to pack the nuget.  I haven't looked at what will be needed for that yet or if dotnet.exe is still supported for nuget packing with the .csproj format.  We may need to switch back to nuget.exe or use something else.\nI think my work is also keeping with project.json currently so could be a harder switch for me.. Great news, thanks!  I currently use Rider and VSCode.  I don't think the \"older\" GraphiQL project works in VSCode or Rider (I've been meaning to update it), but the core project does.  I think the trick is to still have the \"older\" dotnet core exe installed.  I'm currently running 1.0.0-preview2-003131.. Closing this as it is now complete.. This should be working with the latest Nuget.  What version are you currently on?  That Coerce syntax is fairly old (5-6 months ago).. Here is our test for that scenario: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Types/StringGraphTypeTests.cs#L34-L38. Going to go ahead and close this.  Let me know if the latest version doesn't work for you.. > I'd lean towards this approach since our GraphQL implementation is already very similar to Facebook's JS implementation so it'd be very familiar to those coming from Node or other implementations\nMy vote would be this for the reasons given.. @drobertson123 That is a good point and I am agreeing 100%.. Since what @johnrutherford has works with the latest base I would vote for starting with that and porting over any missing functionality.. Not sure if it is well known, but the ResolveFieldContext does have a SubFields property which is the fields that should be requested.  It looks like that Dapper.GraphQL may have a bug in that even though a field is in the SelectionSet, it may not necessarily be returned (due to directives mainly).. @TheMoogster 3rd party libraries are handling this, it will most likely not be something built-in to the core framework at this point.. See these resources listed in the docs:\nhttps://graphql-dotnet.github.io/docs/getting-started/databases. Thanks!  I believe the ParseLiteral function of the DecimalGraphType then needs to be updated to support that value, otherwise it won't go through.. Closes #251 . It is named UserContext to match the JavaScript GraphQL project.  The intent is to keep close to those same names so we can use the same verbiage when talking about things.  The User in this sense means \"the user of the GraphQL library\", aka you as the developer.  You can name the class you use as the value of UserContext whatever you like.. Hah, so it appears they are just calling it context now.  So, perhaps it should indeed be updated.. This could lead to a bit of confusion since context has typically been used elsewhere for the \"field resolver context\".\nFrom:\nResolve = async context =>\n  {\n    var userContext = context.UserContext.As<GraphQLUserContext>();\n    var rqf = userContext.HttpContextAccessor.HttpContext.Features.Get<IRequestCultureFeature>();  \n    ...\n  }\nTo:\nResolve = async resolveContext =>\n  {\n    var context = resolveContext.Context.As<GraphQLUserContext>();\n    var rqf = context.HttpContextAccessor.HttpContext.Features.Get<IRequestCultureFeature>();  \n    ...\n  }. Coming back to this I think I'm just going to keep it as is for now.  Thank you for the suggestion though!. There is none that I am aware of. You could be the first! #186. I'm in agreement with @jquense.  As he mentions they should be discrete types.  While I wouldn't be opposed to updating the code to use an interface, I do not want to promote this type of use.. Going to go ahead and close this.  Thanks!. @harrisse What you propose can be done with the code already. (There is an example of that pattern in the mutations docs.)  What would your changes be?. You could use a generic to define the InputObjectGraphType.  As you mention it would perhaps just make refactoring easier.  What we have to today and a generic InputObjectGraphType would be equivalent as far as the engine is concerned.\nWhat was proposed earlier in this PR was to use the same GraphType class for both the input and output graph types, which is against the spec.. @jquense Agreed that could cause issues with how we have it setup. Will take some experimenting and thinking upon to see if it would work without causing a bigger headache.. Because it is a date string, it is probably getting converted to a DateTimeValue, which the StringGraphType does not know how to handle.  Are you able to use the DateGraphType instead of the StringGraphType?  Is there a reason why you want to just use the string?. Thanks for the PR!  There is another issue as well, https://github.com/graphql-dotnet/graphql-dotnet/issues/197, which this fix may tie into.  I want to pull this down and play with it a little bit but I think what you've done will probably work.  I should be able to do that on Friday.  Thanks again!. This fix is now published to Nuget, thanks!. From the docs: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md\n\nGraphQL isn't tied to any specific database or storage engine and is instead backed by your existing code and data.\n\nThis project sticks to the spec as much as possible.  So yes, it supports EF.  This GraphQL implementation is data agnostic.  You can use whatever data store you want.\nThe existing GraphiQL example uses ASP.NET MVC.  I haven't updated it to use ASP.NET Core yet though you should be able to do so with that example?  There has been other community members providing additional code, such as middleware, to work with ASP.NET Core.\n1) What do you think an EF example would provide over the existing in-memory objects example?\n2) This project has supported any data store from the start.  What has lead you to think that EF wouldn't be \"supported\"?\n3) Were you aware of the docs I linked to?\n4) Are you looking for more of a \"pass my EF context to this engine and it should do stuff for me\" behavior?. There's really nothing special that you have to do to use EF.  My EF is rusty so this may not be 100% correct usage, but it should get the idea across.\nThe provided example:\n```csharp\npublic class StarWarsQuery : ObjectGraphType\n{\n    public StarWarsQuery(StarWarsData data)\n    {\n        Name = \"Query\";\n    Field<CharacterInterface>(\"hero\", resolve: context => data.GetDroidByIdAsync(\"3\"));\n}\n\n}\n```\nEF Example:\n```csharp\npublic class StarWarsQuery : ObjectGraphType\n{\n    public StarWarsQuery()\n    {\n        Name = \"Query\";\n    Field<CharacterInterface>(\"hero\", resolve: context =>\n    {\n        using(var db = new MyEfContext())\n        {\n          return (from d in db.Droids\n                 where d.Id == \"3\"\n                 select d).FirstOrDefault();\n        }\n    });\n}\n\n}\n```\nAll you have to do is return the object from your data store to the resolver.\n\nI am looking for a way to easily generate schema from EF context\n\nThis is unfortunately out of scope for the core project.  There are a few \"schema generator\" projects in the works from other community members though.  This one has examples in EF.. I'm going to go ahead and close this one.  I added a link to @JacekKosciesza example in the docs.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#how-do-i-use-xyz-ormdatabase-with-graphqlnet. @bancroftway the great thing about free and open source software is that if you don't think the previous examples are of high enough quality, you have everything at your disposal to do it yourself.  Including writing your own library.  If you have any specific questions about this project let me know.. I just pushed #373 which adds an example mutation to the StarWars sample.\nThis example, of course, is using an in-memory repository of data.  However you save data in EF you would do so in your \"repo\" class.\nClasses of interest:\n```csharp\n/// \n/// This is an example JSON request for a mutation\n/// {\n///   \"query\": \"mutation ($human:HumanInput!){ createHuman(human: $human) { id name } }\",\n///   \"variables\": {\n///     \"human\": {\n///       \"name\": \"Boba Fett\"\n///     }\n///   }\n/// }\n/// \npublic class StarWarsMutation : ObjectGraphType\n{\n    public StarWarsMutation(StarWarsData data)\n    {\n        Field(\n            \"createHuman\",\n            arguments: new QueryArguments(\n                new QueryArgument> {Name = \"human\"}\n            ),\n            resolve: context =>\n            {\n                var human = context.GetArgument(\"human\");\n                return data.AddHuman(human);\n            });\n    }\n}\npublic class HumanInputType : InputObjectGraphType\n{\n    public HumanInputType()\n    {\n        Name = \"HumanInput\";\n        Field>(\"name\");\n        Field(\"homePlanet\");\n    }\n}\npublic class StarWarsData\n{\n    ...\npublic Human AddHuman(Human human)\n{\n    human.Id = Guid.NewGuid().ToString();\n    _humans.Add(human);\n    return human;\n}\n\n}\n```. The above is merged to master and I switched the mutation example in the docs to use that one.\nhttp://graphql-dotnet.github.io/getting-started#mutations. Short answer is no, that is not currently supported.  https://github.com/graphql-dotnet/graphql-dotnet/issues/169. No, I don't think I would want to maintain \"yet another way to register a field\".  Have way too many of those already.\nMy thoughts on solving this issue are kind of similar to your CustomCaseResolver though I would want the GraphQL Engine to handle it and not the JSON Serializer.  This is because I do not think you have enough context in the serializer to know what case a field requires.  So here is what I think should be done - this is semi-pseudo code.\n```\nvar result = await new DocumentExecuter().ExecuteAsync( _ =>\n{\n  .Schema = schema;\n  .FieldNameConverter = new CamelCaseFieldNameConverter();\n...\n}).ConfigureAwait(false);\npublic class CamelCaseFieldNameConverter : IFieldNameConverter\n{\n  public string NameFor(string field, Type parentType)\n  {\n    return field.ToCamelCase();\n  }\n}\npublic class UnchangedFieldNameConverter : IFieldNameConverter\n{\n  public string NameFor(string field, Type parentType)\n  {\n    if( isIntrospectionType(parentType) )\n    {\n      return field.ToCamelCase();\n    }\nreturn field;\n\n}\n}\npublic class PascalFieldNameConverter : IFieldNameConverter\n{\n  public string NameFor(string field, Type parentType)\n  {\n    if( isIntrospectionType(parentType) )\n    {\n      return field.ToCamelCase();\n    }\nreturn field.ToPascalCase();\n\n}\n}\n```\nI'm not sure how much effort adding this feature will be though I think that will allow everyone to have their pick of how field names should be handled.. @pravinhabbu4u just pushed up a spike of the behavior I described in #277.  It should support what you are trying to accomplish.. @pravinhabbu4u I don't ... I am traveling this week so not sure when I can get to it.  If things clear up in the next day or two I'll see if I can do the updates I need and get it pushed.. Thanks!. Thoughts on this @tlil @jquense @pravinhabbu4u ?\nOther idea I have is having a static class with these options.  That way the option wouldn't have to be passed from class to class.  Also with this implementation the \"real\" field name isn't determined until after the Schema is initialized.. @pravinhabbu4u you will need to change the default FieldNameConverter on the config options of ExecuteAsync.  There is a PascalCaseFieldNameConverter and a DefaultFieldNameConverter.  You probably want the \"default\" one.  Currently the CamelCaseFieldNameConverter is registered as the default.  You can also implement your own IFieldNameConverter.. @pravinhabbu4u Great to hear!  I need to do a little more testing on it and I'll wait for any other feedback.. @tlil Good idea to add more tests for those.  We have at least one or two tests that have aliases, though nothing that does checks around casing.. @jquense Looks like your StringUtils library strips _ so that messes with fields like __type. \ud83d\ude1e  . You could theoretically send those headers to the server, build the schema and cache it, then use introspection to determine what is available.  So you would have a schema per CSV.. My suggestion sort of works around the problem.\n\nMake a post to a non-graphql endpoint with the csv information.  Create a schema and give it an ID.  Return the ID in the response.\nMake an introspection post to the graphql endpoint with the ID of the schema you want to use.  Using the information from introspection, build your queries.\nMake subsequent posts to the graphql endpoint, with the ID of the schema to use, with your \"real\" query that is statically typed for the specific CSV file.\n\nYou could technically use graphql in the initial post to the server using a mutation that generated a new schema.  So if you're just sending the whole file to the server that could work.\nAs Jason suggested you could also try a custom Scalar type, maybe coupled with a few arguments to the field on the GraphType that you could use for filtering/querying.. As we've mentioned, the way to extend the GraphQL \"language\" and engine in the way you want is to write a custom scalar.  You shouldn't need to alter the source to accomplish this.\nSomething along these lines:\n```csharp\npublic class DynamicGraphType : ScalarGraphType\n{\n   public DynamicGraphType()\n   {\n       Name = \"Dynamic\";\n   }\npublic override object Serialize(object value)\n   {\n     ...\n   }\npublic override object ParseValue(object value)\n   {\n     ...\n   }\npublic override object ParseLiteral(IValue value)\n   {\n     ...\n   }\n}\nField(\"someField\");\n``. @acronoah You just need to add aIFieldResolver` that knows how to work with dynamics/JObjects.  No need to fork the repo.  The default resolver just uses reflection over properties.  You just have to teach the library how to find the field.\n```csharp\npublic class MyRootType : ObjectGraphType\n{\n    public MyRootType()\n    {\n        Field(\n            typeof(MySubType),\n            \"something\",\n            resolve: ctx =>\n            {\n                return new JObject();\n            }\n        );\n    }\n}\npublic class MySubType : ObjectGraphType\n{\n    public MySubType()\n    {\n        Field(\n            typeof(IdGraphType),\n            \"id\",\n            resolve: ctx =>\n            {\n                // ctx.Source is JObject as defined by ObjectGraphType\n                // and returned in MyRootType\n                return ctx.Source[ctx.FieldName];\n            }\n        );\n    }\n}\n```\nThe Field method is just a helper around AddField, which sets the Resolver property on the FieldType.  You can create your own IFieldResolver to resolve values however you want.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/6385f2b9a7ecf9a1f4c89bfc14e29fa06652c565/src/GraphQL/Types/ComplexGraphType.cs#L59-L78. Just as a note to anyone that may look at this, the errors are currently getting transformed via ExecutionResultJsonConverter.. This is released in 0.17.3. Thanks for the report!  DocumentExecuter should be thread safe, so looks like we need to update the ComplexityAnalyzer to be so as well.. This should be fixed in #707 (Thanks @bittercoder!). The GraphQL spec has the concept of \"Validation Rules\".  They are mentioned briefly in the new docs.  If you want to do a custom check then I would suggest to use a Validation Rule.  Here are all of the existing rules.. I think you should be able to do that (inherit from NonNullGraphType<T>.\ncsharp\n    public class NonNullNonEmptyGraphType<T> : NonNullGraphType<T>\n        where T : GraphType\n    {\n        ...\n    }\nThen can do a check similar to ProvidedNonNullArguments.. Which one are you using and how are you using it?  That error means that a NonNullGraphType is not getting properly unwrapped.  The core engine only wants to register \"root\" types (not ones wrapped in non-null or list), which is what that error means.. It looks like GetNamedType will have to be updated to be more robust.  Right now it seems like it doesn't work with inherited classes.  It appears that it also won't work with the non-generic version.. The more I think on this though I think you could continue to hit issues.  Since I know there are other specific checks + type building with list/non-null.\nPerhaps a better way would be to add meta-data and use that for the validation check?  I have an example of using metadata to provide authorization.\nObject/Field Metadata\nAuthorization Metadata / Validation Rule. And here's a discussion on this issue with GraphQL in general - https://github.com/graphql/graphql-js/issues/361. In general, you can throw an error.  I'm not sure that it comes through very well currently but that is possible.\nAs per providing a better way to handle fine-grained validation, I agree with you that coming up with something more concrete would be nice.  As everyone has their own favorite validation framework I kind of don't want to invent something new myself.  Since the core GraphQL does not provide anything in the spec yet, I see this as an \"add-on\" currently.\nAnother option would be to create a custom Scalar that does validation on the value.\nA reason to not do validation in the resolver is because if your input values do not pass validation there is really no reason to execute the request.  So you should be able to validate those inputs before execution happens so you're not fetching data you don't need to.  That is how the validation rules in the GraphQL spec are currently setup.. @oldnavy1989 All errors in resolvers should be caught by the framework and show up in ExecutionResult.Errors.  If you want to handle it \"closer to the source\", one option would be to use field middleware.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#error-handling\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#field-middleware. Closing this as #342 was merged.. Fixes #252 . I would say add error handling/logging around this method and verify that you're getting the JSON that you're expecting.\ncsharp\npublic static async Task<ExampleCustomerModel> GetSingle_Resolver(string ID)\n{\n  string Resp = await API_Handlers.Get_API_ByID(ID);\n  ExampleCustomerModel API_Resp =  \n                Newtonsoft.Json.JsonConvert.DeserializeObject<ExampleCustomerModel >(Resp);\n  return API_Resp;\n}\nThere is an open issue (#279) that talks about exposing errors better.  Are you possibly getting a generic \"can't resolve xyz field\" error but not seeing the real error?\n\nNote: I never had to have any sort of code to handle deserialization during node implementation.\n\nThat is just a function of a static language like C# vs. a dynamic language like JavaScript.. I'll also add that there are a few \"schema generator\" frameworks currently in the works, perhaps one of those would make it easier for you?\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#schema-generation. Sounds like you got this resolved, going to go ahead and close this issue.. Using ExecuteAsync with a bunch of overloads is the \"legacy\" way of calling that method.  I would suggest to use the newer configuration options as that overload will be removed sometime in the future.  Something like this:\ncsharp\nvar result = await new DocumentExecuter().ExecuteAsync( _ =>\n          {\n            _.Schema = schema;\n            _.Query = graphqlRequest.Query;\n            _.Inputs = new Inputs(graphqlRequest.Variables);\n          }).ConfigureAwait(false);. Inputs inherits from Dictionary<string, object> and takes a Dictionary<string, object> in its constructor, which is why that code is working.  You can simplify to just using the extension method alone.\ncsharp\n_.Inputs = graphqlRequest.Variables.ToInputs();. I don't know, since this isn't an issue with this project.  The sample graphiql project works fine with just using a string as the Variables property.  Others have also said they had issue with that approach, so I can only guess it depends on how you have your project setup.\nWhat this project does require is that the JSON.NET types get converted to \"real\" .NET types instead of the JArray / JObject etc. to populate the Inputs class.  The ToInputs extension method currently accomplishes this.. Since Inputs takes a Dictionary in its constructor you don't need to loop over all of the key/values yourself.\ninputs = new Inputs(graphqlRequest.Variables);. Sorry about this!  Dates suck.  Looks like we missed a Unit test for that scenario.  You may be right that it will be difficult to support both of these use cases.  I would opt for just using DateTime as well.  I say lets get a Unit Test written for the GetArgument scenario and see where that leads.. You have it right.  context.UserContext in resolvers will be populated with the value assigned to _.UserContext.\nI would suggest to create a class so you can add other information later if needed, and you won't have to go back and edit everything.\n```csharp\npublic class GraphQLUserContext\n{\n    public IHeaderDictionary Headers { get; set; }\n}\n_.UserContext = new GraphQLUserContext { Headers = request.Headers };\n```. >Do you already have something to load/convert a __schema response into an ISchema which can be used to validate queries?\nNot currently, no.\n\nDo you know of another way to validate a query against the schema of another graphql server? (like what Graphi does, but in C#)\n\nWhat you propose is the only way I can think of at this moment.. One thing of note.  A separate GraphQL server may have its own custom validation rules.  So you could run the default rules, but the only way to know if its truly valid would be to send it to the other server.. \ud83d\udc4d  This looks good to me.  If @lngr can confirm I'll get this pulled in and a nuget pushed.\nThanks @mamasselin and @cstlaurent for jumping on this so quick!. This is published now https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.15.1.678. Closing as answer was given on stackoverflow.. I don't think there is a good answer to this one yet.\nSome conversations from the JS community:\nhttps://github.com/graphql/graphql-js/issues/223\nhttps://github.com/apollographql/apollo/issues/39\nGraphQL is pretty much designed around a single server architecture currently which makes this a bit harder.  Here are a couple options I can think of:\n\n\nOnly use GraphQL in the gateway\n\nOther microservices are just typical rest+json endpoints\n\n\n\nTry a merged schema\n\nWe don't have a feature to create a schema from introspection currently, so you would be on your own\nAn alternate approach would be to use the \"Schema Language\" and map that to resolvers (kind of like graphql-tools) - also not a feature yet but one I'm pretty interested in (see #362)\nI don't think you need a custom IDocumentExecuter.  You can add field resolvers that proxy to the targeted microservice.  The harder part may be forwarding variables + arguments.\nIf you have types with the same name, you would have to provide some sort of namespacing, or just error.. Filtered data (as in the list of objects that GraphQL will extract fields from) needs to be supplied by you the developer.  For instance, if you have a list of people and you want to only return those who are older than 65 of age, then you the developer needs to do that filtering.. I have double checked that GraphiQL is working on latest master.  Perhaps you need to do a clean and re-build?  Going to close this.. > Is there a reason to have this generic error \"hiding\" the orginal error?\n\n\n\nYes, the idea was to just expose generic errors as to not provide attack vectors.\nWhat I would like to do is have a \"turn on errors\" feature so you can turn on returning the full error during development.  You can still send the \"real\" error to a log file in production.\nRelated: https://github.com/graphql-dotnet/graphql-dotnet/issues/279. > their innerException is lost\nYes, that is on purpose.  You can override the behavior of ExecutionResultJsonConverter and have it expose the inner exception.\nI don't want to introduce a special exception that developers would have to use.  I would instead like to provide what is mentioned in #279, and if that doesn't fit your scenario you can override the ExecutionResultJsonConverter behavior, perhaps with your own IDocumentWriter.. I would be open to having some config settings for #279 that allowed you to just use and/or append the inner exception message and still exclude the stacktrace.  I think that would solve your issue?  Since you could still throw your own exception if you want but have the framework handle the output.. * the line/column should be provided in the error for the fragment so you can trace it back to a resolver\n you can add your own try/catch in your field resolve functions\n you can log or debug and check the inner exceptions for specific exceptions\nPossibly related?  #279 . I'm honestly not sure, I haven't looked at that feature too in depth yet.  @dNetGuru ?. Just want to make a comment.  The purpose of the complexity analysis is to get an estimate of complexity of the query.  Its not designed to use the schema at all.  It should run fast and \"bail out\" fast if the complexity reaches a certain threshold.  We're not going for a super accurate representation just an estimate.. I could see wanting to be able to say \"this particular field is very expensive, please weight this one more\".. @dNetGuru He's talking about the return type of a field.  It is reasonable to want a field that returns a list of objects to have a higher complexity for a field that just returns a scalar.\n\nWhy is complexity analysis run before query validation in document execution conveyor? Are there any risks in validation of malicious queries or validation is considered to be the \"heavy\" operation?\n\nYes, you could send a query that bogged down the validation procedure.  You can also add your own validator which could be a database call.\nThe original intent of feature #185 was to match what Sangria had done, found here: http://sangria-graphql.org/learn/#query-complexity-analysis\nIt appears they allow you to add an optional complexity number to a Field in your Schema.  Doing something similar in our project makes sense.  Whether that is on the Field directly on the Schema, or you do some other registration with the complexity analyzer, I'm open to either.  I think that should be a built-in feature and not something that a user would have to add on their own.. @dNetGuru I don't think he's talking about the field context during the real execution of a query.  Just a new \"context\" class that has the information mentioned.  Kind of like how there is a ValidationContext when working with validation rules.. Here's also a little bit I put together on Authentication/Authorization.. @ujwaliyer Updated:  https://graphql-dotnet.github.io/learn/#authentication-authorization\nAlso see: https://github.com/graphql-dotnet/authorization. Here's how it is done in the Star Wars sample. https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.StarWars/Types/DroidType.cs#L15-L18. \ud83d\udc4d  Mind doing a PR to fix this?. I'm not sure of a good way to run all tests under a specific culture, especially in the .NET Core world.  I would be fine just writing some tests for this specific issue for now.\nHere are some sample tests that use UseCulture and Theory + InlineData to run tests with a specific culture.. This should be fixed in this release https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-793. What use case do you have where a dictionary would be preferable?  So far the list as been working fairly well.  There may be one or two places in the code where doing a dictionary lookup could be faster.  Do you have something specific that you're seeing an issue with or are you just commenting in general?. I'm going to close this. Feel free to re-open with more context.. I believe ValidationContext.TypeInfo.GetLastType() should be the parent.  ValidationContext.TypeInfo has a lot of context for where you are in the graph.. And I'm following the SO tag now.  ;]. Yes you should be able to count on the order.  The DocumentValidator uses a BasicVisitor to traverse all of the INode in the Document.. Looking at the code for TypeInfo it pushes the parent type when it hits a SelectionSet.  So you should be able to add a .Match<SelectionSet> and keep a list of parent types yourself.  You can provide both a enter and a leave actions, so you can remove the type from you list on the leave action.. Going to go ahead and close this. Feel free to reopen if you have additional questions.. Going to close this one as the same issue as #309 . Yes, AppVeyor updated to VS2017 csproj and we're still on project.json.   This can potentially be fixed by adding a global.json until the project is updated to the new csproj format.  See #311. Added the sdk to the global.json file, so if you rebase on master that should be fixed.. Sorry for the delay on this, though I'm concerned that there would be more places that we would need to handle null, which is why it has lingered so long.  Have you looked at the JavaScript implementation to check its usage?. Closing in favor of #374. We do not have a dataloader in this project yet, no.  See https://github.com/graphql-dotnet/graphql-dotnet/issues/264. The framework itself does not do anything to batch field resolves.  Field resolvers should run in parallel though for a given type.  You can return a Task from a field resolver and the framework will wait until all fields for that type are resolved and continue.. No, you don't have to use FieldAsync, FieldAsync just makes it a little easier to return a Task.  If none of you're resolvers are returning a Task, then they probably are all running in sequence.. Related discussion: https://github.com/graphql-dotnet/graphql-dotnet/issues/205. One thing I've noticed is that your ID with the variable isn't ID! which is what the error is saying.  Have you tried changing your mutation to be a non-null variable?. Hi!  Thanks for reporting. We have an issue to track a fix for this. https://github.com/graphql-dotnet/graphql-dotnet/issues/302. As far as I understand, yes this would require VS2017 or VSCode.  I've been deving a lot on the Mac side of things lately so that would be VSCode or Rider.  This will also require some changes to the build scripts.  Any reason for the change to NetStandard 1.3?. Thanks for this btw @OlegZee - My work is still on 2015 as well (for the most part), so I'm in no rush to upgrade yet.  So this may sit for a little while.  I think we may switch here fairly soon, if I had to guess I would say within a Month.. Thanks for the work on this!  I have updated the build scripts in #327 - going to close this one in favor of that one.. This is mostly pseudo code, though I was thinking something more like this:\n```csharp\nvar config = new ComplexityConfig(_ =>\n_.For(\"hero\", ctx => {\n    var limit = ctx.Args(\"limit\");\n    return ctx.childScore * limit;\n  });\n_.Field(\"hero\", ctx => {\n    var limit = ctx.Args(\"limit\");\n    return ctx.childScore * limit;\n  });\n);\n```\nI'm thinking that to target a specific field, you're going to need to know the type.  Since two different types can have the same field name.  So we may end up wanting to do something similar to validation using a INodeVisitor pattern to easily keep track of what type you're currently working with.\nSo the more I think about this it seems like the \"better\" route would be to add this logic to the field itself in the Schema and pull out that data while walking the tree in the complexity analysis.. Added the sdk to the global.json file, so if you rebase on master that should be fixed.. Microsoft got rid of project.json with VS2017.  See #311.. 1. Yes\n2. I do not have an estimate really, other than most likely sometime within the next few weeks.  In addition to just updating the project files the build script also needs to be updated.  So there's some work to be done.. Not in the GraphQL language itself.  You can add arguments, though they are in key/value pairs.\ngraphql\nquery {\n  droid(ids: [1, 2, 3]) {\n    id\n    name\n  }\n}\ncsharp\nField<DroidType>(\n      \"droid\",\n      arguments: new QueryArguments(\n        new QueryArgument<ListGraphType<IntGraphType>> { Name = \"ids\" }),\n      resolve: context =>\n      {\n        var ids = context.GetArgument<List<int>>(\"ids\");\n        return repo.GetDroidsByIdsAsync(ids);\n      }\n    );. There is a feature called Directives which you can use.  There are only a couple of built-in directives - @incldue and @skip.  It is possible to add a custom directive, though you would have to handle the logic for that yourself.\nhttp://graphql.org/learn/queries/#directives. re global.json: I am doubtful that the global.json supports wildcards.  You can have multiple sdks installed at once so I would go that route.  That being said, all of the .json stuff is deprecated  in the .NET world, so once this project is upgraded to the new csproj all of that will be going away.\nSome early comments on this - there is code already available that works with walking a query tree - validation accomplishes this with a BasicVisitor class.  Have a look at the Validation rules.  The associated TypeInfo class handles things such as tracking what GraphType is associated with a given field.  You can re-use some of that infrastructure which would alleviate some of the issues you ran into with creating additional dependencies between classes (such as creating a dependency to the DocumentExecutor).  This would also allow a more declarative programming style which I think would be much easier to maintain.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Validation/DocumentValidator.cs#L47-L56\nDeclarative validation rule:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Validation/Rules/ArgumentsOfCorrectType.cs#L20. No, I do not want this added to the validation code. I am trying to point out is that you can write new code that uses some of the same classes and patterns that validation uses.  I added links to those classes in my previous post.  You can add variable/argument access to that new code.  We also have established patterns for accessing those values so those should be followed, see  GetArgument on the ResolveFieldContext.\nThe TypeInfo class should provide all of the information needed so you wouldn't need that method in the DocumentExecutor.  If it doesn't, the TypeInfo class should be updated so it does.. No, that is not possible.  You can do an alias http://graphql.org/learn/queries/#aliases , but not transform/project.. > Have you thought about that yet or do any other projects allow this?\nI have thought about this.  Enabling this was one of my primary motivations for the \"instance-based\" api.  I have a spike of this somewhere.  What I'm not sure about is what the API should look like in the .NET world for the field resolvers.  Have ideas?. Here is a start for this: https://github.com/graphql-dotnet/graphql-dotnet/pull/362. #362 is merged and there is an alpha of 2.0 available.  Going to close this as complete.. There is not a built-in DictionaryGraphType.  You can create your own input types though.  In general, GraphQL is a very Type specific system.  You can create an input type that matches that signature.  While it may be possible to create a \"Dictionary Graph Type\" I wouldn't really recommend it as that kind of defeats the purpose of GraphQL.\n```csharp\npublic class SearchOptions\n{\n    public List Address { get; set; }\n    public List State { get; set; }\n}\npublic class SearchOptionsType : InputObjectGraphType\n{\n    public SearchOptionsType()\n    {\n        Description = \"Search criteria\";\n        Field>(\"address\");\n        Field>(\"state\");\n    }\n}\npublic class SearchDataType : ObjectGraphType\n{\n    public SearchDataType()\n    {\n      Field(\n        \"data\",\n        arguments: new QueryArguments(new QueryArgument(\"options\")),\n        resolve: context =>\n        {\n            // this is now your strongly-typed DTO (not a GraphQL type)\n            var options = context.GetArgument(\"options\");\n            return Database.Search(options);\n        }\n      );\n    }\n}\n```. No, that is not currently a feature of GraphQL.. I think perhaps your best bet is to have a \"result\" class that you can add that data to.. Going to close this, re-open if needed.  Thanks!. This is what I ended up doing.\nYou can use \"object/field metadata\" to add arbitrary information to either an Object or Field.  You can then use that information and write Validation rules that check for authentication and authorization.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#objectfield-metadata\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#authentication--authorization\nThis ended up looking like:\nField(x => x.Name).AddPermission(\"Some permission\");\nYou could tweak that code a bit to look more like:\nField(x => x.Name).RequiresClaim(\"SomeClaim\", \"SomeValue\");. Going to go ahead and close this.. I'm going to close this.  Re-open if needed.  Btw, I really like your avatar pic @ilya-chumakov \ud83d\ude04 . Please see #186 . Yes this should in theory be working.. Going to go ahead and close this one.. I'm not sure what your scenario is exactly, though I would suggest using an extension method vs. creating that dependency.  I would further suggest to use either traditional inheritance and/or the Union or Interface features of GraphQL.. Any more on this or can it be closed?. I'm pretty sure that skippping null fields would be contrary to the GraphQL spec, so I don't think this is a feature that will be added.  If the user requests a field, as long as that field exists and null is a return value then it will be returned.. Going to go ahead and close this.. How are you passing your variables to the GraphQL .NET Engine?\nThis is how the sample is doing it.. This is what we currently have: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#variables\nAny suggested additions?. I'm pretty sure you should be able to check the Source property in your resolve method.  TypeA should get resolved and passed down to the TypeB resolver.. For custom directives you do the check in the field resolver using the FieldAst field on the ResolveFieldContext.  You could do a \"generic\" implementation by using field middleware.. Here's an example of checking directive values: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/DocumentExecuter.cs#L849-L863. Here's a basic example:\ncsharp\npublic class ToUpperDirectiveFieldMiddleware\n{\n    public async Task<object> Resolve(\n        ResolveFieldContext context,\n        FieldMiddlewareDelegate next)\n    {\n        // the next delegate calls into the \"next\" child middleware\n        var result = await next(context);\n        // check context.Field.Directives + context.Variables to determine if\n        // a directive is being applied\n        // see the GetArgumentValues method in DocumentExecutor\n        var uppercase = false;\n        return uppercase ? result.ToString().ToUpper() : result;\n    }\n}. Its probably in the wrong namespace right now, but that extension method is here:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Instrumentation/FieldResolverBuilderExtensions.cs#L13. Going to go ahead and close this.  Re-open if needed.  Thanks!. GraphQL is originally designed around calling into your service layer and/or other REST services and aggregating those into a single service.  There are a few GraphQL projects out there that convert your GraphQL query into direct SQL commands, though this project is not one of them.  There are many discussions around solving N+1 queries with a service layer.\nSee a few of these links:\nhttp://graphql.org/learn/best-practices/#server-side-batching-caching\n264\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#query-batching\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#projects-attempting-to-solve-n1\nhttps://github.com/facebook/dataloader\n. @Kurren123 I haven't used EF for years so I'm not sure I can be of much help there.  As far as I understand it, I'm not sure that just using Include will get you query batching though.  The above links point to a DataLoader for GraphQL .NET project which does use EF as an example if that is helpful.. I'm going to close this, re-open if needed.  Thanks!. I believe this changed in this release: https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.14.0.633\nWith the release of instance-based schema creation.  This simplified the schema so that it would only store the \"root\" type and not deal with nonull/list types.. > extract graphql schema from Entityframework Core\nI'm not sure what you're asking for.\n\nif it is possible create a sample with (aspnet core + Entityframework core )\n\nHere is a link with an example that uses Entity Framework: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#how-do-i-use-xyz-ormdatabase-with-graphqlnet. A feature like that is beyond the scope of this core project.  The conventions project should work with EF code-first.. All metadata should be supported.  Can you provide an example query of the issue you're having?  Here's some sample queries using introspection: http://graphql.org/learn/introspection/. Going to go ahead and close this.  Feel free to re-open with an example of the issue you're having.. @stephenlautier This is a feature request to add List<T> to GetGraphTypeFromType so it can be used in the Field(x=>x.ListProperty) syntax.. This was fixed in #359 and published in 0.16.0.. Here's some middleware for .NET Core: https://github.com/wesamco/ASP.Net-Core-GraphQL-Middleware. Going to close this as I just added a .NET Core middleware example to the repo.. This is how you add/use arguments: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#arguments. Here's an extension method that can help with registering fields in an instance-based API.. > that might not be supported as standard\nCorrect, that is not standard behavior currently.  The \"default\" behavior is the NameFieldResolver.  You can override that by just setting the resolver.. Here are links to the NerdDinner sample.  IDocumentSession is a class from the Marten project.\nhttps://github.com/joemcbride/marten/tree/graphql2/src/DinnerParty/Models/Schema\nhttps://github.com/joemcbride/marten/blob/graphql2/src/DinnerParty/Modules/GraphQLModule.cs. Thanks for this PR, I will give this a proper review today.. That stacktrace doesn't show any code from this project.  What makes you think the issue is GraphQL .NET?  Is there a more detailed inner exception?. I'm going to close this issue.  Feel free to re-open if you can provide more information.  Thanks!. Possibly related to #298 . Closing this as I am able to run the project in latest VS + Resharper.. My guess is that this is due to there not being a GraphType registered that knows how to render the Droid type.  In this case, use the RegisterType or RegisterTypes method on ISchema.. @negue @spicydonuts There are a few problems with this code.  You basically shouldn't ever be using the AddPossibleType directly.  That perhaps should be an internal method.\nThere are basically two ways to create a Schema.  An \"instanced\" based Schema where you manually new up all of the GraphTypes yourself, and a \"type\" based Schema that may or may not use Dependency Injection.  The sample that @negue posted is mixing the two and its causing issues.\nWhen the Schema is built, it looks at the \"root\" types (Query, Mutation, Subscription) and gathers all of the GraphTypes they expose.  Often when you are working with an interface type, the concrete types are not exposed on the root types (or any of their children).  Since those concrete types are never exposed in the type graph, the Schema doesn't know they exist.  This is what the RegisterType on the Schema is for.\nSo yes, you are adding Interface<CharacterInterface> to say DroidType, though DroidType isn't in the type graph itself, only the CharacterInterface is.\nBy using RegisterType<>, it tells the Schema about the specific type and it will properly add it to the PossibleTypes collection on the interface when the Schema is initialized.\nSort of related, see the docs for IsTypeOf and ResolveType for how interface types figure out what concrete type to use.\n. @negue I believe this should fix that issue.\n```diff\npublic class TestSchema : Schema\n{\n    public TestSchema()\n    {\n        Query = new TestQuery();\n\nRegisterTypes(new MyClass1GraphType(), new MyClass2GraphType());\nRegisterType();\nRegisterType();\n    }\n}\n\npublic class TestQuery : ObjectGraphType\n{\n    public TestQuery()\n    {\n        Field>(\"entries\", resolve: ctx => new IMyType[]{\n            new MyClass1(),\n            new MyClass2()\n        });\n    }\n}\npublic interface IMyType\n{\n    int Id { get; }\n}\npublic class InterfaceType : InterfaceGraphType\n{\n    public InterfaceType()\n    {\n        Field(x => x.Id);\n\nAddPossibleType(new MyClass1GraphType());\nAddPossibleType(new MyClass2GraphType());\n    }\n}\n\npublic class MyClass1 : IMyType\n{\n    public int Id => 1;\npublic string StringInClass1 => \"Class 1\";\n\n}\npublic class MyClass2 : IMyType\n{\n    public int Id => 2;\npublic string StringInClass2 => \"Class 2\";\n\n}\npublic class MyClass1GraphType : ObjectGraphType\n{\n    public MyClass1GraphType()\n    {\n        Field(x => x.Id);\n        Field(x => x.StringInClass1);\n    Interface<InterfaceGraphType>();\n}\n\n}\npublic class MyClass2GraphType : ObjectGraphType\n{\n    public MyClass2GraphType()\n    {\n        Field(x => x.Id);\n        Field(x => x.StringInClass2);\n    Interface<InterfaceGraphType>();\n}\n\n}\nvar query = @\"{\n    entries {\n      id\n    }\n}\";\nvar executer = new DocumentExecuter();\nvar result = await executer.ExecuteAsync( =>\n{\n    .Schema = new TestSchema();\n    _.Query = query;\n});\n``. @spicydonuts If you are using the type-based API for building your schema, you don't have to use the instance-based API ofRegisterTypes.  TheSchemawill call theresolveType` for you.  https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/Schema.cs#L163\n```diff\npublic StorefrontSchema(Func resolveType)\n        : base(resolveType)\n{\n  Query = (StorefrontQuery)resolveType(typeof(StorefrontQuery));\n\nRegisterTypes(\nresolveType(typeof(StorefrontDealInterface)),\nresolveType(typeof(StorefrontDealLiveType))\n);\nRegisterType();\nRegisterType();\n// or\nRegisterTypes(new[]{ typeof(StorefrontDealInterface), typeof(StorefrontDealLiveType) });\n}\n```. @justRu Its not, I'm adding it to the interface section.. In the docs!\n\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#registertype. @negue The other bug in your code:\ndiff\n-Interface<InterfaceGraphType>();\n+Interface<InterfaceType>();. Finally got this published. https://www.nuget.org/packages/GraphQL/0.16.0. Thanks for the question, pretty much a duplicate of #291 . I currently do not have plans to provide signed assemblies.  Hopefully you can use the same solution as #234.. Similar issue as with https://github.com/graphql-dotnet/graphql-dotnet/issues/336. @Karnich see https://github.com/graphql-dotnet/graphql-dotnet/pull/342. This is now released https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.16.1.705. I don't know Relay myself.  I would suggest to have a look at https://github.com/graphql-dotnet/relay. I have certainly had the same thought.  They were originally added by contributors.  Here are some tests that may help with usage:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Builders/ConnectionBuilderTests.cs. I am also vaguely recalling that someone had to add ConnectionType<> and EdgeType<> to their DI container for types to be resolved through DI.. See #451. @mule  Thanks for the PR! #302 was not closed ... there was a duplicate report that was closed though.  Can you please add tests that run this code under a non-US culture to verify this behavior?. Yes, this PR was superseded by #434 . @Jonatthu You don't.  The framework has access to them, though the field resolvers currently do not.. Adding a note here: I was partially wrong in my previous statement that you don't have access to sub selections.  You DO have access to ResolveFieldContext.FieldAst.SelectionSet, which has the selections.  Those selections are not filtered by directives nor are fragments expanded, but you can get at the raw selections there.. Also, a limitation of having this feature (getting a list of child fields) is that it won't work with fields that return abstract types (interfaces and unions).  This is because the framework doesn't know what GraphType to use for the child selections until the parent resolver has returned a value.  Could perhaps provide a ResolveFieldContext.GetChildFields(object source) which took an object so that could be determined, though that may undermine the point of the feature (fetch child fields at the same time as the parent?). 2.0 now provides a SubFields property in the resolver context.  There was also a major restructuring to support the DataLoader pattern, which also supplies parent node information.\nSee the docs on DataLoader: https://graphql-dotnet.github.io/dataloader/\nAnd this tutorial: http://fiyazhasan.me/tag/graphql-dotnet/\nThis project is also attempting to solve the query issue: https://github.com/landmarkhw/Dapper.GraphQL. Can you provide example input values of it failing?  Even better, a unit test for it?. @phischepi at first glance I'm noticing the request is sending non-null LoginType argument and your query is not defined as such.  Can you try adding non-null to your query argument definition on the input?. Other possible issue.  I see you're not using the built-in conversion to the Inputs class.  That conversion converts JObject values to actual .NET types.  So the engine may be hanging up on that.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/getting-started.md#variables\nSo query.Variables should be raw JSON vs. a Dictionary<string, object> that contains JObject values.\n```csharp\nvar inputs = variablesJson.ToInputs();\nvar result = await executer.ExecuteAsync( =>\n{\n    .Inputs = inputs;\n});\n```\nYou may also call GetValue manually if needed.. You can also pass the JObject to GetValues.  Though may need to configure the Serializer settings to match that of the ToInputs method.. Going to go ahead and close this, re-open if needed.  Thanks!. There is not, though it is a feature I'm very interested in having.  See #317 . All mutations have to return a value. That is part of the GraphQL spec.  Take a look at the mutations section at http://graphql.org/learn/queries/ for how to execute a mutation.  Essentially, just change the \"query\" keyword to \"mutation\" and set your root mutation object on your Schema.\n. Yes, if you are using any sort of dependency injection then something like container.Singleton(new StarWarsSchema(type => (GraphType) container.Get(type))); is required.  That gives the Schema class a func that it can use to resolve types in your DI container.\nThe SimpleContainer class is just that - very simple, and I would not be surprised if you ran into bugs or issues with it.  I would not suggest to use it for any sort of production application.  I would suggest to use a different container such as StructureMap.\nThat being said, the SimpleContainer expects every type to be registered with the container, such as in the example.  Have you registered both your InnerType and the Service2 with the container?. That should be calling this method on the Schema class and this method on the SimpleContainer class.  Does your Schema class have a different constructor that takes different arguments?\n. That looks fine to me then.  I can't say why you're getting a compile error.. Ah, yes the example shows registering the Schema as a Singleton vs. an instance.  You only ever need a single instance of your schema.  container.Singleton(...). Yes, should be Singletons.. That's because it DOES implement IDisposable.  It cleans up types it used when it is disposed.  As stated above it is suggested you register all of your graph types and schema as singletons.. Got this published.  https://www.nuget.org/packages/GraphQL/0.16.0. After some thought, I want to keep the SchemaBuilder class in the core repo.  This is mainly so we can switch the \"hello world\" example to something much simpler and people can get started without so much overhead.\nAny thoughts @jquense @tlil ?\n```csharp\nvar schema = Schema.For(@\"\n    type Query {\n      hello: String\n    }\n\");\nvar root = new { Hello = \"Hello World!\" };\nvar result = schema.Execute( =>\n{\n    .Query = \"{ hello }\";\n    _.Root = root;\n});\nConsole.WriteLine(result);\n```\n~I have some \"Authorization\" code in this branch, though I'll move that to its own repo/nuget since it requires .NET 4.6 and NetStandard 1.3.~. @QuantumDecay hi, what are these PRs?. @QuantumDecay please stop opening these PRs. . Definitely the intent of https://github.com/graphql-dotnet/graphql-dotnet/pull/342 was so that the errors would bubble. If they're not then we're missing some proper integration tests.  Looking back at that PR that could be the case.\nAs per status code, I'm not sure if there is specific guidelines in the spec for that or not, as the spec is transport agnostic.  Can take a look at the JS project to see what they do.. Thanks for the investigation - this is probably the culprit: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/ExecutionResultJsonConverter.cs#L32\nCan just keep this issue and perhaps rename the title.. This should be fixed in https://github.com/graphql-dotnet/graphql-dotnet/commit/0539da91c24932d9a8ba36887f37382427710427.  I'm pushing out a 0.17.0 with that fix.. Got that published to Nuget.  Let me know if that works for you.. @drobertson123  I have started some markdown doc files for basically that purpose.  I just haven't gotten around to generating a site for them yet.  I do like what the st-docs is doing.\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/docs. @drobertson123 Yes I would be interested in that.  I work with Jeremy (he's run the Architecture Team I'm on) so I'm very familiar with Storyteller (though admittedly not as familiar with the st-docs).  I have commit access to the ST repo so I can help facilitate changes there.\n@antmdvs \n\nthere's simply too many (exposed) ways to register a field\n\nI think this is certainly part of the problem.  Most of them are just overloads and I would think that after using the project for just a little while that would come to light.  I think XML docs could help though won't necessarily solve the problem of knowing which one to use and why, without perhaps adding tons of docs in the XML comments which I think I would be opposed to.. @drobertson123 this was so I could publish to GitHub pages in just a few minutes of work.  I want to use st-docs or perhaps gatsbyjs which uses GraphQL long term.. @antmdvs Sorry for hijacking this issue, I created #388 to track \"better docs\" and can keep this one for XML docs.. I believe that if you have your serialize method return a string, instead of a guid, this will work as expected.  That would then give a StringValue which the framework will use.\nNote that the IdGraphType is meant to also be used with guids, though I understand if you want something more specific.. Easy thing to do!  Glad to hear it worked.. You're the first to report it. Can you try 0.16.0 and/or 0.16.1 and see if you get the same issue?. Found the problem, fixing it.. Thanks for the PR!  You can fix the build by temporarily adding the myget.org nuget source to use your changes and make sure all the tests pass.\nhttps://www.myget.org/feed/graphql-dotnet/package/nuget/GraphQL-Parser\nhttps://www.myget.org/F/graphql-dotnet/api/v3/index.json\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/NuGet.config. Ah, yeah - its not broken, but the myget deploy is restricted by branch which I forgot about.  You could perhaps add your branch to the appveyor.yml, but if you did it manually then I'm not worried about it.  Will have this CI re-run once a new package is officially released.. Some other places we probably want to update:\n\nAstFromValue extension method.\nAstPrinter\nSchemaPrinter - may need to look at the graphql-js project and see what they do with NullValue.  Perhaps only need to worry about it with DefaultValue argument values?\n. It looks like the JS project uses astFromValue to convert the DefaultValue.  That looks like an existing bug in our SchemaPrinter.  No need to fix that now if you don't want.. It will need to be removed once an official release of v3 of the parser is on Nuget.org. I want to make a few tweaks to the parser project before officially releasing it. I'll do that today.. @tlil yes, see th dev branch in that project.. The issue is the building of the Parser nuget package.  That build process had to be changed and I haven't been able to 100% verify its working yet.  Since this is a behavior change in the parser, yes it requires a major version bump.  Ditto for this project.\n\nhttps://github.com/graphql-dotnet/parser/pull/18. Got the parser project updated and added #421 which merges these changes.. Do you have a custom scalar that is returning a Guid in its serialize method?  What is the GraphType for inspectionIds on inspectionReportInspections?\nThis is where the error is thrown, so the type returned from the scalar.Serialize method is returning a type that the method doesn't recognize.\nSee also https://github.com/graphql-dotnet/graphql-dotnet/issues/370#issuecomment-314803698. What version are you using?. Honestly not sure what the issue is.  It works on basic queries, proved here: https://github.com/graphql-dotnet/graphql-dotnet/pull/377\nPossibly an issue with fragments?  Can you reproduce the issue in a test?. Also just pushed a test with using variables in a fragment and it works there too.  So has to be some other setup you have.\n\nif stepping into dependencies is possible in C# like this\n\nShould be.. That shouldn't be needed.  In that context, what is the .NET Type of serialized?  How are you creating your Inputs class?  The .ToInputs extension method calls GetValue for you .... That looks to be the issue. I would suggest to do it like this example:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.GraphiQLCore/GraphQLMiddleware.cs#L57. They are currently considered \"built-in\" scalars, as configured here.  They are not technically part of the spec, so I could see an argument for printing them.\nWe could perhaps provide a way to override what the built-in scalars are defined as instead of it just being an additive configuration as it currently is.. Sounds good to me.  This should be a fairly easy change, most of the work being updating tests.\n@antmdvs Care to make a PR for this?  Just need to delete these lines and update tests.. https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/EnumerationGraphType.cs#L82\nEnumerationGraphType<T> does a ToUppercase().. All uppercase is idiomatic GraphQL/JavaScript.  http://graphql.org/learn/schema/#enumeration-types\n\nUse EnumerationGraphType instead (the base class) and add the values manually\nCopy the code and change that one line (a little easier)\nDecide to be a hipster and stick with uppercase (easiest!) \ud83d\ude04 . :+1:. This is released in 0.17.2. No, there isn't anything built in for that at present.  I looked into it after it was announced at the last GraphQL Summit, though at the time they didn't have free accounts so that made it a lot harder to integrate.  They also want the metrics in a very specific format.  I would say the current metrics are about 70% of what Apollo Optics want.\n\nSee the docs on metrics: http://graphql-dotnet.github.io/learn#metrics. It looks like they've switched to wanting a new, simpler format.  This should be much easier to accomplish than what was previously required.\nhttps://github.com/apollographql/apollo-tracing. @jbaxleyiii For sure!  The way that metrics are currently tracked has a bit of a performance issue, but you should be able to write an extension for apollo-tracing without too much effort.  Extensions are presently not very well defined in this project so I'm open to any suggestions you may have there.. @RehanSaeed The way they want you to do it is run a proxy in front of your GraphQL server that sends the tracing information.\nhttps://www.apollographql.com/docs/engine/setup-standalone.html#configure-proxy. The commit with that code was added after the last release.  It was added with the mutation example.  https://github.com/graphql-dotnet/graphql-dotnet/releases Shows commits to master after the release.  It will be included in the next release.. http://graphql-dotnet.github.io/graphql-dotnet/getting-started#arguments\nhttp://graphql-dotnet.github.io/graphql-dotnet/getting-started#variables\nhttp://graphql.org/learn/queries/#variables. You can use variables anywhere within the Operation.  You can add arguments to any field.. graphql\nquery AccountList($first: Int, $offset: Int) {\n  accounts {\n    accountName\n    accountNumber\n    status\n    accountDescription\n    accountPayments(first: $first, offset: $offset){\n     amount\n     paymentDate\n    }\n  }\n}\nYou have to add arguments to the field as is shown in the documentation.\ncsharp\nField<ListGraphType<AccountPaymentsType>>(\n      \"accountPayments\",\n      arguments: new QueryArguments(\n        new QueryArgument<IntGraphType> { Name = \"first\" },\n        new QueryArgument<IntGraphType> { Name = \"offset\" }\n      ),\n      resolve: context =>\n      {\n        var first = context.GetArgument<int>(\"first\");\n        var offset = context.GetArgument<int>(\"offset\");\n        // cast the context.Source if you need to\n        var source = (MyClass)context.Source;\n        return source.AccountPayments.Skip(offset).Take(first);\n      }\n    );. Are you sending the variables in the http request as shown here?\nhttp://graphql-dotnet.github.io/graphql-dotnet/getting-started#variables. This is on purpose since your GraphQL api may not match your internal api.  I wouldn't mind adding a class that inherited from ObjectGraphType<T> that did this though.  Tough part will be what the name should be. \ud83d\ude06 . Closing as we merged the PR.. I'm guessing your schema looks something like this:\n```graphql\ninput ApplicationInput {\n  name: String\n}\ntype Mutation {\n  createApplication(application: ApplicationInput!): Something\n}\n```\nCheck the value of the app variable.  It is the string value {ApplicationInput { name: \"Test App\" }}.  You want to actually send a JSON object vs. just a string.\njson\n\"app\": {\n  \"name\": \"Test App\"\n}\nSo in other words - you are sending a Scalar (a string) instead of an Object, hence the error you are getting.. How are you passing the variables to the execution engine?  Are you using the ToInputs extension method?\nOfficial Docs\nASP .NET Core Example\nASP .NET Example. My only other suggestion is to ensure that the app variable does actually exist as an IDictionary<string, object> in the Inputs class when passing it to the engine.\nIt may not be super intuitive, but this actually removes all validation rules and just adds your single rule.  You most likely want to add DocumentValidator.CoreRules() to that list.  Perhaps you get a different error when you do?\ncsharp\n                x.ValidationRules = new[]\n                {\n                    new AuthorizationValidationRule()\n                };. Perhaps the problem is non-null vs. null.  In your query you are defining a non-null, though in your definition it is nullable.. This is where that error is: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/DocumentExecuter.cs#L674\nOnly way to get that error is if the variable is null.. Can you print your schema with SchemaPrinter?. If you're using VS2017, I wouldn't be surprised.  I've had some funny things happen myself.... @Giorgi I would like to keep those examples as they are and add some different ones with unit tests.  I'm also leery of calling a virtual method in a constructor.  I don't think I would want to handle the support requests on that one.  I can understand wanting to override that, though that is something someone could just add to the ctor of the subclass and not need to add an override for.. @Giorgi Since the amount of code to do this is fairly minimal, I don't think I want to introduce an API for this.  My guidance to users would be to just create their own class.. I would just inline it.. Thanks for the report, I ran into this same issue.  I have this fixed in this PR: https://github.com/graphql-dotnet/graphql-dotnet/pull/362. This fix is available in the 2.0 alpha release.. This is done with the gatsby site, so I\u2019ll close this.. I'm guessing you are using variables?  The engine expects the values to be converted from JSON.NET types before execution.\nSee the Variables section in the docs about converting from json/JObject to the Inputs type.. What type is GraphQLRequest.Variables?  ToInputs takes a String (raw json) or JObject.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/d7264a9ad3b0be88638a72ff4e4cc318eae41ef0/src/GraphQL/StringExtensions.cs#L52\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/d7264a9ad3b0be88638a72ff4e4cc318eae41ef0/src/GraphQL/StringExtensions.cs#L60. I would also suggest to use the ExecuteAsync(_=>...) function as the one that takes individual parameters is going to be deprecated here pretty soon.... You can perhaps change your GraphQLRequest to look like this to avoid some extra work:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/6c45e34805ec8aad99b83ee13f44d5006b4164b1/src/GraphQL.GraphiQLCore/GraphQLRequest.cs#L5-L10\nMy understanding is that a JToken is just a generic representation of a value.  So it could and should be a JObject.  So perhaps it would be better to update that extension method to be a JToken since it is just trying to cast the value.. I'm fairly sure that ConcurrentBag<T> doesn't keep a specific order, which the Metrics want.  Perhaps can change this to a ICollection<T> backed by a ConcurrentStack<T>.. Hey, thanks for this PR, though this doesn't handle a few other places where the errors are set.  This transformation should be happening elsewhere.  Right now that is in the ExecutionResultJsonConverter.  An idea I have is to have that ExposeExceptions property on the ExecutionResult class.  That way you can check that value in the ExecutionResultJsonConverter.  I don't really like the idea of copying that value around, though I'm not thinking of a better idea at current.  I'm looking into this a bit more today.. @mrdezzods This is released in 0.17.3.. Unfortunately I don't know Relay at all.  .ResolvedType = new ConnectionType(myGeneratedProductGraphType); is not how you should be registering types though.  That is mixing the instance-based and type-based systems, which isn't a good idea.\nI would suggest to use GraphQL.Relay project.. Hey, sorry for the terse response previously.\nThe Field<T> creates a FieldType class and adds it to the ObjectGraphType.  So when you call Field<GraphType>, is it creating the FieldType with a Type of GraphType.  That is the \"type-based\" system.  When the Schema is first built, the engine goes through and resolves all of the Type's and assigns the value to the ResolvedType property on the FieldType.  So what you have done here is define both the Type and the ResolvedType properties with different values.  It perhaps technically could run, though that is setting yourself up for potentially odd errors.\nSo a better approach would be to add a method that worked with only instances.  Creating the FieldType and assigning the ResolvedType property within the method instead of assigning it after the fact and creating the type mis-matches.\nAlso note that there only ever needs to be a single instance of a given GraphType.  So there only ever needs to be a single instance of the StringGraphType.  This is a little difficult to work with with the current release because how do you get an instance of the StringGraphType to use?  I have a PR (#362) that introduces GraphQLTypeReference for this purpose.  So you can reference a type without having the actual instance of it.\nIn short, the \"Type-Based\" system is mostly what is currently supported, though the instance-based system is still in flux.. Please read this thread:  https://github.com/graphql-dotnet/graphql-dotnet/issues/389 - I'm guessing you're having the same type of issue with variables.. Going to close this as you can accomplish this as @jquense mentions. \ud83c\udf89 . From my understanding, graph.cool IS your GraphQL server, and you use JavaScript to make calls to your API to fetch data.  So no, you wouldn't use this project at all with graph.cool.. Going to go ahead and close this.. Did you try out that code?  That is how it is done.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4da2d8af548b4f0d9cd620da2504781861cf6e37/src/GraphQL.StarWars/Types/DroidType.cs#L15-L18. That error means you need to provide the fields you want to select on the BillingArrangementType.\n. The way GraphQL works is you need to explicitly request the specific fields you want.\nIf your classes look something like this:\n```csharp\npublic class BillingArrangement\n{\n   public string Name { get; set; }\n   public string Type { get; set; }\n}\npublic class AccountSearchResult\n{\n    public List BillingArrangement { get; set; }\n}\npublic class BillingArrangementType : ObjectGraphType\n{\n  public BillingArrangementType()\n  {\n    Field(x => x.Name);\n    Field(x => x.Type);\n  }\n}\npublic class AccountSearchResultType : ObjectGraphType\n{\n  public AccountSearchResultType()\n  {\n    Field>(\"billingArrangement\");\n  }\n}\npublic class Query : ObjectGraphType\n{\n  public Query\n  {\n    Field(\n      \"searchAccounts\",\n      resolve: context => new AccountSearchResult());\n  }\n}\nvar schema = new Schema { Query = new AccountSearchResultType() };\n```\nYour GraphQL query would look something like this:\ngraphql\nquery SearchResults {\n  searchAccounts {\n    billingArrangement {\n      name\n      type\n    }\n  }\n}. You can put whatever code you want within that function.\ncsharp\nField<AccountSearchResultType>(\n  \"searchAccounts\",\n  context => \n{\n  // call API here\n  AccountSearchResult result = myApi.GetResult();\n  return result;\n});. Take a look at the StarWars example.  It shows how to get data from an external source.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4da2d8af548b4f0d9cd620da2504781861cf6e37/src/GraphQL.StarWars/StarWarsQuery.cs#L7-L32. Going to close this.  Re-open if needed.. Thanks for the heads up!  I haven't tried this yet myself.  I probably won't be getting around to looking at this till next week.  Was there a more detailed error available?  I believe you can see that in VS in the Output window, though should be able to see it for sure if you use dotnet restore on the command line.. @jeinz11 use the pre-release version.. Not a bug per say, but a missing feature.  GetArgument<T> calls into ToObject.  Right now, that doesn't support Array properties.  Would just need to add that feature.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4da2d8af548b4f0d9cd620da2504781861cf6e37/src/GraphQL/ObjectExtensions.cs#L20. @wiktor-golonka I will gladly review a submitted PR. This issue is labeled \u201chelp wanted\u201d.. This is now supported!. Please see #234 . Check this thread for trouble-shooting tips: https://github.com/graphql-dotnet/graphql-dotnet/issues/389. Going to close this.  Let us know if you have additional questions.. Your non-scalar argument inputs needs to be of type InputObjectGraphType.  That is probably the issue you're seeing.\nhttp://graphql.org/learn/schema/#input-types\nExample:\ncsharp\npublic class HumanInputType : InputObjectGraphType\n{\n    public HumanInputType()\n    {\n        Name = \"HumanInput\";\n        Field<NonNullGraphType<StringGraphType>>(\"name\");\n        Field<StringGraphType>(\"homePlanet\");\n    }\n}. Did you change this code then?  This shows using ClienteType in the input argument.\ncsharp\n                arguments: new QueryArguments(\n                    new QueryArgument<NonNullGraphType<ClienteType>> { Name = \"clienteArgument\" }. Welcome!  It looks like you're sending a list of data in the query, though it is only defined as a single non-null item in the argument.  Could be the other issue.. Yes, you would need two different inputs if you want to be able to determine a specific type.  That would make it so you have to have a different method for each IMaker type though, which wouldn't be very fun.\nAre the input values going to be different per IMaker?  If not, perhaps you could add a Type property to the input and make it more generic.. Yes.  Not super elegant but it could work.\ncsharp\nresolve: context =>\n{\n  var input = context.GetArgument(\"input\") as Dictionary<string, object>();\n  string inputType = input[\"type\"];\n  Type type = determineType(inputType);\n  var actualInput = context.GetArgument(type, \"input\") as IMaker;\n}\nYou could also smuggle the information as a serialized string, then deserialize in the handler.  Also not super elegant and you wouldn't get any built-in validation.  You could write your own validation rule though.. Going to close this, though would be interested in hearing if you came up with a good solution.. Hey, thanks for this, though I would like to stay targeted at NetStandard1.1/net45 as long as possible.  What I would like to see is if just updating to the new sdk but staying at 1.1 will work.\nMay also need to add a global.json to specify the target sdk for AppVeyor.. I wouldn't want to maintain a 2.0 branch.  If I were targeting 2.0 I would have that be master and have a 0.x branch as maintenance.    You should be able to target 1.1 with the 2.0 sdk.\nThis is an example global.json:\nhttps://github.com/JasperFx/marten/blob/master/global.json\nThe build script would have to also be updated (may be more than one place):\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4da2d8af548b4f0d9cd620da2504781861cf6e37/tools/tasks/compile.js#L9. @srini85 That was the intent of the global.json file - to tell AppVeyor which sdk version to use.  There should only be a single global.json file in the root of the repo.  A few days ago AppVeyor was defaulting to the 2.0 sdk.  Perhaps that changed?  I don't know.. @pekkah No, it has several issues.  Most notably removing the net45 and Netstandard 1.1 support (which should be able to be multi-targeted).  I'm also stuck on 1.0.4 sdk on Windows due to some bugs in latest VS2017, though I could probably switch to 2.0 on macOS.  Just low priority at the moment.. Hey, thanks for participating in this project!  We have an issue that is basically this - #264 - which is creating/providing a DataLoader like Facebook's.. Closing this since its duplicate.. Error trying to resolve user. means you got an error running your resolver.  Please check the inner exception on the Errors result to find out what you need to fix.  Or you can add a try/catch around your code and find out what the problem is.. Input types have to be InputObjectGraphType vs. ObjectGraphType.\ncsharp\npublic class HumanInputType : InputObjectGraphType\n{\n    public HumanInputType()\n    {\n        Name = \"HumanInput\";\n        Field<NonNullGraphType<StringGraphType>>(\"name\");\n        Field<StringGraphType>(\"homePlanet\");\n    }\n}. @cheesemacfly The GraphQL spec prescribes these as two different types.  At present they are design as two different classes in this implementation.  There are at least a couple places in the logic that behaves differently based on whether it is an input or an object.. In addition to the above, you also need to configure the Schema to know about Dependency Injection.\nhttp://graphql-dotnet.github.io/graphql-dotnet/learn#dependency-injection\nThis works with your Root object because it is being resolved from the DI Container in the Controller class.. Going to close this, re-open if you need additional assistance.. Thanks!. This is not added yet.  The conventions project added this feature though did not push it upstream.  So could take some guidance from there to complete the feature.. I think what you have in the gist is a fine approach and cuts down on the boilerplate.\nI have a PR open to also support the GraphQL Schema syntax and move towards a more MVC endpoint approach.  Would that work for your codebase?  See #362 . You can add custom errors in the ResolveFieldContext.  I think this should solve your issue?\ncsharp\ncontext =>\n{\n  context.Errors.Add(new ExecutionError(\"Some Error\"));\n  return null;\n}. See your previous issue: https://github.com/graphql-dotnet/graphql-dotnet/issues/351. You can't directly send files as arguments.  This is a limitation of http.  It needs to be sent as a multi-part form.  You can do something like the following though:\nhttps://medium.com/@danielbuechele/file-uploads-with-graphql-and-apollo-5502bbf3941e\nCreate a custom NetworkInterface in Apollo which replaces the files with a unique id.  You could then perhaps use your custom FileGraphType to match up the file with the id.. Can you explain a bit more about what you're trying to do?  Are you trying to follow the official GraphQL spec on subscriptions?\nhttp://facebook.github.io/graphql/#sec-Subscription. This example is using the JavaScript projects, but shows an app that uses subscriptions:\nBlog: https://dev-blog.apollodata.com/tutorial-graphql-subscriptions-server-side-e51c32dc2951\nCode: https://github.com/apollographql/graphql-tutorial/tree/t8-end\nNote that this project currently does not implement the subscription spec.  So once it does, working with subscriptions should be easier to do.  See  #322 . > need to implement my own SubscriptionExecuter (similar to DocumentExecuter) which will return an event stream as result\nI think this will be the best route to take.  Without changes in the core project, you could also probably inherit from FieldType and add a Subscribe field that would be used instead of the existing Resolver.  There is logic in the DocumentExecutor that could be refactored so it could be re-usable.. Looking good!. A couple other thoughts (that may be on your todo list):\n\nI believe I saw in the Apollo implementation that the Resolve method on the Subscription functioned as a data transform.  So it could transform the Message payload before it got sent to the client.  So that's an argument for both Resolve and Subscribe on the FieldType.\nNeed a way to filter events based on arguments passed in the subscription query.\n\n```csharp\nprivate Task> Subscribe(ResolveEventStreamContext context)\n{\n  return _chat.JoinAsync(context.GetArgument(\"from\"));\n}\npublic Task> JoinAsync(string from)\n{\n    var subject = _events\n        .Subject(\"messageAdded\")\n        .Where(x => x.From == from);\n    return Task.FromResult(subject);\n}\n```\n\nCould probably make EventStreamResolver<T> to remove the object.. I was thinking more of something like this:\n\ncsharp\nField(\"messageAdded\",\n  resolve: context =>\n  {\n    // convert Message to another data type\n    var message = context.Source as Message;\n    return new MyOtherClass {  };\n  },\n  subscribe: context => _chat.JoinAsync(context.GetArgument<string>(\"channel\")));. Looking again at the reference implementation, that is how it is implemented there.  I would say this is mostly so that the resolve doesn't have different behavior when it is a subscription, which could be confusing.  If someone wants to do the transform outside of the resolver that would work perfectly fine as well, since the default behavior would be to just return the object that it is given.\ngraphql-js implementation. Nice work!\n\nthe actual subscription executer should be part of this repo\n\nAgreed, a PR to here will work.\n. @joelmandell I'm not familiar with using WebSockets in 4.5.2.  What you need to implement depends on the JavaScript client you're using.  If using Apollo, this is the server protocol that client expects:\nhttps://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md. You may need to manually register titlepart.\nSee http://graphql-dotnet.github.io/graphql-dotnet/getting-started#registertype. I would also suggest you read the section about IsTypeOf.. Are all of the available parts known beforehand?  One limitation of GraphQL is that it needs to know all of the Schema Types up front.\ncsharp\nIsTypeOf = obj => true;\nDid you remove that line of code and read the docs about IsTypeOf?  That could be causing the issue you're seeing.. Note that you can create types on the fly and register them with the Schema.  They just need to be registered with the Schema before it is initialized.  I typically suggest your Schema being a Singleton, but if your types change dynamically you would need to build it on each request.. Please see #402 for a fix.. @KoditkarVedant I would be pretty surprised if that is the case.  Lets track that separately and see if you can add some tests to show that its broken.. @KoditkarVedant I think its fine to have them fail, then when the build passes we know we've fixed it.. This should be fixed with #980 . \ud83d\udc4d  I pulled this down and played with it a bit.  In this particular case I think we can short-circuit it at the top of the GetPropertyValue method, since the goal is to not do any conversion at all.\nThis appears to work:\n```csharp\npublic static object GetPropertyValue(this object propertyValue, Type fieldType)\n{\n    if (fieldType.IsInstanceOfType(propertyValue))\n    {\n        return propertyValue;\n    }\n...\n\n}\n``. This IS supported today.  You just need to write your http endpoint to support it. See #398 . How about asubscriptions-transport-ws` repo under this org?. Unless you can prove otherwise, this won't be merged as this would break the GraphQL spec.. Thanks, I was aware of it. Good to have an issue here though.  Hopefully they have some good news soon.. Looks like they have issued new licenses that should alleviate any patent issues. \ud83c\udf89 \nhttps://medium.com/@leeb/relicensing-the-graphql-specification-e7d07a52301b\nhttps://dev-blog.apollodata.com/facebook-grants-full-patent-rights-to-all-graphql-users-2c41abc6df66. They run fine on my machine and CI without those changes.  So we need tests that run under the specific culture that you run the code in.  Otherwise changes can be made that will break this again and no one will know since CI won't break.. For whatever reason, CI failed when this was merged.  Kicking that off again then I'll push out an updated alpha with this fix.. Hey, thanks for these suggestions.  I think it would be great to get some of these in the 2.0 release.\n\n\n\nall fields should be run in a new thread\n\n\n\nThat was definitely not the intent.  The intent was that they were all ran async.  Overall the executor does need an overhaul.  Right now the project is technically not following the spec in that queries should be ran async and mutations should ran serial.  Right now both run async.\n\nadding an opt in policy on the IFieldResolver to signify if it should run threaded\n\nFirst thought on that is I don't want to have to deal with an api for that (thinking some sort of property marker).  My original intent was that fields that returned a Task would signify that they should be awaited and that is the only API the framework would need.  Open to making changes here though.\n\nFieldMiddlewareBuilder wrapping every field with a resolver\n\nThis was specifically implemented for metrics.  So if you want to opt-out of that pipeline I can see that being beneficial as that does add some overhead.\n\n\n\ncache query validation\n\n\n\nI do think this could be a good idea, though caching the validation result would only work if the context of the validation does not change.  For instance, I have created some authentication/authorization rules which would need to get evaluated on each request since the authentication or authorization context may have changed between requests and between users.\nRelated to this - you could cache the actual parsing of the Document itself based on the Query.  The ExecutionOptions allows you to pass in an already populated Document for that purpose.  One thing with this sort of caching is making sure that your cache doesn't get overly bloated.  So if we were going to provide some sort of caching mechanism for queries I think we would want to make sure that it could be limited to say the top 10/50/100 queries or whatever fits your domain and your servers can handle.  There's a specific caching pattern for that though I'm not remembering the exact name of it at present ...\n\n\ud83d\udc4d  to this one\n\ud83d\udc4d  to this one\n\nSo I think it would be great to get 3 &4 in, with a maybe? on 2.  I think the changes to 1 could go in a 2.1 or 3.0 release, with finally fixing the serial mutation issue.. This should be fixed when #434 is merged.. This should be fixed in this release - feel free to re-open if you find an issue.  https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-793. Mainly just documentation left.  Hope to have everything ready in the next couple weeks.  See the new docs.  https://graphql-dotnet.github.io/. Calling the docs done for now.. I think this looks good.  May need to add using a newer System.Reflection.TypeExtensions for 2.0 according to #402 \nxml\n<ItemGroup Condition=\"'$(TargetFramework)' == 'netstandard2.0'\">\n    <PackageReference Include=\"System.Reflection.TypeExtensions\" Version=\"4.4.0\" />\n</ItemGroup>. Some good comments here.  A few thoughts from me.\n\n\ninstantiate QueryArguments, QueryArgument I agree that it is a bit verbose, especially around Arguments.  I'm open to suggestions to make the \"do it by hand\" less verbose.  Note that for the most part, these are just extension/overload methods that build a FieldType and add it to the list.\n\n\ninstantiate the ResolvedType This sounds like to me that perhaps you're using the library differently than originally envisioned (you could blame that on the API).  You essentially should never need to do this outside of DI container unless you're building your own schema builder.  I would like to hear more about how you're using the library and perhaps point you in a different direction.\n\n\none has to first instantiate the ExecutionError class, then call AddLocation then add the error to the context This is another one of those \"can you tell me why/how you are using those?\" questions.  You shouldn't have to be dealing with those basically ever.\n\n\nThe core library is purposefully server agnostic and mostly transport agnostic, though you would need to add a few more steps to support something other than JSON.\n\n\nI wouldn't mind having an \"official\" nuget for ASP.NET Core, though I don't personally want to have to support others.\n\n\nVersion 2.0 provides a Schema Builder centered around the Schema type language.  It is not fully-featured at present for what can be done with using the GraphType classes directly, but it should help those new to GraphQL to get started easier.\n\n\n```csharp\npublic class Droid\n{\n  public string Id { get; set; }\n  public string Name { get; set; }\n}\npublic class Query\n{\n  // context is optional\n  public Droid Hero(ResolveFieldContext context)\n  {\n    return new Droid { Id = \"123\", Name = \"R2-D2\" };\n  }\n}\nvar schema = Schema.For(@\"\n  type Droid {\n    id: String\n    name: String\n  }\ntype Query {\n    hero: Droid\n  }\n\", _ => {\n    _.Types.Include();\n});\nvar result = schema.Execute( =>\n{\n  .Query = \"{ hero { id name } }\";\n});\n```\n\nThere is a fairly new authorization project that uses claims based authorization based on the suggested pattern in the core docs.  Docs in the authentication project are lacking, but it looks like the following in conjunction with a validation rule to check that a request passes the given Policy.\n\n```csharp\nvar settings = new AuthorizationSettings();\nsettings.AddPolicy(\"MyPolicy\", _ => _.RequireClaim(\"role\", \"admin\"));\npublic class Query\n{\n  [GraphQLAuthorize(Policy=\"MyPolicy\")]\n  public Droid Hero()\n  {\n    return new Droid { Id = \"123\", Name = \"R2-D2\" };\n  }\n}\n```\n\nmaintained by the library authors There are honestly very few core contributors (thanks to all those reading this!).  Maintenance is an issue.  There is lots of interest, though not a whole lot of consistent contributors.  Those that are solving issues that the community may be interested in I have created additional repos under this Org for those authors to have at it.  I personally mostly work on this project as a side project since we haven't adopted it as a standard at my workplace (at present).  That is why weeks/months can go by without code reviews/merges/deploys/new features.  I'm guessing a lot of those reading this are in that same position, or what has been provided so far has been \"good enough\" to solve their need.\n. > I suspect instantiation of resolved type is only required for mutations, or perhaps in other circumstances.\n\nHaving the ResolvedType populated is required for everything.  If you look at the QueryArgument class, there is a Type property in addition to the ResolvedType property.  When you use QueryArgument<T>, it sets the Type property.  When your Schema is initialized, it walks the Graph Type tree and resolves all of the defined types, setting that ResolvedType property for you.\nWhen this project was first released, only the \"type-based\" API was available and the \"resolved type\" was fetched on the fly.  To support an \"instance-based\" API, the behavior was changed so that the types are resolved when the Schema is first initialized and \"cached\" in the ResolvedType property.  The library then uses that ResolvedType property instead of the Type property.\n\nThe authorization project looks promising. Thought looks like a separate implementation not using asp.net core.\n\nYes that is the case.  Same idea of not being locked into a specific server.. @drobertson123 I agree with a lot of what you posted.  At present, there is a convention based approach in the 2.0 codebase (examples posted above).  Granted it is different than what is provided in the conventions project, though it is what I can currently support.  As from the start, the conventions project was created due to the lack of core contributors.  Tommy did a great job on it, though as it happens, he has no longer been contributing to the core project and instead forked it to add behavior specific to his business needs.  Future goals I had in mind for the project were to be an \"instance-based\" type system vs. the \"type-based\" system that the conventions project is currently based on.  I honestly just don't have the cycles to be able to support the additional overhead of someone else's code of that size.  There are dozens of issues and features in the core project (and the server project) waiting to be fixed/added.  Any volunteers?. Added in #470. Yes, this is now covered by the server project.. Can you be more specific?  Perhaps post your question on stackoverflow?. Here are the docs on how to use this library.\nhttp://graphql-dotnet.github.io/graphql-dotnet/. That version does not target 2.0 (look at the dependencies on nuget.org).  Please stop opening new issues in regards to this.. Use the latest pre-release.  You can also read the docs for alternatives.\nhttp://graphql-dotnet.github.io/graphql-dotnet/. The Source property on the ResolveFieldContext has the full object, which in your case should be Character.\ncsharp\nresolve: ctx =>\n{\n  return db.Gender.Find(ctx.Source.GenderId);\n});\n. Are you getting any errors?  Check the Errors property on the ExecutionResult.  You can also set ExposeExceptions on the ExecutionOptions to get a more detailed error in the returned json.. Can you show the code of how you are using the DocumentExecutor/DocumentWriter?. Query looks okay I think, as long as the Schema looks like\ncsharp\nvar schema = new Schema { Query = new CharactersQuery() };. @Willovent if you\u2019re using DI, make sure every type is registered with the container.. Thanks for your work on this!  Happy to get some speed gains and a better understanding of async/await + Task.Run.. There are several docs showing how to use this project.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/README.md\nhttp://graphql-dotnet.github.io/graphql-dotnet/\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.GraphiQLCore\nIf you\u2019re looking for more detailed learning of GraphQL in general, see the Facebook docs.\nhttp://graphql.org/learn/. I believe that example is incorrect (sorry about that).  It should be using the non-generic version of ResolveFieldContext.\ncsharp\nFunc<ResolveFieldContext, string, object> func = (context, id) =>\n{\n  return data.GetDroidByIdAsync(id);\n};. \ud83d\udc4d  I'm going to keep this open to make sure that this gets fixed in the code.. This was fixed in https://github.com/graphql-dotnet/graphql-dotnet/pull/520. It doesn't support UserContext directly at present, but you can add ResolveFieldContext as a parameter.\ncsharp\npublic class Query\n{\n  [GraphQLMetadata(\"hero\")]\n  public Droid GetHero(ResolveFieldContext context)\n  {\n    var userContext = context.UserContext;\n    return new Droid { Id = \"123\", Name = \"R2-D2\" };\n  }\n}. Thanks, I\u2019ll get that fixed.. This fix is released and also adds the ability to use UserContext directly as a parameter: https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-817. You can do this yourself already. Just create an extension method that creates a FieldType that uses your custom resolver.. Example:\ncsharp\npublic static void DictionaryField<TGraphType>(\n    this IComplexGraphType graphType,\n    string name,\n    string description = null,\n    QueryArguments arguments = null,\n    string deprecationReason = null)\n{\n    graphType.AddField(new FieldType\n    {\n        Name = name,\n        Description = description,\n        DeprecationReason = deprecationReason,\n        Type = typeof(TGraphType),\n        Arguments = arguments,\n        Resolver = new MyNameFieldResolver()\n    });\n}. It defaults to NameFieldResolver if no resolver is provided.  So you need to give it your custom one, in EntityType in your example, then it won\u2019t use the default.. ```csharp\npublic class EntityType : ObjectGraphType\n{\n  public EntityType()\n  {\n    this.DictionaryField(\"id\");\n    this.DictionaryField(\"name\");\n  }\n}\npublic class SomeType : ObjectGraphType\n{\n  public SomeType()\n  {\n    Field(\n        \"entity\",\n        arguments: new QueryArguments(\n                new QueryArgument> { Name = \"id\", Description = \"id of the entity\" }\n            ),\n        resolve: context =>\n        {\n            return new Dictionary(){ {\"id\", 1}, {\"name\", \"object1\"} };\n        }\n    );\n  }\n}\n```\nNow in the above code, when EntityType fields are resolved, it will use your custom MyNameFieldResolver instead of the default NameFieldResolver.. Hey, it was never intended for the Value property of the EnumerationGraphType to have any value other than a primitive value (string, int, long, etc.) so I'm not surprised you're hitting some issues.\n\nIs there some reason that this cannot be changed as follows?\n\nNot as far as I'm aware.. > I need support for byte, short, and double scalar graph types\nThe good news is that the FloatGraphType / FloatValue uses double internally, so you should be fine there.  The GraphQL spec calls it a Float, though the type in .NET that matches the spec is Double.\n\nSo the question I have is; should I change the code and submit a pull request or is there a better way to handle these types?\n\nI've had a few other people run into issues with this, so it is probably time to provide a way to hook-in custom handling.  I don't think this should be too difficult to add.  I'm thinking some sort of registration off of ISchema that could get ran in AstFromValue.  It may be smart to update the IValue interface so that each IValue can just provide its own value, vs. the framework explicitly checking for each known type in ValueFromAst.\nSome quick thoughts on the interfaces:\n```csharp\npublic interface IASTFromValueConverter\n{\n  bool Matches(object value);\n  IValue Convert(object value);\n}\npublic interface IValue : INode\n{\n  object GetValue();\n}\n.csharp\nschema.RegisterValueConverter(new ByteValueConverter())\n```\n```csharp\npublic interface IAstFromValueConverter\n{\n  bool Matches(object value);\n  IValue Convert(object value);\n}\npublic interface IValue : INode\n{\n  object GetValue();\n}\npublic sealed class ByteValue : IValue\n{\n  public ByteValue(byte value)\n  {\n    Value = value;\n  }\npublic byte Value { get; }\npublic object GetValue()\n  {\n    return Value;\n  }\n}\npublic sealed class ByteValueConverter : IAstFromValueConverter\n{\n  public bool Matches(object value)\n  {\n    return value is byte;\n  }\npublic IValue Convert(object value)\n  {\n    return new ByteValue((byte)value);\n  }\n}\npublic class ByteGraphType : ScalarGraphType\n{\n    public ByteGraphType()\n    {\n        Name = \"Byte\";\n    }\npublic override object Serialize(object value)\n{\n    return ParseValue(value);\n}\n\npublic override object ParseValue(object value)\n{\n    if (value == null)\n        return null;\n\n    try\n    {\n        var result = Convert.ToByte(value);\n        return result;\n    }\n    catch (FormatException)\n    {\n        return null;\n    }\n}\n\npublic override object ParseLiteral(IValue value)\n{\n    var byteVal = value as ByteValue;\n    return byteVal?.Value;\n}\n\n}\n```. @DexJen Got your changes merged, with a few tweaks.  Published to Nuget as 2.0.0-alpha-811\n```csharp\n    schema.RegisterValueConverter(new ByteValueConverter());\ninternal class ByteValueConverter : IAstFromValueConverter\n{\n    public bool Matches(object value, IGraphType type)\n    {\n        return value is byte;\n    }\n\n    public IValue Convert(object value, IGraphType type)\n    {\n        return new ByteValue((byte)value);\n    }\n}\n\ninternal class ByteValue : ValueNode<byte>\n{\n    public ByteValue(byte value)\n    {\n        Value = value;\n    }\n\n    protected override bool Equals(ValueNode<byte> node)\n    {\n        return Value == node.Value;\n    }\n}\n\ninternal class ByteGraphType : ScalarGraphType\n{\n    public ByteGraphType()\n    {\n        Name = \"Byte\";\n    }\n\n    public override object Serialize(object value)\n    {\n        return ParseValue(value);\n    }\n\n    public override object ParseValue(object value)\n    {\n        if (value == null)\n        {\n            return null;\n        }\n\n        try\n        {\n            var result = Convert.ToByte(value);\n            return result;\n        }\n        catch (FormatException)\n        {\n            return null;\n        }\n    }\n\n    public override object ParseLiteral(IValue value)\n    {\n        var byteValue = value as ByteValue;\n        return byteValue?.Value;\n    }\n}\n\n```. Agreed. We are tracking that with #381 . Use the pre-release version.. I would suggest to use an enumeration for that.\n```csharp\npublic enum Status\n{\n  Active,\n  Paused,\n  Closed\n}\npublic class StatusEnum : EnumerationGraphType\n{\n    public StatusEnum()\n    {\n        Name = \"StatusEnum\";\n    }\n}\n``. Are you using DI?  Did you register the type with your container?. I can't help much with that code since that is not related to this project and I have no context.  Are you asking how you get the value from the input?  What does yourInputObjectGraphType` look like?\nThis is how I would get an input object in a GraphQL resolver (see Mutations).\n```csharp\npublic class MyInputType : InputObjectGraphType\n{\n    public MyInputType()\n    {\n      Name = \"MyInput\";\n      Field(\"Status\");\n    }\n}\npublic class MyInputClass\n{\n    public Status Status { get; set; }\n}\npublic class SomeObjectType : ObjectGraphType\n{\n    public SomeObjectType()\n    {\n        Name = \"SomeObject\";\n        Field(\n            \"something\",\n            arguments: new QueryArguments(new QueryArgument{ Name = \"input\" })\n            resolve: context =>\n            {\n              var input = context.GetArgument(\"input\");\n              return \"something\";\n            });\n    }\n}\n``. Thoughts on this @jquense, as you are the owner of the relay project.. This can happen if there is some exception or if you are using Dependency Injection and haven\u2019t registered all of your types with the container.  Try setting the ExposeExceptions property on the ExecutionOptions and printing your Schema with SchemaPrinter and look for missing types.. Gotcha, that is higher up the chain than I was thinking, so that isn\u2019t hitting any code from this project.  I would look at the HttpContext.Request directly and verify what is being sent to the server.. @Keeo That's not what you want.  You want theVariablesto come in as its raw form and use the.ToInputs` extension method.  That extension method will convert the JSON.NET Types to their .NET equivalent.  Otherwise you can get some unwanted behavior since the core GraphQL engine doesn't understand JSON.NET types.. Take a look at this example.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/85bc995e2bc8246592feca86a045fbed0913ad68/src/GraphQL.GraphiQLCore/GraphQLRequest.cs#L5-L10\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/85bc995e2bc8246592feca86a045fbed0913ad68/src/GraphQL.GraphiQLCore/GraphQLMiddleware.cs#L64\n. Yes, context.Source is the object resolved from the parent field.  If on the root Query/Mutation/Subscription then the Source is the Root object from the Execute Options.. ResolveFieldContext.RootValue == ExecutionOptions.Root\nYes, ResolveFieldContext.Source is only one level up.  There is no built-in function to access further up the hierarchy.. @emulicus There isn't a way inside this library to do it.  It would have to be an added feature.  That's not part of the GraphQL spec so its never been on the roadmap.  Resolvers can run in parallel and the parent hierarchy could be different between resolvers, so this would be a non trivial feature to add.\nYou could write your own context class that tried to keep track of the relationships, adding that relationship in each resolver.  You could also add an ID to the parent on your child classes, providing yourself a breadcrumb to backtrack.  Those are just a couple ideas I can think of to solve it.. From my understanding, this will happen if you use Task.Run as you have shown.  Don't use Task.Run.  The latest alpha uses Task.Run for you when not a mutation.. Different usage patterns.  The readme shows the newer way, the other docs just haven't been updated yet.. #440 . I have come to accept that a lot of people just don't understand how to use git.  And for whatever reason some people will always do a merge vs. a rebase (perhaps using tooling vs. the command line?).  After it has been available, I have used squash on a case-by-case basis.. Yes, I know.\n\nAfter it has been available, I have used squash on a case-by-case basis.\n\n^^. Closes #443 . Can you talk to what a Uri specific GraphType would provide that the StringGraphType does not?. Can you provide a concrete example?. @KoditkarVedant Thanks!. There aren't currently plans to add one, no.  This could be difficult to add with what is currently supported.  #458 should make that easier to do though.. Yes, see RegisterType in the docs about Interfaces.\nhttp://graphql-dotnet.github.io/graphql-dotnet/getting-started#registertype. > Transient can not be resolved in Singletons\nThat is not the case.  You can resolve Transient classes in Singletons.  The transient instance resolved just takes on the same lifetime as its parent.  So it would hold onto an instance of the class for the Singleton lifetime.\nFrom my understanding, Scoped means Singleton for this request.  So you are essentially registering GraphQLMutation as a Singleton for the request.  So I think your problem is mixing Singleton and Scoped - your Singleton Schema class (which is alive for the entire lifetime of the application) is requesting a Scoped Mutation class (which should only be a Singleton for only that request).  I believe if you changed your GraphQLMutation class to be a Transient or a Singleton itself then the error you are getting will go away.\nNote that this Library does its own Caching of types.  So it only attempts to resolve a type once and then caches it.. Yep so same issue. You\u2019ll have to change that.  Going to close since this is not an issue with this project.. @benmccallum the main thing to be aware of is the internal caching and initialization.  Building a Schema is fairly expensive since the entire graph is walked on initialization.  So the bigger the graph the more expensive it would be to build it.  Since the types are internally cached then they take on the lifetime of the Schema.  So you can certainly change the lifetime, just be aware of those two things and do performance testing.. Just a note on this after looking at it - I'm not sure I want to support this, since it would also mean potentially trying to support setting values on read-only properties.. What this will actually do is convert the uint to either an int or a long.  That doesn't seem like it would be expected behavior?\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/e173a61b9e8d77f55f4a007f5f7081bae622cb1f/src/GraphQL/Types/IntGraphType.cs#L27-L38\n2.0.0-alpha-811 added the ability to provide IValue converters + custom scalars which is what I would suggest to do - a uint specific scalar type + IValue.. These extension methods are to help get you started.  Since that indent is not related to the execution I don\u2019t want it on that class.  I would be fine with an optional parameter in the extension method.. @deinok Its less about performance and more about design.  The ExecutionOptions go with the DocumentExecuter class.  I don't want to add a property related to the DocumentWriter to the class that is paired with the DocumentExecuter.\nSomething more like this would be acceptable:\n```csharp\npublic static string Execute(\n    this ISchema schema,\n    Action configure,\n    bool indent = true)\n{\n    ...\n}\npublic static string Execute(\n    this ISchema schema,\n    Action configure,\n    Action configureWrite = null)\n{\n    ...\n}\npublic class WritingOptions\n{\n    public Formatting Formatting { get; set; } = Formatting.None;\n    public JsonSerializerSettings SerializationSettings { get; set; } =\n        new JsonSerializerSettings\n        {\n            DateFormatHandling = DateFormatHandling.IsoDateFormat,\n            DateFormatString = \"yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFF'Z'\",\n        };\n}\n``. Yep. The 2.0 prerelease supports NetStandard 2.0.. Thanks for the report!  That indeed seems like a bug.. Going to close this as it appears it is fixed.  Thanks @pekkah @kamsar !. Yes,ResolveFieldContext` just needs to be ahead of any GraphQL arguments:\ncsharp\npublic Blog Blog(ResolveFieldContext context, string id)\n{\n  ...\n}\nYou can also directly inject the ResolveFieldContext.Source.\nThere is a bug currently (https://github.com/graphql-dotnet/graphql-dotnet/issues/455) where you can't use ResolveFieldContext as the only parameter.. #455 is now fixed and released: https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-817. This is currently not supported.  I believe you would need to change the Activator.CreateInstance code in these extensions, as well as the SetValue since those will also fail with read-only properties.  I'm not sure I want the code to start getting that complicated though.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/2d1ca76fbe4ec07c22c35922002839491d372995/src/GraphQL/Types/ResolveFieldContext.cs#L99\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/2d1ca76fbe4ec07c22c35922002839491d372995/src/GraphQL/ObjectExtensions.cs#L23\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/2d1ca76fbe4ec07c22c35922002839491d372995/src/GraphQL/ObjectExtensions.cs#L62\nThere may be other places but that is the code that GetArgument is calling into.. Same as #479 . Thanks for the feedback.  I have some ideas for an overhaul for the field middleware.  Would you ever have a scenario where you would want to apply middleware to only a specific resolver and not all of them?. Agreed, that should be added to the docs.\n\nCreate custom errors\nThrow these custom errors\n\nAt present, you can throw any error you would like and it should be caught and wrapped in an ExecutionError.  Otherwise you can create an ExecutionError yourself and add it to the context which will get bubbled up.\ncsharp\nField<DroidType>(\n  \"hero\",\n  resolve: context =>\n  {\n    context.Errors.Add(new ExecutionError(\"Custom error\"));\n    return null;\n  }\n);\n\nCustomize the rendering of these errors to JSON (for example how to add fields to the errors response object)\n\nThis is not currently possible.  This is the code that handles writing errors at present.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/c733e48fe38fb22d2360af35379cfbd6bbca8a36/src/GraphQL/Execution/ExecutionResultJsonConverter.cs#L36. ExecutionError just inherits from Exception.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/c733e48fe38fb22d2360af35379cfbd6bbca8a36/src/GraphQL/Execution/ExecutionError.cs#L8\nFrom my understanding, should be able to add values to it like this (since it is just an IDictionary):\ncsharp\nvar exc = new ExecutionError(\"Some error\");\nexc.Data.Add(\"avalue\", \"value\");\nThough that won't do anything unless the ExecutionResultJsonConverter is updated to write json from that property.. Another option is to use field middleware to catch and translate domain exceptions.\nhttps://graphql-dotnet.github.io/docs/getting-started/field-middleware. I would be fine with that.  I can have it setup so you have full control over that repo as well.  I can add AppVeyor/myget for the project if you like (under the org), but you can use whatever setup you prefer.. I would probably want to change the repo name to client or something like that to keep with the simple repo names.. \ud83d\udc4d . @deinok Do you want to transfer the existing repo or create a new repo and push to that repo?  You can transfer via Settings->Danger Zone->Transfer Ownership.  Otherwise I can create a new repo.. @deinok I made the transfer to the org, you should have read/write access and be able to add more collaborators.. \ud83d\udc4d  Got them.  Do you want me to add AppVeyor or do you want to stick with CircleCi?. Moving the CI conversation to https://github.com/graphql-dotnet/graphql-client/issues/4. You can currently use GraphQLMetadataAttribute to set description/deprecation, though you can't currently use the Schema syntax (the Parser ignores all comments at present).\ncsharp\n[GraphQLMetadata(\"hero\", Description = \"A description\", DeprecationReason = \"A reason\")]\npublic Droid GetHero()\n{\n  return new Droid { Id = \"123\", Name = \"R2-D2\" };\n}\nI have started work on enabling comments in the Parser though it still needs some work.  https://github.com/graphql-dotnet/parser/pull/16. Sorry, I lost track of this.\nYes, I would like to eventually support the @deprecated directive in the schema syntax.  I believe that the parser will handle that, though the schema builder doesn't currently handle it.  That should be a fairly easy addition if the parser already supports it.\nAt present the Schema Builder also does not support handling fields like your Droid example.  This is a bit harder to add but not impossible.\nEdit:\nConfirmed that the parser does support directives like that, so that should be easy to add.. The @deprecated support is published in GraphQL.2.0.0-alpha-839. @acronoah Not yet.  I believe the code is mostly done, though it needs updated tests and potentially more tests to confirm.  Happy to review a PR based on my existing one of you're up for the challenge.. For the .NET Core GraphiQL sample:\n```\n\ndownload source\nnavigate to root of project in cmd\nnpm install -g yarn\nyarn install\nyarn start\nOpen Solution in VS\nRun the GraphiQLCore project\n```. And here's a new stand-alone example: https://github.com/graphql-dotnet/examples/tree/master/src/AspNetCoreCustom. Are you using a value converter?  As shown here:\n\nhttps://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-811. Looking at this, I believe you have to change JSON.NET to get a DateTimeOffset.  Have you done something like this (ASP.NET Core)?\ncsharp\nservices\n    .AddJsonOptions(options =>\n    {\n        var settings=options.SerializerSettings;\n        // this may need to be different for you\n        options.DateFormatHandling = DateFormatHandling.IsoDateFormat;\n        options.DateTimeZoneHandling = DateTimeZoneHandling.Local;\n        options.DateParseHandling = DateParseHandling.DateTimeOffset;\n    });\nThat may have other implications on how you need to handle variables since if you are just passing in JSON then there are some hard-coded settings.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/9ec880761ec5785ff1473c3fe638bf53455f442c/src/GraphQL/StringExtensions.cs#L67-L76\nBut if you use a JObject I think that should be fine.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/9ec880761ec5785ff1473c3fe638bf53455f442c/src/GraphQL/StringExtensions.cs#L60-L65. Hm, can you try registering HumanInputType with the Schema?\n```csharp\n    public class StarWarsSchema : Schema\n    {\n        public StarWarsSchema(IDependencyResolver resolver)\n            : base(resolver)\n        {\n            Query = resolver.Resolve();\n            Mutation = resolver.Resolve();\n            RegisterType();\n        }\n    }\n```\nAnd is your input setup like this?  As non-null.\ncsharp\nnew QueryArgument<NonNullGraphType<HumanInputType>> {Name = \"human\"}. I just double check that that exact mutation works in the sample app and it does.  So must be something different you have in your setup.\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.GraphiQLCore\nPerhaps missing that class in your container?\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/9ec880761ec5785ff1473c3fe638bf53455f442c/src/GraphQL.GraphiQLCore/Startup.cs#L20-L29. Those extension methods are not in the project.  If you scroll a bit further down in the docs they are listed there:\nhttp://graphql-dotnet.github.io/graphql-dotnet/learn#permission-extension-methods\nThat said, I have created a different project with some updated Authorization techniques uses permissions, similar to what is found in ASP.NET Core.  That doesn't have an example/docs but I can provide one later today.  https://github.com/graphql-dotnet/authorization. @olegBryukhanov My apollogies though I wasn't able to get a sample fully updated to use Auth.  Here is an outline of what it may look like.\nKey elements:\n\nRegister the authorization classes in your container (IAuthorizationEvaluator, AuthorizationSettings, and the AuthorizationValidationRule).\nProvide a UserContext class that implements IProvideClaimsPrincipal.\nAdd policies to the AuthorizationSettings.\nApply a policy to a GraphType or Field (which implement IProvideMetadata) using AuthorizeWith(string policy).\nThe AuthorizationValidationRule will run and verify the policies based on the registered policies.\nYou can write your own IAuthorizationRequirement.\nUse GraphQLAuthorize attribute if using Schema + Handler syntax.\n\n```csharp\npublic static void AddGraphQL(this IServiceCollection services)\n{\n    services.TryAddSingleton();\nservices.TryAddSingleton(s =>\n{\n    var authSettings = new AuthorizationSettings();\n\n    authSettings.AddPolicy(\"AdminPolicy\", _ => _.RequireClaim(\"role\", \"Admin\"));\n\n    return authSettings;\n});\n\nservices.AddTransient<IValidationRule>(s => new AuthorizationValidationRule(s.GetRequiredService<IAuthorizationEvaluator>()));\n\n}\npublic static void AddGraphQL(this IApplicationBuilder app)\n{\n    var settings = new GraphQLSettings\n    {\n        BuildUserContext = async ctx =>\n        {\n            var principalProvider = app.ApplicationServices.GetService();\n            var principal = await principalProvider.Principal();\n        var userContext = new GraphQLUserContext\n        {\n            User = principal\n        };\n        return userContext;\n    }\n};\n\nvar rules = app.ApplicationServices.GetServices<IValidationRule>();\nsettings.ValidationRules.AddRange(rules);\n\napp.UseMiddleware<GraphQLMiddleware>(settings);\n\n}\npublic class GraphQLUserContext : IProvideClaimsPrincipal\n{\n    public ClaimsPrincipal User { get; set; }\n}\npublic class GraphQLSettings\n{\n    public Func> BuildUserContext { get; set; }\n    public object Root { get; set; }\n    public IList ValidationRules { get; } = new List();\n}\n```\nType syntax - use AuthorizeWith.\ncsharp\npublic class MyType : ObjectGraphType\n{\n    public MyType()\n    {\n        this.AuthorizeWith(\"AdminPolicy\");\n        Field<StringGraphType>(\"name\").AuthorizeWith(\"SomePolicy\");\n    }\n}\nSchema + Handler syntax - use GraphQLAuthorize attribute.\ncsharp\n[GraphQLAuthorize(Policy = \"MyPolicy\")]\npublic class MutationType\n{\n    [GraphQLAuthorize(Policy = \"AnotherPolicy\")]\n    public async Task<string> CreateSomething(MyInput input)\n    {\n        return Guid.NewGuid().ToString();\n    }\n}. It is just a wrapper around HttpContext.User.. You can use IHttpContextAccessor.. BuildUserContext is a function that needs to be invoked.  Your middleware is just assigning the func to the UserContext instead of invoking the function and assigning the created GraphQLUserContext class.. Calling AuthorizeWith in the constructor applies the policy to the whole Type, which you then would not need to apply to each field.  If you have some fields you want to not apply the policy to, then you would need to not add it to the Type and add it to only the fields you want it applied to.. You\u2019re right - at present the validation rule doesn\u2019t check the Type of the Field that is being returned, only that the current Field being requested is allowed.  Since there are no policies applied to the GraphQLQuery class it allows it.  That should probably be updated to work as you expect.  Mind adding an issue to that project?. @sudhabt you can use annotations with the Schema/handler syntax (shown in the Authorization readme).  Using annotations with Type syntax you would only be able to add an annotation to the Type and not fields (not very granular).  Using annotations with Types is not currently supported (due to its limitations).  You could write your own validation rule to support that though.. Closing this as the issue is fixed in the other project.. Use FieldAsync. Thanks for the report, yes that seems like an issue.. This could be another victim of the most recent threading refactor.  I don\u2019t think we have good tests around this feature so there could be a regression.\nCould perhaps be this same issue?  #506. Ditto what @kamsar mentioned may not be the best candidate for GraphQL.  You could also perhaps return a url to the file to download and handle that url on the client as another non GQL request - or present the url to the user and let the browser do the work.\nThe relay project has a good example of working with posting files to a GQL server.\nhttps://github.com/graphql-dotnet/relay/blob/master/src/GraphQL.Relay/Http/Deserializer.cs#L23\nhttps://github.com/graphql-dotnet/relay/blob/master/src/GraphQL.Relay/Http/RequestExecutor.cs#L31. I\u2019m fairly certain that the original query is used for other things, such as providing line/column numbers in error messages.  So it would still be required.. I honestly don't know, the code would need to be checked.  It could perhaps be updated to use that instead, though then that validation would just move to checking that the Document object has the original query set.. Use List vs. IEnumerable or an array.  The backing code does not understand those.. What type is the inputs variable that you\u2019re using?. I believe you should be using GetArgument on the ResolveFieldContext.\nShown here in ththe docs: http://graphql-dotnet.github.io/graphql-dotnet/getting-started#arguments. Can you post the whole relevant code?  It\u2019s hard to be helpful with only partial snippets.. From what you posted, this is the structure I see:\n{\n  \"heart\": { <-- DashboardQuery\n    \"responses\": [ <-- HeartQuery\n      { \"date\": \"...\" }  <-- Response\n    ]\n  }\n}\nSo if your Reponse : ObjectGraphType<Models.Heart.Response> has a user field, then that would work.\nAre you getting any sort of errors in the response?  Are you sure your GetOrCache method is actually returning data?. @kamsar Good call, yes that seems to be the case.  Not sure why I glazed over that.  \ud83d\ude06 . You can have your heart API Group, but you do have to provide a resolver and return a value.  By default, if a resolver is not provided it tries to resolve the value from the Parent GraphType's Source, which in this case would be null if a Root object was not provided in ExecutionOptions.  In your case, you can just return new {} in the heart resolver and that would be sufficient.\ncsharp\nField<HeartQuery>(\"heart\", resolve: ctx => new {});. I\u2019m going to leave this open so we can document this approach.. Documentation for this is live here: https://graphql-dotnet.github.io/docs/getting-started/query-organization/\nFeedback welcome.. @EmmanuelPonnudurai that is the trade off.  If you don\u2019t have a lot of root queries you can just add them to the root. If you have a lot you can group them with the empty resolver.  You\u2019ll have to decide what works best for your service.. Just as an FYI I\u2019m not sure that this PR will bbe accepted. Just a forewarning.. Closing this.. Indeed this needs some help.  Care to do a PR?  \ud83d\ude04 . Yes, this should be fixed now with the new ValueConverter.. That should only be needed if you want to change the name of the GraphType or set some other value.  By default it should just use the name of the class if the GraphQLMetadata attribute is not used.. If that is the case then that's a bug that has creeped in, though it should be optional.... This is the other option you have - explicitly give the type to the schema:\n```\ntype Post {\n    id: ID!\n    title: String!\n}\ntype MyQuery {\n    post(id: ID!): Post\n}\nschema {\n  query: MyQuery\n}\n```\n  . Hm, I'm doing something similar and it works.\n```csharp\nservices.AddSingleton(sp =>\n{\n    var schema = Schema.For(\n        SchemaTypeSystem,\n        _ =>\n        {\n            .DependencyResolver = new FuncDependencyResolver(sp.GetRequiredService);\n            .Types.Include();\n            _.Types.Include();\n        });\nreturn schema;\n\n});\n```\nCan you use new SchemaPrinter(schema).Print() and see what it shows you?. If you use GetRequiredService vs. GetService I believe it should throw an error when that is the case:\ncsharp\n_.DependencyResolver = new FuncDependencyResolver(sp.GetRequiredService);\nThat being said, if DI isn't setup like that and it can't construct the object (which in your case seems like it wouldn't be able to), I agree, it should thrown an error.. I haven\u2019t tested the ASP.NET MVC example project in a while, though yes it did work with just a String previously.\nvar inputs = new Inputs(query.Variables ?? new Dictionary<string, dynamic>());\nYou can run into problems with this.  GraphQL expects all JSON.NET types to be converted to scalar .NET Types.  You want to use the .ToInputs extension method which does the conversion.\nI would instead suggest to use JObject along with .ToInputs as seen here\ncsharp\n    public class GraphQLRequest\n    {\n        public string OperationName { get; set; }\n        public string Query { get; set; }\n        public JObject Variables { get; set; }\n    }. Going to close this.  Let me know if you're still having issues.. I'm double checking this, though can you expand on how you're handling your variables?  Are you using JObject and .ToInputs as shown here?  .NET Core or Full Framework?\nhttps://github.com/graphql-dotnet/example-aspnetcore/blob/master/src/Example/GraphQLRequest.cs#L9\nhttps://github.com/graphql-dotnet/example-aspnetcore/blob/master/src/Example/GraphQLMiddleware.cs#L59. It would be helpful to know how your server is setup, including the stacktrace of the error.. I've validated this works with the following test.  Are you able to write a failing test?\n```csharp\n[Fact]\npublic void optional_variable_not_provided()\n{\n    var testSchema = @\"\n      input ExampleInputObject {\n        a: String\n        b: Int!\n      }\n      type Query {\n        something(input: ExampleInputObject): String\n      }\n    \";\n    var schema = GraphQL.Types.Schema.For(testSchema, _ => .Types.Include());\n    var result = schema.Execute( =>\n    {\n        .Query = \"query ($var: String) { something(input: { a: $var, b: 1 }) }\";\n        .Inputs = \"{}\".ToInputs();\n    });\nSystem.Console.WriteLine(result);\n\n}\npublic class MyInput\n{\n    public string A { get; set;}\n    public int B { get; set; }\n}\n[GraphQLMetadata(\"Query\")]\npublic class MyHandler\n{\n    public string Something(ResolveFieldContext context, MyInput input)\n    {\n        return $\"A: {input.A}, B: {input.B}\";\n    }\n}\n```. Can you be more specific?  What Type are you referring to?. Can you provide what versions of graphqL-js and GraphiQL you\u2019re using?  The 2.0 branch supports null values in the parser and 17.3 does not. So that is a different GraphQL spec and will show different behavior in that regard.. Thanks for the report.  We are tracking this issue here: https://github.com/graphql-dotnet/graphql-dotnet/issues/475\nUp to doing a PR for it?. I have seen it fail intermittently on CI.  May just need to try to run it again, or bump of the time while on CI.. I kicked off a new build.. Ran this a couple more times, both being > 900 and < 1000.  So may be sufficient to bump it to 1k for now.  The ~1300 was probably an outlier.. Yes the types are cached using GraphTypesLookup.. You can use constructor injection coupled with a DI setup, though at this time the result will be cached and live the lifetime of the Schema.. AST Nodes is for the Query itself, not arguments/variables.  You can access the Arguments (as a Dictionary) via the ResolveFieldContext.Arguments.  Granted this could potentially be faster, though there are rules in the GraphQL spec in regards to the Arguments which preclude just providing the raw JSON arguments.. Are you able to provide an example of what doesn't work for you?  This is how this library is currently setup to function:\nhttps://graphql-dotnet.github.io/getting-started/#mutations\n```csharp\npublic class StarWarsMutation : ObjectGraphType\n{\n    public StarWarsMutation(StarWarsData data)\n    {\n        Field(\n            \"createHuman\",\n            arguments: new QueryArguments(\n                new QueryArgument> {Name = \"human\"}\n            ),\n            resolve: context =>\n            {\n                var human = context.GetArgument(\"human\");\n                return data.AddHuman(human);\n            });\n    }\n}\npublic class HumanInputType : InputObjectGraphType\n{\n    public HumanInputType()\n    {\n        Name = \"HumanInput\";\n        Field>(\"name\");\n        Field(\"homePlanet\");\n    }\n}\npublic class Human\n{\n    public string Name { get; set; }\n    public string HomePlanet { get; set; }\n}\n```. Have you tried:\ncsharp\nvar obj = JObject.FromObject(context.Arguments);\nvar obj = JObject.FromObject(context.Arguments[\"human\"]);\nAlso, are you expecting there to be values in the Arguments that aren't defined in your GraphQL Schema?\nThis is the GraphQL spec for how arguments are determined: http://facebook.github.io/graphql/October2016/#sec-Coercing-Field-Arguments\nSo the values found in ResolveFieldContext.Arguments is determined by the algorithm defined in the spec.\nIf for whatever reason you're looking to bypass that portion of the spec, the easiest route would be to create a \"user context\" object and add the raw values to that context.\nhttps://graphql-dotnet.github.io/learn/#user-context. Can you provide an example of how this caused a problem?  What is the fieldType in your case?. Gotcha. Probably would need to check to see that the type implements IList, then could use the fieldType. Otherwise use the generic list. That way can also support IEnumerable properties.\nUp to doing the PR?. This is published as GraphQL.2.0.0-alpha-839. Thanks for these updates!  I re-ran CI and it passed.  That test needs to go away.... #381 . The bundle.js file is created by running webpack.  Webpack is a javascript bundler.  You can find the configuration file at the root of this repo.  To bundle all of the javascript files to run the GraphiQL sample, you will need to have node installed and follow the steps in the readme of the project:\nAt the root of the repo run:\nnpm install\nnpm start\nnpm install: installs of the node package dependencies\nnpm start: runs the start \"script\" found in the node package.json file.\nThat should create the bundle.js files.  You can then run the application from Visual Studio.. Tracking issue: #424 . @roman-kozachenko Appears to be working.  Once those tests are updated I can get this merged.. @roman-kozachenko I can\u2019t pull this in with your changes to that test.  Fix the test so it is a meaningful test again and I can revisit.. Hey, thanks for the report.  We are tracking this issue here:  #424 . Initial review this looks good, though since there's a number of changes I'm going to pull it down and play with it a bit.. Thanks for looking into this! We have been tracking this as #264.\nI'll be honest and say that tackling this is a bit beyond my currently level of knowledge and is a major reason why this feature does not exist yet.  I also think it would be a great feature to have.\n\nI have a repo I setup under the org for a dataloader implementation that I created a while back.  We can use that for the parts that do not have a GraphQL dependency.  Perhaps the GraphQL specific parts could also go in that repo but a different project.  Depending on what it looks like, I could see adding those dependencies to the server project or at least an example.\n\nhttps://github.com/graphql-dotnet/dataloader\n\n\nMutations do have to run serially and can't be batched.  In general, the guts of DocumentExecutor needs a fairly big overhaul.  <insert lame excuse here>  In the past I had in my head a \"batching\" executor vs. a \"serial\" executor.  I'm fairly sure the ruby project does something like that.  That could be transparent to the user but sort of like a pluggable behavior model within the executor.\n\n\nI agree on the threading.  I can understand why it was changed (a community contribution) though it does feel like there should be a better design.  This also is not my expertise so I'm grasping at straws a bit there myself.. Lets continue this in #264 , though @drobertson123 makes a good point that we should probably just keep all of this in the core repo to reduce fracturing.  Can pull it out to a different repo/NuGet later if needed.. Looking good!  One problem I noticed is that the DataLoader tests aren't being ran on CI.  This is because the build script only targets the GraphQL.Tests.\n\n\nThis script will need to be updated.  I can work on getting that updated to easier support multiple test projects.. Got that updated.  So you can add a line here for that project or merge it in.  Either way, once the tests are running and green I can get this merged.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/8dc9227b616eba8bd186e39844c650a5b1832f8a/tools/tasks/test.dotnet.js#L13-L17. Indeed big changes.  Will take me a bit to wrap my head around it I think but I'm happy this is getting done!. We push the packages to MyGet automatically for this.\nhttps://www.myget.org/F/graphql-dotnet/api/v3/index.json\nI would not suggest using the AppVeyor feed as it has some funky packages on there and I have no control over it.. @drobertson123 Thanks for you thoughts and I agree that lack of documentation has been an issue.\n\nconfusing mix of C# and javascript conventions\n\nCan you point out some specifics?  Admittedly I did follow the JS and Java projects quite a bit, though I'm not sure what aspects don't \"feel like C#\".  Living in both communities and being the person that wrote it I need specifics to be able to make this better.. Just as a forewarning, there is about a 99% chance that I won't be pulling in any PRs that add FX Cop or anything similar.  I'll admit that some of the APIs could be better, though most of the difficulty I've seen people have is with learning GraphQL itself.  I would prefer to get direct feedback from users of the library vs. a code analyzer.  There have been a few threads like this that distinctly lack feedback on specific APIs and what was confusing other than \"make it better\". There's not much I can do with that.. > I just spent a decent amount of time tracking down a bug that was attributed to such behavior, because the ObjectGraphType had a public property that the DI happily recognized and replaced.\nCan you please provide what happened and what your expectation was?  From your comment I have no idea if that is expected behavior or not.  Need the specifics to be of any help or to fix it.. @AndrewRissing That one is meant to be public and should stay public, so unfortunately no help there.  \u2639\ufe0f \nhttps://graphql-dotnet.github.io/getting-started/#istypeof - if you haven't seen it.. They are compatible with 1.x (I\u2019m using it myself in a 1.x production project), though there is currently some churn in master.\nHave you tried this example that uses nuget packages?  https://github.com/graphql-dotnet/example-aspnetcore. Yes that is the case.  One note though - at present once a GraphType is created it is cached in the Schema.  So those types will \"live\" for the lifetime of the Schema.. No objections from me, would love a PR for it.. Thanks for this!  Would you mind adding another test for interfaces?  The StarWars schema has a CharacterInterface type.  Could also use some tests for Unions and fragments, though the StarWars schema doesn't have any Unions.  I'll pull this in after the interface test is added.. I would suggest reading about Unions here: http://graphql.org/learn/schema/#union-types\nA Union means the result may be any of the types defined in the Union.\nFor this library's specific implementation I would suggest reading about ResolveType and IsTypeOf.\nhttps://graphql-dotnet.github.io/getting-started/#resolvetype\nhttps://graphql-dotnet.github.io/getting-started/#istypeof\nIn your resolver you return the value you want mapped, and ResolveType or IsTypeOf is used to make a determination of which GraphType to use to map the values over the transport.\nThere is no UnionGraphType<T> because a Union can have an unlimited number of members and that makes it hard to try to use generics.\nUnfortunately I don't think what you're wanting to use a Union for will work.  If you want to have a result type with optional members then I would just use an ObjectGraphType<T> and add fields for each of the items.. Closing as a new PR with fixes has been made.. Closing as most of these are fixed in other PRs.. Closing, as I'm not interested in having this in the repo.. #540 has been merged, let us know if this problem persists.. We do have some basic cursor pagination support with Connection.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Builders/ConnectionBuilderTests.cs\nThere is a bit more support and helpers around nodes/edges/connections in the Relay project.  https://github.com/graphql-dotnet/relay. Are you talking about across fields or in a single field?\nYou would only be doing filtering in-memory if your ORM didn't support the query you are trying to do.\nThere is a DataLoader pattern that can be used for efficient querying across fields.  This is a new feature just added to this project.\nhttps://github.com/facebook/dataloader (javascript implementation by Facebook)\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.DataLoader.Tests (Tests for the DataLoader)\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/540 (PR for updates to the DataLoader pattern in this repo). Yep.  Here's a basic example using Dapper.\n```csharp\npublic class InvoiceData\n{\n    public Invoice GetInvoiceByID(int id)\n    {\n        using (var db = new SqlConnection(\"Connection String\"))\n        {\n            const string sql = \"SELECT * FROM Invoice WHERE InvoiceID = @InvoiceID;\";\n            return db.QueryFirstOrDefault(sql, new {InvoiceID = id});\n        }\n    }\n}\npublic class QueryObjectType : ObjectGraphType\n{\n    public QueryObjectType(InvoiceData data)\n    {\n        Name = \"Query\";\n        Field(\n            \"invoice\",\n            arguments:  new QueryArguments(\n              new QueryArgument> { Name =\"invoiceID\"}\n            ),\n            resolve: ctx =>\n            {\n              return data.GetInvoiceByID(ctx.GetArgument(\"invoiceID\"))\n            });\n    }\n}\n``. Input objects are essentially POCOs, so with yourDataViewInputTypeyou shouldn't need any resolvers.  In fact, you're trying to use Arguments inDataViewInputType` but you have no arguments defined.  I will have to double-check, though I don't think you're allowed to use Arguments with input objects, so that may be an API Design issue.\nIt seems that error is typically from a mis-match between null and non-null definitions in the query/mutation.  You are using DataViewInput! in your mutation so that seems correct based on your definition in DataViewMutation.\n\nUnable to parse input as a 'DataViewInput' type\n\nNotice that the error does not have a ! on the type, so perhaps somewhere isn't sending the mutation correctly?  Have you tried this out with just a basic http request using something like Postman?\ncsharp\nvar dataView = context.GetArgument<DataViewInputType>(\"dataView\");\nvar name = context.GetArgument<string>(\"viewName\");\nvar fields = context.GetArgument<ListGraphType<StringGraphType>>(\"viewColumns\");\nThe above fetching of the arguments is invalid.  You need to use a POCO object and not the GraphType.  Then you just use the values on the POCO.\n```\npublic class DataViewInput\n{\n  public string ViewName { get; set; }\n  public string ClientName { get; set; }\n  public List ViewColumns { get; set; }\n}\nvar dataView = context.GetArgument(\"dataView\");\ndataView.ViewName\n...\n```. You will still need the argument on your mutation.\n```\npublic class DataViewMutation : ObjectGraphType\n    {\n        public DataViewMutation(IDataViewRepository data)\n        {\n            Name = \"DataViewMutation\";\n        Field<DataViewType>(\n            \"createDataView\",\n            arguments: new QueryArguments(\n               new QueryArgument<NonNullGraphType<DataViewInputType>> { Name = \"dataView\" }\n           ),\n            resolve: context =>\n            {\n                var dataView = context.GetArgument<DataViewInput>(\"dataView\");\n                Debug.WriteLine(dataView.ViewColumns);\n\n                return data.Query(new string[] { \"\" }, \"\");\n            });\n    }\n}\n\n```\nHow are you trying to run the mutation?  Through graphiql?  Postman? Apollo?  If any of those, what version are you using?. Yes, you need an InputType for GraphQL, and the POCO class for easier mapping from the raw dictionary.  The POCO class isn't necessary but makes it way easier to work with.\nFor input objects you need to use InputObjectGraphType<T> vs. ObjectGraphType<T>.  Also since they're basically just POCOs you probably don't need any dependencies in the constructor.\n```\npublic class DataViewInputType : InputObjectGraphType\n{\n    public DataViewInputType(IDataViewRepository data)\n    {\n        Name = \"DataView\";\n    Field(r => r.ViewName).Description(\"ViewName\");\n    Field(r => r.ClientName).Description(\"Fields to pull from the database\");\n    Field(r => r.ViewColumns).Description(\"List of view columns for the report.\");\n}\n\n}\n```. Oh - and the version of graphiql may be the issue.  I've been using 0.11.2+ on projects with latest pre-release versions of GraphQL.NET.. Lets break down the error:\n\nUnknown type DataViewInput\n\nThis means there is no DataViewInput type registered with your Schema, which is a type you must be using in your mutation request.\n\nDid you mean \\\"DataViewQuery\\\" or \\\"DataView\\\"?\n\nThe InputObjectGraphType example I posted used the Name DataView.  So you probably have a name mis-match.\n\nVariable \\\"dataView\\\" cannot be non-input type \\\"DataViewInput\\\".\n\nWhile this error is \"valid\" per say, it is caused by the other issue.  Since DataViewInput does not exist in the Schema.. I suggest to use a JObject instead.  Example here:\nhttps://github.com/graphql-dotnet/example-aspnetcore/blob/master/src/Example/GraphQLRequest.cs. @JSanchezIO It all depends on your server setup.  string seems to work fine with old ASP.NET MVC.  JObject seems to work better with .NET Core.  JObject should work in both places though, so I have started to just suggest that.  You still use .ToInputs with JObject.  If you use .ToInputs with a string it essentially just converts it to a JObject first.. @ericklind Its extremely difficult to debug your code without actually having it in hand.  That error tells me that either you have an invalid request or some setup wrong.  Are you able to push your code so I see your setup?  If not, I would suggest to fork the working examples or use the existing .NET Core middleware that is setup for you.\nASP.NET MVC: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.GraphiQL/Controllers/GraphQLController.cs\nASP.NET MVC Core: https://github.com/graphql-dotnet/example-aspnetcore\nASP.NET Core Middleware: https://github.com/graphql-dotnet/server. That error is telling you that you are trying to cast a Value (such as a string, int, etc.) to an Object.  So that tells me that the variables you are passing to the server is probably a string, which to match to your server configuration, it should be a JSON object.\nNot this:\njson\n{\n  ...\n  \"variables\": \"{'someVarName': { 'viewName': 'my-view', 'clientName': 'my-client', 'viewColumns': ['column1', 'column2' ] }}\"\n}\nBut this:\njson\n{\n  ...\n  \"variables\": {\n    \"someVarName\": {\n      \"viewName\": \"my-view\",\n      \"clientName\": \"my-client\",\n      \"viewColumns\": [\"column1\", \"column2\" ]\n    }\n  }\n}\n. That is the variables pasted into GraphiQL, but did you confirm what the actual http request looks like?  The actual http request should have a different structure than that, variables should be the top level and dataView and everything else should be an object under it.  What version of GraphiQL are you using?. So that request appears to be sending the variables as a string.  Newer versions of GraphiQL send it as the JSON structure.  You just need to have your server match whichever way you want to use it.. \ud83c\udf89 . Thanks for catching that, I missed that in my review.  I think those should probably be added back.. This should be fixed, though StatsReport has also been replaced by Apollo Tracing.  https://graphql-dotnet.github.io/docs/getting-started/metrics. In newer versions, you have the option to turn off the field middleware with a flag, just as an FYI.. Docs are markdown files found in the docs folder.  https://github.com/graphql-dotnet/graphql-dotnet/tree/master/docs. Closing as there are now docs and a link to a blog series.  https://graphql-dotnet.github.io/docs/guides/dataloader. Thanks for this!. Can you elaborate on why you believe that this is not possible?  You can use essentially that same code in your resolver and return null to provide the same result, or provide a more generic try/catch in field middleware to do the same.. Agreed that having those extra error handlers would be nice.  Path, Field (FieldAst) and Document are all found on the FieldResolutionContext so you can use those to call AddLocation and set Path.. Also note that at present other error fields are not serialized.  So that is an example of something not currently possible.  Have ideas for making that easier to customize?\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/514fa76063c05cf3e4d60514c1b6eedb5ac69722/src/GraphQL/Execution/ExecutionResultJsonConverter.cs#L48. I failed to link this issue, though in #578 it does now catch ExecutionError.  The generic error handler is still there though.. A note on this - the GraphQL spec now defines an extensions section for errors.  We have added data and code to that.  So at present you can add extra info to data which will get serialized to the extensions on the error.  See #748 \nhttp://facebook.github.io/graphql/June2018/#sec-Errors\njson\n{\n  \"errors\": [\n    {\n      \"message\": \"Name for character with ID 1002 could not be fetched.\",\n      \"locations\": [ { \"line\": 6, \"column\": 7 } ],\n      \"path\": [ \"hero\", \"heroFriends\", 1, \"name\" ],\n      \"extensions\": {\n        \"code\": \"CAN_NOT_FETCH_BY_ID\",\n        \"timestamp\": \"Fri Feb 9 14:33:09 UTC 2018\"\n      }\n    }\n  ]\n}. Also added a ThrowOnUnhandledException option to ExecutionOptions.  See #776 . @dinoantonello this change was made to conform to the latest GraphQL spec.  Previously this aspect was not well defined.  You could perhaps do your own serialization of the ExecutionResult and include it in both places until all your clients have updated.. No, in GraphQL there is only a single root Query.\nYou can however \"namespace\" your queries on the root Query by providing a \"stub\" field + resolver, as shown here: https://github.com/graphql-dotnet/graphql-dotnet/issues/515#issuecomment-354916397. What version are you using?  This was fixed once already.... Closing this as the examples have moved to here: https://github.com/graphql-dotnet/examples. Yes, so to support ExpandoObject you would have to write your own IFieldResolver that knows how to work with ExpandoObject.  Using a custom IFieldResolver is not currently supported with the handler+Schema syntax.. What would you say your end goal is?  What does ItemsResolveFunc look like?  Typically usage would look more like:\nresolve: context =>\n{\n  var ids = context.GetArgument<List<long>>(\"ids\");\n  return GetStatus(ids);\n}. So what is your end goal?. Behind the scenes, FieldDelegate uses MethodModelBinderResolver.  At present, I'm pretty sure that GetArgument doesn't support IEnumerable<T>, so I'm guessing that could be part of the problem.  The code in MethodModelBinderResolver attempts to match the arguments based on name.  So the name of the argument defined in your GraphType needs to match the argument defined in your ItemsResolveFunc.\ncsharp\nprivate IEnumerable<IItem> ItemsResolveFunc(ResolveFieldContext context, List<long> ids)\n{\n    return from id in ids\n           select new OrderedItem(id);\n}. Not with that setup, no.  GraphQL is designed to work that way.  If you want to retrieve settings without first going through a User, you would have to add that as a top-level field on Query.\ntype Query {\n  users: [User]\n  userSettings(id: String!): UserSettings\n}\n. That would be possible, yes, though I would not suggest doing that as it would be way less performant than just loading those simple values (according to your example) up front.\nYou can see what sub fields are requested by checking SubFields on ResolveFieldContext.. You can use the DataLoader pattern for lazy resolving.  No docs yet, though you can look at the tests.\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.DataLoader.Tests\nTracking docs for DataLoader here: #560 . #564 . No this is not currently supported.  It would most likely require significant changes to the current design of the library.. There is no current plan to try to support this scenario in the near future.  You could perhaps get close to something working with implementing your own IFieldResolver (work with JObjects vs. class properties + methods).  Though the internal system would still need the GraphQL Schema Model to know how to execute the GraphQL requests.. @elauffenburger For sure, I would be interested in seeing what you came up with.. Codegen in the \u201cnew world\u201d is with Roslyn.  My colleague Jeremy Miller is doing some interesting stuff with that in his new project BlueMilk.  I would lean towards something like that for .NET Core.\nhttps://github.com/JasperFx/bluemilk\nUnless you want to dive into that, it\u2019s fine just seeing what you\u2019re doing with the dynamic assembly stuff.. Thanks for the feedback.  In this instance _executer is IDocumentExecutor.. The result is the result of the GraphQL query.  You would typically pass that result to a DocumentWriter to convert it to JSON.\nFull example of a console app in the basics section:\nhttps://graphql-dotnet.github.io/getting-started/#basics. I've updated the docs to mainly use:\ncsharp\nvar schema = new Schema();\nvar json = schema.Execute(_ => { ... });. Thanks for the PR!  Pondering on this one for a little bit but wanted to let you know I've looked at it.. Hey, sorry for letting this linger.  #627 was recently merged.  I think we can update the ValidationError to use that Code and remove it's associated ErrorCode.. \ud83d\udc4d I would probably change the Stack to a Dictionary + TryGetValue for lookup.. Sorry to hear about that!  I think that Field<TGraphType> will need to stay at IGraphType, though could probably change AddField on ComplexGraphType to be virtual and ensure the given type does not inherit from ObjectGraphType.  Both InputObjectGraphType and ObjectGraphType inherit from ComplexGraphType.. That sample has been deprecated (and I will be removing it from the source very soon here ...) in favor of https://github.com/graphql-dotnet/example-aspnetcore - can you give that one a try?. @elauffenburger Hey, sorry I haven't been able to dig into this at all yet.  Still on my \"at a future date\" list.  \u2639\ufe0f . May want to have a look at how DocumentValidator walks the tree.  It uses TypeInfo to keep track of context within the document tree (so you can look at parent types and such).\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/3f2355aacd6cfd8e080dba1d802b2fa00f958f85/src/GraphQL/Validation/DocumentValidator.cs#L35-L59. @thivy there are no plans to merge this at this time.  This is based on my ability to support this code in the future.  Right now that is not possible.. I would suggest to use IsTypeOf instead.  The IGraphTypes are defined in the Schema class for you, though ResolveType is not optimal.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/ea0a324eb659c309fa70adced3aac5c5922c6a30/src/GraphQL.Tests/Utilities/SchemaBuilderExecutionTests.cs#L92-L132. You can read more about IsTypeOf vs. ResolveType here:\nhttps://graphql-dotnet.github.io/getting-started/#istypeof\nhttps://graphql-dotnet.github.io/getting-started/#resolvetype\nEspecially in large domains I would highly suggest to not use ResolveType (as it is required to be exhaustive), if nothing else just for maintainability and de-coupling.\nI have not done any performance testing between the two definition patterns with those numbers.  I would not expect there to be any significant difference (they both essentially use the same patterns), though only the numbers would tell us.  The text-based schema definition may use a bit more reflection, so that could show with that type of load.  Compiled funcs or generated classes would be faster, though I haven't been able to fully look into that yet.  The major things that could be done to increase performance mostly seem to be query validation and metrics.  So if your domain is executing the same queries or mutations over and over, you could use \"compiled queries\", a pattern where the server is already familiar with that query.  So you could bypass validation since it already knows it is valid and already have a pre-parsed re-usable Document cached in memory.\nField middleware has been identified as particularly slow (it needs a bit of a re-design), and that is what Metrics currently uses.  So I would suggest to disable that.\nWe have some rudimentary performance tests here: https://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.Tests/Execution/Performance\nSee here for a discussion on performance: https://github.com/graphql-dotnet/graphql-dotnet/issues/435. Can you talk to as per why you would want to use ResolveType over IsTypeOf?  Do you have a specific scenario or just looking for parity?  From what I understand, Apollo also supports __isTypeOf as well as __resolveType (though it does not appear to be documented).\nTaken that example given, to be able to add another Vehicle, say Boat, you would have to make the Boat type and edit the ResolveType function for Vehicle.  Otherwise you would never be able to useBoat, even though it was added as a type.  Using IsTypeOf all you need to do is add Boat and any other number of types that implement Vehicle and you don't need to ever edit Vehicle.\nThe idea here being that IsTypeOf follows Open/Closed principle and ResolveType does not.  I've found that ResolveType is a \"gotcha\" that people new to GraphQL run into.\njavascript\nconst resolverMap = {\n  Airplane: {\n    __isTypeOf(source, context, info) {\n      return Object.prototype.hasOwnProperty.call(source, 'wingspan')\n    }\n  },\n  Car: {\n    __isTypeOf(source, context, info) {\n      return Object.prototype.hasOwnProperty.call(source, 'licensePlate')\n    }\n  }\n}\nvs.\n```javascript\nconst resolverMap = {\n  Vehicle: {\n    __resolveType(obj, context, info){\n      if(obj.wingspan){\n        return 'Airplane';\n      }\n  if(obj.licensePlate){\n    return 'Car';\n  }\n\n  return null;\n},\n\n},\n};\n```. Just a note to myself:\nCould return a GraphQLTypeReference and have the engine find the real type if that is what is returned.  Could also change the signature of ResolveType to supply the Schema or a context class that contained the Schema.\nreturn new GraphQLTypeReference(\"Car\"). Makes sense.  Taking a look, with the recent changes made to support DataLoader making changes to support either of those scenarios I mentioned is going to be harder than I thought.. Hey, I think you added this to the wrong project.  Perhaps this is the QtSharp project you're looking for?\nhttps://github.com/ddobrev/QtSharp. Thanks for the report!  Indeed I do believe that is a bug.. > I'm assuming that advanced field equivalence (i.e. are the arguments the same) is already checked during validation.\nNot yet. That is the last validation rule not yet implemented.  #160 . So, I have no problem including symbols as I can see that being useful.  My main concern is running out of space quickly on myget.org (only 500MB allowed).  In addition, right now pushing to nuget.org happens from myget.org, so also pushing symbols may be a second manual step.\nWhat I'm thinking is: merge this and try it out.  If it becomes a problem then revert.. Hey, thanks for the PR though I've decided to not pull this in.  That func is marked as obsolete for users to have an easier upgrade path.  It will be removed in the next major version.  I would rather see the warnings than forget about it later.\nAlso, that link you posted does not apply to the purpose of setting the properties to null.  Setting the properties to null is removing those references so they can get garbage collected.\nSee this note from that link:\n\nSetting an object (reference) to null is NOT required to get the item to be garbage collected, unless failing to do so would ensure a (strong) reference to the object is kept alive.\n\nSo this is ensuring there is no strong reference (which there may be).. For whatever reason CI failed when this was merged (the PR ran fine).  Re-running CI to build the package.. Pushed 2.0.0-alpha-870 to NuGet.org. I would agree that having both the parse (data coming in) and serialize (data going out) should know how to handle both.\nI would think that the output should still always be a bool, but update it so if it is a number then it provides the correct boolean value?. @KoditkarVedant Still up for grabs.  Yes, need to make a change in the Serialize for BooleanGraphType to call ParseValue.  Can add tests for Serialize to here.  https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Types/BooleanGraphTypeTests.cs. Closing as this has now been fixed.. Related: #564 . Thought on this for a while.  I'm going to go with adding an option to ExecutionOptions to re-throw unhandled generic Exception while still catching and handling ExecutionError.. How is QueryEngineParameterType defined?  Is it a InputGraphType?. That error is from here:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/41c516a9f4be08d9b338b94c9da39c4c3f35ee7a/src/GraphQL/Execution/ExecutionHelper.cs#L166-L175\nSo it appears that those variable values are not ever getting to there.  I'm guessing it is failing on line 168.  How are you passing your variables to the execution engine?  Are you using the .ToInputs extension method?  That method does a conversion from JSON.NET types to basic .NET types which the core engine relies upon.\nhttps://graphql-dotnet.github.io/getting-started/#variables\nA couple snippets from this example:\nhttps://github.com/graphql-dotnet/example-aspnetcore/blob/master/src/Example/GraphQLMiddleware.cs#L59\n```csharp\npublic class GraphQLRequest\n{\n    public string OperationName { get; set; }\n    public string Query { get; set; }\n    public JObject Variables { get; set; }\n}\nprivate async Task ExecuteAsync(HttpContext context, ISchema schema)\n{\n    var request = Deserialize(context.Request.Body);\nvar result = await _executer.ExecuteAsync(_ =>\n{\n    _.Schema = schema;\n    _.Query = request.Query;\n    _.OperationName = request.OperationName;\n    _.Inputs = request.Variables.ToInputs();\n    _.UserContext = _settings.BuildUserContext?.Invoke(context);\n});\n\nawait WriteResponseAsync(context, result);\n\n}\n```. When this library was fairly new, it only supported camelCase just about everywhere.  There were a number of issues logged asking for this to be configurable.  So I would vote for avoiding forcing casing to something specific.\nThere is a IFieldNameConverter that could perhaps be utilized to \"force the preference\".\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Conversion/IFieldNameConverter.cs. There are pre-release versions of 2.0 on nuget.  There won't be any more 0.x versions published.  Here are the milestones that need to be complete for an official 2.0 release:\nhttps://github.com/graphql-dotnet/graphql-dotnet/milestone/2. Perhaps you could use a dataloader?  I'm not sure if that would exactly fit (needing a sub property of what is loaded), but seems like that could potentially be supported.\nhttps://graphql-dotnet.github.io/dataloader/. I was going to suggest to do some perf testing on it, but if @johnrutherford has already done so with those previous changes then I'm leaning towards not including this.  Admittedly that performance concern is why this was bumped from the initial 2.0 release.. That error means there is not a field defined on Human with the value of name - but there is one with Name.  So in your query you should be using Name instead of name, or change the field on Human to be name.\ncsharp\nResolvedType = new HumanType(data)\nThe above is a code smell and could lead to issues.  Namely, it could lead to multiple instances of the HumanType and you would start to see odd behavior.  If you need to inject data, use an IOC container instead of trying to manually construct the ResolvedType like this.  Constructing your own FieldType means you need to do a lot of the configuration yourself.  If you want to go that route I would suggest to look at the code in ComplexType which has a number of helper methods to properly construct a FieldType.\nIf you are trying to dynamically build a schema, I would suggest to look at SchemaBuilder and utilize GraphQLTypeReference where you need to dynamically reference other types.\nYou can also use SchemaPrinter to see the structure of your built Schema.. > I thought field names are camel-cased automatically, aren't they?\nFields are cased based upon the setting in Schema.FieldNameConverter, which defaults to CamelCaseFieldNameConverter.\n\nare mutations supposed to work with a dynamically constructed schema the way I am trying to make them work?\n\nYou are probably experiencing the issue I spoke of due to how you have it constructed.  There should only ever be 1 instance of a given GraphType for a given Schema.  So new HumanType(data) tells me that there could be more than 1 instance since you are manually creating that GraphType.  That instance should also be registered with the Schema.  So if you have a new HumanType anywhere, that should immediately be followed by a schema.RegisterType(humanType).\nThe field names are probably not using FieldNameConverter due to that manual creation of HumanType and it not being registered with the Schema.. @mike-niemand your issue appears to be using an Input Type as a return type.  You need a different GraphType as the return type for the field definition.\n```\nField -> Field\npublic class ConsultantType : ObjectGraphType\n``. Mind sharing what you ended up going with?  This has been a TODO.  Since you may also want to filter what is returned with Introspection.. That example is using the 2.0 pre-release which is newer than 0.17.3.  So you can upgrade to the pre-release or use the setup that is required in 0.17.3, which is just removing theFuncDependencyResolver` type.\n2.x\nservices.AddSingleton(\n  s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));\n0.x\n``\nservices.AddSingleton( \n  s => new StarWarsSchema((type) => (IGraphType)s.GetRequiredService(type)));. 2.0 is currently the master branch. @fiyazbinhasan Yes, if you do not provide a dependency resolver to your Schema then if you attempt to do constructor injection in any other GraphTypes in the graph then it will fail.  By default, if no dependency resolver is provided, it attempts to useActivator.CreateInstance` to create the graph types.. Updates related to this in #780.. They are essentially functionally equivalent when it gets executed, though it provides different features such as resolving the arguments for you strongly typed.  I can see removing that from the example since it creates confusion, though it provides a different purpose (and was a contribution by someone in the community that DID want the feature).. >  If you aren't sure what value it provides\nI DO know what value it provides as mentioned in my previous post.  That is why this was closed and marked as wont fix.. I believe that is a bug, fixed in #626. Going to close this one, thanks!. Closing this as an implementation was added in #700 . Yes they should be merged.. Looking at this again they are different (one is instance-based and one is type-based).  Though perhaps their names could be updated and moved \"closer\" to each other in the repo.. Since that is adding a couple more options, mind switching that to a Options object instead of more optional parameters?. Mind adding those custom scalars to the options as well?  Then will merge.. Yep I\u2019m fine with that.. Sorry, just noticed a couple items.. Resolved in #647 . None at all, that is a bug.. I could see that making sense for custom validators.  As a work-around at present, you could include those inputs on your UserContext, since that is available on the ValidationContext.. Hey, thanks for trying out the project!  Those would certainly be things that can be added though I won't be able to get to them in the near future.  I would gladly review a PR for it.. Merged in #635 . I like this idea though looks like this has a test failure.. There are two different issues.  One is a flakey test, the other appears to be some changes that AppVeyor may have made.  I'm looking into it.. ResolveFieldContext.Arguments is a dictionary with arguments.   Should be able to pull values from there.  If it is multiple levels deep then you would have to do some additional casting to/from Dictionary<string,object>().. Ah - you could create your own scalar type to do that.  To convert it from your value object to a string.. Something like this:\n```\nField(\"email\", resolve: context =>\n{\n    return new Email{ Value = \"me@me.com\"};\n});\npublic class Email\n{\n    public string Value { get; set; }\n}\n\npublic class EmailGraphType : ScalarGraphType\n{\n    public override object ParseLiteral(IValue value)\n    {\n        if(value is StringValue)\n        {\n            return ParseValue(((StringValue)value).Value);\n        }\n\n        return null;\n    }\n\n    public override object ParseValue(object value)\n    {\n        if(value is string)\n        {\n            return new Email { Value = value.ToString() };\n        }\n\n        return null;\n    }\n\n    public override object Serialize(object value)\n    {\n        return ((Email)value).Value;\n    }\n}\n\n``. @PascalSenn You can access variables onResolveFieldContext` today if you need that scenario.\nI'm seeing this as a global available to all resolvers like UserContext.  So you could add to it in a Resolver if you would like, but it wouldn't be scoped to a node tree.. Have you been using the ExposeExceptions option in the ExecutionOptions?  That should show the inner exception if I\u2019m not mistaken.. Can you provide more information?  A project that reproduces this error?. I won\u2019t be pulling this one in. It should reference the nuget version.. That sample is deprecated.  See one of these:\nhttps://github.com/graphql-dotnet/example-aspnetcore\nhttps://github.com/graphql-dotnet/example-orders. The build script is doing a npm install -g npm.  It appears the latest version of npm is causing an issue.  So need to update the build script to fix that.. https://github.com/graphql-dotnet/graphql-dotnet/blob/58ba1ea0b769a3fc88c7e8daad45c1c1515f36cf/appveyor.yml#L14. I'll take a look.  I'll mention that I'm not a huge fan of attributes, so I'm hesitant with making attributes required for subscriptions, since that also makes it required for the other resolvers.  Though I honestly can't think of a better solution yet.  It also seems easy to get wrong since you have to ensure you didn't mis-type the two method names.  Just some initial thoughts.. Hey, sorry for going dark on this.  Would you mind rebasing on master so I can give it a proper review?. It seems like you could use a service locator pattern, though I think that provides a brittle programming model.  It would be easy to expose the IDependecyResolver as a property on the ResolveFieldContext which is what I would suggest.\nI've been trying to think of some other metadata based approach but I'm falling short.. @johnrutherford I view the expensive part is the \"initialization\".  At present the entire graph is walked and the Schema is built. The Schema creates and internally caches all of its associated GraphTypes so all GraphTypes take on the lifetime of the Schema.  It seems like there should be a way to create the primary graph only once but create the resolvers with their dependencies on a per-request basis.. @john1452 yes, at present GraphTypes are created only once for the lifetime of the Schema and resused.  So whatever types are injected to GraphTypes also take on the lifetime of that GraphType and subsequently the Schema.. Duplicate of #607 - can you add your comments there?  Thanks!. Do you need to check authorization after they have already successfully subscribed to that resource?  It seems like it would be way easier to just not allow the subscription in the first place.  You could do that with a pattern like https://github.com/graphql-dotnet/authorization uses.. Arguments are not setup to support DI.  They are designed to use basic DTOs.  So you would need to create a DTO with a parameterless constructor that represents your arguments.. Argument are just a Dictionary<string, object>, so you could write your own mapper if you really like, though having a DTO is a bit easier.. @johnrutherford Able to provide any insight into this?. Because owner on Asset is a complex type, you have to provide what fields on that GraphType you want to query.\nquery {\n    asset(id: \"1\")\n    {\n        id\n        owner {\n            id\n            name\n        }\n        location\n}\nAlso because it is a complex type you will need to configure what GraphType it is.\n```diff\n-Field(a => a.Owner).Description(\"The owner of the asset\");\n+Field(a => a.Owner, type: typeof(ActorType)).Description(\"The owner of the asset\");\n```\nor\n```diff\n-Field(a => a.Owner).Description(\"The owner of the asset\");\n+Field(\"owner\", resolve: ctx => ctx.Source.Owner);\n```\nor\n```diff\nField(a => a.Owner).Description(\"The owner of the asset\");\n+GraphTypeRegistry.Register(typeof(Actor), typeof(ActorType));\n```. Version 0.13+ support NetStandard.  I would suggest to use the latest 2.0 prerelease.. I'll take a closer look next week, though my initial response is I'm not sure I'm comfortable with these changes.  If nothing else, due to the hard break in compatibility (this could have a very large impact).\nDo you have a specific use case you are trying to solve?. Still feeling uncomfortable with these changes.  Mainly with the Source -> SourceObject change and the addition of the async resolver.  I think I would prefer to break people and make returning Task required vs. having two different resolvers that the library has to guess which one to use.. Try context.SubFields. @Jonatthu Was added in 2.0.. I've been thinking on this and admittedly I am a bit resistant to how much this would break people, though at the same time this makes a whole lot of sense.\nI'll gladly review a PR and thanks for the offer!. @SapphireBrand You can create your own custom Scalars.  You do not need this PR merged to support DateTimeOffset.\nThat is partially why this PR is not merged yet.  There seems to be a perception that you cannot write your own scalars.  All of these proposed types are not in the Core GraphQL spec.  Everyone is going to have their own preference on how dates and times are formatted.  I am partially leaning towards just removing Date all together and suggesting that people write their own Scalars and format them as they need.. @RehanSaeed I can be on board with the date / time changes.  I think providing just the seconds or milliseconds for the TimeSpan sounds reasonable for easier integration into other technologies (such as JavaScript).. An interface in GraphQL works just like in .NET.  It provides no default implementation.   If you want to provide a default implementation, you should be able to use inheritance.\n```csharp\n    public abstract class NotificationSubscriptionBase : ObjectGraphType {\n        protected NotificationSubscriptionBase() \n        {    \n            Interface();\n        Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\n        Field(x => x.endpoints);\n        Field(x => x.trigger);\n        Field(x => x.target).Description(\"The triggering event for the subscription.\");                \n    }        \n}\n\npublic class BillingNotificationSubscription : NotificationSubscriptionBase {\n        public BillingNotificationSubscription() \n        {    \n            IsTypeOf = s => (s as NotificationSubscription).threshold != null; \n        Field(x => x.threshold, nullable:true);                                  \n    }        \n}\n\n``. What middleware/endpoint are you using to host the GraphQL endpoint?. @RaySheikh That's the webserver it is deployed to.  How did you create your/graphqlendpoint?  What framework did you use?  ASP.NET Core?  ASP.NET Web Api?  If .NET Core did you write your own middleware or did you use the server nuget package?  Is there a different application running at http://siteroot.com andsubsiteis a new application that hosts the/graphql` endpoint?\nMaybe this will help?\nhttps://stackoverflow.com/questions/4747576/sub-website-in-iis-asp-net. \ud83e\udd37\u200d\u2642\ufe0f Not sure how I can help.  That setup isn't something this project has control over.  My only suggestion would be to check the middleware or endpoint you're using to ensure it isn't expecting absolute paths.. Going to close this as it is not an issue with this project.. @SapphireBrand You probably need to change this registration:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/GraphTypeRegistry.cs#L24\nCan you open a different issue and post more specifics of your setup if that does not fix it?. Not enough information to be of much help.  Primary reason you would be getting nulls is if your resolver returned a null.\nDid an exception happen?  Did you debug your resolver and ensure that it is actually returning data?. What does the rest of your field definition look like?  Looking at that resolver it is returning both a single object and a list.  You would typically have two different fields for that and two different resolvers.. What is the Type returned by _customerRepository.GetAsync?  Assuming its something like Customer,  do you have an associated GraphType that implements CustomerInterface?  Is that GraphType registered with the Schema?\n```csharp\npublic class CustomerInterface : InterfaceGraphType\n{\n  public CustomerInterface()\n  {\n    Field(x => x.Name);\n  }\n}\npublic class CustomerGraphType : ObjectGraphType\n{\n  public CustomerGraphType()\n  {\n    Interface();\n    Field(x => x.Name);\n  }\n}\nschema.RegisterType();\n```. Check out these sections of the docs:\nhttps://graphql-dotnet.github.io/getting-started/#interfaces (including the RegisterType section)\nhttps://graphql-dotnet.github.io/getting-started/#istypeof\nhttps://graphql-dotnet.github.io/getting-started/#resolvetype. Don't see Interface<CustomerInterface>(); on CustomerType.  You probably also need to use a different name for the interface and the implementing type.  Internals of the library may not distinguish between customer and Customer.. \ud83c\udf89 IsTypeOf is added for you if you use ObjectGraphType<T>.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/ObjectGraphType.cs#L25. You were missing Interface<CustomerInterface>();.  I would venture if you removed the IsTypeOf but kept the Interface<> it would work.. Here is one \"trick\" you can do - you can \"group\" them under a subfield.  Something like this:\n```\nField(\"people\", resolve: ctx => new {});\nmutation CreatePersonMutation {\n  people {\n    createPerson(name: \"Joe\") {\n      id\n      name\n    }\n  }\n}\n```\nNot the best perhaps, but an option.. I think the issue you're running into is that KeyValuePair only has a constructor and the code in GetArgument expects a class with a parameterless default constructor and tries to set properties (Key/Value on KeyValuePair are read-only).. Field<ListGraphType<InputMapType>>(nameof(Create.Stats), resolve: context => {\n    context.Arguments[\"createCharacter\"];\n});\nThis code should not work because you have not defined an argument for that field - which you shouldn't be using Arguments with input types anyways. Input types should basically be a 1-1 mapping to your DTOs.. Here's an example of something that works:\nmutation {\n  createCharacter(create: { name: \"name\", set: \"DOMAIN\", stats: [ { key: \"hello\", value: 1  } ] }) {\n    name\n    set\n    stats {\n      key\n      value\n    }\n  }\n}\n```csharp\n    public class Character\n    {\n        public string Name { get; set; }\n        public string Set { get; set; }\n        public IEnumerable Stats { get; set; }\n    }\npublic class CreateCharacter\n{\n    public string Name { get; set; }\n    public string Set { get; set; }\n    public IEnumerable<StatsKVP> Stats { get; set; }\n}\n\npublic class StatsKVP\n{\n    public string Key { get; set;}\n    public int Value { get; set;}\n}\n\npublic class CharacterType : ObjectGraphType<Character>\n{\n    public CharacterType()\n    {\n        Name = \"Character\";\n        Field(x => x.Name);\n        Field(x => x.Set);\n        Field(x => x.Stats, type:typeof(ListGraphType<StatType>));\n    }\n}\n\npublic class CreateCharacterInputType : InputObjectGraphType<CreateCharacter>\n{\n    public CreateCharacterInputType()\n    {\n        Name = \"Character\";\n        Field(x => x.Name);\n        Field(x => x.Set, nullable: true);\n        Field<ListGraphType<StatsInputType>>(\"stats\");\n    }\n}\n\npublic class StatType : ObjectGraphType\n{\n    public StatType()\n    {\n        Name = \"Stat\";\n        Field<StringGraphType>(\"key\");\n        Field<IntGraphType>(\"value\");\n    }\n}\n\npublic class StatsInputType : InputObjectGraphType\n{\n    public StatsInputType()\n    {\n        Name = \"StatsInput\";\n        Field<StringGraphType>(\"key\");\n        Field<IntGraphType>(\"value\");\n    }\n}\n\npublic class MySchema : Schema\n{\n    public MySchema()\n    {\n        Mutation = new CreateMutation();\n    }\n}\n\npublic class CreateMutation : ObjectGraphType\n{\n    public CreateMutation()\n    {\n        Name = \"Mutation\";\n        Field<CharacterType>(\n            \"createCharacter\",\n            arguments: new QueryArguments(\n                new QueryArgument<CreateCharacterInputType>() { Name = \"create\" }\n            ),\n            resolve: context =>\n            {\n                var create = context.GetArgument<CreateCharacter>(\"create\");\n                // create character from arguments\n                return new Character();\n            });\n    }\n}\n\n```. What versions of this library and GraphiQL.js are you using?  Have you been able to make successful requests without using GraphiQL?. I need more information to be able to help.  Can you post what your Schema and GraphType's look like?\nAlso, on the ExecutionOptions you can set ExposeExceptions which will give you the full stacktrace of the error.  You can also see the full exceptions when debugging by looking at the ExecutionResult.\ncsharp\nvar result = schema.Execute(_ =>\n{\n  _.Query = \"...\";\n  _.ExposeExceptions = true;\n});. I highly suggest to not have a \"one resolver for everything\" pattern.\ncsharp\nField<EmployeeTypeInterface>(\"employeeType\");\nThis declaration has no resolver defined, so it will use the default resolver.  The default resolver just looks for a property on the Source object with the given name.  In this case, it expects the Employee object to look like such:\ncsharp\npublic class Employee\n{\n    public EmployeeType EmployeeType { get; set; }\n}\nIf you need to call a function to get that information you need to provide a resolver for it.\ncsharp\nField<EmployeeTypeInterface>(\"employeeType\",\n  context => _employeeTypeRespository.TypeForEmployee(context.Source));. > library throws a error saying that a EmployeeType cannot be returned for an expected EmployeeTypeInterface.\nDid you register EmployeeTypeType with the schema?  If you print the schema is EmployeeType graph type listed as well as the employeeType interface?\ncsharp\nnew SchemaPrinter(schema).Print();\nI should look something like:\n```\ninterface employeeType {\n  id: ID!\n  name: String!\n}\ntype EmployeeType implements employeeType {\n  id: ID!\n  name: String!\n}\n```\n\nCan you also verify that utilizing async methods is handled properly by a Field when resolving?\n\nYes you can use methods that return a Task.  If you want to use the async keyword then you would need to use an overload, FieldAsync.. I would suggest to users to put this on the UserContext vs the Root object. The Root object has other implications (it is used as the Source of the Root Query/Mutation/Subscription), whereas the UserContext is meant exactly for these kind of things.. Closing this as there are other updated docs for DL and there has been no movement on this for a while. Feel free to re-open with any suggested changes to the new docs.\nhttps://graphql-dotnet.github.io/docs/guides/dataloader. Potentially fixed in #769 . csharp\nvar body = \"{\\\"query\\\":\\\"{transactions(term:\\\"hello\\\") {transactionId}}\\\"}\"\nThat is invalid JSON (which is why you get the parse error).  To properly escape the \" around hello you have to include the escaped \\.\ncsharp\nvar body = \"{\\\"query\\\":\\\"{transactions(term:\\\\\\\"hello\\\\\\\") {transactionId}}\\\"}\"\nYou can see the required JSON format by reversing the process:\ncsharp\nvar data = new GraphQLQuery\n{\n    Query = \"{transactions(term:\\\"hello\\\") {transactionId}}\"\n};\nvar body2 = JsonConvert.SerializeObject(data);. @libinks10 This library provides a IDependencyResolver interface.  It is not the same as the one in System.Web.Mvc.IDependencyResolver.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/IDependencyResolver.cs\nYou will want to provide an implementation of that interface for the IoC container you are using.. @RehanSaeed My merging of your other PR created conflicts it appears.  I can merge after those conflicts are resolved.. This is typical if using a ReplaySubject.  It does as you describe by design.  What type of observable are you returning in your subscription?. I'm not sure I'm fully understanding what you're trying to do.  You are trying to dynamically build a Schema based on JObjects?  Or are you fetching data, returned as JObjects, and you're trying to return those values in the resolver?  Can you provide an example of what you're expecting the input arguments to look like in GraphQL Schema syntax?\nEx:\n```\ninput CreateInput {\n  name: String\n  age: Int\n}\ntype Query {\n  person(id: String): Person\n  createPerson(input:CreateInput): Person\n}\n```\nIn this case id and input are the arguments.. So are you trying to go from the benutzerStrasse input field back to benutzer-stra\u00dfe in a mutation?. \ud83d\udc4d My first recommendation would be to write a small object model around that JObject.  Then it could handle that mapping fairly easily for you.\n```csharp\npublic class Benutzer\n{\n    public Benutzer(JObject json)\n    {\n        Json = json;\n    }\npublic string BenutzerStrasse\n{\n    get => Json.TryGetString(\"benutzer-stra\u00dfe\");\n    set => Json.SetString(\"benutzer-stra\u00dfe\", value);\n}\n\npublic JObject Json { get; }\n\n}\npublic static class JObjectExtensions\n{\n    public static JToken TryGetValue(this JObject json, string name)\n    {\n        if (json != null && json.TryGetValue(name, StringComparison.OrdinalIgnoreCase, out JToken value))\n        {\n            return value;\n        }\n    return null;\n}\n\npublic static string TryGetString(this JObject json, string name)\n{\n    JToken value = json.TryGetValue(name);\n    return value?.ToString();\n}\n\npublic static void SetString(this JObject json, string name, string value)\n{\n    json[name] = value;\n}\n\n}\n```\nIf it needs to be more dynamic than that, you could perhaps add the mapping as Metadata on the GraphType or the FieldType.\ncsharp\nvar field = new FieldType\n{\n    Name = key.ToCamelCase(),\n    Resolver = resolver,\n    ResolvedType = fieldInfo.ResolveType,\n};\nfield.Metadata[\"mappedName\"] = key;\nThe FieldType can be accessed in the resolver.\ncsharp\ncontext => context.FieldDefinition.Metadata[\"mappedName\"]\ncontext => context.FieldDefinition.GetMetadata<string>(\"mappedName\");. > skip the generation of the IDictionary and create the objects manually or set the properties\nThere are several things that happen related to the Arguments + Variables to conform to the GraphQL spec and get those specific values to the specified resolver.\nI'm not sure I want to try to deal with this with this framework.\nThat said, if this is really wanted can you provide a proposal on what you would expect that API to look like and how it would behave?. You can still use Schema syntax, though you do have to provide that implementation - just like you have to provide a resolver.  No way around that.\nExample of providing IsTypeOf: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/Utilities/SchemaBuilderExecutionTests.cs#L120\nSee these docs: https://graphql-dotnet.github.io/getting-started/#istypeof. Going to close this, let me know if I can help further.. > My query has an argument that is of GraphQL type Date!\nYou should be using DateTimeOffset vs. Date!, this is what the error is trying to tell you.\n\nGraphQL.Validation.Rules.VariablesInAllowedPosition: \"Variable \"$from\" of type \"Date!\" used in position expecting type \"DateTimeOffset\".\"\n\nYou're defining the arguments to be of DateTimeOffsetGraphType.  So that is the type you need to use in your query.\narguments: new QueryArguments(\n  new QueryArgument<DateTimeOffsetGraphType> { Name = \"from\", Description = \"optional start of date/time range\" },\n  new QueryArgument<DateTimeOffsetGraphType> { Name = \"to\", Description = \"optional end of date/time range\" }\n),\nquery Shipments($from: DateTimeOffset, $to: DateTimeOffset) {\n  shipments(to: $to, from: $from) {\n    id\n  }\n}. Did that get resolved with #693 ?. Probably fine - I'd be curious in hearing what your scenario is?. Hm, you could probably do what you need with the BasicVisitor used in Validation.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/c66b6c0b4cde1cdd7b93d025c60b169f9a0c81d4/src/GraphQL/Validation/BasicVisitor.cs. Something like this?  Not sure if you want VariableDefinition or VariableReference.\n```csharp\nvar document = ...\nvar varDefMap = new Dictionary();\nvar listener = new EnterLeaveListener( =>\n{\n    .Match(\n        varDefAst => varDefMap[varDefAst.Name] = varDefAst\n    );\n});\nvar visitor = new BasicVisitor(listener);\nvisitor.Visit(document);\n// print each variable in varDefMap using AstPrinter.Print()\n``. I should probably move that visitor/listener toUtilities` namespace to make it more discoverable .... Yes. My experience with Docker is minimal, though my understanding is that you create your docker container which copies your compiled asp.net core project to a base image, which would include the dlls from this project.\nhttps://docs.docker.com/engine/examples/dotnetcore/. Let me know if you run into any issues.. You can use this authorization library.  https://github.com/graphql-dotnet/authorization\nLooks like perhaps you looked at it already with .AuthorizeWith(PolicyConstant.Member);?. Ah, my misunderstanding.  At present there isn't an easy way to do it.  What you have currently is the easiest way.  You could probably write a custom validation rule to do it, though it would not be very straightforward.. I'll also note that Facebook suggests to do exactly what you are doing with that type of scenario:\nhttps://graphql.org/learn/authorization/. Another thing that may be of note is the JSON Settings on serialization.  That may want to be customized with the DocumentWriter.. You can use a ValidationRule for this to validate the inputs before it attempts to execute the query.  Here's one of the core validation rules used for the GraphQL spec that deals with Arguments:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/3f2355aacd6cfd8e080dba1d802b2fa00f958f85/src/GraphQL/Validation/Rules/ArgumentsOfCorrectType.cs#L14-L38\nYou can pass the validation rules you want to run to the DocumentExecutor.\ncsharp\nvar executor = new DocumentExecutor();\nvar result = await executer.ExecuteAsync(_ =>\n{\n    _.Schema = schema;\n    _.Query = request.Query;\n    ...\n    _.ValidationRules =\n        DocumentValidator.CoreRules().Concat(new[]{ new EmailValidationRule() });\n});\nYou could add metadata to the QueryArgument to provide a more generic way to configure what validations should be done for that argument, and use some validation library to do the actual check against the given value.. I would say to add the metadata to the QueryArgument.  QueryArgument does not currently have built-in metadata like fields and objects do but should be able to add it.\nThis is what I was thinking:\n```csharp\npublic class MyQueryArgument : QueryArgument, IProvideMetadata\n{\n    // members of IProvideMetadata\n    IDictionary Metadata { get; }\n    TType GetMetadata(string key, TType defaultValue = default(TType));\n    bool HasMetadata(string key);\n}\npublic static class ArgumentValidationExtensions\n{\n    public static QueryArgument IsEmail(this QueryArgument argument)\n    {\n        argument.Metadata[\"validator\"] = \"EMAIL_VALIDATOR\";\n        return argument;\n    }\n}\narguments: new QueryArguments(new MyQueryArgument().IsEmail())\n```\nThen in your ValidationRule you can check to see if the QueryArgument has any associated validations.\n\nGet the validator(s) from metadata, match it with the actual validator(s)\nGet the argument value - it will either be a direct value or a variable, so you may have to pull the value out of a variable\nrun the validator(s) passing it the provided value\n\nSome pseudo code:\n```csharp\n// in the ValidationRule\nvar argumentAst = ...  // this is an Argument from the executed query\nvar argument = ...  // this is a QueryArgument from the Schema\nvar validator = GetValidator(argument);\nvar value = GetValue(argumentAst, argument, context.Inputs);  // context is ValidationContext\nvar validationResults = validator.Validate(value);\n// add any errors to ValidationContext as needed\n```. You only need to use FieldAsync if you need/want to use the async keyword.  You can return a Task and it will be awaited for you with the other overloads.. > is this what you mean\nYes. These are functionally equivalent.  One just allows you to use the async keyword in the resolve: declaration.\n```csharp\nField(\"createTransaction\",\n    resolve: ctx => TransactionInput.CreateTransaction();\nFieldAsync(\"createTransaction\",\n    resolve: async ctx => await TransactionInput.CreateTransaction();\n```. Thanks for the report - mind submitting a PR with a fix?. Deployed in https://www.nuget.org/packages/GraphQL/2.0.0-alpha-927. Supersedes #624 . Deployed in https://www.nuget.org/packages/GraphQL/2.0.0-alpha-927. @KoditkarVedant Thanks for this! #606 . Thanks for the PR! Ending up having two PRs for the same thing. Going with #701 for now.. Closing this as the other PR has now been merged.. @eugenpaval I don't know SignalR myself, though \"yes\" should be the answer.  The core GraphQL library is transport agnostic, so it should be compatible with SignalR.  The core library relies on Observables.  So if SignalR understands those then it should work.. Hey, thanks for the PR though this is one of the cases where I'm not sure I want to add this since it is not defined in the core GraphQL spec.\nFor a \"proper\" implementation you would need to handle the UriValue in the AstPrinter. Also at present I do not believe you would ever get a UriValue, since it would get converted to a StringValue first.  To ever get a UriValue you would need to alter this code.. The milestone is \"up to date\".  Those are the issues that need to be worked on.  There is one regression bug, one breaking change PR waiting changes, and most of the others are documentation.  The larger portion of the work needed is on documentation.  Once all those things are done I would be comfortable pushing an official release.\nhttps://github.com/graphql-dotnet/graphql-dotnet/milestone/2. The GraphQL specification says you can only provide defaults for Arguments and Variables.  So providing a default on a field is pretty much non-standard ... I'm not even sure that's used at all in execution .... So may want to keep this open so we can remove that from FieldType.. #662 Was recently merged which has done an overhaul on date types.  I believe those changes change this behavior to be more in line with what you expect.. This is probably due to a mis-match in the GraphQL specs.  0.17.3 is probably providing an older specification format and the application you're using expects a newer one.. The test harness uses node for GraphiQL.  I\u2019ve used cake and rake on other projects.  I find node to be much easier to use and it\u2019s nice not to have to swap between stacks. On projects that I used cake I also ran cake from node to make cross platform building easier (since you have to use a different entry for cake depending on the platform).  I build on both macOS and Windows.  The main contributors decided to use cake on the server project.  That\u2019s fine, that\u2019s their preference.. #475 . > Currently, I have considered null as a valid field name, as it is currently allowed.\nA null or empty name should not be allowed.\n\nThis test case occasionally fails, even on master branch.\n\nYes that is a flakey test.  It never fails on .NET Core 1.1 or NET45, but it sometimes fails on Net Core 2.0.. Having the default is probably fine for now.  We also need this validation on QueryArgument names, though that could be a separate PR.. I think this looks good.  Since I merged your other PR this one now has a conflict.  If you can fix that then I'll go ahead and merge.. You can configure what GraphType to use for a field a couple different ways:\n```csharp\nField(x => x.OwnerId, type:typeof(StringGraphType))\n  .Name(\"Id\")\n  .Resolve(context => context.Source.OwnerId.ToString());\nField(\"Id\",\n  resolve: context => ((Owner)context.Source).OwnerId.ToString());\n```\nNot sure if I understand fully what you want with the OwnerNames.  Something like this?\n```csharp\npublic class OwnerGraphType : ObjectGraphType\n{\n  public OwnerGraphType(IOwnerStore store)\n  {\n    Name = \"Owner\";\nField<StringGraphType>(\"Id\",\n  resolve: context => ((Owner)context.Source).OwnerId.ToString());\n\nField<StringGraphType>(\"Name\",\n  resolve: context => ((Owner)context.Source).OwnerNames.First());\n\nField<StringGraphType>(\"Name\",\n  resolve: context => store.FetchName( ((Owner)context.Source).OwnerId ) );\n\n}\n}\n```. Yeah ... so EVERY field has a resolver.  If you do not provide one then the default is essentially the following:\n```csharp\nFunc resolver = context =>\n  ReflectionHelper.GetPropertyValue(context.Source, context.FieldName);\nField(\"Id\", resolve: resolver);\n``. Some error is happening in your resolver.  You can setExposeExceptionsonExecutionOptions` and check the results of the request to get more detailed information.. > Is my understanding correct that to surface meaningful error messages, that can only be done through the validation rules? There's no way I can surface useful messages in resolvers unless ExposeExceptions is on?\nExposeExceptions just displays the whole exception including its stacktrace (essentially Exception.ToString()).  The top level exception message is still displayed even if ExposeExceptions is false.  This is handled a bit better in 2.0.  You can add errors directly from your resolver in 2.0, and/or use try/catch in your resolver to throw a GraphQL .NET specific error instead.\nIn your example mutation you do not provide an operation name.\ngraphql\nmutation ($profile: ProfileInput!){ createProfile(input: $profile) {id}}\ncreateProfile is the field.  You can add an operation name like such:\ngraphql\nmutation MyMutation($profile: ProfileInput!){ createProfile(input: $profile) {id}}\nMyMutation is now the operation name.\nHere is a thread that talks about validating input: https://github.com/graphql-dotnet/graphql-dotnet/issues/694#issuecomment-397411404. There is an overload available, FieldAsync. If you create a .NET Type without a parameterless constructor, you have to provide a way for this library to construct that object.  The GraphType's are created on initialization and cached.  This library uses an abstraction for type resolution.  In 0.x that is a simple func, in 2.0 it is  IDependencyResolver.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4e74411859c27c3e44c8b3751abfcb51f2f1adcf/src/GraphQL/Types/Schema.cs#L59-L73\nThe default implementation uses Activator.CreateInstance to construct the types.  Activator.CreateInstance requires a parameterless constructor.  That is the error you're getting.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4e74411859c27c3e44c8b3751abfcb51f2f1adcf/src/GraphQL/IDependencyResolver.cs#L44-L47\nSo if you want to construct types without a parameterless constructor, you need to provide an implementation of the IDependencyResolver interface that knows how to construct your types.\nThe library provides a FuncDependencyResolver to make integration with DI containers easier. \n The examples how how to do it  in.NET Core.\ncsharp\nservices.AddSingleton<IDependencyResolver>(s =>\n  new FuncDependencyResolver(s.GetRequiredService));\nhttps://github.com/graphql-dotnet/examples/blob/cbb177b606b1750a112ab4574d6c288e77f5342f/src/AspNetCoreCustom/Example/Startup.cs#L18\nThen you need to make sure all of your GraphTypes and their dependencies are registered with your container, so they can be resolved through your container.. \ncsharp\npublic class GamesDataType : ObjectGraphType<GamesData> \n{\n    GamesDataType()\n    {\n    }\n}\nThis has a private parameterless constructor, but not a public one.  Activator.CreateInstance also requires it to be public.\ncsharp\npublic class GamesDataType : ObjectGraphType<GamesData> \n{\n    public GamesDataType()\n    {\n    }\n}. Np, it took me a few passes to see it myself! \ud83d\ude06 You're not the first to get tripped up by this, so perhaps I can catch this specific error when using the Default dependency resolver and provide a more helpful one.. You would need two different fields for that.\n```graphql\ntype User {\n  id: ID!\n  name: String!\n}\ntype Query {\n  user(id: ID!): User\n  users(country: String): [User!]!\n}\n```\n! signifies that a value is non-null.. (P.S. You can see a view of your Schema in that syntax by using SchemaPrinter).\ncsharp\nConsole.WriteLine(new SchemaPrinter(schema).Print());. Change Field<UserType>(..) to Field<ListGraphType<UserType>>(...) for users.. Here's a good tutorial that goes through a lot of things and uses EF.  http://fiyazhasan.me/tag/graphql-dotnet/. I think it would be helpful.  I was just looking at the basic StarWars example and it doesn't show returning a list of data.  So it would be helpful for sure.  This example has a few more features too: https://github.com/graphql-dotnet/example-orders. \ud83c\udf89 . I've pushed an updated docs site based on gatsbyjs.  This will make it easier to split sections up.\n~I've basically kept what was there for now, but I was planning on pulling out a lot of the sections into their own documents.~\nI've pulled out the sections into their own documents.\nhttps://graphql-dotnet.github.io/. Awesome!  Thanks for this! #381 . The sample is correct. You\u2019re mapping to a DTO, not a GraphType.  The InputGraphType represents the structure of the data only.  That code is mapping a Dictionary of values to a class structure.  The GraphType doesn\u2019t contain those properties.. > DTO = data transfer objects\nYes.\nHere is the StarWars Schema code, where the Human type very much exists.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/fbfc8c3ebe86fbeed7ca5ccb378252cb9e994ae9/src/GraphQL.StarWars/Types/StarWarsCharacter.cs#L11-L14\nAnd in the samples:\nhttps://github.com/graphql-dotnet/examples/blob/a62468ebd08e6241502a33a9ff3bc5d33a9ea0ae/src/StarWars/Types/StarWarsCharacter.cs#L11-L14\n\nI can't figure out how to access the values passed in from the argument.\n\ncontext.Arguments is a Dictionary<string, object> which contains the values passed to that resolver.  Those values are calculated based on variables, inline values and default values.  Its your job to figure out how to map that Dictionary<string, object> to whatever format your data store requires.  Typically the easiest way to do so is a DTO, which the library provides that GetArgument method to use.\n\nAnd do I simply return the newly created database object and the library takes care of mapping that to UserType?\n\nYep, that's how it works.  Your GraphType represents the structure of your data.  As long as you provide the engine a class instance with the structure that it expects it will do the work for you.  That's where IsTypeOf kicks in, to map the DTO to a GraphType if the GraphType is an InterfaceGraphType or UnionGraphType.. Yes, the documentation could use updating.  I encourage you to run the example code which has all of that fully working and setup.. #602 . I went ahead and added those changes in #756 since they were minor.  Thanks for the help here!. https://github.com/graphql-dotnet/graphql-dotnet/blob/fbfc8c3ebe86fbeed7ca5ccb378252cb9e994ae9/src/GraphQL/Types/Schema.cs#L64-L71\nProviding a Func<Type, IGraphType> resolveType is the old way of providing Dependency Injection for a Schema.  This has been replaced with an IDependencyResolver interface in 2.0, which the docs have not been updated yet to display.  The examples show this in use.\nAlso - I know you have a lot of questions.  Since you have a lot of questions, can you please just keep them in a single issue instead of creating so many different ones?  We can open separate issues if there are specific tasks or features that need to be done.. Please use the original thread you opened and not this closed one.  The reason I ask is so that I don't have to keep jumping between issues to answer questions.\n\nIs there a reason the library can't abstract away most of this? Why can't we simply do Mutation = new MyMutation(dbContext); like we do for adding a query?\n\nYou can.  There is literally no difference in the code you write for a mutation vs. a query.  The engine does execute them differently - a mutation is executed serially whereas a query is executed in parallel.. It should work just like the other setup.  You just need to include the Type's that define your resolvers.  The Schema Syntax provides the skeleton of your Schema and the types you include are the resolvers for that schema.\ncsharp\n_.Types.Include<Query>();\n_.Types.Include<MyOtherType>();\n\nComplex resolvers in the new system only have access to specific injected properties, of which only the UserContext is customizeable.\n\nThis is also true of the \"old system\".  The only way to get other services is through injection of the GraphType constructor.\nWas there something specific you were trying that wasn't working?. You can introduce a new DroidType that represents the GraphType, just like Query represents a GraphType.   DroidType is resolved through the container and you can get injected services. Today on DroidType you still have to add all the schema defined fields.  For simple properties it would be nice to be able to exclude that and just look at the source object.\nLink for a console app of the following.\n```csharp\nvar schema = Schema.For(@\"\n  type Droid {\n      id: String\n      name: String\n      friend: Character\n  }\ntype Character {\n      name: String\n  }\ntype Query {\n      hero: Droid\n  }\n\", _ =>\n{\n    .Types.Include();\n    .Types.For(\"Droid\").IsTypeOf();\n    .Types.Include();\n    .DependencyResolver = new FuncDependencyResolver(type => container.Get(type));\n});\npublic class IImportantBusinessObject\n{\n    public Guid Id => Guid.NewGuid();\n}\n\npublic class Droid\n{\n    public string Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class Character\n{\n    public string Name { get; set; }\n}\n\npublic class MyUserContext\n{\n}\n\n[GraphQLMetadata(\"Droid\")]\npublic class DroidType\n{\n    public DroidType(IImportantBusinessObject obj)\n    {\n        Object = obj;\n    }\n\n    private IImportantBusinessObject Object {get; set; }\n\n    public string Id(Droid droid) => droid.Id;\n    public string Name(Droid droid) => droid.Name + \" \" + Object.Id.ToString();\n\n    public Character Friend(ResolveFieldContext context, Droid source, MyUserContext context)\n    {\n        return new Character { Name = \"C3-PO\" };\n    }\n}\n\npublic class Query\n{\n    public Query(IImportantBusinessObject obj)\n    {\n        Object = obj;\n    }\n\n    private IImportantBusinessObject Object {get; set; }\n\n    [GraphQLMetadata(\"hero\")]\n    public Droid GetHero()\n    {\n        return new Droid { Id = \"1\", Name = \"R2-D2\" };\n    }\n}\n\n``.IsTypeOf` is optional in this case, but it is good practice to provide one.\nhttps://graphql-dotnet.github.io/docs/getting-started/interfaces#istypeof\nI added some overrides to the registration, so you can exclude the GraphQLMetadata attribute on the type and do it in the Include.\ncsharp\n_.Types.Include<DroidType, Droid>(\"Droid\");\ngraphql\n  type Droid {\n      id: String\n      name: String\n      friend: Character\n  }\nThe GraphQL schema syntax defines the structure and return types of the GraphQL Type.\ncsharp\n_.Types.Include<DroidType>(\"Droid\");\nThis Include tells the framework - \"For the Droid schema type, use the fields/methods on DroidType as the field resolvers.  For simple types that do not need computed values, you do not have to provide a type with resolvers - the framework will build one with basic resolvers that attempts to read properties on the source object.. Since an errorCode was not part of the spec, that was the main reason to not serialize it.  Now that there is a spec for it, we can refactor that to use extensions instead.. At present it should be showing a code and data though ... so that seems like a bit of a design issue in that both ValidationError and the ExecutionError now have two different code properties.  So that should be fixed.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/4e74411859c27c3e44c8b3751abfcb51f2f1adcf/src/GraphQL/Execution/ExecutionResultJsonConverter.cs#L79-L95. @KoditkarVedant Indeed it is.. @KoditkarVedant One is just a more specific error.  Kind of like NullReferenceException vs. Exception.. > I think we should have another constructor which do not accepts nodes.\nSince it is a params, it is essentially optional.  params allow you to pass zero or more values.\n\nit is very specific and mainly used by IValidationRule.\n\nThat is what it is designed for.  You provide a node so the end user can know exactly what part of the query is giving the validation error.\n\nDid you get time to review it?\n\nYes, I added comments to it.. Seems like a good addition to me.. @SimonCropp thanks!. It's been a very long time since I had to deal with a DataTable, though I think you should be able to create a IFieldResolver that knows how to work with a DataRow.\n```csharp\npublic class QueryGraphType : ObjectGraphType\n{\n    public QueryGraphType()\n    {\n        Name = \"Query\";\n        Field>(\n            \"employees\",\n            // notice that the 'DataTable.Rows' are being returned\n            // the GraphQL library should loop over those rows (hopefully)\n            resolve: context => GetAllEmployees().Rows\n        );\n    }\npublic DataTable GetAllEmployees()\n{\n    return ...;\n}\n\n}\npublic class EmployeeGraphType : ObjectGraphType\n{\n    public EmployeeGraphType()\n    {\n        Name = \"Employee\";\n        // new extension method for your custom field type\n        this.DataRowField(\"Id\");\n        this.DataRowField(\"Name\");\n    }\n}\npublic static class ObjectGraphTypeExtensions\n{\n    public static void DataRowField(\n        this ObjectGraphType type,\n        string name,\n        string description = null,\n        QueryArguments arguments = null,\n        string deprecationReason = null)\n        where TGraphType : IGraphType\n    {\n        // create a new FieldType with your custom DataRowResolver\n        type.AddField(new FieldType\n        {\n            Name = name,\n            Description = description,\n            Type = typeof(TGraphType),\n            Arguments = arguments,\n            DeprecationReason = deprecationReason,\n            Resolver = new DataRowResolver()\n        });\n    }\n}\npublic class DataRowResolver : IFieldResolver\n{\n    public object Resolve(ResolveFieldContext context)\n    {\n        var row = context.Source as DataRow;\n        // context.Name is the name of the field\n        // registered on FieldType\n        return row[context.Name];\n    }\n}\n``. Thanks!. You have access to variables and the parsedDocument+Operationin theResolveFieldContext`.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/ad9c5c8523dde84dd040755a80d829b1f74ede9e/src/GraphQL/Types/ResolveFieldContext.cs#L33-L39. Seems fine to me.  These have been requested a few times.. Merged in #812 . Looks like this is indeed a bug with the new DateGraphType.  I've tracked it down to the GraphType not properly converting the string to a DateTime on serialization.. The fix is released and pushed to Nuget.  May take a bit for it to be indexed.  https://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-951. This is pushed as GraphQL 2.0.0-alpha-952.  Will take Nuget.org a while to index it.. Probably a good idea.  Either there or the AddValue method.. @tsteele it has always been \u201csupported\u201d, as in you are able to do it.  The GraphQL spec however does not specify handling files.  So there is nothing built-in specifically for file handling.  It is entirely possible to do it though.. The generic version of EnumerationGraphType tries to add all the enum values for you so you don't have to duplicate them.  This is helpful in most cases.\nYou should be able to just override the Name and it will still set all the enum values for you?\npublic class OrganisationAccessLevelEnum : EnumerationGraphType<Organisation.AccessLevel>\n{\n    public AccessLevelEnum()\n    {\n        Name = \"OrganizationAccessLevelEnum\";\n    }\n}\nNote that with using the non-generic version you will still be required to set the Name.. There is nothing build-in, but you could inspect the request to determine it is introspection and not allow it.  Either by using a validation rule (probably the easiest) or you can build the Document yourself and inspect it.\n```csharp\nvar documentBuilder = new GraphQLDocumentBuilder();\nvar document = documentBuilder.Build(options.Query);\n// loop through operations + fields and see if it is introspection\n// pass Document to executor so it doesn't have to build it again\nschema.Execute( =>\n{\n    .Query = options.Query;\n    _.Document = document;\n});\n```\nValidation rules already loop through operations + fields for you.\n```csharp\npublic class IntrospectionNotAllowed : IValidationRule\n{\n    public INodeVisitor Validate(ValidationContext context)\n    {\n        return new EnterLeaveListener(_ =>\n        {\n            var myContext = context.UserContext as MyGraphQLContext;\n        if(!myContext.IsProduction()) return;\n\n        _.Match<Field>(\n            enter: field =>\n            {\n                // don't recall the exact properties off-hand\n                if (field...)\n                {\n                    var error = new ValidationError(\n                        context.OriginalQuery,\n                        \"code1\",\n                        \"Not allowed\",\n                        field);\n                    context.ReportError(error);\n                }\n            });\n    });\n}\n\n}\n```. Thanks!  Awesome avatar - love Kenshin.. You should be able to return anything from a subscription that you can return as a \"normal\" GraphQL query.  That being said, I haven't tried this exact scenario.  If you can provide a test that shows this not working that would be helpful in tracking down any issue there may be.. @BitPuffin We can just use this issue.  Are you using the server project for subscriptions?. Yep I\u2019ll take one.. What does your controller look like?  Did you add an Authorize attribute to it?  Did you add a a setting to require Auth on all controllers?. Have you tried hitting your endpoint manually in the browser or that GraphiQL middleware?  Do you get the same 401?\nWhat does your ConfigureServices(IServiceCollection services) look like?  Are you adding any authorization middleware?  Authorization filters for MVC?\nSomething like this would require auth on all controllers.\n```\nservices.AddMvc(options =>\n{\n  var policy = new AuthorizationPolicyBuilder()\n    .RequireAuthenticatedUser()\n    .Build();\noptions.Filters.Add(new AuthorizeFilter(policy));\n});\n```\nYou could also try adding the [AllowAnonymous] attribute.\nOther than that, I'm out of ideas.. Not much I can do to help since it appears this isn\u2019t an issue with this project.  My last suggestion is to look at the http request in the browser to make sure it is going to your server and to the correct endpoint.. A note on this, it appears there is a versioning issue with the server project so need to update that to the official release.  Working on that.\nEdit: https://github.com/graphql-dotnet/server/pull/145. This is done.. This is due to how the server project set the version.  It should be fixed with this PR https://github.com/graphql-dotnet/server/pull/145. Think you could write a test to demonstrate this behavior?. I think that would be fine for a 3.0 release.. Yes - this was fixed here: https://github.com/graphql-dotnet/server/pull/145\nWaiting on official release here: https://github.com/graphql-dotnet/server/pull/146. What version are you using?\ncsharp\nField(\"startDate\", x => x.Date);\nUsing that works for me to rename fields, so perhaps you are just getting an error?  Can you try inspecting the full exception?\nYou can set ExposeExceptions on ExecutionOptions which will expose error stack traces.\nhttps://graphql-dotnet.github.io/docs/getting-started/errors\nYou could also try the following so you can set a breakpoint during execution:\ncsharp\nField<DateGraphType>(\"startDate\", resolve: context =>\n{\n    var source = (MyObject)context.Source;\n    return source.Date;\n});. :+1:. > allow for user defined conversions to be defined\nIt is currently possible to create your own scalars, it is just not well documented.  You should be able to create a NodaTime package as an add-on without further changes to this library.\nTake a look at GraphTypeTypeRegistry, which is where you can override or add the default scalar GraphType for a specific .NET type.\nValueConverter for any value conversions.\nThis is where the conversion to an IValue happens for scalars.  If one of those does not work for your scalar GraphType, then you can register your own with the Schema.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/d90a1a4daa80dff4844c3e361b12366d25199fac/src/GraphQL/Types/Schema.cs#L46\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/d90a1a4daa80dff4844c3e361b12366d25199fac/src/GraphQL/GraphQLExtensions.cs#L372-L441. You won't be using DateGraphType since it doesn't know how to work with a LocalDate (I'm assuming that is a NodaTime Type).  You will need to write your own custom scalars to work with the NodaTime Types.\nHere's an example of a custom scalar for LocalDate:\n```csharp\npublic class LocalDateValue : ValueNode\n{\n    public LocalDateValue(LocalDate value)\n    {\n        Value = value;\n    }\nprotected override bool Equals(ValueNode<LocalDate> other)\n{\n    return Value == other.Value;\n}\n\n}\npublic class LocalDateValueConverter : IAstFromValueConverter\n{\n    public bool Matches(object value, IGraphType type)\n    {\n        return value is LocalDate;\n    }\npublic IValue Convert(object value, IGraphType type)\n{\n    return new LocalDateValue((LocalDate)value);\n}\n\n}\npublic class NodaLocalDateGraphType : ScalarGraphType\n{\n    public StringGraphType()\n    {\n        Name = \"LocalDate\";\n    }\npublic override object Serialize(object value)\n{\n    return ParseValue(value);\n}\n\npublic override object ParseValue(object value)\n{\n    return ValueConverter.ConvertTo<LocalDate>(value);\n}\n\npublic override object ParseLiteral(IValue value)\n{\n    var localDate = value as LocalDateValue;\n    return localDate?.Value;\n}\n\n}\n// set default GraphType for LocalDate, so you can use Field(x => x.MyLocalDate) syntax\nGraphTypeTypeRegistry.Register(typeof(LocalDate), typeof(NodaLocalDateGraphType));\nValueConverter.Register(typeof(DateTime), typeof(LocalDate), value =>\n{\n    // however you convert a DateTime to a LocalDate\n    return ConvertToLocalDate(value);\n});\nValueConverter.Register(typeof(string), typeof(LocalDate), value =>\n{\n    // however you convert a string to a LocalDate\n    return ConvertToLocalDate(value);\n});\nValueConverter.Register(typeof(DateTimeOffset), typeof(LocalDate), value =>\n{\n    // however you convert a DateTimeOffset to a LocalDate\n    return ConvertToLocalDate(value);\n});\n// register your GraphType and ValueConverter with your schema\nschema.RegisterType();\nschema.RegisterValueConverter(new LocalDateValueConverter());\n``. Usage ofNodaLocalDateGraphType` would look like:\n```csharp\npublic class MyObject\n{\n    public LocalDate MyLocalDate { get; set; }\n}\npublic class MyGraphType : ObjectGraphType\n{\n  public MyGraphType()\n  {\n    // two different options\n    Field(x => x.MyLocalDate);\n    Field(\"myLocalDate\", resolve: context =>\n    {\n        var source = context.Source as MyObject;\n        return source.MyLocalDate;\n    });\n  }\n}\n```. @Jefffrey the reasons are related to the GraphQL Specification.  There is a limited set of scalar values defined in the specification and those scalar values are defined and used in a certain fashion.  \nhttps://facebook.github.io/graphql/June2018/#sec-Appendix-Grammar-Summary.Lexical-Tokens\nIf you want to augment the specification, then you need to provide the pieces that this engine requires.  This engine requires the following pieces:\n\nA custom value ast (abstract syntax tree) type (ValueNode<T>)\nA custom scalar graph type that knows how to work with the new custom value ast type (ScalarGraphType)\nA IAstFromValueConverter to convert between your custom type (LocalDate in this instance) to the custom value ast type\n(optional) Using ValueConverter is optional, though you may want to provide a way to automatically convert one value type to another (such as converting a DateTime to a LocalDate).\n\n1 and 3 (ValueNode<T> and a IAstFromValueConverter) can be optional.  For instance, you can create your own scalar type without those items, though you would have to work with the built-in ValueNode's, which are those defined in the spec:\nIntValue\nFloatValue\nStringValue\nBooleanValue\nEnumValue\nNullValue\nAnd a few additions from this project:\nLongValue\nDecimalValue\nDateTimeValue\nDateTimeOffsetValue\nTimeSpanValue\nUriValue\nThere is no other documentation for writing a custom scalar type.  The posts in this issue are presently the only docs available.. Assuming you're serializing the JSON with JSON.NET where it would convert 2018-05-24 to a DateTime first, if you want to use Noda's LocalDate instead, you don't have a simplified option.  You need 1-4.  If you are somehow serializing the JSON to a LocalDate directly, you still need 1-3.. Using StringValue will work fine if you want to work with string types, with your POCO model looking something like this:\ncsharp\npublic class MyInput\n{\n    public string Date { get; set; }\n}\nIf it doesn't look like that, and you want to use LocalDate (which I assume you do since that is what this issue is), you need 1-4.\ncsharp\npublic class MyInput\n{\n    public LocalDate Date { get; set; }\n}\nScalars are designed to be used for both Input and Output values.  I encourage you to put that code in your project and try it out to see how it works.. @shoooe They don't technically need to be in your container at all since they have no dependencies, so you could leave that up to the user.  You can manually register them with the schema like so:\ncsharp\nschema.RegisterTypes(new []{ typeof(InstantGraphType), typeof(LocalDateGraphType) });\nThough that should also not be needed if the types are in your public schema.  I see you didn't create any new Value nodes and converters.  You if you had those, you could register those with the schema too with an extension method like this:\n```csharp\npublic static class NodaTimeSchemaExtensions\n{\n  public static ISchema UseNodaTime(this ISchema schema)\n  {\n    schema.RegisterTypes(new []{ typeof(InstantGraphType), typeof(LocalDateGraphType) });\n    // other value stuff\n    return schema;\n  }\n}\nschema.UseNodaTime();\n```. Option 1. is not a different approach.  That is just registering services for middleware or a controller to use.\nYes you can use the Controller approach in ASP.NET Core.  The code would be nearly identical from what you would use in ASP.NET Web Api.\nhttps://stackoverflow.com/questions/45568380/what-is-the-asp-net-core-equivalent-to-httprequestmessage\n```csharp\npublic class GraphQLController : Controller\n{\n    private readonly ISchema _schema;\n    private readonly IDocumentExecuter _executer;\n    private readonly IDocumentWriter _writer;\n    private readonly IHttpContextAccessor _accessor;\npublic GraphQLController(\n    IDocumentExecuter executer,\n    IDocumentWriter writer,\n    ISchema schema,\n    IHttpContextAccessor accessor)\n{\n    _executer = executer;\n    _writer = writer;\n    _schema = schema;\n    _accessor = accessor;\n}\n\n[HttpPost]\npublic async Task<IActionResult> PostAsync([FromBody]GraphQLQuery query)\n{\n    var inputs = query.Variables.ToInputs();\n    var queryToExecute = query.Query;\n\n    var result = await _executer.ExecuteAsync(_ =>\n    {\n        _.Schema = _schema;\n        _.Query = queryToExecute;\n        _.OperationName = query.OperationName;\n        _.Inputs = inputs;\n\n        _.ComplexityConfiguration = new ComplexityConfiguration { MaxDepth = 15 };\n        _.FieldMiddleware.Use<InstrumentFieldsMiddleware>();\n\n    }).ConfigureAwait(false);\n\n    var httpResult = result.Errors?.Count > 0\n        ? HttpStatusCode.BadRequest\n        : HttpStatusCode.OK;\n\n    var json = _writer.Write(result);\n    return new Content(json, \"application/json\");\n}\n\n}\npublic class GraphQLQuery\n{\n    public string OperationName { get; set; }\n    public string Query { get; set; }\n    public Newtonsoft.Json.Linq.JObject Variables { get; set; }\n}\n```. What information are you needing from HttpContext?  I suggest you pass that information on your UserContext, or just pass the whole HttpContext, vs trying to use HttpContext.Current.. Taking a look at the spec:\nhttp://facebook.github.io/graphql/June2018/#sec-Unions\n\nGraphQL Unions represent an object that could be one of a list of GraphQL Object types, but provides for no guaranteed fields between those types.\n\nI read this as only Object GraphTypes are allowed.\nFurther down:\n\nThe member types of a Union type must all be Object base types; Scalar, Interface and Union types must not be member types of a Union. Similarly, wrapping types must not be member types of a Union.. Yes, this is a great idea.  I'm thinking we should also keep the write to a string as an overload for convenience - maybe even as an extension method vs. on the interface - but this is a great idea.\n\n```\n  public interface IDocumentWriter\n  {\n    Task WriteAsync(Stream stream, T value);\n  }\npublic static class DocumentWriterExtensions\n{\n    public static async Task WriteToStringAsync(this IDocumentWriter writer, T value)\n    {\n          var stream = ...\n          await writer.WriteAsync(stream, value);\n          ...\n    }\n}\n``. Yes ... here's a thought.DocumentWriteris meant to be used withExecutionResult.  I can't think of any other use for it.  Perhaps we should just make it specific to that.  It would also be good to provide an upgrade path with marking the previous methodObsolete`, which we would then remove in the next major version.\n```csharp\npublic interface IDocumentWriter\n{\n  Task WriteAsync(Stream stream, ExecutionResult value);\n[Obsolete(\"This method is obsolete and will be removed in the next major version.  Use WriteAsync instead.\")]\n  string Write(object value);\n}\n``. Merged in #809 . This sample Harness test project also uses [Alba](https://github.com/JasperFx/alba) for doing HTTP request testing similar toMicrosoft.AspNetCore.Mvc.Testing`.  So you have a number of choices.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/83e1ee320e20581cb98e076ca91d89524b549370/src/GraphQL.Harness.Tests/BasicTests.cs#L8-L24. Can you provide some more context for your issue?\nWhat version are you using?  What server technology are you using (ASP.NET Core MVC, Web API, etc.)?\nThe Field you\u2019re showing is the object model for the Query. We call that the Abstract Syntax Tree (AST) type.  The Arguments on the AST represent the parsed object model, with the values represented as an IValue.  CoreToVanillaConverter exists a bit for historical reasons, though that is converting the GraphQL Parser AST to the AST that the GraphQL .NET framework understands.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/bfb23d2653f60f9a5d03a1ab6c134cd417caca69/src/GraphQL/Language/AST/Argument.cs#L19\nResolveFieldContext.Arguments represent the computed arguments for the field that are provided to your resolver function.  Those computed values could be from inline values as shown above, variables, or default values.\nSo in short - one is the AST, one is the computed values.  Related, but two different things.\nAs far as having trouble passing dates - can you provide a failing test that demonstrates this issue?. > How do you want me to provide the test?\nThere is a BasicQueryTestBase (example usage) that you can use and a folder for bugs.\n\nwhy 2 different ways of representing the arguments\n\nI guess I'm a bit confused by the question since they are two different things.  They don't have the same structure, the same values, nor would they use the same classes.  One correlates directly to the GraphQL specification grammar so you can write a nice object model around it.  The other is a set of name/value pairs that has an unknown, and most likely nested, structure.  The best match for the name/value pairs in .NET seemed to be a Dictionary<string, object>.  You could certainly wrap those values in another object model with both an Arguments (list) class + Argument (with name + value properties), though that seemed like overkill at the time.  If you wrote those classes you would have to choose between having different names than the existing Arguments + Argument classes in the AST or dealing with any name collisions.\n```csharp\n// AST\npublic class Argument : AbstractNode\n{\n    public Argument(NameNode name)\n    {\n        NamedNode = name;\n    }\npublic string Name => NamedNode.Name;\npublic NameNode NamedNode { get; }\npublic IValue Value { get; set; }\n\npublic override IEnumerable<INode> Children\n{\n    get { yield return Value; }\n}\n\n// a bit more stuff\n...\n\n}\n// what an object model may look like if there was one for resolved arguments\npublic class Argument\n{\n    public string Name { get; set; }\n    public object Value { get; set; }\n}\npublic class Arguments\n{\n    private Dictionary _arguments = new Dictionary();\npublic Argument ArgumentFor(string name)\n{\n    if (_arguments.TryGetValue(name, out object value))\n    {\n        return new Argument { Name = name, Value = value };\n    }\n\n    return null;\n}\n\npublic object ValueFor(string name)\n{\n    if (_arguments.TryGetValue(name, out object value))\n    {\n        return value;\n    }\n\n    return null;\n}\n\n// this would probably be used 99.9% of the time\npublic object this[string name]\n{\n    get\n    {\n        return ValueFor(name);\n    }\n}\n\n}\n`. Not much to go on here, I would look at the type that it is pointing to in the error -GraphQL.Types.ObjectGraphType`1[Foobar.Data.Bar]``.  I would look at the specific fields you are trying to access to figure out why it is returning a null value when it shouldn't.. You could perhaps do something like that, though that is not a \"built in\" scenario for this project (at least my understanding of what you're trying to do).  You can easily call other microservices from within a field resolver (GraphQL IS designed to do that) though that would not be related to introspection.\nYou may be interested in this work that others have done.  https://github.com/graphql-dotnet/graphql-dotnet/pull/592\n. Yes, you will need to call .ToInputs to convert from JSON.NET types.\nhttps://graphql-dotnet.github.io/docs/getting-started/variables\nI suggest to switch your public Dictionary<string,object> Variables { get; set; } to public JObject Variables { get; set; }.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/93590f26ee8b052fb6b5e4128f6eb6fe677fe0a4/src/GraphQL/StringExtensions.cs#L93-L101. Are you trying to sort across multiple fields?  If so, I can\u2019t think of one.  If you\u2019re trying to sorting/filtering in general, I suggest to pass those parameters to the downstream services to sort/filter.  An in-memory sort/filter would be pretty inefficient.. @Patrick-Spiegel 2.1 is released with this fix.  Sorry it took so long!. That unfortunately does not follow the GraphQL Spec so it would not be supported.  You could create a Dictionary GraphQL scalar type, though since it is a scalar the engine would not be able to support querying sub fields.. That could be done, though that would not conform to the GraphQL spec and it would need special handling in the engine.  Since that is far outside of the spec, unfortunately that is not a feature that I would want to add.. This definitely sounds like something that should be fixed.  Thanks for the report!  I think we do have an issue for something similar, I'll link that if I can find it.. You can't access parent arguments directly from a child resolver, but you can access variables.  ResolveFieldContext.Variables\nhttps://graphql-dotnet.github.io/docs/getting-started/variables. What does your schema look like when printed with SchemaPrinter?. I'm seeing a couple issues here which seem a bit confusing.  Can you please post the full error stacktrace (including the inner exception)?\nFieldAsync<IncidentType>(\n                \"createIncident\",\nWhat type is IncidentType?  Is that a .NET Object model?  That should be a ObjectGraphType.\nvar incident = context.GetArgument<IncidentType>(\"incident\");\nYou're using that same type here, which would seem to be incorrect usage, unless that is indeed your .NET Object model.  You should be using a .NET class with GetArgument<T>, but not with FieldAsync<T>.  Can you post what this class looks like, including the enum .NET Type?\nIncidentTypeEnum appears to be assigned a GraphQL name of IncidentType.  Is that on purpose?  Looking at it for the first time it seems a bit confusing, with the other (what I'm guessing is a class) named IncidentType.. Okay - yes, you cannot use a GraphType with GetArgument.  You need to use a DTO, with only .NET types. So you need to use an actual C# enumeration.  I see you\u2019re trying to use the same class for both, which could cause some issues - it was not designed to use the same class for both.  It may work if you use a C# enum.\nSee the Human class in the Mutation example.\nhttps://graphql-dotnet.github.io/docs/getting-started/mutations. You can create your own methods and types which would enforce this.  Create a method which requires providing a description.  All the Field methods call into AddField.  You can override that method and ensure that the given FieldType has a Description.. Example override.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/0dc0443ffd9d21673583901d534d47e3fefc3d7e/src/GraphQL/Types/InputObjectGraphType.cs#L15-L24. Yes - sorry, I was thinking more about only fields vs. the Description on the Graph Type itself.  Description provided on ObjectGraphType (inherited from GraphType) is currently not virtual, so you could override that with new.. Merged in #839 . This is most likely because there is not a long->double converter registered.  Can you try the following and see if it fixes your issue?\nAdd this somewhere in your app bootstrapping.\ncsharp\nValueConverter.Register(\n  typeof(long),\n  typeof(double),\n  value => Convert.ToDouble((long)value, NumberFormatInfo.InvariantInfo));. This appears to have a valid failing test, can you take a look?. No that's fine, that is a known issue in the build script currently.. See the client project. I don\u2019t think there is auto generation at present.\nhttps://github.com/graphql-dotnet/graphql-client. It may be easier to implement the container directly.  Something like:\n```csharp\npublic class UnityDependencyResolver : IDependencyResolver\n{\n    private readonly IUnityContainer _container;\npublic UnityDependencyResolver(IUnityContainer container)\n{\n    _container = container;\n}\n\npublic T Resolve<T>()\n{\n    return (T)Resolve(typeof(T));\n}\n\npublic object Resolve(Type type)\n{\n    return _container.Resolve(type);\n}\n\n}\n```. @clustersnake Going to close this, let us know if you need more assistance.. Here's the github repos for the node + javascript libraries:\nhttps://github.com/graphql/graphql-js/issues\nhttps://github.com/graphql/express-graphql/issues\nYou can also ask your question on their slack channel:\nhttps://graphql.org/community/#slack-discord. I believe that is because at present there is no method for using an expression for the field coupled with providing a custom resolve method.  Its not that it can't be done, just that there currently isn't a method for it.\nIn this case that field is being converted from a DateTime to a String with a specific format.\nThat example could be changed to:\ncsharp\nField(x => x.BirthDate, type: typeof(DateGraphType));\nAssuming that DateGraphType serializes the data in the format that is wanted.. I think you could also do:\ncsharp\nField(x => x.BirthDate, type: typeof(StringGraphType))\n  .Resolve(context => context.Source.BirthDate.ToShortDateString());. Yes - here's the release notes for 947:\nhttps://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v2.0.0-alpha-947. Are you providing a unique type name on your ResponseRegister types?. How are you hosting GraphiQL?  Are you using a package you didn't write?  You may just need to change the url where GraphiQL is pointed.\nThis example shows integrating GraphiQL with a React app:\nhttps://github.com/graphql-dotnet/examples/blob/58d1360e8595fbc5fe71bf5faf44af55c38ebfe6/src/AspNetCoreCustom/app/app.js#L8-L16\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport GraphiQL from 'graphiql';\nimport axios from 'axios';\nimport 'graphiql/graphiql.css';\nimport './app.css';\nfunction graphQLFetcher(graphQLParams) {\n  return axios({\n    method: 'POST',\n    url: window.location.origin + '/api/graphql',\n    data: graphQLParams\n  }).then(resp => resp.data);\n}\nReactDOM.render(, document.getElementById('app'));\n``\n. There is anExtensionsproperty on theExecutionResult` which you can add extra information.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/ExecutionResult.cs#L26\nOn a per-error basis, you can add extra information to the Data property which will get rendered as extensions.. It would report how long the particular resolver took.  If you're using a cache, it would only reflect the actual data fetch when not pulling the data from the cache.. I'm not aware of any metrics captured specific to using a DataLoader.  The main metrics being captured are on a per-field (resolver) basis.  If that field uses a DataLoader then the time it takes to fetch could be different if pulling from the DataLoader's cache vs. the first time it fetches.\nHere's the docs for metrics:  https://graphql-dotnet.github.io/docs/getting-started/metrics\nAnd the implementation of InstrumentFieldsMiddleware:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/3c7bd27dbd00c3971a7b7bfef4f277946e716e25/src/GraphQL/Instrumentation/InstrumentFieldsMiddleware.cs#L8-L25. @johnrutherford  Ha, duh - yes that would do it.. @RehanSaeed Yes, I'm updating that with async/await.  Metrics are not enabled by default in the server project.  You would need to create your own class that inherits from DefaultGraphQLExecuter<T> so you can add the InstrumentFieldsMiddleware to the ExecutionOptions.. This is published in 2.3.0 (along with a few other things). There is currently nothing built-in to transform the input in this way.  This would need to be a manual transform that you do yourself from the Arguments dictionary.. Perhaps a slightly better version (with a little less processing):\ncsharp\nvar personArg = ctx.Arguments[\"person\"];\nvar person = personArg != null\n    ? JToken.FromObject(personArg).ToObject<Person>()\n    : null;. @rose-a I don't want to have multiple ways to transform the data.  This is an often requested feature though so I think we should provide some way to do it.  I'm not sure what that looks like yet, but I'm stewing on it.. What framework are you running on?  .NET Core or Full Framework?. @dietergoetelen What framework (and version) are you running on? .NET Core or .NET Framework?. Other JavaScript clients, such as Apollo, also use graphql-tag, though they convert it back to a query before sending it to the server.  Sending a json payload of the AST is going to be a much larger payload than just the Schema syntax.  I don\u2019t think this is a feature that fits with the goals of this project.  It would be possible for you to convert the AST json to this project\u2019s Document AST and pass that to the Executor.  The ExecutionOptions allows you to pass a pre-populated Document.  There are other aspects that expect there to be the raw query (such as line/column numbers in errors).. @SimonCropp Do you think you were perhaps hitting #873 ?. Nice find, thanks!. There are a lot of companies using this in production, though there are no companies directly backing  this project.  There are several indirectly supporting it by allowing their developers time to work on features and fix bugs.. OrchardCMS is currently using it.\nhttps://twitter.com/bleroy/status/1057406453827297280. It could possibly be related, though I believe the default is bigger than 1024KB.  \nFor that code path it should be getting this buffer size:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/0917a2c8c3f7fc078ce4429f0edc3b051ef949c9/src/GraphQL/Http/DocumentWriter.cs#L24\nCan you try switching to using the new WriteAsync directly?  That would look something like:\ncsharp\nprivate async Task WriteResponseAsync(\n  IDocumentWriter writer,\n  HttpContext context,\n  ExecutionResult result)\n{\n  context.Response.ContentType = \"application/json\";\n  await writer.WriteAsync(context.Response.Body, result);\n}\nThoughts @DSilence?. @DSilence can you talk to why there is a hard limit currently?  If that is specific to websockets we should probably make that explicit.. Syntax for a mutation is the exact same syntax for a query.  The only difference is having the Mutation name vs. Query.. You need to add those types to your DI Container so it can construct the objects.  By default it uses Activator.CreateInstance.\nhttps://graphql-dotnet.github.io/docs/getting-started/dependency-injection. global.json at present is mainly used to control what sdk is used on AppVeyor.  There may be a different way that we can control which SDK AppVeyor uses.  If we can fix that issue, I have no problem removing the global.json.  Preferably in the AppVeyor.yml file and not a powershell script.  Any ideas?. @RehanSaeed Agreed, that's a simple enough change for me.. There is middleware provided by this project that works, so there must be something about your setup that is causing the error to occur. Can you please provide the full source for the middleware?. https://github.com/graphql-dotnet/graphql-dotnet/blob/952b4ef6950e51bbfe009354f0520180c343e8d4/src/GraphQL/Execution/ExecutionStrategy.cs#L97\nThat error is from here, which indicates that your field expects a list, though it isn\u2019t getting one. Are you perhaps calling ToUpper on a list?. Sorry, that is beyond the scope of this project.. > Is this because theses features aren't supported in the .net implementation yet?\n\nfilter, orderby, first\n\nThose features are not part of the GraphQL spec.  To support those features you have to build them yourself.  Since this project is Data-Source Agnostic, there are no plans to try to provide this type of functionality.. It looks like 4.0.0 only supports netstandard2.0 and net46, so we may have to either target 4.0.0 for just nestandard2.0 or drop support for netstandard1.x and net45.  It is currently planned to drop support for netstandard1.x and net45 in version 3 of this project.\nHave you tried manually adding a PackageReference for System.Reactive.Core to your project with the 4.0.0? version?\n<PackageReference Include=\"System.Reactive.Core\" Version=\"4.0.0\" />\n<PackageReference Include=\"System.Reactive.Linq\" Version=\"4.0.0\" />\n. No timeframe for 3.0.\nLooks like that's complaining about downgrading packages, so may have to pick a higher package version than what you chose?. Question though ... doesn't seem like you should be referencing this project from Android or iOS?  Are you using the graqphl-client project?. Gotcha - yes the GraphQL nugget is for building your own GraphQL server.  You\u2019ll want that client project for calling an existing GraphQL server.. Going to close this, let us know if you have more questions.. No objections.. Every GraphType requires a unique name. Since you are not providing one, one is generated for you based on the type name. That generation does not understand generics.  You need provide a unique name for the GraphType that meets that regex.. this.Name = this.MethodToGenerateName();. > But in any case perhaps the right answer is to use the new API _writer.WriteAsync(Stream, T)?\nYes, that would be the route to take.  There is a WriteToStringAsync too if you still want the direct JSON.. You CAN pre-register the type if you wish.  But you are required to register it if you only expose the interface/union in the Schema.  IsTypeOf or ResolveType is also required when working with interfaces and unions.\nhttps://graphql-dotnet.github.io/docs/getting-started/interfaces\n. That should be impossible.  If you did not have IsTypeOf or ResolveType properly setup that would happen though.. Posted answer on StackOverflow.  Short answer:  use IHttpContextAccessor.. @drowhunter No, there is currently no way to customize its behavior.  If you need to customize the behavior I would copy the source into your own project and customize as needed.. Yes, it will only work for very niche cases.  You may be able to get it to work with your specific enumeration type by registering it:\ncsharp\nGraphTypeTypeRegistry.Register(typeof(MyEnum), typeof(MyEnumGraphType));. > I looked at the source code and realized that before you mentioned it. Is this documented anywhere?\nI do not believe it is.\n\nAre you aware of the GraphQL Library called HotChocolate ?\n\nI am aware of that project and yes the way they have designed the field registration has some perks that this project does currently not.. Yes there is currently nothing in place to access the parent values multiple levels up.  This may be available in the Node structure that is used with DataLoader (if I\u2019m remembering correctly) but that is currently not exposed to consumers of the API.. Closing as this is related to #648 . What error are you getting and how are you registering your Schema with your DI container?  I\u2019ve deployed this to IIS without issue so there is a problem with your setup.. See SubFields on ResolveFieldContext.. This is working as intended.  You will only get the arguments that are defined in the field.  If that is only one, you will only get one.  The variable that is defined should get passed in as the argument.. If you need both, why not pass both to the field?. Create two arguments in the field so you can pass in two variables as inputs.. Field<ListGraphType<DeliveryItemType>>(\u201citems\u201d, resolve: context => context.Source.Items)\nThat should work, looking into the exact syntax for lists with expression syntax but yours looks fine to me.\nHave you registered your DeliveryItemType with your container?. At this time there is no built-in way provided by this project to do custom mappings as you describe.  You will have to use a third-party library to do that.\nSee #864 for more discussion on the topic.. I have to create another commit to bump the version, wait for the build to complete, then I manually push to nuget.. You can get earlier releases by subscribing to the myget.org feed:\nhttps://www.myget.org/F/graphql-dotnet/api/v3/index.json. 1. You can use fragments for this.\nhttps://graphql.org/learn/queries/#fragments\nhttps://graphql.org/learn/queries/#inline-fragments\nhttps://graphql-dotnet.github.io/docs/getting-started/fragments\n\nThere is not an easy way to do this at present.  Since GraphQL is a type system, you will have to have different types for each input that varies.  You could perhaps make this a little easier by using an abstract base GraphType that included the fields from your interface.. What you are wanting to do is not provided by the GraphQL spec.  So this is not supported.. If you rebase on master, global.json is no longer included in the project.. This is not an issue with this project.  I suggest you search for documentation specific to working with validation in ASP.NET Core.. That GraphiQL middleware you're using is not associated with this project.  I suggest you read the documentation or source code of that project.. @aoakeson Key word is \"custom\".  Any custom GraphType has to be registered with the Schema for it to know about it (including Scalars).  Depending on your setup, that could either be by your DI container or calling the RegisterType on Schema.  Whether this framework does it for you or not for these specific types, it has to be done.  Right now this framework is not registering them by default.  This PR changes that.. Closing in favor of #1074 which fixes the merge issues.. Unfortunately we can't remove this immediately because it has now been shipped.  We need to mark it as obsolete and remove it in the next major version.. Hey, so this is not really an issue with this project.  You would continue to generate those urls as you were previously.  GraphQL.NET can't do anything to help or hinder you here.. This project cannot help you accomplish that task.  There are no classes provided by this framework that generates urls.  That is a generic task that you can accomplish with just plain .NET Code or ASP.NET.  I suggest you post your question on Stackoverflow.. Anything I can think of related to this that I can help you with is in the documentation for this project:\n\nhttps://graphql-dotnet.github.io/docs/getting-started/introduction\nI cannot write this code for you or provide code examples.  You are going to have to solve this problem in your own project as it is specific to your project and is not related to GraphQL.  This framework helps you map your existing C# class to a GraphQL response.  It does not help you populate those classes with data.  If you need to dynamically generate a URL then you need to use classes provided in .NET or ASP.NET to do so.\nI strongly suggest that you do some learning about how GraphQL works and what it is trying to solve.  The issues you've been opening are not issues that GraphQL itself can help you solve.  They have been generic programming issues that you as a developer are expected to solve.  Here are some resources and tutorials:\nhttps://www.youtube.com/watch?v=F_M8v6MK0Sc\nhttps://graphql.org/learn/\nhttps://www.howtographql.com/. Field(x => x.Customer, true, typeof(ComplexGraphType<Customer>));\nThis won't work.  ComplexGraphType is an abstract base type.  Arguably that perhaps should be an internal type.  You need to create a class that inherits from ObjectGraphType.. That stacktrace is helpful. This is happening during the initialization of the Schema, which builds up the entire Graph.\nDoes your customer class look like this?  You didn\u2019t just do typeof(ObjectGraphType<Customer>)?\npublic class CustomerGraphType : ObjectGraphType<Customer>\n{\n  public CustomerGraphType()\n  {\n    Name = \u201cCustomer\u201d;\n    // add fields\n  }\n}. Change this:\ncsharp\nField(x => x.Customer, true, typeof(ObjectGraphType<CustomerType>));\nTo this:\ncsharp\nField(x => x.Customer, true, typeof(CustomerType));. One thing that could perhaps be done is to throw an error if you pass an object that inherits from IGraphType to the ObjectGraphType/ComplexGraphType generic argument.. I'm not sure.  That should have never worked.  That it somehow was is a mystery to me.. Look at the Name of your AttachmentType.  It has the wrong name.. A number of people have ran into this issue, so it is planned to throw an exception to try to help.. Whoops!  Thanks!. That issue provides the ability to make it easier to write your own custom scalar.  This project does not currently provide a ByteGraphType that you can consume, you will have to write your own as demonstrated on that issue.. Hey, thanks for this - I haven't done an in-depth review, though I would prefer that this custom scalars be in its own document instead of in the schema-types doc.  Mind adding that to its own file?. Unfortunately no - that is part of the GraphQL spec so I don't see that being budged on.  If that is an actual problem with your data I would suggest to instead do that check yourself and throw your own custom error vs. letting that bubble up to the null check.. You should be able to use Field, as in the example.  Did you try that?\ncsharp\n_.Match<Field>(fieldAst =>\n{\n ....\n}. My apologies, I should have looked closer at this.  In this case we\u2019re matching on the AST types, which for an Argument is going to be an IValue.  That maps to ObjectValue which has ObjectField.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Language/AST/Argument.cs#L18\nThe AST is walked based on the Children of the Node.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Language/AST/ValueNodes/ObjectValue.cs#L30\nSo you should be able to use ObjectValue and ObjectField in conjunction with the Argument.\n. There is an extension method to help unwrap types btw, called GraphQLExtensions.GetNamedType.\ncsharp\nvar it = context.TypeInfo.GetInputType()?.GetNamedType();\nI think this is closer to what it can look like:\n```csharp\npublic INodeVisitor Validate(ValidationContext context)\n{\n    return new EnterLeaveListener(_ =>\n    {\n        InputObjectGraphType inputType;\n    _.Match<Argument>(f =>\n    {\n        inputType = context.TypeInfo.GetInputType().GetNamedType() as InputObjectGraphType;\n    });\n\n    _.Match<ObjectField>(f =>\n    {\n        var field = inputType.GetField(f.Name);\n        field.Metadata...\n    });\n});\n\n}\n```. ? What is this for?. Going to close this. Re-open if I\u2019m missing something.. There aren\u2019t any specific plans around this, though see this PR:\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/592. Fragments are part of the GraphQL spec and this framework supports them.  As long as you follow the patterns described in those articles then they would be \u201creusable\u201d.  Fragments are used within the query/mutation and there is nothing special you need to do on the server to support them.. Not at this time, no.  You can use JSON.NET yourself to accomplish that today, something like this:\ncsharp\nresolve: context =>\n{\n    var jObject = JObject.FromObject(context.Arguments[\"test\"]);\n    var serializer = new JsonSerializer\n    {\n      ConstructorHandling =  ConstructorHandling.AllowNonPublicDefaultConstructor\n    };\n    var test = jObject.ToObject<Test>(serializer);\n    return repository.AddAsync(test);\n}. Just to comment on this.\nJSON.NET is used in 2 places, once on input to convert from JSON.NET values to .NET Values, and once on output in the DocumentWriter. There should be no other uses of it (if there are then we failed!), as it was a very purposeful decision to enable this exact request to use a different serializer.\nThat said, I think there can be work done to create a smarter DocumentWriter so you wouldn't have to do so much work to replace it. You should be able to use another serializer with only those two things in mind.. This feature should be added, though it is not deployed yet.\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/952. Nothing that I can tell off-hand.  Can you provide a failing test?. How are you passing your variables to the executor?  Are you using ToInputs?\nhttps://graphql-dotnet.github.io/docs/getting-started/variables. I think I just realized what your issue is - since your Scalar is converting the value to a Guid, that Guid needs to be converted to an IValue.  There is a GuidValue class which you are using in your ParseLiteral function.  You need to teach the Schema about that.  This is done manually in this pr https://github.com/graphql-dotnet/graphql-dotnet/pull/917 though it is not merged yet.\nFor you to do it, you will need to create an IAstFromValueConverter and register it with your Schema.\n```csharp\nschema.RegisterValueConverter(new GuidValueConverter());\ninternal class GuidValueConverter : IAstFromValueConverter\n{\n    public bool Matches(object value, IGraphType type)\n    {\n        return value is Guid;\n    }\n\n    public IValue Convert(object value, IGraphType type)\n    {\n        return new GuidValue((Guid)value);\n    }\n}\n\n```. That error appears to be from here:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/952b4ef6950e51bbfe009354f0520180c343e8d4/src/GraphQL/Execution/ExecutionStrategy.cs#L157\nYou would get that error when the GraphType is not one of: ListGraphType, IObjectGraphType, IAbstractGraphType, ScalarGraphType.\nWhat does the GraphType are you using look like?. Can you provide the code for what your GraphType's looks like?  Are you providing a unique GraphType Name for each permutation of GraphQLMutation<T> and MutationTable<T>?  Can you print your schema and post that using SchemaPrinter?. If they are different classes, they need to have a unique name.  Input objects also need to inherit from InputObjectGraphType, so they would also need to be separate.  Re-using the same GraphType with a mutation is common, as in returning that GraphType from the mutation, though typically the parent GraphTypes are separate.\nA schema has only one root Query and one root Mutation object.  Your Query objects should not have mutation functions on them and your Mutation objects should not have Query functions on them.  Part of that is because Query objects get ran in parallel whereas Mutation objects get ran serially.\nhero on Query returns a Droid\nadd on Mutation returns a Droid\n```gql\ntype Droid {\n  id: String!\n  name: String!\n}\ninput DroidInput {\n  name: String!\n}\ntype Query {\n  hero: Droid\n}\ntype Mutation {\n  add(input: DroidInput!): Droid!\n}\nschema {\n  query: Query\n  mutation: Mutation\n}\n``. My only guess is that somehow theGraphType` is null.  The most likely candidate would be that the name of the type is not being treated as unique and one type is overriding the other.  Your type names look very similar.  Have you tried drastically different type names?\nWhat I described above is a known issue:  #827. That should certainly work and looks like correct syntax at first glance.  What specific versions are you referring to?  Can you provide a failing test?. Part of the idea is that the tests should run targeting the supported runtimes. Removing 1.1 and 452 in the tests could make it so regressions could creep in (though I do think 1.1 and 45x support should be removed in the next major released).  Do you not think that is the case?. > which is used all over the codebase\nJust want to point out that this is a bit of a stretch.  It is used in 2 places, once on input to convert from JSON.NET values to .NET Values, and once on output in the DocumentWriter.  There should be no other uses of it (if there are then we failed!), as it was a very purposeful decision to NOT have it used \"all over the codebase\" to enable this exact request to use a different serializer.\nThat said, I think there can be work done to create a smarter DocumentWriter so you wouldn't have to do so much work to replace it.  You should be able to use another serializer with only those two things in mind.. Going to close this as a duplicate of #959 . Went with #989 so closing this one.. There are other issues with this same error. Can you search through those and see if the responses apply to you?  Thanks.. PlayerBalanceRequestType should be an InputObjectGraphType.. As was mentioned in the other PR for this, we can't just remove the schema results from IntrospectionResult.  The tests that use that should be updated so it doesn't return null (if that is the issue) so the test is actually still testing the introspection response.\nI'm also weary of doing exception-based control flow.  This other PR seemed to be able to impliment this feature without using exceptions.  #534. > update the test case test\nThis.\nYou should still get a introspection result even with nullable types/fields.  I suspect the problem with the test is that it basically has no query/mutation/subscription.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/6ecd4f0980e058eba3f086b717978747fffc4325/src/GraphQL.Tests/Introspection/SchemaIntrospectionTests.cs#L17\nIf you still get a top level null after a Query is added then there is a bug in the implementation.. > I have removed the NonNullableGraphType from from queryType field\nThat needs to be added back as it should be NonNull, according to the GraphQL-JS implementation.. @KoditkarVedant I don't know either.  You will need to get the branch fixed before it can be accepted into master.. Hey, thanks for this.  One thing I want to make sure is that the GraphQL Parser can also handle that ampersand.  Otherwise this printer will be producing something that the parser can\u2019t parse.. I'm not sure how it happened, but there were two PRs for this same thing on the same day (do you two work together??).  I like this other implementation since it has a flag for the old syntax.\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/983. Closing this in favor of #983.. Closing this in favor of #983.. As @Tarig0 mentioned, you can dynamically build the schema on request instead of making it a singleton.  However, once it has been initialized adding types can be dangerous.  It is technically possible to do so by getting the specific GraphType and adding a field, though you would need to ensure all of the models of the GraphType you are adding are properly populated.  That is not a typical scenario that I would suggest someone to do as there are a ton of issues you could run into.\nSummary:  its technically possible, though not supported.. No, that is not possible due to the strong type safety that is defined in the GraphQL specification.  You will need to deprecate the old argument and provide a new one.. This fix is published in the core library in GraphQL 3.0.0-preview-1107.  I will work on getting the server project updated.. We can keep them to the same PR, since I can't merge the one with failing tests.. The expression helps when you have that data model and you rename fields.  There is a parameter to the expression method to make it nullable (nullable = true).  Behind the scenes they both do the exact same thing.. @SimonCropp That was me.  Can ping me on gitter or twitter.. closes #872 . This is fixed by #983 . That is not currently a feature, no.  Can you please use the \"Feature Request\" template for this?. Looking at this, I don't believe that this would be behavior that we want to support.  Can you provide a better example of how/why you would want this behavior?. One thing to also know is that all Graph types take on the same lifetime of the Schema.  So a Graph type is only created once for a given Schema instance and is reused.  So depending on your injected services you could have similar issues even when not Singleton.. @bugged84 if you have a very large schema it can cause performance issues to create it on every request.  You\u2019ll have to do some perf testing and see if that applies to your project.. It may not be handling T[][].  Can you two post what version you're using?  @dadhichankur @juliankay . If I'm understanding what you're needing, using a Dataloader may help you solve this issue.  It can help transform those 11 resolvers into a single query to the database.\nDocs: https://graphql-dotnet.github.io/docs/guides/dataloader\nBlog post: http://fiyazhasan.me/graphql-with-asp-net-core-part-x-data-loader-series-finale/. This may or may not be a bug, in that I can see that being a bit confusing.  I'm not sure if that would be possible though with the generics in use.  You can define your field like such in the meantime:\nNullable example:\n```csharp\n// these are equivalent\nField(\"fieldInt\", context =>\n{\n  var model = context.Source as MyModel;\n  return model?.fieldInt;\n});\nField(\"fieldInt\");\n```\nNon-null example:\ncsharp\nField<NonNullGraphType<IntGraphType>>(\"fieldInt\", context => null);. Currently this is unsupported but I can see how it would be useful.. Just to re-iterate what @huysentruitw mentioned, this will be an issue in your code.  There is nothing built-into this framework that does any filtering or paging.  So I would double check that the data you are returning in your resolver is correct.. @bugged84 Not at this time.  Right now the field middleware is created using Activator.CreateInstance.. @bugged84 I would be fine with something like that, though the field middleware would need to have a heavy refactoring to support that.\nOverall, field middleware needs a big overhaul.  Right now field middleware is applied individually to each field.  I would like to change that so you could have both \"global\" middleware and field specific middleware.  Right now the middleware is basically global, though it is applied once to each field.  I think we could save some processing cycles by changing that.. This is trying to fix the problem you\u2019re having improperly.  Instead of changing the execution strategy to work with your code that is not thread safe, fix your code so that it is thread safe.  That can easily be done with a factory method.  This is trying to provide a work-around, not fixing the core problem.\nI admit that the re-use of GraphTypes for the lifetime of the Schema is causing some people headaches.  This is not the right fix for that problem.  Not everyone uses EF.  This will instead create another api surface that I have to support with differing logic that can already be changed through inheritance.  What if someone wants to change the behavior of mutations?  Do we add another flag?  What about subscriptions?  It sets a presidence on the design of the api that I don\u2019t want to support.. There is currently no way to hide fields, so yes it would have to be authentication today.. This was just merged today, so fine with just renaming it.. I think this is fine. . Not I'm in love with the name of the field, but this is certainly needed.  UserContext was added to be in line with what the JS reference implementation uses.\nLooks like another merge created a conflict.  Mind resolving that?  Then I'll get this merged.. Fixes #637. I'm actually liking that idea quite a bit ... that is closer to the JS idea, since in JS you can just use it like a dictionary.. Especially since with adding another property, they would both be doing the same thing.. Admittedly I'm no expert on the DataLoader feature, though I'm fairly certain this scenario is not currently supported by it.. Here's the documentation for arguments.\nhttps://graphql-dotnet.github.io/docs/getting-started/arguments\ncsharp\nvar id = context.GetArgument<int>(\"vendorId\");\nvar desc = context.GetArgument<string>(\"description\");\nvar isEnabled = context.GetArgument<bool>(\"isEnabled\");\nYou could also use an Input type instead of individual fields.  Shown in the mutation documentation.\nhttps://graphql-dotnet.github.io/docs/getting-started/mutations. The Arguments property on ResolveFieldContext is just a C# Dictionary.  So you can use it like any other Dictionary.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/ResolveFieldContext.cs#L23. csharp\nFieldAsync<ObjectGraphType>(...)\nThis is not valid.  You need to create a GraphType that represents the response from your resolver.  GraphQL has a strongly typed Schema.  Your resolver is currently returning both a string and an anonymous object with a token string property.  That is also not valid.  You have to return the same datatype.\nSee the introduction on the GraphType first approach.  https://graphql-dotnet.github.io/docs/getting-started/introduction#graphtype-first-approach\n```csharp\npublic class TokenResult : ObjectGraphType\n{\n  public TokenResult()\n  {\n    Field(\"token\");\n    Field(\"userId\");\n    Field(\"error\");\n  }\n}\nFieldAsync(\"login\", ...)\n```\nSo the shape of the data returned in your login field is required to be an object with token and error properties.. You should never need to call RegisterType with an interface type.  What has lead you to that solution?  Also, this framework provides a class called InterfaceGraphType already, so are you sure this code compiles and is using the expected types?. Also note - you\u2019re not setting any names on your GraphTypes.  What does your Schema look like when you print it with SchemaPrinter?. To expand on this a bit, what type is \"allowed\" is determined by IsTypeOf or ResolveType.\nhttps://graphql-dotnet.github.io/docs/getting-started/interfaces#istypeof\nhttps://graphql-dotnet.github.io/docs/getting-started/interfaces#resolvetype\nEither of those functions could be checking multiple Domain types.  So the intent is not to be checking a specific Domain type, but to determine which GraphType to use.  So the messaging should probably be updated to reference that vs. trying to guess at what Domain types are valid.. @sungam3r Yes, it was turned off temporarily, if you wouldn't mind adding it back.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/tools/tasks/test.dotnet.js#L19-L20. Thanks!. In this regard we are following the Facebook implementation of making a query type required.  You could have an \"empty\" query type with zero fields if you must, I think that should work.\nhttps://github.com/graphql/graphql-js/blob/master/src/type/introspection.js#L50. This is related to #648 .  Please read through that thread.\nQuestion\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/648#issuecomment-403167295\nAnswer\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/648#issuecomment-403169179\nA fix:\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/648#issuecomment-431489339. See this PR:\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/917\nIt has some merge issues that need to be resolved.. I pushed 3.0.0-preview-1141 to nuget.org.  For immediate builds you can connect to the myget.org feed.\nhttps://www.myget.org/feed/Packages/graphql-dotnet. I think this return could cause issues with interfaces not getting registered (the ObjectGraphType check after this one).\n. Would be nice to see some tests for the Coerce behavior.\nOne thing of note.  I don't really like having the direct dependency on JSON.NET here.  The way I did Input Objects in my branch was to convert all of those values up front.  That way you don't have to have JSON.NET littered everywhere and you only have to deal with core types.\n. Not sure I'm keen on this repository stuff, it seems like this treats the Schema as a Container.  Can you give a use case / example?  Perhaps these could be added as extension methods in your own project if this is a pattern that you want to use?\n. I had to do something like this too.  I think this \"full name\" should probably be moved to the Variable type itself.\n. :+1: I thought I recalled seeing some issue with this too.\n. Having this does seem to go against the idea of GraphQL, in that you only request what you need.  If you do need \"everything\", dynamically, you could use the introspection pieces to find out what all possible fields are.\n. I don't think it is ... those are new tests I just added.  I will double-check though.\n. :+1: \n. Some funkyness with the merge here I think.  The lines above this are already registering the field arguments.\n. I think keeping the name of the field in the exception is helpful.\n. I think we need to use name here, which is passed in, and not graphType.Name.  Part of when this code runs is the type may actually not have a Name populated yet, or is not a proper name.  This is something I don't like and would like to change.\n. This was a bug with the description not being added.  :+1: \n. That goes along with the \"you can't trust the Name\" stuff.  =/\n. Here is the matching tests in the JS project.  Shows only outputting the input values that are given.  So this is unexpected behavior.\n. Think this is a potential bug or future bug - should be returning obj instead of assigning it.\nAlong those lines, the logic in CoerceValue and CoerceValueAst should be near identical (and I would like to merge them together).  This makes them out of sync.  Do you recall why you needed to make this change?\n. :+1: They were originally separate in the JS project so I was trying to duplicate their logic (while I was also still learning).  I think they have combined them into one as well.\n. The alpha version is 1.5 years ahead of \"stable\".  I wanted to be on the latest antlr version.  The official GraphQL nuget il-merges the Antlr runtime so there should be no policy issue in that sense.  Not sure I want to make this change without metrics.\n. I agree that the Name issue needs to be fixed.  I think this isn't going to help though, since you are essentially picking a random field?  The real field that it is looking for is only known from the caller (which could be several calls deep with lists/non-nulls).  Is this not the case?  Need tests to prove this behavior.  ;]\n. I'm not really liking this.  This type of conversion should be done on the input before the execute method is even called.  The input parser I added should make this a non-issue.  How are you passing inputs to the executor?\n. Any reason for not using a @ string here?\n. Do you have an example of this failing and where it is needed?  This seems like an odd and incorrect change.  \"If the type can't be found and its non-null, create a nullable variable type\".  Is the issue the name is coming through as MyType! and the lookup only knows about MyType?\n. The pattern here was the direct casts so variables didn't leak into the outer scope  - as is such the case now with this change.\n. I wouldn't want to include the whole field object here.  Also since it doesn't always apply, I wouldn't want to make it a required field in the constructor.  I would probably be fine with adding a string of FieldName as a optional field.\n. I do want to have a way to provide additional types, though I'm not sure this is the way I want to support it.  I was originally thinking of having a constructor overload that took in an IEnumerable<Type> or some sort of loader.\n. I don't want to accept this change without a use case and unit tests.  Is this how the reference javascript project works?  I'm not sure if it is or not.  I do know we potentially have some issues here, though I don't want to make changes without locking down the behavior.\n. I'm fairly sure we want to use Equals vs. a ToString here.  Do you have a use case?  Unit tests to prove?\n. This should get handled by validation, which is in progress.\n. I can understand what you want here, though would Validation perhaps solve the problem you're looking to solve?  Is that just essentially validation?  I don't want to move too far away from the official spec on behavior.\n. I have a number of updates to the GraphQL Language in https://github.com/graphql-dotnet/graphql-dotnet/pull/65 to help support validation.  There are a number of validation scenarios that will be super hard to do until that is merged in.  If you are able to add your specific validation scenarios to https://github.com/graphql-dotnet/graphql-dotnet/issues/10 then we can double check that they aren't already solved with the core validation rules provided by the spec.\n. It would, yes.  I'll add a test for that too.\n. Need to revert these hard-coded paths.\n. Don't need ToString here since the ParseValue can handle a DateTime.\n. We will want to handle possible nulls here, so I think just value?.ToString() should work.\n. We perhaps should check to see if the DateTime is a UTC date and if not convert it before it is returned.\n. I think this should get passed to the ParseValue method to ensure that it does get converted UTC if needed.\n. Value could be null here again.  I would move the Trim to the ParseValue method to ensure that the Trim happens in either case.\n. value?.ToString().Trim('\"')\n. This one needs to be kept as it was, since other users are using it like it was (with the enumeration value vs. the base type value) and I want to make sure there are tests that cover that usage.\n. Looking at the reference implementation again, this is correct behavior to exclude the InputObjectGraphType here.   There is inputFields where the input object data is queried from.\nhttps://github.com/graphql/graphql-js/blob/master/src/type/introspection.js#L287-L295\nhttps://github.com/graphql/graphql-js/blob/master/src/type/introspection.js#L236-L254\n. I like the new use.  @tlil87 ?\n. I like this update and the consistent behavior. \ud83d\udc4d \n. This exposes the underlying List to the outside world.  I have been trying to keep that encapsulated within the class so that the user is forced to use one of the api methods and doesn't have direct access to the list.  Doing so makes it so some of the rules (such as unique field names) get applied.\nIEnumerable<FieldType> vs. List<FieldType>\n. Same issue here with exposing List vs. IEnumerable.\n. You can keep the interface, though add the Add method to the interface.  You can then also have a base implementation of that interface to remove the duplication.  That is a common pattern.\n. I am a fan of this (as I had it in the next branch), however I have heard from several people that they would like to have the option of PascalCase property names.  So this ToCamelCase will have to go to support that.\n. It may make a difference, depending on what the final solution will be to enable the PascalCase feature.  Right now it is all handled by the serializer and it is setup to just do camelCase.  Though to support a mix of both PascalCase and camelCase (since I believe some of the spec properties need to be camelCase) we may have to have it configured as \"do not transform\" or something.  I'm honestly not sure yet.\n. What I'm kind of leaning towards is having the serializer setup as \"do not transform\", but then providing a configurable convention.  So when a field is registered, even if someone mis-types the name, it would get transformed at registration time to that convention.  I'm leaning towards something like that to stay away from having JSON.NET attributes or something similar littered throughout the code.\n. Noticed that DateTime is missing in this check.  We have a DateGraphType that can be used.  We may eventually want to provide a hook so users can add their own custom Type->GraphType mapping here.\n. I would keep these smaller ones in the original test file.  This massive one was put in a different file because of massiveness.\n. What version of VS are you using?  Could just be a mis-match between the two of us.  I am running 14.0.25425.01 Update 3.\n. Looking at how this changes the exception, perhaps we should instead just not try to await the task if it is already faulted instead of re-throw?\nif (!task.IsFaulted)\n{\n   await task.ConfigureAwait(false);\n   result = task.GetProperyValue(\"Result\");\n}. Instead of making a change here, it should be done in the DateTimeConverter.  That is where all of the actual conversion of values are taking place.  After messing with it a bit, I think this is the change that is needed:\ncsharp\n// var success = DateTime.TryParseExact(trimmedString, \"yyyy-MM-dd'T'HH:mm:ss.fffffff'Z'\", CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal, out result);\nvar success = DateTime.TryParse(trimmedString, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal, out result);. I think we don't need this Value property at all?. This should print the text null vs. just a null value.\nc.Print(f => \"null\");. Yes, that matches the JS project behavior.\nhttps://github.com/graphql/graphql-js/blob/master/src/language/printer.js#L79. May want to do some additional error/bounds checking here, just in case .As<T> returns null and parameters.Length is 0.  I think that passing a delegate with zero parameters would be a valid scenario.  I would want to use this in a \"schema builder\" scenario where some methods may not care about parameters.. I think this should be changed to actually pass the Type of the parameter so it could cast/convert it properly.  You would need to refactor GetArgument so you could pass in a Type, and have GetArgument<T> delegate to that new method.. I missed this before - I think you want context.Source.As<TSourceType>() here.  That has me thinking though ... I don't think you need SourceType or ReturnType at all.  Removing both of those would simplify this code a lot.  I added a check for ResolveFieldContext.\nEdit: Added field _parameters since those only need to be fetched once.\n```csharp\npublic class DelegateFieldModelBinderResolver : IFieldResolver\n{\n    private readonly Delegate _resolver;\n    private readonly ParameterInfo[] _parameters;\npublic DelegateFieldModelBinderResolver(Delegate resolver)\n{\n    _resolver = resolver ?? throw new ArgumentNullException(\"A resolver function must be specified\");\n    _parameters = _resolver.GetMethodInfo().GetParameters();\n}\n\npublic object Resolve(ResolveFieldContext context)\n{\n    object[] arguments = null;\n\n    if (_parameters.Any())\n    {\n        var index = 0;\n        arguments = new object[_parameters.Length];\n\n        if (typeof(ResolveFieldContext) == _parameters[index].ParameterType)\n        {\n            arguments[index] = context;\n            index++;\n        }\n\n        if (context.Source?.GetType() == _parameters[index].ParameterType)\n        {\n            arguments[index] = context.Source;\n            index++;\n        }\n\n        foreach (var parameter in _parameters.Skip(index))\n        {\n            arguments[index] = context.GetArgument(parameter.ParameterType, parameter.Name, null);\n            index++;\n        }\n    }\n\n    return _resolver.DynamicInvoke(arguments);\n}\n\n}\n``. Mind switching this to a property?. The purpose of these lines of code was to only build/test .NET Core when on macOS.  This switches it to build only .NET Core on both macOS and Windows, which isn't the wanted behavior.  When on Windows it should build both .NET Core and the full-framework .NET version (as it was previously).. Same as previous comment.. This should be moved to the root of the repo.. This is non-standard creation ofInputs.  All of the values should be converted from JSON.NET types to base types (string, int, etc.).  Have you ran this using the.ToInputsextension method on your input variables without your change?  Does that make it needed?. Mind switching these assertions to Shouldly?  That is what the rest of the project is using.. I believe you can useSelectMany` here so you can use async/await.\ncsharp\n.SelectMany(async value => ...). Can fix this todo now that this code is in the same repo.. I think we should use something like this UseCulture attribute since this sets the culture but then does not revert it back to its original value.  That could then create instability between tests.\nExample tests:\nhttps://github.com/xunit/samples.xunit/blob/6f687c676c03df61ca9853eb0a47d38bf602a073/UseCulture/UseCultureAttributeTests.cs#L102-L112. The point of this is to potentially convert the value to a specific type.  Perhaps there should be a more generic check if the value is already of the target fieldType?  Similar to what the DateTime check is doing above.  That would remove the need of the additional parse.  Of course if it does need the conversion then the below would be required.. > convert between float and decimal\nThat is possible.  It all depends on how the data is de-serialized and what Type someone added to their property on their object.\n\nI think the whole parsing, coercing etc. needs an overhaul.\n\nI agree with this - the primary purpose of some of this was to convert the JSON.NET types to actual types.  So the core framework didn't have a dependency on JSON.NET.  Otherwise you would have to be checking for JSON.NET types (JObject, JArray, etc.) throughout the codebase.. What we have done elsewhere is reverse this inheritance.\n```csharp\npublic class InputObjectGraphType : ComplexGraphType {}\npublic class InputObjectGraphType : InputObjectGraphType {}\n```\nThough that will probably cause problems with how we're doing checks on InputObjectGraphType and a number of people (including yourself) will want to use the generic InputObjectGraphType<T>.\nThere is an open issue related to this (#335) that I would like to fix for the 2.0 release.  We can use an interface to represent the input object and use that where we are now using the InputObjectGraphType.  Similar to what you were attempting to do with the IComplexGraphType but it would be input specific.. @holm0563 may need to bump the GraphiQL version to one that supports the null keyword perhaps?. I think this should be renamed to EnableMetrics.  Since logging is not the same things as the Metrics.. I think this needs a different flag.  Disabling field middleware is different than disabling the metrics gathering.  You can use field middleware for more than just metrics.. I'm really not liking this flag.  I understand why you want to \"disable\" it, though I'm thinking of too many instances where this would cause problems.  I don't think this should be a feature flag but instead have this behavior in a class that does that for you (which I believe you had in your original post).  We can pass the validator more data if it needs it to properly \"disable\" validation.. I think the ResolvedType should always be a ScalarGraphType here (due to a previous check), though I think technically the ? here would potentially change the result from non-null to null.  Is that the wanted behavior?  Should this be a hard-cast to ScalarGraphType since it should always be one or an error thrown after the as check?. I think this should be removed (see comment on where it is used).. AH, I see what you're saying.\nhttps://github.com/graphql/graphql-js/blob/4f5e351c2afb28e4ae3a44eae76d45d895ff3aa2/src/utilities/astFromValue.js#L70-L78\nThe JS project treats null different than undefined and NaN.  We don't have the \"luxury\" of 3 different \"nulls\" in C#.  Will have to decide on the best course of action here.. >If I'm understanding right you would prefer something like:\nvar exec = new DocumentExecutor(new GraphQLDocumentBuilder(), new SkipDocumentValidator(), new ComplexityAnalyzer());\nCorrect.  This flag turns off the Validation feature which is part of the spec.  So everything that Validation does doesn't happen.  Basically, I really don't want to support turning off that feature this easily since that is a pretty big portion of the spec being turned off.  I can understand why you want to do it, though completely turning it off is specific to your business needs and I wouldn't suggest anyone to do it unless they really understand what it means.  Meaning, it would now be easy to write invalid queries and get hard-to-understand errors or null data.\nWriting a class like SkipDocumentValidation is very easy to do, accomplishes the same thing, and doesn't put the support burden on the core project.. > Maybe as a future update the default validator should be evaluated from a performance standpoint and/or implement a caching strategy.\nI think that could be beneficial.  What I've heard from Facebook is they do cache quite a bit.  They have a set of \"trusted\" queries which I believe would skip validation (since they know it is valid) and even Document parsing, since they cache the parsing of the Document.\nI believe they even go as far as only having the client send a \"query name\", not even a GraphQL query, and associated variables to cut down on the http traffic.  I added the basic idea of this here though it doesn't add the Document parsing/validation benefit.. 4.4.0 lowest support is netstandard1.3 so this needs to stay at 4.0.0  The netstandard.2.0 section targets 4.4.0.. This should be kept at net45.. Need to remove this copyright.. https://github.com/graphql-dotnet/example-aspnetcore This repo now replaces that project.  It will be removed from the source soon.. I believe this is probably causing tests to fail.. Can you add this to its own test file?  This test is not super related to the other ones in this class/file.. Perhaps this can just be simplified to something like:\nif (fieldType.IsInstanceOfType(value)) return value;\nSo if the given value is of the given type it just returns it.. I think can just return result here.. Would like to keep this file as it signals to AppVeyor what SDK to use.. Could perhaps add the full exception as the inner exception to keep the simpler top level message.. The inner exception will never been seen in the response unless you have ExposeExceptions set on the ExecutionOptions.  I'm fine with either way.. This creeped in again.. This should be kept at Unix-style.. I would just merge this project into the core project so that there aren't multiple DLL's that have to get packaged.. I know this is probably still a work in progress, though the way these are strategies are currently setup there is a lot of duplicate logic.  That is the core of the GraphQL spec logic so I want to make sure that we can reduce that duplication as much as possible.  Obviously my concern is that this would make it way too easy for a query or mutation to start behaving differently.. Ditto on this one, merge it into the main project.. Its probably time to update to it. \ud83c\udf89 . These should stay at a specific Nuget reference.. Can you talk to about why to do this manually in this middleware vs. using the ASP.NET Core CORS middleware?. Hm, this change is a little troubling.  Didn't notice this one on the failed tests.  Will look at this closer.. I believe this needs to be moved above the type.IsArray check to fix the tests.. Should perhaps DataLoaderContext implement IDisposable and be disposed here, which would clear out any queue and loader references?. Can this perhaps be changed to a more generic IEnumerable?. Should this also use underlyingType vs. elementType, since the elementType could be nullable?  That would be a good test to add.. This project uses Shoudly if you can please update these assertions to that.\nresult.ShouldBe(doubles).. \ud83d\udc4d to using elementType.\nIs the reason for checking for ICollection so that you can use CopyTo?  One test that we're missing is one for an array of objects (or an array of arrays).  I don't think you'll be able to use CopyTo with that.  So I think that check should just be against IEnumerable and then build up the values.\n```\nvar valueList = propertyValue as IEnumerable;\nif (valueList == null) return newArray;\nvalueList.Apply((listItem, idx) =>\n{\n  tempArray[idx] = listItem == null ? null : GetPropertyValue(listItem, elementType);\n});\nreturn tempArray;\n``. There is aGraphQLExtensions.GetNamedType` that can do this unwrapping for you (and it includes multiple levels).  I think that would simplify this to:\nprivate static bool IsEnumType(IGraphType type)\n{\n    return type.GetNamedType() is EnumerationGraphType;\n}. Do we not have to worry about printing the ! for explicitly non-null enum values?  Seems like we should?  Something like the ResolveName function in this same file?. I'm a little confused by this.  You're calling error twice which does not seem right.  Should that instead be return await result?. Mind splitting this up into two different tests?. In general I would also prefer the docs to use descriptive names vs non descriptive.  ctxAc is non descriptive.. This should be uppercase O. . This looks like invalid code, missing parentheses around the cast?  Is that a C#7 feature I\u2019m not aware of?  Perhaps split to two lines to make it more readable?. Can remove this from the sample since it is not required.. Should this method name match the GetUserIds used above?. This code isn\u2019t making much sense to me. I\u2019m guessing this is a mix of C# and VB?  Can you update this to make a bit more sense?. The sample above uses a IUserStore interface.  I think it would help the reader to keep with that interface definition vs create an entirely new sample with basically the same name.  For example, show the class implementing that interface to keep continuity. I think the implementation is somewhat irrelevant to the sample.. Missing a semicolon here.. This project uses Shoudly for assertions. Can you please update these to use that?. This is failing on CI.. Just noticed this addition.  I'm not seeing ValueTuple used anywhere (maybe I'm missing some other usage).  Can this be removed?. These TimeSpan types should have unique names.  Otherwise you won't be able to use both in the same schema (one would override the other).. I think this need to be changed to similar to the Milliseconds type?  Checking for TimeSpan and then choosing TimeSpan.TotalSeconds?. Need to keep these DataAsDictionary changes.. Looking at this it does seem a bit redundant.  Perhaps we should provide a default implementation in the TypeConfig, which you can override with this IsTypeOf property you added to the metadata?  TypeConfig contains the Type, in this case ABlog, already.. Let\u2019s not catch any exceptions here and let them bubble up.. Can you switch this to formatException.Message.ShouldBe(...). For completeness can you add an actual Boolean value?. Don\u2019t need Uri->Uri registration.  The code checks to see if the value is of the requested type and returns if so.. This project uses Shoudly for assertions, would you mind updating these to use that?. I think this is the only change I'm mildly concerned about.  Mind moving the exception to the GetPropertyValue method?  I think that provides helpful debugging - perhaps the error should only be thrown in debug mode?  Maybe that would cause too much confusion with different behavior?  It appears that method wasn't being used by anything else.. Perhaps these two checks should be IsNullOrWhitespace?. This change is a little off.  This change would make it impossible to return a null value (which is valid), vs. ensuring that the requested property exists on the object.. Looking at this and the spec it appears that both code and data should be in the extensions.  Mind making that change?. I would instead add the validation to this AddValue method, since the other is an override.  So direct calls to AddValue(EnumValueDefinition) would not get validated.. Instead of replacing 2.0 with 2.1, I think 2.1 should just be added as another target.. Changing this package version to 2.1 should be done at the same time as when the project is updated to 2.1.  It may need to multi-target 2.0 as well as 2.1.. This project multi-targets several frameworks.  These need to stay under the net45 umbrella.. Yes.  I would prefer to run the tests against all the targeted frameworks.  Call me suspicious but I don't trust that they're 100% compatible.  \ud83d\ude00 . Is that a new feature with the new SDK?  It appears CI is failing specifically because of that change.  It is using 2.1.4 SDK.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/global.json. Little bit of clarity on the request to add names.  I was thinking the name of the field  and the GraphType vs. the name of the FieldType class.  With the intent being it would be easier to track down which class has the error.\nSome potential examples:\n\nThe declared field 'name' on 'MyGraphQL.MyGraphType' requires a field 'Type' when no 'ResolvedType' is provided.\nThe declared field 'name' on 'ComplexType\\<Droid>' requires a field 'Type' when no 'ResolvedType' is provided.. Link for extension method for a \"friendly type name\".\n\nhttps://stackoverflow.com/a/26429045/279764\n``\n    public static string GetFriendlyName(this Type type)\n    {\n        string friendlyName = type.Name;\n        if (type.IsGenericType)\n        {\n            int iBacktick = friendlyName.IndexOf('');\n            if (iBacktick > 0)\n            {\n                friendlyName = friendlyName.Remove(iBacktick);\n            }\n            friendlyName += \"<\";\n            Type[] typeParameters = type.GetGenericArguments();\n            for (int i = 0; i < typeParameters.Length; ++i)\n            {\n                string typeParamName = GetFriendlyName(typeParameters[i]);\n                friendlyName += (i == 0 ? typeParamName : \",\" + typeParamName);\n            }\n            friendlyName += \">\";\n        }\n    return friendlyName;\n}\n\n``. I prefer not to call methods in object constructor syntax since if the method throws an error you do not get what line number caused the error in the stack trace, it just points to the constructor.. Did you try usingJObject.FromObject`?  Does it serialize correctly?  It may not, though is worth a shot.\npublic static JObject FromObject(\n    Object o,\n    JsonSerializer jsonSerializer\n). I mentioned the one with the serializer to use if we were avoiding calling the WriteToStringAsync.  It would seem like calling FromObject would be much faster than serializing to string then re-parsing.. Since the source is available for making this change, I would prefer that an API is provided vs. doing this type of casting.  You should be able to move this RemoveField method to the ComplexGraphType class which has direct access to the collection of fields.. This would seem like confusing behavior that is hard to track down.. I do not think this would be a good idea.  As in, I don't think I would want to try to field the support tickets around this.  Do you have a specific use case for this?  If you have a scenario where this may be needed, I would instead opt for a method that handles this specific behavior.. > I don't think the ExecutionNode should be exposed in this way since it's internal to the execution\n+1 to this, though also ditto with ExecutionContext.  That class is currently not exposed on the public API and I would prefer it to stay that way if possible.  Is there a way we can accomplish something similar without exposing that class?. Can you rename this variable from timeValue to guidValue?. This does not need to be parsed because it is already a Guid.. Not every IObjectGraphType is going to have a SourceType that is helpful so I'm not sure that this is the direction that we should take.. I would like to pull in this PR but I'm concerned that adding these additional checks will slow down these methods.  Was there a reason for adding these additional checks?  Did you do perf tests and see that this was faster?\nhttps://www.dotnetperls.com/uppercase-first-letter\nThe above suggests to switch to the following for higher performance:\ncsharp\nchar[] a = s.ToCharArray();\na[0] = char.ToUpper(a[0]);\nreturn new string(a);. ",
    "bryanerayner": "It seems like using the C++ implementation would be mean a lot less work in the future.\n. @joemcbride Just submitted a PR for validation. Let me know what you think.\n. I have a pull request which puts rules in a namespace, as you suggested in your first point. Looking at the JS implementation, validation is implemented with static functions. We could make a partial class, with each file adding a new static function. My implementation was a more OOP approach.\n@moserware, I'm unfamiliar with unit-testing in C#. Would you be able to tackle that command line tool? I feel like it would be a useful thing to have in general.\n. ",
    "attilah": "For parser generator I'd take a look at Jetbrains' Nitra.\n. Wow ;-) can you share a link? :dancer: \n. ",
    "zhech2": "I ported facebook's javascript graphql parser/lexer to c#.  Any interest in including it?\n. Here it is: https://github.com/zhech2/graphql-dotnet/commit/4f0c720569fe76f9c7175f269775819b113d9ebf.\nIt could still use work but at least you can review it.  So far, I've only written enough to get all tests passing.  Some of the code to convert from the parser's ASTs to the current format is not implemented.  This is because the current tests were not calling any of the methods and I didn't want to implement them until I write tests.\nIf this method were used, I was thinking that the original JS source could be saved or referenced in some manner, so that it could be compared against.  This would allow for updating the C# when the JS source is updated.\n. I'm curious of how this is progressing.  I started writing code similar to what you describe until I noticed this issue.  It currently works against the star wars example.  \n@moserware are you still working on it?  I would be interested in helping out.\n. @tlil87 we have made significant progress on this issue as well. I would love to compare approaches to get the best solution. \n. @SpencerMacKinnon What team is the GraphQL dotnet channel under?\n. My username is zhech on the GraphQL dotnet channel.\n. ",
    "baronfel": "@zhech2 you could potentially use Paket's Github dependencies feature to reference the specific parser.js file in that repo at a point in time.  Then, any updates to that would show as an updateable dependency when 'paket update' is run.\n. ",
    "plecong": "Hi @joemcbride, \nFirst off, great work here and I'm super excited about this project. \nTL;DR The current use of .NET Types as GraphQL types is conflating concepts and could lead to some problems down the road.\nI realize this issue is closed, but having played with the graphql-js implementation I was puzzled by the change from \"instance of GraphQL type\" to \"Type of GraphQL type\". I actually think this wasn't a flaw in the original API design.\nWhile I see that you can now use a GraphQL type Type class as the generic parameter, I'm not sure it buys you anything. The generic parameter is for .NET, and not for GraphQL's type system. What I mean is that users of the API aren't benefiting from knowing that the generic type is the GraphQL type.\nBoth of these examples are equivalent:\n``` csharp\n// Now: Type as GraphQL type\nField(\"name\", \"The name of the person\")\n// Before: Instance as GraphQL type\nField(Scalars.GraphQLStringType, \"name\", \"The name of the person\")\n```\nHowever, with method generic type information which .NET knows how to use, you could define the Field() DSL method on GraphType like:\ncsharp\npublic void Field<TResolve>(\n    GraphType type, \n    string name,\n    string description = null,\n    QueryArguments arguments = null,\n    Func<ResolveFieldContext, TResolve> resolve = null)\nThis enables type safety when creating the schema:\ncsharp\nField<string>(\n    Scalars.GraphQLString, \n    \"name\", \n    description: \"The name of the person\",\n    resolve: ctx => \"John\"); // <- this must return a string\nI was taking a look at converting the Union and other missing types, but things get a little mixed up. For example, a GraphQLUnionType consists of two or more other GraphQL types, so one way to do this is to make the union of types a generic parameters on the UnionGraphType:\ncsharp\npublic class UnionGraphType<T1,T2> : GraphType \n    where T1 : GraphType \n    where T2 : GraphType { }\nThis would allow the Field DSL method to look like this:\ncsharp\nField<UnionGraphType<FooType,BarType>>(\"FooBar\", \"A foo or a bar\");\nUnfortunately, this can get unwieldly and we'd have to limit the number of sub-types in the GraphQL union (which probably isn't bad).\nUsing .NET Types as GraphQL types also means that we have to instantiate the type to get properties on it because the .NET Type doesn't give a way to get additional information through Reflection (except through Attributes). This leads to the need for GraphTypesLookup and TypeCollectionContext.\nAll this being said, I believe the reason (and correct me if I'm wrong) for changing to this was so that the Schema DSL had .NET \"feel\" where code liked Field<StringGraphType> read like, \"Field of this GraphQL String type\". Unfortunately this is conflating the GraphQL type (which graphql-js represents as an instance) with the .NET type.\nAlso, looking down the road, I saw there was an issue for auto-generating schema. I think having GraphQL types as .NET types would ultimately make this very complicated. For example, from #14 we have the following:\n``` csharp\n    public abstract class StarWarsCharacter {\n        [NotNull]\n        [Description(\"The id of the character.\")]\n        public int Id { get; set; }\n    [Description(\"The name of the character.\")]\n    public string Name { get; set; }\n\n    // If the function returns a Task, the executor will execute it asynchronously\n    public async Task<IList<StarWarsCharacter>> Friends() {\n        return await _Repository.GetFriendsForIdAsync(Id);\n    }\n\n    [Description(\"Which movie they appear in.\")]\n    public async Task<IList<Episode>> AppearsIn() {\n        return await _Repository.GetAppearsInById(Id);\n    }\n}\n\n```\nTo make this work, there would have to be code generation to create a .NET Type to represent it in the schema:\ncsharp\n// This would have to be generated or manually created as boilerplate.\npublic class StarWarsCharacter : GraphObjectType { }\nHowever, if you had instances of GraphQL types you could potentially build an instance by Reflecting on the properties and attributes:\ncsharp\npublic static class GraphQLTypeExtensions\n{\n    public static ObjectGraphType AsGraphType(this Type type)\n    {\n        // scan through properties and create fields automatically using \n        // attributes for name/descriptions\n    }\n}\nThen in code your schema DSL would be:\ncsharp\nvar starWarsCharacter = typeof(StarWarsCharacter).AsGraphType();\nI realize there was a lot of work put into this to get it down this road, but I'm a little concerned that this disconnect with the reference implementation might impede full implementation down the road.\n. Hi,\nThanks for the reply and I do think there's ways to solve the problems you state. \nRequirement 1\nSo, the way that the reference implementation solves this is that they create a __Schema singleton instance that represents the \"base\" types. I would imagine that a static variable on a static class like Introspection would suffice to contain this as a global in .NET.\nThis is essentially the same as having a schema builder instance, but the __Schema instance is more likely an internal singleton.\nRequirement 2\nThat __Schema global is used in their Schema object during the type discovery phase (let's call it). A similar technique now that the object is global can be used in .NET. This essentially merges all of the \"base\" and \"user-defined\" types together into the single schema instance.\nI'm also thinking that the Schema would also be an instance. The instance could be of a type that inherits from Schema or just be an single value constructed or just a singleton pattern:\n``` csharp\npublic class StarWarsSchema extends Schema \n{\n    public static readonly StarWarsSchema INSTANCE = new StarWarsSchema();\npublic StarWarsSchema()\n{\n    Query = // build your query schema here. \n}\n\n}\n```\nRequirement 3\nSo using IoC with an instance type where the .NET type is the generic type instead of the GraphQL type actually makes more sense to me.\nFor instance, let's say you have a Foo domain class:\ncsharp\npublic class Foo \n{\n    public string Name { get; set; }\n}\nAnd with that you have something that \"loads\" the Foo from a database or REST call:\ncsharp\npublic interface ILoader<T>\n{\n    T GetItem(int id);\n}\nAnd now you create a GraphQL type that represents Foo in GraphQL:\n``` csharp\npublic class FooSchema : GraphQLSchema\n{\n    public FooSchema(ILoader fooLoader)\n    {\n        var fooType = new GraphQLObjectType(\n            name: \"Foo\",\n            fields: builder => {\n                builder.Field(\"name\", GraphQLScalars.GraphQLString, f => f.Name);\n            });\n    Query = new GraphQLObjectType(\n        name: \"Query\",\n        fields: builder =>\n        {\n            builder.Field<Foo>(\"foo\", resolve: (context) => fooLoader.GetItem(context.args[\"id\"]));\n        });\n    }\n}\n\n}\n```\nThis could get unwieldly when there are a lot of different loaders and types. The pattern that I think would be helpful then is to create provider objects that create GraphQL type instances for related subsets of types that are fetched together. Then the top-level Schema would compose these parts together like modules that are provided by the IoC container.\nOther Considerations\nI've been playing with how this would work with various builder patterns and one tricky problem that arises with instance vs Type is the circular reference problem. The Java project solved this by introducing a \"type reference\" type. During the \"type discovery\" phase, the references would be resolved to their real instance. There would have to be some validation to ensure that there aren't leftover references and it makes schema construction a little more difficult.\nAlso, I've been playing with a prototype and using the generic type parameter as a domain type instead of a GraphQL type also enables really easy schema creation using Reflection:\ncsharp\n// with the right defaults this is all that is really needed\n// because the name and fields can be inferred.\nvar fooType = new GraphQLObjectType<Foo>();\nThat has opened up the builder API I'm toying with because then you could create predicates on which properties you want to expose, have the builder just use a Linq Expression to generate the resolve and name, etc.\ncsharp\nvar fooType = new GraphQLObjectType<Foo>(fields: builder => {\n    // as an Expression I could get the name of the property and have the resolve built-in\n    builder.Field(f => f.Name);\n});\nThis could make schema creation extremely easy for existing .NET projects. This however changes it to mean \"GraphQL Object Type that represents Foo\".\n. That's correct. The Field method has some overloads to be able to work correctly.\nHere's what I'm playing with:\n``` csharp\npublic class GraphQLObjectType :\n    GraphQLObjectType,\n    IGraphQLType,\n    IGraphQLOutputType,\n    IGraphQLCompositeType,\n    IGraphQLNullableType,\n    IGraphQLNamedType\n{\n    public GraphQLObjectType(\n        string name,\n        IEnumerable interfaces = null,\n        Action> fields = null,\n        Func isTypeOf = null,\n        string description = null) : base(name, interfaces, isTypeOf: isTypeOf, description: description)\n    {\n}\n\n}   \npublic interface IGraphQLFieldBuilder\n{\n    void Field(\n        string name,\n        IGraphQLOutputType type = null,\n        string description = null,\n        IGraphQLFieldResolver resolver = null);\nvoid Field<TResolve>(\n    string name,\n    IGraphQLOutputType type = null,\n    string description = null,\n    IGraphQLFieldResolver<T,TResolve> resolver = null);\n\nvoid Field<TResolve>(\n    string name,\n    IGraphQLOutputType type = null,\n    string description = null,\n    Func<T, GraphQLResolveInfo, TResolve> resolve = null);\n\nvoid Field<TResolve>(\n    string name,\n    IGraphQLOutputType type = null,\n    string description = null,\n    Func<T, TResolve> resolve = null);\n\n}\n```\nThe IGraphQLFieldResolver is what is responsible for resolving the field from type T to type TResolve. It's possible to create a re-direction around an existing Func<> or interfaces that are responsible for the loading.\nWhat I'm finding is that the generic and non-generic versions of the constructors can get unwieldly. I'm thinking that it's possible to expose two different APIs that are largely similar, but would make the constructors more consistent. Essentially, where there are a lot of overloads due to options for optional parameters, we would expose that as method overrides. Then for classes, expose a more traditional Builder pattern (e.g. inner-class, setter methods, etc.).\nThe IGraphQLFieldBuilder above illustrates creating the method overloading pattern. It also shows how the constructor for GraphQLObjectType can get pretty hairy with generic parameters. Instead, we can expose methods on GraphQLSchema:\n``` csharp\npublic class GraphQLSchema {\nprotected GraphQLObjectType ObjectType(...);\nprotected GraphQLListType ListType(...);\nprotected GraphQLNonNull NonNull(...);\nprotected GraphQLTypeReference TypeRef(...);\n\n}\n```\nThis gives consumers of the API that are building the schema built-in helper methods when creating a schema for 80% options. Or they can go to the more advanced \"kitchen-sink\" Builder for fully customizing the GraphQL types.\nWe may want to expose methods like MapType on GraphQLSchema that do the Reflection based schema constructions so developers have a scalable API surface area from easy (Reflection-based, get it up and working fast on existing models), to medium (add some descriptions and get some depth), to full-blown.\n. I'm probably over thinking this, but I'm trying to think through the use-cases for the API. For the IoC use-case it seems like there would be a need for a \"bridging\" class that could be created.\nPerhaps, the helper methods above could be placed on an abstract class like SchemaModule:\n``` csharp\npublic class Page { }\npublic class Post\n{\n    public int Id { get; set; }\n}\npublic class Comment { }\npublic interface ICommentLoader\n{\n    IEnumerable GetComments(int postId);\n}\npublic interface IPostLoader\n{\n    IEnumerable GetPosts();\n    Post GetPost(int id);\n}\npublic class PageSchemaModule : GraphQLSchemaModule { }\npublic class PostSchemaModule : GraphQLSchemaModule\n{\n    public GraphQLObjectType PostType { get; private set; }\npublic GraphQLObjectType CommentType { get; private set; }\n\npublic PostSchemaModule(ICommentLoader loader)\n{\n    CommentType = new GraphQLObjectType<Comment>(\"Comment\");\n\n    PostType = new GraphQLObjectType<Post>(\n        name: \"Post\",\n        fields: _ =>\n        {\n            _.Field(\n                name: \"Comments\", \n                type: new GraphQLList(CommentType), \n                resolve: (post, context) => loader.GetComments(post.Id));\n        });\n}\n\npublic IEnumerable<Post> GetPosts() { }\n\n}\npublic class WordpressSchema : GraphQLSchema\n{\n    public WordpressSchema(\n        PostSchemaModule postModule,\n        PageSchemaModule pageModule)\n    {\n        Query = new GraphQLObjectType(\n            name: \"RootQuery\",\n            fields: _ =>\n            {\n                _.Field(\n                    name: \"posts\", \n                    type: new GraphQLList(postModule.PostType), \n                    resolve: ctx => postModule.GetPosts());\n            });\n    }\n}\n```\nThe IoC container can then build up the modules using constructor injection and output a schema. The module is a way to decompose the schema into sections or even aggregate roots (if you speak DDD).\n. Re: Making fields required, I was going back and forth on this and I think you're right. My original thinking was that without a fields definition that it would automatically reflect, but I think for constructors being explicit is a better API. \nI was toying with a FieldsFromReflection method on the IGraphQLFieldBuilder:\ncsharp\n            var humanType = new GraphQLObjectType<Human>(\n                name: \"Human\",\n                description: \"A humanoid creature in the Star Wars universe.\",\n                fields: _ => _.FieldsFromReflection());\nI'm also going back on forth on if there should be a IGraphQLFieldsBuilder for building fields on a a GraphQLObjectType and when you call Build() or BuildField() on it you get an IGraphQLFieldBuilder:\ncsharp\n            var humanType = new GraphQLObjectType<Human>(\n                name: \"Human\",\n                description: \"A humanoid creature in the Star Wars universe.\",\n                fields: _ =>\n                {\n                    _.BuildField(\"id\")\n                        .Description(\"The id of the character\")\n                        .Resolve(x => x.Id);\n                });\nRe: Using the same names as the reference implementation, again I was going back and forth. I originally setup my model like theirs so that I could write samples that looked similar. I found the names a tad verbose, but having sample code that looks like the reference is probably beneficial in the end.\n. Hi @moserware,\nI've been spending a lot of time with the .NET implementation of GraphQL as well as looking at implementations in other languages. My particular use case will be a mix of SQL and REST backends, so the N+1 problem has been in the front of my mind for awhile.\nLet me walk through my thoughts on how this would be solved because I believe it aligns with the \"first way\" in @dschafer's comment:\nEach resolve starts on a field (of the \"root\" query type or a type down the tree). This is where in GraphQL custom logic to retrieve data is implemented and where there is the most control. The field will either return a single or many results.\n1. What would be helpful is if the resolving function was passed (through ResolveFieldContext) the child fields. In your example, in the function resolving posts it would be helpful to know that author is a subfield that needs to be fetched. The JOIN or 2-query optimizations that you mentioned could be done there.\n2. Helper extension methods ResolveFieldContext could be implemented that scan the document for sub-fields.\nA few differences from your suggestion:\n1. I don't think we would necessarily want a different Executor implementation. There's talk on the graphql-js implementation about doing a \"collecting\" execution, but aside from that I believe the execution order and what can be safely parallelized is defined in the spec. \n2. I don't think we would want to know \"sibling\" nodes as then that makes each resolving function potentially dependent on information outside of it's context. It would also force a serial execution and it'd be difficult to signal that a particular resolving function must be serial or dependent.\n3. I don't think a breadth-first strategy is required again because at the top of the tree, each resolve function should know what it needs below it.\nTo follow-up on your example, here's how I would see this working. With the query:\nposts(sortBy: RECENT, take: 10) {\n    id,\n    date,\n    author {\n        name\n    },\n    content\n}\nThe code to handle this would look something like this:\ncsharp\npublic IEnumerable<Post> GetPosts(ResolveFieldContext context)\n{\n    // check if we are getting authors\n    if (context.GetChildFields().Contains(\"author\"))\n    {\n        return dao.GetPostsWithAuthor(context.Args[\"take\"]);\n    } \n    else \n    {\n        return dao.GetPosts(context.Args[\"take\"]);\n    }\n}\nThe resolving function here handles the optimization and selection by previewing what will happen down the GraphQL tree. It doesn't need to look at siblings or be breadth-first across the entire tree because for the view of the tree where it is the apex, it will be first.\nNow, let's say you also want to get comments from your GraphQL query. It'd be possible then to optimize the query into multiple queries: (a) for posts, (b) for authors on those posts, (c) for comments on those posts, (d) authors on those comments.\nThe problem then becomes where to store this data as the Executor traverses down the tree. I would also propose adding a general Dictionary on the ResolveFieldContext that sits along side the source object as a sort of \"shadow\" source. \nNote: This is your idea where we could memoize the data and I think it's necessary to store the data outside of the source\n``` csharp\npublic IEnumerable GetComments(ResolveFieldContext context)\n{\n    Post post = (Post)context.Source; // the parent Post\n// this value can be populated higher-up in the tree as an optimization\nif (context.Contains(\"comments\")) \n{\n    var comments = (IEnumerable<Comment>)context[\"comments\"]);\n    return comments.Where(c => c.Post.Id == post.Id);\n}\nelse \n{\n    // fetch using the Post.Id;\n}\n\n}\n```\nFinally, I believe that the Executor implementation should attempt to \"batch\" queries as much as possible. The comment from @dschafer is a month old, but Facebook has released an implementation of a data loading/caching layer that could sit between GraphQL and data sources: https://github.com/facebook/dataloader.\n. ",
    "michshat": "Joe thanks!!! \nThat's right the babelRelayPlugin.js initializing schema and validating against it.\nI did get the the library from nuget at first, but later realized it wasn't up todate. I used introspections queries to produce schema - it does work very nicely - but i think i may need to combine several of them into one for babelRelayPlugin to consider it complete.\nI'll play more with it and let you how it goes.\nThanks again.\nMichael\n. A couple things I noticed aren't supported yet :)\n1. field arguments via arg property - where compiler complains resolving arg property\n   the case is described here https://github.com/graphql/graphql-js/blob/master/src/tests/starWarsIntrospectionTests.js#L299\n2. when generating schema of this schema introspection query babel relay plug-in says it's incomplete\ncsharp\n var query = @\"\n            query SchemaIntrospectionQuery {\n              __schema {\n                queryType { name, kind }\n                types { \n                    kind\n                    name\n                    description\n                    fields {\n                        name\n                        description\n                        type {\n                            name\n                            kind\n                        }\n                        isDeprecated\n                        deprecationReason\n                    }\n                }\n                mutationType { name }\n                directives {\n                  name\n                  description\n                  onOperation\n                  onFragment\n                  onField\n                }\n              }\n            }\n            \";\nI'll play with it more ...\nThanks!!!\n. Joe, that's awesome. Thanks!\nI'm past resolving arg property, now hitting the \"can't resolve ofType\"\n\\\"errors\\\":[{\\\"ClassName\\\":\\\"GraphQL.ExecutionError\\\",\\\"Message\\\":\\\"Error trying to resolve ofType.\\\",\\\"Data\\\":null,\\\"InnerException\\\":{\\\"ClassName\\\":\\\"System.IndexOutOfRangeException\\\",\\\"Message\\\":\\\"Index was outside the bounds of the array.\\\",\\\"Data\\\":null,\\\"InnerException\\\":null,\\\"HelpURL\\\":null,\\\"StackTraceString\\\":\\\"   at GraphQL.Introspection.__Type.\\u003c.ctor\\u003eb__b(ResolveFieldContext context) in\ncsharp\nvar query = @\"\n            query SchemaIntrospectionQuery {\n              __schema {\n                queryType { name, kind }\n                types { \n                    kind\n                    name\n                    description\n                    fields {\n                        name\n                        description\n                        type {\n                            name\n                            kind\n                        }\n                        args {\n                          name\n                          description\n                          type {\n                            name\n                            kind\n                            ofType {\n                              name\n                              kind\n                            }\n                          }\n                          defaultValue\n                        }\n                        isDeprecated\n                        deprecationReason\n                    }\n                }\n                mutationType { name }\n                directives {\n                  name\n                  description\n                  onOperation\n                  onFragment\n                  onField\n                }\n              }\n            }\n            \";\nThanks again. And looking forward getting further with that :)\nMichael\n. Wow, adding graphiql is huge!!! I have got no errors whatsoever, and relay babelify plugin takes the schema and able perform validation against it.  I'll play more today.\nThanks!!!\n. That's great!\nCouple things:\n1. isDeprecated\": \"False\" - string vs boolean (doesn't seem to be making any difference though)\n2. Also the following code generates circular reference error where babel-relay-plugin raises \"maximum call stack size exceeded while parsing\" exception (there is seem to be object and interface type collusion)\n{\n                    \"kind\": \"OBJECT\",\n                    \"name\": \"User\",\n                    \"description\": \"A mechanical creature in the Star Wars universe.\",\n                    \"fields\": [ { \"name\": \"UserId\", \"description\": null, \"args\": [ ], \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, \"isDeprecated\": false, \"deprecationReason\": null }, { \"name\": \"FirstName\", \"description\": null, \"args\": [ ], \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null }, \"isDeprecated\": false, \"deprecationReason\": null }, { \"name\": \"LastName\", \"description\": null, \"args\": [ ], \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null }, \"isDeprecated\": false, \"deprecationReason\": null } ],\n                    \"inputFields\": [ ],\n                    \"interfaces\": [ \n                        { \"kind\": \"INTERFACE\", \"name\": \"User\", \"ofType\": null } ],\n                    \"enumValues\": [ ],\n                    \"possibleTypes\": [ ]\n                },\nThank you!\n. 1. In the example above i had it adjusted, here is non modified example:\n{\"name\":\"ENUM\",\"description\":\"Indicates this type is an num.  `enumValues` is a valid field.\",\"isDeprecated\":\"False\",\"deprecationReason\":null},\nParser doesn't seem to mind it though\n1. I have this that causes the issue\nC#\npublic class UserType: ObjectGraphType\n    {\n        public UserType()\n        {\n            Name = \"User\";\n            Description = \"A mechanical creature in the Star Wars universe.\";\n            Field<NonNullGraphType<IntGraphType>>(\"UserId\", \"The id of the droid.\");\n            Field<StringGraphType>(\"FirstName\", \"The name of the droid.\");\n            Field<StringGraphType>(\"LastName\", \"The name of the droid.\");\n            Interface<UserInterface>();\n        }\n    }\nNote UserType and UserInterface \n. Regarding item 2:\nI have tried to change the name from User to IUser (for the sake of it) and also changing UserInterface to IUserInterface - in both cases running into exception where it says that the schema is incomplete\nWhat seem to be missing (could be wrong though), is INTERFACE type definition:\n{\n          \"kind\": \"INTERFACE\",\n          \"name\": \"Node\",\n          \"description\": \"An object with an ID\",\n          \"fields\": [\n            {\n              \"name\": \"id\",\n              \"description\": \"The id of the object.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"ID\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": [\n            {\n              \"kind\": \"OBJECT\",\n              \"name\": \"Todo\",\n              \"ofType\": null\n            },\n            {\n              \"kind\": \"OBJECT\",\n              \"name\": \"User\",\n              \"ofType\": null\n            }\n          ]\n        }\nObject Types interfaces are properly defined, it's the type that is not.\n. Joe, thank you.\nThis query is exactly what i'm after :)\nBut have a look here - we are missing the \"INTERFACE\" kind\n{\n    \"data\": {\n        \"__schema\": {\n            \"queryType\": { \"name\": \"Query\" },\n            \"mutationType\": null,\n            \"types\": [\n                { \"kind\": \"SCALAR\", \"name\": \"String\", [ ... ] },\n                { \"kind\": \"SCALAR\", \"name\": \"Boolean\", [ ... ] },\n                { \"kind\": \"SCALAR\", \"name\": \"Float\", [ ... ] },\n                { \"kind\": \"SCALAR\", \"name\": \"Int\", [ ... ] },\n                { \"kind\": \"SCALAR\", \"name\": \"ID\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"__Type\", [ ... ] },\n                { \"kind\": \"ENUM\", \"name\": \"__TypeKind\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"__Field\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"__EnumValue\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"__InputValue\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"Query\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"User\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"__Schema\", [ ... ] },\n                { \"kind\": \"OBJECT\", \"name\": \"__Directive\", [ ... ] },\n                { \"kind\": \"INTERFACE\", \"name\": \"IUser\", [ ... ] ], } <= this part is NOT getting output\n            ],\n            [ ... ]\n            [ ... ]\n        }\n    }\n}\nOnce I added * { \"kind\": \"INTERFACE\", \"name\": \"IUser\", [ ... ] ], }* the schema validation succeed.\n. Sorry. It should export, but it doesn't - it is missing from the generated schema top level __schema->types\nDoes it make sense? If not, i'll troubleshoot the code and see what's happening.\n. I had tried your suggestion, the Character interface is handled correctly - something is wrong with my setup :)\nIt's all good. Thank you!!!\n. Joe thank you!!!\nFew more nuances I came across while playing with Relay\n1. Relay doesn't like errors:[] - to make it work i had to strip it liek this: result = result.Replace(\",\\\"errors\\\":[]\", \"\"); But more elegant would be omitting it when returning success data\n1. Property names should be camel cased in both ends (example. firstName, lastName) - result data returns it in such format\npublic UserType()\n        {\n            Name = \"User\";\n            Description = \"A mechanical creature in the Star Wars universe.\";\n            Field<NonNullGraphType<IntGraphType>>(\"userId\", \"The id of the droid.\");\n            Field<StringGraphType>(\"firstName\", \"The name of the droid.\");\n            Field<StringGraphType>(\"lastName\", \"The name of the droid.\");\n            Interface<IUserInterface>();\n        }\n1. For whatever reason root level arguments type expected to be string (note id parameter bellow, i had initially setup as integer)\nField<UserType>(\n                \"user\",\n                arguments: new QueryArguments(\n                    new[]\n                    {\n                        new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\" }\n                    }),\n                resolve: context => data.SingleOrDefault<User>(\"WHERE UserId=@0\", (string)context.Arguments[\"id\"])\n. Joe thanks!\n1. I'll check that out, but i think graphql-relay library (https://github.com/graphql/graphql-relay-js) that does runtime validation\nwhen i defined the Relay like following:\nexport default Relay.createContainer(Index, {\n   fragments: {\n    user : () => Relay.QL`\n      fragment on User {\n        firstName,\n        lastName,\n      }\n    `,\n  },\n});\nthe request is being handled by GraphQL server:\n``` c#\n        public ContentResult ExecuteGraphQL(string query)\n        {\n            var result = (new Executer()).Execute(new UserSchema(), query);\n            result = result.Replace(\",\\\"errors\\\":[]\", \"\");\n        return Content(result, \"application/xhr\");\n    }\n\n```\nand if empty array of errors is present \"errors\":[] the relay-graphql complains\n1. ok\n2. Testing that on its' own - works with integers, but when connecting Relay layer - it won't (but may be its' just my setup, i'll play more with it)\nThanks again!\n. Joe, that's pretty slick - I wasn't aware of that -Thanks!\nAnother question, not sure if it's a part of the scope of the the GraphQL.NET - the Relay nodeDefinitions (nodeInterface and nodeField), as well connection  and connectionType\n1. nodeDefinitions - defining node and its' edges (item and item collections)\n2. connection - connecting related data and providing paging information\nDo you think it should be implemented as a separate library?\n. ",
    "james-andrewsmith": "@joemcbride \n@scmccart \nNice!\nI've got to cleanup what I've done (this is on the whole neater than my very quick take) however a lot of the actual task casting / whenall looks similar, I'll through up what I have on a fork so it makes for easier discussion. \nThe key difference is I've kept a single resolve, and I'm just checking if the resolve is a task. \nI updated some of the tests to have a mix of Sync/Async resolution, at the very least we'll be able to use those tests. \n. @joemcbride @scmccart \nHey Guys - I've opened another PR to help with a discussion about Resolve & ResolveAsync vs Execute & ExecuteAsync \nPS: I've done it really quickly while at lunch, apologies about the new line / diff situation. \n. ",
    "scmccart": "Hey, I've moved this to a single resolve that isn't specifically dependent on Task<object>, but can use Task<Human> and Task<Droid>.\n. @joemcbride Execute is now ExecuteAsync.\n. @moserware I do like having the option of a CancellationToken, and it's usually best practice. Seems that it could short circuit the  DocumentExecutor and also be available in the ResolveFieldContext.\n. Hey, IMHO ExecuteAsync should replace Execute, having a synchronous Execute call with asynchronous resolves can end up in deadlocks unless handled carefully. That would also bring it back to just one DocumentExecutor.\nI've also updated #7 to use a single resolve.\n. Any progress here, or anything I can help with? \nI'm running into the same issues that @plecong mentions in #3, e.g. the use of GraphType.Field<T> at runtime is difficult due the generic. This makes it difficult to plug any convention based approach on top of the library.\n. If you like, I can take on adding cancellation support. I think timeout should be handled by the caller of the library, though it can be baked in easily on top of the cancellation.\n. Added a couple of tests, could use suggestions on other tests to add... couldn't think of any more unique cases.\n. @joemcbride,  @moserware, any thing else I add to this?\n. Happy to help.. ",
    "moserware": "I'm still getting up to speed on this, but I agree that async support would be great! What do you think about supporting CancellationTokens? I think it'd be nice to have some form timeout support (e.g. to prevent Denial Of Service attacks with deeply nested queries since they're coming from a possibly untrusted client) and a simple CancellationToken support combined with a Task.Delay could help with that.\nThat is, we could kick off the ExecuteAsync and a Task.Delay. If the Task.Delay finishes first, then we cancel the query by signaling the CancellationTokenSource\nThoughts?\n. Here's a rough sketch of what this might take:\n1. Create a GraphQL.Validation.Rules namespace (and folder) that has one class per rule as defined in Section 5 of the GraphQL spec. It's probably a good idea to pattern off of the graphql-js implementation. It might also be nice to provide a way of generating a link back to the spec itself for each validation error.\n2. Update GraphQL.Validation.DocumentValidator to go through each rule and aggregate errors into the final ValidationResult\n3. It could make sense to write a command line tool that extracted the test cases from the graphql-js test suite and converted them into a C# test (with proper license attribution)\n. Further details can be found in the GraphQL spec and graphql-js implementation\n. For details, see graphql-js implementation and the GraphQL spec\n. We could also use a conventions-based approach to automatically generate TypeScript definitions that could be used by React/Relay components in their respective JSX/TSX.\n. Exactly! For at least the first iteration, the wrapper would build a traditional Schema and then pass it to the Executor. Down the road, I could imagine lots of optimizations like those done in Dapper and Jil to possibly eliminate the need for the intermediate Schema.\nI'm still very early on in my thinking on this, so it's possible I could be missing something big that will make it not work, but I think this \"POCO\" approach could make it a bit easier for people to create GraphQL backends in .NET.\nI welcome any suggestions and warnings of possible \"gotchas\" with this approach.\n. @zhech2 I'm not currently working on this. We've decided at work to put further Relay work on pause for at least a few months. \n. @scmccart that'd be great! It should be a matter of adding a CancellationToken cancellationToken = default(CancellationToken) as a final optional parameter to ExecuteAsync and then flow that to the ExecutionContext where resolve methods can optionally use it. There might also be places where cancellationToken.ThrowIfCancellationRequested(); calls might make sense or doing some minor optimizations by checking if the token is non-default by looking at the CanBeCanceled property. \nTimeouts would then be trivial:\nvar cancelSource = new CancellationTokenSource();\ncancelSource.CancelAfter(TimeSpan.FromSeconds(30));\nvar result = await executer.ExecuteAsync(..., cancelSource.Token);\n. @plecong Thanks for sharing your thoughts!\nSome follow-ups:\nKnowledge of sibling fields isn't necessary.\nYou're right, I think you can do all the optimizations at the parent level instead. \nThe use case here is for the first optimization I described regarding multiple field selects. If your data store/REST endpoint forces you to get all columns/fields on a table/resource, then there's little that can be optimized since you'll have the full object in memory and can get any column/property at no (additional) cost. \nHowever, SQL stores (and some REST APIs like the Stack Exchange API v2.0) allow you to declare what fields you actually want.\nBy knowing what child fields will actually be selected, we can optimize execution of the query on the backend. For example, if we're using Dapper for SQL, we could generate a SELECT query that just has the child fields that were specified in the GraphQL query.\ndao.GetXWithY(...)-style Optimizations\nI agree that while processing a top-level like posts you could \"peek\" at its children to see if you should opportunistically fetch a related resource. With Entity Framework (or similar), you could achieve this with a series of .Include(<NavigationPropertyName>) calls. \nBuilding on your example:\n```\npublic IEnumerable GetPosts(ResolveFieldContext context)\n{\n    // Note that we take advantage of the IQueryable style until the very end:\n    var posts = efContext.Posts; \n// check if we are getting authors\nif (context.GetChildFields().Contains(\"author\"))\n{\n    posts = posts.Include(\"Author\");\n}\n\nswitch(context.GetArg<string>(\"sortBy\"))\n{\n    case \"RECENT\":\n        posts = posts.OrderByDescending(p => p.Id);\n        break;\n    ...\n}\n\nposts = posts.Take(context.GetArg<int>(\"take\"));\n\n// This last line actually materializes the query\nreturn posts.AsEnumerable();\n\n}\n```\nNote that Dapper users could do something similar. In fact, this is how Stack's API implements filters.\nOne advantage of this approach is that you can carefully craft more optimal queries to your backend and effectively achieve the JOIN optimization I described earlier. \nOne possible disadvantage is that you might need to spend more time upfront thinking about all the different shapes of queries you'd receive and the necessary optimizations they'd require. If you forgot one, you'd potentially be back to the N+1 problem. I imagine this problem gets worse as the code/team developing it grows and thus is one of the reasons Facebook developed DataLoader.\nDataLoader-style optimizations\nThis could potentially offer a pragmatic approach that isn't quite as efficient as the more handcrafted approach above, but it could make writing backend \"glue\" code easier because you wouldn't have to know in advance the types of GraphQL queries that'd be thrown at it. Further, you wouldn't have to manually write code to cache data from one level to the next.\nI think this is actually similar to the breadth-first search approach I mentioned previously but with a slight variation.\nThe idea is that the Executor would always work at a single \"level\" of the AST of the query. The Executor would asynchronously ask the relevant DataLoader instances to fetch the requested entities. The DataLoader(s) then would not execute any backend queries at all and instead would just keep \"batching\" them up. \nAt some point, the Executor would signal that all backend queries at that AST \"level\" were now \"in flight\" and that no further work could proceed until I/O occurred. This might be similar to where the Executor now does a Task.WhenAll(...) call. When the DataLoader(s) receive this \"go ahead\" signal, they batch up all deferred queries into a single batched call and then once this batch call returns, the DataLoaders can demux the batch query back to the original requests for single entities.\nAt this point, the Executor can start to work on the next \"level\".\nI haven't thought too much on the details of this approach, but I think we could make this work if we paired something like a DataLoader factory with a GraphQL execution context and then had the Executor signal the factory (which could know about any created DataLoaders) that would then give each DataLoader the \"go ahead and execute a batch query\" signal. \nOne possible wrinkle with this approach is that if it's combined with the \"only ask the DAO for fields you're actually going to use\" optimization above, you could have a case where the same object is asked for at different levels but for non-overlapping fields and thus you'd have to re-ask the store for the same object.\nWrapping up\nI think that there are still some details to work out, but these optimizations seem like they should work to address the concerns I had. Perhaps there are even simpler ideas that we haven't considered yet?\n. Hi Everyone!\nIt's been 16 months since I last looked at this, but I'm starting to look into it again. A few interesting things have happened related to this issue:\n\n\nOthers have been able to replicate Facebook's DataLoader ideas in .NET. In particular, I'd like to call out @dlukez 's DataLoader implementation where the key idea is to have some sort of context created before your executor.ExecuteAsync call and then you await on the context to flush everything out. The net effect of this approach is very similar to the nextTick approach the JavaScript implementation uses. As a learning exercise and proof of concept, I was able to create a fully featured working DataLoader implementation in about 80 lines of C# code. Note that this pairs very nicely with SQL Server 2016's new STRING_SPLIT function for a single query plan that can be parameterized. Dapper 1.50+ takes advantage of this.\n\n\nOther communities have thought about the JOIN problem as it pertains to SQL. In particular, I want to mention Join Monster which effectively annotates the schema types with enough information to do decent joins. As far as I know, nobody has implemented this idea in .NET yet, but it could be useful for most cases. This would allow simple Dapper calls rather than requiring Entity Framework for reads. As a side benefit to the JOIN improvement, it can work with GraphQL executor to just SELECT/project the fields the GraphQL query requested. Another similar idea to this approach is GraphJoiner\n\n\nLee Byron from Facebook gave a talk at React Europe 2016 about future GraphQL experiments. I think these are very interesting and they give flexibility to optimize for perceived speed by @defering queries that are expensive. I'd love it if we could have some experimental mode of GraphQL.net that allowed us to use this.\n\n\nAdditionally, perhaps GraphQL servers (and implementations like GraphQL.net) might benefit from having the equivalent of a \"Query Planner\" much like modern relational databases have one inside their query processor that comes up with a (hopefully efficient) plan (based off cardinality estimates/statistics) that is used to answer the query for the execution engine. Given \"plugins\" that work with the executor (like Join Monster), perhaps the executor could decide how to best \"resolve\" the query parts/sub-graphs?\nI think that some of these optimizations need to happen for GraphQL to be adopted in large-scale production systems that use SQL as a backend store.\nWhat do other people think? Anyone else (still) interested in this if I looked into it? \nOne outcome is that we could have a standardized DataLoader that's either part of this project or a separate Nuget package (but under this organization). \nAdditionally, we could have another repo/project/Nuget package that's like Join Monster. This would likely require updates to the executor itself such that we could have such plugins.\n. Thanks for the feedback everyone! This issue has been open for awhile now and given the more recent developments I mentioned above, I think it's better to split the discussion up into specific issues that are narrower in scope that can be worked on independently. \nLet's continue the discussion there.. ",
    "SaltyDH": "This is far from a complete solution but I've had an initial go at introducing mutations.\nThere's some hacks with how the Input object coercion works using JSON.NET.\nI\u2019d also add I haven\u2019t spent a great deal of time looking at the GraphQL spec.\nIf anyone\u2019s interested, the fork is here.\nhttps://github.com/SaltyDH/graphql-dotnet\n. @srt0422 Key changes are found in the DocumentExecutor, GraphType, InputObjectGraphType and ResolveFieldContext. The example implementation of a Mutation is found in the StarWarsMutations class in the Test project with (at this stage) a single accompanying test in the StarWarsBasicMutationTests class. I definitely thought about ticking the Mutations box on the roadmap but felt it was a little premature - I haven't validated that mutations produce the correct introspection responses or anything like that.\n@joemcbride Appreciate the feedback on the unit testing side of things. I knew when I pulled in NUnit that I'd need to remove that. Really just a time saver with built in test runner support for NUnit in Resharper. I'll definitely take a look at the conventions more closely so I adhere to that with future tests.\n. ",
    "srt0422": "Thanks for putting out this attempt.  I look forward to trying it out.\nThis would be a comment applicable to all of the forks, but if you could update the readme so that your roadmap represents the state of your fork, that would make it a lot easier to see what's different in each of the forks.\n. I'm having a hard time finding the actual code that implements a mutation.  Could you include something in the readme, so I can know what I'm looking at please?\n. ",
    "Henrik-R": "Hi \nWould you be interested in some help for this issue? \nRegards, Henrik\n. Here is the deal. The company I work for is doing a PoC using graphql-dotnet and we require the validation ASAP.\nThe good news is that we probably are able to contribute but as usual there is company politics / red-tape that needs to be dealt with. My current plan is to get a dev to make a commit of a feature on the checklist for your comments / approval to get the ball rolling if that is OK with you. The dev will if all goes well start on this Monday or Tuesday next week.\nI would like your input on how to organize this? Do we branch of your PR branch? Or? What is an easy feature as the first thing?\n. ",
    "jaymitchell": "I've got the \"Unique variable names\" rule ready to push. How do you decide where it fits in the list of core rules?\n. What a mess. :) Will get you a good pull request.\n. ",
    "mwilliamson-firefly": "We're looking at using GraphQL, and having support for unions would be quite handy. Do you have any idea much work adding support for unions might involve, or whether anybody has already started that work?\n. ",
    "AdamLynamFirefly": "Thanks @joemcbride, it looks pretty likely we will end up needing to implement Unions to properly represent the data we intend to expose via our GraphQL endpoint; as @mwilliamson-firefly mentioned.\nAny direction on where to begin would be extremely valuable. As would a heads up about any \"gotchas\" you anticipate we might encounter along the way.\n. Hi @joemcbride, oh wow, ok. That is awesome.\ngraphql-dotnet is really great work, we appreciate your effort.\n. ",
    "tlil": "I'd be interested in looking into this / contributing to this. Will see if I can set off some time taking a stab at it next week.\n. Just as an FYI, I've got some basic bits up and running for this. Will open a PR at some point, but probably won't be for another couple of weeks due to the holidays.\n. @joemcbride @moserware @zhech2: I have a fully working implementation of this with support for dependency injection. Our fork has diverted a bit from the public one though, so I will copy across the relevant parts and create a PR for it here early next week.\n. @joemcbride Yep, makes sense to me. Most/all of this should pretty much be extensions to the existing library anyway. The current implementation is mostly a wrapper on top, except for a couple of very minor modifications I needed to make in the core library. If you set up a new repo, I can transition it over to there and try to get around those core modifications so that it becomes completely independent. :+1: \n. Ditto.. Conventions could work. Let me have a think about it and get back to you tomorrow. On my way out here atm.\n. @joemcbride Yes, let's go for conventions - I quite like that. I think it makes a lot of sense, and that it is a natural name for utilities and helpers for upholding GraphQL conventions. Seeing it like that, the library could naturally hold the Relay extensions etc. too (instead of maintaining those in the core library). So my suggestion is that we:\n- Set up the repository graphql-dotnet/conventions\n- I can transition over the non-standard GraphQL types that I added to core over to conventions (i.e., the Relay ones, PageInfo, Edge and Connection; and Date)\n- Consequently, ConnectionBuilder and its dependencies would be transitioned across too\n- FieldBuilder can remain in graphql-dotnet\nPS: I might need to implement a couple of minor changes to the main library to enable the type wrappers to live in a separate repository. If so, I'll submit a separate PR for that obviously.\nAny thoughts on the above?\n. Okay, cool. I'm happy with that. I was just thinking if you wanted to keep the core library as closely related to the GraphQL spec as possible. On a side note, completely agree re Date (a bit baffled that it's not in the official spec).\nWill move the Relay types into a separate namespace then for now. GraphQL.Relay sounds good. Hope to update the PR with those changes over the weekend, so please wait with merging that one :)\nThanks for creating the other repo - is it set up with AppVeyor at all?\n. Awesome, thanks! Appreciate it\n. @scmccart Yes, I expect to have a branch out some time over the weekend. Sorry for the delay on this; I've been pretty swamped lately. \n. Absolutely, would be good to touch base on that @zhech2. My week is pretty packed, but we can talk later, either this week, or next..?\n. We have have a fully operative solution for it at the moment that we're using in production. I just need to migrate it across to graphql-dotnet. @zhech2, are you on Slack?\n. Guys, I need a couple of extra days to finish this off, but getting there. Just tidying up a few lose ends, and didn't have as much time this weekend as I first anticipated. Back on it 100% tomorrow though, so will keep you posted. PR #53 is step one and a prerequisite for the graphql-dotnet/conventions implementation.\n. I've pushed the initial version of graphql-dotnet/conventions - i will provide more documentation and examples soon. per now, the tests and example project are the best sources of information.\ncc @zhech2 @SpencerMacKinnon @scmccart @moserware \n. Cool, thanks @joemcbride; makes sense. Still working on a few bits and pieces, but can include those once your changes are in master then. Have also been meaning to adding in some unit tests for this, but haven't had time to do that yet.\n. @joemcbride: How do you feel about merging this with master?\n. Ah, yeah. I forgot to copy those across. Will do that and ping you when they're in :+1:\n. @joemcbride: so I've added some unit tests, but discovered a problem with the current unit testing framework. Currently, there's a stack overflow happening, but the tests here on GitHub reports all is fine. Is this something that you've bumped into previously?\n~~removed stack trace~~ (fixed)\n. Yeah, both fails though. But I seem to have found the issue, so will dig in a bit more. There's a stack overflow happening here (see below) when run through Fixie (both test.ps1 and test-local.ps1):\n~~removed screenshot~~ (fixed)\n. Yeah, it just ignores it as it can't find any test results. Will get the unit tests sorted :) But perhaps worth investigating whether we could make Appveyor raise an error in similar scenarios.\n. Okay, @joemcbride, this should be fixed now by the latest commit\n(https://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/1.0.43/tests).\nI had to update some of the unit tests as they seemed outdated (they were missing descriptions in the expected output for introspection tests, etc.), and fixed a self recursive call-site in the type lookup class (caused by one of my earlier changes).\n. :+1: Sweet, thanks!\n. I've got a few minor improvements to input handling that I will post as a separate PR. That fixes the issue in https://github.com/graphql-dotnet/graphql-dotnet/pull/31#discussion_r46328642 as well.\nUpdate: Have submitted https://github.com/graphql-dotnet/graphql-dotnet/pull/32\n. Hi @joemcbride and @rvlietstra - apologies, this is an artefact from us having combined the GraphType and the data object early on. We've migrated away from that now, but I haven't gotten around to create a PR here to get that into the public repo yet. It was a blunder on my part forgetting to open up for the use of data objects instead. I have started on a branch migrating the version that we're currently using across to the public repo. This will allow you to do what you're trying to do above @rvlietstra. That branch will also include a bunch of unit tests for the FieldBuilder and the ConnectionBuilder. I will have that ready by tomorrow for you. Sorry for the inconvenience. (Will include a basic example in the unit tests, @joemcbride).\n. @joemcbride: I've submitted PR https://github.com/graphql-dotnet/graphql-dotnet/pull/42 for this - @rvlietstra, have a look at the unit tests for examples.\n. Just to confirm, since AppVeyor wasn't reporting unit test failures earlier:\n\n. Yep, that makes more sense. :+1: Good call. I have some more updates (additional helper functions, etc.) that I've added on our end, so can restructure when I'm adding those to this PR. Will do that tomorrow or Friday.\n. See https://github.com/graphql-dotnet/graphql-dotnet/issues/14#issuecomment-169917167:\n\nWould it make sense to transition the non-standard GraphQL types (the Relay ones and DateGraphType over to conventions? I personally think so. That way we can keep the core library as lean and to-spec as possible.\n. Thanks Martin. There are some changes on its way to get around that (I have them working in my private fork). Hope to have that out by early next week. At least the PR :-) Will let you know once it's out.\n\nOn 20 Jan 2016, at 21:35, Martin Damgaard Lorensen notifications@github.com<mailto:notifications@github.com> wrote:\nWe are currently using the hudl:ConnectionBuilderImprovements branch in development and it works fine with only a single issue - a new() contrains on TGraphType in GraphType.Connection().\nThanks for some great work.\n\nReply to this email directly or view it on GitHubhttps://github.com/graphql-dotnet/graphql-dotnet/pull/42#issuecomment-173351542.\n. Superseded by PR #53 - closing.\n. @baluubas also, have a look at: https://github.com/graphql-dotnet/graphql-dotnet/pull/127 :)\n. Works great here as well - will keep testing it and report if I see any issues :+1:\n. Reading my mind :) This will also come through with the refactoring that I'm currently working on. It's on my list to migrate across from what we use internally. Will ping here when available, but quite packed schedule this week and beginning of next, so probably won't get to it until end of next week or so.\n. @MartinLorensen does this branch resolve the issues that you were seeing before?\n. @MartinLorensen yep, was referring to that and the new() constraint that we got fixed earlier :+1: thanks for confirming\n. I think I have this fixed on a higher level in my graphql-dotnet/conventions branch (which will be out in a few days). Would be good to solve it in the engine though. I can incorporate a fix in https://github.com/graphql-dotnet/graphql-dotnet/pull/53 if you want @joemcbride ?\n. Yes, I've seen the same, and have a more general, recursive variant in place locally that I use with the conventions repo that I'll release soon.\n. Good thing - I've completely forgotten about this, sorry. :tada: \n. @JarnoNijboer I aim to get the first release out early next week :) will keep you posted \n. :+1: Will take a look at that @MartinLorensen \n. This should do: https://github.com/graphql-dotnet/graphql-dotnet/pull/61 :)\n. Let me take a look at this early next week @MartinLorensen - I'll be out travelling over the weekend and won't have time before that. Sorry. I'm pretty sure that I've run into the same in the past and that I've resolved it with my local, unpushed changes, but I will have to take a closer look before confirming that.\n. Correct. Aiming for a first release of the conventions project some time this week.\n. @joemcbride @MartinLorensen: Re what I said about first release of conventions: I'm out traveling the next couple of weeks and won't have internet access unfortunately. So won't be able to make the release until I'm back. Sorry about that.\n. :+1: Will do that with my next PR\n. :+1: \n. Thanks for the report - will address this as well in my next PR.\n. @joemcbride Yes, seems like duplicated logic now. I know there were a couple of cases that didn't work earlier (prior to recent work and improvements) where the default values weren't set, hence why I added it back then. Feel free to remove :+1:\n. I seem to remember this being the reason for one of the changes I had in earlier that i later removed as I didn't remember the reason... Duh.. Will try to address this in my next branch as well - I've got some other changes lined up as well, so can deal with this at the same time.\n. Yep, run into the same and was gonna address that. :+1: I think your suggestion would make sense.\n. Sounds good @joemcbride\n. LGTM :+1: \n. Interesting - has this changed in the latest version of GraphiQL? In the past, deprecated fields have been hidden to me in GraphiQL.\n. Yes, seems to have changed in later versions.\n. :+1: Like it - will take a closer look when I'm back from my travels.\n. @cable729 It will have minimal effect on the Conventions library as the graph type construction is abstracted away from the underlying way that the graphql-dotnet library currently constructs types. If anything, it will simplify the library down the line :) I hope to have a preliminary release of Conventions ready early this upcoming week, so will let you know when it's out.\n. @cable729 Thanks for asking - let's touch base when the first release is out and we can talk about next steps. Sound like a plan?\n. The fact that the enum value is encoded as a string in the JSON input is correct. So I'm guessing that it's consequently not interpreted as an enum value following the translation from JSON to input object (which is not touched by the parser) @joemcbride. There doesn't seem to be an existing unit test for that scenario either (i.e. where it's passed in separately through the variables payload).\n. Should be noted that this will also behave differently in the Conventions library, so will ping some details on that when the release is out. Just wanted to throw that in there.\n. LGTM :+1:\nWould it be an idea to have some tests covering input values passed through operation variables as well? To ensure that they get passed through semantically correct I mean. Or did you already get that covered when you fixed that bug the other day (where the type was incorrectly determined since it came thru input variables instead of a parsed token)? \n. Sounds good :+1:\n. Nice \u2013 I like how the validation is coming together\n. @joemcbride, this looks good and in line with what I was envisioning :+1: Thanks for fixing.\n. Does it work if you change $input_0:MyInput! to $input_0:MyInput?\n. Like it \u2013 I was planning on having a stab at this myself after the Conventions work.\n. Nice! \ud83d\udc4d \ud83c\udf89 Excited!\n. > Doing some research last night, this new GraphQL project has its own parser/lexer in C#. I don't know if its fully implemented, though it looks like it may be. Comparable perf to Antlr, even faster. That is running on dotnet core, so perf could be a little different on the full .NET framework. License for that project is MIT, so hopefully he won't mind if we use it.\nDid you try to benchmark that parser explicitly with this use case?\n. @joemcbride \ud83d\udc4d Sounds good \u2013 and performance-wise in those tests you said it was on par / faster than the Antlr, right? That sounds promising.\n. Nice - yep that makes sense :+1:\n. Yay!! That's great!\n. LGTM :+1:\n. FYI: I have already developed a closed-source library for this that we're using in production. I'm currently working to port this over to an open-source repository which will live in graphql-dotnet/conventions. Expecting to have the public repo up some time over the next 7-10 days.\n. @holm0563  FYI\n\nhttps://github.com/graphql-dotnet/conventions is up @drobertson123 @dlukez - i will provide more documentation for it soon. per now, the tests and example project are the best sources of information.\n. It seems to be because you're mixing non-nullable and nullable types. I.e. the argument is of type (nullable) Date, but you're passing in Date!. Could you try changing one of the two so that they are consistent and see if that works?\n. That repo has gone thru some major refactoring that I will push beginning of next week. So I fear that this will clash with my more recent changes. Will ping you once I push my work to Conventions.\n. @holm0563 yes, but haven't pushed any changes yet unfortunately as I wanted to wrap up the refactoring i'm working on (I have a closed-source repo that we've used in production at Hudl for the past 9 months). i will push my changes over the next few days though. the repo will live in graphql-dotnet/conventions.\n. I'm literally just making a last few changes when I'm free over the weekend, and then the full library will be released as open-source. So I'm not too concerned about the timing aspect of it :)\n. I second that @joemcbride. And @holm0563, I agree, I'd love to work together on this one, so don't get me wrong. And it's great to have more contributors as well :+1: I'm out until the weekend, but will touch base when I'm back.\n. @dNetGuru graphql-dotnet/conventions is also coming up shortly. there will essentially be two options there until @holm0563 and I potentially look into consolidating our efforts into one.\n. @drobertson123 I will put up my work on the Conventions library over the next few weeks, so happy to touch base on this once that's out...?\n. https://github.com/graphql-dotnet/conventions is up @drobertson123 @dlukez - i will provide more documentation for it soon. per now, the tests and example project are the best sources of information.\n. @dbettin FYI:\nhttps://github.com/graphql-dotnet/conventions is up @drobertson123 @dlukez - i will provide more documentation for it soon. per now, the tests and example project are the best sources of information.\n. Yep, I have this fixed locally here as well; just haven't gotten around to pushing it yet. Thanks for the reminder :-)\n. LGTM \ud83d\udc4d \n. :+1:\n. @joemcbride Dunno if you want to keep those Console.WriteLine() calls for DEBUG targets. I've commented them out for now.\n. @joemcbride :+1: cool, thanks!\n. Ah, yeah, that might well be! I'll create a PR for that as well. @lcola you haven't provided any arguments to your field definition:\n\ndiff\n Field<ListGraphType<RuoliType>>()\n     .Name(\"ruoli\")\n+    .Argument<NonNullGraphType<IntGraphType>>(\"id\", \"<Description goes here>\")\n     .Resolve(ctx =>. What does the inner exception on that error say?. @lcola Glad you found the problem. \ud83d\udc4d \n@joemcbride Yep, in the Conventions library I'm actually untwining the exceptions to elevate the details of the inner exception (in most cases). We experienced similar difficulties in the past when trying to troubleshoot based on logs and stacktraces in prod without the full dump of inner exceptions. A similar approach might be worth considering in the engine?. @fbrier are you using Conventions? Or vanilla graphql-dotnet?\nThe latest version of Conventions should untwine the exception and show a more helpful message, but not necessarily the full stack trace. I haven't added the debug mode yet... But that's something I could do for the next update.. Have you had a look at the Conventions library (which builds on top of graphql-dotnet)? There's an example here.. @ronnyek i don't follow i'm afraid. so, with the Conventions library your object doesn't need to inherit from ObjectGraphType, you could implement something like this for example:\n```cs\nclass Query\n{\n       public Droid GetDroid(string id) => _myRepository.GetDroidById(id);\n}\nclass Droid // existing DTO\n{\n    public string Id { get; set; }\npublic string Name { get; set; }\n\n// ...\n}\nvar engine = new GraphQLEngine();\nengine.BuildSchema(typeof(SchemaDefinition));\n```\nIs that what you're trying to do?\nAnd if you wanted to modify any of your repo objects with attributes you can do that too:\n```cs\n[Name(\"Droid\")]\n[Description(\"Some description\")]\nclass DroidDto // existing DTO\n{\n    public string Id { get; set; }\n[Description(\"The name of the droid.\")]\npublic string Name { get; set; }\n\n[Ignore]\npublic double SomeInternalProperty { get; set; }\n\n// ...\n}\n```\nSorry if it's not very clear. I've been meaning to throw together some documentation for that library. Hope that helps though.. You need to pass in the variables separately through x.Inputs, see:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/8b581f9607491d4c11b978eeddffbc1c4d9149f0/docs/getting-started.md#variables. @joemcbride Sounds good to me. Might be a good idea to add a unit test to ensure that aliases aren't affected by IFieldNameConverter's?. > Looking at large APIs i'd like to build with graphql-dotnet, i'm not too pleased by having to write all that code by hand.\nThat's been the motivation behind graphql-dotnet/conventions. Although it doesn't allow you to map a plain text schema file in like you describe, it allows you to express your schema more succinctly.\nUsing the GraphQL schema files like you describe is nice too though :) Dunno if @joemcbride has any plans in mind re that, but I have definitely been thinking about it. Not started anything yet though.. Makes perfect sense to me @joemcbride \ud83d\udc4d  No objections from my end. This is starting to look good @joemcbride - will take a closer look over the weekend!. @joemcbride  Hmm, these look like the changes I have in the conventions-adjustments branch \u2013 some of which are temporary, etc. I've been meaning to raise a PR with some of them at some point, but not had time yet. So totally disregard this for now.\nLooks like @QuantumDecay has just accidentally pushed these branches to the wrong remote...?. > I want to make a few tweaks to the parser project before officially releasing it. I'll do that today.\n@joemcbride did you make any progress on that?. @joemcbride - FYI, will be raising a few PRs over the next few days to support the work in https://github.com/graphql-dotnet/conventions/pull/82.. Another PR for the engine decoupling (https://github.com/graphql-dotnet/conventions/pull/82). Sure thing \u2013 can do that.. Okay so you're happy with me breaking the backwards compatibility for that then? If so, happy to make that change as well, yeah.. PR CI seems to be intermittently failing btw:\n\nTotal tests: 676. Passed: 671. Failed: 0. Skipped: 5.\nTest Run Successful.\nTest execution time: 7.5126 Seconds\nerror An unexpected error occurred: \"Command failed.\nExit code: 1\nCommand: C:\\windows\\system32\\cmd.exe\nArguments: /d /s /c set CONFIGURATION=Release&& yarn&& babel-node tools/build.js ci\nDirectory: C:\\projects\\graphql-dotnet\nOutput:\n\".\ninfo If you think this is a bug, please open a bug report with the information >provided in \"C:\\projects\\graphql-dotnet\\yarn-error.log\".\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n\nAll the other builds seem fine though. Fixed it earlier by re-pushing a commit.. Sure thing - will take a look at those. At first glance they both make sense. :+1:\nUpdate: Fixed the first item. See comment above for the second.. Yep, agree. Thinking about this now, I'd rather extract the whole ISchema bit out of the basic library and into my own project. :+1: \n. Agree. Sorry, I've already got this part sorted in my local branch. We're using this in our own code base, and was a quickfix I had to put in place recently that I've later refactored. Will get my most recent changes in here (hopefully tomorrow), and make sure to include that one.\nUpdate: And 'yay' to unit tests.\n. :+1:\n. Good spot; will fix that.\n. Forcing enumeration here as this bit was causing some trouble further down the stack in some cases (can't remember the exact steps to reproduce right now, but can try to find those if you want me to).\n. This is just a mechanism that allows us to use interfaces, but at the same time allows for the user to request all fields on the resulting object without having to know which ones exist in the resolved implementation (so including fields that are not defined through the interface itself).\nExample:\nISomeInterface : { FieldA, FieldB }\nFoo implements ISomeInterface : { FieldA, FieldB, FieldC }\nBar implements ISomeInterface : { FieldA, FieldB, FieldD, FieldE }\nFor any field of type ISomeInterface with IReturnsAllFields, we essentially want to project FieldA, FieldB, FieldC, FieldD, FieldE (without specifying them in case they don't exist).\nThinking of it now, perhaps it's cleaner and better to just force the user to specify all \"possibly\" projections, instead of this \"wildcard\". So considering to change this. Any thoughts?\n. Yes, on second thought that was exactly what I realised too. So I went ahead and removed it.\n. Upgraded from 1.0.0.29 to 1.0.0.33. This is not strictly needed, but thought it was worth being on par with the latest version of Fixie.\n. These unit tests seem outdated. So I went ahead and added missing descriptions for introspection tests.\n. These variable tests also seem outdated, so went ahead and updated them. Please verify that this is the expected behaviour.\n. Ah, okay. Let me know. If my changes has modified the expected behaviour here, I can fix that.\n. :+1: will fix\n. Yep, agree. Just most times, the name was null when I tested it, so didn't provide context. Will re-add.\n. Indeed, will sort that. Thnx\n. Kk, will sort.\n. Can't remember exactly - there was some reason, but it might have been an artefact from something else. Will dig into it.\nI'm happy to sync these two up. I can do that as part of this PR if you want. Any reason why you kept them separate in the first place?\nUpdate: Have made the necessary changes locally, and sorted the inconsistencies in the unit tests above. ~~Will push in a few.~~ (pushed)\n. Any reason why you were using the alpha version here in the first place @joemcbride? It seems to be running fine with the stable version on my end.\n. nonNullType.Name was consistently null, and was referring to the type name rather than the field name anyway. So think this makes more sense, at least from the testing that I've gone through.\n. Coerce first to expand variables, then validate.\n. Okay, makes sense. We don't do il-merge in our build chain, hence why I ran into this. But can change that. Will remove this from the PR.\n. Actually, I moved this out already (and into the input processor), so this is not needed. Will remove.\n. Hmm, truth. Will give this some more thought. Thanks for pointing that out.\n. Actually, looking at the applicable call sites, it seems like this will indeed work. See GraphQL/Execution/DocumentExecuter.cs#L131) and all calls to CompleteValue.  Travelling atm, but will set up some unit tests for this later and verify. \n. Nope, will change it.\n. Gotcha, will change that back\n. Sorry, forgot to take this out. You're absolutely right. Removing.\n. This test would still pass without skip => null being passed in here, yeah?\n. Yep lgtm :+1: Thnx @jquense \n. @joemcbride Yes, can do \u2013 reuse the logic here to report the task.Exception then you mean?. Confirmed working - will update.. This is for the enum value, not the type. Essentially, if you have a resolver: foo(arg: SomeEnum = X), it ensures that X is printed as the name of the enum value, i.e., the serialised form of value X in type SomeEnum.\nIn other words: If SomeEnum is defined for values FooEnum.Foo with name = FOO and FooEum.Bar with name BAR (using FooEnum here just to make it clear that the underlying linked value of an enum doesn't necessarily have to match with the GraphQL enum type (name of type and values)), this would print FOO instead of Foo if the value X was FooEnum.Foo. Make sense?. ",
    "SpencerMacKinnon": "I'd be interested in participating in this conversation as well, I've been working on something to map types to GraphQL type definitions. I'm on the GraphQL dotnet channel as smackin.\n. ",
    "jusefb": "Does anyone have any more examples as it is currently difficult to understand how to migrate from the classic graphql-dotnet to conventions based graphql-dotnet.. thanks\n. Can anyone help to understand how to use GraphiQL with graphql-dotnet?. @arunprasathv I am getting the same issue could you explain what you mean by \"I made it working by passing array\"?. ",
    "ethanli83": "Hi @moserware & @plecong ,\nI uploaded a small project on github to demonstrate an idea on how to solve the 'N+1  Select' problem. I know it has been awhile since you guys discussed the issue, so hope it is still relevant.\nHere is the link:\nhttps://github.com/ethanli83/ResolveGraphQL\nI will be updating it with more comments and explanations on how it works, but I think you guys may be able to figure it out since the code is not that complicated. \n. ",
    "randyridge": "Out of curiosity has anyone played with integrating  haxlsharp?  I thought it might be a worthwhile experiment for this problem (of which I'll ne d a solution for soon). I'll take a look at this one as well. :D\n. about to get back to some graphql experimentation, looking forward to trying out what you came up with in your dataloader tomorrow.  initial feedback based on glancing at it is to parameterize your key, int's won't work for me :)\n. fyi, i straight-ported the reference graphql-js lexer to .net 4.5 and netstandard 1.3 and it appears to be 7x faster something like 10us vs 77us than the dotnetcore one, not sure how much overall benefit that would give and i haven't diffed the performance between the two, maybe i'll get to it this weekend\n. i believe i have all of the reference lexer tests working minus the syntax error ones, but those aren't critical path and i should get them wrapped up soon.\non my machine with 1MM of your showdown tests in release mode:\ncore_builder: (1000000) GraphQLDocumentBuilder Time elapsed: 00:00:34.9865384\nnew_lexer: (1000000) GraphQLDocumentBuilder2 Time elapsed: 00:00:10.3672227\nI think I have a bit more room for perf enhancements.  I'll try to get a repo with it before the weekend is out, but we'll see...\nalso I suggest taking a look at BenchmarkDotNet for these types of things\n. I'll be following up with another pull request to remove await in a number of places, where the state machine is not needed.\nAnd also installing AsyncFixer.\n. It shouldn't be necessary to list each framework and net standard, just go with the lowest common denominator. Same applies for the parser project, it's netstandard is much too high and has like 87 framework versions :D\n. Yeah, I believe that's the case, would need to doublecheck with the portability analyzer. Keep the library reference at 1.6, but declare the framework to the lowest.\n. Yep, that's absolutely the issue, the hosted graphiql.min.js is dep on graphql 0.7.0, which I guess you don't have compatibility with yet.  I'm marginally annoyed they're a little loose on semver, but I guess their argument is leading zero... yolo.\n. i just set them up to do some quick prototyping.  I think they'd work fine as nuget packages to get folks up and running quickly and for examples.\n. i'm going to get these up-to-date with tests next week.\n. The middleware should depend on iserviceprovider, I believe is the correct\ntype, then you could inject what you want, I just didn't get to it yet\nOn Friday, October 7, 2016, Joe McBride notifications@github.com wrote:\n\nIndeed I think that would be a good feature to have. I haven't quite\nfigured out how we want to go about it yet since that code will be .NET\nCore specific. Just as another DLL in the netstandard folder of the nuget\nsounds the easiest. I'm hoping the dotnet packager supports that.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/190#issuecomment-252337076,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAdDnR6owneWDPWZU_RhB1KYpOAA7Lqeks5qxpmVgaJpZM4KRC6H\n.\n\n\nRandy Ridge\n. Cd\nLlogj. looks like it, i'll hopefully get back to graphql stuff next week\n. ",
    "dlukez": "Had a look at HaxlSharp, but it seemed like a bit of work to get integrated. Here's another way of solving the N+1 problem:\nhttps://github.com/dlukez/graphql-dotnet-dataloader/\n. I actually created a fresh repository for the DataLoader port a little while back - it's at https://github.com/dlukez/dataloader-dotnet. Most of what little code I originally wrote wasn't specific to this library, so I wanted to open it up in case there were other potential uses for it / for a bit of a challenge.\nThat said, it would be pretty painless to do a version that's integrated in as part of this library.. Here's something I've been working on for creating a schema from a POCO model using attributes:\nhttps://github.com/dlukez/graphql-dotnet-annotations/\n. Here's something I've been working on:\nhttps://github.com/dlukez/graphql-dotnet-annotations/\nThe more the merrier I suppose...\nEdit: wrong thread, not sure if this is relevant here\n. > I'd lean towards this approach since our GraphQL implementation is already very similar to Facebook's JS implementation so it'd be very familiar to those coming from Node or other implementations\nThis makes sense, provided we can port the features in a straight-forward manner.\nMy experience so far is that the core concept doesn't translate easily across to the .NET environment and requires additional work or an alternative approach (e.g. triggering the loaders :smile:).\nWhile familiarity for those coming from other platforms would be great, if our implementation must differ in order to properly fit the .NET infrastructure then this should be reflected in the API, lest we end up trying to fit square pegs into round holes (or something like that...). It should also align with the expectations of .NET developers and any related standards/best practices.\nAs long as the core API is familiar enough that those migrating from another platform can pick it up easily, then beyond that I think we can be flexible in how we implement the rest.\nSo basically yeah, keep it the same where possible and adapt where required.\n\nShould this DataLoader be part of core or a separate repo/NuGet package?\n\nI think for now separate is better. Helps keep the code modular and promote use outside of GraphQL.\nPotentially we could publish an integration package (GraphQL.DataLoader), however integrating the two is already pretty easy... I'm just working out the kinks in the sample app that shows ways of doing so which I'll hopefully have done tonight.\nFYI I already have a NuGet package released under the name \"DataLoader\" (versions are 0.1.0 and 0.1.1). I'm using it successfully at work but it'd be good to get some others to play with it, no doubt there'll be some issues to be discovered/sorted out.. Sorry guys I haven\u2019t had much time to keep my original dataloader up to\nspeed or participate in discussions or the like. I now have more free time\non my hands though which I\u2019ve set aside to get up to across what\u2019s changed\nand to fix any issues in my original repository. Those things\nnotwithstanding, I\u2019m also happy to have it merged into the main graphql\ncodebase or at least have the my project moved across into the\ngraphql-dotnet organist.\nAlso there are some changes that I need to push that will hopefully help\nthe handling of multiple levels and cleanup the code and clarify usage a\nbit better.\nI\u2019ve kind of jumped onto this reply without much context so forgive me if\nhasn\u2019t been relevant - I\u2019ll be catching up on things today and answering\nany issues/questions so feel free to ping me.\nCheers!\nOn Fri, 26 Jan 2018 at 9:01 am, Doug Robertson notifications@github.com\nwrote:\n\nJust my 2 cents, but I would prefer this to be part of the main project.\nWe are already seeing instances of outside projects getting out of sync and\nunusable.\nIf this is integrated into the main project then it is naturally part of\nthe upgrade cycle.\nThis doesn't feel like an 'optional' way of doing something or even added\nfunctionality. These feel like a significant improvement to the way the\nsystem would get data.\nIs there a use case for not using this? If so I would be more open to a\nseparate project.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/264#issuecomment-360615077,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABpTqQj0sZ6z3qoI_asPS11NTLF3arMXks5tOPm5gaJpZM4LtwdP\n.\n-- \nDaniel Zimmermann\nWeb Designer/Developer\ndaniel.luke.zimmermann@gmail.com\n. \n",
    "xrob": "Just popping my head around the corner to point out that many SQL implementations have already come up with solutions to the N+1 problem. MS SQL Server has XML serialization (2016 has JSON serialization too). Postgresql will output to JSON too.\nI guess my point is that instead of trying to solve this problem in graphql-dotnet we should just provide the user with an immediately obvious point at which to take the query tree containing all of the fields to select and let them come up with their own way of creating a good SQL query?\nI've just had a brief look around the code but I'm guessing DocumentExecutor.ExecuteFieldsAsync would be the best place to do this?. Might want to take a look at Join Monster: http://join-monster.readthedocs.io/en/latest/ \nI seem to have finally stumbled across what I was looking for. Might save a fair bit of work.. ",
    "drjokepu": "Yes, the following works with Relay:\nC#\nvar result = executer.ExecuteAsync(schema, null, request.Query, null, null).Result;\nvar resultJson = writer.Write(result);\nvar response = Newtonsoft.Json.Linq.JObject.Parse(resultJson);\nresponse.Remove(\"errors\");\nvar responseJson = response.ToString();\n. The following does not appear to work with the latest version of Relay:\nC#\nvar result = executer.ExecuteAsync(schema, null, request.Query, null, null).Result;\nif (!result.Errors.Any())\n{\n    result.Errors = null;\n}\nvar resultJson = writer.Write(result);\nIt fails with the following error:\n\nCannot read property 'map' of null\nRelayPendingQueryTracker.js:162\n\nA combination of assigning null to it if it's empty and an attribute such as [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] on the ExecutionResult.Errors property should take care of the situation.\n. ",
    "tlogik": "The current ANTLR 4 installed required JAVA to work.\nInstalling JAVA allowed the ANTLR parser to work.\n. So there definitely is an issue here,\nI am pretty sure that ANTLR has a issue parsing strings containing a datetime.\nBelow is the flow\nThe query setup\n```\n public ArticleSearchQuery()\n        {\n            Name = \"Query\";\n        Field<ListGraphType<ArticleType>>(\"articles\",\n            arguments: new QueryArguments(\n                new[]\n                {\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\n                    {\n                        Name = \"iql\",\n                        Description = \"The Iql Query\",\n                        DefaultValue = string.Empty\n                    },\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\n                    {\n                        Name = \"startIndex\",\n                        Description = \"The Index to start paging from\",\n                        DefaultValue = 0\n                    },\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\n                    {\n                        Name = \"pageSize\",\n                        Description = \"The size of the page you want to received\",\n                        DefaultValue = \"10\"\n                    },\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\n                    {\n                        Name = \"searchFrom\",\n                        Description = \"The datetime to search from. Format\",\n                        DefaultValue = \"searchFrom_FOO\"//DateTime.Now.AddDays(-14).ToString(CultureInfo.InvariantCulture)\n                    },\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\n                    {\n                        Name = \"searchTo\",\n                        Description = \"The Index to start paging from\",\n                        DefaultValue = \"searchTo_BAR\"//DateTime.Now.ToString(CultureInfo.InvariantCulture)\n                    }\n                }),\n            resolve:\n                context =>\n                    Search((string) context.Arguments[\"iql\"], int.Parse((string) context.Arguments[\"startIndex\"]),\n                        int.Parse((string) context.Arguments[\"pageSize\"]),\n                        (string) context.Arguments[\"searchFrom\"],\n                        (string) context.Arguments[\"searchTo\"], context));\n    }\n\n```\nMark the rather NOT datetime defaults on the searchFrom and searchTo. Those are there to easily see that the default value is emitted rather than the passed argument.\nThe sent request from fiddler/swagger\n{\n  \"Query\": \"{articles(iql:hund, startIndex:0, pageSize:12, searchFrom:'2015-04-05T23:52:05.568Z', searchTo:'2015-05-05T23:52:05.568Z'{\nsource\nheading\nsubHeading\nparagraph\ncaptions\nwordCount\n}}\"\n}\nHere is what is recieved for processing in the code\n{articles(iql:hund, startIndex:0, pageSize:12, searchFrom:'2015-04-05T23:52:05.568Z', searchTo:'2015-05-05T23:52:05.568Z'{\nsource\nheading\nsubHeading\nparagraph\ncaptions\nwordCount\n}}\nThe request sent and what is received match up perfectly. Especially the datetime entries are unprocessed and handed as simple strings.\n_Here is what is emitted by the context.Arguments_ for the datetime fields after GraphQL processing/Parsing\n{[searchFrom, 2015]}\n{[searchTo, searchTo_BAR]}\nso it seems that the parser strips everything from the first - dash in searchFrom so that i only get 2015 and then searchTo will emit its default value.\nI am merely guessing here but From my days in ANTLR this seems to be a tokenizer issue. Could relate to the DSL definition not taking into account that an input could contain \u00b4- dash\u00b4 and possible later on also :. \nI suppose creating a custom datetime scalar will not change this parser issue.\nI have not tried to modify the DSL. Mostly because i have not read the GraphQL  spec fully so me editing the DSL will most definitely not be prudent at this time :-)\n. > I'm not sure if it is an issue with your application or something else, though the examples you gave are not valid requests. The hund value for iql needs to be surrounded with quotes. You are also missing an ending ) in the argument list.\nCorrect. There was a missing ), but that was part of a copy past issue. Sorry about that. The actual query sent had the paranthesis.\nThe code is a basic ripoff of you starwars example, yet much simpler. And the request is handled just fine, except when an argument contains a - dash\nIf you look at the ex below:\n{\n  \"Query\": \"{articles(iql:hund, startIndex:0, pageSize:5){\nheading\n}\"\n}\nyou can see that the full value of Query is embedded in \" \" thus represents a full string.\nAll the parameters are parsed correct except when there is a - dash in the input argument.\nJust to show that there is an issue with the dash i have done this:\n{\n  \"Query\": \"{articles(iql:hu-nd, startIndex:0, pageSize:5{\nheading\n}\"\n}\nand then the argument for iql after parsing is hu\nSo the parser is stripping the value after the -\nRunning the above query without a - dash everything works fine.\nI am running the version of tag 0.3.0.0 representing the latest deployed nugetpackage.\n. > Since you are setting the startIndex as a StringGraphType the DefaultValue should also be a string value. You have given it a DefaultValue of 0 which is an integer.\nThanks. Had spotted that one, and it was fixed.\n\nHere is the JSON representation of the query which is expected in the sample project:\n\nThat indeed fixed it. It assumed that wrapping everything as a string was valid. The framework will actually parse the query it correctly (when no - is present).\nThanks for your support.\nIll give the DateTime scalar type a try later on.\n. I'm pretty busy at work and such but I'll slowly start adding to the wiki. Expect a couple of weeks before completion. Hopefully sooner but time has a tendency to fly fast\ud83d\ude0f\n. Yes. Spot on\ud83d\udc4d\nThanks. \n. ",
    "tomasaschan": "Hm. You mean something like\npublic class StarWarsSchema : Schema\n{\n    public StarWarsSchema(IContainer container) {\n        ResolveType = type => container.Resolve(type);\n    }\n}\nand then injecting also the schema into wherever I need it? This would mean I have to register the container with itself, which seems a little smelly, but way better than not being able to do anything like this at all :)\n. Well, there's a number of reasons I don't want to use a service locator - this is a good read on the topic, but you might want to start here.\nIt would probably be possible to use a factory pattern, or - better yet - to utilize System.Func as a parameter, but I'd have to think on it for a while to come up with something that might actually work.\n. Yeah, that would probably be a good solution - that would let any DI container do the job, even if they don't support property injection. (Some DI containers can even auto-register Funcs that act as factories for registered types, making that even more attractive...)\n. That sounds like a good plan!\nIt might also be worthwhile to extract some interfaces on the schema types, to make container registration easier.\n. ",
    "ManishTrivedi": "@joemcbride  I am fairly new to GraphQL. As per my understanding, there should be only one query class and one schema class. So, if I get data from multiple classes, like StarWarsData, how will I initialize it in the StarWarsQuery class. Number of parameters in the StarWarsQuery class will keep on increasing right? I might be completely wrong. \nOr can we have multiple controllers, queries and schemas?\n. @joemcbride It would be great if you can share your thoughts on these issues:\n1. We register all the types and queries in the GraphQL controller constructor. What if I have 100 types in my system. Will I be registering all in this controller or can I have multiple controllers?\n2. Should I be using Factory method pattern to decide which schema should be used based on the metadata.\n3. Can you please elaborate on what do you mean by top level object in the above comment. If I have StarWarsData.cs and many other data classes, my StarWarsQuery constructor would look like this StarWarsQuery(StarWarsData data, .............. ). I am confused about the dependency injection in the Query class.\nPlease help!\n. @joemcbride I was going through the Document executor class to understand how context is built. I noticed that both source and RootValue property are set to context.RootValue in the ResolveField method. The source in this method is nothing but context.RootValue passed from the calling method. Is there a specific reason to do so? Also, what is the difference between the two?\nIf I want to pass the headers from the request to my backend logic, how should I proceed in doing so. I populated the headers in rootObject. Is this the correct way?\nThank you for your help.\n. Thank you for your response. Makes me understand GraphQL better.\nFor a dictionary, I can resolve the field using the context.Source property. \nField<NonNullGraphType<StringGraphType>>(\n                \"Keyname\",\n                \"this is the key\",\n                null,\n                resolve: context =>\n                {\n                    var x = context.Source as IDictionary<string, string>;\n                   // return the value corresponding to the key\n                });\nBut I should not be knowing the key of the dictionary in advance. Is there a way to return the dictionary in a generic manner?\nOne thing I have noticed that the HumanType and DroidType need to have all the fields that are present in the CharacterInterface. Is there a better way to do this? Not duplicate fields present in the interface.\n. I have a 'ImageType' which has a field 'Version'. This 'Version' field is a dictionary of  which contains a key value pair of different versions of an image. My GraphQL query returns this ImageType. Hence, I need to return this dictionary as part of the request. I have a DictionaryGraphType which inherits the ObjectGraphType. As of now, I am trying to figure out how to resolve the key and value for any dictionary of type , so that I can return it in the GraphQL query.\nHence, in my ImageType, I have a field\nField< DictionaryGraphType >(\"version\",\"the dictionary of image versions\");\nIn the DictionaryGraphType, I need to resolve the key and values such that the front end show\nverison\n[\n\"version1\":\"www.xyz.com/folderpath/version1.jpg\",\n\"version2\":\"www.xyz.com/folderpath/version2.jpg\"\n]\nwhere version1, version2 etc are the keys\n. @vinayakbhadage Can you please let me know how are you resolving the UserInputType. \nI am assuming you will have a method somewhere that takes in the profileImage and gender as its parameters. How do you get the values from the UserInputType to pass it to this method?\nIs that logic in the CreateUser method? \nI am getting the values in resolve from the arguments dictionary as follows\n`public class MutationRoot: ObjectGraphType\n    {\n```\n    public MutationRoot() {\n        Name = \"MutationRoot\";\n        Description = \"GraphQL MutationRoot for supporting create, update, delete or peroform custom actions\";\n    Field<UserType>(\"createUser\", \"create user api\",\n        arguments: new QueryArguments(\n         new QueryArgument[]{\n                new QueryArgument<NonNullGraphType<UserInputType>> { Name = \"userInput\", Description = \"user info details\"}\n        }\n    ),\n    resolve: context=> \n          {\n                var dictionary = context.Arguments[\"UserInput\"] as Dictionary<string, object>;\n                string profileImage = dictionary[\"profileImage\"];\n                CreateUser(profileImage);\n          }\n );\n}\n\n}`\n```\nIs this the correct implementation?\nPlease help.\nThank you!\n. ",
    "sammosampson": "Yay!\nOn Sat, Dec 12, 2015 at 12:48 AM, Joe McBride notifications@github.com\nwrote:\n\nToday!\nhttps://github.com/graphql-dotnet/graphql-dotnet/releases/tag/v0.4.0\nhttps://www.nuget.org/packages/GraphQL/0.4.0\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/34#issuecomment-164090673\n.\n. My mistake got the \"App\" type wrong it should have been \"AppType\" apologies\n. I am not using a controller, I am reading the request (directly) to string\nand passing that to the graphql executor\n\nOn Tue, Dec 22, 2015 at 11:30 AM, nmaait notifications@github.com wrote:\n\nI'm using relay without any issues. What is the object you are passing to\nyour controller? Have you tried annotating the properties?\nMine looks like\n[DataContract]public class GraphQLQuery\n{\n    [DataContract(Name=\"query\")]\n    public string Query { get; set; }\n    [DataContract(Name=\"variables\")]\n    public Dictionary Variables { get; set; }\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/38#issuecomment-166589585\n.\n. Thanks again jo\n\nOn Tue, Dec 22, 2015 at 4:08 PM, Joe McBride notifications@github.com\nwrote:\n\nThe following should work for you:\npublic class GraphQLQuery\n{\n    public string Query { get; set; }\n    public Dictionary Variables { get; set; }\n}\nvar request =\n    \"{\\\"query\\\":\\\"query RouteQuery { viewer { routes{ createdOn, machine } } }\\\",\\\"variables\\\":{\\\"one\\\":\\\"two\\\"}}\";\nvar query = JsonConvert.DeserializeObject(request);\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/38#issuecomment-166661419\n.\n. \n",
    "nmaait": "I'm using relay without any issues. What is the object you are passing to your controller? Have you tried annotating the properties? \nMine looks like\nc#\n[DataContract]\npublic class GraphQLQuery \n{\n    [DataContract(Name=\"query\")]\n    public string Query { get; set; }\n    [DataContract(Name=\"variables\")]\n    public Dictionary<string,string> Variables { get; set; }\n}\n. For ease of use I changed the Variable property to a Dictionary and let my JSON serializer parse the variables string.\n[DataContract]\npublic class GraphQLQuery\n{\n    [DataMember(Name = \"query\")]\n    public string Query { get; set; }\n    [DataMember(Name = \"variables\")]\n    public Dictionary<string, object> Variables { get; set; }\n}\nThen Inputs can take Variables in its constructor.\npublic async Task<IHttpActionResult> Query(GraphQlQuery query)\n    {\n        var input = query.Variables != null ? new Inputs(query.Variables) : null;\n        var responseModel = await Execute(new MediaSchema(), null, query.Query, inputs: input);\n        return Ok(responseModel);\n    }\n. ",
    "mattferrin": "We should copy paste someone's Relay compatible MVC and/or Web API code into the readme at some point. My MVC isn't working because I assumed arguments would be embedded in my mutation query. I'm still not sure how to pass a relay mutation to the async executer.\n. (I do see that the Inputs parameter inherits from Dictionary now.) I'm going to assume \"Inputs\" and \"Arguments\" are synonymous and move ahead.\n. I really do appreciate the awesome help. Your simple container gave me pause yesterday evening, but your code looks really great. Thanks. (Beginning again now.)\n. I am having a little trouble with this because Relay does not send \"variables\" as a string, but as JSON without double quotes around it. My \"Variables\" property is always null no matter what I do. (Edit: I'll follow the original advice given in this thread and stringify the entire request.)\n. Thought I'd share the hack solution that got things working for me in case it helps someone else maybe:\n``` csharp\n[HttpPost]\npublic async Task PostGraph(string request)\n{\n   Func getRequest = () =>\n   {\n       Request.InputStream.Position = 0;\n       using (Stream receiveStream = Request.InputStream)\n       {\n           using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))\n           {\n               return readStream.ReadToEnd();\n           }\n       }\n   };\n   request = getRequest();\nIDictionary nestedKeysValues = JsonConvert.DeserializeObject>(request, new JsonConverter[] { new NestedKeysValues() });\n   Inputs inputs = new Inputs((Dictionary)nestedKeysValues[\"variables\"]);\n   string query = (string)nestedKeysValues[\"query\"];\nIDocumentExecuter executer = new DocumentExecuter();\n   DocumentWriter writer = new DocumentWriter();\nISimpleContainer container = new SimpleContainer();\n   container.Register();\n   container.Register();\n   container.Register();\ncontainer.Singleton(() => new GraphSchema());\nFunc getOperationName = () =>\n   {\n       if (query.StartsWith(\"query\"))\n       {\n           return \"GraphQ\";\n       }\n       else\n       {\n           return \"GraphM\";\n       }\n   };\n   string operationName = getOperationName();\n   ISchema graphSchema = container.Get();\n   var result = await executer.ExecuteAsync(graphSchema, null, query, operationName, inputs);\n   return writer.Write(result);\n}\n```\nSee http://stackoverflow.com/questions/6416017/json-net-deserializing-nested-dictionaries/6417753 for dictionary parsing details.\nSee https://github.com/graphql-dotnet/graphql-dotnet/blob/622cb5c685cd0c20f2853048491a8eb2b4c51f3f/src/GraphQL.Tests/SimpleContainer.cs for the simple container.\n. Thank you. I considered doing that and should have. Instead I searched the internet looking for query examples like a dummy :) Is that proper syntax GraphQL spec?\n. Beautiful. My code works.\nThanks for the great library. I really like it thus far.\n. (It's proper spec. Cool.)\n. I've looked through the Github source and saw that... but all I am dealing with is a list of strings, even removed the dashes to see if it would help.\nNo custom scalars.\nThe field in question:\nField<ListGraphType<InspectionType>>(\n    \"inspectionReportInspections\",\n    arguments: new QueryArguments(new QueryArgument[] {\n        new QueryArgument<ListGraphType<StringGraphType>> {\n            Name = \"inspectionIds\"\n        }\n    }),\n    resolve: context =>\n    {\n        // I have more code here, but it's not relevant.\n    }\n);. Schema Generator (not so relevant):\n<package id=\"GraphQL\" version=\"0.17.1\" targetFramework=\"net45\" />\n  <package id=\"GraphQL-Parser\" version=\"2.0.0\" targetFramework=\"net45\" />\nQuery Endpoint (relevant):\n<package id=\"GraphQL\" version=\"0.17.1\" targetFramework=\"net45\" />\n  <package id=\"GraphQL-Parser\" version=\"2.0.0\" targetFramework=\"net45\" />. I think it is an issue a bit related to Relay Modern fragment generation. Queried the field with Relay Classic before. \nCloned the dependencies. Am going to try to debug, if stepping into dependencies is possible in C# like this. Slightly more of a JavaScript guru. Thanks for taking a look at this.. I don't understand why this is the case this one particular time, but...\nAdding a serialized.GetValue() clause to graphql-dotnet\\src\\GraphQL\\GraphQLExtensions.cs works:\n```\n            if (serialized is string)\n            {\n                if (type is EnumerationGraphType)\n                {\n                    return new EnumValue(serialized.ToString());\n                }\n            return new StringValue(serialized.ToString());\n        }\n\n        if (serialized.GetValue() is string)\n        {\n            if (type is EnumerationGraphType)\n            {\n                return new EnumValue(serialized.GetValue().ToString());\n            }\n\n            return new StringValue(serialized.GetValue().ToString());\n        }\n\n        throw new ExecutionError($\"Cannot convert value to AST: {serialized}\");\n\n```. First thing my MVC Controller Action does regarding inputs:\n```cs\n            Func getRequest = () =>\n            {\n                Request.InputStream.Position = 0;\n                using (Stream receiveStream = Request.InputStream)\n                {\n                    using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))\n                    {\n                        return readStream.ReadToEnd();\n                    }\n                }\n            };\n            request = getRequest();\n        IDictionary<string, object> nestedKeysValues = JsonConvert.DeserializeObject<IDictionary<string, object>>(request, new JsonConverter[] { new NestedKeysValues() });\n        Inputs inputs = new Func<Inputs>(() =>\n        {\n            if (nestedKeysValues.ContainsKey(\"variables\") && nestedKeysValues[\"variables\"] != null)\n            {\n                return new Inputs((Dictionary<string, object>)nestedKeysValues[\"variables\"]);\n            }\n            else\n            {\n                return new Inputs(new Dictionary<string,object>());\n            }\n        })();\n\n. My object appears to be another object that is a string, but I will update this comment if I am wrong.. I'm honestly confused because the dictionary I pass to inputs looks great when I inspect it and I parse a lot of other input variables that are also arrays of strings just fine, but I'll try anything. Don't mind changing my code to match the example as much as possible. Thanks for the help and we'll see if it works.. Your deserialization technique works perfectly and resolves my issue. Thank you.cs\npublic class GraphQLRequest\n{\n    public string OperationName { get; set; }\n    public string Query { get; set; }\n    public JObject Variables { get; set; }\n}\n[HttpPost]\n[AllowAnonymous]\npublic async Task PostGraph(string request)\n{\n    Func getRequest = () =>\n    {\n        Request.InputStream.Position = 0;\n        using (Stream receiveStream = Request.InputStream)\n        {\n            using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))\n            {\n                return readStream.ReadToEnd();\n            }\n        }\n    };\n    request = getRequest();\n    GraphQLRequest deserialized = JsonConvert.DeserializeObject(request);\n// ...\n\n```. ",
    "rvlietstra": "Hi.\nI changed the previously referenced equality check in DocumentExecuter to compare the type name instead of the two objects, for what ever reason they are not equal. I will write a test at some point, I could be using things wrong but at least this allows me to move on.\nMy node interface is now working.\n. Just tested it and it seems to work!\nMany thanks!\n. Ok, this is what I have so far\nc#\nConnection<OrganizationType, UserType>().Name(\"Users\").Resolve(                \n    context => \n    {\n        Organization org = context.Source as Organization;\n        List<UserType> ret = ...\n        return ret;\n});\nThe Resolve func is returning a list of ObjectGraphTypes, shouldn't that be a list of my actual data layer types ? The reason I think that is that later on UserType is given the items in the list to resolve, which then has a context.Source of UserType when resolving it's fields instead of a User (type) ...\nPlease help! :)\n. Hi,\nExcellent.\nThanks!!\n. Thanks that seems to work!\n. ",
    "Radiv3": "Yes, I want to add a endpoint that can receive GraphQL queries from our SPA, and translate the GraphQL to our internal query format, fetch the data, and return it. We're currently do that with OData, but we would love to support GraphQL as well.\nThe GraphQLController helps a bit, but it still takes a lot of effort to get an overview of how the different parts fit together. I think a description that can help people understand the project would make the barrier for entry a lot lower. I see how much effort that has been put into this, and I would love for this to be widely used, so please take this as constructive feedback!  \nTo me it looks like the following is needed: \n- create a class that implements IDocumentExecuter.\n- create a schema class\n- create a query class (only one for all queries?)\n- define the graph types that represents our internal schema. \n- Do i need to create a a class that implements ISimpleContainer, or can I use SimpleContainer from the test project?\n. ",
    "sachinnshah": "I am new to GraphQL. Do you have any idea about working example.. GraphQL Server in .net and web page in java script ?\n. ",
    "MartinLorensen": "We are currently using the hudl:ConnectionBuilderImprovements branch in development and it works fine with only a single issue - a new() contrains on TGraphType in GraphType.Connection().\nThanks for some great work.\n. @tlil87: Do you refere to the issues with unquoting in IdGraphType.Coerce() ? I have just verified that I can remove my id = id.Trim('\\\"') from my node-field handling - so if that was the issue I would say it has been solved.\n. @tlil87 Ahh - okay. And yes, as indicated in that issue, it was solved too.\n. Sounds great.\nI am not sure I understand the separation between the convention and the \"main\" repo. But as long as the different elements found in conventions can be used independently that is fine with me. It seems like \"data and contract in one instance\" vs. \"data instances (non-GraphType) and contract instances (GraphType-derived)\" is central to the convention - but that does not seem to be related to this ToObject<T>() nor to e.g. EnumType<T>.  But if \"conventions\" is just anything to do with conventions (less code by following some \"standard\" conventions, e.g. fewer Field/Connection builders), no matter how the underlying model is, that sounds very reasonable - and in that case the ToObject<T>() is most definitly a convetion-thing.\n. I am VERY impressed and pleased! Thanks a lot! From issue to release in just about an hour!\n. Thanks - This works fine with regards to the DocumentWriter.\n. Ok, now I think I understand what is going on.\nThe easy fix/workaround is for me to add EnsureLookup in the end of the constructor of my Schema-derived class.\nMultiple places in the Schema class EnsureLookup is called. I assume multiple threads can call these methods, possibly concurrently. EnsureLookup is not thread safe since it test if _lookup is set and right after set it and continues to modify it. I see 3 reasonable changes:\nA) No locking - possibly do the work multiple times:\nif (this._lookup != null)\n        return;\n      var lookup = new GraphTypesLookup();\n      ...initialize lookup...\n      this._lookup = lookup;\nB) Local locking\nreadonly object myLock = new object();\n    ...\n   lock(myLock)\n   {\n      if (this._lookup != null)\n        return;\n      this._lookup = new GraphTypesLookup();\n      ...initialize _lookup...\n   }\nC) Use Lazy, remove calls to EnsureLookup.\n```\n   private readonly Lazy _lookup = new Lazy(CreateLookup);\n   ...\n   private GraphTypeLookup CreateLookup()\n   {\n      var lookup = new GraphTypesLookup();\n      ...initialize lookup...\n      return lookup;\n   }\n```\nDepending on call patterns A might be faster, but B and C should be very similar. I would probably go for C.\n. Sounds great!\nAnd no hurry! The JS tooling (at least the one we are using) does not seem to care too much about anything being marked NonNull - so the easy workaround is just to declare the types as EnumType<T> instead of NonNullGraphType<EnumType<T>>.\n. I am not sure if this is the same issue, but adding the code bellow in a GraphType caused a simular problem:\nConnection<FooType>()\n        .Name(\"foo\")\n        .Argument<EnumType<MyEnum>>(\"p\", \"p\")\n        .WithObject<Bar>()\n        .Unidirectional()\n        .Resolve(\n          c => GetFoos(c.Object, c.GetArgument<MyEnum>(\"p\"));\nIntrospection failes with (Exception message: \"Unkown kind of type: MyEnum\", from GraphQL.Introspection.__Type.KindForType(Type type) in C:\\Home\\projects\\graphql-dotnet\\src\\GraphQL\\Introspection__Type.cs:line 205).\nSecond, I had hoped c.GetArgument(\"p\")  would work, but it returns defailt(MyEnum), ignoring the actual value of p. If i use c.GetArgument(\"p\") I get the string. This is a different problem, and I can see it is not obvious to solve as the context c does not seem know about the underlying GraphType (EnumType<> from conventions) which is the one that knows the actual mapping from string to enum value. Any thoughts? Should I make a separate issue? Here or in the conventions project?\n. I think 0.6.4 is broken. Our schema.json (the output from the introspection query) just shrunk 10% in size (from about 145 KB to about 131 KB) when upgrading from 0.6.3 to 0.6.4 (no other changes). And using the schema with GraphiQL, graphql-js causes exceptions like: \n```\nERROR in [...]/js/graphiqlapp.js\nModule build failed: Error: Decorated type deeper than introspection query.\n    at getType ([...]/node_modules\\graphql\\utilities\\buildClientSchema.js:89:15)\n ....\n```\nIt looks like most ofType becomes null. E.g. the __Schema  type, the types field  is of type \"NOT_NULL\" with ofType = null (where in 0.6.3 it was ofType = List<NotNull<__Type>>.\n. It is a lot simpler. Running the attached Program.cs:\n```\n      var documentExecuter = new DocumentExecuter();\n      var executionResult = documentExecuter.ExecuteAsync(new Schema(), null, SchemaIntrospection.IntrospectionQuery, null).Result;\n      var json = new DocumentWriter(true).Write(executionResult.Data);\n      var version = new AssemblyName(documentExecuter.GetType().Assembly.FullName).Version;\n      var scema = new SchemaPrinter(new Schema()).PrintFilteredSchema(_ => true);\n  using (var textWriter = File.CreateText($\"EmptyScema-{version}.txt\"))\n    textWriter.WriteLine(scema);\n\n  using (var textWriter = File.CreateText($\"EmptyScema-{version}.json.txt\"))\n    textWriter.WriteLine(json);\n\n```\n... it creates attached output file EmptyScema-0.6.3.0.json with version 0.6.3, while with version 0.6.4 it creates EmptyScema-0.6.4.0.json. If you compare the two there is a lot of differences that I would not expect.\nThe other generated file (from the ScemaPrinter) is actually identical.\n. This seems to work now. Thanks!\n. I noted almost any argument has the same issue. E.g.\n- A StringGraphType/stringdoes not \"unescape\" e.g. backslashes.\n- A ListGraphType<StringGraphType> argument can only be accessed with GetArgument<object[]>(\"arg\").Cast<string>().ToList().\n. While using the new methods in our code, I noted that they are not part of the interface ISchema. I am not sure if that is intentionally or not. It was not a problem for me, but I would just mention it.\n. Very much in line with what I was hoping for.\nHave you considered public void RegisterTypes(param Type[] types) instead of public void RegisterTypes(IEnumerable<Type> types) and public void RegisterType(Type type) ?\n. I would assume that one solution would be to change ExecutionError to it does no extend Exception and add a property \"message\" mapped to \"innerException.Message\" and an optional locations list also provided by a constructor argument.\n. Most uses of ExecutionError is currently in the form of \"throw new ExecutionError(....)\" so it needs to extend exception or it has to be split into the exception and the \"DTO\".\nThe result of the current incorrect casing of message causes Relay to output something along the way of: Server request for query \"Xxxx\" failed for the following reasons: 1. undefined, 2. undefined, 3. undefined..... where the undefined is the value of the (missing) message key in the errors list.\nThings looks better with a simple FiddlerScript a la:\nstatic function OnBeforeResponse(oSession: Session) {\n        if (oSession.PathAndQuery==\"/path/to/graphql\") {            \n            oSession.utilReplaceInResponse('Message','message');\n        }\n    }.\n. This does not seem to work for me. I am not 100% sure, but I think the reason is that I am not able to enable the \"correct\" JsonFormatter.\nIf I replicate the code in \"graphql-dotnet\\src\\GraphQL.GraphiQL\\App_Start\\WebApiConfig.cs\" in my project build with the NuGet version of GraphQL, I get a different instance of Newtonsoft.Json then the one internalized and embedded in GraphQL. So when the \"public\" version scans for attributes it does not find the [JsonConverter(typeof(ExecutionResultJsonConverter))] attribute - and then it does just do default formatting (at least that is the result - it acts as before - both with 0.7.1 and 0-8.0-alpha).\nDoes that sound reasonable?\n. Reproduction:\n 1) Add the following method to graphql-dotnet\\src\\GraphQL.GraphiQL\\Controllers\\GraphQLController.cs:\npublic async Task<HttpResponseMessage> Get(HttpRequestMessage request)\n    {\n      return await Post(request, new GraphQLQuery { Query = \"query foo { hero }\" , Variables = \"\" });\n    }\n2) Verify that you can see the expected error (request http://localhost:47080/api/graphql in a browser):\n{\n  \"data\": null,\n  \"errors\": [\n    {\n      \"message\": \"Error trying to resolve hero.\"\n    }\n  ]\n}\n3) Remove the GraphQL project from the solutionn. Add GraphQL 0.7.1 from NuGet.\n4) Verify that you can see the unformated error \n{\n  \"data\": {\n    \"hero\": null\n  },\n  \"errors\": [\n    {\n      \"ClassName\": \"GraphQL.ExecutionError\",\n      \"Message\": \"Error trying to resolve hero.\",\n      \"Data\": null,\n      \"InnerException\": {\n        \"ClassName\": \"System.NullReferenceException\",\n        \"Message\": \"Object reference not set to an instance of an object.\",\n        \"Data\": null,\n        \"InnerException\": null,\n        \"HelpURL\": null,\n        \"StackTraceString\": \"   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action) in C:\\\\Home\\\\projects\\\\graphql-dotnet\\\\src\\\\GraphQL\\\\EnumerableExtensions.cs:line 29\\r\\n   at GraphQL.DocumentExecuter.CollectFields(ExecutionContext context, GraphType specificType, Selections selections, Dictionary`2 fields, List`1 visitedFragmentNames) in C:\\\\Home\\\\projects\\\\graphql-dotnet\\\\src\\\\GraphQL\\\\Execution\\\\DocumentExecuter.cs:line 534\\r\\n   at GraphQL.DocumentExecuter.<>c__DisplayClass10_0.<CompleteValue>b__1(Field field) in C:\\\\Home\\\\projects\\\\graphql-dotnet\\\\src\\\\GraphQL\\\\Execution\\\\DocumentExecuter.cs:line 291\\r\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action) in C:\\\\Home\\\\projects\\\\graphql-dotnet\\\\src\\\\GraphQL\\\\EnumerableExtensions.cs:line 31\\r\\n   at GraphQL.DocumentExecuter.<CompleteValue>d__10.MoveNext() in C:\\\\Home\\\\projects\\\\graphql-dotnet\\\\src\\\\GraphQL\\\\Execution\\\\DocumentExecuter.cs:line 289\\r\\n--- End of stack trace from previous location where exception was thrown ---\\r\\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\\r\\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\\r\\n   at GraphQL.DocumentExecuter.<ResolveField>d__8.MoveNext() in C:\\\\Home\\\\projects\\\\graphql-dotnet\\\\src\\\\GraphQL\\\\Execution\\\\DocumentExecuter.cs:line 189\",\n        \"RemoteStackTraceString\": null,\n        \"RemoteStackIndex\": 0,\n        \"ExceptionMethod\": \"8\\nApply\\nGraphQL, Version=0.7.1.0, Culture=neutral, PublicKeyToken=null\\nGraphQL.EnumerableExtensions\\nVoid Apply[T](System.Collections.Generic.IEnumerable`1[T], System.Action`1[T])\",\n        \"HResult\": -2147467261,\n        \"Source\": \"GraphQL\",\n        \"WatsonBuckets\": null\n      },\n      \"HelpURL\": null,\n      \"StackTraceString\": null,\n      \"RemoteStackTraceString\": null,\n      \"RemoteStackIndex\": 0,\n      \"ExceptionMethod\": null,\n      \"HResult\": -2146233088,\n      \"Source\": null,\n      \"WatsonBuckets\": null\n    }\n  ]\n}\n. ",
    "chmontgomery": "it seems like Antlr4 already supports this as of v4.5-alpha003: https://github.com/tunnelvisionlabs/antlr4cs/issues/126\n. ",
    "alexsandro-xpt": "+1\n. ",
    "we4sz": "+1\n. Yes indeed!\n. ",
    "natemcmaster": "Unless the dependency on Antlr4 is removed, this will be hard to complete before Antlr also supports .NET Core. See https://github.com/antlr/antlr4/issues/1142\nAlso, DNX is being retired. It's better to support its replacement, dotnet cli. See https://github.com/dotnet/cli.\n. ",
    "baluubas": "If someone is really itching (like me) to make the move to .NET core then I've made a quick and ditry port based on this fork of antlr4: https://github.com/lecode-official/antlr4\nYou can find it here:\nhttps://www.myget.org/feed/Packages/baluubas\nNeedless to say, it comes with a huge disclaimer.\n. @tlil87 Awesome, looking forward to a .NET core build\n. 0.12.0-alpha-511 works perfectly in my core solution, no hiccups so far. \n. I'm struggling a bit with this too, that is, injecting dependencies to do the resolving.\nWhat I currently do is some sort of poor man's dependency resolver thingy.\nIn the root type I set a static property on all types that require some sort of injections.\n```\n    public class RecruitQuery : ObjectGraphType\n    {\n        public RecruitQuery(IServiceProvider ioc)\n        {\n            Name = \"Root\";\n        // Poor mans DI\n        MeType._ioc = ioc;\n\n        Field<MeType>(\n            \"me\",\n            \"Root for queries based on the authenticated user\",\n            resolve: ctx => new MeObj()\n        );\n    }\n}\n\n```\nand in the MeType \n```\n    public class MeType : ObjectGraphType\n    {\n        internal static IServiceProvider _ioc { get; set; }\n    public MeType()\n    {\n        Name = \"Me\";\n\n        Field<NonNullGraphType<UserType>>(\n            \"profile\",\n            \"Fetches info for the autenticated user.\",\n            resolve: context => _ioc.GetService<GetAutenticatedUser>().Execute()\n        );\n    }\n}\n\n}\n```\nIt would be nice to if this would be build-in. Perhaps by registering a resolver (inheriting from some interface) when creating a field\nField<NonNullGraphType<UserType>>(\"profile\").ResolveWith<GetAutenticatedUser>();\n. @JarnoNijboer  I'm quite sure that doesn't work. I might be out on limb here but I think the instance of MeType is created by the framework using Activator.CreateInstance() and the way it's used it requires a empty constructor. \nIt can work for the root query but if you have nesting as I do you run in to this problem.\n. Ah, I totally read that wrong - missed that it could be used to resolve GraphType in that context. Yes, that does work beautifully - thanks for pointing me in the right direction @JarnoNijboer .\n. From the schema?\n. Ok, this the actual code I'm using and not the example code (react-relay is building these). The structure is the same though.\n```\nmutation UpdateOrganizationWebPresenceMutation($input_0:UpdateOrganizationWebPresenceInput!) {\n     updateOrganizationWebPresence(input:$input_0) {\n          clientMutationId,\n          ...F1\n     }\n}\nfragment F0 on Organization {\n  id,\n  webPresence {\n    website,\n    careerPage, \n    facebook,\n    instagram,\n    twitter\n  }\n}\nfragment F1 on UpdateOrganizationPayload {\n  organization {\n    ...F0\n  }\n}\n```\nAnd variables:\n{\n  \"input_0\":{\n    \"id\":\"15a29266-fb7e-4c85-a8c0-3190e017e893\",\n    \"__dataID__\":\"client:-18344258881\",\n    \"website\":\"google.com\",\n    \"careerPage\":\"google.com\",\n    \"facebook\":\"adf\",\n    \"instagram\":null,\n    \"twitter\":\"asdf\",\n    \"clientMutationId\":\"0\"\n  }\n}\nNote, the instagram null value which is causing the error.. \n. Cool, thanks for the help. \n. That was just a contrived example. The actual name of the input doesn't have space. \nI'll try and see if I can't make a failing test.\n. Ok here is a runnable example that fails due to input variable \"foo\" being null\n```\nusing GraphQL;\nusing GraphQL.Types;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nnamespace GraphQL_NET_Null_Property\n{\n    public class MyQuery : ObjectGraphType\n    {\n        public MyQuery()\n        {\n            Name = \"Root\";\n        }\n}\npublic class MySchema : Schema\n{\n    public MySchema()\n    {\n        Query = new MyQuery();\n        Mutation = new MyMutation();\n    }\n}\n\npublic class MyInput : InputObjectGraphType\n{\n    public MyInput()\n    {\n        Field<StringGraphType>(\"foo\");\n    }\n}\n\npublic class MyMutation : ObjectGraphType\n{\n    public MyMutation()\n    {\n        Field<AMutionPayload>(\n            \"a_mution\",\n            arguments: new QueryArguments(new[] {\n                new QueryArgument<MyInput> { Name = \"input\" }\n            }),\n            resolve: ctx => new { bar = \"Hello world\" }\n        );\n    }\n}\n\npublic class AMutionPayload : ObjectGraphType\n{\n    public AMutionPayload()\n    {\n        Name = \"AMutionPayload\";\n        Field<StringGraphType>(\"bar\");\n    }\n}\n\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Task.Run(Execute).Wait();\n        Console.ReadKey();\n    }\n\n    private static async Task Execute()\n    {\n\n        var query = @\"\n            mutation MyMutationReference($input_0:MyInput!) {\n                a_mution(input:$input_0) {\n                    bar\n                }\n            }\";\n\n\n        var executer = new DocumentExecuter();\n        var schema = new MySchema();\n        var inputs = new Inputs(\n            new Dictionary<string, object>{\n                { \"input_0\", new Dictionary<string, object> { {  \"foo\", null } } }\n        });\n\n        try\n        {\n            var result = await executer.ExecuteAsync(schema, null, query, null, inputs);\n\n            if (result.Errors != null)\n            {\n                Console.WriteLine(\"Execution error from ExecuteAsync\");\n                foreach (var error in result.Errors)\n                {\n                    Console.WriteLine(error.Message);\n                }\n                Console.WriteLine(\"Execution error from ExecuteAsync\");\n            }\n            else\n            {\n                Console.WriteLine(\"Success\");\n            }\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine(\"Runtime exception from ExecuteAsync\");\n            Console.WriteLine(e.ToString());\n        } \n    }\n}\n\n}\n```\n. Yes it does :) \nI still get the error if I change the input parameter to \nnew QueryArgument<NonNullGraphType<MyInput>> { Name = \"input\" } (and keep  $input_0:MyInput!)\n. Yes, that did the trick. Good work!\n. ",
    "LogikBlitz": "Just to be explicit. \nThe variables are present in the QueryObject, the question is how to pass it in to the Executor in a proper manner.\n. > You may also try the ToInputs extension method on string, which tries to handle nested complex objects.\nThat indeed did the trick, and it now works like a charm.\nI chose not to change the input to being a dict, in order to preserve compatibility and just passing a string.\n@joemcbride I am keen on writing a guide as to how to build a graphQl server using this lib.\nI could do it on code project but would rather do it here on a wiki and link to a repo containing the full source in steps.\nSince this a learning progress for me it will also allow for easy updating of possible misconceptions and alike if we do it on the wiki.\nIs that something you are interested in?\nThanks again. Your responses saved my day.\n. I am closing the issue and moving my question as to creating a wiki into a more direct PM to @joemcbride \n. ",
    "graphql-dotnet-ci": "Hey Vinayak, right now the way the EnumerationGraphType works is matching on the value.  So since you passed Female, it is trying compare that string to the numbers you provided (0-2).  If you change the values to their string equivalent then it should match.  There does seem to be some awkwardness (strings vs. numbers) here with the input so we may want to look at that closer.\n. ",
    "vinayakbhadage": "Thanks for reply @joemcbride , @tlil87.  would you please know when can be the next release with this fix.\n. Right now I got working solution for Enum by overriding object Coerce(object value) method,And made a Name and Value same for EnumValue. \n```\n public class GenderEnum : EnumerationGraphType\n    {\n    public GenderEnum()\n    {\n        Name = \"Gender\";\n        Description = \"User gender\";\n        AddValue(\"NotSpecified\", \"NotSpecified gender.\", \"NotSpecified\");\n        AddValue(\"Male\", \"gender Male\", \"Male\");\n        AddValue(\"Female\", \"gender female\", \"Female\");\n    }\n\n  public override object Coerce(object value)\n    {\n        EnumValue found = null;\n        if (value != null && !String.IsNullOrWhiteSpace(value.ToString()))\n        {\n            value = value.ToString().Replace(\"\\\"\", \"\");\n            foreach (var val in Values)\n            {\n                if (val.Value.ToString().Equals(value.ToString()))\n                {\n                    found = val;\n                    break;\n                }\n            }\n        }\n        //   var found =    Values.FirstOrDefault(v => v.Value.Equals(value));\n        return found != null ? found.Name : null;\n    } \n}\n\n```\nThanks & Regards,\n-Vinayak\n. @ManishTrivedi yes , it is correct implementation. The resolve argument is function pointer/delegate like  Func < ResolveFieldContext , object > resolve so that I used like below:\n```\n    public class MutationRoot : ObjectGraphType\n    {\n    public MutationRoot() {\n        Name = \"MutationRoot\";\n        Description = \"GraphQL MutationRoot for supporting create, update, delete or peroform custom actions\";\n\n        Field<UserType>(\"createUser\", \"create user api\",\n            arguments: new QueryArguments(\n             new QueryArgument[]{\n                    new QueryArgument<NonNullGraphType<UserInputType>> { Name = \"userInput\", Description = \"user info details\"}\n            }\n        ),\n        resolve: UserDelegate.CreateUser);\n    }\n\n}\n\npublic class UserDelegate\n{\n    public static User CreateUser(ResolveFieldContext context)\n    {\n        string output = JsonConvert.SerializeObject(context.Arguments[\"userInput\"]);                     \n        dynamic userInput = JObject.Parse(output) ; // using Newtonsoft json.net\n\n        var gender = userInput.gender;\n        var profileImage = userInput.profileImage;\n\n        // perform persistence and return created user.\n        return new User;\n    }\n}\n\n```\nRegards,\n-Vinayak\n. @joemcbride Thank you for clarification also for removing Resolve Type dependency from InterfaceGraphType in 0.5.1.\n. Thanks, But it is useful feature as GraphQL response is supporting the polymorphism and not in a request. Other API like  WCF, REST(Swagger) also support it.\nMight be in future they will support it.\n-vinayak\n. Sure, Let us assume, want to provide user authentication using graphql mutation. User can be authenticated in multiple ways \n1. User name and password authentication.\n2. Username, security question and answer.\n3. Username and Token based authentication.\nmutation authenticateUser(AuthenticationInput) {\n    userId,\n    userDetails\n   {\n      firstName\n      ... etc\n    }\n  }\nHere AuthenticationInput can have following subtypes:\n```\npublic class AuthenticationInput : InputObjectGraphType\n{\n    public AuthenticationInput ()\n    {\n      Field(\"userName\");\n    }\n}\npublic class UserNamePasswordAuthenticationInput : AuthenticationInput \n{\n    public UserNamePasswordAuthenticationInput ()\n    {\n      Field(\"password\");\n    }\n}\npublic class SecurityQuestionBasedAuthenticationInput : AuthenticationInput \n{\n    public SecurityQuestionBasedAuthenticationInput ()\n    {\n      Field(\"secretQuestion\");\n      Field(\"secretAnswer\");\n    }\n}\npublic class TokenBasedAuthenticationInput : AuthenticationInput \n{\n    public TokenBasedAuthenticationInput ()\n    {\n      Field(\"token\");\n    }\n}\n```\nThis is available in WCF using KnownType attribute on DataContract .\nThanks & Regards,\n-Vinayak\n. ",
    "draganjovanovic1": "Hi, here is an interesting idea on how this could be solved by implementing union input type https://github.com/Cardinal90/graphql-union-input-type. You can also use Dictionary for variables but you have to play a bit with custom JSON converter to make deserialization work properly. If you don't mind reading some F# you can see a working example here https://github.com/draganjovanovic1/cryptoql . ",
    "JarnoNijboer": "@tlil87 Can you share details on the release of the conventions repo?\nWe are thinking about refactoring our current v1 GraphQL implementation, and some of the things in the conventions repo, e.g. IdType, should making our codebase a lot easier to manage.\nKeep up to good work guys!\n. My solution works for correct for validation, but fails when CoerceValue method from DocumentExecutor is executed.\nThe solution that @HasAndries mentioned in #70 is working perfectly for me\n. @joemcbride Thanks for the fast response! \ud83d\ude03 \n. It seems that relay sends the enum value as a part of the input variable. The result of this is that the enum value is send as a string, and not as text.\nAt the moment I have not the time needed for creating a failing test, I will try to do this when I have the necessary time available.\nAn shortend example of the mutation that is send by relay:\n``` graphql\nmutation AddPropertyMutation($input_0: AddPropertyInput!) {\n  addProperty(input: $input_0) {\n    clientMutationId\n    ...F4\n  }\n}\nfragment F4 on AddPropertyPayload {\n  productType {\n    id\n    ...F0\n  }\n}\n```\nand the corresponding variables\njson\n{\n  \"input_0\": {\n    \"clientMutationId\":\"b\",\n    \"type\":\"lookup\"\n  }\n}\n. You could used ctor injection, so that the IGetAuthenticatedUser is injected into the ctor from MeType.  Then the resolve method would look like resolve: ctx => getAuthenticatedUser.Execute()\nSuch a solution doesn't force you to sprinkle your Ioc container throughout your GraphQL code.\nAn example of what this would look like:\n``` csharp\npublic class MeType : ObjectGraphType\n{\n    public MeType(IGetAuthenticatedUser getAutenticatedUser)\n    {\n        Name = \"Me\";\n    Field<NonNullGraphType<UserType>>(\n        \"profile\",\n        \"Fetches info for the autenticated user.\",\n        resolve: context => getAutenticatedUser.Execute()\n    );\n}\n\n}\n``\n. @baluubas It will work, trust me \ud83d\ude09 Since you can pass aFunc` into the ctor of the Schema class, as outlined by @joemcbride above\nThe func you can pass in the ctor allows you to plugin your Ioc container, and to me the  default Activator.CreateInstance is just a fallback, for when you don't use a Ioc container at all.\nAn example of how I use StructureMap, in conjuction with GraphQL, it in one the projects I work with:\n``` csharp\nusing GraphQL.Types;\nusing StructureMap;\npublic class MySchema : Schema\n{\n    public MySchema(IContainer container) : this(type => (GraphType) container.GetInstance(type)) { }\nprivate MySchema(Func<Type, GraphType> resolveType)\n    : base(resolveType)\n{\n    ...\n}\n\n}\n```\n. This repository contains a working sample project:\n- Starwars sample project\n- GraphQL server using the sample project\nThe unittests we're also a great learning resource for me, when exploring this project\n. There isn't a client api in this library, as far as my knowledge goes. But it's fairly simple to create one; the query is just a string literal, that is part of the query request.\nA sample of a GraphQL query object, which you can sent, via a post request, as JSON object to an GraphQL(.NET) endpoint:\ncsharp\npublic class GraphQLQuery\n{\n    public string OperationName { get; set; }\n    public string Query { get; set; }\n    public string Variables { get; set; }\n}\n. The error message No parameterless contructor defined for this object. is generated by the .NET framework. Did you use a DI container with this, since that could explain the message you got. The DI container tries to create a HumanType and looks for a parameterless ctor or a ctor with only interface parameters.\n. A good source I tend to use, are the unit tests for this project. \n. You haven't specified an id in your query:\nQuick example of your query with an id specified for ruoli\ngraphql\nquery {\n    ruoli (id: 10) {\n        tipi\n    }\n}. ",
    "HasAndries": "Hi @joemcbride\nWe currently use the library with production code and would like to use your official nuget package again. Could you please include these fixes and additions with the next release?\n. Thanks for all the comments, I'll work through them and provide unit tests where applicable. We don't use rebase in our normal workflow, so I'll need to read up on how to use it without messing up the repositpory.\n. I've updated our code to support the standard nuget package without the changes from this fork. The only fix that I have on my side is to do with EnumerationGraphType and I will submit a pull request for that.\nWhen an enum value is passed as part of an Input, the Coerce for EnumerationGraphType gets passed a string value, and the lookup on Values fails, because it does a lookup on the actual enum value. That is why I changed the Coerce to lookup on Values if not found:\npublic override object Coerce(object value)\n{\n    var found = Values.FirstOrDefault(v => v.Value.Equals(value));\n    if (found != null) return found.Name;\n    return Values.FirstOrDefault(v => v.Name.Equals(value))?.Value;\n}\n. @joemcbride The build seems to be broken. Is this something that you are aware of?. @joemcbride Thanks for the fix, the build is passing. Any chance we can add this change sometime soon? Just remember that this change goes with this change in the parser: https://github.com/graphql-dotnet/parser/pull/10. I used the whole field because it can have an alias and didn't want to pollute the code with conditionals. I'll make it an optional parameter.\n. I will remove this change as I have removed the code my side that needed access to it.\n. If memory serves me right, the original code works when mapping out to JSON, but it does not work for inbound conversion of enums. I'll add a test.\n. I see this was fixed since I started using the library source, it used to be if (conditionalType == type). I'll revert to the code in master.\n. I didn't know about the DocumentValidator, it looks like it can serve the same pupose. I'll make the change.\n. ",
    "emreeren": "I used MEF to import query classes and merge fields in a single RootQuery class. What do you think about this solution? \nI created an empty class to differ queries from mutations by class type.\nc#\npublic class GraphqlQuery : ObjectGraphType\n{}\nRoot query imports queries and builds fields.\nc#\n[Export(typeof(RootQuery))]\npublic class RootQuery : ObjectGraphType\n{\n    [ImportingConstructor]\n    public RootQuery([ImportMany]IEnumerable<GraphqlQuery> graphqlQueries)\n    {\n        Name = \"Query\";\n        foreach (var fieldType in graphqlQueries.SelectMany(graphqlQuery => graphqlQuery.Fields))\n        {\n            Field(fieldType.Type, fieldType.Name, fieldType.Description, fieldType.Arguments, fieldType.Resolve);\n        }\n    }\n}\nRemaining part is unrelated but I thought it will be a good idea to give some more details.\nQueries derives GraphqlQuery class.\n``` c#\n[Export(typeof(GraphqlQuery))]\npublic class TicketGraphqlQuery : GraphqlQuery\n{\n    public TicketGraphqlQuery()\n    {\n        Field(\"ticket\",\n            arguments: new QueryArguments(\n                new[]\n                {\n                    new QueryArgument>\n                    {\n                        Name = \"id\",\n                        Description = \"id of the ticket\"\n                    }\n                }),\n            resolve: context => GetTicketById(context.Argument(\"id\"))\n            );\n    }\nprivate object GetTicketById(int id)\n{\n    return Dao.Single<Ticket>(x => x.Id == id, x => x.Orders);\n}\n\n}\n```\nI also exported types as MEF exports so I can inject my services. I used Schema's ResolveType to resolve them with a ServiceLocator implementation that works with MEF. If it fails to resolve it activates classes as demonstrated in tests.\nc#\n[Export]\npublic class TicketGraphType : ObjectGraphType\n{\n    [ImportingConstructor]\n    public TicketGraphType(ICacheService cacheService)\n    {\n        Name = \"Ticket\";\n        Field<NonNullGraphType<StringGraphType>>(\"id\", \"Id of the ticket\");\n        Field<StringGraphType>(\"type\", \"TicketType of ticket\", resolve: x => cacheService.GetTicketTypeNameById(((Ticket)x.Source).TicketTypeId));\n        Field<StringGraphType>(\"number\", \"Generated ticket number\", resolve: x => ((Ticket)x.Source).TicketNumber);\n        Field<StringGraphType>(\"date\", \"Ticket creation date\", resolve: x => ((Ticket)x.Source).Date);\n        Field<ListGraphType<OrderGraphType>>(\"orders\", \"Orders\", resolve: x => ((Ticket)x.Source).Orders);\n        IsTypeOf = value => value is Ticket;\n    }\n}\nTicket is a Model class that maps to database via EF.\n. That probably changed after 11th version. AddField works fine for me too.. ",
    "petrovic-ivan": "@emreeren What is fieldType.Resolve?  It doesn't exist on FieldType. On FieldType I can only find Resolver which is the type of IFieldResolver . How I can return resolver for that field?. Instead of trying to build field I am adding existing field with this: AddField(field); and it works for me.. An example in StarWars app we have StarWarsQuery class. Basically, correct way will be to always implement new fields and types if I need them, not to implement now SomeQueryclass and register somehow?. Values per IMaker will be very different. By adding Type property did you mean to add some identifier and based on that deserialize into the desired type? It can work but it will become more complicated once I find nested properties. . Thanks for response. I created dummy FileGraphType which can serve as description only.. ",
    "hades200082": "A note for anyone looking at this - .Net Core 2.1 has a bug in MEF that means ImportMany never populates an array.\nI went a slightly different way from the docs using partials...\n```csharp\n/// Query.Root.cs\npublic partial class Query : ObjectGraphType\n{\n    public Query(IPlayerDatastore playerDatastore, IPlayerBoundDatastore shipDatastore)\n    {\n        AddPlayerFields(playerDatastore);\n        AddShipFields(shipDatastore);\n    }\npartial void AddPlayerFields(IPlayerDatastore ds);\npartial void AddShipFields(IPlayerBoundDatastore<ShipModel> ds);\n\n}\n```\n```csharp\n/// Query.Player.cs\npublic partial class Query\n{\n    // _ctx = Datacontext\npartial void AddPlayerFields(IPlayerDatastore ds)\n{\n    FieldAsync<PlayerType>(\n        name: \"me\",\n        description: \"the currently logged in player\",\n        resolve: async context =>\n        {\n            var id = ((AuthorizationHelper)context.UserContext).Auth0Id;\n            return await ds.GetByAuth0IdAsync(id);\n        });\n\n    FieldAsync<PlayerType>(\n        name: \"player\",\n        description: \"A list of players that are not nessescarily the currently logged in player\",\n        arguments: new QueryArguments(new QueryArgument<GuidGraphType> {Name = \"id\"}),\n        resolve: async context =>\n        {\n            var id = context.GetArgument<Guid>(\"id\");\n            return await ds.GetByIdAsync(id);\n        });\n}\n\n}\n```\n```csharp\n/// Query.Ship.cs\npublic partial class Query\n{\n    partial void AddShipFields(IPlayerBoundDatastore ds)\n    {\n        FieldAsync(\n            \"ship\",\n            arguments: new QueryArguments(new QueryArgument { Name = \"id\" }),\n            resolve: async context =>\n            {\n                var id = context.GetArgument(\"id\");\n                return await ds.GetByIdAsync(id);\n            });\n    FieldAsync<ListGraphType<ShipType>>(\n        \"ships\",\n        arguments: new QueryArguments(new QueryArgument<IdGraphType> { Name = \"playerId\" }),\n        resolve: async context =>\n        {\n            var playerId = context.GetArgument<Guid>(\"playerId\");\n            return await ds.GetByPlayerIdAsync(playerId);\n        });\n\n}\n\n}\n```\nThoughts?. I'm getting the same issue in .Net Core 2.1 also.\nI followed the \"Setup\" section of the docs precisely and have double and triple checked it.\nIn the Type below, accessor.Context is always null.\ncsharp\npublic class PlayerType : ObjectGraphType<PlayerModel>\n{\n    public PlayerType(IPlayerDatastore playerds, IPlayerBoundDatastore<ShipModel> shipDs, IDataLoaderContextAccessor accessor)\n    {\n        Name = \"Player\";\n        Field(x => x.Id, type: typeof(IdGraphType));\n        Field(x => x.Auth0Id);\n        Field(x => x.Nickname);\n        Field<ListGraphType<ShipType>, IEnumerable<ShipModel>>()\n            .Name(\"Ships\")\n            .ResolveAsync(ctx =>\n            {\n                var loader =\n                    accessor.Context.GetOrAddBatchLoader<Guid, IEnumerable<ShipModel>>(\"GetByPlayerId\", shipDs.GetByPlayerIdsAsync);\n                return loader.LoadAsync(ctx.Source.Id);\n            });\n    }\n}\n```csharp\npublic async Task>> GetByPlayerIdsAsync(IEnumerable playerIds)\n{\n    var entities = await Context.Set()\n        .Where(x => playerIds.Contains(x.PlayerId))\n        .ToListAsync();\nreturn playerIds.ToDictionary(playerId => playerId, playerId => Mapper.Map<IEnumerable<TModel>>(entities.Where(x => x.PlayerId == playerId)));\n\n}\n```\nI also inspected the listener in the graphql controller action... The accessor context was null there also.\nMy project is blocked at present due to this issue so any help would be appreciated.. Sure thing....\nFrom startup.cs\ncsharp\nservices.AddSingleton<IDataLoaderContextAccessor, DataLoaderContextAccessor>();\nservices.AddSingleton<DataLoaderDocumentListener>();\nservices.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();\nservices.AddTransient(s => s.GetService<IHttpContextAccessor>().HttpContext.User);\nservices.AddTransient<AuthorizationHelper>();\nservices.AddSingleton<IDocumentExecuter, DocumentExecuter>();\nThen in my GraphQlController.cs\n```csharp\npublic class GraphQLController : BaseController\n{\n    private readonly IDocumentExecuter _documentExecuter;\n    private readonly IDocumentExecutionListener _documentListener;\n    private readonly ISchema _schema;\npublic GraphQLController(ISchema schema, IDocumentExecuter documentExecuter, DataLoaderDocumentListener documentListener, AuthorizationHelper authHelper)\n    : base(authHelper)\n{\n    _schema = schema;\n    _documentExecuter = documentExecuter;\n    _documentListener = documentListener;\n}\n\n[HttpPost]\npublic async Task<IActionResult> Post([FromBody] GraphQLQuery query)\n{\n\n    if (query == null) { throw new ArgumentNullException(nameof(query)); }\n    var inputs = query.Variables.ToInputs();\n\n    var options = new ExecutionOptions\n    {\n        Schema = _schema,\n        Query = query.Query,\n        Inputs = inputs,\n        UserContext = User,\n        ComplexityConfiguration = new ComplexityConfiguration { MaxDepth = 15 }\n};\n    options.Listeners.Add(_documentListener);\n\n    var result = await _documentExecuter.ExecuteAsync(options).ConfigureAwait(false);\n\n    if (result.Errors?.Count > 0)\n    {\n        return BadRequest(result);\n    }\n\n    return Ok(result);\n}\n\n}\n```. Quick note...\ncsharp\npublic T Resolve<T>() => _services.GetService<T>();\nshould be ...\ncsharp\npublic T Resolve<T>() => _services.GetRequiredService<T>();\nGetService doesn't have a generic implementation.\nI'll try the solution and reply back if it works for me.. It worked! Thanks.\nI had to make the queries & schema scoped because my data-layer is scoped due to being EF.\n```csharp\nservices.AddSingleton();\nservices.AddSingleton();\nservices.AddSingleton();\nservices.AddSingleton();\nservices.AddScoped();\nservices.AddScoped();\nservices.AddScoped();\nservices.AddScoped();\n```\ncsharp\npublic class RootSchema : Schema\n{\n    public RootSchema(IDependencyResolver resolver) : base(resolver)\n    {\n        Query = resolver.Resolve<Query>();\n    }\n}\n```csharp\ninternal sealed class ServiceProviderAdapter : IDependencyResolver\n{\n    private readonly IServiceProvider _services;\npublic ServiceProviderAdapter(IServiceProvider services)\n{\n    _services = services.CreateScope().ServiceProvider;\n}\n\npublic T Resolve<T>() => _services.GetRequiredService<T>();\n\npublic object Resolve(Type type) => _services.GetService(type);\n\n}\n```. ",
    "ManuelDeLeon": "Thanks. Had to download nuget.exe from https://docs.nuget.org/consume/Command-Line-Reference put it on the root folder and then execute nuget restore GraphQL.sln\n. Seems like GraphiQL changed. Closing this one. Thanks.\n. The thing is that without the camel case resolver I get \"Data\" instead of\n\"data\". If I add the json property name or just rename the property to\nlowercase I get the proper casing (\"data\") without the camel case resolver.\nOn Jun 30, 2016 3:39 PM, \"Joe McBride\" notifications@github.com wrote:\n\nCurrently, this project ILMerge's its own version of Json.NET, so those\nJsonProperty attributes will only apply if you use the DocumentWriter.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Http/DocumentWriter.cs\nThose values should always be lowercase to conform to the GraphQL spec.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/116#issuecomment-229795844,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AED31vGKUQKIiX9lhdbTUgB1I5bfSxHPks5qRDaIgaJpZM4JCgJH\n.\n. I'm confused about the following statements (they seem to contradict themselves):\nthose JsonProperty attributes will only apply if you use the DocumentWriter. (regarding https://github.com/graphql-dotnet/graphql-dotnet/issues/116#issue-163246025)\nAnd:\nThat would be expected if you're not using the DocumentWriter (regarding https://github.com/graphql-dotnet/graphql-dotnet/issues/116#issuecomment-229798447)\n\nAssuming ExecutionResult doesn't need JsonProperty or a change of case, how should I modify the GraphQL.GraphiQL project so that it doesn't force camel case on the JSON objects?\n. I'm using the Nuget version on my project but let's take your GraphQL.GraphiQL example. \nI just cloned the whole project, restored the packages, and modified the character interface (in StarWars) so that the name is PascalCase (also updated Droid and Human to match).\nAt this point the schema returns the right case (\"Name\"), the intellisense also yields the correct result, but when I run the query, name is lowercase.\nQuery:\n{\n  hero {\n    Name\n  }\n}\nResult:\n{\n  \"data\": {\n    \"hero\": {\n      \"name\": \"R2-D2\"\n    }\n  }\n}\nWhat else do I need to do on your sample project(s) so that the JSON comes back with the right case?\n. Why does DocumentWriter forces JSON objects to have camelCase keys in the first place? I mean, data and errors can be lowercase (along with the rest of GraphQL specific keys) and the user's JSON object keys maintain their case.\n. Making it configurable doesn't make much sense. Wouldn't you agree with following?\n1) The client should receive the object keys in whatever casing the schema has. If the schema says Name the object key should be Name, not name.\n2) The client should receive the object keys in whatever casing their alias has. If they query Name: name the object key should be Name, not name.\n. I understand you use camelCase and indeed it would be a bug in your API if a field is PascalCase. My point is that forcing the response to be camelCase doesn't prevent you from having casing bugs in your API. \nConsider the scenario where you make a typo and give a field the name StateCode instead stateCode. Without forcing the case in your output you have a bug in your API: case not matching the convention. If you force camelCase in your output you'd still have a bug: the schema is different than the output.\nAnd then there's the issue of the consumer of your API not being able to alias the fields to whatever case they want.\nNow if you don't think it's a bug for the output to be different than the schema and the aliases, then I'll see about that PR. It's your library after all.\n. We solved this problem by adding a DecimalValue to IntValue.cs and a decimal check in GraphQLExtensions.cs\nIntValue.cs:\n```csharp\n    public class DecimalValue : AbstractNode, IValue \n    { \n        public DecimalValue(decimal value) \n        { \n            Value = value; \n        } \n    public decimal Value { get; }\n\n    public override string ToString() \n    { \n        return \"DecimalValue{{value={0}}}\".ToFormat(Value); \n    }\n\n    protected bool Equals(DecimalValue other) \n    { \n        return Value == other.Value; \n    }\n\n    public override bool IsEqualTo(INode obj) \n    { \n        if (ReferenceEquals(null, obj)) return false; \n        if (ReferenceEquals(this, obj)) return true; \n        if (obj.GetType() != this.GetType()) return false; \n        return Equals((DecimalValue)obj); \n    } \n}\n\n```\nGraphQLExtensions.cs (in AstFromValue)\ncsharp\n            if (serialized is decimal) \n            { \n                return new DecimalValue((decimal)serialized); \n            }\nIs there a problem with this solution?. > Long term I would like to provide hooks so that anyone who wants to add custom scalar types could override these behaviors.\nThat's an interesting idea. I dig it for custom types but I wonder about types native to .Net (like decimal). The target audience here are .Net developers so would it really make sense to declare \"Types that translate to the GraphQL spec are handled out of the box. For the rest of the .Net types use this separate library (or turn on this flag)\"?\n\nWe can probably add DecimalValue in the short term. \n\nWant a PR?. Cool. PR sent.\nbtw, if some poor soul reading this is having trouble opening this repo on Visual Studio (getting \"dotnet-projectmodel-server unable to start\"). Make sure you haven't installed one of the .Net Core Toolset Preview 3 or 4 By default it grabs the highest (incompatible) version.. @joemcbride \nOne of our devs is working on a PR for this. Adding if (field.Resolver == null) to FieldMiddlewareBuilder.ApplyTo seems to fix the problem. It prevents it from wrapping the existing resolver over and over again. All existing tests pass but creating a test for this issue is proving to be tricky.\n```\n        public void ApplyTo(ISchema schema)\n        {\n            schema.AllTypes.Apply(item =>\n            {\n                var complex = item as IComplexGraphType;\n                complex?.Fields.Apply(field =>\n                {\n                    if (field.Resolver == null)\n                    {\n                        var resolver = new MiddlewareResolver(field.Resolver);\n                    FieldMiddlewareDelegate app = context => resolver.Resolve(context);\n                    app = Build(app);\n\n                    field.Resolver = new FuncFieldResolver<Task<object>>(context => app.Invoke(context));\n                }\n            });\n        });\n    }\n\n```\nWhat do you think?. That makes testing it a lot easier too. We'll have something soon.. You're right. I added the test for ParseLiteral.. Oh well. Thanks anyway =). ",
    "cable729": "@tlil87 - How will this this affect the conventions library?\n. Awesome, is there anything I can do to help?\n. One thing we might consider is using the new standardized dependency injection interface (from https://github.com/aspnet/DependencyInjection). It is starting to be used by major frameworks, as well as ASP.NET Core and Entity Framework Core. The interface is basically:\n/// <summary>Defines a mechanism for retrieving a service object; that is, an object that provides custom support to other objects.</summary>\n  /// <filterpriority>2</filterpriority>\n  public interface IServiceProvider\n  {\n    /// <summary>Gets the service object of the specified type.</summary>\n    /// <returns>A service object of type <paramref name=\"serviceType\" />.-or- null if there is no service object of type <paramref name=\"serviceType\" />.</returns>\n    /// <param name=\"serviceType\">An object that specifies the type of service object to get. </param>\n    /// <filterpriority>2</filterpriority>\n    object GetService(Type serviceType);\n  }\nWhat I think should happen is that we should register the types that we want to inject into ObjectGraphType or any other graph type, and let the internals of this framework handle constructing the graph types with the types that the user provides. Right now, we're telling the library how to construct graph types, which is a concern as an end user I shouldn't have to worry about. I should only have to tell the library about my custom types that it should inject.\n. I like the idea of moving away from an inheritance and constructor-based setup. This looks good, but may I suggest a few improvements?\n```\npublic class Person\n{\n    public Guid Id { get; set; }\n    public string Name { get; set; }\n}\npublic class MyQuery\n{\n    private readonly IPersonRepository _people;\npublic MyQuery(IPersonRepository people) { _people = people; }\n\npublic IPerson Person(int id)\n{\n    return _people.Find(id);\n}\n\n}\n// using Microsoft.Extensions.DependencyInjection\nIServiceProvider dependencyProvider = new ServicesCollection()\n    .AddTransient()\n    .BuildServiceProvider();\nvar schema = TypedSchema.For(dependencyProvider);\n// or: var schema = TypedSchema.For(...);\n// It is possible for the TypedSchema class to walk the object tree to see which types the Query and Mutation are providing\nvar runner = Runner.For(schema);\nconst string getPersonQuery =@\"\n    query {\n      person('e86547f6-d77a-48c3-8849-6f205b5a38cc') {\n        id\n        name\n      }\n    }\";\nvar result = await _runner.ExecuteAsync(getPersonQuery);\nConsole.WriteLine(result);\n// same as your result\nconst string queryWithParameters = \"...\";\nparameters = \"{ personId = 'e86547f6-d77a-48c3-8849-6f205b5a38cc }\";\n// or parameters = new Dictionary() { [\"personId\"] = \"e86547f6-d77a-48c3-8849-6f205b5a38cc\" };\nvar result2 = await _runner.ExecuteAsync(queryWithParameters, parameters);\nAssert.Equals(result, result2);\n// true\n```\nAttributes would also make this very nice to use.\nThe only thing I'm not exactly sure on is where the ExecutionContext should go.. It could be added as a parameter to any method that uses it I suppose, and other methods that don't want it don't have to add it to the parameter list.\n. > When a ListGraphType or NonNullGraphType type is requested via FindType, that type is created on the fly.\nDoes this mean that all types that are needed are not created at the beginning anymore? I.E. we could have two different instances of ListNodeType<MyNodeType>?\n. Yeah, could be. Why is the executor requesting that QueryArguments be resolved in the first place though?\n. It would be good to have some tests around dependency injection. I won't have a chance to look at this until Sunday night, but if it's still open then I can take a crack at it. We should have:\n- A failing test(s) that describes this issue\n- Tests that ensure this system works with the top C# dependency injection frameworks\n. @joemcbride looks like it is still possible: https://github.com/dotnet/cli/issues/4765\nAnd for your work, I'm not sure what to recommend. It would be nice to be able to work on this project in VS 2017. Upgrading to .csproj would allow work to be done on this project in VS Code, VS 2015, and VS 2017.. ",
    "SimonCropp": "@joemcbride time to delete this branch?. @joemcbride so should this be closed?. doesnt this only make sense if we also document all the other containers to the same extent?. @amaningenium the readme here has a pretty good example https://github.com/graphql-dotnet/graphql-client. @ZenSoftware thanks for the ping\n\nGraphQL fragments are currently not supported.\n\nYep still happy to accept a PR for that. or if someone really needs it, and cant spend the time themselves, I can quote an hourly rate\n\nThere are some type introspection issues for parameters.\n\nNot sure what u mean by that? can u add a failing test as a PR?\n\nDeeply nested relations sometimes need to be explicitly included.\n\nthe full doco is here https://github.com/SimonCropp/GraphQL.EntityFramework#includes-and-navigation-properties. in the majority of cases includes are derived by the graphql query and do not need to be explicitly included. happy to accept feedback if someone finds ways to tweak the current implementation \n. just an fyi. i stated a small side project with some basic support for EF where, skip and `take, semantics https://github.com/SimonCropp/GraphQL.EntityFramework. There is also \nhttps://readthedocs.org/. As for compilable/runnable snippets i created this \nhttps://github.com/SimonCropp/MarkdownSnippets. Happy to help apply it, if u think it would make things easier . @joemcbride shouldnt handling of the above types be an internal library concern?. @serhii-ohorodnyk could you submit a PR with a failing unit test?. How would that work? Generic constraints are ANDed. So in your example no type could both be a string and an int. @ericnograles any response to https://github.com/graphql-dotnet/graphql-dotnet/issues/545#issuecomment-362916829\nis this still happening for you?. @nportelli is this answered to your satisfaction? ok if we close?. @Grauenwolf yep i understand what it is. but the description of the PR doesnt really capture the scope of the change. I know i have seen, and experienced myself, many problem with fxcop over the years. and hence prefer to avoid it these days.. @joemcbride given this now conflicts. would you like a new PR?. @ujwaliyer would this help you? https://github.com/SimonCropp/GraphQL.EntityFramework. closing since it seems to be answered. @jweite so looks like this one can be closed?. I might be missing something. But why cant this ship as a stand alone nuget and live in its own repo?. @joemcbride looks like should be closed now?. @neooleg could you supply a failing unit test in a PR? or upload a repro somewhere?. @neooleg still cant repro. i added a test for your scenario https://github.com/graphql-dotnet/graphql-dotnet/pull/769 and it passes. \ncan u try the latest version 2.0.0-alpha-978. @joemcbride reviewing some other code i found a bug that may have caused this https://github.com/graphql-dotnet/graphql-dotnet/pull/769/commits/e56e282bb8c9740a3372f2f8b26dcfbdcb639643. @neooleg BTW dont u think this is a strange stance to take when consuming a free open source project\n\nIt led for tremendous time waste since I 100% trust to the graphql-dotnet and look for an issue in another place.. perhaps add to the 2.0 milestone?. ok closing this one for now as it seems to be fixed. @neooleg please raise a new issue if you experience anything similar. @kamleshdelat u can add it to the UserContext at execute time\n\neg\n```\n    [HttpPost]\n    public async Task Post([FromBody] GraphQlQuery query)\n    {\n        var inputs = query.Variables.ToInputs();\n        var executionOptions = new ExecutionOptions\n        {\n            Schema = schema,\n            Query = query.Query,\n            Inputs = inputs,\n            UserContext = new MyUserContext\n            {\n                HttpContext = this.HttpContext,\n            }\n        };\n    var result = await documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\n\n    if (result.Errors?.Count > 0)\n    {\n        return BadRequest(result);\n    }\n\n    return Ok(result);\n}\n\nu can then use that instance in the resolve\nresolve: context =>\n{\n    var userContext = (MyUserContext)context.UserContext;\n    var httpContext= userContext.HttpContext;\nreturn ....;\n\n}\n```. @HilalHakla did u meant to re-open this?. gentle bump. my understanding is Schema should be single instance. . should graphql-dotnet adopt features that are not part of the graphql spec?. i will re submit this in a new PR. i will re submit this in a new PR. nor sure where in the CI you say what version of netcore is required?. ok changes made. i will rebase my other PRs on this one once it is merged. gentle bump. shouldnt timeouts and time based throttling be the responsibility of the controller (or any web api) that is executing the graphql query? it can then propagate that cancellation through to graphql via the cancellation token. @joemcbride seems to be failing due to versioning issue? u still happy to merge?. Yes that test is flaky . @joemcbride this one looks good to me. Ok with a merge?. @Jefffrey sounds like a good opportunity for you to start a side project. do you need any help from me to get started?. Have u considered wrapping it up in a nuget?. you can work around this by implementing your own execution strategy\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/1026\npublic class EfDocumentExecuter : DocumentExecuter\n{\n    protected override IExecutionStrategy SelectExecutionStrategy(ExecutionContext context)\n    {\n        if (context.Operation.OperationType == OperationType.Query)\n        {\n            return new SerialExecutionStrategy();\n        }\n        return base.SelectExecutionStrategy(context);\n    }\n}. ok this fixed it. but i have no idea why https://github.com/SimonCropp/GraphQL.EntityFramework/commit/a7737df9d6d79e03268fa72f6910b68dbe24665a. i dont see how given this was the argument that caused it to happen https://github.com/SimonCropp/GraphQL.EntityFramework/commit/a7737df9d6d79e03268fa72f6910b68dbe24665a#diff-42e8db515530f05df18eb7b2fa6b852dR35\n\nhappy to be corrected :). Also using in production. Closing this one. Seems have served its purpose. @BottlecapDave currently there is no such build process. At my current client we generate the schema file in a unit test, it can then be committed to source control and included as a build asset\nYou could also optionally create a new open source project that produces such a build task. @joemcbride any objections to merging this?. @johnrutherford i reverted, then re-applied in a new branch+pr for you to continue your changes. sorry for jumping the gun\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/976. @santoshpatro did u end up solving this?. @mohsin31 can u answer joes question?. @Kunjahamed-P can u submit a PR for this. will close this one for now. on the next major all [obsoletes] will be reviewed and cleaned up. \n@DSilence  thanks for the other PR. mostly to prevent the binding redirect hassle. One small note that this is a breaking change. @cgatian want to have a go at submitting a fix for this via a PR?. Can a unit test be added to this, to ensure we dont have a regression in the future. Re ef and queryable https://github.com/SimonCropp/GraphQL.EntityFramework. Re validation https://github.com/SimonCropp/GraphQL.Validation. Re auth https://graphql-dotnet.github.io/docs/getting-started/authorization. Also re validation https://graphql-dotnet.github.io/docs/getting-started/query-validation. Do one if u want to submit a new PR?. i should also note i was having significant troubles running the tests with netcoreapp1.1. the test runner was taking several minutes to start. this was reproducible in both the VS test runner and the r# test runner, and on 3 diff machines. @joemcbride any guesses as the the test failure? it passes locally. Ok seemes to have passed due to a new build triggered by a rebase. \nSo i assume that test is flakey. So only support net standard 2.0?. replaced by https://github.com/graphql-dotnet/graphql-dotnet/pull/969. @joemcbride ok with this one?. @joemcbride LGTM. IMO it is a breaking change, but given we have the netstandard change which is also breaking, i think we merge this and declare the next pending release v3. @maxmathews thanks :). @johnrutherford and @joemcbride any objections to this one before i move on to the next thing?. i should also point out that the current date parsing seems to be susceptible to ambiguous dates.  eg 09-10-2015. which i didnt think should be allowed under ISO_8601?. @joemcbride thoughts on this one. If we r going to change it we should do it as part of the major. Curious who creatthe open collective? Would like to get on a call and have a chat about the postives and negatives. #983 is merged. so closing this one. @bugged84 is this answered to your satisfaction?. Would it be better to pass the current httpcontext in to the graphql context when u initially execute the query? Then it will be accessible from all query/mutation parts. @vitaliitylyk does placing and resolving IHttpContextAccessor from the container not work in graphql?. @vitaliitylyk  i much prefer to flow the state https://www.planetgeek.ch/2016/04/26/avoid-threadstatic-threadlocal-and-asynclocal-float-the-state-instead/ rather than relying on ThreadStatic, ThreadLocal or AsyncLocal. i would prefer to remove usercontext and have only the dictionary, but didnt want to introduce a breaking change . @joemcbride any objections to merging this one?. Yep. Happy to rebase. But re the name, one alternative would be to change usercontext to a dictionary . Ok. I will do a new pr. @joemcbride do u want it as a ConcurrentDictionary, a Dictionary, or an IDictionary?. uploading a small solution that illustrates your problem would be helpful. @joemcbride thoughts?\n. @joemcbride awesome. Thanks. looking at AppRepository how would anything ever initialize _db. hence it will always be null. \nas for resolving your dbcontext in a field. you should pass it through the UserContext. similar to what is done here https://github.com/SimonCropp/GraphQL.EntityFramework/blob/master/pages/configuration.md#dependencyinjection-and-aspnet-core\nvar executionOptions = new ExecutionOptions\n        {\n            Schema = schema,\n            Query = query,\n            OperationName = operationName,\n            Inputs = variables?.ToInputs(),\n            UserContext = dataContext,\nthen extract it in the field resolve\nresolve: context =>\n            {\n                var dataContext = (MyDataContext) context.UserContext;\n                return dataContext.Companies;\n            });\n. @deborapoh did you resolve your issue?. > Can I use graphql-dotnet to set up a gateway for multiple web services\ncan u clarify what you mean by that?. @joemcbride any objection to me merging this?. @cRUSHER-HLG this project already supports .net core. so we can close this?. @sungam3r that only effects people who want to contribute to this project. Consumers of the nuget can use any c# version they want. adding a new nuget as part of a \"spelling fix\" PR seems a bit heavy handed?. My intention here was not to \u201calso test against 2.1\u201d. It was more to get the benefits of build and runtime perf improvements of 2.1 in the context of tests\nWith that it mind. Do u still want to multi target?. Afaik netore handles this scenario correctly. Ie it will redirect to the correct assemblies at run time \nAlso when i left it the 45 condition it would not compile. Yep. I updated the sdk in my netcore 2.1 pr. I will rebase this one after netcore is merged. i assume we consider changing a base type a breaking change?. ",
    "drobertson123": "I would like to add that it would be good to keep the internal dependencies of GraphQL as independent of the DI system as possible. We should be able to create a JSON version of the Schema and register the data sources using that. \nIdeally this would work by injecting schema fragments into GraphQL that let the service know what and how those registered objects would provide data. Each data source would do this independently and GraphQL would assemble the overall Schema for the service.\nQueries and Mutations could be sent to the Data Source objects in the same way. GraphQL's primary responsibility would be parsing the requests, routing the requests to the proper sources and consolidating the data for the reply.\nGraphQL Data Sources would need to comply with a set of Interfaces. These could be published in a completely independent GraphQL Data Source SDK project that would be used both in GraphQL and in any outside implementation of a Data Source object.\nIf you keep the SDK limited to just Interface definitions and some minor utility code you could drop the dependency requirements for the SDK to a very low level. This would decouple GraphQL from the Data Source objects and allow the developer a lot of leeway.\nIt would be good to avoid having lots of GraphQL internal objects required for the implementation of a Data Source. That would make it harder for both sides to change later. \nSorry for the essay, just my 2 cents.\n. I understand that timelines are tough, especially on open source projects, but the details you just gave are very helpful. Thanks for that and keep up the good work.\nI was hoping the new parser would replace Antlr before I got going but that isn't a huge deal. It will be nice to have that dependency gone.\nI will be using graphql-dotnet in a prototype project over the next 3-4 weeks. My goal is to create a test replacement of a current API that is a mix of ASP.NET MVC and Razor. I would really like to move to a React.js front end and GraphQL-dotnet on the backend. \nIf I can get a better handle on how everything works and free some time I would be happy to pitch in. This project does a great job of meeting a specific need I have. Thanks.\n. great, I will work from that one. Thanks.\n. Just an odd side note. Seeing this same conversation about casing happening in multiple disparate repositories. I guess casing is the new Tabs vs Spaces fight.  :-)\n. @tlil87 That sounds great. Not trying to rush anyone. I just would like to use a similar structure to what you are doing if it makes sense.\nI will keep an eye out on the conventions repository.\n. I am also taking a look at GraphQl.SchemaGenerator for inspiration. If anyone has any additional thoughts I am open to them.\nMy project goal is to create a framework that would allow me to wrap backend data sources that emit objects with an Attribute/Reflection based schema generator that would work in a GraphQL server. This will be based on a Dependency Injection model and ideally allow for runtime plugging/enabling/disabling of data sources.\nMy current target is graphql-dotnet, but I would also like it to be able to put out generic schema fragments that could be used somewhat universally.\n. Just my 2 cents, but I would prefer this to be part of the main project. We are already seeing instances of outside projects getting out of sync and unusable.\nIf this is integrated into the main project then it is naturally part of the upgrade cycle.\nThis doesn't feel like an 'optional' way of doing something or even added functionality. These feel like a significant improvement to the way the system would get data. \nIs there a use case for not using this? If so I would be more open to a separate project.. Thanks Joe,\nIs there anything I can do to test this further and help dig into the problem. It makes sense to me that the errors should bubble up, but as far as I can tell they are getting lost someplace.\nFrom my perspective, it looks like the context object is somehow getting lost or disconnected. Anything I add to it inside the Resolve is gone once the Resolve finishes.\nI will do some more testing and see if that is the case. . Before you waste much time, it looks like the context object is working and errors are bubbling up. I am not sure what the difference is, but this is a different outcome from what I was seeing earlier. I think I was testing against the Nuget package earlier and now I am working with the latest code directly.\nI am looking at a slightly different problem related to this.  It seems like if there are any errors at all in the results from the DocumentExecutor then no data is sent with the request.\n{\n  \"data\": null,\n  \"errors\": [\n    {\n      \"message\": \"Operation Error: test\"\n    }\n  ]\n}\n vs no errors\n{\n  \"data\": {\n    \"files\": [\n      {\n        \"fileName\": \"2017_June.zip\",\n        \"size\": 551923895,\n        \"location\": \"FTP\",\n        \"fileType\": \"Monthly\",\n        \"fileDate\": \"2017-06-01T00:00:00Z\"\n      },\n      {\n        \"fileName\": \"items_20170505.zip\",\n        \"size\": 25948808,\n        \"location\": \"FTP\",\n        \"fileType\": \"Compressed\",\n        \"fileDate\": \"2017-05-05T00:00:00Z\"\n      },\n      {\n        \"fileName\": \"items_20170508.zip\",\n        \"size\": 25250319,\n        \"location\": \"FTP\",\n        \"fileType\": \"Compressed\",\n        \"fileDate\": \"2017-05-08T00:00:00Z\"\n      }\n    ]\n  }\n}\nIn both cases the only difference is if there is an Error in the ExecutionResult.Errors collection. In both cases the result object contained the same data and both cases the response was being sent as an Ok(result).\nreturn Ok(result);\nBased on my reading of the GraphQL spec this doesn't seem to be the correct outcome for a request that contains errors.\n7.2.2 Errors\nThis is a bit different from my original Issue. I would be happy to have this issue closed and I can create a new issue focused on the response problem if that would help keep things organized. \n. It looks like that is the problem. Based on my reading of the GraphQL spec errors section I think that the document should return data even if there are errors. A small change to writeData in the ExecutionResultJsonConverter could fix that.\n```\n        private void writeData(ExecutionResult result, JsonWriter writer, JsonSerializer serializer)\n        {\n            var data = result.Data;\n        if (result.Errors?.Count > 0 && data == null)\n        {\n            return;\n        }\n\n        // Remove this section or make it configurable\n        //if (result.Errors?.Count > 0)\n        //{\n        //    data = null;\n        //}\n\n        writer.WritePropertyName(\"data\");\n        serializer.Serialize(writer, data);\n    }\n\n```. Thanks for the quick response on that.. I finally had a chance to pull the nuget and do some tests. Everything looks like it is working fine.\nI can add errors from inside resolve, they make it back up to the ExecutionResult and the JSON conversion now includes both errors and data as expected.  Thank you for the help.. Just my 2 cents. I would certainly love more documentation, but in my experience, it seems like XML Documentation has a tendency to overwhelm the code and make it harder to follow.\nIn many cases, the XML docs just state what is already there and little effort is put into adding the knowledge and context that needed to understand what is actually going on. I can figure out a method signature easily enough. What I would like to get from any documentation is the context for using the code. What is it used for, is there anything special in the way it works, are there side effects from interacting with the objects/code, etc...\nI am not saying that XML docs are horrible or that in this case they would be a bad idea, but there is a tradeoff when using them. Code files explode in size with less code per screen space vs the comments in the file.\nAside from disagreeing (generally) with the idea of XML docs I think more documentation and information would be a wonderful thing. I am happy to pitch in to help some if that is useful.\nPersonally, I like the idea of more of a Living Documentation approach to the documentation. I believe Marten uses this. The basic concept is combining markdown files with a tool that renders them into a website containing the documentation (github pages). The markdown has syntax for linking directly to code examples that are rendered into the HTML documents as you go. The focus would be on writing good documentation of the software concepts and using descriptive Tests as the embedded code to show how things are done.\nIf the tests get out of sync with the markdown due to code changes it becomes fairly obvious and the markdown can be revised. Knowing that the tests are likely to be visible in the documentation encourages people to make well written and expressive tests (hopefully).\nStoryteller seems to have a good system for this. Jeremy Miller has an article on doing this. How I\u2019m Documenting OSS Projects\n. To be fair, I have been trying to get motivated enough to use st-docs on an internal project. I really like the concepts and it seems like a very sensible aproach, but I haven't gone throught setting everything up yet. So all I have is opinions.\nIf I get it done I can share anything I learn back here.\nIn an open source project, having a list of methods isn't that useful. I can get most of that right from the code base. Documentation that helps a user understand the concepts and process flow is much more valuable, especially in this project. I have followed data front to back in debugging sessions and it jumps around a lot in graphql-dotnet. Having some good documentation that explains it all would be a big help.\nI can see two types of documentation. The conceptual docs would help explain how and why it works the way it does. Ideally putting the major sections of the code in context so new devs can come up to speed faster and contributors could help sooner.\nThe second section would be practical how-to focused information. st-docs could tie the topics directly to relevant unit tests as examples of how something is done. The unit tests would need to stay current as code changes so the documentation would be partially self updating.\nThe real hard part is how to do documentation without it being a serious time suck. Better yet, how to get motivated contributors to do a lot of that work for you. You and this project need more minions.\n. @joemcbride I am playing with setting up Storyteller for documentation in one of my projects and I need to do some tests. The GraphQL-DotNet project would be a great functional test of what I want to do.\nI could do a branch of the project and set up the living documentation system from storyteller. It would involve adding a Documentation project and would have some dependencies for storyteller. I am not entirely sure how everything would go together with GitHub, but I am willing to try it out.\nMy thought is that if the setup goes well it could be pulled back into the main project.\nI am happy to do it (it would help me), but before I put the effort in I wanted to see if you are interested in this solution at all. No big deal either way, but if it works I would like it to be useful.. I have no issue with focused use of XML docs. The key is that they should actually add value instead of just being autogenerated placeholders that make the code impossible to read.  I have seen way too many projects where the screen real estate was more than half un-informative XML docs and comments. It actually reduces your ability to understand the code when the code gets so spread out. \n@joemcbride I will Branch the code and start playing with st-docs as a test project. If I can get it into a useful setup I will send it over to you. Maybe something will come together and we can do a PR. \ngraphql-dotnet has matured pretty nicely. It is time that it has a solid set of documentation to go along with it. I will see how far I can get. If I run into a wall I may reach out to you for your contacts in that project.. @joemcbride I am working on some documentation process ideas. I have a quick question. What was your intent with the YAML in the new docs? Did you want to use jekyll or are you open to a different approach?\nI was working with a st-docs system or possibly a pandoc based transform so far. Any thoughts would be welcome.. Just a small request regarding the title of this post. Can we keep the politics out of here?\nThe post title may seem like a small political joke but I would rather have this focused on GraphQL than have politics dragged into every corner of my life. I feel like I am getting PTSD from all the politics these days.. Note - I took some of this from comments I made in Conventions. Sorry for the cross post.\nI have been thinking about the Conventions library and graphql-dotnet. I think it could really use a place inside the main project. Possibly as a tightly connected subproject.\nWhat I am suggesting isn't to make Conventions the only way to use graphql-dotnet, but to integrate some of its core concepts and to make it a directly available first choice way to use graphql-dotnet. Right now the projects are getting out of sync and it is impossible to use Conventions with the new GraphQL 2.0. By bringing it into the project it would be easier to keep it up to date.\nI understand the idea of keeping graphql-dotnet pure and focused (a good goal), but the industry is already expanding beyond the GraphQL spec with features that are being widely adopted. Apollo has many features like this. As long as the outside interface stays true to and only expands the GraphQL standards then I see additional features as a good thing (as long as standard GraphQL always works as a base.)\nThe .NET side also has a disadvantage. We don't have the huge ecosystem of NPM and similar packages of small tools. Nuget is great, but it is more focused of full-fledged libraries. NPM fills in the gaps for connecting to back-end data. We don't have as full a toolset on the .NET side (at least for GraphQL.)\ngraphql-dotnet has focused on being a direct copy of the javascript implementation from the beginning, but .NET isn't javascript and the approaches to programming in the environments are different. I think this has hurt adoption of graphql-dotnet. The initial learning curve is harder than other libraries because of the conceptual impedance mismatch between javascript and .NET concepts.\nIn my mind, this argues for a more feature rich connection to the data and business layers. Conventions could be an effective part of that. It could give a more familiar approach to regular .NET devs right inside the graphql-dotnet system.\nPlease don't take any of this as criticism of graphql-dotnet. I love the project and rely on it now for some big projects I am involved in. I just believe that this change would increase adoption of graphql-dotnet and hopefully bring more devs in to support the efforts. The more interest, the more it will grow and get better. I want to see that.\nKeep going and good luck on everything.. Conventions is a good project but I am open to any approach to smoother binding between GraphQL and the data/business layer. That is my greatest pain right now. Looking forward to seeing more changes in the future.\nI seriously wish I could contribute more but I am buried in the middle of an early stage startup right now. When things settle down I would enjoy giving back to this project. It has been a great base for what we are doing. \nI do have some work that may/may not be useful to the users. Mainly I am trying to simplify the process of schema creation, configuration and DI in an ASP.NET Core 2.0 server. Is there a way to share those items that would be useful?\nIf the concepts are useful it would be great to hand them off. I may even be able to do a PR if it is worthwhile, but I don't have the bandwidth (or temperament) to do a fully supported extension project.. @jquense That is similar to the approach we are using now. We have a GraphQL project that is entirely focused on bringing all the pieces together.\nWe define the Types, Queries, Mutations, etc local to the project that is working with that data and then weave them together into a master Schema in the GraphQL project. ctor DI is our general approach also but I am hoping for some flexibility to use a configuration file to say what goes in and what doesn't. These aren't exclusive of each other but we haven't hit the sweet spot on these issues yet.\nOur outside data sources are less than reliable. We have built in a lot of data redundancy but switching back and forth is still a bit of a challenge. Flexibility is a key issue for us.\nI am hoping that other people who have dealt with larger GraphQL systems could share some ideas and experiences. Even better would be some code examples for ways they have dealt with problems. . also, here is a super easy thing to just add;\nhttps://www.nuget.org/packages/GraphiQL/\n. I absolutely want to add many upvotes to this. We are configuring a GraphQL server from multiple data projects. It is extremely easy to overwrite a type and cause a bug that is almost impossible to track down.\nI would much rather have to deal with an exception than the mystery result that happens later in the process.\nAs a non-breaking alternative, I would be open to a different method for registering the Types. A SafeRegister method or something like it.\nThis goes for any area that has the same type of collection overwrite code. By allowing an overwrite it creates an opportunity for lots of unintended consequences. This should be an anti-pattern;\ncollection[name] = thing   . After doing some research I can see where this could be a fairly major undertaking. On the surface, it looks simple but there are valid arguments for overwriting registrations. There is also the complication of precedence in registering types.\nAutofac has an excellent discussion of a similar (but not exactly the same) topic;\nDiscussion: ContainerBuilder.Update Marked Obsolete\nI actually like their eventual solution. They added two extension methods that helped get around the problems;\nRegistrationExtensions.IfNotRegistered Method\nAttaches a predicate such that a registration will only be made if a specific is not already registered. The predicate will run at registration time, not runtime, to determine whether the registration should execute.\nRegistrationExtensions.OnlyIf\u00a0Method\nAttaches a predicate to evaluate prior to executing the registration. The predicate will run at registration time, not runtime, to determine whether the registration should execute.\nThe core idea would be to add these extension methods for cases where more control is needed over the registration process, but the main function would remain the same.\n. @joemcbride \nI am wondering what your thoughts are on the two extension methods or a similar idea.\nIf it seems to be worthwhile I can take a shot at doing a pull request for them. One thing that would be helpful is pointing to where you would see something like this living in the code.. I would second this and possibly go a bit beyond.\nVersion 2.0 would be a good time to define what is and what isn't part of GraphQL and also set some ground rules for extensions, API's, etc. A basic philosophy document that makes it clear for contributors how things should be done and why they are done that way.\nI really appreciate GraphQL. It is a great project, but it is developed in a confusing mix of C# and javascript conventions. That isn't surprising considering where it came from, but I think it leads to confusion and makes it challenging for people to contribute to the project.\nA basic developers bible with clear rules for how GraphQL is built would go a long way towards getting more help for this project. Other more traditional projects may get away without doing this, but graphql-dotnet is a challenge to dive into.\nI don't think many of us came from the javascript/node world looking for a C# implementation of the GraphQL javascript example project. I know my motivation was that I wasn't strong in javascript/node but I wanted to find a way to implement a GraphQL server in the C# and ASP.NET core world I was familiar with.\nThis has made understanding GraphQL-dotnet much harder than other projects. There is an impedance mismatch between what I expect to see and the way this follows some javascript idioms. Over time I have learned but it was a steep curve in places.\nGraphQL-dotnet is hitting it's 2.0 phase now. Establishing a clear vision of how the library works and is developed will make it much easier for others to help and encourage adoption.\nJust some thoughts. . @joemcbride Sorry for the slow response. It has been a hell week.\nI think one of the main differences is how graphql-dotnet feels like layer after layer of object resolvers. Each piece of the system requires multiple calls to look up an object type, or converter or handler. In fact, it feels like the whole system is an intricate IoC mapping scheme.\nThere is absolutely nothing wrong with this and it is one of the reasons why it can be so powerful, but this approach is mind bending when you are coming from a more traditional hierarchical object-oriented world. I know that made me feel like I was heading down Alice's rabbit hole when I first started.\nIt is a bit strange to think that I am not making a call to a specific class, but instead making a call to one class implementation out of many possible ones that will be there when I need it and is based on the resolvers finding the right one based on the type of data. You can do this in C#, but it is far from what you normally expect in .NET code.\nThe next one I actually like a lot and have started using, but it is an uncommon way of doing things in C#. Using generics as a way to pass a type as a variable to be used in a method.  Example;\nField<ObjectType>();\nNormally variables would be passed as parameters of the method and the Generic Type would define some object that acts on those variables. In this case, the Generic Type is acting as the variable itself. It is specifically what you want to pass in.\nField<ObjectType>() is also an example of something that was confusing for a different reason. This is probably because I have programmed in one way for such a long time that changes hurt my brain. For the longest time, I couldn't figure out what you were doing with all those Nouns in the constructor.\nI had always been taught that you used Nouns for properties and Verbs for methods. It was such a simple thing, but I couldn't get my head around the fact that Field<ObjectType>()was actually adding the object type to the collection. In my mind Field is something and AddField does something.\nNow that I work in Javascript more I see these things everywhere, but they tripped me up a lot as I was trying to figure out what is going on.\nOne thing that would help is an introduction to the flow of how the whole system works. Including the concept of the resolvers and how everything works together. When you are first dealing with graphql-dotnet it is hard to get your head around some of those things. The nearest concept is a DI/IoC container and not everyone is familiar with using those.\nObviously, these are my perspectives. Other people will have different views.\nOver time I have come to really like graphql-dotnet and we are using it at the core of a major project. Hopefully smoothing out some of these things and adding documentation that clarifies the basic concepts will help more people use it and contribute to the project.\n. ",
    "rahuljadhav": "We are using 0.5.1 version. It is working fine in current version. \nThanks for quick reply.\n. ",
    "isaachaw": "I passed in the value as the inputs parameter to the DocumentExecuter.ExecuteAsync directly without the ToInputs helper function. I think that might caused the problem.\nI found another issue when the value is passed in to the query without the parameter.\nE.g.\nquery AnotherQuery { GetUser(userid: 10001) { id, created_dt, username } },\ncontext.Arguments[\"userid\"] returns 10001 which is correct.\nHowever, when long value is passed in,\nquery AnotherQuery { GetUser(userid: 1000000000000001) { id, created_dt, username } },\ncontext.Arguments[\"userid\"] returns 0.\n. Hi, I think you misunderstood. In my last finding, the argument key userid does exist in the arguments list, however if the value given is long type eg.1000000000000001 , it is parsed to 0.\n. Thanks for the fast response. I have tested with 0.9.1 and the problems are gone.\n. ",
    "yon86": "thank you\n. ",
    "CCarminati": "Hi Joe, thanks for your quick response.\nIt was my mistake because I was confused about instruction under GraphiQL to emit \n\nnpm install\nwebpack --progress\ndoing it in GraphiQL folder, not in the root of the project as you say. :(\nSorry about this.\n\nRegards\n. ",
    "acjackman": "Thanks @JarnoNijboer and @joemcbride!\n. ",
    "bkniffler": "I've been looking for the same in this repo, but it doesn't really seem to be the purpose of this library. If someone is interested, I created a very simple example graphql client here, maybe it will help you get started with your clients: https://github.com/bkniffler/graphql-net-client. ",
    "wis": "Hey Great job @joemcbride. I can't wait for .NET Core support!\nit seems ANTLR 4 is on its way to support .NET Core soon, see #antlr4/1114 & Nate Mcmaster a entity framework core member opened that issue. \nEdit: I just read issues 2 & 43, Never mind.\nisn't it feasible to create a .NET Core Native wrapper library for the c++ parser? you benefit by not having to implement every feature in the specification and having to maintain it. \n\nIt can be used on its own in C++ code (or in C code via the pure C API defined in the c subdirectory), or you can use it as the basis for an extension module for your favorite programming language instead of writing your own parser from scratch.\n. @dNetGuru  Cool. push it to a repo.\nI remmember I saw in KestrellHttpServer uses Libuv, with some Interop. Libuv is written in C and C++.\nin dependencies in project.json there is \"Libuv\": \"1.9.0\", I think this is for the platform specific Native binaries[1] for Libuv that they reference in the dllimports see Libuv.cs#L494\n\n[1]\n. in a MVC application, you might want to short-circuit the middleware pipeline after you return the response\nby not calling \nawait next(context).ConfigureAwait(true);\n. ASP.Net-Core-GraphQL-Middleware\nworked flawlessly \ud83d\ude06 Now next: How to integrate with Entity Framework Core? & efficiently?\nshould I use a Repository Pattern?\nwill you :shipit: an official Middleware supposedly under GraphQL.Middleware namespace in the next \ud83d\udce6?\n. in a MVC application, you might want to short-circuit the middleware pipeline \nby not calling \nawait next(context).ConfigureAwait(true); \nthe implementation seems to be application specific\n\npublic async Task Invoke(HttpContext context)\n        {\n            if (context == null)\n            {\n                throw new ArgumentNullException(nameof(context));\n            }\n            if (ShouldRespondToRequest(context.Request))\n            {\n                var executionResult = await ExecuteAsync(context.Request).ConfigureAwait(true);\n                await WriteResponseAsync(context.Response , executionResult).ConfigureAwait(true);\n                return;\n            }\n            await next(context).ConfigureAwait(true);\n        }\n. ",
    "dNetGuru": "I can look into the C++ route for you.\nMind you that having native assemblies will make it platform/arch dependent and would require distribution of the compiled native assemblies with the packages.\nUsing protocol buffers might look attractive in this case as well.\nCan you clarify if you are waiting for Antlr's port to .Net Core or if you are thinking about getting rid of Antlr?\n. Today I had some free time and got the parser to compile on win32 with minor edits to the source/headers and it works perfectly.\nHowever after I tried integrating the resulting library into a CoreCLR project I ended up facing a lot of problems and some digging led me to https://github.com/dotnet/coreclr/issues/641 and https://github.com/dotnet/coreclr/issues/659. I guess if the objective is to support .Net Core then this approach is not going to work.\nLet me know if you want to take a look at the parser compiled for win32.\n. Just out of curiosity.\nIs the conventions package published anywhere? What about the schema generator?\n. I'm working on this!\n. I worked on different ways to compute the complexity of a query including the ones on Sangria and decide if it is suitable while keeping the performance overhead minimal and I settled on this approach:\nEnd nodes are scored based on the average impact of resolving each field and their depth (i.e. how nested they are) in the following way).\nComplexity of Node = (Average Impact) ^ Depth of the Node\nThis way a query such as query { A { B { C D } } } assuming that on average (or by a hard-coded maximum) each Field would have two graph objects returned (of any type, including lists) we will have the following results:\n```\nComplexity: 22\nSum(Query depth across all subqueries) : 2\nField{name='A'} : 2\nField{name='B'} : 4    // There will be on average 2 A's each having 2 B's\nField{name='C'} : 8    // There will be on average 2 A's each having 2 B's each having 2 C's\nField{name='D'} : 8   // There will be on average 2 A's each having 2 B's each having 2 D's\n```\nWhich simply shows that if every query returns the maximum (two) objects then we will be dealing with 22 objects maximum returned.\nFurthermore we know the level of nesting which is 2.\nReducing the level of nesting will allow the query to have more fields. For example this query query { A B C D E F G H I J K } has the same complexity value of the previous query (returns on average 22 items) but with less nesting (here all fields have an assigned complexity of 2).\n. In the event that there are multiple queries the query depth will reflect the sum of all sub-queries. For example:\n{\n  empireHero: hero(episode: EMPIRE) {\n    name\n  }\n  jediHero: hero(episode: JEDI) {\n    name\n  }\n}\nHas a query depth of 2 and Complexity of 12.\nI did toy with the idea of passing a list of \"expensive fields\" or fine tuning each and every field's complexity value but it seemed like a faster heuristic would be preferable in most cases. A IComplexityAnalyzer can be implemented for the edge cases.\nThe complexity value can be audited for a period of time to establish a baseline for normal distribution of query complexities and then locked in to detect anomalous queries. For this reason I think it would be a good idea to report back the complexity value to the user in th execution result so users can fine tune the allowed complexity on the fly if it fits their application.\nAnother issue is that the complexity analysis routine would be vulnerable to DoS attacks itself. Since I use recursion to traverse the AST, a maxRecursionCount can be passed to the ComplexityAnalyzer's constructor which prevents it to loop through more than that number of elements in the tree. This has a defualt value of 100, which is more than enough for almost all cases. (GraphiQL introspection takes ~96). An InvalidOperationException is thrown if traversing the AST takes more than maxRecursionCount to protect against DoSing the ComplexityAnalyzer.\nKnown limitations: if a non-inline fragment is included it can skew the results of complexity and depth. I will resolve this soon after I do some code cleanup and find some free time.\n. Sure typing. I'll do more testing and add support for fragments this weekend.\n. Added a lot more to the PR!\nThe only remaining issues are queries like this:\n``` GraphQL\n{\n  hero {\n    friends {\n      ...A\n    }\n  }\n  human(id: \"1\") {\n    ...A\n  }\n  droid(id: \"4\") {\n    ...A\n  }\n}\nfragment A on Character {\n  id\n  name\n  friends {\n    id\n    name\n    friends {\n      id\n      name\n      friends {\n        id\n        name\n        appearsIn\n      }\n    }\n  }\n}\n```\nI'd say the complexity of this query should be (2+avgImpact) * (complexity of fragment A). I'm writing the code to handle this but I don't want the complexity analysis routine to impose any noticeable overhead.\n~~And there is also the issue of limits (like Sangria's example).~~\n~~Do you think if I should look for the arguments in the AST and override the impact of a field if it has a \"first\" or \"last\" N argument? I personally think this is not a good way to approach this problem. For example assume if we were to add a \"limit\" argument to the \"friends\" field in the StarWars schema now think about the following query:~~\n~~Now this causes the datastore to be queried 4 times (if everyone has at least one friend) but it will end up having a very low complexity due to the \"limit\" argument here. I'd say going with the number of average number of objects that are present in the datastore per field would be a better estimation since even if there is a limit or any other filter is present, the datastore still has to scan over ~(average number of objects per entity) number of objects to find the results anyway.~~\nI'm open to suggestions on this matter if you think otherwise.\n. Fragmented queries are now fully supported.\n. The ComplexityMap dictionary has a detailed account of each AST node with its calculated complexity. We can use this to show the most complex nodes to the user (when throwing an error etc.)\nFor now I'm just printing the complexity and depth to the debug console. I'll add more functionality soon.\nSee the test cases for more info.\n. Testing the completed concept: https://github.com/dNetGuru/graphql-dotnet/blob/master/src/GraphQL.Tests/Complexity/ComplexityValidationTests.cs\n. Fragments are now supported. All tests passing!\n. No problem. I'll pull the new changes and fix any conflicts before this weekend\n. I really like the new outline of the library! Awesome work.\nI ended up having some spare time so I ported the changes and all builds/tests are passing now. I did also make a call to metrics.Subject(\"document\", \"Analyzing complexity\") (to be consistent with the rest of the file).\nIt doesn't take more than a millisecond to run the complexity heuristics w/o a debugger attached (in debug mode where calls to Debug.WriteLine in a loop would take ~30ms here https://github.com/graphql-dotnet/graphql-dotnet/pull/209/files#diff-c2e673b2d799880c33583cfba1f798daR37).\nHere's the data from executing the GraphiQL introspection query without a debugger (Release configuration):\n{\n    \"Category\": \"operation\",\n    \"Subject\": \"IntrospectionQuery\"\n    \"Duration\": 105\n  },\n  {\n    \"Category\": \"document\",\n    \"Subject\": \"Building document\"\n    \"Duration\": 1\n  },\n  {\n    \"Category\": \"document\",\n    \"Subject\": \"Analyzing complexity\"\n    \"Duration\": 1\n  },\n  {\n    \"Category\": \"document\",\n    \"Subject\": \"Validating document\"\n    \"Duration\": 33\n  },\n  {\n    \"Category\": \"execution\",\n    \"Subject\": \"Executing operation\"\n    \"Duration\": 70\n  }\nPerf data with DEBUG defined (attached to VS):\n{\n    \"Category\": \"operation\",\n    \"Subject\": \"IntrospectionQuery\"\n    \"Duration\": 972\n  },\n  {\n    \"Category\": \"document\",\n    \"Subject\": \"Building document\"\n    \"Duration\": 0\n  },\n  {\n    \"Category\": \"document\",\n    \"Subject\": \"Analyzing complexity\"\n    \"Duration\": 30\n  },\n  {\n    \"Category\": \"document\",\n    \"Subject\": \"Validating document\"\n    \"Duration\": 911\n  },\n  {\n    \"Category\": \"execution\",\n    \"Subject\": \"Executing operation\"\n    \"Duration\": 31\n  }\n. I added some more logic to handle complexity changes when limits are imposed during pagination using these conventions: https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm (test cases here https://github.com/dNetGuru/graphql-dotnet/blob/5150fe845e53ef71d01d720f6877352fe9109bba/src/GraphQL.Tests/Complexity/ComplexityTestsWithLimits.cs)\nI'll try to write up some docs on this when I get the chance,\nAlso if there are any bugs, questions etc. about my contributions please let me know I'll try to provide a timely fix.\n. All tests are passing, everything seems to be in order. @joemcbride let me know if I need to change anything.\n. This was opened by mistake.\n. Awesome! Want me to write the \"Protection Against Malicious Queries\" section?. Added #238.. @joemcbride let me know what you think.. Sure thing! Let me know if you end up needing any help with this.. @kantora The ComplexityAnalyzer's routine was written with two requirements in mind! To be fast (aimed for sub-millisecond runtime) and for the heuristic algorithm to make the least number of assumptions about the backend. The problem is that we need to have an approximation of how complex a given query is WITHOUT doing anything that can lock/take resources which would leave to a DoS vulnerability. The extreme case being writing some routine that takes as much time as it takes to actually execute the query! That would give us pretty accurate results, but would defeat the purpose!\nI did experiment with various heuristics (some included a weight map passed into the function etc.) and ran a diverse sample of queries against them to find the best heuristic (that I could come up with) and the fastest one.\nNow I do not claim that this is the absolute best approach, it's the one that satisfied the requirement that I had set forth. For this reason there exists a IComplexityAnalyzer interface if you need to implement your own custom made function that makes all the right assumptions about your sepecific backend and environment.\nMaking assumptions as to what operation takes more time or if the approximation that everything takes constant time on average would be too much of an assumption about the backend. Keep in mind we just need a good heuristic, not an accurate value. Unless if an operation takes 1000% more time than another I'd say that would be an okay estimation.\nAbout adding a FieldImpact to every Field I would say that I would agree that it would give way for more flexible analysis without having to write your own function. It would be up to @joemcbride to decide if he'd want to do that. I would make the necessary changes to the ComplexityAnalyzer if Joe's okay with it.. > ...complexity can be counted as number of request graph nodes * field impact, so defining both parameters is redundant\nNo! I guess did write some docs on this (albeit in hurry). But the complexity is defined as the Sum of (Node's Depth * Node's Impact) over all depths (or all layers of the AST).\nSo no, that is not redundant, since if you have one you have no idea how nested a query is!\nThe docs are here! I'll write better docs hopefully when I have the time.. Quoting from the docs (the link I shared):\n\n\nThe query depth setting is a good estimation of complexity for most use cases and it loosely translates to the number of unique queries sent to the datastore (however it does not look at how many times each query might get executed). Keep in mind that the calculation of complexity needs to be FAST otherwise it can impose a significant overhead.\nOne step further would be specifying MaxComplexity and FieldImpact to look at the estimated number of entities (or cells in a database) that are expected to be returned by each query. Obviously this depends on the size of your database (i.e. number of records per entity) so you will need to find the average number of records per database entity and input that into FieldImpact. For example if I have 3 tables with 100, 120 and 98 rows and I know I will be querying the first table twice as much then a good estimation for avgImpact would be 105.\n\n\nYou see, the GetImpactFromArgs is not a workaround or anything! Since the impact is defined as the number of entities expected to be returned on average (I explained reggae in the docs elsewhere) to was crucial to handle the case were the averages didn't apple and that's when hard limits are imposed by the query on that number of expected returned items.\nAgain, I'm not opposed to including the value on fields. But delegates? Well, what kind of a method signature would you suggest? Besides, a method signature you're happy with would probably leave the rest of the users unhappy. I'm open to suggestions.. \"Some nodes are arrays - some are not, current estimation doesn't take this into an account.\"\nThat is completely untrue! If a node had children then the node and it's children are considered in the complexity!\nAbout the high impact nodes, sure that information can be passed through to the complexity analyzer without introducing breaking changes but can you show with example where it would introduce a meaningful load hence a vulnerability? I can fix this part with a couple of lines of code but I'd like to see if it's actually necessary!\nCould you also produce a schema/query example where this would be out of touch with reality? Mind you the complexity number is not really absolute!! It's a heuristic. You'd look at your average complexity out of any given schema and then allow for that plus some leeway.\nCan you produce an example where the current method fails? i.e. it doesn't do what it's supposed to which is weeding out abnormally big/heavy load inducing queries while passing through the normal traffic?. I thought more about your comment and I guess this feature isn't really that user friendly. It is optimized several times so it's hard to see the original reasoning behind it.\nI'm still very interested in seeing an example where this heuristic fails.\nI'll think about what I can do about this user friendliness issue. Perhaps a more through documentation would help.. I'll add that and tweak some other things to make this feature more extensible.. @kantora take a look at #312.\nI will implement the functionality to pass in a dictionary of very expensive fields to the default implementation of ComplexityAnalyzer in a separate PR soon (perhaps by this weekend when I find the time).\n/cc @joemcbride . The first part makes very little sense! The children are always taken into account. We check for them in every iteration. Give me an example where children are unaccounted for. An example query would help clear what you mean a lot.\nSecond part: read the PR's description which says \"In that example I implemented a dummy (the logic behind it is flawed for simplicity so don't use that in production)\"\nYou can't just not read these and assume things!\nYou can now pass the schema or anything you'd please by extending the functionality there. I've passed a dictionary (which isn't a copy of schema, it's just a list of expensive nodes and their cost, again just meant as an example). \nSimply use that PR's pattern and you can write any validation function for the Complexity analysts while passing anything you'd want to that function! I just made it easier to extend without any breaking changes attached with a crude example attached.. Oh, well I said in my first comment in this thread that I'd be open to that since it doesn't really break anything since it can be implicitly assumed to be set to one.\nNow there is one design decision that needs to be made here and that is about passing through the list of weights.\nOne option would be to generate a map from the schema from field names to weights (needs changing the schema) or only passing the list of more expensive items and their weights down to the validator and implicitly assuming the rest (means faster checks but much less user friendly).\nI'll measure the performance penalty of this to see which route to go and make the necessary changes hopefully by this weekend.. I'm still against delegates and the rest. It might have made sense there but I am not sold on it making a noticeable in detecting malicious queries.\nAdding a constant work multiplier for different fields yes, I'm goigoing to add that as soon as I find some free time.\nGoing through the context seems very wasteful! I'd look into calculating the complexity as the document is being executed and bailing if it goes over in that cad. Perhaps the current system could be the fast first pass and then a more thorough pass can be done during execution with the context in hand.\nHow close are you to finishing your implementation @kantora I want to take a look at it and see how your implementation holds.. Build seems to fail due to unrelated reasons! Complaining about https://github.com/graphql-dotnet/graphql-dotnet/blame/master/src/GraphQL.Tests/GraphQL.Tests.xproj#L7 (same as another PR #306)\n\ndotnet build src/GraphQL.Tests  -c Release\n.........SNIP.........\nC:\\projects\\graphql-dotnet\\src\\GraphQL.Tests\\GraphQL.Tests.xproj(7,3): error MSB4019: The imported project \"C:\\Program Files\\dotnet\\sdk\\1.0.1\\Microsoft\\VisualStudio\\v14.0\\DotNet\\Microsoft.DotNet.Props\" was not found. Confirm that the path in the  declaration is correct, and that the file exists on disk.\nBuild FAILED.\n.........SNIP.........\n    0 Warning(s)\n    1 Error(s)\nTime Elapsed 00:00:00.16\n\nBuild environment problems with the new tooling?. @joemcbride see https://github.com/appveyor/ci/issues/1377#issuecomment-287644271 to fix this problem.. I'll investigate this!. I was away for a while. So the main change in this PR is making the ComplexityConfiguration extensible so the user can pass through any info/object required to the analysis function they'd implement.\nI'm also going through the other PR to test it out.. ",
    "holm0563": "I like forward to seeing it thanks! We are in a similar situation.\n. Thanks. This is currently setup as a separate project. I like the idea of a separate nuget package as well. \n. https://github.com/holm0563/graphql-dotnet/blob/master/src/GraphQl.SchemaGenerator.Tests/QueryTests.cs\nThere is a test \"BasicExample_WithEnums_Works\" written here.  I haven't seen a good template to setup a custom schema and test. I started down that road but was having to re-architect a lot to accomplish it.\n. Thanks, that example helped. A test has been added for the enums.\n. @joemcbride  any updates on this? Also when do you plan to push an updated nuget package? Once that is done I'll start a new github project with my SchemaGenerator code and have this project included as a nuget reference. Just waiting on a few of these bug fixes. Thanks!\n. @joemcbride  the problem I run into is that any modification to the StarWarsSchema causes existing tests to fail. For example there is a full_schema_query() test written against it. So my solution was start another schema in the tests that doesn't have these dependencies. \nThe bug is directly related to how enums are handled in query arguments. The submitted test should clearly show this but I agree the amount of setup to do it is difficult either way. Either we start a new schema for testing or modify a lot of the existing tests so they are more focused and the star wars schema can be modified easier.\nThanks for the quick responses, let me know how you'd like to proceed.\n. Thanks @joemcbride  that was a much better spot for the test. Hopefully this is what you had in mind.\n. @joemcbride those suggested changes have been made.\n. @joemcbride, I've merged in the latest from the master. Checks are passing now.\n. @tlil87 does your project exist on github?\n. We are in a similar situation using this in production. I'd like to get this concept starter sooner than later otherwise we will probably run off the forked version for a while. If your solution is closed source it would be quicker to start with this one and move over additional functionality.\n. I guess I'm not familiar enough with how open source works. Whats the process to merging our two different ideas and making sure we have the best of both worlds moving forward? It definitely makes it difficult when this is closed source and no one else has the ability to contribute. This pull request is supporting our needs for this concept which include over 200 models converting to fields and 50 different queries and mutations.\n. Thanks for the clarification. I took it as a separate project not repo. I'll continue with that path. @tlil87 let me know when your project is done and hopefully we can come up with one standard approach. Thanks guys!\n. The schema generator is under my fork.  Once a few bug fixes are in place I'll move it to a separate project and just include this one as a nugget reference.\n. @mirhagk Check out https://github.com/holm0563/graphql-schemaGenerator\n. Thanks that helped. I think i did find a bug but I'm not positive on the solution. See:\nhttps://github.com/graphql-dotnet/graphql-dotnet/compare/master...holm0563:introspectionBug?expand=1\nThe issue lies with the __Type.cs checking two interfaces that then aren't being used. This prevents an inputobject from correctly displaying its fields.\n. Thanks so much @joemcbride. I was getting some weird issues with graphiql and introspection but I think I've found them now. I have the Schema generator fully working with this included as a nuget package and will work towards getting it setup as a nuget package of its own.\n. Thanks i'll plan on building this feature outside of graphql-dotnet\n. I also have a case where we dont want it converted to UTC. We report dates for other countries in their local time. So say its 1-2-2016 5:00 (EST). Converting it to UTC is based on the server time zone which could be (MST). To make it even worse DateTimeOffsets do not work because we would like this iso format returned to the client \"2016-09-19T17:00:00-07:00\" instead we would get a zulu time \"2016-09-20T00:00:00Z\" and now the client cant display the local (EST) time value. The hours aren't accurate in my examples but you get the idea. \nNoda time support for c# would help with these issues. \nI'd expected graph to work similarly to the asp.net date time parser.\narrivalTime=2017-02-16T04:00:00 (datetime.kind = unspecified)\narrivalTimeUtc=2017-02-16T09:00:00Z (this is the same datetime with datetime.kind = utc)\nhttps://msdn.microsoft.com/en-us/library/system.datetime.kind(v=vs.110).aspx\nThe proposed solution #198 would be better imho.. This is how we are currently solving the issue:\nhttps://github.com/holm0563/graphql-schemaGenerator/blob/AsReference/src/GraphQl.SchemaGenerator/Types/OriginalDateGraphType.cs\nhttps://github.com/holm0563/graphql-schemaGenerator/blob/AsReference/src/GraphQl.SchemaGenerator.Tests/Tests/DateTests.cs. I build a schema generator as well: https://github.com/holm0563/graphql-schemaGenerator. Note: My company (Navitaire) just finished load tests with these changes in place. Graph is now performing better then Rest in all categories including server CPU and response time. We typically have several web servers in a farm that handle quite a bit of traffic.. It seems like I originally had the opposite problem. Everything was running in series. See\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/452\nSpecifically:\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/452/files#diff-cd0bbfa3fdf59b53c127e4af8a76db8d\nDoes the version you are using have these changes in?. This is failing on test: ThreadPerformanceTests.Executes_IsQuickerThanTotalTaskTime which was previously skipped. My guess is its machine specific and needs two+ processors to run correctly. The test passes on my local machine. Any suggestions? This was not changed as part of this pull request.. This change is making GraphIQL not able to parse the introspection. Is anyone else having this problem?. Note after reverting this change set, graph iql works as expected.. @joemcbride should this be sent as a new issue?. @joemcbride i didn't look at the spec but I'd be shocked if its truly supposed to change to 'null' as a string?. Thanks, this would be faster since its a list and not an enumerable. @joemcbride \nIf I'm understanding right you would prefer something like:\nvar exec = new DocumentExecutor(new GraphQLDocumentBuilder(), new SkipDocumentValidator(), new ComplexityAnalyzer());\nI liked the flag idea since a SkipDocumentValidator is not part of this project.\nNote this change alone was responsible for most of the 600% improvements with the starwars query. Most of the time executing small queries is in the validation and would be a huge potential savings in a production environment.\nI am very curious on your thoughts. Everything I threw at it seemed to handle appropriately and just give back a more cryptic error since it wouldn't be able to parse the query. It does make me nervous as well, what kind of problems would we need to prevent without this validation?. This is mostly due to me using Resharper which somewhat realizes a null can be returned (although it shouldn't because of the previous check) and playing it safe with a null check vs throwing an exception.. Yeah i like this idea much better, this change was pushed.. Yeah i like this idea much better, this change was pushed.. Thanks @joemcbride . I'm understanding your point now. I still like it being easier since in production everyone should care about response times but like you mentioned if developers understand the issue they can still implement a custom validator. Maybe as a future update the default validator should be evaluated from a performance standpoint and/or implement a caching strategy.\nRemoving this features takes the StarWarsPerformanceTest speed improvement from 642% speed gains to 15%.\nFor our business needs we will plan on removing it completely, since our severs handle a very high amount of traffic.\nI've updated my branch. I think I have all of the changes ready that you suggested. Let me know if I'm missing anything.. Cool, that is very good to know. I was playing around with the idea of named queries. Good to know that is the direction Facebook went as well.. ",
    "alexmcmillan": "Sorry that was an artefact of my mucking around - changing from Date! to Date in the query makes no difference..\n. The request body generated by GraphiQL - you can see the fromUtc and untilUtc fields contain valid ISO8601 strings\njson\n{\n    \"query\" : \"query ($authorId: String! $fromUtc:Date $untilUtc:Date) {\\n  author(id: $authorId) {\\n    id\\n    posts(fromUtc: $fromUtc, untilUtc: $untilUtc) {\\n      id\\n    }\\n  }\\n}\\n\",\n    \"variables\" : \"{\\n  \\\"authorId\\\": \\\"879461\\\",\\n  \\\"fromUtc\\\":\\\"2016-06-27T00:00:00.000Z\\\",\\n  \\\"untilUtc\\\":\\\"2016-06-29T00:00:00.000Z\\\"\\n}\"\n}\n. 1. I'm working with a clone of your current master branch\n2. I am just incrementally modifying the types in GraphQL.StarWars (learn by doing!) and interacting with it via the included GraphiQL instance\n3. I added this field to HumanType (on a freshly-checked-out copy of master without any of my changes):\nc#\nField<StringGraphType>(\n    \"datetest\",\n    \"Testing whether a date can be passed as an argument\",\n    arguments: new QueryArguments(\n        new QueryArgument<DateGraphType>\n        {\n            Name = \"theDate\",\n            Description = \"French Toast\"\n        }\n    ),\n    resolve: context => \"I am a lineman for the county!!!  \" + context.Argument<DateTime>(\"theDate\").ToString()\n);\nthen fired the query \ngraphql\nquery getHuman($idValue: String! $theDate: Date) {\n  human(id: $idValue) {\n    datetest(theDate: $theDate)\n  }\n}\nwith arguments\njson\n{\n  \"idValue\": \"3\",\n  \"theDate\": \"2016-08-16T22:51:10.762Z\"\n}\nand received the response:\njson\n{\n  \"errors\": [\n    {\n      \"message\": \"Variable '$theDate' expected value of type 'Date'.\"\n    }\n  ]\n}\n. It does seem similar - but that appears to have been resolved?\nI am working in Visual Studio Professional 2015 v14.0.25123.00 u2 with .net v4.6.01038 on a Windows 10 machine.\n1. Destroyed my local copy of graphql-dotnet\n2. Freshly cloned git@github.com:graphql-dotnet/graphql-dotnet.git\n3. Built the frontend with npm install and npm start (using Node v6.3.1, npm v3.10.3)\n4. Opened GraphQL.sln in Visual Studio, set the startup project to GraphQL.GraphiQL\n5. Started the solution in debug mode, GraphiQL opened in Chrome v52.0.2743.116 m (latest) with the default query showing (droid with id 3 etc)\n6. Ran the default query and saw the expected results\n7. Stopped Visual Studio\n8. Added the Field from above to HumanType\n9. Started the Solution again, GraphiQL appeared in Chrome\n10. Updated the query and the arguments to those above\n11. Ran the query and got the exact same (failing) result\nCan you see anything that could be wrong?  Did I miss anything?  How does your environment differ from mine?\n. The problem is here.  \nPassing CultureInfo.InvariantCulture causes the date string (which by this stage is in the form \"16/08/2016 10:51:10 PM\") to fail to parse.\nChanging this to null or CultureInfo.CurrentCulture allows the value to parse (it becomes 2016-08-16T22:51:10.0000000 when calling .ToString(\"o\"))\nI am in New Zealand, and my timezone is NZST (GMT + 12)... assuming you are in a different timezone, that likely explains why it is happening for me but not you.\n. Is changing the second argument to CultureInfo.CurrentCulture an acceptable solution?  I can issue a PR\n. No problem!  Glad I could contribute to this awesome project :)\n. Okay I will update for that and fix the failing test case tomorrow.\n. Hows that?\n. I've been backed up with \"priority\" side-tasks, but I'll (hopefully) be back into it next week - i'll have a look into it then\n. Yeah.. I was a bit quick with my commit -am command :)  Will clean this up now\n. Done.\n. ",
    "mirhagk": "Has anything happened here yet?\nI'm interested in building an API on GraphQL but I'd really rather using POCOs than what the core requires writing for the schema.\nI have a feeling that there's probably a lot of other people in my same position who'd really only consider adopting it if one of these schema generators is up and running, so once one of these options gets published it'd be nice to see a reference to it on the main readme.  (I of course understand the reasoning to have it in a separate package)\n. Wouldn't this make having no errors (errors being null) default to showing error 400? That's what I'm getting when I run this locally. The result is working perfectly fine however.\nShould switch this to response.StatusCode = executionResult.Errors?.Count > 0 ? 400 : 200;\n. ",
    "wastaz": "Sorry, I was too quick here. It seems like this is not what I though it was. It actually only shows up when there is only a single doublequote, it seems to work fine otherwise. So this issue could be disregarded since I also opened this one which seems to be the actual problem. :)\nSorry for the extra issue.\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/154\n. ",
    "KoditkarVedant": "@joemcbride I would like to take a shot at it. I have started the initial work.. @joemcbride I was going through graphql spec for List and NonNull and noticed that as of now we do not handle it in out library.\nmyField: [String!]\nThis means that the list itself can be null, but it can't have any null members. For example, in JSON:\nmyField: null // valid\nmyField: [] // valid\nmyField: ['a', 'b'] // valid\nmyField: ['a', null, 'b'] // error\nNow, let's say we defined a Non-Null List of Strings:\nmyField: [String]!\nThis means that the list itself cannot be null, but it can contain null values:\nmyField: null // error\nmyField: [] // valid\nmyField: ['a', 'b'] // valid\nmyField: ['a', null, 'b'] // valid\nref\n@joemcbride should we track this as separate or should we consider as part of this enhancement itself. \nI am curious to know your thoughts.. @joemcbride Is it okay to keep those test cases failing or should I skip them from running?. > \n\n@KoditkarVedant I think its fine to have them fail, then when the build passes we know we've fixed it.\n\nDone.. @joemcbride what are your views on this? I really don't see any use case for this.. @joemcbride this is already been taken care in #741(PR #812). we are good to close this issue.. @joemcbride,  I think this issue is irrelevant now.. Hello @joemcbride, Is this issue is still up for grab I mean are we adding functionality to convert numerical string into boolean? If yes I would like to help.\n. Thanks, @joemcbride, I'll work on this and create the pull request.. @joemcbride I'm thinking of only considering \"1\" and \"0\" as a valid boolean string. What do you think? \nEarlier I thought of parsing string value which throws an exception while conversion and check if it is 0  then return false else return true I mean the way other languages like Ruby, Javascript consider 0, false, f, empty, null as false and rest all as true but not sure whether we should implement in this way. . Hello @joemcbride, Can you please look into this PR? Let me know if there are any changes I need to make.. Hello @joemcbride, completed the review changes.. Hello @joemcbride, I would like to understand in which case we want users to set the field name as null?\nCurrently, I have considered null as a valid field name, as it is currently allowed.. Hello @joemcbride, can you please look into this test case.\n\nThis test case occasionally fails, even on master branch.. @joemcbride, Updating the validator is a no-brainer. We need to change following Field methods in ComplexGraphType to accept the name argument.\n- FieldBuilder<TSourceType, TReturnType> Field<TGraphType, TReturnType>()\n- FieldBuilder<TSourceType, object> Field<TGraphType>()\nThis will give a compile-time error to existing users when they upgrade to this version.\nWhat do you think?. @joemcbride,  There is another approach I can think of is, Currently while adding the Fields using the FilderBuilder method we set the field name to null instead we can set some default name to like _ or default. This will not break the existing code written in the older version and even we make sure we have valid field name if the user doesn't pass name.. Hello @joemcbride, Can you please have a look at this PR? I have updated the code. Now it will throw an error if the field name doesn't match the spec, A null or empty name is not be allowed.. Sure.. Fixed conflict. Done. . Hello @joemcbride, I would like to work on this enhancement. Is it still up for grab?. @joemcbride why we are keeping two different classes ValidationError  and the ExecutionError. I was thinking to combine them as GraphQLError or GraphQLException.  \nCan you help understand what is the need of exposing this publicly to users? https://github.com/graphql-dotnet/graphql-dotnet/blob/1842756f1ef4b190c19994fb53f92fb80701968b/src/GraphQL/Validation/ValidationError.cs#L28-L36. @joemcbride I got it. I think we should have another constructor which do not accepts nodes. I feel it is very specific and mainly used by IValidationRule.\nWhat do you think about the PR changes? Did you get time to review it?. @joemcbride I have added PR for above request.. @joemcbride which icon we have planned to set for NuGet package? Is it a plain GraphQL icon or should we have a hybrid of .Net and GraphQL.. \n@joemcbride I see we already have icon URL in GraphQL.csproj file. So I think we should close this. what are your thoughts?. @joemcbride I am not sure why the checks failed for this PR. Can you please look into it?. I'll close this PR and create new one changing branch name. @joemcbride I have changed my branch name and recreated the PR. Can you please have look at it?. @joemcbride gentle bump\n. @joemcbride Friendly ping.. @cgatian I have created the PR for the issue. Please let me know if you had completed the changes and want to raise the PR. I would be happy to close my PR.. @joemcbride if I understand you correctly, do you mean even if NonNullable graph type returns the null it should test the complete IntrospectionResult (as currently present?) or do you want to add new/update the test case test case with no NonNullable graph type in the schema?. > \n\n\nupdate the test case test\n\nThis.\nYou should still get a introspection result even with nullable types/fields. I suspect the problem with the test is that it basically has no query/mutation/subscription.\n\n\nI have removed the NonNullableGraphType from from queryType field. I get results as expected. There is an additional test case was failing in SchemaPrinterTests which I fixed.\n\ngraphql-dotnet/src/GraphQL.Tests/Introspection/SchemaIntrospectionTests.cs\nLine 17 in 6ecd4f0\n _.Schema = new Schema(); \nIf you still get a top level null after a Query is added then there is a bug in the implementation.\n\nI will quickly check if I get null after adding the query.. > \n\n\nI have removed the NonNullableGraphType from from queryType field\n\nThat needs to be added back as it should be NonNull, according to the GraphQL-JS implementation.\n\nI have reverted that change & reset the queryType as NonNull. I have added the a TestQuery so we can still get a introspection result.. @joemcbride I will add some more test cases for the change.. @joemcbride FYI, I have completed the changes required and as suggested added the failing test cases for not working Non Null ListGraphType. @joemcbride this PR is now ready for review. I am not sure why commits from @SimonCropp are being displayed in this PR?. @joemcbride I have fixed it.. @joemcbride friendly ping!. @joemcbride we shall close this issue?. @joemcbride this PR is ready for review.. @joemcbride friendly ping!. @joemcbride I have completed the changes, shall I create separate PR or should I push my changes in #980 PR itself?. Merged into #980 PR itself.. @joemcbride I am not sure who to retrieve the total number of fields in the Fragment Spread? I tried to using the Children property of Fragment Spread but it always returns count as 0. I have also added the skipping test. Need help.. Hey @joemcbride, I have updated the code to handle the case if a Fragment Spread with multiple root field is present. This PR is ready for review.. @joemcbride friendly ping!. @joemcbride friendly ping!. I had caught the exception because the old Serialize method was always returning the boolean value.. Done.. Done.. Done.. Done.... ",
    "jquense": "Thinking a bit on this in general. It seems like maybe ultimately you'd want to be able to do GraphType<TSource>  so you can type Source for any field, instead of specifying it on each Field() call? Can the Source differ between the fields of a particular type?\n. thanks ya'll!\nI might take a crack at a generic GraphType if ya'll don't mind. I like the stuff in #91 btw, if only because it feels closer to the JS api i'm used too.\n. So i've been thinking a bit about this and it may be helpful to voice the stumbling blocks I ran into while working on this for the sake of getting a better api.\n- I think that the generic form better belongs to ComplexGraphType rather then ObjectGraphType, so ComplexGraphType<TSource>\n- I ran into issues with inheritance and typing trying that; there are lots of is checks on ObjectGraphType that would be harder if only ObjectGraphType<T> existed. There are also a few classes that have type constraints on ObjectGraphType as well that I don't think can be changed to ObjectGraphType<T> and compile\n- I couldn't think of a way to both surface ObjectGraphType and have it inherit ComplexGraphType<T> while also allowing ObjectGraphType<T> and have ObjectGraphType<T> is ObjectGraphType be true.\n- An interface for the sake of typing ObjectGraphType felt contrived to me (IObjectGraph, GraphType)\nAlso let me know if it's even worth going down this road, or whether it'd be more productive to help work on #91 :)\n. Thank's for helping out with this! So I've hit this from a few different angles now and have some thoughts. There are two big object types here right, Fields and GraphTypes Most of the derivations of the GraphTypes can be more or less neatly split into \"Abstract\", \"Types with Fields\", and \"Scalar\" or plain old \"GraphType\". The main issue is that in order to use Generics on the Fields to get the typed expressions, you end up needing to push said generic TSource up into the GraphTypes that contain Fields. This leads to a few parallel class heirarchies: \n- ObjectType : ComplexType -> ComplexType : GraphType\n- ObjectType<T> : ComplexType<T> ->  ComplexType<T>: GraphType\nOtherwise you end up new all the shared methods. That's not so much a problem except that the document execution logic, depends heavily on checking for specific GraphTypes. So now if you need to check of ObjectTypes, its a lot harder, and impossible to constrain other generic type defs to tho (such as ConnectionBuilder<T>  where T : ObjectType). Invariably ou need interfaces for each levels of Types, and need to switch all the execution logic to deal with IGraphType, and IComplexType. i messed around heavily with the next branch as well, and it does avoid this messiness in the Type classes, but mostly pushes it to the Configs. \nOverall I'm just unsure if this use of Interfaces constitutes a bad pattern. In some senses, having all the execution logic check for interfaces makes more sense, since it can be more explicit in which stuff it is interested in. Though there seems to be cases where there isn't a clear overlap, such as \"f is ObjectType || f is InputObjectType\" I suppose those are the two concrete complex types?\n. I do think the Field is not finished here, but I think the bones are there. I didn't want to presume changing all the API's without talking about it :P \nIt seems like perhaps now that expressions are possible for infering field data, maybe the none-fluent form of the FuncResolver api is less relevant? Part of the problem is that that API tends to start clashing with the expression one. The other conflict is that the Func/Builder apis use generics to specify the GraphType, which is a heck of a lot neater than: type: typeof(NonNullGraphType<ListGraphType<StringGraphType>>>). The nice bit about nexts use of instances is that it deftly avoids that but not dealing in Types.\nOne thought I had was to limit the non-expression API's to builders only, where you can more easily do Type<StringGraphType>().\n. :wave: gonna rebase to fix conflicts.\nI also was going to remove the ToCamelCase but that creates problems outside of just client json serialization. Field validation is also case sensitive and the schema fields will be in teh case you add them. \nI think for folks who want camelCase they want it in the schema in order to not fight the validation, or write queries in a different case then the payload actually is. To that end I imagine that you'd been the configuration option to be higher up than the json serializer, and I am not quite sure  how to go about that. It may be helpful to actually defer FieldType creation so that you can process the result\ncsharp\nField(builder=> builder.Name(\"fOo\"));\nvs\ncsharp\nField().Name(\"fOo\"));\n. Sounds like a plan \ud83d\udc4d  I'd like to at least start building some stuff on top of this.\nmy one sort of concern with instance based approach is that it makes defining stuff in seperate files much weirder. Seems like you'd end up defining classes anyway except now you need to call some sort of Init() method in the ctor. That may just be an artifact of the way /next is structured tho where the GraphType classes are more like builders and the Config is the real type data. \nThat being said i've been trying to mess around with some Relay types and things like Mutations are way more convoluted and confusing using classes vs instances. Cases where you wnat to augment the graphType given to you (in this case adding clientMutationId and adjusting the resolvers to add it to the output type from the input).\nSeems like it would be nice if you could mostly keep the current class structure, but you can/should new them for use inside of defining fields. At this point tho i'm just talking a bunch about stuff that is outside my wheelhouse :)\n. done rebasing! \nI'd also be happy to make an attempt at instance based things, but I'm a bit unsure how that changes the execution/building logic. i'm also fairly uncertain how to provide the right hooks for DI, ctor injections is the one i'm most familiar with.\n. related: it seems like you could handler recursive references via a closure, like the JS API.\n``` c#\nObjectGraphType DroidType = null;\nDroidType = new ObjectGraphType( =>\n{\n    .Name = \"Droid\";\n    .Description = \"Droid type\";\n    .Field(new ListGraphType(DroidType), \"friends\");\n});\n```\n. interesting...does that approach offer something over using a closure?\n. ahh good point ok. i'm not quite sure how to implement that (or port it from next) but i'l give it a shot when I have a moment. \nFor now how do you feel about this PR and could we get maybe an incremental release? Or prerelease if you want to bunch breaking changes together.\n. :tada: thanks!\n. I'm actually not really familiar with the new Core stuff. Does the .net core only work with .net core or can I use it in projects on 4.5 (where i'm stuck for stuff)?\n. My initial concern with the API is that sharing instances across c# is much more awkward than languages like JavaScript. And I'm not sure the Reference classes are a good way to address that.\n- We would want to validate that any type added has it's name associated with exactly one instance, however starting to port some of the existing schema over, its really easy to forget that each instance === one distinct type, especially when defining classes.\nc#\nField(new Human(), \"Boss\");\nField(new Human(), \"Spouse\"); // invalid\n- Using references in class constructors can lead to situations where the referenced Type is never actually registered with the schema and therefore unresolvable. overall that feels way to loose of a coupling, since you get no safety that what you are referencing will ever exist. I'm also vaguely worried about cycle issues with references referencing other references\n- You could solve this with DI and ensuring that your types are singletons but that feels like it leaves too much to the user to solve just to do it correctly. But i'm also not sure it makes sense to have an API specifically for type registration, and that isn't much different then Reference(\"human\") \nthis would all be less of an issue if it was easy enough to import a single instance of a type. I'm not sure about other folks, but we like to keep our types to one per file, which means we'd still be defining a lot of classes\n. Gonna close this for now since ya'll seem to have something in the works already (and frankly I've ended up preferring the class based model anyway). feel free to pick it for parts if helpful. added in #222 . o this also adds support for nullable type inference...I meant to include that in a different PR oops :P . oops with the merge commit, one second. :+1: should be gtg, wouldn't mind a quick release if you have a moment as well ;) (no worries if not). :bowing_man: thanks so much!. graphql.js gets away with calling it context because revolvers are passed a bunch of arguments (object, args, context, fieldInfo) but i like the graphql. dotnet approach better, naming things aside. also I was under the impression that what we call Root is what the js version calls context now. Not sure I understand what this gains you...mutations with object inputs were already possible, What does having an interface here enable that wasn't possible before?. @joemcbride can speak more intelligently about this, but I'm fairly certain that InputObjectGraphType and ObjectGraphType are intentionally discrete types per the GraphQL spec. It doesn't really make sense to have an InputObjectGraphType<TSource> since the source object is always a dictionary deserialized from a json object, as opposed to a data model object. I do see how it could be convienent to reuse the output types where they overlap but I'd also be concerned that it's conflating non-overlapping Types. >  Field(userInput => ((UserInput)userInput).Id)\nThe object there is not a UserInput its a Dictionary<string, object> You can define types without the generics api. e.g.\n```c#\npublic class UserInputType : InputObjectGraphType {\n    public UserInputType() {\n        Field(\"Id\", StringGraphType);\n        Field(\"Name\", StringGraphType);\n        ... etc.\n    }\n}\n``. doing the generic InputGraphType might cause errors in the resolvers as it'd expect the Source object is theTSource` type. I dunno, I see how it'd be useful for type definition but it seems weird to key off an object Type that isn't the actual backing type. Just my 2cents tho :). The problem is there is no correct tutorial. And adding a naive implementation would only lure ppl into a false sense of what a real implementation looks like. How you connect an API to a database is just as varied and fraught with GraphQL as it is with WebApi, it's also conceptually the same. \nWebAPI you fetch data in your actions and return it, you do the same thing with GraphQL, expect instead of actions you have resolvers. In most cases you probably are going to have a layer between GQL/WebApi and EF, e.g. repository and service patterns. Overall though you can apply all the knowledge you already have in building an API in front of EF and continue to use it here, but the details of how one does that aren't particularly amenable to simple demos.. sounds reasonable to me. might want to use more robust utils for the included case manipulations to cover a bit more edge cases. I'm partial to https://github.com/jquense/StringUtils :P. You can't create truly dynamic graphql types unfortunately. They are by design statically defined, otherwise the client would never know what it's gonna get back based on the type. Alternatively you can use a UnionType if you only have a set amount of variants of your type. In JavaScript land we generally handle this sort of thing with a custom JSON scalar like: https://github.com/taion/graphql-type-json. bit of a tangential addendum. If you are using something like Relay, that wouldn't work, since the schema needs to be known at build time :/. I do think the default name resolver probably should handle the dynamic object case. I don't think this actually solves your problem, which is that the schema, not the source object, needs to be dynamic. Even if your source object is dynamic you will still need to statically define the type if is resolved to (and it's fields). There is a reason why GraphQL makes this sort of thing really hard and it's because without the static definition you lose a lot of the benefits on the client, such as type checking your queries.\nI still think a custom scalar is the simplest way to handle this. We've used that JSON one or indeterminate db fields and it works great. In this case I'd be pretty straight forward to write a scalar that serializes a dynamic object as json directly. then you can put whatever you want in it. . I think this is a good idea generally. graphql-express has formatError which lets the user customize the mapping of GraphQL errors to the serialized ones. nit sure what this means... \nGraphql is a way to query data but you still need a backend to provide that data. your arguments can be whatever you want/need. yeah GQL doesn't provide any sort of pagination, sorting, or filtering built-in. Instead lets you add arguments you can use to do those things, very similarly (and annoyingly) like REST. Things like Relay.js help a bit, because they add some conventions on top of your graphql schema so that the client (most of relay) can do smart paging.. As it is you can already access the \"real\" inner exception on the Execution error right? I've just had some DEBUG switches in my http handler that formats errors differently depending on the environement.. Authentication should happen before the GQL bits get involved by whatever is actually handling your http requests. If you are using WebApi then an auth filter/action/whatever they are called can grab the token from the header, validate it, and reject or continue the request.\nFor metadata you might be storing in your token, I'd decode that in your http handler, and add it to the UserContext object when creating the schema, that way any field resolvers can access it through the whole graph. You probably don't have to do anything fancy with ResolveType at all. try just removing it. The reason you'd need it is that the Union type needs to know how to turn its source object into the output type. To do that it needs to know which of the union type (Employee, Customer) maps to that Source, and ResolveType can provide some custom logic to do that. \nHowever individual types can also implement a IsTypeOf method that takes a source object and returns true if it's a valid source type. All the ObjectGraphType<T> types already implement this method by default as type => type is T. So if the source object is a Customer it will resolve to CustomerGraphType, and the same for Employee.\nref: https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/ObjectGraphType.cs#L26. that's up to you, This sort of polymorphic list is more of a c# pattern question. GQL.net doesn't add any special utilities for adding discriminated unions. The most straightforward way to do it tho, is to have a List<IPeople> where Customer and Employee both implement IPeople. In your example the field Friends isn't a known scalar value (string, int, date, etc) so We can't infer the graphType for Friends. In those cases you need to tell it what type it is, using one of the (many) overloads\ncsharp\nField(\n  name=\"Friends\",\n  description= \"The friends of the user\",\n  type=typeof(ListGraphType<FriendGraphType>),\n  resolve= context => context.Source.Friends);. you'll need to write a FriendGraphType btw, which is probably a ObjectGraphType<Friend>. @janskoruba there isn't one specific way to do that. I'd do a quick search of the issue tracker here for the current conversations happening around that. Personally tho i've found that the ORM (I've used the Telerik Data Access which is mostly an Entity clone) does a pretty good job of optimizing and batching as it is.. i will never understand why they removed the finally hand editable/readable .json project file to go back to xml Does this require vs2017? . I'd selfishly prefer to not require vs2017, but i'm stuck at 2015 and dotnet 4.5.x for a while on some projects.\nStill haven't gotten VSCode and the build chain to work on my Mac :P. I do wish there was gql support for typed maps. someone should submit an RFC :P. Graphql as a query language has no specific filtering or sorting syntax. What it does have are query arguments that you can use to implement filtering or sorting in your field revolvers. In this way it's more like REST apis than sql, where you are responsible for building the various semantics you want into your server. . An additional note, the idea of GQL is not to give the client access to your sql database or do direct queries against it. That's generally a bad idea. Graphql, like REST is a way to define specific, albeit flexible, apis, not be a frontend for your database . yeah this is a bit confusing. the default value is used when the argument doesn't exist at all in the query, not when it's empty. e.g null is considered a value here.. Ya if you put together an example of that not working we can troubleshoot a bit more. The inference will work for arrays, e.g. string[]. You can manually specify the GQL type in your field declaration tho.. You have to specify the GraphQLType not the data type it resolves from, so field<ListGraphType<StringGraphType>>(). The inference isn't there because no one has added it ;) PR's are always welcome.. You might be interested in https://github.com/graphql-dotnet/relay generally.\n. ahh sorry...your Node Query should return a NodeInterface not a concert Node type e.g. Field<NodeInterfaceType>() GraphQL isn't aware of your c# inheritance (that's not codified in the schema). Hi thanks for the PR! What query/schema was leading to this error? I think it's great to catch this but I'd be even better to point a user to where to actually fix it, otherwise this exception is going to be equally as cryptic in context. Not sure how that would be related to this project. Sounds like you have something in VS or ReSharper configured or installed wrong. I think that distinction makes sense to me. It can be a point of confusion to not treat Date and Decimal as \"custom\" explicitly, especially if you go looking for more general GQL documentation about them and are confused why you can't find stuff.  I think carrying over that explicitness in the printer is a good thing, especially for interop with none C# consumers who may need to know what additions are required to consume a schema (a pie in the sky sort of case). Is ServiceAddress a list? Also the GQL type is ListGraphType<TGraphType>. You can already do that, it just depends on how you implement the https bits on your end. For instance the Relay adapters here (https://github.com/graphql-dotnet/relay/blob/master/src/GraphQL.Relay/Http/RequestHandler.cs) demonstrate one way to do it. @nick-lehmann you may not need a specific client library, the core http client libs should be fine. From the client side there isn't really anything special about querying a GQL backend, you send a http POST with the query and variables. Most actual backends differ on want format they want the request specified anyway.\nFor complex cases where you want caching and the like client libraries like Relay and Apollo are cool, but as far as i know there aren't any big libraries like that outside the javascript/browser ecosystem. It'd be really neat tho!. > since the name of the project does not include \"server\" and at least I found it while searching for a client library.\nYeah i understand where you are coming from if you aren't familiar with GQL. Honestly the reason it doesn't specify \"server\" is because there isn't a client portion. Like you don't usually see things labeled as REST api servers, and REST api clients. A REST api means server, and so too here. And like i mentioned generally you really don't need a specialized client, like you don't need a REST client, the normal http libraries do everything you need.. Usually you don't need to do that, Since the user can query for some or all of the possible fields you define in your types, you can just define types that cover all the different possibilities and then a user can just query for the fields relevant to them. you wouldn't implement a new query type no, its not like a REST api where you might version it and have 3 different full API's, GQL you can add new types or fields as you go. If you want to remove older fields you can deprecate them . I'm stuck on 4.5 as well tho I am fairly certain you can multi target without issue, I've done that in the last bits of the Relay code. You need to explicitly tell the field what graph type it is for complex types. As well as define an Animal graph type that  extend ObjectGraphType see the various examples and docs for examples on objects. If anyone is looking for an example of code that does this check out https://github.com/graphql-dotnet/relay/blob/master/src/GraphQL.Relay/Http/RequestExecutor.cs and surrounding code. . I also think the current approach is the correct one. I think some of the tension here is cultural differences and expectations between folks that are coming from a purely C# windows environment and those of us that are coming form the JS/frontend world. For example the JS implementations of graphql has a few different packages, the base implementation of the GQL spec and schema language, and graphql-express which provides easy to use middleware and http stuff for running a server. As it is I think that distinction makes the most sense. As you move up the abstraction stack needs get far more personalized and opinionated. Folks build web servers a lot of different ways, and it would be restrictive to require a single path to use GQL in DOTNET. \nI've hit this tension myself, trying to author Relay extensions for graphq-dotnet. Originally I provided direct hooks into WebAPI, but have since pulled that back and now only require a request body stream, so folks can build wahtever server they want. And to be clear the reason there is even http bits in the Relay lib, is because Realy specifies the request format whereas plain ol graphql does not.. Its ok with me, but there is a niceness to having the Object type have a connection builder, as a first class API. That may be addressable tho, it's already a bit annoying that Connection and Field so easily diverge, maybe it'll end up being neater to handle it outside the API here.... Honestly there really isn't a great way to stitch multiple schemas together, it's still a thing people are trying to solve in the GQL community.\nThat said I've done a few large gql schemas and I've found that having a single project for the schema has worked fine even with many types. You can still leverage application structure patterns like having isolated service layers split accross multiple places and handling sticking it all together with DI. In terms of structuring the schema itself I've found the class based approach  with ctor DI better (for my use cases) than the instance based approach for splitting stuff up and handling organization via the filesystem. Have you tried: https://github.com/graphql/graphiql#getting-started ?. Yes please, let's keep api churn down unless it's making a practical improvement based on specific feedback :) . How are you handling errors in your endpoint?. I have not personally found a good option for handling \"patch\" operations in GQL with C# but generally (in JS world) i've reserved null to mean an explict change in value for a field, and omitted as an indication that the field is not altered. To give meaning to that distinction tho you need someway of handling the mapping in either case. I'd imagine that for patch/updates mapping the json object to an existing instance of an object in C# land would work, e.g. Automapper.Map where you provide the initial destination object and only override the values that are included in the source. . try: https://github.com/graphql-dotnet/conventions\n. ah ok, yeah nothing that I know of for doing that, sorry!. I don't feel like i understand that value vs complexity this adds here. Fields should be ordered in by creation order, which makes sense as the correct default i think. Adding additional sorting is likely to cases performance concerns for a benefit that is purely useful during introspection in development?. the spec does have a bit of a section on this: http://facebook.github.io/graphql/October2016/#sec-Objects. this is sort of unfortunate, GraphQL Relay already adds most of this with a bit more robustness. We should perhaps consider more seriously moving all the connection stuff out of GraphQL.dotnet?. @RehanSaeed i'd happily take any PRs on that front, also always looking for help maintaining if that interests you \ud83d\udc4d . The relay dotnet project is mostly an implementation of the server bits to the relay graphql spec, which is what actually defines a Connection (it's not a core graphql concept). Generally that is paired with the relay client, but it's not required, I often use the relay server stuff with non relay clients (like apollo) since the pagination concepts are usually still helpful. its not strictly disallowed, but it is strongly discouraged: https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm and to some degree doesn't make a lot of sense to do, since pagination is confusing at best in both directions. That said it is not prohibited so and the above seems reasonable :P. actually the note is more about first and last together not either and the paired cursor. This seems like a good change \ud83d\udc4d . You can still build and test via the dotnet cli if you want, but running any of the examples or frontend bits require node for the frontend tooling so for the full end to end build it's needed anyway. Using not-node for frontend stuff is a chore in and of itself at this point. Assuming you've got most of the logic behind the resolvers in a layer that's unit testable, my favorite approach to testing gql apis in general is to stand up the server, mock out the layer right below it and do something like a snapshot test against queries that exercise the API surface area. I believe that's added by https://www.newtonsoft.com/json it should be configurable . this use case is now not possible, however It struck me that you can put whatever resolution logic you want in Resolve . Is there a use case for this I'm not thinking of?\n. The behavior here was inconsistent between the fluent and non-fluent APIs. The former returned a default value and the latter threw (per this test). In my uses I've always wanted the default value vs an error but I defer to you for which makes the most sense \n. see : https://github.com/graphql-dotnet/graphql-dotnet/pull/166/files#r76537857\n. \"Types with Fields\", is the more correct name\n. swiched to an interface mostly to manage InterfaceGraphType being both a ComplexType and an Abstract one\n. ya I meant to change it back, when I added a more direct Field(FieldType field) method, let me change it\n. this is harder, The extension methods (below) needed a concrete implementation for adding types, I could just move that into each implementation directly though.\n. does it make a difference in terms of final json payload? I went with camel case since it's more idiomatic json/graphql, but if that's handled by the json serializer sticking with pascal case here seems reasonable as well. \n. Ya it seems like you'd really want it to be a single sort of toggle for the entire schema vs annotating all the classes, since case is something you really want consistent. Like I said, as long as I can eventually consume the data in camelCase on the client it seems reasonable to not force something on the schema builder, while also letting them make use of shortcuts like deriving the name from the expression \ud83d\udc4d \n. is this behavior for any error or the error in which it resolves to null but the value is non-nullable?. This is a bit misleading, this is really an IndexCursor. While it's definitely helpful in simple cases, generally you probably don't actually want to use index cursors for serious implementations, as it doesn't account for ordering and can't be derived from just an item, which makes it inefficient if you are backing GQL with an ORM.\nThat is not say it's bad, but i worry that providing it as a default under the generic name \"Cursor\" suggests to much for it's use.. > what is the more efficient alternative?\nBuilding the cursor from an unique id, is the most straightforward, and doesn't create collisions. Ideally any cursor should be derivable from just a single item, so you don't have to query the DB for where that item is  total. Think about a create mutation, often you want to return the created node, as well as an Edge<T> for that node, in the mutation payload. It's generally not easy to efficiently insert the new item and also get its index. If you can derive it from the item tho, you don't have to do any additional lookups. The other thing is you don't collisions when fetching connections for multiple sort or filter situations.. I think this overstates the case a bit. Graphql occupies the same same space as a REST api, that may mean the level below it is a database, but more often than not its probably a service layer or other business logic  specfic thing between the DB or ORM. It just talk to the ORM directly but we shouldn't imply that's the only or correct way to use it.. again this isn't really true. yeah \"data\" in the general sense is correct, im only nitpicking \"database\" as it connotes a specific thing. Resolve, for instance may make an http request to another REST API. ",
    "Matthias-Hess": "Thanks a lot for your help!\nIf I understood you correctly, the spec does not dictate that the property names of my domain models fields names are camelCased, right? If possible, I would like to stick with PascalCase property names for \"my\" properties.\nI tried the following hacky ContractResolver, which did the trick:\ncsharp\npublic class CamelCasePropertyNamesResolverExceptDataAndError : DefaultContractResolver\n    {\n        protected override string ResolvePropertyName(string propertyName)\n        {\n            return propertyName.ToLowerInvariant() == \"errors\" || propertyName.ToLowerInvariant() == \"data\"\n                ? propertyName.ToLowerInvariant()\n                : propertyName;\n        }\n    }\nNow I have my PascalCase propertyNames and GraphiQl works! \nBut of couse, this solution is not very elegant. Wouldn't it be best if GraphQl for .NET could make sure that the property names of the important properties like \"errors\" and \"data\" are always camelCased (as the spec dicates), while just leaving the names of the Fields just as the user of the library entered them? \n. This was the straw that broke ~~the camel's~~ Pascals back!\nWe have discussed the topic on our team. We decided to use camelCase in javaScript..\nThe whole PascalCase mindset was a result of our .NET roots. But because in javaScript, camelCase is more common, we think it is better to use that idiom. Thanks for your thoughts!\n. Works like a Charm. Thank you!\n. ",
    "pravinhabbu4u": "@joemcbride  Thanks for the information. I was looking for a hack that would be an extension to what @Matthias-Hess was trying to do. I am actually able to use the names in custom cases using below hacks:\n\nPrefix all field names with a standard string - In my case I am trying with Field_ (example: Field_Id, Field_Name etc) and then using below hacks in code\n+\nModify ToCamelCase function from StringExtensions as: \n        public static string ToCamelCase(this string s)\n        {\n            if (string.IsNullOrWhiteSpace(s))\n            {\n                return string.Empty;\n            }\n            if(s.StartsWith(\"Field_\") && s.Length > 6)\n            {\n                return s.Substring(6);\n            }\n             return $\"{char.ToLowerInvariant(s[0])}{s.Substring(1)}\";\n        }\n+\n\nOverridign CamelCasePropertyNamesContractResolver with CustomCaseResolver \npublic class CustomCaseResolver : DefaultContractResolver\n{\n    protected override string ResolvePropertyName(string propertyName)\n    {\n        string s = propertyName;\n        return propertyName;\n}\n\n}\n\n\nI am now trying to see if the same overrides can be applied while using nuget GraphQL package . \n\n\n. #275 . Maybe this needs to be posted under https://github.com/graphql/graphiql. @joemcbride My hack attempt on at https://github.com/graphql-dotnet/graphql-dotnet/issues/169#issuecomment-277821315 has given me another idea. Instead of renaming field with a prefix why cant we have another implementation for FIELD method as FIELD_UDC - user defined case. This method can avoid converting first character of field to lower case/ camel case. I need your advice on how you feel about this suggestion. I was able to successfully achieve the results wanted using this change. I can submit a change if it makes any sense to you.\n   public FieldBuilder<TSourceType, TProperty> Field_UDC<TProperty>(\n        Expression<Func<TSourceType, TProperty>> expression,\n        bool nullable = false,\n        Type type = null)\n    {\n        string name;\n        try\n        {\n            name = expression.NameOf().ToUserCase();   // Retains user defined case than camel case\n        }\n        catch\n        {\n            throw new ArgumentException(\n                $\"Cannot infer a Field name from the expression: '{expression.Body.ToString()}' \" +\n                $\"on parent GraphQL type: '{Name ?? GetType().Name}'.\");\n        }\n        return Field(name, expression, nullable, type);\n    }\n\n\n    public static string ToUserCase(this string s)\n    {\n        if (string.IsNullOrWhiteSpace(s))\n        {\n            return string.Empty;\n        }\n        return s;\n    }\n\nUsage:\n      Field_UDC(x => x.IdentityID, nullable: true).Description(\"\");\nthan Field(x => x.IdentityID, nullable:true).Description(\"\");\nDocument Writer using custom case resolver:\n        public DocumentWriter(bool indent)\n            : this(\n                indent ? Formatting.Indented : Formatting.None,\n                new JsonSerializerSettings\n                {\n                    ContractResolver = new  CustomCaseResolver(),\n                    DateFormatHandling = DateFormatHandling.IsoDateFormat,\n                    DateFormatString = \"yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFF'Z'\",\n                })\n        {\n        }\npublic class CustomCaseResolver : DefaultContractResolver\n{\n    protected override string ResolvePropertyName(string propertyName)\n    {\n        string s = propertyName;\n        return propertyName;\n      //  return propertyName.ToLowerInvariant() == \"errors\" || propertyName.ToLowerInvariant() == \"data\"\n      //      ? propertyName.ToLowerInvariant()\n     //       : propertyName;\n    }\n}\n\n. @joemcbride Thanks for the response. I am trying to understand above change to see if it will allow us to \n1. Query fields using user defined case???\nPlus\n2. See fields in response in user defined case\nDo you want me to look into implementation of above change? Kindly advise. Thanks!. @joemcbride Do you have any tentative date for making this change available on nuget package? . @joemcbride Thanks for the quick response. I tried running a test using casing branch but I was not able to query/ see output in user defined case. Am I supposed to pass an additional parameter while registering fields OR need to override something in my implementation. . @joemcbride This is great. I was able to run a quick test and achieve required results. Now I can have case sensitive fields as well\n\n. @joemcbride Sounds good. Thanks for your quick assistance. I hope new options will be available via nuget package soon.. In case anyone is looking for Default/ Pascal field name converter then use _.FieldNameConverter option on execute async:\n`            return await new DocumentExecuter().ExecuteAsync(_ =>\n            {\n                _.Schema = schema;\n                _.Query = graphqlRequest.Query;\n                _.Inputs = inputs;\n                _.FieldNameConverter = new DefaultFieldNameConverter();\n            }).ConfigureAwait(false);`. @joemcbride As always thanks for quick response. Do you recommend creating a new type NonNullNonEmptyGraphType (similar to NonNullGraphType) so that I can easily add this validation on arguments that I want to have value? \n\nCreate NonNullNonEmptyGraphType\nCreat ValidationRule based on this type check . I must be doing something wrong because of which I am getting an exception as - GraphQL.ExecutionError: Only add root types.\r\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\r\n   at GraphQL.Types.GraphTypesLookup.<>c__DisplayClass15_0.<HandleField>b__0(QueryArgument arg)\r\n   at GraphQL.EnumerableExtensions.ApplyT\r\n   at GraphQL.EnumerableExtensions.ApplyT\r\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\r\n   at GraphQL.EnumerableExtensions.ApplyT\r\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable1 types, IEnumerable1 directives, Func2 resolveType)&#xD;&#xA;   at System.Lazy1.CreateValue()\r\n--- End of stack trace from previous location where exception\n\nMy project is currently using graphql nuget package hence I was trying to do some quick checks using:\npublic class NonNullNonEmptyGraphType<T> : NonNullGraphType<T>\n   where T : GraphType\n{\n\n}\n\n\npublic class NonNullNonEmptyGraphType : GraphType\n{\n    public NonNullNonEmptyGraphType(IGraphType type)\n    {\n        if (type is NonNullNonEmptyGraphType)\n        {\n            throw new ArgumentException(\"Cannot nest NonNull inside NonNull.\", nameof(type));\n        }\n\n        ResolvedType = type;\n    }\n\n    protected NonNullNonEmptyGraphType(Type type)\n    {\n        if (type == typeof(NonNullNonEmptyGraphType))\n        {\n            throw new ArgumentException(\"Cannot nest NonNull inside NonNull.\", nameof(type));\n        }\n\n        Type = type;\n    }\n\n    public Type Type { get; private set; }\n    public IGraphType ResolvedType { get; set; }\n\n    public override string CollectTypes(TypeCollectionContext context)\n    {\n        var innerType = context.ResolveType(Type);\n        ResolvedType = innerType;\n        var name = innerType.CollectTypes(context);\n        context.AddType(name, innerType, context);\n        return \"{0}!\".ToFormat(name);\n    }\n}\n\npublic class ProvidedNonNullNonEmptyArguments : IValidationRule\n{\n    public string MissingFieldArgMessage(string fieldName, string argName, string type)\n    {\n        return $\"Field \\\"{fieldName}\\\" argument \\\"{argName}\\\" of type \\\"{type}\\\" is required but not provided.\";\n    }\n\n    public string MissingDirectiveArgMessage(string directiveName, string argName, string type)\n    {\n        return $\"Directive \\\"{directiveName}\\\" argument \\\"{argName}\\\" of type \\\"{type}\\\" is required but not provided.\";\n    }\n\n    public INodeVisitor Validate(ValidationContext context)\n    {\n        return new EnterLeaveListener(_ =>\n        {\n            _.Match<Field>(leave: node =>\n            {\n                var fieldDef = context.TypeInfo.GetFieldDef();\n\n                if (fieldDef == null)\n                {\n                    return;\n                }\n\n                fieldDef.Arguments?.Apply(arg =>\n                {\n                    var argAst = node.Arguments?.ValueFor(arg.Name);\n                    var type = arg.ResolvedType;\n\n                    if (argAst == null && type is NonNullGraphType)\n                    {\n                        context.ReportError(\n                            new ValidationError(\n                                context.OriginalQuery,\n                                \"5.3.3.2\",\n                                MissingFieldArgMessage(node.Name, arg.Name, context.Print(type)),\n                                node));\n                    }\n                    if ((argAst == null || argAst.ToString() == String.Empty) && type is NonNullNonEmptyGraphType)\n                    {\n                        context.ReportError(\n                            new ValidationError(\n                                context.OriginalQuery,\n                                \"5.3.3.2\",\n                                MissingFieldArgMessage(node.Name, arg.Name, context.Print(type)),\n                                node));\n                    }\n                });\n            });\n\n            _.Match<Directive>(leave: node =>\n            {\n                var directive = context.TypeInfo.GetDirective();\n\n                if (directive == null)\n                {\n                    return;\n                }\n\n                directive.Arguments?.Apply(arg =>\n                {\n                    var argAst = node.Arguments?.ValueFor(arg.Name);\n                    var type = arg.ResolvedType;\n\n                    if (argAst == null && type is NonNullGraphType)\n                    {\n                        context.ReportError(\n                            new ValidationError(\n                                context.OriginalQuery,\n                                \"5.3.3.2\",\n                                MissingDirectiveArgMessage(node.Name, arg.Name, context.Print(type)),\n                                node));\n                    }\n                    if ((argAst == null || argAst.ToString() == String.Empty) && type is NonNullNonEmptyGraphType)\n                    {\n                        context.ReportError(\n                            new ValidationError(\n                                context.OriginalQuery,\n                                \"5.3.3.2\",\n                                MissingDirectiveArgMessage(node.Name, arg.Name, context.Print(type)),\n                                node));\n                    }\n                });\n            });\n        });\n    }\n}. My use was as simple as:\n\nField( \"MyName\",\n                    arguments: new  QueryArguments(new QueryArgument> { Name = \"MyParmName\"}),. Thanks for the information. I am trying to integrate the information provided above. I would have simply loved to have something as throwGraphQLError  / addGraphQLError (something like ModelType.AddModelError) from resolver. This can allow more control that just restricting logic to validation errors.. Throwing error generally results in error resolving .... error. This really doesnt work well when I allow requestor to access data from related microservices as part of single query. Failure on any API call in this case results in entire resolve exception. If an individual nested call fails then currently I report error at specific level/ nested field using error block available on each microservice.. Thanks. I will review those tomorrow just to verify deserializer is required or not. In my case I am using API metadata which includes such custom components such as linkage/ relationship of a microservice with other related microservices and any field conditions needed to cal related api. I feel this is a very unique case hence existing schema generators may not help. This additional relationship information allows me to create additional nested fields which can be queried by requestor to get data from more than 1 API.. yes I was getting generic error whenever API call was failing ( like api down) or whenever deserializer was failing after API call. I have handled API call errors using another mechanism (just generate default response by populating error block available on each APi response with an error and actual error description).\nI have fixed my intermittent deserializer problem (which was originally caused by me) by not modifying the data type of existing response field. Now I am using different approach in case existing primitive API field has link with other API then I add a new list to support downloading data from related API and resolving it using\n{\nField>(\"ReferredFriends\", \"\");\nField>(\"ReferredFriends_Details\", \"\",\n    resolve: context => {\n      List __D = new List();\n      foreach (var __ID in context.Source.ReferredFriends)\n      {\n          __D.Add(API_Organization_Get_Resolvers.GetSingle_Resolver(__ID.ToString()).Result);\n       }\n       return __D;\n   });\n}. @joemcbride  I tried changing Variables type from string to public Dictionary Variables { get; set; }. It has fixed deserializer issue. I have made additional below changes to fix it. It works but not sure if this is the best way to handle this change:\nUpdated GraphQLRequest:\n  ```\n internal sealed class GraphQLRequest\n    {\n        public string OperationName { get; set; }\n    public string Query { get; set; }\n\n    public Dictionary<string, string> Variables { get; set; }\n}\n\n```\nUpdated call to ExecuteAsync as:\n   string requestBodyText;\n            using (var streamReader = new StreamReader(request.Body))\n            {\n                requestBodyText = await streamReader.ReadToEndAsync().ConfigureAwait(true);\n            }\n            var graphqlRequest = JsonConvert.DeserializeObject<GraphQLRequest>(requestBodyText );\n            Inputs _inputs = new Inputs();\n            foreach (var arg in graphqlRequest.Variables)\n            {\n                _inputs.Add(arg.Key, arg.Value);\n            }\n        return await new DocumentExecuter().ExecuteAsync(schema, null, graphqlRequest.Query, graphqlRequest.OperationName, _inputs ).ConfigureAwait(true);. @joemcbride Thanks for the quick response. I just tried your suggestion. It is working as well after modifying variables type as:\n\n    public Dictionary<string, object> Variables { get; set; }\n\nfrom \n        public Dictionary Variables { get; set; }\n. @joemcbride  Moved back Variables type to string from Dictionary as it was causing problem with schema not loading with exception (Dicitionary cant be null ).\nNow using:\n  return await new DocumentExecuter().ExecuteAsync(_ =>\n            {\n                _.Schema = schema;\n                _.Query = graphqlRequest.Query;\n                _.Inputs = new Inputs(graphqlRequest.Variables.ToInputs());\n            }).ConfigureAwait(false);. @joemcbride I am back to square 1 - Do we need to make any change on request deserialization as changing Variables types back to string brings back the deserializer issue.\nvar graphqlRequest = JsonConvert.DeserializeObject<GraphQLRequest>(requestBodyText);. @joemcbride Makes sense. For now I have fixed the issue by making some changes in my graphiql interface/ middleware implementation in .net core. \nI will review the Middleware implementation once I complete some automation work on mutations.\n``    internal sealed class GraphQLRequest\n    {\n        public string OperationName { get; set; }\n    public string Query { get; set; }\n\n    public Dictionary<string, object> Variables { get; set; }\n}`\n\n\n                Inputs inputs = null;\n                if (graphqlRequest.Variables != null)\n                {\n                    inputs = new Inputs();\n                    foreach (var arg in graphqlRequest.Variables)\n                    {\n                        inputs.Add(arg.Key, arg.Value);\n                    }\n                }\n                //var inputs = graphqlRequest.Variables.ToInputs();\n                return await new DocumentExecuter().ExecuteAsync( =>\n                {\n                    .Schema = schema;\n                    .Query = graphqlRequest.Query;\n                    .Inputs = inputs;\n                }).ConfigureAwait(false);\n```\nMy team is quite desperate in having PascalCases back on field names. I will wait for completion of remaining work on your end to support pascal cases.. @joemcbride That sounds cool. Thanks!. I actually ended up using new user context to share config entries and also to share unique GraphQL request identifier that can be tagged on all API calls made under a single request.. @jquense Thanks for the quick response. This truly clears my biggest confusion on why I needed both resolve on query field and ResolveType on union object. I have removed the resolve type section now. I am only trying to see how I can take care of resolve method on union field.\npublic class Query__: ObjectGraphType\n    {\n        public Query__()\n        {\n            Field(\"SearchEmployeeOrCustomer\",\n        arguments: new QueryArguments(new QueryArgument> { Name = \"SearchWord\" }),\n        resolve: context =>\n        {\n    List<Employee> EmpList = new List<Employee>();\n   ..... Add few records to employee list\n    List<Customer> CustomerList= new List<Customer>();\n   ..... Add few records to cust list\n\n  var matchingEmployees = EmpList.find(....); // filter matching\n  var matchingCustomers = CustList.find(....); // filter matching\n\nhow can I now return matchingEmployees + matchingCustomers from here????\n        }\n    );\n. @jquense Thanks for the explanation. I think I am close to resolution now but kind of not sure why still the response is null. Any input from your end is greatly appreciated. Thanks!\n```\n    public class Human\n    {\n        public string _Name { get; set; }\n    }\npublic class Employee :Human\n{\n    public string _Name { get; set; }\n    public string EmployeeID { get; set; }\n}\n\npublic class EmployeeType : ObjectGraphType<Employee>\n{\n    public EmployeeType()\n    {\n        Field(x => x._Name, nullable: true).Description(\"Name\");\n        Field(x => x.EmployeeID, nullable: true).Description(\"ID\");\n    }\n}\n\npublic class Customer :Human\n{\n    public string _Name { get; set; }\n    public string CustomerNumber { get; set; }\n}\n\npublic class CustomerType : ObjectGraphType<Customer>\n{\n    public CustomerType()\n    {\n        Field(x => x._Name, nullable: true).Description(\"l Name\");\n        Field(x => x.CustomerNumber, nullable: true).Description(\"ID\");\n    }\n}\n\npublic class EmployeeORCustomer : UnionGraphType\n{\n    public EmployeeORCustomer()\n    {\n        Type<EmployeeType>();\n        Type<CustomerType>();\n    }\n\n}\n\n```\n    ```\nField<EmployeeORCustomer>(\"SearchEmployeeOrCustomer\",\n    arguments: new QueryArguments(new QueryArgument<NonNullGraphType<IdGraphType>> { Name = \"SearchWord\" }),\n    resolve: context =>\n    {\n        Employee ee = new Employee();        ee.EmployeeID = \"1234\";             ee._Name = \"AABBCC\";\n        Customer cc = new Customer();       cc.CustomerNumber = \"xyz\";        cc._Name = \"david\";\n\n        List<Human> L = new List<Human>();\n        L.Add(ee);\n        L.Add(cc);\n        return L;\n    }\n\n```\nfor some reason my response is empty/ null. I understand it is not a graphql issue but something that you can clarify would be great.\nquery Union{\nSearchEmployeeOrCustomer(SearchWord:\"ABC\"){\n    ... on EmployeeType{\n      _Name\n      EmployeeID\n}\n... on CustomerType{\n  _Name\n  CustomerNumber\n}\n\n}\n}\nResponse:\n{\n  \"data\": {\n    \"SearchEmployeeOrCustomer\": null\n  }\n}\nI am trying to find missing link of EmployeeType vs Employee and CustomerType vs Customer which seems like an issue. Got it, It was stupid issue of me not specifying ListGraphType on query field but was returning list. Changed it and is working as expected. Thanks @jquense \n```\nquery q{\n  SearchEmployeeOrCustomer(SearchWord:\"ABCD\"){\n    ... on EmployeeType{\n      _Name\n      EmployeeID\n    }\n    ... on CustomerType\n    {\n      _Name\n      CustomerNumber\n    }\n  }\n}\n{\n  \"data\": {\n    \"SearchEmployeeOrCustomer\": [\n      {\n        \"_Name\": \"PRAVIN\",\n        \"EmployeeID\": \"1234\"\n      },\n      {\n        \"_Name\": \"david\",\n        \"CustomerNumber\": \"xyz\"\n      }\n    ]\n  }\n}\n```. Note: I do have a current implementation that is solving my problem of caching within a request (which is what I want). However, I would like to know if there is a unique way for it\n. Is it all about using FieldAsync than Field??? OMG I am so excited to see this in another thread. @joemcbride. Thanks for the quick response. Will the field resolver run in parallel only when FieldAsync is used? In above example, I am expecting if 10 customer records are returned then call to next API (PaymentHistory) should invoke at same time after 1st list type is resolved hence ideally having total time down to time taken to call first API (get customer list) + (max time taken by paymenthistory API). @joemcbride Thanks. I will make some changes to return a Task and see what happens. If FieldAsync is not always needed then I was expecting at least a resolve request for all 10 records should have initiated at same time.. @jomcbride Thanks a ton. return Task.Run(() => { resolver code} ); has made a huge difference. I will try to improve performance further. . Thanks for the clarification. I have instead provided 2 separate arguments (with a pre-defined naming standards to handle this scenario)\nnew QueryArgument< StringGraphType > { Name = \"fType\"},\nnew QueryArgument< ListGraphType < StringGraphType >> { Name = \"fType__AsList\"},. ",
    "bdangh": "Yes, it is GraphQLDeprecatedDirective, and I use 0.7.0 version.\nCan it be because of type: GraphQLString?\nI've found another schema.json where it looks like this.\njavascript\n        {\n          \"name\": \"deprecated\",\n          \"description\": \"Marks an element of a GraphQL schema as no longer supported.\",\n          \"locations\": [\n            \"FIELD_DEFINITION\",\n            \"ENUM_VALUE\"\n          ],\n          \"args\": [\n            {\n              \"name\": \"reason\",\n              \"description\": \"Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formattedin [Markdown](https://daringfireball.net/projects/markdown/).\",\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"\\\"No longer supported\\\"\"\n            }\n          ]\n        }\n. \ud83d\udc4d Thanks, Awesome! Keep up the good work!\n. ",
    "kamil-mrzyglod": "@joemcbride Sure, that's perfectly fine. From my point of view(someone who just tried to make example working) it was all a bit cumbersome - the example itself doesn't work so there is a need to dig into code to get it working.\nMaybe adding usings and a link to GraphQL.StarWars project would make a deal?\n. @joemcbride Reverted and added only a link to the StarWars project.\n. @joemcbride Splendid!\n. BTW - I checked source code and I see that this error is not coming from graphql-dotnet, still I think it'd viable to fix this.\n. @JarnoNijboer Yeah, I investigated the code and realized that this error is thrown by Activator.CreateInstance().\nI didn't use any DI container, I got it using code I pasted here. What I managed to discover is that the problem is in https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/Schema.cs file in following lines:\npublic Schema()\n            : this(type => (GraphType) Activator.CreateInstance(type))\n        {\n}\nat least this is something I saw in the stack trace.\n. I see. Is there any kind of wiki, where this information can be found or be added?\n. ",
    "neooleg": "This is another example for .NET Core Dependency Injection (Microsoft.Extensions.DependencyInjection).. @joemcbride thanks for clarification.. Hi @joemcbride, could you please update -- is there an example appeared? . Thanks for quick response.\nI plan to deal with subscriptions, so will share my experiments, if it's useful here.\nRelated question -- is this possible to setup WebSocket connection (e.g. SignalR) and send everything thru it? I mean to use this WS only (w/o any HTTP endpoints) for queries, mutations as well as for subscriptions?. @garethrampton as far as I understood -- is this not a simple solution for SignalR and subscriptions in graphql-dotnet working together?\nP.S. We're using HTTP until in development, so didn't have a change to set mentioned experiments. Could you please share more info (pitfalls, code or concepts), if possible?. @OneCyrus,\nPersonally, I didn't plan to use Apollo in this initiative -- SignalR and graphql-dotnet only.\nHowever, if you will share anything with Apollo it will be interesting. Although, it might be out of scope for this thread, so sharing a link would be the best \ud83d\ude04 . @joemcbride thanks for sharing.\nIs this means that subscriptions will be a part of graphql-dotnet, so they will be used without additional SignalR code?. @joemcbride sure, it absolutely make sense. My point was a bit different -- will graphql-dotnet do all job for developer on backend regarding pub/sub and further push (when a developer provides e.g. SignalR transport of it)?\nJust to be aligned -- do you have an approximate ETA for the subscriptions scope?\nAnyway, as soon as I will tackle a solution -- immediately will share this as promised above.. ## Disclaimer\nLet me to update since I've spent some time for investigation. Probably the summary will be useful for someone, however, it's far from final goal of the topic.\nAbstract\nWe're targeting .NET Core only, but SignlaR 2.0 (which compatible with Core) was rewritten from scratch, so released just a few days ago. It doesn't even have any documentation yet (https://github.com/aspnet/SignalR/issues/724). Hence, IMO it looks like a bit fresh and need to be settled few releases until take it to production.\nConclusion\nThus, it was decided to postpone implement solution with the graphql-dotnet subscriptions and SignalR 2.0 and kept a while subscriptions at all.. Sorry, k can't promise. Too much business work.\nCan you reproduce it?\nOn Thu, Aug 2, 2018 at 15:29 Simon Cropp notifications@github.com wrote:\n\n@neooleg https://github.com/neooleg could you supply a failing unit\ntest in a PR? or upload a repro somewhere?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/674#issuecomment-409909286,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABkhyfXJLtvLC61MyN0qfwgmrqN63holks5uMvDEgaJpZM4UPNKb\n.\n-- \nBest regards,\nOleg\n. @SimonCropp \ncan u try the latest version 2.0.0-alpha-978\n\nSure, will do. Thank you very much for following up this!. > @neooleg BTW dont u think this is a strange stance to take when consuming a free open source project\n@SimonCropp I might totally agree with you for now! Although, this is mostly philosophical question to be honest \ud83d\ude0a. @joemcbride thank you very much for quick response!\nIt was a nice catch with example while I write. \ud83d\ude0e\nLet me clarify first.\nDo you suggest to inherit from ObjectGraphType (if I understood your correctly) and override Description()?. Got it, thanks for details.\nHence, am I correct -- is Description() calls for each type? Hence, am I need just to rise an exeption that null/empty string passed?. ",
    "etombi": "got this error , trying NOT To use DI , can be implemented without DI ?. ",
    "cmiagika": "Thank you for your fast answare.\nI will try to update on 0.12 alpha and will inform you if it worked.\nVery good work \ud83d\udc4d.\n. ",
    "garethrampton": "@neooleg I'd be really interested in you seeing your experiments here - I've not found any examples of getting subscriptions working  (with .NET).\nI've got some ideas how this might work for us via SignalR (and we're already internally using an event driven architecture), but its just at concept stage right now.. ",
    "OneCyrus": "i'm interested to get a basic subscription with apollo client working as well. any starting point to get the schema right and how i should push data from the backend?. @joemcbride i was searching this backend implementation in the source. but couldn't find it. is this something you're working on now?. apollo is implementing it now\nhttps://dev-blog.apollodata.com/graphql-schema-stitching-8af23354ac37\nhttps://github.com/apollographql/graphql-tools/pull/382\n. i'm exploring a bit on this topic. the schema builder in 2.0 is pretty cool for this. and it should be possible to implement the merging algorithm on top of this. the harder part is the type resolving. currently it looks like we need explicit types in the DI to be able to resolve additional types. There's no fallback to handle local unresolved types. Maybe we can introduce some kind of universal type which can route those unresolved types.\n@joemcbride do you have an idea how you would implement the resolver logic?\n. @troydalldorf we started working on this in https://github.com/graphql-dotnet/graphql-dotnet/pull/592 though lately there's not much progress on our side. but this should change early next year as we want to push this forward.. it looks like grapgql 2.0 prereleases are not compatible with asp.net core 1.x. try to upgrade to asp.net 2.0.. we have a similiar problem. couldn't find the root cause yet.\nthis is the memory diff between same apollo requests:\n\n. ok. removing the InstrumentFieldsMiddleware resolves the issue here.. is there a newer version which is stable/usable for production?\nwhile the memory leak is not really visible anymore, the performance gets pretty bad after a few days with the current version. it looks like there are still some issues somewhere.. this looks nice @elauffenburger! as this PR doesn't change anything in graphql-dotnet itself maybe we can polish this as a separate package which doesn't need to live inside the main repo?\nwe are really interested to have proper schema stitching in graphql-dotnet. this seems to be a good start and with some effort we should be able to move the codegen to roslyn and improve on some edge cases.. that sounds great! btw. did you look into changing to roslyn code generation yet? we are a bit stuck with the current version as we would need this in a .net core application.\nand another feature would be nice to have is custom scalar types.. two more questions about using this library:\n\n\nis there an easy way to \"generate\" the query which i would send to the remote server inside the RemoteField resolver? something like generate query from resolver \"ctx.FieldAST\" (with children) and map this to the typeName from the remote schema.\n\n\ndid you already experiment with filtering variables/arguments to only pass the correct ones to the remote server?. @PascalSenn that's nice! now we need to have an AstPrinter which can print the AST in the other direction in an other schema.\n\n\npublic schema\nQuery {\n   LocalType {\n      RemoteType {\n         MyRemoteField\n      }\n      OtherRemoteType {\n         OtherRemoteField\n      }\n   }\n}\nschema from remote server\nQuery {\n   RemotePrimaryType {\n     EvenDeeper {\n        RemoteType {\n           MyRemoteField\n        }\n        NotQueriedRemoteType {\n           NotQueriedField\n        }\n     }\n   }\n}\nAST printer would give me\njavascript\n{\n   RemoteType {\n       MyRemoteField\n    }\n}\nand this is what i would need\nQuery {\n  RemotePrimaryType {\n    EvenDeeper {\n      RemoteType {\n        MyRemoteField\n      }\n    }\n  }\n}\nthough it could get difficult if there are multiple times the same type in the remote schema. GraphlQL.Dynamic currently has a type as en entry point. And in this direction it's not necessary to know where this type is in the AST. but resolving it back to the remote schema we are missing the path to the type. as in the test case in this PR (https://github.com/graphql-dotnet/graphql-dotnet/pull/592/files#diff-3c2a7abce1b810eb64bdad8bfd0ea9b5R21) \"GithubAPI\"/GithubMoniker should probably be a path and not just a type/name.. @elauffenburger in the next couple of days we would like to start with adopting this approach for our project. would it be possible for you as mentioned to address the known bugs or should we fork this from the current state?\n@PascalSenn sounds good!. @elauffenburger I just created a PR to change to roslyn code generation and .net standard\nhttps://github.com/elauffenburger/graphql-dotnet/pull/1. @elauffenburger thanks a lot! I'll have a look. \nfor the codegen PR I've some additional changes which I'll push there in the next days.. i just merged your branch in our internal exploration codebase and played around with it. while it works good for what it does right now we still have three major limitations which we need to tackle before we can use it for real use cases.\n\n\nArguments: currently the inputtypes are not assigned to the graphtypes. do you have any ideas how to do this the best way?\n\n\nUNION: we are using unions and would need to have some basic union support. from your comments ii get that you made some thoughts about them but they are not that easy to implement. we thought about them a bit as well and probably the only way to do this would be to bet on forcing __typename for unions in the query to the remote location. dynamic deserialization with type lookup should be possible.\n\n\ndynamic query builder: fully generate the query from all the information inside the graphql AST and remote schemas to request the data from remote location. did you implement something like that yet or are you using more or less fixed queries to request the data?\n\n\ni guess we already made quite some progress with this PR and once we have the remaining limitations fixed it will be an awesome solution.\n. @deinok what @PascalSenn meant is that with introspection and code generation (what this PR here actually does), you could do a fully typed graphql client.\n@PascalSenn and I are moving over to a competing solution for schema stitching in .Net. We won't invest more into this PR as well.. what node version is it using? looks like the new npm 6 isn\u2018t compatible with this node version.. ok that looks wrong in appveyor.yml\ninstall:\n  - npm install -g npm\n  - npm --version\n  - ps: Install-Product node LTS\n  - node --version\n  - dotnet --version\nps: Install-Product node LTS should be the first install action.. btw. this gives the wrong path (shadowed assembly path). using the following gives the correct path:\nPath.GetDirectoryName(Uri.UnescapeDataString(new Uri(Assembly.GetExecutingAssembly().CodeBase).AbsolutePath)). just had some issues with mediaheaders. this helps to set the accept format.\nclient.DefaultRequestHeaders\n  .Accept\n  .Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));. as above with the accept header, setting the content type helped to solve an issue in our environment:\nvar response = client.PostAsync(new Uri(url), new StringContent(JsonConvert.SerializeObject(query), Encoding.UTF8, \"application/json\")). DateTime is missing:\nPopulateTypeMapping(LiteralGraphTypeMemberInfoType.DateTime, typeof(DateTime), CreateFieldType<DateGraphType>);. this generates not valid names. changing to Name = $\"{_name}\"; should fix this. or is there a reason other than duplicated types for this?. this fails if the schemaType is a base GraphQL type e.g. ListGraphType<StringGraphType>. putting the full url in front of every remote type gives a very verbose schema. the docs look very busy as well. can't we find a simpler way to solve this? e.g. using the moniker or an intelligent solution which only triggers for conflicting types.. not sure if this should be DateTimeOffset or DateTime. .Result can lead to threadpool exhausting. usually the better way is using task.GetAwaiter().GetResult() (it's already this way in the master and probably the root issue of this PR). ",
    "lbrolinz": "@neooleg @joemcbride , Hi, is there any solution for graphql-dotnet subscriptions?. ",
    "pekkah": "I actually have a example ready also. Once I fix those small things with my PR I'll push it out.. Example of using WebSockets with new ISubscriptionExecuter can be found here. Not production ready.. This should be easy to add with the changes done to implement subscriptions.. This might help also https://github.com/graphql-dotnet/server/tree/master/src/Ui.GraphiQL. Another fix for this is here https://github.com/graphql-dotnet/graphql-dotnet/pull/434. @seralexeev Try using GetRequiredService.. Is this being worked on? Hitting this issue while running unit tests..  This can be closed now?. This will replace optics https://dev-blog.apollodata.com/introducing-apollo-engine-insights-error-reporting-and-caching-for-graphql-6a55147f63fc. For my purposes I created this https://pekkah.github.io/tanka-docs-gen/beta/basics/1-usage.html. For c# it uses Roslyn to find the snippet to include and for others it uses the docfx extensions for markdig. Here's a something generated using it https://pekkah.github.io/tanka-graphql/beta/.. Latest version of master should've this fixed.. Is this going to get merged into master anytime soon?. PR with standard2.0 was merged to master while keeping the old targets.. Got it working but not very cleanly. Is there an easy way to filter object properties based on the selection set of an query? Basically executing but with given result object?. Sorry for being bit unclear what I was doing. That's what you get from hammering the code for too long. Not getting the thoughts out clear anymore. \nI mean I have subscriptions working now with graphql-dotnet and websockets transport compatible with this https://github.com/apollographql/subscriptions-transport-ws. Whole setup is currently working with GraphiQL built on top of .NET Core 2.0.\nCurrently I'm publishing an event from my mutation resolver and if there are any subscriptions for that event I'm publishing the data associated with the mutation. How I currently handle the subscribing part is very very hacky. Didn't want to mess with the dotnet-graphql code base first.  I'm going to delete the hacky prototype next and implement it properly. To get things right I probably need to implement my own SubscriptionExecuter (similar to DocumentExecuter) which will return an event stream as result. This allows me to have the proper pipeline for filtering the events based on the subscription query and the field selection set.\nI'll let you know when I have something to show. As this is an hobby project for me there's no timeline for it. \n. Here's my current progress\n\nI took the DocumentExecuter as a base and modified it so that the result of the execution is a Dictionary of streams. Each stream is just an IObservable<ExecutionResult>.  When websocket connection is made I check if the requested protocol is \"graphql-ws\" and then create a connection wrapper. This wrapper will read any messages coming from the client. Currently supported are init, and start messages. If message is start message I execute the query using new executer and subscribe to the resulting observable.\nHere's the subscription node\n```csharp\npublic class ChatSubscriptions : ObjectGraphType\n    {\n        private readonly IChat _chat;\n    public ChatSubscriptions(IChat chat)\n    {\n        _chat = chat;\n        AddField(new EventStreamFieldType\n        {\n            Name = \"messageAdded\",\n            Type = typeof(MessageType),\n            Resolver = new EventStreamResolver(Subscribe)\n        });\n    }\n\n    private Task<IObservable<object>> Subscribe(ResolveEventStreamContext context)\n    {\n        return _chat.JoinAsync();\n    }\n}\n\n```\nHere's the Chat domain object:\n```csharp\npublic class Chat : IChat\n    {\n        private readonly IEventAggregator _events;\n    public ConcurrentStack<Message> Messages { get; }\n\n    public Chat(IEventAggregator events)\n    {\n        _events = events;\n        Messages = new ConcurrentStack<Message>();\n    }\n\n    public void AddMessage(Message message)\n    {\n       Messages.Push(message);\n        _events.Publish(\"messageAdded\", message);\n    }\n\n    public Task<IObservable<object>> JoinAsync()\n    {\n        var subject = _events.Subject(\"messageAdded\");\n        return Task.FromResult(subject);\n    }\n}\n\n``\nI callChat.AddMessage` from the mutation node.\nTodo\n\n[ ] transport: unsubscribe\n[ ] executer: clean up and tests\n[ ] transport: query (standard query trough websocket)\n[ ] transport: proper websocket close state handling\n\n. Each value in the observable returned by EventStreamResolver.Resolve goes trough DocumentExecuter.CompleteValueAsync and gets wrapped into the ExecuteResult. So it uses the FieldType to transform the result. \nYou can pass in any arguments your domain requires as longs the result is an IObservable<object> from the resolver. IObservable makes it quite easy to implement any filtering etc logic. You could even handle the actual creation of the stream in another service and just proxy it trough. The IEventAggregator I'm using in the sample is just a simple PubSub service I created to make the testing easier.  . What benefit would that resolve give?\nIf you wanted transform the results you could do this:\n```\nprivate async Task> Subscribe(ResolveEventStreamContext context)\n        {\n            var messages = await _chat.JoinAsync();\n        return messages.Select(message => new MyOtherClass());\n    }\n\n``\nOf course that MyOtherClass would be passed trough theCompleteValueAsync`. So it would need  to match the FieldType.\nAnother option for transforming the result would be when subscribing to the stream. You could specify transformation there before sending to the client.\n. Yep, I'll change it to execute instead of just complete value.  I'll push the code this week so it's easier to comment on and maybe move it into the main project.. These work now.\n```\nusing System.Threading.Tasks;\nusing GraphQL.Server.Execution;\nusing GraphQL.Server.Resolvers;\nusing GraphQL.Server.Types;\nusing GraphQL.Types;\nusing System;\nusing System.Reactive.Linq;\nusing GraphQL.Resolvers;\nnamespace GraphQL.Server.Tests.TestSchema\n{\n    public class ChatSubscriptions : ObjectGraphType\n    {\n        private readonly IChat _chat;\n    public ChatSubscriptions(IChat chat)\n    {\n        _chat = chat;\n        AddField(new EventStreamFieldType\n        {\n            Name = \"messageAdded\",\n            Type = typeof(MessageType),\n            Resolver = new FuncFieldResolver<Message>(ResolveMessage),\n            Subscriber = new EventStreamResolver(Subscribe)\n        });\n\n        AddField(new EventStreamFieldType\n        {\n            Name = \"messageAddedByUser\",\n            Arguments = new QueryArguments(\n                new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\" }\n            ),\n            Type = typeof(MessageType),\n            Resolver = new FuncFieldResolver<Message>(ResolveMessage),\n            Subscriber = new EventStreamResolver(SubscribeById)\n        });\n    }\n\n    private async Task<IObservable<object>> SubscribeById(ResolveEventStreamContext context)\n    {\n        var id = context.GetArgument<string>(\"id\");\n\n        var messages = await _chat.MessagesAsync();\n\n        return messages.Where(message => message.From.Id == id);\n    }\n\n    private Message ResolveMessage(ResolveFieldContext context)\n    {\n        var message = context.Source as Message;\n\n        return message;\n    }\n\n    private async Task<IObservable<object>> Subscribe(ResolveEventStreamContext context)\n    {\n        return await _chat.MessagesAsync();\n    }\n}\n\n}\n```\n@joemcbride should I make a PR for the subscription executer or would you prefer it as a separate repo/nuget? I was planning to move the websockets transport/protocol code to separate NuGet and release it, but I'm sure the actual subscription executer should be part of this repo.. @junelau FYI https://github.com/graphql-dotnet/server. Have to do a rebase. Will post updated pull request later.. @joemcbride should be ready for second pass. Yep, will post any problems importing the codebase here https://github.com/graphql-dotnet/subscriptions-transport-ws/issues/1. Yep. That should \"fix\" the issue. At the moment all of the float tests fail on my machine without these changes.. Just the tests against master are here https://github.com/graphql-dotnet/graphql-dotnet/pull/437. @joerneu thanks :) Fixed. ObjectExtensions uses Conversions and that should be covered.. @joerneu yes, you're right. Fixing it now. Too many .ToStrings and Parses.. @joemcbride includes now bunch of tests with xunit theories. @joemcbride created a test helper to run test with specific culture and another to run with premade set of cultures. @joerneu saw the DateTime but didn't want to touch it in scope of this PR. . @joemcbride done. ## Conventions\nYep they're good when getting started or building from scratch but if you're adding GraphQL on top of existing APIs then they just get into way. Installing another package to get Conventions support is not that bad.\ndelivered with middleware\nI like how the core library does not bind to any specific hosting method or include one. It doesn't take that long to make your own or copy/paste from samples. One middleware to handle both normal queries and subscription is being done here Subscriptions\nThe library should be delivered with an available/suggested authorization technique\nAgain my opinion is that it should be and is its own package you can opt-in if you need it. In my experience in any API the authentication can be common pre-packaged dropin to your project, but authorization requirements are so wide that it's hard to make one to fit all or it would be horribly complex.\n. What's the benefit?. https://github.com/graphql-dotnet/server/blob/develop/README.md. Version GraphQL -Version 2.0.0-alpha-800 has the new target. Is the problem in query query?. For benchmarks could use this https://github.com/dotnet/BenchmarkDotNet. When closing a PR there's an option to do an squash merge. This doesn't require the creator of the PR to squash or rebase the commits.. You can handle it with the unsubscribe of your observable. #496 should fix this issue. Use Observable.FromAsync or Task.ToObservable. . What is stream? Are you in control of stream.SubscribeAsync ?. OK. The problem with allowing async resolver was due to IObservable being also awaitable. Allowing returning Task> would open a hole for some very interesting bugs to creep in.. @lwansbrough sorry for the delay. Many devs have been waiting RX to include async observable support but so far the progress on that has been slow. What I read from Orleans issues some people have worked on wrapping the orleans stream into IObservable. You could ask the same question there first? I'm currently on vacation and will check this again beginning of next year.. So it's this https://github.com/dotnet/roslyn-analyzers/blob/master/README.md. You probably have already looked here https://github.com/graphql-dotnet/server/tree/master/samples/Samples.Server. This is currently blocking easy async/await with Rx https://github.com/Reactive-Extensions/Rx.NET/pull/435  . @lwansbrough I made a PR with async subscriber support. Can you check it out if it helps with your problem.. Should be easy to setup for tests with this https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL.Tests/CultureTestHelper.cs. Not sure if this is fully fixed but at least the tests now pass. Will add some helpers. @joemcbride added some helpers. Note that I also pushed the global.json sdk version to latest.. Could you get the schema out from the introspection endpoint?. These tools https://github.com/apollographql/apollo-client-devtools are for client development. So you need a client side app which uses Apollo. Then you should be able to use them.. You can close and reopen the PR to trigger the build. Using obsolete for obsolete methods is quite common and getting the warning about is quite useful so people know to migrate away from it.. I think this is not supported. Care to make a PR for it?. No idea why the build fails. This still requires a bit of work. Thanks. That was fast :). Hijacking UserContext for this seems just wrong, but that's an another topic (#637)\nIn your example _scopedService would still be a singleton as FooType would be part of the Schema and schema would be singleton. You would need to resolve it inside the resolver which you probably meant.. I'm trying to simplify interfaces and the context for resolving fields so I can actually add to them features related to two other issues I opened earlier. Now the resolving just has too much magic related to the type of the source object, using new keyword in the interfaces, weird inheritance chain in the context that any changes to them causes too many complications.. Ok no problem. I'll see if I can clean it up without breaking anything.. It will be only \"cached\" for the duration of the query so that same data won't be resolved more than once during the graph execution.. You can combine this https://github.com/graphql-dotnet/server/tree/develop/src/Transports.Subscriptions.Abstractions and SignalR. Have been planning on doing it but summer taking too much of my time to sit at the computer outside work. \nOh and you can easily have observables with SignalR https://github.com/aspnet/SignalR/tree/dev/samples/SignalRSamples. This sounds like a common problem when running asp.net or any web server app under a reverse proxy and different base path. Use PathBase extension to tell the app that it's running under a path base. Docs https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.usepathbaseextensions.usepathbase?view=aspnetcore-2.1.. Of course.. I think the whole parsing, coercing etc. needs an overhaul. Currently \"converting\" values is happening in way too many places, but I think that kind of refactoring is outside the scope of this PR.. So do we change this part somehow?. Await with Task.FromResult... . Do we lose context if only exception message is added? Should it contain the whole ex.ToString()?. Especially in case of AggregateException etc... ",
    "diaconesq": "@joemcbride The link to the spec for subscriptions ( http://facebook.github.io/graphql/#sec-Subscription ) now redirects to http://facebook.github.io/graphql/October2016/ which doesn't seem to contain anything subscription-related. Do you happen to know where the subscription docs moved?\nUpdate\nThe WayBackMachine has a snapshot:\nhttps://web.archive.org/web/20170813042021/http://facebook.github.io/graphql/#sec-Subscription-Operation-Definitions\nIt seems like subscription-related stuff has methodically been removed from the last incarnation of the spec. Hmm.... Thank you for the quick reply!\n\nOne other thing may be that the dynamic type may need to be registered with the Schema directly. This test shows a dynamic schema being created\n\n^^ this \nOnce I registered the complex type's instance in the schema (and gave it a name), it worked!\nThanks a lot for showing me the direction! This exercise also helped me better understand how the GraphQL type hierarchy should be defined. \nI owe you a beer, if you're into that :)\nFWIW, what I'm trying to do is create the GraphQL schema dynamically by parsing a set of JSON Schema documents (with some conventions on how to represent references between types) and later resolve their values from a JSON document store (possibly DocumentDB).\nI feared I would have to generate C# code from the JSON schemas in order to have it compiled and thus usable with the strongly-typed API of GraphQL-dotnet, but this dynamic run-time schema definition saves me tons of hassle!. Thank you for adding this! \nI gave it a try -- but hit issue #257.. BTW this is a regression - it works before support for runtime unions.. Wow, that was fast!\nI confirm it's working - thanks a lot!. ",
    "junelau": "It's still on the master spec.\nhttps://github.com/facebook/graphql/blob/master/spec/Section%206%20--%20Execution.md. Thanks for the subscription executer \ud83d\ude04 \nFwiw, I made a small chat sample with groups.\n. ",
    "cdroulers": "Should I put my tests in a \"Bug\" specific file?\n. How does this look?\n. Let me rebase!\n. All good!\n. I was going to create this issue today! Thanks! :D\n. There seems to be a mention of location in this comment: https://github.com/graphql-dotnet/graphql-dotnet/pull/127#issuecomment-237761918\n. I'm not sure where to look, any pointers on where to look more specifically?\n. If I remove the code I changed in WithLocation, the nodes don't have proper line / column information.\nHere is a screenshot of the debugger at DocumentExecuter:205.\n\nIf I understand correctly, I can add the location in a few places you pointed out, but I need to keep my code which calculates the line/column. Maybe I can make that code evaluate lazily in SourceLocation or something like that so the computation isn't done for every node of the AST and only when an error occurs?\n. I could also make the AddLocation return this so it would be one line to throw an error and not 3.\ncsharp\nvar error = new ExecutionError(\"Schema is not configured for mutations\");\nerror.AddLocation(operation);\nthrow error;\nBecomes\ncsharp\nthrow new ExecutionError(\"Blah\").WithLocation(operation);\n. I was just figuring all that out as your message came in. I'll look at ValidationError! commit incoming!\n. To have the document.OriginalQuery in most of the places where .AddLocation is called, I have to modify a lot of methods to pass the document all the way down. Is that acceptable?\n. I had to fix indentation in CoreToVanillaConverter back to what it was. Visual Studio indented all the switch/case curly brackets one level for some reason. Can't find the setting. Anyway, it's fixed and everything has a test!\n. Does github do automatic rebasing now?\n. Sweet! Good to know!\n. Not why this is here? VS keeps adding this when I run the tests.\n. Exact same version. I'll just remove the change from the PR and rebase.\n. I was wondering where to put them. I'll move them back!\n. ",
    "rwg0": "I think you also need to change the where clause on \nObjectGraphType.ConnectionBuilder<TNodeType, object> Connection<TNodeType>() where TNodeType : IObjectGraphType\nfortunately can work around this by creating the ConnectionBuilder manually and that seems to work. Thanks :)\n. ",
    "ryanlewis": "Looks like I got my root query definition wrong - problem went away when I just implemented ObjectGraphType, (possibly jiggling a number of other different things).\n. ",
    "huysentruitw": "How is this related to AutoMapper?. When you think about it, List just isn't so great to use as input/output type, because you want something more immutable. I'd rather suggest to change your habit of using List everywhere \ud83d\ude04 . Any idea when this gets released? I'm currently running into dead-lock issues with dataloader in 2.1.0 when calling EF Core queries with async/await. When I call everything synchronously and return Task.FromResult everywhere, I don't have the dead-lock issue. I wonder if the changes in this pull-request affect this behavior.. Moved to  #855. Moved to #855. Moved to #855. Yes, tried your second suggestion in an other project and it works, thanks. Always better to work with expressions instead of a hard-coded string \ud83d\udc4c . I have decompiled those 3 packages and ran the code through KDiff3.\nOnly change between 937 and 938 is this commit: https://github.com/graphql-dotnet/graphql-dotnet/commit/fbfc8c3ebe86fbeed7ca5ccb378252cb9e994ae9#diff-b4c19b6d66951c1c5d547222ae0d874b\nChanges between 938 and 947 is this probably related to the change in DateGraphType: https://github.com/graphql-dotnet/graphql-dotnet/commit/ad9c5c8523dde84dd040755a80d829b1f74ede9e#diff-6ecb3c17fef816d6cd02a67ad408ea9eR17 which can probably be fixed in graphql-conventions by using the new DateTimeGraphType instead. Let me check...\n. Ok fixed both issues https://github.com/graphql-dotnet/conventions/pull/106/files. I've tested the same successfully with my own implementation YADI \ud83d\ude01 \nSee the Yadi branch: https://github.com/huysentruitw/conventions/tree/sample/yadi\nAnd even with async EF Core calls: https://github.com/huysentruitw/conventions/tree/sample/yadi-async-repos\nI think the reason is the while loop, which keeps running and checking for new loaders: https://github.com/huysentruitw/yadi/blob/master/src/Yadi/DataLoaderContext.cs#L49. Ok, I do have a DataLoaderContext per request (thanks to DI), so I don't need that accessor in my example. However I see that the GraphQL convention listener is only triggering the DispatchAll once per query (BeforeExecutionAwaitedAsync) instead of per step. Is BeforeExecutionStepAwaitedAsync called multiple times per query?. I've found out it does and that totally makes sense. Thanks for the heads up! I will try to call DispatchAll on BeforeExecutionStepAwaitedAsync tomorrow, but that will likely solve my issue here.\nWill test tomorrow and report back. Thanks for your time already.. triggering the DataLoaderContext in BeforeExecutionStepAwaitedAsync instead of BeforeExecutionAwaitedAsync fixes this issue. Closing now.\nThanks again \ud83d\udc4d . I totally missed the BeforeExecutionStepAwaitedAsync event which will probably solve my test case.. @joemcbride - gentle ping \ud83d\ude0a. The problem will be in the code behind, please share a snippet that shows how the roles are resolved inside the project item class.. Don't add this dependency in the PR. I know this is not optimal, so if we can find any non-dead-locking solution without Task.Run, I'm all for it!. ",
    "slottjj": "Apologies. I've used incorrect terminology. Ignore AutoMapper. What I had intended to say is that I found it of use to utilize reflection against my transport objects in order to establish graphql schema information.\nSorry for the confusion.. ",
    "lngr": "Yes, indeed I think it's unsafe to force UTC. In fact we originally transferred all dates in our local timezone (servers and clients are known to be in the same TZ) before we switched to UTC throughout the stack.\nNewtonsoft's JSON-converter is actually pretty good at figuring that stuff out, it'll use Unspecified if the \"Z\" or another time zone identifier is missing and use UTC if \"Z\" is specified.  And you can already set global config settings that forces UTC serialization in JSON.NET, no need to duplicate that in GraphQL.NET IMO.  I would leave that issue to the JSON converter. :)\n. This breaks UTC Dates that are resolved within resolvers.. No harm caused \ud83d\ude04  I tried to come up with a unit test that catches the bug but was not successful yet.. Yes, I tested it and this fixes the bug. \ud83d\udc4d . Bad.. ",
    "rolfwessels": "@holm0563 thanks for the fix. Works great. \nIs there a way that I can set that as the default type for date time?\nThey way it is written now:\nField(d => d.CreateDate,type: typeof(OriginalDateGraphType)).Description(\"Create date.\");\nPreferred:\nField(d => d.CreateDate).Description(\"Create date.\");\n. Hi,\nI'm on the latest version.\n<PackageReference Include=\"GraphQL\" Version=\"2.0.0-alpha-952\" />\n<PackageReference Include=\"GraphQL.Authorization\" Version=\"1.0.16-alpha-16\" />\n<PackageReference Include=\"GraphQL.Server.Transports.AspNetCore\" Version=\"3.1.0-alpha0022\" />\nI have a test setup where I pass the same data to WebAPI model and to the GraphQL object. The WebAPI  shows the date \"2016-09-17T09:46:37.749+02:00\" and graphQL date system shows it as \"2016-09-17T09:46:37.749Z\".\n. @joemcbride Sure, Let me see what I can do about the sample code. To answer some of the questions\n1) I use Field(d => d.CreateDate).Description(\"Create date.\"); do I believe it uses DateTimeGraphType\n2) The data comes from mongo db. I have two interfaces over the same data ( web api and graphql )\n3) I have never set any specific culture so it will use my system settings. Which are set to +2h and standard date time format for my current region \"south africa\"\n. Hi,\nSo I have gone ahead and created a branch where I remove the OriginalDateTimeType. \nhttps://github.com/rolfwessels/CoreDocker/tree/bug/date-utc\nI have also setup a test to show what is expected.\nhttps://github.com/rolfwessels/CoreDocker/blob/755289dee2cf27f02b5f5cd9f66c06b1aebfcd03/test/CoreDocker.Sdk.Tests/WebApi/UserApiClientTests.cs#L159\nWhats a bit strange is that it now seems to use the DateType. Actually the behavior has changed some how. Before I was on the latest alpha version I had the issue where we were 2hours out (based on +2h). No it seems to map my date to a Date without time. clearly I'm doing something wrong with the setup.\nSome pointers \n Sorry but these are integration tests so they currently require a local mongodb connection :-/\n IOC is in  https://github.com/rolfwessels/CoreDocker/blob/bug/date-utc/src/CoreDocker.Api/AppStartup/IocApi.cs#L45\n* Specification https://github.com/rolfwessels/CoreDocker/blob/bug/date-utc/src/CoreDocker.Api/Components/Users/UserSpecification.cs#L27\nNot sure what else you need. Please let me know if you see something obvious.\n. ",
    "alerdenisov": "Thanks for advice. I found what I need \ud83d\udc4d \n. I'm found \"way\" to debug. I just use DocumentValidator.Validate at begin of initializing my controller and throw Exception if document isn't valid. Work okay for me. \nBut.. Let's return to DEBUG environment? If I'm throwing serialized exception I got detailed info (with InnerException), but as Response I just having message field. I guess, is it problem on my side?\n. Sure, I will. In few words I have PublishedContentInterface : InterfaceGraphType<IPublishedContent> and a default type: PublishedContentType : ObjectGraphType<IPublishedContent>. It works well as expected, but I want to provide way to create something like PublishedWikiPageType : ObjectGraphType<IPublishedContent> what will be returned if fit to model (IsTypeOf = source => (source as IPublishedContent).Alias == \"wikiPage\" for example) in any way it should return default PublishedContentType object\n. Interface class \ncsharp\npublic class QLPublishedInterface : ExtendedInterfaceGraphType<IPublishedContent>\n    {\n        public QLPublishedInterface()\n        {\n            Name = \"PublishedInterface\";\n            Description = \"Published content graphql interface\";\n            // ... fields initialization\n        }\n    }\nDefault class\ncsharp\n    public class QLPublishedContentType : ObjectGraphType<QLPublishedContent>\n    {\n        public QLPublishedContentType()\n        {\n            Name = \"PublishedContent\";\n            Description = \"Published content graphql type\";\n            // ....fields \n            Interface<QLPublishedInterface>();\n        }\n    }\nand for example special type:\n``` csharp\npublic class PublishedWikiPageType :\n    ObjectGraphType<QLPublishedContent>\n{\n    public PublishedWikiPageType()\n    {\n        Name = \"WikiPage\";\n        Description = \"Wiki page type of the content\";\n\n        // ... base fields\n        // extra wiki's fields\n\n        Interface<QLPublishedInterface>();\n\n        IsTypeOf = src =>\n        {\n            var published = (src as QLPublishedContent);\n            if (published == null) return false;\n\n            return published.DocumentTypeAlias == \"wikiPage\";\n        };\n    }\n}\n\n``\n. I need to something such asLastChanceIsTypeOfinsideQLPublishedContentTypeor something such as[TypePriority(int priority)]and decide what type from list is best by attribute\n. Right now I handle it by movingRegisterType()` over base type registration, but it isn't' a perfect solution as I think. \n. ",
    "geocine": "@joemcbride  No worries. I do want to ask though if that yarn output is normal on windows?\n. Thank you\n. If anyone wants to know\nvar container = new Container();\ncontainer.Configure(config =>\n{\n    //GraphQL\n    config.For<StarWarsQuery>().Use<StarWarsQuery>();\n    config.For<HumanType>().Use<HumanType>();\n    config.For<DroidType>().Use<DroidType>();\n    config.For<CharacterInterface>().Use<CharacterInterface>();\n    config.For<StarWarsSchema>().Use(x => new StarWarsSchema(type => (GraphType)  container.GetInstance(type)));\n});\n. Thank you @joemcbride @xplatsolutions \n. ",
    "xplatsolutions": "Could you please elaborate on using async /await extending the Field () method, it is very important in today's C# applications.\nI tried the below but no luck of using it in my graphtype\npublic static class ObjectGraphTypeExtensions\n    {\n        public static void Field<TGraphType>(\n            this IObjectGraphType obj,\n            string name,\n            IGraphType type,\n            Task<Func<ResolveFieldContext, object>> resolve = null)\n        {\n            var field = new FieldType();\n            field.Name = name;\n            field.Resolver = resolve != null ? new FuncFieldResolver<object>(context => resolve) : null;\n            obj.AddField(field);\n        }\n    }\n. Thanks for the quick answer and great library.\nI get compilation error in field.ResolvedType = type; looks like this property does not exist in FieldType in latest version, I'm using 0.13.0.562.\nAlso, I need something like this,\nFieldAsync<ListGraphType<CustomGraphType>>\n. Thanks, it worked now, I was very close, just my extension didn't appear until I add \"this.\", pff. I also noticed that somehow it was awaited because I was getting results, but, exceptions will be swallowed. \nLooks good now.\n. Hmmm, I get what you mean and thank you for the example. \nI need this to be agnostic so at the moment I will just work it out using a different endpoint and just pass the results through GraphQL to filter response.. ",
    "MisterJimson": "Sorry to comment on a closed issue, but do we still need to write our own extension method to support async/await in resolve?. ",
    "dbettin": "That looks great!  How does it do the instance resolution? \n. Also, how close are you to merging this PR?\n. FYI - this worked wonderful for me.  Do you know when this will be published to nuget?. I installed 0.13.1.601 and it is not finding ResolvedType.. ",
    "MarkPieszak": "Anytime, just getting into the project now so I'll be sure to help contribute if you guys don't mind! :)\n. ",
    "jlebensold": "See http://stackoverflow.com/questions/40547164/file-upload-with-relay-and-graphql-dotnet/40553857#40553857\n. ",
    "ZenSoftware": "Yes that is correct.  I installed yarn via npm install -g yarn\n. I uninstalled yarn via npm uninstall -g yarn and then installed yarn via the Winows msi package.  I went ahead and git clone the repo again and went through the sequence of commands described in the original post. yarn is now v0.16.1 after the msi install.\nAfter yarn install there seems to be a bit more of a messy error in regards to optional dependencies, I am presuming it is irrelevant.  yarn start will go ahead and start the webpack processing, but fails again in the same manner.  If I may speculate, maybe it is something failing in the webpack bundling, rather than yarn.  Although I guess webpack would fail due to something funky going on in how yarn brings down node_modules.  Sorry I am not sure how to investigate further.  I have only stumbled across this repo today, but would love to support it.\nSystem configuration this time\nWindows 10 Home v10.0.14393 Build 14393\nnode v7.1.0\nnpm v3.10.9\nyarn v0.16.1\nIf you are interested, here is the log for the command prompt for this particular configuration.  Everything is the same besides the optional dependency error, again, I am presuming is irrelevant (although it did not happen when I had the latest version of yarn v0.17.2).\ncommand-log-yarn0-16-1.txt\n. Alright! I managed to get yarn start to works on node v6.9.1!  \nFinal successful combination for my system:\ngraphql-dotnet master branch v0.13.1.601\nWindows 10 Home v10.0.14393 Build 14393\nnode v6.9.1\nnpm v3.10.9\nyarn v0.17.2 \nI tested that both the MSI package for yarn, and yarn installed via npm, both fix the issue if using node v6.9.1.  Although, neither yarn combination works using node v7.1.0.  Hopefully it will help you narrow down what is going wrong.  Cheers my friend @joemcbride\n. So after a bit of poking around, the solution to construct Inputs via an already parsed Variables is actually quite simple.\nCopy the private static function GetValue(object value) - /src/GraphQL/StringExtensions.cs#L80 and use the following code to construct the Inputs object required to execute the query:\n```\npublic async Task PostAsync(GraphQLQuery query)\n{\n    Inputs inputs = null;\n    if (query.Variables != null)\n    { \n        var variables = query.Variables as Newtonsoft.Json.Linq.JObject;\n        var values = GetValue(variables) as Dictionary;\n        inputs = new Inputs(values);\n    }\n    ...\n    ...\n    var result = await ExecuteQuery((Schema)_schema, queryToExecute, null, query.OperationName, inputs);\n    ...\n    ...\n}\npublic class GraphQLQuery\n{\n    public string OperationName { get; set; }\n    public string NamedQuery { get; set; }\n    public string Query { get; set; }\n    public object Variables { get; set; }     // <-- Set to type object instead of string\n}\nprivate static object GetValue(object value)\n{\n    // Copied from https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/StringExtensions.cs#L80\n    ...\n    ...\n}\n```\nIt would have been really nice if GetValue(object value) was a public utility function.  I'll submit a new issue that is a feature request, in regards to refactoring it out as a utility function. This issue became a bit unwieldy to decipher...\nThanks a bunch @joemcbride, you can go ahead and close this issue.\nAgain, we're big fans over here.  We're 100% behind this project!. @jannikbuschke & @TehWardy  There is a library written by @SimonCropp / GraphQL.EntityFramework that we are using to implement cursor based pagination in GraphQL.  It utilizes EFCore as the data access layer to implement your graphql-dotnet types.  It has a many impressive querying features you get for free, including pagination.  Though I should mention that there are some major flaws to this library. Namely:\n\nGraphQL fragments are currently not supported. \nThere are some type introspection issues for parameters.  Query parameters for this library always introspect as a String array, which can break type generation tools like Apollo CLI.\nDeeply nested relations sometimes need to be explicitly included.  Which can be hard to figure out if you are a novice.  Though this is not really the fault of the library, as it is simply a more fundamental problem of data access querying in general.. \n",
    "leandrozapata": "Thanks for your help! . ",
    "MrFlorent": "Hi everyone !\nI was just wondering if there had been any updates on GraphQL dot net server used in production mode ? \nWith a bad or happy ending :) \nRegards,\nFlo. ",
    "biapar": "So, I wish to try to use (ReactNative)<->.NET Core WebAPI + GraphQL DotNet <-> SQL Server and as second try (ReactNative)<->FeahterJS <-> .NET Core WebAPI + GraphQL DotNet <-> SQL Server\nWhat Do you think about?. I wish to use Feathers for its realtime functions and front end to react native, I wish to use .Net Core WebApi because I know c# and this is more familiar for me. . ",
    "siada": "Is the first option not built in? Does it have to be part of my GraphType? I don't actually manually construct any of my Graph objects, I use the attachment from https://github.com/graphql-dotnet/graphql-dotnet/issues/196 to generate them, could this be causing my isssue?\nEDIT: as a side note; Pascal case appears to have no effect on the result, switching to camelCase the issue still occurs.. Okay glad we found that out haha, could you point me in the right direction with how to achieve what I'm trying? I've read through the official GraphQL docs and it does mention about parameters like first, last, skip etc. I'm just trying to get the first element of an array.. ",
    "jeremydmiller": "@joemcbride I'd strongly recommend you point users at Strongnamer and try to hold off on signing the assemblies. ",
    "Mischi": "Yes, Strongnamer works perfectly for us \ud83d\udc4d Didn't know about it before. Thanks for your quick help!. ",
    "MakaBuka": "Hi joemcbride,\nFirst of all, thank you for the prompt replay. \nAccording to EntityFrameworkExecutionTests.cs I found that you're using EFcontext (based on DbContext - which includes populating objects with data from a database, change tracking, and persisting data to the database):\nvar schema = GraphQL.CreateDefaultSchema(() => new EfContext());\nIt's mean, that we will have up-to-date data (let's assume that our EFContext is configured and working with MSSQLLocalDB).\nIt would be great if you clarify me (or just send  me an example) how it works without EF (in case when we have to retrieve/update data from database like mysql or mssql) \nLooking forward to your reply.\nThx, Dima.. @jphenow haven't implemented yet (not be able to do it, at least during this week).\nFor sure, keep us posted with attempts here. I've just investigated implementation of DataLoader and have a few questions:\n1) is it correct, that now, dataloader just cache similar queries? lets say get user (id: 1) {name} more that once\n2) I haven't found solution for n+1 issue (classic case: we have 3 requests in our resolver - user(id:1){name}, user(id:2){name}, user(id:3){name} - it should be combined in the end to sth like this - users(id in (1,2,3)) {name}\n--\nCould u please advice how we can resolve issue that IS described above?\nThx, D.. @johnrutherford thx for prompt reply\nI'll double check docs , but yeah, it would be nice to have more examples.. ",
    "ronnyek": "I too am trying to do something similar (reflection on occasion). Keep ending up with weird results... I think after the inclusion of the registerTypes, things are better... but still getting random errors whilst trying to hook graphiql up to my automatically generated list.\nDo you have recommendations on how I can say inject a context for resolving method results? Eg, at the time I'm doing the mapping, I could easily get at the context and do something like this...\nFieldType.ResolveFunc = ()=>{return capturedRepository.All()}\nAre there any built in functions in the library to validate a schema before trying to query it? I saw a validator, but seemed to validate queries more so than schema. \nIm getting Error: Invalid or incomplete schema, unknown type: null, (from graphiql) and would like to know sooner than later that the schema I built is actually usable.\n. Actually all that information ended up working out super good... I think the confusion was caused about how we have to add objectgraph types with fieldtype. Seems like that could be simplified with some helpers, or a fluent builder or something.\nWhen I'm creating a field of ListObjectGraph, I set the fieldtype to a custom fieldresolver so I can take advantage of the contexts... but I never see code trying to enter into the resolve method while introspecting schema, or querying for that list. (seems like if I was trying to build this out at runtime, I need a resolver that doesnt operate as a generic class) . Ok, so I've already found valuable stuff here that will help elsewhere, but my point is I don't have classes that inherit from some ObjectGraphType.  So I need to be able to say generate the equivalent of marking an arbitrary class up with ObjectGraphType dynamically. Because I'm iterating through properties, generics will likely not work unless the methods were setup with type inference. Looks like some of the derivation tests might have an example how to achieve what I'm after. I'm gonna continue to dig through that after writing this up, so if it becomes glaringly obvious I'll update this.\nBetter example would be Starwars since everyone uses that for examples in graphql.\nPseudo Code for basically iterating my repository which can be marked up with my own custom attributes. Maybe graphql-dotnet was not at all designed to work this way, and thus my difficulty.+\n```\n[GraphQlEnabled(\"Droids\")] //think this should just generate another object that has maybe AllDroids?\npublic class DroidRepository{\n...\n}\n[GraphQlObject] //should theoretically just pull properties off into derived types\npublic class Droid{\n...\n}\nvar query = new ObjectGraphType(); // create root level element\n//make sure schema understand what a droid is vs a human\nassemblies.GetTypes()\n.Where(x=>x.GetCustomAttribute()!=null)\n.ForEach(t=>query.AddDerivedType);\nassemblies.GetTypes()\n.Where(x=>x.GetCustomAttribute()!=null)\n.ForEach(t=>query.AddTopLevelPropertyThatGetsMethodsAndPropertiesFor(t))\nreturn query;\n```\n. No no... I think its good and again I appreciate your patience... I think conceptually the dto exposure is actually pretty straight forward... I'm not asking anyone to build me anything. Just trying to understand how (or at this point, if I even can achieve this)\nThe first part tho... I dont want my structure to be hard defined in a query class... I want to build dynamically... so instead of creating Query class... I'd like to be able to have a builder or something... and I dont mind building that, but in the raw GraphQL-dotnet stuff... I cant seem to figure out how to just build a tree.\nso instead of \n```\npublic class Query{\n[GraphQlFunc]\npublic List GetDroids(){\n}\n[GraphQlFunc]\npublic List GetHumans(){\n}\n}\n```\nI'm trying to do this...\n```\nvar query = new Schema();\nquery.AddGraphQlFunc>(\"Droids\", Func); //cant seem to figure out how to achieve this\nquery.AddGraphQlFunc>(\"Humans\", Func);\n//and do I need to manually expose my dtos to schema?\n//or maybe be able to have high level object that exposes more functions like DroidContext that will let me have a hierarchy like\nquery.Droids.AllDroids\nquery.Droids.DroidsWithFriends\n```\nI'm trying to effectively building a list of get funcs or whatever. For all intents and purposes the only thing I want generated based on class is the dto / known type stuff.\nAlso, I guess is part of my confusion is the schema itself... \ntype QueryRoot {\n  droids: [Droid] //is this a List type? Is it a function that returns a list? does the schema denote how items will be fetched?\n  humans: [Human]\n}. ok, that's exactly what I was looking for. I'll play with that a bit more. I think that explanation along with some of the type resolver stuff you have in conventions, I've got a very good idea of what else I'll need to do. I appreciate you taking the time to answer these questions\n. ",
    "lcola": "I tried to pass an id in 2 different way, but the results are the same.\n\n\nFollowing Local variables (the stack trace is null)\n\n\nI also tried to make a query without parameters; response is the same \n\"message\": \"Error trying to resolve ruoli.\"\n    public IBeachDBQuery()\n    {\n        Name = \"Query\";\n        Field<ListGraphType<RuoliType>>()\n            .Name(\"ruoli\")\n            .Resolve(ctx =>\n            {\n                using (var db = new IBeachDBModel())      // public partial class IBeachDBModel : DbContext\n                    return db.ibb041_tbruoli.ToList();\n            });\n    }\n\nBelow my PostAsync method (is the same using in the graphiQL original sample):\n  [HttpPost]\n    public async Task<HttpResponseMessage> PostAsync(HttpRequestMessage request, GraphQLQuery query)\n    {\n        var inputs = query.Variables.ToInputs();\n        var queryToExecute = query.Query;\n\n        if (!string.IsNullOrWhiteSpace(query.NamedQuery))\n        {\n            queryToExecute = _namedQueries[query.NamedQuery];\n        }\n\n        var result = await _executer.ExecuteAsync(_ =>\n        {\n            _.Schema = _schema;\n            _.Query = queryToExecute;\n            _.OperationName = query.OperationName;\n            _.Inputs = inputs;\n\n            _.ComplexityConfiguration = new ComplexityConfiguration { MaxDepth = 15 };\n            _.FieldMiddleware.Use<InstrumentFieldsMiddleware>();\n\n        }).ConfigureAwait(false);\n\n        var httpResult = result.Errors?.Count > 0\n            ? HttpStatusCode.BadRequest\n            : HttpStatusCode.OK;\n\n        var json = _writer.Write(result);\n\n        var response = request.CreateResponse(httpResult);\n        response.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n        return response;\n    }\n\nAny suggestions?\nRegards.\nLorenzo. @tlil87 nothing has changed; the same error message.\n    public IBeachDBQuery()\n    {\n        Name = \"Query\";\n        Field<ListGraphType<RuoliType>>()\n            .Name(\"ruoli\")\n            .Argument<NonNullGraphType<IntGraphType>>(\"id\", \"codice ruolo\")\n            .Resolve(ctx =>\n            {\n                using (var db = new IBeachDBModel())\n                    return db.ibb041_tbruoli.Find(ctx.GetArgument<int>(\"id\"))**.As<ListGraphType>()**; (with and without)\n            });\n    }. @tlil87: The first error was generated by my **big mistake**:: I create a database library but i didn't copy the app.config settings to WebAPi Web.config settings (a beginner's mistake, grrr).\n\nNow i completly remove all the other error and this is the result:\nquery: {\nruoli (id:1) {\n  ibb041_id\n  ibb041_tipo\n  ibb041_descrizione\n}\n}\nresult:\n{\n  \"data\": {\n    \"ruoli\": {\n      \"ibb041_id\": 1,\n      \"ibb041_tipo\": \"adm\",\n      \"ibb041_descrizione\": \"Administrator\"\n    }\n  }\n}\nThank you at all for your attention!!\nRegards.\nLorenzo. thank you @joemcbride. Could you pls write me on this thread for any news?\nLorenzo. what kind of information do you need?\nI created my own project copying the GraphiQL sample (same controller, bootstrapper, query and schema code).\nIf i try to publish the GraphiQL sample, i get the same result (as follows):\nCode executed by visual studio:\n\nCode executed by IIS:\n\n. OK. resolution completed. tks @joemcbride . ",
    "fbrier": "Did you ever add in that \"debug\" mode? I am having virtually the identical problem. When I am debugging my returned database object does contain data. Everything else looks the same. My error says:\n{\n  \"data\": {\n    \"resource\": null\n  },\n  \"errors\": [\n    {\n      \"message\": \"Error trying to resolve resource.\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ],\n      \"path\": [\n        \"resource\"\n      ]\n    }\n  ]\n}. I am using vanilla graphql-dotnet, ver. 2.0.0-alpha-820. I also added in GraphiQL. I did see your Conventions project. Since my code seemed close to working, I did not want to add another moving part, but it does seem like it would reduce the amount of boiler plate code. If I can get this working, I will definitely look at adding it.\nSo the schema is displayed and navigable in GraphiQL. This is my first project with GraphQL in any language. Looking at the unit tests, it is not clear to me how to set the ExecutionOptions. The examples, based on the GraphQLMiddleware (GraphQLRequest, and GraphQLUserContext) classes being in a project under the GraphQL-DotNet solution, but not in NuGet, the intention seemed that developers would copy and customize those classes in their own project. If so, is this where the ExecutionOptions are set? How?\nIt seems like the DocumentWriter instance injected into GraphQLMiddleware class would need to be aware of the mapping to a GraphQL class, unless it is merely converting whatever POCO with public properties into JSON output, and graph types you create for GraphQL inputs do not matter. Does it matter? It seems like this is where my Resource return object is failing to be converted. The argument is being parsed from the context. The data is read from the database, and returned in the resolve lambda. I too have tried returning a single Resource instance, as well as an IEnumerable (wrapping with a ListGraphType). The only gotchya I can see is that the ResourceType is a ResourceInterface which derives from InterfaceGraphType<> with the Resource as the type. Would that cause a problem? I plan on having many classes that extend the ResourceInterface, I was just trying to get a Query and a Mutation working first.\nAs an aside, your test support classes would be nice to have in NuGet, to create tests for people using GraphQL-DotNet.. And mutations work for me! This is very exciting. Thank you SO much for\nwriting this library.\nOn Thu, Jan 25, 2018 at 1:50 PM, FrederickBrier notifications@github.com\nwrote:\n\nThe exception confirmed that you cannot return an InterfaceGraphType,\nwhich makes sense.\n\"message\": \"GraphQL.ExecutionError: Error trying to resolve resource. --->\nGraphQL.ExecutionError: Abstract type resource must resolve to an Object\ntype at runtime for field Query.resource with value\nARM.Server.Data.Entities.Resource, received 'null'.\\r\\n at\nGraphQL.DocumentExecuter.\nI created an ObjectGraphType to wrap the same Resource object and it\nworked. Now onto Mutations... Thank you!!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/239#issuecomment-360612073,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAuq7NQpNvo96_fSek55f3fDu_pw7cwxks5tOPcbgaJpZM4LJtgX\n.\n. \n",
    "FrederickBrier": "The ExposeExceptions was embarrassingly easy .\n       var result = await _executer.ExecuteAsync(_ =>\n        {\n            _.Schema = schema;\n            _.ExposeExceptions = true;\n            _.Query = request.Query;\n            _.OperationName = request.OperationName;\n            _.Inputs = request.Variables.ToInputs();\n            _.UserContext = _settings.BuildUserContext?.Invoke(context);\n        });\n\n. The exception confirmed that you cannot return an InterfaceGraphType, which makes sense.\n\"message\": \"GraphQL.ExecutionError: Error trying to resolve resource. ---> GraphQL.ExecutionError: Abstract type resource must resolve to an Object type at runtime for field Query.resource with value ARM.Server.Data.Entities.Resource, received 'null'.\\r\\n   at GraphQL.DocumentExecuter.\nI created an ObjectGraphType to wrap the same Resource object and it worked. Now onto Mutations... Thank you!!. I integrated https://github.com/JosephWoodward/graphiql-dotnet \nThere is graphiql in the source in some example code in this repo. I only realized that after looking at the above repo. It was fairly straightforward to integrate. I did have some minor issues with changing the default path. Eventually it executed queries, but now my schema is not longer showing up (problem-of-the-day), so I am not sure how much help I will be beyond the above URL.. I attempted the above approach and am still getting an exception trace from GraphiQL.\njson\nError: Introspection must provide object type for possibleTypes.\n    at invariant (http://localhost:8888/GraphQL/graphiql.js:24179:11)\n    at getObjectType (http://localhost:8888/GraphQL/graphiql.js:29999:29)\n    at Array.map (<anonymous>)\n    at **buildUnionDef** (http://localhost:8888/GraphQL/graphiql.js:30076:47)\n    at buildType (http://localhost:8888/GraphQL/graphiql.js:30020:16)\n    at getNamedType (http://localhost:8888/GraphQL/graphiql.js:29980:19)\n    at http://localhost:8888/GraphQL/graphiql.js:30151:12\n    at Array.map (<anonymous>)\n    at buildClientSchema (http://localhost:8888/GraphQL/graphiql.js:30150:41)\n    at http://localhost:8888/GraphQL/graphiql.js:2140:55\n GraphiQL was displaying the schema in the documentation panel, but now it is not. This type of error trace can occur if you do not use an InputObjectGraphType, however I am, and the stack trace has a buildUnionDef call. I am only using the UnionGraphType to output a response.\nI was also thinking the marshaling could occur from a C# object that looked like:\ncsharp\npublic class ResponseResult\n{\n   public RequestId RequestId {get; set;}\n   public Item Item {get; set;}\n}\nAnd only one item would be non-null.\n. ",
    "KyleGobel": "Ah, it's a property on the the actual type...my bad...closing.. ",
    "cnickeson": "The strongnamer package was able to resolve my issue. Thanks for the help!. ",
    "ghstahl": "We don't need to merge this.  . Did some stepping and proof of concepts in the GraphQL library.\n1. Changed all Dictionaries that have string as the keys to ignore case.\n2. Fixed up some linq FirstOrDefault lamdas to do a case insensitive compare.\nAdmittedly a shotgun approach that fixed the problem and now allows case insensitive inputs.\n. Yea, Context is pretty generic and overused everywhere.  Going off topic, and just for fun, this is a autofac gem where you have to resolve a context from a context and then use that context to do the real resolve.   That was a fun stackoverflow search.\nbuilder.Register<Func<Type, GraphType>>(c =>\n            {\n                var context = c.Resolve<IComponentContext>();\n                return t => {\n                    var res = context.Resolve(t);\n                    return (GraphType)res;\n                };\n            });. _.Match<Field>(fieldAst =>\n                {\n                    var fieldDef = context.TypeInfo.GetFieldDef();\n                    var parentType = context.TypeInfo.GetParentType();\n                    var name = fieldAst.Name;\n                });\nOk, so you did have a parent.\nNext question, is there a more efficient way  for me to get the path, as I would have to traverse up on each of the iterations.   I was hoping to build up the path as I go.\nIs the lifecycle of my ValidationRule class  something that I can count on.  It seems that you keep it around.  I was hoping I could trigger off of the _.Match Operation as a start, and if I see another one, I start over.\n. I had to get this up and working for my asp.net core 2.0 project, and opted to do the following;\n1. I copied all the code from GraphQL project and moved it into a brand new asp.net core 2.0 class library.\n2. I didn't change any code, this stuff is tight!\nNow I have my own \"Temporary\" copy of this library which I will swap out when this one releases a 2.0 compliant one.\nPassed all my unit test.\nAnyway, that's the good news. \n. I was able to correctly track path through walk when there were FragmentSpreads.  I store away the path up to the FragmentSpread and then fix things up when I get a following FragmentDefinition.  \nAnyway, I want to make sure you know that I am tracking visited filed paths for the purpose of authenticating by path.\n```\n{\n\"graphQLFieldAuthority\": {\n    \"records\": [\n      {\n        \"operationType\": \"query\",\n        \"fieldPath\": \"/accessCode\",\n        \"claims\": [\n          {\n            \"type\": \"x-graphql-auth\",\n            \"value\": \"\"\n          }\n        ]\n      },\n      {\n        \"operationType\": \"query\",\n        \"fieldPath\": \"/identity/claims/value\",\n        \"claims\": []\n      },\n      {\n        \"operationType\": \"mutation\",\n        \"fieldPath\": \"/blog2\",\n        \"claims\": [\n          {\n            \"type\": \"x-graphql-auth\",\n            \"value\": \"\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\nThe above, by convention, requires that the user.isAuthenticated and the claims must exist to be authorized.\n. ",
    "pc-lover": "Thanks for the answer. I've just tried to use IsTypeOfinstead of ResolveType (on the InterfaceGraphType) and AddPossibleType. And it only works if there is a field that returns UserGraphTypein Schema.Query.\nFor example:\ncs\nField<UserGraphType>( ... );\nIt looks like if there isn't at least a field which returns UserGraphType in Schema.Query (or maybe Schema.Mutation) then UserGraphType object will not be initialized (UserGraphType's contructor is not even called). So if there is an InterfaceGraphType which returns an object is compatible with UserGraphType, the query result would be null.\nI wonder if I'm missing something?. ",
    "jbaxleyiii": "@ZenSoftware this saved my bacon! Thank you so much!. @joemcbride \ud83d\udc4b I'm from the Apollo team and would be happy to PR support for apollo-tracing and apollo-cache-control if you are open to it!. @joemcbride awesome! I'll start playing around with it over the next few weeks and reach back out! Thanks for this great project \ud83e\udd17 . ",
    "ashleydw": "@ZenSoftware Did you make the PR to make the function public?. ",
    "codepunkt": "@joemcbride @jbaxleyiii @ZenSoftware \nI either had the same problem, or a very similar one.\nWhenever i sent variables, Post Endpoint responded with 500 (System.NullReferenceException, Object reference not set to an instance of an object) because query.Variables is null and therefore ToInputs() can not be called.\nThe variables part of the request body sent to the endpoint is \"variables\":{\"id\":\"2\"}\nWhen i change Variables to public object Variables { get; set ; } and use the code posted by @ZenSoftware, things work as they should. I'm using Web API on .NET Framework 4.6.2 - no other fancy stuff. I'm glad this solution works, but i'm confused why this even happens.\nCan someone shed light on this?. I've read a lot on the subject in the last few hours. My intial questions might have been short-sighted. Two questions remain:\n\ni assume xproj was the project file that was used in combination with project.json?\nthe projects in this repository still use project.json/xproj - i assume #311 will be merged some time soon?. Great, thank you! Looking forward to it! \ud83d\udc4d . Actually, i can't help much with that (yet). I've just been doing .NET for the better part of 2 weeks so i'm actually glad i finally go a basic example running using my Unity DI setup.\n\nGreat to hear you've been thinking about this, though! Will keep an eye on this and might be able to comment or chip in with ideas once i'm more settled in the language and ecosystem! . ",
    "AlexanderSeel": "Hi,  yes it's just in the demo code. The problem with the parsing of the variables is also with a DTO class.  If I parse the values direct in the mutation without variables the mutation runs like expected. It seem to be at the mapping from variables to the input structure.  \nThe problem is at DocumentExecutor.cs in Line 660 Version 'https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Execution/DocumentExecuter.cs#L660' an entry from the subtype list is parsed to IsValidValue Function as a KeyValuePair and at Line 660 it will be casted as a Dictionary.\nIt is possible to have a class with a List of a Subclass as property in a InputObjectGraphType Class?\nGreets Alex . This is the same query without variables and there is no error\ngraphQL\nmutation medirect {\n  createTest(testInput: {name: \"1234\", values: {label: \"1234\", value: \"4321\"}}) {\n    id\n  }\n}\nHere is the changed code with DTO's\n```C#\npublic class StarWarsSchema : Schema\n    {\n        public StarWarsSchema(Func resolveType)\n            : base(resolveType)\n        {\n            Query = (StarWarsQuery)resolveType(typeof (StarWarsQuery));\n            Mutation = new TestMutation();\n        }\n    public class TestMutation : ObjectGraphType\n    {\n        public TestMutation()\n        {\n            Field<TestOutputType>(\"createTest\", arguments: new QueryArguments(new QueryArgument<TestInputType> {Name= \"testInput\"}), resolve: context =>\n            {\n                var testInput = context.GetArgument<TestOutput>(\"testInput\");\n                return new TestType() {Id = \"123\"};\n            });\n        }\n    }\n    public class TestType\n    {\n        public string Id { get; set; }\n\n    }\n\n    public class TestOutput\n    {\n        public string Name { get; set; }\n        public List<TestSubOutput> Values { get; set; }\n    }\n\n    public class TestSubOutput\n    {\n        public string Label { get; set; }\n        public string Value { get; set; }\n    }\n    public class TestOutputType : ObjectGraphType\n    {\n        public string Id { get; set; }\n        public TestOutputType()\n        {\n            Field<StringGraphType>(\"id\");\n        }\n    }\n\n    public class TestInputType : InputObjectGraphType\n    {\n        public TestInputType()\n        {\n            Field<StringGraphType>(\"name\");\n            Field<ListGraphType<TestInputSubType>>(\"values\");\n        }\n    }\n\n    public class TestInputSubType :InputObjectGraphType\n    {\n        public TestInputSubType()\n        {\n            Field<StringGraphType>(\"label\");\n            Field<StringGraphType>(\"value\");\n        }\n    }\n}\n\n```\n. Ok thanks, this solved the problem.. ",
    "LasseNisted": "Sure, it has to do with reusing a schema, so if I change the Execute method in GraphQL.Tests\\Complexity\\ComplexityTestBase.cs to:\n    public async Task<ExecutionResult> Execute(ComplexityConfiguration complexityConfig, string query)\n    {\n        var starWarsSchema = new StarWarsTestBase().Schema;\n        ExecutionResult result = null;\n        for (int i = 0; i < 10000; i++)\n        {\n            result = await StarWarsTestBase.Executer.ExecuteAsync(\n                options =>\n                {\n                    options.Schema = starWarsSchema;\n                    options.Query = query;\n                    options.ComplexityConfiguration = complexityConfig;\n                });\n        }\n        return result;\n    }\n\nTo simply invoke the execution successively with the same schema, then I get a stack overflow in e.g. \nGraphQL.Tests.Complexity.ComplexityValidationTest.should_work_when_complexity_within_params\nIf I add the option:\n                    options.FieldMiddleware = new FieldNoMiddlewareBuilder();\n\nwith the following dummy builder:\nclass FieldNoMiddlewareBuilder : IFieldMiddlewareBuilder\n{\n    public IFieldMiddlewareBuilder Use(Func<FieldMiddlewareDelegate, FieldMiddlewareDelegate> middleware)\n    {\n       throw new InvalidOperationException();\n    }\n\n    public FieldMiddlewareDelegate Build(FieldMiddlewareDelegate start = null)\n    {\n       throw new InvalidOperationException();\n    }\n\n    public void ApplyTo(ISchema schema)\n    {\n       // Do nothing.\n    }\n}\n\nThen the stack overflow disappears since it is due to the builder wrapping the resolve calls in the schema again and again.\nI think the ExecuteAsync method should only apply the FieldMiddleware once (possibly by having an initialization step separate from the ExecuteAsync method).\n. I think you are right. Based on your response I looked into all .Resolve-calls on builders for inputs and none of them seem necessary. Thanks!. ",
    "EniOnGit": "Hello @joemcbride \n\nI don't see that an InputObjectGraphType<T> would be helpful other than generating the fields for you.\n\nIMHO: The possibility to declare typed properties, would be helpfull to prevent errors during conversion from the InputObjectGraphType to  MyClass.\nUsage of the InputObjectGraphType:\n```c#\npublic class MyQuery : ObjectGraphType \n{\n  public MyQuery()\n  {\n  Field>(\"datapoints\", \"Get all datapoints.\",\n    arguments: new QueryArguments(\n       new QueryArgument() { Name = \"ValueRange\"}\n    ),\n     resolve: context =>\n        {\n        var myClass= context.GetArgument(\"ValueRange\"); \n        // using myClass\n        }\n    );\n  }\n}\n````\nInput type Declaration: \nc#\n public class ValueRangeType : InputObjectGraphType\n    {\n        public ValueRangeType()\n        {\n            Field<FloatGraphType>(name: \"to\", description: \"maximal value\");\n            Field<FloatGraphType>(name: \"from\", description: \"minimal value\");\n        }        \n    }\nDeclaration of my MyClass:\nc#\npublic class MyClass \n{\n        public double? From { set; get; }\n        public double? To { set; get; }\n   ...\n}\nTo declare the properties, i have to name them by strings and they have to be equivalent to the MyClass declaration. In case of renaming a property of MyClass, i don't get a hint from the compiler, because of the untyped property declaration. \nCan this issue be solved by making the InputObjectGraphType generic?\n. ",
    "EmmanuelPonnudurai": "Hello @joemcbride Is this piece of code still valid ? I am trying to generate my types dynamically based off of my model but I just cant seem to get the Query to build up correctly. What I have is something like this. But, the types are not getting registered correctly. The code which you have above gives compilation errors right now. May be because the syntax has changed now? If i get it working correctly then I'll be more than happy to add a sample in the documentation? Thanks,\nIm using \n\n```cs\n            var droidType = new ObjectGraphType\n            {\n                Name = \"Droid\"\n            };\n            droidType.Field(typeof(StringGraphType), \"id\");\n            droidType.Field(typeof(StringGraphType), \"name\");\n            droidType.IsTypeOf = type => type is Droid;\n            var root = new ObjectGraphType\n            {\n                Name = \"QueryRoot\"\n            };\n            root.Field(\n                typeof(ListGraphType>), // how do I specify the type of the droidType here?\n              \"droids\",\n              resolve: ctx => new[] { new Droid { Id = \"R2-D2\", Name = \"R2-D2\" }, new Droid { Id = \"K-2SO\", Name = \"K-2SO\" } });\n        var schemaDynamic = new Schema\n        {\n            Query = root\n        };\n\n``\n. Thank you @joemcbride It works now. I was trying to do it with existing overloads for adding fields. I'm wondering why this extension method lives in the test class and can it not be within the other available overloads forField(...)inComplexGraphType.cs`. HI @joemcbride This post has been helpful, however, I am facing a slight organization blip with this structure. In my case, it ends up as as two levels of same verbiage. I'm going by the documentation sample and tweaking a little to explain my situation,\njs\n{studentQuery \n  {sudentData(id: 123)\n    {id fullName }\n  } \n}\nAs you can see here, I am now having to deal with repeated verbiage. studentQuery(this is where I have the root query and register all my other types) and then studentData(this is from the actual type that i call into from the root query). Since I have to name the item in the root query and provide an empty resolver, I end up with two levels of same verbiage. I am aiming for something just like this,\njs\n{sudentData(id: 123)\n  {id fullName }\n}\nAny help would be much appreciated.. Thank you @joemcbride \ud83d\udc4d . I may have something in mind to get around this. If it works, I will be sure to post it here for feedback.. I have a small suggestion. Why don't you use the well tested and solid ADO.NET? \nIt gives you so many features, one of which is to execute queries against SQL Server.\nAll you'd have to do is hookup your resolver to the these and you should be good to go. \nPlease disregard if this is not what you are looking for. Thank you.. ",
    "johnrutherford": "I started working on a DataLoader implementation over the last few days (see #537). As far as I can tell, there's no way to make it work across multiple levels without making changes to the DocumentExecuter. I have it working well on multiple levels, and my next step was to modify the execution flow to maximize the \"batchability.\" \nI don't want to duplicate effort or step on any toes, but I personally need something working within the next week. \nI've pushed what I have so far to the dataloader branch on my fork. Maybe some of you can review and then we can discuss the best direction to go. . I\u2019m adding some more tests and I\u2019ll be submitting a pull request later today with what I have currently. Then I\u2019ll continue to work on optimizing the \u201cbatchability.\u201d. @TwitchBronBron,\nI don't think it's necessarily a bad idea to expose the DataLoaderContext on the ResolveFieldContext. But I also think it should be flexible as well. That was the idea with creating IDataLoaderContextAccessor. Personally I'm using MediatR with my GraphQL types. So I just inject IMediator into my GraphQL types rather than all of the other dependencies that may be necessary to resolve each field. So I need to be able to inject the IDataLoaderContextAccessor to be able to access the current context outside of the resolver delegate.\nOn the second part of your comment, the whole point of a DataLoader is to be able to batch queries. So if you start creating different context instances, it's more likely that you will not be batching as efficiently as possible. For the scenario you described, I think the best solution would be to use the selected fields as part of the data loader key. So there would still be a single context, but each query on the same fields would be batched together. Something like this:\n``` csharp\nField()\n    .Name(\"User\")\n    .ResolveAsync(ctx =>\n        {\n            var columnNames = ctx.SubFields.Keys;\n            var dataLoaderKey = \"GetUsersById[\" + String.Join(\",\", columnNames) + \"]\";\n        var loader = ctx.DataLoader.GetOrAddBatchLoader<int, User>(dataLoaderKey,\n            (IEnumerable<int> ids) =>\n            {\n                //get a list of users, retrieving only the columns requested\n                return users.GetUsersByIdAsync(ids, columnNames);\n            });\n        return loader.LoadAsync(ctx.Source.UserId);\n    });\n\n```. @benmccallum Sorry, it taken me so long to get back to you. I like using MediatR a lot because I can easily add new fields to my types without having to inject a bunch of different dependencies. \nI'm actually currently running a custom middleware that I wrote that resolves a schema instance per request. And I have my Schema registered as scoped. I'd like to switch to the \"official\" middleware if it will respect the configured schema lifetime. See this issue.. I decided to store the customer object on the UserContext when it's loaded. Then I can access it from the resolve context on the order.. I wasn't, but I just added one and registered it. \nGetting the same result. No breakpoints on the value converter are hit. \n``` csharp\n    schema.RegisterValueConverter(new DateTimeOffsetValueConverter());\npublic class DateTimeOffsetValueConverter : IAstFromValueConverter\n{\n    public bool Matches(object value, IGraphType type)\n    {\n        return value is DateTimeOffset;\n    }\n\n    public IValue Convert(object value, IGraphType type)\n    {\n        return new DateTimeOffsetValue((DateTimeOffset)value);\n    }\n}\n\npublic class DateTimeOffsetValue : ValueNode<DateTimeOffset>\n{\n    public DateTimeOffsetValue(DateTimeOffset value)\n    {\n        Value = value;\n    }\n\n    protected override bool Equals(ValueNode<DateTimeOffset> node)\n    {\n        return Value == node?.Value;\n    }\n}\n\n``. Ok, I figured it out. I was usingDocumentWriter(bool indent). I changed it to grab the serializer settings fromIOptions. Thanks for your help!. Pull request #536 should also fix this issue.. I'm also running into the same issue. Even if I go back to an earlier version whereBeforeExecutionAwaitedAsync()` is called at the expected time, it only works for the first level. If there are batched operations beyond the first level, I get a deadlock. \nHas anyone been able to get some sort of DataLoader solution working beyond one level? It appears that the dataloader-dotnet repository has been abandoned. It seems like maybe it would help if there was a hook like BeforeExecutionAwaitedAsync() called for each level.\nI'm just trying to determine if this is even possible with this library at this time or if it will be at any point in the near future. . I haven't really looked at the internals to know whether it should be possible or not currently. \nBut the whole point of GraphQL is to allow the client to query the relationships that they need across any number of levels. So if query batching only works on a single level, then it's not very useful. \n  . I'm not sure why the Executes_IsQuickerThanTotalTaskTime test is failing. The tasks are still being run in parallel and it passes on my local machine. . Ok, great. \n\n\nI'll start with a pull request to the dataloader repository. Then once we have that on a MyGet feed or on NuGet, I can add the dependency to the GraphQL.DataLoader project. I think it would make more sense to have the GraphQL.DataLoader project in this repository since it's going to depend on re-working the DocumentExecuter.\n\n\nYeah, I was looking at the Java port and they have the concept of \"execution strategies\" (http://graphql-java.readthedocs.io/en/v6/execution.html?highlight=strategy#execution-strategies). So something like that could work. \n\n\nYeah, I definitely think it should be more obvious to the implementer that the resolver is going to be executed on a ThreadPool thread. And it should be handled in the resolver itself. The executor shouldn't have to know about it. I'll address that too since it's related to the areas I want to work on. . Ok, it looks like I can't submit a pull request to the dataloader repository because it's empty. \n\n\nI just pushed to this repository: https://github.com/johnrutherford/dataloader. Do you want to look that over and then give me push access? Or you could just add a README or something and then it should allow a pull request.. Ah, ok. I'll keep the dataloader in the main solution then for now. And I'll continue the discussion in #264.. @joemcbride I just pushed some more changes for this. \nI'm working on a separate branch for the ExecutionStrategy optimizations. It's almost done. I'll submit a separate pull request for it.. Ok. Or I can merge all of the tests into one project if that's easier. They're both testing the same library anyway.. My changes for optimizing the execution are ready. Once this pull request is merged, I'll submit another pull request since it obviously depends on this branch.. Ok, all tests are included and passing now. :). @TwitchBronBron You should probably comment on issue #264 since this pull request has been merged already. . Fixed conflicts with the master branch.. Like @drobertson123 it took me a bit to wrap my head around how to build one's graph types. In particular, I was confused about the different approaches. The schema + class and attributes versus creating a class that derived from ObjectGraphType<T>. I didn't think having my schema as a string was going to be maintainable for a real application, so I couldn't use that. And it was a little confusing at first figuring out the different options for creating fields using Field().\nI think something more convention-based with a more typical class structure would be more intuitive. Something like this:\n``` csharp\n[GraphQLType(\"User\")] // Optionally used to override type name\npublic class UserType : ObjectGraphType\n{\n    // All public properties and methods are exposed by default\n    // Field name and graph types are inferred\n    public string FirstName => Source.FirstName;\n[Description(\"The User's first name\")]\npublic string LastName => Source.LastName; // Source is a property of type T\n\n[GraphQLField(NonNull = true)] // Attribute is only necessary to override inferred parameters\npublic string UserName => Source.UserName;\n\n[GraphQLField(DeprecationReason = \"Use the UserName field instead\")]\npublic string Email => Source.Email;\n\n[GraphQLField(\"Orders\")] // Override field name\npublic Task<IEnumerable<Order>> GetOrders()\n{\n    ...\n}\n\n}\n```\nSo this has the advantage of using composition to explicitly expose the fields that you want, but is more declarative and feels more like a normal class. . This is what pull request #540 addresses. \nThere is already a test for this (DataLoaderQueryTests.TwoLevel_MultipleResults_OperationsAreBatched()), but it is skipped on the master branch. . I can work on this. @joemcbride, where should this go? In the wiki?. I've started on it, but I'm not done yet. Haven't had much time to work on it. I'll try to finish it this week. \nYou might be able to figure it out from looking at the test project:\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.DataLoader.Tests\nThe IDataLoaderContextAccessor and DataLoaderDocumentListener need to be configured in your DI container. Then you need to add the DataLoaderDocumentListener instance as a listener on the DocumentExecuter. Then check out the OrderType and UserType to see how to get a loader instance and use it in a resolver.. Ok, I've finally completed a first draft of the DataLoader documentation. I'd welcome any feedback on how it could be improved or made clearer. \n@sommarlov That makes sense. There's no way to do that currently, but it could be added.\n@MakaBuka The DataLoader does query batching as well as caching. Check out the documentation and let me know if it explains well enough how to use it to batch queries.. That works. I plan on adding support to the middleware, but haven\u2019t had time. . @benmccallum, you can pass additional arguments using closures. For example:\n``` csharp\nint page = ...\nvar loader = accessor.Context.GetOrAddLoader>($\"GetAllUsers[{page}]\", \n    () => store.GetAllUsersAsync(page));\nreturn loader.LoadAsync();\n```\n``` csharp\nstring[] fields = ...\nvar loader = accessor.Context.GetOrAddBatchLoader($\"GetUsersById[{String.Join(\",\", fields)}]\", \n    (ids) => store.GetUsersByIdAsync(ids, fields));\nreturn loader.LoadAsync(context.Source.UserId);\n```\nAs for automatically generating the cache key, I thought about that a lot when I wrote the DataLoader code. I felt that with \"magically\" generating the cache key, there was the potential to cause bugs that would be very difficult to track down and fix. I decided it would be best to leave it completely in control of the developer. If there is a bug because the same cache key was used, it's very easy to understand the problem and fix it. . If you actually throw the ExecutionError, the field should get set to null. Like this:\n``` csharp\npublic FieldMiddlewareDelegate Resolve(FieldMiddlewareDelegate next) {\n    return context => {\n        if (context.FieldName == \"id\") {\n            throw new ExecutionError(\"Test-Error\");\n        }\n    return next(context);\n};\n\n}\n```. I don't see a valid use case for this. In C#, you can't return a private class from a non-private method, so I don't see a valid reason why this would need to be supported with GraphQL.NET.\n``` csharp\npublic class Foo\n{\n    private class Bar { }\n// This will not compile because of inconsistent accessibility\npublic Bar GetBar()\n{\n    return new Bar();\n}\n\n}\n``\n. Yeah, there's no way for the compiler to tell there that the private class is being exposed. Reflection was being used prior to 870 to get theResult`. That works because reflection allows you to \"break the rules\" and access private fields, classes, etc., that you can't otherwise. \nWhen I made the change to use dynamic, I did some benchmarks and it was considerably faster than using reflection. So I don't think it's worth the performance hit to support this usage. \nI agree it should probably be documented somewhere.. Why the requirement to keep the Schema as a singleton? If it's expensive to create then maybe some stuff can be cached to make it cheap to create. Then a new Schema instance can be resolved per request/execution and lifetimes are respected for all dependencies.. @benmccallum, there are two ways I have done this:\n\nMake the Schema transient rather than a singleton. There is a performance cost to this and we ultimately abandoned this in favor of 2 below.\nUse HttpContext.RequestServices in your UserContext. This is the request-scoped IServiceProvider. You can either resolve your services and expose them as properties on your user context class, or expose the IServiceProvider directly. \n\nHere's an example:\n``` csharp\npublic class MyUserContext\n{\n    public IServiceProvider RequestServices { get; }\n    public IMyService MyService { get; }\npublic MyUserContext(HttpContext httpContext)\n{\n    RequestServices = httpContext.RequestServices;\n    MyService = httpContext.RequestServices.GetRequiredService<IMyService>();\n}\n\n}\n```\nOr you could even declare your dependencies on your user context class and then resolve it like this: httpContext.RequestServices.GetRequiredService<MyUserContext>().. Here's an idea:\n\nAllow for a dependency resolver instance to be passed in through the ExecutionOptions. This would allow you to wrap HttpContext.RequestServices in ASP.NET Core and pass that in. If you're not using ASP.NET Core, this would still allow you to create a custom scope for execution and pass that in. If this is not set at all, it should probably default to the dependency resolver on the schema.\nExpose this as an ExecutionServices property on the ResolveFieldContext class.\nThen implement some field resolvers with 1-3 additional type parameters that handle the dependency resolution. Like this:\n\n``` csharp\npublic class FuncFieldResolver : IFieldResolver\n{\n    private readonly Func _resolver;\npublic FuncFieldResolver(Func<ResolveFieldContext, TServiceType, TReturnType> resolver)\n{\n    _resolver = resolver;\n}\n\npublic TReturnType Resolve(ResolveFieldContext context)\n{\n    var service1 = context.ExecutionServices.Resolve<TServiceType>();\n    return _resolver(context, service1);\n}\n\nobject IFieldResolver.Resolve(ResolveFieldContext context) => Resolve(context);\n\n}\n```\nAnd then set up extension methods so fields could be created like this:\ncsharp\nField<FooType, Foo>()\n    .Name(\"foo\")\n    .ResolveAsync<IMyService>((context, myService) =>\n    {\n        return myService.GetFooAsync();\n    });\nSo this would be equivalent to injecting parameters into a controller action in MVC.\nAs an aside, I think we should get rid of IDependencyResolver and use System.IServiceProvider. That would obviously have to be a 3.0 thing, and not essential to the above. It's a very similar interface and doesn't require any other dependencies, but it would allow for out-of-the-box integration with Microsoft.Extensions.DependencyInjection and any other IoC libraries that have support for it.. Yeah... I think what is happening is that IDs are queued for the first batch and then the operation is dispatched as designed. Then the other IDs are queued, but they do not get dispatched, because it's still part of the same execution step. \nCan you see if rewriting it like this works?\n```\nvar recurrentPaymentTask = recurrentPaymentLoader.LoadAsync(ctx.Source.VaultId);\nvar planTask =  planLoader.LoadAsync(ctx.Source.PlanId.Value);\nvar recurrentPayment = await recurrentPaymentTask;\nvar plan = await planTask;\n```. @flessard, this is still starting and awaiting each task one-by-one. You need to start all tasks and then await all of them. \nTry something like this:\n``` csharp\nvar account = ctx.Source;\nvar recurrentPaymentLoader = _dataLoaderContextAccessor.Context.GetOrAddBatchLoader(\"RecurrentPayment\", _recurrentPaymentResolver.GetByVaultIdsAsync);\nvar planLoader = _dataLoaderContextAccessor.Context.GetOrAddBatchLoader(\"Plan\", _planResolver.GetByIdsAsync);\nvar recurrentPaymentTask = (ctx.Source.VaultId != null)\n    ? recurrentPaymentLoader.LoadAsync(ctx.Source.VaultId)\n    : Task.FromResult(null);\nvar planTask = (ctx.Source.PlanId != null)\n    ? planLoader.LoadAsync(ctx.Source.PlanId.Value)\n    : Task.FromResult(null);\nvar nextPlanTask = (ctx.Source.NextPlanId != null)\n    ? planLoader.LoadAsync(ctx.Source.NextPlanId.Value)\n    : Task.FromResult(null);\nPlanModel plan = await planTask;\nPlanModel nextPlan = await nextPlanTask;\nRecurrentPaymentModel recurrentPayment = await recurrentPaymentTask;\n```. Awesome! Glad we got it working for you. . Yeah, it was really designed to work with DI. But I don't see any problems with the way you've done it.. @pekkah is correct. We wouldn\u2019t want to make assumptions about caching data beyond a single execution. For example, you may need to return different data depending on the user making the request. . The DataLoader doesn\u2019t do anything with threads. There are unit tests that run within a synchronization context to make sure there are no issues with it. \nIs it possible that your code is creating threads or queuing work on the ThreadPool with Task.Run() or something? \nCould you create a simple app that reproduces the issue?. @dBug404, thanks. I've looked into it a bit more. It looks like it's happening because we're using ConfigureAwait(false) in a number of places. Continuations aren't run in the same synchronization context and so HttpContext.Current is null. If we removed ConfigureAwait(false) everywhere, it's possible to cause deadlocks for other users depending on how they are calling things. \nThe DataLoader code doesn't explicitly create threads or queue task on the ThreadPool but it does do a lot of async stuff. And that's necessary to be able to batch requests. \nSo I agree with @joemcbride, that it would be best to pass your HttpContext instance using the UserContext.. I just opened a pull request with some changes that may fix this issue. . For your first question: You should use the same key if you\u2019re using the same fetch delegate. Otherwise you won\u2019t benefit from caching on the other query levels. \nFor your second question: I think you should be able to use the DataLoader within the resolvers for the dependent fields. You could await the result from LoadAsync() and then calculate your return value. For resolvers that use more than one DataLoader, you need to start all tasks (call LoadAsync() without awaiting) and then await them all. Otherwise it may deadlock. . @corstian Yes. . @RehanSaeed, where are you referring to? Other than in unit tests, I don't see any calls to Task<TResult>.Result where the task is not being awaited first. . @RehanSaeed, ah yes, I noticed that problem too. That was part of the reason I did https://github.com/graphql-dotnet/server/pull/158.. @joemcbride, looks like the AppVeyor build failed when downloading yarn packages (unrelated to my changes). Are you able to manually trigger a new build?. @huysentruitw, these changes are unlikely to make a difference if you\u2019re having deadlocks. Can you open up a new issue with some more details and tag me? I can try and help you there.. @DSilence, @joemcbride, @pekkah, who wants to update the server project to use this?. I had some free time, so I went ahead and did a pull request to use this from the server project for the HTTP middleware. I did not make the change for web sockets as part of this pull request.. Yeah, I had also noticed that test was flaky. It should be fixed in PR #808.. I think we should somehow make the call to filter the node be async to make it easier to work with IAuthorizationService.AuthorizeAsync() in ASP.NET Core. \nBut most of the time, you're going to do a quick synchronous check first to see if you need to do an authorization check on the current node. \nI wonder if ValueTask<bool> would be appropriate for this. Or maybe use an interface with two separate methods like ShouldCheckNode() and FilterNodeAsync() or something. \nThen to avoid having to re-write a bunch of methods to make them async, the check could be moved to the beginning of ExecuteNodeAsync() and then add a Skip property to the node. This property would be checked when building output. . If _accessor.Context is returning null in BeforeExecutionStepAwaitedAsync, that indicates a more fundamental issue. \nAre you able to write a unit test or provide a sample that reproduces the issue? \nSetting the DataLoaderContext in BeforeExecutionStepAwaitedAsync might stop the errors for you, but it's not addressing the underlying issue. And it could cause deadlocks if you were using the DataLoader and a new context was being created on each call to BeforeExecutionStepAwaitedAsync.. Hi, it looks like you're just not using the DataLoader correctly. Please refer to the documentation here: https://graphql-dotnet.github.io/docs/guides/dataloader#setup. Specifically, you need to set up the DataLoaderDocumentListener. This will automatically call DispatchAll() at the right time on each execution level. And you should be injecting IDataLoaderContextAccessor rather than DataLoaderContext. . The existing DataLoader implementation is working when used according to the documentation. The existing unit tests validate that it works (even within a synchronization context). \nSo I'm not sure I understand the need for these changes. \nYes, the tests still pass, but the code is more complicated. Usage is awkward (e.g., await await ((IDispatchableDataLoader)loader).DispatchAsync(CancellationToken.None);). And work is explicitly queued on the ThreadPool, which is not ideal.. If there is an actual issue with deadlocks, let's start with a unit test that reproduces the issue.. It looks to me like the next delegate needs to be awaited in InstrumentFieldsMiddleware for accurate timing with an async resolver. . Nothing comes to mind. Can you share some code that shows the problem? Then I should be able to see what's wrong.. @nvhoanganh, @aaronjedwards, does the above fix the issue for you?\nIf not, it would help if you could provide some sample code that reproduces the issue. I know there could be unexpected issues depending on when the context is created/accessed in the asynchronous control flow. So it would help to see what exactly you're doing so we could provide better guidance in the documentation or make some changes to help others avoid this too.. @hades200082, can you share the part of your code where the DataLoaderDocumentListener is added to the DocumentExecuter? Maybe a different instance of the IDataLoaderContextAccessor is being used there. . EDIT: Nevermind. . Yeah, I don't see anything wrong with that setup. I'll have to investigate more what could be happening.. @stripeyjumper, thank you. \nI think I understand now what's happening. The dependency injection for the GraphQL types is being handled by the dependency resolver on the Schema which just uses Activator.CreateInstance() by default. So two different instances of DataLoaderContextAccesor are being used.\nI'm not exactly sure why @stripeyjumper's work-around works, though, because it's still a separate instance being created by the Schema. Maybe something with how AsyncLocal<T> works. But it's a simple workaround, if it does work.\nThe other option would be to hook up the Schema to the service container. Something like this:\n``` csharp\npublic class MySchema : Schema\n{\n    public MySchema(IServiceProvider services) : base(new ServiceProviderAdapter(services))\n    {\n}\n\n...\n\n}\nprivate sealed class ServiceProviderAdapter : IDependencyResolver\n{\n    private readonly IServiceProvider _services;\npublic GraphQLDependencyResolver(IServiceProvider services)\n{\n    _services = services;\n}\n\npublic T Resolve<T>() => _services.GetService<T>();\n\npublic object Resolve(Type type) => _services.GetService(type);\n\n}\n```\nI will work on making this easier to do and improving the setup documentation. . @aoakeson, you're registering DataLoaderDocumentListener as IDocumentExecutionListener and then trying to resolve DataLoaderDocumentListener. You need to resolve IDocumentExecutionListener.. @maxr96, could you share some sample code? I\u2019m not sure how that would make a difference. Whether you\u2019re using Async/await or not, the return type would be the same. . I wrote the ParallelExecutionStrategy, so I\u2019d certainly be interested in checking this out in a pull request. \nI\u2019d be a little concerned if there would be some scaling issues if a new Dataflow pipeline is created for each execution. There could also be issues with running in a SynchronizationContext (like with #795). I\u2019m also not sure how it would work batching queries with the DataLoader. \nAt the very least, maybe it could be available as an alternate execution strategy that users could opt-in to. . @troydalldorf, I\u2019ll check it out. The DataLoader requires OnBeforeExecutionStepAwaitedAsync to be called or it will deadlock. \nCurrently one can sub-class DocumentExecuter and override SelectExecutionStrategy() to use a different execution strategy. . @troydalldorf, you inspired me to look into how the existing ParallelExecutionStrategy could be optimized to allow sub-nodes to execute once parent nodes are complete. It hadn't occurred to me at the time when I first wrote it. \nI opened pull request #891. Can you check it out to see if it meets your needs?\nThere could still be a use case for an execution strategy using DataFlow blocks, so I'll check out your PR when I have time tomorrow.. @joemcbride, @SimonCropp, sorry for going dark on this. I had a lot of stuff come up around the holidays. \nI found that this made some queries much slower because of the O(n) performance of List<T>.RemoveAt(). I re-wrote it using a LinkedList<T>, but haven't gotten a chance to finish it completely. \nI think the merge should be reverted, if possible, until I can finish this up.. @SimonCropp thanks! I\u2019ll try to finish it up soon. . I don\u2019t see a reason to do this unless there is a feature in v12 that is actually needed. . The problem I see is that it\u2019s going to force users to update, rather than allowing them to upgrade to v12 if they want. . @Cooke, I agree that this is an issue that should be fixed, but I think there may be a simpler way to fix it. We should also avoid async void methods.\nCan you explain exactly how this fixes the issue? \nMaybe we could do something like putting a loop inside DispatchAllAsync() and keep calling DispatchAsync() on the loaders as long as they have more requests to dispatch (e.g., make IsFetchNeeded() public). . Adding a method to the IDocumentExecutionListener interface is a breaking change. We want to avoid breaking changes until the next major version. \nSo I\u2019d like to see if it\u2019s possible to fix this issue another way. . This is the expected behavior because the key is the same. \nUse the parameter as part of the key for the data to be cached separately.. @shoe-diamente The DataLoader caches based on the key provided only. It assumes nothing so the developer has explicit control over how data gets cached.\nHere's an example of how to accomplish what you want:\n``` csharp\nField>()\n    .Name(\"other\")\n    .Argument(\"param\", \"\")\n    .Resolve(async context => \n    {\n        var param = context.GetArgument(\"param\");\n    // The DataLoader has no way of knowing that another argument is being used as part of the fetch delegate\n    // So you need to include it as part of the key so values will be cached separately based on the parameter value\n    var loader = accessor.Context.GetOrAddBatchLoader<int, OtherEntityBaseType>(\n        $\"Key:{param}\",\n        async (ids, ct) => await GetStuffAsync(param, ids, ct)\n    );\n\n    return await loader.LoadAsync(context.Source.Id);\n});\n\n``. I changed it because it conflicts with the line ending settings in .gitattributes. On Windows, files are checked out with CRLF and normalized to LF in the repository. So all of the .cs files would have CRLF line endings for me except when adding new lines which would be LF. Kind of annoying. So I think removing this would be best for development on different OSes, but line endings still get normalized in the repository because of the setting in .gitattributes.. Ok, I didn't realize we were talking about putting it all in to the main project. But I'm fine with that. I've always been a bit skeptical of the usefulness of a DataLoader outside of GraphQL, anyway. And it could always be separated out later. . Will do.. Yeah, I agree. My plan was to make the parallel and serial logic completely separate for now. Then re-work the parallel logic, and then see what could be shared. But I could re-factor them to share more code in the meantime if you'd prefer. . If I put this in the main project, I'll need to target netstandard1.3 instead of netstandard1.1. Is that a problem?. I don\u2019t think that would be necessary. There\u2019s nothing that needs to be disposed of before garbage collection. . This change probably isn\u2019t necessary. I just wanted to make sure that the context would not be reused for another execution. . This needs a semicolon at the end and false must be lowercase. . I don\u2019t understand why you would need to set the context on the store. Your store shouldn\u2019t need to know anything about GraphQL. . You do need parentheses around the \u201cas\u201d statement. . I'm calling.ToList()because the items are needed again for the error message. So we don't do the iteration twice. . If we just returnedIEnumerable, I think it's possible that the enumeration would happen more than once.. TheMap()extension method was calling.ToList(), so this replicates that behavior. And I'm not sure what's going to consume the enumerable later, so I want to make sure it doesn't get generated multiple times.. Yeah I forgot to go back and remove them. I'll do that.. Ifdatais anICollection, we should create a list with the known capacity. This will be more efficient.. Using an array and for loop is more efficient that LINQ andToArray()`. The cancellation token check can still be outside of the loop.. Adding a method to this interface is a breaking change which we shouldn't do before the next major version. And I don't think the ExecutionNode should be exposed in this way since it's internal to the execution.\nInstead you could create a separate interface like this:\ncsharp\npublic interface ISimpleFieldResolver : IFieldResolver\n{\n    object Resolve(ExecutionContext context, object source, string fieldName);\n}\nThen implement that interface on the resolvers that benefit from this. \nThen you could do this in ExecuteNodeAsync():\n``` csharp\n    object result;\nif (resolver is ISimpleFieldResolver simpleResolver)\n{\n    result = simpleResolver.Resolve(context, node.Source, node.Field.Name);\n}\nelse\n{\n    result = resolver.Resolve(context.CreateResolveFieldContext(node));\n}\n\n```. ",
    "TwitchBronBron": "May I recommend adding DataLoaderContext as a property to ResolveFieldContext rather than having each app manage it themselves? This would reduce the boilerplate that each interested app would need to write. Each top-level field resolve would get their own instance, and that same instance would be passed along to all child fields. \nIt would be valuable for each top-level field resolver to have its own copy of the DataLoaderContext, because of the following scenario:\nHere's the query. \ngraphql\n{\n    order1: order(orderId: 1) {\n        orderId\n        user {\n            userId\n        }\n    }\n    order2: order(orderId: 2) {\n        orderId\n        user {\n            userId\n            giantBlob\n        }\n    }\n}\nNotice that order1 is asking only for userId, while order2 is additionally asking for giantBlob. The way DataLoader is implemented right now, the fetchFunc will only be run ONCE, with both userIds in the same ID list, and there's no way to know what columns each order wanted. Ideally it would be run twice (once for order1, and once for order2) so that the fetchFunc can craft a query with only the desired columns. \nHere is how I imagine this would look in code:\nC#\nField<UserType, User>()\n    .Name(\"User\")\n    .ResolveAsync(ctx =>\n        {\n            ctx.DataLoader.GetOrAddBatchLoader<int, User>(\"GetUsersById\",\n                (IEnumerable<int> ids) =>\n                {\n                    var columnNames = ctx.SubFields.Keys;\n                    //get a list of users, retrieving only the columns requested\n                    return await users.GetUsersByIdAsync(ids, columnNames);\n                });\n            return loader.LoadAsync(ctx.Source.UserId);\n        });\nIf we need to have the best of both worlds, there could be a setting on the schema indicating whether to create a new instance of DataLoader for each top-level field resolve, or if it should share the same DataLoader for the entire query.\n. @OmarElMallahy I don't have access to the code right now, but here's a rough approximation of how GetUsersByIdAsync is implemented. I'm using dapper (but not the Dapper.GraphQL library).\nIn a conventional server-side project I would be hesitant to use string concatenation to build a query. However, GraphQL-dotnet is already doing the field validation, so context.SubFields can be trusted, and so can the userIds list as long as it also came directly from GraphQL-dotnet as well.\nc#\npublic async Task<IEnumerable<User>> GetUsersByIdAsync(IEnumerable<int> userIds, IEnumerable<string> columnNames){\n    using(var connection = GetIDbConnectionSomehow()){\n        var query = \n            \"select \" + string.join(',', columnNames) + \n            \" from users where id in @userIds\";\n        var users = await connection.QueryAsync<User>(query, new {userIds=userIds});\n        return users;\n    }\n}. May I recommend adding DataLoaderContext as a property to ResolveFieldContext rather than having each app manage it themselves? This would reduce the boilerplate that each interested app would need to write. Each top-level field resolve would get their own instance, and that same instance would be passed along to all child fields. \nIt would be valuable for each top-level field resolver to have its own copy of the DataLoaderContext, because of the following scenario:\nHere's the query. \ngraphql\n{\n    order1: order(orderId: 1) {\n        orderId\n        user {\n            userId\n        }\n    }\n    order2: order(orderId: 2) {\n        orderId\n        user {\n            userId\n            giantBlob\n        }\n    }\n}\nNotice that order1 is asking only for userId, while order2 is additionally asking for giantBlob. The way DataLoader is implemented right now, the fetchFunc will only be run ONCE, with both userIds in the same ID list, and there's no way to know what columns each order wanted. Ideally it would be run twice (once for order1, and once for order2) so that the fetchFunc can craft a query with only the desired columns. \nHere is how I imagine this would look in code:\nC#\nField<UserType, User>()\n    .Name(\"User\")\n    .ResolveAsync(ctx =>\n        {\n            ctx.DataLoader.GetOrAddBatchLoader<int, User>(\"GetUsersById\",\n                (IEnumerable<int> ids) =>\n                {\n                    var columnNames = ctx.SubFields.Keys;\n                    //get a list of users, retrieving only the columns requested\n                    return await users.GetUsersByIdAsync(ids, columnNames);\n                });\n            return loader.LoadAsync(ctx.Source.UserId);\n        });\nIf we need to have the best of both worlds, there could be a setting on the schema indicating whether to create a new instance of DataLoader for each top-level field resolve, or if it should share the same DataLoader for the entire query.\n. Will do. Thanks! . Oh ok. Good to know. Is this in the documentation somewhere and I just missed it? If it's not, do you think it would be valuable to put this link in the installation section as an alternative? Something like this:\nInstallation\nYou can install the latest version via NuGet.\nPM> Install-Package GraphQL\nOr you can get the latest pre-release packages from the MyGet feed.\n. Sure! I added tests for both InterfaceGraphType and ListGraphType< InterfaceGraphType>.  . Oh ok, great! . #540 solved the issue. Thanks a lot for the fantastic work on this feature!. I'm not sure why there was a restriction to only IObjectGraphType. I changed this to simply verify that there are selections available. . ",
    "benmccallum": "I'm guessing this issue can probably be closed as the dataloader is already available right?\n@johnrutherford, quick q. How are you finding Mediatr with your graphql types? Is it a worthwhile abstration, or unnecessary/overkill given you could just interface it yourself? \nEdit 1:\nI gave it a go, but how are you getting it to work with the DI as graphql-dotnet wants things \"singleton\" and mediatr in a resolver as \"scoped\" is throwing all kinds of issues. Made my query and schema \"scoped\" and now it can't find my schema on the root provider... hmmf.\nEdit 2: I've managed to get it working by registering IMediatr as \"scoped\" and creating a scope within my resolver to then request an instance of IMediatr inside of. Is that what you ended up doing?. @OmarElMallahy, I can't comment on how these guys are doing it, but I've had great success with two options:\n1) AutoMapper's Queryable extensions on Entity Framework, specifically .ProjectTo<T>(fieldsToMap) after configuring the map to expand only explicitly. \n2) Dapper.GraphQL if you want to work at a lower level with Dapper instead of EF, where you're really building the queries yourself.\nYou can access fields required by client using .SubFields of the resolve context and passing that down to your lower DB/ORM/etc layers. Good luck!. When you configure AutoMapper, for the mapping between User (db entity) and UserDto you can call an additional method for all fields that tells AutoMapper it shouldn't automatically project/map all fields over to the DTO, only the fields you explicitly ask for. I can't see the code so not exactly sure what the name of the method is. Then when you use ProjectTo, it's really myUsersQueryable.ProjectTo<UserDto>(context.SubFields.Keys) though you may need to do a mapping from the field names your graphql types use to the field names on the DB entities.. Doesn't look like there's been much progress here \ud83d\ude1d It's certainly a tough problem. \nOver at graphql-net the implementation dynamically builds an IQueryable. I'm currently exploring that library, but it's severely lacking in support of the spec (no variables, introspection doesn't work, etc. etc.) and a community that it's unusable for me. I do like the fundamental approach though and I think the wider .NET community really needs the best of both these libraries. \nFor instance, using IQueryables it can use projection to only request fields asked for, and can handle things like paging and sorting to for you simply by extending the original IQueryable you provide in your resolver. You can then have any IQueryable provider under there (SQL or CosmosDB) and it just works (for the most part)!\nI may be missing something fundamental, but would it be possible for a graphql executor to just continue to build up an IQueryable across/down through fields right until the last moment or execution is required (e.g. service boundary). Then we let the underlying IQueryable provider handle the complexity of resolving it to an optimal query (e.g. EF Core + SQL, or EF Core + CosmosDB which is coming soon). . @vertonghenb, For my current project I've decided to go a little more raw and use something called Dapper.GraphQL where you're essentially building up the query yourself so it's optimised by you. Haven't gotten to building on it just yet but my plan is DbUp + Dapper.GraphQL which uses this library (graphql-dotnet) and exposed via graphql-dotnet/server middleware.\nI'd love to see the IQueryable support come over into here in some form, but I just don't have the skills in that area of expression building and manipulation, so it's a little out of reach for me. If someone else wanted to help, like @ckimes89, we'd really get the value out of both libraries.\nThe EF Core team are also working on a CosmosDb EF provider so that'd be amazing to have a CosmosDb collection backing graphql-dotnet endpoint, even though there's no concept of cross-collection JOINs at this stage.. @vertonghenb, would be keen to see what you came up with for sure, share a link when you can.\n@joemcbride, ~~are you saying that Dapper.GraphQL is building the SELECT clause with SubFields/SelectionSet correctly, but doesn't take into account directives that may mean some fields/columns wouldn't need to be returned for those records? I guess many implementations would overlook this. Maybe a complete example would help, and you/I can log an issue over there.~~\nEdit: My other thinking was that it's incorrectly using SelectionSet instead of SubFields. I see you've posted the issue over there and explained that in the title. Nice one, thanks!. Hi @joemcbride , sorry to beat a dead horse here, just wondering if there's a perf hit to be aware of registering the Mutation or Query classes as Scoped or Transient. I'm running into a similar issue using Mediatr in my resolvers. \nReached out to Jimmy to see if IMediator can be registered as Singleton, but I'm guessing there's a reason why the default is Scoped so I just want to have a backup plan but be sure performance isn't smashed by whatever happens when a Query or Mutation is setup (fields and all).\nEdit:\nEnded up registering IMediator as scoped and creating a scope within my resolvers to then request an IMediator instance from within. Should be fine I guess.\nThanks!. Did you ever find a way to do that @alexandercarls? I think I have a use case for that too.. But aren't resolvers just Funcs, so they aren't classes that can inherit from another. You mean a Func that wraps (and internally executes) your actual resolver Func?\nEdit: Oh, I see there's a Field().Resolver property where you can set an IFieldResolver. Just learnt something new. Cheers!. Started looking at IFieldResolver and although it would allow me to create my own abstract base MyFieldResolver : IFieldResolver, I'm using async await, so it looks like I'd need to implement/inherit an AsyncFieldResolver<TIn, TOut>. \nStarts getting weird quick though. Inheriting AsyncFieldResolver<TIn, TOut> means I need to pass my resolver in the call to base constructor. Not really a problem but kinda funny looking. \ncsharp\npublic class BookingPayingMethodResolver : AsyncFieldResolver<BookingDto, BookingPayingMethodDto>\n{\n    public BookingPayingMethodResolver(IPaymentClient paymentClient, IDataLoaderContextAccessor accessor)\n        : base(async context =>\n        {\n            var loaderKey = $\"{nameof(IPaymentClient)}::{nameof(IPaymentClient.GetBookingPayingMethodsAsync)}\";\n            var loader = accessor.Context.GetOrAddBatchLoader<int, BookingPayingMethodDto>(loaderKey, async (ids) =>\n            {\n                var request = new GetBookingPayingMethodsRequest(1, ids.Count(), ids.ToHashSet());\n                var response = await paymentClient.GetBookingPayingMethodsAsync(request);\n                response.CheckForError();\n                return response.Items.ToDictionary(bpm => bpm.BookingId);\n            });\n            return await loader.LoadAsync(context.Source.BookingID);\n        })\n    { }\n}\nNot inheriting but simply taking inspiration from AsyncFieldResolver<TIn, TOut> I get close but I don't really understand how it works. It does a call to .As<TIn> on the ResolveFieldContext so that it can be passed to the resolver func as ResolveFieldContext<TIn>, but that extension method for me just casts it to TIn. Am I missing an implicit cast or getting the wrong extension method? \n```csharp\npublic class BookingPayingMethodResolver2 : IFieldResolver>, IFieldResolver\n{\n    private readonly IPaymentClient _paymentClient;\n    private readonly IDataLoaderContextAccessor _accessor;\npublic BookingPayingMethodResolver2(IPaymentClient paymentClient, IDataLoaderContextAccessor accessor)\n    : base()\n{\n    _paymentClient = paymentClient;\n    _accessor = accessor;\n}\n\npublic Task<BookingPayingMethodDto> Resolve(ResolveFieldContext context)\n{\n    var contextTyped = context.As<BookingDto>();\n\n    var loaderKey = $\"{nameof(IPaymentClient)}::{nameof(IPaymentClient.GetBookingPayingMethodsAsync)}\";\n    var loader = _accessor.Context.GetOrAddBatchLoader<int, BookingPayingMethodDto>(loaderKey, async (ids) =>\n    {\n        var request = new GetBookingPayingMethodsRequest(1, ids.Count(), ids.ToHashSet());\n        var response = await _paymentClient.GetBookingPayingMethodsAsync(request);\n        response.CheckForError();\n        return response.Items.ToDictionary(bpm => bpm.BookingId);\n    });\n\n    // FAILS to compile here as context is of type `BookingDto` instead of ResolveFieldContext<BookingDto>`\n    return await loader.LoadAsync(context.Source.BookingID);\n}\n\nobject IFieldResolver.Resolve(ResolveFieldContext context)\n{\n    return Resolve(context);\n}\n\n}\n```\nI'm keen to get something nice here as the other benefit is the resolver is in another *.cs file rather than having all your resolvers defined in your graph type, which could get pretty unwieldly over time.. Good point about the middleware. In the end it turned out the thing I thought would throw exceptions and I'd want to catch and transform isn't, it just returns an empty response object essentially with a status flag on it. So I've just got a extension method on it's type .ThrowIfNotValid() or similar and it throws the exception I want that'll flow through into the GrpahQL errors. \nIt's great that more people are getting real world experience using all this stuff to the point where we can iterate on the core framework / server and add in the extension points. \nI thought about chucking in MediatR, but I'm essentially wrapping back-end Web APIs with my GraphQL server, so that's about as big as my resolvers should get and essentially I end up doing the same thing as you (building up a request/message object with some props and passing it to the relevant Web API client. So for now I'm hesitant to chuck in a mediator pattern in there as it's just another abstraction, but I guess I'll see how unit testable this all is and go from there. Potentially I may need the mediator abstraction when it comes to mutations that need to call out to several web APIs... I'm not sure if building GraphQL on existing microservices/web apis is a blessing or a curse yet.\nThanks for the help!. Looks good. Maybe it's worth referencing \"all\" the examples in the unit tests? \nThe use of a cache key reminds me of a POC I did once where I managed to write a cache helper that wouldn't require a cache key, just the expression of the operation you wanted to cache the results of, and it'd figure out the cache key based on that. May not work here, but would save a dev needing to supply it. Only downside would be if someone is doing GetUserById and GetUserByIdAsync for some reason, the cache keys wouldn't overlap. Perf would take a small hit too I guess with expression Compile() and Invoke(). . @acronoah, thanks for that. Definitely the solution at the moment. Would be good for this to be supported without having to modify a framework class, but will have to do for now. Is this something that should fall in the server repo @pekkah ?\n@johnrutherford, a question I've got right now is, how can I pass additional arguments to my repository/service/data getter implementation? Right now you're restricted to Func<IEnumerable<TKey>, Task<Dictionary<TKey, T>>>, is there any way we can add some overloads with T1, T2, T3? Or some generic clean way of allowing additional arguments? Would obviously need to involve this in the cache key generation but it'd be super helpful. In my case I need to pass paging arguments, but also the list of field names requested by the client, so it's a scenario that's going to be very common.. Thanks @johnrutherford! My brain was obviously too tired at that moment to think of using a closure. Thanks!\nWith the cache key, I get ya and understand. . @alexandercarls, I've previously done the following with success:\n Add IServiceProvider into constructors of my Query/Mutation and other Types.\n In my resolver func, use the IServiceProvider to create a scope with CreateScope (notice it's IDisposable so wrap it in a using\n* In that scope resolve my scoped dependencies using GetRequiredService<T>, etc.\nI'm having some DI fun at the moment where I've got the following:\n I have an IAuthParams registered as scoped and a middleware that injects it into the Invoke method, pulls some stuff out of the HTTP request and sets properties on it.\n Then I have the service locator pattern in my GraphQL resolver, which is resolving an IBookingClient which has a constructor dependency for IAuthParams, so it can pull some details off it and set them as headers for a request to a downstream API. \nProblem is, the instance of IAuthParams it gets always seems to be fresh, everything is null, it's apparently not the one that went through my middleware earlier. I guess that's because I've created a new scope, so it should be expected that the DI thinks it should create a new one. Problem is, I'm not exactly sure how to solve that. Essentially by using the Service Locator pattern in my resolver, and having to create that scope, I've lost access to the outer scope. I think I've basically got this issue, so will probably need to inject \nIHttpContextAccessor in my IBookingClient, and unravelling the details I \nneed there. http://github.com/aspnet/Mvc/issues/7267\nAny suggestions anyone? Can we solve all these issues in one go by baking something into the framework somewhere? I guess as long as the Types are singleton, the resolvers will be creating their own scope and doing ServiceLocator... So I'll always have this problem. I'm not even using EF, I'm just trying to instantiate a HttpClient essentially that also needs access to the current HttpRequest, or a scoped dep I''ve already created from the request that's now stuck in the outer scope.\nWould another DI framework help me?. Thanks @johnrutherford, will give it a go. And thanks @alexandercarls too, your abstractions look great!\nI was also thinking about how we could do this as a framework. Since I'm in the auth space at the moment, we could take the approach that setting up authentication use when you need to provide custom event handlers. I can't remember the type, I'm on my phone, I think it'd be JwtBearerAuthOptions or something, but they have a property EventsType of Type, so you just give it typeof(MyEvents) and the auth pipeline resolves it for you and calls methods on it for diff events. You can register it as scoped/singleton/transient as you please. \nCould we apply that same pattern to GraphQL resolvers? We give the field simply the type of our resolver with a new property ResolverType, this type must inherit from some standard set of interfaces (like the IFieldResolver ones) so we can check compat at schema build time on startup, and then at execution GraphQL takes care of initialising this, creating the scope (if needed), resolving the resolver and executing it, then disposing the scope (if needed).. That sounds really good. I like the parallel with ctor/invoke method injection so it'll make sense to a lot of people and be easy to document.. @alexandercarls, FYI I ended up with what John posted with the MyUserContext holding a pointer to the HttpContext's IServiceProvider. Then I just have some convenience extensions on it to resolve the services I regularly use. I imagine like the SO link you posted, if you resolved IHttpContextAccessor somewhere and did .HttpContext.RequestServices it'd have the same net effect though.. @joemcbride , if you quickly confirm there's an issue here I can write up the PR. . Ahh, I see how it works. ComplexGraphType::Connection<TNodeType>() calls ConnectionBuilder.Create<TNodeType, TSourceType>() which calls ConnectionBuilder<TGraphType, TSourceType>.Create() which returns new ConnectionBuilder<TGraphType, TSourceType>(fieldType, null, false, false, null).Unidirectional(). Key part being that the chained call to .Unidirectional() there always means that after and first are setup as arguments. Nevermind me! Closing.. ",
    "OmarElMallahy": "@TwitchBronBron \nCan you share the implementation of GetUsersByIdAsync(ids, columnNames)?\nHow did you return only the specified columns from your database?. @benmccallum \nWhat do you mean by \"after configuring the map to expand only explicitly\"?\nAlso, the .SubFields are in the format of dictionary<string,Field>\nHow to use the keys of this SubFields dictionary as a Type T in ProjectTo<T>?. Great. Thanks @benmccallum , @TwitchBronBron . ",
    "vertonghenb": "@benmccallum, any luck with exploring the Graphql-net library (F# isn't really my thing).\nThe EF Core team has done some remarkable work in their latest version (2.1, still in preview). We should really consider supporting IQueryable which will solve a lot of issues with included properties etc.\nHowever if we could inspect which children the root has and include them in the \"include properties\" of the root query (going to the DB) and map those Navigation properties it would already solve some issues.\nI'd gladly participate in this solution, any idea's how to tackle the issue?. @benmccallum The Dapper.GraphQL package looks pretty interesting but I don't like to go back to Dapper especially because of the work being done in EF Core.  However Dapper is still amazing though!\nI'll post a Medium article soon how I tried to manage the Join issue. The main idea is to check the include props. (to be continued). I've been looking into this situation and checking if we could use it to optimize our queries #21 \nWhat I'm trying to do is getting the Children of the SelectionSet to create a Include string (IQueryable situation for EF).\nLet's say we have the following query:\norder(id:1) {\n        orderlines{\n            amount\n            product{\n                id\n                name\n            }\n        }\n        customer{\n            name\n            vatNo\n        }\n    }\nIn an ideal Linq to SQL situation we'd do the following:\ndbContext.Orders.Include(\"orderlines.product,customer\").Where(order => order.id == 1).ToList();\n(note the '.' between Orderlines and Product\nIn other words if we can get the Navigation Properties of the query into the Include string, we can optimize quite a bunch of queries thus eliminating the N+1 in some situations.\nI'm thinking to use reflection to get the navigation properties, but it would be sweet to get a parent-child relationship from the GraphQL selectionset to match it.\n@Jonatthu  would something like this help you?\n@joemcbride what do you think?. ",
    "patoncrispy": "Hey everyone, has there been any progress on this?. ",
    "techniq": "https://github.com/SimonCropp/GraphQL.EntityFramework has been serving me very well (first GraphQL project, migrating from OData). ",
    "TheMoogster": "I guess there is no more progress on this?. > @TheMoogster 3rd party libraries are handling this, it will most likely not be something built-in to the core framework at this point.\nYou know any 3rd party lib that does this for .NET?. ",
    "christostatitzikidis": "With the current implementation the input object would have to inherit from InputObjectGraphType which inherits from ComplexGraphType of object.\nThe output object type would be ObjectGraphType of T.\nSo if one wanted to implement both Input and Output on the same object type they would not be able to to use fluent syntax like\nField( => .Id).Description(\"The id\");\nField( => .Name, true).Description(\"The name\");\nWith that small change, one can create an object like:\nMyGraphType : ObjectGraphType of T, IInputObjectGraphType which will handle both input and output with a fluent syntax.\nAll the rest of the code just works fine with this little tweak, so it could be a nice feature that saves having to write different objects for in and out or not use fluent syntax. \n. I wouldn't say that I have studied the specification much, so if it this steps out of it, fair enough. \nThanks for your time! :). ",
    "harrisse": "@joemcbride @jquense I understand why you would want different types for input and output, but I think there's a valid use case for a strongly typed InputObjectGraphType:\n```\npublic class UserInputType : InputObjectGraphType {\n    public UserInputType() {\n        Field(userInput => userInput.Id);\n        Field(userInput => userInput.Name);\n        ... etc.\n    }\n}\npublic class UserInput {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    ... etc.\n}\n```\nThis can also be nice when it comes to resolution of the User as you can pass your strongly typed UserInput object directly to your user resolution service:\nField<User>(\n    \"user\", \n    arguments: new QueryArguments(new QueryArgument<UserInputType> { Name = \"input\" }),\n    resolve: context => userService.FindUser(context.GetArgument<UserInput>(\"input\"))\n);\nWhat are your thoughts on this usage, and would you accept a PR for InputObjectGraphType\\<T>?. Reviewing that example, what would be the base type of DinnerInputType? Based on my understanding it would be InputObjectGraphType\\<Dinner>, but that type is not available in the current codebase.\nEdit: I'm relatively new to the library so my understanding could likely be wrong, but I had been imagining classes like UserType as describing User as the type is exposed through GraphQL. This works out nicely with output types like the DroidType example at the beginning of the getting started guide where DroidType describes Droid using Field(droid => droid.Id). I'd like something similar for input types, but the closest I've been able to get is Field(userInput => ((UserInput)userInput).Id) since InputObjectGraphType extends ComplexGraphType\\<object>. I understand you can define types without generics, but I would prefer to do it with generics where possible to support refactoring, type safety, etc (another aspect I'm interested in is being able to generate Typescript models using something like TypeLite so my clients can reuse the same input model as well). Do generic input types not work / not make sense from the graphql spec's perspective?. ",
    "mamasselin": "Thanks for the quick response.\nI can't use DateGraphType because my field will contain any kind of string values, including date strings.\nI haven't had the chance to look deeper into this yet, so I'm just throwing some ideas here:\nWould it be possible for the StringGraphType to fallback to the .ToString() of the object if it's from a different type?\nAlternatively, the json could be interpreted as a string when deserializing (I assume by removing the DateFormatHandling.IsoDateFormat setting from the serializer), and if it's going into a DateGraphType only then it would be parsed as a DateTime?. I added the following setting to the JSON Serializer and it seems to solve my problem:\nDateParseHandling = DateParseHandling.None\nBut now the following test fails because the date is converted to my local time for some reasons:\n```c#\npublic void can_convert_utc_date_to_datetime_with_correct_kind()\n{\n    var json = @\"{ 'h': '2016-10-21T13:32:15.753Z' }\";\n    var expected = DateTime.SpecifyKind(DateTime.Parse(\"2016-10-21T13:32:15.753\"), DateTimeKind.Utc);\nvar inputs = json.ToInputs();\nvar myInput = inputs.ToObject<MyInput>();\n\nmyInput.ShouldNotBeNull();\nmyInput.H.ShouldBe(expected);  \n// Fail reason: myInput.H is now in my local time (2016-10-21T09:32:15.753)\n\n}\n```\nUPDATE:\nI made a small change in the ObjectExtensions.cs class to account for the above issue. I updated the ConvertValue method to look like this:\n```c#\npublic static object ConvertValue(object value, Type fieldType)\n{\n    if (value == null) return null;\nif (fieldType == typeof(DateTime))\n{\n    DateTime dateTimeValue;\n    if (DateTime.TryParse($\"{value}\", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dateTimeValue))\n    {\n        return dateTimeValue;\n    }\n}\n\nvar text = value.ToString();\nreturn _conversions.Value.Convert(fieldType, text);\n\n}\n```\nCould you please take a look at my pull request and see if that makes sense to you?\n272 . Hi guys, just to let you know that I submitted a pull request #289\nI added tests for UTC date times and also non UTC (with timezone offset). Closing.. @joemcbride \nThanks for the quick response.\nTo clarify my use case:\nIt is not for debugging purposes of Dev vs. Prod environments as you mentioned.\nMy use case is to have a way of displaying friendly error messages to the client applications that use my GraphQL API (the errors being sent in the response).\nFor example with the changes in this PR, I can do this in my item creation resolver:\nthrow new ExternalExecutionError(\"An item with the same name already exists.\")\nThen in my client application where the user tried to create that item, I can display this error message \"as is\", or at least the client application knows why it failed.\nBefore my changes, any exception thrown would generate the exact same error in my client application (\"error trying to resolve createItem\").\nAs for the \"attack vectors\", the developer will have to specifically throw an ExternalExecutionError for the error to be sent \"as is\" to the client application. So the initial behavior still remains for all other cases.\n@jquense \nMaybe I'm missing something but once the errors are serialized in the HTTP response, their innerException is lost. Maybe a configuration issue on my end?. Thanks, I will play around with this a bit and keep you posted on my findings.. It turned our I implemented a small logic in my code to parse the errors before sending the response. This way I can receive the \"real\" errors in my client applications.\nThanks for your input guys, I will close this pull request.. fixed. I did the change and it works. I agree that logic  should be in the DateTimeConverter class. Thanks!. ",
    "jbliss1234": "Joe, Thanks for your reply. Yes, I have scoured the docs...but it is still unclear, as to how to make the leap from a console app to an ASP.Net Core webapi, and have it work for EF IQueryables, while avoiding the issues around excessive database queries for joins etc (n+1 issue). I am pretty sure it is possible, but being new to GraphQL (and even .Net core), it is unclear..I am pretty sure I am not alone; this is evidenced by the fact that there is not a single youtube (or anywhere else) tutorial that shows how to build a graphql api on .net. So please help us newbies out.\nI would love to be able to get an api running and experiment with Apollo client as I am very familiar with Apollo\nAnswers to your questions below:\n\nWhat do you think an EF example would provide over the existing in-memory objects example?\nI think for most developers, the in-memory objects examples have limited value...What most bread-and-butter .Net developers are looking for is: how I can avoid messy REST api for my next app by using GraphQL, and yet not sacrifice the power of Linq and EF\nThis project has supported any data store from the start. What has lead you to think that EF wouldn't be \"supported\"?\nI am pretty sure EF is supported...I am just get trying to get my hands on a tutorial that can teach me how\nWere you aware of the docs I linked to?\nYes, unfortunately got limited value out of the docs. The docs as they exist today don't help me get my ASP.Net Core graphql api up and running quickly (or at all)\nAre you looking for more of a \"pass my EF context to this engine and it should do stuff for me\" behavior?\nWell at this point I am looking for a way to easily generate schema from EF context. Most of the db fields could be made part of the schema automatically but then in case  something special needs to be done, how to write a custom resolve function which could leverage the power of Linq\n\nBTW, this frustration with lack of clear steps to work with IQueryables and EF Core probably led to creation of the graphql-net project, which unfortunately is not being actively developed or maintained. . @joemcbride @JacekKosciesza  There is a real hunger in the community from people like myself (who hate doing REST webapis the traditional way) for a better solution like graphql. However, Graphql is very new and unfamiliar to us. That is why we are requesting a very small/simple step by step tutorial on using EF Core and graphql.net, both for query and mutations. \nPlease understand that this is a HUGE issue we are facing. I have spent several hours on google with an an example or tutorial on how to do this, and came up empty. \nI would also argue that this will invite more .Net developers to use this great library and push the project to new heights.\nPS: BTW, if you search for Graphql .Net, this thread comes up at third position on Google. This should mean that a lot of people are looking for guidance on this subject.. ",
    "JacekKosciesza": "I've created simple 'Hello GraphQL!' example based on the example from 'Usage' section (console version), but using ASP.NET Core and Entity Framework Core. I've also briefly described steps while I was coding. Maybe it will be useful. I'm planning to create some more advanced examples:\nYou can find it here: https://github.com/JacekKosciesza/StarWars. ",
    "bancroftway": "A lot of time has elapsed and this still remains an issue. The examples linked above are poor quality and interestingly, won't provide any examples of mutations. \nIt is very disheartening that we want to use graphql in .Net and yet there is no quality guidance available on building a small yet fully functional web/mobile app using Graphql.net. I think developers can easily figure out and resolve the EF context vs Repository debate themselves. A simple starter tutorial that shows how to achieve mutations in an asp.net core/EF Core is still valuable. \nBTW, see this link down  in the comments, even the author of the article does not provide an example of a mutation with EF Core, and acknowledges that documentation on mutations with graphql.net is scant.. ",
    "thangchung": "I have written up the article about how to make EF Core and GraphQL.NET work together at https://www.codeproject.com/Articles/1224151/How-to-implement-Generic-Queries-by-combining . ",
    "mmacneil": "I have put together a recent, in-depth guide on using GraphQL.NET with ASP.NET Core 2, GraphiQL and Entity Framework Core 2.\nhttps://fullstackmark.com/post/17/building-a-graphql-api-with-aspnet-core-2-and-entity-framework-core. ",
    "amaningenium": "since i could hardly find a thread about graphQL, i am posting a query here, please don't delete.\nI m looking to consume a graphQL API, my project being in c# do i need to write the request as a specific type and then convert to string or basic string would do?. ",
    "RehanSaeed": "Can't help with EF Core, but I created an ASP.NET Core project template you can get started with pretty quickly called ASP.NET Core GraphQL Boxed.. Not sure if this issue/PR is affected but it would be worthwhile keeping in mind that GraphQL API's like the one from GitHub are also commonly secured using time based throttling and timeouts if the query is taking too long. More information: https://github.com/graphql-dotnet/graphql-dotnet/issues/764.. My understanding is that the default complexity of a field is 1. Would it also be useful to simply be able to set the complexity of a field as a number as in SetComplexity(2), as well as the delegate you've added?. Is there any example on how to set this up with GraphQL.NET Server? The docs don't cover that. I've only just found out about Apollo Tracing, is there an easy way to ship these logs to Apollo to get the free metrics and charts?. @csboling Thanks for that. I added the code and see the tracing section show up in the GraphQL playground:\njson\n\"extensions\": {\n    \"tracing\": {\n      \"version\": 1,\n      \"startTime\": \"2018-09-14T15:31:49.5565957Z\",\n      \"endTime\": \"2018-09-14T15:31:49.5595957Z\",\n      \"duration\": 3241900,\n      \"parsing\": {\n        \"startOffset\": 13900,\n        \"duration\": 280500\n      },\n      \"validation\": {\n        \"startOffset\": 13900,\n        \"duration\": 280500\n      },\n      \"execution\": {\n        \"resolvers\": []\n      }\n    }\n  }\nHowever, I don't see the tracing pane in the GraphQL Playground that seems to exist. I looked at the GraphQL.NET Playground NuGet package and don't see anywhere where we would be turning Apollo Tracing off.. Also, does anyone know if the Apollo Engine Tracing strips the tracing data once it's been consumed?. Thanks @csboling. I now have data showing in my resolvers but still no tracing pane showing in the browser:\n\n. It turns out GraphQL Playground disables tracing by default. I've enabled it in what I thought would be a PR here but I forgot that I'm now a contributor, so when I hit the edit button it does a commit instead, Doh!. I'm new to GraphQL.NET. Assuming 2.0 is a breaking change and I'm just investigating with no concrete plans to build anything, is it worth looking at the 2.0 alpha builds instead? Is there a guestimate for when it will solidify?. Could we add DateTimeOffsetGraphType as a built in type? It's really common to want to use it.. There is a fully working example of bi-directional pagination using Connection in the ASP.NET Core GraphQL Boxed project template.. I'm trying to use a DateTimeOffset using the following syntax but I'm getting errors, a DateTime works. What is the syntax you settled on?\nField(o => o.Created);. 2.0 is in alpha, so now is the time to make breaking changes if you want to.\nHave submitted a PR https://github.com/graphql-dotnet/graphql-dotnet/pull/665\nThe TimeSpan type has really got me thinking, so I asked a StackOverflow question \"What is a good format for Duration in JSON?\".. On the subject of representing TimeSpan in JSON. I feel we should probably default to using a scalar that outputs an integer showing the total number of seconds and provide an additional scalar using milliseconds that people can use for greater accuracy. Thoughts before I update the PR?. I would use Int64 for a seconds scalar and a second milliseconds scalar type.\nIt's not clear in the ISO 8601 standard but it does support milliseconds.\nI could be wrong but I think ticks are System.TimeSpan specific implementation detail.. Cool, I'll get the PR updated with the TimeSpan changes.. Added two TimeSpan scalars. The default one serializes to seconds, while the other one which you'd have to set manually uses milliseconds.. > @rianjs In DateTimeToDateTimeOffset, you have the UTC offset hard-coded to TimeSpan.Zero which does not follow the .NET convention for DateTimeOffset types.\nAgreed, I've changed it to be a case (DateTimeOffset)dateTime which should handle things properly.\nOn DateTimeOffsetToDateTime, I'm not wedded to it but my thinking was to provide some sensible default and using UTC, seems like a sensible default.\nOn to fixing and writing some tests.... Tests are green, build is green. PR is ready to merge, unless there are further comments.. Cool, thanks for your time and help in making this happen!. Fixed the silly typo.. AppVeyor fixed.. @jquense Moving makes sense to me. I saw this code in the relay project related to cursors but it didn't quite meet all my needs, so I wrote a Cursor static helper class.. @jquense So you want this same PR, submitted to the Relay project? Thanks for the invite, much appreciated. I'm done learning GraphQL but am still getting used to this code base and have little knowledge of Relay (I can't find a good way to learn it without also learning React). I'm only interested in the connection type and other common sense types right now but that might change. I've heard you can use Relay with VueJS, is there also a .NET client? Relay sounds very useful, being closed to React is the only blocker.. I don't know why my tired brain thought this was a good idea. I got the cursor confused with ordering the paged items.. Was just about to reply, you beat me to it.. Fixed conflicts.. Looks like it's possible but not currently documented.\n@petrovic-ivan seems to have implemented it here.\n@jlebensold has also managed it here.\nWould be nice to get this documented.. See also https://github.com/graphql-dotnet/server/issues/135. This can be closed. 2.0 is out. There is a call for additional documentation here https://github.com/graphql-dotnet/graphql-dotnet/issues/758.. Looks like a cool feature. Should it be assumed that if it is not part of the spec, that it eventually will be, given how big Apollo is in the community?. There is also the @stream directive. More info about @defer and @stream here.. Yes, perhaps this issue should live in the server repo.. Moved to https://github.com/graphql-dotnet/server/issues/140. Cool, I'll wait for that.. 4.5 is not supported by Microsoft. I believe the minimum bar for them is 4.5.2 or 4.6.1 and above.. I've been running integration tests using the Microsoft.AspNetCore.Mvc.Testing package. See docs. You can run normal HTTP requests by passing in the GraphQL query in your request body.\nAs for lower level unit tests of individual graph types, I'd be interested in learning a way to do that too.. Good stuff.\nI would add calls being made to Task.GetAwaiter().Result as something which is also probably killing performance. I was thinking of raising a PR to fix this but it requires breaking changes, unfortunately not had time.. Not in this repo, the IValidationRule needs to return a Task, so that the code in the Authorization repo doesn't need to call GetAwaiter.GetResult() here.. It looks like the build script did not like your branch name.. I've seen a few people talk about converting the AST to Gremlin or other graph database queries. Are there any examples? I think it would make an interesting blog post.. @joemcbride There seems to be an implementation of InstrumentFieldsMiddleware built in here which has not been updated yet with an await. Also, is this something that is enabled by default in the server project, I can't quite figure it out?. Relying on AppVeyor to have the right version of the SDK is flaky at best (They take a while to update). I use the following line in my yaml to ensure the correct version is installed:\n- ps: choco install dotnetcore-sdk --no-progress --confirm --version 2.1.301\nAppVeyor has chocolatey installed by default.. You can see a full example of it's usage in the ASP.NET Core GraphQL Boxed project template. You can see how to use it in the InstrumentingGraphQLExecutor.cs file.. Project templates that give you optional features to get you started quicker.. Switched to Shoudly as requested.. Now using CultureInfo.InvariantCulture to fix dates being converted to and from string producing different results in different parts of the world.. This allows the use C# tuples public static (string firstCursor, string lastCursor) GetFirstAndLastCursor<TItem, TCursor>(). The alternative if you want to avoid the dependency is to add a custom struct with these two properties.. Thats interesting, what is the more efficient alternative? Storing the cursor in the database, so it doesn't have to be recalculated? In my head I was thinking you could use an orderby field that determines which property on a model to use as the cursor and which property on the model to run an ORDER BY on if you are using SQL.\nOn a related efficiency note, I asked the question \"Does GraphQL negate the need for Graph Databases\" on StackOverflow. For a personal project, I was thinking of using Microsoft Orleans because it's cheap to run but CosmosDB or some other graph database might also be interesting from an efficiency standpoint. Neo4j even has some GraphQL integration.. @jquense Take a look at my GraphQL.NET project template or specifically this relay connection for droids I'm trying to add. It talks to a droid repository.\nThe connection is ordering droids by their created date (date of birth). If you use the ID for the cursor as opposed to the created date property, this makes it more difficult to get the data from the database. Currently in the droid repository I call:\npublic Task<List<Droid>> GetDroids(\n    int? first,\n    DateTime? createdAfter,\n    CancellationToken cancellationToken) =>\n    Task.FromResult(Database\n        .Droids\n        .If(createdAfter.HasValue, x => x.Where(y => y.Created > createdAfter.Value))\n        .If(first.HasValue, x => x.Take(first.Value))\n        .ToList());\nIf the droid created date is the cursor, I can simply pass that into the query above. If the ID is the cursor, I'm not sure what the most efficient way to write that query would be (assuming we are using EF Core or some other SQL/Linq based data store). Perhaps I would have to get the created date of the droid with the given ID and then use that in the query above. Am I missing something?. Yes of course, I missed that. I've now called the types Seconds and Milliseconds unless you have a better name. Perhaps TimeInSeconds and TimeInMilliseconds?\nIf there are no more suggestions, should I start fixing and writing new tests?. ",
    "TehWardy": "Forget EF for a moment ... I feel like the bit that's missing is some sort of translation that maps from a GraphQL request body to a LINQ expression tree. \nFor example ...\nIn WebAPI OData I can do something like this:\n```\npublic FooController : ODataController {\n     DbContext data;\n     FooController(DbContext data) { this.data = data; }\n public IHttpActionResult Get(ODataQueryOptions options) \n {\n          return Ok(data.Foos);\n }\n\n}\n```\nnow (assuming the usual EF and OData model configuration has been done) ... I add my Set to my OData model and the above controller code gives me complete CRUD functionality on my Foo table in the db (overrides for crud methods optional, the get above shown for illustration of my next point).\nWith a simple GET request to ~/Api/Foo? i can do everything from querying exactly what i need (including other graph related objects), I can also do aggregations ect.\nWhat I think is needed for GraphQL here is some sort of example that works something like this ...\n```\npublic class MyGraphQuery : ObjectGraphType\n{\n    public MyGraphQuery()\n    {\n        Name = \"MyQuery\";\n    Field<Foo>(\"Foo\", resolve: context =>\n    {\n        using(var db = new MyEfContext())\n        {\n             return GraphQLOptions.Apply(db.Foos);\n        }\n    });\n}\n\n}\n```\nThe key here being the GraphQLOptions object that translates a request in to the appropriate set of queries on the IQueryable exposed by EF as db.Foos (but as stated above, it doesn't have to be EF).\nNot having this it seems whilst GraphQL supports all this querying type stuff we can't really leverage it without having to write lines of code that do the QL to LINQ translation.\nMy understanding (which may be wrong) is that a GraphQL \"Query\" is similar to an OData Action that performs a business operation on a CRUD supporting ICollection.\nOr have I missed something about the implementation here?\nAlso where do we get metadata about the graph as it's all on one controller (that according to the samples i've seen only have pieces of the CRUD functionality for 1 or 2 types).\nWhat would really show this off ... would be if someone built a simple demo on top of Northwind or something, it would be crazy easy to get everything except the GraphQL bit as a base start point.. Did a bit of digging through the info above these are pretty good ...\nhttp://fiyazhasan.me/tag/graphql-dotnet/\nhttps://fullstackmark.com/post/17/building-a-graphql-api-with-aspnet-core-2-and-entity-framework-core\n... looks to me like this can be closed now :). ",
    "snortblt": "Note that the simple examples shown above where a new DbContext is created per type is bypassing much of the efficiencies that EF provides as explained here. You ideally want to have a single context per GraphQL query not per database query.. ",
    "BenHayat": "But, shouldn't GraphQL implementation be done by MSFT EF Core team? So we have official & proper implementation by the vendor of EF.. ",
    "jannikbuschke": "@TehWardy did you find answers to your question? Im facing the same issue. All the GraphQL hype sounds good (compared to OData where community and tools is not extremly vivid), but when I actually want to understand a simple querying use case where a combination of pagination, filtering and ordering should be applied to a EF Core IQueryable/DbSet then I seem to not find any good example (I could only find some unrealistic inmemory List examples).\nOdata works just fine with an IQueryable, and as EF Core exposes IQueryables the combination is extremly simple and powerfull.\n[EnableQuery]\npublic IQueryable<Person> GetPersons(){\n return dataContext.Persons;\n}\nis basically all the code I need to expose Persons that can be searched, paged, filtered, ordered at the same time and the generated SQL is just as good as I could have written it. How to do that with GraphQL?. ",
    "Kurren123": "@jquense  thanks for your reply. The schema is being built at runtime and the response will match the schema exactly so it's static in that sense, but I don't know the fields at compile time. Say I have a CSV file where the top row is a header row but I'm unsure of columns at compile time.\nI can generate the schema from the CSV file at runtime, but how would I return the response?\nThanks for the help. What if an existing API gave me back response objects of type Dictionary. How could I send that as a response? I'm pretty sure I could send it if the dictionary could be serialised into JSON rather than a plain object. . @joemcbride thanks. How would the response be sent in the resolve method in this situation?. @joemcbride we can assume there's only 1 csv file on the server at a known path. The problem is that the resolve method only accepts a plain object, on which it reflects over the objects properties. Once the schema is built how do we return the response for subsequent queries?. Hi @jquense and @joemcbride. I think this will all be solved if we allow the resolve method to return a dynamic object. This will allow users to use something like an ExpandoObject  and do something like this:\n```\ndynamic person = new ExpandoObject();\nperson.FirstName= \"Ellen\"; //known at compile time\nvar personDict = person as IDictionary;\npersonDict.Add(myFieldName, \"Adams\"); //not known at compile time\nreturn person;\n```\nThis way you don't have to know the fields at compile time, and the library will still return an error if you don't return fields specified by the schema. I don't mind making the required changes and submitting PR. I would propose the following:\n\nIn the Resolve method of NameFieldResolver, before we call source.GetType().GetProperty(context.FieldAst.Name, _flags); add an if statement to check if source implements IDynamicMetaObjectProvider. \nIf it doesn't, get the property as usual.\nIf it does, try casting it to IDictionary<String, Object> (the easiest way to get the property) . If it fails, throw an error saying all dynamic objects returned from the resolve method must implement IDictionary<String, Object>. If it succeeds, get the property value by using the dictionary.\n\nSomething to note is that we can relax the conditions and just have the object implement IDictionary<String, Object> rather than having to be dynamic, and we can resort to trying to cast to a dictionary if trying to get the property the usual way fails. I don't mind implementing this approach either.\nAfterwards I can add a unit test if need be. Please let me know if I am on the right track.\nThanks again for your help,\nKurren. > Even if your source object is dynamic you will still need to statically define the type if is resolved to (and it's fields)\n@jquense thanks for your reply. The schema itself is in fact static, it never changes. It's just not known at compile time, the headers in the CSV file are never changing. I can construct the schema fairly easily using the dynamic schema creation and reading the headers of the CSV upon starting the webservice. I just get stuck on sending the response in the resolve method.\nInstead of a CSV it could instead be a sql table whos columns never change or an API of an existing system that returns a Dictionary<String, Object> with the same keys every time rather than a plain object. In fact I think there are quite a lot of situations a dynamic object will be needed even with a static schema. \nIn the graphQL javascript client we have the benefit of just doing myObject['myProperty'] = 'value'; but the only real way in .Net is dynamic objects. I made the above change and added a unit test. I can use this for my own use but I'm also happy to do further work and submit a PR if you think the library can benefit from this.\nKind regards,\nKurren. Hi @joemcbride thanks for your help. I managed to find a solution without creating a custom scalar type or modifying the source. For anyone else reading that wants to return a dynamic object or Dictionary<String, Object> when resolving an ObjectGraphType:\nFirst create a wrapper class:\npublic class FieldInfo\n{\n    public Dictionary<string, object> FieldValues { get; set; }\n}\nThen in your resolve method for the object type where you want to return a dictionary:\nreturn new FieldInfo {FieldValues = myDictionaryResult};\nThen in the resolve method for each field in the object type, I built each one dynamically so I already knew the field name:\nvar info = ctx.Source as FieldInfo;\nreturn info.FieldValues(fieldName);\nThank you both very much for your time. I think we may close this issue now.. @lwansbrough Yes the fields were contained in a static text file. I added each one to the ObjectGraphType and in the resolve method checked if dictionary contained in ctx.Source contained a key with the name of the current field being added.\nAs the others said the API itself needs to be static (not changing often) but in my case I didn't have .net classes defined for each GraphObjectType, they were built from other sources like text files and databases.. Hi @joemcbride, thanks for your reply. I want to use graphql-dotnet's query batching but the example isn't very easy to follow because it assumes knowledge of marten. Is there a simpler example, using e.g. Entity framework's include method? I think more people would familiar with that rather than marten.. I use this library to wrap existing APIs which use strings rather than classes. E.g. api.GetAll(\"customers\"). Because of this I build my graphQL api manually (adding my own FieldTypes etc) rather than auto generating through static classes. So a convention based approach won't help me.\nI also do not use this with ASP.net core, so maybe the middleware could be provided through a separate library?. ",
    "lwansbrough": "@Kurren123 How did you build the fields dynamically? Presumably you'd need to know the keys of the dictionary in order to do that, correct? I'm at the point where I've got the field defined as so:\ncsharp\n            Field(\n                typeof(ObjectGraphType),\n                \"metadata\",\n                \"Metadata related to this object.\",\n                resolve: ctx =>\n                {\n                    return ctx.Source.Metadata[ctx.FieldName];\n                }\n            );\nbut of course because ObjectGraphType doesn't have any fields on it, I can't query like:\n... metadata { someProperty } ...\nI get an error saying someProperty doesn't exist in ObjectGraphType. . This doesn't cover asynchronous work. I'm having to run an async method with forced synchronization in the Dispose method of my observable. . Oh great, wasn\u2019t aware that was possible. Thanks!. This doesn't seem to solve my issue. Let me elaborate with some code:\nMy (Theoretical) Subscriber (EventStreamResolver):\n```\nprivate IObservable SubscribeThing(ResolveEventStreamContext context)\n{\n    var thingSubject = new Subject();\nvar subscription = await stream.SubscribeAsync((Thing data) =>\n{\n    // `data` here is updated\n    thingSubject.OnNext(data);\n});\n\n// store `subscription` here\n\nreturn thingSubject.AsObservable();\n\n}\n```\nSo you see, I need to be able to await something while also being able to return an observable. Obviously the code above doesn't work because I can't make SubscribeThing async. I could make the SubscribeAsync call synchronous but that's not a good solution.. @pekkah It is not my code. It is a Microsoft Orleans stream. Therefore it must be async.. I\u2019m pretty unfamiliar with reactive programming in C# - are there any work arounds you can think of? The workaround I\u2019m using right now just basically blocks until the async method is completed, but that\u2019s not a very nice solution.. @pekkah - Is there a workaround? Pretty safe to assume we might want to use an async interface to set up a subscription channel.. @pekkah Yes that API is perfect for my needs. This looks great, thank you!. Whoops, I should have upgraded before filing this, I'm on 2.0.0-alpha-817. I'll upgrade then retry. Thanks!. Fixed, thank you.. ",
    "acronoah": "I am running into the same problem.  I pull data dynamically from an underlying database and have my schema defined externally in a .graphqls file.  I am able to successfully build the fields, but if I try to resolve with a List I get an error at runtime:  \nGraphQL.ExecutionError: Error trying to resolve id. ---> System.InvalidOperationException: Expected to find property id on JObject but it does not exist.\\n   at GraphQL.Resolvers.NameFieldResolver.Resolve(Object source, String name)\\n   at GraphQL.Resolvers.NameFieldResolver.Resolve(ResolveFieldContext context)\\n   at GraphQL.Instrumentation.MiddlewareResolver.Resolve(ResolveFieldContext context)\\n\nIs there any plan to natively support dynamics as @Kurren123 mentioned earlier?  I'm at the point where I am contemplating forking the repo to deal with the problem as he described.   Any other best places to start from or alternate solutions to returning a dynamic?. @harsimranb Can you please post your solution?  I am running into this exact issue - I can get arbitrary data from my database and I expect it to conform to the graph ql schema (it does).  If I create the object in my resolver as an anonymous type, it works fine, but if I try to return dynamic objects it fails with:\nGraphQL.ExecutionError: Error trying to resolve id. ---> System.InvalidOperationException: Expected to find property id on ExpandoObject but it does not exist.\\n   at GraphQL.Resolvers.NameFieldResolver.Resolve(Object source, String name)\\n\n. My solution (not yet generified for all types, but...):\n```csharp\nvar schema = Schema.For(File.ReadAllText(\"GraphQL/schemas/schema.graphqls\"));\nvar simulationType = schema.FindType(\"Simulation\") as ObjectGraphType;\nsimulationType.Fields.ForEach(f => f.Resolver = new FuncFieldResolver(ctx =>\n{\n    var o = ctx.Source as IDictionary;\n    if (o == null)\n    {\n        return null;\n    }\nif (!o.ContainsKey(ctx.FieldName))\n{\n    return null;                    \n}\n\nreturn o[ctx.FieldName];\n\n}));\nRegisterTypes(schema.AllTypes.ToArray());\nQuery.AddField(\n    new FieldType()\n    {\n        Name = \"simulations\",\n        ResolvedType = new ListGraphType(simulationType),\n        Resolver = new FuncFieldResolver>(ctx =>\n        {\n            var simulations = _db.GetCollection(simulationType.Name);\n            var result = simulations.Find(Builders.Filter.Empty).Limit(10).ToList();\n            return result;\n        })\n    });\n}\n. How I solved this:csharp\n public class AspNetDependencyResolver : IDependencyResolver\n    {\n        private IServiceProvider _serviceProvider;\n    public AspNetDependencyResolver(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public T Resolve<T>()\n    {\n        return (T) _serviceProvider.GetService(typeof(T));\n    }\n\n    public object Resolve(Type type)\n    {\n        return _serviceProvider.GetService(type);\n    }\n}\npublic class GraphSchema : Schema\n{      \n    public GraphSchema(IServiceProvider serviceProvider)\n    {\n        DependencyResolver = new AspNetDependencyResolver(serviceProvider);\n     }\n}\n\n. Essentially works, although graphQL explorer complains about the input side:csharp\n  class JsonGraphTypeConverter : IAstFromValueConverter\n    {\n        public bool Matches(object value, IGraphType type)\n        {\n            return type.Name == \"Json\";\n        }\n    public IValue Convert(object value, IGraphType type)\n    {\n        return new JsonGraphValue(value as Dictionary<string, object>);            \n    }\n}\n\n\nclass JsonGraphValue : ValueNode<Dictionary<string, object>>\n{\n    public JsonGraphValue(Dictionary<string, object> value)\n    {\n        Value = value;\n    }\n\n    protected override bool Equals(ValueNode<Dictionary<string, object>> node)\n    {\n        return Value == node.Value;\n    }\n}\n\ninternal class JsonGraphType : ScalarGraphType\n{\n    public JsonGraphType()\n    {\n        Name = \"Json\";\n    }\n\n    public override object Serialize(object value)\n    {\n        return ParseValue(value);\n    }\n\n    public override object ParseValue(object value)\n    {\n        if (value == null)\n        {\n            return null;\n        }\n\n        return value;\n    }\n\n    public override object ParseLiteral(IValue value)\n    {\n        if (value is JsonGraphValue)\n        {\n            return value.Value;\n        }\n        else\n        {\n            var tv = value as JsonGraphTypeConverter;\n            return tv?.GetValue();\n        }\n    }\n}\n\n```\n\n. @joemcbride - Any progress on adding description support via comments in the parser?  This is definitely the \"standard\" way/place for this information to go.. I am unclear as to where to add this code:\n```csharp\nvar listener = Services.GetRequiredService();\nvar executer = new DocumentExecuter();\nvar result = executer.ExecuteAsync(opts => {\n...\n\nopts.Listeners.Add(listener);\n\n});\n```\n. I ended up modifying GraphQLHttpMiddleware.cs to add the listener.  \nhttps://github.com/Conning/graphql-dotnet-server/commit/56398c9e1e2693652e056d9adf867c1a961d34d4\n. To be clear, here's my goal code:\n```csharp\n public class NotificationSubscriptionUnion : UnionGraphType\n    {\n        public NotificationSubscriptionUnion()\n        {          \n            Type();\n            Type();\n        }\n    }\npublic class NotificationSubscriptionInterface : InterfaceGraphType<NotificationSubscription> {\n    public NotificationSubscriptionInterface()\n    {\n        Name = \"NotificationSubscription\";\n        Field<StringGraphType>().Name(\"_id\").Description(\"Unique ID\");\n        Field(x => x.endpoints);\n        Field(x => x.trigger);\n        Field(x => x.target).Description(\"The triggering event for the subscription.\");                      \n    }\n}\n\npublic class SimulationNotificationSubscription : ObjectGraphType<NotificationSubscription> {\n    public SimulationNotificationSubscription() \n    {      \n        Interface<NotificationSubscriptionInterface>();\n\n        IsTypeOf = s => !string.IsNullOrEmpty((s as NotificationSubscription).simulationPhase); \n        Field(x => x.simulationPhase);                                  \n    }        \n}\n\npublic class BillingNotificationSubscription : ObjectGraphType<NotificationSubscription> {\n    public BillingNotificationSubscription() \n    {      \n        Interface<NotificationSubscriptionInterface>();\n\n        IsTypeOf = s => (s as NotificationSubscription).threshold != null;\n\n        Field(x => x.threshold, nullable:true);                                  \n    }        \n}\n\n. Similar problems with interfaces:\nGraphQL.ExecutionError: Interface type IAutomationJobOutput does not provide a \"resolveType\" function and possible Type \"SimulationJobOutput\" does not provide a \"isTypeOf\" function.\n. ObjectGraphType.AddResolvedInterface() is called twice for my object, but the Fill() call below public void AddResolvedInterface(IInterfaceGraphType graphType)\n    {\n      this._resolvedInterfaces.Fill(graphType);\n    }\n```\nwhich incorrectly believes the item already is contained here:\npublic static void Fill<T>(this IList<T> items, IEnumerable<T> itemsToAdd)\n    {\n      itemsToAdd.Apply<T>((Action<T>) (x =>\n      {\n        if (((ICollection<T>) items).Contains(x))\n          return;\n        ((ICollection<T>) items).Add(x);\n      }));\n    }\nI am unsure as to why Contains is returning true when the interface most definitely doesn't already existing in the list:\n\n. The problem is that the base GraphType.cs implements Equals like so:\nprotected bool Equals(IGraphType other)\n    {\n      return string.Equals(this.Name, other.Name);\n    }\nThere needs to be an override in GraphQLTypeReference to make this comparison use TypeName instead.. Fixed by this commit. ",
    "mahald": "If u really want to expose ur full exceptions u can do this like this:\n```\n           var result = await new DocumentExecuter().ExecuteAsync(.....\n        #if DEBUG\n            result.Errors?.ToList().ForEach(err =>\n            {\n                result.Errors.Add(new ExecutionError(err.ToString()));\n            });\n        #endif\n\n```\nExecute it after DocumentExecuter().ExecuteAsync and it will expose all exeptions fully on Debug Mode.\nA Result may looks like this:\n{\n  \"data\": {\n    \"permissionGroupUpdate\": null\n  },\n  \"errors\": [\n    {\n      \"message\": \"Error trying to resolve permissionGroupUpdate.\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ]\n    },\n    {\n      \"message\": \"GraphQL.ExecutionError: Error trying to resolve permissionGroupUpdate. ---> System.AggregateException: One or more errors occurred. (HARRY HIRSCH) ---> System.Exception: HARRY HIRSCH\\r\\n   at Csf4.Api.Private.ApiMutations.<>c.<<-ctor>b__0_10>d.MoveNext() in D:\\\\mh\\\\officeSVN\\\\csfWebBackend\\\\Api\\\\Private\\\\ApiMutations.cs:line 412\\r\\n   --- End of inner exception stack trace ---\\r\\n   at GraphQL.Instrumentation.MiddlewareResolver.<Resolve>d__2.MoveNext() in D:\\\\mh\\\\tmp\\\\graphql-dotnet-master\\\\src\\\\GraphQL\\\\Instrumentation\\\\MiddlewareResolver.cs:line 27\\r\\n   --- End of inner exception stack trace ---\"\n    }\n  ]\n}\n. I further improved it. I also got the wish as @jquense mentioned.\nfollowing solution let's u see full stack trace in DEBUG mode AND Let's u throw error Messages in the Resolver that can be understood by the user.\nfirtst is passing any \"GraphQL.ExecutionError\" exception.\nSo u can throw new ExecutionError(\"DISPLAY THIS ERROR MESSAGE\"); in the resolver.\nsecond is the above and displays the full stack trace.\nI replace the Errors of the result, so no double errors are in there.\n```\n            var result = await new DocumentExecuter().ExecuteAsync(_ => ....\n        ExecutionErrors myExecutionErrors = new ExecutionErrors();\n\n        result.Errors?.ToList().ForEach(err =>\n        {\n            var inner = err.InnerException?.InnerException;\n            var type = inner?.GetType();\n            if (type?.FullName == \"GraphQL.ExecutionError\")\n            {\n                myExecutionErrors.Add(new ExecutionError(inner.Message));\n            }\n            else\n            {\n                myExecutionErrors.Add(err);\n            }\n        });\n\n        #if DEBUG\n        result.Errors?.ToList().ForEach(err =>\n            {\n                myExecutionErrors.Add(new ExecutionError(err.ToString()));\n            });\n        #endif\n\n        if (myExecutionErrors.Count > 0)\n        {\n            result.Errors = myExecutionErrors;\n        }\n\n        return result;\n\n```\nso if i throw a GraphQL.ExecutionError inside the resolver now it looks like this (second one is due to DEBUG mode):\n{\n  \"data\": {\n    \"permissionGroupUpdate\": null\n  },\n  \"errors\": [\n    {\n      \"message\": \"DISPLAY THIS ERROR MESSAGE\"\n    },\n    {\n      \"message\": \"GraphQL.ExecutionError: Error trying to resolve permissionGroupUpdate. ---> System.AggregateException: One or more errors occurred. (DISPLAY THIS ERROR MESSAGE) ---> GraphQL.ExecutionError: DISPLAY THIS ERROR MESSAGE\\r\\n   at Csf4.Api.Private.ApiMutations.<>c.<<-ctor>b__0_10>d.MoveNext() in D:\\\\mh\\\\officeSVN\\\\csfWebBackend\\\\Api\\\\Private\\\\ApiMutations.cs:line 413\\r\\n   --- End of inner exception stack trace ---\\r\\n   at GraphQL.Instrumentation.MiddlewareResolver.<Resolve>d__2.MoveNext() in D:\\\\mh\\\\tmp\\\\graphql-dotnet-master\\\\src\\\\GraphQL\\\\Instrumentation\\\\MiddlewareResolver.cs:line 27\\r\\n   --- End of inner exception stack trace ---\"\n    }\n  ]\n}\nhth. Well there are 2 ways of donig this:\n\n\nchange in the ExecutionResultJsonConvert for Debug Mode:\n#if DEBUG\n                    serializer.Serialize(writer, error.ToString());\n                #else\n                    serializer.Serialize(writer, error.Message);\n                #endif\nThe Problem here is to bring in config or parmas from somewhere\n\n\nAdd ExposeExceptions to the options of DocumentExecuter and change in DocumentExecuter.cs after Execution:\n\n\nif (context.Errors.Any())\n                    {\n                        if (config.ExposeExceptions)\n                        {\n                                result.Errors = new ExecutionErrors();\n                                foreach (ExecutionError err in context.Errors)\n                                {\n                                    result.Errors.Add(new ExecutionError(err.ToString()));\n                                }\n                        }\n                        else\n                        {\n                            result.Errors = context.Errors;\n                        }\n                    }\n@joemcbride  would u accept a PR for 2) or what do u think ?. Pull request #391 added to implement variant 2) as 1) doesn't work if u don't got it local. Yea the above mentioned middleware is great. BUT don't forget to take the bugfixes from the open pull request. Else u will run into big trouble.. Yes\nIt must be defined explicitly:\nField(x => x.Id, type: typeof(IdGraphType)).Description(\"Id of the UserProfile\");\n. The GraphQL request is lookin like this: \nmutation permissionGroupUpdate($id: ID!, $permissions: [String]) {\n  permissionGroupUpdate(id: $id, permissions: $permissions) {\n    id\n    name\n    permissions {\n      id\n    }\n  }\n}\nThe Variables: \n{\n  \"id\": \"7a2883e1-b113-4c45-9ffd-7c3fde4d6254\", \n  \"permissions\": [\"USER_PROFILE_R\",\"USER_PROFILE_R\"]\n}\nHere is the way i execute it: \n```\n        private async Task ExecuteAsync(HttpContext context)\n        {\n            string requestBodyText;\n            using (var streamReader = new StreamReader(context.Request.Body))\n            {\n                requestBodyText = await streamReader.ReadToEndAsync().ConfigureAwait(true);\n            }\n            var graphqlRequest = JsonConvert.DeserializeObject(requestBodyText);\n        return await new DocumentExecuter().ExecuteAsync(schema: schema, root: null , query: graphqlRequest.Query, operationName: graphqlRequest.OperationName,\n            inputs: graphqlRequest.Variables, userContext: context).ConfigureAwait(true);\n    }\n\n```\n<-- Is this not ok ?\n. i can not finde the ToInputs() function on Variables. Ok, thanks for the help, i had to change:\nJsonConvert.DeserializeObject<GraphQLRequest>(requestBodyText);\nto:\nJsonConvert.DeserializeObject<JObject>(requestBodyText);\nThe entire function now looks as follows:\n```csharp\n        private async Task ExecuteAsync(HttpContext context)\n        {\n            string requestBodyText;\n            using (var streamReader = new StreamReader(context.Request.Body))\n            {\n                requestBodyText = await streamReader.ReadToEndAsync().ConfigureAwait(true);\n            }\n        var graphqlRequest = JsonConvert.DeserializeObject<JObject>(requestBodyText);\n\n        var Variables = graphqlRequest[\"variables\"]?.ToInputs();\n\n        var result = await new DocumentExecuter().ExecuteAsync(_ =>\n        {\n            _.Schema = schema;\n            _.Root = null;\n            _.Query = graphqlRequest[\"query\"].ToString();\n            _.Inputs = Variables;\n            _.OperationName = graphqlRequest[\"operationName\"]?.ToString();\n            _.UserContext = context;\n        }).ConfigureAwait(false);\n\n        return result;\n    }\n\n```\ni had to add following code to ur lib:\ncsharp\n        public static Inputs ToInputs(this JToken obj)\n        {\n            var variables = obj?.GetValue() as Dictionary<string, object>\n                            ?? new Dictionary<string, object>();\n            return new Inputs(variables);\n        }\nas graphqlRequest[\"variables\"] is of type Jtoken\n. Thanks a lot this solved it.. Ok here the PR with copy the config variable to ExecutionResult. See #279. Note: The example maybe isn't good, as permission are handled outside the resolver. But in my case it would be like:\nthrown new GraphQL.CustomException($\"insufficent licenses, please buy more licenses in the license menu\");. oops, sorry missed that this was implemented. thanks a lot.. ",
    "oldnavy1989": "I've got similar behavior. There's a service inside resolving function. It can throw an exception. I need to log the exception. Haw can I reach that globally without try/catch blocks in particular resolving function?. @joemcbride Thank you for answer. I tried to use middleware to catch exceptions but didn't figure out how to implement it. While debuging if exception raised in resolver there is no continuation in resolve method in middleware class, so it just returns executionresult. Can you provide a sample with handling errors in middleware please?. ",
    "rami-hatoum": "I have tried to add meta-data using the field middleware to use in a validation rule and generate custom errors. The problem is validation rules run before the field middleware. Any ideas? Also it would be great if we can pass in a custom JSON convertor.. ",
    "cstlaurent": "Hi, @lngr, I worked with @mamasselin on the pull request #272 ans I would advise against reversing it. The goal of this merge request was to fix the unexpected behavior of receiving null in your StringGraphType field value if you had a string that happened to look like an ISO date. I think this correction puts this library in line with the GraphQL standard.\nDate handling is not in the standard since it's not native to json, but I still agree with you that losing timezone information when you have a DateGraphType is very bad.\nI was pretty sure we covered the issue you mentioned while doing the modifications but maybe we missed something.\nAnyway, @mamasselin and me are looking into it.. ",
    "santoshpatro": "Hi Joe/Pravinhabbu4u,\nI have the same requirement as mentioned  in this question. After reading your suggestions, I created a class: GraphQLUserContext as mentioned by you and registered in the ConfigureServices method in the Startup.cs class.I see that even the UserContext is set with the headers in the GraphQLController but on using it in the TestQuery class, resolve method it is still returning null and leading to error. In short I am not getting the headers in the TestQuery class resolve method.\nCan you please help me how to fix this issue. \nOne more small request like in my current project where I am using Graphql.NET to create the new endpoints, I have to always pass the locale data by reading the incoming request headers to the business logic via the resolve methods. Since this is going to be repeated in almost every resolve method can you please guide me how to encapsulate it in one centralized place and implement it instead of repeating the duplicating the code in every resolve method.\nAny help on this is much appreciated.\n```\n// Utilties\npublic interface IGraphQLUserContext\n{\n    IHeaderDictionary Headers\n    {\n        get;\n        set;\n    }\n//string GetCookieId();\n}\npublic class GraphQLUserContext : IGraphQLUserContext\n{\n    public IHeaderDictionary Headers\n    {\n        get;\n        set;\n    }\n}\n// GraphQLController\n[HttpPost]\npublic async Task Post([FromBody] GraphQLQuery query)\n{\n    if (query == null)\n    {\n        throw new ArgumentNullException(nameof(query));\n    }\nvar inputs = query.Variables.ToInputs();\nvar executionOptions = new ExecutionOptions{Schema = _schema, Query = query.Query, Inputs = inputs, UserContext = new GraphQLUserContext{Headers = Request.Headers}};\nvar result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\nif (result.Errors?.Count > 0)\n{\n    return BadRequest(result);\n}\n\nreturn Ok(result);\n\n}\n// Startup.cs\npublic class Startup\n{\n    public Startup(IConfiguration configuration)\n    {\n        Configuration = configuration;\n    }\npublic IConfiguration Configuration\n{\n    get;\n}\n\n// This method gets called by the runtime. Use this method to add services to the container.\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\n    services.AddScoped(provider =>\n    {\n        var connectionString = Configuration.GetConnectionString(\"TestDb\");\n        return new CMSDbContext(connectionString);\n    }\n\n    );\n    services.AddSingleton<IGraphQLUserContext, GraphQLUserContext>();\n    services.AddSingleton<ITestService, TestService>();\n    services.AddSingleton<IDocumentExecuter, DocumentExecuter>();\n    services.AddSingleton<TestSchema>();\n    var sp = services.BuildServiceProvider();\n    services.AddSingleton<ISchema>(new TestSchema(new FuncDependencyResolver(type => sp.GetService(type))));\n}\n\n// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseHsts();\n    }\n\n    app.UseGraphiQl();\n    app.UseHttpsRedirection();\n    app.UseMvc();\n}\n\n}\n// TestQuery\npublic class TestQuery : ObjectGraphType\n{\n    public TestQuery(ITestService testService, IGraphQLUserContext graphUserContext)\n    {\n        Field(\"result\", resolve: context =>\n        {\n            var headers = graphQLUserContext.Headers;\n            // Process headers to get the locale\n            return testService.GetDetailsForLocation(locale);\n        }\n    , description: \"Location details data\");\n}\n\n}\n```\n. I am also getting the same error. Joe can you please help me to get the fix that you applied in this case. Any help on this is much appreciated.. Hi Joe,\nI am using GraphQL 2.3.0 version. Based on your above details I believe I should be able to use the ByteGraphType similar to the other GraphQL.Types. But I am not able to use it. Am I missing anything here.\nCan you please help me to get some sample reference of using ByteGraphType. I am trying to return byte[] for a field and seeing an error. \nAny help on this is much appreciated.\nThanks,\nSantosh. Thanks a lot Joe for your help \ud83d\udc4d . Hi Joe,\nGetting stuck  through some errors to get it half-working, but was wondering if we could get an example with some code sample on this issue.\nI have been trying a lot but nothing working.\nAny help is much appreciated. \nThanks,\nSantosh. Thanks for your response. Sorry I am not able to follow you here. Can you please help me with some code sample to understand it in better.. Thanks for your response. Can you please help me with any example or links as a reference. From the link, I see it is related to Field metrics which is supported by Graphql.net. I want to know how to add additional custom fields in this case.. By the time I am trying to set the values for the metadata the graphql response is already returned and control goes to the middleware code. Is there anyway to access the fields and update their value. Here goes the field details:\nIn this case Field,Field(x => x.Authorised),Field(x => x.UserMessage, nullable: true) should be returned with every endpoint response.\npublic class TestResultType: ObjectGraphType<TestResult>\n    {\n        public TestResultType()\n        {\n            Field<ListGraphType<TestDTOType>>(\n                \"details\",\n                resolve: context => {\n                    return context.Source.Locations;\n                }\n            );\n            **Field<LocaleType>(\n                \"locale\",\n                resolve: context => {\n                    return context.Source.Locale;\n                }\n            );\n            Field(x => x.Authorised);\n            Field(x => x.UserMessage, nullable: true);**\n        }\n    }\nAny help with some code sample is much appreciated. Hi Joe,\nThanks for your quick response. In my case I need to create a graphql endpoint containing the image path, which in this case is dynamic one. I would like to know how we can create with some code sample.\nIn short an analogous graphql query to the REST API endpoint.\nAny help on this is much appreciated.\nThanks,\nSantosh\n. Hi Joe,\nThanks for your quick response. In my case I need to create a graphql endpoint containing the image path, which in this case is dynamic one. I would like to know how we can create with some code sample.\nIn short an analogous graphql query to the REST API endpoint.\nAny help on this is much appreciated.\nThanks,\nSantosh\n. I have posted the question with all the details at https://stackoverflow.com/questions/53506345/how-to-generate-dynamic-path-value-for-a-graphql-query-response-using-graphql-ne\nI would like to know the mapping between the REST API endpoint and the graphql query that I need to create which will point to the image in this implementation.\nNeed some help from you Joe in this implementation. Thanks Joe for your response. But can you please help me how to deal with image responses. In short how to deal with Fields having image type response. Does it mean that we cannot have anything inbuilt support for providing image response to the client application. Can you please help me to get some code samples as reference.\nAny help on this is much appreciated.. ",
    "troydalldorf": "@OneCyrus @joemcbride Are there any updates on this topic? I have the same question as @OneCyrus for @joemcbride as to what the best strategy would be for implementing distributed queries (at a high level)?. A nice-to-have addition to this would be to have the ability to process children of children in parallel where the parent id was the same or said differently where the child and the child of child have a 1:1 ratio. For example, if an organization only has one address, it would be great to have organization and its address child loaded in parallel.. The nice-to-have in my comment above is already available (#354). @joemcbride I ended up creating a new ParallelStrategy using TPL Dataflow Blocks. The performance improvements are pretty good. Let me know if I should submit a pull request for this.\nHere are the before and after Fiddler timelines.\n\n\n. @joemcbride I have a fork with the code here.\nIt's working code, but pretty rough, i.e. no comments, testing, or ability to set settings, propagate task cancellation, etc. and I wasn't sure how to handle: OnBeforeExecutionStepAwaitedAsync(context).\nIf this is something that would be considered being merged into graphql-dotnet master, I can clean it up and add testing.\nAs a side note: Are there any plans to allow dependency injection of the ExecutionStrategy?\n. Thanks @johnrutherford. I'll clean up the code a little and create a pull request. Good point on the new pipeline for each request. Might be nice as an opt-in. In my particular use case I'm seeing around 4X faster response time.. @johnrutherford, here's the pull request:\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/890\nStill has plenty of work to do, but would appreciate the feedback. Thanks!. Thanks. I'll check out your pull request as well. Thanks for digging into this so fast!. One feature I would still need is the ability to control the maximum degrees of parallelism. This would prevent a few complex queries from consuming too many threads.. ",
    "andrewtyped": "We also have a microservice architecture in alpha which uses GraphQL to provide a gateway. Our approach is similar to GraphQL Hub's. \n\nEach microservice implements its own GraphQL schema which is capable of independent operation. Resolvers in these schemas only access the public API surface of the microservice under test.\nEach microservice's DI registrations for its GraphQL types are made publicly available. \nA separate web service pulls in each schema and its DI registrations and merges them by inserting a ObjectGraphType with an empty resolver in each root object of the merged schema for each  component schema.\nThe inserted ObjectGraphType contains all the fields of the component schema's root object.\nSchema-level objects like directives are added from each component schema to the merged schema.\n\nFor example, suppose I have two schemas:\n```\nSchema A\nschema {\n  query {\n     name: \"AQuery\",\n     AField1: Object,\n     AField2: Object\n  },\n  mutation {\n    name: \"AMutation\",\n    AMutation1: Object, \n    AMutation2: Object\n  }\n}\nSchema B\nschema {\n  query {\n     name: \"BQuery\",\n     BField1: Object,\n     BField2: Object\n  },\n  mutation {\n    name: \"BMutation\",\n    BMutation1: Object, \n    BMutation2: Object\n  }\n}\n```\nThe merged schema would look like: \nschema {\n  query: {\n    AQuery: {\n      AField1: Object,\n      AField2: Object\n    }\n    BQuery: { \n      BField1: Object,\n      BField2: Object\n    }\n  }\n  mutation: {\n    AMutation: {\n       AMutation1: Object, \n       AMutation2: Object\n    }\n    BMutation: {\n       BMutation1: Object, \n       BMutation2: Object\n    }\n  }\n}\nUnfortunately I can't share the code which performs the merger because I don't own it. I can say it was not difficult to write.\nWe like this plan so far because the boundaries of each microservice are clearly marked by the top-level fields in each root object, and it's easy to test each component schema separately. The client, however, is slightly disadvantaged because they have an extra level of nesting to drill through before getting to their query results. We've accepted this trade-off.\nIf there are other disadvantages to this strategy we haven't advanced far enough to see them yet - both our microservices and their GraphQL schemas are simple, and their functions are distinct enough that we don't see value in trying to handcraft a schema that is aware of the overall system. . Confusing behavior occurs when a name is duplicated between any object or interface graph type. In these cases, the playground works (or at least displays a schema) but the schema only registers the first graph type, silently skipping the rest. Probably this is due to GraphTypesLookup.AddTypeIfNotRegistered.  Since the GraphQL spec mandates uniqueness of all type names, maybe this method should throw an exception when it encounters a duplicate name whose type does not match what's already in the lookup dictionary?. I believe this is related to #648 .\nBasically GraphTypes are created only once per schema, when the Schema is initialized. So any dependencies of your GraphTypes are also created only once per schema. Schema is best left as a singleton for now due to the cost of initialization, so all your GraphTypes and their dependencies are also effectively singletons where query execution is concerned.. I'm still reviewing this part of the code myself but I'll give it a shot.\nStarting with your second question: GraphQL.NET serialization happens in 2 stages\n- Query fields are resolved. Assuming no errors occur, their results are aggregated into a .NET object which is assigned to ExecutionResult.Data.\n- The ExecutionResult will eventually be passed to IDocumentWriter.WriteAsync, either by your own code or one of the middleware implementations. The default implementation of IDocumentWriter just serializes ExecutionResult.Data to JSON.\nScalarGraphType.Serialize handles the first step. Serialize will be passed the output of a resolver, and I think usually Serialize will output the same type as the resolver. This is why most Serialize implementations call ParseValue, which in turn usually calls ValueConverter.ConvertTo. ConvertTo performs no action if the provided value is already of the requested type - so Serialize often returns very quickly. I think you would only serialize to a different type if you didn't want the client to see the default JSON representation of your scalar. TimeSpanSecondsGraphType gives an example of this sort of alternative serialization.\nFor your first question... I am not sure why Serialize is called when reading arguments either. Note that Serialize is only called for arguments passed in JSON query variables, and not for literals in the GraphQL query itself. The goal is clear - the library wants to convert the value from JSON to a .NET type to an AST (see GraphQLExtensions.AstFromValue. But it does seem like using the same method call for input and output like this confuses the issue - In this context the operation seems more like deserialization than serialization to me.. @joemcbride Hey, I started on the requested change but wanted to host the docs locally to make sure I got the site yaml right. I'm having problems with the output of the gatsby build - I can build and host the docs locally but every page I try to visit results in TypeError: Cannot read property 'jsonName' of undefined. I'm doing this on Windows, do you use a different platform (assuming yes since you publish w/ a bash script)? I get the same issue even when building docs for a fresh clone of the main repo.\nUPDATE: I set up an ubuntu VM to test this and everything works. I may open a separate issue for the Windows problems but for now I'll work out of my VM.. Looks like the build is failing on SimpleDataLoaderTests.Operation_Can_Be_Cancelled. Seems like this fails sporadically and has occurred in many PRs. I haven't made code changes anyway so I'm not sure I need to debug this.. ",
    "psavanur": "Yes I want to know if filtered data need to be supplied by us or GraphQL gets it by applying its own query mechanism.. Thanks joemcbride. Thanks joemcbride. ",
    "harsimranb": "I figured this out.  FieldType has a Resolver property which helps address this.. ",
    "ghost": "Thanks for your feedback. It's very helpful for us.. ",
    "kantora": "As far as I see from the code, ComplexityAnalyzer recursively goes through the graph tree and have access to these fields. So adding FieldImpact to every field should not generate any additional load impact.\nIt can be double?, so for undefined case avgImpact can be used to maintain backward compatibility.. But this will give very flexible analysis. As requesting pre-initialized scalar field costs almost nothing. Requesting something that leads to select from db with a large amount of data is complex. This select but with the use of some string filters is very complex. You just can't take an average for such complexity. They are too different.. @dNetGuru sorry, really missed some points.\nAs for now looked more deeply into the code and (I hope) got more understanding.\nIMHO this code from general implementation \n```\n        private static double? GetImpactFromArgs(INode node)\n        {\n            double? newImpact = null;\n            var args = node.Children.First(n => n is Arguments) as Arguments;\n            if (args == null) return null;\n        if (args.ValueFor(\"id\") != null) newImpact = 1;\n        else\n        {\n            var firstValue = args.ValueFor(\"first\") as IntValue;\n            if (firstValue != null) newImpact = firstValue.Value;\n            else\n            {\n                var lastValue = args.ValueFor(\"last\") as IntValue;\n                if (lastValue != null) newImpact = lastValue.Value;\n            }\n        }\n        return newImpact;\n    }\n\n```\nlooks lika a kludge to work around specific relay connections. But is made in general implementation for every field. Maybe it will be better to move this method to be a part of the Field. So field can implement it depending of it's meaning.\nSo Field can have virtual method GetFieldImpact() (I still don't have enough understanding of its arguments, but it should have access to the arguments AST) that will return an actual value. By default, it can return avgImpact. But it can be overridden, for example, to make relay connections estimate the number of returned edges by passed arguments. \n. Also, GetFieldImpact can be defined as a delegate to get rid of Field inheritance.. Yeah, it is hard to discuss this abstractly. I hope that I can get enough time to work on it this weekend and propose the PR, so everything will become more obvious..  As it always happens - task is more complex that seems from the first sight,\nUnfortunately, I must admit that this will be the breaking change as current implementation tries to estimate complexity only by query tree without using the schema (it even runs before the query validation).\nAs it seems to me - the process of complexity analysis very looks like the resolve process with only difference - that there is no actual resolve but calculating complexity on every hop.\nI am still working on the PR and will try to show the results soon.. I tried to apply it to the real schema in my project and get a huge complexity estimation for rather simple queries. And as I see - this estimation has a very little touch with reality. Some nodes are arrays - some are not, current estimation doesn't take this into an account. Also, it will be great, if fields that lead to the heavy db request will bring much more field impact then simple cached field value request. I hope, that I can introduce new complexity analyzer based on validators, so these will be just alternative way, not breaking change. Nevertheless, I believe that it is impossible to make any estimations without taking schema in account at all.\nAnd yes - I understand that this should be fast and generate very little load.. That is completely untrue! If a node had children then the node and it's children are considered in the complexity!\nI haven't meant that node's children aren't taken into account.\nIn general (I'll simplify for now and will forget about fragments for a minute) - every request node can be some object, array or scalar. For arrays - the children complexity should be multiplied by the possible number of children. For non-arrays, we shouldn't do this and just take in account field self-complexity and a sum of the complexity of its children. Just with the use of AST tree, you can't distinguish objects from the array of objects and scalars from the array of scalars (but yes, you can distinguish scalars from objects).\nAs far as I understood, you are trying to guess the type of node in custom analyzer by its name and/or arguments. And I still miss the point why you don't want to use the ready schema data? And its seems to me, that in #312 you are trying to create a duplicate schema definition for ComplexityAnalyzer just to avoid the usage of the real schema definition.. One more question. Why is complexity analysis run before query validation in document execution conveyor? Are there any risks in validation of malicious queries or validation is considered to be the \"heavy\" operation?. @dNetGuru according to sangria example - simple weight is not enough. Every field can have complexity delegate that accepts context?, field arguments and pre-calculated child score and returns the final complexity score for this field. This is exactly what I was trying to explain/suggest all this thread.. > I'm still against delegates and the rest. It might have made sense there but I am not sold on it making a noticeable in detecting malicious queries.\n@dNetGuru Can you explain why? What are the risks? And as far as I know almost all of GraphQL implementations on other platforms use this approach.\nAnd If you are going to add only constant weight, how do you propose to handle example from Sangria?\ncomplexity = Some((ctx, args, childScore) \u21d2 25.0D + args.arg[Int](\"limit\") * childScore) - when complexity is dependent from field arguments?\n\nHow close are you to finishing your implementation @kantora I want to take a look at it and see how your implementation holds.\n\nI've made some dirty code for PoC, but I really don't like it for now and want to completely rewrite it. \nMy friend is working on the extension to implement Sangria approach with use the of custom validators as an external solution (complexity delegate could be stored in the field's metadata).\nI can spend this weekend on creating built-in sangria approach as an additional solution, without breaking changes (in the case of approval, the current solution could be just marked as obsolete but will still be compliant) - of course, if there is an interest in it.\n. I've made a PR. Please - look at it.. sorry, tried to search for duplicates using the wrong keyword 'locale'. The main problem with Validators - in current solution they don't have an access to the variables values. So they can't resolve field argument values properly. Now the only correct solution to resolve arguments are in the execution context (I had to make my own resolver in this proposition). Suppose that this should be extracted to som other entity to be available also in the validators and/or complexity analyzer.\nThe second option - you told me that complexity analysis should be done before validation to avoid validation overload. Is this still correct?\nI can try to rewrite it to Validators but will have to update them to gain access to the variables. The field complexity parameter can be also moved to field metadata with easy access through extension methods.\nIn case you prefer the solution from this PR, the DocumentExecutor dependency can be easily removed with DocumentExecutor refactoring. Some of its methods are really static by their body and can be moved in a separate utility class (and only such method are used in PreciseComplexityAnalyser).\nSo please - tell me what the way is preferable,. Ouch, I haven't read your comment accurate. Sorry.\nThanks for response - I'll look at it an make an update.. @joemcbride thanks a lot. That was some stupid of me. I fixed as you said and everything started to work as expected.. ",
    "janskoruba": "Thank you so much, you are right because I've used the web api. :). I am excited :) it works like a charm\nI am wondering about creating the queries to the database:\nIf I've use the query above \"users\" where this query returns the  list of users with friends but if I've created following query:\n{\n   users{\n    id\n  }\n}\nThis query get users with friends from database and in the memory get only users with id's.\nIs it good approach? \nI am wondering how optimize the finally query to database according the query from the client like this:\nSELECT id FROM dbo.[User]\nWhat do you think about that?\nThank you.\n. Thank you very much guys for your quick reply. I appreciate it. I will continue discover this awesome implementation of GraphQL. :). ",
    "ujwaliyer": "above Authentication/Authorization link is broken! @joemcbride . Thank you so much joe!. so i can using Dapper or Iqueryable EF to directly execute my filter clauses on the server right. that shud be the way going forward. . ",
    "prabaprakash": "```cs\nusing GraphQL;\nusing GraphQL.Http;\nusing GraphQL.Types;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nnamespace GraphQLDemo\n{\n    class Program\n    {\n        public static void Main(string[] args)\n        {\n            Run().Wait();\n        }\n        private static async Task Run()\n        {\n            Console.WriteLine(\"Hello GraphQL!\");\n        var schema = new AuthorsSchema();\n\n        var result = await new DocumentExecuter().ExecuteAsync(_ =>\n            {\n                _.Schema = schema;\n                _.Query = @\"\n             query {\n             authors (name: \"\"nicholas cage\"\") {\n                id\n                name\n                country\n                books {\n                   name\n                   genres {\n                           name\n                     }\n\n                  } } }\";\n            }).ConfigureAwait(false);\n\n        var json = new DocumentWriter(indent: true).Write(result);\n\n        Console.WriteLine(json);\n        Console.Read();\n    }\n}\n\npublic class Author\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Country { get; set; }\n\n    public List<Books> books { get; set; }\n}\npublic class Books\n{\n    public String Name { get; set; }\n    public int Id { get; set; }\n\n    public List<Genre> Genres { get; set; }\n}\npublic class Genre\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class GenreType: ObjectGraphType<Genre>\n{\n    public GenreType()\n    {\n        Name = \"Genre\";\n        Field(x => x.Id).Description(\"ID\");\n        Field(x => x.Name, nullable: true).Description(\"genre\");\n    }\n}\n\npublic class AuthorsType : ObjectGraphType<Author>\n{\n    public AuthorsType()\n    {\n        Name = \"Author\";\n        Field(x => x.Id).Description(\"ID\");\n        Field(x => x.Name, nullable: true).Description(\"Name of author\");\n        Field(x => x.Country, nullable: true).Description(\"Country\");\n        Field<ListGraphType<BookType>>(\n                         \"books\", \"list of books\");\n    }\n}\n\npublic class BookType : ObjectGraphType<Books>\n{\n    public BookType()\n    {\n        Name = \"Book\";\n        Field(d => d.Id).Description(\"ID\");\n        Field(d => d.Name).Description(\"Name\");\n        Field<ListGraphType<GenreType>>(\n                        \"genres\", \"list of genre\");\n    }\n}\npublic class StarWarsQuery : ObjectGraphType\n{\n    public StarWarsQuery()\n    {\n        Field<AuthorsType>(\n          \"authors\",\n          arguments: new QueryArguments(new QueryArgument<StringGraphType> { Name = \"name\" }),\n          resolve: context =>\n          {\n\n              List<Genre> genres = new List<Genre>();\n              genres.Add(new Genre() { Id = 1, Name = \"Adevnture\" });\n              genres.Add(new Genre() { Id = 1, Name = \"Romantic\" });\n              List<Books> books = new List<Books>();\n              books.Add(new Books() { Id = 1, Name = \"The Notebook\", Genres = genres });\n              books.Add(new Books() { Id = 1, Name = \"Game of Thrones\", Genres = genres });\n\n              return new Author() { Id=1, Name=\"Nicholas Cage\", Country=\"US\", books= books };\n          }\n        );\n    }\n}\npublic class AuthorsSchema : Schema\n{\n    public AuthorsSchema()\n    {\n        Query = new StarWarsQuery();\n        RegisterType<AuthorsType>();\n        //RegisterType<BookType>();\n        //RegisterType<GenreType>();\n    }\n}\n\n```. ",
    "schlaup": "Ok, the fix is easy but I am not so familiar with xUnit.\nHow would you want to setup additional tests?\nSomething like: ?\nhttps://coding.abel.nu/2014/02/rerunning-all-unit-tests-with-different-ui-culture/\nThe alternative would be to write some additional tests that only cover the tests that are failing now.\n. I forgot to include the error message:\n{\n  \"errors\": [\n    {\n      \"message\": \"Variable \\\"$type\\\" of type \\\"AnimalType\\\" used in position expecting type \\\"AnimalType!\\\".\",\n      \"locations\": [\n        {\n          \"Line\": 1,\n          \"Column\": 24\n        },\n        {\n          \"Line\": 3,\n          \"Column\": 23\n        }\n      ]\n    }\n  ]\n}\n. You are absolutely right! \n\"ID!\" is working.. @mule Thanks for working on this! I've never gotten to it. In your commit \"Improved conversion, decimal to decimal conversion now works for different cultures\" you allow parsing of the current server's culture. I believe this is too much magic. For example, someone might accidently input a number with thousand-separator. (US: 11,000) If your implementation runs on a DE server it would convert this to \"11.000\" and allow the value. I believe, it should always throw an error. The GraphQL API should always use invariant culture and should not allow other formats if it runs on a server with a different locale setting.. Thanks for the feedback!\nI looked at GraphQL.Relay project and it seems that it does not support the instance-based type system.\n\nThat is mixing the instance-based and type-based systems, which isn't a good idea.\n\nReally? Maybe, I do not understand it correctly.\nI my example \"myGeneratedProductGraphType\" is a GraphType and \"ConnectionType\" is a GraphType as well. (It is \"ConnectionType\" from your project that I modified. Maybe \"ConnectionType\" in your project should really be named \"ConnectionGraphType\"?)\nAm I correct that I can use:\nResolvedType = new ListGraphType(new StringGraphType));\nIs this the correct usage of the instance-based system? (Is there more documentation on how to use the type system? It seems to me that it evolved over time and I am never really sure what the \"official\" or current way to do it is.)\nThanks!\n. Ok, thanks for the explanation! I really appreciate it!\nI will revise my code and post it here so that anyone else looking for a solution can find it.\nI also have to change my implementation of my GraphType generator because I am creating new instances of StringGraphType for each property. Thanks for the hint! I have a much better idea now how your implementation is working internally.. ",
    "mule": "Uh, why was this closed, the issue still remains AFAIK?\nAnyways, I'm writing a fix for it. I need the parsing for DecimalGraphTypes to work. \nParsing seems to work for FloatingGraphType though. I guess double parsing is more lenient than decimal for some reason.. ",
    "joerneu": "@schlaup and @mule - The fix is not as easy as described in this issue. There are a couple more places to change (depending if the value is an argument, variable or part of an object). Sometimes a converted numeric value gets converted back to a string and then to a numeric value again. (So the ToString() call needs to use InvariantCulture as well.)\nI went ahead and fixed the issue. All tests run successfully and I tested on a different locale. Attached is a GIT patch file for anyone who needs it now or want to look at the required changes.\n@joemcbride I cannot provide a PR yet as my fork and IDE is not up to date.\npatch.diff.txt\n. @pekkah: I believe you missed FloatGraphType.cs and ObjectExtensions.cs. The rest looks good.. @pekkah:\nLine 132 in ObjectExtensions uses culture dependent conversion:\nvar text = value.ToString();\nI changed it to:\nstring text;\n            if (value is float)\n                text = ((float)value).ToString(CultureInfo.InvariantCulture);\n            else if (value is double)\n                text = ((double)value).ToString(CultureInfo.InvariantCulture);\n            else if (value is decimal)\n                text = ((decimal)value).ToString(CultureInfo.InvariantCulture);\n            else\n                text = value.ToString();\nWithout this change the next line does not work correctly:\nreturn _conversions.Value.Convert(fieldType, text);\n. @pekkah: Yes, many ToString() and Parse() calls. Did you see my \"patch.diff.txt\" at #302? It should cover all ToString() and Parse() calls.\nIt also fixes DateTime parsing which is also culture dependent.. Yes, I agree. Not knowing the internals I went for the safest solution. For example, I did not know if the ObjectExtensions' method is used to convert between float and decimal. Or between float and strings, etc.\nDepending on the requirements we could check the fileldType and use .NET's Convert which already handles float, double and decimal conversions.. ",
    "OlegZee": "In fact no reasons. I'm going to review why I did this and update PR.\nOn Mon, Mar 27, 2017 at 9:06 PM, Joe McBride notifications@github.com\nwrote:\n\nAs far as I understand, yes this would require VS2017 or VSCode. I've been\ndeving a lot on the Mac side of things lately so that would be VSCode or\nRider. This will also require some changes to the build scripts. Any reason\nfor the change to NetStandard 1.3?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/311#issuecomment-289463933,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAfVFU6MwMIOZcQZzs9Rt_4-anuN89K4ks5rp8JkgaJpZM4Mp8Uc\n.\n. No, it just requires final dotnet SDK.\nDon't worry, new XML projects are different, much much lighter that the old\nones.\n\nAfter initial scepticism I got accomodated to it and I'd say I love it too.\nOn Mon, Mar 27, 2017 at 8:44 PM, Jason Quense notifications@github.com\nwrote:\n\ni will never understand why they removed the finally hand\neditable/readable .json project file to go back to xml Does this require\nvs2017?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/311#issuecomment-289457342,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAfVFQt-ZgqOq2YvH3ttHrGMLpaVkUMmks5rp708gaJpZM4Mp8Uc\n.\n. @joemcbride I tried to lower target fwk to netstandard1.1 and here're the findings.\nThe problem is that recent System.Reflection.TypeExtensions version 4.3.0 targets netstandard as lowest one. Version 4.0,0 references old tfm monickers such as netcore50.\n\nNow I added PackageTargetFallback which is the same as imports in project json.\nBtw here's good paper explaining project.json migration (http://www.natemcmaster.com/blog/2017/01/19/project-json-to-csproj/). ",
    "minawalphonce": "I this this is needed\nin facebook, they always add Id for example, \ni need to add something like totalCount even if it is not requested but paging is requested . ",
    "ilya-chumakov": "@jquense, thanks for nice explanation. It seems that GraphQL's best application is to describe projections in short and well-readable way, isn't?. ",
    "Jonatthu": "@joemcbride Well it seems no example is available yet, but is this in theory working? . Yes I know I'm not sending any argument in the query that's why, I'm going to do testing to validate this . Temporal workaround\n```\n    public class TyFittQuery : ObjectGraphType\n    {\n        public TyFittQuery()\n        {\n        Name = \"TyFittRoot\";\n        Description = \"Welcome to TyFitt API\";\n\n        new UserQuery(this);\n\n    }\n}\n\n```\nAnd\n```\npublic class UserQuery\n{\n    private TyFittQuery b;\n\n    public UserQuery(TyFittQuery tyFittQuery)\n    {\n        this.b = tyFittQuery;\n        b.Field<ListGraphType<UserType>>(\n            name: \"Users\",\n            description: \"A user inside TyFitt\",\n            arguments: new QueryArguments(\n                new QueryArgument<IntGraphType> { Name = \"id\", Description = \"id of the user\" }\n            ),\n            resolve: context =>\n            {\n                var list = new List<User>\n                {\n                                new User { Id = 4 }\n                };\n                return list;\n            }\n        );\n    }\n}\n\n``. @joemcbride Thanks it is ok \ud83d\udc4d . Great! @joemcbride Can we put this on the docs? Or Is it already there?. I will do a pull request of getting started @joemcbride for now I will close this issue thanks!. I really would like to have this feature . @joemcbride How do we access to the subchilds currently?. @joemcbride If we add this, we could ad include parameters to our services to do joins in the same query, like one-to-one relationships this would be perfect, and for lists is other history.... @joemcbride  When I trytype => (GraphType) container.Get(type))Fromcontainer.Singleton(new StarWarsSchema(type => (GraphType) container.Get(type)));`\nI got a precompile issue saying can not convert from System.Type to MyNamespace.GraphType. @joemcbride \nIt looks like this \npublic StarWarsSchema(Func<Type, GraphType> resolveType)\n            : base(resolveType)\n        {\n            Query = (StarWarsQuery)resolveType(typeof (StarWarsQuery));\n        }\nand my registration\ncontainer.Register(new StarWarsSchema(type => (GraphType)container.GetInstance(type)));\nand container.GetInstance(type) is returning a object  type.. It was container.Register(() =>new StarWarsSchema(type => (GraphType)container.GetInstance(type)));\n@joemcbride  thanks!\n. @joemcbride \n```\n            container.Register(Lifestyle.Scoped);\n        var typeAssambly = typeof(GraphQL.Types.UserType).GetTypeInfo().Assembly;\n        var typeRegistrations = typeAssambly.GetExportedTypes()\n            .Where(x => x.Namespace == \"TyNET.Api.GraphQL.Types\" && x.GetTypeInfo().IsClass);\n\n        foreach (var reg in typeRegistrations)\n        {\n            container.Register(reg, reg, Lifestyle.Scoped);\n        }\n\n        container.Register(() => new TyNETSchema(type => (GraphType)container.GetInstance(type)), Lifestyle.Scoped);\n\n```\nAs you see the implementation is Scoped should I change all these to Singleton?\n. What about scoped ? Because when I side singleton it says that my schema is implementing dispose :/. when I put it as Singleton my schema is implementing Disposed *. @joemcbride Should my services being call inside this schema and types be Singletons as well?\nOtherwise SimpleInjector is warning me is a mismatch. public class GraphQLQuery\n    {\n        public string OperationName { get; set; }\n        public string NamedQuery { get; set; }\n        public string Query { get; set; }\n        public object Variables { get; set; }\n}\nI fixed it changing the definition of query and then manually changing variables ToString().ToInputs();. You need to declare the types as well like your services on the DI system . Graphql 0.17.3 does not have SubFields on context when I am debugging  @joemcbride . ",
    "negue": "Hmm, I see.\nI just had the idea so that I don't have to transfer all null fields to the client, to speed up the network request. I had the same issue, then after using RegisterType(s) the null values are now {} even though I requested multiple properties on this type\nEdit: here's is an example:\n```c#\npublic class TestSchema : Schema\n{\n    public TestSchema()\n    {\n        Query = new TestQuery();\n    RegisterTypes(new MyClass1GraphType(), new MyClass2GraphType());\n}\n\n}\npublic class TestQuery : ObjectGraphType\n{\n    public TestQuery()\n    {\n        Field>(\"entries\", resolve: ctx => new IMyType[]{\n            new MyClass1(),\n            new MyClass2()\n        });\n    }\n}\npublic interface IMyType\n{\n    int Id { get; }\n}\npublic class InterfaceType : InterfaceGraphType\n{\n    public InterfaceType()\n    {\n        Field(x => x.Id);\n    AddPossibleType(new MyClass1GraphType());\n    AddPossibleType(new MyClass2GraphType());\n}\n\n}\npublic class MyClass1 : IMyType\n{\n    public int Id => 1;\npublic string StringInClass1 => \"Class 1\";\n\n}\npublic class MyClass2 : IMyType\n{\n    public int Id => 2;\npublic string StringInClass2 => \"Class 2\";\n\n}\npublic class MyClass1GraphType : ObjectGraphType\n{\n    public MyClass1GraphType()\n    {\n        Field(x => x.Id);\n        Field(x => x.StringInClass1);\n    Interface<InterfaceGraphType>();\n}\n\n}\npublic class MyClass2GraphType : ObjectGraphType\n{\n    public MyClass2GraphType()\n    {\n        Field(x => x.Id);\n        Field(x => x.StringInClass2);\n    Interface<InterfaceGraphType>();\n}\n\n}\nvar query = @\"{\n    entries {\n      id\n    }\n}\";\nvar executer = new DocumentExecuter();\nvar result = await executer.ExecuteAsync( =>\n{\n    .Schema = new TestSchema();\n    _.Query = query;\n});\n``` \nthe result is: {\"data\":{\"entries\":[{},{}]}}\nif I remove the AddPossibleType calls the result has null values\n. @joemcbride no it doesn't fix that. Like I already wrote before:\n\nIf I remove:\n   ```patch\nAddPossibleType(new MyClass1GraphType());\n\nAddPossibleType(new MyClass2GraphType());\n   ```\nI get this result:\n{\"data\":{\"entries\":[null,null]}}\n\n\nIf I leave the AddPossibleType calls I get:\n    {\"data\":{\"entries\":[{},{}]}}\n\n\nNone of those are right!\nWhat I expect to get is:\n{\"data\":{\"entries\":[{\"id\": 1},{\"id\": 2}]}}. @joemcbride  oh wow, I should've used better class names, thanks! Now that the example works I can test it on the real project. Thanks!!. ",
    "zimmybln": "Hi Joe,\nthanks for your reply. Meanwhile I found it, I should have use the resolver for TypeB in TypeA instead of the resolver within the query type. Everything is fine.\nBest regards,\nTorsten. ",
    "arianmotamedi": "Thanks Joe. I'm having a hard time figuring out the actual value of a field during resolution. Does a Field Middleware have access to the values? Or at what point does it get called? In my example I'm trying to run a .ToUpper() on a field if it has that directive, but obviously that can't happen until after the value is obtained.... That makes sense. One final question, how can I register this middleware class now? In your example (https://github.com/graphql-dotnet/graphql-dotnet/blob/master/docs/learn.md#field-middleware), you're just using FieldMiddleware.Use<InstrumentFieldsMiddleware>(), but the Use() method in my DocumentExecutor has a different method signature: IFieldMiddlewareBuilder Use(Func<FieldMiddlewareDelegate, FieldMiddlewareDelegate> middleware);. Awesome, thank you sir! Much appreciated.. If I try to specify the type List<string> or List<> as a parameter during registration I get another error saying The declared Field type: List1 should derive from GraphType, but doesn't. Seems like it only takes type inheriting from GraphType. I'm surprised it doesn't infer List<T> since frankly that is more commonly used than T[].... Cool thanks. I might open up a PR one of these days :smile: . Hmm so how should I get around that? It doesn't seem like StringGraphType works for enums. Why does it do a .ToUpperCase() anyways? I'm curious now :D. Thanks Joe. I'll copy the code and change that line. I'd personally be ok with being a hipster, but unfortunately I can't force that on our consumers who have already coded against these enum values \ud83d\ude09 . Feel free to close the issue \ud83d\ude04 . ",
    "ceferrari": "I have made an extension method that converts the GraphQL Query into Entity Framework Includes.\n```\npublic static class ResolveFieldContextExtensions\n{\n    public static string GetIncludeString(this ResolveFieldContext source)\n    {\n        return string.Join(',', GetIncludePaths(source.FieldAst));\n    }\nprivate static IEnumerable<Field> GetChildren(IHaveSelectionSet root)\n{\n    return root.SelectionSet.Selections.Cast<Field>().Where(x => x.SelectionSet.Selections.Any());\n}\n\nprivate static IEnumerable<string> GetIncludePaths(IHaveSelectionSet root)\n{\n    var q = new Queue<Tuple<string, Field>>();\n    foreach (var child in GetChildren(root))\n    {\n        q.Enqueue(new Tuple<string, Field>(child.Name.ToPascalCase(), child));\n    }\n\n    while (q.Any())\n    {\n        var node = q.Dequeue();\n        var children = GetChildren(node.Item2).ToList();\n        if (children.Any())\n        {\n            foreach (var child in children)\n            {\n                q.Enqueue(new Tuple<string, Field>(node.Item1 + \".\" + child.Name.ToPascalCase(), child));\n            }\n        }\n        else\n        {\n            yield return node.Item1;\n        }\n    }\n}\n\n}\n```\nLets say we have the following query: \nquery {\n  getHistory {\n    id\n    product {\n      id\n      category {\n        id\n        subCategory {\n          id\n        }\n        subAnything {\n          id\n        }\n      }\n    }\n  }\n}\nWe can create a variable in \"resolve\" method of the field:\nvar include = context.GetIncludeString();\nwhich generates the following string:\n\"Product.Category.SubCategory,Product.Category.SubAnything\"\nand pass it to Entity Framwork:\npublic Task<TEntity> Get(TKey id, string include)\n{\n    var query = Context.Set<TEntity>();\n    if (!string.IsNullOrEmpty(include))\n    {\n        query = include.Split(',', StringSplitOptions.RemoveEmptyEntries).Aggregate(query, (q, p) => q.Include(p));\n    }\n    return query.SingleOrDefaultAsync(c => c.Id.Equals(id));\n}\n. Thank you for your response but it produced the following error:\nTypeError: Cannot read property 'kind' of null\n. Registering the enum within my container made the error disappear.\nThank you @joemcbride !. @joemcbride Could you help me again please? \nNow I am trying to read the values of the field.\nI am implementing a filter logic using aPredicate Builder and I need those values to build the predicate.\nLike this:\n```\npublic override Expression> GetExpression()\n        {\n            var predicate = PredicateBuilder.New(true);\n        if (STATUS_FIELD_VALUE == Status.Active)\n            predicate.And(x => x.Status.Equals(\"active\"));\n        else if (STATUS_FIELD_VALUE == Status.Paused)\n            predicate.And(x => x.Status.Equals(\"paused\"));\n        else if (STATUS_FIELD_VALUE == Status.Closed)\n            predicate.And(x => x.Status.Equals(\"closed\"));\n\n        return predicate;\n    }\n\n```\nHow can I access the STATUS_FIELD_VALUE?. I got it. Thank you again!. ",
    "badre429": "i meen Schema generator based Entityframework core DbContext . ",
    "akaSybe": "I would like to know how to use custom directives too. ",
    "stephenlautier": "I believe this can be closed as its already implemented as @jquense suggested.. @joemcbride ahh my apologies. That's even better  \ud83d\udc4d . was there any progress on this one?. ",
    "MichaelHilus": "Thanks for your link, I will defineltly go deeper into that project.\nThe query that I posted was generated by my Relay based app after it was told to reload the entityList. I can't say how I could manipulate this in any way. But obiously NodeType is not the right type set when I define my node field, or am I wrong?\nShould I define it to return a ViewerType?. Ah, thank you, that did the trick!. ",
    "seralexeev": "Here is great example of using graphql-dotnet with dotnet core and EF core: https://github.com/JacekKosciesza/StarWars. I tried to use ASP.NET Core 2 Preview, and it's service locator return null for unregistered types. It can happen with any schema if GraphType factory has a bug. What do you think should write the error message?\nExpected non-null value, {nameof(resolve)} GraphType factory return null for \\\"${type}\\\". Check ResolveType property in your Schema type\" ?\ncsharp\nclass RootType : ObjectGraphType<> {\n  Field<ListGraphType<StepType>>(...)\n}\ncsharp\n// Startup.cs\nservices.AddTransient<RootType>();\nservices.AddSingleton<StepType>(); // commenting this line leading to error \nservices.AddScoped<ISchema>(x => new MySchema(type => (GraphType) x.GetService(type)));. ",
    "sh1989": "^ That middleware pr has been merged now :). ",
    "GeekyEggo": "Thanks @joemcbride, that also answers another question I had regarding a missing method within unit tests (the Field(...) one).\nI've added the arguments successfully, however I'm having issues consuming them. It might be worth mentioning, I'm working against a single in-memory instance of a dynamic object. Ideally I'd like to auto-magically query the object, but appreciate that might not be supported as standard?\nI'm currently setting the Root to the dynamic object when constructing a new DocumentExecutor.. Thanks again @joemcbride, your feedback has given me enough insight to start work on a little \"dynamic object schema builder\". \ud83d\ude04 . ",
    "lefoulkrod": "@GeekyEggo I'm looking for examples on dynamic schema building and resolving if you or @joemcbride have any up to date examples I'd love to see them.. ",
    "kfrajtak": "Thanks Jason for your reply. I was not implying there's something wrong with the project, I just ran into this problem and wondered if anybody had the issue.. ",
    "wallymathieu": "Could be that resharper is running the tests from a different folder than another test runner. Sometimes you got to make sure to copy some files, make sure to locate the files next to the dlls, et.c.?. Shouldn't you use csproj format in order to test it with VS2017?. ",
    "kimbell": "Project.json is only supported on VS2015. For VS2017, you need to upgrade the project type to the new csproj format. . ",
    "spicydonuts": "Also ran into this and had no idea what to do.. I was learning from the Star Wars example project and it does not use AddPossibleType: https://github.com/JacekKosciesza/StarWars/blob/master/StarWars.Api/Models/CharacterInterface.cs\nOnce I added that it started working.  It'd be better to throw something like Type [type] doesn't appear to be a member of interface [interface].  Did you forget to add it as a possible type in the interface graph type definition? instead of just returning null.  In my case it was in a list of non-nullable things, so instead of seeing what the problem was I was just getting an opaque 400 \"TypeError\" on the GraphiQL client.\nAlso, why is AddPossibleType necessary when the implementing type already has Interface<CharacterInterface>()?. > When the Schema is built, it looks at the \"root\" types (Query, Mutation, Subscription) and gathers all of the GraphTypes they expose. Often when you are working with an interface type, the concrete types are not exposed on the root types (or any of their children). Since those concrete types are never exposed in the type graph, the Schema doesn't know they exist. This is what the RegisterType on the Schema is for.\nAh, that makes sense!  Thanks for the explanation.\nI removed the hacks and added RegisterTypes to my root schema:\n```csharp\n    public StorefrontSchema(Func resolveType)\n        : base(resolveType)\n    {\n      Query = (StorefrontQuery)resolveType(typeof(StorefrontQuery));\n  RegisterTypes(\n    resolveType(typeof(StorefrontDealInterface)),\n    resolveType(typeof(StorefrontDealLiveType))\n  );\n}\n\nSeems to work now \ud83d\udc4d . >csharp\n\nRegisterType();\nRegisterType();\n```\n\n@joemcbride Ohh, much better.  Thanks!. ",
    "justRu": "Sorry, I haven't updated this issue earlier. RegisterType<> worked for me. Thanks!\n\nWhen the Schema is built, it looks at the \"root\" types (Query, Mutation, Subscription) and gathers all of the GraphTypes they expose. Often when you are working with an interface type, the concrete types are not exposed on the root types (or any of their children). Since those concrete types are never exposed in the type graph, the Schema doesn't know they exist. This is what the RegisterType on the Schema is for.\n\nCan you add this to the docs? It would be very helpful. Or is it already there?. ",
    "ChristianRuiz": "Hi Joe, I didn't know about StrongNamer. We try it out! Thanks!. ",
    "RustamIbragimov": "@mahald, did you solve the problem ? . ",
    "Karnich": "im sitting with the exact same thing. I would expect this to be possible, but cant figure out how.\nanyone? @joemcbride @moserware . ",
    "MFFoX": "+1 I'd love to see some general usage of Connections as well. . Thanks, Joe. I am not actually using Relay, but just want to implement cursor-based pagination. I think the ConnectionBuilder and basic support for connections in this repository will work for my use case, but I can't seem to figure out how to resolve the object correctly. . I will try installing and using the relay library for now. If those classes aren't going to be supported/documented, maybe they should be completely removed in favor of graphql-dotnet/relay?. +1 from me so long as it's optional. A couple of quick thoughts:\nHow would it work for complex members? Would/should you be able to control the reflection depth? What about circular navigational properties?. ",
    "flieks": "also interested, any progress ?\nNow if we request 1 field of a child object, the resolver is getting the complete object first. \nWould be awesome if graphql-dotnet resolvers can return iqueryables and only fetches what it needs.. ",
    "phischepi": "Hi there,\nI'm facing a similar issue: when I try to pass a complexObject into the variables, it seems that the DocumentExecuter could deserialize the JSON:\nrequest:\nmutation TryLogin($info: LoginInput!) {\n  tryLogin(login: $info)\n}\nvariables\n{\n  \"info\": {\n    \"email\": \"xxxx\",\n    \"password\": \"yyyy\",\n    \"rememberme\": false\n  }\n}\nI got the following exception:\nException\nVariable '$info' is invalid. Unable to parse input as a 'LoginInput' type. Did you provide a List or Scalar value accidentally?\n   at GraphQL.DocumentExecuter.AssertValidValue(ISchema schema, IGraphType type, Object input, String fieldName)\n    at GraphQL.DocumentExecuter.AssertValidValue(ISchema schema, IGraphType type, Object input, String fieldName)\n    at GraphQL.DocumentExecuter.GetVariableValue(Document document, ISchema schema, VariableDefinition variable, Object input)\n    at GraphQL.DocumentExecuter.<>c__DisplayClass18_0.<GetVariableValues>b__0(VariableDefinition v)\n    at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\n    at GraphQL.DocumentExecuter.GetVariableValues(Document document, ISchema schema, VariableDefinitions variableDefinitions, Inputs inputs)\n    at GraphQL.DocumentExecuter.BuildExecutionContext(ISchema schema, Object root, Document document, Operation operation, Inputs inputs, Object userContext, CancellationToken cancellationToken, Metrics metrics)\n    at GraphQL.DocumentExecuter.<ExecuteAsync>d__7.MoveNext()\nHere is my inputtype:\n```\n    public class LoginInputType : InputObjectGraphType\n    {\n        public LoginInputType()\n        {\n            Name = \"LoginInput\";\n        Field<NonNullGraphType<StringGraphType>>(\"email\");\n        Field<NonNullGraphType<StringGraphType>>(\"password\");\n        Field<BooleanGraphType>(\"rememberme\");\n    }\n}\n\nMy Mutation:\n        public MAPMutation(IApplicationUserManager manager)\n        {\n            Name = MutationName;\n            FieldAsync(\n                \"tryLogin\",\n                arguments: new QueryArguments(new QueryArgument {Name = \"login\"}),\n                resolve: async context =>\n                {\n                    var login = context.GetArgument(\"login\");\n                    return await manager.SignInAsync(\n                        login.Email,\n                        login.Password,\n                        login.RememberMe);\n            }\n        );\n    }\n\n``\nThe schema:            services.AddSingleton(sp => new Schema {Query = sp.GetService(), Mutation = sp.GetService()});`\nAnd the action:\n```\n        [HttpPost]\n        public async Task Post([FromBody] GraphQLQuery query)\n        {\n            var vars = query.Variables;\n        var result = await _executer.ExecuteAsync(_ =>\n        {\n            _.Schema = _schema;\n            _.Query = query.Query;\n            _.Inputs = query.Variables != null ? new Inputs(query.Variables) : null;\n        }).ConfigureAwait(false);\n\n        if (result.Errors?.Count > 0)\n            return BadRequest();\n\n        return Ok(result);\n    }\n\n```\nSorry if I did not pack the code into a ZIP but I have quiet a lot of dependencies on 3rd parts. One small update, I found a workaround:\nvar dico = new Dictionary<string, object>();\n            if (query.Variables != null)\n                foreach (var var in query.Variables)\n                    dico.Add(var.Key, (var.Value as JObject)?.ToObject<Dictionary<string, object>>());\nBut as far as I can see, it should not work with nested objects (level 2 and more). @joemcbride : I try both without success\nEDIT: and thx for the notice ;). I try to change my model to store the variables into a simple string but the JSON formatter dont let do it so easily (I try to use the GraphQLQuery as written in the tests but then the query failed).\nJust for the info, my project is running asp.net core 1.1 and this could be my issue.. Another workaround, instead of having the property as \"string\", I set the type to JObject and when executing the query I use the following trick:\n...            \n_.Inputs = query.Variables?.ToString()?.ToInputs();\n...\nThank for pointing me what was wrong in my code.. Thank you for the hint, for those interested, here is my final try:\n...\nvar inputs = StringExtensions.GetValue(query.Variables) as Dictionary<string, object>;\n...\nwhere \"Variables\" is a JObject. ",
    "antmdvs": "I think both forms of documentation are valuable and have come to be expected from any library with a non-trivial API surface.\nA lot of .NET developers rely on IntelliSense for guidance, (both in VS proper and VS Code), as well as Go to Definition (F12) results, Object Browser, etc., all of which surface documentation sourced from XML doc comments.\nAs I alluded to above, I think this is particularly warranted for Field registration. Currently, when I type Field(, I'm presented with 6 overloads. This is further conflated by generic type inference, i.e. when I type Field<>(, I'm presented with 4 overloads. And then there's AddField.\nFor IntelliSense users, after a user types Field(, it would be ideal if they could cycle through the overloads and use the descriptions in addition to the signatures and parameter info to inform their method selection, only breaking out a web browser when they want to see example usage and/or read more details.\n\nIn many cases, the XML docs just state what is already there and little effort is put into adding the knowledge and context that needed\n\nYeah, so they need to be informative yet terse. @joemcbride If we take a stab at this with Field and find that it's difficult to accomplish, it may be an indication that there's simply too many (exposed) ways to register a field. I suppose this could be a separate issue.\n\nCode files explode in size with less code per screen space vs the comments in the file.\n\nThis would only be a potential issue for contributors, consumers savvy enough to view the repo (many may not even GitHub, increasingly so as the audience/adoption grows), and those who employ XML comments in their own code. For the latter, Edit -> Outlining -> Collapse to Definitions and go from there. This issue is more concerned with the majority of current and future consumers, not contributors.. @joemcbride Feel free to rename this issue or close it and create a new one to track the other documentation effort being discussed.. I see now that the code is already in place to print the SDL/IDL in question, but the issue seems to stem from the indistinct treatment of custom \"built-in\" scalars and actual \"built-in scalars\" as defined in the spec: Int, Float, String, Boolean, ID (those being referred to as \"core types\" here).\nTo illustrate this, I temporarily modified the IsBuiltInScalar() method to exclude \"Date\" and \"Decimal\" as follows:\ncsharp\npublic bool IsBuiltInScalar(string typeName)\n{\n    return _scalars\n        .Except(new[] { \"Date\", \"Decimal\" }) // these are \"custom\" according to the spec\n        .Contains(typeName);\n}\nand then the expected SDL is included in the schema printout:\n```graphql\nThe Date scalar type represents a timestamp provided in UTC. Date expects\ntimestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar Date\nscalar Decimal\n```\nWould you be open to aligning the terminology with that of the spec?\n\n\"core types\" should be \"built-in scalars\"\nAll other scalars, including Date/Decimal, should be \"custom\" scalars.. Happy to do it! Just need to find some time.. \n",
    "Grauenwolf": "The idea behind GhostDoc was that it writes the tedious bits, but you are supposed to supply the details. Since we all know that doesn't happen, GhostDoc now has quality checks to watch for purely auto-generated documentation that doesn't actually provide information. I think you can even tell it to remove any XML that exactly matches the auto-generated templates. . Anyways, I'm going to take a stab at this because that's the only way I'm going to understand what the heck is going on.. I'm torn here. I want to wait until this is done so I only have to document the public API. But I think documenting the public API will make this effort more successful. . This looks promising: https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.MicrosoftCodeAnalysis2017\nFor .NET Framework projects I always use FXCop (a.k.a. VS code analysis) to ensure that my APIs actually look like .NET APIs.\n. Scratch that, this its probably a better choice. https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/\nI'll do a pass when I have some free time. A lot of the things it flags are stuff you probably wouldn't catch like exposing a public field instead of a public property. (Does that distinction even exist in JavaScript?)\n. I did a trial pass with FxCopAnalyzers and I think this will definitely move us in the right direction.\nHowever, we definitely need to fix the warnings from FxCopAnalyzers one at a time and suppress the rest. Otherwise we're just going to get completely overwhelmed. . Yep. First pass: https://github.com/graphql-dotnet/graphql-dotnet/pull/553. That's why I turned off most rules in the sample PR and focused just on internal stuff like reducing unnecessary memory allocations. There are a lot of CA rules that offer incremental improvements without changing the public API.. It's the same static code analysis feature that's part of Visual Studio. They just moved it to a package for .net core.. It's not a runtime dependency and it will help to prevent future spelling errors.. ",
    "bittercoder": "Thanks heaps for fixing this issue@joemcbride  :+1: . Thanks for merging this @joemcbride . ",
    "AndyBan": "I think your CI is broken? The myget feed hasn't updated in a few days.  Appveyor has the package but the feed asks me for a password so I guess that isn't public.  If I download it and use it in a local feed then all the tests pass.\nhttps://i.imgur.com/VfPygy4.png. I have resolved the first two comments.  I don't think the schema printer needs to know about the NullValue AST object as it can never end up with one.  The printer will only deal with actual types or types wrapped in non null never actual values (Ignoring the default which might be null but that's the value not the AST type).\nThe JS project just passes null around being untyped which I did consider doing here but it does make the code a bit more messier in C# land as you end up changing int to int? etc and then having to check everywhere where you use that value that you have a value.  . A bit pushed for time at the moment so I'll hold off on that one.\nI tried changing the parser ci branch config but after looking into it they have disabled deployment for pull requests for non trusted people.. I have renamed null -> Nullvalue as reviewed on the parser repo and squashed all the commits.  Let me know if there is anything blocking this from being merged.. I have pointed to the custom MyGet feed now the Parser change has been merged.  Let me know if you want that commit removing but I think it might be best left in?\nEdit: I have removed the CI change in response to the below.  Here was the green build: https://ci.appveyor.com/project/graphql-dotnet-ci/graphql-dotnet/build/0.17.2.756-jtrsgfnc. Its been ready for merging for 6 weeks now afaik - I think @joemcbride is waiting for some other unrelated features to do a major version bump.  I don't think this feature requires a major version bump itself.  \nVariables look to be working correctly with my PR.. Are you sure?  If you do that you end up with null in a string which correctly fails a couple of unit tests:\nMessage: Assert.Equal() Failure\n                                 \u2193 (pos 29307)\nExpected: \u00b7\u00b7\u00b7    \"defaultValue\": null\\r\\n          }\\r\\n        ]\\r\\n      },\\r\\n \u00b7\u00b7\u00b7\nActual:   \u00b7\u00b7\u00b7    \"defaultValue\": \"null\"\\r\\n          }\\r\\n        ]\\r\\n      },\\r\u00b7\u00b7\u00b7\n                                 \u2191 (pos 29307). Patch pushed. Let me know if you need it squashing once your happy. ",
    "enkodellc": "What is the status of this? Wouldn't this reduce the need for multiple GraphQL queries for arguments. Can the feature be applied to Variables as well? Thanks for all the work on the project. I hope to learn a bit more and contribute.. Thanks! . ",
    "Giorgi": "Thanks for your feedback. I added a new overload because without it I got lots of compilation errors because the compiler was unable to determine which overload to use. We can update all the code in our project but it will cause compilation error in other code too which uses this library.\nIf you have any suggestion how to avoid compilation error and keep the Field overload that will be great.. @joemcbride Can you review the updated PR ?. Done. It won't work for complex members at least in the beginning. If you need to register those too you will have to do it manually because you will probably want to provide customer resolver.. @MFFoX I created a pull request for this issue. See #386 . The introspection test failed for two reasons:\n\nThe order of the fields is now different\nFields name and primaryFunction are now non nullable.. @joemcbride Yes, I agree that it's better to add new examples instead of touching existing ones. As for virtual method in a ctor, yes it's not a best practice but if the base ctor registers all the properties it will be too late to do anything in the constructor of the subclass.\n\nOn the other hand we can add some kind of option to opt-out of bulk registration of the fields and allow to specify which properties to register in bulk. Something similar to Entity Framework OnModelCreating which allows to customize configuration.. @joemcbride What do you think about the second approach that I mentioned?. OK, I see. Do you want to keep it as it is or inline the virtual method ?. @joemcbride Done.. Will give it a try tomorrow.. Agreed, it does need more error checking.. ",
    "benpriebe": "Thanks for the link. . ",
    "csboling": "I haven't used the server project but it looks to me like you should be able to configure a customized service for IGraphQLExecuter<TSchema>, something like:\ncsharp\npublic class MyGraphQLExecuter<TSchema> : DefaultGraphQLExecuter<TSchema>\n    where TSchema : ISchema\n{\n    public override async Task<ExecutionResult> ExecuteAsync(string operationName, string query, Inputs variables, object context, CancellationToken cancellationToken = default(CancellationToken))\n    {\n        var result = await base.ExecuteAsync(operationName, query, variables, context, cancellationToken);\n        result.EnrichWithApolloTracing();\n        return result;   \n    }\n}\nand instead of services.AddGraphQL you would adapt the service bindings   to use MyGraphQLExecuter instead. I don't have any experience with setting up Apollo's analytics stuff but if your responses contain the tracing extension then GraphQL Playground's tracing view ought to display it, so I'd guess Apollo can figure it out too.. In my GraphQL Playground I get a \"TRACING\" pane I can expand in the bottom right:\n\nNot sure what exactly the Playground configuration is like for the GraphQLDotnet server.\nAlso it looks like your \"resolvers\": section is empty. For that to get populated you need the InstrumentFieldsMiddleware installed to collect timings for every field. So probably you also need:\n```csharp\npublic class MyGraphQLExecuter : DefaultGraphQLExecuter\n    where TSchema : ISchema\n{\n    . . .\nprotected override ExecutionOptions GetOptions(string operationName, string query, Inputs variables, object context, CancellationToken cancellationToken)\n{\n    var options = base.GetOptions(operationName, query, variables, context, cancellationToken);\n    options.FieldMiddleware.Use<InstrumentFieldsMiddleware>();\n    return options;\n}\n\n}\n```\nOtherwise it's possible that GraphQL Playground is seeing that the \"resolvers\": section is empty and not displaying tracing data.. ",
    "shenbomo": "Thank you so much for the fast response and clarifications, I am closing the issue.. ",
    "David-BOG": "Arguments an variables work for main query AFAIK, i need to apply them to one of the fields, not to the main query. How can i add them to field? \nI resolve this property on main Type like this:\nField(x => x.AccountPayments, nullable: true, type: typeof(ListGraphType<AccountPaymentsType>))\n  .Resolve(context => context.Source.AccountPayments)\nif i just add  accountPayments(first: 10 offset: 0) arguments in  graphiql expplorer, query fails\n. accountPayments(first: $first, offset: $offset){\n     amount\n     paymentDate\n    }\nI did it this way and it works:\nField(x => x.AccountPayments, nullable: true, type: typeof(ListGraphType<AccountPaymentsType>))\n  .Resolve(context => context.Source.AccountPayments).Argument<IntGraphType> (\"first\", \"\").Argument<IntGraphType>(\"offset\", \"\");\nand retrieve values like this\nvar first = c.Variables.ValueFor(\"first\");\nvar offset = c.Variables.ValueFor(\"offset\");. Ok doing like above, ii set arguments to my field, but when I try to retrieve values like this\"\nresolve: context =>\n                    {\n                        var first = context.GetArgument<int>(\"first\");\n                        var offset= context.GetArgument<int>(\"offset\");\n}\nvalues are 0\nis that a bug or i'm doing it wrong?. yes, like that\nanyway i figured all out, I add Field with resolver in constructor of AccountType Class and all works\nthanks for your support. ",
    "Stoom": "This is still causing the error:\ngraphql\n{\n    \"errors\": [\n        {\n            \"message\": \"Variable '$app' is invalid. Unable to parse input as a 'ApplicationInput' type. Did you provide a List or Scalar value accidentally?\"\n        }\n    ]\n}\ngraphql\n{\n    \"query\": \"mutation($app: ApplicationInput!) { createApplication (application: $app) }\",\n    \"variables\": {\n        \"app\": {\n            \"name\": \"Test App\"\n        }\n    }\n}\nHere is the schema introspective\ngraphql\n{\n    \"name\": \"Mutation\",\n    \"kind\": \"OBJECT\",\n    \"fields\": [\n        {\n            \"name\": \"createApplication\",\n            \"type\": {\n                \"name\": \"String\",\n                \"fields\": null,\n                \"inputFields\": null\n            }\n        },\n        {\n            \"name\": \"removeApplication\",\n            \"type\": null\n        }\n    ],\n    \"inputFields\": null\n},\n{\n    \"name\": \"ApplicationInput\",\n    \"kind\": \"INPUT_OBJECT\",\n    \"fields\": null,\n    \"inputFields\": [\n        {\n            \"name\": \"name\",\n            \"defaultValue\": null\n        },\n        {\n            \"name\": \"isDefault\",\n            \"defaultValue\": null\n        }\n    ]\n},. Yup\n```csharp\n        var request = JsonConvert.DeserializeObject<GraphQLRequest>(body);\n\n        var result = await _executer.ExecuteAsync(x =>\n        {\n            x.Schema = _settings.Schema;\n            x.Query = request.Query;\n            x.OperationName = request.OperationName;\n            x.Inputs = request.Variables.ToInputs();\n            x.UserContext = new GraphQLUserContext\n            {\n                Request = context.Request,\n                User = context.User\n            };\n            x.ValidationRules = new[]\n            {\n                new AuthorizationValidationRule()\n            };\n        });\n\n. I've fixed the validation rules, but same error.  Here is a screenshot of the inputs after the `ToInput()`\n![image](https://user-images.githubusercontent.com/5356206/28991462-ab7da748-794d-11e7-83c0-b3128080d160.png)\n. If I make the argument nullable I get this errorgraphql\n{\n    \"errors\": [\n        {\n            \"message\": \"Variable \\\"$app\\\" of type \\\"ApplicationInput\\\" used in position expecting type \\\"ApplicationInput!\\\".\",\n            \"locations\": [\n                {\n                    \"line\": 1,\n                    \"column\": 10\n                },\n                {\n                    \"line\": 1,\n                    \"column\": 68\n                }\n            ]\n        }\n    ]\n}\n```\nCould it be something about the default value of isDefault is null?  It is marked as a nullable field in the input type.. Everything I try keeps coming back to that error.  Is there a unit test that exercises custom input types that I can reference?. Not quite sure whats going on.  I uninstalled the nuget package and included the source directly and everything worked.  I then removed that and installed the nuget package and everything is working...\nI'm good with closing this, but really don't know what happened.. ",
    "matjazmav": "@Giorgi Good job. I have just 2 comments. I think Guid type resolver would be useful, just convert Guid to string. Another thing is that reflection is slow, maybe we could cache instances of  ObjectGraphTypes.\n```cs\n    public class CachableDependencyResolver : IDependencyResolver\n    {\n        private IObjectGraphTypeCache _cache;\n    public GenericDependencyResolver(IObjectGraphTypeCache cache)\n    {\n        _cache = cache;\n    }\n\n    public T Resolve<T>()\n    {\n        return (T)Resolve(typeof(T));\n    }\n\n    public object Resolve(Type type)\n    {\n        if(!_cache.TryGetGraphType(type, out var graphType))\n        {\n            graphType = type\n               .GetConstructor(new Type[] { })\n               .Invoke(new object[] { });\n\n            _cache.AddGraphType(type, graphType);\n        }\n\n        return graphType;\n    }\n}\n\n```\nIObjectGraphTypeCache is just wrapper around IMemoryCache.\nI have tested few queries with CachableDependencyResolver response times are between 200 ms and 300 ms, with default IDepandencyResolver response times are between 500 ms and 800 ms.. ",
    "GoaKoala": "Just a side note as it might help someone in the future. For the fix to work you need to have the latest nuget pkg of the GraphQl(currently 0.17.3). It might not work with older versions. (It doesn't work with 0.15.1.678) . ",
    "landbolts": "hi joe, thanks for the reply. ConcurrentBag is unordered, however I noticed that \"AllRecords\" property in  Metrics.cs is being sorted by its start time in milliseconds: \npublic IEnumerable AllRecords => _records.OrderBy(x => x.Start).ToArray();\nIs there a reason why the list would need to be ordered beforehand?\n. thanks for the quick response, the fieldType in my case extends from a generic list, eg. \nMyObjectCollection : List<MyObject>, ICloneable\nThe type on my input graph type is just a ListGraphType. \nI think the issue seems to be down-casting the list to the collection. \n. ",
    "pvsleeper": "We're also having some inconsistent failure around the metrics, but we're getting a NullReferenceExcepsion.\nThe exception's stacktrace look like this:\nat GraphQL.Instrumentation.Metrics.<>c.<get_AllRecords>b__7_0(PerfRecord x)\\r\\n   at System.Linq.EnumerableSorter`2.ComputeKeys(TElement[] elements, Int32 count)\\r\\n   at System.Linq.EnumerableSorter`1.Sort(TElement[] elements, Int32 count)\\r\\n   at System.Linq.OrderedEnumerable`1.<GetEnumerator>d__1.MoveNext()\\r\\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\\r\\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\\r\\n   at GraphQL.DocumentExecuter.<ExecuteAsync>d__7.MoveNext()\\r\\n--- End of stack trace from previous location where exception was thrown ---\\r\\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\\r\\n   at \n.\n.\n.\n.\nLooks like its on the AllRecords property and from what I can tell this will happen if an item in the _records list is null. Suspecting this some threading issue..... ",
    "mrdezzods": "@joemcbride  Can you please make a new release including this commit ?\nThanks. @joemcbride: now eagerly waiting for #415 to be fixed :) \n. ",
    "mafalarz": "Thanks for the help, It's working now. I didn't know the engine expects the values to be converted from JSON.NET types before execution and like in thread #389 I was passing in a Json type. I fixed it like this: \nHaving interface I receive from my MVC controller:\npublic interface IGraphQlQuery\n    {\n        string OperationName { get; }\n        string NamedQuery { get; }\n        string Query { get; }\n        JObject Variables { get; }\n    }\nI complete the execution like this:\nvar queryDictionary = query.Variables.GetValue() as Dictionary<string, object>;\nvar executionOptions = new ExecutionOptions\n            {\n                Schema = schema,\n                Query = query.Query,\n                Inputs = new Inputs(queryDictionary);\n            };\nreturn await new DocumentExecuter().ExecuteAsync(executionOptions).ConfigureAwait(false);. ",
    "arunprasathv": "types.txt\n@jquense  Attached file has all the classes that are required. . @jquense @joemcbride I made it working by passing array. Getting this error\nField billingArrangement of type [BillingArrangementType] must have a sub selection.\nCode\nField>(\"billingArrangement\",\n                 resolve: context => context.Source.BillingArrangement);. I need the whole object from AccountSearchResult.. Yes, I get that. I need to make an API call instead of  context => new AccountSearchResult()  which gets the model to map.\nField<AccountSearchResultType>(\n  \"searchAccounts\",\n  context => new AccountSearchResult());\n\nFollowing line throws error as I mentioned before\n    Field>(\"billingArrangement\");\n. ",
    "nick-lehmann": "Yes, graph.cool is my GraphQL server/backend. And I was trying to find a GraphQL client to make calls to it from a client programmed in C#. Since you find this project first when you search for \"C# graphql\", I just looked into and did not find any information about using graphql-dotnet as client. Are you aware of any graphql client libraries for C#?. @jquense Thanks for the answer. I had a bad feeling that this might be the case. This tutorial on how to use GraphQL with Xamarin might be helpful. Still, it would be nice to have some kind of information in the documentation about how to consume GraphQL API, since the name of the project does not include \"server\" and at least I found it while searching for a client library.\nIt would also be really nice to have an example on how to implement GraphQL subscriptions using C# and websockets. I will have a look into it and post if I managed to get everything to work and maybe create a PR.. ",
    "mokeyish": "@joemcbride Here is the screenshot #403 . #402. same with #402. ",
    "srini85": "I had this issue as well. I decided to upgrade the project to dotnet core 2.0 and created a PR\nhttps://github.com/graphql-dotnet/graphql-dotnet/pull/409\n. you can also get around the issue by forcing your project to use 4.1.0 of System.Reflection.TypeExtensions\nE.g.\n```\n\n\nnetstandard2.0\n\n\n\n\n\n\n```. @mpfisterUniBE may be might be better to use netstandard and then reference this in your netcoreapp. This way the library is portable if you choose to goto netframework. But if you don't have a need, leaving it as netcoreapp2 is ok. great change! lovely!. Hi Joe, do you think it is worthwhile creating a 2.0 branch and having it at Dotnet core 2.0 this will ensure we can get the latest features or Dotnet core 2. Looks like build is also failing on appveyor. Seems to build fine locally :S. @joemcbride thanks for the info . @joemcbride - noticed the appveyor server has dotnet sdk 1.0 installed. Would have to get this upgraded if this was to be built in 2.0 (if required down the line). Thanks for the reviews and comments. Will look at them. ",
    "mpfisterUniBE": "Thanks @srini85 this helped me getting it back working.\nFor my netcoreapp2.0 I had to use some newer packages however, 4.1.0 of the TypeExtensions wasn't enough:\nxml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n    <PropertyGroup>\n        <TargetFramework>netcoreapp2.0</TargetFramework>\n    </PropertyGroup>\n    <ItemGroup>\n        <PackageReference Include=\"GraphQL\" Version=\"0.17.2\" />\n        <PackageReference Include=\"Newtonsoft.Json\" Version=\"10.0.3\" />\n        <PackageReference Include=\"System.Reflection.TypeExtensions\" Version=\"4.4.0\" />\n    </ItemGroup>\n</Project>. ",
    "jeinz11": "this is still occuring when i get the package through nuget... when will this be updated?. ",
    "wiktor-golonka": "Hi @joemcbride ,\nI did a quick fix which worked for me inside ObjectExtensions.GetPropertyValue method. \nCode below with marked modifications:\n```\n        /// \n        /// Converts the indicated value into a type that is compatible with fieldType.\n        /// \n        /// The value to be converted.\n        /// The desired type.\n        /// There is special handling for strings, IEnumerable<T>, Nullable<T>, and Enum.\n        public static object GetPropertyValue(this object propertyValue, Type fieldType)\n        {\n            // Short-circuit conversion if the property value already\n            if (fieldType.IsInstanceOfType(propertyValue))\n            {\n                return propertyValue;\n            }\n        if (fieldType.FullName == \"System.Object\")\n        {\n            return propertyValue;\n        }\n\n        var enumerableInterface = fieldType.Name == \"IEnumerable`1\"\n          ? fieldType\n          : fieldType.GetInterface(\"IEnumerable`1\");\n\n        if (fieldType.Name != \"String\"\n            && enumerableInterface != null)\n        {\n            object newArray;\n            var elementType = enumerableInterface.GetGenericArguments()[0];\n            var underlyingType = Nullable.GetUnderlyingType(elementType) ?? elementType;\n            var implementsIList = fieldType.GetInterface(\"IList\") != null;\n\n// MODIFICATIONS STARTS HERE\n                if (fieldType.IsArray)\n                {\n                    if (!(propertyValue is IList values))\n                    {\n                        return null;\n                    }\n                var tempArray = Array.CreateInstance(elementType, values.Count);\n                values.CopyTo(tempArray, 0);\n                newArray = tempArray;\n                return newArray;\n            }\n\n// MODIFICATIONS ENDS HERE\n                else\n                {\n                    if (implementsIList)\n                    {\n                        newArray = (IList)Activator.CreateInstance(fieldType);\n                    }\n                    else\n                    {\n                        var genericListType = typeof(List<>).MakeGenericType(elementType);\n                        newArray = (IList)Activator.CreateInstance(genericListType);\n                    }\n                var valueList = propertyValue as IEnumerable;\n                if (valueList == null) return newArray;\n\n                foreach (var listItem in valueList)\n                {\n                    ((IList)newArray).Add(listItem == null ? null : GetPropertyValue(listItem, underlyingType));\n                }\n            }\n\n            return newArray;\n        }\n\n        var value = propertyValue;\n\n        var nullableFieldType = Nullable.GetUnderlyingType(fieldType);\n\n        // if this is a nullable type and the value is null, return null\n        if (nullableFieldType != null && value == null)\n        {\n            return null;\n        }\n\n        if (nullableFieldType != null)\n        {\n            fieldType = nullableFieldType;\n        }\n\n        if (propertyValue is Dictionary<string, object>)\n        {\n            return ToObject((Dictionary<string, object>)propertyValue, fieldType);\n        }\n\n        if (fieldType.GetTypeInfo().IsEnum)\n        {\n            if (value == null)\n            {\n                var enumNames = Enum.GetNames(fieldType);\n                value = enumNames[0];\n            }\n\n            if (!IsDefinedEnumValue(fieldType, value))\n            {\n                throw new ExecutionError($\"Unknown value '{value}' for enum '{fieldType.Name}'.\");\n            }\n\n            var str = value.ToString();\n            value = Enum.Parse(fieldType, str, true);\n        }\n\n        return ConvertValue(value, fieldType);\n    }\n\n```\nIt's quite important for anyone working with Postgresql and EF to be able to use arrays as Npsql doesn't support inserting List<> columns so could you please review this change, and if everything will be working fine, could you please push it to master? \n. Hi @joemcbride,\nCan you please give us a time frame of when you think you might have to found some time to add a support for arrays and when we could expect it in the stable release?\n. @joemcbride : Thank you Joe. PR has been created. . Hi @joemcbride \nThanks for review. You are right, I had to modify the code to support multidimensional arrays. \nCode is now just a very little bit more complex but should work as intended.\nI've added tests to cover that case.\nHowever I did found a potential issue: when querying for an object with a field: ListGraphType> - it was showing always null items for me.. Hi @joemcbride , \nHope you are well.\nDid you had a chance to take a look on this solution?\nI did it in the very similar way you proposed however, I couldn't use the Apply method because it requires IEnumerable but here we have only IEnumerable. \nAlso we don't have a Count() method so I had to iterate over that collection to get a length of the array before created new one.\nIt's passing all the tests, also I checked it on my solution. . @joemcbride: I cleaned this code so it should be more readable.\n. Thank you, I will take a look on the dataloader. \nCurrently I am using this code:\n(please notice it was possible, because I had a FieldType of a fieldA (fieldAFieldType)\n```\nFieldAsync(\n    FieldBGraphType,\n    \"fieldB\",\n    description,\n    arguments,\n    async context =>\n{\n    var fieldAValue = context.Source.GetPropertyValue(\"fieldA\");\n    if (fieldAValue is null)\n    {\n        // context is ResolveFieldContext<> type \n        // Creating ResolveFieldContext object (not generic) from context\n        var resolveFieldContext = new ResolveFieldContext\n        {\n            Arguments = context.Arguments,\n            CancellationToken = context.CancellationToken,\n            Document = context.Document,\n            Errors = context.Errors,\n            FieldAst = context.FieldAst,\n            FieldDefinition = context.FieldDefinition,\n            FieldName = context.FieldName,\n            Fragments = context.Fragments,\n            Metrics = context.Metrics,\n            Operation = context.Operation,\n            ParentType = context.ParentType,\n            Path = context.Path,\n            ReturnType = context.ReturnType,\n            RootValue = context.RootValue,\n            Schema = context.Schema,\n            Source = context.Source,\n            SubFields = context.SubFields,\n            UserContext = context.UserContext,\n            Variables = context.Variables\n        };\n    // Creating a task with a resolve method for FieldA \n    var fieldAValueTask = (Task)fieldAFieldType.Resolver.Resolve(resolveFieldContext);\n    await fieldAValueTask.ConfigureAwait(false);\n\n    // Calling a Result property of a Task with reflections\n    var resultProperty = fieldAValueTask.GetType().GetProperty(\"Result\");\n\n    fieldAValue = resultProperty.GetValue(fieldAValueTask);\n}\nreturn fieldAValue?.GetPropertyValue(\"fieldB\");\n\n}\n```\nBut as you can see it's a not a most pretty solution. . If I correctly understood it, the dataloader has to be filled with data already so unfortunately I can't use it.\n. @joemcbride: Sorry for late response. \nYes, as permissions to subscribe to the stream doesn't mean necessary that user has the rights to see everything that can go through. \nOf course, it can be done before pushing that item through EventStreamResolver but I found that it's not the best way as the user context has to be stored somewhere.. Ah, actually I've implemented that on the FieldResolver not the EventStreamResolver like for normal field.\n. @joemcbride : ... You're right! I was initializing ISubject with ReplySubject. Completely missed that. Thanks!. Hi, \nI've added some unit tests and changed IList to ICollection.\nIf we want to have an array: double?[], then I believe taking the elementType is the only way as it preserve information about nullablelity. \nWith underlyingType we would get the double[]\n. ",
    "kdelorey": "@joemcbride Yeah I just found that and I came to close this myself. Apologies.. ",
    "joelmandell": "Actually I got kinda same problem. What I finally did was to use [FromBody] ExpandoObject query, and then fetching the query, operationname and variables using late binding. . Ok thx @joemcbride. Gonna try JObject type for the Variables property,  in a Body model/class for the GraphQL endpoint. \ud83d\udcaa. Hello. I am in need to stick to .NET 4.5.2 as highest currently, therefore I use System.Net.WebSockets.\nTrying to wrap my head around how to implement the subscription functionality.\nI just dont know really where to start.. This is awesome. Gonna use it :). Okay so I did find a way. But I does not feel quite right to do it like this.\nSorry for vb syntax:\nDim ctxAc = New DataLoader.DataLoaderContextAccessor\nctxAc.Context = New DataLoaderContext()\nDim doc = New DataLoader.DataLoaderDocumentListener(ctxAc)\nAnd when defining the DocumentExecutor I set the Root object to contain the DataLOaderContextAccessor.\nThen in my field resolvers I can do ctx.Root.Context.GetOrAddBatchLoader...\nIf there is a better way than using DI, I would like to know it :=). I am not sure if I describe it well... But I can see 3 variables in ResolveFieldContext.Variables, but not in ResolveFieldContext.Arguments.. Oh. I see. Well I imagine I can iterate trough FieldAst to find out the variable name from the argument and the match that name to the name in Variables.. Excuse me but I don't follow . Okay. I don't know if I ever will have the possibility to explain why I am hitting this problem. But I solved it by grabbing the Variable name from FieldAst. And then do an LINQ on the Variables object for the variable with that name. That gives me everything I need :). I found out which field that was failing by inspecting the network tab in Graphiql and the types object on recieved data from introspection query. \nSo I did som dirty stuff with the mutation resolver... I had it to expect a List<ObjectGraphType> as InputType\n\ud83e\udd26\u200d\u2642\ufe0f \nBut I wonder, is it some API that can make it possible to errormessage this?. Okay. So this is what happend...\nI have in my Application_BeginRequest method a check for OPTIONS HttpMethod.\nIf then I set the statuscode to 200 and do a Response.End(). This triggers the ThreadAbortException.\nI fixed this with Flushing, SuppressContent and ApplicationInstance.CompleteRequest.\nSorry for this. \ud83e\udd26\u200d\u2642\ufe0f . Yes I agree that it creates inconcistency. But a question... did I just miss something or how can something happen in the interface? The interface is basically only a skeleton of what needs to be implemented? But there is no function?. That possibility has existed for some time (https://stackoverflow.com/questions/4926677/c-sharp-as-cast-vs-classic-cast)\nI will make it more readable :). Yes I will remove it.. Yep typo when copied from my own code in another project.. Okay sorry for my stupid question, I just got it :). ",
    "AlexNOliveira": "Hi Joe,\nThank you for the tip. I double checked my code and it was type of InputObjectGraphType. This is my class:\n```c#\n    public class ClienteInputType : InputObjectGraphType\n    {\n        public ClienteInputType()\n        {\n            Name = \"clienteInput\";\n        Field<NonNullGraphType<IntGraphType>>( \"Id\" );\n        Field<NonNullGraphType<StringGraphType>>( \"Nome\" );\n        Field<ListGraphType<EnderecoType>>( \"Enderecos\" );\n    }\n}\n\n``\n   I even commentedField>( \"Enderecos\" );from my code as also any other \"Endereco\" types from the project, by assuming the usage ofListGraphType` had something to do, but no success.. Hi Joe,\nThank you for a pair of fresh eyes. I completely missed the necessary change from ClienteType to ClienteInputType in the code you mentioned. After fix the code, I started to face another issue that I will try to figure out what is wrong on it.\nThanks again,\nAlexandre. Hi Joe, thank you very much.\nI tried simplify my code, removing any mention to the Endereco class, in order to find the issue. I left the  class called Cliente with two properties, one Int and another String, but didn't succeed. I fixed the mutation class per your previous comment and tried a different approach for the mutation JSON string, trying to follow the sample from the StarWarsMutation class. My JSON string becomes:\njson\n{\n    \"query\": \"mutation ($clienteArgument:ClienteInput!){ incluirCliente(clienteArgument: $clienteArgument) { id nome } }\",\n    \"variables\": \"{ cliente: { id : 33, nome : \\\"Cliente de Teste 33\\\"  }   }\"\n}\nI have updated my ActionResult method to:\n```c#\n        [HttpPost]\n        public async Task Post( [FromBody] GraphQLQuery query )\n        {\n            var data = new Core.Data.ClienteData();\n            var schema = new Schema { Query = new ClienteQuery( data ), Mutation = new ClienteMutation( data ) };\n        var result = await new DocumentExecuter().ExecuteAsync( _ =>\n        {\n            _.Schema = schema;\n            _.Query = query.Query;\n            _.Inputs = query.Variables.ToInputs();\n        }\n        ).ConfigureAwait( false );\n\n        if(result.Errors?.Count > 0)\n        {\n            return BadRequest( result );\n        }\n\n        return Ok( result );\n    }\n\n```\nAnd the error I am receiving is:\njson\n{\n    \"errors\": [\n        {\n            \"message\": \"Variable '$clienteArgument' is invalid. Received a null input for a non-null field.\"\n        }\n    ]\n}. ",
    "KhalilMohammad": "Removing .Net 4.5 support should not be a problem . Most applications can be upgraded to .Net 4.6.1 seamlessly. Migration guide for .Net 4.5 , .Net4.6 and .Net 4.7 . ",
    "cheesemacfly": "@joemcbride I know this is an old ticket but I was actually wondering why we couldn't use an ObjectGraphType as an InputObjectGraphType? It's definitely possible for a type to be used for both a input on a mutation and as result of a query. Is there a way to not have to create 2 separate classes in this case?. @joemcbride thanks for the answer. Do you have a link to where they behave differently? In my current project, I'm using a generic class and reflection to add the property of my dto to the graphql types. I need to do it twice because of that and I'm trying to find a better way to handle it. . ",
    "trbngr": "I've been playing with some experimental syntax as well.\nCheck it out here\nI still need to complete it. But it's not bad for 1.5 hours of hackin ;). ",
    "oasis1992": "@joemcbride I used this example to understand subscriptions with an owner, thank you for sharing\nhttps://github.com/apollographql/graphql-tutorial/tree/t8-end. ",
    "Jetski5822": "Perfect, okay cool so I got this out...\n{\n   data:{\n      contentitems:[\n         {\n            id:47,\n            contentType:\"LandingPage\",\n            parts:[\n               {\n                  __typename:\"autoroutepart\",\n                  path:\"agency-start-bootstrap-theme\"\n               },\n               {\n                  __typename:\"titlepart\",\n                  title:\"Agency - Start Bootstrap Theme\"\n               },\n               null,\n               null,\n               null,\n               null,\n               null,\n               null\n            ]\n         }\n      ]\n   }\n}\nfrom this query\nquery {\n  contentitems(contentType: \"LandingPage\") {\n    id\n    contentType\n    parts { \n        __typename\n        ... on autoroutepart { path }\n        ... on titlepart { title }  \n    }\n  }\n}\nheres the code:\n```c#\n            Field>(\n                \"parts\",\n                resolve: context =>\n                {\n                    var typeDefinition = contentDefinitionManager.GetTypeDefinition(context.Source.ContentType);\n                var typeParts = new List<ContentElement>();\n\n                foreach (var part in typeDefinition.Parts)\n                {\n                    var name = part.Name; // About\n                    var partName = part.PartDefinition.Name; // BagPart\n\n                    var contentPart = contentParts.FirstOrDefault(x => x.GetType().Name == partName);\n\n                    if (contentPart != null)\n                    {\n                        typeParts.Add(context\n                            .Source\n                            .Get(\n                                contentPart.GetType(),\n                                name));\n                    }\n                }\n\n                return typeParts;\n            });\n\n```\nIt seems that is typeParts contains a type that is not registered in the Schema, null is returned. Is there a way to stop this happening?. Faster to use a .Count > 0 I believe?. ",
    "csantero": "@joemcbride Thanks, I added a commit to do that instead.. I can confirm that this is fixed as of alpha 870.. Not sure what's going on with Appveyor. The tests are passing but some command failed afterward?. Never mind, I see the specific appveyor failure now, but it doesn't seem related to this PR. I also ran yarn test locally and that passed.. Hmm, after rebasing onto master it seems this PR has broken the data loader tests. I'll need to investigate what's changed.. @johnrutherford I often find myself creating fields that return an object of a type I won't ever need anywhere else. Graphql-dotnet's instance-based API makes the following code compile fine:\n```c#\npublic static class FieldUtils\n{\n    public static FieldType MakeFieldType()\n    {\n        var outputType = new ObjectGraphType\n        {\n            Name = \"SomeType\"\n        };\n        outputType.Field(\"SomeValue\", t => t.SomeValue);\n    return new FieldType\n    {\n        Name = \"someField\",\n        ResolvedType = outputType\n    };\n}\n\n// Note the private class\nprivate class SomeType\n{\n    public int SomeValue { get; set; }\n}\n\n}\n```\nbut it will fail at runtime. When I upgraded to alpha-870 of this library, this first started affecting my project, and it took me quite some time to figure out what was going on. Given that it used to work, it seemed like it would be worthwhile to try to fix it, and I'd hate for other people to run into the same problem.\nAll this being said, the workaround is easy enough (just make the class public). If this PR turns out to be bad for performance or can't be easily reconciled with the data loader changes then I'm perfectly content to let the matter drop. Though we should probably document the limitation somewhere.. @johnrutherford Got it, thanks for the explanation. I'll go ahead and close this.. @joemcbride I just did it that way to make the test easier to write. I've pushed a new commit that uses ToInputs.. @OneCyrus Thanks, didn't know that. I've updated the PR.. ",
    "RobinHoody": "\nYou need to explicitly tell the field what graph type it is for complex types. As well as define an Animal graph type that extend ObjectGraphType see the various examples and docs for examples on objects\n\nWouldn't a link to the examples you're referencing above help the original poster here?. ",
    "kamsar": "For the validation caching, what if a bool Cacheable property was added to the IValidationRule interface, and the validation result would be cached if none of the validation rules were uncacheable. That would provide a way for must-run rules to be executed while having static rule results get cached.. It is possible to do this easily, because JSON can accept a StringValue. The implementation (which unfortunately I can't share at this time) is a simple class that derives from ScalarGraphType; no value class or converter (like is in #458) is required. Also works for input objects.. Looks great @pekkah. Sorry I didn't PR it myself (working on getting permission for that...). In usages so far, no. But seems like it might be a use case for other scenarios to target resolvers by type.. Would it make sense here to have ApplyTo also return before applying anything if _components.Count == 0?\nThen I think the SetFieldMiddleware execution option would be more or less irrelevant as middleware wouldn't be applied unless some was used.. Setting SetFieldMiddleware = false on your ExecutionOptions would probably be a workaround, assuming you aren't using field middleware.. Funny I came here to report the same thing but with a different reproduction. In my case, I'm using TaskCompletionSource to block the field from completing until the BeforeExecutionAwaitedAsync() method is fired. This is the method that Marten, which the batching example uses, is using.\nIn all cases, the execution of BeforeExecutionAwaitedAsync is being blocked until after the resolvers have been awaited (i.e. without the timer to push things along, the sample below would hang forever)\nI've also noticed different behavior depending on the number of async fields in the query. In my example below, if I query on { foo }, the BeforeExecutionAwaitedAsync gets called in a sane order, but if I change the query to { foo bar: foo } (repeating the same field) then the execution order is incorrect: BeforeExecutionAwaitedAsync is called before bar is added to the batch by its resolver.\nI'm also using SetFieldMiddleware = false, which should avoid the wrapping deadlock in #506 \nHere's my test code (against 2.0-alpha820):\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing GraphQL;\nusing GraphQL.Execution;\nusing GraphQL.Types;\nnamespace UnitTestProject1\n{\n    public class UnitTest1\n    {\n        public static Timer breaker;\n    public async Task TestMethod1()\n    {\n        var schema = new Schema();\n        schema.Query = new AsyncGraphType();\n\n        var userContext = new GraphQLUserContext();\n\n        breaker = new Timer(obj =>\n        {\n            Console.WriteLine(\"Timed out, pushing query batch (as it isn't pushing itself)\");\n            userContext.Batch();\n        }, null, 5000, 5000);\n\n        var result = schema.ExecuteAsync(_ =>\n        {\n            _.UserContext = userContext;\n            _.Query = $@\"{{ foo bar: foo }}\";\n            _.ExposeExceptions = true;\n            _.Listeners.Add(new ExecuteBatchListener());\n            _.SetFieldMiddleware = false;\n        });\n\n        var output = await result;\n        breaker.Dispose();\n\n        Console.WriteLine(output);\n    }\n\n    public class AsyncGraphType : ObjectGraphType\n    {\n        public AsyncGraphType()\n        {\n            Name = \"Query\";\n            Field<StringGraphType>(\"foo\", resolve: context =>\n            {\n                Console.WriteLine(\"Deferring until batched\");\n                var uc = context.UserContext.As<GraphQLUserContext>();\n                return uc.DeferUntilBatched();\n            });\n\n            Field<StringGraphType>(\"bar\", resolve: context => \"bar\");\n        }\n    }\n\n    public class ExecuteBatchListener : DocumentExecutionListenerBase<GraphQLUserContext>\n    {\n        public override Task BeforeExecutionAwaitedAsync(GraphQLUserContext userContext, CancellationToken token)\n        {\n            userContext.Batch();\n\n            return Task.CompletedTask;\n        }\n    }\n\n    public class GraphQLUserContext\n    {\n        private List<TaskCompletionSource<string>> tcses = new List<TaskCompletionSource<string>>();\n\n        public Task<string> DeferUntilBatched()\n        {\n            var tcs = new TaskCompletionSource<string>();\n            tcses.Add(tcs);\n\n            return tcs.Task;\n        }\n\n        public void Batch()\n        {\n            Console.WriteLine(\"Batching\\r\\n\" + new StackTrace());\n            int i = 0;\n            foreach (var tcs in tcses)\n            {\n                tcs.SetResult($\"BATCHED{i}\");\n                i++;\n            }\n\n            tcses.Clear();\n        }\n    }\n\n\n}\n\n}\n```. It makes sense for a multilevel query to deadlock, because the result of\nchild resolvers would deadlock with needing the parent resolver to\ncomplete. I'm not sure if this pattern will work as intended without\nrefactoring the way queries execute unless Joe is an async ninja who knows\nthings I don't. Which he might be ;)\nOn Thu, Jan 4, 2018, 12:28 PM John Rutherford notifications@github.com\nwrote:\n\nI'm also running into the same issue. Even if I go back to an earlier\nversion where BeforeExecutionAwaitedAsync() is called at the expected\ntime, it only works for the first level. If there are batched operations\nbeyond the first level, I get a deadlock.\nHas anyone been able to get some sort of DataLoader solution working\nbeyond one level? It appears that the dataloader-dotnet\nhttps://github.com/dlukez/dataloader-dotnet repository has been\nabandoned. It seems like maybe it would help if there was a hook like\nBeforeExecutionAwaitedAsync() called for each level.\nI'm just trying to determine if this is even possible with this library at\nthis time or if it will be at any point in the near future.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/508#issuecomment-355390069,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAGU_cMiKj-cvrDUP-OdCiIzC95tPEHQks5tHTSKgaJpZM4RJWPg\n.\n. You'd have to encode it in some form that would be transmissible via JSON (e.g. Base64). If the file isn't part of some other structured data result, it may not be a good candidate for a GraphQL API.\n\nNote that Base64 is significantly less efficient bandwidth-wise than binary transfer, and you won't get a browser download prompt from receiving it, though it could be possible maybe to do something with data: URLs; not sure.. The document object has an originalquery property though. Wouldn't that be\nused?\nOn Thu, Dec 28, 2017, 9:56 PM Joe McBride notifications@github.com wrote:\n\nI\u2019m fairly certain that the original query is used for other things, such\nas providing line/column numbers in error messages. So it would still be\nrequired.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/512#issuecomment-354401619,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAGU_STcDgrysrszFOG6yTWW5-W0YxKvks5tFH8XgaJpZM4RN4Sm\n.\n. I suspect this might be the issue:\n\n```\npublic class DashboardQuery : ObjectGraphType\n{\n    public DashboardQuery()\n    {\n        Name = \"Query\";\n    Field<HeartQuery>().Name(\"heart\");\n}\n\n}\n```\nThere's no resolver for the heart field, and there's no underlying root object with a Heart property to auto-resolve to. Thus, it's resolving to null. It works as a root field, because then there is a resolver function to call.. When I picked up graphql-dotnet I found most of my issues were related to needing to learn GraphQL more than the library conventions. GraphQL itself springs from JS and does things in a more JS-ey fashion overall, so there is some adaptation necessary for folks familiar with C# idioms. Resolvers and how dynamically typed a lot of things are comes to mind. I don't think that's a problem, but it is an educational opportunity.\nIn my implementation, I'm building a schema dynamically based on a database so having the ability to define types directly from ObjectGraphType<T> has been amazing (especially being able to make a schema out of object instances - IoC isn't always the way) - whereas a convention-based approach like this would have made my schema generation impossible. Admittedly mine is probably a less common use-case, but there are places for both a convention-based and more raw API.. +1 to being able to control ordering. I'm doing schema composition so it's difficult to control the order in which all fields are added.. IMO the current behavior is fine. GraphQL doesn't really need HTTP status codes with the GQL protocol already including the ability to return errors. The returned errors themselves determine the type of error that occurred, and there is already control over that (context.Errors in the resolver).\nIn other words, GraphQL != REST. In this particular case to not catch and re-emit exceptions as a GraphQL error would not be following the GQL protocol because a query can be partially resolved when an error occurs.. Changes made as requested. You're right, and that's why this change was a bad idea in the first place. It doesn't quite share the semantics with GetPropertyValue(). I'll revert it.. ",
    "Jasonkingsmill": "Good suggestion. \nI've made changes as suggested, inverting the inheritance and removing the now-redundant duplicated Field methods inherited from ComplexGraphType.\nI've updated all Input type checking to check against the IInputObjectGraphType interface.. ",
    "eXon": "I'm using v0.17.3 with .NET 4.6.. Great thanks for the follow up! \ud83d\udc4d . ",
    "simonhaenisch": "\n[ ] add a migration guide?. \n",
    "Cooke": "@Kurren123 @pekkah I have no problem with installing another package/library for a convention based approach. What I think is bad is that it is not part of the main repository and promoted and documented and maintained accordingly. I think the difference is big mentally especially for newcomers, though small in practice. \nThe same goes for middleware and authorization. It can be a separate package but I want it their, up for grabs, maintained by the library authors. Copy pasting samples is an unnecessary bump on the road. \nI guess what it boils down to is that I assume that many of the library users do run on ASP.NET Core and that the library should be delivered with packages that solve a majority of the library users headache. My assumption could also be a projection of my own current needs. . @joemcbride Thanks for your elaborate answer. \n\n\ninstantiate the ResolvedType example:\nc#\nnew QueryArguments(\n  new QueryArgument<NonNullGraphType<StringGraphType>>\n    {\n       Name = \"key\",\n       ResolvedType = new NonNullGraphType<StringGraphType>\n       {\n            ResolvedType = new StringGraphType()\n       }\n    }),\nI suspect instantiation of resolved type is only required for mutations, or perhaps in other circumstances.\n\n\nExecutionError class: we use custom errors a lot with help of a middleware we catch exceptions and do the following:\nc#\nvar error = new BusinessExecutionError(ex.Message, ex.ErrorCode);\nerror.AddLocation(context.FieldAst, context.Document);\ncontext.Errors.Add(error);\nThis is a very minor detail and nothing to get hang up on. Though another thing to note is that we can't extend the errors with custom codes so we worked around that with a custom ExecutionResult structure that we can serialize the way we want (instead of ExecutionResultJsonConverter). \n\n\nI get that the core library is server agnostic and I think that is good. I just would like to see more official support for ASP.NET Core in particular. I could probably ship on such a package. Though I think that it needs to be closely related to graphql-dotnet, with examples and links straight from the core library. Just like graphql-express is linked straight from http://graphql.org/graphql-js/. I also believe that in such an opinionated ASP.NET Core package support for ASP.NET authorization should be included.\n\n\nPerhaps the schema builder can help new comers, from graphljs, but it feels inferior to a convention based approach, thought it is more compact. \n\n\nThe authorization project looks promising. Thought looks like a separate implementation not using asp.net core. \n\n\nmaintained by the library authors should probably more like maintained by the community. I don't mind shipping in on stuff that I use.\n\n\nI hope graphql will have a bright future and thus a great dotnet library is needed. This library could very well be that library. With this post I just want to express my thoughts around what could be done and here if others felt the same and perhaps we could join efforts to fill the gaps. The response so far indicates that what I suggest are not overwhelmingly missed properties of this library. \nMaybe we can keep this issue open a little bit longer to hear if anyone else has anything to say. Thanks.. My guess is that the result selects of the mutations execute in serial which prevents the data loader from batching. I guess this since mutations are required to execute in serial and it feels likely that this execution strategy continues when executing the sub selects.. @saborrie I'm no longer working on a fix for this. I closed my pull request. \nThe deadlock happens because data loaders are only run \"once\" when the resolvers await the first time. Consecutive awaits will not trigger the data loaders to run. For more details please take a look at my pull requests. . To be honest I have written my own data loader so I have very little interest in the included one. \nLooking at my second commit again (modifying the data loader) I agree that it is less than optimal. \nJust scrap my second commit but please merge my first. This would allow any data loader implementation to better batch load requests: \"buffer\" up requests until all current resolvers have awaited/finished and then start processing then pause again when all resolvers have finished.\nYour suggestion \"looping inside DispatchAll.. until all done\" wont work on its own since you don't know when all is done. You need to continue to process load requests until the all the fields have resolved. . Ok. I'm sorry but I cannot put more time into this now. It seems like my data loader work good enough without pausing. You can close this.. ",
    "Odonno": "That is pretty much exactly what every developer want when starting a new project.. Why can't we convert a string or ExpandoObject to JSONGraphType?. ",
    "damithashyamantha": "Lets say I have a model class as follows.\npublic class Model\n{\npublic int id{get; set;}\npublic Datetime? CreatedOn{get; set;}\n}\nhow do we fetch this date field?\nThanks,. nullable: true great thanks, mate. Cheers!. ",
    "n-ate": "It looks like this may be version: 0.16.0.1140, not 0.17.2.752. ",
    "calvinxli": "Errors is set to null. Setting ExposeExceptions to true didn't seem to change anything.. I'm basically just using GraphQLMiddleware.cs:\n```\n        private async Task ExecuteAsync(HttpContext context, ISchema schema)\n        {\n            string body;\n            using (var streamReader = new StreamReader(context.Request.Body))\n            {\n                body = await streamReader.ReadToEndAsync().ConfigureAwait(true);\n            }\n        var request = JsonConvert.DeserializeObject<GraphQLRequest>(body);\n\n        var result = await _executer.ExecuteAsync(_ =>\n        {\n            _.Schema = schema;\n            _.Query = request.Query;\n            _.OperationName = request.OperationName;\n            _.Inputs = request.Variables.ToInputs();\n            _.UserContext = _settings.BuildUserContext?.Invoke(context);\n        });\n\n        await WriteResponseAsync(context.Response, result);\n    }\n\n    private async Task WriteResponseAsync(HttpResponse response, ExecutionResult result)\n    {\n        var json = _writer.Write(result);\n\n        response.ContentType = \"application/json\";\n        response.StatusCode = result.Errors?.Any() == true ? (int)HttpStatusCode.BadRequest : (int)HttpStatusCode.OK;\n\n        await response.WriteAsync(json);\n    }\n\nAnd in my Startup.cs:\n          services.AddSingleton();\n            services.AddSingleton();\n            services.AddTransient();\n            services.AddSingleton();\n            services.AddSingleton(\n                s => new CharactersSchema(new FuncDependencyResolver(type =>\n                    (GraphType)s.GetService(type))));\n```. Oops I didn't mean to close the issue.. Not quite sure how but I've got it working again.. It might've been a DI issue. I think instead of registering my query and schema I registered my query only and constructed the schema manually. I'm not sure if that was the fix though.. ",
    "Willovent": "I've got this exact issue (returning a list full of null element).  Do you remember any step you've done that can help ?. @joemcbride You were right about my DI, it missed the registration of my types. It work just fine now, thanks. ",
    "wakemaster39": "The issue was related to the dependency injection. I needed to ensure I added the Relay types so that they could be resolved.\npublic void ConfigureServices(IServiceCollection services)\n{\n   ...\n    services.AddTransient(typeof(ConnectionType<>));\n    services.AddTransient(typeof(EdgeType<>));\n    services.AddTransient<PageInfoType>();\n   ...\n}. ",
    "Risbot": "Thank you for information.\nYour solution is working . ok :). I have the same problem with delegate:\nin files i get null\n```\npublic class FileInputType : ScalarGraphType\n    {\n        public FileInputType()\n        {\n            Name = \"FileInput\";\n        }\n    public override object Serialize(object value)\n    {\n        return value;\n    }\n\n    public override object ParseValue(object value)\n    {\n        return value?.ToString();\n    }\n\n    public override object ParseLiteral(IValue value)\n    {\n        var stringValue = value as StringValue;\n        return stringValue?.Value;\n    }\n\n}\nFunc, Task> uploadImageDelegate = (context, files) => UploadImage(context, files);\nFieldDelegate(\n    \"UploadImage\",\n     arguments: new QueryArguments(\n                    new QueryArgument>> { Name = \"file\" }),\n     resolve: uploadImageDelegate);\n```. Hi, @corstian Thank you for your example, but in you example you load all data from data source. I use EF for loading data from database, Can you write how is posible to load only needed data from the database?. ",
    "hfroliveira": "Hello,\nI tried the solution but I got the following exception:  Index was outside the bounds of the array.\nInspecting the latest code it looks a problem at Resolve method (MethodModelBinderResolver.cs, line:38)\nwhile checking if the type of the argument matches the type of the data source type.\nI was able to proceed with the following fix:\nif ((_parameters.Length != index) && (context.Source?.GetType() == _parameters[index].ParameterType))\nI've attached the code of my sample program.\nThanks.\nProgram.zip\n. Hello,\nmaybe this can help, this query was sent using Postman with content-type: application/json.\n{\n \"Query\": \"query getCharacterById($characterId: String!) { character(Id: $characterId) { name friends { name } } }\",\n \"Variables\": \"{ characterId: \\\"15\\\"    }\"\n }\nUsing Fiddler to inspect the request sent by GraphiQL you will be able to see the same kind of data.\nSo the query typed using GraphiQL is a bit different than the one sent throught the wire.. Hello, \nThanks for the help. I'm trying to generate the types from Schema Syntax using the graphql parser. So, having the parser reading comments is enough to generate the proper GraphQLMetadata as you mentioned. I've seen the commit graphql-dotnet/parser#16 and the additional comment member. \nIn terms of Schema Syntax I understand that the description would be set using markdown:\ngraphql\ntype CustomType\n{\n    # field `count` description\n    count: Int!\n}\nWhat I can't understand, even reading graphql spec, is how to deprecate fields and set a proper deprecation reason just by using Schema Syntax.\nDo you believe that this could be a future enhancement of this project?\nThanks.\n. > What I can't understand, even reading graphql spec, is how to deprecate fields and set a proper deprecation reason just by using Schema Syntax.\nI think you are trying to accomplish this using the directive  @deprecated(reason: \"deprecation reason\"), is that true?\n```graphql\nextend type Query \n{\n    fieldB: Int\n    fieldD: Int @deprecated(badName : \"must be called reason\")\n    fieldE: Int @deprecated(reason : \"it must have\", one : \"argument value\")\n}\n```. Hi,\na situation that I just came across now is the fact that it is not possible to deprecate or set the description of a field within a type using GraphQLMetadata. The attribute usage is set to AttributeTargets.Class and AttributeTargets.Method.\n```csharp\npublic class Droid\n{\n    public string Id { get; set; }\n[GraphQLMetadata(\"name\", Description = \"Name of the droid.\")]\npublic string Name { get; set; }\n\n[GraphQLMetadata(\"foo\", DeprecationReason = \"Replaced by something else.\")]\npublic string Foo { get; set; }\n\n}\n ```\nThis way I don't know if there is an alternative way to deprecate or set a description of fields belonging to a type when loading build schemas using GraphQL Schema syntax.\nThanks.. Hi, no problem. Thanks.. ",
    "miguelcaravantes": "sorry in advance for my poor english....\nit's not the idea you put forward.\nThe MiddlewareResolver\n(https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Instrumentation/MiddlewareResolver.cs)\n intantiate classs NameFieldResolver( https://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Resolvers/NameFieldResolver.cs) when _next is null.\nNameFieldResolver get properties of the object you return in the resorver Func to extract values contained in ast names of query\npublic MiddlewareResolver(IFieldResolver next)\n        {\n            _next = next ?? new NameFieldResolver();\n        }\nif we could specify in the executionoptions the implementation to instantiate to be able to solve dictionaries or others.\nexample to resolve query\nquery entity(id:1){ id name}\nthis field solve by returning a dictionary\nField<EntityType>(\n                \"entity\",\n                arguments: new QueryArguments(\n                        new QueryArgument<NonNullGraphType<IntGraphType>> { Name = \"id\", Description = \"id of the entity\" }\n                    ),\n                resolve: context =>\n                {\n                    return new Dictionary<string, object>(){ {\"id\", 1}, {\"name\", \"object1\"} };\n                }\n            );\nthis thow error \"Expected to find property id on dictionary but it does not exist.\"\nbecause the actual implementation of NameFieldResolver only get of properties of type of object retuned, the implementation that i suggested support return dictionary but i cant implement in the MiddlewareResolver classs of GraphQL because this instance its own implementation and does not allow to configure another .. yes, the proposal would include can initialize via reflection private set properties. like AutoMapper or EF Core.  Schema.For supports a string array for definitions string[] typeDefinitions, split your definition in multiple files and read all files on your path and create this string array.\nSomething like this:\n```\nstring[] typeDefinitions =Directory.EnumerateFiles(Path.Combine(_env.ContentRootPath, _options.SchemaDirectory))\n                .Select(path => File.ReadAllText(path))\n                .ToArray()\nvar schema = Schema.For(typeDefinitions );\n```\n. the problem is not pull arguments, the problem is sending values to the client, my email value object is not sended as string. thank you so much!!!. ",
    "DexJen": "I really like this. I'm going move forward with it hopefully submit a pull request.. ",
    "christophglass": "Hey, well what is really weird (I am answaering for pwfraley btw) is that the query works when we put it in the graphiql web interface (copied from our angular app).  So I do not think it has to do with the types.  Also when we debug the server, the first line in the controller which checks if the query object is null, fails because the query object is null.\nThe query object comes from:\n    public async Task<IActionResult> Post([FromBody] GraphQLQuery query)\n    {            \n        if (query == null) { \n            throw new ArgumentNullException(nameof(query)); \n        }\n\nand it throws the exception, but only if the query comes from angular, if we use the graphiql interface it works fine.. ",
    "pwfraley": "That is what we checked and it seems identical.  Just was hoping someone had used this server with the angular apollo client and had a quick anser.  Thanks for the help!. The Problem is that APollo Client sends the Variables not as strings, but as JSON, so the definition\ncsharp\n    public class GraphlqlQuery\n    {\n        public string OperationName { get; set; }\n        public string NamedQuery { get; set; }\n        public string Query { get; set; }\n        public string Variables { get; set; }\n    }\nfails.  Will try Keeo suggestion and see if this works.. Thank you all, we got it working.  joemcbride example worked. :). ",
    "Keeo": "Hi, It is long shot but I think you hit the same issue as I while implementing this with apollo. GraphQLQuery should look like this - note that Variables are type GraphQL.Inputs:\ncsharp\npublic class GraphlqlQuery\n{\n    public string OperationName { get; set; }\n    public string NamedQuery { get; set; }\n    public string Query { get; set; }\n    public GraphQL.Inputs Variables { get; set; }\n}\n. Aslo thanks :+1:. ",
    "darting": "Hi there, other than store the parent object, is there any other way? thanks. hmm I think just\nc#\nresolve : context => {\n    var parent = context.Source;\n}\n?\n. ",
    "emulicus": "Actually, I have the same question. Context.Source doesn't really work since it's only giving you the closest parent, in this case order object. Is there a way to access it's parent? What does context.RootValue represent ?. So, what's the best way to access the higher levels? I don't really like the idea of using UserContext for this.. I see. Thank you Joe. . ",
    "serhii-ohorodnyk": "@joemcbride thanks for your feedback but isn't that just spins off another thread?\nAnyway I do have the same result without Task.Run:\nvar task = executer.ExecuteAsync(_ =>\n        {\n            _.Schema = new Schema()\n            {\n                Query = new Query(),\n                Mutation = new Mutation()\n            };\n            _.Query = @\"\n                mutation {\n                    one: testAsync\n                    two: testAsync\n                    three: testAsync\n                }\n            \";\n            _.OperationName = null;\n            _.Inputs = null;\n        });\n        task.Wait();\nDo you have a working example?. ",
    "deinok": "Source has changed a lot from 2017/11 Closing this. The same as DateTimeGraph\nA string with a special format.\nIts not in the spec, but its very useful. An URI, \"must\" have the format of this spec -> https://tools.ietf.org/html/rfc3986\nAnything that cant be parsed with this rules is not a valid URI.\nImagine I have a Schema with field called \"uri\" of type URI.\nIf I try to insert a valid URI everything goes okey, if its invalid, an error is returned to the caller, cause I dont want invalid URIs in my DB.\nIf \"uri\" is of type String, by default, the two scenarios above goes okey and the DB have an unexpected value.\n(Yes, we could check if a \"String\" is an URI in our own code, but better share this \"check\" with other interested people)\nAlso, the fact that somthing is of type URI, gives to the client more information about the schema.\n. @joemcbride Interesting, but does't common primitives come by default with the library? Like DateTime. @joemcbride Is there a more performant way?. Are PRs for this accepted?. # Before Transfer:\n- [x] Change name of repository from GraphQL.Client to graphql-client\nAfter Transfer:\n\n[x] Give you rights at nuget\n[x] Update CI configs (Even let CircleCI or change to other)\n[x] Change .props in order to show the change of property.\n[x] Change links of graphql.org and awesome-list. @joemcbride I think i dont left anything.\nIf you give me the OK I will start with the tranfer. @joemcbride Seems like we dont have rights to create repositories :(\nFollowing error while tranfering:\nYou don\u2019t have the permission to create repositories on graphql-dotnet. @joelmandell Thanks, its our intention ;). Yeah, transfer it. I will tranfer it to you then you can do it for me.. Ok, i have tranfer it to you. Okey, i have added you as a nuget admin. @joemcbride I'm okey with CircleCI but i dont have any problem changing the CI.. Okey, I Close this.\nAlso thanks for accepting it. We will probably continue creating more libraries related to GraphQL and helping to this org ;). Yeah, im doing some tests on Graph Types.\nBut GraphQL.GraphiQLCore is causing my VS to crash. So im using the appveyor to test this.. @elauffenburger Can you give me a TLDR for this, as @PascalSenn said that It could be interesting for the GraphQL Client?. Sure, code generation using something like this : Microsoft.CodeAnalysis.CSharp from the Introspection model as an MSBuild Task would be awesome. Im usign a lot of nameof(Type) and the QueryArguments seems the only point where a \"variable\" is using not the DefaultNameConverter.\nAlso, this change will be a breaking change, so im not sure if its okey to do it or no.. @VladimirAkopyan use the GraphQLClient v2 and server.CreateHttpHandler() or the AsGraphQLClient() extension method. @VladimirAkopyan Not your fault, I should document how make the tests. done. done, test also not passing. \n",
    "mrpink76": "Ahh, thanks!\n . It's defined as:\ncsharp\n    public class QueryEngineParameterType : InputObjectGraphType\n    {\n        public QueryEngineParameterType(IndsysDao indsysDao, IMapper mapper)\n        {\n            Name = \"QueryEngineParameter\";\n            Field<NonNullGraphType<StringGraphType>>(\"Name\");\n            Field<NonNullGraphType<StringGraphType>>(\"Value\");\n        }\n    }\n. You were absolutely correct! \nMy fault since I was storing inputs in an unstandard way.\nSorry for the inconvenience!\n. ",
    "siberianstark": "I have disabled scope validation in Progrma.cs and it helped me. But it seems to me it is not a good idea.\ncsharp\n        public static IWebHost BuildWebHost(string[] args) =>\n            WebHost.CreateDefaultBuilder(args)\n                .UseStartup<Startup>()\n                .UseDefaultServiceProvider(options => options.ValidateScopes = false)\n                .Build();. @joemcbride I changed GraphQLMutation to singletone and i have got an error \nAn exception of type 'System.InvalidOperationException' occurred in Microsoft.Extensions.DependencyInjection.dll but was not handled in user code: 'Cannot consume scoped service 'AutoMapper.IMapper' from singleton 'Trytoremember.Services.Interfaces.IAccountService'.'\nbecause AutoMapper resolves as scoped and uses in my AccountService. >  I can provide one later today\nIt would be cool! Thank you a lot!. @joemcbride https://github.com/graphql-dotnet/authorization Does this project contain an example of graphql authorization? Just i did not find this.. @joemcbride Thank you for an example! But i can not find whence is IPrincipalProvider inherited?. @joemcbride I tried to tune my configuration for authorization with the help of your guide but it did not work. My code.\nRegister the authorization classes\n```csharp\n        public static void AddGraphQL(this IServiceCollection services)\n        {\n            services.TryAddSingleton();\n        services.TryAddSingleton(s =>\n        {\n            var authSettings = new AuthorizationSettings();\n\n            authSettings.AddPolicy(\"AdminPolicy\", _ => _.RequireClaim(\"role\", \"Admin\"));\n\n            return authSettings;\n        });\n\n        services.AddTransient<IValidationRule>(s => new AuthorizationValidationRule(s.GetRequiredService<IAuthorizationEvaluator>()));\n    }\n\nSent GraphQLSettings to my GraphQlMiddlewarecsharp\n        public static IApplicationBuilder UseGraphQl(this IApplicationBuilder builder)\n        {\n            var settings = new GraphQLSettings\n            {\n                BuildUserContext = async ctx =>\n                {\n                    var principalProvider = builder.ApplicationServices.GetService();\n                    var principal = principalProvider.HttpContext.User;\n                var userContext = new GraphQLUserContext\n                {\n                    User = principal\n                };\n                return Task.FromResult(userContext);\n            }\n        };\n\n        var rules = builder.ApplicationServices.GetServices<IValidationRule>();\n        settings.ValidationRules.AddRange(rules);\n\n        return builder.UseMiddleware<GraphQlMiddleware>(settings);\n    }\n\nGraphQlMiddleware's code\nGraphQLSettings inject from constructor and Settings.ValidationRules send to ExecutionOptions ValidationRules, Settings.BuildUserContext to UserContext in ExecutionOptions.csharp\n    public class GraphQlMiddleware\n    {\n        private RequestDelegate Next { get; }\n        private ISchema Schema { get; }\n        private GraphQLSettings Settings { get; }\n        public GraphQlMiddleware(RequestDelegate next, ISchema schema, GraphQLSettings settings)\n        {\n            Next = next;\n            Schema = schema;\n            Settings = settings;\n        }\n    public async Task Invoke(HttpContext httpContext, IDocumentExecuter documentExecuter)\n    {\n        var sent = false;\n        if (httpContext.Request.Path.StartsWithSegments(\"/graph\"))\n        {\n            using (var sr = new StreamReader(httpContext.Request.Body))\n            {\n                var query = await sr.ReadToEndAsync();\n\n                if (!String.IsNullOrWhiteSpace(query))\n                {\n                    var request = JsonConvert.DeserializeObject<GraphQLDto>(query);\n\n                    var executionOptions = new ExecutionOptions\n                    {\n                        Schema = Schema,\n                        Query = request.Query,\n                        OperationName = request.OperationName,\n                        Inputs = request.Variables != null ? JsonConvert.SerializeObject(request.Variables).ToInputs() : null,\n                        ValidationRules = Settings.ValidationRules,\n                        UserContext = Settings.BuildUserContext\n                    };\n\n\n                    try\n                    {\n                        var result = await documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\n                        if (result.Errors?.Count > 0)\n                        {\n                            var errors = WriteErrors(result);\n\n                            await WriteResult(httpContext, new ExecutionResult\n                            {\n                                Errors = errors\n                            },\n                            400);\n                        }\n                        else\n                        {\n                            await WriteResult(httpContext, result, 200);\n                        }\n\n                    }\n                    catch (Exception ex)\n                    {\n                        await WriteResult(httpContext, new ExecutionResult\n                        {\n                            Errors = new ExecutionErrors() { new ExecutionError(ex.Message, ex.InnerException) }\n                        },\n                        400);\n                    }\n\n                    sent = true;\n                }\n            }\n        }\n        if (!sent)\n        {\n            await Next(httpContext);\n        }\n    }\n\n    private async Task WriteResult(HttpContext httpContext, ExecutionResult result, int statusCode)\n    {\n        var json = new DocumentWriter(indent: true).Write(result);\n\n        httpContext.Response.StatusCode = statusCode;\n        httpContext.Response.ContentType = \"application/json\";\n        await httpContext.Response.WriteAsync(json);\n    }\n\n    private ExecutionErrors WriteErrors(ExecutionResult result)\n    {\n        var errors = new ExecutionErrors();\n        foreach (var error in result.Errors)\n        {\n            var ex = new ExecutionError(error.Message);\n            if (error.InnerException != null)\n            {\n                ex = new ExecutionError(error.Message, error.InnerException);\n            }\n            errors.Add(ex);\n        }\n\n        return errors;\n    }\n}\n\nStartup.cscsharp\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n        app.UseCors(\"DefaultPolicy\");\n        app.UseAuthentication();\n        app.UseGraphQl();\n        app.UseMvc();\n    }\n\n```\ncsharp\n        public void ConfigureServices(IServiceCollection services)\n        {\n            ...........\n            services.AddMvc();\n            services.AddGraphQL();\n            services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n            services.AddTransient<IAccountService, AccountService>();\n            services.AddTransient<IRedisService, RedisService>();\n            services.AddTransient<IUserService, UserService>();\n            services.AddTransient<IRoleService, RoleService>();\n            services.AddTransient<IDictionaryService, DictionaryService>();\n            services.AddTransient<IWordService, WordService>();\n            services.AddTransient<IConnectionFactory, ConnectionFactory>();\n            services.AddTransient(typeof(IRepository<>), typeof(GenericRepository<>));\n            services.AddSingleton<ErrorType>();\n            services.AddSingleton<RoleType>();\n            services.AddSingleton<UserType>();\n            services.AddSingleton<LoginType>();\n            services.AddSingleton<DictionaryType>();\n            services.AddSingleton<WordType>();\n            services.AddSingleton<TranslationType>();\n            services.AddSingleton<LoginUserInput>();\n            services.AddSingleton<DictionaryInput>();\n            services.AddSingleton<WordInput>();\n            services.AddSingleton<UserInputType>();\n            services.AddSingleton<RegisterUserInput>();\n            services.AddSingleton<GraphQLQuery>();\n            services.AddSingleton<GraphQLMutation>();\n            services.AddScoped<IDocumentExecuter, DocumentExecuter>();\n            services.AddAutoMapper();\n            services.AddSingleton<ISchema>(\n                s => new GraphQLSchema(new FuncDependencyResolver(type => (GraphType)s.GetService(type))));\n        }\nI used this.AuthorizeWith(\"AdminPolicy\"); but if I'm noy authorized, GraphQl still returns result from db,  doesnt return \"not authorized\" exception.\ncsharp\n    public class DictionaryType : ObjectGraphType<DictionaryView>\n    {\n        public DictionaryType(IWordService service)\n        {\n            this.AuthorizeWith(\"AdminPolicy\");\n            Field(x => x.Id, nullable: true, type: typeof(IdGraphType)).Description(\"Dictionary id\");\n            Field(x => x.UserId, nullable: true, type: typeof(IdGraphType)).Description(\"User id\");\n            Field(x => x.Name, nullable: true, type: typeof(StringGraphType)).Description(\"Name of dictionary\");\n            FieldAsync<ListGraphType<WordType>>(\n                \"words\",\n                resolve: async context =>\n                {\n                    return await service.GetListAsync(context.Source.Id);\n                }\n            );\n        }\n    }\nCan you take a look at my code and suggest where there might be an error?. @joemcbride I did what you said and it is working now, thank you!\nAnd i have questions, if i want to protect my type should i call .AuthorizeWith(\"Policy\") at each field?  If i dont want to protect field do i just not call AuthorizeWith(\"Policy\") at field? Is there no way to protect  all type by one attribute or method?\nSecond question: I did not understand, what is this.AuthorizeWith(\"AdminPolicy\"); for ? Just authorization works without calling this method at DictionaryType\ncsharp\n    public class DictionaryType : ObjectGraphType<DictionaryView>\n    {\n        public DictionaryType(IWordService service)\n        {\n            this.AuthorizeWith(\"AdminPolicy\");\n            Field(x => x.Id, nullable: true, type: typeof(IdGraphType)).Description(\"Dictionary id\");\n            Field(x => x.UserId, nullable: true, type: typeof(IdGraphType)).Description(\"User id\").AuthorizeWith(\"AdminPolicy\");\n            Field(x => x.Name, nullable: true, type: typeof(StringGraphType)).Description(\"Name of dictionary\").AuthorizeWith(\"AdminPolicy\");\n            FieldAsync<ListGraphType<WordType>>(\n                \"words\",\n                resolve: async context =>\n                {\n                    return await service.GetListAsync(context.Source.Id);\n                }\n            ).AuthorizeWith(\"AdminPolicy\");\n        }\n    }. @joemcbride then this.AuthorizeWith(\"AdminPolicy\"); doesnt work for me. I set it in my constructor and tried to send request without authorization and did not get 401 Error, i got entity from db. But if set AuthorizeWith(\"AdminPolicy\"); for each field then i get 401 if I throw not authorized request.\nAn example with this.AuthorizeWith(\"AdminPolicy\"); from my code.\n```csharp\npublic class DictionaryType : ObjectGraphType<DictionaryView>\n{\n    public DictionaryType(IWordService service)\n    {            \n        Field(x => x.Id, nullable: true, type: typeof(IdGraphType)).Description(\"Dictionary id\");\n        Field(x => x.UserId, nullable: true, type: typeof(IdGraphType)).Description(\"User id\");\n        Field(x => x.Name, nullable: true, type: typeof(StringGraphType)).Description(\"Name of dictionary\");\n        FieldAsync<ListGraphType<WordType>>(\n            \"words\",\n            resolve: async context =>\n            {\n                return await service.GetListAsync(context.Source.Id);\n            }\n        );\n        this.AuthorizeWith(\"AdminPolicy\");\n    }\n}\n\nThat example works, get 401 if is not authorizedcsharp\n    public class DictionaryType : ObjectGraphType\n    {\n        public DictionaryType(IWordService service)\n        {          \n            Field(x => x.Id, nullable: true, type: typeof(IdGraphType)).Description(\"Dictionary id\").AuthorizeWith(\"AdminPolicy\");\n            Field(x => x.UserId, nullable: true, type: typeof(IdGraphType)).Description(\"User id\").AuthorizeWith(\"AdminPolicy\");\n            Field(x => x.Name, nullable: true, type: typeof(StringGraphType)).Description(\"Name of dictionary\").AuthorizeWith(\"AdminPolicy\");\n            FieldAsync>(\n                \"words\",\n                resolve: async context =>\n                {\n                    return await service.GetListAsync(context.Source.Id);\n                }\n            ).AuthorizeWith(\"AdminPolicy\");\n            this.AuthorizeWith(\"AdminPolicy\");\n        }\n    }\nqueriescsharp\n    public class GraphQLQuery : ObjectGraphType\n    {\n        public GraphQLQuery(IDictionaryService dictionaryService, IWordService wordService)\n        {\n            FieldAsync>(\n                \"dictionaries\",\n                Name = \"Dictionaries\",\n                arguments: new QueryArguments(new QueryArgument() { Name = \"userId\" }),              \n                resolve: async context =>\n                {\n                    var userId = context.GetArgument(\"userId\");\n                    var result = await dictionaryService.GetListAsync(userId);\n                    return result;              \n                }\n            );\n        FieldAsync<DictionaryType>(\n            \"dictionary\",\n            Name = \"Dictionary\",\n            arguments: new QueryArguments(new QueryArgument<IdGraphType>() { Name = \"id\" }),\n            resolve: async context =>\n            {\n                var id = context.GetArgument<Guid>(\"id\");\n                var result = await dictionaryService.GetAsync(id);\n                return result; \n            }\n        );\n\n    }\n}\n\n. @joemcbride I checked, if call.AuthorizeWith(\"AdminPolicy\");at GraphQLQuery method then it works well, i just did not expect that need call.AuthorizeWith(\"AdminPolicy\");at GraphQLQuery method.\nThis example works well, get 401 if not authorized ;)csharp\n    public class GraphQLQuery : ObjectGraphType\n    {\n        public GraphQLQuery(IDictionaryService dictionaryService, IWordService wordService)\n        {\n            FieldAsync>(\n                \"dictionaries\",\n                Name = \"Dictionaries\",\n                arguments: new QueryArguments(new QueryArgument() { Name = \"userId\" }),              \n                resolve: async context =>\n                {\n                    var userId = context.GetArgument(\"userId\");\n                    var result = await dictionaryService.GetListAsync(userId);\n                    return result;              \n                }\n            ).AuthorizeWith(\"AdminPolicy\");\n        }\n    }\n```\n\nMind adding an issue to that project? \n\nIt think, it would be better to add issue to https://github.com/graphql-dotnet/authorization project :). I got this error when used this webpack 1 config\n```\nvar webpack = require('webpack');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');\nvar output = './wwwroot';\nmodule.exports = {\n    entry: {\n        'bundle': './Scripts/app.js'\n    },\noutput: {\n    path: output,\n    filename: '[name].js'\n},\n\nresolve: {\n    extensions: ['', '.js', '.json']\n},\n\nmodule: {\n    loaders: [\n      { test: /\\.js/, loader: 'babel', exclude: /node_modules/ },\n      { test: /\\.css$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader!postcss-loader') }\n    ]\n},\n\nplugins: [\n  new ExtractTextPlugin('style.css', { allChunks: true })\n]\n\n};\n```\nwhen i tried to build graphiql app with webpack 3, with config \n```\nconst path = require('path');\nconst fs = require('fs');\nvar webpack = require('webpack');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst appDirectory = fs.realpathSync(process.cwd());\nconst resolveApp = relativePath => path.resolve(appDirectory, relativePath);\nvar output = resolveApp('wwwroot');\nmodule.exports = {\n    entry: {\n        'bundle': './GraphiQL/app.js'\n    },\noutput: {\n    path: output,\n    filename: '[name].js'\n},\n\nresolve: {\n    extensions: ['.js', '.json']\n},\n\nmodule: {\n    loaders: [\n        { test: /\\.js/, loader: 'babel-loader', exclude: /node_modules/ },\n        {\n            test: /\\.css$/,\n            loader: ExtractTextPlugin.extract({\n                fallback: require.resolve('style-loader'),\n                use: [\n                    {\n                        loader: require.resolve('css-loader'),\n                        options: {\n                            importLoaders: 1,\n                            minimize: true,\n                            sourceMap: true,\n                        },\n                    }\n                ]\n            })\n        },\n    ]\n},\n\nplugins: [\n    new ExtractTextPlugin('style.css', { allChunks: true })\n]\n\n};\n```\nIt works well. @joemcbride \nUsed \"graphiql\": \"^0.7.8\" - did not work. Now \"graphiql\": \"^0.11.11\" - is working. I think if it works, issue may be closed.. ",
    "KreativJos": "It is a temporary solution. We have solved it by extending the framework (=> hacking a lot), but it makes the code pretty unreadable for now.. If you use GraphQL server, you can add graphiql & graphql playground with some easy steps:\nIn commandline (version could be upgraded later on):\ndotnet add package GraphQL.Server.Transports.Subscriptions.Abstractions -v 3.1.0-alpha0003\ndotnet add package GraphQL.Server.Transports.AspNetCore\ndotnet add package GraphQL.Server.Ui.GraphiQL\nAnd optionally for the playground and websockets subsequently:\ndotnet add package GraphQL.Server.Ui.Playground\ndotnet add package GraphQL.Server.Transports.WebSockets\nAnd then in Startup.cs - Configure\napp.UseGraphiQLServer(new GraphiQLOptions\n{\n    GraphiQLPath = \"/graphiql\",\n    GraphQLEndPoint = \"/graphql/v1\"\n});\nAnd for the playground:\napp.UseGraphQLPlayground(new GraphQLPlaygroundOptions()\n{\n    Path = \"/playground\",\n    GraphQLEndPoint = \"/graphql/v1\"\n});. Yes, we have done this before, but in a kind of hacky way (can be done in a much better way, probably with observables or something in that direction).\nCurrently, it is solved by having a 'isChanged' property for every property in the model, like this:\nprotected string _name;\npublic bool IsNameSet { get; set; } = false;\npublic string Name\n{\n    get { return _name; }\n    set\n    {\n        _name= value;\n        IsNameSet = true;\n     }\n}\nThen, when saving the data, we check if the property has been set.\nif (input.IsNameSet ) efItem.Name = input.Name;\nThis can also be used for checking if an object should be created or updated for example, and working with sub-objects becomes easier that way.. That doesn't seem possible in the current framework, because of the resolver functions.\nPOCO-classes should be doable of course, like Droid, EpisodeEnum, Human etc. Maybe someone would like to build a project for that kind of purpose?. It is quite easy to split up your root query into multiple sub-queries, like this:\nquery {\n  subRootQuery {\n    hero: Droid!\n  }\n}. This was an issue on my side too. I resolved it simply by creating my own singleton with the IMemoryCache.. Shouldn't the UserContext be an interface instead of an object type? The only issue I see with that is that there is no property or function which can be within that interface. But it would be better for clarity.. Ah, guessing now this belongs to the GQL-server repo:\n\n\"GraphQL.Server.Transports.AspNetCore/3.1.0-alpha0027\": {\n        \"type\": \"package\",\n        \"dependencies\": {\n          \"GraphQL\": \"[2.0.0-alpha-868, 2.1.0)\",. Ah, sorry, couldn't find it via the search. I think I might have had a typo.\nThnx!. \n",
    "roman-kozachenko": "Another question related to that model - is it possible to access ResolveFieldContext (or some other context) in Blog(string id) method?. A simple test added.. I add simple bubbling.\nSome tests still not passing, will take a look.\n. @joemcbride I fixed tests. . @joemcbride, @jquense any remarks for my PR? We want to have that changes on our production app, but until that PR will be merged we have to use custom nuget package based on my branch, losing ability to rapidly get your library updates.. Since current pull request does not any feedback, I closed it.\nAll code is available in my branch https://github.com/roman-kozachenko/graphql-dotnet/tree/fix/null-bubbling. It can be merged in main repository, or any changes can be requested in future.. Sure, accidentally copy-pasted it from main solution.. Yes, it should work for other types too.. Sure, extracted to separate file. . Missed it, thanks.. This is a Resharper auto-generated file template. I really don't want to have rights on that file :).\nRemoved. . If 'two' fields is nullable, then it is ok to set it to null when error occurred.\nBut if it is non-nullable - nearest nullable parent should be set to null in result.. You can find failed tests here. Failed test name is GraphQL.Tests.Introspection.SchemaIntrospectionTests.validate_core_schema.\nAs I see, queryType property is NonNullable, but its value is null. So, its value should be bubbled to nearest nullable parent - __shema. . ",
    "Drinker5": "I thought it would be easier to add a new inherited type from InputObjectGraphType\nIn fork i make\n```C#\n    public interface IInputValueObjectGraphType : IInputObjectGraphType\n    {\n        object Convert(object source);\n        Type SourceType { get; }\n    }\npublic abstract class InputValueObjectGraphType<TSourceType> : InputObjectGraphType<TSourceType>, IInputValueObjectGraphType\n{\n    public InputValueObjectGraphType()\n    {\n        SourceType = typeof(TSourceType);\n    }\n\n    public Type SourceType { get; }\n    public abstract object Convert(object source);\n}\n\nand added little change inGraphQL.DocumentExecuter.CoerceValueC#\nif (complexType is IInputValueObjectGraphType)\n{\n   var inputValueObject = complexType as IInputValueObjectGraphType;\n   var sourceObject = obj.ToObject(inputValueObject.SourceType);\n   return inputValueObject.Convert(sourceObject);\n}\n```\nhere: https://github.com/Drinker5/graphql-dotnet/commit/9aba623d11154fda7a3c2e92c00422dcc3113725\nIt's acceptable?. ",
    "igordaiko": "The problem was in circular dependecy. ",
    "alexandercarls": "Just to provide an alternative solution, although I think that the approach is very similiar.\nI created two marker attributes QueryAggregate and MutationAggregate. Each \"Sub\"-Schema would need to have this set at the class level.\nFor the container, I have a method like .AddGraphQLAggregates<RootQueryAggregate, RootMutationAggregate>(); which takes the Root Schemas (mostly empty classes), looks up in the specified assemblies and finds classes which are annotated with the above-mentioned attributes and stitches them together via reflection.\n@drobertson123 \n\nI am hoping for some flexibility to use a configuration file to say what goes in and what doesn't. \n\nCan you give an example of what would be unwanted? Or where the flexibility would lie?\n. I am especially interested for error handling as a cross-cutting concern.\nFor example when my business logic within the resolver throws a CustomDomainException.\nI would like to have the opportunity e.g. with a Middleware to catch this specific exception and translate it to a GraphQL specific ExecutionError.. I made a similar detour and couldn't get it to work nicely without forking the project.\nFor this current project I decided that our domain exceptions just inherit from ExecutionError.\nI only had one idea left which I didn't explore yet.\nIn the GraphQL Middleware there might be a spot where I could translate domain exceptions in to ExecutionErrors.\n```csharp\n        private async Task ExecuteAsync(HttpContext context, ISchema schema) {\n            var request = Deserialize(context.Request.Body);\n            var dataLoaderDocumentListener = serviceProvider.GetRequiredService();\n        var result = await executer.ExecuteAsync(opt => {\n            opt.Schema = schema;\n            opt.Query = request.Query;\n            opt.OperationName = request.OperationName;\n            opt.Inputs = request.Variables.ToInputs();\n            opt.UserContext = settings.BuildUserContext?.Invoke(context);\n            opt.Listeners.Add(dataLoaderDocumentListener);\n            opt.ThrowOnUnhandledException = true;\n            opt.ExposeExceptions = env.IsDevelopment();\n        });\n        // --> Iterate result.Errors and replace them here.\n        await WriteResponseAsync(context, result);\n    }\n\n```\nAs for your resolver structure. I used a mediator pattern with some rather large abstractions. My resolvers are only sending a message object with some props and the mediator is invoking the correct handler. That way my logic is agnostic of GraphQL (aside from the domain exceptions). @joemcbride Maybe I am fundamentally miss understanding async/await or the middleware.\nI tried that before and the catch block never gets executed.\nI do agree, that would be the best case scenario for translating domain exceptiong as a cross-cutting concern.\ncsharp\npublic class ErrorHandlingFieldsMiddleware {\n    public async Task<object> Resolve(\n        ResolveFieldContext context,\n        FieldMiddlewareDelegate next) {\n        try {\n            return await next(context);\n        }\n        catch (Exception e) {\n            Console.WriteLine(e);\n            throw;\n        }\n    }\n}. FYI The middleware now properly works with this Pull Request: https://github.com/graphql-dotnet/graphql-dotnet/pull/865/files#diff-b4c19b6d66951c1c5d547222ae0d874bR22 and can be used to translate the exceptions.. @aaronjedwards for the update mutations we simply get the argument, in this case named \"data\" and pass the changes along.\nvar changes = (IReadOnlyDictionary<string, object>)ctx.Arguments[\"data\"];\nWe also have a helper method which traverses top-level keys and patches the properties of the persistence model (prop names and key names are the same) via reflection.. @aaronjedwards that is just a normal input graph type which can have object as the generic type argument. The field names have to be present for the schema + built-in validation, other than this I see no reason for an UpdateFoo DTO. As we work with the changes directly.. @joemcbride \n\nIt seems like you could use a service locator pattern, though I think that provides a brittle programming model. It would be easy to expose the IDependecyResolver as a property on the ResolveFieldContext which is what I would suggest.\n\n\nCan you provide a short snipped/info on how to do this? This is exactly my use case as I need a dependency resolver (Servicelocator) in a generic FieldBuilder ResolveFieldContext method.\nThanks!\n. @benmccallum I also enabled a service locator on my ResolveFieldContext, using GraphQLUserContext just as a dummy to get access to IDependencyResolver.\nI am then using a set of extension methods on ResolveFieldContext to access the resolver.\nIn the actual resolver code I create a scope, just as you described taking a runnable action.\nKeep in mind that this is a toy project and does not necessarily reflect the code running in production.\nAs for you problem, I didn't encoutered that one yet, as I use the \"bag\" of the HttpContext and then have an \"Accessor\" service.\nThinking about it, instead of creating a new scope, given that we are still in the middleware chain, it should be possible to just \"get the existing scope, created by ASP.NET Core\".\nYou could try this: https://stackoverflow.com/a/37895590. Please report back if you do :)\nA way certainly would be opening your own scope with a custom lifetime using another DI solution at the beginning of the middleware. But this is not really idomatic.. ",
    "shoooe": "I see that ExecutionError has a Data property. Can this property be set somehow?. But what if a graphql type is injected a resource X via the standard DI which is supposed to be \"transient\" or \"scoped\" (live as long as the request lives)?\nOr to put it better. Say each graphtype needs some sort of resource. What is the recommended way to inject such resource?. For something like DbContext that seems suboptimal. Considering that DbContext is not guaranteed to be thread safe and considering that resolvers, as far as I know, are run concurrently, that may yield concurrent errors. With Npsql (Postgres binding for Entity Framework) I get exceptions due to concurrent access to the same DbContext instance which is injected into multiple GraphQL types.\nMaybe I'm missing something though. Some of my GraphQL types need to perform queries therefore for something like:\nquery {\n    user(id: ...) { \n        ...\n        posts {\n            comments {\n                id,\n                ...\n            }\n        }\n    }\n}\nThe PostType would perform a query for its related comments. And each PostType seems to be resolved concurrently and each PostType is injected with a DbContext which is not thread safe.\nI should probably be reading more about the N + 1 problem's solution given in the docs. That may solve this issue as well as the issue of performance in this case.. @SimonCropp This month I won't have time to take a look at this, but if there's anybody else that care about it I might work on a PR.. @kenrim626 Maybe a more appropriate way would be to allow for user defined conversions to be defined in this library and then, yes, create a specific NodaTime package for the integration.\n. In the first case is it possible to add a converstion from, for example, LocalDate to DateGraphType without changing the library code (via a pull request or local edit)?\nIf so, it's not clear to me how.. What's GraphTypeTypeRegistry and ValueConverter? Where can I read the docs about making a custom scalar type? Why wouldn't a class inheriting from ScalarGraphType be enough to map LocalDateGraphType to LocalDate?. So what would be the simplest example (with only the 2nd step) for a custom LocalTime scalar value assuming a local time value is passed in as a JSON string to GraphQL (ex. \"2018-05-24\")?. I'm not doing any serialization manually. I think StringValue would be fine.. For those wondering here you can find 4 examples (Instant, IsoDayOfWeek, LocalDate, LocalTime) of the ScalarGraphType definitions that I've tested and seem to work as of today.. @SimonCropp I'm writing it now, but I'm dubious as to how to hook these scalar types up without having the user add them manually with:\nservices.Singleton<InstantGraphType>();\nservices.Singleton<LocalDateGraphType>();\n.... I'll work on it at: https://github.com/shoooe/graphql-nodatime.. Oh, I was unable to find that in the documentation. Thanks.. Apparently this was caused by an incorrect schema definition. Specifically TypeB and TypeC where defined as ObjectGraphTypes of themselves due to a typo.. ",
    "BenjaBobs": "You could write a base resolver that all your resolvers inherit from, that has a try..catch to catch that specific exception.. Well, the whole inheritance chain of contexts and resolvers is a bit confusing, I was actually hoping that there would be a discussion to change it at some point. I haven't tried to implement the scenario you're describing, so I don't currently have an overview of the process.. You could deserialize as a Dictionary<string, object> and see what keys are there. If you're graph input object is an object with nullable properties, and you only set the properties you want to change, then only those keys will show up in the dictionary.. We do have the UpdateFoo in the schema, but we generate it based on attributes on our Foo class so we don't have to maintain both separately.. I use reflection to add a type to the schema that has the same properties as my data class, except all nullable.. I created a generic EntityGraphType that maps each of it's properties to existing graphql types and properties that reference other Entities to their closed generic EntityGraphType.. I think that is what the Register method is for. You could create your own GraphType for char and then register it.. That's weird. Both the class and method are public. Did you add using GraphQL;?\nAnd do you have the latest version of graphql-dotnet?. The version I'm using (in which it works) is 2.0.0-alpha-864.\nIf you can't find anything inside the GraphQL namespace I think your visual studio may need a restart. I find that sometimes restarting visual studio fixes these things.. Yes. There are lots of changes and fixes.. I think https://github.com/dvdbot/graphql-dotnet/blob/3fda05fcbe4f480e54f63c35d9043f9c9959deb1/src/GraphQL/TypeExtensions.cs#L135-L149 can be merged like this:\nc#\nif (typeof(IEnumerable).IsAssignableFrom(type))\n{\n    var elementType = type.IsArray ? type.GetElementType() : type.GenericTypeArguments.First();\n    var graphElementType = GetGraphTypeFromType(elementType, isNullable);\n    var listType = typeof(ListGraphType<>);\n    graphType = listType.MakeGenericType(graphElementType);\n}. Actually I forgot that string implements IEnumerable, so a more correct version would be\nc#\nif (typeof(IEnumerable).IsAssignableFrom(type) && type != typeof(string))\n{\n    var elementType = type.IsArray ? type.GetElementType() : type.GenericTypeArguments.First();\n    var graphElementType = GetGraphTypeFromType(elementType, isNullable);\n    var listType = typeof(ListGraphType<>);\n    graphType = listType.MakeGenericType(graphElementType);\n}. This pr was closed a long time ago, but I think it has some good ideas that should be considered again. In particular, a less complex inheritance chain.\nSomething like:\n```c#\npublic class ResolveFieldContext\n{\n    //...\n    public object Source { get; set; }\n}\npublic class ResolveFieldContext : ResolveFieldContext\n{\n    public new TSource Source { get => (TSource)base.Source; set => base.Source = value; }\n}\n```\nThis would increase flexibility in cases where the exact type isn't known / necessary.. Yes\ngraphql\nquery GetAccounts {\n  A : account(name: \"Account_0\") { \n    name \n  }\n  B : account(name: \"Account_2\") {\n    name\n  }\n}. Interesting.\nOperation_Can_Be_Cancelled test seems to be failing on appveyor.\nWhen running tests locally, it passes just fine.\nprints_multiple_interfaces test however fails sometimes.\nIt appears to be a race condition, sometimes resulting in \n```\ntype Bar implements Foo, Baaz {\n  str: String\n}\ninterface Baaz {\n  int: Int\n}\n```\nand sometimes resulting in \n```\ninterface Baaz {\n  int: Int\n}\ntype Bar implements Foo, Baaz {\n  str: String\n}\n```. I like the idea of option 2.\nSomething like: \n```c#\npublic class OperationMessage\n{\n    public string Id { get; set; }\n    public string Type { get; set; }\n    public object Payload { get; set; }\n}\npublic class OperationMessage : OperationMessage\n{\n    public new TPayload Payload \n    { \n        get => (TPayload)base.payload; \n        set => base.payload = value; \n    }\n}\n```\nAnd then we can use the IDocumentWriter to serialize it in the WebSocketWriterPipeline.\nhttps://github.com/graphql-dotnet/server/blob/develop/src/Transports.Subscriptions.WebSockets/WebSocketWriterPipeline.cs#L51-L82. IIRC, if you close and re-open the PR a new build will trigger.. I suggest adding the ability to write to JObject. Currently Server is using Server is using JObject.FromObject() which can make subscription results look different from query/mutation results. If IDocumentWriter can write JObjects, it should be easy to fix.. It seems that a test is failing, specifically GraphQL.DataLoader.Tests.SimpleDataLoaderTests.Operation_Can_Be_Cancelled. I ran into that specific test randomly passing and failing. I think there is a race condition in the tests somewhere.. I suggest creating a class that inherits from DocumentExecuter and overrides the SelectExecutionStrategy() method.. In my team we use a graph database (CosmosDB in our case), and instead of going through the resolvers recursively, we only resolve the top-level resolver, and in that we use the AST to create a Gremlin query that fetches all the data we need in one go.\nThis has the benefit of being very effecient for joins like this, however it negates the smart flexibility that GraphQL provides with the resolver model.. Also there is the Dataloader.. This may be related to #815. You could try checking out the repo using that as reference instead of the nuget package to test if it was fixed by #815.. Here is some reading material on the subject:\n\nhttp://fiyazhasan.me/tag/graphql-dotnet/\nhttps://fullstackmark.com/post/17/building-a-graphql-api-with-aspnet-core-2-and-entity-framework-core. Then you can use the same approach as me (although it's not documented anywhere).\n\nWhat I've set up is a service can traverse the entire AST and then translates it into another query language (in my case, Gremlin, but you'd use SQL).\nThen I use that service in my root resolver to fetch the data.\nI'm not sure how well that would work with a regular SQL database though, as joins can become quite expensive.. Not that I've seen, but I initially started doing it that way to take advantage of the Gremlin language for traversals with better performance than SQL joins.\nThe execution flow is something like this, though this is an old version:\nhttps://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgcGFydGljaXBhbnQgY2xpZW50IGFzIFJlYWN0IENsaWVudFxuICAgIHBhcnRpY2lwYW50IHdlYiBhcyBXZWJDb250cm9sbGVyXG4gICAgcGFydGljaXBhbnQgZ3FsIGFzIEdyYXBoUUwgZG90bmV0XG4gICAgcGFydGljaXBhbnQgdHJhdmVyc2VyIGFzIEdyYXBoUUwgVHJhdmVyc2VyXG4gICAgcGFydGljaXBhbnQgbm9kZSBhcyBHcmFwaFFMIE5vZGUgVmlzaXRvclxuICAgIHBhcnRpY2lwYW50IGV4dHJhY3QgYXMgR3JhcGhzb24gVHJhdmVyc2VyXG4gICAgcGFydGljaXBhbnQgZ3JhcGhzb25Ob2RlIGFzIEdyYXBoc29uIE5vZGUgVmlzaXRvclxuICAgIHBhcnRpY2lwYW50IGNvc21vcyBhcyBDb3Ntb3NcblxuICAgIGNsaWVudC0-PndlYjogR3JhcGhRTCByZXF1ZXN0XG4gICAgd2ViLT4-Z3FsOkdyYXBoUUwgc3RyaW5nICYgdmFyaWFibGVzXG4gICAgZ3FsLT4-Z3FsOiBWYWxpZGF0ZSBzeW50YXhcbiAgICBncWwtPj50cmF2ZXJzZXI6IEdyYXBoUUwgYXN0XG4gICAgbG9vcCBFdmVyeSBub2RlXG4gICAgICAgIHRyYXZlcnNlci0-Pm5vZGU6IEdyYXBoUUwgbm9kZVxuICAgICAgICBub2RlLT4-bm9kZTogVmFsaWRhdGUgc2VtYW50aWNhbGx5XG4gICAgICAgIG5vZGUtPj50cmF2ZXJzZXI6IEVycm9yc1xuICAgICAgICBub2RlLT4-bm9kZTogVHJhbnNsYXRlIHRvIGdyZW1saW5cbiAgICAgICAgbm9kZS0-PnRyYXZlcnNlcjogR3JlbWxpbiBzdWJzdHJpbmdcbiAgICBlbmRcbiAgICB0cmF2ZXJzZXItPj5ncWw6IEVycm9yc1xuICAgIHRyYXZlcnNlci0-PmNvc21vczogR3JlbWxpbiBxdWVyeVxuICAgIGNvc21vcy0-PmV4dHJhY3Q6IFJlc3VsdCBpbiBncmFwaHNvblxuICAgIGxvb3AgRXZlcnkgbm9kZVxuICAgICAgICBleHRyYWN0LT4-Z3JhcGhzb25Ob2RlOiBHcmFwaHNvbiBub2RlXG4gICAgICAgIGdyYXBoc29uTm9kZS0-PmdyYXBoc29uTm9kZTogUGFyc2UgYXMgZW50aXR5XG4gICAgICAgIGdyYXBoc29uTm9kZS0-PmV4dHJhY3Q6IEVudGl0eVxuICAgIGVuZFxuICAgIGV4dHJhY3QtPj5ncWw6IEVudGl0aWVzXG4gICAgZ3FsLT4-d2ViOiBKc29uIHJlc3BvbnNlICsgRXJyb3JzXG4gICAgd2ViLT4-Y2xpZW50OiBKc29uIHJlc3BvbnNlICsgRXJyb3JzIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0. This is not the repository for GraphQL in node.js, but rather in C#/.NET.\nI suggest you find the community for the GraphQL package you're using and post the question there.\nIs it Apollo Server?. In terms of GraphQL --> Gremlin there is https://github.com/apache/tinkerpop/tree/master/gremlin-dotnet\nSpecifically for CosmosDB there is https://github.com/evo-terren/Gremlin.Net.CosmosDb which makes creating traversals a bit easier, not to mention type-safe.. Also relevant: #831. I'm not quite sure I'm allowed to, we have talked a bit about open sourcing at my job, but it's not something that has amounted to anything yet.\nI can say though, that I'm working on making Gremlin.Net.CosmosDb suitable for GraphQl -> Gremlin conversion.\nA few small pointers:\nFor queries, what I do is simply create a traversal that reaches the same entities as the GraphQl does and then use the tree() step.\nExample:\ngraphql\nquery GetPersonTransactions {\n  people {\n    name\n    purchased {\n      id\n      price\n    }\n    sold {\n      id\n      price\n    }\n  }\n}\nWould translate roughly to\ngroovy\ng.V().has('label', 'person')\n  .union(\n    OutE('purchased').InV(),\n    OutE('sold').InV()\n  ).tree(). Just got back from sprint start and talked to my boss about open sourcing. He said that he liked the idea, but he'd have to take it further up the chain to see if it's okay legally.. Well, the higher ups have asked my team to compile a pros and cons list pf open sourcing, which I think will be discussed in january at some point (hopefully). If we are able to convince them that open sourcing is the way forward I'd have to take some time to actually prep the repo (lot of undocumented code and structures I've since come to regret.) for being published. I have no idea how long that would take, but I'll post again when I know what the future holds. Until then I'd be happy to discuss architecture. :). I second @rose-a question about the inheritance chain.\n```c#\npublic class ResolveFieldContext\n{\n    //...\n    public object Source { get; set; }\n}\npublic class ResolveFieldContext : ResolveFieldContext\n{\n    public new TSource Source \n    { \n        get => (TSource)base.Source; \n        set => base.Source = value;\n    }\n}\n```\nIf we design it like this, we can make generic (in the Source-type agnostic sense) solutions by creating solutions for the ResolveFieldContext.\nI think it would simplify the code.. You could probably achieve this with extensions.. I haven't played with it myself, but as you can see here, the extension field is added. I think it's on the ExecutionResult.. A quick search revealed this:\nExecutionResult#L26\nc#\npublic Dictionary<string, object> Extensions { get; set; }\nTry adding your meta data to that dictionary.. How about ListGraphType<ListGraphType<IntGraphType>>?. Maybe go the extra mile and also print the name of the type and field? :). I rebased onto master and moved potential exceptions out of the object initializer.. This might very well be the case. Then maybe the WriteToJObjectAsync method shouldn't be included in order to not encourage it? Sorry for leading you out on a wild goose chase here. \ud83c\udf55 . ",
    "ffalsino": "Hello @joemcbride \nCan you please post a simple code example about how to use\nhttps://graphql-dotnet.github.io/docs/getting-started/field-middleware  ?\nThank you so much. ",
    "philosowaffle": "+1 for adding support for comments to parser. ",
    "MisinformedDNA": "Also, if you know if any tutorials that explain what the heck yarn and webpack are doing, that'd be great. Because this is all voodoo to me. :). The question isn't if someone wanted it, the question is if it belongs and provides additional value. If you aren't sure what value it provides, you should consider either finding out what/if any value it provides or deprecate it. Just my 2 cents.. ",
    "andrewrudman": "Thanks Joe! After your suggestion to look at Startup i noticed that i was\nmissing the StarWarsMutation...scratching my head a bit because i'm pretty\nsure i copy and pasted from your solution...but anyway it works now.\nOn Fri, Dec 15, 2017 at 11:26 AM, Joe McBride notifications@github.com\nwrote:\n\nI just double check that that exact mutation works in the sample app and\nit does. So must be something different you have in your setup.\nhttps://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.\nGraphiQLCore\nPerhaps missing that class in your container?\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/\n9ec880761ec5785ff1473c3fe638bf53455f442c/src/GraphQL.\nGraphiQLCore/Startup.cs#L20-L29\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/501#issuecomment-351877312,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHjMYwVelMDOvugRVY9NdMBg4mPi_1Q3ks5tAbzTgaJpZM4RC144\n.\n\n\n-- \nRegards,\nAndrew Rudman\nandrewrudman@gmail.com\n. User error. Joe saved the day.. ",
    "sudhabt": "@joemcbride\nis there a way to add annotation based authorization, instead adding to every field/type, like [authorize] in asp.net MVC ?. ",
    "drowhunter": "This works well, but what would you suggest for this scenario\nI have a type with three fields\neach field requires a different policy\nright now if any of the fields I access fails it throws an error for the whole thing.\nWhat i would like is that any field that doesn't pass the policy just return null or default.\nwould this require custom field middleware?. also what if i want to remove one of the autogenerated fields. it seems that when poco contains an enumeration it doesnt map correctly.  And without a way to override field you cant correct it. \nI think im starting to understand why this class is undocumented.. I looked at the source code and realized that before you mentioned it.  Is this documented anywhere?\nAnd I added generic versions of the register and get method and submitted a pull request\nPull Request - Generic versions of Register and Get Methods\nI put the following code into my project in the StartUp\nGraphTypeTypeRegistry.Register<MyEnum,MyEnumGraphType>();. Are you aware of the GraphQL Library called HotChocolate  ?\nthe way they handle overriding field is the following\n\nrather than configuring your fields in the constructor, you configure them by overriding the Configure() Method\nthere is a property you can set which turns autogeneration on or off in the constructor\nany fields defined in override will use that implementation instead of being auto generated\nadding Ignore on to the field causes that property to be  skipped when auto generating\n\ncode sample\npublic class PersonType : ObjectType<Person>\n{\n    protected override void Configure(IObjectDescriptor<Person> desc)\n    {\n        desc.Field(t => t.FriendIds).Ignore();\n        desc.Field<PersonResolver>(t => t.GetFriends(default, default));\n    }\n}\nDocumentation\nI may try to do something like this on my fork. Because as it is the autogeneration isn't very useful, as I do not want to expose every single field, or may need to override a field so that i can use a custom resolver. I am currently in the process of choosing which project to go with for my graphql server and it was a very close race between this and hot chocolate,  but this library won out because it is more streamlined with the way the resolvers are defined and handles asynchronous methods better.\nThe auto resolve is the only area in which Hot chocolate is better.. oh and i just noticed that you accepted my pull request? how long before it shows up on the nuget package ?\n. curious , how long does it take before commits merged into master hit the nuget package? is it right away?. good to know thanks. damn i didn't mean for global.json to be included but it wouldn't build for me unless i updated the sdk version. i did not know that.   i just rolled back the file\n. what is this dotnet boxed project for? looks interesting. I was concerned that removing fields is only something that made sense in context of auto generated fields.  but I can move it down there. sorry could you elaborate on what you mean by a method that handles this specific behaviour?\nDo you mean i should do this instead\n```\npublic class User\n{\n        public int UserId { get; set; }\n        public string Firstname { get; set; }\n        public string Lastname { get; set; }    \n }  \n// override the UserId name and resolver\nGetField(f => f.UserId).Name(\"id\").Resolve(c =>23456);\n// remove the Lastname\nRemoveField(f => f.Lastname);\n//or you can do this\nRemoveField(\"Lastname\");\n```\nthis way  the Field function can continue throwing exceptions in case of duplicate fields in all scenarios.. FYI I did it the first way because i was trying to replicate how HotChocolate handles this scenario, but second way works as well. ",
    "samueledirito": "Oooook, amazing! Thank you ;). ",
    "dustinsoftware": "Nvm, turns out the sample project has been replaced by\nhttps://github.com/graphql-dotnet/example-aspnetcore\n. Hi there! Unfortunately it looks like this change broke the GraphiQLCore project, which still relies on a project reference.. Hah, just saw this comment... never mind the PR I just opened :) . ",
    "glennblock": "@joemcbride thoughts?. @joemcbride verified that worked. Updated the code/tests. Thanks!. @pekkah @joemcbride adding setting the inner exception now, and added back the global.json.. \ud83d\udc4d \n. Thanks use to not wrap it but it was not working right. I wlll test again.. OK, will add it back. @joemcbride the point of this method is to allow nicer messages. In my case for example I am throwing a contextual message to the user. I didn't include the stack trace / inner exception for that reason. I guess one option is to have a switch that lets you decide if you want the inner exception.. ",
    "MartinDawson": "This seems to be due to graphQlQuery.Variables.ToInputs(); converting it to an array objects instead of array strings. Not sure why this is though.\nAt the moment I am doing inputs.Get<object[]>(\"artists\").Cast<string>();. This doesn't seem correct though.. @joemcbride var artists = inputs.Get<List<string>>(\"artists\"); still gives me the error:\n\nUnable to cast object of type 'System.Object[]' to type 'System.Collections.Generic.List1[System.String]'. @inputs Is of typeDictionary. I'm using [graphql-dotnet-relay](https://github.com/graphql-dotnet) library. It's because it can't castobject[]tostring[]`. @jquense Should the relay library handle list inputs?\n\nhttps://github.com/graphql-dotnet/relay/blob/master/src/GraphQL.Relay/Types/MutationInputs.cs\n```\npublic T Get(string key, T defaultValue = default(T))\n{\n    object value;\n    if (!TryGetValue(key, out value))\n        return defaultValue;\nreturn (T) value;\n\n}\n```\nHere's what I do at the moment: var artists = inputs.Get(\"artists\", new object[0]).Cast<string>();. I created an issue here as it's more of a graphql-dotnet-relay question. I know how to do it using standard graphql-dotnet.\nIt's mainly an issue with complex types for input in mutations.. ",
    "Themodem": "Sorry @joemcbride that seems to be the worst copy/paste ive done.\nIf this was looked at as REST then it could be something like this /api/heart/responses\nWhich would return\n{\n    \"responses\": [\n        {\n            \"user\": { OBJECT... }\n        }\n    ]\n}\nWhat i am trying to avoid if possible is massive root level queries for things like heartResponses heartSubmissions etc.\nIt would be much nicer to be able to group them to\nheart{\n    responses:[]...\n    submissions:[]...\n}\n{\n  \"heart\": { <-- API Group\n    \"responses\": [ <-- Controller\n      { \"date\": \"...\" }  <-- Response\n    ]\n  }\n}\nYes the Models.Heart.Response does have a user field.\ncsharp\nField<User>(\n    \"user\",\n    \"Response user\",\n    resolve: context => context.Source.User\n);\nThe cache works as expected and returns data.\n@kamsar Not sure what you mean by resolver. I can use Field<HeartQuery>().Name(\"heart\").Resolve(context => ... but not sure what I would resolve it to?. @joemcbride, @kamsar Thank you both, it now works as expected \ud83d\ude04 . ",
    "danielpox": "How is this applied to the Schema First approach?. ",
    "joeaudette": "I encountered this issue because I develop a set of loosely coupled components that I ship as nuget packages and I ship a project template that can wire up the various nugets depending on selected settings.\nSo for me having to have the main web app know that much about the nugets to create a query and schema for all the selected components didn't seem like a good idea. So I pondered a solution that allows me to create separate Query objects for each of my components (using the GraphType first approach) and automatically aggregate them into one Query and Schema in the app.\nI will explain my solution and hope to get some feedback on whether this is a reasonable idea.\nFirst I define a marker interface to decorate my component Query objects:\npublic interface IGraphQueryMarker\n{\n}\n\nThen I defined a component Query like this:\npublic class CoreQuery : ObjectGraphType<object>, IGraphQueryMarker\n{\n    public CoreQuery(\n        SiteService siteService\n        )\n    {\n        Name = \"CoreQuery\";\n\n        Field<ListGraphType<SiteInfoType>>(\n            \"sites\",\n            resolve: context => siteService.GetAllSites(context.CancellationToken)\n        );\n    }\n}\n\n\nservices.AddSingleton<IGraphQueryMarker, CoreQuery>();\n\nThen I defined a CompositeQuery that depends on an IEnumerable of IGraphQueryMarker\npublic class CompositeQuery : ObjectGraphType<object>\n{\n    public CompositeQuery(IEnumerable<IGraphQueryMarker> graphQueryMarkers)\n    {\n        Name = \"CompositeQuery\";\n        foreach(var marker in graphQueryMarkers)\n        {\n            var q = marker as ObjectGraphType<object>;\n            foreach(var f in q.Fields)\n            {\n                AddField(f);\n            }\n        }\n    }\n}\n\nSo I just inject my component queries as IGraphQueryMarker, and I have a CompositeSchema that uses the CompositeQuery\npublic class CompositeSchema : Schema\n{\n    public CompositeSchema(IDependencyResolver resolver) : base(resolver)\n    {\n        Query = resolver.Resolve<CompositeQuery>();\n    }\n}\n\nIt works, though of course I still need to try something similar for CompositeMutation.\nJust wonder does anyone see a problem with this approach?\nMy main goal is to keep my components loosely coupled while allowing them to be used in various combinations with GraphQL.. oops, posted on the wrong issue, meant to post on #565. I encountered this issue because I develop a set of loosely coupled components that I ship as nuget packages and I ship a project template that can wire up the various nugets depending on selected settings.\nSo for me having to have the main web app know that much about the nugets to create a query and schema for all the selected components didn't seem like a good idea. So I pondered a solution that allows me to create separate Query objects for each of my components (using the GraphType first approach) and automatically aggregate them into one Query and Schema in the app.\nI will explain my solution and hope to get some feedback on whether this is a reasonable idea.\nFirst I define a marker interface to decorate my component Query objects:\npublic interface IGraphQueryMarker\n{\n}\n\nThen I defined a component Query like this:\npublic class CoreQuery : ObjectGraphType<object>, IGraphQueryMarker\n{\n    public CoreQuery(\n        SiteService siteService\n        )\n    {\n        Name = \"CoreQuery\";\n\n        Field<ListGraphType<SiteInfoType>>(\n            \"sites\",\n            resolve: context => siteService.GetAllSites(context.CancellationToken)\n        );\n    }\n}\n\n\nservices.AddSingleton<IGraphQueryMarker, CoreQuery>();\n\nThen I defined a CompositeQuery that depends on an IEnumerable of IGraphQueryMarker\npublic class CompositeQuery : ObjectGraphType<object>\n{\n    public CompositeQuery(IEnumerable<IGraphQueryMarker> graphQueryMarkers)\n    {\n        Name = \"CompositeQuery\";\n        foreach(var marker in graphQueryMarkers)\n        {\n            var q = marker as ObjectGraphType<object>;\n            foreach(var f in q.Fields)\n            {\n                AddField(f);\n            }\n        }\n    }\n}\n\nSo I just inject my component queries as IGraphQueryMarker, and I have a CompositeSchema that uses the CompositeQuery\npublic class CompositeSchema : Schema\n{\n    public CompositeSchema(IDependencyResolver resolver) : base(resolver)\n    {\n        Query = resolver.Resolve<CompositeQuery>();\n    }\n}\n\nIt works, though of course I still need to try something similar for CompositeMutation.\nJust wonder does anyone see a problem with this approach?\nMy main goal is to keep my components loosely coupled while allowing them to be used in various combinations with GraphQL.. ",
    "omelhoro": "Ok I'll try it again. I remember that after copy & pasting the examples it didn't work without the metadata attribute.. @joemcbride You're right. Thanks! It works like you said. I've not used 'Query' as class name.\n  . Actually I noticed one other problem I had was the dependency injection, in something like that:\n```\n  public class Query\n  {\npublic IPlayerRepository PlayerRepository { get; private set; }\n\npublic Query(IPlayerRepository playerRepository)\n{\n  PlayerRepository = playerRepository;\n}\n\n[GraphQLMetadata(\"player\")]\npublic Players[] GetPlayers(int[] id)\n{\n  return PlayerRepository.GetByIds(id);\n}\n\n}\n``\nIt seems not to work that way. The executer says there's no path 'player'.\n. Thanks again!! I included the code you send, and what also was important was to include that lineservices.AddSingleton();`. Actually, I'm new to .NET and the DI  so I have no idea why this solves it. But maybe it would possible to somehow throw an error if no singleton for schema or query is configured?\n. ",
    "wa4-fearless-otter": "No, I'm requesting from react-apollo on my local machine. I use .NET Core on the server side.. Sorry, my fault. My endpoint couldn't accept variables as an object. Fixed it.. @jquense\nNow I see where I made the mistake. I have used this project as a template. My error handling now looks like this\nc#\nif (result.Errors?.Count > 0) {\n    returnValue = BadRequest(result);\n}\ninstead of returnValue = BadRequest();. My response body looks now like this\njson\n{\n    \"data\": {\n        \"hero\": {\n            \"id\": 1,\n            \"name\": \"San Holo\"\n        }\n    },\n    \"errors\": [\n        {\n            \"message\": \"Test-Error\"\n        }\n    ]\n}\nIs there a way to set id automatically to null when i add an error for this field?. @johnrutherford This works for me, thanks.\n@pouladpld I created an own issue for this: #564.. ",
    "enesdalga": "On the client side, After adding a review i will check the status code or error message but I forgot it. I can check this with HttpRequest header and response\n. ",
    "JonasZ95": "await Task.WhenAll(externalTasks.ToArray());\nYou can remove the ToArray() here aswell unless I'm wrong.. ",
    "SebastianStehle": "I tried to understand the code, but I don't get it yet. For me it seems, that the input is converted in this way JObject => Dictionary => AST Nodes => Objects\nseems to be very complicated, especially because JObject is more powerful and faster than the custom conversion and deserialization stuff. It also generates a lot of allocations right now.\nMy idea would be to convert everything to JObject instead and get rid of a lot of code.. The point is:  I don't want to write another serializer from Dictionary-tree to my class. I would just like to get the JObject that represents my object that is passed as variable to the mutation, but this does not work.\nI would also guess that the whole ObjectExtensions are not very fast, because the are based on reflection and not as flexible as JSON.Net.\nTherefore my idea is to get rid of Dictionary stuff and just use JObject and the Json.Net Serializer.. Basically I need\n  resolve: context =>\n        {\n            var human = context.GetArgument<JObject>(\"human\");\n            return data.AddHuman(human.ToObject<Human>());\n        });\n\nIf possible I also would like to skip the valdiation logic. I am writing a headless CMS: https://github.com/squidex/squidex and have custom schemas and validation logic. The query part of graphql already exists since several month, but I have a problem with mutations at the moment.\n     . This actually works, stupid me. But of course it is not optimal with a lot of conversion steps:\nStream => JObject => Dictionary => JObject\nThanks. Works fine, thx. I have a custom schema for my  JObjects. The schema could say that there is a field with name benutzer-stra\u00dfe. The field name is in German and contains the dash and the letter \u00df which should be replaced with ss. So to stay in your example it would become this schema.\ninput CreateInput {\n  benutzerStrasse: String\n}\n\ntype Query {\n  person(id: String): Person\n  createPerson(input:CreateInput): Person\n}\n\nIn my queries this mapping is easy to do with the resolvers, I can just change the field name with key.ToCamelCase().Replace(...) and it works fine. But for mutation I can not make this (reverse) mapping very easily. Because graphql-dotnet always uses the field Name to add the values to the dictionary. Of course I can process the input object in the mutation but I think it should be the responsibility of the input scheme to make this mapping.. Yes. The schema is not known at build time. Therefore I use the JObject for my data. The metadata approach is probably the same idea like my approach: To process the input Dictionary in my mutation-resolver.  You can use the metadata for that but I also have my custom schema, which I can use. But I think there should be something like a reverse-resolver for input types.. ",
    "hasibul2363": "@SebastianStehle \nCould you please share your solution, please. I am very new on GraphQL\nWhat will be possible queryArgument type.\nI am also interested to collect an anonymous object from the argument.\nnew QueryArguments(\n                        new QueryArgument<What will be type here> { Name = \"model\", Description = \"anonymous\" })\nStream => JObject => Dictionary => JObject\nIs it string or stream?\nExpecting your help.. @joemcbride \nThank you very much. It works for me.. ",
    "mvestergaard": "Test failure looks like a false positive to me. @joemcbride Any thoughts on this? Like I said, I'll happily submit a PR for this, but I'm unsure whether ordering was left out intentionally.. I don't know if you've tried looking at a root Query with several hundred fields. Unless they are ordered in a meaningful way, it's pretty difficult to find what you are looking for.\nAnd expecting developers to sort them manually at the time of definition is not really feasible.\nIf this is not something you wish to do by default. Could we at least add an ability to do it optionally?. I read the points made in the spec as, when you query something, the fields should appear in the order in which they were queried, which makes sense. But this issue relates to something else. It relates to order in which fields are output in the introspection information.. Just to clear that up even further. I'm only suggesting ordering the introspection data, not fields in results in general.. I went ahead and added a PR for this. The change should really be very harmless.. Test failure seems to be due to a flaky test. I'm confused as to whether I'm doing something wrong, or there are general issues with scalar types.\nI tried using the DateTimeGraphType, and I get similar issues:\nFor context, this is the exception. It's trying to resolve the scalar type from my DI container (Autofac) because the scalar type isn't registered by default:\nGraphQL.ExecutionError: The requested service 'GraphQL.Types.DateTimeGraphType' has not been registered. To avoid this exception, either register a component to provide the service, check for service registration using IsRegistered(), or use the ResolveOptional() method to resolve an optional dependency. --\n-> Autofac.Core.Registration.ComponentNotRegisteredException: The requested service 'GraphQL.Types.DateTimeGraphType' has not been registered. To avoid this exception, either register a component to provide the service, check for service registration using IsRegistered(), or use the ResolveOptional() method\n to resolve an optional dependency.. ",
    "jphenow": "I've been looking around for a bit for this exact thing. Thanks y'all! Excited for 2.0 - nice work on this lib.\n. Have you implemented a project that uses this form of paginatiton @joemcbride? Just hobbled through some errors to get it half-working, but was wondering if we could get an example? If that's tough for you in the next few days, I'll try to wrap up my attempts and push a PR - if there's issues we can fix there. Nope, sorry! I've been focused elsewhere in the last several weeks. If I can spend a few minutes I'll try to come back and see if it can at least have an example so it can easily plug in to Apollo - maybe Relay's that seems like more of an undertaking. . The purpose of the Stack was simply so any added classes that overlap would default to user-added while retaining the original (in case at some point the system would want to force the system-default) but that's overkill now that I say it loud - especially since it isn't currently doing that.\nAlright, yea, I'll switch it :-). Woot! Thanks!. ",
    "dylinmaust": "+1 - also interested in leveraging this technique. @jphenow Any luck with a connection implementation? I am struggling to get one setup but feel like I'm almost there.. ",
    "michaelkrog": "IMO the Best solution is to load the entity from the backend, patch the loaded object and then persist it. Then it will work no matter what backend the entity comes from.\nI created something similar for Json and Rest in Java. I did not want to use json-patch as I find it cumbersome. I just wanted to be able to send a partial model.\nCheck out https://github.com/michaelkrog/rest-patch. ",
    "LarsCelie": "Would be nice to have support for this \"out of the box\"\nCurrently we have a generic solution where we check which input types are supplied, and only apply those values to the domain entity.\nFieldAsync<ActivityType>(\n    \"createActivity\",\n    arguments: new QueryArguments(\n        new QueryArgument<NonNullGraphType<ActivityInputType>> { Name = \"activity\" }\n     ),\n     resolve: async context =>\n     {\n         var activityFieldInputArguments = context.Arguments[\"activity\"] as Dictionary<string, object>;\n         // patch your entity based on field inputs here\n     }. ",
    "aaronjedwards": "@joemcbride any thoughts on the issue? I am looking to solve the same problem. In the rest world I would take an incoming JObject from a PATCH request, patch an existing model and then persist the patched model. With an InputType model, I can't find a way to distinguish what has been explicitly set as null and what doesn't exist and is mapped as null with GetArgument. . @BenjaBobs @alexandercarls seems like you both have a similar approach. Would I need to have a dummy input type to capture the argument then?. @alexandercarls thanks for the help! For now I was able to deserialize as Dictionary<string, Object> as was suggested and patch in a similar way as I had before by converting the deserialized dictionary to a JObject with JObject.FromObject(deserialized), and then using the created JObject. My method of patching the model uses the JsonSerializer.Populate method. Not sure if I am doing myself injustice with that approach or not, but it works for now. I will look into using reflection as that may be a more reliable and effective way.. @BenjaBobs what do you mean/how do you generate your UpdateFoo DTO based on your Foo class if you don't mind me asking? . (sorry for all the questions) and do you use a non specific Schema Type for the fields? or do you somehow map the data class property type to one of the library provided Schema Types?. @johnrutherford @joemcbride I am also experiencing the same issue, I have followed the example in the documentation almost exactly without success. \nhttps://graphql-dotnet.github.io/docs/guides/dataloader.\nThis line:\nvar loader = accessor.Context.GetOrAddBatchLoader<string, MyModel>(...);\nResults in the following error: \nException has occurred: CLR/System.ArgumentNullException\nAn exception of type 'System.ArgumentNullException' occurred in GraphQL.dll but was not handled in user code: 'Value cannot be null.'\nThis is in reference to Context being null, but im unable to determine why. Any insight would be appreciated.\n. @johnrutherford I will be sure to post some code when i get the chance here in a few hours. I am running on .NET Core 2.1. Is there by chance a working example using DataLoader and .Net Core for reference?\nEdit: Im fairly certain I properly added the listener but will be sure to follow up.. ",
    "andrebts": "@aaronjedwards aproach worked for me. I'm using GetArgument<dynamic> and serializing it using JsonConvert.SerializeObject then by calling JsonConvert.PopulateObject I'm able to update only the fields that were informed.. ",
    "AndrewRissing": "@joemcbride \nThanks for the library, but I'd like to point out this change is more than an enhancement as well.  Since you're leveraging DI throughout the code, all of the public properties/fields you have exposed are fair game for a DI to go in and populate.\nI just spent a decent amount of time tracking down a bug that was attributed to such behavior, because the ObjectGraphType had a public property that the DI happily recognized and replaced.\nIf you don't expect someone to monkey with something outside of your internal code, I would highly stress that you shield it from the outside world.\nThanks. :). @joemcbride Sorry, I'll be more specific.  The ObjectGraphType.IsTypeOf was being matched by my DI and replaced with a different function.  Why my DI has that is another story...\nEither way, if you were to hide away all of the public properties/fields used only internally, it might prevent others from having to dig through things like I had to.. @joemcbride Ah, I see.  Np.  Thanks for the link.  I've got a clean enough workaround for now.. ",
    "ericnograles": "Good call @OneCyrus. No luck with upgrading to 2.0, but I'm just going to use the v0.17.3 branch for now till the latest gets stable. Thanks for the assist!. ",
    "Tochemey": "Hello,\nCan someone please guide us in how to implement the pagination feature in graphl?. . Hello,\nI have tried a direct request and I got the following error:\n{\n    \"errors\": [\n        {\n            \"message\": \"Object reference not set to an instance of an object.\"\n        }\n    ]\n}\nI am a newbie in graphql.. Hello Joe,\nPlease how do we solve this issue:\n{\n    \"errors\": [\n        {\n            \"message\": \"Expected non-null value, resolve delegate return null for \\\"$......TransactionType\\\"\",\n            \"code\": \"INVALID_OPERATION\"\n        }\n    ]\n}. I am able to figure out the issue. It was due to IoC registration. Some of my types were not registered. \nThank you very much.. ",
    "athurner": "A example of how to implement pagination would be very much appreciated. \nThank you. ",
    "denisedelbando": "i've implemented something but not utilizing the directives.\nhttps://github.com/denisedelbando/AspNetGraphQL/blob/master/Data/Schema/Type/CompanyType.cs\nI do it in the service layer\n. I thnk my issue is similar #828 \n. @BenjaBobs thank you. . So its either i use variables or resolve on my services layer (where it formats to return a dto). \nthank you.. Diving deeply into the issue, i now realized that the graphiql issue has a bug!\nthe enum being sent is wrong in graphiql (mind the letter i in between) is showing the \"overwrite\" but when i ignored the issue, it went through. I may have to investigate further on why this is..\n. i got it working. its a case of copying and pasting.\nthe name part i never bothered changing. i did not know it had to be unique everytime i create an enumgraphtype.\nforexample\n```\npublic class UserPropsEnumType : EnumerationGraphType\n    {\n        public UserPropsEnumType()\n        {\n            Name = \"userprops\";\n        }\n    }\npublic class EmployeePropsEnumType : EnumerationGraphType\n    {\n        public EmployeePropsEnumType()\n        {\n            //needs to change here\n            Name = \"employeeprops\";\n        }\n    }\n```\ni was using just name=\"props\" before so it was easy to miss this.. ",
    "DrSensor": "I also curious is it possible to implement multiple Query Arguments?\n\nExample\ngraphql\nquery getActors(\n    filter: {\n        movies_some: {\n            releaseDate_gte: \"2009\"\n        }\n    }\n    limit: 3\n    orderBy: name_ASC\n) \n{\n    name\n    movies {\n        title\n    }\n}\n. And where do I use variable result? . ",
    "ericklind": "Thanks for getting back to me Joe. I changed the DataViewInput to what you posted above.  I changed the mutation to this:\n ```\npublic class DataViewMutation : ObjectGraphType\n    {\n        public DataViewMutation(IDataViewRepository data)\n        {\n            Name = \"DataViewMutation\";\n        Field<DataViewType>(\n            \"createDataView\",\n\n            resolve: context =>\n            {\n                var dataView = context.GetArgument<DataViewInput>(\"dataView\");\n                Debug.WriteLine(dataView.ViewColumns);\n\n                return data.Query(new string[] { \"\" }, \"\");\n            });\n    }\n}\n\nBut I'm still getting errors:\n{\n  \"errors\": [\n    {\n      \"message\": \"GraphQL.Validation.ValidationError: Variable \\\"dataView\\\" cannot be non-input type \\\"DataViewInput\\\".\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 19\n        }\n      ]\n    },\n    {\n      \"message\": \"GraphQL.Validation.ValidationError: Unknown type DataViewInput. Did you mean \\\"DataViewQuery\\\" or \\\"DataView\\\"?\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 30\n        }\n      ]\n    },\n    {\n      \"message\": \"GraphQL.Validation.ValidationError: Unknown argument \\\"dataView\\\" on field \\\"createDataView\\\" of type \\\"DataViewMutation\\\".\",\n      \"locations\": [\n        {\n          \"line\": 3,\n          \"column\": 18\n        }\n      ]\n    }\n  ]\n}\n```\nThoughts?\nThanks,\nErick. So I need to create a DataViewInput and a DataViewInputType?  What should the definition of the DataViewInputType look like? Something like this?\n```\n    public class DataViewInputType : ObjectGraphType\n    {\n        public DataViewInputType(IDataViewRepository data)\n        {\n            Name = \"DataView\";\n        Field(r => r.ViewName).Description(\"ViewName\");\n        Field(r => r.ClientName).Description(\"Fields to pull from the database\");\n                    Field(r => r.ViewColumns).Description(\"List of view columns for the report.\");\n           }\n   }\n\n```\nI'm using graphiql, using this cdn: https://cdn.jsdelivr.net/graphiql/0.7.5/graphiql.min.js. I'm still getting errors, but I have to switch to another project. I'll swap out the graphiql next week and get back to you.  Thanks!. I'm not having any issues with the JSON. Variables are being deserialized properly and I can see them at the breakpoints. I have the code implemented per Joe's instructions but I am still getting the following errors:\n{\n  \"errors\": [\n    {\n      \"message\": \"GraphQL.Validation.ValidationError: Variable \\\"dataView\\\" cannot be non-input type \\\"DataViewInput\\\".\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 19\n        }\n      ]\n    },\n    {\n      \"message\": \"GraphQL.Validation.ValidationError: Unknown type DataViewInput. Did you mean \\\"DataViewQuery\\\" or \\\"DataView\\\"?\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 30\n        }\n      ]\n    }\n  ]\n}\nThoughts?. Here's the Schema:\npublic class DataViewSchema : Schema\n    {\n        public DataViewSchema(IDependencyResolver resolver) : base(resolver)\n        {\n            Query = resolver.Resolve<DataViewQuery>();\n            Mutation = resolver.Resolve<DataViewMutation>();\n        }\n    }\nHere's the mutation:\n```\n public class DataViewMutation : ObjectGraphType\n    {\n        public DataViewMutation(IDataViewRepository data)\n        {\n            Name = \"DataViewMutation\";\n        Field<DataViewType>(\n            \"createDataView\",\n            arguments: new QueryArguments(\n               new QueryArgument<NonNullGraphType<DataViewInputType>> { Name = \"dataView\" }\n           ),\n            resolve: context =>\n            {\n                var dataView = context.GetArgument<DataViewInput>(\"dataView\");\n                Debug.WriteLine(dataView.ViewColumns);\n\n                return data.Query(new string[] { \"\" }, \"\");\n            });\n    }\n}\n\n```\nHere's the DataViewInput:\npublic class DataViewInput\n    {\n        public string ViewName { get; set; }\n        public string ClientName { get; set; }\n        public List<string> ViewColumns { get; set; }\n    }\nAnd lastly, the DataViewInputType:\n```\npublic class DataViewInputType : InputObjectGraphType\n{\n    public DataViewInputType(IDataViewRepository data)\n    {\n            Name = \"DataView\";\n        Field(r => r.ViewName).Description(\"ViewName\");\n        Field(r => r.ClientName).Description(\"Fields to pull from the database\");\n        Field(r => r.ViewColumns).Description(\"List of view columns for the report.\");\n    }\n\n}\n```\nAlso, here are my entries in the Startup ConfigureServices:\nservices.AddScoped<IDataViewRepository, DataViewRepository>();\nservices.AddScoped<DataViewInput>();\nservices.AddScoped<DataViewInputType>();\nservices.AddTransient<DataViewType>();\nservices.AddScoped<DataViewMutation>();\nservices.AddScoped<DataViewQuery>();\n            . @joemcbride  I missed your post about the Name=\"DataView\". Changing that seemed to help, but now I'm getting an issue deserializing the variables using NewtonSoft.  It doesn't seem to like converting that to a dictionary which is weird because that part was working before, but now it's not. O_o\nAny idea why it would have an issue with the Variables property:\n[JsonProperty(\"variables\")]\npublic Dictionary<string, object> Variables { get; set; }\nAnd the variables from the query:\n{\\n  \\\"dataView\\\": {\\n    \\\"viewName\\\": \\\"v_ReadyReports\\\",\\n    \\\"clientName\\\": \\\"Suntime\\\",\\n    \\\"viewColumns\\\": [\\n      \\\"id\\\",\\n      \\\"product\\\"\\n    ]\\n  }\\n}\nthrowing this error:\n\"Error converting value \\\"{\\n  \\\"dataView\\\": {\\n    \\\"viewName\\\": \\\"v_ReadyReports\\\",\\n    \\\"clientName\\\": \\\"Suntime\\\",\\n    \\\"viewColumns\\\": [\\n      \\\"id\\\",\\n      \\\"product\\\"\\n    ]\\n  }\\n}\\\" to type 'System.Collections.Generic.Dictionary`2[System.String,System.Object]'. Path 'variables', line 1, position 360.\"\nThoughts?\nThanks,\nErick. Joe, I adjusted the Variables property to JObject and used the Deserializer code in the example and it's telling me that it cannot convert a JValue object to JObject for the Variables property.  Is there some other setting I need for the deserializer?\n. I can't fork it as it's company code. But here are the relevant bits:\n```\npublic class GraphQLQuery\n{\n    [JsonProperty(\"query\")]\n    public string Query { get; set; }\n[JsonProperty(\"variables\")]\n    //public Dictionary<string, object> Variables { get; set; }\n    public JObject Variables { get; set; }\n\n    [JsonProperty(\"operationName\")]\npublic string OperationName { get; set; }\n\n}\n```\nThe deserialization code:\npublic static T Deserialize<T>(Stream s)\n        {\n            using (var reader = new StreamReader(s))\n            using (var jsonReader = new JsonTextReader(reader))\n            {\n                var ser = new JsonSerializer();\n                return ser.Deserialize<T>(jsonReader);\n            }\n     }\nThe call where it's crashing:\nprivate async Task ExecuteAsync(HttpContext context)\n        {\n            try\n            {\n                var request = Deserialize<GraphQLQuery>(context.Request.Body);\n//,....Other code\n}\n}\nAnd finally, the error message:\nInnerException: {System.InvalidCastException: Unable to cast object of type 'Newtonsoft.Json.Linq.JValue' to type 'Newtonsoft.Json.Linq.JObject'.\n   at lambda_method(Closure , Object , Object )\n   at Newtonsoft.Json.Serialization.ExpressionValueProvider.SetValue(Object target, Object value)}\n    Message: \"Error setting value to 'Variables' on 'Sift.GraphQL.Server.Common.GraphQLQuery'.\"\n    Source: \"Newtonsoft.Json\"\nI'll check out the other samples that you've suggested.. Hmmm....It is coming back as the second. It's from Graphiql:\n{\n  \"dataView\": {\n    \"viewName\": \"v_ReadyReports\",\n    \"clientName\": \"Suntime\",\n    \"viewColumns\": [\n      \"id\",\n      \"product\"\n    ]\n  }\n}. Here's the request:\n\"{\\\"query\\\":\\\"\\\\nmutation DataView($dataView: DataViewInputType) {\\\\n  createDataView(dataView: $dataView) {\\\\n    viewName\\\\n    viewColumns {\\\\n      columnName\\\\n      \\\\n    }\\\\n  }\\\\n}\\\\n\\\",\\\"variables\\\":\\\"{\\\\n  \\\\\\\"dataView\\\\\\\": {\\\\n    \\\\\\\"viewName\\\\\\\": \\\\\\\"v_ReadyReports\\\\\\\",\\\\n    \\\\\\\"clientName\\\\\\\": \\\\\\\"Suntime\\\\\\\",\\\\n    \\\\\\\"viewColumns\\\\\\\": [\\\\n      \\\\\\\"id\\\\\\\",\\\\n      \\\\\\\"product\\\\\\\"\\\\n    ]\\\\n  }\\\\n}\\\",\\\"operationName\\\":\\\"DataView\\\"}\"\nI'm using Graphiql 0.7.5. I tried using the latest, and it was causing some issues.  I give it another go.\nThanks for responding and being so helpful!. Okay, I dropped in the 0.11.11 version. I'm not getting the previous error, but now it deserializes to null.. Switch back to my previous deserialization with the JObject and it seems to be working.  Thanks! . Actually the mutation is not. :( Let me work through some of it.. Finally! Have it working as expected. Phew! Thanks Joe.. ",
    "JSanchezIO": "I think this also might be related to your variables not being sent over as a string. Variables should be posted over as a JSON string and then converted to Inputs using the .ToInputs() extension method.\ne.g. \njson\n{\n\"query\": \"mutation ($someVarName: DataViewInput!) { createDataView(dataView: $someVarName) { PROPERTIES_I_WANT_BACK_AFTER_MUTATION }}\",\n\"variables\": \"{'someVarName': { 'viewName': 'my-view', 'clientName': 'my-client', 'viewColumns': ['column1', 'column2' ] }\"\n}. You mind posting your mutation and input?. @joemcbride I thought string wasthe preferred type, for variables, followed by using the .ToInputs() extension method. Has that changed?. ",
    "kirill-chilingarashvili": "With latest GraphQL and request object as below, I was getting the same exception:\nc#\n       public class RequestVm\n        {\n            public string OperationName { get; set; }\n            public string NamedQuery { get; set; }\n            public string Query { get; set; }\n            public Dictionary<string, object> Variables { get; set; }\n        }\nThe fix was to change dictionary to JObject\nc#\n       public class RequestVm\n        {\n            public string OperationName { get; set; }\n            public string NamedQuery { get; set; }\n            public string Query { get; set; }\n            public Newtonsoft.Json.Linq.JObject Variables { get; set; }\n        }\nI also had to change \nc#\n                var inputs = query.Variables != null ?\n                    new Inputs(query.Variables) :\n                    new Inputs();\nto\nc#\n                var inputs = query.Variables.ToInputs();\n. ",
    "mRowlinson27": "We were not using InstrumentFieldsMiddleware, but changing all our GraphQl Types to being singletons seems to have stopped the count rising. Requires further testing to see if this will fix the stack overflow issue though, and still not 100% on whether this will lead to concurrency issues. Looks promising however. By looking at the graphql codebase, I noticed that if the schema is initialized before use the middlewareresolver class is never actually created. By doing this we seem to have solved the stack overflow issue, not sure if this solution would help anyone who actually has middleware in use though. ",
    "WiredUK": "For info, to solve a persistent StackOverflowException and degrading performance over time, I also had to disable field middleware. To do this, the code is essentially:\nvar result = await _documentExecuter.ExecuteAsync(options =>\n{\n    //Add this:\n    options.SetFieldMiddleware = false;\n\n    options.OperationName = query.OperationName;\n    options.Schema = _schema;\n    options.Query = query.Query;\n\n    /etc...\n});.\n",
    "Pets": "@johnrutherford Did you had the time to work on the documentation ? :)\nLike @PrimeHydra I'm super excited about this feature... but it's unclear for me how to work with it.\nThank you!. ",
    "sommarlov": "I've been using this and its fantastic so far. Great work!\nWhile waiting for the documentation, I have a question. Is there a way to do .LoadAsync() on a list of Ids? Lets say for example (looking at the unit test Types) that User already has the Order ids. In this case I would like to load the orders by a list of order ids instead of the User id.\nI hope my explanation makes sense, thanks!. @johnrutherford \nI think the documentation looks good! Just some code examples that uses tabs instead of spaces.\nI would love to see this added. :). Sorry, I meant the data loader's cache.\nTo me it looks like only LoadAsync is instrumented (fetch from data loader cache).\n. Thanks for this!. I'm closing this, it was fixed when I added IsTypeOf to my implementations and removed some registrations from my schema.\nMaybe this is not strange, but if have any fields in the graph that resolves an implementation of an interface (Field<SomeImplementationOfAnInterface>) , the implementations should not be registered on the schema with RegisterType or middlewares will ignore it for whatever reason. If I on the other hand only use the interface on fields (Field<SomeInterface>) , and never the implementation, I need to register it.. Thanks! That makes sense.\nI just found it a bit confusing that if I pre-registered a type (implementation of interface) that was later exposed in the schema, it would get ignored by the middlewares. Instrumentation middleware would skip that type and it's fields, for example.. Weird, I can currently go from having instrumentations to not having instrumentatioins for a type by just adding one line of RegisterType. That said, it may be my solution that is somehow causing this. I will try to recreate this in something less complex and get back to you if I find something.. ",
    "poulad": "I believe there should be another catch block to allow users define their own custom exceptions. Maybe using an ExecutionError.\nUsers should be able to define message, localtion and path for an error. Specs here.\nI'd prefer to derive from that class and make my own custom error to include more machine readable data like error type.\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/514fa76063c05cf3e4d60514c1b6eedb5ac69722/src/GraphQL/Execution/ExecutionStrategy.cs#L224-L233. Also, I'd prefer to derive from that exception class and make my own custom error to include more machine readable data like error type.. @joemcbride That's a good idea. I tried and there is a small problem.\nhere is my resolve func to get user by its username.\n```c#\npublic async Task GetUserAsync(ResolveFieldContext context)\n{\n    string username = context.GetArgument(\"id\");\n    UserEntity entity;\n    try\n    {\n        entity = await _userRepo.GetByNameAsync(username, cancellationToken: context.CancellationToken);\n    }\n    catch (EntityNotFoundException)\n    {\n        context.Errors.Add(new Error(\"not found\") // \"Error\" inherits from \"ExecutionError\"\n        {\n            Type = \"ID_ERROR\",\n            Path = new[] {\"user\"}\n        });\n        return default;\n    }\nreturn (User) entity;\n\n}\n```\nExpected\n\ndata should have value of null or could be omitted.\ntype of error\n\njson\n{\n    \"data\": null,\n    \"errors\": [\n        {\n            \"message\": \"not found\",\n            \"type\": \"ID_ERROR\",\n            \"path\": [\n                \"user\"\n            ]\n        }\n    ]\n}\nActual\njson\n{\n    \"data\": {\n        \"user\": null\n    },\n    \"errors\": [\n        {\n            \"message\": \"not found\",\n            \"path\": [\n                \"user\"\n            ]\n        }\n    ]\n}. In addition, how can I properly assign these 2 values to my exception from outside of ExecutionStrategy?\nc#\nerror.AddLocation(node.Field, context.Document); \nerror.Path = node.Path;. I'd suggest to add two more catch blocks to ExecutionStrategy:\nc#\ncatch (ExecutionError error)\n{\n    error.AddLocation(node.Field, context.Document); \n    error.Path = node.Path; \n    context.Errors.Add(error);\n    node.Result = null; \n}\ncatch (AggregateException ex)\n    when (ex.InnerExceptions.All(e => e is ExecutionError))\n{\n    context.Errors.AddRange(ex.InnerExceptions\n        .Select(error =>\n        {\n            error.AddLocation(node.Field, context.Document); \n            error.Path = node.Path; \n        }\n    );\n    node.Result = null; \n}\ncatch (Exception ex) \n{ \n    var error = new ExecutionError($\"Error trying to resolve {node.Name}.\", ex); \n    error.AddLocation(node.Field, context.Document); \n    error.Path = node.Path; \n    context.Errors.Add(error); \n    node.Result = null; \n}. maybe something like this would help:\nc#\nerrors.Apply(error => {\n  if (error.GetType() != typeof(ExecutionError))  {\n    string json = JsonConvert.SerializeObject(error);\n    writer.WriteRaw(json);\n    return;\n}\n// ...\nassuming that we use json attribs on error classes now.\n```c#\n// [json.OptIn, camelcased]\nclass MyCustomError : ExecutionError {\n// [json prop. default value - ignore]\n  string Type;\n}\n```. Oh. My bad. Thank you. Still learning the language.... ",
    "jinhong-": "Also, I want to point out that right now the resolver logic catches all exceptions and converts it to an item in the error list. I don't think this is the right move forward considering that all errors are now swallowed, which prevents the caller from further handling exceptions and processing them. One possible use case is this. In HTTP protocol, 4XX status codes represents client error. During resolution, in the event that something blows up. the entire exception gets swallowed and added into the Errors list. And if we're using the middleware, it would automatically return 4XX code. Which in most cases is incorrect since there are many reasons why. IE, database down, programming bug etc. and all these should never be 4XX but 5XX errors\nJust to summarize, i think not only should custom execution errors be provided, I think we should not be swallowing all Exceptions, but letting the higher layer handle it. I disagree. Have a read on HTTP Status codes: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\nAccording to HTTP specs, not REST specs, it is said that 4XX represents client side errors and 5XX represents server side errors.\nWhile I do agree with you that there could be potential scenarios that you might want to return partial results, that should be something that the developer should choose to handle. The library itself should not be concerned with catching all exceptions, just like it should not be concerned with handling transient faults and retries.\nI think there are a couple of ways to handle this. One is to remove the catch all exception handler and allow the user to throw their own Validation or Execution exception. Or we could just use the field middleware to handle the exception in a custom manner. I think the foundation is there. We just need to allow custom behavior and not swallow the exception. If this is the behavior we want for this library, then maybe we need to figure out custom handling for the graphql server instead. ",
    "dinoantonello": "We just upgraded to the latest version of graphql dot net have have noticed the code property in the error object is now moved to be wrapped in an extensions property object. This breaks a lot of code that we dont have access too as they are in our clients system.\nHow do we manage this in terms of backward compatibility? \nThere must be lots of other implementations who have clients who have existing code that is looking for the error code in the error object and not in extensions object. ",
    "tinganho": "@joemcbride I've tried with the namespace solution. Though, doesn't look so elegant, since it requires consumer of the API to namespace the queries as well?\nCan't you just add a feature to compose multiples Query classes?\ncs\nnamespace Starwars.Types\n{\n    public class StarwarsQuery : ObjectGraphType\n    {\n        public Query()\n        {\n            Extends(CharacterQuery);\n            Extends(DroidQuery);\n        }\n    }\n}\nIt stills conforms to GraphQL having only one root query.. ",
    "SapphireBrand": "Yes, the implementation is (well, some details are omitted, but basically...)\nc#\ncontext.GetArgument<List<long>>(\"ids\").Select(id => new Item(id))\nThat is, it returns an IEnumerable < Item >.. To select fields from a list of items. (Is that what you mean by \"end goal\"?)\nOr maybe I am just trying to figure out why the resolve argument is null when my field delegate has a list argument...\nWhen the argument to my FieldDelegate is a scalar, then the resolve function arguments are bound to the value of the argument:\nc#\n        // {item(id:30000000101){status}}\n        private Task<IItem> ItemResolveFunc(ResolveFieldContext context, long o)\n        {\n            return Task.FromResult(new Item(o));  // o is 30000000101\n        }\nBut when the argument is a list, then o is null:\nc#\n        // {items(ids:[30000000101,30000000202]){status}}\n        private IEnumerable<IItem> ItemsResolveFunc(ResolveFieldContext context, IEnumerable<long> o)\n        {\n            // o is null when this function is called, so I am pulling the arguments from the context\n            return from id in context.GetArgument<List<long>>(\"ids\")\n                   select new OrderedItem(id);\n        }\nI assumed that o is null because I don't know how to declare the resolver, but maybe that's not true. So why is o null when the resolve function is called for a FieldDelegate that has a list argument?\n. Matching by name! Right, that makes sense. And it happens that my resolvers for scalar GraphTypes all used the same name as the argument types, but my list resolver didn't.\nOK, so the \"yellow brick road\" is:\n\nname the delegate arguments to match the QueryArgument names\nthe delegate argument types match what you want to get in and out\nat runtime the MethodModelBinderResolver matches arguments by name\nat runtime, if the types of the supplied values do not convert then you get a runtime exception\n\nOne clarification, for the sake of future folks who find this answer on the Internet. It isn't the implementation function whose name matters; it is the resolve delegate:\n```c#\nFieldDelegate>(\n    \"items\",\n    arguments: new QueryArguments(\n    new QueryArgument>>> { Name = \"ids\", Description = \"list of ids the items\" }\n    ),\n// The argument whose name must match the QueryArgument is \"ids\" in the delegate here\nresolve: new Func<ResolveFieldContext, IEnumerable<long>, IEnumerable<IItem>>((context, ids)\n    => ItemsResolveFunc(context, ids)) // <-- declared in the line above as taking arguments (ResolveFieldContext, IEnumerable<long>) and returning IEnumerable<IItem>\n\n);\n```. This change is important to me, as I have a GraphQL server that I can't push into production until I have support for DateTimeOffset. I was about to propose the same thing. Good to see a proposal that is already in process.\n. Your proposal is to have seconds + fraction, which I assume is int64/double.\nYou might just send the double, as a number of seconds including fractional part.\nAlas, there isn't a great universal standard. The ISO 8601 \"Duration\" concept (https://en.wikipedia.org/wiki/ISO_8601#Durations) only seems to have one-second resolution.\nNodaTime has a serialization standard for duration that is worth looking at: https://nodatime.org/1.2.x/userguide/serialization. There is a serialization standard for that format.\nThe simplest is just to use ticks. The TimeSpan is internally an int64 counting \"tick\" units of 100 nanoseconds: https://msdn.microsoft.com/en-us/library/system.timespan(v=vs.110).aspx\nYour proposal at least has the advantage of being more powerful than any of these standards, so it will be inter-operable with just about anything.\nI haven't thought this over long enough to have an opinion yet. Gimme a couple of hours.\n-----Original Message-----\nFrom: Muhammad Rehan Saeed notifications@github.com\nTo: graphql-dotnet/graphql-dotnet graphql-dotnet@noreply.github.com\nCc: SapphireBrand sheppardco@aol.com; Comment comment@noreply.github.com\nSent: Wed, Jun 6, 2018 9:44 am\nSubject: Re: [graphql-dotnet/graphql-dotnet] Add support for Date, DateTime and DateTimeOffset (#662)\nOn the subject of representing TimeSpan in JSON. I feel we should probably default to using a scalar that outputs an integer showing the total number of seconds and provide an additional scalar using milliseconds that people can use for greater accuracy. Thoughts before I update the PR?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. OK for Int64 + milliseconds, but make sure that you can represent sub-millisecond resolution. That is, C# TimeSpan objects have 100 nanoseond resolution, and you would not want to create a new standard in the future when someone needs femtoseconds.\nThanks again for moving this forward.\nBest,\nBrian\n-----Original Message-----\nFrom: Muhammad Rehan Saeed notifications@github.com\nTo: graphql-dotnet/graphql-dotnet graphql-dotnet@noreply.github.com\nCc: SapphireBrand sheppardco@aol.com; Comment comment@noreply.github.com\nSent: Wed, Jun 6, 2018 11:42 am\nSubject: Re: [graphql-dotnet/graphql-dotnet] Add support for Date, DateTime and DateTimeOffset (#662)\nI would use Int64 for a seconds scalar and a second milliseconds scalar type.\nIt's not clear in the ISO 8601 standard but it does support milliseconds.\nI could be wrong but I think ticks are System.TimeSpan specific implementation detail.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Good point! I can do that. I should do that. I will do that.\nI will copy the current code from the PR, so that it is easy to adopt if the PR is released.\nI strongly recommend that you not remove support for dates. First: that is an annoying and disappointing breaking change. Additionally, I disagree with the philosophy. The fact that the code is extensible doesn't replace the fact that the library exists in order to be useful. After all, we don't need GraphQL.Net for extensibility! Our own code is already extensible!\nBest,\nBrian\n-----Original Message-----\nFrom: Joe McBride notifications@github.com\nTo: graphql-dotnet/graphql-dotnet graphql-dotnet@noreply.github.com\nCc: SapphireBrand sheppardco@aol.com; Mention mention@noreply.github.com\nSent: Wed, Jun 6, 2018 12:31 pm\nSubject: Re: [graphql-dotnet/graphql-dotnet] Add support for Date, DateTime and DateTimeOffset (#662)\n@SapphireBrand You can create your own custom Scalars.  You do not need this PR merged to support DateTimeOffset.\nThat is partially why this PR is not merged yet.  There seems to be a perception that you cannot write your own scalars.  All of these proposed types are not in the Core GraphQL spec.  Everyone is going to have their own preference on how dates and times are formatted.  I am partially leaning towards just removing Date all together and suggesting that people write their own Scalars and format them as they need.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I am missing one detail.\nIf a query root has an argument of type \"Date!\" then that will serialize from the client to the server in ISO 8601, which possibly has time zone information.\nThe current behavior of GraphQL.Net is to map that argument to DateGraphType, which does not have time zone information. For instance, I get an error message from GraphQL.Validation.Rules.VariablesInAllowedPosition:\n\"Variable \\\"$from\\\" of type \\\"Date!\\\" used in position expecting type \\\"DateTimeOffset\\\".\"\nI must have to register that Date maps to DateTimeOffset somewhere. How do I do that?\n(I am not requesting that this pull request map GraphQL's Date type onto C#'s DateTimeOffset, because that would be a breaking change, but it must be possible to do so or else the value of DateTimeOffsetGraphType would be limited.)\nThx. I agree with @rianjs regarding the use of TimeSpan.Zero in the DateTime to DateTimeOffset conversion. I wrote my own code for DateTimeOffsetGraphType, intending to use this pull request when it is merged, but now I realize that I would have to keep my own code because this implementation would not convert DateTime according to the ISO spec.. Oh, in the query. I can declare my arguments to be things that are not built into GraphQL. I didn't know that, but it's a useful feature. I will try that.. Declaring $from as a DateTimeOffset got past the first obstacle. Thank you for that pointer.\nThe query is right SearchDataContainerFromDateRangeResponse($from: DateTimeOffset, $to: DateTimeOffset) {...}\nThe variables are of type DateTimeOffset: { from = {5/23/2018 5:26:57 PM -04:00}, to = {6/5/2018 8:56:23 AM -04:00} }\nOn the server side, DateTimeOffsetValue.ParseValue() is now being called.\nProblem is that a DateTime is passed in (call stack below). So at some level there is a DateTime being created. Any ideas?\nVP.Fulfillment.Direct.Orders.Service.DateTimeOffsetGraphType.ParseValue(object value)\n    GraphQL.dll!GraphQL.Execution.ExecutionHelper.ValueFromScalar(GraphQL.Types.ScalarGraphType scalar, object input)\n    GraphQL.dll!GraphQL.Execution.ExecutionHelper.AssertValidValue(GraphQL.Types.ISchema schema, GraphQL.Types.IGraphType type, object input, string fieldName)\n    GraphQL.dll!GraphQL.Execution.ExecutionHelper.GetVariableValue(GraphQL.Language.AST.Document document, GraphQL.Types.ISchema schema, GraphQL.Language.AST.VariableDefinition variable, object input)\n    GraphQL.dll!GraphQL.Execution.ExecutionHelper.GetVariableValues.AnonymousMethod__0(GraphQL.Language.AST.VariableDefinition v)\n    GraphQL.dll!GraphQL.EnumerableExtensions.Apply(System.Collections.Generic.IEnumerable items, System.Action action)\n    GraphQL.dll!GraphQL.Execution.ExecutionHelper.GetVariableValues(GraphQL.Language.AST.Document document, GraphQL.Types.ISchema schema, GraphQL.Language.AST.VariableDefinitions variableDefinitions, GraphQL.Inputs inputs)\n    GraphQL.dll!GraphQL.DocumentExecuter.BuildExecutionContext(GraphQL.Types.ISchema schema, object root, GraphQL.Language.AST.Document document, GraphQL.Language.AST.Operation operation, GraphQL.Inputs inputs, object userContext, System.Threading.CancellationToken cancellationToken, GraphQL.Instrumentation.Metrics metrics, System.Collections.Generic.IEnumerable listeners)\n    GraphQL.dll!GraphQL.DocumentExecuter.ExecuteAsync(GraphQL.ExecutionOptions options)\n    mscorlib.dll!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Startd__8>(ref GraphQL.DocumentExecuter.d__8 stateMachine)\n    GraphQL.dll!GraphQL.DocumentExecuter.ExecuteAsync(GraphQL.ExecutionOptions options)\n. I confess that every question I have asked over the last few days has been because of problems in my own code. :-) I worked them out by cloning master and stepping through in the debugger. Understanding the problems in that way was both easy and enlightening, and I highly recommend the experience.\nI opened #693 thinking that this exception was related to how variables were converted into value types, but I was mistaken about that.\nIn the debugger, I found that this exception occurred because I had a DateTime field that was being pushed into the DateTimeOffsetObjectGraph value chain because I didn't declare something properly. I thought I had changed all of the DateTime fields to DateTimeOffset, but I missed one. The exception here went away after I declared my field as a DateTimeOffset.\nThere was actually a problem (also in my code) about how DateTimeOffset variables are converted into value types. So that is how #693 came to be opened and then closed.\nSo I am closing this issue.. OK, so this issue is outside the GraphQL code, I am leaving the solution here so that others can stumble upon the answer.\nThe GraphQL code does not deal with serializing the incoming message. Instead, your web app code has an object that represents the request payload, and a web framework constructs the payload by deserializing the request. For example, my code had the following:\n```\n        public class GraphQLDto\n        {\n            public string Query { get; set; }\n            public string OperationName { get; set; }\n            public JObject Variables { get; set; }\n        }\n    [Route(\"\")]\n    public async Task<HttpResponseMessage> PostAsync(GraphQLDto query)\n    {\n    }\n\n```\nSo the Web framework (System.Web.Http) is constructing a JObject from the request object, and it is the serialization settings from that conversion that need to be controlled in order to get dates to convert into DateTimeOffset.\nThe solution is to add the line below to the config for your web app:\nconfig.Formatters.JsonFormatter.SerializerSettings.DateParseHandling = DateParseHandling.None;\n(And you also need to declare your query arguments as DateTimeOffset, and define a DateTimeOffsetGraphType based on ScalarGraphType, and define a ParseValue member function that converts string to DateTimeOffset.)\nAn alternative is to set DateParseHandling.DateTimeOffset, but I think that is a subtle error. The key point is that the query knows the type of every variable, and the GraphQL engine will perform the right conversions internally. So it is best to use DateParseHandling.None (which leaves all dates as strings) so that the declaration of each variable will determine the type of parsing required.. I didn't find any problem that required changes to GraphQL.Net's serialization settings. IIRC, the default serialization settings convert dates into strings, which works fine whether the source is DateTime or DateTimeOffset.\nIf I find anything then I will post a question.. ",
    "ravgupms": "public class UserType : ObjectGraphType<User>\n{\n    public UserType()\n    {\n        Field(\"id\", x => x.Id).Description(\"Id of the user.\");\n        Field(x => x.Name);\n        Field(x => x.Address);\n        Field(x => x.Phone);\n        Field<UserSettingsType>(\"settings\", resolve: context => { ... });\n    }\n}\nIs there any way to write a single resolver for Name, Address and Phone fields? That way from top I can pass a dummy User object with only Id field populated and then make a network call to get other properties in case if anyone of them is requested?. Manually checking whether any leaf field of a type is requested or not at every level is a big overhead. \nWhat I'm looking for is some sort of lazy resolving(only the data fetching part). I think right now the library executes a parent resolver before iterating its children, right? If somehow we can delay its execution that would take care of my scenario. Correct me if I'm wrong.. Look like it generate grpah ql schema from .NET classes but I'm look for reverse of it.. But are there any plans to support something like this in the near future?. @elauffenburger : Even I want to have a look too.. @elauffenburger : Did you get a change get a PR out for you code changes?. ",
    "rose-a": "I noticed a strange interpretation of explicit null values when the concerning property is defined as a ListGraphType<someothertype>: It results in a System.Object[] containing one element which is null!\nIs this a behaviour desired?. I'm having this issue too. As stated above the documented way works fine with queries and mutations.\nBut with Subscriptions this does not work since it tries to resolve the Subscriber of the subscription field, and the subscriber then must call OnNext() when something in its child elements changes, which is not hooked up automatically.\nThe concrete RX subscription must be evaluated for each query, because simply aggregating them would result in all subscriptions firing every time one of them pushes something...\n@joemcbride Any idea how to create a TopLevelSubscriptionGraphType which could make this work?\n. I managed to get the grouped Subscription working like so:\nc#\npublic class TestSchema : Schema\n{\n    public UnitTestSchema(IDependencyResolver dependencyResolver) : base(dependencyResolver)\n    {\n        this.AddSubscriptionWithTopLevelGroup<TestSubscription>(\"test\");\n    }\n}\nThe used extension method:\n```c#\npublic static void AddSubscriptionWithTopLevelGroup(this Schema schema, string groupName) where TSubscription : ObjectGraphType\n{\n    if (schema.Subscription == null)\n        schema.Subscription = new ObjectGraphType { Name = \"Subscription\" };\nschema.Subscription.AddField(new EventStreamFieldType\n{\n    Name = groupName,\n    Type = typeof(TSubscription),\n    Resolver = new FuncFieldResolver<object>(context => context.Source as dynamic),\n    Subscriber = new EventStreamResolver<object>(ctx =>\n    {\n        // try to get the first selected field which contains a Subscriber and return the subscription to that\n        foreach (var selection in ctx.FieldAst.SelectionSet.Selections)\n        {\n            if (selection is Field field)\n            {\n                if (ctx.FieldDefinition.ResolvedType is ObjectGraphType graphType)\n                {\n                    var eventStreamField = graphType.GetField(field.Name) as EventStreamFieldType;\n\n                    if (eventStreamField?.Subscriber != null)\n                    {\n                        return eventStreamField.Subscriber.Subscribe(ctx);\n                    }\n                }\n            }\n        }\n\n        return null;\n    })\n});\n\n}\n```\nThis works for regular input, but I think this has lots of special cases where it could fail.\nMaybe someone with good understanding of the document execution process can implement this so that before throwing an exception here when no Subscriber is found the execution process tries to find a selected child which provides a Subscriber and forward that.. Well, it fails when you have arguments for your subscription query... those are not passed as Arguments to the subscribe method.... You can let Newtonsoft.Json do the conversion like so:\nc#\nvar personArg = ctx.GetArgument<object>(\"person\");\nvar person = personArg != null\n    ? JToken.FromObject(personArg).ToObject<Person>()\n    : null;\nWorks pretty well by default in most situations, you can even leverage a potentially already written custom JsonConverter for complexer objects.. Just to be thorough, here are some ready to use extension methods:\n```c#\npublic static class ResolveFieldContextExtensions\n{\n    public static TObject ConvertArgumentToObject(this ResolveFieldContext ctx, string argumentName)\n        => _convertArgument(ctx.Arguments, argumentName);\npublic static TObject ConvertArgumentToObject<TObject>(this ResolveFieldContext<object> ctx, string argumentName)\n    => _convertArgument<TObject>(ctx.Arguments, argumentName);\n\npublic static TObject ConvertArgumentToObject<TObject, TSource>(this ResolveFieldContext<TSource> ctx, string argumentName)\n    => _convertArgument<TObject>(ctx.Arguments, argumentName);\n\nprivate static TObject _convertArgument<TObject>(IReadOnlyDictionary<string, object> arguments, string argumentName)\n{\n    return arguments[argumentName] != null\n        ? JToken.FromObject(arguments[argumentName]).ToObject<TObject>()\n        : default;\n}\n\n}\n```\nto be used like this:\nc#\nvar person = ctx.ConvertArgumentToObject<Person>(\"person\");\n@joemcbride \nMaybe this could be delivered with the library? \nIs there a reason the generic ResolveFieldContext<TSource> does not inherit from ResolveFieldContext? This would eliminate the need of creating separate extension methods for them (not just in this case).... Dammit, I used the wrong query string variable... took me 2 hours and writing this issue to figure that out -_-. It sure is awaitable. It just forwards to the implementation below which accepts an ExecutionNode instead of an ObjectExecutionNode.\nSince there is no await used in forwarding to the other method, you don't need to use the async keyword. You just return the async Task created by the forwarded method.. ",
    "mrtoby": "Why not create a generic class, e.g. Optional (like in java) that can represent a present value (which could be null) and a absent value? Then you could add handling for this special type when parsing input types.\nI imagine something like\npublic class User {\n    public string Id { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\npublic class UserPatch {\n    public Optional FirstName { get; set; }\n    public Optional LastName { get; set; }\n}\nThen you use the User class for queries and mutations that create users, but the UserPatch class for mutations that can be used to update the first name, the last name or both.\nA workaround is to avoid using input types and rather just use plain arguments. You can see if an argument is provided or not and it can have the value null (I guess...).. Another idea: Implement the property setters so that they track if a value has been set or not.\nThis would relay on that GraphQL.NET not set null explicitly even if the field is absent in the mutation.\nSomething like:\npublic class UserPatch {\n    private string _firstName;\n    private string _lastName;\n    public bool HasFirstName { get; private set; }\n    public bool HasLastName { get; private set; }\n    public Optional FirstName { get _firstName; set => { HasFirstName = true, _firstName = value; } }\n    public Optional LastName { get _lastName; set => { HasLastName = true; _lastName = value; } }\n}\nUpdate: I tested this, and it works fine. I decided to go with a non-standard construction with a \"patch\" argument in stead of an \"input\" argument and the type \"UserPatch\" instead of \"UserInput\" since I need two input types. \nThe bad thing though, is that this depends on how GraphQL.NET works internally. The implementation could explicitly set all non-provided values to null, but it doesn't - and thus this works.. ",
    "elauffenburger": "I actually came here to ask this exact question!  I couldn't find a good solution, so I'm wrapping up something I've been working on.  It's...a bit of a hack as it requires dynamic type generation, but it fetches the remote schema and generates subtypes that just proxy through a JObject.\n@joemcbride: do you have any interest in me forking to show that work to see if want to take it over?\nOh, and great job on this library -- it's been really invaluable to me and the rest of my team!. Awesome! I'll get something together in the next day or two since I need to wrap this up, get it pulled out of my NuGet package, scrub it a bit (\ud83d\ude04), and get you a PR!\nIf I seem to fall off the face of the planet, it's probably because I'm dealing with some fire or something, so feel free to just message me \ud83d\ude04. @joemcbride: So I started porting my work over, and the only real issue I'm seeing is that I use some very Full .NET FX-y APIs like AppDomain.CurrentDomain or AppDomain.DefineDynamicAssembly, which is going to be a problem for netstandard2.0 and netstandard1.3 support.\nAny recommendations here? I'm thinking we could have framework-dependent implementations and inherit from the base type (letting each implementation figure out how it wants to support those APIs), but I think it's going to just straight up be an issue for anyone targeting netstandard2.0 or netstandard1.3.. Ah yeah, that makes total sense.  I didn't really even look into what was supported via Roslyn, but I imagine it's a lot :)\nI'll just get this up and then we'll figure out how to correct it.. @ravgupms Sorry! I've been a bit underwater at work, so I haven't had a chance to get it all up there yet. I'd like to throw at least a couple test cases out there to demonstrate usage. \nI'll try to get at it in the next couple days (assuming nothing else is on fire). @joemcbride @ravgupms: PR is up! Take a look to see what I'm thinking.  I mentioned it in the PR, but this is not prod ready but I'd reckon it's ~70% complete (I need to support union types and, like we talked about earlier, doesn't use Roslyn for codegen).. @joemcbride: can I revive this?  I'd love to get your input!. @joemcbride all good! Just wanted to keep the conversation alive :)\n@PascalSenn yep! But obviously just custom types (as in, types graphql.net isn't aware of by default). Awesome! I'm really glad this is gaining some traction (and thanks to @PascalSenn for such an in-depth analysis \ud83d\ude04)\nI actually have a number of changes and bug fixes that I need to merge into this PR (@OneCyrus has already found most of them!)\nI'll try to do that ASAP so no one is churning on this too much!\nCC @joemcbride . Hey guys, sorry I dropped off the face of the Earth; a bit busy at the day job :)\nI'd like to address the bugs here to unblock @onecyrus & co, so that'll be my first priority; I'll port everything over from our codebase to the PR and then address comments brought up here.\nThanks for everyone's support!\ncc: @joemcbride. Alright, I just kinda sat down and finally did it \ud83d\ude04\nLet's give it another look and try to wrap this in the next week or so!\ncc: @PascalSenn @OneCyrus @joemcbride . @OneCyrus: thanks for taking a look and for giving it a semi-\u2b50\ufe0f of approval \ud83d\ude04 \nSo to answer your questions:\n  - Arguments:\n    - I'll need to take a look at this -- I thought I implemented that, but I may have missed it...\n  - Unions:\n    - Yeah, I haven't really event given it a thought tbh; obviously we'll have to support it, so my best approach (off the top of my head) would be exactly what you suggested.  I don't think there's an issue with deserialization (since we really have no idea what the remote is returning us); i think the only challenges will come from supporting them from an \"infrastructure\" perspective (as in, we have to float the fact that these are unions along to field resolvers).  I don't think it will be too challenging to implemented\n  - Dynamic query builder:\n    - I don't have a good solution for this yet \ud83d\ude2d.  We've just been taking the selection set from the FieldAst and throwing that at the remote.. So, I'm going to recommend not merging this and actually aborting the PR.\nSince opening the PR I've heavily modified the implementation and dealt with issues like cyclical type dependencies across services, lazy loading, and schema synching.\nLong story short: it works but it feels gross\nI've recommended that the team using the implementation use it as a last resort to prevent breaking changes but not to consider it for new work unless absolutely necessary.\nCan this live as its own library: yes!\nDo I feel comfortable maintaining it: no :(\nLong story short: this will likely never be clean to implement in strongly typed languages and I wouldn't want to release this into the world without having a whole lot more confidence in it. \n@joemcbride What are your feelings here?. Awesome! Thank you!. @OneCyrus: fixed as part of my merges; thanks for the great find \ud83d\ude04 \n@PascalSenn: yeah, honestly I don't know the GraphQL spec well enough to know the right way to handle this.  I just know that it's supposed to be a unique value that serializes as a string -- any help would be appreciated here!. yep; you've got it -- it's to avoid name collisions.  This should be fixed as part of merging my changes in!. Again, great catch; this is fixed per my incoming fix commits. ",
    "wilsonrivera": "Sorry for the delay, I agree, no need. closing this pull request.. ",
    "nebushin": "My apologies, did not read the readme completely. Ran the npm install -g yarn, yarn install and yarn start and they ran fine.\nStarted the web project in Edge browser and still got the \"entities/maps/entites.json not found\" error. On a hunch, switched to chrome and the website started working. So, there might an issue with Edge.. ",
    "BenjaminHolland": "Nevermind. It doesn't work if I specify the type explicitly, but the type-parameterless Field function seems to work correctly.. ",
    "jweite": "Thanks Joe.  example-aspnetcore works fine.  I find it less useful to me as a study project, though, since the biz logic (StarWars) comes in via Nuget, and is therefore rather opaque.  But I'll learn what I need to from the predecessor project.. ",
    "PascalSenn": "Are you creating types for the whole remote schema?. @elauffenburger \nAlright. Alright. \nWe made some thoughts about this and there are many different ways to stitch a schema together and all with different ups and downs. \nThere is the way you chose which generates a schema based on the introspection. \nUps: \n- it gives the possibility to actually stitch a schema together. That means with some engineering you could also automatically merge types. \nDowns: \n- You have to resolve a type one each backend. What is an overhead.\nAnother way would be to create another ComplexGraphType in which you configure the endpoint, the prefix,  argument and a root query on the endpoint. \nThen on the introspection you just \"bubble\" up the introspection and decorate it with a prefix. The resolver also just bubbels the resolved json up. \nDowns: \n- You'd only be able to stitich together queries and not able to merge trees\nUps: \n- the resolving would be less cost intensive. \nConclusion: \nI guess it wouldn't be too bad to have both implementations at the end. Because the use cases are slightly different. What do you think @joemcbride ?\nSome follow up questions: \nHow hard is it to implement a dataloader in your solution? \nDo you prefix and translate types? \nHow about arguments?. @OneCyrus  \n\nYou can use the AstPrinter to Print a graphql query AstPrinter.Print(context.FieldAst.SelectionSet) \n. @OneCyrus\nFunny enough. I tried to get all variable references to pass down variables for stitching and was going to refactor ASTPrinter. Would have been a good moment to add a reverse printer.\nBut @joemcbride  showed me the BasicVisitor. \n\nI guess we could use something like this. \nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/690 \nJust pattern match around the different node types should do the job\nor make a generic AstPrinter so we can create one that works reversed\n. @joemcbride  should work. \nIf understand everything correctly (I've never actually build this pull request), it generates type and resolver for every field, therefore we have all types, therefor it should not be much work to merge those types. \nImagine this scenario\nRemoteField ListGraphType fetches all users.  users { username, emai}l\nExtendedGraphType defines a dataloader which fetchs the online status. user { online }\nIf we merge those two, it should be possible to do this: \ngraphql\n{\n    users {\n        username\n        online\n    }\n}\nI'm hyped! Great work @elauffenburger! \nCC @OneCyrus . @elauffenburger  \n\nDynamic query builder:\nThats basically what we are doing too.\nI just added #710 yesterday to support inline fragments in AstPrinter.\nWith BasicVisitor it's easy to walk down the tree and get all variable references used in the selection set. \nBased on that we can get all variable definitions that map with the variable references and add them to a new document. We can also add the operation name, type and the selection set. \n\nTo add the __typename's I've got a bit of a controversial idea. \nThe problem we face is, that we should not mutate the SelectionSet and I doubt it's easy to clone it. \nWe could just make this protected:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Utilities/AstPrinter.cs#L155\nCreate our own Printer that extends AstPrinter that automatically includes all typenames: \nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Utilities/AstPrinter.cs#L227-L234\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Utilities/AstPrinter.cs#L393-L399\nIf we request __typenames in the frontend and request them from the backend and then further from a remote schema, we would request them twice. But I guess that wouldn't really be a problem. If i request:\n\nI get the response type only once. \n\nI'm not sure if they acutally get resolved multiple times. But even if, there's little overhead and we could still check if the first item of a selection set is already a __typename. (So in deeply nested schemas we would request them only twice) \nMaybe @joemcbride  has a better idea. \nMaybe interesting for https://github.com/graphql-dotnet/graphql-client/issues/42 @deinok \n. Makes sense. I wouldn't order the inputs though. It's handy to do for example multi column orderings in the order they are defined in the request. . I'm not sure how this behaves, but have you ever tried to use a nullable type as the underlying list type?. Or just add a null check and return a empty list . It's just a way to work around this. If the list is null it also should return null I guess.. Try to specify the Name  property of the type.\n```\n    public GenericType()\n    {\n          var type =  typeof(T);\n          Name = $\"GenericType{type.Name}\";\n          foreach (PropertyInfo info type.GetProperties().Where(x => x.GetGetMethod() != null))\n               {\n\n```. Sweet!\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/Types/GraphType.cs#L9\n. as in #648 mentioned I like the idea of a property bag. \nIt'd be nice to pass it down as an object in resolvers. It'd also be nice if it's accessible inside the type tree. \nExample: \nQueryType -> FooType -> BarType -> FooBarType -> StringType\n  {   }           ->   {    }       -> { f: \"B\" }  ->  { f: \"B\" }      -> { f: \"B\" }   \nThat'd be a very handy way to pass down scopes of a request, specified as arguments. \ngraphql\nquery Sample($f: String!){\n    foo {\n        bar(f: $f) {\n            fooBar {\n                name\n            }\n        }\n    }\n}. @joemcbride\nI'd like to revive this. \nWhat about this scenario. Our API is scoped. We have an array of customers that we'd like to resolve. \nUnderneath the customer node we have a fairly deep graphql tree. \nAs far as i know the only way to pass down properties is to drill them down the tree.\ncsharp\n           FooBarModel  Customer(string customer).getFooBar();\n                    ->  FooBarModelDeep FooBarModel(string customer).GetFooBarModelDeep();\nThat leads to unnecessary models and a higher complexity over all. \ngraphql\nquery Sample($f: [String]){\n    foo {\n        customers(f: $f) {\n            fooBar {\n               fooBarDeep {\n                      name\n                   }\n            }\n        }\n    }\n} \ninput [\"FirstEntry\", \"SecondEntry\"]\nresult:\n```\n{\n   foo: {\n       customers: [\n          {\n               fooBar: {\n                    fooBarDeep: {\n                          name:\"FirstEntry\"\n                    }\n               }\n          },\n             {\n               fooBar: {\n                    fooBarDeep: {\n                          name:\"SecondEntry\"\n                    }\n               }\n          }\n    ]\n}\n\n}\n```\nIs there also already a way around it?. I know to ways to workaround this problem:\nUser Context\nYou can inject the IDependencyResolver into the user context. As far as the user context and the dependency resolver are scoped services, you can resolve dependencies in every field resolver. Not really a nice way, but it does the job\nIContextProvider (IHttpContextAccessor)\nThere is a way to request scoped services on demand with the IHttpContextAccessor. \nSample: \n```csharp\npublic interface IContextProvider<T>\n{\n    T Get();\n}\n\npublic class ContextProvider<T> : IContextProvider<T>\n{\n    IHttpContextAccessor contextAccessor;\n    public ContextProvider(IHttpContextAccessor contextAccessor)\n    {\n        this.contextAccessor = contextAccessor; \n    }\n\n    public T Get()\n    {\n        if(contextAccessor?.HttpContext?.RequestServices == null) {\n            return default(T);\n        }\n        return contextAccessor.HttpContext.RequestServices.GetService<T>();\n    }\n}\npublic class FooType : ObjectGraphType<Foo>\n{\n    private readonly IContextProvider<DependencyToResolve> _scopedServiceProvider;\n    public FooType (IContextProvider<DependencyToResolve> provider)\n    {\n        _scopedServiceProvider= provider;\n        Field<BarType>(\"bar\", resolve: x => _scopedServiceProvider.Get().Magic(x.Source.Bar));\n    }\n}\n\n```\nEDIT. @pekkah Totally agree with the user context.\nsure. What I meant to do:\ncsharp\n    public class FooType : ObjectGraphType<Foo>\n    {\n        private readonly IContextProvider<DependencyToResolve> _scopedServiceProvider;\n        public FooType (IContextProvider<DependencyToResolve> provider)\n        {\n            _scopedServiceProvider= provider;\n            Field<BarType>(\"bar\", resolve: x => _scopedServiceProvider.Get().Magic(x.Source.Bar));\n        }\n    }\nWhat could be nicer way of resolving dependencies in the schema was to have a provider bound to the HttpContext on ResolvedFieldContext. \nSomething like: \ncsharp\n    public class FooType : ObjectGraphType<Foo>\n    {\n        public FooType()\n        {\n            Field<BarType>(\"bar\", resolve: x => x.Get<DependencyToResolve>().Magic(x.Source.Bar));\n            // or\n            Field<BarType>(\"bar\", resolve: x =>(x.Get(typeof(DependencyToResolve)) as DependencyToResolve)?.Magic(x.Source.Bar));\n        }\n    }\n. Just read #637 \nMaybe we could combine that: \n```csharp\n    public class FooType : ObjectGraphType\n    {\n        public FooType()\n        {\n            // Resolves Dependencies\n            Field(\"bar\", resolve: x => x.Ressources.Request().Magic(x.Source.Bar));\n            // or\n            Field(\"bar\", resolve: x =>(x.Ressources.Request(typeof(DependencyToResolve)) as DependencyToResolve)?.Magic(x.Source.Bar));\n        // Reads data from property bag\n        Field<StringType>(\"foo\", resolve: x =>(x.Ressources.Get<string>(\"foo\"));\n        // or\n        Field<TType>(\"tFoo\", resolve: x =>(x.Ressources.TryGet<T>(\"foo\", default(T)));\n        // or\n        Field<StringType>(\"foo\", resolve: x =>(x.Ressources.Get(\"foo\"));\n    }\n}\n\n. I need to get all variable references from a query. \nProbably gonna make a pull request with a refactored AST printer. Gonna make it more generic.   \nAstPrintVisitor : AstVistor . That's.. \nyes, exactly what I was searching for \ud83d\udc4d  Thanks a lot !. That'd be good. \ud83d\udc4d \n. I guess the easiest way would be a immutable dictionary on the resolve field context and then just pass that dictionary down the tree. \nWould you accept a pull request?\nAnd if so, do you have any idea how to call that property.. naming's hard.. . Also: \nI'm not so sure about this linecsharp\nPopulateTypeMapping(LiteralGraphTypeMemberInfoType.Guid, typeof(Guid), CreateFieldType);\n``\nbecause a GUID is not certainly aIdGraphTypeas aIdGraphType` is not always a GUID\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/c4bc7ca006d3ab5d7e60089c12e8e7038ee3797f/src/GraphQL/Types/IdGraphType.cs#L27. ",
    "thivy": "@joemcbride any idea when this would be merged to the main branch?. @joemcbride thanks!\nHopefully this will get merged into master soon.. ",
    "meteor57": "Thank you for your good solution. Considering I've many queries or mutations per seconds (says 1M req/sec) and there are many GraphTypes (about 100 or more):\n\nAs IsTypeOf is checked for all types that implement the interface, using which method will have better performance (IsTypeOf or ResolveType)?\nIs there any performance difference between using type definition texts or directly inheriting and implementing ObjectGraphType objects?\n\nThank you for your help.. Thank you for mentioning helpful notes!\nYou saved me a lot of time \ud83d\ude0a \nAnyway, as a suggestion, it would be great if the ResolveType could be called just once for resolving a GraphQL interface object and could just accept the final GraphQL type name like \"Droid\" as a string.\nThis is how Apollo GraphQL Tools works:\nhttps://www.apollographql.com/docs/graphql-tools/resolvers.html#Unions-and-interfaces\n\ud83c\udf37. The scenario in my mind is that instead of defining a IsTypeOf method for all types, I could just use a single ResolveType method with a single line of code! The way I did it before in NodeJS using Apollo GraphQL Tools.\nIn that library, if you have a ResolveType method, when it wants to resolve the type of an interface, it just calls the ResolveType method once (so the time complexity is O(1)), however if you define IsTypeOf for each type, it needs to call it for all the types (until the right type is found)! so for n types, its time complexity is O(n).\nif we could do something like:\nBuilder.Types.For(\"Vehicle\").ResolveType = obj => obj.GetType();\nor as you noted:\nBuilder.Types.For(\"Vehicle\").ResolveType = obj => new GraphQLTypeReference(typeof(obj).Name)\nIn this way you can add any number of types without changing ResolveType method or defining IsTypeOf for them.. ",
    "dojo90": "Oh that's embarrassing! Yes that's right, of course!. ",
    "dvdbot": "Reboot of Visual Studio fixed it somehow\n. Can't access the class and method from my code, tried that yesterday. Can't do GraphTypeRegistry.Register(). Yeah I did - even tried in a class extending ObjectGraphType and tried it inside my Query class, can't access it. I'm using the latest graphql-dotnet inside my .net core project - so it should work fine, right?\nAlso, there's nothing in the GraphQL namespace I can access, only sub-namespaces\n. I can access the ***extension classes I think\n. Fixed the not being able to access the GraphQL namespace - I had a sub-namespace in my project x.y.GraphQL and somehow it conflicted - but I'm not seeing the GraphTypeRegistry yet. It was something with a conflict with namespaces even though one is GraphQL; and the other x.y.GraphQL; it conflicted.... Checking the version.... I have 0.17.3 (Latest Stable). Recommended to update to the alpha version?. Got access to it now, thanks :D. Where do I specify the name?\nAlready did it on the field. The first parameter for Field<>() is the name. Found it - setting the Name property in the constructor now\nJust noticed the changed code, thanks :D. It works!\n. Thanks for the help - this issue can be closed :D\nGot to <3 CodeShare :D. Yeah - noticed that one :P. This may have to be checked first - but seems like a good solution. ",
    "mrtes": "I have tracked down the issue to this line of code.\nAccording to spec, at this point, duplicate equivalent fields  (with sub selections) should be merged into one.\nI'm assuming that advanced field equivalence (i.e. are the arguments the same) is already checked during validation. This allows to merge the fields if the alias (if defined) and field names are equal.\nI'm going to add a PR for this soon.. Alright.\nI'll take a look at that bug first, and try to understand the Handler/Endpoints approach. Maybe I can do something about the documentation stuff too.\nAre there any contributor rules/guidelines for this repo?. Regarding AppVeyor:\nThe failing DataLoader test sometimes passes and sometimes fails on my machine.\nSeems to be a timing/concurrency issue?\n. Ok, I will try to clarify with some examples:\n```csharp\npublic class DroidType : ObjectGraphType\n{\n  public DroidType(IImportantBusinessObject object)\n  {\n    Field(x => x.Id).Description(\"The Id of the Droid.\");\n    Field(x => x.Name).Description(\"The name of the Droid.\");\n    Field(\n       \"manufacturer\", \n       resolve: context => {\n         // Here I can use both the context properties, as well as the IImportantBusinessObject methods.\n         // The IBusinessObject is injected for me by execution engine via my dependency injection \n         // framework.\n       });\n}\n}\npublic class StarWarsQuery : ObjectGraphType\n{\n  public StarWarsQuery()\n  {\n    Field(\n      \"hero\",\n      resolve: context => new Droid { Id = \"1\", Name = \"R2-D2\" }\n    );\n  }\n}\n```\nWith this \"old type\" schema, I can return my DTO (the Droid) from the field handler, and it will be wrapped into the DroidType by the execution engine.\nThe IImportantBusinessObject will be injected when the DroidType is generated.\n```csharp\npublic class Droid\n{\n  public Droid(IImportantBusinessObject object){\n    Object = object; // Injected 'manually'\n  }\n  private IImportantBusinessObject Object {get; set; }\n  public string Id {get; set; }\n  public string Name {get; set; }\n  public Manufacturer Manufacturer(MyUserContext context){\n    // Here I can use the methods of 'IImportantBusinessObject' or of 'MyUserContext'\n  }\n}\npublic class Query\n{\n  public Query(IImportantBusinessObject object){\n     Object = object; // Injected by my dependency injection framework\n  }\n  private IImportantBusinessObject Object {get; set; }\n[GraphQLMetadata(\"hero\")]\n  public Droid GetHero()\n  {\n    return new Droid(Object) { Id = \"1\", Name = \"R2-D2\" };\n  }\n}\n```\nWith the \"Handler/Endpoints\" approach, no types are generated by the execution engine, except for the top level types (e.g. query or mutation roots).\nThe object returned by the GetHero() method is directly used by the schema, without further wrapping. \nTherefore typical dependency injection frameworks are not applicable, except for the top-level types. \nInstead users have to inject these objects manually in the parent type.\nAlternatively, users can register all required methods in the user context, which can be injected into each resolver method, or make their required services static.\nThis brings me back to my question:\nWhich approach is recommended in the handler/endpoints implementation?\nOr am I misunderstanding something?\n. Thank you, that possibility was not obvious to me!\nI still don't really get why this works (especially the \u00ccsTypeOf registration). Maybe I have to take a look at the source :)\nAnyway, I see that you have added this scenario to the documentation (and tests), which should help clarify the issue for others :+1:\n. ",
    "joshkel": "Thanks!. ",
    "derwasp": "Hm. I didn't touch the code. Why did the test fail? Can you please try to restart the build?. @pekkah thanks. I just saw that I needed to rebase anyway, so that's what I did.. @joemcbride thank you for the merge!\nOne way around the limitation might be to just shovel everything to nuget ;). @joemcbride thank you for the merge! Can you please tell me when should I expect this version to be available on nuget?. ",
    "VVildVVolf": "Hello, thank you for the response. I would suggest to use the \u201ctodo\u201d statement instead of keeping warning, because of warning says \u201cthere is something bad\u201d, but todo says \u201cdo not forget to do this\u201d. About nulls - sorry, I have provided the bad link. The main idea is that this object is not reusable (at least because it is disposable). The appropriate way of using this object is using the \u201cusing\u201d statement (or kill it in another dispose call), so the code will not keep these links after dispose call, if it is written ok\nThank you, \nVVildVVolf. >> Using obsolete for obsolete methods is quite common and getting the warning about is quite useful so people know to migrate away from it.\nI understand. But we tald about keeping in memory to remove obsolete property. Users who use this property will see the warning and look for an workaround. There is the suggestion to suppress the warning only because we cannot do not use it, but to not forget to remome it there is the \"todo\" statement\nThank you,\nVVildVVolf. ",
    "dBug404": "I don't have a problem that the output will always be bool. \nMy problem is, that the input of \"1\" results in false and  both methods (serialize/parse) gets called, but the result of the serialize method is used.. You are right and in new code this is done. But in my case GraphQL is used on top of a bigger legacy backend so that is not really an option in the near future.\nIn most cases HttpContext.Current is abstracted via interfaces. So I could pass the HttpContext.Current via UserContext to the resolve methods and then override the standard DI registration for each specific DI resolution in the resolve method. \nBut in my opinion it would be preferable, if the user can configure if multiple threads are used or not.. I've created a simple app https://github.com/dBug404/graphql-dotnet-issue-795\nBoth projects can reproduce the issue. In graphql.web.simple I removed all StructureMap DI code.\nThe endpoint url should be: http://localhost:8153/api/graphql\nThere is a queries.txt file which contains the sample query with and without debug information.\n\nThe only place where the code does anything with Tasks is the func in the DataLoaderContextAccessor where I use Task.FromResult(...) to support non async methods in the backend. But this should not be responsible for starting new Threads, right?\n`\n        Field<DealerGraphType>(\"dealer\", resolve:\n            context =>\n            {\n                //return dealerService.GetDealer(context.Source.DealerId);\n                var loader = new DataLoaderContextAccessor().Context.GetOrAddBatchLoader<string, Dealer>(\"getDealerByDealerId\", dealerIds =>\n                {\n                    IDictionary<string, Dealer> dictionary = new DealerService()\n                        .GetDealers(dealerIds.ToList())\n                        .ToDictionary(dealer => dealer.DealerId);\n\n                    return Task.FromResult(dictionary);\n                });\n                return loader.LoadAsync(context.Source.DealerId);\n            });\n\n`\n. ",
    "wingsking": "I'm in the same boat with you @jinhong- \nI need to intentionally throw an exception so that my service can return 500 under some circumstances. The way I think how it should work is to provide a \"ThrowException\" swutch in ExecutionOption, just like \"ExposeException\". And it should check this inside the catch block to determine whether the non-ExecutionError exceptions should be swallowed or re-thrown.\nAlternatively, we can remove all catch blocks that catch general Exceptions, but keep the catch blocks that catch ExecutionErrors. In this way, if we want to handle the exception ourselves, we can throw a Exception; otherwise we can catch these exceptions ourselves, say in the resolvers, and turn it into ExecutionErrors which should be added to context.Errors.\nWhat do you think?\n. Please take a look at the PR when you have a chance. @pekkah @joemcbride . Sure, I will submit a PR soon, probably tomorrow.. Do you have any idea why it failed the check?. Hi @joemcbride , did you have a chance to take a look?. Hi @joemcbride, it's been awhile since I sent out this pull request. Do you have any concerns about this? Or if any changes I can make?. Thanks for looking into this. You should be good to go now.. There you go. The checks failed again.... ",
    "alexandervantrijffel": "It would be great if I can subscribe to an event similar to the AppDomain.UnhandledException event for any unhandled exception that is raised during a resolve. With such a callback, I would have a mechanism to log the unexpected exception.. ",
    "alexolex": "Thank you very much for your response!\nRegarding the error\n\nSo in your query you should be using Name instead of name, or change the field on Human to be name.\n\nI thought field names are camel-cased automatically, aren't they?\nAfter capitalizing first letters of field names, like this:\nvar mutation = @\"mutation ($human:HumanInput!){ createHuman(human: $human) { Name HomePlanet } }\";\n(same test can_add_new_human)\nit resulted in an error saying:\n\nError trying to resolve createHuman.\n\n(Although this time it enters the field's resolver, adds Boba Fett and fails somewhere afterwards).\nI will find time to debug it further.\nRegarding my case\nI do need to build a schema dynamically, since it depends on a data source which a query targets. Multiple data sources with different data schemas lead to the need to construct it dynamically.\nTo build a Query part of the schema I used the approach of instantiating a type and adding a FieldType with its ResolvedType set to that instance (there is only one type instance per a field, I am sure).\nAnd since that worked out as expected, I attempted to take the same approach while implementing a Mutation part.\nI will take a closer look at ComplexType, SchemaBuilder and GraphQLTypeReference as you suggested. Thank you.\nTell me please, are mutations supposed to work with a dynamically constructed schema the way I am trying to make them work?\n. @joemcbride You are exactly right. \nBy looking at source of the Schema and SchemaBuilder classes I finally understood how it works. \nThanks alot for your time and your efforts!\nFor those who may need it.\nI made it work by implementing own schema builder that:\n- keeps a dictionary of all dynamically instantiated types;\n- immediately calls schema.RegisterType for every newly added type;\n- and provides a GraphQLTypeReference instance for a field that needs a registered type.\nIssue's been resolved. Thanks! . We are using it heavily on production. graphql-dotnet framework is pretty friendly to use.. ",
    "mike-niemand": "Joe, thanks for this work\nI have a similar problem which I'm trying to wrap my head around: \n\n\"Cannot query field \\\"consultantId\\\" on type \\\"ConsultantInputType\\\". Did you mean \\\"consultantId\\\"?\"\n\nMy mutation looks like this: \nField<ConsultantInputType>(\n           \"toggleConsultantEnabled\",\n             arguments: new QueryArguments(\n                        new QueryArgument<NonNullGraphType<ConsultantInputType>> { Name = \"consultant\" }\n                ),\n                resolve: context =>\n                {\n                    var consultant = context.GetArgument<VMConsultant>(\"consultant\");\n                    practiceRepository.ToggleConsultantEnabled(consultant.ConsultantId, consultant.IsEnabled.Value);\n                    return consultant;\n                });\nConsultantInputType looks like this:\n```\n public class ConsultantInputType : InputObjectGraphType\n    {\n        public ConsultantInputType()\n        {\n            Name = \"ConsultantInputType\";\n        Field(x => x.ConsultantId);\n        Field(x => x.PracticeId, nullable: true);\n        Field(x => x.Firstname, nullable: true);\n        Field(x => x.Surname, nullable: true);\n        Field(x => x.Email, nullable: true);\n        Field(x => x.ContactNumber, nullable: true);\n        Field(x => x.Modified, nullable: true);\n        Field(x => x.Created, nullable: true);\n    }\n}\n\n```\nI suspect the problem is on my call to the mutation return as follows:\n```\nvar query = ' mutation ($consultant: ConsultantInputType!) {toggleConsultantEnabled (consultant: $consultant) {consultantId}}';\nvar variables = '{consultant:{consultantId: 42, isEnabled: 1}}';\n```\nBut it looks correct?\nEDIT:\nIn the mutation definition: Field<ConsultantType> is the 'OUTPUT' type.\n. OMW. Of course, apologies. Why is it that the longer you stare at something, the less you bloody see. . > Hello joemcbride, and thank you for your answer.\n\nConsidering this happens on all queries (of which there are dozens) regardless of the fields i'm trying to access, why would this be happening after i've upgraded the packet? The rest of the code was left the same as before the upgrade (when all queries worked correctly) which is the part that really confuses me.\nI have quite a limited lack of knowledge in regards to graphql, and I wasn't involved in setting the whole thing up for our project initially so there could definately be something i'm missing. Anyways, your help is very much appreciated.\n\nHey Coding, how did you solve this? I've run into the same problem after upgrading where if a query one field it throws this on another.. Thanks for the response Joe, it's much appreciated. I'm still having trouble even after defining Customer as typeof ObjectGraphType.\n_{System.InvalidOperationException: Expected non-null value, resolve delegate return null for \"$GraphQL.Types.ObjectGraphType`1[DelFornoAPI.Models.Customer]\"\n   at GraphQL.GraphQLExtensions.BuildNamedType(Type type, Func`2 resolve)\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable`1 types, IEnumerable`1 directives, Func`2 resolveType, IFieldNameConverter fieldNameConverter)\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\n   at System.Lazy`1.CreateValue()\n   at GraphQL.Types.Schema.get_AllTypes()\n   at GraphQL.Instrumentation.FieldMiddlewareBuilder.ApplyTo(ISchema schema)\n   at GraphQL.DocumentExecuter.ExecuteAsync(ExecutionOptions options)}_\nI'm not querying this type at all though?. I have the following registered in the schema:\npublic class CustomerType : ObjectGraphType<Customer>\n    {\n        public CustomerType()\n        {\n            Name = \"Customer\";\n            Field(x => x.CustomerId);\n            Field(x => x.Firstname);\n            Field(x => x.Surname);\n        }\n    }\nand\npublic class CustomerOrderType : ObjectGraphType<CustomerOrder>\n    {\n        public CustomerOrderType()\n        {\n            Name = \"CustomerOrderType\";\n            Field(x => x.CustomerOrderId);\n            Field(x => x.FranchiseId);\n            Field(x => x.Customer, true, typeof(ObjectGraphType<CustomerType>));\n        }\n    }\nWhich throws: \n_{GraphQL.ExecutionError: Expected non-null value, resolve delegate return null for \"$GraphQL.Types.ObjectGraphType`1[DelFornoAPI.GraphQL.CustomerType]\" ---> System.InvalidOperationException: Expected non-null value, resolve delegate return null for \"$GraphQL.Types.ObjectGraphType`1[DelFornoAPI.GraphQL.CustomerType]\"\n   at GraphQL.GraphQLExtensions.BuildNamedType(Type type, Func`2 resolve)\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable`1 types, IEnumerable`1 directives, Func`2 resolveType, IFieldNameConverter fieldNameConverter)\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\n   at System.Lazy`1.CreateValue()\n   at GraphQL.Types.Schema.get_AllTypes()\n   at GraphQL.Instrumentation.FieldMiddlewareBuilder.ApplyTo(ISchema schema)\n   at GraphQL.DocumentExecuter.ExecuteAsync(ExecutionOptions options)_\nI'm clearly confused as I don't understand why it's expected to be non-null?\n. Yes. That solved it and also taught me a little more about what you've done. Thank-you so much. What a great project.. I'm sure that would help. Was this a change implemented in 2.x? I had it working fine before I moved to 2.4 although this is a much better.. ",
    "r2o3k": "Disregard, we've managed to find a way to do this.. ",
    "peyoquintero": "Thanks Joe. Is 2.0 pre-release the TypeResolve branch?. ",
    "fiyazbinhasan": "Hi @joemcbride , what if I configure the default container the following way,\nservices.AddSingleton<StartWarsQuery>();\nservices.AddSingleton<ISchema, StarWarsSchema();\n\nAnd apply constructor injection to pass in the query or mutation,\npublic class StarWarsSchema : Schema \n{\n    public StarWarsSchema(StartWarsQuery query)\n    {\n        Query = query;\n    }\n}\n\nWill it be any different from,\nservices.AddSingleton(s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));. Got it. I was mixing it up with `Etag` related stuff. Thanks, @pekkah @johnrutherford for clearing it up.. got it. thanks \ud83d\udc4d .\n",
    "cphillips83": "I'm new to GraphQL and this library but I would have to agree if this is the case. The code below is the first piece of code I actually modified in the source to see what happens if I change it. I was confused (and still am) on what FieldDelegate is doing on the 2nd setup. So the first thing I did was rewrote the 2nd resolve: to match the first resolve (removed the func) and to my surprised it operated the same, so I still don't understand the difference of what is happening here.\n```\n    public class StarWarsQuery : ObjectGraphType\n    {\n        public StarWarsQuery(StarWarsData data)\n        {\n            Name = \"Query\";\n        Field<CharacterInterface>(\"hero\", resolve: context => data.GetDroidByIdAsync(\"3\"));\n        Field<HumanType>(\n            \"human\",\n            arguments: new QueryArguments(\n                new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\", Description = \"id of the human\" }\n            ),\n            resolve: context => data.GetHumanByIdAsync(context.GetArgument<string>(\"id\"))\n        );\n\n        Func<ResolveFieldContext, string, object> func = (context, id) => data.GetDroidByIdAsync(id);\n\n        FieldDelegate<DroidType>(\n            \"droid\",\n            arguments: new QueryArguments(\n                new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\", Description = \"id of the droid\" }\n            ),\n            resolve: func\n        );\n    }\n}\n\n```. ",
    "john1452": "Hi I am also interested in finding out how to use relay with Dataloader.\nI tried applying the current examples given in Dataloader documentation but I didn't get to far and received an error. I am hoping someone could point me into a right direction. \nIn the GraphQl.Relay.StarWars Project I tried updating the planet -> residents connection to use Dataloader\nfollowing is my attempt.\n```\nConnection()\n                .Name(\"residents\")\n                .Unidirectional()\n                .Resolve(ctx =>\n                {                 \n                    var context = (GraphQLContext)ctx.UserContext;\n                    var accessor = (IDataLoaderContextAccessor)context.ServiceProvider.GetService(typeof(IDataLoaderContextAccessor));\n                    var ordersLoader = accessor.Context.GetOrAddCollectionBatchLoader>(\"GetOrdersByUserId\",\n                        e =>\n                        {\n                            // mock list to simulate many people.\n                            var pplApi = new List { new People { Url = new Uri(\"https://swapi.co/api/people/1/\"), PlanetId = \"1\" }, new People { Url = new Uri(\"https://swapi.co/api/people/2/\"), PlanetId = \"2\" }, new People { Url = new Uri(\"https://swapi.co/api/people/3/\"), PlanetId = \"3\" } };\n                            // selecting from mock list the \"e\" parameter is a list of planets being sent from dataloader.\n                            var peoples = pplApi.Where(m => e.Contains(m.PlanetId)).ToList();\n                        // converting the results to a ILookup<string,Connection<People>> by using a dictionary.\n                        var dic = new Dictionary<string, Connection<People>>();\n                        foreach (var id in e)\n                        {\n                            var peopless = peoples.Where(m => m.PlanetId.Equals(id));\n                            var key = id;\n                            var connection = ConnectionUtils.ToConnection(peopless, ctx);\n\n                            dic.Add(key, connection);\n                        }\n                        //here we have the expected return type ILookup<string,Connection<People>>.\n                        var lookup = dic.ToLookup(x => x.Key, x => x.Value);\n\n                        return Task.FromResult(lookup);\n                    });\n                return ordersLoader.LoadAsync(ctx.Source.Id);\n            });\n\n```\nI am getting the following error.\nGraphQL.ExecutionError: Error trying to resolve edges. ---> System.InvalidOperationException: Expected\n to find property edges on Grouping`2 but it does not exist.\\r\\n   at \nGraphQL.Resolvers.NameFieldResolver.Resolve(Object source, String name)\\r\\n   at \nGraphQL.Instrumentation.MiddlewareResolver.Resolve(ResolveFieldContext context)\\r\\n   at \nGraphQL.Resolvers.FuncFieldResolver`1.GraphQL.Resolvers.IFieldResolver.Resolve(ResolveFieldContext \ncontext)\\r\\n   at GraphQL.Execution.ExecutionStrategy.<ExecuteNodeAsync>d__7.MoveNext()\\r\\n   --- End of inner exception stack trace\nI am guessing the return type of the dataloader ILookup> is causing this issue.\nIf anyone has worked with relay and dataloader please point me into the right direction. Your help will be very much appreciated.\n. Hi @johnrutherford @jquense can you please share your expertise on this :). @corstian mate, do you have a working example of DataLoader with relay Pagination? If so, can you please share a code snippet of your implementation?. Correct me if I am wrong, but if I inject dbContext into my fooType. Will the db context be used for subsequent requests ( as a singleton)? Even though dbcontext is registered as a scoped service?\nThis would answer my other questions: https://github.com/graphql-dotnet/graphql-dotnet/issues/729. @joemcbride thanks, I am now passing the IServiceProvider to userContext and resolving all dbcontext through that. Not the best but it does the job :)\n. Closing - See referenced issue.. ",
    "Harmindersingh05": "Looks like the NameFieldResolver cannot resolve the DataLoader grouping when used with Relay... \nExample:  Looking at the resolve function parameters. public static object Resolve(object source, string name) . The source parameter is Grouping<int,Connection<People>> and the resolve function is trying to find the 'edge' property on the grouping --> '(var prop = source.GetType().GetProperty(name, _flags);)' This will obviously fails because Grouping<int,Connection<People>> doesn't have the edge property. The edge property is on the Connection.\nHere is the current function:\n```\npublic static object Resolve(object source, string name)\n        {\n            if (source == null || name == null)\n            {\n                return null;\n            }\n        var prop = source.GetType()\n            .GetProperty(name, _flags);\n\n        if (prop == null)\n        {\n            throw new InvalidOperationException($\"Expected to find property {name} on {source.GetType().Name} but it does not exist.\");\n        }\n\n        return prop.GetValue(source, null);\n    }\n\n```\nSolution\nThe solution that I am using is straight forward. but in my opinion very hacky. Basically, I find the connection on the source parameter by unwrapping it. Then use the connection to find the 'name' parameter (Edge in this case).  \nI'm sure this is not the best approach, handling relay/dataloader specific cases directly in  NameFieldResolver. @joemcbride  what is your opinion on this?  Happy to submit a PR with the correct approach :)\nModified version of Resolve function.\n```\npublic static object Resolve(object source, string name)\n        {\n            if (source == null || name == null)\n            {\n                return null;\n            }\n        PropertyInfo prop = null;\n        var grouping = source as IGrouping<object, object>;\n        if (grouping != null)\n        {                \n            var connection = grouping.SingleOrDefault();\n            if (connection != null)\n            {\n                prop = connection.GetType().GetProperty(name, _flags);\n\n                if (prop == null)\n                    throw new InvalidOperationException($\"Expected to find property {name} on {source.GetType().Name} but it does not exist.\");\n\n                return prop.GetValue(connection, null);\n            }              \n        }\n        else\n        {\n            prop = source.GetType()\n                .GetProperty(name, _flags);\n        }\n\n        if (prop == null)            \n            throw new InvalidOperationException($\"Expected to find property {name} on {source.GetType().Name} but it does not exist.\");\n\n        return prop.GetValue(source, null);\n    }\n\n```\n. ",
    "corstian": "Although my stack trace seems a bit different I heavily suspect these issues are related;\nGraphQL.ExecutionError: Error trying to resolve pageInfo. ---> System.InvalidOperationException: Expected to find property pageInfo on AsyncStateMachineBox`1 but it does not exist.\n   at GraphQL.Resolvers.NameFieldResolver.CreatePropertyDelegate(Type target, String name)\n   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\n   at GraphQL.Resolvers.NameFieldResolver.Resolve(Object source, String name)\n   at GraphQL.Instrumentation.MiddlewareResolver.Resolve(ResolveFieldContext context)\n   at GraphQL.Execution.ExecutionStrategy.ExecuteNodeAsync(ExecutionContext context, ExecutionNode node)\n   --- End of inner exception stack trace ---\nSimilarities is that I'm also combining the connection and the dataloader, although this specific connection is a root query, and does not use the dataloader, although it does use the ResolveAsync method, which is probably where the AsyncStateMachineBox comes from.\nIs it possible to patch this issue temporary by copying a class (or maybe a few) and registering these modified versions in the DI? As the alternative of including the whole GraphQL project in my solution doesn't really appeal me.\n@joemcbride, any hints on how to (temporarily) resolve this issue, besides not using the ResolveAsync method probably?. In the end I figured this was a typical PICNIC issue. The main issue, besides other stupidities from my side, involves returning a Task instead of a POCO from the ResolveAsync method. ':). I managed to throw a demo project together in which both the dataloader and relay connections are being used. (See https://github.com/corstian/graphql-dataloader-connections-demo)\nIf there's something which needs further clarification, please let me know!. @Risbot Check out this post which goes into detail into that (assuming you're asking about connections).\nLong story short; EF Core is not suited to properly implement cursor based pagination right now, and therefore I started using SqlKata in order to have a bit more flexibility. I think going this route is your best bet right now, and the ideas behind the libraries are quite the same (though SqlKata is not strongly typed).\nIf you want to go this way I recommend you to read through section 6 of said post.\nIn case you were asking about the data loader, this post might help you with that.\nIf you don't feel like copy/pasting the code blocks from these posts into your project, I was literally just busy combining these helper methods into a small library: https://github.com/corstian/Boerman.GraphQL.Contrib.. @johnrutherford If I understand you correctly that would be something like this?\n```C#\nvar motherTask = motherLoader.LoadAsync(context.Source.Id);\nvar fatherTask = fatherLoader.LoadAsync(context.Source.Id);\nvar motherResult  = await motherTask;\nvar fatherResult = await fatherTask;\n```. Allright, this one is slightly related to graphql-dotnet/server#156.\nI suppose that for now it is easiest to implement the IOperationMessageListener interface in order to fetch the payload that comes with a connection_init message. These contents can then be stored in the Properties property on the MessageHandlingContext object in order to access them from the subscription resolver.\nSlightly related, I think it's quite strange to see the MessageHandlingContext show up on the UserContext field of the ValidationContext on a IValidationRule where I'd normally expect another type. Maybe I'd wait for graphql-dotnet/graphql-dotnet#637, depending on the amount of time it would take to ship this (?).. Strictly speaking I solved my own question by now. See code snippet below for a way to get to process the Authorization header and determine whether the user is authenticated or not. Additional validation rules can be added as needed.\n```csharp\npublic class SubscriptionInitializer : IOperationMessageListener\n{\n    public Task BeforeHandleAsync(MessageHandlingContext context)\n    {\n        return Task.CompletedTask;\n    }\npublic async Task HandleAsync(MessageHandlingContext context)\n{\n    if (context.Terminated) return;\n\n    var message = context.Message;\n\n    if (message.Type == MessageType.GQL_CONNECTION_INIT)\n    {\n        JwtSecurityTokenHandler handler = new JwtSecurityTokenHandler();\n        var user = handler.ValidateToken(\n            message.Payload.GetValue(\"Authorization\").ToString().Replace(\"Bearer \", \"\"),\n            new TokenValidationParameters\n            {\n                ValidIssuer = \"\", /* TODO: INSERT ISSUER */\n                ValidAudience = \"\", /* TODO: INSERT AUDIENCE */\n                IssuerSigningKey = new JsonWebKey(@\"\") /* TODO: ADD SIGNING KEY */\n            },\n            out SecurityToken token);\n\n        if (!user.Identity.IsAuthenticated) await context.Terminate();\n    }\n}\n\npublic Task AfterHandleAsync(MessageHandlingContext context)\n{\n    return Task.CompletedTask;\n}\n\n}\n```\nNow it would be interesting to see how the UserContext can be preserved when dealing with subscriptions so that the ClaimsPrincipal can be populated and existing IValidationRule implementations can be used for validating user access rules.. This is kind of related to the way you structure your graph types. Two of the methods I have seen in the wild are:\nJSON\n{\n    \"latitude\": 0.1,\n    \"longitude\": 0.2,\n    \"altitude\": 0.3\n}\nWhile another method is putting latitude, longitude and altitude in an array like this:\nJSON\n{\n    \"location\": [0.1, 0.2, 0.3]\n}\nYou will need to create a graph type which represents this structure. It can be something like this (untested).\n```C#\npublic class Location {\n    public double Latitude { get; set; }\n    public double Longitude { get; set; }\n    public double Altitude { get; set; }\n}\npublic class LocationType : ObjectGraphType {\n    public LocationType() {\n        Field(q => q.Latitude);\n        Field(q => q.Longitude);\n        Field(q => q.Altitude);\n    }\n}\n```. For convenience; this is the link: http://corstianboerman.com/2019-03-08/implementing-pagination-with-graphql-net-and-relay.html. ",
    "ltouro": "@PascalSenn Thanks for the swift feedback. Tried  your suggestion and it \"worked\". That is, the conversion to the object completed without errors.\nHowever, the final array contains a null value, which does not map entirely to the input.\nWhich means:\njson\nsomePossibleNullList: null\nis treated as \njson\nsomePossibleNullList: [null]\nThat is fine because I can handle that scenario with no problem. However, that seems kind odd. Should I look around for a possible fix?\n. Thanks for all the support guys. This library is awesome :) Cheers. ",
    "aalmada": "Doh! I'm looking into it.. Does it make sense?. I just realized this would be a breaking change so I made a small change to maintain backwards compatibility.. I think it now keeps all previous behaviors.. Sorry but I don't know how to make build succeed.. Yes, you're right. I forgot to make the change after adding the if-clause. \nI added the if-clause because 'error' returns a Task so it should be awaited but the existing unit test returns a null (not a Task that returns null). This way both scenarios still work.. ",
    "pingvinen": "I had not noticed that option. I will try that out.. That works :). As a user, I can say that the company I work in use this in the context of dotnet Core 2.x only. So for me it makes sense :). ",
    "lusess123": "Thanks.   I have already settled the matter.. but   \"GraphQL.GraphiQLCore\"    would be throwing Error when running \"dotnet run\" . @joemcbride  thx. ",
    "Mardoxx": "This really needs doing doesn't it.\nI'd imagine a lot of people from a C# background will have a strong affinity towards using Entity Framework as their persistence layer/ORM. Here, singleton instances just won't work unless you either: only ever have one instance of your GraphQL server running and no other service modifying the database, or run everything with change tracker disabled (i.e. .AsNoTracking() on all queries). (Ignoring that EF's DbContext is not thread safe, so if things are resolved concurrently it will throw up).\nNot too clued up on internals of EF, but I'd imagine the former will grind to a halt on a significantly large enough database as the change tracker would eventually try and cache all DB entities.. if it even works at all!. ",
    "sgenache": "Hi, maybe I'm missing something obvious here, but here is what I've done.\nStarting with Asp.Net Core 2.0 we have a way of registering a scoped/transient middleware in the application ( see https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/extensibility?view=aspnetcore-2.0 )\nThis means that you can inject scoped services in the middleware, eg:\n```      \nservices.AddScoped(s =>\n{\n      var httpContextAccessor = s.GetService();\n     ...\n      // gets the tenant Id from claims, creates TenantContext()\n});\nservices.AddScoped(s => new GraphQLSettings\n{\n     BuildUserContext = httpContext => new GraphQLUserContext\n     {\n          HttpContext = httpContext\n     }\n });\n```\nIn the case of GraphQLSettings you don't have to pass it as a parameter to the middleware, it actually throws exception as explained in the link: \npublic static IApplicationBuilder UseFactoryActivatedMiddleware(\n    this IApplicationBuilder builder, bool option)\n{\n    // Passing 'option' as an argument throws a NotSupportedException at runtime.\n    return builder.UseMiddleware<FactoryActivatedMiddleware>(option);\n}\nNow here is the part that I'm not sure about. But I feel I'm on the right track (?!)\nI'm registering the schema, types as singleton(as before), but the queries as scoped:\nservices.AddSingleton<ISchema, OISchema>();\nservices.AddSingleton<AccountType>();\nservices.AddScoped<RootQuery>();           \nservices.AddScoped<AccountsQuery>();\nHere is the AccountsQuery and RootQuery:\n```\npublic class AccountsQuery : AuthorizedObjectGraphType\n{\n        public AccountsQuery(ITenantContext tenantContext)\n        {\n           Field()\n                .Name(\"account\")\n                .Description(\"Get Account by Id\")\n                .Argument>(\"id\", \"The Id of the Account.\")\n                .ResolveAsync(async ctx =>\n                {\n                     ...\n                     // resolve using tenantContext\n                }            \n        }\n}\npublic class RootQuery : ObjectGraphType\n{\n        public RootQuery()\n        {\n            Name = \"root\";\n        Field<AccountsQuery>(\"accounts\", resolve: ctx => new { });\n        ..\n        //other queries...\n    }\n\n}\n```\nThis still fails as singleton scoped Schema can't resolve scoped RootQuery/AccountsQuery so I'm doing this in the middleware (and not resolving RootQuery in Schema):\n```\nvar request = Deserialize(httpContext.Request.Body);\nschema.RegisterType(httpContext.RequestServices.GetService());\nschema.Query = httpContext.RequestServices.GetService();\nvar result = await executer.ExecuteAsync( =>\n {\n       .Schema = schema;\n       .Query = request.Query;\n       .OperationName = request.OperationName;\n       .Inputs = request.Variables.ToInputs();\n       .UserContext = _settings.BuildUserContext?.Invoke(context);\n       .ValidationRules = httpContext.RequestServices.GetServices();\n});        \nawait WriteResponseAsync(context, result);\n```\nNow ITenantContext is successfully resolved in the AccountsQuery.\nThis still seems weird, does registering the Queries as scoped and resolving them in the middleware makes sense?\nEdit: this seems to work only for the first request, subsequent requests give this error:\n\"message\": \"GraphQL.ExecutionError: Unexpected type:  ---> \nSystem.InvalidOperationException: Unexpected type: \\r\\n \nat GraphQL.Execution.ExecutionStrategy.BuildExecutionNode(ExecutionNode parent, IGraphType graphType, Field field, FieldType fieldDefinition, String[] path)\\r\\n \nat GraphQL.Execution.ExecutionStrategy.SetSubFieldNodes(ExecutionContext context, ObjectExecutionNode parent, Dictionary`2 fields)\\r\\n \nat GraphQL.Execution.ExecutionStrategy.BuildExecutionRootNode(ExecutionContext context, IObjectGraphType rootType)\\r\\n \nat GraphQL.Execution.ExecutionStrategy.d__0.MoveNext()\\r\\n\n--- End of stack trace from previous location where exception was thrown ---\\r\\n \nat System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\\r\\n \nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\\r\\n \nat GraphQL.DocumentExecuter.d__8.MoveNext()\\r\\n \n--- End of inner exception stack trace ---\",\n}. ",
    "Historyman": "Thats what I suspected, but thanks for the confirmation.. ",
    "flessard": "Hi @johnrutherford,\nI test your solution, but doesn't work.\nrecurrentPayment = await recurrentPaymentTask; work fine, but still wait at plan = await planTask; \n```\nPlanModel plan = null;\nPlanModel nextPlan = null;\nRecurrentPaymentModel recurrentPayment = null;\nvar account = ctx.Source;\nvar recurrentPaymentLoader = _dataLoaderContextAccessor.Context.GetOrAddBatchLoader(\"RecurrentPayment\", _recurrentPaymentResolver.GetByVaultIdsAsync);\nvar planLoader = _dataLoaderContextAccessor.Context.GetOrAddBatchLoader(\"Plan\", _planResolver.GetByIdsAsync);\nif (ctx.Source.VaultId != null)\n{\n    var recurrentPaymentTask = recurrentPaymentLoader.LoadAsync(ctx.Source.VaultId);\nrecurrentPayment = await recurrentPaymentTask;\n\n}\nif (ctx.Source.PlanId != null)\n{\n    var planTask = planLoader.LoadAsync(ctx.Source.PlanId.Value);\nplan = await planTask;\n\n}\nif (ctx.Source.NextPlanId != null)\n{\n    var nextPlanTask = planLoader.LoadAsync(ctx.Source.NextPlanId.Value);\nnextPlan = await nextPlanTask;\n\n}\n```. @johnrutherford, nice work fine now. Thanks for your help and your time. Very appreciated. \ud83d\udc4d . ",
    "kdelwat": "Thanks so much, that fixed it! . ",
    "iamgmd": "Thanks for the response @KreativJos, I think I tried that using the class below but it didn't work, do you have any code snippets to hand? I am probably missing something somewhere.\nAdded with:\nservices.AddSingleton<Cache>();\nCache class: \n```\n    public class Cache\n    {\n        private readonly IDistributedCache _cache;\n    public Cache(IDistributedCache cache)\n    {\n        _cache = cache;\n    }\n\n    public void WriteToCache(string key, string value)\n    {\n        this._cache.SetString(key, value);\n    }\n\n    public string ReadFromCache(string key)\n    {\n        return this._cache.GetString(key);\n    }\n}\n\n```\nand accessed:\n```\npublic class ContactType : ObjectGraphType\n    {\n        Cache _cache;\n        public ContactType(Cache cache)\n        {\n            _cache = cache;\n        Name = \"contact\";\n        Description = \"A contact.\";\n\n        Field<StringGraphType>(\n            \"t4a_title_name\",\n            description: \"The t4a_title_name of the contact.\",\n            resolve: context =>\n            {\n                var attributeName = context.FieldName.Replace(\"_name\", \"\");\n                var objectTypeCode = 2;\n                var attributeValue = context.Source?.t4a_title;\n                var key = $\"optionset_{attributeName}_{objectTypeCode}_{attributeValue}\";\n                var value = _cache.ReadFromCache(key);\n                return value;\n            });\n    }\n}\n\n```\n. ",
    "RaySheikh": "We are using IIS on windows server 2012 . Hi Joe, I am running Asp.net Core 2.0.  Started the project with the WebApi projects, using the graphql nuget package. The siteroot is an empty application. All our sites are under the site root. \nYour link.. feedback, Yes, i created a virtual directory to host each sub-site under the root.\nThanks, \nRay. Hi joe, I did not add an authorize attribute. below is my controller.\n  `[Route(\"[controller]\")]\npublic class GraphQLController : Controller\n{\n    private IDocumentExecuter _documentExecuter { get; set; }\n    private ISchema _schema { get; set; }\n    private readonly ILogger _logger;\n\n    public GraphQLController(ISchema schema, IDocumentExecuter documentExecuter, ILogger<GraphQLController> logger)\n    {\n        _schema = schema;\n        _documentExecuter = documentExecuter;\n        _logger = logger;\n    }\n\n    [HttpGet]\n    public IActionResult Index()\n    {\n        _logger.LogInformation(\"Got request for GraphiQL. Sending GUI back\");\n        return View();\n    }\n\n    [HttpPost]\n    public async Task<IActionResult> Post([FromBody] GraphQLQuery query)\n    {\n        if (query == null) { throw new ArgumentNullException(nameof(query)); }\n\n        var inputs = query.Variables.ToInputs();\n        var executionOptions = new ExecutionOptions\n        {\n            Schema = _schema,\n            Query = query.Query,\n            Inputs = inputs\n        };\n\n        var result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\n\n        if (result.Errors?.Count > 0)\n        {\n            _logger.LogError(\"GraphQL errors: {0}\", result.Errors);\n            return BadRequest(result);\n        }\n        _logger.LogDebug(\"GraphQL execution result: {result}\", JsonConvert.SerializeObject(result.Data));\n        return Ok(result);\n    }\n}`. Hi Joe, Everything works perfectly with GraphiQL interface. I'm using EFcore and all of the queries/mutations work on GraphiQL. Only issue is the 401 when using Apollo. I know the client works with other mockup GraphQL endpoints.\n\nbelow is my startup.cs. Thank you again for your help on this.\n`public class Startup\n{\n    private readonly string _EnvUrl;\n    public Startup(IConfiguration configuration)\n    {\n        Configuration = configuration;\n        _EnvUrl = Configuration[\"EnvUrls:CurrentUrl\"];\n    }\n\n    public IConfiguration Configuration { get; }\n\n    // This method gets called by the runtime. Use this method to add services to the container.\n    public void ConfigureServices(IServiceCollection services)\n    {\n        string appapprovalconn = Configuration.GetConnectionString(\"AppApprovalConn\");\n        services.AddDbContext<AppApprovalContext>(options => options.UseSqlServer(appapprovalconn, opt => opt.EnableRetryOnFailure()));\n\n        //DI\n        services.AddScoped<AppApprovalSchema>();\n        services.AddScoped<AppApprovalQuery>();\n        services.AddScoped<AppApprovalMutation>();\n\n        services.AddScoped<UserType>();\n        services.AddScoped<RoleType>();\n        services.AddScoped<ApprovalChainType>();\n        services.AddScoped<V_AppApprovalChainApproverCountType>();\n        services.AddScoped<V_AppApprovalRecordFullType>();\n        services.AddScoped<V_ApplicationApprovalChainType>();\n        services.AddScoped<V_AppApprovalRecordHistoricalType>();\n        services.AddScoped<V_WestDivEmployeesType>();\n        services.AddScoped<ApplicationCostType>();\n\n        services.AddScoped<ApprovalChainInputType>();\n        services.AddScoped<V_AppApprovalRecordFullInputType>();\n        services.AddScoped<UserInputType>();\n        services.AddScoped<RoleInputType>();\n        services.AddScoped<ApprovalRecordInputType>();\n        services.AddScoped<ApplicationCostInputType>();\n\n\n        services.AddScoped<IAppApprovalRepository, AppApprovalRepository>();\n\n        services.AddScoped<IDocumentExecuter, DocumentExecuter>();\n        var sp = services.BuildServiceProvider();\n        services.AddSingleton<ISchema>(new AppApprovalSchema(new FuncDependencyResolver(type => sp.GetService(type))));\n\n\n        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\n    }\n\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseHsts();\n        }\n        app.UseCors(builder =>\n            builder.AllowAnyOrigin()\n                .AllowAnyHeader()\n                .AllowAnyMethod()\n                .AllowCredentials());\n\n        app.UseHttpsRedirection();\n        app.UseGraphiql(\"/graphiql\", options =>\n        {\n            options.GraphQlEndpoint = \"/GraphQL\"; //Point to the controller\n        });\n        app.UseMvc();\n    }\n}`. Joe,\n\nI figured it out, It was something very minor and I feel stupid not catching it. Taking a break from programming for a couple of days helped a lot. \nReading some of your responses led me to check the Debug settings in the project properties and checking \"Enable Anonymous Authentication\" fixed the issue.\nThank you again for your help. If anyone needs help building an API with EFcore using your repository layer please feel free to hit me up. I have queries and mutations working and i'm working on the subscriptions next.\nThanks again Joe!!\n\n. Hello, I have the same issue. Can someone give a complete example of the execution strategy class along with their startup.cs file please. \nThanks. public class EfDocumentExecuter : DocumentExecuter\n{\n    protected override IExecutionStrategy SelectExecutionStrategy(ExecutionContext context)\n    {\n        if (context.Operation.OperationType == OperationType.Query)\n        {\n            return new SerialExecutionStrategy();\n        }\n        return base.SelectExecutionStrategy(context);\n    }\n}\nAnd calling it in my controller\nvar docExec = new DocumentExecuter();\n            var result = await docExec.ExecuteAsync(_executionOptions).ConfigureAwait(false);\nThis is still causing parallel executions with ef core. Am I missing something?\nPlease help. ",
    "rianjs": "In DateTimeToDateTimeOffset, you have the UTC offset hard-coded to TimeSpan.Zero which does not follow the .NET convention for DateTimeOffset types.\nThe rules for converting DateTime to DateTimeOffset are:\n DateTimeKind.Local or DateTimeKind.Unspecified = use the local machine's time zone to figure out the UTC offset that should apply to that DateTime.\n DateTimeKind.Utc = use TimeSpan.Zero.\nI would suggest following the convention, otherwise you're going to confuse a lot of .NET devs who are going to have to wrap the library to handle its non-standard behavior. In fact, you changed the Description property on both Date and DateTime to say:\n\n\"The DateTime scalar type represents a date and time. DateTime expects timestamps to be formatted in accordance with the ISO-8601 standard.\n\n...which the library itself then ignores by explicitly saying that value is UTC. ISO-8601 requires a Z suffix to mean UTC. Everything else is \"local time\".\nI have similar objections to DateTimeOffsetToDateTime which always returns a UTC representation. I would get rid of that entirely, and only return a DateTimeOffset when applicable, and let the application developer decide whether they want:\n- DateTimeOffset.LocalDateTime (that moment converted to the machine's local time)\n- DateTimeOffset.DateTime (truncate the UTC offset)\n- DateTimeOffset.UtcDateTime (that moment expressed as a DateTime with DateTimeKind.Utc)\n...these are all subtly different, and all of them can be useful given the right circumstances.. - ~~All ints are also longs. How will the IntValue case ever be reached? Can you get rid of int and just use long?~~ Boxing handles the type safety, my bad.\n- In .NET, new TimeSpan(long) corresponds to the Ticks property, NOT seconds or milliseconds, so that's a bit of a break from convention, but I suppose the type is called TimeSpanMillisecondsGraphType :). ",
    "bdparrish": "I originally thought this was just a common problem with me doing a dumb mistake.  I debugged it as much as I could.  It would not step into the library resolver for the returned entities.  There are two entities in the database.  I am using the shared model and repository code that I have with my standard API and I am returning the two entities from my database there.\nHere is the resolver code, it is utilizing an async process, but I am assuming that that is not the problem since the result has the right number of records.  My guess is from the library not being able to create the object correctly.  Is there anyway to utilize Newtonsoft.JSON library to return the right JSON?  It seems like it is the standard for a JsonResult and that is what I am currently implementing on my models.\nAlso, I tried a different model and I return the same count of results that are in the database, but they are null for each record as well.\n```csharp\npublic Func, object> GetResolver()\n{\n    return context => {\n        Guid id = context.GetArgument(\"id\");\n    if (id != Guid.Empty)\n    {\n        return _customerRepository.GetAsync(id);\n    }\n    else\n    {\n        return _customerRepository.ListAllAsync();\n    }\n};\n\n}\n. Field definitions in Query class...csharp\nField(\n    \"customer\",\n    resolve: new CustomerData(customerRepository).GetResolver()\n);\nField>(\n    \"customers\",\n    resolve: new CustomerData(customerRepository).GetResolver()\n);\nCustomerInterface definition...csharp\npublic class CustomerInterface : InterfaceGraphType\n{\n    public CustomerInterface()\n    {\n        Name = \"customer\";\n    Field(x => x.Id, type: typeof(IdGraphType)).Name(\"id\");\n    Field(x => x.Name).Name(\"name\");\n}\n\n}\n```\nThat resolver returns a single entity if it cannot find an id argument in the context otherwise it returns a collection of entities.. Yeah it returns a Customer object, other things look like this...\nCustomerSchema\ncsharp\npublic class CustomerSchema : Schema\n{\n    public CustomerSchema(ICustomerRepository customerRepository)\n    {\n        Query = new CustomerQuery(customerRepository);\n        RegisterType<CustomerType>();\n    }\n}\nCustomerInterface\n```csharp\npublic class CustomerInterface : InterfaceGraphType\n{\n    public CustomerInterface()\n    {\n        Name = \"customer\";\n    Field(x => x.Id, type: typeof(IdGraphType)).Name(\"id\");\n    Field(x => x.Name).Name(\"name\");\n}\n\n}\n```\nCustomerData\n```csharp\npublic class CustomerType : ObjectGraphType\n{\n    public CustomerType()\n    {\n        Name = \"Customer\";\n    Field(x => x.Id, type: typeof(IdGraphType)).Name(\"id\");\n    Field(x => x.Name).Name(\"name\");\n}\n\n}\n```. Bingo! Thanks @joemcbride \nI had to add these... to my Type definition.\n```csharp\nInterface();\nIsTypeOf = obj => obj is Customer;\n```\nFor the documentation I would add this part as a necessity(?).  It seemed out of place as a secondary need if I wanted to do it for custom definitions when I originally read that section.. So, why didn't it work in my original definition of CustomerType if it is automagically added?. Quick change and that is correct.  Thanks again for the quick responses @joemcbride - excellent customer service and a 5 star rating.. If I am using the repository pattern, then the library throws a error saying that a EmployeeType cannot be returned for an expected EmployeeTypeInterface.  Is there a way to do something else where I am handling it with its own specific resolver?  Can you also verify that utilizing async methods is handled properly by a Field when resolving?\ncsharp\nField<EmployeeTypeInterface>(\"employeeType\", resolve: new EmployeeTypeData(employeeTypeRepository).GetEmployeeResolver());. ",
    "chwarwick": "@sgwozdz A simple option that you can use is to put a marker Interface on all your individual Mutation classes and then inject them into the main Mutation.  Then you just just loop through and add all it's fields\npublic Mutation(IEnumerable<IMutation> mutationClasses)\n{\n    foreach (var mutationClass in mutationClasses)\n    {\n         foreach (var field in mutationClass.Fields)\n         {\n             AddField(field);\n         }\n    }\n}\n. ",
    "sgwozdz": "In fact few minutes after I wrote this question I found out this solution. I'm not happy with this but it works.. ",
    "KiraNamida": "That still leaves we with:\n[ {key, value}, {key, value}, {key, value}, ... ]\nrather than\n{\n    key: value,\n    key: value,\n    key: value,\n    ...\n}\nwhich is what I am going for to match up with my .NET entites.. ",
    "Dale4": "Awesome! Thanks.. Thanks Joe,  I am going to take your nuget package for GraphQL, which I really like,  and put it in a docker image.\nI am new to both technologies but feel they really fit our needs.\nDale.\nhttps://www.lds.org/media-library/video/2015-06-01-using-the-booklet-my-family-stories-that-bring-us-together?category=start-with-your-family&lang=eng\n\nFrom: Joe McBride notifications@github.com\nSent: Friday, June 8, 2018 6:07 PM\nTo: graphql-dotnet/graphql-dotnet\nCc: Dale4; Author\nSubject: Re: [graphql-dotnet/graphql-dotnet] Containerized (#691)\nYes. My experience with Docker is minimal, though my understanding is that you create your docker container which copies your compiled asp.net core project to a base image, which would include the dlls from this project.\nhttps://docs.docker.com/engine/examples/dotnetcore/https://nam03.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.docker.com%2Fengine%2Fexamples%2Fdotnetcore%2F&data=02%7C01%7C%7Cf7e2fef61f8d4fab1f0e08d5cda55a6a%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636641032418153335&sdata=wxxPNxgdC9bW659iDaldgT1rJ9W1b%2FVVLkB8fzpH9t0%3D&reserved=0\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://nam03.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fgraphql-dotnet%2Fgraphql-dotnet%2Fissues%2F691%23issuecomment-395928346&data=02%7C01%7C%7Cf7e2fef61f8d4fab1f0e08d5cda55a6a%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636641032418153335&sdata=PS9g51gubXvK%2FBwil2xA7mkqf7o%2FXS%2F4Lbf9KmCw4cc%3D&reserved=0, or mute the threadhttps://nam03.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAXeTzW67rAU5FAiKgMY8INOEit0o6ONoks5t6x_IgaJpZM4UhHGF&data=02%7C01%7C%7Cf7e2fef61f8d4fab1f0e08d5cda55a6a%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636641032418153335&sdata=p4CKhfAQBu%2Fr%2FiXCodOyQmOES5PdbaZq85kMTu9DXdY%3D&reserved=0.\n. ",
    "ddecours": "thank you for taking the time to post the resolution - you save me time!. Hi Joe -  thanks for the fantastic work!!   Any thoughts on when it could be better to use graphql middleware technique vs. using an mvc controller?    The code is very similar, but it's not obvious to me which technique is best.   Maybe have both in place and allow a hook to \"pre-process\" the request prior to handoff to the controller?\nI realize the implementation depends on the business need, so really just looking for general input.\nMuch appreciated!. ",
    "saborrie": "+1 for the reverse resolver. Maybe there's already a way to do this nicely, but essentially it would be good to define how input types deserialise into the models that they are for. For example, it would be nice to have a way of replacing this:\n```\n    public class MyInputType: InputObjectGraphType\n    {\n        public MyInputType()\n        {\n            Field( => .Payload);\n        }\n    }\npublic class MyInputModel\n{\n    public string Payload { get; set; } // actually just a JSON serialised payload\n}\n\n```\nWith this:\n```\n    public class MyInputType: InputObjectGraphType\n    {\n        public MyInputType()\n        {\n            // something along these lines:\n            Field().Name(\"payload\").Deserialize( => JsonConvert.DeserializeObject());\n        }\n    }\npublic class MyInputModel\n{\n    public dynamic Payload { get; set; } // the deserialised payload object\n}\n\n```\nSince I'd never actually want to \"resolve\" a field on an input type, I'm not sure why it has Resolve methods. Thank you for the quick reply.\n\nThe generic version of EnumerationGraphType tries to add all the enum values for you so you don't have to duplicate them. This is helpful in most cases.\n\nCool, that's really useful!\n\nYou should be able to just override the Name and it will still set all the enum values for you?\n\nOk, yeah I didn't realise I could just set the name.\nHowever:\n\nNote that with using the non-generic version you will still be required to set the Name.\n\nThis didn't seem the case for me, the non generic one worked as expected\n. @Cooke how's this issue doing? \nAfter having this issue in a project I've had to use Task.WhenAll in order to combine multiple dataloader calls into one await, which should do for now.\nI cloned this repo and added it to my solution locally so that I could add breakpoints and noticed that this deadlocking stopped happening if I breakpoint in the ParallelExecutionStrategy class. So I'm guessing the deadlocking only happens because of a race condition?. ",
    "AmbroiseCouissin": "Would love this as well. This would clean a lot of our DTOs.. @joemcbride Little up. Any idea on how to execute my sorting after everything has been resolved?. You're right. I'll do that. Thanks!. We use it in prod. No regret. Amazing library.. On our side, I was wrong about the limit of 1024KB. It was much bigger.. This would be very useful for us as well. Right now, we are stitching things manually from the root mutation resolver.. ",
    "Tarig0": "This would be nice to handle differences in naming conventions since snack case => pascal case does not work with the current input mapping.. Design wise this would need to change the work flow to.\n\nCheck if type conversion exists for the raw types\nIf so use that conversion .. stop\nIf not continue old logic\nContinue recursive calls for nested ienum types. Have you tried Async field? Looks like the issue may be you are returning Task and not PlayerBalance. Ah I see, did you add the PlayerBalanceRequestType to the DI container. All you need to do is instead of creating a singleton service for your scheme use the addscoped function. \n",
    "alonstar": "@joemcbride  I can't figure out how to pass the company id to the validator.. @joemcbride  oh, I got it. Thanks !\ud83d\udc4d . ",
    "phoenixjun": "Thanks very much to your reply @joemcbride .\nYou mentioned about adding metadata to the QueryArgument, how is that done in the library? Currently, my argument is StringGraphType, do I need to create the argument as a separated type and then put the meta data there or I can just configure that when I defined the QueryArgument?\nThanks. Thanks for your information on this.. ",
    "masduo": "Thanks @joemcbride \nBut is my sample above the recommended way to use the library if i need need/want async? Otherwise do you have an example of how to use it? \nAlso is this what you mean by\n\n... return a Task and it will be awaited for you with the other overloads.\n\n```csharp\n// mutation\nField(\"createTransaction\",\n    // arguments: new QueryArguments {...}\n    resolve: ctx => TransactionInput.CreateTransaction();\n// resolver's still async and returns a Task\n public static async Task CreateTransaction() \n{ \n    await _httpClient.SendAsync(...);\n}\n```\n. Alright great, thanks for your speedy response :). ",
    "vinhbachkhoa": "how to use veraiable in mutation . ",
    "dharmeshtailor": "Sure will do it over the weekend.\nThanks.. Thanks, Sorry was busy over the weekend. So didn't get chance to submit the PR.\nClosing the issue.. Sorry for missing out on the information:\nGraphQL version : 2.0.0-alpha-805\nTechnology : ASP.Net Web API on Azure Service fabric.\nI got that, one is AST and other computed value from root level arguments. but my point was to check, why 2 different ways of representing the arguments?\nHow do you want me to provide the test?. ",
    "MNie": "@dharmeshtailor @joemcbride it could be closed since #699 was merged.. @joemcbride I didn't saw the another one :). @joemcbride ok I get it :). I fix the pr, so now all should be fine. Since I used this library in my daily work I want to contribute to it somehow so I grab some issues and try to resolve/fix them. But as you said if the URI is not available in GraphQL. I'm not 100% sure that it would be good to add it to a GraphQL-Dotnet? But on the other hand, thanks to it we have a confidence that field of type URI would be properly formatted no matters what is done on the server side.. @joemcbride make sense them to not adding it as an argument. I was curious not from a graphql specifications side, but from a user experience, thanks for an answer! :). @joemcbride so you think it would be sensible to remove implementation of a IHaveDefaultValue from a FieldType?. bump @joemcbride \n. @joemcbride \nI think the API would be more flexible so we are not supposed to have one concrete return type. But I agree it would create some complication in an implementation.. @joemcbride up. @joemcbride what a shame, cause syntax when ScalarTypes would be allowed looks neat. Closing this one, thanks!. fix'd. @joemcbride fix'd!. ",
    "eugenpaval": "All requested changes provided. If the resolving type name matches GraphQL type name there is no need to add GraphQLMetadata attribute to the resolving type just to provide an implementation of IsTypeFuncOf for the GraphQL schema type.. Thank you for the answer. SignalR does not have anything to do with Observables but I would think one can reasonably make it work by building a bridge. Hopefully will have some time soon to take a look.... Thanks pekkah for the pointers. Yea, summer is pretty hard on finding the time to do extra coding especially since I have so much to do at my office. Regardless, I am pushing for a GraphQL implementation of our API and subscriptions are a necessity. At my previous job I used Java to implement a GraphQL server and I must say there was nothing in terms of subscriptions so, hats off to you @joemcbride and @pekkah for this excellent library.... My soultion would be something similar to this:\n```\ntype Query\n{\n    humans(exp: String!): [HumanType]!!\n}\ntype HumanType\n{\n    id: Int!\n    name: String!\n}\n```\nAnd use System.Linq.Dynamic nuget package which allows for string expressions instead of lambda expressions as parameters.\nThen a query may look like\n{\n    humans(exp: \"name == \\\"given-name\\\"\"\n}. I implemneted slightly different sorting, filtering and grouping inspired by Linq actually! In Linq you have pipes described by expressions which defer execution till it reaches a materializing expression. This is described very well in Linq ecosystem. For example users.Where(u => u.ID == givenID) is not excuted immediately but rather when a GetEnumerator() is called on that and even then only for the elements that are enumerated. Also, there is System.Linq.Dynamic nuget package which basically implements a good part of Linq by using string expressions. For my example I would then have users.Where(\"ID == givenID\").\nIn your example then instead of creating multiple properties to basically just do filtering I would have\n``\ntype Users\n{\n     where(exp: String!): Users!\n     select: [User!]!`\n}\ntype User\n{\n     id: String!\n     name: String!\n     country: String!\n }\n```\nYou can just imagine how this works with OrderBy and GroupBy as well (just follow Linq paradigm). The only downside is the variable shape of the output since where, orderBy and groupBy properties are going to appear in the output a variable number of ways depending on the query. My solution for that was to use in the query renaming of properties, which is a GraphQL feature and then use JsonPath to get to the actual results.\nThinking more about it, a better implementation would be to just use directives for where and orderBy since they do not actually modify the shape of the result. This would be my next implementation.. @espray I put together a sample: https://github.com/eugenpaval/graphql-linq-sample\n A possible query would be:\nquery Test\n{\n  products\n  {\n    where(exp: \"category == \\\"Category-1\\\" or category == \\\"Category-2\\\"\")\n    {\n      orderBy(exp: \"category, name desc\")\n      {\n        select\n        {\n          name\n          category\n          price\n        }\n      }\n    }\n  }\n}\nor\nquery Test\n{\n  products\n  {\n    where(exp: \"price > 50\")\n    {\n      orderBy(exp: \"category, name desc\")\n      {\n        select\n        {\n          name\n          category\n          price\n        }\n      }\n    }\n  }\n}. You're right. Let me see how I can provide the default implementation.... ",
    "msheldon83": "We are looking for this as well.  Is anyone currently working on it?  @pekkah? If not I may jump in to take a look.. ",
    "dominusbelial": "This is not an issue, i accidentally left out some of the types (incomplete graphql model) out of the IServiceCollection at Startup class. . ",
    "Meir017": "which part of this repo uses nodejs? the only parts I found are the build scripts and the docs site. ",
    "Perlkonig": "Thank you. I was able to get things working.\n\n\nThe resolve: _ => .... usage only appears in the Mutations and Interfaces sections, and even there they're not clearly explained.\n\n\ncontext.Source is also only shown in the Interfaces section and is similarly unexplained.\n\n\nIf you're open to it, I'll eventually do a pull request on the docs, making some suggestions on how to better walk n00bs through things. Thanks again!. See pull request #721 . Moving my questions here as requested. You said that mutators could be added as simply as queries. My initial pass (v0.17.3) at this problem was as follows:\ncsharp\npublic class APSchemaRW : Schema\n{\n    public APSchemaRW(MyContext db)\n    {\n        Query = new APQuery(db);\n        Mutation = new APMutator(db);\n    }\n}\nBut I end up with the following error: Error trying to resolve createProfile.\nWhat could be causing that?\nHere's the mutator code:\ncsharp\npublic class APMutator : ObjectGraphType\n{\n    public APMutator(MyContext db)\n    {\n        Field<UserType>(\n            \"createProfile\",\n            arguments: new QueryArguments(\n                new QueryArgument<NonNullGraphType<ProfileInputType>> {Name = \"input\"}\n            ),\n            resolve: _ => {\n                var profile = _.GetArgument<ProfileDTO>(\"input\");\n                //Do a bunch of database stuff with the input, \n                //ending with a proper database object that gets returned.\n                return owner;\n            }\n        );\n    }\n}. Now a question around meaningful error messages. Is my understanding correct that to surface meaningful error messages, that can only be done through the validation rules? There's no way I can surface useful messages in resolvers unless ExposeExceptions is on?\nSo the implication is that if I want to validate the inputs to a specific mutation, I create a validation rule that runs every time, looking for when op.Name equals the name of my mutator. When it does, step through the variables doing whatever validation I need done (I assume through the Inputs property or one of the helpers). Yes?\nIf I need access to my database context, as long as I store it in my schema class, I should be able to access it via the Schema property, yes?\nThanks again for your time. Slowly but surely!. Well, op.Name seems to be blank. I assumed it would be the name I gave the field in my mutator (in this case, createProfile). This is my input. I want to validate the variables.\njson\n{\n    \"query\": \"mutation ($profile: ProfileInput!){ createProfile(input: $profile) {id}}\",\n    \"variables\": {\n        \"profile\": {\n            \"name\": \"Perlk\u00f6nig\",\n            \"anonymous\": false,\n            \"country\": \"CA\"\n        }\n    }\n}\nAnd here's my naive first attempt:\ncsharp\n    public class VRCheckProfileInput : IValidationRule\n    {\n        public INodeVisitor Validate(ValidationContext context)\n        {\n            return new EnterLeaveListener(_ =>\n            {\n                _.Match<Operation>(op =>\n                {\n                    if (op.Name == \"createProfile\")\n                    {\n                        var vars = context.GetRecursiveVariables(op);\n                        //do stuff with the vars, returning errors as necessary\n                    }\n                });\n            });\n        }\n    }. Thanks again for all your help. I've been making great forward progress on my project. This next question will demonstrate my limited understanding of asynchronous paradigms in .NET.\nIn the resolver of one of my mutations, I need to make an incidental call to an async function partway through. I flag the lambda as async, but now I get errors trying to return the actual database object at the end of the mutation.\n```csharp\nField(\n    \"myMutation\",\n    arguments: new QueryArguments(\n        new QueryArgument> {Name = \"input\"}\n    ),\n    resolve: async _ => {\n        //do a bunch of prep work\n    //now call this completely incidental async method whose return value I don't care about\n    //(specifically I'm emitting a message to an AWS SNS queue)\n    await IncidentalAsyncMethod().ConfigureAwait(false);\n\n    //now finish up the database work and return the updated database object\n    return val; //which is of the type mapped to the `MyType` GraphQL schema\n}\n\n);\n```\nNo surprisingly, I'm told Cannot convert async lambda expression to delegate type 'Func<ResolveFieldContext<object>, object>'. What is the right way to do this? \nI've been reading the MS docs on asynchronous programming and scouring StackOverflow. I even put the logic in a standalone function with the correct Task<MyDbObjType> return type (resolve: async _ => await HandleChallenge(_, db).ConfigureAwait(false) but to no avail.. Thank you for such a quick reply! That one change fixed everything!. And now a \"blue screen of death.\" Everything was working fine this morning. I added some new types, linked them to existing ones, and am now developing the queries and mutations. I finally deployed for testing and am greeted on all endpoints with the following:\njson\n{\n    \"errors\": [\n        {\n            \"message\": \"GraphQL.ExecutionError: No parameterless constructor defined for this object. ---> System.MissingMethodException: No parameterless constructor defined for this object.\\n   at System.RuntimeTypeHandle.CreateInstance(RuntimeType type, Boolean publicOnly, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor)\\n   at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly, Boolean skipCheckThis, Boolean fillCache, StackCrawlMark& stackMark)\\n   at System.Activator.CreateInstance(Type type, Boolean nonPublic)\\n   at System.Activator.CreateInstance(Type type)\\n   at GraphQL.Types.Schema.<CreateTypesLookup>b__56_2(Type type)\\n   at GraphQL.Types.GraphTypesLookup.AddTypeIfNotRegistered(Type type, TypeCollectionContext context)\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable`1 types, IEnumerable`1 directives, Func`2 resolveType, IFieldNameConverter fieldNameConverter)\\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\\n   at System.Lazy`1.CreateValue()\\n   at GraphQL.Types.Schema.get_AllTypes()\\n   at GraphQL.Instrumentation.FieldMiddlewareBuilder.ApplyTo(ISchema schema)\\n   at GraphQL.DocumentExecuter.<ExecuteAsync>d__8.MoveNext()\\n   --- End of inner exception stack trace ---\",\n            \"code\": \"MISSING_METHOD\"\n        }\n    ]\n}\nI see there are past issues with this error message, and it appears to be related to dependency injection, but I haven't knowingly done anything related to DI. I just created new types for existing database objects and expanded existing types to link to them. My frustration is that there's no line number or function name, or even a GraphQL type name. How does one go about tracking this problem down?\nDependencies include the following. I'm using lazy loading.\nxml\n    <PackageReference Include=\"EntityFrameworkCore.Scaffolding.Handlebars\" Version=\"1.5.1\" />\n    <PackageReference Include=\"graphql\" Version=\"2.0.0-alpha-938\" />\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"2.1.1\" />\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"2.1.1\" />\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore.Proxies\" Version=\"2.1.1\" />\n    <PackageReference Include=\"pomelo.entityframeworkcore.mysql\" Version=\"2.1.1\" />. After painstaking commenting and uncommenting of new code, I finally narrowed the problem down to a couple new types. I don't see what's wrong yet. What I'm doing in these types I've done in others. But I'll hammer at it after a good night's rest.. Thank you for your patient reply. What you stated I gleaned from my searching, but none of my types have parametered constructors. Only the queries and schemas do, and they've worked fine up to now. \nI've traced the problem to one new type in particular (GamesDataType), but I can't figure out why. So here's one type that pulls in the offending one:\n```csharp\npublic class GamesMetaType : ObjectGraphType\n{\n    public GamesMetaType()\n    {\n        //Fields that work fine are omitted\n    //This one triggers the problem. If I comment it out, the query runs fine.\n    Field<ListGraphType<GamesDataType>>(\n        \"games\",\n        description: \"All current instances of this game\",\n        resolve: _ => ((GamesMeta)_.Source).GamesData.ToArray()\n    );\n}\n\n}\n```\nAnd the error happens even if I empty out the GamesDataType object. I was hoping I could trace it to a specific field, but nope:\ncsharp\npublic class GamesDataType : ObjectGraphType<GamesData> \n{\n    GamesDataType()\n    {\n    }\n}\njson\n{\n    \"errors\": [\n        {\n            \"message\": \"GraphQL.ExecutionError: No parameterless constructor defined for this object. ---> System.MissingMethodException: No parameterless constructor defined for this object.\\n   at System.RuntimeTypeHandle.CreateInstance(RuntimeType type, Boolean publicOnly, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor)\\n   at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly, Boolean skipCheckThis, Boolean fillCache, StackCrawlMark& stackMark)\\n   at System.Activator.CreateInstance(Type type, Boolean nonPublic)\\n   at System.Activator.CreateInstance(Type type)\\n   at GraphQL.Types.Schema.<CreateTypesLookup>b__56_2(Type type)\\n   at GraphQL.Types.GraphTypesLookup.AddTypeIfNotRegistered(Type type, TypeCollectionContext context)\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\n   at GraphQL.EnumerableExtensions.Apply[T](IEnumerable`1 items, Action`1 action)\\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable`1 types, IEnumerable`1 directives, Func`2 resolveType, IFieldNameConverter fieldNameConverter)\\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\\n   at System.Lazy`1.CreateValue()\\n   at GraphQL.Types.Schema.get_AllTypes()\\n   at GraphQL.Instrumentation.FieldMiddlewareBuilder.ApplyTo(ISchema schema)\\n   at GraphQL.DocumentExecuter.<ExecuteAsync>d__8.MoveNext()\\n   --- End of inner exception stack trace ---\",\n            \"code\": \"MISSING_METHOD\"\n        }\n    ]\n}\nI'm baffled. Here are the DB objects created by EFCore scaffolding (database first):\nGamesMeta:\n```csharp\nusing System;\nusing System.Collections.Generic;\nnamespace abstractplay.DB\n{\n    public partial class GamesMeta\n    {\n        public GamesMeta()\n        {\n            Challenges = new HashSet();\n            GamesData = new HashSet();\n            GamesMetaStatus = new HashSet();\n            GamesMetaTags = new HashSet();\n            GamesMetaVariants = new HashSet();\n        }\n    public byte[] GameId { get; set; }\n    public string Shortcode { get; set; }\n    public string Name { get; set; }\n    public DateTime? LiveDate { get; set; }\n    public string Description { get; set; }\n    public string Url { get; set; }\n    public bool IsLive { get; set; }\n    public byte[] PublisherId { get; set; }\n    public string PlayerCounts { get; set; }\n    public string Version { get; set; }\n    public string State { get; set; }\n    public string Changelog { get; set; }\n\n    public virtual GamesMetaPublishers Publisher { get; set; }\n    public virtual ICollection<Challenges> Challenges { get; set; }\n    public virtual ICollection<GamesData> GamesData { get; set; }\n    public virtual ICollection<GamesMetaStatus> GamesMetaStatus { get; set; }\n    public virtual ICollection<GamesMetaTags> GamesMetaTags { get; set; }\n    public virtual ICollection<GamesMetaVariants> GamesMetaVariants { get; set; }\n}\n\n}\n```\nGamesData DB object:\n```csharp\nusing System;\nusing System.Collections.Generic;\nnamespace abstractplay.DB\n{\n    public partial class GamesData\n    {\n        public GamesData()\n        {\n            GamesDataChats = new HashSet();\n            GamesDataClocks = new HashSet();\n            GamesDataPlayers = new HashSet();\n            GamesDataStates = new HashSet();\n            GamesDataWhoseturn = new HashSet();\n        }\n    public byte[] EntryId { get; set; }\n    public byte[] GameMetaId { get; set; }\n    public bool Closed { get; set; }\n    public bool Alert { get; set; }\n    public string Variants { get; set; }\n    public ushort ClockStart { get; set; }\n    public ushort ClockInc { get; set; }\n    public ushort ClockMax { get; set; }\n    public bool ClockFrozen { get; set; }\n\n    public virtual GamesMeta GameMeta { get; set; }\n    public virtual ICollection<GamesDataChats> GamesDataChats { get; set; }\n    public virtual ICollection<GamesDataClocks> GamesDataClocks { get; set; }\n    public virtual ICollection<GamesDataPlayers> GamesDataPlayers { get; set; }\n    public virtual ICollection<GamesDataStates> GamesDataStates { get; set; }\n    public virtual ICollection<GamesDataWhoseturn> GamesDataWhoseturn { get; set; }\n}\n\n}\n```. I thought maybe it was because the type never appeared in the root query. So I added it there and removed it in the type I listed above. So the following is a field in the root query:\ncsharp\nField<ListGraphType<GamesDataType>>(\n    \"games\",\n    description: \"All games in progress\",\n    resolve: _ => db.GamesData.ToArray()\n);\nSame error, but with a shorter stack trace. db is the database context passed in through the schema. So the query has a parametered constructor, but none of the types do.. sighs Well that's one of the more embarrassing public coding errors I've made. That fixed the problem.\nIs there any way I can buy you a beer or something?\nThe library itself, and your willingness to help, has made it possible for me to make more progress on my hobby project than I thought possible this month. Many thanks.. I'm not sure what to do with this. The following code works:\ncsharp\nField<UserType>(\n    \"user\",\n    arguments: new QueryArguments(new QueryArgument<StringGraphType> { Name = \"id\" }),\n    resolve: context =>\n    {\n        var id = context.GetArgument<string>(\"id\");\n        return db.Owners.Include(x => x.OwnersNames).Single(x => x.OwnerId.Equals(GuidGenerator.HelperStringToBA(id)) && !x.Anonymous);\n    }\n);\nThe following does not:\ncsharp\nField<UserType>(\n    \"users\",\n    arguments: new QueryArguments(new QueryArgument<StringGraphType> { Name = \"country\" }),\n    resolve: context =>\n    {\n        var country = context.GetArgument<string>(\"country\");\n        if (String.IsNullOrWhiteSpace(country))\n        {\n            return db.Owners.Include(x => x.OwnersNames).Where(x => !x.Anonymous).ToArray();\n        }\n        else\n        {\n            return db.Owners.Include(x => x.OwnersNames).Where(x => x.Country.Equals(country) && !x.Anonymous).ToArray();\n        }\n    }\n);\nI'm told Expected value of type \"abstractplay.GraphQL.UserType\" but got: abstractplay.DB.Owners[]. But there's no casting that happens in the working code. So what am I supposed to do differently with this new code that returns multiple results?\n. Many thanks. I'll walk through that. Thanks for your patience with my questions. Again, if you're open, I'll submit a docs PR once I get things working. There's some foundational stuff that might be helpful. Then again, maybe it's just me \ud83d\ude04 . I have been, but it also does not illustrate or explain what to me seem to be fundamental aspects of the library. Again, it could just be that I'm thick, but I'm having to do a lot of reading between the lines. \nIt doesn't help that there's a lot of text (especially in the Jacek example) talking about the data layer and HTTP layer. That's not bad in and of itself, but the library itself should be front and center. I just think the documentation could benefit from some more focus (I say this as a professional editor).\nI'll do a PR that shows what I mean and that we can discuss. . See pull request #721 . I did some more extensive rewriting. There's lots I don't understand, so I'm not putting this text forward as some ideal or final state. But in my experience it's easier to edit existing text than to create something from nothing. For your consideration.. DTO = data transfer objects? There is no Human object in the sample code (or anywhere else in the documentation).\nMy database layer is EFCore over MySQL. I pass the context into the mutator. I have a InputObjectGraphType that lists the fields the mutator expects. I then have the following mutator code:\ncsharp\npublic APMutator(MyContext db)\n{\n    Field<UserType>(\n        \"createProfile\",\n        arguments: new QueryArguments(\n            new QueryArgument<NonNullGraphType<ProfileInputType>> {Name = \"user\"}\n        ),\n        resolve: _ => {\n            var profile = _.GetArgument<????>(\"user\");\n            //do stuff with `db` to create and save objects based on `profile`\n        }\n    );\n}\nI can't figure out how to access the values passed in from the argument. And do I simply return the newly created database object and the library takes care of mapping that to UserType?\n. Human doesn't exist anywhere on the page that the potential user is actually reading, though. The level of detail provided is inconsistent. For example, the mutation sample code contains the schema class, which has no bearing on what's being discussed, but it doesn't have Human, which is central. Nor are DTOs mentioned anywhere.\nRegardless, I sincerely appreciate your responsiveness and willingness to help. I'll keep hammering at this. . Hopefully my PR provides a helpful starting point for updating things.\nI will review the StarWars example code again. Part of this is my own ignorance, I know. I'm no n00b, but I'm no pro either. I'm a weekend coding warrior \ud83d\ude04 . Thanks. I will try to figure this out. \nI'm happy to keep my questions in this thread if you like. I apologize. In other situations I've been asked to keep them separate \ud83d\ude04 \nI do appreciate your assistance. This is the first library I've found that works in my scenario (EFCore + AWS Lambda), so I'm motivated to figure things out, but the docs are a stumbling block.. The further down the rabbit hole I go, the more frustrated I get. Adding a query was the simplest thing in the world. But from the sample code, it looks like to add a mutation I have to add all this other cruft, and I can't tell how much of this is ASP specific and how much is actually essential to making things work.\nI tried installing 2.0.0 and using IDepedencyResolver but couldn't see a way to pass the database context down the chain. I went back to 0.17.3 because queries are at least working there.\nIs there a reason the library can't abstract away most of this? Why can't we simply do Mutation = new MyMutation(dbContext); like we do for adding a query?\nSorry. This all just feels much more complicated than it needs to. I'll walk through Fizz's tutorial again and see if I can see what I'm missing. He talks about dependency injection, but it appears to be ASP specific. I'm in an AWS Lambda context. I just need a standalone function to spin up; accept clear, already-processed input; instantiate a schema; and execute the input. \nFor example, here's the totality of the function that processes read-only queries:\n```csharp\npublic async Task GraphQL(APIGatewayProxyRequest request, ILambdaContext context)\n{\n    string query = request.QueryStringParameters[\"query\"];\n    var schema = new APSchemaRO(dbc);\n    var result = await new DocumentExecuter().ExecuteAsync( =>\n    {\n        .Schema = schema;\n        _.Query = query;\n    }).ConfigureAwait(false);\n    var json = JsonConvert.SerializeObject(result, Formatting.Indented, new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore });\nvar response = new APIGatewayProxyResponse\n{\n    StatusCode = (int)HttpStatusCode.OK,\n    Body = json,\n    Headers = new Dictionary<string, string> { { \"Content-Type\", \"application/json; charset=utf-8\" } }\n};\n\nreturn response;\n\n}\n```. We can certainly expand on that. Any suggestions? \nWould you prefer calling it a more general \"data layer\" instead of \"database\"? Something like:\n\nGraphQL sits between your data and the \"outside world.\" ...but in a real-world application your data layer would consist of an ORM or some other data service provider.... How would you prefer to say it? Even if you're not querying through a direct ORM, this is where you fetch the actual data, however that is provisioned. The important part to me is to signal that the resolve: line given is not representative of real-world application.. \n",
    "stysiok": "@Perlkonig I encourage you to view this example project by Jacek Kosciesza. It has basic instruction step by step how to implement GraphQL server based on graphql-dotnet. Hope it will help you.\nStar Wars GraphQL by Jacek Kosciesza. ",
    "espray": "@eugenpaval do you have a sample of this technique?. @BenjaBobs  can you share your GraphQL=>Gremlin source?\nI am looking to do exactly what your doing GraphQl to Gremlin to Azure CosmosDB(Graph). @BenjaBobs thanks fo the reply! I guessed that might be the case, but had to ask. If your team could give back even just a little to the .net GraphQL community, it would me much appreciated. Who know with more eyes on it, the community could improve it or find bugs. :). @BenjaBobs Any update?. ",
    "HilalHakla": "Thank you soo much, I'll try this. Keep up the good work \ud83d\udc4d. By mistake. I'll reopen this if anyone needs help with this.. ",
    "jannavarro": "@joemcbride I looked at Document and Operation and I can get it there though it is more complex. I'm going to add it as variables. How do you add variables for the code I posted? This article doesn't declare variables. Do I need to create an InputGraphType and add it as field like: Field<SomeInputGraphType>?. Oh, saw it. I need to add it as inputs.\nExecutionResult result = await new DocumentExecuter().ExecuteAsync(options =>\n            {\n                options.Schema = schema;\n                options.Query = queryText;\n                options.Inputs = \n            });. ",
    "tsteele": "If the File Upload needs an example, doe that mean it is supported in release 2.0.?\n. ",
    "wendelnascimento": "Great! We've implemented the validation rule and it worked!. ",
    "BitPuffin": "Just ran into this. Can confirm it doesn't work when you return a list (or array).. Should a new issue be created for this or should it stay here? Was trying to set up a test in a PR but struggled getting building working on linux :/. @joemcbride Yep that's what we're using.. PR with failing test incoming. ",
    "ztripez": "Did some digging. In SubscriptionExecutionStrategy line 63-85:\n```\n            var resolveContext = new ResolveEventStreamContext\n            {\n                FieldName = node.Field.Name,\n                FieldAst = node.Field,\n                FieldDefinition = node.FieldDefinition,\n                ReturnType = node.FieldDefinition.ResolvedType,\n                ParentType = node.GraphType as IObjectGraphType,\n                Arguments = arguments,\n                Source = source,\n                Schema = context.Schema,\n                Document = context.Document,\n                Fragments = context.Fragments,\n                RootValue = context.RootValue,\n                UserContext = context.UserContext,\n                Operation = context.Operation,\n                Variables = context.Variables,\n                CancellationToken = context.CancellationToken,\n                Metrics = context.Metrics,\n                Errors = context.Errors,\n                Path = node.Path\n            };\n\n``ParentType = node.GraphType as IObjectGraphType` becomes null if it's a ListGraphType due to ListGraphType don't implements IObjectGraphType. \nChanging the base class for ListGraphType to GraphObjectType make the test in PR: https://github.com/graphql-dotnet/graphql-dotnet/pull/849 to work, \nHowever 2 test fails after:\n```\nSchemaIntrospectionTests validate_core_schema\nTest Name:  GraphQL.Tests.Introspection.SchemaIntrospectionTests.validate_core_schema\nTest FullName:  GraphQL.Tests.Introspection.SchemaIntrospectionTests.validate_core_schema\nTest Source:    D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\Introspection\\SchemaIntrospectionTests.cs : line 12\nTest Outcome:   Failed\nTest Duration:  0:00:00,053\nResult StackTrace:\nat GraphQL.Tests.Introspection.SchemaIntrospectionTests.ShouldBe(String actual, String expected) in D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\Introspection\\SchemaIntrospectionTests.cs:line 44\n   at GraphQL.Tests.Introspection.SchemaIntrospectionTests.validate_core_schema() in D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\Introspection\\SchemaIntrospectionTests.cs:line 23\nResult Message: \nAssert.Equal() Failure\n                                 \u2193 (pos 4183)\nExpected: \u00b7\u00b7\u00b7           \"kind\": \"LIST\",\\r\\n                \"name\": null,\\r\\n  \u00b7\u00b7\u00b7\nActual:   \u00b7\u00b7\u00b7           \"kind\": \"OBJECT\",\\r\\n                \"name\": null,\\r\\n\u00b7\u00b7\u00b7\n                                 \u2191 (pos 4183)\nTest Name:  GraphQL.Tests.StarWars.StarWarsIntrospectionTests.allows_querying_the_schema_for_object_fields\nTest FullName:  GraphQL.Tests.StarWars.StarWarsIntrospectionTests.allows_querying_the_schema_for_object_fields\nTest Source:    D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\StarWars\\StarWarsIntrospectionTests.cs : line 92\nTest Outcome:   Failed\nTest Duration:  0:00:00,119\nResult StackTrace:\nat Shouldly.ShouldBeStringTestExtensions.ExecuteAssertion(IAssertion assertion, Func1 customMessage)\n   at GraphQL.Tests.QueryTestBase2.AssertQuery(String query, ExecutionResult expectedExecutionResult, Inputs inputs, Object root, Object userContext, CancellationToken cancellationToken, IEnumerable1 rules) in D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\QueryTestBase.cs:line 155\n   at GraphQL.Tests.QueryTestBase2.AssertQuerySuccess(String query, String expected, Inputs inputs, Object root, Object userContext, CancellationToken cancellationToken, IEnumerable`1 rules) in D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\QueryTestBase.cs:line 55\n   at GraphQL.Tests.StarWars.StarWarsIntrospectionTests.allows_querying_the_schema_for_object_fields() in D:\\code\\graphql-dotnet\\src\\GraphQL.Tests\\StarWars\\StarWarsIntrospectionTests.cs:line 152\nResult Message: \nShouldly.ShouldAssertException : \"{\n  \"data\": {\n    \"__type\": {\n      \"name\": \"Droid\",\n      \"fields\": [\n        {\n          \"name\": \"appearsIn\",\n          \"type\": {\n            \"name\": null,\n            \"kind\": \"OBJECT\"\n          }\n        },\n        {\n          \"name\": \"friends\",\n          \"type\": {\n            \"name\": null,\n            \"kind\": \"OBJECT\"\n          }\n        },\n        {\n          \"name\": \"id\",\n          \"type\": {\n            \"name\": null,\n            \"kind\": \"NON_NULL\"\n          }\n        },\n        {\n          \"name\": \"name\",\n          \"type\": {\n            \"name\": \"String\",\n            \"kind\": \"SCALAR\"\n          }\n        },\n        {\n          \"name\": \"primaryFunction\",\n          \"type\": {\n            \"name\": \"String\",\n            \"kind\": \"SCALAR\"\n          }\n        }\n      ]\n    }\n  }\n}\"\n    should be\n\"{\n  \"data\": {\n    \"__type\": {\n      \"name\": \"Droid\",\n      \"fields\": [\n        {\n          \"name\": \"appearsIn\",\n          \"type\": {\n            \"name\": null,\n            \"kind\": \"LIST\"\n          }\n        },\n        {\n          \"name\": \"friends\",\n          \"type\": {\n            \"name\": null,\n            \"kind\": \"LIST\"\n          }\n        },\n        {\n          \"name\": \"id\",\n          \"type\": {\n            \"name\": null,\n            \"kind\": \"NON_NULL\"\n          }\n        },\n        {\n          \"name\": \"name\",\n          \"type\": {\n            \"name\": \"String\",\n            \"kind\": \"SCALAR\"\n          }\n        },\n        {\n          \"name\": \"primaryFunction\",\n          \"type\": {\n            \"name\": \"String\",\n            \"kind\": \"SCALAR\"\n          }\n        }\n      ]\n    }\n  }\n}\"\n    but was not\n    difference\nShowing some of the 432 differences\nDifference     |                 |    |    |    |    |    |    |    |    |                                            |    |      \n               |                \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/                                          \\|/  \\|/     \nIndex          | ...  186  187  188  189  190  191  192  193  194  195  196  197  198  199  200  201  202  203  204  205  206  ...\nExpected Value | ...  \\s   \"    L    I    S    T    \"    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   }    \\r   ...\nActual Value   | ...  \\s   \"    O    B    J    E    C    T    \"    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   ...\nExpected Code  | ...  32   34   76   73   83   84   34   13   10   32   32   32   32   32   32   32   32   32   32   125  13   ...\nActual Code    | ...  32   34   79   66   74   69   67   84   34   13   10   32   32   32   32   32   32   32   32   32   32   ...  \nDifference     |                                     |    |    |    |    |    |                                  |    |    |      \n               |                                    \\|/  \\|/  \\|/  \\|/  \\|/  \\|/                                \\|/  \\|/  \\|/     \nIndex          | ...  210  211  212  213  214  215  216  217  218  219  220  221  222  223  224  225  226  227  228  229  230  ...\nExpected Value | ...  \\s   \\s   \\s   \\s   \\s   \\s   }    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   {    \\r   \\n   ...\nActual Value   | ...  \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   }    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   {    ...\nExpected Code  | ...  32   32   32   32   32   32   125  44   13   10   32   32   32   32   32   32   32   32   123  13   10   ...\nActual Code    | ...  32   32   32   32   32   32   32   32   125  44   13   10   32   32   32   32   32   32   32   32   123  ...  \nDifference     |       |                                            |    |    |    |    |    |    |    |    |    |    |    |      \n               |      \\|/                                          \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/     \nIndex          | ...  232  233  234  235  236  237  238  239  240  241  242  243  244  245  246  247  248  249  250  251  252  ...\nExpected Value | ...  \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \"    n    a    m    e    \"    :    \\s   \"    f    r    i    ...\nActual Value   | ...  \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \"    n    a    m    e    \"    :    \\s   \"    f    ...\nExpected Code  | ...  32   32   32   32   32   32   32   32   32   34   110  97   109  101  34   58   32   34   102  114  105  ...\nActual Code    | ...  10   32   32   32   32   32   32   32   32   32   32   34   110  97   109  101  34   58   32   34   102  ...  \nDifference     |       |    |    |    |    |    |    |    |    |    |    |    |    |    |    |                                    \n               |      \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/                                   \nIndex          | ...  248  249  250  251  252  253  254  255  256  257  258  259  260  261  262  263  264  265  266  267  268  ...\nExpected Value | ...  \\s   \"    f    r    i    e    n    d    s    \"    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   ...\nActual Value   | ...  \"    :    \\s   \"    f    r    i    e    n    d    s    \"    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   ...\nExpected Code  | ...  32   34   102  114  105  101  110  100  115  34   44   13   10   32   32   32   32   32   32   32   32   ...\nActual Code    | ...  34   58   32   34   102  114  105  101  110  100  115  34   44   13   10   32   32   32   32   32   32   ...  \nDifference     |                      |    |    |    |    |    |    |    |    |    |    |    |    |                               \n               |                     \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/                              \nIndex          | ...  268  269  270  271  272  273  274  275  276  277  278  279  280  281  282  283  284  285  286  287  288  ...\nExpected Value | ...  \\s   \\s   \\s   \"    t    y    p    e    \"    :    \\s   {    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   ...\nActual Value   | ...  \\s   \\s   \\s   \\s   \\s   \"    t    y    p    e    \"    :    \\s   {    \\r   \\n   \\s   \\s   \\s   \\s   \\s   ...\nExpected Code  | ...  32   32   32   34   116  121  112  101  34   58   32   123  13   10   32   32   32   32   32   32   32   ...\nActual Code    | ...  32   32   32   32   32   34   116  121  112  101  34   58   32   123  13   10   32   32   32   32   32   ...  \nDifference     |                 |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |                \n               |                \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/               \nIndex          | ...  292  293  294  295  296  297  298  299  300  301  302  303  304  305  306  307  308  309  310  311  312  ...\nExpected Value | ...  \\s   \\s   \"    n    a    m    e    \"    :    \\s   n    u    l    l    ,    \\r   \\n   \\s   \\s   \\s   \\s   ...\nActual Value   | ...  \\s   \\s   \\s   \\s   \"    n    a    m    e    \"    :    \\s   n    u    l    l    ,    \\r   \\n   \\s   \\s   ...\nExpected Code  | ...  32   32   34   110  97   109  101  34   58   32   110  117  108  108  44   13   10   32   32   32   32   ...\nActual Code    | ...  32   32   32   32   34   110  97   109  101  34   58   32   110  117  108  108  44   13   10   32   32   ...  \nDifference     |            |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |      \n               |           \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/     \nIndex          | ...  320  321  322  323  324  325  326  327  328  329  330  331  332  333  334  335  336  337  338  339  340  ...\nExpected Value | ...  \\s   \"    k    i    n    d    \"    :    \\s   \"    L    I    S    T    \"    \\r   \\n   \\s   \\s   \\s   \\s   ...\nActual Value   | ...  \\s   \\s   \\s   \"    k    i    n    d    \"    :    \\s   \"    O    B    J    E    C    T    \"    \\r   \\n   ...\nExpected Code  | ...  32   34   107  105  110  100  34   58   32   34   76   73   83   84   34   13   10   32   32   32   32   ...\nActual Code    | ...  32   32   32   34   107  105  110  100  34   58   32   34   79   66   74   69   67   84   34   13   10   ...  \nDifference     |       |    |    |         |    |    |                        |    |    |    |    |    |    |    |                \n               |      \\|/  \\|/  \\|/       \\|/  \\|/  \\|/                      \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/               \nIndex          | ...  347  348  349  350  351  352  353  354  355  356  357  358  359  360  361  362  363  364  365  366  367  ...\nExpected Value | ...  }    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   }    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   ...\nActual Value   | ...  \\s   \\s   \\s   \\s   }    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   }    ,    \\r   \\n   \\s   \\s   ...\nExpected Code  | ...  125  13   10   32   32   32   32   32   32   32   32   125  44   13   10   32   32   32   32   32   32   ...\nActual Code    | ...  32   32   32   32   125  13   10   32   32   32   32   32   32   32   32   125  44   13   10   32   32   ...  \nDifference     |       |    |         |    |    |                                  |    |    |    |    |    |    |    |    |      \n               |      \\|/  \\|/       \\|/  \\|/  \\|/                                \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/     \nIndex          | ...  371  372  373  374  375  376  377  378  379  380  381  382  383  384  385  386  387  388  389  390  391  ...\nExpected Value | ...  \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \"    n    a    m    e    \"    :    \\s   \"    ...\nActual Value   | ...  \\s   \\s   \\s   {    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \"    n    a    m    e    ...\nExpected Code  | ...  13   10   32   32   32   32   32   32   32   32   32   32   34   110  97   109  101  34   58   32   34   ...\nActual Code    | ...  32   32   32   123  13   10   32   32   32   32   32   32   32   32   32   32   34   110  97   109  101  ...  \nDifference     |       |    |    |    |    |    |    |    |    |    |    |    |                                  |    |    |      \n               |      \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/  \\|/                                \\|/  \\|/  \\|/     \nIndex          | ...  390  391  392  393  394  395  396  397  398  399  400  401  402  403  404  405  406  407  408  409  410  ...\nExpected Value | ...  \\s   \"    i    d    \"    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \"    t    y    ...\nActual Value   | ...  m    e    \"    :    \\s   \"    i    d    \"    ,    \\r   \\n   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   \\s   ...\nExpected Code  | ...  32   34   105  100  34   44   13   10   32   32   32   32   32   32   32   32   32   32   34   116  121  ...\nActual Code    | ...  109  101  34   58   32   34   105  100  34   44   13   10   32   32   32   32   32   32   32   32   32   ...\n```\n. ",
    "kenrim626": "Did anyone have a further look at this issue? @ztripez showed that it is there and he even provided a possible solution. I think we should discuss what kind of functionality was destroyed with it and if we can find an alternative that fixes both (the original issue and the ones arisen from the possible solution).. The idea of NodaTime integration is great, but wouldn't it make sense to make a separate, optional package for it? I mean, not everyone needs NodaTime. . @johnrutherford Why not remove this commented areas? If required, git still has the records of them.. Why do you need the .ToList() here? For me it looks like it would suffice to use a IEnumerable<T> here and work with .Any(). This should be faster and more memory efficient.. If a List or an Array is fine, IEnumerable<T> would probably be enough, is it not? This way you could prevent the .ToList().. Why do you use .ToList() here? Guessing from the old usage, it seems to me that IEnumerable<T> would be fine.. ",
    "bryanjhogan": "Turing on the ExposeExceptions showed me my mistake. \nI am dynamically generating the the db queries, and while I updated the field map I forgot to update the mapping for my query.  I was sending a query to the db looking for \"startDate\" rather than \"Date\".\nThanks for the help. . ",
    "freakingawesome": "I've pushed up a change to improve the error message and added a test around the error.. I've pushed up another set of changes incorporating the GetFriendlyName() functionality (had to tweak it because IsGenericType isn't available in .net standard 1.x), but I've only changed the error message in this PR to incorporate the friendly type name extension. It looks like type names are used in a handful of other places and error messages, and perhaps it would be best to consolidate them all to use the friendly name, but that's probably best left to a new Issue.. Hmmm... that AppVeyor build failed on Operation_Can_Be_Cancelled - I don't think that was me that broke it . Yea, that's an odd failure. I haven't been able to reproduce it locally or make any sense of how my minor change could have caused the failure. I'm merging latest from master to trigger another build and will see what happens.. Another failed build - but this time it's failing on what looks like nuget trying to create a an invalid version string.. I think that latest nuget failure is caused by the / character in my branch name. I could close this and open up a new PR against a more appropriate branch name to see if that fixes it, if you think that would be beneficial.. Good call. I took a quick stab at updating the parser here, and while it works I wonder if it is too naive, since it just treats & as a comma-equivalent separator everywhere (if I'm reading this right). If you're ok with that update I'll open another PR for the parser.. Ha! No, we don't work together. Just a coincidence!\nLooks like that PR also addresses the other PR I had opened (also on the same day) for fixing the documentation descriptions (#982)\nI still think we'll need to update the parser to allow reading of &-separated interfaces to make sure graphql-dotnet can read in the same format it generates.. While this fixes the printing of field annotations specifically, there are further inconsistencies with how printing annotations is done which I've started addressing in another branch, but that will involve a lot of changes to the utilities tests and I haven't yet had time to fix all of them.. Sure thing!\n. ",
    "DSilence": "I'm willing to work on a PR if you guys are ok with it.. Decided to take API discussion from pull request to the issue, since it's easier to find here. \nI've given some thought to the WebSocket transport. The following solution might work:\n\nIDocumentWriter should be able to write OperationMessage. This could be achieved using the original generic Write method concept (possibly with some generic restriction only allowing ExecutionResult and OperationMessage).\nThe OperationMessage payload type should be changed to object or generic. This way we can store ExecutionResult without turning it into JObject for writing purposes. \n\n\nOption A: In WebSocketWriterPipeline we create a MemoryStream and use IDocumentWriter to write OperationMessage to the stream. We can then use TryGetBuffer to get the ArraySegment and send it over socket.  (Optional) The MemoryStream instances used by WebSocketWriterPipeline could use an ArrayPool to avoid extra allocations. \nOption B: We add an additional method to IDocumentWriter to write the object to ArraySegment or Memory. We can then use the produced entity to write it to a WebSocket channel.\n\n\n\nAlternative: A separate entity could be created specifically for writing OperationMessage.. Ping @BenjaBobs, @joemcbride. What do you think of this proposal?. Sounds good. Here is what I've had in mind for IDocumentWriter for that case. The challenge here is that to pool the byte array to avoid unnecessary allocations. So we need a proxy class for result that will be able to store the results of the serialization and return the array pool back after the response was processed.\nThe interface: \ncsharp\npublic interface IByteResult : IDisposable\n    {\n        ArraySegment<byte> Result { get; }\n    }\nThe implementation (note that a reference to System.Buffers is required):\n```csharp\npublic class PooledByteResult : IByteResult\n    {\n        private readonly byte[] _buffer;\n        private readonly ArrayPool _pool;\n    public PooledByteResult(ArrayPool<byte> pool, int minLength)\n    {\n        _pool = pool;\n        _buffer = _pool.Rent(minLength);\n        Stream = new MemoryStream(_buffer);\n    }\n\n    public ArraySegment<byte> Result { get; private set; }\n\n    internal MemoryStream Stream { get; }\n\n    internal void InitResponseFromCurrentStreamPosition()\n    {\n        Result = new ArraySegment<byte>(_buffer, 0, (int)Stream.Position);\n    }\n\n    private void ReleaseUnmanagedResources()\n    {\n        _pool.Return(_buffer);\n        Stream.Dispose();\n    }\n\n    public void Dispose()\n    {\n        ReleaseUnmanagedResources();\n        GC.SuppressFinalize(this);\n    }\n\n    ~PooledByteResult()\n    {\n        ReleaseUnmanagedResources();\n    }\n}\n\nResulting API for IDocumentWriter will look like this:csharp\npublic interface IDocumentWriter\n    {\n        Task WriteAsync(Stream stream, T value);\n    Task<IByteResult> WriteAsync<T>(T value);\n\n    [Obsolete(\"This method is obsolete and will be removed in the next major version.  Use WriteAsync instead.\")]\n    string Write(object value);\n}\n\nImplementation:csharp\npublic class DocumentWriter : IDocumentWriter\n    {\n        private readonly ArrayPool _pool = ArrayPool.Shared;\n        private readonly int _maxArrayLength = 1048576;\n        private readonly JsonSerializer _serializer;\n        private static readonly Encoding Utf8Encoding = new UTF8Encoding(false);\n    public DocumentWriter()\n        : this(indent: false)\n    {\n    }\n\n    public DocumentWriter(bool indent)\n        : this(\n            indent ? Formatting.Indented : Formatting.None,\n            new JsonSerializerSettings())\n    {\n    }\n\n    public DocumentWriter(Formatting formatting, JsonSerializerSettings settings)\n    {\n        _serializer = JsonSerializer.CreateDefault(settings);\n        _serializer.Formatting = formatting;\n    }\n\n    public Task WriteAsync<T>(Stream stream, T value)\n    {\n        using (var writer = new StreamWriter(stream, Utf8Encoding, 1024, true))\n        using (var jsonWriter = new JsonTextWriter(writer))\n        {\n            _serializer.Serialize(jsonWriter, value);\n        }\n\n        return TaskExtensions.CompletedTask;\n    }\n\n    public async Task<IByteResult> WriteAsync<T>(T value)\n    {\n        var pooledDocumentResult = new PooledByteResult(_pool, _maxArrayLength);\n        var stream = pooledDocumentResult.Stream;\n        try\n        {\n            await WriteAsync(stream, value).ConfigureAwait(false);\n            pooledDocumentResult.InitResponseFromCurrentStreamPosition();\n            return pooledDocumentResult;\n        }\n        catch (Exception)\n        {\n            pooledDocumentResult.Dispose();\n            throw;\n        }\n    }\n\n    public string Write(object value)\n    {\n        return this.WriteToStringAsync((ExecutionResult) value).GetAwaiter().GetResult();\n    }\n}\n\n```\nI believe this covers all our cases.. Sounds like a good idea. This could be added as another extension method. I'll update the PR.. Added an overload to write to JObject. . Updated the pull according to ideas from #798.. Some more improvements added:\n\nPooling for JsonTextWriter\nFlush to response stream async\nUsed the HttpResponseStreamWriter from Microsoft.AspNetCore.WebUtilities to pool memory (in place of StreamWriter). In addition it should be more async friendly.. Gentle ping, the build seems to be failing because of the branch name. I can create a PR with a different branch name if needed.. @johnrutherford, I'm willing to work on it.. Unfortunately, DbContext is not capable of doing multiple requests at the same time. Using transient DbContext is an option, but you have to carefully dispose of them later, and usage of DbContextFactory may be broken.\nYou may also try creating a custom context in your resolve methods (or somewhere in you dataloader methods) and use it to work with DbContext.\ncsharp\n    Field<UserType>(\n                \"getUser\",\n                arguments: new QueryArguments(\n                    new QueryArgument<NonNullGraphType<StringGraphType>> {Name = \"name\"}\n                ),\n                resolve: context =>\n                {\n                    var name = context.GetArgument(\"name\", \"\");\n                    using (var scope = _serviceProvider.CreateScope())\n                    {\n                        var dbContext = scope.ServiceProvider.GetService<DbContext>();\n                        var user = await dbContext.Users.FirstAsync(e => e.Name == name);\n                        return user;\n                    }\n                });. @AmbroiseCouissin , @joemcbride, Yep, that should solve the issue. The hard limit should only be valid for websocket requests, but since the backwards-compatible Write method is using the same code as well, it's affected by this change.\nAs a side note, I probably should have left the implementation of old method as is. I'll make a quick PR to fix it.\nAlso, If there is a need to have a larger websocket responses, it should be possible to use https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream in place of PooledByteResult solution that I wrote. It has support for resizing.. I'm also experimenting on the server project with alternative Stream API for writing websockets. Something like this\n```csharp\n public class WebsocketWriterStream : Stream\n    {\n        private readonly WebSocket _webSocket;public WebsocketWriterStream(WebSocket webSocket)\n{\n    _webSocket = webSocket;\n}\n\npublic override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)\n{\n    return _webSocket.SendAsync(new ArraySegment<byte>(buffer, offset, count), WebSocketMessageType.Text, false,\n        cancellationToken);\n}\n\npublic override Task FlushAsync(CancellationToken cancellationToken)\n{\n    return _webSocket.SendAsync(new ArraySegment<byte>(Array.Empty<byte>()), WebSocketMessageType.Text, true, cancellationToken);\n}\n\n}\nThis way the whole buffered thing will not actually be needed, websockets will support messages of any size, and DocumentWriter could be reduced to a single method.\n. @joemcbride There is a hard limit on ArrayPool.Shared as specified here (https://adamsitnik.com/Array-Pool/). It's used in my implementation to pool the byte arrays for DocumentWriter method that's supposed to write to sockets. The hard limit though should be 1mb, not 1024KB. \nThe new, WriteAsync method should work just fine and should not have any limits.\nAt the moment, I'm working on server project to possibly have a stream-based response writing. For the time being, I've created a PR which restores the old implementation for the method that writes to string to avoid any explicit limits.. Gotcha, will mark it as obsolete for now in a separate pull request.. It's possible to do it for responses - you just have to implement a custom IDocumentWriter. Once https://github.com/graphql-dotnet/server/pull/174 is merged, I'm planning to provide a nuget package for that (or, if the maintainers are interested, making it a part of official distribution). It's not possible for request variables for now - I've been looking for ways of changing that, but the implementation is too JToken dependent for now, and it's probably required to build and extra abstraction as a workaround - someone from maintainers should confirm that.. Here is a sample DocumentWriter using Utf8Jsoncsharp\npublic class Utf8JsonDocumentWriter : IDocumentWriter\n{\n    private readonly IJsonFormatterResolver _jsonFormatterResolver;\npublic Utf8JsonDocumentWriter()\n{\n    _jsonFormatterResolver = CompositeResolver.Create(new IJsonFormatter[] {new ExecutionResultJsonFormatter()},\n        new[] { StandardResolver.CamelCase });\n}\n\npublic Task WriteAsync<T>(Stream stream, T value)\n{\n    return JsonSerializer.SerializeAsync(stream, value);\n}\n\npublic Task<IByteResult> WriteAsync<T>(T value)\n{\n    var result = JsonSerializer.SerializeUnsafe(value);\n    return Task.FromResult<IByteResult>(new Utf8ByteResult(result));\n}\n\npublic string Write(object value)\n{\n    return JsonSerializer.NonGeneric.ToJsonString(value, _jsonFormatterResolver);\n}\n\nprivate class Utf8ByteResult : IByteResult\n{\n    public Utf8ByteResult(ArraySegment<byte> result)\n    {\n        Result = result;\n    }\n\n    public void Dispose()\n    {\n    }\n\n    public ArraySegment<byte> Result { get; }\n}\n\n}\ncsharp\npublic class ExecutionResultJsonFormatter : IJsonFormatter\n{\n    public void Serialize(ref JsonWriter writer, ExecutionResult value, IJsonFormatterResolver formatterResolver)\n    {\n        writer.WriteBeginObject();\n        var shouldWriteData = (value.Errors == null || value.Errors.Count == 0) && value.Data != null;\n        var shouldWriteErrors = value.Errors != null && value.Errors.Count > 0;\n        var shouldWriteExtensions = value.Data != null && value.Extensions != null && value.Extensions.Count > 0;\n        var separated = false;\n        if (shouldWriteData)\n        {\n            WriteData(ref writer, value, formatterResolver);\n            separated = true;\n        }\n    if (shouldWriteErrors)\n    {\n        if (separated)\n        {\n            writer.WriteValueSeparator();\n        }\n        WriteErrors(ref writer, value.Errors, formatterResolver, value.ExposeExceptions);\n        separated = true;\n    }\n\n    if (shouldWriteExtensions)\n    {\n        if (separated)\n        {\n            writer.WriteValueSeparator();\n        }\n        WriteExtensions(ref writer, value, formatterResolver);\n    }\n\n    writer.WriteEndObject();\n}\n\npublic ExecutionResult Deserialize(ref JsonReader reader, IJsonFormatterResolver formatterResolver)\n{\n    throw new NotImplementedException();\n}\n\nprivate void WriteExtensions(ref JsonWriter writer, ExecutionResult value, IJsonFormatterResolver formatterResolver)\n{\n    writer.WritePropertyName(\"extensions\");\n    formatterResolver.GetFormatter<Dictionary<string, object>>().Serialize(ref writer, value.Extensions, formatterResolver);\n}\n\nprivate void WriteData(ref JsonWriter writer, ExecutionResult result, IJsonFormatterResolver formatterResolver)\n{\n    writer.WritePropertyName(\"data\");\n    formatterResolver.GetFormatter<object>().Serialize(ref writer, result.Data, formatterResolver);\n}\n\nprivate void WriteErrors(ref JsonWriter writer, ExecutionErrors errors, IJsonFormatterResolver formatterResolver, bool exposeExceptions)\n{\n    writer.WritePropertyName(nameof(errors));\n    writer.WriteBeginArray();\n    var separated = false;\n    foreach (var error in errors)\n    {\n        if(separated)\n            writer.WriteValueSeparator();\n\n        writer.WriteBeginObject();\n        writer.WritePropertyName(\"message\");\n        writer.WriteString(exposeExceptions ? error.ToString() : error.Message);\n        if (error.Locations != null)\n        {\n            writer.WriteValueSeparator();\n            writer.WritePropertyName(\"locations\");\n            writer.WriteBeginArray();\n            foreach (var location in error.Locations)\n            {\n                writer.WriteBeginObject();\n                writer.WritePropertyName(\"line\");\n                writer.WriteInt32(location.Line);\n                writer.WriteValueSeparator();\n                writer.WritePropertyName(\"column\");\n                writer.WriteInt32(location.Column);\n                writer.WriteEndObject();\n            }\n\n            writer.WriteEndArray();\n        }\n\n        if (error.Path != null && error.Path.Any())\n        {\n            writer.WriteValueSeparator();\n            writer.WritePropertyName(\"path\");\n            formatterResolver.GetFormatter<IEnumerable<string>>().Serialize(ref writer, error.Path, formatterResolver);\n        }\n\n        WriteErrorExtensions(ref writer, error, formatterResolver);\n\n        writer.WriteEndObject();\n        separated = true;\n    }\n\n    writer.WriteEndArray();\n}\n\nprivate void WriteErrorExtensions(ref JsonWriter writer, ExecutionError error, IJsonFormatterResolver formatterResolver)\n{\n    if(string.IsNullOrWhiteSpace(error.Code) && error.Data.Count == 0)\n    {\n        return;\n    }\n\n    writer.WriteValueSeparator();\n\n    writer.WritePropertyName(\"extensions\");\n    writer.WriteBeginObject();\n\n    var extSeparated = false;\n    if (!string.IsNullOrWhiteSpace(error.Code))\n    {\n        writer.WritePropertyName(\"code\");\n        writer.WriteString(error.Code);\n        extSeparated = true;\n    }\n\n    if (error.Data.Count > 0)\n    {\n        if (extSeparated)\n        {\n            writer.WriteValueSeparator();\n        }\n        writer.WritePropertyName(\"data\");\n        writer.WriteBeginObject();\n        var separated = false;\n        foreach (var entry in error.DataAsDictionary)\n        {\n            if (separated)\n                writer.WriteValueSeparator();\n            writer.WritePropertyName(entry.Key);\n            formatterResolver.GetFormatter<object>().Serialize(ref writer, entry.Value, formatterResolver);\n            separated = true;\n        }\n        writer.WriteEndObject();\n    }\n\n    writer.WriteEndObject();\n}\n\n}\nThe ExecutionResultJsonFormatter is not the most performant for now (e.g. property names could be cached) but it works.. Thanks for your comment @joemcbride! I was wondering if there is demand for replacing JsonNet for the process of reading values. For our project we're OK with using JsonNet for that, but others might need that functionality. If that is the case, there is a point in creating an abstraction for that (and I do realize that the task is far from trivial due to dynamic nature of variables).. It does work. \nThe reason I chose not to call JObject.Parse is that\ninternally, JObject.FromObject just serializes into JTokenWriter anyway. \nhttps://github.com/JamesNK/Newtonsoft.Json/blob/master/Src/Newtonsoft.Json/Linq/JToken.cs#L1881.\nSince DocumentWriter might potentially customize the serialization workflow, I chose to use this approach. In addition, there is no need to pass JsonSerializer here - the one in DocumentWriter will be reused.. ini\n\n\nBenchmarkDotNet=v0.11.0, OS=Windows 10.0.17134.254 (1803/April2018Update/Redstone4)\nIntel Core i7-7700HQ CPU 2.80GHz (Max: 0.80GHz) (Kaby Lake), 1 CPU, 8 logical and 4 physical cores\n.NET Core SDK=2.1.401\n  [Host]     : .NET Core 2.1.2 (CoreCLR 4.6.26628.05, CoreFX 4.6.26629.01), 64bit RyuJIT\n  DefaultJob : .NET Core 2.1.2 (CoreCLR 4.6.26628.05, CoreFX 4.6.26629.01), 64bit RyuJIT\n```\n|              Method |     Mean |    Error |   StdDev |     Gen 0 |     Gen 1 |    Gen 2 | Allocated |\n|-------------------- |---------:|---------:|---------:|----------:|----------:|---------:|----------:|\n|          FromObject | 122.1 ms | 2.428 ms | 5.226 ms | 4800.0000 | 2000.0000 | 600.0000 |  25.81 MB |\n| UsingDocumentWriter | 131.9 ms | 2.634 ms | 4.882 ms | 6000.0000 | 2500.0000 | 500.0000 |   36.3 MB |\nFromObject will be faster. Both options are very slow in general and allocate a lot of memory (Compare this with the results of direct stream writing, it's using the same test set). I think we need to consider a better alternative than passing JObjects for WebSocket API. . Yeah, I think we need to come up with something else for websockets. I'll remove the method for now.. ",
    "larsbloch": "I Found this \"solution\" I think it would be cool if it was placed in the example somehow as it can cause confusion with some people like myself who might be new in this area.\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/560\n```\nstring[] fields = ...\nvar loader = accessor.Context.GetOrAddBatchLoader($\"GetUsersById[{String.Join(\",\", fields)}]\", \n    (ids) => store.GetUsersByIdAsync(ids, fields));\nreturn loader.LoadAsync(context.Source.UserId);\n```. ",
    "VladimirAkopyan": "Thanks a lot for the feedback.\nI am using  Microsoft.AspNetCore.Mvc.Testing, and it provides you with an HTTPclient implementation that will send requests to the test server.\nCSHARP\n    TestServer server = new TestServer(new WebHostBuilder());\n    HttpClient client = server.CreateClient();\nUsing JSON.Net to serialise GraphQLRequest to JSON works fine. Then it can be submitted in the body of an HTTPRequest using that HTTPclient. \nI wanted to use GraphQLClient as that would make testing more convenient. To do that I would need to replace HTTPClient used in GraphQLHttpHandler  or GrapQLClient to the one produced by the TestServer. \nCurrently GraphQLHttpHandler class is marked as internal in V2, and HTTPClient is marked as internal in version 1. \nAt the moment I am using reflection to replace the HTTPClient as follows: \nCSharp\npublic GraphQLClient GetClient()\n{\n    // For version 1 of the GraphQL client \n     GraphQLClient gqlClient = new GraphQLClient(\"http://localhost/graphql\");\n     typeof(GraphQLClient).GetField(\"httpClient\", BindingFlags.NonPublic | BindingFlags.Instance).SetValue(gqlClient, Client);\n     return gqlClient; \n}\nThis works well but the code will break if you change the library. I see that you are switching to GraphQLHTTPClient and it has a constructor that takes an HTTPCLient\n```CSHARP\ninternal GraphQLHttpClient(GraphQLHttpClientOptions options,HttpClient httpClient) {\n    if (options == null) { throw new ArgumentNullException(nameof(options)); }\n    if (options.EndPoint == null) { throw new ArgumentNullException(nameof(options.EndPoint)); }\n    if (options.JsonSerializerSettings == null) { throw new ArgumentNullException(nameof(options.JsonSerializerSettings)); }\n    if (options.HttpMessageHandler == null) { throw new ArgumentNullException(nameof(options.HttpMessageHandler)); }\n    if (options.MediaType == null) { throw new ArgumentNullException(nameof(options.MediaType)); }\nthis.graphQLHttpHandler = new GraphQLHttpHandler(options,httpClient);\n\n}\n```\nCould we make this public? . Thank you deinok, i am not sure how I missed that. . ",
    "codinglikejesus": "Hello joemcbride, and thank you for your answer.\nConsidering this happens on all queries (of which there are dozens) regardless of the fields i'm trying to access, why would this be happening after i've upgraded the packet? The rest of the code was left the same as before the upgrade (when all queries worked correctly) which is the part that really confuses me.\nI have quite a limited lack of knowledge in regards to graphql, and I wasn't involved in setting the whole thing up for our project initially so there could definately be something i'm missing. Anyways, your help is very much appreciated.. > \n\n\nHello joemcbride, and thank you for your answer.\nConsidering this happens on all queries (of which there are dozens) regardless of the fields i'm trying to access, why would this be happening after i've upgraded the packet? The rest of the code was left the same as before the upgrade (when all queries worked correctly) which is the part that really confuses me.\nI have quite a limited lack of knowledge in regards to graphql, and I wasn't involved in setting the whole thing up for our project initially so there could definately be something i'm missing. Anyways, your help is very much appreciated.\n\nHey Coding, how did you solve this? I've run into the same problem after upgrading where if a query one field it throws this on another.\n\nHey, I stopped working on that project so I haven't even tried to get it running. Apparently you did get a answer so good for you :). ",
    "cotzo": "Hey. Any ETA for when this will be published so we can also have #812?\nThanks. ",
    "ennui": "Thank you so much. It's works great! I did not even think in this direction. ",
    "angular-patterns": "Thanks, that fixed it. ",
    "gbiellem": "What I was trying to achieve here has been addressed in Simon Cropp's GraphQL.EntityFramework project.\nThe GlobalFilter is exactly what i was looking for.  It's definitely neater than my proposed change here\n. ",
    "Patrick-Spiegel": "Alright. I will just wait for a new Release as it is currently not too urgent. \n\ud83d\udc4d . @joemcbride any plans on making a new Bugfix release? . Is there a reason why this Async method is not awaitable?. ",
    "alexb5dh": "Yes, found an issue in JSON.NET configuration.\nThanks.. Can it be created in similar fashion to ListGraphType?  It does support subfields queries. . ",
    "klacol": "sorry, wrong repo. ",
    "jumpinjackie": "If it helps, I use an extension method (off of ObjectGraphType<T>) to farm off field registrations for common sets of properties (from interfaces or base classes, which you would constrain T to in your extension method), so that instead of duplicating the field registrations over and over, just call the common extension method instead to do it all for you.. Currently, yes: We use registration extension methods for certain interfaces in our GraphQL-visible types.\n~~Though if you want to take this to the extreme, you could do this generically by using reflection and reflect on typeof(T) to look for properties of a certain custom attribute (eg. [GraphQLField]) to perform field registrations (as Field() has non-generic overloads that can work with string property names and System.Type type, which you can slot in whatever your reflected PropertyInfo instances give back)~~\n~~Which your hypothetical BaseObjectGraphType<T1, T2> could probably automagically do for you.~~\n~~And if you really want to be adventurous, you could try looking for methods of a certain signature (a method that takes the GraphQL resolver context (ResolveFieldContext<T>) and returns a known GraphQL base type) with another custom attribute (eg. [GraphQLResolvedField]) to perform resolved field registrations. I haven't fully thought through if C# generics is expressive enough to allow us to do this, so I may be talking about something which is not possible.~~\nEDIT: Just use AutoRegisteringObjectGraphType or do what it does\n. If it helps, assuming you're using MVC core what we've done is modify our Program.cs so that if a certain argument is present (eg. generate), we build the aspnetcore web host but do not run it. We then resolve GraphQL's IDocumentExecuter from the built DI container and use it to run the introspection query and dump the result and exit afterwards.. This happens because the apollo tracing enrichment blindly assumes the perf records on the execution result have all the required categories present: operation/document/field\nIf one of these categories is not present in the perf records, you get the aforementioned error.\nWe've worked around this by adding this simple check and enrich with apollo tracing only if the check returns true:\nstatic bool CanEnrich(ExecutionResult result)\n        {\n            var hasOp = result?.Perf?.Any(x => x.Category == \"operation\");\n            var hasDoc = result?.Perf?.Any(x => x.Category == \"document\");\n            var hasField = result?.Perf?.Any(x => x.Category == \"field\");\n            return hasOp == true && hasDoc == true && hasField == true;\n        }. ",
    "JamiePed": "Interesting, so you have a separate Extension method for each interface type you want to inherit fields from? That isn't too bad a way to share that logic without flat out copying it!\nI may investigate creating either some kind of BaseObjectGraphType<T1, T2> or create a this.Base<T>() method that might be able to automagically import some stuff. If I get anything working I'll try to create a PR for it\n. ",
    "MustaMohamed": "Thank you BenjaBobs, but unfortunately this is not what I want.\nI want to use the grahpql direct with sql server queries.\nSo I am able to write sql select query and it's executed on the database, or something like that. So I am able to talk direct to the database not using entity framework.\nThank you again.. ",
    "tomasmcguinness": "I will try and create a project with a simple demo of the problem over the next couple of days. An issue (https://github.com/graphql-dotnet/server/issues/162) was opened and that's how I came across the problem. That might give you some pointers. Essentially, subscriptions don't work if a DataLoader service is added.. ",
    "darbio": "Hi @joemcbride - thanks for taking the time to look at this.\nI changed the name of IncidentTypeEnum to reflect the proper type name \"IncidentTypeEnum\" so it now represents below:\nIncidentTypeEnum.cs\n```\n    public class IncidentTypeEnum : EnumerationGraphType\n    {\n        public IncidentTypeEnum()\n        {\n            Name = \"IncidentTypeEnum\";\n        AddValue(\"Bushfire\", \"Bush fire incident\", 0);\n        AddValue(\"MVA\", \"Motor vehicle incident\", 1);\n    }\n}\n\n```\nIncidentType is a c# class as per below. The properties are contained in this type (and it probably needs to be renamed - bad name because there is already an Incident type) so I can see the confusion.\nIncidentType.cs\n```\n    public class IncidentType : ObjectGraphType\n    {\n        public Guid Id { get; set; }\n        public IncidentTypeEnum Type { get; set; }\n        public double Latitude { get; set; }\n        public double Longitude { get; set; }\n    public IncidentType()\n    {\n        Name = \"incident\";\n\n        Field(x => x.Id, type: typeof(IdGraphType));\n        Field(x => x.Type, type: typeof(IncidentTypeEnum));\n        Field(x => x.Latitude);\n        Field(x => x.Longitude);\n    }\n}\n\n```\nException:\n\"GraphQL.ExecutionError: Error trying to resolve createIncident. ---> System.InvalidOperationException: Could not find conversion from System.Int32 to Siren.UI.WebApi.Models.IncidentTypeEnum\n   at GraphQL.ValueConverter.GetConversion(Type valueType, Type targetType)\n   at GraphQL.ValueConverter.ConvertTo(Object value, Type targetType)\n   at GraphQL.ObjectExtensions.ToObject(IDictionary`2 source, Type type)\n   at GraphQL.Types.ResolveFieldContext`1.GetArgument[TType](String name, TType defaultValue)\n   at Siren.UI.WebApi.Models.IncidentMutation.<>c__DisplayClass0_0.<<-ctor>b__0>d.MoveNext() in /Users/darbio/SirenDotNet/Siren.UI.WebApi/Models/IncidentMutation.cs:line 25\n--- End of stack trace from previous location where exception was thrown ---\n   at GraphQL.Execution.ExecutionHelper.UnwrapResultAsync(Object result)\n   at GraphQL.Execution.ExecutionStrategy.ExecuteNodeAsync(ExecutionContext context, ExecutionNode node)\n   --- End of inner exception stack trace ---\". Cheers. I'll give it a go and get back to you. How does it know what enum to convert it to? Is it based on the number of the name?\nUPDATE: It works, thanks!. ",
    "mrezmerita": "Thank you,\nIt makes sense.\nWe'll modfy the mutation in order to return less data but it is not ideal as it could force the client application to refetch with a query in order to obtain all the details. \nI assume that there is not much else that we can do about it, for now. \n. ",
    "minuseight": "We are also experiencing this error.\nGraphQL.ExecutionError: Could not find conversion from System.Single to System.Double\nAdding the code suggested fixed the issue:\nValueConverter.Register(\n                typeof(float),\n                typeof(double),\n                value => Convert.ToDouble(Math.Round((float)value, 3, MidpointRounding.AwayFromZero), NumberFormatInfo.InvariantInfo));. ",
    "joro550": "Yes this is possible, but it is kind of hidden away in the documentation, let me point it out so it may become clearer: https://graphql-dotnet.github.io/docs/getting-started/dependency-injection\nThis page talks about dependency injection in your query typs if you look very closely you'll see \nservices.AddSingleton<IDependencyResolver>(s => new FuncDependencyResolver(s.GetRequiredService));\nThis is what you need to hook into, the \"s\" here will be your dependency injection library of choice, so in your example unity, and you give it the function that will \"resolve the types\" which looks like it's something like:\n_container.Resolve\nSo in your case it would be \nservices.RegisterType<IDependencyResolver>(s => new FuncDependencyResolver(s.Resolve));\nThen when you set up your schema make sure to use the resolver to inject in your types:\npublic class StarWarsSchema : GraphQL.Types.Schema\n{\n  public StarWarsSchema(IDependencyResolver resolver)\n    : base(resolver)\n  {\n    Query = resolver.Resolve<StarWarsQuery>();\n    Mutation = resolver.Resolve<StarWarsMutation>();\n  }\n}\nand viola, everything should work - hope this helps. ",
    "clustersnake": "@joro550 \nWow! I was working on frontend tasks and I just forgot about this for a little. I'm going to try it right now.Thank you very much!. @joro550 maybe I'm just too noob to this. I have to really learn this\n\n. @joemcbride thanks, I have to learn DI in detail. I'm actually playing the one man band role and since the app is running I have to move on without it :-/ . ",
    "Prof3ssa": "Thank you for your contribution guys .. fixed the error.. ",
    "dimortizp": "Hi @joemcbride \nWhat do you mean on \"unique type name\"?\nMy ResponseRegister is like this: \npublic class ResponseRegister : ObjectGraphType>\n    {\n        public ResponseRegister(){\n             Field(x => x.Error, nullable:true).Description(\"Hay error\");\n             Field,IEnumerable >()\n                .Description(\"Lista de errores\")\n                .Name(\"ErrorList\");\n             Field()\n                .Name(\"Entity\")\n                .Description(\"Entity\");\n        }\n    }\nAnd in the implementations, I'm trying to do it in this way\nField> with the name CreateStudent\nField> with the name CreateTeacher\nIf I try to call the mutation the autocomplete always shows me \nthe option of the TeacherType for the response of the migration, in this way\nmutation{\n  createSchool\n  (\n    school:\n    {\n      name:\"test school same ID\"\n      internalIdentification:\"800236529\"\n    }\n  ) {\n    entity{\n      userId\n    }\n  }\n}\nBut the parameter userId doesn't belongs to StudentType, it belongs to TeacherType.. Hi @joemcbride \nNow I got what you meant. The issue was caused because I didn't add a unique name for the generic ObjectGraphType. It was solved just by doing this:\npublic class ResponseRegister : ObjectGraphType>\n    {\n        public ResponseRegister(){\n            Name=typeof(TEntity).Name;\n            Field(x => x.Error, nullable:true).Description(\"Hay error\");\n            Field,IEnumerable >()\n            .Description(\"Lista de errores\")\n            .Name(\"ErrorList\");\n            Field()\n            .Name(\"Entity\")\n            .Description(\"Entity\");\n        }\n    }\nThanks. ",
    "bmmathe": "Ah, I thought the GraphiQL plugin for .Net Core was written by you guys.  Guess not.  All I did was add the GraphiQL nuget package and added the app.UseGraphiQl() line.\nThe nuget package includes a react app that is the GraphiQL web site.  It just hosts the files under the /graphql endpoint.  If a browser hits /graphql the react files are returned.  Like I said, the site loads fine it's just that the requests are being made to the base URL + /graphql instead of my reverse proxy address.. Thanks guys!  \nThere seem to be two solutions to this problem specifically with GraphiQL.\n1) The prerelease version of GraphiQL has a new variable in the app.UseGraphiQL method called \"apiPath\" which lets you specify the API base path.\napp.UseGraphiQL(\"graphql\", \"urlstem\")\n2) As @pekkah suggested you can also add app.UsePathBase(\"/urlStem\") which also fixes the issue.. ",
    "nojaf": "If you can give me some pointer how to tackle this, I'm willing to try this myself.\n. ",
    "rajmondburgaj": "Cool, that worked for me. Thanks for the info :) . ",
    "lyrana": "Following. ",
    "justusburger": "It makes perfect sense considering the implemented (and desired) behaviour as demonstrated here:\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/master/src/GraphQL/DataLoader/DataLoaderContext.cs#L52\nAlso, obviously what one uses the DataLoaders for is ones own concern and out of the domain of the library. Just wondering if there is something obvious I'm missing.\n. ",
    "kefengwei": "I have the same problem. is there a better solution?. ",
    "BottlecapDave": "I have also just hit this issue with a .NET Core implementation. Unfortunately, I think it's something that most people will hit if they use EF with the default settings, as the DbContext is scoped by default. This means that not only does this issue arise for data loaders, but also potentially query requests that contain multiple queries as they are executed in parallel.\nLike DSilence suggested, you could create new a DbContext for each resolver, but depending on the size of the DbContext this could be expensive creating the model each time (creating relationships etc). \nFor the data loader situation, it would be nice if there was a toggle (off by default) which could have the data loaders dispatch sequentially instead of in parallel.. Ok thanks for the quick response. ",
    "zjean": "Thanks for your suggestions!. ",
    "dietergoetelen": "Same issue here. Using the following dependencies: \n<ItemGroup>\n    <PackageReference Include=\"Autofac\" Version=\"4.8.1\" />\n    <PackageReference Include=\"Autofac.Extensions.DependencyInjection\" Version=\"4.3.1\" />\n    <PackageReference Include=\"AutoMapper\" Version=\"7.0.1\" />\n    <PackageReference Include=\"GraphiQL\" Version=\"1.2.0\" />\n    <PackageReference Include=\"GraphQL\" Version=\"2.3.0\" />\n    <PackageReference Include=\"MediatR\" Version=\"5.1.0\" />\n    <PackageReference Include=\"Microsoft.AspNetCore.App\" />\n    <PackageReference Include=\"Microsoft.AspNetCore.Razor.Design\" Version=\"2.1.2\" PrivateAssets=\"All\" />\n    <PackageReference Include=\"NLog\" Version=\"4.5.11\" />\n    <PackageReference Include=\"NLog.Web.AspNetCore\" Version=\"4.7.0\" />\n  </ItemGroup>. @joemcbride sorry, it's working now, my issue was because I didn't entirely understand step 3 in the documentation. Once I've added the DataLoaderDocumentListener to the listeners array everything started working fine.\n```\nvar executionOptions = new ExecutionOptions\n{\n    Schema = _schema,\n    Query = query.Query,\n    Inputs = inputs\n};\nexecutionOptions.Listeners.Add(_listener);\nvar result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\n```\nI'm using the latest .NET Core framework.. ",
    "tDuy": "same issue in .Net Core 2.1. ",
    "stripeyjumper": "I have the same issue, on .Net Core 2.1.\nWeirdly, even though it's registered as a singleton, my services are receiving different instances of the DataLoaderContextAccessor.  \nI don't know if it's a problem with the dependency injection service or graphql-dotnet, but my solution is to manually create an instance of DataLoaderContextAccessor in Startup.cs:\ncs\nservices.AddSingleton<IDataLoaderContextAccessor>(new DataLoaderContextAccessor());. ",
    "aoakeson": "I did exactly what @hades200082 did, and now I am getting an error \"No service for type 'GraphQL.DataLoader.DataLoaderDocumentListener' has been registered.\"\nI am definitely registering it in startup.cs using \ndiSvcs.AddSingleton<IDocumentExecutionListener, DataLoaderDocumentListener>();\nAnd calling it here in my GraphQL Controller:\nvar listener = _provider.GetRequiredService<DataLoaderDocumentListener>();\n            executionOptions.Listeners.Add(listener);\nThis is where I get the exception.  Any ideas? . @johnrutherford Thanks, that did help me in finding the issue.  Think I was getting confused based on different articles, repos, and docs that were doing things differently. . I attempted to use ShortGraphType, and was getting Expected non-null value, resolve delegate return null for \"$GraphQL.Types.ShortGraphType\".  I added it to the DI container, and it started working.  Is this by design? Or should it work like the other scalar types like string. Imo I shouldnt have to register these custom types. . Thanks for the explanation @joemcbride. It all makes sense.  Im pretty new to this project, but I'm in the process of converting my companys web api to using this. Its been great to learn and work with.  Hope to be able to contribute in the future.  Huge thumbs up. . ",
    "lanwin": "Thanks for your answer. Your are right, I think I misunderstood what the persistent AST is used for.  . ",
    "bugged84": "@DenisAloner I'm having the same issue. Why was this issue closed without being addressed? GuidGraphType does not seem to work because the value is always StringValue.. @joemcbride is there an ETA on the next deployment?. If I change my query to pass the argument inline rather than using a variable, then it works.\n```\n{\n    \"query\": \"mutation {\n        updateAnimal(animal: { id: \\\"7f100a22-3bd2-e811-af11-00155dfa2f51\\\", name: \\\"Bones2\\\" }) {\n            id,\n            name\n        }\n    }\"\n}\nSo what is wrong with my original query using variables?\n``. @joemcbride any thoughts on this one?. Yes, I'm passing variables to the executor by assigning the result ofToInputsto theExecutionOptions.Inputs` property.\nRegistering the GuidValueConverter implementation you provided fixed the issue for me. Thanks for that.. @bogdancice but if they are all singleton, then how are you getting scoped dependencies? For example, you wouldn't want to share a single Entity Framework DbContext between all mutation requests. Are you injecting factories everywhere instead?. @bogdancice I use Autofac for my DI and I've solved the issue by using two DbContext registrations.\nThe first is registered with a lifetime scope per request and is resolved by key for my repositories (read-only).\n```\nprivate static void RegisterRepositories(ContainerBuilder builder)\n{\n   const string repositoryClassNameSuffix = \"Repository\";\nbuilder\n     .Register(GetMyContext)\n     .Named(repositoryClassNameSuffix)\n      // All repository instances can share a context per request (e.g. read-only)\n     .InstancePerLifetimeScope();\nbuilder\n     .RegisterAssemblyTypes(typeof(MyRepository).Assembly)\n     .Where(t => t.Name.EndsWith(repositoryClassNameSuffix))\n     .AsImplementedInterfaces()\n     .WithParameter(\n         (info, context) => info.ParameterType == typeof(DbContext)\n       , (info, context) =>\n            context.ResolveNamed(repositoryClassNameSuffix)\n      )\n     .InstancePerLifetimeScope();\n}\n```\nThe second is registered with a lifetime scope per dependency and is resolved by key as a Func<DbContext> for my mutation services.\n```\nprivate static void RegisterServices(ContainerBuilder builder)\n{\n   const string serviceClassNameSuffix = \"Service\";\nbuilder\n     .Register(GetMyContext)\n     .Named(serviceClassNameSuffix)\n      // Each service instance needs a separate context per unit of work\n     .InstancePerDependency();\nFunc GetDbContextFactory(IComponentContext context)\n   {\n       return\n           () => context.Resolve().ResolveNamed(serviceClassNameSuffix);\n   }\nbuilder\n     .RegisterAssemblyTypes(typeof(MyService).Assembly)\n     .Where(t => t.Name.EndsWith(serviceClassNameSuffix))\n     .AsImplementedInterfaces()\n     .WithParameter(\n         (info, context) => info.ParameterType == typeof(Func)\n       , (info, context) => GetDbContextFactory(context)\n      )\n     .InstancePerLifetimeScope();\n}\n```\nWithin my services I just write mutations like this:\nusing (var uow = dbContextFactory())\n{\n    ...\n    await uow.SaveChangesAsync();\n}. > One thing to also know is that all Graph types take on the same lifetime of the Schema. So a Graph type is only created once for a given Schema instance and is reused. So depending on your injected services you could have similar issues even when not Singleton.\n@joemcbride I have my schema registered as a transient service rather than singleton. The original question was: is there a reason not to do so?. @joemcbride I have not noticed any performance issues so far. How would you determine whether a schema is \"large\"? Total number of graph types defined? Total number of queries on the root? Is there a ballpark number you can share to give me an idea of what to test for?. > Generally, and this is my experience using Framework without any DI, most things can either be passed through and/or you can reference a public static class.\n\nI've yet to run into anything that \"required' DI.\nThat said, someone with more DI experience may be able to chime in.\n\nHow would you get runtime dependencies such as an HTTP request context by using only static classes?. > @bugged84 Not at this time. Right now the field middleware is created using Activator.CreateInstance.\nHow do you feel about something like this instead? There would need to be some fail checks of course.\n```\nvar args = new List();\nforeach (var c in typeof(MyMiddleware).GetConstructors(BindingFlags.Public))\n{\n   foreach (var p in c.GetParameters())\n   {\n      args.Add(_dependencyResolver.Resolve(p.ParameterType));\n   }\n}\nActivator.CreateInstance(typeof(MyMiddleware), args);\n```\nWe could also add the dependencies to the Invoke method. The arguments to that method would be reflected and resolved in the same manner.. @OpenSpacesAndPlaces \n\nUserContext is available from anything in the \"ResolveFieldContext\" flow. (or whatever you want to pass through).\n\nHmm. That's interesting that you put whatever you want in UserContext. I had forgotten that this was just an object on ResolveFieldContext. This is probably the best workaround given the current version of the library, despite the name of the property being misleading. In other words, you can inject dependencies into the GraphQLController and then assign those services to properties on the UserContext of the ExecutionOptions.\n... new ExecutionOptions\n{\n    Schema = m_schema,\n    Query = request.Query,\n    Inputs = request.Variables.ToInputs(),\n    UserContext = new MyContext {\n        User = m_claimsPrincipalProvider.User,\n        MyService1 = m_myService1,\n        MyService2 = m_myService2,\n        etc ...\n    }\n}\n...\n\nOtherwise there is a \"Metadata\" property on most GraphTypes/Field Types you can define at runtime.\n\nSure, but it seems awkward to inject \"dependencies\" into a graph type just to set metadata for another class to use. The injected \"dependency\" would not be a true dependency of the graph type.\n\nLikewise any statics I'm using are runtime defined, so I can stick whatever I need in them for look-ups.\n\nI don't like static dependencies in general due to complications that they impose on unit testing.\n\nIf you have no other options for your use case, then likely you could write something relatively ok using \"System.Collections.Concurrent\" statically that should be problem free (but I wouldn't do that as a first line solution).\n\nThis seems like overkill when IoC is the expected standard for modern .NET libraries.\n\nIt's also possible to leverage \"HttpContext.Current.Items\" if that helps your use case too.\n\nHttpContext.Current was removed from ASP.NET Core.\n. > @bugged84 is this answered to your satisfaction?\nYes, I think the UserContext workaround is sufficient.. > I referenced \"HttpContext.Current\" since I'm using DI free .Net Framework build.\n\n.Net core still has that property though:\n\nThat's just it, though, that static property literally does not exist in ASP.NET Core. Of course, you can still get the HttpContext through an IHttpContextAccessor that can be injected like any other dependency, but there is no static reference to the current HttpContext like in ASP.NET.\nThat being said, it is specifically the GraphQL FieldMiddleware to which my question refers, so the fact that you can't inject anything made it difficult to get a reference to the HttpContext. However, passing it to the FieldResolutionContext of the FieldMiddleware Invoke method by using the UserContext seems like a decent workaround.\n. ",
    "ivaxi": "Hey. We plan to use it in the existing government project of document flow for the whole country - Ukraine. Some parts already on it.. ",
    "abhikmitra": "Awesome ,probably it would be good to have a section in the readme called \"Built with GraphQLDotNet\" . ",
    "baig316-adfenix": "And how would we cater for custom input types as arguments to the mutation when those custom input types also include nested custom types.. Got it working.. ",
    "Marsellus47": "Thank you very much.\nThe problem wasn't in missing DI settings, but in not passing IDependencyResolver to my Schema.. ",
    "narbit": "Unfortunately I don't have any AppVeyor experience. Searching for any yml-based non-PS solutions didn't produce any good leads. It appears as though AppVeyour explicitly supports .NET Core SDK 2.1.402, same version I was able to compile against locally after pulling global.json out. Wouldn't it just work the same way in AppVeyor?\n. ",
    "maxr96": "@joemcbride Thank you very much for the help. The problem for me was using async/await in a resolve method of StringToUpperDirectiveMiddleware. I replaced it with Task.FromResult(). And I should mention, that before updating from 2.0.0-alpha to 2.3 it was working.. ",
    "ullmark": "I can confirm that I also got this issue when trying to use a FieldMiddleware that runs an async function with an await in it.\nWorks;\ncsharp\npublic Task<object> Resolve(ResolveFieldContext context, FieldMiddlewareDelegate next)\n{\n    Task.Run(() => Thread.Sleep(100)).Wait();\n     return next(context);\n }\nDoesn't Work (Causes error above);\ncsharp\npublic async Task<object> Resolve(ResolveFieldContext context, FieldMiddlewareDelegate next)\n{\n    await Task.Run(() => Thread.Sleep(100));\n    return next(context);\n }. ",
    "RPHEngineering": "What's the timeframe like on version 3? \nNo dice with adding System.Reactive.Core. \nThere's actually a System.Reactive.Compatibility package that the Reactive guys made for just this scenario but when I add it I get into another problem. \nAndroid give me this error: \nError XA2002: Can not resolve reference:System.Threading.Tasks.Extensions, referenced bySystem.Reactive. Please add a NuGet package or assembly reference forSystem.Threading.Tasks.Extensions, or remove the reference toSystem.Reactive. (XA2002)\niOS gives me this error: \nError MT2001: Could not link assemblies. Reason: Error while processing references of 'Lynkd.iOS, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' (MT2001)\nIf I add the latest version of System.Threading.Extensions it makes no difference. I have read that to fix this you need to add System.Threading.Extensions 4.4.0. \nSo, I tried adding \"System.Threading.Tasks.Extensions 4.4.0\" directly and I get this when I try to add it: \nDetected package downgrade: System.Threading.Tasks.Extensions from 4.5.1 to 4.5.0. Reference the package directly from the project to select a different version. \n Lynkd (>= 1.0.0) -> System.Reactive.Compatibility (>= 4.1.2) -> System.Reactive.Interfaces (>= 4.1.2) -> System.Threading.Tasks.Extensions (>= 4.5.1) \n Lynkd (>= 1.0.0) -> System.Threading.Tasks.Extensions (>= 4.5.0)\nDetected package downgrade: System.Threading.Tasks.Extensions from 4.5.1 to 4.5.0. Reference the package directly from the project to select a different version. \n Lynkd (>= 1.0.0) -> System.Reactive.Compatibility (>= 4.1.2) -> System.Reactive.Core (>= 4.1.2) -> System.Threading.Tasks.Extensions (>= 4.5.1) \n Lynkd (>= 1.0.0) -> System.Threading.Tasks.Extensions (>= 4.5.0)\nDetected package downgrade: System.Threading.Tasks.Extensions from 4.5.1 to 4.5.0. Reference the package directly from the project to select a different version. \n Lynkd (>= 1.0.0) -> System.Reactive.Compatibility (>= 4.1.2) -> System.Reactive.Linq (>= 4.1.2) -> System.Threading.Tasks.Extensions (>= 4.5.1) \n Lynkd (>= 1.0.0) -> System.Threading.Tasks.Extensions (>= 4.5.0)\nDetected package downgrade: System.Threading.Tasks.Extensions from 4.5.1 to 4.5.0. Reference the package directly from the project to select a different version. \n Lynkd (>= 1.0.0) -> System.Reactive.Compatibility (>= 4.1.2) -> System.Reactive.PlatformServices (>= 4.1.2) -> System.Threading.Tasks.Extensions (>= 4.5.1) \n Lynkd (>= 1.0.0) -> System.Threading.Tasks.Extensions (>= 4.5.0)\nDetected package downgrade: System.Threading.Tasks.Extensions from 4.5.1 to 4.5.0. Reference the package directly from the project to select a different version. \n Lynkd (>= 1.0.0) -> System.Reactive.Compatibility (>= 4.1.2) -> System.Reactive.Providers (>= 4.1.2) -> System.Threading.Tasks.Extensions (>= 4.5.1) \n Lynkd (>= 1.0.0) -> System.Threading.Tasks.Extensions (>= 4.5.0). ah, that was the real answer I needed :) Brand new to GraphQL so still fumbling around a bit. ",
    "NZSmartie": "Hey @joemcbride \nRegarding your comment:\n\nIt looks like 4.0.0 only supports netstandard2.0 and net46, so we may have to either target 4.0.0 for just nestandard2.0 or drop support for netstandard1.x and net45. It is currently planned to drop support for netstandard1.x and net45 in version 3 of this project.\n\nWith the recent move to .Net Standard 2.0 in #969, there is no-longer any need to be backwards compatible and can upgrade System.Reactive from v3.1.1 to >= v4.0.0\nWould you think it's now suitable to update to this version or is there other reasons to keep System.Reactive at v3.1.1?. ",
    "redplane": "Thank you for your response.\nBut how can I generate an unique name for my generic class in Graphql-dotnet ?. I have changed my RangeModelType<TFrom, TTo> to : \n```\npublic RangeModelType()\n        {\n            Name = \"RangeModel\";\n        var fromType = typeof(TFrom);\n        Field(x => x.From, fromType.IsGenericType && fromType.GetGenericTypeDefinition() == typeof(Nullable<>));\n\n        var toType = typeof(TTo);\n        Field(x => x.To, toType.IsGenericType && toType.GetGenericTypeDefinition() == typeof(Nullable<>));\n    }\n\n```\nFinally it works.\nThank you for your help.. ",
    "yoDon": "This seems like you're fighting hard against a core concept of GraphQL. If the client needs those fields, it should ask for them, which would I think make your problem go away. If you don't want to list those fields manually in all your requests, use a fragment or some other client side tool tool to add them automatically.. ",
    "wpatter6": "Ok good to know, thank you. ",
    "mohsin31": "Hi Joe,\nThanks for your quick response.. ",
    "kmanev073": "\nField<ListGraphType<DeliveryItemType>>(\u201citems\u201d, resolve: context => context.Source.Items)\nThat should work, looking into the exact syntax for lists with expression syntax but yours looks fine to me.\nHave you registered your DeliveryItemType with your container?\n\nThanks man! \nI had registered my type like: services.AddSingleton<IMyInterface,DeliveryItemType>();\nNow I just changed it to  services.AddSingleton<DeliveryItemType>();\nBoth syntaxes work! Thank you once again!. Thanks for the answer! Where can I find more information on \"abstract base GraphType\"?. ",
    "desbrowne": "I'm using context.CancellationToken for this, does this pattern not work for your needs?\nYou of course need to set the CancellationToken as part of your executor for it to exist on the context, e.g.:\n\nvar result = await executor.ExecuteAsync( =>\n  {\n      _.CancellationToken = cancellationToken;\n.... \n",
    "stilren": "@joemcbride you are my hero!\nSorry to bother would have probably figured it out if I hadnt been unsure of the Field syntax. ",
    "Toxu4": "Possible workaround  - use your own implementation of AutoRegisteringObjectGraphType:\npublic class FixedAutoRegisteringObjectGraphType<TSourceType> : ObjectGraphType<TSourceType>\n    {\n        public FixedAutoRegisteringObjectGraphType()\n        {\n            foreach (PropertyInfo propertyInfo in ((IEnumerable<PropertyInfo>) typeof (TSourceType).GetProperties(BindingFlags.Instance | BindingFlags.Public)).Where<PropertyInfo>((Func<PropertyInfo, bool>) (p =>\n            {\n                if (!p.PropertyType.GetTypeInfo().IsValueType)\n                    return p.PropertyType == typeof (string);\n                return !p.PropertyType.IsEnum;\n            })))\n                this.Field(propertyInfo.PropertyType.GetGraphTypeFromType(propertyInfo.PropertyType.IsNullable()), propertyInfo.Name, (string) null, (QueryArguments) null, (Func<ResolveFieldContext<TSourceType>, object>) null, (string) null);\n        }\n    }\nthe fix is return !p.PropertyType.IsEnum; line. ok, good.\nhow did you handle this?\npublic enum MyEnum: short \n{ \n    one, \n   two \n}\n...\nDebug.Print(typeof(MyEnum).IsEnum); // false. lol, my fault. in my model i have a nullable MyEnum?. Of cause its not IsEnum :)\n```\npublic enum MyEnum: short \n{ \n    one, \n   two \n}\n...\nDebug.Print(typeof(MyEnum?).IsEnum); // false\n```. ",
    "Demivan": "This will just ignore enum fields and I want to have them included in schema.\nI fixed it by using custom AutoRegisteringObjectGraphType implementation but instead of ignoring enums I used own GetGraphTypeFromType extension method with added enum handling.\nif (type.IsEnum)\n{\n    var listType = typeof(EnumerationGraphType<>);\n    graphType = listType.MakeGenericType(type);\n}\n\nGetGraphTypeFromType\n\n```\npublic static Type GetGraphTypeFromType(this Type type, bool isNullable = false)\n{\n    TypeInfo info = type.GetTypeInfo();\n\n    if (info.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))\n    {\n        type = type.GetGenericArguments()[0];\n        if (isNullable == false)\n        {\n            throw new ArgumentOutOfRangeException(nameof(isNullable),\n                $\"Explicitly nullable type: Nullable<{type.Name}> cannot be coerced to a non nullable GraphQL type. \\n\");\n        }\n    }\n\n    var graphType = GraphTypeTypeRegistry.Get(type);\n\n    if (type.IsEnum)\n    {\n        var listType = typeof(EnumerationGraphType<>);\n        graphType = listType.MakeGenericType(type);\n    }\n\n    if (type.IsArray)\n    {\n        var elementType = GetGraphTypeFromType(type.GetElementType(), isNullable);\n        var listType = typeof(ListGraphType<>);\n        graphType = listType.MakeGenericType(elementType);\n    }\n\n    if (IsAnIEnumerable(type))\n    {\n        var elementType = GetGraphTypeFromType(type.GenericTypeArguments.First(), isNullable);\n        var listType = typeof(ListGraphType<>);\n        graphType = listType.MakeGenericType(elementType);\n    }\n\n    if (graphType == null)\n    {\n        throw new ArgumentOutOfRangeException(nameof(type),\n            $\"The type: {type.Name} cannot be coerced effectively to a GraphQL type\");\n    }\n\n    if (!isNullable)\n    {\n        var nullType = typeof(NonNullGraphType<>);\n        graphType = nullType.MakeGenericType(graphType);\n    }\n\n    return graphType;\n}\n```\n\n\n\n. Are you sure this returns false?\nJust checked using and it returns true: https://dotnetfiddle.net/cJourE. Current version of GetGraphTypeFromType already handles all nullable (non-nullable) types.\nif (!isNullable)\n{\n    var nullType = typeof(NonNullGraphType<>);\n    graphType = nullType.MakeGenericType(graphType);\n}. ",
    "abarger-bss": "Sure. I was originally planning to make a separate PR which broke all the sections under Schema Types out into their own files for an easier diff, but I can do that now.. I noticed #870 implemented this but the PR author closed it. We would also find this valuable. @SimonCropp  Not sure what you're asking... You were the author of the closed PR. I noticed it sat idle for 2 months before it was closed. I'm happy to make a new PR for this, but does this one stand any better chance of getting merged?. ",
    "atbamparo": "Thanks for the replies, i've got a few more toughts:\nI actualy could store the immutable part of the ExecutionNode (ExecutionNodeDefinitions) on the GraphType, and reuse on needed, avoiding creating copy objects.\nWhat do you guys think about this?\nEDIT: its not possible right now, just realize the Definition contains data only resolved after the query parse.. Oh, thats right, i actually miss that. True, actually the commit did not improve that much and i think i will revert and push the SimpleResolver interface in another PR.. ",
    "steviemcg": "OK, thanks. It's a gigantic number of properties so I'm not sure how to do that in a workable way. I'll stick with my hack of ignoring this text when choosing the status code. \ud83d\ude04 As the error text is definitely useful, but it's not necessarily big enough of a problem for the entire request to fail. Feel free to close and thanks for your time.. ",
    "OpenSpacesAndPlaces": "Did either of you figure out where \"field\" gets populated?\nThe docs make it look like it should just be automatic:\nhttps://graphql-dotnet.github.io/docs/getting-started/metrics\n. I think the issue for me was running in Framework - the middleware not actually resolving.\nI added some manual calls:\n```\npublic static ResolveFieldContext Resolve(ResolveFieldContext rfc)\n    {\n        var metadata = new Dictionary\n        {\n            {\"typeName\",  rfc.ParentType.Name},\n            {\"fieldName\",  rfc.FieldName},\n            {\"returnTypeName\", SchemaPrinter.ResolveName( rfc.ReturnType)},\n            {\"path\",  rfc.Path},\n        };\n    using ( rfc.Metrics.Subject(\"field\",  rfc.FieldName, metadata))\n    {\n        return  rfc;\n    }\n}\n\n```\nThe only horsey thing is that it doesn't seem you can check the execution options from that context - so have a global set to see if it should run.. > What does the GraphType are you using look like?\npublic object Resolve(ResolveFieldContext rfc)\nWould just be returning an Entity Framework Core object.\nFor the GraphType definition I've been using like this for \"Mutation\" on \"Schema\":\npublic class GraphQLMutation<T> : ObjectGraphType<object> where T : DbContext\nAnd then like the following for each of the \"ResolvedType\" on the  \"FieldType\" definition\npublic class MutationTableType<T> : ObjectGraphType<object> where T : DbContext\nAs mentioned, the part that confusing me is that queries work fine, and the resulting definitions represented in GraphIQL look good. It's just something is nulling the DB object for \"Resolve\" in the mutation case, but not for queries.\n. @joemcbride Any other suggestions or additional details I can provide?. @joemcbride \nSchemaPrinter + \"unique GraphType Name \" were very helpful hints - I was able to trace it further.\nThe underlying problem seems to be that I used the same name for the Query objects and the Mutation objects. \nIf I comment out the QueryResolver - Mutations then work fine:\nnew Schema\n            {\n                //Query = new GraphQLQuery<T>(\nIs there a way for me to maintain the same naming between the two resolvers or is the expectation that I have to have three separate namings:\nMyObjectQuery\nMyObjectMutation\nMyObjectMutationInput\nI ask, because the underlying definition is the same for all three cases - at the moment there is no DTO needed for the use case.\n. Maybe this will help clarify:\nThis schema works for mutations:\n```\nscalar ByteArray\nThe Date scalar type represents a year, month and day in accordance with the\nISO-8601 standard.\nscalar Date\nThe DateTime scalar type represents a date and time. DateTime expects\ntimestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar DateTime\nThe DateTimeOffset scalar type represents a date, time and offset from UTC.\nDateTimeOffset expects timestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar DateTimeOffset\nscalar Decimal\nscalar Json\nThe Milliseconds scalar type represents a period of time represented as the total number of milliseconds.\nscalar Milliseconds\ntype Mutation {\n  tblTemplate(data: TblTemplate, key: TblTemplate_key): tblTemplate\n  tblTemplate_list(data: TblTemplate, key: TblTemplate_key): [tblTemplate]\n}\nThe Seconds scalar type represents a period of time represented as the total number of seconds.\nscalar Seconds\ntype tblTemplate {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n  ct: Json\n  tblContentBlock: Json\n  tblTagToContent: Json\n}\ninput TblTemplate {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n  ct: Json\n  tblContentBlock: Json\n  tblTagToContent: Json\n}\ninput TblTemplate_key {\n  tId: Int!\n}\n```\nThis schema does not work for mutations:\n```\nscalar ByteArray\nThe Date scalar type represents a year, month and day in accordance with the\nISO-8601 standard.\nscalar Date\nThe DateTime scalar type represents a date and time. DateTime expects\ntimestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar DateTime\nThe DateTimeOffset scalar type represents a date, time and offset from UTC.\nDateTimeOffset expects timestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar DateTimeOffset\nscalar Decimal\nscalar Json\nThe Milliseconds scalar type represents a period of time represented as the total number of milliseconds.\nscalar Milliseconds\ntype Mutation {\n  tblTemplate(data: TblTemplate, key: TblTemplate_key): tblTemplate\n  tblTemplate_list(data: TblTemplate, key: TblTemplate_key): [tblTemplate]\n}\ntype Query {\n tblTemplate(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, ct: String, tblContentBlock: String, tblTagToContent: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): tblTemplate\n  tblTemplate_list(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, ct: String, tblContentBlock: String, tblTagToContent: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): [tblTemplate]\n}\nThe Seconds scalar type represents a period of time represented as the total number of seconds.\nscalar Seconds\ntype tblTemplate {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n  ct: Json\n  tblContentBlock: Json\n  tblTagToContent: Json\n}\ninput TblTemplate {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n  ct: Json\n  tblContentBlock: Json\n  tblTagToContent: Json\n}\ninput TblTemplate_key {\n  tId: Int!\n}\n```\nThe only difference I'm seeing is (because of this being commented or not):\n```\ntype Query {\n tblTemplate(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, ct: String, tblContentBlock: String, tblTagToContent: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): tblTemplate\n  tblTemplate_list(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, ct: String, tblContentBlock: String, tblTagToContent: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): [tblTemplate]\n}\n```\nOtherwise what's still getting me is that Query will work with both Query/Mutations enabled and Mutation will only work if just Mutation is enabled.\n. A simple suffix pattern on the FieldType names didn't improve anything:\n```\ntype Mutation {\n  tblTemplate_m(data: TblTemplate_i, key: TblTemplate_key): tblTemplate\n  tblTemplate_m_list(data: TblTemplate_i, key: TblTemplate_key): [tblTemplate]\n}\ntype Query {\n tblTemplate_q(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): tblTemplate\n  tblTemplate_q_list(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, , pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): [tblTemplate]\n}\ntype tblTemplate {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n}\ninput TblTemplate_i {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n}\ninput TblTemplate_key {\n  tId: Int!\n}\n```\nBut it led me to try changing the name of the \"Resolved Type\" - that solved the problem:\n```\ntype Mutation {\n  tblTemplate(data: tblTemplate, key: tblTemplate_key): tblTemplate_m\n  tblTemplate_list(data: tblTemplate, key: tblTemplate_key): [tblTemplate_m]\n}\ntype Query {\n tblTemplate(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, ct: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): tblTemplate_q\n  tblTemplate_list(tId: String, ctId: String, tCtIds: String, tDesc: String, tDisplayPage: String, tName: String, ct: String, pageSize: Int, pageNumber: Int, filters: String, orderBy: String, includes: String): [tblTemplate_q]\n}\ninput tblTemplate {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n}\ninput tblTemplate_key {\n  tId: Int!\n}\ntype tblTemplate_m {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n}\ntype tblTemplate_q {\n  tId: Int\n  ctId: Int\n  tCtIds: String\n  tDesc: String\n  tDisplayPage: String\n  tName: String\n}\n```\nSo it seems that you can share the CLR type, but the GraphQL ResolvedType name needs to be different between Query/Mutation (ultimately creating a dupe definition in the schema). It's odd that the underlying schema seems to need a name variation and separate object definitions, but that said, now that I know what the trick, the end result is nearly exactly what I was looking for. Even though the schema has the \"_q\" and \"_m\" in the ResolvedType name, the FieldType names are all almost the same. Thus when using GraphiQL or coding out front-end code, developers aren't needing to remember a naming pattern.\nThanks for the help in tracking down a fix.. Pseudo like the following works for me:\nInputObjectGraphType<MyObject> o = new InputObjectGraphType<MyObject>();\no.Name = \"UniqueObjectName\";\no.Field(FieldGraphType,\"FieldName\");\nQueryArgument qa = new QueryArgument(o);\nqa.Name = \"data\";\nqa.Description = \"UniqueObjectDesc\";\nTableArgs.Add(qa);\nDuplicate names/lack of names/incorrect inferred graph types could all be culprits from what I've seen before.\nI don't know if it would help you, but I've had good luck with the GraphTypes  explicitly defined vs. inferred with syntax sugar.\ne.g.\nAddField(new FieldType\n                {\n                    Name = \"playerBalance\",\n                    Type = typeof(PlayerBalanceType),\n                    ResolvedType = GraphType,\n....\n. Not sure if this is what you mean, but this worked fine for me to output first full child data:\nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/474\nThen loading via:\n    schema.RegisterValueConverter(new JsonGraphTypeConverter());. Thanks @joemcbride !\nThat gets me closer to something reasonable (I coded out a demo app to play with it) - it's at least down to one database call per level. (which is way better that way).\nIt's still kind of heavy given that it still has to run a resolver per item.\n\nI think in a perfect world \"ResolveFieldContext.FieldAst.SelectionSet\" would have the types and I'd be able to-do everything from one resolver.. @joemcbride When I switched over to \"ResolveAsync\" from \"AddField(new FieldType\" - I keep getting null for the result of the sub-field resolver. (no errors).\nAny ideas for debugging?\nRough example of how I have this laid out below:\nFieldBuilder<object, dynamic> fb = Field<ObjectGraphType<object>, dynamic>(ColumnName)\n                .ResolveAsync(rfc =>\n                {\n                    return TestMe<T, KParent, KChild>.ResolveOne(rfc);\n                });\npublic static Task<dynamic> ResolveOne(ResolveFieldContext<object> rfc)\n        {\n            IDataLoader<KParent, dynamic> loader = Accessor.Context.GetOrAddBatchLoader<KParent, dynamic>(name,\n            fetchFunc: (keys, token) => { return LoadOne(rfc,keys,token); },\n            keyComparer: EqualityComparer<KParent>.Default\n            );\n            return loader.LoadAsync(AutoMapper.Mapper.Map<KParent>(rfc.Source));\n        }\n```\nprivate static Task<IDictionary<KParent, dynamic>> LoadOne(ResolveFieldContext<object> rfc\n\nIEnumerable keys, CancellationToken cancellationToken)\n        {\n           List lst = RunData(rfc,  keys);\n        IDictionary<KParent, dynamic> d = lst.ToDictionary(k => (KParent) k[nameof(BaseEntity.Parent)], v =>v);\n\n        return Task.FromResult(d);\n    }\n\n```\n. @joemcbride \nI think this can be closed.\nI was able to work out the problems by copying some of the source code classes over and setting up debug points.\n\nGenerically I think my feedback/suggestion would be to consider some kind of warning/unlikely data cases system, especially around data-loaders, given all the layers of abstraction.\nAs simple example of what I mean:\nLoadAsync in CollectionBatchDataLoader\nloads data like\nresult[key];\nExpect that if for example your IEqualityComparer needs adjusted (or some other related problem) that method, buried three classes deep inside dlls just returns \"[]\". As a first time user it turns into a needle haystack problem of:  is there something out of alignment with the overall architecture of my graph classes or some obfuscated user error? It's generally hard to tell.\nI certainly wouldn't expect not to have to my own digging, but at the same time it seems there may be an enhancement possible somewhere in process that reduces the need to drop in source code to figure out why something isn't resolving.\n. @aslamhadi  Dataloaders do have an in-memory cache, but as others said, this would still be a user problem. ( ran into something like that and needed to sideload some source code classes to track it down.)\nIf that's the case, I'd check your usage of TKey and IEqualityComparer - the data loader doesn't validate your keys, and you could end with bad data/no data.. Generally, and this is my experience using Framework without any DI, most things can either be passed through and/or you can reference a public static class.\nI've yet to run into anything that \"required' DI.\n\nThat said, someone with more DI experience may be able to chime in.. @bugged84 \n\nHow would you get runtime dependencies such as an HTTP request context by using only static classes?\n\nFor something like request context I use:\n_executer.ExecuteAsync(_ =>\n        {\n            _.UserContext = HttpContext.Current;\n        });\nUserContext is available from anything in the \"ResolveFieldContext\" flow. (or whatever you want to pass through).\nOtherwise there is a \"Metadata\" property on most GraphTypes/Field Types you can define at runtime.\nLikewise any statics I'm using are runtime defined, so I can stick whatever I need in them for look-ups.\n\nIf you have no other options for your use case, then likely you could write something relatively ok using \"System.Collections.Concurrent\" statically that should be problem free (but I wouldn't do that as a first line solution).\nIt's also possible to leverage \"HttpContext.Current.Items\" if that helps your use case too.\n. > It's also possible to leverage \"HttpContext.Current.Items\" if that helps your use case too.\n\nHttpContext.Current was removed from ASP.NET Core.\n\nI referenced \"HttpContext.Current\" since I'm using DI free .Net Framework build.\n.Net core still has that property though:\nHttpContext ctx = 'grab context from your middleware or DI';\nctx.Items;\nI bring that up because if your use case would be helped by it - Items is going be available on the whole stack vs. UserContext only being in the GraphQL layer.\nIn my use case UserContext was fine given I'm only referencing it for IAuthorizationRequirement.. The primary reason cited is:\n\"not all platforms and transports support encoding integer numbers larger than 32\u2010bit\"\nFrom discussion here it seems JS is maxing out at 52/53bits:\nhttps://github.com/facebook/graphql/issues/73\n\nIMO - this seems overly hand holdie on the part of the spec - but it is what it is I guess.\nAt least for me, the problem I normally run into is a specific API's documentation being ambiguous. \n. There's no built-in value converter.\nYour option is to either make one and register it:\nschema.RegisterValueConverter\nOr just use it as a string. (that's what I currently do).\n\nI believe the reason for missing converters is that there isn't as JSON type of guid - so while string is the logical conversion ( and what many other libraries do) - I think the goal in this project wasn't to have things auto-magically happen.\n. ",
    "thegroke": "\nYou should be able to use Field, as in the example. Did you try that?\ncs\n_.Match<Field>(fieldAst =>\n{\n ....\n}\n\nThat was my first assumption, but (in 2.4.0 at least) it doesn't match. I'll put together an example.. Okay, I created an example at: https://github.com/thegroke/scratch-GraphQLDotNet-ValidationMatchingExample\nI understand this could be a terminology issue, but the field \"pleaseValidateMe\" that is part of the ExampleInputType passed as an argument to the mutation is not matched. Check the output of the program and the code in ValidationRuleA and ValidationRuleB:\nValidationRuleA matched exampleMutation\nValidationRuleB matched field pleaseValidateMe\n. Thanks Joe, that makes sense and I appreciate the time you took to help me out here.\nI'm still not quite at the point where I've got a clean system for \"this field on input types passed as mutation arguments should run with \"*, but you've pointed me in the right direction for walking the graph.\n\nMy validators instead look more like the NonNullGraphType wrapper, which isn't the architecture I want to go with. \n",
    "cgatian": "Hell mutha fawkin yeah. ",
    "NathanMagnus": "Updated to include some tests. The list of tested types is not exhaustive. If you prefer a different naming scheme please let me know.. ",
    "Rensvind": "Don't know why that test failed, it has nothing to do with my changes. All tests succeeds locally.. ",
    "MirceaMatei": "\nThat should certainly work and looks like correct syntax at first glance. What specific versions are you referring to? Can you provide a failing test?\n\nI am currently using the 2.4.0 version but previously I used the 0.16.0. I only have the test I provided where on the query I receive the two null values instead of the matrix.. After some testing these are the results that I gathered:\nWhen using this definition for the field:\n```\nField>>()\n    .Name(\"someRandomName\")\n    .Resolve(context =>\n        {\n            var newList = new List>();\n                    var newItem = new List<decimal>();\n        newItem.Add(10.0m);\n        newList.Add(newItem);\n\n        var secondNewItem = new List<decimal>();\n        secondNewItem.Add(10.0m);\n        newList.Add(secondNewItem);\n\n        return newList;\n    });\n\n``\nThe result is: \"someRandomName\":[ null,null ]`\nChanging the configuration to:\n```\nField>()\n    .Name(\"someRandomName\")\n    .Resolve(context =>\n        {\n            var newList = new List>();\n                    var newItem = new List<decimal>();\n        newItem.Add(10.0m);\n        newList.Add(newItem);\n\n        var secondNewItem = new List<decimal>();\n        secondNewItem.Add(10.0m);\n        newList.Add(secondNewItem);\n\n        return newList;\n    });\n\n``\nI get an error:Could not find conversion from System.Collections.Generic.List1[[System.Decimal, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] to System.Decimal\",\nChanging the GraphType:\n```\n Field>>()\n    .Name(\"someRandomName\")\n    .Resolve(context =>\n        {\n            var newList = new List>();\n                    var newItem = new List<string>();\n        newItem.Add(\"10.0m\");\n        newList.Add(newItem);\n\n        var secondNewItem = new List<string>();\n        secondNewItem.Add(\"10.0m\");\n        newList.Add(secondNewItem);\n\n        return newList;\n    });\n\n``\nSame result:\"someRandomName\":[ null,null ]`\nThe fun part is here:\n ```\nField>()\n    .Name(\"someRandomName\")\n    .Resolve(context =>\n        {\n            var newList = new List>();\n                    var newItem = new List<string>();\n        newItem.Add(\"10.0m\");\n        newList.Add(newItem);\n\n        var secondNewItem = new List<string>();\n        secondNewItem.Add(\"10.0m\");\n        newList.Add(secondNewItem);\n\n        return newList;\n    });\n\n``\nI get the correct result:\"someRandomName\": [ [ \"10.0m\" ], [\"10.0m\" ] ]`\nWhat happens is that if I choose ListGraphType< StringGraphType > or even just  StringGraphType the results is as expected. In my example choosing DecimalGraphType breaks it. It is weird that it does not work as expected. I was hoping that when choosing ListGraphType< ListGraphType< DecimalGraphType> > I can return a a matrix of decimals instead I can return the matrix of decimals if I choose only StringGraphType.\nIn the end my solution is to just change it to the plain StringGraphType (not ListGraphType< StringGraphType >) and return the desired result.. ",
    "diouxis": "Update:\nI can see the issue is coming from the following code\nhttps://github.com/graphql-dotnet/graphql-dotnet/blob/0917a2c8c3f7fc078ce4429f0edc3b051ef949c9/src/GraphQL/Types/GraphTypesLookup.cs#L349-L367\nFor some reason, objectType.ResolvedInterfaces might get one more additional null value at the end of ResolvedInterfaces, and this make the interfaceType.AddPossibleType(objectType); throw NULL_REFERENCE  exception.\nI still have no idea how does the null value come, meantime I am doing the following to temporarily avoid the issue.\nc#\n                objectType.ResolvedInterfaces = objectType\n                    .ResolvedInterfaces\n                    .Where(x => x != null)\n                    .Select(i =>. ",
    "markchilton": "Hi, I already did look through similar issues. The closest one I could find is this: \nhttps://github.com/graphql-dotnet/graphql-dotnet/issues/930\nHowever I followed and applied the suggested fix but am still getting the same error.. Thanks for the reply, I already tried that but it didn't fix the issue.\nI changed my PlayerBalanceRequestType class to look like this:\npublic class PlayerBalanceRequestType : InputObjectGraphType<PlayerBalanceRequest>\n    {\n        public PlayerBalanceRequestType()\n        {\n            Name = \"request\";\n            Field(x => x.Id);\n            Field(x => x.Login);\n            Field(x => x.ForMoney);\n        }\n    }\n. That didn't make any difference unfortunately. GraphQL works just fine if I pass in all the types as separate QueryArguments. It just doesn't seem to like me passing in an object as a QueryArgument.  . ",
    "agibsonIL": "Haha! Totally an accident on the duplicate PR (#983). It is a funny coincidence. I apologize @freakingawesome , I didn't mean to step on your toes. Probably should have looked at the pending PR's before I submitted mine.. ",
    "gregbty": "Any time table for this to be released (as well as the server package being updated with it)? We are using the server package and we are running into this issue and there is no workaround.. ",
    "bogdancice": "@MagenicJB I think you have to specify the GraphQL type.\nTry it this way: Field(x => x.PWS, nullable:true, type:typeof(PType));. In our app we registered GraphQL and GraphQL Types as Singletone because we have a large schema (lots of queries and mutations), this approach improved the API performance significantly because the initialization of all the queries and mutations is done only at Startup. If we define GraphQL and the Types as Scoped then at each request ALL the queries and mutations are initialized because GraphQL is building the entire graph before analyzing the request body (even if my request contains only one or two query). I think that you should test the performance hit on your app if you use Scoped vs Singletone and see if it's worth it to use Scoped. We didn't had any other issues when we used Scoped instead of Singletone. @bugged84 great point. We are getting scoped DataContext object from HttpContextAccessor.\nExample:\n``` \npublic class UserRepository\n{\n        private DataContext DbContext => m_accessor.HttpContext.RequestServices.GetRequiredService();\n    public UserRepository(IHttpContextAccessor accessor)\n    {\n        m_accessor = accessor;\n    }\n\n}\n```\nThis is working fine if the repository is used when an API request is made, but if we want to use this repositories on some background tasks/threads (e.g. we want some database entities to be updated based on some context information) this repositories will be useless because HttpContext is Null. For fixing that we created another Repo class.\n```\npublic class ScopedRepository\n{\n        private DataContext DbContext => m_serviceProvider.GetRequiredService();\n    public ScopedRepository(IServiceProvider serviceProvider)\n    {\n        m_serviceProvider = serviceProvider;\n    }\n\n}\n```\nAnd the background task will look something like this:\n```\n public class BackgroundTask\n{ \n        private readonly IServiceScopeFactory m_scopeFactory;\n    public BackgroundTask(IServiceScopeFactory scopeFactory)\n    {\n        m_scopeFactory = scopeFactory;\n    }\n    public async void ExecuteBackgroundAction(object input)\n    {\n            using (var scope = m_scopeFactory.CreateScope())\n            {\n                var scopedRepository= scope.ServiceProvider.GetService<ScopedRepository>();\n                 //call the repository methods\n            }\n    }\n\n}\n```\nWe know this is not the best approach (duplicating the repos is not a scalable idea ) and we will refactor this when we have more time. I think that using a factory for getting DataContext is a better idea, we just have to test it :)\n@bugged84 let us know if you find a better solution for this challenge ;). ",
    "MagenicJB": "@bogdancice I cross posted here and stumbled upon this \"solution\" a couple days ago. \nField(\"PWS\"); //NOTE:replaced lamda above with string value for name\nSo it really seems to have something to do with complex types not being able to \"get everything needed\" from the lambda and you need to explicitly declaring the type. \nI do like your way better and refactored to that.\nThanks. ",
    "JoshuaDickson": "That's fair enough, it is a bit niche behavior.\nIn my project, I have a code generator that takes a GraphQL schema, and emits graphql-dotnet scaffolding in the form of abstract base classes. This allows me to ensure the ASP.NET Core server and the declarative schema are always in sync. It catches most, but not all errors at compile time, and then a handful more at schema creation in runtime. It's been very useful for me in developing, as I've reduced the boilerplate needed to mimic a schema down to just writing the resolver function, with full type safety (for queries at least - mutations need a bit of work).\nI'll likely be open sourcing the generator once I get it in a bit better shape.. ",
    "shivangbansal": "@joemcbride If you think this could be the part of Complexity Analyzer, I can raise a PR for the same. \nPlease let me know your inputs on this.. ",
    "dadhichankur": "@BenjaBobs  I used this \nField<ListGraphType<ListGraphType<IntGraphType>>>(\n                \"GetNetworkData\",\n                 arguments: new QueryArguments(\n                                                new QueryArgument<IntGraphType> { Name = \"direction\" },\n                                                new QueryArgument<StringGraphType> { Name = \"siteId\" },\n                                                new QueryArgument<StringGraphType> { Name = \"timeFrame\"},\n                                                new QueryArgument<StringGraphType> { Name = \"duration\" }\n                                              ),\n                 resolve: context => sdwanService.GetNetworkUsagess(context.GetArgument<int>(\"direction\"), \n                                                                    context.GetArgument<string>(\"siteId\"),\n                                                                    context.GetArgument<string>(\"timeFrame\"),\n                                                                    context.GetArgument<string>(\"duration\"))\n                );\nand this is what it returned \n{\n  \"data\": {\n    \"getNetworkData\": [\n      null,\n      null,\n      null,\n      null\n    ]\n }\n}\nso it is not able to parse data. ",
    "juliankay": "Looks like I'm getting a similar issue with string[][] / ListGraphType<ListGraphType<StringGraphType>> returning all the nulls just like @dadhichankur.\nShould this work?. Version 2.4.0 here. ",
    "vitaliitylyk": "It could be a solution, but it won't cover the case when HttpContext.Current (and potentially other stuff flowing in SynchronizationContext) is used within some libraries/services, which are called from queries/mutations. Also, in ASP.NET core scenario I assume developers would use IHttpContextAccessor, so probably passing HttpContextwithin graphql context would not be very useful for that scenario as well.. I am not using ASP.NET Core on my project (not yet unfortunately ;) ), but I assume injecting IHttpContextAccessor would work just fine with GraphQL. But for now I have to deal with HttpContext.Current.\n\ni much prefer to flow the state\n\nYes indeed, flowing the state is a better solution and more future proof. Unfortunately for legacy ASP.NET it will not always be possible since you don't have control over all code where HttpContext.Current is used (e.g some external libraries).\nSo maybe if you're focusing more on .NET Core it makes sense to not change anything. In this case it might be nice to mention this behavior in the documentation?\nWhat I did for now in my project is implemented custom ParallelExecutionStrategy and SerialExecutionStrategy classes by removing ConfigureAwait calls, which works fine for me. \n. ",
    "JasonKitson": "Hi Joe,\nThanks for the response.\nI am aware that the IExecutionStrategy SelectExecutionStrategy() method is virtual and can be overridden.\nHowever, that requires that users of this product have a strong understanding of the codebase. \nThe reason behind this change was due to a threading issue. We are working with a stack that includes GQL.NET and Entity Framework. In one of out Graphs there are 2 properties that both require DatabaseContext (EF). These are competing in parallel and results in this exception:\nMessage: System.InvalidOperationException : A second operation started on this context before a previous operation completed. This is usually caused by different threads using the same instance of DbContext, however instance members are not guaranteed to be thread safe. This could also be caused by a nested query being evaluated on the client, if this is the case rewrite the query avoiding nested invocations.\nUnderstanding how this relates back to an Execution Strategy isn\u2019t trivial, this is very challenging to unpack.\nI was given guidance by a peer of what the likely cause of the threading issue and how it could be solved by making changes to GraphQL-dotnet. This is a luxury that many developers do not have. \nIn my opinion it's much easier to set an options boolean than implement an override solution. As the boolean solution hides the complexity.\nSolutions like this -     \npublic class myDocumentExecutor : DocumentExecuter\n    {\n        protected override IExecutionStrategy SelectExecutionStrategy(ExecutionContext context)\n        {\n            if (context.Operation.OperationType == OperationType.Query)\n            {\n                return new SerialExecutionStrategy();\n            }\n            return base.SelectExecutionStrategy(context);\n        }\n    }\n...\n    var docExec = new myDocumentExecuter();\n            var result = await docExec.ExecuteAsync(_executionOptions).ConfigureAwait(false);\n\nVersus this - \npublic EnableSerialExecutionOnQuery()\n        {\n            _executionOptions = new ExecutionOptions()\n            {\n        ...\n                EnableSerialExecutionOnQuery = true\n            };\n        }\n...\n    var docExec = new DocumentExecuter();\n            var result = await docExec.ExecuteAsync(_executionOptions).ConfigureAwait(false);\n\nThere are quite a few developers who have raised issues around this problem (in the issue register) and they may well appreciate a simpler work around than what is presently available.\nI appreciate your concerns about not wanting to make ExecutionOptions anymore complex. There's certainly a lot going on within the ExecuteAsync method.\nHowever, these are execution options and they're doing exactly what they're supposed to, I don't see that this adds any great complexity to the status quo.\n. ",
    "Anberm": "I get multiple instances inside the root with dependency injection and reassemble them\uff0c which is not elegant. ",
    "deborapoh": "Yeah, I did, thank you for your help and sorry for the late reply.. ",
    "jeffw-wherethebitsroam": "You haven't included ManagedContent or ManagedContentRequest in your schema, which makes it harder. But I assume that the content field of  ManagedContent is of type Content.\nYour Content type is currently\ntype Content {\n  layout: Layout\n  page: [Page]\n}\nIf you want page to support a filter, it would need to be something like:\ntype Content {\n  layout: Layout\n  page(filter: Filter): [Page]\n}\nJeff. ",
    "magnusottosson": "I guess that the dataloader implementation in GraphQL does not support this because the task are only triggered once in this scope. Previously I have been working with facebooks javascript implementation and it supports using multiple dataloaders and you can even chain dataloaders so one loader uses another loader inside itself.\nThe use case above seems like a common scenario that should be supportet? Maybe it's just me that dont understand how to solve this?\nMy solution was to create another dataloader that performs all the calls it seend inside itself. This works but the loader will be very specific to this use case and wont combine requests with others where only the relationship is needed etc.... ",
    "sangeethasunkari": "I am already using InputType and context.GetArgument in my Resolve. Here is my Resolve function\nField<VendorType, Vendor>()\n                .Name(\"updateVendor\")\n                .Argument<VendorUpdateInputType>(\"vendor\", \"vendor input to update\")\n                .ResolveAsync(context =>\n                {\n                    var vendorinput = context.GetArgument<Vendor>(\"vendor\");\n                    var vendorid = vendorinput.VendorId;\n                    var args = context.Arguments;\n                    return vendors.UpdateVendorAsync(vendorid, vendorinput);\n                }\n});\nIs there a way to get the the query variables via a loop dynamically... like args.Values.Items[0].Key and args.Values.Items[0].Value... something like that? But Values does not contain a definition for Items[0].. ",
    "DanielMillerSEL": "This code example is just to highlight the issue. In our actual application names do not collide and we do manually provide the name in our graph types. This code does compile though, so I do not believe it is running into the name conflict you describe.\nWe kept running into issues where it was more maintainable to do schema first, so we wrote a code generator that would produce the graphql-dotnet binding classes from a schema. We use some systems using resolvers that are not supported out of the box, such as using the asp dependency injector that made normal gql.net schema first undesirable.\nWe did the brute force approach with our codegen and registered every type listed in the schema, including interfaces. We already fixed it on our end by removing the interface registration, but it still feelt like a bug, hence the bug report.\nFeel free to report this as closed and as working-as-intended, my goal is to report that its an unintended behavior, but I agree that it's from an odd usage that was an issue on our end. We just didn't know it was an issue until the error occurred, which was around the third interface we added to the schema, the first two worked as intended as one of their implementors were registered first.\nPS: Without names declared, the schema printer prints the names long form as QueryGraphType, ImplementationGraphType , and InterfaceGraphType.\nHere is the printed schema\n```\nschema {\n  query: QueryGraphType\n}\nThe Date scalar type represents a year, month and day in accordance with the\nISO-8601 standard.\nscalar Date\nThe DateTime scalar type represents a date and time. DateTime expects\ntimestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar DateTime\nThe DateTimeOffset scalar type represents a date, time and offset from UTC.\nDateTimeOffset expects timestamps to be formatted in accordance with the\nISO-8601 standard.\nscalar DateTimeOffset\nscalar Decimal\ntype ImplementationGraphType implements InterfaceGraphType {\n  id: String!\n}\ninterface InterfaceGraphType {\n  id: String!\n}\nThe Milliseconds scalar type represents a period of time represented as the total number of milliseconds.\nscalar Milliseconds\ntype QueryGraphType {\n  inst: InterfaceGraphType\n}\nThe Seconds scalar type represents a period of time represented as the total number of seconds.\nscalar Seconds\n```. ",
    "sungam3r": "I could not find the corrected test in the appveyor logs. Is it ignored somewhere?. By the way, despite the exception, the server returns a json response to the introspection request. But, apparently, the GraphQL Playground does not like the structure of the answer as it contains errors, so it continues to repeat it every 2 seconds (schema.polling.interval in Playground Settings).\nResponse:\njson\n{\n  \"data\": {\n    \"__schema\": {\n      \"queryType\": null,\n      \"mutationType\": {\n        \"name\": \"Mutation\"\n      },\n      \"subscriptionType\": null,\n      \"types\": [\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"String\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Boolean\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Float\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Int\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"ID\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Date\",\n          \"description\": \"The `Date` scalar type represents a year, month and day in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"DateTime\",\n          \"description\": \"The `DateTime` scalar type represents a date and time. `DateTime` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"DateTimeOffset\",\n          \"description\": \"The `DateTimeOffset` scalar type represents a date, time and offset from UTC. `DateTimeOffset` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Seconds\",\n          \"description\": \"The `Seconds` scalar type represents a period of time represented as the total number of seconds.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Milliseconds\",\n          \"description\": \"The `Milliseconds` scalar type represents a period of time represented as the total number of milliseconds.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"SCALAR\",\n          \"name\": \"Decimal\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"__Schema\",\n          \"description\": \"A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.\",\n          \"fields\": [\n            {\n              \"name\": \"directives\",\n              \"description\": \"A list of all directives supported by this server.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"LIST\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"NON_NULL\",\n                    \"name\": null,\n                    \"ofType\": {\n                      \"kind\": \"OBJECT\",\n                      \"name\": \"__Directive\",\n                      \"ofType\": null\n                    }\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"mutationType\",\n              \"description\": \"If this server supports mutation, the type that mutation operations will be rooted at.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"OBJECT\",\n                \"name\": \"__Type\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"queryType\",\n              \"description\": \"The type that query operations will be rooted at.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"OBJECT\",\n                  \"name\": \"__Type\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"subscriptionType\",\n              \"description\": \"If this server supports subscription, the type that subscription operations will be rooted at.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"OBJECT\",\n                \"name\": \"__Type\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"types\",\n              \"description\": \"A list of all types supported by this server.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"LIST\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"NON_NULL\",\n                    \"name\": null,\n                    \"ofType\": {\n                      \"kind\": \"OBJECT\",\n                      \"name\": \"__Type\",\n                      \"ofType\": null\n                    }\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"__Type\",\n          \"description\": \"The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\\r\\n\\r\\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.\",\n          \"fields\": [\n            {\n              \"name\": \"description\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"enumValues\",\n              \"description\": null,\n              \"args\": [\n                {\n                  \"name\": \"includeDeprecated\",\n                  \"description\": null,\n                  \"type\": {\n                    \"kind\": \"SCALAR\",\n                    \"name\": \"Boolean\",\n                    \"ofType\": null\n                  },\n                  \"defaultValue\": \"false\"\n                }\n              ],\n              \"type\": {\n                \"kind\": \"LIST\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"NON_NULL\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"OBJECT\",\n                    \"name\": \"__EnumValue\",\n                    \"ofType\": null\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"fields\",\n              \"description\": null,\n              \"args\": [\n                {\n                  \"name\": \"includeDeprecated\",\n                  \"description\": null,\n                  \"type\": {\n                    \"kind\": \"SCALAR\",\n                    \"name\": \"Boolean\",\n                    \"ofType\": null\n                  },\n                  \"defaultValue\": \"false\"\n                }\n              ],\n              \"type\": {\n                \"kind\": \"LIST\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"NON_NULL\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"OBJECT\",\n                    \"name\": \"__Field\",\n                    \"ofType\": null\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"inputFields\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"LIST\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"NON_NULL\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"OBJECT\",\n                    \"name\": \"__InputValue\",\n                    \"ofType\": null\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"interfaces\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"LIST\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"NON_NULL\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"OBJECT\",\n                    \"name\": \"__Type\",\n                    \"ofType\": null\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"kind\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"ENUM\",\n                  \"name\": \"__TypeKind\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"name\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"ofType\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"OBJECT\",\n                \"name\": \"__Type\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"possibleTypes\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"LIST\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"NON_NULL\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"OBJECT\",\n                    \"name\": \"__Type\",\n                    \"ofType\": null\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"ENUM\",\n          \"name\": \"__TypeKind\",\n          \"description\": \"An enum describing what kind of type a given __Type is.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": [\n            {\n              \"name\": \"SCALAR\",\n              \"description\": \"Indicates this type is a scalar.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"OBJECT\",\n              \"description\": \"Indicates this type is an object.  `fields` and `possibleTypes` are valid fields.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"INTERFACE\",\n              \"description\": \"Indicates this type is an interface.  `fields` and `possibleTypes` are valid fields.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"UNION\",\n              \"description\": \"Indicates this type is a union.  `possibleTypes` is a valid field.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"ENUM\",\n              \"description\": \"Indicates this type is an num.  `enumValues` is a valid field.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"INPUT_OBJECT\",\n              \"description\": \"Indicates this type is an input object.  `inputFields` is a valid field.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"LIST\",\n              \"description\": \"Indicates this type is a list.  `ofType` is a valid field.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"NON_NULL\",\n              \"description\": \"Indicates this type is a non-null.  `ofType` is a valid field.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"__Field\",\n          \"description\": \"Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.\",\n          \"fields\": [\n            {\n              \"name\": \"args\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"LIST\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"NON_NULL\",\n                    \"name\": null,\n                    \"ofType\": {\n                      \"kind\": \"OBJECT\",\n                      \"name\": \"__InputValue\",\n                      \"ofType\": null\n                    }\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"deprecationReason\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"description\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"isDeprecated\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"Boolean\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"name\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"String\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"type\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"OBJECT\",\n                  \"name\": \"__Type\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"__InputValue\",\n          \"description\": \"Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.\",\n          \"fields\": [\n            {\n              \"name\": \"defaultValue\",\n              \"description\": \"A GraphQL-formatted string representing the default value for this input value.\",\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"description\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"name\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"String\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"type\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"OBJECT\",\n                  \"name\": \"__Type\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"__EnumValue\",\n          \"description\": \"One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.\",\n          \"fields\": [\n            {\n              \"name\": \"deprecationReason\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"description\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"isDeprecated\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"String\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"name\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"String\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"__Directive\",\n          \"description\": \"A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\\r\\n\\r\\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.\",\n          \"fields\": [\n            {\n              \"name\": \"args\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"LIST\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"NON_NULL\",\n                    \"name\": null,\n                    \"ofType\": {\n                      \"kind\": \"OBJECT\",\n                      \"name\": \"__InputValue\",\n                      \"ofType\": null\n                    }\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"description\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"locations\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"LIST\",\n                  \"name\": null,\n                  \"ofType\": {\n                    \"kind\": \"NON_NULL\",\n                    \"name\": null,\n                    \"ofType\": {\n                      \"kind\": \"ENUM\",\n                      \"name\": \"__DirectiveLocation\",\n                      \"ofType\": null\n                    }\n                  }\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"name\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"String\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"onField\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"Boolean\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": true,\n              \"deprecationReason\": \"Use 'locations'.\"\n            },\n            {\n              \"name\": \"onFragment\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"Boolean\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": true,\n              \"deprecationReason\": \"Use 'locations'.\"\n            },\n            {\n              \"name\": \"onOperation\",\n              \"description\": null,\n              \"args\": [],\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"Boolean\",\n                  \"ofType\": null\n                }\n              },\n              \"isDeprecated\": true,\n              \"deprecationReason\": \"Use 'locations'.\"\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"ENUM\",\n          \"name\": \"__DirectiveLocation\",\n          \"description\": \"A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.\",\n          \"fields\": null,\n          \"inputFields\": null,\n          \"interfaces\": null,\n          \"enumValues\": [\n            {\n              \"name\": \"QUERY\",\n              \"description\": \"Location adjacent to a query operation.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"MUTATION\",\n              \"description\": \"Location adjacent to a mutation operation.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"SUBSCRIPTION\",\n              \"description\": \"Location adjacent to a subscription operation.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"FIELD\",\n              \"description\": \"Location adjacent to a field.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"FRAGMENT_DEFINITION\",\n              \"description\": \"Location adjacent to a fragment definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"FRAGMENT_SPREAD\",\n              \"description\": \"Location adjacent to a fragment spread.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"INLINE_FRAGMENT\",\n              \"description\": \"Location adjacent to an inline fragment.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"SCHEMA\",\n              \"description\": \"Location adjacent to a schema definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"SCALAR\",\n              \"description\": \"Location adjacent to a scalar definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"OBJECT\",\n              \"description\": \"Location adjacent to an object type definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"FIELD_DEFINITION\",\n              \"description\": \"Location adjacent to a field definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"ARGUMENT_DEFINITION\",\n              \"description\": \"Location adjacent to an argument definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"INTERFACE\",\n              \"description\": \"Location adjacent to an interface definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"UNION\",\n              \"description\": \"Location adjacent to a union definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"ENUM\",\n              \"description\": \"Location adjacent to an enum definition\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"ENUM_VALUE\",\n              \"description\": \"Location adjacent to an enum value definition\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"INPUT_OBJECT\",\n              \"description\": \"Location adjacent to an input object type definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            },\n            {\n              \"name\": \"INPUT_FIELD_DEFINITION\",\n              \"description\": \"Location adjacent to an input object field definition.\",\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"OBJECT\",\n          \"name\": \"Mutation\",\n          \"description\": null,\n          \"fields\": [\n            {\n              \"name\": \"sendEmail\",\n              \"description\": null,\n              \"args\": [\n                {\n                  \"name\": \"messageDto\",\n                  \"description\": null,\n                  \"type\": {\n                    \"kind\": \"INPUT_OBJECT\",\n                    \"name\": \"EmailMessageDtoInput\",\n                    \"ofType\": null\n                  },\n                  \"defaultValue\": \"null\"\n                }\n              ],\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"Boolean\",\n                \"ofType\": null\n              },\n              \"isDeprecated\": false,\n              \"deprecationReason\": null\n            }\n          ],\n          \"inputFields\": null,\n          \"interfaces\": [],\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"INPUT_OBJECT\",\n          \"name\": \"EmailMessageDtoInput\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": [\n            {\n              \"name\": \"fromAddresse\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"fromDisplayedName\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"toAddresses\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"subject\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"body\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"isBodyHtml\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"Boolean\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"attachments\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"LIST\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"INPUT_OBJECT\",\n                  \"name\": \"FileInfoDtoInput\",\n                  \"ofType\": null\n                }\n              },\n              \"defaultValue\": \"null\"\n            }\n          ],\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        },\n        {\n          \"kind\": \"INPUT_OBJECT\",\n          \"name\": \"FileInfoDtoInput\",\n          \"description\": null,\n          \"fields\": null,\n          \"inputFields\": [\n            {\n              \"name\": \"url\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"fileName\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            },\n            {\n              \"name\": \"contentType\",\n              \"description\": null,\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"null\"\n            }\n          ],\n          \"interfaces\": null,\n          \"enumValues\": null,\n          \"possibleTypes\": null\n        }\n      ],\n      \"directives\": [\n        {\n          \"name\": \"include\",\n          \"description\": \"Directs the executor to include this field or fragment only when the 'if' argument is true.\",\n          \"locations\": [\n            \"FIELD\",\n            \"FRAGMENT_SPREAD\",\n            \"INLINE_FRAGMENT\"\n          ],\n          \"args\": [\n            {\n              \"name\": \"if\",\n              \"description\": \"Included when true.\",\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"Boolean\",\n                  \"ofType\": null\n                }\n              },\n              \"defaultValue\": \"null\"\n            }\n          ]\n        },\n        {\n          \"name\": \"skip\",\n          \"description\": \"Directs the executor to skip this field or fragment when the 'if' argument is true.\",\n          \"locations\": [\n            \"FIELD\",\n            \"FRAGMENT_SPREAD\",\n            \"INLINE_FRAGMENT\"\n          ],\n          \"args\": [\n            {\n              \"name\": \"if\",\n              \"description\": \"Skipped when true.\",\n              \"type\": {\n                \"kind\": \"NON_NULL\",\n                \"name\": null,\n                \"ofType\": {\n                  \"kind\": \"SCALAR\",\n                  \"name\": \"Boolean\",\n                  \"ofType\": null\n                }\n              },\n              \"defaultValue\": \"null\"\n            }\n          ]\n        },\n        {\n          \"name\": \"deprecated\",\n          \"description\": \"Marks an element of a GraphQL schema as no longer supported.\",\n          \"locations\": [\n            \"FIELD_DEFINITION\",\n            \"ENUM_VALUE\"\n          ],\n          \"args\": [\n            {\n              \"name\": \"reason\",\n              \"description\": \"Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted in [Markdown](https://daringfireball.net/projects/markdown/).\",\n              \"type\": {\n                \"kind\": \"SCALAR\",\n                \"name\": \"String\",\n                \"ofType\": null\n              },\n              \"defaultValue\": \"\\\"No longer supported\\\"\"\n            }\n          ]\n        }\n      ]\n    }\n  },\n  \"errors\": [\n    {\n      \"message\": \"GraphQL.ExecutionError: Cannot return null for non-null type. Field: queryType, Type: __Type!.\\r\\n   at GraphQL.Execution.ExecutionStrategy.ValidateNodeResult(ExecutionContext context, ExecutionNode node)\\r\\n   at GraphQL.Execution.ExecutionStrategy.ExecuteNodeAsync(ExecutionContext context, ExecutionNode node)\",\n      \"locations\": [\n        {\n          \"line\": 3,\n          \"column\": 5\n        }\n      ],\n      \"path\": [\n        \"__schema\",\n        \"queryType\"\n      ]\n    }\n  ]\n}. Can I ask a clarifying question? That is, this behavior is just part of the library implementation, not the specification? Is the implementation from facebook considered canonical and the implementation of other libraries should also follow it?\nWhile writing this comment already found the answer on the specification page\ngraphql\ntype __Schema {\n  types: [__Type!]!\n  queryType: __Type!\n  mutationType: __Type\n  subscriptionType: __Type\n  directives: [__Directive!]!\n}\nIndeed, this is a required field. Thanks!. Indeed, ExecutionStrategy.ValidateNodeResult do nothing with that type mismatch. fieldType is {Int!} and no one if condition work.. I understand. I was talking exactly about contributors. For example, I wanted to use enum type constraint which is only available in version 7.3.. Thanks! How can I get a package with these changes now? These errors are blocking our work now. I see on nuget.org only package with version 3.0.0-preview-1107 builded 17 days ago.. Fixes #1073. double whitespace. Just for internal use in fluent style.. I was guided by this behavior.. It seems to me that the behavior regarding this property was wrong:\nc#\n public List<int> someList { get; set; }\nElements of this list can never have null value, so it should be coerced to ListGraphType<NonNullGraphType<IntGraphType>>.\nI added tests for various combinations of types.. Is it permissible to add this dependency?. There was an error in the case of IEnumerable property (not IEnumerable<T>) - GenericTypeArguments returns empty array.. This behavior seems to me to be wrong. You can\u2019t just take and allow to register all structures/enums.\nWhile left as it was before. All types allowed for registration should already be in GraphTypeTypeRegistry.. And again forgotten scalars .... Oops, I accidentally clicked cancel review.. OK, for the interest I have conducted the tests.\nDemo:\n```c#\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\nnamespace ConsoleApp6\n{\n    [MemoryDiagnoser]\n    public class Program\n    {\n        [Params(\"someName\", \"SomeName\")]\n        public string s;\n    [Benchmark(OperationsPerInvoke = 16)]\n    public string ToCamelCaseOld()\n    {\n        if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n\n        return $\"{char.ToLowerInvariant(s[0])}{s.Substring(1)}\";\n    }\n\n    [Benchmark(OperationsPerInvoke = 16)]\n    public string ToCamelCaseNew()\n    {\n        if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n\n        var newFirstLetter = char.ToLowerInvariant(s[0]);\n        if (newFirstLetter == s[0])\n            return s;\n\n        return newFirstLetter + s.Substring(1);\n    }\n\n    [Benchmark(OperationsPerInvoke = 16)]\n    public string ToCamelCaseWithArray()\n    {\n        if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n\n        char[] a = s.ToCharArray();\n        a[0] = char.ToLowerInvariant(a[0]);\n        return new string(a);\n    }\n\n    static void Main(string[] args)\n    {\n        var summary = BenchmarkRunner.Run<Program>();\n    }\n}\n\n}\n```\nResults:\n``` ini\nBenchmarkDotNet=v0.11.4, OS=Windows 10.0.17134.648 (1803/April2018Update/Redstone4)\nIntel Core i5-6200U CPU 2.30GHz (Skylake), 1 CPU, 4 logical and 2 physical cores\nFrequency=2343750 Hz, Resolution=426.6667 ns, Timer=TSC\n.NET Core SDK=2.2.104\n  [Host]     : .NET Core 2.1.8 (CoreCLR 4.6.27317.03, CoreFX 4.6.27317.03), 32bit RyuJIT\n  DefaultJob : .NET Core 2.1.8 (CoreCLR 4.6.27317.03, CoreFX 4.6.27317.03), 32bit RyuJIT\n```\n|               Method |        s |      Mean |     Error |    StdDev |    Median | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |\n|--------------------- |--------- |----------:|----------:|----------:|----------:|------------:|------------:|------------:|--------------------:|\n|       ToCamelCaseOld | SomeName | 12.975 ns | 0.5710 ns | 1.6474 ns | 12.642 ns |      0.0035 |           - |           - |                 6 B |\n|       ToCamelCaseNew | SomeName |  5.013 ns | 0.2041 ns | 0.5791 ns |  4.943 ns |      0.0030 |           - |           - |                 5 B |\n| ToCamelCaseWithArray | SomeName |  3.533 ns | 0.1134 ns | 0.3254 ns |  3.504 ns |      0.0024 |           - |           - |                 4 B |\n|       ToCamelCaseOld | someName | 12.883 ns | 0.3666 ns | 1.0517 ns | 12.943 ns |      0.0035 |           - |           - |                 6 B |\n|       ToCamelCaseNew | someName |  1.038 ns | 0.0311 ns | 0.0906 ns |  1.025 ns |           - |           - |           - |                   - |\n| ToCamelCaseWithArray | someName |  3.357 ns | 0.1235 ns | 0.3562 ns |  3.153 ns |      0.0024 |           - |           - |                 4 B |\nSo, in any case, the proposed method impl is much faster than the current one. And if the word begins with a lowercase letter, then there is no allocation at all. Additional character checking is nothing compared to the time spent on allocating objects :).\n. ",
    "shoe-diamente": "Isn't that confusing? Why would you ever cache data loading that depends on different parameters?. ",
    "A360JMaxxgamer": "Of course you can do that. Basically it is done by schema stitching or remote schemas. This repo does not support it yet I guess #955. \nAs a temporary solution your api service could use the hotchocolate package. It supports schema stitching. But it it lacks a support for supscriptions on a stitched schema.\nOr you do the stitching by yourself. ;) . ",
    "cRUSHER-HLG": "Okey nice, then i will help you by contributing :D. . Something like the dataloader or caching and so on will be very nice i think. Better sayed apollo graphql not in shitty node.js :D. . yes. ",
    "Kayomani": "You shouldn't call next if you have responded here.  Whats with the .ConfigureAwait(true) all over the place? There shouldn't be any need to keep the original context.\nThis and the errors check previously discussed are the only two bugs I have I found with this PR. GraphQL.AspNetCore.GraphiQL.index.html seems to be missing too but I didn't test the explorer middleware.. ",
    "kalexii": "Hey, guys. Just browsing through the code, anyone seeing anything weird here?. string counts too?. ",
    "d3vi1h3aRt": "Consider using AppDomain.CurrentDomain.BaseDirectory instead of Assembly.GetExecutingAssembly().Location.. "
}