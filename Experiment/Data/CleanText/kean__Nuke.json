{
    "kean": "Thank you! I'll review you pull request some time later this week.\nBe aware that this is not a production ready framework. You might want to use DFImageManager instead. It's written in Objective-C but I've almost finished with nullability annotations.\n. DFImageManager 0.4.0 with nullability annotations is out. And yes, it uses NSURLSession (compared to SDWebImage.\n. Closing this for now on. Please wait for version 0.1.0 to submit pull requests.\n. Done\n. done\n. Added CocoaPods and Carthage support for Nuke/Core and Nuke/Alamofire\n. done\n. going to be available soon https://twitter.com/RuiAAPeres/status/645009646630117376\n. @marlowcharite Done 44e5e3b39757ab00b8d34c9b29798b931c1bd995. Carthage available in Nuke 0.2.2\n. done\n. I've added Carthage support 44e5e3b39757ab00b8d34c9b29798b931c1bd995 without copying source files. Also updated readme, CocoaPods setup etc. CocoaPods is still required for demo project, playground, and Alamofire and FLAnimatedImage integration. I'll have to figure out the best way to do it using Carthage.\n. Thanks, seems like an Alamofire issue, I'll take a look later.\n. Fixed, ImageTask no longer uses NSProgress #19\n. I was too hasty to release previous version. Fixed.\n. Hey, the repo structure has changes dramatically since the introduction of Carthage so this can no longer be merged. I'm downloading Xcode 7.1 at the moment and starting to implement tvOS support :wink:\n. Right, I just copied it from podfile ;)\n. Fixed by #14\n. Thanks, I'll take a look a little bit later. I guess that NSProcessInfo.processInfo().physicalMemory returns invalid value like UInt64.max starting with iOS 9 (can't test atm). If it does then we should either find an alternative API or just always return some default value as a recommendedCacheTotalLimit. Returning Int.max is unreasonable, 32-bits devices can't even address more memory.\n. Oh, actually physicalMemory works fine. It's just that you have more than 8 Gb of RAM :)\n(1024 * 1024 * 1024 * 16) * 0.2 = 3\u00a0435\u00a0973\u00a0836\n3\u00a0435\u00a0973\u00a0836 > 2 147 483 647 (Int.max on 32 bit)\n. Requires https://github.com/Flipboard/FLAnimatedImage/pull/95\n. Requires move from CocoaPods subspecs to separate specs for each plugin.\n. This is now handled in https://github.com/kean/Nuke-AnimatedImage-Plugin/issues/1\n. done\n. Done\n. Done\n. done eace47e1c1b54b8e8c440dd1bef0318fbb70b3ca\n. 1. There are no subspecs anymore\n2. Not feasible in Swift\n. Users can easily start using NSURLSessionDownloadTasks by providing custom ImageDataLoader\n. done\n. done 3e612d0c04d140b202e4f011782629ec578abff8\n. done\n. Weird, I don't have any issues:\nbash\n~/Develop/Source/Nuke @ host-192-168-1-34 (kean) \n~> xcodebuild -list\nInformation about workspace \"Nuke\":\n    Schemes:\n        Nuke iOS\n        Nuke OSX\n        Nuke watchOS\nbash\n~> carthage update --platform iOS\n*** Cloning Nuke\n*** Checking out Nuke at \"0.5.1\"\n*** xcodebuild output can be found in /var/folders/d1/d34_w5tj47lfm9szwgzr4tr00000gn/T/carthage-xcodebuild.L1llzl.log\n*** Building scheme \"Nuke iOS\" in Nuke.xcworkspace\nbash\n~> carthage version\n0.9.3\nXcode 7.0.1\nI would recommend to:\n- Clean Carthage cache, it regularly breaks stuff on my machine (~/Library/Caches/carthage)\n- Update Carthage\n. Hi\nUsing Nuke.ImageView\nswift\nlet imageView: Nuke.ImageView = <#imageView#>\nimageView.prepareForReuse()\nimageView.image = <#placeholder#>\nimageView.setImageWithURL(<#imageURL#>) \n// or imageView.setImageWithRequest(<#request#>)\nIf you need to add some transition animations you can subclass Nuke.ImageView and override public func imageTaskDidFinishWithResponse(response: ImageResponse) method.\nCreate your own UI classes\nNuke makes it extremely easy. See Nuke.ImageView for an example.\nBe aware that built in UI components might change in v1.0.\n. In version v1.0 (releasing soon) you would be able to set a placeholder using a built-in extensions:\nswift\nlet imageView = UIImageView()\nimageView.nk_setImageWithRequest(ImageRequest(URL: <#imageURL#>), options: ImageViewLoadingOptions(placeholder: <#placeholder#>))\nCurrently in develop branch\n. > pud????? \"Nuke-AnimatedImage-Plugin\"\nok ;)\n\ni just followed the instruction.. i just tried your framework on your sample project, by doing pod try \"Nuke\"..\n\npod try does seem to work on my machine. It should automatically download a repo to a temp folder, resolve dependencies and open a created workspace.\nI'm using CocoaPods 0.39\n. I would recommend to:\n- Update CocoaPods (sudo gem install cocoapods)\n- Clean CocoaPods caches (pod cache clean --all)\nThen try again. If it still doesn't work then please be more specific (show your Podfile, console output after pod install, full error message).\n. I can't reproduce this problem. Have you tried installing other frameworks? Does that problem occur only with Nuke?\n. Ok ;)\n. done\n. It would be nice if someone could port image preheating to OS X, I don't have any experience with NSTableView and NSCollectionView which seem very different from iOS versions.\n. Check out this guide please. On-disk caching is already handled by NSURLCache.\nIt's possible to add a custom on-disk cache by implementing ImageLoading protocol, but it would require a certain amount of extra code.\n. @ZAPHIT Nuke 4 will allow you to add custom on-disk cache into its pipeline. Releasing soon.\n. @joe528 Actually Nuke 3 already has such a protocol:\n``` swift\n/**\n On-disk storage for image data.\nNuke doesn't provide a built-in implementation of this protocol. However, it's very easy to implement it in an extension of some existing library, for example, DFCache (see Example project for more info).\n*/\npublic protocol ImageDiskCaching {\n    /// Stores data for the given task.\n    func setData(data: NSData, response: NSURLResponse, forTask task: ImageTask)\n/// Returns data for the given task.\nfunc dataFor(task: ImageTask) -> NSData?\n\n/// Clears the receiver's storage.\nfunc removeAllCachedImages()\n\n}\n```\nAs you can see It's synchronous, but the Nuke.ImageLoader calls methods from this protocol from the asynchronous Foundation.Operation.\nOn-disk caching in Nuke 4 is going to look more like this (it's still in the works, there is a lot to be done):\nswift\npublic protocol DataCaching {\n    func response(for request: URLRequest, completion: (CachedURLResponse?) -> Void) -> Cancellable\n    func setResponse(_ response: CachedURLResponse, for request: URLRequest)\n}\nIt's asynchronous, the user would be responsible for scheduling.\n. Nuke already features Alamofire integration. You can easily implement the same thing for AFNetworking, it would require 30 lines of code at most. If would be great if you could do that and share it with the community (distribute via CocoaPods and/or Carthage).\n. \n. 64 bpp, 16 bpc, kCGImageAlphaLast (what image data tells us) is not supported\n64 bpp, 16 bpc, kCGImageAlphaPremultipliedFirst (that I mention in a PR) is not supported either\nAs far as I can tell we should simply draw all images using the same pixel format which is best for rendering (for instance, 32 bbp, 8 bpc, kCGImageAlphaPremultipliedLast). End users should be able to easily alter this behaviour by implementing custom image decompressors.\n. swift\n// See Quartz 2D Programming Guide for more info\nguard let contextRef = CGBitmapContextCreate(nil,\n    Int(imageSize.width),\n    Int(imageSize.height),\n    8,\n    0,\n    CGColorSpaceCreateDeviceRGB(),\n    CGImageAlphaInfo.PremultipliedLast.rawValue) else {\n        return image\n}\n\n. I actually thought about drawing all images in a single format that is best for rendering. I haven't figured out which one to use yet but kCGImageAlphaPremultipliedFirst looks good.\n. Ok, thanks a lot. I'll take a closer look when I get home :+1:\n. Fixed in 9e24eca381aa5554bc8c78f60068e33ce1e7facc. Releasing v1.0.1 today.\n. That's right, there aren't many reasons to scale up.\n. Ok, I've just tested it and I can confirm that Swift calls the default implementation provided in public extension ImageDisplayingView where Self: View, which shouldn't be the case.\n. As a workaround you can set a custom handler on ImageViewLoadingController:\nswift\nclass CustomImageView: UIImageView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.nk_imageLoadingController.handler = { task, response, options in\n            // your nk_imageTask(task: ImageTask, didFinishWithResponse response: ImageResponse, options: ImageViewLoadingOptions?) implementation\n        }\n    }\n}\n. Please leave it open. Users should be able to override methods declared in ImageDisplayingView protocol, at least that was the intended behaviour. I should figure out why virtual dispatch doesn't work here.\n. After some research I've found several different issues related to methods dispatch with protocol extensions that still hasn't been fixed in Xcode 7.\nHere's the related one http://www.openradar.me/23067007. You have class A that conforms to protocol P that has default implementation of method foo. If you create subclass B of class A and implement method foo it never gets called unless class A also provides an implementation of foo method.\nAnd that's how it works in Nuke:\n1) If you implement nk_imageTask(_:didFinishWithResponse:options:) method in a class that declares conformance to ImageDisplayingView protocol (for instance UIImageView) then this method gets called (as expected):\n``` swift\n    extension UIImageView: ImageDisplayingView, ImageLoadingView {\n        public var nk_image: UIImage? {\n            get { return self.image }\n            set { self.image = newValue }\n        }\n    public func nk_imageTask(task: ImageTask, didFinishWithResponse response: ImageResponse, options: ImageViewLoadingOptions?) {\n        print(\"UIImageView method called\")\n    }\n}\n\n```\n2) However if you implement nk_imageTask(_:didFinishWithResponse:options:) method in a subclass of UIImageView and don't implement this method in UIImageView then this method never gets called (this is a bug which is the same as in the radar).\n``` swift\npublic class NKImageView: UIImageView {\n}\nextension NKImageView {\n    public override var nk_image: UIImage? {\n        get { return self.image }\n        set { self.image = newValue }\n    }\npublic func nk_imageTask(task: ImageTask, didFinishWithResponse response: ImageResponse, options: ImageViewLoadingOptions?) {\n    print(\"NKImageView method never gets called\")\n}\n\n}\n```\n3) If you implement nk_imageTask(_:didFinishWithResponse:options:) method in both UIImageView and NKImageView classes then you get the following error in NKImageView class (as of Xcode 7.1):\n\nThe error message is pretty obvious. And as you can see properties already can be overridden and get called as expected.\n. This behaviour (http://www.openradar.me/23067007) doesn't match the documentation that clearly states that:\n\nYou can use protocol extensions to provide a default implementation to any method or property requirement of that protocol. If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.\n\nSame thing holds with extensions with where clauses (which I've also tested):\n\nIf a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift will use the implementation corresponding to the most specialized constraints.\n. I haven't made it available, because it's not tested on tvOS yet. See ImageLoadingViewExtensions.swift\n. closed by dd752bdfc71dac0ad17304d65365f0db439ffb92\n. Hey! Yep, I've investigated this issue some time ago. Nuke does feature Bitcode support but Carthage 0.9.3 was completely broken in terms of Bitcode, see the discussion in https://github.com/Carthage/Carthage/issues/535. New version (0.9.4) does seem to feature some sort of workaround, but I haven't tested it yet. Are you using the latest version (0.9.4)?\n\nI would recommend to either use CocoaPods (which is excellent in terms of supporting new stuff as soon as it is available) or just disable Bitcode all together (which is the safest thing to do right now).\n. Carthage readme states that their script with workarounds now also contains a workaround for Bitcode. Please reopen if there are any issues with Nuke (not Carthage).\n. Thanks!\n. Hey @pyrtsa . I think I understand why you would want to express targetSize in points, however I'm not entirely sure about this change (which is a major one btw).\nThere are at least two ways to treat targetSize as points, and they produce different results:\n1. targetSize is premultiplied by screen scale (which makes sense, you want your images to have the same pixel size as your views)\n2. targetSize is multiplied by image scale (the way it works in your pull request)\n```\nExample:\nimage1: size 400x200, scale 2\nimage2: size 800x400, scale 1\nresizing image to targetSize 200x100 for screen with scale 2: \n\n\npoints X screen scale\nimage1 -> size 200x100, scale 2\nimage2 -> size 400x200, scale 1\n\n\npoints X image scale\nimage1 -> size 200x100, scale 2\nimage2 -> size 200x100, scale 1\n```\n\n\nIt seems less ambiguous to express targetSize in pixels. \nAnd PHImageManager also does the same thing - all the sizes including targetSize in requestImageForAsset(_:targetSize:contentMode:options:resultHandler:) method are in pixels.\n. It's late, I can't think anymore ;) \n1. I'm not sure what is the best way to handle image scale; Please take a look at ImageDecoder class before making changes; What problem are you solving? Is there a scenario in which you would want to set the image scale manually?\n2. keep targetSize in pixels?\n3. Seems alright.\n. It's ok, we're not in a hurry, thanks that you are investing your time :) It's not really a bikeshedding, the framework is already complete, and even though that change is small, it's still a breaking one.\nI understand how you would want targetSize to work. But I'm still not convinced why it should work that way. The default implementation is really simple - targetSize is in pixels, image scale it set to the display scale. The main goal in Nuke is not to cover every scenario imaginable but to make things simple and customizable.\nIf you want to treat targetSize as points (either one of the scenarios that I described in my first comment) you can implement a custom ImageDecompressor and return it in the factory method in ImageLoaderDelegate. Then you can pass targetScale in a userInfo property of ImageRequest class. That's just one way to do it. And there are other ways to use targetSize too. Hell, you can even use it to modify NSURLRequest if your server has a method to scale images on the fly (and ignore it in image decompressor).\nAbout scale. Again, I'm very reluctant about adding targetScale to the ImageRequest. I tried but I couldn't imagine a scenario in which I would want to set image scale manually when you I make a request. However, I've thought of a scenario in which you would ask your server for an image and it would return either @1x or @2x (or else) image based on some internal logic. Then you would want to set image scale according to the metadata provided by the server. The problem with Nuke in this scenario is that ImageDecoder doesn't have access to anything except for image data (NSData) and that might be a problem if image scale is not embedded in the image data (EXIF or something else).\n. There is also an option of removing targetSize altogether :)\n. Thanks for the contribution anyway, I haven't put much thought in image scale before.\n. 1. Yes\n2. Yes, I would also point out that \"in default implementation target size means pixels\", and explain how and when it's actually used. I'll work on this today.\n3. Nuke lacks documentation in some places\n. docs for targetSize and contentMode 1346119f13a873f0ded9764e04ce6d4931220bd6\n. hey @pyrtsa, could you please create a new pull request that would fix rendering errors due to the lack or rounding? Please branch of the develop branch and create pull request to the develop branch.\n. CocoaPods handles this automatically https://github.com/CocoaPods/CocoaPods/pull/4539\n. Nuke uses NSURLCache for disk cache. See ImageDataLoader class for more info.\nSee Image Caching Guide for more info about caching in Nuke.\n. I don't have experience with NSImage, it would be nice if someone could implement this for OS X. However, I'm not sure whether decompression and scaling is actually important on OS X.\n. This no longer aligns with current design. Also, ImageTask (Task in Nuke 4) no longer has targetSize and contentMode parameters which could lead to confusion on OS X which doesn't have an ImageDecompressor.\n. Here's a little more context about this issue: the problem is the lack of control over image preheating. Specifically, in some cases user would want preheating tasks to stop after image data is stored into disk cache.\n. There is also a problem with Nuke design. It doesn't provide a straightforward way to implement this feature by extending existing classes. Adding this feature would require users to reimplement the entire ImageLoader class. This problem should be addressed in Nuke v2.\n. Closed by aca5899e6222fe72973a5873f59bfd3c94678f4f\n. We came up with a simpler solution. Now there is a new property memoryCacheStorageAllowed in ImageRequest struct.\nUsage:\n``` swift\n// MARK: ImagePreheatingControllerDelegate\nfunc preheatingController(controller: ImagePreheatingController, didUpdateWithAddedIndexPaths addedIndexPaths: [NSIndexPath], removedIndexPaths: [NSIndexPath]) {\n    func requestForIndexPaths(indexPaths: [NSIndexPath]) -> [ImageRequest] {\n        return indexPaths.map {\n            var request = self.imageRequestWithURL(self.photos[$0.row])\n            request.memoryCacheStorageAllowed = false\n            request.shouldDecompressImage = false\n            return request\n        }\n    }\n    Nuke.startPreheatingImages(requestForIndexPaths(addedIndexPaths))\n    Nuke.stopPreheatingImages(requestForIndexPaths(removedIndexPaths))\n}\n```\nWhat happens: image data is loaded, stored in disk cache, decoded (NSData -> UIImage, neglectable) and NOT decompressed and NOT stored in memory.\n. Thanks!\n. Done\n. There are at least two ways to add WebP support:\n1. Add a new image decoder (see ImageDecoding protocol) and register it in ImageManagerConfiguration. That's how GIF support is implemented in Nuke AnimatedImage Plugin.\n2. Use WebPImageSerialization which has a swizzle that extends UIImage with WebP support. This method doesn't require any additional code on Nuke's side. I haven't tested it in Swift yet, but it should work just fine.\n. It seems that there is no work required on Nuke's side (see WebPImageSerialization). Haven't tested it thought.\n. Yeah, that's true, most servers would require you to explicitly tell them that the client supports webp. It's possible to set those headers either using HTTPAdditionalHeaders property of NSURLSessionConfiguration, or via NSURLRequest.\n. It would be nice if you guys share what you come up with, I'll add it somewhere in the Documentation.. Hey! There is a community plugin (Nuke-WebP-Plugin) which adds support for WebP! I've contacted the author, he's committed to update it to work with Nuke 7 when it is released. This means: \n- adding progressive decoding support (new in Nuke 7)\n- simplifying setup using ImageDecoderRegistry (new in Nuke 7)\nI'm adding the link to this plugin in README as a recommended solution for WebP decoding \ud83c\udf7b. I've simplified ImageLoaderDelegate by combining methods that were customizing processing in a single high-level method: loader(_:processorFor:image:). Users now have more control over processing.\n. Closed by aca5899e6222fe72973a5873f59bfd3c94678f4f\n. Nuke uses NSURLSession's cache management without any modifications. It's most probably that your server sets a really long max-age in cache headers - cache responses are not revalidated until they are expired.\nThere at least two ways to adjust that behaviour:\n1. Server should set a max-age value depending on how often do you want responses to be revalidated.\n2. Server should set must-revalidate in Cache-Control header to force image to be revalidated each time it's requested.\n\nUpdate: must-revalidate doesn't work as I expected, you should use no-cache or set max-age to 0 instead (see the end of discussion)\n\nThere are also some ways to control it programatically. I've actually written an entire guide on this topic. You might want to check it out.\n. Cache-Control:must-revalidate yeah that seems alright.\n\nUpdate: must-revalidate doesn't work as I expected, you should use no-cache or set max-age to 0 instead (see the end of discussion)\n. Nuke also has a memory cache for fast access to processed images. It doesn't have any revalidation mechanisms (yet, it will in Nuke 2), because it gets cleared frequently. It might add some confusion, because images would not get revalidated if they are present in memory cache. I doubt that it's a problem, but just so you know.\n\nThere isn't anything else that might interfere with cache management in NSURLSession. It should just work if the headers are correct (and seems that they are).\n. There a separate options for controlling memory cache now:\n``` swift\n/ Defines constants that can be used to modify the way ImageManager interacts with the memory cache.\n */\npublic enum ImageRequestMemoryCachePolicy {\n    / Return memory cached image corresponding the request. If there is no existing image in the memory cache, the image manager continues with the request.\n     */\n    case ReturnCachedImageElseLoad\n/** Reload using ignoring memory cached images. Doesn't affect on-disk caching.\n */\ncase ReloadIgnoringCachedImage\n\n}\n```\n``` swift\npublic struct ImageRequest {\n/** The request memory cache policy. Default value is .ReturnCachedImageElseLoad.\n */\npublic var memoryCachePolicy = ImageRequestMemoryCachePolicy.ReturnCachedImageElseLoad\n\n}\n``\n.NSURLRequestCachePolicyno longer affects memory cache in any way, onlyNSURLSessionTask`.\n. That's pretty much the only change in the behaviour in Nuke 2. Everything else should work as expected.\n. Yeah, I'm sorry, I can't really help with debugging that :( \nI would recommend trying to set a  max-age=0. See http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache\nIf you can't control server side, you can update Cache-Control on the client in optional public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, willCacheResponse proposedResponse: NSCachedURLResponse, completionHandler: (NSCachedURLResponse?) -> Void)\n. Or just ask on stackoverflow :)\n. Actually, yeah, I might have misunderstood how must-revalidate works. I haven't used it myself.\n. > I believe that must-revalidate means \"once the cache expires, refuse to return stale responses to the user even if they say that they are acceptable\". Whereas no-cache implies must-revlidate plus the fact the response becomes stale right away.\n. Hmm, thanks for the report. Maybe I should just make priority optional to avoid the problem altogether\nswift\npublic var priority: Float?\n. Fixed in Nuke 2.0.1. I decided to remove NSURLSessionTaskPriorityDefault, it seems like a more reliable solution. I don't want to depend on CocoaPods. And from the look of things Carthage doesn't support that kind of dependencies at all.\n. Hi, that's a common question.\nThe code that you are using updates cached response in a memory cache. It doesn't update response into a disk cache.\nswift\n/** Stores response into the memory cache.\n */\npublic func setResponse(response: ImageCachedResponse, forRequest request: ImageRequest) {\n    self.cache?.setResponse(response, forKey: ImageRequestKey(request, owner: self))\n}\nThe common way to update images in both in-memory and on-disk cache would be to configure HTTP cache headers on the server in a way that supports validation. I've written a guide on this (recurring) topic http://outscope.net/blog/image-caching, you should check this out.\nYou do have direct access to both in-memory and on-disk cache, but I personally wouldn't want to access them manually.\nThere is also a similar question regarding validation of image hosted on S3 https://github.com/kean/Nuke/issues/52\n. Yeah, there is a lot of info both in the issue and in the guide. Also, feel free to ask more questions.\n. Bitmaps created during decompression are in 32 bits per pixel, 8 bits per component, kCGImageAlphaPremultipliedLast image format starting with v1.0.1 https://github.com/kean/Nuke/issues/35\nI thought about supporting opaque bitmaps (use 32 bits per pixel, 8 bits per component, kCGImageAlphaNoneSkipLast), but I haven't found enough evidence that it actually affects performance in a measurable way yet. The memory usage is the same; the drawing performance might differ though.\n. I will support opaque bitmaps in the next release, it certainly wouldn't hurt.\n. (1) targetSize and contentMode properties on ImageRequest merely describe how to resize loaded images:\nswift\nprivate func decompress(image: UIImage, targetSize: CGSize, contentMode: ImageContentMode) -> UIImage {\n    let bitmapSize = CGSize(width: CGImageGetWidth(image.CGImage), height: CGImageGetHeight(image.CGImage))\n    let scaleHor = targetSize.width / bitmapSize.width\n    let scaleVert = targetSize.height / bitmapSize.height\n    let scale = contentMode == .AspectFill ? max(scaleHor, scaleVert) : min(scaleHor, scaleVert)\n    return decompress(image, scale: Double(scale))\n}\nIf you want resized image to fill the image view you should set imageView.contentMode to .ScaleAspectFill. That's the correct behavior.\n(2) Yes, targetSize is in pixels. There was a long discussion here https://github.com/kean/Nuke/pull/42 about whether it should be in points or in pixels. Nuke is sticking with pixels.\nHere's how it computes target size when you use nk_setImageWith(URL: NSURL) method:\nswift\npublic extension View {\n    /** Returns image target size in pixels for the view. Target size is calculated by multiplying view's size by screen scaling factor.\n     */\n    public func nk_targetSize() -> CGSize {\n        let size = self.bounds.size\n        #if os(iOS) || os(tvOS)\n            let scale = UIScreen.mainScreen().scale\n        #elseif os(OSX)\n            let scale = NSScreen.mainScreen()?.backingScaleFactor ?? 1.0\n        #endif\n        return CGSize(width: size.width * scale, height: size.height * scale)\n    }\n}\n. > By the way, do you have any suggestion about Nuke configuration that might help the scrolling performance?\nIt's already well optimized (images are decompress in a background, NSURLSessionTasks are created in a background, etc). I doubt that there's anything else that you can do on image loading side.\nI can't give any concrete advice about scrolling performance. In general, I rarely encounter any GPU-related problems when it comes to scrolling (unless you use some CALayer features like cornerRadius or shadows). First thing to do should always be to use Instruments to profile your CPU usage.\n. Thanks for the feedback :)\n. ImageDecompressor now uses CGImageAlphaInfo.NoneSkipLast for opaque images and CGImageAlphaInfo.PremultipliedLast for images that have alpha channel. There are no more blended layers when displaying images without an alpha channel.\n. Animations are expensive.\n\nCan this transition be disabled by configuration so that I can test without it?\n\nSee ImageViewLoadingOptions\n. > Any other option I can try? \nProbably not. I'm going to release fix for blended layers today.\n\nWould request.memoryCacheStorageAllowed = false help?\n\nIt disables memory caching (more precisely, it prevents manager from storing images into memory cache). It doesn't disable memory cache lookup, you should set memoryCachePolicy to ReloadIgnoringCachedImage to do that. But if you really don't need a memory cache you should initialize ImageManager without a memory cache.\n. > I am wondering if it consumes more CPU time or actually helps?\nI don't have a complete answer. If you take a JPEG, then in general it consumes a significant amount of CPU time when the images are resized by 0.5-1.0 scale factor. And it reduces CPU usage when the images are resized by 0.0-0.5 factor. In reality it's not that simple, it depends on the underlying decoding implementation, the scaling factors that it supports.\nIn general I would probably avoid scaling images. Maybe someone could provide more info on this.\n. I've updated an answer above, hope it makes some sense now.\n. This no longer aligns with current design. Users do have access to all that is needed to implement this outside of Nuke.\n. Tasks do get cancelled, there is no problem with that. Apparently there is too much NSURLSessionTasks being resumed and cancelled, even though there is a mechanism that prevents excessive creation of tasks. I have an idea how to improve this, I'll work on it on a weekend.\n. I've made some changes in the develop branch, everything works as expected now. I'll test them tomorrow and release v2.2 soon. It would be nice if you could test it too.\n. I'm testing it in nk59-test branch. I've tried multiple configurations: \n- Disable task reusing in ImageLoader\n- Disable disk storage\n- Disable memory storage\nIt works fine, and I do scroll fast enough (see taskIdentifiers):\nexecute <__NSCFLocalDataTask: 0x14a81a3e0>{ taskIdentifier: 31248 } { running }, pending: 3, executing: 10\nexecute <__NSCFLocalDataTask: 0x14a8137c0>{ taskIdentifier: 31247 } { running }, pending: 2, executing: 10\nexecute <__NSCFLocalDataTask: 0x14a8174c0>{ taskIdentifier: 31246 } { running }, pending: 1, executing: 10\nexecute <__NSCFLocalDataTask: 0x14a80c750>{ taskIdentifier: 31245 } { running }, pending: 0, executing: 10\nHowever, I did find a problem with Alamofire. I've missed the fact that they resume NSURLSessionTasks right after they are created (startRequestsImmediately option). This behaviour defeats the purpose of limiting number of concurrent tasks in Nuke.ImageLoader. I'll fix this in https://github.com/kean/Nuke-Alamofire-Plugin/issues/2\nAre you testing it with Alamofire plugin?\n. https://github.com/kean/Nuke-Alamofire-Plugin/issues/2 does fix the issue with Alamofire. I'm trying to find a workaround that wouldn't require changing startRequestsImmediately to false, it might break existing code.\n. > Any specific code to use Alamorefire plugin?\nYou have to install it and then create custom Nuke.ImageManager with an Nuke.AlamofireImageDataLoader. You would have known if you used it.\nBack to the issue. I've found two problems, both are fixed now. You can checkout nk59-test branch, update pods, and run \"Basic\" (built-in networking) and/or \"Alamofire\" (Alamofire networking) demos to see it for yourself. \nThose fixes hasn't been released yet, changes to Nuke are in develop branch, changes to Nuke Alamofire Plugin are in master branch of the corresponding repos.\nIf you are still experiencing any issues please either provide access to your project, or create a demo project (you can use Nuke's demo), I'll be glad to help.\n. > I have to scroll \"at a certain speed\" to reproduce the problem\nYeah, that's true. Nuke 2.0...2.2 ignored requests that were cancelled in a short period of time after they were created. That was an experimental feature (that you could turn off), it didn't work as well as I expected. Now ImageLoader simply limits number of concurrent NSURLSessionTasks - honestly, that's how it should've been implemented in the first place.\n\nThe project to reproduce the problem:\nNukeTestFastScrolling.zip\n\nYou should update dependency in your podfile to, your are not seeing the changes made in develop branch.\nruby\npod \"Nuke\", :git => \"https://github.com/kean/Nuke.git\", :branch => \"develop\"\nI'll release those changes as soon as I finish testing it.\n. > What you mean is that you actually had fix for the problem I am seeing?\nYes, it clearly is fixed.\n\nDo you want me to do any further testing at this moment?\n\nI'm testing using your sample project.\nFirst, I install Nuke from master to see that the problem exists in a current version:\n```\npodfile\npod \"Nuke\", :git => \"https://github.com/kean/Nuke.git\", :branch => \"master\"\n```\nThen, I remove the app (to clear caches) and install Nuke from develop to verify that it actually fixes the problem:\n```\npodfile\npod \"Nuke\", :git => \"https://github.com/kean/Nuke.git\", :branch => \"develop\"\n```\nThe problem is easier to reproduce with Network Link Conditioner enabled.\n. Well, I guess I'll release those changes (hard limit for number of concurrent tasks) anyway.\nOnce again, I've tested it using your sample project. I can clearly see a problem using Nuke version from master (10+ seconds delay, just like your described), and I can confirm that there is no delay in develop branch.\nSorry, I can't allocate any more time on this issue. However, if you'll have some more ideas regarding it, please let me know.\n. I made some extra improvements in a develop branch. It should be more than enough for most cases. \n. Hey @BabyAzerty,\nI found that you could trigger this problem by resuming and cancelling NSURLSessionTasks at a really fast rate which would eventually trash NSURLSession. AFAIK none of the existing frameworks (AlamofireImage, HanekeSwift, Kingfisher) have a built-in solution to this problem. All they do is limit the number of concurrent NSURLSessionTasks. Nuke also does that in a form of a custom Nuke.TaskQueue in Nuke 3, and simple Foundation.OperationQueue in Nuke 4. This helps in a way but does not eliminate the problem.\nI think the problem requires a custom solution on app's side. In a nutshell, you need to make sure that you don't resume and immediately cancel requests when cells go offscreen. I could think of a number of ways to achieve that. A classic solution would involve rate-limiting image requests. I believe that that goes out of scope of Nuke or other image loading frameworks (I might be wrong on this one, I would probably rethink this for Nuke 4).\n. Just checked your edit. Yeah, it was much simpler in your sample, your were not cancelling requests at all. The problem that @joe528 described here is different (and more intricate one, thus rate-limiting etc).\n. Nuke 4 now features a Rate Limiter which solves this problem without any compromises \u26a1\n. Closed d6fe8899460940536b5b5c0ec3f0aafd26fa6811\n. By default, Nuke relies only on HTTP caching implemented in Cocoa for on-disk caching. I've written a comprehensive guide on this topic.\nIf custom on-disk caching is required than take a look at ImageDiskCaching protocol:\nswift\npublic protocol ImageDiskCaching {\n    func setData(data: NSData, response: NSURLResponse, forTask task: ImageTask)\n    func dataFor(task: ImageTask) -> NSData?\n    func removeAllCachedImages()\n}\nSee CustomCacheDemoViewController for an example.\n. I'm not aware of the details related to live photos. If there are some specific requirements please let me know.\n. Thanks, I'll take a look later today. From the first impression, it does seem quiet complicated.\nMy first thought was to create a custom UIView subclass that would request .jpg and .mov via separate tasks (why make user wait for a .mov?). Nuke already supports .jpg. And I think @mitchellporter has already tricked Nuke into supporting .mov files.\n. Nuke 3.0 requires Swift 2.2 and Xcode 7.3. Please use Nuke 2.3.0 until you update to Xcode 7.3.\n. Hmm, I can't think of anything that could have affected this. I've mostly just removed some excessive features in new versions.\n. My first step would be to check the app for memory leaks.\n. I've checked diffs and there are at least two things that might have affected this:\n1. ImageLoader reuses NSURLSessionTasks for equivalent requests (for example, same URL). After the data is loaded it needs to be decoded (NSData -> UIImage). In Nuke 2.2.0 the data was decoded once for all of the registered equivalent requests. Now it is decoded once for each request. Note: this change was made to simplify implementation to support custom on-disk caching, it is reversible though.\n2. The default ImageLoadingView protocol implementation no longer resizes loaded images by default. You have to opt-in to resize images. Note: I've found resizing to be ineffective when images size is close to the view size.\nCould any of these changes affect your app? More specifically, do you start (intentionally?) multiple equivalent requests for the same URL? Did you rely on automatic resizing of loaded images?\n. > Is there a change we should make on our end , or is this something you will address?\nThere's a performance regression on my end. But you could stop making too much tasks; maybe cancel tasks when the tiles go offscreen.\n\nI think for now I'm going to just throw the map UIImages in an NSCache as a temporary solution until you have a release ready\n\nNuke already has a built-in memory cache.\nI'm going to ship a release that fixes those regressions in a matter of days, maybe even tomorrow. I also have some new performance improvements in mind. I would suggest to stick with version 2.2.0 for now.\n. Fixed https://github.com/kean/Nuke/releases/tag/3.1.0\n. Do you use custom image cache (ImageDiskCaching)?\n. There is a problem with custom disk cache - it allows partially loaded image data to be stored on disk.\nI've already implemented a fix and I'm going to release it soon. For now on, please, avoid using custom disk cache.\n. Fixed https://github.com/kean/Nuke/releases/tag/3.1.0\n. > Create thumbnails of the locally stored images (in the Documents directory);\nCreate ImageRequest with NSURL that points to the local image, and provide desired targetSize and contentMode. Nuke will load image data and resize the image. Images are resized during decompression (see ImageDecompressor) so it should be effective (you might want to profile it to make sure).\n\nCache these thumbnails (on disk and in memory);\n\nResized image are stored in memory. There is not straightforward way (that I know of) to store resized images on disk. In my opinion memory cache should be enough, it depends on the specifics or you app though.\n\nPopulate the collection view with the thumbnails from the cache using the technique that is described in this Nuke guide.\n\nImage preheating in Nuke supports image filters (including resizing). All you need to do is to make sure that targetSize and contentMode in preheating requests match those of the requests that you create for collection view cells.\nHope that makes sense :)\n. It works at least as of Nuke 4 (currently in development). This method as long as other methods from NSImageView extension are now covered by unit tests.\n. nk_setImageWith(:) method cancels previous task registered with the cell. If you don't call this method on a cell (like you do in else) the previous task won't get cancelled and the \"empty-image\" will be replaced with the loaded image. This might be causing the issue. Try calling nk_cancelLoading on your cell before setting an 'empty-image'.\n. Thanks!\n. Thanks for pointing that out. I agree that it was not a particular good idea and the async should be removed.\n. Thanks, I'll release a new version with this fix sometime soon.\n. Yeah, I guess it was introduced in 3.1.2. There were some changes in ImageViewLoadingController - it now cancels tasks registered with it synchronously. Apparently, I've missed something and changed the previous behaviour.\nThanks for reporting, I'll investigate it. It might help if you could post any of your custom code that gets called in tasks completion handler.\n. I found a serious problem in an implementation of loader(loader: ImageLoading, task: ImageTask, didCompleteWithImage image: Image?, error: ErrorType?, userInfo: Any?) method in ImageManager. It was overwriting response of ImageTask without synchronization and without checking current task's state. This seems like the only possible reason that could lead to EXC_BAD_ACCESS that you reported. It's hard to reproduce since it's a synchronization problem.\nI'm going to release Nuke 3.1.3 today. If you see this problem again, please let me know.\nI hope I didn't miss anything and I hope I would be able to refactor most of it for Nuke 4.\n. Yeah, I'm going to start working on Nuke 4 when Swift 3 it out. I'm actually not programming in Swift at all until Swift 3 is out :)\nI'm not planning a lot of major changes. Just update for Swift 3; probably adoption of new Swift API Design Guideline; a couple of small, but breaking changes to make things more simple. I keep it all in a private (it's a total mess) Trello board.\nI would also like to investigate making Nuke more generic. The \"pipeline\" that is implemented in Nuke might be useful not just for images, but for some other resources as well (like small videos). There is at least some demand (#1, #2) for this feature. If it fits nicely in a current design, I'll implement it.\n. ImageManager guarantees that there is a response by the time it's needed. It's just a private logic check, nothing to worry - it already used force unwrap before. In the meantime, I'll try to refactor it away in v4.\n. Actually, I've started working on it and realised that it needs a complete rewrite because my Swift seemed to evolved a lot \ud83d\ude04 btw, asserts are already gone https://github.com/kean/Nuke/tree/nuke4\n. Yeah, Nuke is built exclusively for images. \nHowever, the \"pipeline\" used for loading images might as well be used for loading other types of media. It shouldn't be too hard to support it (you can do it the same way that FLAnimatedImage plugin adds support for GIFs). I had this in mind for Nuke 4 (which I'm working on).\nMy only concern is that audio and video are \"streaming\" media in their nature. They might require a different approach and thus might not be a good fit for Nuke.\n. Yep, I maintain a Swift 2.3 branch. It supports all latest Xcode 8 betas, including Beta 6.\nIn the meantime, I'm working on Nuke 4 in master branch. It's rewritten in idiomatic Swift 3 and features some other major changes.\n. Absolutely. My plan is to continue releasing Nuke 3 that works with Swift 2.3 for a while. And release Nuke 4 that works with Swift 3 when it's (Nuke 4) finished.\n. @joe528 My main goals for Nuke 4 were to effectively make it a micro framework - that should be Nuke's distinctive feature. It means smaller code base (it now has 785 lines of code compared to Kingfisher's 2357); principle of least astonishment; more and simpler ways to extend existing functionality. I hope it's going to be a pleasure to use \ud83d\ude03 I'm keeping almost all of the existing features (except for progress reporting, I'm still not decided on this one).\nI don't have a complete list of changes (there are too many). If you are interested, you might want to check new APIs for yourself. I'm working in a master branch. Example project, tests, playgrounds, docs are all up to date.\n\nBesides, would the performance be even better?\n\nI believe so. The core performance characteristics are going to be the same. There is almost 0 work made on the main thread; there are no String manipulations whatsoever - you won't find this in any of the other frameworks that I'm aware of. Preheating now also works in a background, that's going to be a new performance win. I also use more structs, finals, etc which means less heap memory allocations, less dynamic dispatch.\nThanks for your interest \ud83d\ude04\n. > Besides, would the performance be even better?\n@joe528 it is now, check out Nuke 4.1!\n. Thanks for reporting! I'll investigate it when I have some free time. The problem is not immediately obvious to me. If you'll have any ideas please let me know.\np.s. this functionality has been rewritten for Nuke 4 which is currently in development\n. @Querschlag  Are you sure that this is the stacktrace from the thread which is actually crashing?\n. Thanks @Querschlag, I found an issue, I missed a lock on the line 170 in ImageManager where I remove preheatingTask. It makes preheating not thread-safe in ImageManager.\nThere is a workaround: use stopPreheatingImages, startPreheatingImages and other preheating related methods from the main thread only.\nI'm going to release a fix alongside Swift 2.3 release. In the meantime, please use a workaround.\n. > If targetSize has a different from the source image aspect - you never get result image sized in targetSize. \nYeah, that's how it was designed to work. targetSize works together with contentMode, image aspect is always preserved.\nFor example, let say you have an input image which size is 200x100 px\n- targetSize = 50x50 px, contentMode = .aspectFill will produce 100x50 px image\n- targetSize = 50x50 px, contentMode = .aspectFit will produce 50x25 px image\nHope that makes sense.\n. targetSize is a size of a target (see Nuke.Target), not output image\n. > Do you recommend to update the app to use Nuke 4?\nNuke 4 is written in Swift 3 (Nuke 3 isn't). If you update your app to Swift 3, you'll have to update to Nuke 4.\n\nWhat are the primary benefits if I do so?\n\nLike I've mentioned, I wanted to make Nuke a micro-framework (in contrast with other frameworks).\nFeature-wise it's very similar to Nuke 3.\nMost changes were made to the implementation. Here's a couple of most meaningful changes:\n- Nuke 3 promised a lot of customization using protocols, however those protocols were vaguely defined and hard to implement in practice. Nuke 4 has a much, much simpler protocols. I really enjoy it and it helped me write more and better unit tests.\n- Nuke 4 now uses Promise for managing async operations, and CancellationToken as a unified model for cancelling operations. It resulted in a more concise code which is much easier to understand.\n- I've generously applied single responsibility principle. For example, instead of packing preheating and deduplicating of equivalent requests in a single vague Manager class they are now implemented as a separate classes (see Preheater, Deduplicator). It makes core classes much easier to reason about.\n\nThe app is like a news app that uses Nuke to download images used in a table view. Preheat feature is also used.\n\nMigration should be straightforward. Just follow the new usage guide and check out Request.swift file.\n\nRight now it's in beta 1, how's the progress and what is the plan for future releases? Should I wait for the general release or should I start with beta?\n\nIt's almost finished. I'm going to release Nuke 4 some time after Xcode 8 release. I really hope to get some feedback before that happens. Chances are I've missed something \ud83d\ude04\n. I'm also planning to implement a custom LRU memcache. I currently use NSCache which is not LRU, and which is a bit slow, because I have to wrap keys (which are structs) into objects. I'll ship it with beta2.\n. I would suggest waiting till beta2 though, I'll release it by the end of the day.\n. 4.0-beta2 is out\n. FYI, I've written an in-depth Nuke 4 Migration Guide.\n. I haven't planned Nuke 3 version updated to Swift 3 yet. I was hoping that migration to Nuke 4 should be straightforward (maybe that's too much to ask though?).\n. And yeah, I should probably just update Nuke 3 to Swift 3 too. I think I'll wait till Xcode 8 release, because migrating between Xcode 8 betas was extremely painful (breaking changes in Swift 3 with each release).\n. I've written an in-depth Nuke 4 Migration Guide to simplify the transition.\n. Yeah, I completely understand. I tried to migrate Nuke 3 to Swift 3 (just like you suggested) recently but it was such a pain that I ultimately decided against it since I already have Swift 3 compatible version (Nuke 4) which I've spent enormous amount of time on.\nCompared to alternatives (SDWebImage) PINRemoteImage seemed pretty good at the time. Hope that it works for you! I would also really like to know whether there were some critical points preventing you from using Nuke 4 instead? I might be missing something obvious that I'm simply not aware of. To me PINRemoteImage seems very similar feature-wise (expect for progressive jpeg support).\n. > In my tests, it also seemed that PINRemoteImage was a bit faster loading images from the disk cache, but I haven't done any controlled tests, so that could be very subjective.\nYeah, PINRemoteImage uses PINCache out of the box which is noticeably faster than URLCache used by URLSession (for multiple reasons). Nuke also has a DataCaching protocol which you can use to integrate PINCache (or any other caching library for that matter). I plan to add a plugin that would do just that, I just haven't decided on a particular library yet.\n\nAnother big factor for me is that I'm looking seriously at using AsyncDisplayKit and it has built-in support for PINRemoteImage, so that kind of sealed the deal.\n\nAsyncDisplayKit has a ASNetworkImageNode built in as well.\n\n... means that I'm not going to have to worry about these Swift migrations in the future.\n\nI'm glad that I currently have 0 lines of Swift code in production. That was the smartest decision I've ever made \ud83d\ude06\nThanks for your feedback!\n. Will do. I should test it with Xcode 8 GM first though.\n. I've added 3.2 tag, but I can't push it to trunk, because CocoaPods still seems to be broken (as of 1.1.0.beta.2).\nP.S. I would really encourage you to check out Nuke 4. I would also greatly appreciate some feedback.\n. Yay, I finally managed to push Nuke 3.2 spec.\n. You are right. I'm still undecided on this feature so I've removed it, probably just temporarily.\nAs a workaround I would suggest to show simple activity indicator instead of a progress bar:\n``` swift\nlet indicator = activityIndicator(for: cell)\nindicator.startAnimating()\nNuke.loadImage(with: request, into: imageView) { [weak imageView] in\n    imageView?.handle(response: $0, isFromMemoryCache: $1)\n    indicator.stopAnimating()\n}\n```\nSorry if this hurts the transition.\n. @ksm hey, unfortunately, I'm still undecided on this feature. Here are some of my points:\n1. Built-in DataLoader doesn't support progress reporting. In order to support progress it needs a bunch of new code. Namely, it needs to use NSURLSessionDataDelegate (which would complicate things).\n2. It doesn't seem right to just add a progress closure to the Request unless default DataLoader actually supports it.\n3. You should also take into account Deduplicator - it combines multiple Requests with the same loadKeys into a single request. This fact also complicates progress reporting (especially closure-based). Deduplicator is enabled by default.\n4. You can implement progress reporting without changing any of Nuke's code by adding a custom DataLoader.  You can either pass progress closure via Request.userInfo, or you can fire progress notifications from your DataLoader.\nHope this helps.\n. Update: this issue is planned for Nuke 6.0.. Added in Nuke 6.0-beta1. The API is:\nswift\nrequest.progress = { completed, total in\n}\nSorry it took me more than a year to deliver this \ud83d\ude05. Hi, glad that it works for you!\nCocoaPods doesn't install beta versions until explicitly told to. Here's how to do that:\npod 'Nuke', '~> 4.0-beta'\nCurrent beta (4.0-beta3) is production ready.\nP.S. Make sure to check out Nuke 4 Migration Guide. There are a lot of changes. If you'll have any issues with new APIs please let me know!\nCheers \ud83c\udf7b \n. @taviscaron, discussed a little bit here #83.\n. @lubos08 did you try pod repo update (see error message)? Also, make sure that you have the latest CocoaPods version.\n. @lubos08 I would recommend to wait just couple of hours till Nuke 4.0 is released though :)\n. 'master' has the latest version, If you install from 'master' you should be fine. Just avoid last tagged 'Nuke 4.0-beta3' build.\n. Hey!\nTechnically yes, Nuke 4 compiles and probably works on iOS 8 (the only exception is Alamofire plugin). However, current iOS 9 + iOS 10 adoption rate is already at 95% which leaves little reasons to still support iOS 8.\n\nIf you absolutely need iOS 8 support you could fork Nuke and lower the deployment target.\n. I've added a Podspec with iOS 8 support for you.\nHere's how to use it:\n// Podfile\npod 'Nuke', :podspec => 'https://gist.githubusercontent.com/kean/7ffdae2526b4e503a95c5e971320e9f9/raw/a90dbd8ba34981a0e43ab7544afdc12b6b000553/Nuke.podspec'\nI've smoke tested it on a clean project.\nP.S. iOS version is a major dependency, I would prefer that Nuke 4 ships with iOS 9 support only.\n. @Looks like I've messed up watchOS target with a recent commit. Please install from master until I release Nuke 4.0 (hope it's going to be soon).\n. Heh, I've just posted this guide 5 minutes ago \ud83d\ude04 I'm currently working on a better structure for Nuke docs.\nThanks for your interest! Keep in touch, I'm going to release Nuke 4.0 some time later today.\n. Sure! Nuke 4 is written in Swift 3, ready for production.\n. Hey, @bmetitiri! Managing reuse of views is one of Nuke's primary features. I'm not removing it and I have plans to extend it beyond what other frameworks do.\nFrom Nuke 4 Migration Guide (check it out!):\n\nInstead of adding extensions to UI components Nuke now has a Manager class which loads images into specific targets (see new Target protocol which replaced ImageLoadingView and ImageDisplayingView protocols).\n\n``` swift\n// Nuke 3\nlet request = ImageRequest(URLRequest: NSURLRequest(NSURL(URL: \"http://...\")!))\nimageView.nk_setImageWith(request)\n// Nuke 4\nlet request = Request(urlRequest: URLRequest(url: URL(string: \"http://...\")!))\nNuke.loadImage(with: request, into: imageView)\n// Nuke 4 (NEW)\n// Use custom handler, target doesn't have to implement Target protocol.\nNuke.loadImage(with: request, into: imageView) { response, isFromMemoryCache in\n    // Handle response\n}\n```\nThere are multiple reasons behind the change, just to name a few:\n- Manager class has context about all the requests per all targets (or just targets per screen if you create a Manager per screen). It will allow me to add features like: lower the priority of the requests when the UIVC goes off screen. That's something I really want in Nuke and it also something that works really well in practice.\n- ImageView no longer \"loads images into itself\". So Nuke doesn't break MVC.\n- I don't have to prefix methods.\n- Nuke 3 had elaborate ImageLoadingView and ImageDisplayingView protocols. They had lots of methods, some implemented by default, some added in extensions. It was a mess. New Manager -> Target relation is super simple and feels natural.\n- If you want to use custom manager for a specific target you no longer have to inject it anywhere - just use it\nAdding extensions to UIImageView that would do something as complicated as loading images is an abuse of extensions. The reason why other frameworks do that is because this is how it was initially implemented in SDWebImage (which was and is a terrible mess).\n. > I also noticed that the extension for FLAnimatedImageView is still around, is that intentional or will that be removed soon as well?\nYou now also use Manager class:\nswift\nlet view = AnimatedImageView()\nAnimatedImage.manager.loadImage(with: URL(string: \"http://...\")!, into: view)\nThe only extension method which is left is public func nk_display(_ image: Image?) which just starts a playback.\n. And about prepareForReuse. This method gets called right before cellForItemAt:.\nswift\nfunc collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    // View reusing is handled automatically\n    Nuke.loadImage(with: url, into: cell.imageView)\n}\nNuke.loadImage(with:into:) method automatically cancels previous outstanding request associated with the target. Which means that you don't have to implement prepareForReuse yourself.\nManager also keeps a weak reference to the target. If the target deallocates the associated request automatically gets cancelled too.\nYou can also (optionally) implement didEndDisplaying:forItemAt: method to cancel the requests as soon as the cell goes off screen:\nswift\nfunc collectionView(_ collectionView: UICollectionView, didEndDisplaying cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {\n    Nuke.cancelRequest(for: cell.imageView)\n}\n. > But you can't use AnimatedImageView in a storyboard right? Because it doesn't have initWithCoder? \nI've added support for Storyboards in AnimatedImageView, will be available in v2.1.\n. @lubos08, I just did, enjoy\n. Have you figured out what the problem was? Do you use pod update?\n. Hey! There is no such function yet (forgot to add it in Nuke 4.0). Please use Manager.shared.cancelRequest(for: cell.imageView) instead. Btw, in many cases you don't have to cancel requests manually.\n. Hey! The loadImage(with:into:handler:) method doesn't do anything when the image is loaded. This makes it useful in more scenarios than if it did.\nHere's an example of how to use it (I'll add it in a Usage section of README for the next release):\n``` swift\nlet indicator = activityIndicator(for: cell)\nindicator.startAnimating()\nNuke.loadImage(with: request, into: imageView) { [weak imageView] in\n    imageView?.handle(response: $0, isFromMemoryCache: $1)\n    indicator.stopAnimating()\n}\n``\n. It makes this method much more flexible:\n1.targetis a simpleAnyObject`\n2. You have full control over how to display an image\nThis enables every possible customization that I could think of.\nWhat loadImage(with:into:handler:) actually does for you is:\n1. Cancels previous outstanding request associated with the target\n2. Loads an image\n3. Checks whether the request is still associated with the target by the time it's completed\nThat's a lot. Actually the main loadImage(with:into:) method is implemented in terms of it:\nswift\nfunc loadImage(with request: Request, into target: Target) {\n    loadImage(with: request, into: target) { [weak target] in\n        target?.handle(response: $0, isFromMemoryCache: $1)\n    }\n}\nIf you need a method that automatically displays an image and has a completion handler you can easily add one in your project:\nswift\nfunc loadImage(with request: Request, into target: Target, completion: @escaping (Void) -> Void) {\n    loadImage(with: request, into: target) { [weak target] in\n        target?.handle(response: $0, isFromMemoryCache: $1)\n        completion()\n    }\n}\n. Hey, duplicate question here https://github.com/kean/Nuke/issues/89\nP.S. I guess I should clarify this behaviour a bit more.\n. Yeah, Decompressor can still resize images. Just replace the Request's default Decompressor with the one with the targetSize and the contentMode that you want.\n. Hey, @toshi0383.\nLoader (which loads images) callbacks are now always asynchronous, isFastResponse was removed.\nManager (which manages image loading into targets)  operates with a Target protocol which does have isFromMemoryCache.\nswift\npublic protocol Target: class {\n    func handle(response: Response, isFromMemoryCache: Bool)\n}\nIf you are using Loader directly and you need an analog of isFastResponse then just read from memory cache directly. It's very easy in Nuke 4:\nswift\nlet request = Request(url: url)\nlet image = cache[request]\n. Hey!\nIf you are using Swift 3 you should be using Nuke 4.x (most recent version).\nIf you are updating from Nuke 3 and lower please check out a migration guide.\nHere's an example how to load an image with a placeholder (this case is documented in Tips and Tricks):\nswift\ncell.videoImage.image = UIImage(named: \"image_thumbnail\")\nNuke.loadImage(with: url, into: cell.videoImage)\nThere is a bunch of other documentation available including usage guide, API reference, inline documentation in code, and more. Please refer to those.\n. Hey,\nYes, it is supported. Nuke uses NSURLSession under the hood and it supports file:// scheme which works with local files:\n\nThe NSURLSession class natively supports the data, file, ftp, http, and https URL schemes\n\nI've just tested it to make sure:\n``` swift\nfunc testFileUrl() {\n    let bundle = Bundle(for: LoaderTests.self)\n    let url = bundle.url(forResource: \"Image\", withExtension: \"jpg\")!\nexpect { fulfill in\n    Loader.shared.loadImage(with: url).completion { response in\n        print(response)\n        fulfill()\n    }\n}\nwait()\n\n}\n```\nMake sure that your urls have a valid format (including scheme).\n. Hi, check out Usage guide. You can use all the same APIs that you use for loading remote images for fetching images from disk.. Hey @lubos08, just provide a custom handler:\nswift\nNuke.loadImage(with: request, into: view) { [weak view] response, _ in\n    view?.image = response.value\n}\nIf you want to reuse this code just extract it to a function.\nloadImage(with request: Request, into target: AnyObject, handler: @escaping Handler) method is super flexible, this is why I don't provide much of the built-in options. Maybe I'll remove the default animation too in Nuke 5. Can't do it right now because of backward compatibility.. Thanks, I'll update that doc, not promising how soon though. \nPreheat readme has more up to date info.\nI find that fast that you have to enable Preheat.Controller manually a bit confusing too, maybe I'll refactor it in a next version.. I've marked the https://kean.github.io/blog/image-preheating as outdated, I simple don't have time to update all the posts. The general ideas described there still apply though.. > Cache.shared.removeAll()\nThat's memory cache only.\nCleaning disk cache isn't that trivial. Disk cache is whatever DataLoader uses. Default DataLoader creates and uses an instance of URLCache:\nswift\n private static func defaultConfiguration() -> URLSessionConfiguration {\n    let conf = URLSessionConfiguration.default\n    conf.urlCache = URLCache(memoryCapacity: 0, diskCapacity: (200 * 1024 * 1024), diskPath: \"com.github.kean.Nuke.Cache\")\n    return conf\n}\nIn the current Nuke version you don't have access to that URLCache instance. You'll have to initialize your own DataLoader with your own URLCache to have access to it.\n. Yes. And the default 'URLCache' created by Nuke has a 200 Mb limit. If you find it to be to large, just use a custom 'DataLoader'.. Thanks, I'll investigate. However, I'm quite sure that's just the fasle negative. LinkedList is very simple and I've also tested Cache numerous times.. @n3trino sorry, I'm on a vacation, had no time to test this. I'm no entirely sure, but I believe that there is no leak, and this Cache object is a singleton anyway.. I've done some extensive testing and can confirm that there are no leaks neither in Cache, LinkedList, nor in any other Nuke classes. All the proper deinit methods get called, memory usage doesn't grow, etc.\nI'm pretty sure it's just a false positive in Memory Graph Debugger, it's a new instrument after all. I wish I could get rid of that warning, but I have no idea how.. @winkelsdorf thank you for a such a detailed (as always) report! I'll investigate when I have some time to do so. I don't have a clear notion what's going on with those warnings right now.. I've simplified memory management in Nuke 5 (not directly related to this issue, I'll give it some more attention later):\n\nNuke 5 Release Notes (Draft)\nNuke 5 Migration Guide (Draft). No worries. I'll update plugins alongside Nuke 5 beta.. Nuke 5 is out \ud83c\udf7e . Xcode 8.3 seems to solve all those pesky false-positive memory leak warnings \ud83c\udf89. Thanks! \ud83d\ude04 . Hey, @michealc. I haven't tried using Swift from Objective-C yet, only the other way around. The former is trickier, because almost none of the Swift features are compatible with Objective-C.\n\nFor instance, from Using Swift with Cocoa and Objective-C:\n\nA Swift class must be a descendant of an Objective-C class to be accessible and usable in Objective-C. For more information about what you can access from Objective-C and how the Swift interface is imported, see Swift Type Compatibility.\n\nAFAIU, you'll need to write a Swift wrapper for Nuke which uses only primitive constructs that are compatible with Objective-C. I would suggest you use a framework written in Objective-C instead, there are plenty of those.\n. Sounds about right. Just wrap the functionality you need and you should be good to go. If there'll be some changes required on Nuke's side, I'll be happy to help.. Could you elaborate? What are you trying to achieve? . Ah, I see. Just create your custom processor and replace the default processor on the Request:\nswift\nvar request = Request(url: ...)\nrequest.processor = AnyProcessor(YourCustomProcessor())\nThe default processor is set to Decompressor which forces image to be decompressed into a bitmap, but it doesn't resize the original image.. \u041c\u043e\u0436\u043d\u043e \ud83d\ude03 \u041d\u0430 \u0430\u043d\u0433\u043b\u0438\u0439\u0441\u043a\u043e\u043c \u043b\u0443\u0447\u0448\u0435, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0434\u0440\u0443\u0433\u0438\u0435 \u0442\u043e\u0436\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0442\u044c, \u0435\u0441\u043b\u0438 \u0443 \u043d\u0438\u0445 \u0431\u0443\u0434\u0435\u0442 \u043f\u043e\u0445\u043e\u0436\u0438\u0439 \u0432\u043e\u043f\u0440\u043e\u0441.. \u0421\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0439, \u043a\u043e\u043d\u0435\u0447\u043d\u043e, \u043d\u0430 \u0440\u0443\u0441\u0441\u043a\u043e\u043c, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e.. > \u0412 \u043e\u0431\u0449\u0435\u043c \u0441\u0443\u0442\u044c \u0432 \u0442\u043e\u043c \u0447\u0442\u043e \u044f \u043a\u043e\u0433\u0434\u0430 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044e \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443 \u0438 \u0441\u0435\u0442\u044e \u0435\u0435 \u0432 \u0442\u0430\u0440\u0433\u0435\u0442 \u0442\u043e \u043e\u043d\u0430 \u0441\u0436\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u0434\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u0442\u0430\u0440\u0433\u0435\u0442\u0430 \u0438 \u044d\u0442\u043e \u043e\u043a. \n\u041c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u0442\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u043c \u0432\u044b\u0437\u043e\u0432\u043e\u043c. \u041a\u0430\u0440\u0442\u0438\u043d\u043a\u0430 \u043f\u043e\u0434\u043d\u0438\u043c\u0435\u0442\u0441\u044f \u0438\u0437 \u0434\u0438\u0441\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0435\u0448\u0430 (\u0435\u0441\u043b\u0438 \u043e\u043d \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043d).\n\u0418 \u043f\u0440\u0438 \u0436\u0435\u043b\u0430\u043d\u0438\u0438 \u043f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0432\u0441\u0435 \u0432 Nuke \u043c\u043e\u0436\u043d\u043e \u043a\u0430\u0441\u0442\u043e\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u0431\u0451\u0440\u0442\u043a\u0443 \u043d\u0430 Decomprssor, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u0443\u044e \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443 \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 \u0430\u0441\u0441\u043e\u0446\u0438\u0430\u0442\u0438\u0432\u043d\u044b\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u043c.\n\u0412\u0442\u043e\u0440\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u0432\u043e\u043f\u0440\u043e\u0441\u043e\u0432 \u043d\u0435 \u0434\u043e \u043a\u043e\u043d\u0446\u0430 \u043f\u043e\u043d\u044f\u043b. \u0412\u0438\u0434\u0438\u043c\u043e \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u044d\u0442\u043e \u043f\u0440\u043e \u043a\u0435\u0448 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438. \u0415\u0433\u043e \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u043e\u0436\u043d\u043e \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0442\u044c \u043f\u0440\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438. \u0418\u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043a\u0430\u0441\u0442\u043e\u043c\u043d\u043e\u0439.. It depends on you requirements. If you are not sure than you should probably just stick with the basics. Prefetching is more of an advanced feature which would make your code more complicated.. Hey! Thanks you so much, happy holidays to you too!\nI'm sorry, I'm on mobile so it's short.\nEquitable here is very simple. Just return 'true' if processor does the same thing with every image (basically doesn't have any parameters). \nProcessor is just part of the key under which the image gets cached. The other part is URL etc.. > Haha, ok I missed the obviou\nIt's just that the Equatable thing on the Processor is not that straightforward, and certainly not usual among image loaders. Any suggestions how to imporove this are welcome.\n\nperformance \n\nNuke performs all processing in the background. So if it feels fast enough I think you should be ok. I'm not using (big) computers till Jan 11th, can't suggest any alternatives atm :). Hey guys! I'm on a vacation till Jan 11th so it's short.\nI think that you don't need promises to do any of this. Just use a good ol counter:\nswift\nfunc loadImages(for requests: [Request], completion: (...)) {\n    var remaining = requests.count\n    let cts = CancellationTokenSource() // cancels all requests, you can return if from fund / accept token as argument - it's flexible\n    requests.forEach {\n        Nuke.loadImage(for: $0, token: cts.token).compeltion {\n            remaining -= 1\n            if remaining == 0 {\n                completion()\n            }\n            // add whatever error handling that makes sense for you app\n       }\n}\nIt's written from mobile, so take it with a grain of salt.\nI'm actually soon going to add a convenience API on top of some of Nuke's functions that return promises. The users don't need to deal with extra complexity that comes with promises.. And in case you were already using promises (which again is by no means necesssary) you could've probably got rid of this boilerplate. You could do something like wrap Nuke.Promise into PromiseKit.Promise (or analog) and use func when<T>(fulfilled promises: [Promise<T>]) -> Promise<[T]> or something like this. But I would suggest to stick with the simple ad-hoc solution with counter.. If are updating to Nuke 5  use Manager to load images directly w/o targets instead of Loader. Loader no longer manages memory cache, only Manager class does.\nswift\nfunc loadImages(for requests: [Request], completion: (...)) {\n    var remaining = requests.count\n    let cts = CancellationTokenSource() // cancels all requests, you can return if from fund / accept token as argument - it's flexible\n    requests.forEach {\n        Manager.shared.loadImage(for: $0, token: cts.token).compeltion {\n            remaining -= 1\n            if remaining == 0 {\n                completion()\n            }\n            // add whatever error handling that makes sense for you app\n       }\n}. RxNuke (NEW!) provides a solution to this use case.. Hey! We've made a new Gifu Plugin which is a Swift alternative to FLAnimatedImage. I'm not removing FL plugin any time soon. From mobile, sorry it's short.. Hi! Here's a similar question: https://github.com/kean/Nuke/issues/89\nTL;DR: loadImage(...) with custom a handler requires you to display an image; doesn't do anything by itself. I ultimately decided that Promises were adding more problems that they were solving. My major problem with promises is memory management, Promises just don't fit well in languages without GC capable of breaking cycles. In Swift it's hard to prove just by looking at the code when the objects are going to be dellocated and whether they are going to be dellocated at all. There were some other minor reasons like extra complexity, performance penalties, etc. As a result I've decided to remove the Promises from Nuke altogether.. Hey!\nIn general, yes, you should not process gifs. If you process an instance of UIImage with an attached gif data, the associated data gets lost.\nAre you using any of the Gif plugins? If yes, you may want to check out how Nuke managers are configured in them: https://github.com/kean/Nuke-Gifu-Plugin/blob/master/Source/AnimatedImage.swift. Hey! Nuke.Decompressor built into Nuke supports resizing, but it will never enlarge the image, only make it smaller if necessary. If you want to enlarge an image, use a Toucan Plugin. It supports resizing as well as many other common operations.. Does work on my machine:\n~> pod install\nAnalyzing dependencies\nDownloading dependencies\nInstalling Nuke (4.1.2)\nInstalling Nuke-Toucan-Plugin (0.2)\nInstalling Toucan (0.6.0)\nGenerating Pods project\nIntegrating client project\nPodfile:\n```ruby\nsource 'https://github.com/CocoaPods/Specs.git'\nuse_frameworks!\ntarget 'test_nuke_toucan' do\n    pod 'Nuke-Toucan-Plugin'\n    pod 'Nuke'\nend\n```\nTry this:\n- run pod update instead of pod install, maybe your specs are out of date\n- update CocoaPods. Hey! Thanks, I'm glad that it works well for you.\nThe use-case you are describing is a bit complicated. Here are couple of thoughts from the top off my head:\n- Don't use Caching. It is used by Manager on the main thread and it's meant for memory caching only\n- I don't have a clear answer what is the best way to solve this right now. I would probably suggest to wrap built-in Loader (or maybe DataLoader) in a disk cache for thumbnails (implementation might be similar to this, but for Loader). I don't think that you need memory cache on Loader / DataLoader level, just let Manager use Nuke.Cache which it's already using.\n- Check out Nuke 5 Changelog, it might affect how you go about solving this. And yeah, Nuke 5 is still work in progress. If you have any suggestions or any comments regarding current changes please share!. > I think this approach will work with 5 too as is, save the change to closures. What do you think about this?\nYeah, that seems reasonable. Just make sure that the request.processor != nil line does what you expect it does. Request has a default processor which is a Decompressor with default parameters. You may want to pass some specific options in request.userInfo instead.\n\nIt would also be nice to provide hooks to get from cache, and cache, the processed image. Maybe have default implementations in 5 that do nothing, but pass the processed image forward?\n\nCould you please elaborate? Regarding \"get from cache, and cache, the processed image\" - you can always use a default Loader to retrieve data from the custom disk cache wrapped into custom DataLoader and then have that data decoded and the image processed automatically by that Loader. If that's what you mean. The default Loader in Nuke 5 no longer has a memory cache so it basically just reads data and processes it, and gives it to you.\n. Awesome, glad that it worked for you! \ud83c\udf7b . Update: it looks like something that RxNuke (NEW!) should be able to handle in the future.. It's a small release. My main goals were to: a) make memory management simpler, b) make it easier to contribute to Nuke. Here's what I've come up with:\n\nNuke 5 Release Notes (Draft)\nNuke 5 Migration Guide (Draft). It's almost complete, I'll release it some time later today.\n\n\nI am using Nuke for image management, I was wondering if I should use 5.0 even if not released quite yet?\n\nYou can start using it from master branch, it's stable and there won't be any critical changes before the release.\n\nseemed like caching stuff changed a bit in 5.0.\n\nIt did, and I'll probably make some adjustments to the new entry about integrating third-party caching libs before the release.\n. Nuke 5 is out \ud83c\udf7e . Hey, Ludovic!\nNuke doesn't support progressive jpeg (can decode, but can't display progressively) and never will. I would suggest to look some place else, maybe something like Concorde will work for you.\nIn my personal opinion, progressive jpeg isn't worst it on iOS because it requires a lot of resources. A better approach for mobile would probably be to load thumbnail first, full-size image second (here's how to do that in Nuke). But of course that depends on the requirements that you have, that's just my thoughts.\nCheers.. Update: it might be something that I'd consider adding as part of Nuke 6.0 + RxNuke 1.0.. Hey, @netspencer. I'm undecided on this one, there doesn't seem to be enough demand for this feature. I personally don't use it. And it's not an easy thing to implement (efficiently) and it's even harder to add it in an existing framework.. FYI I've made lots of infrastructure changes to support some new performance features in 7.0-beta1. I have a plan how to extend image decoding infrastructure as well to support progressive decoding and also make it easier to add other custom decoders (e.g. WebP). There is a good change that the first beta of this feature will appear in 7.0-beta2.. Progressive decoding is available in 7.0-beta2. The feature is in beta.. Hi! \nJust use anything as a target and use loadImage(with:into:hander:) method in which target acts like a cancellation token:\n```swift\nlet viewController =  UIViewController()\nloadImage(with: request, into: viewController) { result, isFromMemCache in\n    // handle result\n}\n// Use target to cancel the request\ncancelRequest(for: viewController)\n```\nThis is one of my primary use cases, I also use it to load thumbnails first, fullsize images later.\nI'll think what I can do in Nuke 5.1 to add something like loadImage(with request: Request, token: CancellationToken? = nil, completion: @escaping Handler) to Manager class. I'll first try to evaluate whether it's actually a desirable change, cause my own use-cases always rely on targets and mem-cache associated with a set of targets.. I've realized that this kind of API is actually necessary for Preheater. I'll do some damage control in Nuke 5.0.1 to address this issue. Stay tuned.. New APIs available in Nuke 5.0.1:\nswift\nclass Manager {\n    public func loadImage(with url: URL, token: CancellationToken?, completion: @escaping (Result<Image>) -> Void)\n    public func loadImage(with request: Request, token: CancellationToken?, completion: @escaping (Result<Image>) -> Void)\n}\nThey both check memory cache asynchronously and they both call completion closure asynchronously on the main thread. Instead of using isFromMemoryCache just use memory cache directly:\nswift\nlet image = Cache.shared[request]. Hey! Nuke 5 is a major release so it does contain some breaking changes.\nHere's some information that aims at easing the transition from the previous versions:\n- Nuke 5 Migration Guide\n- Nuke 5 Release Notes\nRegarding to Response you should replace it with a new Result<T> type. Here's an example:\nswift\nABImageDownloader.sharedInstance.nukeManager.loadImage(with: url, into: strongSelf, handler: { (response: Result<Image>, isFromMemoryCache: Bool) in\n    switch response {\n        case let .success(image): // use image\n        case let .failure(error): // handle error\n    }\n}\nYou might also want to use trailing closures, and type inference instead of hardcoding concrete types:\nswift\nABImageDownloader.sharedInstance.nukeManager.loadImage(with: url, into: strongSelf) { response, isFromMemoryCache in\n    switch response {\n        case let .success(image): // use image\n        case let .failure(error): // handle error\n    }\n}. Hey! Nuke has a built in memory cache that stores rasterized images (CG raster data. That seems about it.\nThe memory usage seems a bit too high for iPhone 5S though. Please let me know if you receive any memory warnings.. > I see Nuke is dropping its cache on receiving memory warning but CGRaster data usage is not dropping.\nI would suggest to disable Nuke's memory cache and see if you still can reproduce the problem. You might have some image views that don't get deallocated. Every image view holds a strong reference to the raster that it's displaying. Make sure that all your view controllers and views get deallocated properly. You might want to use visual memory debugger.\n\nOn side note - What is cached in Nuke default cache?\n\nNuke.Cache.shared is a default memory cache which is used by the default Nuke.Manager. To disable it you can create your own shared manager without a memory cache:\nswift\nlet manager = Nuke.Manager(loader: Nuke.Loader.shared, cache: nil)\n\nIs it network fetched data/ some intermediate representation/resized image?\n\nNo intermediate representations are stored, only processed images which get displayed in your image views.\nP.S. I periodically perform generational analysis using the demo project. I create a new Nuke.Manager instance, push a screen with a collection view with some images, than pop the screen and check if everything get deallocated. I haven't seen any leaked Nuke objects yet, only some UIKit crap like UIFont caches, UIStatusBar icons, etc.\n\n. I just realized that the images that your are displaying are probably enormous in size. I tested Nuke demo with 2000x3000px images and they result in only 22.89 MB rasters.\nTo fix the problem you should download images which are smaller in size and/or resize loaded image to fit your image views. If you still need to display full-size images, do it fullscreen, not in a collection view.\nThe best way to resize images is to replace default Decompressor with the one with a target size. This way only the resized rasters are created, never the full-size ones:\n```swift\nfunc makeRequest(url: URL, view: UIImageView) -> Request {\n    var request = Request(url: url)\n    request.processor = AnyProcessor(Decompressor(targetSize: targetSize(for: view), contentMode: .aspectFill))\n    return request\n}\nfunc targetSize(for view: UIView) -> CGSize { // in pixels\n    let scale = UIScreen.main.scale\n    let size = view.bounds.size\n    return CGSize(width: size.width * scale, height: size.height * scale)\n}\n```\nI've tested this code in a demo again (2000x3000 images, 4 images per row, no mem cache) and now the memory usage never grows more than 40 MB:\n\nP.S. The resizing API isn't very elegant at the moment. I'll add some convenience methods soon, and I'll also update docs based on your feedback. Cheers \ud83c\udf7b \n\nI think issue is Nuke is decoding the image in parallel\n\ndecoding+processing are performed on a serial queue specifically to avoid using too much resources. > So what do you think @kean - it's important to make that kind of resizing(I mean my upscale)?\nI don't have a definitive answer. I would probably avoid upscaling unless there are some visible performance issues. I doubt that there are any on the recent hardware. I think I remember stumbling about upscaling issues back in 2012, but that was an extreme case of displaying ~20x20px images fullscreen.\nAnd btw, if you have custom code that always resizes images than you should remove Decompressor, it would only slow things done.\n\nJust found resize in documentation. But didnt find it in code\n// As an alternative you can provide a target size (in pixels) yourself.\nrequest.resize(to: CGSize(width: 150, height: 150), mode: .aspectFit)\n\nSorry, this API isn't available yet, will be released soon with Nuke 5.1. And this method actually only downscales images. Any thoughts on that? Maybe I should rename it to downscale instead?. Yeah, makes sense.. swift\nNuke.loadImage(with: url, into: _picture) { [weak view = _picture] response, _ in\n    NetworkActivityIndicatorManager.shared.decrementActivityCount()\n    log.debug(\"- 1\")\n    view?.image = response.value\n}\nThe handler doesn't get called when the image view is reused and the request associated with it gets cancelled.\nA better approach would be to track network requests on a networking layer, similar to how AlamofireNetworkActivityIndicator does that.. Yep, just use Alamofire plugin. It's battle tested, AlamofireNetworkActivityIndicator performs as expected.. \ud83d\udc4d \n\nStill, wouldn't it be good to have a handler that is always called and takes success/error/canceled as an argument? However, this issue is done.\n\nMaybe, it's debatable. I decided to stick with non-guaranteed completion handlers so please account for that.\n. NSURLCache is infamous for weird bugs like this. If you want full control over disk caching you should use a third party caching library. Here's a helpful guide to do that.\n\nI am already calling Nuke.Cache.shared.removeAll when I receive a memory warning\n\nThat method removes images stored in memory cache only. And btw, you don't have to call it manually, Nuke.Cache does this automatically for you:\nswift\nNotificationCenter.default.addObserver(self, selector: #selector(Cache.removeAll), name: .UIApplicationDidReceiveMemoryWarning, object: nil). > Loader doesn't have any initializers that take just one argument. Should it be Nuke.Loader(loader: dataLoader, decoder: Nuke.DataDecoder(), cache: nil)?\nThis stuff is new in Nuke 5. Here's some information for easing the transition from the previous versions:\n- Nuke 5 Migration Guide\n- Nuke 5 Release Notes\nIt's a small release, but make sure to go through the changes, especially this one.. Your app might be using too much memory. Can you reproduce this with a default Cache settings (0.2 ratio)?. Using too much memory might result in CGContextDraw crashes like this one. AFAIK there is nothing Nuke can do to prevent this, so I'm closing this issue. The default cache ratio is already quite generous, I would suggest not to increase it.. > A default Request in Nuke without explicit image processing resizes images to the target size to reduce memory consumption and main thread usage, right?\nDefault Request doesn't resize the original images (it doesn't know the target size), it just draws it into the CGContext. I wouldn't expect any regressions in quality.\nAre you sure that you retrieved the image decompressed by Nuke correctly? It seems that it actually has scale = 2 and size = 48x48, which means that its pixel size is 96x96. This is why it might seem edgy when compared to the image produced by Gimp - it has 2x pixel density.. Great, I'm glad that you figured it out. \n\nI get perfectly rendered images when I hardcode the target size in pixels in _picturePixelSize and do\n\nThat's good to know. Yeah, to me the results of CGContext.draw() seem perfectly fine, whatever interpolation algorithm they use by default is alright.. Check out a preheating demo (part of this repo), it works just as you would expect.\nAnd make sure that the Preheater is initialized with the same Manager that you use for loading images into your cells. This might be the reason why cached images aren't reused.. > Actually cached images are not always used for some reason. Apparently it depends on how many rows CollectionView has and how fast you scroll.\nMemory cache in Nuke uses up to 20% of available RAM. Bitmaps are large, you can't fit many of them in memory on iOS devices.\nPhotos app is a bit different. Photos app on iOS stores small thumbnails alongside original images on disk. When you scroll your photo gallery, Photos app loads those thumbnails synchronously from disk before loading fullsize images. That's how even when you scroll really fast there is always a thumbnail ready to be displayed.. There are many different strategies to load images in your app. It's really up to you. I would probably avoid anything too complicated though.\nAnyway, you may find this discussion useful (I assume you are loading images from the web, aren't you?):\n- https://github.com/kean/Nuke/issues/112 - swftvsn loads images from the web and has some custom code to store two copies of each image into the disk cache (original + thumbnail). You could adapt a similar strategy, but also add some custom code to read those thumbnails synchronously (like Photos app does).. Or you may simply try to increase memory cache size / load smaller images / resize images to make them take less space in the memory cache. It's really up to what your goals are.. It seem that it's easy to understand what it is from the context - an instance of URL class. If it's not, you would know as soon as you start using it. I would prefer to keep examples as short as possible.. The view gets captured by the closure in Nuke.loadImage(with:into:) method. It must be declared somewhere in the scope. You need to capture your cell in that closure:\nswift\ncell.image_indicator.isHidden = false\ncell.image_indicator.startAnimating()\nNuke.loadImage(with: request, into: cell.vehicle_image){ [weak cell] response, _ in\n    cell?.vehicle_image.image = response.value\n    cell?.image_indicator.stopAnimating()\n}. Could you provide some sample code please?. Hey, have you figured it out? The commented out code look perfectly fine to me. . Sorry, it seems that there are some problems specific to the environment in which this code is compiled. I can't really help you solve this, going to close this issue.. AnimatedImage.manager has a global memory cache. It stores only the first frame of each GIF + compressed data. Data gets decoded frame-by-frame on demand by Gifu when the GIF is displayed in an AnimatedImageView. I'm not entirely sure whether Gifu has any memory caches for decoded frames which might persist after the AnimatedImageView is deallocated.\nHere are a couple of tips to approach this:\n- Profile memory usage, you may find some unexpected leaks / other issues\n- Reduce memory usage. You might want to a) reduce GIFs size, b) reduce AnimageImage.manager cache size, c) clear shared AnimatedImage.manager cache when leaving the screen, d) create a separate Nuke.Manager per screen, Manager class is designed to be used this way if necessary.\nGIF playback itself is extremely demanding in terms on CPU and RAM. It's hard to get right and you need to be very careful when adding it in your app! Hope this helps.\n. In case you're using default Nuke.Manager:\nTo clear memory cache:\nswift\nNuke.Cache.shared.removeAll()\nTo clear disk cache:\nswift\nNuke.DataLoader.sharedUrlCache.removeAllCachedResponses()\nIn case you're using a custom image loading stack, it would depend on the implementation.\nIn case you'd like to automatically update the image in cache when it changes on a backed, I would recommend to use HTTP cache control. For more info see HTTP caching guide.. Sorry, I couldn't spend much time on this answer so it might be a bit confusing \ud83d\ude09 . > I think you need to add support for this as well\nCould you please elaborate? Is there some functionality that is missing?. Update: Nuke 5.1.1 provides access to the  shared URLCache (DataLoader.sharedUrlCache).. Nuke 5.x minimum deployment targets are:\niOS 9.0 / watchOS 2.0 / macOS 10.11 / tvOS 9.0. Hey!\nNuke doesn't have this built-in, but you can use existing features and build on top of them.\nIf you are relying on Foundation.URLCache for HTTP cache validation I'd suggest that you stick with it. AFAII there are no third-party networking+cache libraries that support cache validation out of the box. It certainly can be done, but it's really tedious plus it requires changes both on cache side and on networking side.\nIf you are using Foundation.URLCache you can take advantage of URLRequest.CachePolicy.returnCacheDataDontLoad to serve stale response first and validate the responses later if necessary.\n\nSpecifies that the existing cached data should be used to satisfy the request, regardless of its age or expiration date. If there is no existing data in the cache corresponding the request, the data is loaded from the originating source.\n\nSo I'd suggest that you send two separate requests: the first one that uses .returnCacheDataDontLoad, cache policy and then the second one that uses the default cache policy (you can learn more about image caching here). I don't want to get into too much detail about how you can manage those requests in terms of concurrency, how you cancel them, how to handle the results. You can either use Loading Images w/o Targets Nuke's API, or you can try to take advantage of this strategy for managing two requests. It's up to you.\nTo wrap up, I don't think that Nuke serves this particular use-case very well. I'd probably revisit it later to see what can be done to improve it. It looks like it should be very easy to implement using RxSwift. The direction that'd probably take: add reactive extensions to Nuke, document some of the common scenarios like yours.\nCheers.\n. I've just released an initial RxNuke version which provides a solution to this use case as well as for many-many more.. It's very early stage, if you have any fixes/suggestions/comments please let me know!\nFrom a quick glance the code from RxNuke readme does seem to do the trick:\n```swift\nlet cacheRequest = URLRequest(url: imageUrl, cachePolicy: .returnCacheDataDontLoad)\nlet networkRequest = URLRequest(url: imageUrl, cachePolicy: .useProtocolCachePolicy)\nObservable.concat(loader.loadImage(with: cacheRequest).orEmpty,\n                  loader.loadImage(with: networkRequest).orEmpty)\n    .observeOn(MainScheduler.instance)\n    .subscribe(onNext: { imageView.image = $0 })\n    .disposed(by: disposeBag)\n```\nThe requests are executed serially. The first request has a .returnCacheDataDontLoad cache policy so it only checks whether the image is in the disk cache. It doesn't do any networking. The second requests has a .useProtocolCachePolicy (which is a default URLRequest policy), it does the networking.\nThe only downside that I see is that if the second requests validates the image and the server returns 304 Not Modified Nuke would still retrieve the data from cache, decode it, and display the image (which we should've already retrieved with the first request).\n\nalthough the second one would not load the whole data\n\nCould you please elaborate?\n. P.S. I would also not recommend installing RxNuke if you don't already use RxSwift in your project. You can implement the same thing manually with just a bit of custom code.. @klop I think that existing locking inside a didSet is sufficient based on the fact that those two properties are simple value types (no reference counting involved). I can't say for sure because documentation on thread-safety either lacking or I'm just not able to find it anywhere.\nThis is the existing implementation:\n```swift\n/// The maximum total cost that the cache can hold.\npublic var costLimit: Int { didSet { lock.sync { trim() } } }\n/// The maximum number of items that the cache can hold.\npublic var countLimit: Int { didSet { lock.sync { trim() } } }\n```\nThe only problem that I see is that if for example you set costLimit with two different values simultaneously from two different threads then both trim calls might use the same value (the one which was set last). However, the last call is always guaranteed to use the latest value, which is good.\nI do have a testThreadSafety test (see CacheTests.swift file) which tests both of those properties. I can't say for sure how efficient it is, but it's good at catching simple threading issues. For example, if I change costLimit implementation to this (no lock): var costLimit: Int { didSet { trim() } } it would catch an exception pretty quickly (might require increasing the iterations count):\nMaybe it's better to change it to what you're suggesting just to be safe. It would be a little bit more verbose, but deterministic. What do you think?. Hey!\nNo, there are no transition settings. There are also no plans to add them, the idea is to keep framework and its API surface as small as possible and not introduce client-specific code. The default animations that are in use today might also be gone in Nuke 6.\nIn Nuke you can take advantage of loadImage(with:into:handler:) to implement any transitions that you might need.\nAnd RxNuke doesn't have any of the UI specific code. You manage the subscriptions and the way images are displayed yourself.. Hey! Sorry, really busy at work right now. My initial thoughts are that Nuke is not designed to support this. It's better If you just implement this aside without using Nuke infrastructure.. Strictly speaking you can:\n- use Processing protocol and any type that implements it without Request\n- use Cache without Request, but you'll need to provide your own cache keys\nI get what you mean tho, yes there is some room for improvement in terms of decoupling components. I might invest in this area some time in the future. If you have some specific ideas please let me know, I might implement them for Nuke 6.\nI'm personally a bit reluctant to change anything at this point. The core framework works great. It's simple, stable, performant and does just what I need in my apps. If I need something specific (for example, the case you've described in this issue) I just grab RxSwift and implement it. To be honest, RxSwift makes about 50% of Nuke code/features obsolete.. It doesn't support SVG and I haven't don't any research in this are yet.. It seems that CocoaPods specs repo on your machine isn't up to date. Please try running pod repo update before installing pods.. Hey! Nuke 5 isn't designed to support this. It's basically just for loading images from URLs. I'd suggest to implement this by hand. If you already use Nuke you might want to take advantage of some of its components, for example (shared) Nuke.Cache.\nI'm open to suggestions how Nuke can be improved to support more use-cases \ud83d\ude03 I've researched this area couple of months ago, but haven't found a good solution yet.. > So it is ok to directly manipulate Nuke.Cache.shared? Will it be also ok to create another shared Nuke.Manager with a new cache instance so I can easily clear it without affecting Nuke.Manager.shared?\nI've made Nuke.Cache.shared public for convenience. In general it's a good idea to configure your own manager with its own components.. Thanks!. FYI going to release a new version with minimum changes soon which supports both Xcode 8 & 9 and both Swift 3.2 & 4.. It seems that it is out of scope of Nuke. Have you tried looking for an answer on SO?. Update: Nuke 7 now features everything that you would expect from an image loading framework and more.\nHey! Sorry, I'm not in a position to compare Nuke with Kingfisher - I haven't used the later myself and I'm not that familiar with it. If you'd like to point out some things which are good/bad in Nuke, please do so \ud83d\ude03 . Please let me know if have any issues when using Nuke with Xcode 9 and Swift 4. I personally haven't migrated to new tools yet.. It looks to me that ThreadSanitizer is reporting a different kind of error. It seems to be unhappy with the fact that reads and writes to isFinished happen from two different threads (Main thread, and T2 thread in the report).\nI'm not yet sure whether it's a genuine problem or a false positive. So far new debug tools (e.g. Memory Debugger) has caused me hours of lost time due to false positives. It would be nice to get rid of those warnings anyway to not annoy people using Nuke with them (this warning is very easy to reproduce). I'm not sure how to go about fixing it yet.\n. I'm going to try to get rid of those warnings. I would appreciate some help. It would be nice to get rid of this Operation type altogether. All it does right now it limits a maximum number of concurrent tasks. There must be a simpler way to do that.. So I've added a custom TaskQueue which limits the number of concurrent tasks (that's all that is needed really). It took less code than NSOperation subclass, it's simpler, and it was much easier to get right than NSOperation subclass... Going to add some unit tests and include it in Nuke 6.. Hey! \n\nIf not, should cancelRequest just be a public static function?\n\nIt continued working fine because of to the implementation details (Manager uses associated objects under the hood). So, no, it should definitely be a Manager's method.\n\nSo, then I looked at Nuke.swift and noticed that cancelRequest is a top-level function just like loadImage\n\nI've added those top-level functions a while ago simply because I saw Alamofire do the same thing (I'm a bit older and a bit wiser now). There are a lot of reasons why this was a bad idea. If I ever get to release Nuke 6, I would definitely remove those, should've done this a while ago. There are almost 0 benefits in having them, and plenty of drawbacks.\n\nIs there a plan for Manager to do more here?\n\nThere have been a lot of plans for improving and extending Nuke, but I simple don't have enough time and motivation to do that right now. I do use Nuke, Nuke+Alamofire and RxNuke (but not other plugins) at my current job though. As soon as I need more features (e.g. progress reporting), I'll probably revisit it. For now, it's in maintenance mode unfortunately. I spend all my free time on Yalta and articles.. Removed in Nuke 6 (WIP).. Hey! Do those other image views load the image with the same URL? Are you using Nuke6-beta1?. That's weird, I think you might be miss-using some of the APIs. Can you please share a snippet of the code which start the image load?\n\nthe image in the new visible cell is the older one initially\n\nYou need to be clearing the view before setting a new URL:\nswift\ncell.imageView.image = nil\nManager.shared.loadImage(with: url, into: cell.imageView). Hey! Sorry for a late response. I've updated RxNuke in master branch. I'm going to release Nuke 6 and update the rest of the extensions soon.. Nuke 6 requires Swift 4, it seems that you might be using an older version. . Thanks, @willdahlberg! Totally missed that. Let me know if there are any other issues on macOS or issues in general.. Hey, @ultimate-deej!\n\nDoes this also mean that rapidly scrolling a table view with images will cause dozens requests to start and cancel? That's not what I want.\n\nI assume a different approach would be to not cancel requests which are already in progress? Is that what you have in mind? I've tried that as well, but I prefer the approach which is currently used in Nuke. There is a rate limiter built in - if you scroll really fast, there is only going to be a limited number of requests started each second (to avoid trashing the system).\n\nIs there an option to turn off this behavior?\n\nI have it in my backlog, it can be added as an option to image Loader.\n. I've spent some time thinking about this issue. For now, I'm not sure that this is a desirable feature. I think it makes perfect sense for Nuke to actually cancel the requests when you ask it to. Starting and cancelling requests too quickly can in fact trash URLSession to the point that it would just stop working correctly, but that problem is very well handled by RateLimiter built in Nuke. This solution is battle tested and it performs very well.\nIf you have a specific scenario in mind that you would like to implement, but which Nuke doens't support yet, please let me know.. Hey @ultimate-deej! \nI'm addressing the issue that you've raised in Nuke 7-beta1 with Resumable Downloads (Beta):\n\nIf the data task is terminated (either because of a failure or a cancellation) and the image was partially loaded, the next load will resume where it was left off. The resumable downloads are enabled by default.\n\nI think this is a perfect solution for the majority of use cases. There are virtually no reasons not to enable it.\nTurning off cancellation on the other hand doesn't work for all apps, but it may still be useful in some. I'll continue researching this area as well.. Hey,\nI'll try to document all of those features as nicely as possible in the future.\n1, 2, 3 By default images are stored on disk using NSURLCache. The cache is controlled by HTTP headers. See more https://kean.github.io/post/image-caching\nIf you want to control disk cache from the client see https://github.com/kean/Nuke/blob/master/Documentation/Guides/Third%20Party%20Libraries.md#using-other-caching-libraries\n4 Yes, this is memory cache only, it stores processed images which are ready for display.\n5 In memory - yes. On disk - depending on HTTP cache control headers. See more See more https://kean.github.io/post/image-caching\n. Hey!\nAFAIK what NSExceptionAllowsInsecureHTTPLoads does is allows you to use http:// requests (by default only https is allowed), it doesn't disable SSL certificate evaluation. If you're using Alamofire for loading data, it seems to have a ServerTrustPolicy which allows you to configure that.. Hey!\nBy \"captured image\" do you mean images taken using the camera? If that's the case then one way to achieve that is to simply store those images in some predefined folder on disk and then fetch them using Nuke.Manager:\nswift\nNuke.Manager.shared.loadImage(with: URL(\"file://path_to_image\")) { result in\n   // Handle result\n}\n\nURLSession which is used under the hood is capable of loading images from disk.\n\n. > [[SDImageCache sharedImageCache] storeImage:image forKey:imageKey] toDisk:YES];\nThere is no dedicated custom disk cache in Nuke, it relies on native Foundation.URLCache instead. The shared cache can be accessed like this: Nuke.DataLoader.sharedURLCache. However, it doesn't have a dedicated API for storing images, you'll have to write a few lines of code yourself.\nKeep in mind that the cache contents can get cleared automatically when it exceeds a certain limit. So it's good for \"caching\" images, but I wouldn't rely on it for persistent storage.\nLike I mentioned in a previous message an alternative to using \"cache\" would be to actually store data on disk, it's pretty straightforward.\n```swift\n// Create image data.\nlet data = UIImageJPEGRepresentation(image, 0.8)\n// Create URL for key.\nlet key = \"ImageKey\"\nlet url = URL(fileURLWithPath: \"path/(key).jpeg\")\n// Write data to disk. Make sure that the directory exists!\ntry data?.write(to: url)\n// Remove data form disk.\ntry FileManager.default.removeItem(at: url)\n```. It's memory cache only.. > let cachedResponse = NSURLCache.sharedURLCache().cachedResponseForRequest(imageRequest)\nI hope it helps.\nThis is true in case you're using a custom DataLoader with NSURLCache.sharedURLCache. However, if you're using Nuke with default configuration here's how you can do that:\n```swift\nlet request = Request(url: \"image_url\")\nif Nuke.Cache.shared[request] != nil {\n    // Image is in memory cache\n} \n// I'd recommend to check Foundation.URLCache documentation before using this.\nif Nuke.DataLoader.sharedUrlCache.cachedResponseForRequest(request.urlRequest) != nil {\n    // Image is in disk cache\n}\n```\nIn general I'd recommend to avoid checking manually if the image is in cache or not - it might not actually be there by the time you make a request. It's ok however, to retrieve image synchronously from memory cache (see Nuke.Cache.shared) without making any requests.. Hey @jtressle,\nI think it has to do with HTTP cache control. I have a starter guide available here with some useful links at the end.\nI don't know exactly what kind of cache control headers are set by Google Storage, but my guess is that  HTTP cache tries to validate that the image in cache is not staled before serving it. This is why it can't serve images offline - can't validate them. There are at least two ways to disable validation:\n- [on a server] Adjust HTTP cache control headers returned by the server to indicate that those resources do not require validation\n- [on a client] Use .returnCacheDataElseLoad option which you already do. This option disables cache validation. Even if the image is \"stale\", it's still going to be served immediately.\nI'm going to close this, if you have any other questions please let me know.. Hey @j-pk, please update to the latest versions.\n\nNuke 6.1 has been updated to Xcode 9.3 a while ago.\nNuke-Gifu-Plugin 3.0 I released just yesterday. Please follow the migration steps from the release notes (there aren't many).\n\nI've fixed the problems by getting rid of both Lock and AnimatedImage class to avoid potential issues in the future.. Hey! Yes, sure, I can definitely lower the deployment target. Please create a PR, I'll merge it and push a new version some time soon.. Pushed 6.1.1 with this fix. There was also disk cache path fix for macOS in 6.1 (#146). Please let me know if you find any issues or missing components on macOS. \ud83d\ude09. Hey, @CWalig! Thanks for the report. I haven't updated to 10.13.4 yet, I'm planning to during this weekend. Which version of Nuke, Xcode, Swift, Platform are you using?. Hey @CWalig!\n2018-04-18 19:00:11.704761+1200 xx[31595:3383983] Task <E20CE7FE-DE34-42DD-96B9-4ED496BC4514>.<78> finished with error - code: -999\nThis error is trivial, it's just a cancellation of a task. When you call loadImage(with:into:) in a loop (not a valid use case) in 5.2 some of the requests (not all) manage to be resumed and then cancelled.\n2018-04-18 19:00:11.675594+1200 xx[31595:3383774] Task <66C9A459-E677-418A-BD3A-6E9D15DA0130>.<124> HTTP load failed (error code: 100 [1:100])\n2018-04-18 19:00:11.675671+1200 xx[31595:3383772] Task <66C9A459-E677-418A-BD3A-6E9D15DA0130>.<124> finished with error - code: 100\nThis one though is interesting. The code 100 is a \"Protocol Error\". I was not able to reproduce this particular error on my machine (still running 10.3.3) but I sometimes receive the following error messages instead:\n2018-04-22 12:39:44.345907+0200 NukeErrorMessage[8494:378626] [BoringSSL] Function boringssl_session_errorlog: line 2871 [boringssl_session_read] SSL_ERROR_ZERO_RETURN(6): operation failed because the connection was cleanly shut down with a close_notify alert\nIt might be something to do with outdated / misconfigured SSL. I'm not sure I'm going to be able to help debugging this. I'm almost certain that's not something that Nuke does that triggers it because it uses high-level APIs in the simplest way possible. I'm going to close this, if you find a solution please post it here.. I see, I was also surprised that on macOS URLSession seems to send those logs automatically. Those logs aren't coming from the project, they are coming from URLSession itself.. Hey, @TML007. I've reopened https://github.com/kean/Nuke/issues/49, planning to add (progressive) WebP in a point release.. Hey, @sunjunkie! The current README in master is already showing 7.0-beta3 APIs (latest published version). Please open the 6.1.1 tag to see the README for version 6.1.1.\nP.S. Nuke 7 does have new global functions (e.g. loadImage(with:options:into:progress:completion:)) some of which look very similar to the functions that were deprecated in Nuke 6.x, those are not the same functions though! Sorry, if it sounds a bit confusing.  Nuke 7 has more new features and changes than all of the previous versions combined. I went out of my way to make it fully source compatible with Nuke 6.1.1, so there is no need to worry about migrating to the not soon-to-be-latest version.. Hey @AndrewBarba. Yes, you do need to use one of the cryptographic hash functions which guarantee that the probability of two URLs having the same hash value (which is used as a filename) is so low that you can ignore it. sha1 is a good candidate.\nThe hashValue uses a different kind of hash function which is designed to be extremely fast (much faster than cryptographic hash functions) but doesn't give many guarantees in terms of collisions. These types of hash functions are designed to be used primarily by hash tables in which keys are eventually tested for equality. If you were to use hashValue as a filename you are guaranteed to encounter a situation where you produce the same filename for two different URLs.\nAnother alternative that I've explored is percent encoding URLs to produce valid filenames. The problem with that approach is that filenames have size limits. The maximum filename size on HFS+ is 255 characters and I'm not yet sure what the limit is on APFS.. There is another option, if you know that you can extract some ID from a URL which uniquely identifies an image and can be used as a filename (or you can percent encode it if necessary), you can use it as a filename.. Yep, this is perfect. I\u2019m going to provide a sensible default in one of the upcoming versions.. It would be nice to add a default hash function to the project. The SHA256 from the SPM project takes almost a whole second to compile. And I haven't tested how fast it is.\n700.40ms    Nuke/Sources/Internal.swift:655:18  private final func process(_ block: ArraySlice<UInt8>)\n176.70ms    Nuke/Sources/Internal.swift:622:17  public final func digest() -> [UInt8]. I'm not really expecting any differences in perceived performance, but I prefer to use the fastest stuff available anyway \ud83d\ude03 The compile time is a real concern though. I wouldn't want users to measure compile time at some point and find out that there are some Nuke's functions at the top (700 ms for a single function is a lot).. Swift 4.2 finally seems to come with CommonCrypto https://twitter.com/mxcl/status/1003789764884140038. Just in time.. I've implemented a default FilenameGenerator which uses SHA1. It's going to ship in v7.3 and is going to be available in Swift 4.2.. Hey, thanks a lot for the PR! Looks like I forgot to add contentModes when copying the macOS version which doesn't support it.. Hey, @jeromescheer, I've published v7.0.1 with this fix and some other changes. If you see any other issues or if you find that there's something that was easy/possible in SDWebImage but isn't in Nuke, please open an issue or send me an email or DM on Twitter. Contributions are welcome \ud83d\ude09. Hey! Thanks, I didn't know that, I'm going to stick with the required format from now on. Fortunately there is a workaround, and 7.0 is also already out.. Hey, @vmartinelli \nYou're exactly right, one of the goals for Nuke 7 is to bring custom disk caching support. I was planning it for Nuke 7.2. I'll see what I can do to make roadmap public - I'm currently managing it in a private Trello board.\nThis seems like a great start. I'm almost 100% certain at this point that the API should be asynchronous and it should return Cancellable (but maybe optional? or we could add Cancellable.noOp?).\nI'm not yet sure whether to pass any context when storing the responses, haven't come up with any use cases yet. This API (DataCaching) is designed for implementing aggressive caching (no HTTP validation needed) which means that we probably don't need to pass URLResponses. There are already ways to implement those types of sophisticated custom caches either via Nuke.DataLoading protocol, or Foundation.URLProtocol.\nI think I can merge this in a way it is and then continue refining it before the released - add tests, documentation, etc.\nDon't mind flaky preheater test, I'm currently working on them in master.\n. Thanks for updating the PR. I've merged it, but please keep in mind that I'll might change the API a little bit.. Hey!\nThe Result type in was deprecated in Nuke 7.0 and I'm planning to remove it completely fairly soon.\nThere are ways to solve the conflict. The conflict only appears in the files in which you import both Nuke and Result at the same time - Swift compiler doesn't know which one to use. To disambiguate, you can explicitly select the module (e.g. Nuke.Result or Result.Result). I know this is not ideal, this is the primary reason why this type is now deprecated.. @edon2005, Result was removed in Nuke 7.5.. TIL you can also do import Result.Result - importing specific declarations from frameworks take precedence.. It only works with native HTTP cache (URLCache).\nThese two caches (native HTTP cache and aggressive disk cache) should be mutually exclusive. If you enable experimental aggressive cache you should also disable native URLCache. In order to do that you to need to create custom ImagePipeline with custom DataLoader. After your create a custom ImagePipeline you can set it as a shared one:\nswift\nImagePipeline.shared = ImagePipeline {\n    $0.dataLoader = DataLoader(configuration: {\n        let configuration = URLSessionConfiguration.default\n        configuration.urlCache = nil\n        return configuration\n    }())\n}\nThe public API for aggressive disk cache (including API for adding and removing items form cache) is going to be available in Nuke 7.2. This version will also contain a protocol which can be used to implement custom disk caches. I'm planning to release Nuke 7.2 in the end of June. The API is actually almost complete, but there is a lot of related work which need to be done including updating documentation, README, sample project and more importantly tests.\nFor now there is no programmatic access to DataCache, the only available API is enableExperimentalAggressiveDiskCaching.\n. If you enable both native HTTP cache and custom aggressive disk cache at the same time, you'll end up storing data in both caches at the same time.. Yes, it's safe to use more than one ImagePipeline at once, it was specifically designed to work like that.\nYou can even use the same configuration  between pipelines to make sure that the only difference between them is cache, and all the other settings are the same, including operation queue (e.g. dataLoadingQueue). This way you can ensure that both pipelines share the same task pools (e.g. they won't perform more than 6 data load operations at the same time).. Hey,\nI personally use RxNuke for those kinds of tasks.\nIn case you're using native URLCache here's one way to do it:\n```swift\nlet cacheRequest = URLRequest(url:\n    URL(string: \"...?width=200&height=200\")!,\n    cachePolicy: .returnCacheDataDontLoad\n)\nlet networkRequest = URLRequest(\n    URL(string: \"...?width=100&height=100\")!,\n    cachePolicy: .useProtocolCachePolicy\n)\nObservable.concat(pipeline.loadImage(with: cacheRequest).asObservable(),\n                  pipeline.loadImage(with: networkRequest).asObservable())\n    .take(1)\n    .subscribe(onNext: { (response, error) in\n        // Use an image\n    }).disposed(by: disposeBag)\n```\nThis would run two requests serially. If the first one succeeded, the second one will not run.\nThe reason why this functionality isn't built in Nuke is that everyone's use cases are slightly different and  RxSwift (or any other reactive or promise library) already solves those kinds of problems in a very elegant way. With RxSwift you can do all sort of things. I've provided a couple more of examples in README for RxNuke.\nBut, if you're not using RxSwift already I probably wouldn't recommend installing it just to use RxNuke. RxSwift is really powerful, but if you need to implement just a single scenario like that I would recommend implementing it by hand.. Hi,\n\nhowever we're noticing some performance issues on large collection views\n\nNuke is faster on the main thread than Kingfisher but I would definitely recommend profiling your app first to make sure what the cause of the performance issues actually is.\nThere is an ImagePreheater type in Nuke which is designed to be used in table and collection views to prefetch images which are expected to appear on the display soon. It's designed to be used on fast internet to make sure the user never sees any loading indicators or empty image views. That's how I personally use it and I imagine this use case is very different from the one that you have.\nI haven't extended ImagePreheater functionality much from the day it was introduced. There is definitely room for adding more features to it - PRs are welcome.\nBut in your specific use case I would recommend implementing this by hand. There isn't much preheater does for you anyway. It can be as simple as this:\n```swift\nfunc startPrefetchingImages(for urls: [URL]) {\n    func prefetchImage(for request: ImageRequest) {\n        ImagePipeline.shared.loadImage(with: request) { (response, error) in\n            if response == nil {\n                // Retry after 10 seconds\n                DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(10)) {\n                    prefetchImage(for: request)\n                }\n            }\n        }\n    }\nfor url in urls {\n    var request = ImageRequest(url: url)\n    request.priority = .low // Lower than regular requests\n\n    prefetchImage(for: request)\n}\n\n}\n```\nThe retry logic can be as complex as you'd like it to be. I personally use RxNuke with smart retries.. Hi,\n\nI gather this might be related to the decodingQueue?\n\nIt might be it. But it's more likely that the problem is background decompression (see ImageDecompressor), not decoding (Data -> Image). I suggest taking a look at ImageTaskMetrics to debug performance issues.\nIf you load lots of images ahead of time I would recommend disabling some of the pipeline steps. Here's what you can do using existing APIs:\nswift\nvar request = ImageRequest(url: url)\nrequest.processor = nil // Don't decompress the image\nrequest.memoryCacheOptions.isWriteAllowed = false // Disable mem cache (optional)\nThe image is still going to be decoded (Data -> Image, quick) but it's not going to be decompressed (slow). The \"deduplication\" is smart enough so that it won't download the same image twice if you then start a request with the same URL but with memory cache enabled & processor enabled.\n\nAlternatively; is there a way to prioritise things in the decoding que so I can just bump item the user is trying to view at the specific moment to the front of the que?\n\nI have a couple of ideas in backlog regarding improving prefetching.\nFirst, there needs to be an API to skip decoding. I was thinking adding something semantic like func prefetchImage(.inDiskCache | .inMemoryCache) to ImagePipeline itself. This needs to be a separate API because if you skip decoding, no image is produced - can't complete with \"success\" ImageResponse.\nSecond, the decoding & processing queues should respect the request priorities - at the moment only data loading queue does.\n. So all the time is spent waiting in a decoding queue. That's weird, it's not normal for decoding to take so long (0.671 seconds). Are you loading WebP images? This might explain why it takes so long. If so, I could create a patch today that would make decoding & processing queues respect requests' priorities - this would fix your issue.\nThis would require switching from DispatchQueue to OperationQueue for decoding queue. I can make if configurable via ImagePipeline.Configuration so that you could play with maximum concurrent task count.. > presumably then I could just re-call the loadImage with a request priority of .veryHigh in order for it to jump to the top of the que?\nThat's correct.. > 1. I make the non-transparent images into JPG's on the server assuming they'll be decoded much quicker from the cache.\nThe reason why JPEG \"decoding\" (Data -> UIImage) is fast is that UIImage doesn't actually decompress the data until it needs to. The reason why ImageDecompressor  exists is to force decompression in a background. If you don't, the decompression is going to happen on the main thread when you display the image which would result in dropped frames.\nSo for JPEG most of the work happens in ImageDecompressor, not ImageDecoder. If you switch to JPEG you might end up just moving the work from \"decoding\" stage to \"processing\" stage.\nI don't have much recent experience with WebP, but my guess is that it eagerly decompresses the data. This is why decoding takes so long.\n\n\ndecoding - creating UIImage from Data\ndecompression - forcing UIImage to render its contents in ImageDecompressor, this happens during the \"processing\" stage\n\n\nI would wait for a patch and see if it improves the situation.\n. Pushed a new version with these changes. It works well but there is some technical debt which I'm going to address in 7.2.1. Hope that helps, please close the issue if it does and create a new one if you find some other issues.. hey @AssyriaGameStudio, I've addressed tech debt introduced in version 7.1 and 7.2 and also made some improvements in the way operations are schedules, reused, canceled, and how priorities are updated. Now it should be pretty much perfect. If you spot any other performance issues, please let me know.. Hey,\nYes, if you're using default DataLoader with a default native URLCache then the server that you're using need to enable HTTP cache.\nAs an alternative to HTTP cache, I'm currently working on bringing custom aggressive disk cache in Nuke. There is already an experimental version available, but it's going to get a lot better soon - there is going to be a full-featured public API, default key encoder implementation, etc.\nI hope that this helps. If you'd like to learn more about HTTP, there plenty of information online. My personal favorite resource about web technologies is MDN.\nI'm sorry if this is all a bit overwhelming. I hope to do a better job explaining those things in README and related guides.. By default this URLCache instance is going to be used:\nswift\n// Shared url cached used by a default `DataLoader`. The cache is\n/// initialized with 0 MB memory capacity and 150 MB disk capacity.\npublic static let sharedUrlCache = URLCache(\n    memoryCapacity: 0,\n    diskCapacity: 150 * 1024 * 1024, // 150 MB\n    diskPath: cachePath\n)\nAnd URLCache uses HTTP cache control. So if the server enables it by setting Cache-Control header, the image data is going to be stored in URLCache.\nI've written a post about this a couple of years ago that goes in a bit more detail. It should still be relevant today.. Good question, I think it would be valuable to put a high-level overview of what the default image pipeline looks like and what does it do in the README.  I'm going to add it soon.\nIf you were to put the pipeline configuration in one place it would look something like this:\n``swift\nlet pipeline = ImagePipeline {\n    // Shared image cache with asizeLimit` equal to ~20% of available RAM.\n    $0.imageCache = ImageCache.shared\n// Data loader with a `URLSessionConfiguration.default` but with a\n// custom shared URLCache instance:\n//\n// public static let sharedUrlCache = URLCache(\n//     memoryCapacity: 0,\n//     diskCapacity: 150 * 1024 * 1024, // 150 MB\n//     diskPath: \"com.github.kean.Nuke.Cache\"\n//  )\n$0.dataLoader = DataLoader()\n\n// Maximum number of concurrent data task set to `6`.\n$0.dataLoadingQueue.maxConcurrentOperationCount = 6\n\n$0.imageDecodingQueue.maxConcurrentOperationCount = 1\n$0.imageProcessingQueue.maxConcurrentOperationCount = 2\n\n// Combine the requests for same original image into one.\n$0.isDeduplicationEnabled = true\n\n// Progressive decoding is disabled by default.\n$0.isProgressiveDecodingEnabled = false\n\n// Custom disk cache is disabled by default, the native URL cache used\n// by a `DataLoader` is used instead.\n$0.dataCache = nil\n\n}\n```\n\nOr if it is possible it will store an image and in Memory and on Disk?\n\nYes, by default there is both a memory cache and a disk cache enabled (those are two separate things, see code sample above).\n\nThat is batch of images should be loaded before UIimageView change status to unhidden, is it possible with Nuke?\n\nYou'll need to write the logic of starting those requests and waiting for their completion by hand. It might be something worth putting into ImagePreheater though. And if you're using RxSwift you can implement this using combineLatest (see RxNuke for examples) and (optionally) smart-retries.. Hey, @edon2005. I've added two sections in README: \"Default Image Pipeline\" and \"Image Pipeline Overview\". I hope that you'll find it useful.. Thanks, I really appreciate fixes in docs / guides!. Thanks!. Hey, @s4x. Yeah, you're right, sorry about that!\nThe custom disk cache is still an experimental feature in Nuke 7.2. I'm glad that so many people are interested in it. I'm currently working on finishing it and making it public in 7.3 which I plan to release some time later this week. I'm going to address this issue as well.\nThe new DataCache is going to be much simpler and even faster than the one in 7.2 \ud83d\ude0e\n. It seems to be a regression introduced in one of the later versions. As a workaround I would recommend downgrading to 7.0.1. I hope to release 7.3 soon.. Hey, @s4x. I've decided to push back some features which were initially in scope for version 7.3 and focus on getting DataCache right first, which I hopefully did. Please give the new version a try.. Hey, you shouldn't need to know when the IO is finished. If you ask cache to remove data for a key, and then immediately try to read data for this key, you'll get nil in response:\nswift\ncache.removeData(for: key)\nlet data = cache.cachedData(for: key)\n// Data is guaranteed to be `nil` at this point.. The only issue that I can see with this case has to do with deduplication (see ImagePipeline.Configuration.isDeduplicationEnabled) - other libraries have this issue as well. With deduplication enabled - which it is by default - there is no guarantee that when you request a new image, your request won't be handled by an already executing task.\nYou could disable deduplication all together, but this feature is crucial for prefetching. I had this in mind for a while now, but haven't yet come up with a final solution yet.\nIt might not be an issue at all depending on when and how you request these images. But please keep this in mind when removing images from cache manually.. > the last image in a cell will be the last dowloaded or the last requested?\nAlways the last requested. And all the previous tasks for the given cell are going to get cancelled.. > String(djb2Hash32(string: name))\nThis seems to be the problem. The FilenameGenerator function should provide a valid filename for a given URL. Naturally each URL should have a unique file name. A cryptographic hash functions like MD5 or SHA1 are usually a good choice and are in fact what most caches use. djb2 is not a cryptographic hash function. With djb2 some URLs will end up having the same filename generated for them which would result in a mix-up like that.\nNuke 7.3 ships with a default FilenameGenerator implementation which uses SHA1 but it's only available in Swift 4.2.. swift\nguard let currentImage = v.image else {\n      Nuke.loadImage(with: req, into: v, completion: cb)\n      return\n}\nPlease take a look at isPrepareForReuseEnabled option, I think you could replace this code with it.. That's just weird. ImageView.loadImage should be solid. If you could build a short demo, I'd be happy to dig into it.. Might be something related to the way UITableViewDelegate is implemented?. I'm going to investigate this soon, seems really weird \ud83d\ude14. Hey, if you could send me a sample project, please do. And please also let me know which version you're using.\n\n$0.isDeduplicationEnabled = true\n\nThe default value is true, I think you meant false?. Hey @cwestMobile, did you manage to figure out what the issue was?. Hi @swftvsn,\n\nI don't have any \"into\" target to give to Nuke.\n\nYou can use ImagePipeline directly to load images without a need for a target.\n\nHow can I use Nuke to give the Data of the image and if it isn't in the cache to download it, apply it to cache and then return it to me.\n\nThere are multiple built-in options:\n\nThe default ImagePipeline comes with URLCache (native HTTP cache)\nIf you're not happy with URLCache you can use a custom aggressive disk cache (also built-in)\nYou can also integrate any custom disk cache that you'd like pretty easily. > I've used DFCache previously to cache images in different sizes. Is there any need to use DFCache anymore, or is the built-in way better?\n\nNuke.DataCache is faster - it allows for parallel reads and it also writes in parallel with reads thanks to the special staging area. And you don't need an extra dependency. It's pretty cool, I don't think there are any faster disk caching solutions available at the moment.\n\nThe more I play with 7 the more I like it!\n\nThanks!\n. Hi! \nThis particular code sample can be replaced with:\nswift\nfunc loadPhoto() {\n    guard let photoURL = user?.photoURL, let url = URL(string: photoURL) else { return }\n    ImagePipeline.shared.loadImage(with: url) { response, _ in\n        self.avatar.photo = response?.image\n    }\n}\nThe main changes here are:\n\nA Manager, Loader classes with vague responsibilities and unnecessary protocols (Loading) were replaced with a single ImagePipeline class.\nThe completion closure now gives you ImageResponse and Error\n\nYeah, there are quite a few changes in Nuke 7 but they had to be made to add all these new features and overall just make the framework more pragmatic - all the versions before 7 were kinda experimental.. Yeah, I haven't touched ImagePreheater in a while, it's entirely possible that it makes some assumptions that are no longer true in 7.. I was able to reproduce it, seems to be a false positive triggered by one of the performance optimizations. Fixed in 7.3.2.. Hey! The deprecation warning appear to be wrong. The Nuke.Target / ImageTarget protocols were replaced by a more flexible ImageDisplaying protocol:\n```swift\nif !os(watchOS)\n/// Displays images. Adopt this protocol in views to make them compatible with\n/// Nuke APIs.\n///\n/// The protocol is defined as @objc to enable users to override its methods\n/// in extensions (e.g. you can override display(image:) in UIImageView subclass).\n@objc public protocol ImageDisplaying {\n    @objc func display(image: Image?)\n}\n/// A UIView that implements ImageDisplaying protocol.\npublic typealias ImageDisplayingView = UIView & ImageDisplaying\nextension UIImageView: ImageDisplaying {\n    /// Displays an image.\n    open func display(image: Image?) {\n        self.image = image\n    }\n}\n```. Hey! I suggest looking into HTTP cache. If you're downloading images directly from FB, chances are it already supports it. There is plenty of information online, you can start with this guide written specifically for Nuke http://kean.github.io/post/image-caching. Hi, there is no elegant way to do this at the moment.. Yeah, this is one way to achieve this.\n\nLooking at the roadmap, there's something coming related to thumbnail caching. \n\nThere is lots of stuff in the backlog, I wouldn't hold my breath on these features though, I'm super busy at work right now :(. Sorry, missed this question. \n\nHow can i set authorization header?\n\nOne way to pass an authorization header is to create it a URLRequest with it.\n\nWill my caching still work if my authorization header keep changing on each request?\n\nYes, memory cache will still work, custom disk cache will still work. I would check the native disk cache though (URLCache), I can't remember exactly how it handles auth headers.. Hey! I've just tested it and it works fine for me. It might be that you've already downloaded this image before and it's not being loaded from the disk cache. In that case you don't get progress reports, the block is only going to get called once.. DataLoader.sharedUrlCache.removeAllCachedResponses()\nAFAIU this would not remove the cached result instantly. It also doesn't seem to make much sense to clear the caches before loading the image. If you don't want caching, disable it.\n\nshould it not load instantly (I'm still having to wait for it to appear)?\n\nNo, this is a pretty large image, it takes a little bit of time to read it from disk and to decompress it (see ImageDecompressor). It won't appear instantly unless it's stored in memory cache (ImageCache).. Glad that you found the issue. I'd recommend using Charles for network debugging \ud83d\ude09. Hey! That's an interesting question. I think this might just work. Technically both DFCache and Nuke.DataCache work with the same simple plain hierarchy of files on disk.\nAll you need to do is make sure that you use the same function to generate filenames from URLs. DFCache uses SHA1. Nuke.DataCache also uses SHA1 by default but this feature is only available on Swift 4.2. To make sure that the caches are compatible you need to create Nuke.DataCache with the same hashing function as the default DFCache one:\nswift\nlet cache = DFCache(name: \"thumbnails\", memoryCache: nil)\ndataCache = try! DataCache(name: \"thumbnails\", filenameGenerator: {\n    return sha1_same_as_dfcache($0)\n})\nPlease make sure to test it cause I might be missing something.\n. DFCache has NSCoding support out of the box (CachedURLResponse implements NSCoding). DataCache doesn't, it only knows how to work with raw data. It should be fairly straightforward to extend it with NSCoding support.. Hey, did you finish migrating to Nuke 7 successfully?. Ok, going to close this for now. If you have more questions or issues, please feel free to open another issue.\nDFCache is not going away any time soon. Also, it seems that you might've been using DFCache as a storage option (you can't just throw it away). I personally would not recommend relying on anything provided in Nuke caching layer, or DFCache, as a permanent persistent storage solution.. @jtressle thanks for putting this together, yes this looks good. I would also recommend reducing the priority of preheating requests:\nswift\nvar request = ImageRequest(url: url)\nrequest.priority = .low\nreturn \nI have a ticket to add native prefetching in a demo project https://trello.com/c/mdFGmp6F/26-add-prefetching-demo-which-uses-native-prefetching-apis. If someone would like to add it, I would much appreciate it.. I've updated the demo to use UICollectionViewDataSourcePrefetching on iOS 10 (Nuke still supports iOS 9, so I'm keeping Preheat demo around for now.. > Note that the total data remaining passed to the progress handler is now the value remaining of the download, not the total value of the image. \nYep, that's seems to be how it works right not, but it's not by design.\nI think there are two reasonable options that can be implemented instead:\n\nReport the progress of the remaining chunk.\nReport the progress of the entire download.\n\nI'm not sure which would to make a default one though. I'd say I would expect a second one. What are your thoughts?. Nuke total progress value uses expectedContentLength of the response which is derived from the HTTP Content-Length header of the response.\nI've performed some tests just to make sure that the Content-Length of the Partial (206) responses report not the total length of the file, but rather the length of the remaining chunk that is being requested:\n```\n~> curl https://cloud.githubusercontent.com/assets/1567433/9781817/ecb16e82-57a0-11e5-9b43-6b4f52659997.jpg\nHTTP/1.1 200 OK\nLast-Modified: Thu, 10 Sep 2015 06:47:19 GMT\nETag: \"ee2fa107a9618d19df8d37dd0e40d2fa\"\nCache-Control: max-age=31557600\nContent-Type: image/jpeg\nContent-Length: 31038\n~> curl -i -H \"Range: bytes=15000-\" https://cloud.githubusercontent.com/assets/1567433/9781817/ecb16e82-57a0-11e5-9b43-6b4f52659997.jpg\nHTTP/1.1 206 Partial Content\nLast-Modified: Thu, 10 Sep 2015 06:47:19 GMT\nETag: \"ee2fa107a9618d19df8d37dd0e40d2fa\"\nCache-Control: max-age=31557600\nContent-Type: image/jpeg\nAccept-Ranges: bytes\nAge: 478813\nContent-Range: bytes 15000-31037/31038\nContent-Length: 16038\n```\nSo it seems that what I need to do is just add the length of the data that has already been downloaded to the expectedContentLength of the partial response and that's it.. Fixed in https://github.com/kean/Nuke/commit/91cde7666f7d61585357d27880da7aba74e71072. Haven't though this through :/. Published a fix which disables this new feature temporarily. The story is that is was added last moment before the release and wasn't though through. You can't call stopPreheating in deinit of ImagePreheater because it calls an escaping closure which tries to retain self. . Thanks, @nanoxd!. Hey, spot on! Thanks a lot for the investigation and for the fix.\nThe issue is extremely hard to reproduce. In this scenario the outstanding request still gets canceled but because cancellation is asynchronous in ImagePipeline there is a small window where it still might call a completion handler for a canceled task.\nI've written a test spec that describes this behavior. Sure enough, it's red and with your fix it becomes green.\n```swift\nfunc testDisplayedCachedImageWhenThereIsPendingRequest() {\n    mockPipeline.queue.isSuspended = true\nlet requestA = ImageRequest(url: URL(string: \"test://imageA\")!)\nlet requestB = ImageRequest(url: URL(string: \"test://imageB\")!)\n\n// Given pipeline with cancellation disabled (important!)\nmockPipeline.isCancellationEnabled = false\n\n// Given an image A not stored in cache and image B - stored.\nlet imageB = Image()\nmockCache[requestB] = imageB\n\n// Given an image view which is in the process of loading the image A.\nNuke.loadImage(with: requestA, into: imageView) { _, _ in\n    // Expect completion to never get called, we're already displaying\n    // the image B by that point.\n    XCTFail(\"Enexpected completion for requestA\")\n}\n\n// When starting a starting a new request for the image B.\nNuke.loadImage(with: requestB, into: imageView)\n\n// Expect an image B to be displayed immediatelly.\nXCTAssertEqual(imageB, imageView.image)\n\n// When the pipeline finishes loading the image B.\nexpectNotification(MockImagePipeline.DidFinishTask)\nmockPipeline.queue.isSuspended = false\nwait()\n\n// Expect an image view to still be displaying the image B.\nXCTAssertEqual(imageB, imageView.image)\n\n}\n```\nI'm going to add this test - and maybe a few more - once it's merged.. > Sidebar, why not use UUID as taskId, instead of incrementing?\nI tried but decided to go with incrementing Int for performance reasons AFAIR. UUID would not have helped prevent this issue, I could still forget to reset it.. @michaelnisi I was adding more tests and found a similar scenario with the same issue. Calling Nuke.cancelRequest(for:) method also had the same flaw, I fixed it.. > So, in that case, Nuke.cancelRequest(for:) would cancel the wrong request?\nIt would cancel the correct request, but it would reset request identifier managed by the ImageView. In these rare cases when canceling the task which is \"almost\" completed, the view it would still display an image.. Thanks, @Nicholas714! I would also add a more details explanation in a Performance Guide.. Hey, @shahzaibiqbal. Existing DataLoader is designed to be a simple solution for most basic cases. If you need some more advanced features like SSL pinning, you have at least two options:\n\nUse Nuke with Alamofire\nImplement your own custom loader and make it conform to DataLoading protocol. Thanks, @freemansion!\n\nI forgot to mention, there also an entry in Third Party Libraries Guide about implementing custom data loaders.\nIt seems that SSL pinning is a frequently requested feature, I'm going to add it to backlog and see whether it feasible to make the build-in data loader to support it without making it to complex. The idea behind DataLoading protocol was that there is a very good chance that if someone need a relatively complex feature like that, they probably already have their own custom data layer anyway. Or they are using Alamofire.. Hey, @drkibitz. I'm not sure what the original motivation behind preventing upscaling was. It's clear why you would want to downscale the images, especially if the source images are much bigger then the target size and you have no control over the source. It's not clear to me what the upsides or downsides of upscaling are. Would you say that upscaling should be enabled by default? If there is a valid argument why, the default can be changed in the next major version.. Closing, merged the original version https://github.com/kean/Nuke/pull/193. Closing, merged the original version https://github.com/kean/Nuke/pull/193. Hey, @mb812. You can set a custom cacheKey (Hashable) for each ImageRequest. I also have an issue in backlog to add a first-class API to support these types of URLs.. Hey, @drkibitz! Thanks, I think it makes sense to add a convenience initializer like that.\nI would suggest making this init generic to hide AnyImageProcessor (it exists because of the Swift limitations):\nswift\npublic init<Processor: ImageProcessing>(urlRequest: URLRequest, processor: Processor) {\n        self = ImageRequest(urlRequest: urlRequest)\n        self.processor = AnyImageProcessor(processor)\n }\n. // Convenience initializers with custom processer. The reason\n// why those are implemented as separate init methods is to take advantage\n// of memorized `decompressor` when custom parameters are not needed.\nI'm not sure I follow, could you please clarify what you meant by this comment? I don't see how these new initializes allow you to do something that the existing ones don't.. Oh, right, there is an existing comment like that \ud83d\ude04. I will take a look, not sure why I thought it was necessary, seems outdated. It's there just for convenience and to make API for resizing images - which is a common operation - easier to find and use.\n\nOut of curiosity, what are you gaining by making the image processor objects in this library structs?\n\nAFAIR to reduce the number of allocations and deallocations, that's it.. It seems I haven't update the Swift version in pbxproj. Not sure how Carthage handles Swift versions yet, will do some research today and update. Thanks for reporting!. Pushed version 7.5.1 which now uses Swift 4.2 by default https://github.com/kean/Nuke/releases/tag/7.5.1. Hey, @gabzsa. I've considered this option, but I never needed anything like that in any of my apps and I couldn't come up with any potential use cases. I would recommend simply running the transition manually in your case.. I think it's a good default not to run transition when an image is stored in memory cache. One example  is when you are scrolling a collection of images - you wouldn't want each cell to be animated each time it appears on the screen. Same with reloadData.\nI checked other frameworks, they also work this way. Some provide an option to run transition even if the image is stored in memory cache. I'm not against adding an option like that.. @gabzsa thanks, looks good. I checked the CI report, the build is failing on macOS:\n```\n\u274c  /Users/travis/build/kean/Nuke/Sources/ImageView.swift:396:66: missing argument for parameter #5 in call\n            _display(image, options.transition, fromMemCache, nil)\n\u274c  /Users/travis/build/kean/Nuke/Sources/ImageView.swift:398:85: missing argument for parameter #5 in call\n            _display(failureImage, options.failureImageTransition, fromMemCache, nil)\n                 ^\n\u274c  /Users/travis/build/kean/Nuke/Sources/ImageView.swift:405:55: missing argument for parameter #5 in call\n        _display(image, options.transition, false, nil)\n``. Thanks, @saroar! We have extensive README and a bunch of guides. If you don't find an answer there, please open an issue.. Hey, @gaborcsontos! I assume you're talking aboutURLSessionTask` messages? These ones are logged by the system, here's how to disable them:\n\nIn Product>>Scheme>>Edit Scheme...>>Run add the following environment variable: Name:OS_ACTIVITY_MODE, Value: disable\n\nP.S. Sorry, couldn't respond earlier, was on vacation.. That seems like something worth investigating. Well, Nuke doesn't do any printing on its own. Is your app doing anything unusual in regards to image loading?. I also tested this a while back on an empty project (no Nuke, nothing). If you cancel any URLSessionTask, you get this message in the console. As @DanielStormApps suggested, setting OS_ACTIVITY_MODE to disable does remove the logs.. Hey, @gabzsa! This is a curious, I'm not entirely sure what the expected behavior might be in this case. \nHave you tried disabling isPrepareForReuseEnabled, does it produce the result you want? I'm note sure this option even makes sense with cross fade. Maybe it would be better if we ignore isPrepareForReuseEnabled when cross fade animation is selected.\nP.S. Sorry, couldn't respond earlier, was on vacation.. Yep, I would appreciate a PR. I'd also suggest rethinking transitions a bit. I'm not entirely sure why I haven't added an explicit crossFade option, it seems that we need it to be smart about removing images on reuse.\nPlease, before you create a PR, describe the behaviour you want from cross fade.. Hey, @eonil. Thanks for the PR! I\u2019m on vacation and don\u2019t have my laptop with me. Will go through the PRs when I\u2019m back.. Hey, @eonil! Just wanted to let you know that I haven't forgot about this PR.\nMy concern is that with so many new targets the project becomes a little unwieldy. I'm currently testing a new approach in FutureX where I have a single multi-platform target (instead of four, one per platform) and where I use xcconfig to extract some of the configuration. As soon as I'm confident that it works, I'm going to try adding a target that builds static libraries. With this new approach it should be nice and easy.. > I don't think \"single binary for multiple platforms\" would work.\nIt doesn't build a single binary, there are still four different binaries produced, depending on which platform you build for.. If you\u2019d like to see an example of such target setup, you can see RxSwift and PromiseKit. The latter has been using it for a while, seems that it\u2019s working well for them.\nGood point about frameworks, it might be worth considering deprecating them, need to do some research.. Don't worry, I'm committed to supporting all of the installation methods, including Carthage and manual installation. All Nuke and FutureX satellite projects use Carthage.. Seems be an issue with fade transition on macOS, would appreciate an MR.. Sorry, I got used to the terminology we use at work (MR - Merge Request). PR - Pull Request.\nYep, seems perfect, I think that's what I'm using except that I forgot to display the actual image \ud83d\ude01. Fixed in 7.5.2. Hey, @keisukeYamagishi.\nWhen I push the new version I use pod trunk push --swift-version=4.2 (I select the swift version manually).\nThe reason I haven't switched to swift_version attribute yet is that CocoaPods doesn't support Swift version ranges.\nThe current behavior is:\n\nSince the introduction of the swift_version DSL CocoaPods has used the following simple strategy to pick which SWIFT_VERSION value to set during installation:\nIf the podspec specifies the swift_version attribute then always use this as the value of SWIFT_VERSION build setting.\nOtherwise, CocoaPods derives the SWIFT_VERSION value based on the target that is integrating this pod. If the targets integrating this pod use different SWIFT_VERSION settings then CocoaPods installation errors out with a message explaining to the user that a SWIFT_VERSION setting cannot be derived.\n\nI'm happy with the \"otherwise...\" version (swift_version isn't provided), Nuke support all 4.x Swift versions.\nCocoaPods 1.7 is going to have support for multiple swift versions. I was planning to switch to swift_version when this feature is shipped.. The PRs are more than welcome. ImageLoadingOptions were designed to support as many options like these as needed.. The code looks good. I ran the tests locally, they succeed. Weird.. Locally I select a \"Nuke iOS\" scheme and run tests, that's about it. On CI the tests are executed based of the Travis config file.\nP.S. in develop branch I got rid of per-platform targets. Haven't merged/released it yet. There is now a single Nuke target instead. Same with unit tests.. OK I found there reason why the tests are failing for tvOS. The new alpha.png file was not added to  the Nuke tvOS Tests target - wouldn't have happened in develop branch where there is a single target for all platforms ;)\nNot sure what's the issue with iOS 9.3 yet. I don't have it locally, downloading it.. > Not sure what's the issue with iOS 9.3 yet. I don't have it locally, downloading it.\nIt seems that you can't use XCAssertEqual on UIImage objects in iOS 9, we need to find a different approach.. Hi,\nThere are multiple cache layers in Nuke which are described in README and there is also a blog post. I would suggest going through these. \nIf the images are removed from cache, I would suggest:\n\nReducing the size of the image on backend side\nIncreasing the limits of disk cache\nMaking sure that HTTP cache control headers are correct. If they are not, fix them, or switch to custom Aggressive Disk Cache\n\nThere is also a new feature in Nuke 7.4 which allows you to ask Nuke to put prefetched images only in disk cache, not in memory cache. It might make sense to use this option if you're prefetching so many images.\nPlease also take into the account that ImagePreheater is not really designed for this use case, it is designed to be used in table/collection views. For example, it only makes a single attempt to prefetch an image. You can't rely on it to prefetch the images no matter what - it doesn't perform any retries.. > Maybe in the future, the ImagePreheater could function as a way to start downloading images in the background.\nPlease elaborate.. Hi,\n\nmaybe different methods that will perform request, cache it and callback with local url instead of an image?\n\nI've investigated a few ways to approach this. Ideally I think you would use URLSessionDownloadTask to download these videos directly to some cache - maybe extend Nuke.DataCache to support it - and then play the videos directly from cache.\nBefore you start playing the video you still might want to create a temporary copy of a file to make sure that exists for the time you're playing it - APFS should be able to do it with no overhead.\nCurrent demo is just a quick prototype really. I haven't really investigated any further.\n. The framework isn't really designed to support videos. But it is possible to find some clever makes to make it work with them. If you will need to validate some ideas, please share, I can help. I don't currently have capacity to design a completion solution for mp4 support in Nuke though.\n\nand wouldn't share same download queue\n\nYou can share the same dataLoadingQueue between two pipelines, it was specifically designed to support this use case. You don't need deduplication across pipelines that work with different image types.. There is no SVG support built it.. Hi, by default there is a native URLCache used by DataLoader. You need to disable it as well. One way to do that is to instantiate DataLoader with a custom URLSessionConfiguration.. This things used to be private.. I haven't yet went through all of Swift 4 changes. Not sure, why is this change necessary?. I don't think that you should remove data at this point. If you get to this point in the pipeline it means that the data wasn't found in the dataCache and was fetched from the network instead. Could you please update the code?. ",
    "marlowcharite": "Sounds good. Thanks @kean \n. ",
    "RuiAAPeres": "@kean :+1: \n. With the following works:\n./xctool -workspace ~/Documents/MailOnline/Money/Money.xcworkspace -scheme Money -sdk iphonesimulator -destination name=\"iPhone 6\" test\nIt seems to me the issue is related to 32bits devices (iPhone5 also crashes, but no the 5s) \n. A bit more digging revealed the following:\nfatal error: floating point value can not be converted to Int because it is greater than Int.max\n. I tested that on the simulator (my carthage file is currently pointing to that commit) and it's working. But we can look for another alternative.\n. ",
    "ollieatkinson": ":+1: \n. ",
    "ZAPHIT": "Hi can i add more.. how can i add a success failure closure on this??\n. i have success and failure closure now..  thanks..\n. ld: framework not found Alamofire\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. ld: framework not found Nuke\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. Its working, using your own project and the sample Nuke, it create sample workspace,\nbut i have my app, and i am linking the pod file on it... seems have problems..\n. Pod Installation is complete no errors...  I tried creating another blank project and intergrate your framework.. same result..\nld: framework not found Nuke\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nOr am i missing something, need to adjust xcode setting linker?\n. Yes its only in Nuke... can you try to create just a plain Swift.. not using cocoa pods... then integrate the project with Nuke using cocoa pods... it does not seem compatible...\n. I am using Haneke and other frameworks before.. I think the only option is to recreate my app to the one cocoa pods have produce.. using    try \"Nuke\" , but its not just easy, because it will require more time..\n. This is my podfile..\nuse_frameworks!\nplatform :ios, \"9.0\"\npod \"Nuke\"\ntarget 'sampleProject' do\nend\ntarget 'sampleProjectTests' do\nend\ntarget 'sampleProjectUITests' do\nend\n. I think i found it.. its fixed now...\n. The problem was opening the app on xcode.. just need to reopen the project using xworkspace\n. Hi kean.. thanks for all of your help.. Your framework is good, i have tried lots of framework, yours is the fastest but i have discover another framework that soothes this cache that i need..maybe you could be inspire by KingFisher.. its also swift version..\n. ",
    "joe528": "@kean  Is caching asynchronous for Nuke? \n. I am not sure if it helps the performance or not. It's because I read an article about it: https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5\nSo I try to improve my table view performance through different angles.\n. By the way, do you have any suggestion about Nuke configuration that might help the scrolling performance? \nI found Nuke has an option that might help performance but I don't quite understand. I set my image view as\nimageView.clipsToBounds = true\nimageView.contentMode = .ScaleAspectFill\nand download images as\nvar request = ImageRequest(URLRequest: NSURLRequest(URL: url!))\nrequest.targetSize = cell..imageView.frame.size\nrequest.contentMode = .AspectFill\ncell.imageView.nk_setImageWith(request)\nbut there are two problems after my experiment:\n(1) I cannot get the same effect as .ScaleAspectFill via Nuke options if I don't set imageView.contentMode as .ScaleAspectFill\n(2) the targetSize is in pixel and setting it in the way above will make the images having lower-quality on screen.\n. Thank you very much for your detailed reply.\nYes, I can understand Nuke is doing a great job for the performance. That's why I switched to Nuke right after I saw RayWenderlich mentioned about you. The scrolling performance of my table view is pretty good already except a bit of jerkiness while scrolling fast and new images been downloaded. I have compared various apps, most of them have such jerkiness except Facebook's app. I am just trying to explore what I may have been missing. Thanks for the great job.\n. After a few days testing with Nuke & Haneke, my source code is the same, I can only feel from my eyes, it seems Haneke is performing better (less jerkiness). The difference is very slight, hardly detected, I am just being extremely picky.\nI will test for the new release when it's out to see if it makes any difference. \nAnother thing is... I found the images shown by Nuke has a alpha transition? (while Haneke doesn't). I like the alpha transition because it provides better UI feeling, however it might affect scrolling performance a bit? Can this transition be disabled by configuration so that I can test without it?\n. Disabling animation does help.\nAny other option I can try? Would request.memoryCacheStorageAllowed = false help?\n. Thanks!  Just one more question... does it make any difference to specify the targetSize? (for UI performance)\nvar request = ImageRequest(URLRequest: NSURLRequest(URL: url!))\nrequest.targetSize = imageView.nk_targetSize() \nimageView.image.nk_setImageWith(request)\nI am wondering if it consumes more CPU time or actually helps?\n. I downloaded develop branch (only one file different: ImageLoader.swift from my SVN diff)\nI cleaned up & re-built. I saw hundreds of logs like this in the console:\n`execute <__NSCFLocalDataTask: 0x138ec2e60>{ taskIdentifier: 441 } { running }, pending: 0, executing: 7\nexecute <__NSCFLocalDataTask: 0x1390042d0>{ taskIdentifier: 442 } { running }, pending: 0, executing: 6\nexecute <__NSCFLocalDataTask: 0x138d67a20>{ taskIdentifier: 443 } { running }, pending: 0, executing: 4\nexecute <__NSCFLocalDataTask: 0x138dec600>{ taskIdentifier: 444 } { running }, pending: 0, executing: 5\nexecute <__NSCFLocalDataTask: 0x138daae20>{ taskIdentifier: 445 } { running }, pending: 0, executing: 6\nHowever, the testing result is the same. I still have to wait 10-20+ seconds before I start to see images. Probably you should try to scroll faster? If I don't scroll fast enough, the images come up without problem. But if I keep accelerating the scrolling (keep moving the finger until the images stop catching up), the problem can be seen.\n. By the way, I call ImageManager.shared.removeAllCachedImages() before a testing and the image in each cell is different.\n. I am not sure if I am testing it with Alamofire plugin... \nI do have pod \"Alamorefire\" but I don't have pod \"Nuke-Alamofire-Plugin\" in my pod file. I use Alamorefire for some file downloading in some other place in my code.\nAny specific code to use Alamorefire plugin?\nHow to verify if I am using it? \n. I tested with nk59-test branch, and the result is still the same. I will see if I can build a project that can reproduce it so that you can see it too.\n. In case my own code causes the issue, I created a new project with a simple UITableView and a custom UITableViewCell that contains only one UIImageView & one UILabel. (The project is attached with this message)\nFortunately, the problem can be reproduced with this simple project. But there is one thing about the scrolling speed, I have to scroll \"at a certain speed\" to reproduce the problem.\n- Too slow: of course, images are downloaded without problem.\n- Too fast: as you can see the text \"item # N\", certain items (cells) are plainly ignored by iOS itself (without any attempt to render these cells). Therefore, when scrolling too fast, a lot of items (cells) are ignored (no request for image download), so the image downloading process still catches up. My original app has more complicated cell layout, therefore I guess when I scroll as fast as I can, iOS spends more time rendering each cell without ignoring cells, so it was a coincidence I was scrolling \"at a certain speed\" to see the problem.\nI also make a video when I was trying to reproduce the problem. As you can see from the video, for the first 400 items, I was either scrolling too slow or too fast, there was no problem for the images to be downloaded and shown up. However, around row 400 or so I was scrolling at a certain speed, you can see clearly that no images are downloaded afterwards. I had to wait 10-20 seconds or sometimes even longer to see image downloading back to normal.\nThe video is 90MB in size. I cannot upload it, so I put it on a server temporarily: http://ibarkley.com/_tmp/nuke.mov\nThe project to reproduce the problem:\nNukeTestFastScrolling.zip\n. I thought all changes were in nk59-test so I just manually downloaded the branch and copied the source files into the project.\nWhat you mean is that you actually had fix for the problem I am seeing?\nDo you want me to do any further testing at this moment?\n. I updated podfile with \npod \"Nuke\", :git => \"https://github.com/kean/Nuke.git\", :branch => \"develop\"\nand run pod update\nI still can reproduce the problem with the sample project I sent you.\n. I tested with the develop branch a few times. It's harder to reproduce the problem, but at certain scrolling speed, I still can see it.\nJust like you said, it should be more than enough for most cases. \n. I actually have no completion handler. My call to Nuke to set images is very simple as below:\nlet request = ImageRequest(URLRequest: NSURLRequest(URL: nsurl))\ncellBase.postView.image.nk_setImageWith(request)\n. Sure, I will keep an eye on it after I updated to 3.1.3\nSo there is a plan for Nuke 4? What would be the main difference/improvement?\n. I looked at the changes you made for this bug.\nWould it be better not to call assert but tolerate the fault (just return if the variable is nil)?\n. @kean What should I be expecting for Nuke 4? I mean what major improvement will it have? Besides, would the performance be even better? Exciting to see Nuke 4 but I am not sure what I am expecting :)\n. Sounds great. I will update to Nuke 4 and provide you feedback if any.\n. Disk cache will be cleaned up automatically & periodically by Nuke or by iOS?. ",
    "sadityam": "Hi,\nHow did you set the environment variable CGBITMAP_CONTEXT_LOG_ERRORS and what did you set it to ?\n-Thanks\n. ",
    "vkaramov": "Product/Scheme/Edit Scheme/Environment variables.\nI had set it to 1.\n. I have also tried it, but I got another warning (\"Unsupported pixel description - 3 components, 64 bits-per-component)\n. ",
    "jsleeuw": "OK thx. Great work here btw!\n. ",
    "ValCanBuild": "Thank, Kean, that works great. Want me to close the issue or will you leave it open to investigate?\n. ",
    "bassrock": "Good news tested it with my app. just need to add || os(tvOS) to the same iOS one in ImageLoadingViewExtensions.swift\n. ",
    "spf2": "I'm using 0.9.4 carthage and Xcode 7.1, which seems to have gotten rid of the option to enable/disable bit code... trying to figure that out right now.  In any event, I think bit code is required for tvos (inexplicably).\n. Regarding enabling/disabling bit code, I added ENABLE_BITCODE=YES manually to my project.pbxproj and rebuilt the Nuke with carthage and still the same error back from the App Store.\nI switched to cocoa pods and now it works...\n. To be clear, I understood this to a problem with Nuke's Carthage config, which is why I opened this bug. I couldn't get it working with Carthage (including those new directions), so I can't really rule that out.  Sorry I can't be of more help. \n. ",
    "joergbirkhold": "Your are welcome , thanks for all your awesome work :+1: \n. ",
    "pyrtsa": "That sounds fair enough. I think using a screen scale becomes problematic in the subtle scenario when there is an external screen attached (often with a scale different from UIScreen.mainScreen().scale).\nHow about doing the following change instead?\n1. Add a property named scale to ImageRequest, with the default value of 1.\n2. Pass the scale on to ImageDecompressor, and return a UIImage with the given scale (and size).\n3. Keep rounding to nearest pixel like in my original patch, because otherwise what gets drawn in decompressImage may crop out a bit of the last pixel row and column.\nI'll modify the pull request accordingly.\n. Sorry for the delay. This issue turned bikesheddy, which I'm sorry about and I don't like.\nHere's another attempt at making it better anyway. I find it unlikely to break existing code but it's a breaking change anyway: now there's a new parameter targetScale (defaults 1.0) that directly sets the target UIImage.scale. This combination, however, makes targetSize behave the way as UIImage.size behaves, at the presence of non-unit targetScale and UIImage.scale.\nWhat do you think?\n. Yes, this is exactly the bikeshedding I'm talking about \u2013 in other words, I don't want to take this discussion further.\nYou're absolutely right that adding targetScale complicates things. The only unexpected thing in the existing behaviour is that targetSize actually means pixels while UIImage.size is in points.\nI'm closing this pull request. I suggest the following fixes could be considered in separate issues, sometime:\n1. Fixing the downscaled size computation like in this PR. As said, minor rendering errors due to bad rounding may happen otherwise.\n2. Documenting better that targetSize means actual pixels (and reminding about Retina scale).\n3. Possibly weighing whether targetSize should be renamed (e.g. targetResolution, maximumResolution, maximumPixelCount, whatever), although just better doc comments and better examples might be enough.\n. \ud83d\udc4d to all!\n. ",
    "RobinChao": "OK,Thanks.\n. ",
    "sschizas": "Any update on this feature?\n. I am pretty sure that Nuke should send image/webp at the http header of the request to identify that supports webp. Especially when image is loaded via image cdn\n. @kean should i treat it as false positive memory leak?. ",
    "mitchellporter": "The easiest way to add WebP support is to follow @kean's advice and use WebPImageSerialization. I just set it up and everything's working fine like normal.\n. @kean Would be more than happy to share and help just need some time. We are using a legacy version of Nuke in an older project that works fine like I mentioned above, but last I checked it no longer works using the latest version of Nuke, animated image plugin, etc.\nWill report back when I can share an update and maybe a quick test project too.. Bump. This has been long overdue. I'm going to try and spin up a test project within the next week or so. Last I remember WebPImageSerialization was no longer working... a lot has changed with Nuke since the last time I had it working.\nI'll update again soon with my findings.. @kean Thanks for letting me know Alexander cheers!. ",
    "swiftTalker": "@mitchellporter do you mind sharing your implementation for WebP support? So other people including me can use it.. ",
    "andreaslindahl": "I'm using Amazon S3 for storing files. The Etag header is set, but the max-age header is not set (if max-age is what Amazon refers to as Expiry date below):\nLast Modified:  Wed Feb 03 08:00:12 GMT+100 2016\nETag:   8069ea92d9e4aff1db9d6ccb38899fdc\nExpiry Date:    None\nUpdate:\nHere's the response headers. See anything that might cause caching problems?\nCache-Control:must-revalidate\nDate:Wed, 03 Feb 2016 10:51:51 GMT\nETag:\"40815c43cd4f6bacfc247011966b724b\"\nLast-Modified:Wed, 03 Feb 2016 10:49:36 GMT\nServer:AmazonS3\nx-amz-id-2:oBOSLSmUFZ19Z5XJ0e/5TRMXE3VeyBya/HCzMWbLpKEU43JfLqI9MrPIKkS1y72kLaCrGVvN9G4=\nx-amz-request-id:5BDEE42876386064\n. After upgrading to 2.0 I'm having trouble getting updated images, even though I'm using NSURLRequestCachePolicy.ReloadIgnoringCacheData:\nlet cachePolicy : NSURLRequestCachePolicy = .ReloadIgnoringCacheData\nlet request = ImageRequest(URLRequest: NSURLRequest(URL: imageUrl, cachePolicy: cachePolicy, timeoutInterval: 360))\nself.nk_setImageWith(request, placeholder: UIImage(named: \"placeholder\"))\nWorked fine in the previous version.\n. Oh, ok. thanks!\n. I'm still having trouble getting updated images unless I set the memoryCachePolicy to ReloadIgnoringCachedImage however. It seems like the Etag is ignored. I have verified that the ETag header is updated when the image is updated on the server and the Cache-Control header is set to \"must-revalidate\" but this doesn't seem to matter - the old, cached image is used instead.\nThe Last-Modified header is also updated, by the way.\nSetting the memoryCachePolicy to ReloadIgnoringCachedImage solves the problem, of course, but since this bypasses the cache entirely it doesn't seem like a good solution...\n. I probably shouldn't bother you with these questions, since they seem to be more about how NSURLRequest and NSURLCache works. :)\n. I managed to solve it by adding CFNetwork to the Nuke target in my Cocoapods project. Should probably be added by default...\n. I did some research and it seems to be a problem with XCode or some part of the SDK. Just adding CFNetwork as a requirement, or as a framework reference should fix it.\n. ",
    "bhmahler": "Ohhhhh I didn't see that Issue for S3.  I will dig deeper.  Appreciate the quick response!\n. ",
    "BabyAzerty": "I believe to have the same issue as joe528.\nI am using 3.1.3 (with \"Alamofire\" bundled but not used in this case, and globally never used with Nuke)\nScrolling \"fast\" on a UICollectionView triggers the problem.\n``` swift\n    //My cell\n    class UserCardCell: UICollectionViewCell {\n        func updateContent(user: User) {\n            Nuke.taskWith(NSURL(string: url)!) { result in\n                //Hide animated loader here <- I removed the code for clarity\n                if let img = result.image {\n                    self.pictureImgView.image = img\n                }\n            }.resume()\n        }\n    }\n//My collection view\nfunc collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(\"userCardCell\", forIndexPath: indexPath) as! UserCardCell\n    cell.updateContent(users[indexPath.row])\n    return cell\n}\n\nfunc collectionView(collectionView: UICollectionView, didEndDisplayingCell cell: UICollectionViewCell, forItemAtIndexPath indexPath: NSIndexPath) {\n    (cell as! UserCardCell).pictureImgView.nk_cancelLoading()\n}\n\n```\nI often get complaints from real users about this glitch.\nSo I don't know if this is an implementation problem on my side or if it will be corrected in the next version or if I need to change library.\nEDIT\nOkay I found out why I couldn't make it work, I was mixing things...\nSo I added a variable imgTask in my cell object and assigned the Nuke task to it\n``` swift\n    var imgTask: ImageTask?\nfunc updateContent(user: User) {\n    self.imgTask = Nuke.taskWith(NSURL(string: url)!) { result in\n            //Hide animated loader here <- I removed the code for clarity\n            if let img = result.image {\n                self.pictureImgView.image = img\n            }\n        }\n    self.imgTask?.resume()\n}\n\n```\nThen in the collection view, I cancel the task\nswift\n    (cell as! UserCardCell).imgTask?.cancel()\n. ",
    "ryanbrozo": "Turns out I was still using XCode 7.2.1 with Swift 2.1. Getting the 2.3.0 release compiled flawlessly.\n. ",
    "bryan1anderson": "Sure! First of all I love Nuke and would prefer to use it for everything, this being my number one motivation for hoping a future build could handle PHLivePhoto and PHLivePhotoView.\nExtremely possible ImageDiskCaching protocol may do the trick! I'll need to see. I'll list as many requirements for using PHLivePhotoView and PHLivePhoto and if you have time perhaps you could offer your best recommendation for integrating. Thanks\nPHLivePhotoView is very similar to UIImageView. Where UIImageView has an optional image property, PHLivePhotoView has an optional livePhoto property.\nThe actual PHLivePhotoView is a very friendly object. Not overly complex, and very familiar. \nHowever, PHLivePhoto is very different from its \"counterpart\" UIImage.\nObviously it is very easy to instantiate a PHLivePhoto from a UIImagePickerController:\nfunc didFinishPickingImageWithInfo(info: [String: AnyObject]) {\nif #available(iOS 9.1, *) {\n   let livePhoto = info[UIImagePickerControllerLivePhoto] as? PHLivePhoto\n}\n}\nAnd here is where it gets tricky. I use an imagePickerController to select a live photo, I use PHAssetResource to get the NSData chunks that make up a PHLivePhoto. I separate that data, upload it to my server.. So now somewhere in a cloud I have a .mov file, and a .jpeg file that constitute a live photo. There is a great tutorial explaining this process here: https://milen.me/writings/live-photo-ios-api-overview/\nI now need to create a PHLivePhoto using the files on my server. Nuke is great at this. I could just use nk_setImageWith(url). Even UIImage makes it easy with an NSURL convenience init.. Granted not the best way....\nThe only method to instantiate a live photo from the .jpeg and .mov data is this:\nclass func requestLivePhotoWithResourceFileURLs(_ fileURLs: [NSURL],\n                               placeholderImage image: UIImage?,\n                                     targetSize targetSize: CGSize,\n                                    contentMode contentMode: PHImageContentMode,\n                                  resultHandler resultHandler: (PHLivePhoto?,\n                                      [NSObject : AnyObject]) -> Void) -> PHLivePhotoRequestID\nhttps://developer.apple.com/library/ios/documentation/Photos/Reference/PHLivePhoto_Class/index.html#//apple_ref/occ/clm/PHLivePhoto/requestLivePhotoWithResourceFileURLs:placeholderImage:targetSize:contentMode:resultHandler:\nWhere UIImage has convenience inits for NSData, and NSURL for remote files, PHLivePhoto only has this method. It only accepts two NSURL's (.mov and .jpeg files). These NSURL CANNOT point to a remote location, like on a server. This method will fail if I provide any NSURL that doesn't point the a file actually stored on the disk.\nSo I can't just download the data from the server. I have to download it, then store it to disk, then use I can use the NSURL's poiningt to those files on the disk.\nSo far the solution for me is:\nUse NSURLSession to download and store the files.\n```\nfunc URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {\n    // First we need to make sure that the folder in which we wish to place the file exists\n    if let documentsDirectoryPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true).first\n    {\n        let baseUrl = NSURL(fileURLWithPath:documentsDirectoryPath)\n        livePhotoFolder = baseUrl.URLByAppendingPathComponent(\"LivePhotos\")\n        do {\n            try NSFileManager.defaultManager().createDirectoryAtURL(livePhotoFolder, withIntermediateDirectories: true, attributes: nil)\n        }\n        catch {\n            print(error)\n        }\n    }\n    // Next we retrieve the suggested name of our file and this file name to the URL\n    guard let suggestedName = downloadTask.response?.suggestedFilename else { return }\n    let newLocation = livePhotoFolder.URLByAppendingPathComponent(suggestedName)\n    do {\n        try NSFileManager.defaultManager().moveItemAtURL(location, toURL: newLocation)\n        let pathExtension = newLocation.pathExtension\n        if pathExtension == \"mov\" {\n            self.videoURL = newLocation\n        } else {\n            self.photoURL = newLocation\n        }\n    }\n    catch {\n        print(error)\n    }\n}\n\n```\nNow self.videoURL and self.photoURL can be used to obtain the live photos.\nI can now use requestLivePhotoWithResourceFileURLs to finally create my PHLivePhoto\nPHLivePhoto.requestLivePhotoWithResourceFileURLs([videoURL, photoURL], placeholderImage: nil, targetSize: CGSizeZero, contentMode: PHImageContentMode.AspectFit) {\n            (livePhoto, infoDict) -> Void in\n            print(infoDict)\n            if let livePhoto = livePhoto {\n                   //YAY, do what you want with it.. \n            }\n        }\nI'm in the process of building a simple caching system. End goal is to extend PHLivePhotoView to have similar functionality to nk_setImageWith(url)\nso \nlet imageURL = NSURL(string: \"https://pbs.twimg.com/media/1234_.jpg\")\nlet movieURL = NSURL(string: \"https://pbs.twimg.com/media/1234_.mov\")\nmyLivePhotoView.setLivePhotoWith(imageURL: imageURL, movieURL: movieURL)\nBut I'm not very experienced when it comes to a caching algorithm that will intelligently delete these large files, and honestly it has been such a pain to get my live photos even working, I see good potential for Nuke to expand functionality for PHLivePhotos so no one ever needs to worry about this again.\n. ",
    "adomanico": "Also, we were not seeing this in 2.2.0 Nuke.\nThis appeared once we upgraded to 3.0.0\n. Please let me know if there is any thing I can do / any more information I can provide\n. Similar issue in ImageLoader\nGoing to fire up instruments and check as well\nEdit: fixed link\n. So after profiling what I am seeing are substantial memory increases happening in ImageDecompressor\nImageDecomp\nsince our app loads multiple map images simultaneously many of these workers are dispatched and will continue until in some cases the device runs out of memory\nMultiple threads\n. Still digging but if you see anything here that looks off let me know\n. Also, not seeing any leaks, just seeing the Nuke image cache grow really large \n. Yeah definitely is case 1.  \nWe have a map interface where we re-query the same images if the user scrolls around (its tile based).\nIs there a change we should make on our end , or is this something you will address?\n. I think for now I'm going to just throw the map UIImages in an NSCache as a temporary solution until you have a release ready\n. Ok awesome, I will block duplicate requests.\nThanks for the fast response\n. \ud83d\udc4d cool\n. Looks like there is already a branch https://github.com/kean/Nuke/tree/swift2.3\n. Awesome thanks, will point our carthage to the swift 2.3 branch for now.\nCan you make a separate release that targets swift 2.3 when it hits GM?\n. Great thanks!\n. ",
    "mperovic": "This is my code for setup ImageManager:\nfunc setupImageManager() {\n    self.previousManager = ImageManager.shared\n    var managerConf = self.previousManager.configuration\n    var loaderConf = (managerConf.loader as! ImageLoader).configuration\n    loaderConf.cache = DFDiskCache(name: \"Home\")\n    managerConf.loader = ImageLoader(configuration: loaderConf)\n    ImageManager.shared = (ImageManager(configuration: managerConf))\n}\n. Thanks.\n. ",
    "stanmots": "Thanks for the detailed comment! I think, I got the idea. I'll try it and if everything's working fine I'll close the issue.\n. ",
    "Querschlag": "Pretty sure...\nI ran a couple of debug sessions and it stops at \nfor task in preheatingTasks.values.sort({ $0.identifier < $1.identifier })\nin executePreheatingTasksIfNeeded() of ImageManager with a BAD_ACCESS.\n. I am now able to reproduce the issue reliably in my project by calling startPreheatingImage(_:) and stopPreheatingImages() multiple times to simulate frequent reloading by the user.\nNuke.stopPreheatingImages()\nNuke.startPreheatingImages(imageRequests)\nNuke.stopPreheatingImages()\nNuke.startPreheatingImages(imageRequests)\nNuke.stopPreheatingImages()\n...\nThe crash occurs when accessing preheatingTasks.values\nStacktrace:\n```\nThread 1Queue : com.apple.main-thread (serial)\n0  0x00000001021a2588 in specialized _fatalErrorMessage(StaticString, StaticString, StaticString, UInt) -> () ()\n1  0x00000001020fa7f8 in _NativeDictionaryStorage.assertingGet(_NativeDictionaryIndex) -> (A, B) ()\n2  0x00000001020f4f94 in _VariantDictionaryStorage.assertingGet(DictionaryIndex) -> (A, B) ()\n3  0x00000001020f4ea4 in Dictionary.subscript.getter ()\n4  0x00000001020f743c in protocol witness for CollectionType.subscript.getter in conformance  [A : B] ()\n5  0x0000000102121768 in LazyMapCollection.subscript.getter ()\n6  0x0000000102121eec in protocol witness for CollectionType.subscript.getter in conformance  LazyMapCollection ()\n7  0x00000001020a126c in _copyCollectionToNativeArrayBuffer (A) -> _ContiguousArrayBuffer ()\n8  0x0000000102078148 in CollectionType._copyToNativeArrayBuffer() -> _ContiguousArrayBuffer ()\n9  0x0000000102123be0 in protocol witness for SequenceType._copyToNativeArrayBuffer() -> _ContiguousArrayBuffer in conformance  LazyMapCollection ()\n10 0x00000001020970ec in Array.init (A1) -> [A] ()\n11 0x0000000100f0a0ac in ImageManager.(executePreheatingTasksIfNeeded in _1052F8D7C79E5ADE8D7CF5528D930A57)() -> () at /path/to/my/app/Pods/Nuke/Sources/ImageManager.swift:210\n12 0x0000000100f1029c in ImageManager.((setNeedsExecutePreheatingTasks in _1052F8D7C79E5ADE8D7CF5528D930A57)() -> ()).(closure #1).(closure #1) at /path/to/my/app/Pods/Nuke/Sources/ImageManager.swift:200\n13 0x0000000100f0ba1c in ImageManager.(perform in _1052F8D7C79E5ADE8D7CF5528D930A57)(() -> ()) -> () at /path/to/my/app/Pods/Nuke/Sources/ImageManager.swift:279\n14 0x0000000100f1021c in ImageManager.((setNeedsExecutePreheatingTasks in _1052F8D7C79E5ADE8D7CF5528D930A57)() -> ()).(closure #1) at /path/to/my/app/Pods/Nuke/Sources/ImageManager.swift:201\n15 0x0000000100efb844 in thunk ()\n16 0x00000001026eda7c in _dispatch_call_block_and_release ()\n17 0x00000001026eda3c in _dispatch_client_callout ()\n18 0x00000001026f9cc8 in _dispatch_after_timer_callback ()\n19 0x00000001026eda3c in _dispatch_client_callout ()\n20 0x0000000102705de0 in _dispatch_source_latch_and_call ()\n21 0x00000001026effe0 in _dispatch_source_invoke ()\n22 0x00000001026f2ec0 in _dispatch_main_queue_callback_4CF ()\n23 0x000000018174cd50 in CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE ()\n24 0x000000018174abb8 in __CFRunLoopRun ()\n25 0x0000000181674c50 in CFRunLoopRunSpecific ()\n26 0x0000000182f5c088 in GSEventRunModal ()\n27 0x000000018695e088 in UIApplicationMain ()\n28 0x00000001001b577c in main at /path/to/my/app/AppDelegate.swift:18\n29 0x00000001812128b8 in start ()\n```\n. ",
    "bdolman": "Thanks. From my perspective, changing to a new API and internals while simultaneously having to migrate all my code to Swift 3.0 isn't the best approach. It's introducing too many changes at once -- Swift 3 migration is painful enough by itself!\nInstead, I switched to PINRemoteImage (which was an easy change given the way I was using Nuke), and then began my Swift 3 migration.\nThanks for your hard work on Nuke, maybe I'll be back in the future :)\n. I like that you have implemented an LRU cache -- that was definitely something I wanted in Nuke 3. In my tests, it also seemed that PINRemoteImage was a bit faster loading images from the disk cache, but I haven't done any controlled tests, so that could be very subjective.\nAnother big factor for me is that I'm looking seriously at using AsyncDisplayKit and it has built-in support for PINRemoteImage, so that kind of sealed the deal.\nI definitely like the idea of a native Swift image loading framework thought. I'm sure that with you keeping up on Swift changes, your API is going to be much nicer to use from Swift as time goes on. But knowing that PINRemoteImage is Objective-C means that I'm not going to have to worry about these Swift migrations in the future.\nAgain, thanks for your work. I don't in any way mean to be critical of the hard work you're putting into this for the community!\n. > AsyncDisplayKit has a ASNetworkImageNode built in as well.\nDidn't realize that -- nice.\n\nI'm glad that I currently have 0 lines of Swift code in production. That was the smartest decision I've ever made \ud83d\ude06\n\nBoy, you were much smarter than me. The last few days have sucked!\n. ",
    "ksm": "@kean Any protips on how one would go about extending Nuke with a progress closure? \nLooking through the source code I'm guessing I would need to implement DataLoading, then instantiate a Loader with that DataLoading implementation.\nSo API for progress could be:\nswift\nrequest.progress = { progress in\n}\n. @kean Thank you for the pointers!\n. Thank you for the update on this. This is great.. ",
    "asenchuk": "@kean, what's the reason of updating deployment target to 9.0 ?\n. ",
    "meDev14": "@kean, I have tried to pull pod 'Nuke', '~> 4.0-beta', but I got this error.\n```\n[!] Unable to satisfy the following requirements:\n\nNuke (~> 4.0-beta) required by Podfile\n\nNone of your spec sources contain a spec satisfying the dependency: Nuke (~> 4.0-beta).\nYou have either:\n * out-of-date source repos which you can update with pod repo update.\n * mistyped the name or version.\n * not added the source repo that hosts the Podspec to your Podfile.\nNote: as of CocoaPods 1.0, pod repo update does not happen on pod install by default.\n```\nWhy does this happen to me?\nThanks\n. @kean Thank you for your help! pod repo update worked for me.\n. @kean will you merge it to main branch?\n. Great, thx @kean \n. @kean It works now. It seems pod.lock file made the issue.\nThank you.\n. @kean Thank you for your support.\n. @kean I have one more question.\nI'm using AnimatedImageView in my tableViewCell, but I got this error.\nrequired public init?(coder aDecoder: NSCoder) {\n        fatalError(\"AnimatedImageView doesn't support NSCoding yet\")\n}\nHow can I fix this?\n. @kean  wow, still is not the latest version...\n. @kean Your demo project pulling latest code, but I'm not sure why my project is not pulling latest code...\nPlease help me.\n. @kean Thanks for your update.\npod update worked for me!\n. @kean, Thanks for your quick response! \nReally appreciate for your support.. ",
    "nelson-chim": "Just set the cocoapods minimum target to iOS 8 is ok, should I make a pull request for that?\n. Thanks! I hope this will help for those needed for supporting on iOS8\n. ",
    "FranciscoAmado": "Thanks! Good to know its being released \ud83d\ude03\n. ",
    "bmetitiri": "\nYou now also use Manager class:\nlet view = AnimatedImageView()\nAnimatedImage.manager.loadImage(with: URL(string: \"http://...\")!, into: view)\n\nBut you can't use AnimatedImageView in a storyboard right? Because it doesn't have initWithCoder? I used the loadImage completion handler and called nk_display myself, that seems to work well. \nThanks for the explanation. Looking forward to seeing where you take this. \n. Thanks, that's super helpful. One other question, the examples on that guide you linked have lines like Nuke.Loader(loader: dataLoader), but Loader doesn't have any initializers that take just one argument. Should it be Nuke.Loader(loader: dataLoader, decoder: Nuke.DataDecoder(), cache: nil)?. ",
    "nico75005": "Ok thanks for the reply. But then I'm confused. What's the point to have a parameter into if it doesn't do anything when there is a handler?\n. Got it! Thanks a lot!\n. ",
    "toshi0383": "Thanks for instruction!! \ud83d\ude03\n. ",
    "AlexLee9986": "Hi. \nPlease help me.\nLoader.shared.loadImage(with: urlVal)\n.then({ (image) in\n....\n})\nerror: missing argument for parameter 'token' in call\ni inserted \"CanecllationTokenSource().token\", but it not work\nThanks!. ",
    "rudedogg": "Disregard! I needed to use a request with .processed(...) in my call to Nuke.loadImage(with: request, into: ...).\n. ",
    "winkelsdorf": "As addendum, I see several leaks - one related to LinkedList<CachedImage> too - but also in Profiler (Leak Mode).\nIn my case this only happens when routing Nuke through Alamofire (here in AppDelegate):\nswift\nlet loader = Nuke.Loader(loader: NukeAlamofirePlugin.DataLoader(), decoder: Nuke.DataDecoder(), cache: Cache.shared)\nlet manager = Nuke.Manager(loader: loader, cache: Cache.shared)\nNuke.Manager.shared = manager\nFor some of them, i.e. NSLock() and LinkedList my educated guess is, that the Profiler is reporting false positives.\nAlamofireNetworkActivityIndicator had reportedly also had to deal with such a leak (now fixed with Xcode 8.2). See: https://github.com/Alamofire/AlamofireNetworkActivityIndicator/issues/19\n@kean Hope you had a pleasant holiday! Can you confirm that routing through Alamofire does not create additional leaks in Nuke (not speaking of leaks probably related to false positives in Alamofire)?\nCheers\nFrederik\nWithout Nuke's Alamofire Routing\n\nWith Routing through Alamofire\n\n\n. @kean You're welcome and thank you for the kind words! Thank you for your extensive support as always, too \ud83d\udc4d As said, I believe it to be a false positive.. Looks already very elegant \ud83d\udc4d I had no time to implement it yet, but I guess it would break Nuke-Alamofire-Plugin at this stage?. Already though that, but I was sooo keen to try the new API ^^ Ok, I promise to be more patient \ud83d\udc4d . You're welcome \ud83d\ude04. You are very welcome! And thank you very much :)\nHaha, ok I missed the obvious and now simply return true. Yes, the processor does the same with every image but I didn't knew about the internal keys taken into account (like url etc) - so a bit overthinking on my end to make sure your cache works.\nThanks for your help!\nI am closing this, as there are no obvious performance issues. And if you stumble upon something for removing backgrounds with a Core Image filter, let me know :)\nCheers,\nFrederik. > It's just that the Equatable thing on the Processor is not that straightforward, and certainly not usual among image loaders. Any suggestions how to imporove this are welcome.\nActually I find this is a very clean approach (being protocol based). But you are right, it is a bit uncommon. It should be sufficient to include it in the docs/example at some later point. Currently the docs are a bit misleading regarding the implementation, but I was able to solve that quickly.\n\nNuke performs all processing in the background. So if it feels fast enough I think you should be ok. I'm not using (big) computers till Jan 11th, can't suggest any alternatives atm :)\n\nIt's definitely ok and was solely based out of curiosity to improve my code and learn a bit more about what's possible.\nSo take your time and enjoy the holiday seasons \ud83d\ude00. ",
    "michealc": "Thanks for that I am close to saying challenge accepted. So stepping it out;\n1. If can write a swift class that I can use in objective-c and then,\n2. Bring Nuke into the new swift class then there might be a way. Does this sound like a plan?. ",
    "Alexsmile2010": "I load the image the same size 1080h1350 and put them in a smaller proportion to imageView compressed. After the image is loaded I need it to carry out additional actions, for example to draw the text. And I need to do on the original size and not compressed. \nThank you). Thankx I will try it.. \u041c\u044b \u0436\u0435 \u043c\u043e\u0436\u0435\u043c \u0433\u043e\u0432\u043e\u0440\u0438\u0442\u044c \u043d\u0430 \u043f\u043e\u043d\u044f\u0442\u043d\u043e\u043c \u0434\u043b\u044f \u043d\u0430\u0441 \u043e\u0431\u043e\u0438\u0445 \u044f\u0437\u044b\u043a\u0435) \n. \u0423 \u043c\u0435\u043d\u044f \u0441 \u043d\u0438\u043c \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0441\u043b\u043e\u0436\u043d\u043e \u0442\u0430\u043a \u043a\u0430\u043a \u0431\u043e\u044e\u0441\u044c \u043d\u0435 \u0441\u043c\u043e\u0433\u0443 \u043e\u0431\u044a\u044f\u0441\u043d\u0438\u0442\u044c \u0441\u0443\u0442\u044c \u0432\u043e\u043f\u0440\u043e\u0441\u0430 \u0438 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b\n. \u0412 \u043e\u0431\u0449\u0435\u043c \u0441\u0443\u0442\u044c \u0432 \u0442\u043e\u043c \u0447\u0442\u043e \u044f \u043a\u043e\u0433\u0434\u0430 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044e \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443 \u0438 \u0441\u0435\u0442\u044e \u0435\u0435 \u0432 \u0442\u0430\u0440\u0433\u0435\u0442 \u0442\u043e \u043e\u043d\u0430 \u0441\u0436\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u0434\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u0442\u0430\u0440\u0433\u0435\u0442\u0430 \u0438 \u044d\u0442\u043e \u043e\u043a, \u043d\u043e \u0432 \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u043c \u043c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u0443 \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443 \u0432 \u0435\u0435 \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u0435. \u041a\u0430\u043a \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440? \u0418 \u0435\u0449\u0435, \u0438\u043d\u043e\u0433\u0434\u0430 \u043a\u043e\u0433\u0434\u0430 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0448\u044c \u0441 \u0431\u043e\u043b\u044c\u0448\u0438\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u043c \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u0430 \u0442\u043e \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u044f\u0447\u0435\u0439\u043a\u0438 \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0442 \u043f\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044c\u0441\u044f \u0432\u0438\u0434\u0438\u043c\u043e \u043f\u043e\u0441\u043b\u0435 \u0442\u043e\u0433\u043e \u043a\u0430\u043a \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u0430\u043c\u044f\u0442\u044c, \u044d\u0442\u043e \u043c\u043e\u0436\u043d\u043e \u043a\u0430\u043a \u0442\u043e \u043f\u0440\u0435\u0434\u043e\u0442\u0432\u0440\u0430\u0442\u0438\u0442\u044c? . ",
    "kaishin": "An easier, maybe stop-gap solution, would be to expose a property on Preheater to let the library user know when preheating is done. Either that or a completionHandler.. ",
    "jnutting": "I tried wrapping Nuke.Promise into PromiseKit.Promise, but couldn't really wrap my head around how to make it work. The solution you suggested above is simple enough, and I think is all I need. Thanks!. ",
    "adougies": "if let checkedUrl = URL(string: \"https://etc\") {\nNuke.loadImage(with: checkedUrl, into: imageView)\n}\nThis at least checks the URL is valid, if that helps?. ",
    "swftvsn": "Thank you for the input!\nI think the change in 5 to pass around the Nuke.Request is a good choice, as that gives more flexibility down the line.\nMy second iteration is this:\n```\nclass ProcessedCachingLoader: Nuke.Loading {\nprivate let backgroundQueue = DispatchQueue(label: \"com.example.image_cache_queue\", qos: .userInteractive, target: nil)\n\nlet backingLoader: Nuke.Loading\nlet backingDiskCache: DFCache\n\npublic init(backingLoader: Nuke.Loading, backingDiskCache: DFCache) {\n    self.backingLoader = backingLoader\n    self.backingDiskCache = backingDiskCache\n}\n\npublic func loadImage(with request: Nuke.Request, token: Nuke.CancellationToken?) -> Nuke.Promise<Image> {\n    return Nuke.Promise() { fulfill, reject in\n        backgroundQueue.async {\n\n            //Only cache processed images.\n            if request.processor != nil, let key = request.urlRequest.url?.absoluteString {\n                if let val = self.backingDiskCache.cachedObject(forKey: key) as? Image {\n                    fulfill(val)\n                    return\n                }\n            }\n\n            self.backingLoader.loadImage(with: request, token: token).completion({ (resolution) in\n                if let error = resolution.error {\n                    reject(error)\n                } else if let image = resolution.value {\n                    if request.processor != nil, let key = request.urlRequest.url?.absoluteString {\n                        self.backingDiskCache.store(image, forKey: key)\n                    }\n                    fulfill(image)\n                } else {\n                    reject(Nuke.Loader.Error.processingFailed)\n                }\n            })\n\n        }\n    }\n}\n\n}\n```\nI think this approach will work with 5 too as is, save the change to closures. What do you think about this?\nIt would also be nice to provide hooks to get from cache, and cache, the processed image. Maybe have default implementations in 5 that do nothing, but pass the processed image forward?. Thank you, again, for the input and feedback! In the end the solution is actually pretty simple and elegant, which is a testimony of good architecture.\n5 Looks to be awesome, and the upgrade process from 4 to 5 was painless.\nThanks!. I've used DFCache previously to cache images in different sizes. Is there any need to use DFCache anymore, or is the built-in way better?. And thank you for the 1) awesome lib 2) impressive time-to-answer :D \nSo I can use directly ImagePipeline.shared.loadImage(with:)?\nThe more I play with 7 the more I like it!. I'd like this feature too. Looking at the roadmap, there's something coming related to thumbnail caching. Maybe this could be altered a bit to include multiple versions cached, produced by a set (or multiple variants using multiple sets) of processors? Ie. provide multiple sets of processors and indicate which set to use for the current load, then use the rest to cache on disk.\nAnyhow, you can catch the raw data from the load and manipulate + fill caches as necessary by piggybacking the URLCache:\nswift\nclass InterceptingURLCache: URLCache {\n    override open func storeCachedResponse(_ cachedResponse: CachedURLResponse, for request: URLRequest) {\n        NukeImageService.instance.cacheData(url: request.url!.absoluteString, data: cachedResponse.data)\n    }\n    override open func storeCachedResponse(_ cachedResponse: CachedURLResponse, for dataTask: URLSessionDataTask) {\n        NukeImageService.instance.cacheData(url: dataTask.originalRequest!.url!.absoluteString, data: cachedResponse.data)\n    }\n}\nand then in url session config:\nswift\nconf.urlCache = InterceptingURLCache(memoryCapacity: 1024*1024*1024, diskCapacity: 0, diskPath: nil)\nNote to set a large memoryCapacity, as otherwise the url cache is not called at all. The example actually does not store anything to underlying cache, so no memory is consumed.\nNot pretty, but I didn't find any other way :(. Thank you for the input! It's been really helpful so far.\nThe example you gave earlier works OK, but I can't pull anything out of the existing cache, that was filled like this\nswift\nlet request = URLRequest(url: URL(string: url)!)\nlet response = URLResponse(url: request.url!, mimeType: \"image/jpeg\", expectedContentLength: data.count, textEncodingName: nil)\noriginalsDiskCache.store(CachedURLResponse(response: response, data: data), forKey: url)\nIs there any way to get that cached data to work with DataCache?. Not yet, I'm doing some other work now and continue it later. (2-4 weeks probably.) \nI think we're going to move the problematic cache to this newer one by iterating the stuff in DFCache, inserting it to the new cache and then deleting the entry in DFCache. Sleep for 50ms and process the next one. Continue as long as there are entries, and start this process in background when the app starts. \nThen we'll remove the DFCache after couple of releases and call it a day.. Hi,\nwe use Firebase (combination of realtime database + firestore) as the persistence mechanism for permanent realtime storage, but we try to avoid re-download at all costs, as that really impacts the perceived speed.. ",
    "netspencer": "I would be very interested in this . ",
    "Unihilator": "Great man) thanks. Just found resize in documentation. But didnt find it in code\n// As an alternative you can provide a target size (in pixels) yourself.\nrequest.resize(to: CGSize(width: 150, height: 150), mode: .aspectFit). Resize means exact own definition. Definitely it should sounds like downscale \ud83d\ude04 . ",
    "vpanghal": "I am getting memory warning and app is terminating after this. I see Nuke is dropping its cache on receiving memory warning but CGRaster data usage is not dropping.\nOn side note - What is cached in Nuke default cache?  Is it network fetched data/ some intermediate representation/resized image?. Hi Kean,\nThanks for these very useful pointers! As you suggested, I disabled Nuke memory caching but I still observe that CGRaster usage is growing and eventually iOS is terminating app.\nI think issue is Nuke is decoding the image in parallel and each thread race to allocates (30MB) separate mapped region to process the image . And from traces, it looks like there are seven threads. So that would initially allocate 210MB.\ne.g. Here is the allocation happen on loading image in Collection view. There are seven memory mapped region of 30MB each allocated within 3 second time window\n\n. Perfect! Decompressing/resizing images to target view size did help and I am not observing unbounded memory growth with in memory cache enabled in the Nuke.  App has around 2000s of images across multiple collection view. App is not getting memory warning and usage is capping around 200MB.\nRight now these image are scaled down to low resolution for full view. But As you suggested, I would need to have another thumbnail of the image for collection view to reduce cpu usage in decompression/resizing. Hopefully that would make user experience little better.  Thanks for all your help! Let me know if I can help anyway. Cheers :beers:. ",
    "webmaster128": "We're already using AlamofireNetworkActivityIndicator.\nSo you suggest, replacing the network layer of Nuke with Alamofire to get the activity indicator for free?. Great, thanks.\nStill, wouldn't it be good to have a handler that is always called and takes success/error/canceled as an argument? However, this issue is done.. I use a 24x24 point UIImageView on a 2x simulator (iPhone SE), which results in a 48x48 pixel screenshot.\nThanks! Now I see the default value for targetSize in Decompressor.\nI tested setting the target size via request.processor = AnyProcessor(Decompressor(targetSize: Decompressor.targetSize(for: _picture))) and added ctx.interpolationQuality = .high but this does not improve the quality.. I debugged my code and confirmed that I set targetSize to 48x48.\nUsing Tucan does not improve the quality as well. Maybe this is as good as possible using default iOS components.. Fixed it. I guess the issue was that UIImageView.bounds.size was not available by the time I created the request (after view construction but before layouting?). I get perfectly rendered images when I hardcode the target size in pixels in _picturePixelSize and do\nvar request = Nuke.Request(url: pictureUrl)\nrequest.processor = Nuke.AnyProcessor(Nuke.Decompressor(targetSize: _picturePixelSize))\nNukeManager.shared.loadImage(with: request, into: _picture)\nwith NukeManager.shared is my application's instance of Nuke.Manager\nThanks for pointing in the right direction.. ",
    "agordeev": "I use master branch version. Nope, only with my custom settings.. ",
    "HamzaGhazouani": "Hi @kean, I use Nuke of one of my project and I would like to take the image size from server, because now it's taking the size of the image view, and I have some quality problems because I don't have the same size in all the app\nNuke.loadImage(with: imageURL, into:cell.trackImageView)\nThere are an option to fix that without using Decompressor ? \nThanks. ",
    "Mezvzv": "The images come from cache, though when cell goes off screen the cell content disappears. When coming back to screen, cell content gets reloaded from cache. But I want the cell content being consistent after loading view once as in Apple's Photos App (e.g. Camera roll).\nI also use the Preheater as you suggest in demo.\nIn my code, both use Manager.shared as seen below:\npreheater = Preheater(manager: Manager.shared)\n        preheatController = Preheat.Controller(view: collectionView!)\n        preheatController.handler = { [weak self] addedIndexPaths, removedIndexPaths in\n            self?.preheat(added: addedIndexPaths, removed: removedIndexPaths)\n        }\nManager.shared.loadImage(....\nUpdate:\nActually cached images are not always used for some reason. Apparently it depends on how many rows CollectionView has and how fast you scroll.. Do you have any advice how to accomplish such behaviour like Photos app? I think this is the most common use case for large image collections in apps.\nI also tried it with DFCache, though it's even slower.. Thanks so much! I'll try different options. Yeah I load them from Firebase.. ",
    "spurdow": "wow that was fast. anyway after following your answer i got another error \nambigous reference to member loadImage(with:into:)\nim using the latest.. ```swift\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        guard let cell = tableView.dequeueReusableCell(withIdentifier: \"VehicleTableViewCell\", for: indexPath) as? VehicleTableViewCell else {\n            fatalError(\"The dequeued cell is not VehicleTable\")\n        }\n    let vehicle = aVehicles[indexPath.row]\n\n    cell.vehicle_body_plate.text = String.init(format: \"%@ %@\", vehicle.vehicle_body_name ?? \"NA\" , vehicle.vehicle_plate_num ?? \"NA\")\n    cell.vehicle_speed.text = String.init(format: \"%d kp/h\", vehicle.speed ?? \"NA\")\n    cell.vehicle_status.text = StatusUtils.getStatusText(type: vehicle.vehicle_type, vehicle: vehicle) ?? \"NA\"\n\n    cell.vehicle_driver.text = String.init(format: \"%@\", vehicle.full_name ?? \"NA\")\n    let dateFormatted = TimeUtils.dateToDateStringWithFormat(date: TimeUtils.dateStringToDate(date: vehicle.created_datetime)! )\n    cell.vehicle_last_update.text = String.init(format: \"%@\", dateFormatted!)\n\n//      cell.image_indicator.isHidden = false\n//      cell.image_indicator.startAnimating()\n        cell.image_indicator.isHidden = true\n    if vehicle.fleetcrew_photoprofile != \"NA\" {\n        let imagePath = String.init(format: Constants.IMAGE_URL, vehicle.driver_profile)\n        print(\"\\(imagePath)\")\n        var request = Request(url: URL(string: imagePath)!)\n        request.memoryCacheOptions.writeAllowed = false\n        Nuke.loadImage(with: request, into: cell.vehicle_image )\n        // error here ambigous reference to member loadImage(with:into:)\n\n//          Nuke.loadImage(with: request, into: cell){ [weak cell] response, _ in\n//              cell?.vehicle_image.image = response.value\n//              cell?.image_indicator.stopAnimating()\n//          }\n    }else{\n        cell.vehicle_image.image = UIImage(named: \"default_photo\")\n    }\n\n\n    return cell\n}\n\n```. not yet, that is why im wondering why xcode prompts me with that error message.. ",
    "thihaaung6245": "Thanks for faster support!!! Appreciated it.\nI just solved it by using this way. Removing the tableview which included GIF at each cell.\noverride func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n        tblGIF.removeFromSuperview()\n    }\nThen it went back to normal. +1 correct at confusing. So, I just used : https://github.com/onevcat/Kingfisher\nI think you need to add support for this as well. I am not saying you library wasn't great. You just share yours to make everybody easily at working with Image(Async). Even I used yours for GIF loading inside UITableView. But, to compare it with Kingfisher, it explained how do we create imagedownloader and clean the cache (Both memory and disk)\nThanks for the support m8. I will not close this until I get the answer. I will try to elaborate well when I got enough knowledge of image caching and how your library work . ",
    "olvb": "Thank you for you answer, I'll have a look at the RxNuke solution. Wouldn't it send 2 requests when the image is loaded for the first time though ? (although the second one would not load the whole data). I will investigate :). I am already using RxSwift in the app so nothing to worry here. You are right, I had overlooked that fact that with returnCacheDataDontLoad no networking will happen. \n\nCould you please elaborate?\n\nI was unclear. I meant that when the image is requested for the first time in the app's lifetime, if it is already cached then the request will stop at the 304 Not Modified, as you properly put it.. ",
    "klop": "@kean I was also thinking about the thread-safety of costLimit and countLimit. Correct me if I'm wrong, but they're the only things preventing Cache from having a fully thread-safe public interface. A potential fix would be to have private backing vars for internal use e.g. _costLimit and _countLimit, then have costLimit and countLimit implement accessors that lock appropriately. What do you think?. @kean given the tests haven't caught any problems, I think what you've said makes a lot of sense! I think it should be kept as it is for the time being.. ",
    "ealymbaev": "Strictly binding Nuke to Requests makes it quite difficult to extend. And Dependency Injection principle does not work here, as I cannot substitute any layer with my own, without binding to Request class.\nIt would be great for library if every layer could work without depending on other one. I  other words as a developer I want to be able to use Caching and Processing layers without the need of any data loading layers.\nBut you have integrated processors into Request class and also require Request class to be present in Caching and Processing layer, but they don't need any URL actually, the just transform and store images in cache.. Initially I wanted to take your library as a start point and implement all my ideas above myself, but I don't want to lose your further updates.. ",
    "igorkulman": "So it is ok to directly manipulate Nuke.Cache.shared?  Will it be also ok to create another shared Nuke.Manager with a new cache instance so I can easily clear it without affecting Nuke.Manager.shared? . ",
    "michaelnisi": "b6ccf69c92b1c1802d8b7e02998aada022c9115f added  support for both Swift 3.2 and 4.0.. I suggest to catch this earlier by adding guards, for example:\nswift\n  override final var isFinished: Bool {\n    get { return _isFinished }\n    set {\n      guard newValue != _isFinished else {\n        // Just to be extra annoying.\n        fatalError(\"Nuke Operation: already finished\")\n      }\n      willChangeValue(forKey: \"isFinished\")\n      _isFinished = newValue\n      didChangeValue(forKey: \"isFinished\")\n    }\n  }\nCasually, we might just return from the guard, but an Operation starting or finishing more than once is a programming error, don\u2018t you think, @kean?\n. Same here https://github.com/ReactiveX/RxSwift/issues/878. Thanks, Alex. I will try isPrepareForReuseEnabled.\nThe FilenameGenerator can\u2019t be the reason, the issue was already there before I changed the pipeline to use one. Good guess though, I wanted to believe that as well. Besides, I haven\u2019t seen a single collision, hashing URLs with djb2, been using it quite a bit.\nTo me, it looks more like a timing issue with the first few images loaded and/or UIKit could do something unexpected during state restoration.. The thing is, this same code path is used throughout a well tested app, but the issue only occurs sometimes after state restoration in landscape mode. I will check if scrolling to the selected row has something to do with it.. I hope I can separate it, but look what I\u2019ve found in the meantime \ud83d\udd25\nAfter populating the table view, the view controller updates the selection. Pass anything other than UITableViewScrollPosition.none and the UITableViewCell image mix-up occurs.\nswift\n tableView.selectRow(at: ip, animated: false, scrollPosition: .none) // is fine. I can isolate it to this call, selecting the table view row, scrolling to its position; even delaying it, waiting for one second, doesn\u2019t change anything, images get mixed-up.\nswift\ntableView.selectRow(at: ip, animated: false, scrollPosition: .middle) // mixed-up\n// ...before first full page scroll\nI will try to produce a demo of this, but not today\u2014onwards to other mysteries. \ud83d\ude42. Well yeah, but it\u2019s a UITableViewController, so...\nBut here\u2019s another detail I\u2019ve found, the issue starts at having three rows, below is fine. \ud83d\ude0f. Still an issue, but as I haven\u2019t got around and this is kind of esoteric, I\u2019m closing this for now. Will reopen when I get to resolving this, annoying but rare, problem. Please reopen if you find it relevant or related\u2014I\u2019ve just skimmed through another issue regarding the first few table view cells.. Getting ready for release, I fixed an indirectly/maybe related \ud83e\udd37\u200d\u2642\ufe0f Dispatch issue in the app, haven\u2019t seen this issue since.. I should have established first, Nuke.loadImage(with:, options:, into:, completion:) happens during UITableViewCell configuration in the data source, nothing special.. So, in that case, Nuke.cancelRequest(for:) would cancel the wrong request? \n\ud83d\udcaf I\u2019m glad, we were able to resolve these. Thank you for your responsiveness.. ",
    "iadxworld": "thanks for the prompt response. No they have different URL. The download is asynchronous, so any image loads first. Also, Even if the image is loaded and the tableview is scrolled, the image in the new visible cell is the older one initially, a lot of times replicated and then after 1/2 secs the original image with the correct URL is displayed.\nAnd I haven't upgraded to Nuke 6 Beta 1. \n. Yes, You were right! I missed to clear the target. Well thank you for your quick response. Highly appreciate it!\nCheers!. I migrated to Nuke 6.0 from 6.0 beta\nUpon build I am constantly getting following errors!\n'CacheKey' is inaccessible due to 'private' protection level\n'_ref' is inaccessible due to 'private' protection level\nThese are the errors in the Request.swift file. I am not quite sure how to deal with them. What is the fix for this.\n. Thats right! I had to change the compiler language in Nuke Build settings to  swift 4 from swift 3.2.\nThank for the prompt response.\n. ",
    "andreaagudo3": "\nThats right! I had to change the compiler language in Nuke Build settings to swift 4 from swift 3.2.\nThank for the prompt response.\n\nHow did u do that? I changed it in the Build Settings of my project and didnt work. ",
    "adxworld": "Go to your Pods> Build Settings> search for \"swift\". > see Swift compiler Language option > select drop down and choose preferred language. ",
    "willdahlberg": "Will do. Thank you!. ",
    "ultimate-deej": "\nI have it in my backlog, it can be added as an option to image Loader.\n\nThank you for the reply, looking forward to implementing this feature.\nSpeaking of the rate limiter, I think it will play well with cancelling disabled as well.\n. Hi @kean,\nThis indeed seems to be the best solution.. ",
    "Lee827": "Thanks for your help!!!!. ",
    "vas7n": "OK. I do not use. I will try.. ",
    "EkambaramE": "I need to directly store image, fetch the image and delete an image from a nuke.. Thanks for reply Kean, yes I'm saying images taken from the camera If allowing storing in a disk with the key. It will be great!!! \nBecause SDWebImage doing the same job:\n[[SDImageCache sharedImageCache] storeImage:image forKey:imageKey] toDisk:YES];\n. Thanks again @kean \nCan you tell me what is the usage of following code:\n```\nlet cache = Cache()\n//Store\ncache[\"key\"] = UIImage(string: \"****\")\n//Fetch\nif let image = cache[key] {\n            return image\n}\n```. ",
    "prajyot-vit": "let cachedResponse = NSURLCache.sharedURLCache().cachedResponseForRequest(imageRequest)\nI hope it helps.. ",
    "jtressle": "HI @kean,\nYou can probably close this request.  I was able to get my caching to work by doing the following:\nlet urlRequest = URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: 60)\nManager.shared.loadImage(with: Request(urlRequest: urlRequest), into: imageView)\nOn-disk caching works as expected.  I believe the issue is that Google Storage uses HTTPS links.\nThanks again,\nJan-Michael. @kean thanks for the tip!  I got it implemented.. ",
    "dclelland": "Cool, I'll put in a PR today. Cheers!. ",
    "waleeg": "Good point I should have mentioned that.\nXcode: 9.3 (9E145)\nNuke: 5.2\nSwift: 4.1\nPlatform: macOS\nI took some time to make a dummy project.  https://cl.ly/382s2r0i2B11 \nIn my own project I am using Nuke inside a NSTableView's cell. To reproduce the issue with a single image, I made a simple loop. Additionally to make sure Nuke is doing a new network request every time, I am clearing the cache.\nLet me know what you think, I might have missed something \ud83d\ude04\ud83d\udc4d. Hi Kean,\nThanks for having a look!\n\nThis error is trivial, it's just a cancellation of a task. When you call loadImage(with:into:) in a loop (not a valid use case) in 5.2 some of the requests (not all) manage to be resumed and then cancelled.\n\nThe loop was to mimic what would happen inside a cell if an NSArrayController would trigger reloads on a short interval. I was just curious if the log was considered as \"normal\" when cancelling a request. \nI will update if I find anything interesting \ud83d\udc4d \nThanks. . ",
    "sunjunkie": "Does this mean that Nuke.loadimage will be the preferred function call in 7.0? If so, then I'll leave my code unchanged.. Got it, thanks.. ",
    "AndrewBarba": "I thought about doing that but most of the images I'm using are going through a service like Imgix which has sizing params in the url so the id doesn't do me much good. Thanks for the explanation though! Will most likely stick with sha1 for now. Feel free to close or rename if you end up exploring other options. I also use Apple's pure Swift implementation of SHA256 in a few other projects, not sure if this is helpful here to lower the barrier to entry: swift-package-manager/SHA256.swift\nI just remove the init(_: ByteString) initializer and it works out of the box:\nswift\nImagePipeline.shared = ImagePipeline {\n    $0.enableExperimentalAggressiveDiskCaching { SHA256($0).digestString() }\n}. I don\u2019t have hard numbers for you, but the app I work on (recently updated to nuke 7, disk cache with sha256) has been scrolling with no hiccups at all. In the main table view there are 3 images loaded by nuke per cell and it fits 4 cells on screen. The perceived performance has been excellent. . Yes totally get it. And that\u2019s why I use Nuke over everything else :). ",
    "jeromescheer": "Great!! Thank you, that was fast! Will do if I see something \ud83d\ude09. ",
    "filipealva": "Got it. I just gave the example of URLCache cleaning because I did not find any other public API to clear aggressive disk caching. \nManually cleaning the cache is not critical for me now, so I'll give the experimental aggressive disk caching a try :) \nJust one more question: Is it safe to use aggressive disk caching on one ImagePipeline and URLCache on another one? I'm asking it because I'm planning to use the aggressive disk caching for static images and HTTP Cache for user profile images (as you suggested in your great Image Caching Guide). They will not be duplicated because I never will cache the same image using both methods, right?\nThank you for the hard work, this is a great library \ud83d\udc4d . Awesome!! \nThank you for your kind and useful answers. I'm closing the issue since I don't have more questions.. Thanks for the tips! I'm working with an user avatar, so it would be better to use HTTP Cache but since the server doesn't support it I have to deal with managing the disk cache and disabling deduplication. Even though I'm doing that, the issue is still happening. I have even tried removeAll() from DataCache but yet when I make a request after this call I have the cached image. I could not isolate the issue, it can be the server that is sending to me the old avatar or it can be the DataCache that is not clearing successfully the cache.. Forget it, I found the real issue, when manually clearing the cache I was referencing ImageCache.shared but I have a custom pipeline configuration with a different instance of ImageCache so clearing the memory cache from ImageCache.shared would not clear this image. \nThank you for the support \ud83d\udcaf . ",
    "wxforgb": "Thank you for your quick reply. \nWe will try the method you provided to us. \nThank you again.. ",
    "AssyriaGameStudio": "Hey - I have profiled it, and it's deff kingfisher that's the culprit (I actually started delving in to clean up some kingfisher code and got it running a fair bit smoother for my specific use-case, however having looked at Nuke and the benchmarks; it seemed like the better option long-term was simply to just switch over, particularly due to the reduced download time of the assets using the WebP extension).\nThanks for pointing me in the right direction :)!. Hey Kean; think I'm almost there! Just one issue I'm running into still...\nOn older devices it's taking quite a while to display a cached image (often 2-5 seconds). I gather this might be related to the decodingQueue?\nI'm going to be implementing UICollectionViewDataSourcePrefetching throughout; but are there any other ways I can improve the speed with which it gets / decodes the cached images?\nWeirdly on initial launch it's actually a better user experience, as it's pre-loads them in the background. On subsequent launches I've got it checking if they're cached ahead of trying to load them / if not it just waits until the user is entering the view containing the image before it starts loading from the cache (I assumed it'd be a few ms, but looks like I was wrong as the result is annoying delay on older devices.)\nAlternatively; is there a way to prioritise things in the decoding que so I can just bump item the user is trying to view at the specific moment to the front of the que?\nMany thanks!. Mmm ok, so I've used the metrics, and I'm getting the following in relation to one of the slower-loading images:\nTask Information {\n    Task ID - 203\n    Duration - 11:18:47.823 \u2013 11:19:00.230 (12.406s)\n    11:19:00.198 \u2013 11:19:00.229 (0.031s) - Process\n    Was Cancelled - false\n    Is Memory Cache Hit - false\n    Was Subscribed To Existing Image Loading Session - false\n}\nImage Loading Session {\n    Session Information {\n        Session ID - 88\n        Total Duration - nil\n        Was Cancelled - false\n    }\n    Timeline {\n        11:18:47.824 \u2013 nil (unknown)         - Total\n        ------------------------------------\n        nil \u2013 nil (nil)                      - Check Disk Cache\n        11:18:49.129 \u2013 11:18:49.138 (0.008s) - Load Data\n        11:18:59.525 \u2013 11:19:00.197 (0.671s) - Decode\n    }\n    Resumable Data {\n        Was Resumed - nil\n        Resumable Data Count - nil\n        Server Confirmed Resume - nil\n    }\n}\nIt looks like loading the data is fairly quick, and de-coding it is passable, however the 'Duration' is still 12.406s by the time the image (on the page I'm looking at) gets loaded... I gather this is due to the images in the que ahead of it.\nIs there a simple way to make the que progress quicker / run more stuff concurrently?\nOr would simply using a separate ImagePipeline for each \"section\" of the app likely yield some benefit . in this instance?. I am indeed using WebP images / think that's the root of the issue... If you could add the ability for it to take priority into account with decoding then that would be fantastic / a huge help... presumably then I could just re-call the loadImage with a request priority of .veryHigh in order for it to jump to the top of the que?\nBeing able to play with the maximum concurrent would also be awesome, that way I can potentially have a play and figure out the optimum concurrent tasks's for the older devices.. Ok yep; I'm thinking:\n1) I make the non-transparent images into JPG's on the server assuming they'll be decoded much quicker from the cache.\n2) There's still a lot of images that require alpha (hence using WebP for them rather than png as for alpha they're like 1/10 of the size)... So for those if I use your patch to just prioritise them if they're on screen (alongside implementing UICollectionViewDataSourcePrefetching)... Hopefully that should improve UX a fair bit.. Ok, so it's working perfectly now!\nThe patch above deff helped... That said, WebP decoding was still really slow on older devices (iPad Air 2 / iPad 4th gen etc), to the point it would often still take a few seconds to load the 10-15 WebP images I had displayed on the given page.\nFor anyone else that runs into the same issue with WebP:\nWe're basically just downloading loads of app content on launch which for the most part remains the same once downloaded. The solution for us was to add a layer of our own cacheing whereby once the WebP image is downloaded and decoded for the first time we use UIImagePNGRepresentation to cache it on disk as a png file.\nWe then used Nuke to simply load the png from local on subsequent re-opens of the app, which decodes orders of magnitude quicker than the WebP image, and even on the old devices makes it work perfectly.\nBit hacky, but it does the job well.. ",
    "zhihuitang": "Hi @kean \nTheorically, if ImagePipeline.shared.loadImage failed, it will try forever? Is my understanding correct?\n```\nfunc startPrefetchingImages(for urls: [URL]) {\n    func prefetchImage(for request: ImageRequest) {\n        ImagePipeline.shared.loadImage(with: request) { (response, error) in\n            if response == nil {\n                // Retry after 10 seconds\n                DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(10)) {\n                    prefetchImage(for: request)\n                }\n            }\n        }\n    }\nfor url in urls {\n    var request = ImageRequest(url: url)\n    request.priority = .low // Lower than regular requests\n\n    prefetchImage(for: request)\n}\n\n}\n```. seems it failed here:\n```\npublic func decode(data: Data, isFinal: Bool) -> Image? {\n        let format = ImageFormat.format(for: data)\n    guard !isFinal else { // Just decode the data.\n        let image = _decode(data)\n        if ImagePipeline.Configuration.isAnimatedImageDataEnabled, case .gif? = format { // Keep original data around in case of GIF\n            image?.animatedImageData = data\n        }\n        return image\n    }\n\n    // Determined (if we haven't yet) whether the image supports progressive\n    // decoding or not (only proressive JPEG is allowed for now, but you can\n    // add support for other formats by implementing your own decoder).\n    isProgressive = isProgressive ?? format?.isProgressive\n    guard isProgressive == true else { return nil }\n\n    // Check if there is more data to scan.\n    guard (scannedIndex + 1) < data.count else { return nil }\n\n    // Start scaning from the where we left off previous time.\n    var index = (scannedIndex + 1)\n    var numberOfScans = self.numberOfScans\n    while index < (data.count - 1) {\n        scannedIndex = index\n        // 0xFF, 0xDA - Start Of Scan\n        if data[index] == 0xFF, data[index+1] == 0xDA {\n            lastStartOfScan = index\n            numberOfScans += 1\n        }\n        index += 1\n    }\n\n    // Found more scans this the previous time\n    guard numberOfScans > self.numberOfScans else { return nil }\n    self.numberOfScans = numberOfScans\n\n    // `> 1` checks that we've received a first scan (SOS) and then received\n    // and also received a second scan (SOS). This way we know that we have\n    // at least one full scan available.\n    return (numberOfScans > 1 && lastStartOfScan > 0) ? _decode(data[0..<lastStartOfScan]) : nil\n}\n\n}\n```\ninternal func _decode(_ data: Data) -> Image? {\n    return _queue.sync {\n        #if os(macOS)\n        return NSImage(data: data)\n        #else\n        #if os(iOS) || os(tvOS)\n        let scale = UIScreen.main.scale\n        #else\n        let scale = WKInterfaceDevice.current().screenScale\n        #endif\n        return UIImage(data: data, scale: scale)\n        #endif\n    }\n}. disable isResumableDataEnabled fixed the issue.. ",
    "edon2005": "Hi,\nThank you for answer. \nSo when we set in application only: \nimport Nuke\nand make only Nuke.loadImage(with: url, into: imageView)\nwhat is default setting will be used? \nThanks you. Thank you, It is just a little unclear what an algorithm is. I mean how Nuke decide to store Image in Memory or on Disk. Or if it is possible it will store an image and in Memory and on Disk? I am a little confused, sorry. If I need to save an Images only once when application runnig for the first time and before showing? That is batch of images should be loaded before UIimageView change status to unhidden, is it possible with Nuke? . Thank you for your answer! It is helpful! . Perfect! Thanks! :). ",
    "DanielStormApps": "@michaelnisi can you provide your UITableViewDelegate implementation. This sounds like a cell reuse issue. Mainly, where is load(...) called? On orientation change do you reload your UITableView?. Can confirm that this is from cancelling prefetching, specifically ImagePreheater.stopPreheating(with: _).\nSetting OS_ACTIVITY_MODE to disable does remove the logs for me though:\n\n. @gabzsa can you share your code for fading in the new images?. ",
    "cwestMobile": "@kean Yeah it was just an incorrect implementation on my part. All good. Closing it out, thanks!. ",
    "agisilaos": "Thank you so much for all the info @kean! Since my question was answered I\u2019m gonna close this issue! Thanks again and hope you have a great day! . ",
    "j531": "Hmm, strange. I'm clearing the caches now and still getting the same result. This progress block is only being called after the image has downloaded. If the image was cached and I don't get progress reports (which would be correct), should it not load instantly (I'm still having to wait for it to appear)?\nShould this work?\n```\nclass PrototypeViewController: UIViewController {\nprivate let imageView = UIImageView()\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    ImageCache.shared.removeAll()\n    DataLoader.sharedUrlCache.removeAllCachedResponses()\n\n    view.addSubview(imageView)\n    imageView.contentMode = .scaleAspectFit\n\n    let url = URL(string: \"https://apod.nasa.gov/apod/image/1809/Broom_Pickering_milne_APODw1200.jpg\")!\n    Nuke.loadImage(with: url, into: imageView, progress: { (_, completed, total) in\n        print(completed, total)\n    })\n}\n\noverride func viewDidLayoutSubviews() {\n    super.viewDidLayoutSubviews()\n\n    imageView.frame = view.bounds\n}\n\n}\n```\nFor what it's worth, this on an iOS 11.4 iPhone 7 simulator. I'll come back to this and have a poke around if I get time.. I'm going for the Nuclear Approach now and I'm wiping the simulator and firing the request off 10 seconds after I've cleared the caches to ensure the image will be retrieved via the network. Progress reports still don't seem to be coming through :(\nFor what it's worth, the following function is only getting called once and the chunk is the entire image:\nprivate func _session(_ session: ImageLoadingSession, didReceiveData chunk: Data, response: URLResponse)\nThanks for your help!. Okay, it turned out that I had netfox enabled and it was doing some black magic behind the scenes to interfere with the request and this somehow broke progress reporting. Disabling it makes it work again.\nThanks for your help regardless!. Reporting the progress of the entire download makes the most sense to me. \nImplementation-wise I think it would be easy enough to store the expectedContentLength on the first chunk received for that task and just return that as the total from there on.\nRight now, I'm front-running the image load task with a HEAD request to get the content-length up front and using that for my calculation. Happy to leave this issue open.\nCheers. ",
    "mono0926": "Thanks for the very quick fix \ud83c\udf63\nIt works fine again in version 7.4.1 \ud83d\udc4d . ",
    "freemansion": "@shahzaibiqbal I had the same issue. I solved it writing custom DataLoading class as @kean recommended. Below is the working code:\n```\nprivate class ImageDataLoader: Nuke.DataLoading {\n    let manager: Alamofire.SessionManager\ninit() {\n    let servertTrustPolicies: [String: ServerTrustPolicy] = [\n        \"add you server address here\": .disableEvaluation\n    ]\n\n    let configuration: URLSessionConfiguration = URLSessionConfiguration.default\n    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n\n    let policyManager = ServerTrustPolicyManager(policies: servertTrustPolicies)\n    let manager = Alamofire.SessionManager(configuration: configuration, serverTrustPolicyManager: policyManager)\n    self.manager = manager\n}\n\n// MARK: DataLoading\n/// Loads data using Alamofire.SessionManager.\nfunc loadData(with request: URLRequest, didReceiveData: @escaping (Data, URLResponse) -> Void, completion: @escaping (Error?) -> Void) -> Cancellable {\n    // Alamofire.SessionManager automatically starts requests as soon as they are created (see `startRequestsImmediately`)\n    let task = self.manager.request(request)\n    task.stream { [weak task] data in\n        guard let response = task?.response else { return } // Never nil\n        didReceiveData(data, response)\n    }\n    task.response { response in\n        completion(response.error)\n    }\n    return task\n}\n\n}\nstruct ImageLoader {\n    static let default = ImageLoader()\n    private init() {\n        let pipeline = ImagePipeline {\n            $0.dataLoader = ImageDataLoader()\n        }\n        Nuke.ImagePipeline.shared = pipeline\n    }\n@discardableResult\nfunc loadImage(url: URL?,\n               options: Nuke.ImageLoadingOptions = Nuke.ImageLoadingOptions.shared,\n               into view: Nuke.ImageDisplayingView,\n               progress: Nuke.ImageTask.ProgressHandler? = nil,\n               completion: Nuke.ImageTask.Completion? = nil) -> Nuke.ImageTask? {\n\n    if let url = url {\n        return Nuke.loadImage(with: url, options: options, into: view, progress: progress, completion: completion)\n    } else {\n        view.display(image: options.placeholder)\n        return nil\n    }\n}\n\n}\n```\nBtw, thanks @kean for awesome library! API and its features as 'preheating', custom loaders etc are really cool.\n. ",
    "shahzaibiqbal": "@kean Sorry for the delayed response. Thank you for all information. Would be nice to see SSL pinning inside Nuke in future. \n@freemansion Thank you for sharing example code. it is really helpful. . ",
    "drkibitz": "I should correct myself, this doesn't cause offscreen rendering. It causes subpixel anti-aliasing.. @kean \nThe upside is avoiding sub-pixel anti-aliasing, which is my goal. (another term is misaligned images in the profiler). This isn't the worst perf offender, but is one of them, especially in image heavy applications.\nThe downside is that if the transform is done before saving to a disk cache, we would save a larger decompressed image to the cache than the source image. Though in Nuke's case, that is not a downside, because as far as I can tell, the decompression is done off the main thread, but before rendering, not before saving to cache. \n . @kean I guess to answer your question, whether or not it is the default might not be important for many people, but I think it is important to provide the option. So as with most projects, we should see how often we all actually use it to opt-in to true.. @kean That comment was taken from what was already there, changing \"Convenience initializers with targetSize and contentMode.\" to \"Convenience initializers with custom processer.\". I didn't mean anything by the comment other than just trying to repeat the pattern of the previous comment but for the custom processor parameter.. @kean Out of curiosity, what are you gaining by making the image processor objects in this library structs?. @kean also, FYI, I've updated the PR hopefully to your liking. I've taken a little liberty on the comment(s), and the init calling pattern.. ",
    "caraquri-hsakurai": "Oh, I detected how do it \ud83e\udd47 \nswift\nlet isCachedOnDisk = dataCache.cachedData(for: url.absoluteString) != nil\nthanks \ud83d\ude04 . ",
    "gabzsa": "For me, it feels strange that a UI effect is dependant on something that is completely behind the scenes for the UI, and that it has to peek behind the layers (check if an image is in cache or not) just to execute the proper effect.\n. I agree, an option would be great.. Created PR. Sorry about that. Seems to be fixed.. ```\noverride func awakeFromNib() {\n  super.awakeFromNib()\n  self.getRandomImage()\n}\n@objc private func getRandomImage() {\n  //... getting the url\n  var options = ImageLoadingOptions(transition: .fadeIn(duration: 1.0))\n  Nuke.loadImage(with: url, options: options, into: self.imageView, progress: nil, completion: { (, ) in\n    self.perform(#selector(self.getRandomImage), with: nil, afterDelay: 3.0))\n  })\n}\n```. No worries! Yeah, disabling it solves it, but of course that has some ill-effects on reusing the cells. I was not sure about the correct approach either, but my conclusion is same as yours. Ignore it when cross-fade.\nShould I PR?. ",
    "gabors": "Hi @kean, Thanks for the really cool image downloader/caching framework. Really like this one andI have tried a lot of them :)\nI see these messages as well, all of them seem to be from cancelled tasks \n_NSURLErrorFailingURLSessionTaskErrorKey=LocalDataTask <2DA11AFC-3362-4C12-A858-CEFB2C59382B>.<97>, NSLocalizedDescription=cancelled} [-999]\nCreating that OS_ACTIVITY_MODE scheme variable doesn't remove these messages.\nAre these messages normal and can be ignored?  App seems to function normally, I think these are data tasks being cancelled when you scroll quickly in collection views.\n\u0441\u043f\u0430\u0441\u0438\u0431\u043e \u0435\u0449\u0435 \u0440\u0430\u0437. Nothing really unusual. \nWBTVD Screeners by Warner Bros. https://itunes.apple.com/ca/app/wbtvd-screeners/id1265331727?mt=8\nLayout is similar to netflix. A lot of long horizontal collection views stacked in vertical table view. \nCurrent AppStore version uses AlamofireImage for downloading and caching but I wanted more control over caching and preloading that\u2019s why I\u2019m trying Nuke. . Don't kill the frameworks pls :)\nI love Carthage . @kean perfect, thanks ;). \u041f\u0440\u043e\u0441\u0442\u0438\u0442\u0435 \u0430 \"MR\" \u0435\u043d\u0442\u043e \u0447\u0442\u043e?. Looked at your code for the macOS fade transition.\nWill try to make it work.\nactually maybe can use this https://github.com/steve228uk/PeachMac/blob/master/Peach/NSImageView%2BTransition.swift. Lol. Happens. . ",
    "eonil": "Test failed for some timeout. How can I perform test again?. @kean Thanks for note.\nI have some opinions for your new approach.\n\nI don't think \"single binary for multiple platforms\" would work. Simply because different platforms needs different executable code, linking and packaging. It has many potential problems that wouldn't be visible immediately, but can crash build silently or explicitly. And in that case, it's very hard to fix such problems. AFAIK, Universal Binary is all about providing \"multiple architecture for one platform\", rather than multi-platform support.\n\nThis kind of configuration was been used as a workaround 5-6 years ago before Xcode didn't support proper library target for iOS. (no Swift, no module, no framework). There was many experiences with exotic configurations, and one of the biggest problem was Simulator. It was impossible to provide proper build settings for Simulator. Even it worked at first, it usually failed when it's been embedded into another large project.\nI wouldn't recommend or go there unless Apple officially recommends it.\n\n\n.xcconfig can be a good option if you're using many custom build settings. Though I think more custom build settings means less stable build on Apple platforms.\n\n\nIMO, framework target is unnecessary for this kind (code-only) of library. With Swift, there's no reason to make libraries as frameworks unless it needs non-code resources. IMO, it's better to erase all framework targets and keep only static library targets. It's just one target for each platforms.\n. \n\n",
    "keisukeYamagishi": "I'm sorry, it was not enough confirmation,\nClose this issues with PR.. I appreciate useful information.\nAnd for future reference.\nFor me, I thought that I should explicitly use .swift-version until that function was added.. I solved it and I will close it.. ",
    "clayellis": "Looks like the test I wrote to check if the rendering mode was successfully applied is failing. It could be a bad test \u2014 I'm open to a better way to checking that if you have any suggestions @kean. I can verify outside of a test that it's working as intended, just need a better way to actually test it.. Interesting. For my own curiosity, how do you run the test suite targeting iOS so that the iOS-specific tests run?. Great, thanks for the insight and time you put into checking on those failures. I'll look into fixes and workarounds.. ",
    "AdamBCo": "Hey @kean,\nThanks for the help on this, I really appreciate it.\nI was able to solve the issue by switching to an aggressive cache and having the ImagePipeline download the images on a background thread,\nMaybe in the future, the ImagePreheater could function as a way to start downloading images in the background.\n\nAdam. For example, if I have an application that knows all of urls for images to show throughout the application ahead of time. I could pass the ImageHeater that array and it would automatically start fetching them in the background and saving them to disk.\n\nWhen using the current version of ImagePreheater and saving them to disk, I am not seeing the images appear in the disk cache as expected.\nAs you mentioned, the ImagePreheater was meant for table/collection views, so I might be using it incorrectly.. ",
    "sinarionn": "\nIdeally I think you would use URLSessionDownloadTask to download these videos directly in some cache - maybe extend Nuke.DataCache to support it - and then play the videos directly from cache.\n\nYes, i can try to build custom DataCache (i can not extend or inherit yours - it is final and 'FilenameGenerator' is private), fill it manually with mp4 and use same instance in ImagePipeline for other supported image types, but in this case i'm losing Deduplication feature of this library, and wouldn't share same download queue. (\n. Well, looks like the only thing i need is sync version of DataCache. In this case when your code will finish it's part - i will be able to get local cached file url and pass it to player. This is the shortest way for me. I started ruining your async DataCache to feet my requirements, but maybe you already have some? ). ",
    "vmartinelli": "Hi. I usually create custom (and private) URL schemes that work together with URLProtocol subclasses. This way I can access data from various sources using URL cacheable items (Nuke cacheable as well). Hope this can help.. You're right. In addition, the data removal logic must be in the cache mechanism itself. The changes have been made.. ",
    "larryonoff": "@vmartinelli this's really great advice. Thank you!. ",
    "irace": "As of Swift 4, they can\u2019t be private because they\u2019re used as default arguments in public methods (I believe constructors in this specific case).. https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md. "
}