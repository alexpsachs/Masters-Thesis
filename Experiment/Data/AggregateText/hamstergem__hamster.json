{
    "harukizaemon": "Applied.\n. This seems to have fixed the issues. Feel free to re-open if anything is still failing.\n. Applied. Thanks.\n. Sorry it's taken so long. Have added simplecov.\n. Thanks!\n. OK, merged. I'll take a look at the List#at and see what gives.\n. See https://github.com/harukizaemon/hamster/commit/ac054ba3caf47f3c33a116a2c1917c3d4995ffc1 for a re-write that works as I believe intended.\n. Hi Trent, \n\nThanks for the pull request. I shall have a look tomorrow.\n\nSimon \n\nOn Monday, 11 June 2012 at 1:47 PM, Trent Ogren wrote:\n\n> This matches the behavior that ActiveSupport monkey patches onto Ruby's Hash.\n> \n> You can merge this Pull Request by running:\n> \n> git pull https://github.com/misfo/hamster slice-and-except\n> \n> Or you can view, comment on it, or merge it online at:\n> \n> https://github.com/harukizaemon/hamster/pull/7\n> \n> -- Commit Summary --\n> - Fix describe name\n> - Hash#slice and Hash#except\n> \n> -- File Changes --\n> \n> M lib/hamster/hash.rb (8)\n> A spec/hamster/hash/except_spec.rb (31)\n> M spec/hamster/hash/has_key_spec.rb (2)\n> A spec/hamster/hash/slice_spec.rb (31)\n> \n> -- Patch Links --\n> \n> https://github.com/harukizaemon/hamster/pull/7.patch\n> https://github.com/harukizaemon/hamster/pull/7.diff\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/harukizaemon/hamster/pull/7\n. Hey Trent, \n\nI'm so sorry I haven't got to this yet. Been a stupidly busy week. I will get to it though.\n\nThanks,\nSimon\n\nOn Monday, 11 June 2012 at 10:10 PM, Simon Harris wrote:\n\n> Hi Trent, \n> \n> Thanks for the pull request. I shall have a look tomorrow.\n> \n> Simon \n> \n> On Monday, 11 June 2012 at 1:47 PM, Trent Ogren wrote:\n> \n> > This matches the behavior that ActiveSupport monkey patches onto Ruby's Hash.\n> > \n> > You can merge this Pull Request by running:\n> > \n> > git pull https://github.com/misfo/hamster slice-and-except\n> > \n> > Or you can view, comment on it, or merge it online at:\n> > \n> > https://github.com/harukizaemon/hamster/pull/7\n> > \n> > -- Commit Summary --\n> > - Fix describe name\n> > - Hash#slice and Hash#except\n> > \n> > -- File Changes --\n> > \n> > M lib/hamster/hash.rb (8)\n> > A spec/hamster/hash/except_spec.rb (31)\n> > M spec/hamster/hash/has_key_spec.rb (2)\n> > A spec/hamster/hash/slice_spec.rb (31)\n> > \n> > -- Patch Links --\n> > \n> > https://github.com/harukizaemon/hamster/pull/7.patch\n> > https://github.com/harukizaemon/hamster/pull/7.diff\n> > \n> > ---\n> > \n> > Reply to this email directly or view it on GitHub:\n> > https://github.com/harukizaemon/hamster/pull/7\n. I certainly have no objection to adding CRUD methods as aliases for existing behaviour (and adding behaviour if necessary). Or did you mean something else?\n\nOn 21/07/2012, at 9:40 AM, 7rans wrote:\n\n> First of all, nice project. After learning a of Erlang I've sometimes wondered if Ruby too would be better if it were fully immutable.\n> \n> So while I'm here, I'd like to encourage you to consider \"CRUDifying\" the design of the classes. I know I am using the term a bit loosely, but to explain I simply mean that the methods should all depend on a core set of methods which are typically the create, read, update and delete methods (whatever the actual names might be). The advantage is that the classes become easier to subclass to create variations.  You can get a better idea about it by looking at my work on [Hashery project](https://github.com/rubyworks/hashery/blob/master/lib/hashery/crud_hash.rb).\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/harukizaemon/hamster/issues/9\n. Hi, No idea what I was thinking having values return a set! That was definitely an oversight.\n\nI'm not so sure I like the idea of keys returning other than a set though. It's always annoyed me that in Ruby it returns an array. Also, unlike Ruby's Hash, Hamster make no guarantee on ordering. I think some kind of OrderedHash could be used for that.\n\nIt should be possible to return a lazy enum for values. I haven't yet gotten around to making a lazy Hash/Set for the keys.\n\nIn any event, I'll apply your patch until I get around to making the other changes.\n. Yup. I hadn't optimised any of that. The Trie class is actually the first class I wrote\u2014as a spike\u2014and is the only one that wasn't re-written TDD. So thanks for looking into it.\n. Hey. Nice. I'm happy to open up .new. I deliberately didn't allow it until I was happy that the abstractions were stable. That said, I'd prefer the main API be Hamster.hash and .new existed primarily for anyone wanting to subclass their own. I prefer Hamster.hash over Hamster::Hash.new in code. Also, couldn't you use composition rather than inheritence to achieve what you wanted?\n. Thanks!\n. Hey Marc,\n\nThat's a very good question. I haven't looked into the experimental directory for a while. I'll do so today and see what I think.\n\nAre you using Hamster in anger, or just playing around with it?\n\nSimon\n. Hey Marc,\n\nOK so I made a start on moving stuff out of experimental and pushed it. I also added []= for you.\n\nThe next step is to build a list of tests and a list of methods that need wrapping in mutable variants.\n\nI might have a go at that later on today if I find the time. Of course, feel free to have a go yourself, although as you're not using it on any projects, I suspect your motivation is somewhat less than mine :)\n\nSimon\n. Hi. I suspect you have raised an issue on the wrong repository.\n\nCheers,\nSimon\n. Oh fascinating, yeah right! I'm guessing we need to add support for dumping and marshalling explicitly?\n. If you are doing this is IRB/Pry that's the reason. They always want to print a description to the console which causes the eager evaluation. Try this instead:\n\n``` ruby\n--> Hamster.stream{\"Hello, World\\n\"}; nil\n==> nil\n```\n\nThe extra statement on the end should cause the REPL to avoid the evaluation.\n\nAlternatively, you could do something like the following:\n\n``` ruby\n--> Hamster.stream{\"Hello, World\\n\"}.take(1)\n==> [\"Hello, World\\n\"]\n```\n. Hey, thanks for taking the time to submit a pull request. Unfortunately they are actually called \"tries\". See http://en.wikipedia.org/wiki/Hash_array_mapped_trie.\n\nCheers,\nSimon\n. I am time poor at present to write documentation but I will most certainly, gladly, accept pull requests.\n. Yes, I'd thought the same thing. Perhaps instead of (or as well as) you could nominate whether a block used in a sequence is volatile or not/expensive or not and change the caching strategy accordingly.\n. It was a while ago :)\n\nI don't recall precisely what I was getting at or even if it was a good idea. A lot of the todo items were a starting point to think about things more :)\n\nIn any case, my general principle was operations should be closed over the same type where possible or the closest hamster type where not\u2014unlike many standard Ruby operations which return Array or at best Enumerable.\n\nSo, a sorted hamster set would be ideal as it is a) sorted which is the purpose of the operation and b) closed over the interface type, namely Set. But returning a Hamster list would also be fine\u2014it's reasonable to assume that because lists are sorted, that's what you would get back.\n\nNot sure if that helps.\n. Hey all. I agree eventually it ought to be rewritten. It was the first thing I ever did and it was written as a spike. That said, it does work albeit perhaps not the easiest thing to look at :)\n\n> On 27 Aug 2014, at 1:31 am, Kurtis Rainbolt-Greene notifications@github.com wrote:\n> \n> No idea, I copied this over from @harukizaemon's list?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Nothing really. Just sheepish that it was literally the very first thing I wrote and it was mostly stream of consciousness lol.\n\n> On 27 Aug 2014, at 3:34 pm, Alex Dowad notifications@github.com wrote:\n> \n> Right now, the main part which appears hard to understand is #delete_at. Other parts could also do with a few more explanatory comments here and there. Are there any other specific parts which you feel could be improved?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Travis integration done. Build fails on 1.8.7 and 1.9 due to RVM Ruby version issues.\n\nHopefully you're able to see those builds as well being a collaborator?\n. https://travis-ci.org/harukizaemon/hamster\nhttps://coveralls.io/r/harukizaemon/hamster\nhttps://gemnasium.com/harukizaemon/hamster\nhttps://codeclimate.com/github/harukizaemon/hamster\n\nNot sure what I should be doing with gittip. Also not sure if the coveralls configuration is sufficient.\n. OK well coveralls sync is setup AFAICT.\n. Haven't looked at it but I know @dkubb reasonably well from a bunch of OSS things and he writes great stuff.\n. Hi,\n\nThanks for your contribution. It's super inspiring to have people participating.\n\nAs it happens, there is an Enumerator#to_list in core_ext, the implementation of which looks remarkably similar :) Would that do?\n\nSimon\n. Looks neat. I hadn't heard of `flat_map`. Looking at the documentation for it, could it be implemented in terms of `map` and `flatten`? For example:\n\n``` ruby\na.flap_map(&b)\n```\n\nis equivalent to:\n\n``` ruby\na.map(&b).flatten(1)\n```\n\nWould it be worth trying to implement `flatten` first then `flat_map` would be almost trivial?\n\nJust a suggestion though. I'm all for adding a working implementation first and then improving upon it as well.\n. What in particular don't you like about A?\n. Happy for you to exercise judgement. I like the idea of composing behaviour. I appreciate that not boiling the ocean is also a concern.\n\nI would probably extract the `flatten(1)` behaviour into a convenience method and comment with: Turn this into the more generic `flatten` when time permits.\n. Rub[y]cop or Rub[o]cop ?\n. Nice. Good idea.\n. FWIW, I just installed chruby which seems to have solved the compatibility issues. Happy to keep going with that for now.\n. If someone can go ahead and create it, I'll transfer ownership?\n. I think you'll need to transfer the repo or temporarily make me an admin on hamstergem in order to do so. Sorry.\n. OK transferred. Feel free to change me from administrator to contributor. Is there anything else I can usefully do to help the transfer? Things I setup recently for example that I need to shut down/transfer?\n. What do I need to do?\n. @krainboltgreene Apparently I need your email address. Shall I use the one listed on your github profile?\n. @krainboltgreene Never mind. Added you as owner.\n. Applied.\n. This seems to have fixed the issues. Feel free to re-open if anything is still failing.\n. Applied. Thanks.\n. Sorry it's taken so long. Have added simplecov.\n. Thanks!\n. OK, merged. I'll take a look at the List#at and see what gives.\n. See https://github.com/harukizaemon/hamster/commit/ac054ba3caf47f3c33a116a2c1917c3d4995ffc1 for a re-write that works as I believe intended.\n. Hi Trent, \n\nThanks for the pull request. I shall have a look tomorrow.\n\nSimon \n\nOn Monday, 11 June 2012 at 1:47 PM, Trent Ogren wrote:\n\n> This matches the behavior that ActiveSupport monkey patches onto Ruby's Hash.\n> \n> You can merge this Pull Request by running:\n> \n> git pull https://github.com/misfo/hamster slice-and-except\n> \n> Or you can view, comment on it, or merge it online at:\n> \n> https://github.com/harukizaemon/hamster/pull/7\n> \n> -- Commit Summary --\n> - Fix describe name\n> - Hash#slice and Hash#except\n> \n> -- File Changes --\n> \n> M lib/hamster/hash.rb (8)\n> A spec/hamster/hash/except_spec.rb (31)\n> M spec/hamster/hash/has_key_spec.rb (2)\n> A spec/hamster/hash/slice_spec.rb (31)\n> \n> -- Patch Links --\n> \n> https://github.com/harukizaemon/hamster/pull/7.patch\n> https://github.com/harukizaemon/hamster/pull/7.diff\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/harukizaemon/hamster/pull/7\n. Hey Trent, \n\nI'm so sorry I haven't got to this yet. Been a stupidly busy week. I will get to it though.\n\nThanks,\nSimon\n\nOn Monday, 11 June 2012 at 10:10 PM, Simon Harris wrote:\n\n> Hi Trent, \n> \n> Thanks for the pull request. I shall have a look tomorrow.\n> \n> Simon \n> \n> On Monday, 11 June 2012 at 1:47 PM, Trent Ogren wrote:\n> \n> > This matches the behavior that ActiveSupport monkey patches onto Ruby's Hash.\n> > \n> > You can merge this Pull Request by running:\n> > \n> > git pull https://github.com/misfo/hamster slice-and-except\n> > \n> > Or you can view, comment on it, or merge it online at:\n> > \n> > https://github.com/harukizaemon/hamster/pull/7\n> > \n> > -- Commit Summary --\n> > - Fix describe name\n> > - Hash#slice and Hash#except\n> > \n> > -- File Changes --\n> > \n> > M lib/hamster/hash.rb (8)\n> > A spec/hamster/hash/except_spec.rb (31)\n> > M spec/hamster/hash/has_key_spec.rb (2)\n> > A spec/hamster/hash/slice_spec.rb (31)\n> > \n> > -- Patch Links --\n> > \n> > https://github.com/harukizaemon/hamster/pull/7.patch\n> > https://github.com/harukizaemon/hamster/pull/7.diff\n> > \n> > ---\n> > \n> > Reply to this email directly or view it on GitHub:\n> > https://github.com/harukizaemon/hamster/pull/7\n. I certainly have no objection to adding CRUD methods as aliases for existing behaviour (and adding behaviour if necessary). Or did you mean something else?\n\nOn 21/07/2012, at 9:40 AM, 7rans wrote:\n\n> First of all, nice project. After learning a of Erlang I've sometimes wondered if Ruby too would be better if it were fully immutable.\n> \n> So while I'm here, I'd like to encourage you to consider \"CRUDifying\" the design of the classes. I know I am using the term a bit loosely, but to explain I simply mean that the methods should all depend on a core set of methods which are typically the create, read, update and delete methods (whatever the actual names might be). The advantage is that the classes become easier to subclass to create variations.  You can get a better idea about it by looking at my work on [Hashery project](https://github.com/rubyworks/hashery/blob/master/lib/hashery/crud_hash.rb).\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/harukizaemon/hamster/issues/9\n. Hi, No idea what I was thinking having values return a set! That was definitely an oversight.\n\nI'm not so sure I like the idea of keys returning other than a set though. It's always annoyed me that in Ruby it returns an array. Also, unlike Ruby's Hash, Hamster make no guarantee on ordering. I think some kind of OrderedHash could be used for that.\n\nIt should be possible to return a lazy enum for values. I haven't yet gotten around to making a lazy Hash/Set for the keys.\n\nIn any event, I'll apply your patch until I get around to making the other changes.\n. Yup. I hadn't optimised any of that. The Trie class is actually the first class I wrote\u2014as a spike\u2014and is the only one that wasn't re-written TDD. So thanks for looking into it.\n. Hey. Nice. I'm happy to open up .new. I deliberately didn't allow it until I was happy that the abstractions were stable. That said, I'd prefer the main API be Hamster.hash and .new existed primarily for anyone wanting to subclass their own. I prefer Hamster.hash over Hamster::Hash.new in code. Also, couldn't you use composition rather than inheritence to achieve what you wanted?\n. Thanks!\n. Hey Marc,\n\nThat's a very good question. I haven't looked into the experimental directory for a while. I'll do so today and see what I think.\n\nAre you using Hamster in anger, or just playing around with it?\n\nSimon\n. Hey Marc,\n\nOK so I made a start on moving stuff out of experimental and pushed it. I also added []= for you.\n\nThe next step is to build a list of tests and a list of methods that need wrapping in mutable variants.\n\nI might have a go at that later on today if I find the time. Of course, feel free to have a go yourself, although as you're not using it on any projects, I suspect your motivation is somewhat less than mine :)\n\nSimon\n. Hi. I suspect you have raised an issue on the wrong repository.\n\nCheers,\nSimon\n. Oh fascinating, yeah right! I'm guessing we need to add support for dumping and marshalling explicitly?\n. If you are doing this is IRB/Pry that's the reason. They always want to print a description to the console which causes the eager evaluation. Try this instead:\n\n``` ruby\n--> Hamster.stream{\"Hello, World\\n\"}; nil\n==> nil\n```\n\nThe extra statement on the end should cause the REPL to avoid the evaluation.\n\nAlternatively, you could do something like the following:\n\n``` ruby\n--> Hamster.stream{\"Hello, World\\n\"}.take(1)\n==> [\"Hello, World\\n\"]\n```\n. Hey, thanks for taking the time to submit a pull request. Unfortunately they are actually called \"tries\". See http://en.wikipedia.org/wiki/Hash_array_mapped_trie.\n\nCheers,\nSimon\n. I am time poor at present to write documentation but I will most certainly, gladly, accept pull requests.\n. Yes, I'd thought the same thing. Perhaps instead of (or as well as) you could nominate whether a block used in a sequence is volatile or not/expensive or not and change the caching strategy accordingly.\n. It was a while ago :)\n\nI don't recall precisely what I was getting at or even if it was a good idea. A lot of the todo items were a starting point to think about things more :)\n\nIn any case, my general principle was operations should be closed over the same type where possible or the closest hamster type where not\u2014unlike many standard Ruby operations which return Array or at best Enumerable.\n\nSo, a sorted hamster set would be ideal as it is a) sorted which is the purpose of the operation and b) closed over the interface type, namely Set. But returning a Hamster list would also be fine\u2014it's reasonable to assume that because lists are sorted, that's what you would get back.\n\nNot sure if that helps.\n. Hey all. I agree eventually it ought to be rewritten. It was the first thing I ever did and it was written as a spike. That said, it does work albeit perhaps not the easiest thing to look at :)\n\n> On 27 Aug 2014, at 1:31 am, Kurtis Rainbolt-Greene notifications@github.com wrote:\n> \n> No idea, I copied this over from @harukizaemon's list?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Nothing really. Just sheepish that it was literally the very first thing I wrote and it was mostly stream of consciousness lol.\n\n> On 27 Aug 2014, at 3:34 pm, Alex Dowad notifications@github.com wrote:\n> \n> Right now, the main part which appears hard to understand is #delete_at. Other parts could also do with a few more explanatory comments here and there. Are there any other specific parts which you feel could be improved?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Travis integration done. Build fails on 1.8.7 and 1.9 due to RVM Ruby version issues.\n\nHopefully you're able to see those builds as well being a collaborator?\n. https://travis-ci.org/harukizaemon/hamster\nhttps://coveralls.io/r/harukizaemon/hamster\nhttps://gemnasium.com/harukizaemon/hamster\nhttps://codeclimate.com/github/harukizaemon/hamster\n\nNot sure what I should be doing with gittip. Also not sure if the coveralls configuration is sufficient.\n. OK well coveralls sync is setup AFAICT.\n. Haven't looked at it but I know @dkubb reasonably well from a bunch of OSS things and he writes great stuff.\n. Hi,\n\nThanks for your contribution. It's super inspiring to have people participating.\n\nAs it happens, there is an Enumerator#to_list in core_ext, the implementation of which looks remarkably similar :) Would that do?\n\nSimon\n. Looks neat. I hadn't heard of `flat_map`. Looking at the documentation for it, could it be implemented in terms of `map` and `flatten`? For example:\n\n``` ruby\na.flap_map(&b)\n```\n\nis equivalent to:\n\n``` ruby\na.map(&b).flatten(1)\n```\n\nWould it be worth trying to implement `flatten` first then `flat_map` would be almost trivial?\n\nJust a suggestion though. I'm all for adding a working implementation first and then improving upon it as well.\n. What in particular don't you like about A?\n. Happy for you to exercise judgement. I like the idea of composing behaviour. I appreciate that not boiling the ocean is also a concern.\n\nI would probably extract the `flatten(1)` behaviour into a convenience method and comment with: Turn this into the more generic `flatten` when time permits.\n. Rub[y]cop or Rub[o]cop ?\n. Nice. Good idea.\n. FWIW, I just installed chruby which seems to have solved the compatibility issues. Happy to keep going with that for now.\n. If someone can go ahead and create it, I'll transfer ownership?\n. I think you'll need to transfer the repo or temporarily make me an admin on hamstergem in order to do so. Sorry.\n. OK transferred. Feel free to change me from administrator to contributor. Is there anything else I can usefully do to help the transfer? Things I setup recently for example that I need to shut down/transfer?\n. What do I need to do?\n. @krainboltgreene Apparently I need your email address. Shall I use the one listed on your github profile?\n. @krainboltgreene Never mind. Added you as owner.\n. ",
    "kef": "All failing due to undefined methods. I can take a look at these in the morning.\n. All failing due to undefined methods. I can take a look at these in the morning.\n. ",
    "tianyicui": "I fixed them for you. See #3.\n. I fixed them for you. See #3.\n. ",
    "headius": "Ahh, I see the truth of it. The power of cons!\n. Ahh, I see the truth of it. The power of cons!\n. ",
    "trans": "Something else. All the other methods must call the \"CRUD\" methods to work with the underlying data. This gives a class a small-as-possible core API.\n. Something else. All the other methods must call the \"CRUD\" methods to work with the underlying data. This gives a class a small-as-possible core API.\n. ",
    "boxxxie": "how about using clojure as reference? it does the exact same thing with conj... i don't know what the reverse of conj is, distj?\n. cool. thanks for the info.\ni'm new to ruby and didn't know of this reply behavior. \n. how about using clojure as reference? it does the exact same thing with conj... i don't know what the reverse of conj is, distj?\n. cool. thanks for the info.\ni'm new to ruby and didn't know of this reply behavior. \n. ",
    "alexdowad": "Interesting idea, but the benefits of keeping the API idiomatic and natural to Ruby developers are greater. That means making the interfaces similar to Ruby's built-in collections, wherever the operations performed are the same or analogous. That precludes making the interfaces for the different collections all the same -- Ruby's built-in Hash and Array have different interfaces, for example.\n. This has languished for 2 years now so I am closing it. Feel free to re-open.\n. Quite frankly, I don't see the usefulness of `MutableHash`. I would just use the `atomic` gem and wrap a `Hamster::Hash` in an `Atomic` object. `Atomic` already gives you a (very efficient) CAS operation.\n. YARD docs needed:\n- [x] Hash (class summary)\n- [x] Hash (individual methods)\n- [x] Set (class summary)\n- [x] Set (individual methods)\n- [x] Vector (class summary)\n- [x] Vector (individual methods)\n- [x] List (module summary)\n- [x] List (individual methods)\n- [x] SortedSet (class summary)\n- [x] SortedSet (individual methods)\n- [x] Queue (class summary)\n- [x] Queue (individual methods)\n- [x] Stack (class summary)\n- [x] Stack (individual methods)\n. The entire library now has YARD docstrings! This is a big milestone.\n. Hmm. \"Laziness by default\" is powerful (witness Haskell), but can be expensive when you don't actually need it.\n. Another perspective: in Ruby 2.0, all `Enumerable`s have a method called `#lazy`. This returns an instance of a class called `Enumerator::Lazy`. `Lazy` is itself `Enumerable`, and at least some of its methods are lazy; they also return instances of `Lazy`. When a `Lazy` needs to be converted to something \"real\", like an `Array`, only as much of the input as is needed is consumed.\n\nThe problem is that _some_ of the methods of `Lazy` are... not lazy. They force the entire input to be processed as soon as they are called. `#partition` is an example. Hamster does better here.\n\nIf Ruby's `Lazy` was fully lazy, there would be little reason for `Hamster`'s lazy lists to exist. What would remain would be the persistent data structures (which I think is really's Hamster's raison de etre).\n\nLinked lists are still a useful (and functional, persistent) data structure to provide. Though it might make more sense to just make them strict, and use Ruby's built-in `Lazy` for lazy processing of input, when it is needed.\n\nAs the built-in lazy processing features of Ruby become more developed, methods like `Hamster.iterate` may or may not remain useful. It depends whether something equivalent is added to Ruby core or not.\n\nI wouldn't want to make any drastic changes to `Hamster::List` right now. Though I think its lazy features should be deemphasized a bit when the documentation is written for the 1.0 release. Some things, like `IO#to_list`, might even be deprecated.\n\nOpinions?\n. More thoughts: our lazy lists are **far** more efficient now than they original were. Will we actually gain any significant performance from making them strict? It would be interesting to benchmark and see.\n. An interesting idea, but it doesn't seem to concord with the way `=~` is used in Ruby core (for regex match), and it is quite nebulous what \"approximate equals\" would actually mean. If you have a specific proposal, please just re-open this issue.\n. This is done as of fefdc20.\n. Are you thinking that they could use the same type of trie?\n. The type of trie used by `Vector` is inherently faster and more memory-efficient for its purpose than the more general type used by `Hash` and `Set`. If someone can find a way to unify the implementation without sacrificing efficiency, they can open a PR for that.\n. The new `Hamster::SortedSet` collection uses AVL trees internally, simply because I never understood the algorithm for deletion from red-black trees well, and it looks like a pain in the anterior to implement. I am guessing that red-black trees might provide a better balance of performance characteristics. That is complete guesswork, as zero benchmarking has been done as of yet. But I believe even \"as is\", performance will be just fine for relatively small sets. (Even for big sets, it shouldn't be terrible.)\n\nThe API also needs to be filled out a bit. Besides supporting all the methods of `Hamster::Set`, I would like to add a couple methods to bring out the strengths of this kind of tree structure. Specifically, it will support iterating over ranges well, iterating over all the items larger or smaller than a certain value, or returning the minimum or maximum value (or min/max within a certain range).\n. This is already done for `Hash` and `Set`. `Vector` is still remaining.\n. Vector initialization was made efficient in cc4dbf9 and ac495f7.\n. This is the same issue as #49.\n. The only cases I can see where this would make sense would be `Set#add`, `Set#delete`, `Vector#add`, `Stack#push`, `List#add`, and `Queue#enqueue`.\n\nHowever, there is a performance cost to doing so. Calling varargs methods is slower than calling methods which take ordinary arguments. Are you willing to accept a small performance hit?\n. For comparison, Ruby's stdlib `Set` requires the programmer to use `#merge` to add many items at once.\n. I say let's close this and open a new issue if there is sufficient popular demand.\n. I would suggest that since `Trie` is an internal, implementation-only class, and not something suitable for consumption by `Hamster` users (can I call them hamsters?), it doesn't need any extra APIs.\n. Added `#sample` with b706bd8.\n. Added `#insert` with bb21e21. I'm not sure what `#insert_by` is intended to do.\n. Checked off `#insert_by` because I have no idea what it's supposed to be. Added `List#fill`, modeled after `Array#fill`, with 94ccf70.\n. Added `List#permutation` (also `#permutations`) in 2e4cd81. The API is modeled after `Array#permutation`. This means that rather than returning a list of permutations, it _yields_ the permutations. If you want a list of them, you need `list.permutations.to_list`.\n\nOn one hand, this API doesn't seem to \"fit\" with the existing `List` methods, which almost all return lazy lists; on the other hand, it may be a good way to cut down on unnecessary allocations.\n\nI think facilitating lazy processing of sequential data is the main purpose for `List`, and both compatibility with `Array` and performance come second. After all, when people need raw performance (if there is such a thing in Ruby),  they will turn to a plain `Array`.\n\nOn the other hand, the Ruby 1.9+ pattern of iterator methods which return an `Enumerator` if called without block _does_ facilitate lazy processing, of a sort. The advantage of a lazy list over an `Enumerator` is that when working with a lazy list, you can hold on to the head and use it again later. With an `Enumerator`, once you have passed an item by, you can't go back (short of `#rewind`, which just isn't the same).\n\n`List` also has the advantage that you can `#cons` onto the front in O(1) time, and also get the `#tail` in O(1) time. But then again, I have a concept for a `Cons` class which can take _any_ `Enumerable` as its tail, and which implements the `Enumerable` API. I also have an idea for how to implement the `#tail` operation on a `Vector` efficiently. (It would mean adding another helper class, so I'm not sure if it's worth it.)\n\nWhat started here as contemplation of whether `List#permutation` should emulate `Array#permutation` is leading to the question of whether `List` is \"worth it\" at all. It might be possible to bring the strengths of `List` to _all_ sequential collections. Then, if it happened to be convenient to build up a sequence by `cons`ing, you would end up with a linked list. Otherwise, you might end up with a `Vector` or even a frozen `Array`. In all cases, you could use the `List` API for lazy processing if you wanted to.\n\nIn any case, I will finish these additions to the `List` API first.\n. Added `List#subsequences` in 96b57ab.\n. Added `List#transpose` (finishing this to-do). Also added `List#delete_at`, `#delete`, and `#rotate` (all inspired by `Array`). I think `List` is \"full-featured\" now and probably won't undergo any API changes before the next major release.\n. `Set#sample` was added in 3f68ea4. `Set#cycle` is also there. I still want to look over the API for Ruby's built-in `Set` one more time, though, and see if there are any other methods which it would be good for `Hamster::Set` to implement.\n. Added `#add?`, `#delete?`, `#disjoint?`, `#intersect?`, `#proper_superset?`, `#proper_subset?`. I think `Hamster::Set` is pretty much \"full-featured\" now. I don't plan to add any more APIs to `Set` before the 1.0 release.\n. It seems that you would get all of this just by including the `Enumerable` module. You might have to make `Hamster::Hash` yield key-value pairs wrapped in Arrays, rather than yielding the key and value as 2 separate arguments.\n. I'd suggest that Hamster::Hash should match the latest Ruby Hash API fairly\nclosely, except in places where it doesn't make sense to do so. Ruby Hashes\nare also Enumerable, so make Hamster::Hash implement the \"Enumerable\"\nmethods in a way which is close to Ruby Hash.\n\nLikewise, Hamster::Vector could be brought close to compatibility with the\nlatest Ruby Array API.\n\nOn Thu, Jun 5, 2014 at 10:18 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Argh, you know what I realize also? If our goal is API compatability we\n> have to do one of two things:\n> 1. Make a release for each Ruby version we support (hamster\n>    1.0.0+mri2.1.1)\n> 2. Only support latest Ruby Array & Hash public API.\n> \n> Thoughts? I mean we clearly can't support 1.9's Enumerable, Array, and\n> Hash at the same time.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/42#issuecomment-45192786.\n. All of these are done.\n. `#grep`, `#partition`, `#group_by_with`, `#<=>`, and `#join` have been added to `Hamster::Enumerable`. That seems like all there is right now.\n. From c693d7d..fa7dae9, I have added tests checking that various `Set` methods don't mutate `Set`s. Every method which could reasonably be suspected of mutating a `Set` is now covered by tests.\n. Tests added from ffe605d..b67148d.\n. The existing specs already check that `#clear`, `#peek`, `#pop`, and `#push` leave the original object as is. There is no other method in the `Stack` API which reasonably could modify the original object.\n. Are there issues with the coding style of the existing `Trie` class? If not, I suggest we \"don't fix what's not broken\".\n. My assessment is that while the `Trie` code isn't perfect, it isn't bad either (and the class is small). A few comments would aid understanding, but rewriting the whole class is just unnecessary work. I suggest that if any specific problems are found with the current implementation, specific GH issues can be opened and worked on.\n. Right now, the main part which appears hard to understand is `#delete_at`. Other parts could also do with a few more explanatory comments here and there. Are there any other specific parts which you feel could be improved?\n. I am having trouble understanding what the purpose of this is.\n\nCircular buffers, or queues, are normally used for memory efficiency. If each item takes a machine word, and I can guarantee there will never be more than 1000 items in my circular buffer/queue, I can allocate 8000 bytes of memory (on a 64-bit machine) and never have to grow the structure. When (for example) programming embedded devices with small memories in C/assembly, this is great. Depending on the application, you may be able to allocate all memory statically and completely avoid using `malloc` and `free`.\n\nSince Hamster collections are immutable, you have to do at least some copying with every \"modification\". There is no possibility of keeping all versions of the structure in a single, static block of memory. So I am questioning what the utility of this structure is.\n\nIs there some application for a queue with limited size which I haven't thought of?\n. To answer my own question: one application of a bounded queue is for managing load in concurrent systems, applying back-pressure, etc. If a \"producer\" component overruns its consumer, you can avoid letting the queue between them grow without limit and crash your application by A) blocking when the queue is full, or B) dropping items from the queue.\n\nHowever, if that is what you want it for, a persistent, immutable queue would be a most unusual choice. So I still think that this does not need to be in Hamster.\n. Triaging this issue; if anyone feels this requires more discussion, please re-open.\n. Done.\n. Done.\n. Done.\n. Does this offer anything over the `memoize` method which already exists in `Hamster::Immutable`?\n. Another note: `#transform` and `#transform_unless` are surprisingly slow. I have gotten worthwhile speed boosts out of `Hash`, `Set`, `Vector`, `Queue`, and `Stack` by refactoring away from the use of `#transform`. `MutableHash`, `MutableSet`, etc. still use `#transform`.\n. Are you thinking of using Adamantium just for memoization, to replace the code in `Hamster::Immutable`? Or for some other purpose?\n. If this is about automatically deep-freezing anything which is inserted into a Hamster collection, I think that is heavy-handed and unnecessary. It won't be good for performance, and in some cases, it will get in the way of people who know what they're doing and can use mutability judiciously without causing problems. As regards `Hamster::Immutable`, I haven't looked at the `memoizable` gem, but if you look at it and think it can do what is needed, and do it better than the existing code, then let's use it. If it's no better or worse than the existing code, I don't feel strongly either way but would vote to stick with what we have.\n\nIf @sporkmonger feels that what we have in Hamster right now doesn't meet his use case, please speak up and let us know what is lacking, which bringing in a new dependency can improve.\n. Triaging this issue, please re-open if there is more to say.\n. This sounds pretty good, except for creating a separate file for each and every method. This will result in an explosion of redundant test files.\n. All the specs use `let` instead of instance vars now. Also, `context` is used everywhere where it is appropriate. Almost all of the `before` blocks are gone, so that is no longer such an issue.\n. This is not a problem. The \"problem\", if you can call it that, is that `lib/hamster/enumerable.rb` is completely redundant and not needed. It offers almost nothing over Ruby's built-in `Enumerable` module. The one thing I can see that it does add is `#product` and `#sum`, but those can easily be added where they make sense, and don't require a module of their own.\n. OK, I spoke too soon. There were a few other things in `Hamster::Enumerable` that were needed. For some reason, after I deleted it, the specs were passing (don't know what I did wrong). Now they are not. I am going through the failures and seeing if they can be fixed with a few small changes here and there, without the need for an entire extra module.\n. OK, I have the specs passing again, but just need to clean up a bit before committing.\n. Just reintroduced `Hamster::Enumerable`, but without all the bloat. Everything in that file is definitely needed now. Still need to prepare a couple more commits, then everything will be fixed.\n. OK, with 544783d, this is finally all sorted out.\n. I don't think we are ready for a \"1.0\" release, and the level of stability and maturity it implies.\n- The public API is 95% there. There are just a couple things to add. Of course, if anyone can review what we have and give some feedback, that is even better.\n- I am in the midst of a full review of all the specs; updating them to @krainboltgreene's preferred style, adding tests for public API methods which are not covered, and adding more test cases for those which are.\n- DOCUMENTATION is badly needed and will be my next project after finishing the current work on the specs.\n\nA \"0.7\" release right now would be entirely appropriate. Or else another RC. @renz45, if you want to hasten things, please go through the GH issues and see if there is anything which you can contribute work (or even just opinions) to.\n. @renz45, are you currently using Hamster in \"production\"? If you can try running the current \"edge\" Hamster and see if you discover any bugs, that will help push us closer to the 1.0 release. Any feedback you have about the API will also help.\n. Interesting to hear that Code School is using our stuff... I have gone through a few of your courses (used to have an employer who provided CS subscriptions for devs).\n. I have started working towards something like this with ca60a96.\n. The next step was 749def5.\n. `List` and `Stack` are both covered as of 94adcdf.\n. `Queue` is covered with 2feca6d.\n. `Hash` is covered with 5089c7.\n\nThe only remaining \"fly in the ointment\" is `Hamster::Tuple`. `Tuple#inspect` returns a string which _cannot_ be eval'd. It could easily be changed from `(...)` to `Hamster::Tuple[...]`, but I would prefer to eliminate `Tuple` and just use frozen `Array`s. They print concisely, and are idiomatic for Ruby. (Though we might prefer that Ruby was a more functional language, it is what it is.)\n. Done!\n. Note, similar speedups could be achieved for other methods like `Hash#merge`, `Hash#except`, and so on, using the same technique.\n. No problem. Would you like me to submit a different PR, and you can close\nthis one?\n\nOn Mon, Jun 2, 2014 at 9:07 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Rebase off master plez, that should fix the test problem.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/93#issuecomment-44877903.\n. Problem is that after rebasing, I can't push (unless I merge the rebased branch back with the old one, and that would be messy). I'll open a new PR.\n. @krainboltgreene, do you still prefer `spec/lib` over just `spec`? If so, I'll finish this.\n. Done in c2821d7.\n. I noticed that Travis is failing when running the specs against JRuby. This was caused by my recent PR which differentiates Hamster::Hash#== and Hamster::Hash#eql?.\n\nThe problem is that JRuby's implementation of Array#eql? does not work like MRI's. MRI returns false if both objects are not Arrays. JRuby looks at whether the other object responds to #to_ary, and if so, it falls back to #==.\n\nThe result is that `[\"A\"].eql?(Hamster.list(\"A\"))` is true.\n\nI'm going to report this as a bug against JRuby.\n. I just sent a PR for JRuby which will fix the Hamster build if accepted:\n\nhttps://github.com/jruby/jruby/pull/1725\n. Sorry, one thing I said wrong... the broken build was not caused by the recent changes to Hamster::Hash#eql?, it was caused by slightly earlier changes to Hamster::List#eql?. In either case, I think this is clearly a bug in JRuby, not in Hamster.\n. JRuby's developer docs state that they prefer tests to be added to Rubyspec, since they use Rubyspec to determine how close they are to compatibility with MRI.\n\nI sent a PR to Rubyspec to add a test which covers this:\n\nhttps://github.com/rubyspec/rubyspec/pull/276\n\nUnfortunately, the build for my JRuby PR is failing. It doesn't seem related to the PR, though. At https://github.com/jruby/jruby, you can see that the build is also failing for JRuby \"master\".\n. If you are retracting support for MRI 1.8.7, then this PR is not needed and can be closed. If you want to support 1.8.7, I just noticed that Ruby 1.9 hash syntax will also have to be removed.\n. I would also suggest you drop 1.8.7 and close this PR.\n. It could be, I hadn't tested against 1.9.2. I will do so right now.\n\nOn Wed, Jun 25, 2014 at 3:23 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> So the tests fail in 1.9.2, is that due to your change?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/97#issuecomment-47099704.\n. It's a bug in 1.9.2. I can reproduce it entirely apart from Hamster, with\nthe following code: `[1,2,3].to_enum.next`.\n\nPerhaps a bug fix has already been applied to 1.9.3 but needs to be\nbackported to 1.9.2. I'll have a look at the MRI bug tracker. If not, and\nsearching the repo doesn't reveal anything, I'll try to fix it and send a\npatch to MRI (hopefully they accept patches for 1.9.2).\n\nOn Wed, Jun 25, 2014 at 4:11 PM, Alex alexinbeijing@gmail.com wrote:\n\n> It could be, I hadn't tested against 1.9.2. I will do so right now.\n> \n> On Wed, Jun 25, 2014 at 3:23 PM, Kurtis Rainbolt-Greene <\n> notifications@github.com> wrote:\n> \n> > So the tests fail in 1.9.2, is that due to your change?\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/pull/97#issuecomment-47099704.\n. I've done some printf-debugging of MRI 1.9.2. The crash is happening where\nit swaps the machine stack when switching to a new Fiber (Enumerators are\nimplemented using fibers).\n\nI haven't figured out all the details, but it appears that when switching\nfibers, MRI saves the entire machine stack in a buffer, and overwrites it\nwith the stack for the new fiber. Later, when it switches back to the\noriginal fiber, it copies the saved stack back in place.\n\nIt segfaults when trying to do that copy, suggesting that either the\npointer to the bottom of the machine stack, the pointer to the buffer, or\nthe calculated stack size is incorrect. I don't know which one it is.\n\nIt's weird that this hasn't been noticed and fixed already.\n\nOn Wed, Jun 25, 2014 at 4:48 PM, Alex alexinbeijing@gmail.com wrote:\n\n> It's a bug in 1.9.2. I can reproduce it entirely apart from Hamster, with\n> the following code: `[1,2,3].to_enum.next`.\n> \n> Perhaps a bug fix has already been applied to 1.9.3 but needs to be\n> backported to 1.9.2. I'll have a look at the MRI bug tracker. If not, and\n> searching the repo doesn't reveal anything, I'll try to fix it and send a\n> patch to MRI (hopefully they accept patches for 1.9.2).\n> \n> On Wed, Jun 25, 2014 at 4:11 PM, Alex alexinbeijing@gmail.com wrote:\n> \n> > It could be, I hadn't tested against 1.9.2. I will do so right now.\n> > \n> > On Wed, Jun 25, 2014 at 3:23 PM, Kurtis Rainbolt-Greene <\n> > notifications@github.com> wrote:\n> > \n> > > So the tests fail in 1.9.2, is that due to your change?\n> > > \n> > > \u2014\n> > > Reply to this email directly or view it on GitHub\n> > > https://github.com/hamstergem/hamster/pull/97#issuecomment-47099704.\n. Thanks for pointing that out. This still bugs me. But maybe it's not worth\nburning more time chasing the bug down.\n\nOn Thu, Jun 26, 2014 at 9:46 AM, Arne Brasseur notifications@github.com\nwrote:\n\n> 1.9.2 end its \"extended maintenance period\" (whatever that means) in 4\n> days, it stopped taking security fixes a year ago. I think we can safely\n> call it dead.\n> \n> https://bugs.ruby-lang.org/projects/ruby/wiki/ReleaseEngineering\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/97#issuecomment-47196880.\n. I'll try it out a bit later.\n\nOn Thu, Jun 26, 2014 at 11:54 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Just noticed Rubinius 2 is also failing, for the same reason?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/97#issuecomment-47207551.\n. No comments seem to be forthcoming, and I don't think this is really a controversial change, so I am going ahead and merging it.\n. Implemented in 0dd7b07.\n. @krainboltgreene, any comment? Do you think conforming to the built-in `Hash` API (minus the \"mutable\" part) is a good idea?\n. Rebased onto `master`, cleaned things up, and merged.\n. Well, I have one or two significant optimizations for Hamster::Hash which I\nhaven't pushed yet. Optimizations for Hamster::Vector are also coming. In\nany case, setting up benchmarks sounds like a great idea.\n\nOn Thu, Jul 3, 2014 at 7:33 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> How many more of these improvements to performance do you think will come\n> over this month?\n> \n> I'm considering setting up built in benchmarks for the CI.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/102#issuecomment-47960328.\n. No comments seem to be forthcoming, so I'm going ahead and merging.\n. Sorry, my comment appeared to be duplicated in GH, but when I tried to delete one of the duplicates, both disappeared. In short, what I said was: defensive copying (even of a Ruby `Hash` or almost any data structure at all) doesn't help if you are mutating the values stored in the structure. So the issue of whether a defensive copy is needed or not is not related to the issue of whether the values stored in the structure are mutable.\n\nHaving said that, warning people not to (figuratively) point a gun at their foot and pull the trigger is still a good idea. I would recommend the following 2 points should come out somewhere in the README:\n- While Hamster collections are immutable, you can still mutate objects stored in them. We recommend that you don't do this, unless you are sure you know what you are doing.\n- Hamster collections are thread-safe and can be freely shared between threads, but you are responsible for making sure that the objects stored in them are used in a thread-safe manner.\n\nMaybe you can write something up and send a PR?\n. @krainboltgreene already added some text to the README making this clearer.\n. Just rebased onto `master`, the specs should pass now.\n. `cherry-pick`ed onto `master` manually.\n. All 6 of the Hamster collections can be pretty-printed as of 96fae6d.\n. Good point! Just thinking about this one.\n\nOn Sun, Jul 20, 2014 at 7:50 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> require \"hamster/set\"\n> class Tags < Hamster::Set\n>   def initialize(name:, context:)\n>     @name = name\n>     @context = context\n>     @trie = EmptyTrie\n>   endend\n> Tags.new() # ArgumentError: missing keywords: name, contextTags.new(name: \"foo\") # ArgumentError: missing keywords: name, contextTags.new(name: \"foo\", context: \"bar\") # ArgumentError: missing keywords: name, context\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/114.\n. A nitpick with the example: I think that `@trie` is an implementation detail and should not be set in a subclass constructor. Rather, the subclass should call `super` with the same args that are normally passed to `new`. The point of the example still remains the same.\n\nIn answer to your question, `new` has been overridden to provide a \"friendly\" interface for users, but I still needed a way to do \"raw\" allocation of new `Set` objects internally. Right now, that is done by `alloc`, which calls `#initialize` internally.\n\nI'm trying to think of a better way to achieve this aim.\n. One really gross way to get around this problem would be to do something like `if arg.is_a? Trie` in `Set#initialize`. I don't want to do that.\n. In some (statically typed) languages, the aim could be met using an undocumented, private constructor (in addition to the public one). In Ruby, there's no such thing.\n. Got it. `Class#allocate` will do what I need. I remember learning about this method a long time ago, but I never used it and had forgotten about it until now.\n. With this fix, we have lost the desirable property of `new` that it returns the canonical empty instance when called with no arguments. `new` _always_ allocates a new object instance now. But that is the only possible way we can make `#initialize` overrideable in a way which will be intuitive for Ruby programmers at large.\n. I applied the same fix to `Hash` and `Vector` in 7f95195 and 032f282. Once I get to working on `Stack`, `Queue`, and `List`, I will make them also subclassable using the same technique.\n. Comments please!\n. @krainboltgreene, could you clarify what you mean by \"writing the reason down somewhere\"? I explain the rationale for this change in the commit comment, which can be found in the project git history using `git grep`. Do you think this information should also be in a documentation page linked to from the GH page?\n\nPerhaps when version 1.0.0 of the gem is released, all these changes can be noted in `History.rdoc` (it will be a pretty massive list).\n. Since @krainboltgreene seems to approve, I have gone ahead and merged this change. KRG, if you want anything additional to be done as regards documentation, let me know and I will do it.\n. Tell them \"Ruby already has Arrays, which can be frozen, and which are CPU\nand memory-efficient\". Tuples are most useful in statically typed\nlanguages, especially when combined with destructuring assignment and\npattern matching. In dynamically-typed Ruby, they don't do much for you.\n\nOn Sat, Jul 26, 2014 at 1:04 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> I've been wanting to add a list of all the collection types we have, with\n> more documentation for each. Hmm.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/117#issuecomment-50231140.\n. I'm not sure what the methods for adding/removing from each end of the deque should be called. By analogy with `Array`, we could use `shift`/`unshift`/`push`/`pop`. Or we could dispense with the `Array` API and come up with our own names.\n\nDoes anyone have any good ideas for method names?\n. Huh. Interesting point. Didn't think of that.\n\nOn Fri, Aug 8, 2014 at 2:35 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> I will say that I've always disliked duplicated signatures:\n> \n> queue = Queue.newqueue.enqueue(object)\n> \n> Vs\n> \n> queue = Queue.newqueue.push(object)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/118#issuecomment-51594901.\n. http://en.wikipedia.org/wiki/Double-ended_queue helpfully provides a table of names which have been used in different programming languages.\n. Going with `Array`-like interface for now. There is still room to change, if anyone comes up with a better idea.\n. Rubyspec has been useful when writing specs for methods which are not yet covered by tests. It appears there were a number of them before I started working on the specs...\n. Added more test cases for `Hash` in e6fd874..3c141c1, inspired by Rubyspec test cases.\n. Done. The only other one which needed to be fixed was `SortedSet`.\n. Added `#assoc` and `#rassoc` in 76a4bf1.\n. Added `#fetch` in bff3ba2.\n. Added `#rindex` in 5750061.\n. Added `#shuffle` in 8392b61.\n. Added `#uniq` in 57fe020, `#rotate` in 412fc6f.\n. Added `#combination` in 1fe0936.\n. Added `#repeated_combination`, `#bsearch`, `#zip`, `#values_at`, `#flatten`. Just a few more left.\n. Added `#*` in 00ec63f.\n. Added `#permutation` and `#repeated_permutation`.\n. Added `#product` in 996b02d.\n. Added `#transpose` in f7b65dc.\n. Added `#slice` in 8496bbd. `#[]` can now take `index,count` arguments or a `Range`, just like `Array#[]`. \n. Added `#insert`, `#delete_at`, `#fill`, and `#concat`. All are relatively efficient. Inserting or deleting close to the beginning of a Vector is (unavoidable) quite a bit slower than doing the same operation on an `Array`, even if you copy the array first. If you insert or delete close to the _end_ of the Vector, though, it is much faster than copying and modifying an `Array`.\n. `Vector` is now feature-complete!\n. Any suggestions what the methods for iterating over keys less-than, less-than-or-equal, etc. to a given key should be called?\n\nIf a block is provided, I intend to make these methods `yield` the appropriate items and then return `self`. If no block is provided, they will return a new `SortedSet`. This can be done quite efficiently.\n. Added `#add?`, `#delete?`, `#reverse_each`, `#clear`, `#subset?`, `#superset?`, `#proper_subset?`, `#proper_superset?`, `#sample`, `#disjoint?`, `#intersect?`, `#group_by`, `#union`, `#intersection`, `#difference`, `#exclusion`. `SortedSet` has a full `Set` interface now.\n. Added `#at`, `#[]`, `#slice`, `#delete_at`, `#fetch`, `#values_at`, `#find_index`, `#take`, `#drop`, `#take_while`, `#drop_while`. Now `SortedSet` has all the `Array`-like functionality which makes sense for it to have.\n. @krainboltgreene, the cherry on the cake will be the methods for iterating over ranges defined by a key or pair of keys (or getting back a new `SortedSet` which includes that range only). Do you have any suggestions what to call those methods?\n. Added `#above`, `#below`, `#from`, `#up_to`, `#between`. See e5d60f9..119cd81.\n. I'm not saying we need to do something like this. It is just an idea for discussion.\n\nWhen C and Java implementations of Hamster are written, the performance and (multi-threaded) scalability benefits of something like this can be had without introducing extra dependencies. If desired, pure-Ruby Hamster can be left with the poor performance/scalability of a mutex per list node. People who care about performance will use the C or Java-based gems.\n. KRG, are you OK with using the `atomic` gem? Or using atomic-swap based code in Java/C, but not in pure Ruby?\n. OK. I just sent a PR for the `atomic` gem: https://github.com/ruby-concurrency/atomic/pull/4. If it is accepted, I will be a bit more confident that this code is really thread-safe. This patch also needs some more testing. When I have more confidence in it, I will merge it in.\n. Just spent some time testing this patch. Performance is horrendously bad if there is contention to realize a lazy list, and thread which is running the block _sleeps_. This is to be expected with spinlocks -- I'll have to make the contending threads sleep on a queue while they wait. Or I might make them spin a few times before giving up and going to sleep.\n. I've just been testing and examining the code more, and feel quite confident it is right. Performance also seems good. I'm merging it now.\n. The audit is finished now. A number of new test cases have been added as a result.\n. Clojr is a very thin wrapper over core Clojure classes, and as such doesn't have anything to offer to a library which must be usable apart from the JVM. Persistent::Vector has 2 interesting things: its `Vector` has a `#pop` method which Hamster doesn't at the moment, and the vector implementation has an array called the \"tail\" for each vector. The vector trie only contains full, 32-item leaf nodes. Any items at the end which are not enough to make a new 32-item leaf are kept in a separate array called the \"tail\".\n\nThis means that when adding items at the end, you don't need to traverse the trie and copy the path to the root for each `#add`, only once for 32 `#add`s. `#pop` is also efficient. The downside is an extra test during each `#get` (to see if the desired item is in the \"tail\"), plus adding a bit of extra code to almost every method to handle the \"tail\".\n. Thank you!\n\nOn Thu, Apr 30, 2015 at 3:14 PM, Ilya Lavrov notifications@github.com\nwrote:\n\n> Should we at first add JRuby and Rubinius support to current\n> implementation? See two tasks here\n> - Make all specs green for JRuby and Rubinius\n> - Add JRuby and Rubinius to Travis\n> \n> I launched current specs for JRuby and Rubinius. For Rubinius all are\n> green. For JRuby all specs except one are green. Ready to fix this one red.\n> \n> Thank you.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/126#issuecomment-97773166.\n. From some \"real-world\" use of my own, I have discovered that we _really_ need a method for updating nested collections. Hashes of hashes of hashes, etc.\n\nWith mutable Hashes, it's not a problem -- you just drill down to the \"bottom-level\" collection, and modify it. With immutable Hashes, you then have to \"reverse your steps\", inserting each child collection into its parent, until you get up to the \"root\".\n. About 6 months has past. The `-rc3` version gem has been downloaded >1000 times. No bug reports against that version have come in. How much more time do you think we should give before shipping it?\n. I also think it's ready.\nOn Jan 21, 2015 1:25 AM, \"Dov Murik\" notifications@github.com wrote:\n\n> I think it's ready.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-70755789.\n. @krainboltgreene, can you go ahead and cut the promised 1.0.0 gem?\n. @harukizaemon @krainboltgreene @dubek @gcapizzi @ryantm @misfo @kef @cstorey @baconpat @gfredericks Thank you for your contributions toward this gem! Congrats to all on the 1.0 release!\n. Done in dae141a.\n. So you like seeing `(also #blah)` rather than an additional method listing?\n. OK, I tried to get the best of both worlds. I used a new YARD handler, so that it is not necessary to bloat the code with tons of YARD directives. The handler treats `def_delegator :self` as creating an alias, not an independent method. But if `def_delegator` is used with a target other than `:self`, it is treated as creating an independent method.\n. To be frank, personally, I feel the use of `def_delegator` rather than `alias` is a mistake. The reason is: supposedly we use `def_delegator` for inheritance, so that (for example) a subclass can redefine `#empty?`, and `#null?` will also \"automatically\" change.\n\nThere are a couple problems with this. First, maybe the subclasser didn't _want_ `#null?` to automatically change. Maybe they wanted to retain one method with the original behavior. Second, unless they read the code, there is no way they would know that our collections behave this way. Even if they like this behavior, there is no way for them to know they should override `#empty?` rather than `#null?`. Third, I think that users are unlikely to use _both_ `#empty?` and `#null?`. They will probably just pick the one they like, and use that. So having 2 methods which \"change together\" is, I believe, of little utility.\n\nHowever, the bigger issue is: do we really want so many names for the same methods? If not, then there is no question of choosing _either_ `def_delegator` or `alias`.\n. For `Hash`, I would suggest:\n- Keep both `#size` and `#length`\n- Prefer `#empty?` over `#null?`\n- Drop `#maximum` and `#minimum`\n- Drop `#+`, keep `#merge`\n- Drop `#uniq`, `#nub`, and `#remove_duplicates`? Is there any reason to keep these?\n. @dubek, since you have expressed an interest in this, do you have any opinion on the above? Would you like to code up a PR?\n. I would like to clear as much as possible before 1.0, though we have to\ntake the jump sometimes. At least let's make whatever\ncompatibility-breaking changes we have to make.\n\nOn Tue, Oct 21, 2014 at 9:49 PM, Dov Murik notifications@github.com wrote:\n\n> I don't really have a strong opinion - I just ran into this library for\n> the first time today (but I really like it!).\n> \n> I'm now working on a small performance improvement from #136\n> https://github.com/hamstergem/hamster/issues/136 . After I'm done with\n> that, I'll take a look at clearing the Hamster::Hash interface (remove the\n> unused aliases as suggested here and converting to use pure alias instead\n> of def_delegator). Are you waiting with a 1.0 release for these interface\n> changes?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-59987225.\n. As per discussion above, I have removed some unneeded aliases from `Hash` in 0dfbdac.\n. Removed unneeded method aliases from `Set` in b226952 and 57e6426. The one remaining question about `Set`: do we want both `#conj` and `#conjoin`? These methods were previously added in an attempt to create a single interface for \"adding an item\" to _any_ collection.\n\nThis is a very useful thing, but I think we just need one or the other. Which one is it going to be?\n. That's true, just `#add` would also do the trick. Most of the collections already have `#add` anyways. `#conj` is a nod to Clojure, and will be familiar to anyone who has programmed in Clojure. `#conjoin` is like `#conj` but a bit more verbose (and more readable to non-Clojure programmers).\n\n`#add` is the most understandable of all to programmers who don't use Clojure.\n\n@dubek, do you have any input?\n. The idea of adding `#conj` in the first place was that yes, you could write generic code to build up _any_ collection. I also like the idea of using `#<<`. Somehow `hash << [key, val]` doesn't look as weird as `hash.add([key, val])`.\n\nHere's another one: do we want `#head` as an alias for `#first` everywhere? I think just `#first` is enough.\n. Oh! I just found one thing which is different about `#conj` and `#<<`.\n\n`#conj` is designed to add an element in the _most efficient_ way. For a `List`, that means prepending it onto the front. But `List#<<` appends an element on the end (as people would probably expect).\n. @dubek, in Clojure, standard functions like `into` are actually implemented using `conj`, using exactly the type of polymorphism which is demonstrated by your Ruby example.\n. @krainboltgreene, OK, that makes sense. I think `#<<` should be kept for ordered collections and `Set`, since Ruby programmers are accustomed to using it. It is not needed for `Hash`.\n. Just pushed a commit which removes `#conj` and `#conjoin`. `List#add` now adds an element to the _front_ of a list (the most efficient place to do it). `#group_by_with` (which `#conj` was originally intended to support) now uses `#add` instead of `#conj`.\n\n`Hash#group_by` is now broken (there are no tests for it though). To fix it, we need to add `Hash#add`. It would be good to also add tests for `Hash#group_by`.\n. For the current implementation of `#group_by` to work, it needs to be like: `hash.add([key, value])`. Perhaps we can just add a new implementation of `Hash#group_by` and forget `Hash#add`.\n. Removed `#head` from `Set`, `Vector`, `SortedSet`, `Deque` in 3b3ba86.\n. Removed `#foreach` alias for `#each`.\n. Removed `#elem?` alias for `#include?`.\n. Removed `#forall?` alias for `#all?`.\n. Any comments on `#exist?` and `#exists?` as aliases for `#any?`? I don't think they are needed. How about `#elem_index` for `#index` or `#contains?` for `#include?`?\n. Dropped `#exist?`, `#exists?`, `#elem_index`, `#contains`. Significant change: dropped `#remove` and `#filter`. Instead of `#select` and `#reject` being aliases, they are now the original method names. (All the built-in Ruby collections use `#select` and `#reject`, not `#filter` and `#remove`.)\n. OK, here's another one. `Hamster.range(from, to)` and `Hamster.interval(from, to)` are identical methods, returning a lazy list. Which one should be \"standard\"?\n. `Deque` is a bit of a mess. The following are groups of identical methods:\n- `#first`, `#front`\n- `#last`, `#peek`\n- `#push`, `#enqueue`, `#<<`, `#add`\n- `#shift`, `#dequeue`, `#tail`\n\nAs you can tell, some of these names were chosen by analogy with `Array`, some reflect the use of the structure as a stack, some reflect its use as a queue. `#tail` reflects the way that \"shifting\" an item out of the front of the deque behaves like taking the \"tail\" of a linked list.\n. I like it! Implementing now.\n. Removed unneeded aliases from Deque.\n. I took the liberty of removing `#fold` as an alias for `#reduce`. Without `#fold`, `#foldr` seems somehow out of place, so I removed it too. We don't have anything with the behavior of `#foldr` now, but I strongly suspect that no-one will use it anyways. If someone really needs it, it is as simple as `.reverse.reduce`.\n. We have trimmed down as far as I think we want to go. There don't seem to be any redundant aliases left.\n\nThe remaining question is if we are going to keep using `def_delegator :self`, or switch to the more conventional `alias`. Opinions?\n. Which option do you prefer? @dubek, do you have any input?\n. We are now converted over to `alias`! I think this issue can be closed now.\n\nAs a side bonus, trimming down on unnecessary method aliases has made the tests run noticeably faster! Changing from `def_delegator` to `alias` made them faster still.\n. I did think of the same idea. But would you want `Deque` permanently aliased as `Stack`? Or are you thinking of that as a transitional measure?\n\nSince Hamster is coming up to a major release, which users should expect to break backwards compatibility, I'd like to clean house. If aliasing collection classes under multiple names is something we would like to do for the long term, that is fine. If not, why not go all the way to where we would really like to be?\n\nIf aliasing is a good idea, `Deque` could also be aliased as `Queue`.\n. Hmm. I am still contemplating whether providing aliases is a good idea or not. In any case, if it is later decided that it is a good idea, it is trivial to add a `stack.rb` which reads like:\n\n```\nrequire \"hamster/deque\"\nHamster::Stack = Hamster::Deque\n```\n. Added some examples for `Hamster::List` in 042e11f. There is still more to do.\n. All that is left is `List#merge`, `#merge_by`, and `#fill`. I can't think of good examples for `#merge` and `#merge_by` at the moment.\n. We have an example for `#fill`, `#merge_by` and `#merge` are still missing. But I think good enough is good enough. Closing for now.\n. Awesome, thank you!\nOn Dec 31, 2014 6:34 PM, \"Dov Murik\" notifications@github.com wrote:\n\n> I added examples for List#merge and List#merge_by.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/133#issuecomment-68452524.\n. @xaviershay, you're right, there is no reason why `Hash#put` and `Hash#store` should not be aliases. To provide some background, `#store` was added to make the interface of `Hamster::Hash` match that of Ruby's built-in `Hash`. `#put` is common to all the `Hamster` collections.\n\nAny chances of sending a PR for this one?\n. I just pushed a fix for the YARD docs for `Hamster.replicate`, you may want to pull before continuing your review.\n. _\"Include expected operation cost...\"_\n\nHmm, sounds like a good idea.\n. @xaviershay, thanks for proofreading ALL the docs for the entire project! It is impressive to see how much better you made them!\n. The GitHub README and locally-generated Yardoc README are now distinct. The FAQ has been pulled out into a separate page in both GitHub and local Yardocs.\n\nThe FAQ still needs some editing though.\n. Great work, thanks!\n. @dubek, good find! I just pushed an optimization based on this: 6813845. Rather than delegating to `#shift`, I made `#drop` use an implementation similar to `#shift`.\n. @dubek, thanks for this suggestion. Please have a look at the latest `master`.\n. @dubek, the value of `@comparator` doesn't matter for an empty sorted set; its job is to determine the order of elements, but an empty set has no elements to order. (But if you can see some case where it would make a difference, please let me know.) _However_, you do have a good point: if called on a subclass, `#drop` and `#take` should return an instance of the subclass.\n\nDo you need assertions in the \"middle\" of methods? Or would checking assertions on method entry/exit be enough? If so, I can think of a way to do it with no performance impact in \"production\". (Write a class macro which \"hooks\" a method with pre/post assertions _only_ when the tests are running.)\n. PS. Just pushed a fix for the problem you noticed with `SortedSet#take` and `#drop`.\n. OK,  now I see why we need the `@comparator` _even for_ an empty sorted set. Do you think `#clear` should do the same?\n. OK. You are absolutely right about that.\n. @dubek, right now there is no way to check if 2 `SortedSet`s have the same order. If you want to do something like that, the best I can think of would be to check if both are using the default order, and switch to the faster code if they are. (Perhaps use a single, canonical `Proc` object for the default comparator.)\n. I just experimented with loosening the balance requirements for `SortedSet`. Surprisingly, it makes insertion performance slightly _worse_.\n\nRetrospect: Since our AVL trees are immutable, each insertion means copying all the nodes to the root, at the very least. Allocating a couple more nodes here and there to rebalance the trees doesn't add much overhead on top of that. And keeping the trees in very strict balance means you don't have to traverse down as far for the next insertion.\n. I've checked off the proposed optimization for `SortedSet#delete_at`, not because I've done anything about it, but because it is too trivial to worry about.\n. While working on one of these optimizations, I just discovered and fixed 2 bugs in `SortedSet`!\n. @eigenhombre, thanks very much for pointing this out. The intention is that `Vector#uniq` should behave like `Array#uniq`, unless a strong case can be made for doing otherwise. So the question is, does  Ruby's `#uniq` always choose the first of equivalent objects? If not, the test is in error and should be removed.\n. @eigenhombre, do you mind checking how MRI's `Array` handles this?\n. I suggest we just amend the test to check equality rather than identify `if RUBY_VERSION == '2.1.0'`. In either case, Hamster is matching the behavior of Ruby's collections.\n. OK, that's a good idea. Let's do that.\n\nOn Wed, Oct 22, 2014 at 5:51 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> I'd just rather drop 2.1.0 support.\n> On Oct 21, 2014 10:46 PM, \"Alex Dowad\" notifications@github.com wrote:\n> \n> > I suggest we just amend the test to check equality rather than identify\n> > if\n> > RUBY_VERSION == '2.1.0'. In either case, Hamster is matching the\n> > behavior\n> > of Ruby's collections.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/137#issuecomment-60033026.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/137#issuecomment-60033278.\n. @egnech, thanks for reporting this issue. When you say you \"can't require and use Hamster in an app\", what do you mean? What exactly happens when you `require 'hamster'`?\n. Can you please try to remove the `\"~> 1.0\"` version requirement? Version 1.0 of Hamster has not been released yet.\n. Version 1.0 is most of the way there. Do you want to help us finish it more quickly? Have a look at the outstanding issues.\n. `Hamster.from` is interesting, I hadn't thought of anything like that. I\nthink the code would read better as `nested2.get_in('a', 'b', 'c')` rather\nthan `nested2.get_in(['a', 'b', 'c'])` -- in other words, make the\nsignature `get_in(*keys)` rather than `get_in(keys)`. Likewise for\n`update_in`.\n\nIs `#merge_deep` only for nested `Hash`es? I'm guessing the answer is yes.\n\n@krainboltgreene, what do you think about this?\n\nOn Tue, Oct 21, 2014 at 10:01 PM, Dov Murik notifications@github.com\nwrote:\n\n> I'd like to suggest adding operations for handling nested Hash and Vector\n> data structures, more or less along the lines of\n> https://github.com/facebook/immutable-js#nested-structures ; here's a\n> suggestion (following closely the immutable-js interface):\n> \n> document = { \"a\" => { \"b\" => { \"c\" => [3, 4, 5] } } }nested = Hamster.from(document)# => Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => [3, 4, 5]]]]\n> nested2 = nested.merge_deep({ \"a\" => { \"b\" => { \"d\" => 6 } } })# => Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => [3, 4, 5], \"d\" => 6]]]\n> nested2.get_in(['a', 'b', 'd'])# => 6\n> nested3 = nested2.update_in(['a', 'b', 'd']) { |value| value + 1 }# => Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => [3, 4, 5], \"d\" => 7]]]\n> \n> Basically I want to use immutable data structures (Hash, Vector) to\n> manipulate JSON-like documents.\n> \n> I'd like to here your opinions.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/140.\n. `Hamster.from` does a \"deep\" conversion of Ruby Hashes, etc to\n`Hamster::Hash`es.\n\nThis proposal seems to be influenced by Clojure -- note that `get-in` and\n`update-in` are core functions in Clojure.\n\nOn Wed, Oct 22, 2014 at 6:52 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> What's the point of Hamster.from?\n> \n> As for Hash#merge_deep I'd rather have it as a toggleable thing on\n> Hash#merge. We need to talk about merge semantics, too.\n> \n> Finally, for Hash#get_in...I like it, but we're getting close to tackling\n> http://goessner.net/articles/JsonPath/. ;)\n> \n> Overall these are things I think _need_ to be in hamster, but we're going\n> to need to talk about _how_.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/140#issuecomment-60036461.\n. The issue here isn't just `[]=`. The issue is that because Hamster collections are immutable, once you drill down to a \"leaf\" collection and insert into it, you have to \"retrace your steps\" back up to the root, inserting each \"modified\" child collection into its original parent, to get a \"modified\" parent collection.\n\nI think that we should add `#update_in`.\n. \"Is there a way to overcome this\"?\n\nYes, there is. Divide up the incoming key-value pairs into groups with the same `(hash >> @significant_bits) & 31` value; there will be 32 groups at most. Recursively use `#bulk_put` to insert each group into the correct child node.\n\nIt's unfortunate that this virtually requires initializing a new `Array` to hold the key-value pairs, and sorting the `Array` (by hash code). You can avoid initializing a new `Array` for each recursive call -- just pass down the original array, with `from` and `to` indices to delineate the range of items to be inserted.\n\nSome benchmarking would be in order, to see if this actually makes things much faster. (I wrote an implementation of `Hamster::Hash` in C once, and it made a _big_ difference in C.) Even if it does, you'll probably want to use a conditional on the number of keys, and use something like the existing code (that is, your code, from the current PR) when there are only a few.\n\nOnce that is done, it may be possible to remove `Trie#put!`.\n\nTo @krainboltgreene, I would just suggest that since `Trie` is purely internal, raw performance counts for more than nice object-oriented design. Maybe we can extract some repetitive bits of code from various methods in `Trie`, and pull them out into new methods, without impacting performance much. If so, that might help to \"trim down\" some of those big methods.\n. It's interesting to see that the current patch is most effective when merging _small_ sets or hashes. That is because it only avoids unnecessary copies of the root, not of children. I'm looking forward to see what the benchmarks look like when avoiding unnecessary copies of children as well. \n. \"Instead of sorting\"... Yes, that is better.\n. ...Or maybe the best of all would be to try both and benchmark. In any case, if you can come up with something faster than what we have now, that will be an improvement.\n. @dubek, can you push the code you are working on to a branch on GH and I can look at it?\n. @dubek, I tried working on your latest code and seeing if I could make it faster, but it's still much slower than your original commit. Sorry that my idea was a failure. I suggest that we can merge your original commit in and close this PR.\n. @dubek, I have rebased your original commit onto the latest 'master' and merged it in. Would you like to do more work on this, or call it done?\n. @dubek, thanks!!! If you want to continue optimizing `Trie`, a method for bulk deletion would also be help.\n. @krainboltgreene, can you explain more about what kind of structure this is? I guess it's more than just an ordinary mutable dictionary, with `#delete`, etc. `undef`'d?\n. Is this still an issue we want to work on? If unsure, I suggest it can be triaged.\n. Closing for now, please re-open if anyone discovers this is really needed.\n. It would just be better if we have different READMEs for GitHub and for compiled RDoc documentation. When I run RDoc on my dev PC to produce local HTML documentation, it is irritating when it contains badges.\n. It's icky, but we could duplicate the README file, and make RDoc use the\nversion without badges.\n\nOn Sat, Oct 25, 2014 at 10:38 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Ideally I'd want first class support for badges at Github, but barring\n> that...What can we do?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/149#issuecomment-60496607.\n. The fact that you have written docs and tests is great. I like both `#put_in` and `.from`, but would like to hear what @krainboltgreene thinks as well.\n. As long as it's implemented using methods which both `Hash` and `Vector` respond to, you are fine. `#put_in` uses `#fetch` and `#put`. Are both of those implemented by `Hash` and `Vector`, and with the needed semantics? If so, just copy the definition of `#put_in` into `Vector`.\n. Using an EmptyHash seems most reasonable. I personally feel that extracting\nan extra module is just gratuitous complexity at this point, though others\nmay have a different opinion. If the number of shared methods was greater\nthen a module would start to make sense.\nOn Oct 30, 2014 8:22 PM, \"Dov Murik\" notifications@github.com wrote:\n\n> And there's an assumption that if a key doesn't exist create it with\n> EmptyHash. Do you think it's reasonable to leave it this way?\n> \n> Also: maybe extract #put_in to a NestedOperations module and include it\n> both classes?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/150#issuecomment-61143698.\n. This is rather unfortunate. It would be nice to have that symmetry between `Vector`s and `Hash`es, so you can also use them polymorphically in some cases. Do you think that as a verb, `#set` sounds more natural than `#put` for a `Vector`, or just the same? Would it be a good idea to alias?\n. Maybe update_in is the best compromise.\nOn Oct 31, 2014 6:55 PM, \"Dov Murik\" notifications@github.com wrote:\n\n> Or we can leave everything as-is (Hash#put and Vector#set) and call out\n> nested method update_in (in both) to celebrate it's Clojure origin :-)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/150#issuecomment-61291911.\n. Looking good. I just commented on one line where I think you can make a performance improvement. Otherwise I can't see anything else to improve. Really good work here.\n. Merged. Thank you!\n. Looks good!\n\nJust to provide some background: I added `Hash#store` simply to match the interface of Ruby's built-in `Hash`. So, for example, if you have a library which takes a Ruby `Hash` as an argument, but doesn't mutate it, you can pass a `Hamster::Hash` instead.\n\n`Hash#store` isn't really a frequently used method for Ruby `Hash`es, so maybe it doesn't make much of a difference. Anyways, that is why it was added.\n\nThe only difference now between `#put` and `#store` is that `#put` can take a block which can be used instead of the second argument. Ruby's `Hash#store` doesn't do that, so I made a new method which duplicates the behavior of Ruby's `Hash#store`, rather than aliasing `#put`.\n\nTo be honest, I don't really care much about how aliasing `#put` affects behavior as regards inheritance. We are not providing a spec of how each method behaves under inheritance. If people want to inherit and override existing methods, it is their job to read the code and understand how it works. (Just my opinion!)\n\nI'm merging your code in now.\n. Looks good, merging.\n. Looks good, merging.\n. The only thing I can think is that _maybe_ `Hash#filter` and `Set#filter` could build up an Array of keys to remove and then `#bulk_delete` them. I'd like to see how this affects the performance characteristics of `#filter` both for large/small collections and cases where filter keeps most keys/rejects most keys.\n. Otherwise, the code looks good!\n. Looks like a win across the board! Nice work! Merging now.\n. @krainboltgreene, what do you think of giving @dubek commit rights?\n. Ooh, nice catch. Merging.\n. That failure has nothing to do with this patch. Probably my clever (?) code for lazy lists performs badly under Ruby 2.0.0. Can you open an issue for that, and I'll look into it when I have time? In the meantime, I'll merge this patch.\n. Looks good, thank you. Merging.\n. It's fine either way. People who use the gem are affected more by the gem name, not the GH organization and repo name.\n. @krainboltgreene I have a fork of this gem going called `immutable-ruby`, repo is here: https://github.com/immutable-ruby/immutable-ruby. Not sure if it will garner much attention. If you want to work on it, just say the word and I will give you commit rights.\n. But `hamster` already has existing users, and we don't want to break things for them.\n. Just pushed a fix in 2d91299. Thanks for noticing this.\n\nIf we want to add tests to make sure this doesn't happen again, they can't run in the same Ruby process as RSpec. I guess they will have to look something like:\n\n```\ncode = <<END\n  require 'hamster/set';\n  set = Hamster::Set.new([1,2,3])\n  raise 'bad' unless set.group_by { |x| x }.eql?(Hamster::Hash.new({1 => 1, 2 => 2, 3 => 3}))\nEND\n`ruby -e \"#{code}\"`\n$?.exitstatus.should == 0\n```\n\n...Does anyone have a better idea?\n. Good work, I am applying this patch. The test for `#find_index(nil)` is broken; we simply never tested this before. It doesn't work, because `nil` can't be compared with a `String`. I don't think this is something we can fix.\n. It's great you are finding this stuff. These are exactly the kind of things I want to work through before the 1.0 release.\n. The fact that a `Vector` can be extended by only 1 was deliberate; I did it that way simply because it was easier to implement. If you want to improve this, that would be great.\n\nThe point about how an empty `Vector` can't be extended is a bug, and needs to be fixed.\n. Pushed a fix with e25f564. It is still only possible to extend by 1, feel free to fix that if you like.\n. We are pushing closer and closer to a major release. Which of the remaining issues should be resolved before a new major release?\n. Do you think that an existing Hamster structure, like the immutable `Hash`, might help you implement your immutable struct? If so, you could write your own library which relies on Hamster.\n\nIn any case, I think the relationship between an immutable struct and the existing Hamster structures is weak, and it would be better to write a separate library. Small is beautiful. Adding more features bloats both code size (making the library harder to maintain) and the documentation (making it harder to learn). If those new features have some inherent synergy with the existing features, if they combine in ways that makes the whole larger than the sum of its parts, then putting them together may be a good tradeoff. Otherwise, let them go their separate ways.\n. Thanks for the report... I'm trying to duplicate it but haven't been able to yet. `0.4.3` is positively ancient -- we want to release a `1.0.0` version but were trying to get the whole library really, really right first.\n\n@krainboltgreene, what would you think of cutting a `0.9.0` gem, so people will stop using `0.4.3`?\n. Just thinking about that some more... we have already broken backward compatibility with `0.4.3`. Would releasing `0.9.0` mean that some people unintentionally get upgraded when they `bundle upgrade`, thus breaking their code?\n. @joelmccracken, we have a _ton_ of bug fixes, performance upgrades, and enhancements of every kind in edge `hamster`. The biggest thing remaining before we ship `1.0.0` is [this](https://github.com/hamstergem/hamster/issues/128). Since it seems that you are using Hamster for \"real\" work, would you be willing to upgrade to edge and see how it works for you?\n. Even for \"just\" a game, it will help. Each person will use things in a way that others might not think of, so the more people who try it, the more bugs we are likely to find.\n. Anyone else want to make your voice heard, before the axe drops? @dubek? Others?\n. One advantage of the `List` methods is that they are lazy. In any case, I don't think we can have everything. If we want everything, the library will bloat, and probably nobody will actually learn and use all those methods.\n\nSo we are looking at either the brevity of `indices`, or else make things more similar to built-in classes with `find_indices`.\n. It is lazy -- if you just need 2 of the indices, it will only scan as much as of the List as is needed to find 2. That is what the `LazyList.new { ... }` block is for -- deferring execution until needed.\n\nI've gone ahead and cut down to just `#indices` in 9dd521c.\n. In any case, @xbeta, thank you for your interest in Hamster! (And thanks to @dubek for explaining things.) If you need a mutable queue, I suggest you use the one in the Ruby standard library.\n. @xbeta, nothing is stopping 2 threads from doing those things at the same time. You can \"stop\" them by locking, just the same as with a mutable queue. Or, you have another option, which doesn't exist with a mutable queue: you can retry an atomic compare-and-swap until it succeeds. Or, your queue might exist only on the stack of one thread, meaning it can never be shared with another thread.\n. This seems really useful. Although we have tried to make Hamster collections interface-compatible with built-in Ruby collections, there are times when you want one or the other. I'm just not sure about the name `Hamster.to` -- it is symmetrical with `Hamster.from`, which is nice, but it doesn't seem to describe what it does very well.\n\n`to(arg)` implies that you are converting something to... something described by `arg`. But actually `arg` is what is being converted. That's just English grammar; it might be different in other languages, but to an English-speaking programmer, that is what the syntax brings to mind.\n. We already have `Vector#to_a`, etc. If we are missing other obviously useful conversion methods, we could think about adding them. But this is something a bit different.\n\nAny opinion from @dubek?\n. \"Stack consistency error (sp: 153, bp: 154)\" on Ruby 2.3.0dev! This\nobviously has nothing to do with @elben's code, so it won't stop it from\nbeing merged in.\n\nOn Tue, Mar 17, 2015 at 3:48 AM, Elben Shira notifications@github.com\nwrote:\n\n> Also, the Travis CI build fails on ruby-head with what seems to be an\n> interpreter bug. Know anything about this?\n> \n> https://travis-ci.org/hamstergem/hamster/jobs/54632445#L3490\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82025852.\n. I think `#to_ruby` reads better than `#to_mutable`. Is it as clear and accurate?\n. A couple comments on the `Class[]` syntax: it was chosen for symmetry with Ruby's built-in `Hash[]`, `Array[]`, and `Set[]`. (If you didn't know about these before, try them in `irb`!)\n\nPreviously, a Hamster `Hash` used the same print syntax as a Ruby `Hash`. If you use both in the same program, this meant that when printing things in `irb` or using debug print statements, you couldn't tell which was which. Also, the print syntax could not be `eval`'ed to get an equivalent structure.\n\nThe primary disadvantage of the current print syntax is its verbosity. If we could extend Ruby core syntax and add our own data structure literals, that would be better, but it's not possible (not unless immutable data structures were merged into the Ruby interpreter itself).\n. We are making progress here but there is still some work to do. Some things I can see:\n- You define a `Convertable` module and then never use it. I would suggest it can just be removed. The method is so short there's not much point in pulling it out into a mixin.\n- Making `Hamster.from` support `SortedSet` is good, but you need to `require \"hamster/sorted_set\"`. Please pull the added support for `SortedSet` in `Hamster.from` out into a single commit of its own, along with the added tests.\n- All the work related to `Hamster.to_ruby` should be squashed into a single commit. `git rebase --interactive` is your friend here.\n- In your additions to `nested/construction_spec.rb`, the description for the tests for `Hamster.to_ruby` say that it \"should return Hamster data\". It would be more correct to say it \"should return Ruby data structures\".\n. One more tiny thing is to avoid whitespace changes which are unrelated to what you are doing, since they clutter up diffs. But I can clean that up myself when merging.\n. I think you are definitely right. It should return the value shown second in the comments.\n. Everything looks nice... merging...\n. OK, merged! I did some slight cleanup (moved `require \"hamster/sorted_set\"` to the commit which involves `SortedSet`, etc.), but naturally @elben is still credited as author and commit lines and dates are the same as I fetched from his repo.\n. @elben, there are lots of ways to work on git commit history, and my ways are probably not the best at all. In many cases I would do exactly what you just described. What I just did was a bit different:\n1. Fetch from your repo.\n2. From `master`, run `git format-patch master..remotes/elben/to-nested-ruby-collection`. Now there are a bunch of `.patch` files in the working directory.\n3. Apply the first patch with `git am`.\n4. Touch things up and `git commit --amend`.\n5. Look at it with `git show` to make sure everything looks good.\n6. Apply the next patch with `git am`...\n7. Repeat until done.\n. Hmm. Thanks for bringing this point up.\n\nI hate to pull in the whole `concurrent` library, which is quite large, for this one teeny-tiny little thing. If you ever have a look at the implementation of `Atomic`, you will see it is positively trivial. But vendoring our own version of `Atomic` would also be a pain.\n\nIn our case, we use `Atomic` to make sure that each node of a lazy list will be only be realized once, on one thread. In some cases, the code which is used to realize a lazy list may have side effects, so this is important.\n\nWhat do others think about this issue?\n. So do we just bite the bullet and pull in `concurrent`? Or do we detect whether the user has already `require`d `concurrent`, and use it if it is already available?\n. If there are no other objections, shall we go ahead with @dubek's suggestion?\n. Implemented @roryokane's suggestion in 25bda8c.\n. Sure, please do! Another option: instead of setting the atomic var to fixnums like 0, 1, or 2, use symbols. I'm pretty sure it will be just as fast (but a little benchmarking would be needed to confirm that).\n. Can you confirm whether === works with the string on the left side?\n. That is what I was also getting at. The `nil`s you are seeing when examining the structure of the trie are also normal.\n. _Is there a particular reason we create big nil-filled arrays?_\n\nYes. First of all, remember the key characteristic of any data structure used to implement a \"set\": it must support a fast inclusion test. You might think that you don't often use inclusion checks on your sets, and that all you really care about is that they never contain duplicate items. But, for that \"set\" to efficiently filter out duplicates, it needs a fast inclusion test.\n\nSo how is a fast inclusion test possible? Linear search won't cut it, as soon as you have any significant number of items. You need some way to find the desired item within the structure more or less \"directly\". We do this by hashing, and using the hash code to guide our search.\n\nFor a mutable \"set\", a traditional hash table using either chaining or linear probing would work fine. BUT, our \"sets\" are immutable. That means we need a way to do fast \"copies\" when an item is added or removed. That can be achieved using a **hash trie**. In our case, it's a tree with 32-way branching, with searches in the tree being directed by extracting groups of 5 bits from a hash code. @harukizaemon's implementation has the unique property of storing up to 32 child nodes _and_ up to 32 key-value pairs in each trie node.\n\nHow do we store those 32 items? You could use 32 instance variables, but the code would be grossly long and inefficient. Using a Ruby Array is much more reasonable.\n\nIn the example you showed, the \"query\" which you inserted in the set had 10100 in the 5 low-order bits of its hash code. Since the items stored in a trie node are numbered starting from zero, that meant it had to be stored as the 21st item. Now, when an object is stored into the 21st position in a Ruby Array, the lower positions have to filled with something, and that \"something\" is `nil`. We could use some other arbitrary object, but that wouldn't gain anything.\n\nMost implementations of a 32-way hash trie would actually allocate a 32-element array for _every_ node, regardless of whether the high-order positions were used or not. In our case, we save memory by only allocating an array of the needed size.\n\nIf we wanted to optimize for memory usage for programs which use huge numbers of very small sets, we could create one \"set\" class for small sets, and one for large sets. The \"small set\" class would pack its elements in an array and use linear search. As soon as the set got larger, it would automatically be converted to the class which uses hashing. I considered doing something like this, but decided it wasn't worth the effort.\n. Regarding `===`, what you actually need to try is something like this:\n\n```\n\"GET /accounts/1\" === earhart_route\n```\n\nIf that is false, then the behavior you are seeing from `#grep` is normal and intended. Please refer to the [documentation on Enumerable#grep](http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-grep).\n. `#find` is what you are looking for.\n\nNo, `Set` is not lazy. Only `List` is. Linked lists allow for a natural and efficient \"lazy\" implementation, but most other data structures do not. For comparison, Clojure has lazy lists which you can create using `lazy-seq`, but its other built-in structures are strict. Languages like Haskell achieve laziness not by providing a full set of \"lazy\" general-purpose data structures, but by delaying the evaluation of code until its results are needed.\n. The key point to take note of is that `#grep` calls `#===` with the pattern on the _left_ side. If `\"GET /accounts/\" === earhart_route` is true, then the behavior you are seeing is definitely a bug. However, in that case, it would be a bug in MRI, not in Hamster, because we are using the built-in implementation of `Enumerable#grep`.\n. Small is beautiful! :)\n. Is there any reason why we can't define a class method called \"new\" on List?\n. OK, fair enough. Agreed.\n. I just removed `Hamster.vector`, including updating all the documentation and specs, in f444320. Will push a commit which removes `Hamster.hash` next.\n. `Hamster.hash` removed in c102c1f. Now the `Hamster` module can be used as a key in a `Hash` or similar collection. (I doubt anybody ever tried this before.)\n\nQuestion: should `Hamster::Hash.[]` be able to take a default block? With `Hamster.hash` removed, people will have to use `Hamster::Hash.new` if they want to create a `Hash` with a default block.\n. `Hamster.set` removed in 8be58e3.\n. `Hamster.sorted_set` removed in 64261e6.\n. `Hamster.deque` removed in 809b6af.\n. `Hamster.list` removed in aba0a4b.\n. `.mutable_hash`, `.mutable_set`, and `.mutable_queue` shortcut methods have also been removed. This is now done.\n. Thanks for your input. I would actually like something like `Immutable::Set`, `Immutable::Vector`, and so on. `Hamster::ImmutableCollections::Set` is too long. Unfortunately, the name the project has inherited is \"hamster\". What would other contributors think about using `Immutable` as a namespace rather than `Hamster`? (Unfortunately, there is already an `immutable` gem. Not sure what they use for names.)\n\nBy the way, @nandosola, since you actually use this library, your input on the open PRs would be appreciated.\n. I've just created a fork of this gem called [immutable-ruby](https://github.com/immutable-ruby/immutable-ruby). It's unfortunate that the \"immutable\" gemname is taken...\n\nFunctionality is basically just like Hamster, but instead of `Hamster::Hash`, it's `Immutable::Hash`, and so on. Since there is no existing user base, I have \"cleaned up\" a bit by removing a few extraneous APIs. Otherwise it's just the same.\n\nI intend to continue maintaining both `hamster` and `immutable-ruby`. Any bugs reported against one gem will be fixed in the other. However, again, since there is no installed user base for `immutable-ruby`, it is a bit freer to evolve, at least until it hits its 1.0.0 release.\n\n@nandosola, please give it a try!\n. 2 points about this one:\n1. `LazyList` is not intended to be instantiated directly. That is why it is marked as `# @private`. Any code which directly uses a class marked `# @private` is not guaranteed to work. The behavior of these classes may be changed at any time, even in a minor release.\n2. When calling `LazyList.new`, you must provide a block. The block must return something which is also a list.\n\nLists are intended to be instantiated in 3 ways:\n1. By calling class methods on the `List` module, OR\n2. By calling `#to_list` on any `Enumerable`, OR\n3. By repeatedly `#cons`ing onto the canonical empty list.\n\nIf you would like to propose a different public API for the \"list\" code, please do so. Then the various contributors can discuss whether it is better than the API we have now, and whether it can be implemented efficiently.\n. Closing due to inactivity.\n. Please see the response to #172 to understand why it behaves this way.\n. Looks good. Merged (using fast-forward to avoid unnecessary branching in history).\n. So this issue will be fixed in the next release of JRuby?\n. This is a pretty brutal limitation of JRuby. I am surprised.\n\nThe PR looks good, I'll merge it.\n. Merged with fast-forward.\n. I'm not convinced that this is a JRuby GC bug. Looking at it now, the code is clearly not thread-safe.\n\nConcurrency is limited in MRI, and you can often get away without using any explicit memory barriers (to make sure that writes are visible from another thread). JRuby allows a lot more concurrency, which is likely why we are seeing this threading bug now. (It's painfully obvious, I don't know why I didn't see it before.) \n\nI'm going to try another fix... just a minute please.\n. @dzjuck, I have just pushed a branch called `attempted_race_fix` to this repo. Can you pull it and try running the JRuby specs again?\n. Thanks to @dubek for pointing out the issue with `List#span` -- I have pushed another commit to `attempted_race_fix`. (It would be nice if we had a spec which confirmed both the problem and the fix...)\n\nThanks to @dzjuck for finding the problem in the first place, and confirming the fix.\n\nRegarding the use of `remove_instance_variable` -- I wonder what the performance impact would be? Does anyone want to try benchmarking?\n. Well, it does use a Ruby method call, which must go through the (relatively slow) method dispatch mechanism.\n. Since the `attempted_race_fix` branch seems to have fixed the problem, and this thread has been quiet for a couple of days, I'm merging it in. Any other desired modifications can be done as new commits.\n. Looks good.\n. Merged.\n. Thank you for reporting this issue. A fix for the problem with\nSymbol#to_proc has been pushed to master (along with a regression test).\n\nYou are very right about the block being called more times than expected.\nWhat do you think is the most useful behavior here? Does it matter to you\nthat the block should only be called once? Or would just adjusting the\ndocumentation be enough?\n\nOn Mon, Jun 8, 2015 at 10:44 PM, Dov Murik notifications@github.com wrote:\n\n> Good catch!\n> \n> Indeed modifying the arity condition in\n> https://github.com/hamstergem/hamster/blob/master/lib/hamster/sorted_set.rb#L103\n> to:\n> \n> if block.arity <= 1\n> \n> fixes the problem (both with the &:name syntax and the weird |*a| block).\n> \n> I'm not sure about the promises about the number of times the block is\n> called.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/179#issuecomment-110132914.\n. OK, sounds good. I'll work on a patch.\n\nOn Wed, Jun 10, 2015 at 6:40 PM, Rafael Cabral Coutinho <\nnotifications@github.com> wrote:\n\n> I think it would be desirable that the behavior followed Array#sort_by.\n> Less surprising, and a better option for expensive key computations, since\n> currently there's no difference in using #sort or #sort_by for such keys.\n> Then, the docs are fine.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/179#issuecomment-110827061.\n. Fixed in 50eaf97. @rcabralc, please check whether the fix works for you and re-open this issue if not.\n. `Hamster::Vector.new` is different from the other 3 because it always initializes a new collection.\n\n`Hamster.vector` was supposed to be a shortcut to make initializing a vector more concise, like `Hamster.vector(1,2,3)`. I think this is redundant; people can define their own shortcuts if they want to. At the same time, you can get the canonical empty vector with `Hamster.vector`. But that doesn't communicate very well what it is doing. `Hamster::Vector.empty` or `Hamster::EmptyVector` is clearer.\n\n`Hamster::EmptyVector` is needed, because we need somewhere to store the canonical empty vector. (Well, a class variable could also be used.) But it could be marked `# @private` and not included in the official public API.\n\n`Hamster::Vector.empty` has the advantage of polymorphism; you can do something like `collection.class.empty` and get an empty collection of the same type as one which you already have. But we have `#clear` for that, and it can easily be reimplemented to avoid using `empty` if we want to remove it.\n. Dropping `Hamster.vector` is a good idea.\n\nPolymorphism _could_ be useful, but not for inheritance. Where it comes in handy is when creating generic collection-manipulating functions which can operate on any type of collection, and return the same type which is passed in. This is fairly common in Clojure. Though, as I said, you could remove `Vector.empty`, and this could still be done using `Vector#clear`. The only difference would be that rather than being implemented using `empty`, `#clear` would have a separate implementation for each collection type.\n. The `EmptyVector` (etc.) constants are now all marked as private. So they are now implementation details, not part of the API. The shortcut methods like `Hamster.vector` have all been removed.\n\nThat leaves us with `Vector.new` and `Vector.empty` which both return an empty collection. I think this resolves the issue of too many redundant API methods.\n. Wow, this is just the kind of thing I was hoping for when I opened this issue. Nice! Note that \"syntax\" is not a countable noun -- \"a syntax\" sounds strange.\n. \"data structure\" is 2 words, not 1.\n. \"Otherwise\", not \"Otherwie\".\n. \"calling the block with the key\", not \"called the block with the key\".\n. OK, I think this is good to merge. The one thing is that the documentation for `#to_ruby` is not quite accurate -- it says \"no Hamster structures will remain\", but `#to_ruby` doesn't convert `Hamster::Deque` into core Ruby structures. (Sounds like something we should fix...)\n. Merged. @xaviershay, thanks for your contribution. Please work on the docs for the other classes if you can.\n. I just fixed `Hamster.to_ruby` so it also converts `Hamster::Deque` structures.\n. Fixed. @xaviershay, thank you for reporting this issue! Your contribution is much appreciated.\n. Hmm. Do we really want to fix this?\n\nYour docs state: \"Behaviour is undefined when elements do not meet assumptions (i.e. are not indexable collections).\"\n\nI'm happy to leave this as \"undefined\". Or if you think it's better to match `Array` more closely, that is also fine.\n\nWhat MRI does: check whether each element is an `Array` (**or** is convertible to an `Array` using `#to_ary`), check whether it contains at least one item, and _only then_ compare the items, using `#==`. Any elements which do not pass the first 2 checks are ignored.\n\nThe docs should probably specify that `#==` is used for comparison.\n. @xaviershay, please have a look at the following branch:\n\nhttps://github.com/hamstergem/hamster/compare/vector_assoc_skips_bad_elements\n\nLook good?\n. I'd sooner let that fall under the umbrella of \"undefined behavior\". :smile:\n. 2 nice catches (both this and #183). Do you intend to fix both of these, or would you like me to?\n. Sounds good. Can you come up with an example where `Array#transpose` works but `Vector#transpose` doesn't?\n. Looking at this again, I don't think that calling `#to_ary` on all the sub-vectors is really desirable. It will add performance cost for no real gain.\n\nHave a look at this and see if you think it makes things better: https://github.com/alexdowad/hamster/commit/846b5889afbb19b396d811065f72adb08654c827\n. `to_ary` is used for implicit conversion... to a Ruby array. In some cases, when the Ruby interpreter wants an `Array`, but finds something else, it will call `#to_ary` on it and expect to get an `Array` back. So `#to_ary` needs to return an `Array`.\n\nIf there's something I'm missing, feel free to re-open this issue.\n. I see. That performance issue is a concern -- we want everything to be as fast as is practicable. But breaking `#to_ary` to make `#transpose` faster is not an option.\n\nRegarding \"implicit\" conversion to `Array`, that just means that the Ruby interpreter _internally_ converts an object to an `Array`. To see where and why this is done, consult the MRI code. (If you've never dug into it before, it's not that bad.)\n. Cool, sounds good.\n. Made this change to `Vector#uniq` in 1a73f23.\n. Wow, wow, wow. I didn't notice you had added so much here. Let me look through.\n. This was a lot of work! Thank you!! Let me go ahead and cherry-pick everything which is ready for merging right now.\n. I've merged most of these commits. Will comment on the ones which are not merged yet tomorrow. Thanks!!\n. Just added some more feedback.\n. OK, I've merged the last 3 commits (with a couple tiny edits). Thank you!! Great job!!\n. Just duplicated this with 2.3.0-dev. \"Stack consistency error (sp: 47, bp: 48)\". Intriguing!\n. I have a Ruby interpreter which I have built with full debug info, which makes the stack trace much better:\n\n```\n-- C level backtrace information -------------------------------------------\n/home/alex/Software/ruby/ruby(rb_vm_bugreport+0x51f) [0x55e28ea69acf] vm_dump.c:695\n/home/alex/Software/ruby/ruby(rb_bug+0xca) [0x55e28ead4f8a] error.c:414\n/home/alex/Software/ruby/ruby(vm_exec_core+0x59a6) [0x55e28ea5b856] insns.def:1031\n/home/alex/Software/ruby/ruby(vm_exec+0x72) [0x55e28ea5b902] vm.c:1472\n/home/alex/Software/ruby/ruby(invoke_block_from_c+0x5d4) [0x55e28ea5c634] vm.c:850\n/home/alex/Software/ruby/ruby(rb_yield+0x68) [0x55e28ea5c9e8] vm.c:888\n/home/alex/Software/ruby/ruby(rb_ary_each+0x3d) [0x55e28ea8609d] array.c:1820\n```\n. I've found what is causing this error. It would be nice if it was just a simple coding error, but unfortunately it seems to be more of a conceptual error in the design of the block-calling and argument-passing mechanism. If only I could wrap my mind around the right way to fix it up...\n. OK, sigh of relief. It seems that the fix wasn't as tricky as I had thought. Have a look: https://bugs.ruby-lang.org/issues/11451\n\n@xaviershay, I seriously doubted that this had anything to do with https://bugs.ruby-lang.org/issues/11071, but it turns out you were right! My patch also fixes that one.\n. @xaviershay, I said it in the Ruby core bug tracker, but I'll say it here too: thanks for reporting this problem!\n\nIf and when you run across a similar problem in the future, try to eliminate all gems and get a repro script which uses only core Ruby. You can do this by repeatedly inlining gem method calls (by hand), and checking each time to see if the problem still occurs (and backing up if it doesn't).\n\nAfter each inlining, you will usually be able to delete some unneeded code and simplify what remains. After each change, check again to see if the script still crashes or not. If inlining makes the crash \"disappear\" -- in other words, if the method call itself is part of the problem -- just copy-and-paste the gem code into the repro script. Then remove as much as you can, while checking that the crash still occurs.\n\nYour repro script was already quite small, which was a big help. But I reduced it further down to this:\n\n``` ruby\nclass Yielder\n  def each\n    yield [1,2]\n  end\nend\n\nclass Getter1\n  include Enumerable\n\n  def each(&block)\n    Yielder.new.each(&block)\n  end\nend\n\nclass Getter2\n  include Enumerable\n\n  def each\n    Yielder.new.each { |a,b| yield(a) }\n  end\nend\n\nGetter1.new.map { Getter2.new.map {} }\n```\n\n`Yielder` was originally `Hamster::Trie`, `Getter1` was `Hamster::Hash`, and `Getter2` was `Hamster::Set`. The core Ruby devs will appreciate it if they don't have to wade through 1000s of lines of gem code to track down a crash. (More realistically, they may actually look into it rather than ignoring it.)\n. So, having said all that, now we can look at fixing up Hamster. I would suggest that we apply @xaviershay's fix, _with a comment_ stating that the modified code is for MRI 2.2.2 compatibility and that the change will be reverted when 2.2.2 is sufficiently old. (Because the changed code will almost certainly be slower.) Whenever that time comes, we can add a warning message if someone uses the gem on MRI 2.2.2.\n\nComments from other contributors? @dubek @krainboltgreene \n. Already merged @xaviershay's fix.\n. Thanks for the fix -- but I would like to dig into the interpreter code and find out exactly why it is segfaulting before we merge any fix.\n. Looks great, let me merge.\n. Merged.\n. Don't worry about the \"barrage\". You are making the library better. We will examine each of your patches, though as you said it may not happen all at once.\n. Merged (with tweaked commit message for brevity). Thank you!\n. For `SortedSet`, the index is integral, starting from the far \"left\" of the tree. For `Set`, you could say that each item is its own index, but I don't know how useful that will actually be. Probably `Set` will not have `#update_in`.\n. Not needed, since we have identified what is causing the problem and can fix it right away.\n. Looking at the graph, I've also noticed that `hamster/version` is only `require`d from the main `hamster.rb` file. It should probably get pulled in by all of the individual structures as well.\n. Let me draw attention to another thing: `nested` pulls in _all_ the collection classes. And almost all the collection classes pull in `nested`. So loading any one of them results in all the others getting pulled in as well.\n\nOriginally, it was possible to load the `Hamster` collections selectively. This is not true any more. Do we care?\n\nWhat if the `nested` methods, like `Hamster.from`, were defined in `lib/hamster.rb`, and would only be available if the library was loaded with `require 'hamster'`, not if a specific collection was loaded with `require 'hamster/vector'` (for example)? Would that be better?\n. After discussion in another GH thread, `#to_ruby` was removed in 30a6aa8. Here is what the sourcefile dependency graph looks like now:\n\n![depgraph](https://cloud.githubusercontent.com/assets/1067359/9793594/6c8d7c64-57e6-11e5-81e3-aba8d0002d6f.gif)\n. Interesting -- comments from other contributors, please?\n. To add another comment: `List.from_enum` could also be called `List.new`... though that might confuse people by implying that `List` is a class, which it isn't... comments?\n. OK, it sounds like @dubek likes this, and the other contributors haven't commented. I guess we go ahead and merge?\n. OK, merged.\n. Again, very interesting. I hadn't thought of doing it this way. Comments from other contributors?\n. As an opinion, I don't think switching on object class is _always_ a \"code smell\". It's a question of how you want to organize your code: would you rather have all the code for `Vector` (as an example) together, or would you rather have all the code for conversion to Ruby structures together? The second consideration is whether new classes which should be convertible to Ruby structures are likely to be added frequently.\n\nI would be happy to just use `Hamster.to_ruby(obj)` rather than `obj.to_ruby`. It seems that @dubek likes this option. @xaviershay hasn't expressed an opinion. Preferences, anyone else?\n. @xaviershay, that's not a problem, since `#to_ruby` was not even included in the last gem release. (Have a look at the git history.)\n. It seems no further comments are forthcoming? So can we go ahead and remove the per-class `#to_ruby` methods, and let people use `Hamster.from` and `Hamster.to` instead?\n. @xaviershay, would you like to code up a patch for this? If you don't want to, I will go ahead and do it.\n. Just removed `#to_ruby` in 30a6aa8. Our problems with circular dependencies are greatly reduced. Have a look:\n\n![depgraph](https://cloud.githubusercontent.com/assets/1067359/9793532/2886fb44-57e6-11e5-9650-9ff0716a4953.gif)\n. @dubek I just updated the docstrings for `.to_ruby` and `.from`.\n. Ah, OK. That makes sense.\n. ACK\n. Applied with some minor cleanup. Thanks!\n. @Bill, list comprehensions are definitely a powerful feature. But can you propose a syntax which the Ruby interpreter can parse?\n. `instar` does look powerful, though I doubt that it is something which we would do in Ruby.\n\nI'm missing what `assoc-in` gives you which Hamster's `Vector#update_in` and `Hash#update_in` don't. Could you explain?\n. @Bill, thanks for this suggestion. Comments from other maintainers?\n. For better or worse, Ruby is an class-based OO language which relies heavily on class-based method dispatch. All the core Ruby classes work this way. Therefore, I suggest that we keep `#update_in` on `Vector` and `Hash`. But extracting the code into a module is a good idea.\n\n@Bill, would you like to code up a PR? Adding to the README at the same time would be good.\n. I second this! We have also fixed several bugs since `1.0.0` was released.\n. Yes, it's @krainboltgreene. `1.1.0` gem, please!\n. Committed with @dubek's suggested implementation.\n. Defining extra methods on `Object` and `BasicObject` in library code is to be avoided at all costs, _unless_ the purpose of the library is specifically to add those methods.\n\nSince all Ruby code in a process shares the same `Object` class, `Array` class, `Enumerator` class, and so on, adding methods to those classes is like adding them to the global namespace. We should \"tread lightly\" on the global namespace; adding methods at will tends to cause incompatibilities between libraries, and the application programmer may have had their own ideas about what they wanted to do in that global namespace.\n\nThat's why we don't add helper methods to `Enumerator` unless the user specifically requests them by requiring `hamster/core_ext/enumerator`.\n\nI can't speak for the other maintainers, but I am very open to suggestions about how better to implement `hamster/nested`. However, that \"better\" way should not just be \"better\" in stylistic purity while sacrificing things which really affect our users (like performance, etc).\n\nI haven't found an arguably better way yet.\n. @Bill, although it looks like we may keep `hamster/nested` as it is for now, please let us know any other ideas which you have for improvement! Your opinions are valued.\n. Looks good to me. I'd just like to adjust some spacing in `README.md` before merging.\n. Merged with some cleanup:\n- Made commit message a bit shorter\n- New docs in YARD-README.md also added to README.md (the latter is specifically for GitHub)\n- Syntax highlighting in README example\n- Code formatting in README example\n- Squashed the 2 commits here into 1\n. @Bill Thanks for the great work!\n. Looks nice!\n. The problem is that you are storing a mutable object in `Hamster::Hash`, and using destructive (mutating) methods on it.\n\nUse `name + 'sy'` instead and it will be fine.\n. The main GitHub page states about this:\n\n> While Hamster collections are immutable, you can still mutate objects stored in them. We recommend that you don't do this, unless you are sure you know what you are doing.\n. Thanks, but this is known and expected behavior, not a bug. As the documentation states:\n\n> While Hamster collections are immutable, you can still mutate objects stored in them. We recommend that you don't do this, unless you are sure you know what you are doing.\n. Thanks for bringing up what is a very real issue with using immutable data structures in Ruby!\n\nI think that `#put_if` is just a special case of a pattern which says: if some condition holds, get a modified copy of this immutable data, and if it doesn't, get the original. The modification could be `put`, or it could be deleting a key, filtering, mapping, etc.\n. Using Ruby's blocks, you could do something like:\n\n``` ruby\nhash.if(condition) { |h| h.put(:foo, :bar) }\n```\n. > feel free to close this\n\nI don't want to close it. I would like to keep it open and hopefully get ideas from other interested parties.\n\nI just hope we don't add more methods to the API without really making sure that it is the right decision.\n. > At this point, there is no win for using \"immutable\" data structures\u2014you're now mutating the pointer!\n\nMutating the pointer can still be a win in some cases. You don't have any aliasing bugs that way. Ask me how many times I have written code with aliasing bugs... (I can't count.)\n\nCertain algorithms are easier to code correctly and efficiently when you have immutable data structures like Hamster's.\n\nHamster has been very deliberately designed so that our structures integrate well with code which uses the core Ruby structures. At least, that is the goal. So you don't necessarily have to convert all your Ruby code to \"everything immutable, all the time\".\n\nMy preference would be to use the plain old mutable Ruby structures locally (such as a temporary structure which is used within a single method and then discarded, or a structure which is passed between a few `private` methods). This is akin to the use of \"transient\" structures in Clojure. The benefits of immutable structures are greater for data which is accessed in many disparate places. OR, when coding an algorithm which involves backtracking, etc.\n\nIf need be, you can convert an immutable structure to mutable on method entry, hammer on it, then convert it back to immutable before returning.\n\nOf course, if you want _all_ your code to use immutable structures, all the time, that is also OK. Definitely, some of Ruby's core language syntax (for control flow, etc.) may not serve you well in that case.\n\nIt might be possible to (partially) work around the problem using some of the ideas in this thread. However, I think that Hamster really exists just to provide immutable data structures, not as a general solution to all the problems of writing pure-functional code in Ruby.\n\nOf course, `#put_if` is a useful helper method, even if we are not trying to provide that \"general solution\". But I am concerned about the proliferation of `_if` methods which might ensue.\n\nI would suggest that:\n1. If you find that methods like `#put_if` really help a certain program, create a local extension for Hamster. Ruby has open classes for a reason, after all.\n2. Some of these other ideas could become little libraries of their own. (Like @Bill's hamstar -- I am happy to see this kind of cross-pollination of ideas, whereby the work done here enables people to explore and innovate in new directions of their own.)\n3. If you really find that `#put_if` is so compellingly useful that you keep coming back to it with every program you write, push harder to have it included in Hamster!\n\n> \"No More Ruby\" Bill\n\nI hope Hamster hasn't turned you off Ruby! Maybe there is another language which works better for your purposes?\n. > I could rewrite it to select the concurrent-ruby version that's installed on the machine, but that seems a bit brittle.\n\nIt would be nice for the users if Hamster \"just works\" with whatever version of `concurrent-ruby` they use. But maybe it's reasonable to expect that everybody should upgrade to at least version 1.\n\nWe should also accept `1.1`, `1.2`, and so on, when they are released. Let's not lock the users down to a very specific version of `concurrent-ruby`.\n. That should be `~> 1.0`, not `~> 1.0.0`.\n. Merged manually into `master`. @Ch4s3, thank you for your contribution!\n. :+1:\n. Thanks @dubek!\n. Nice catch! Looks like this problem dates back to 2013.\n. @xaviershay , do you want to amend the test so it actually checks that `#grep` maps results through the block? Or would you like this patch to be merged first?\n. I must have accidentally clicked \"Comment and close\" rather than \"Comment\". That wasn't my intention. Sorry.\n. Good catch. This is definitely a bug; a bug in specification.\n\nI would prefer just to bump the minor version number after applying a fix. @krainboltgreene?\n. I think this is ready to merge. Yes, it would be nice to unify the code between `Hash` and `Vector`, but I think that can be done in a separate PR. @dubek, would you like to merge?\n. > Does it make sense to add dig to the Associable module\n\nIt does. `dig` is about recursive retrieval from nested, associable structures.\n. Any comments from other contributors?\n. > I can't think of a good way of implementing this with fetch\n\nIf so, adding a dependency on `get` is not really a problem.\n. I think this is ready to merge.\n. I like it!\n. Thanks for the link!\n\nI just looked at the page, and the \"compact\" representation which they show is actually very similar to what JVM Clojure uses for nodes which are less than half full. The idea of separate buckets for key/value pairs and subnodes is similar to what Hamster uses. I need to read the paper for details, though.\n. Hmm. One issue with using a packed representation for nodes, is that Ruby doesn't have a fast, built-in popcount (count number of 1 bits in a number) operator. JVM Clojure uses popcount to convert logical indices to physical indices in a packed node, and this new CHAMP representation would need the same.\n\nI have created a gem called `bit-twiddle` which provides a fast popcount operation for Ruby; we could use it, but it would need to also have a pure-Ruby version for JRuby/RBX.\n. The pseudocode for deletion in Steindorfer and Vinju's paper is faulty; still, the idea is clear. And it is a good idea.\n. An alternative to using `bit-twiddle` would be for me to code up a C extension for Hamster, which replaces `Trie`. I was planning to do this for the `immutable-ruby` gem, but it doesn't seem to have much traction. Perhaps people like \"Hamster\" better?\n. > What is the difference between that\n> gem and hamster?\n\nIt's a fork of Hamster which uses a different namespace. Structures are `Immutable::Hash`, `Immutable::Set`, and so on. Otherwise everything is the same.\n. @dreammaker, any discussion of `immutable-ruby` can be done from its GH page. This location is for discussion of `hamster`.. @hzulla Thanks for your interest in Hamster. I have adjusted the gemspec to include the license file in the gem.\n\n@krainboltgreene New minor version?\n. @krainboltgreene There is a funny build failure whereby Travis CI can't install the Hamster gem on certain Ruby versions. I am looking at it.\n. Looks like Travis CI is using an old version of Bundler. From their output:\n\n```\n$ bundle --version\nBundler version 1.8.4\n```\n\nOn my PC:\n\n```\n21:42 ~prog/Ruby/parser % rbenv shell 2.3.0\n21:42 ~prog/Ruby/parser % bundle --version\nBundler version 1.11.2\n```\n\nIn [this thread](https://github.com/bundler/bundler/issues/3560), one of the Bundler devs stated that he thinks this bug should be fixed by a commit which made it into v1.11.2.\n. @hzulla Why not just submit a PR rather than patching the code downstream?\n. @krainboltgreene Can you go ahead and cut a new minor release? It looks like the Travis CI failure is a problem on their side.\n. @krainboltgreene New gem please!\n. Done. Thank you for pointing this out.\n. I am open to this.\n. I'm happy to merge this _once_ we see that the tests are still passing on all interpreters. Looks like the failure here is due to Travis, not your code. Is there some way you can make the Travis build run again?\n. It's sad that Travis CI has become so unreliable. Let me have a look at the failures. Maybe we can merge this anyways.\n. Just merged it in via a PR of my own. Sorry I didn't see this first.\n. (You are still credited in the commit logs, of course. Same commit, just merged via a different PR.)\n. Sounds like a good idea, though a dedicated implementation (perhaps based on `Hamster::Trie`) would be better than relying on `Vector`.\n\nThe first thing would be to come up with a POC and see if the performance advantage over just using frozen strings is compelling.\n. Travis CI failure has nothing to do with @no-reply's change. It's one of the random failures which has become all too common on their platform.\n. Looks good! Thanks!\n. I like this.\n. Merged.\n. Persistent data structures cannot be used in this way. Sorry. It's by design.\n. Personally, I don't care if tests fail on Rubinius. Rubinius is a buggy heap of... bugs.\n. Sorry, what was the motivation for the removal of all occurrences of `&block`?. Nice. When was this introduced in stdlib? Is it available in all the Rubies which Hamster supports?. In that case this PR looks fine to me.\n\nOn Sun, Mar 5, 2017 at 11:44 AM, Denis Defreyne <notifications@github.com>\nwrote:\n\n> It\u2019s been around at least since Ruby 1.9.3, so yes!\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/hamstergem/hamster/pull/234#issuecomment-284216837>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABBJX01ffdIVpt4zRvHmJuuJMIfQCvDBks5rioPqgaJpZM4MTXCH>\n> .\n>\n. Errr... I dunno. Make some noise?. Merged into `master`. Sorry for the delay.. Thanks for the question. As far as I am concerned, the library is finished.\nAny performance improvements would be welcome but I will not be the one to\nmake them.\n\nIf you or anyone else wants to submit a PR to update the dependencies, that\nwould be very welcome.\n\nAs far as the broken build, I think Travis used to work well for us, but\nlater we started to see so many spurious failures that we tired of even\nbothering to look into them.\n\nI think if you clone the repo and run the tests locally, you will see that\nthey all pass. If not, tell me and I will fix them.\n\nOn Aug 30, 2017 12:23 AM, \"Logan Campbell\" <notifications@github.com> wrote:\n\n> I saw build failing, deps out of date and most changes a year ago. Should\n> there be a depreciation/unmaintained warning in the readme? Or is it just\n> that the library is done and no further work needs doing?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/hamstergem/hamster/issues/236>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABBJX-FHsp_OS2X7X5PtseQR3CEa6exiks5sdOPOgaJpZM4PG2Zw>\n> .\n>\n. Looks good to me.. Merged into `master`. Can't merge into `core` because Travis CI failed.\r\n\r\nBitrot has caused our CI to become completely broken over time, although the Hamster codebase hasn't changed. Would be nice if someone could step in and help set Hamster up with another CI solution which works.. I wonder if we can just drop official support for 1.9.3. Any idea if the\nRuby development team still supports it or not?\n\nOn Oct 10, 2017 9:43 PM, \"kevgathuku\" <notifications@github.com> wrote:\n\n> Thanks @alexdowad <https://github.com/alexdowad>\n> I can check out the CI.\n> It seems the failure is happening only on ruby 1.9.3, and weird enough\n> after the tests pass.\n> [image: screen shot 2017-10-10 at 10 42 16 pm]\n> <https://user-images.githubusercontent.com/3721994/31407107-591cd980-ae0c-11e7-8838-4836d76b187f.png>\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/hamstergem/hamster/pull/237#issuecomment-335585788>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABBJX3CkCc4POmxs2ZyGpk9sLRDb0VAkks5sq8j5gaJpZM4P0Edi>\n> .\n>\n. Great, thank you!. Interesting idea, but the benefits of keeping the API idiomatic and natural to Ruby developers are greater. That means making the interfaces similar to Ruby's built-in collections, wherever the operations performed are the same or analogous. That precludes making the interfaces for the different collections all the same -- Ruby's built-in Hash and Array have different interfaces, for example.\n. This has languished for 2 years now so I am closing it. Feel free to re-open.\n. Quite frankly, I don't see the usefulness of `MutableHash`. I would just use the `atomic` gem and wrap a `Hamster::Hash` in an `Atomic` object. `Atomic` already gives you a (very efficient) CAS operation.\n. YARD docs needed:\n- [x] Hash (class summary)\n- [x] Hash (individual methods)\n- [x] Set (class summary)\n- [x] Set (individual methods)\n- [x] Vector (class summary)\n- [x] Vector (individual methods)\n- [x] List (module summary)\n- [x] List (individual methods)\n- [x] SortedSet (class summary)\n- [x] SortedSet (individual methods)\n- [x] Queue (class summary)\n- [x] Queue (individual methods)\n- [x] Stack (class summary)\n- [x] Stack (individual methods)\n. The entire library now has YARD docstrings! This is a big milestone.\n. Hmm. \"Laziness by default\" is powerful (witness Haskell), but can be expensive when you don't actually need it.\n. Another perspective: in Ruby 2.0, all `Enumerable`s have a method called `#lazy`. This returns an instance of a class called `Enumerator::Lazy`. `Lazy` is itself `Enumerable`, and at least some of its methods are lazy; they also return instances of `Lazy`. When a `Lazy` needs to be converted to something \"real\", like an `Array`, only as much of the input as is needed is consumed.\n\nThe problem is that _some_ of the methods of `Lazy` are... not lazy. They force the entire input to be processed as soon as they are called. `#partition` is an example. Hamster does better here.\n\nIf Ruby's `Lazy` was fully lazy, there would be little reason for `Hamster`'s lazy lists to exist. What would remain would be the persistent data structures (which I think is really's Hamster's raison de etre).\n\nLinked lists are still a useful (and functional, persistent) data structure to provide. Though it might make more sense to just make them strict, and use Ruby's built-in `Lazy` for lazy processing of input, when it is needed.\n\nAs the built-in lazy processing features of Ruby become more developed, methods like `Hamster.iterate` may or may not remain useful. It depends whether something equivalent is added to Ruby core or not.\n\nI wouldn't want to make any drastic changes to `Hamster::List` right now. Though I think its lazy features should be deemphasized a bit when the documentation is written for the 1.0 release. Some things, like `IO#to_list`, might even be deprecated.\n\nOpinions?\n. More thoughts: our lazy lists are **far** more efficient now than they original were. Will we actually gain any significant performance from making them strict? It would be interesting to benchmark and see.\n. An interesting idea, but it doesn't seem to concord with the way `=~` is used in Ruby core (for regex match), and it is quite nebulous what \"approximate equals\" would actually mean. If you have a specific proposal, please just re-open this issue.\n. This is done as of fefdc20.\n. Are you thinking that they could use the same type of trie?\n. The type of trie used by `Vector` is inherently faster and more memory-efficient for its purpose than the more general type used by `Hash` and `Set`. If someone can find a way to unify the implementation without sacrificing efficiency, they can open a PR for that.\n. The new `Hamster::SortedSet` collection uses AVL trees internally, simply because I never understood the algorithm for deletion from red-black trees well, and it looks like a pain in the anterior to implement. I am guessing that red-black trees might provide a better balance of performance characteristics. That is complete guesswork, as zero benchmarking has been done as of yet. But I believe even \"as is\", performance will be just fine for relatively small sets. (Even for big sets, it shouldn't be terrible.)\n\nThe API also needs to be filled out a bit. Besides supporting all the methods of `Hamster::Set`, I would like to add a couple methods to bring out the strengths of this kind of tree structure. Specifically, it will support iterating over ranges well, iterating over all the items larger or smaller than a certain value, or returning the minimum or maximum value (or min/max within a certain range).\n. This is already done for `Hash` and `Set`. `Vector` is still remaining.\n. Vector initialization was made efficient in cc4dbf9 and ac495f7.\n. This is the same issue as #49.\n. The only cases I can see where this would make sense would be `Set#add`, `Set#delete`, `Vector#add`, `Stack#push`, `List#add`, and `Queue#enqueue`.\n\nHowever, there is a performance cost to doing so. Calling varargs methods is slower than calling methods which take ordinary arguments. Are you willing to accept a small performance hit?\n. For comparison, Ruby's stdlib `Set` requires the programmer to use `#merge` to add many items at once.\n. I say let's close this and open a new issue if there is sufficient popular demand.\n. I would suggest that since `Trie` is an internal, implementation-only class, and not something suitable for consumption by `Hamster` users (can I call them hamsters?), it doesn't need any extra APIs.\n. Added `#sample` with b706bd8.\n. Added `#insert` with bb21e21. I'm not sure what `#insert_by` is intended to do.\n. Checked off `#insert_by` because I have no idea what it's supposed to be. Added `List#fill`, modeled after `Array#fill`, with 94ccf70.\n. Added `List#permutation` (also `#permutations`) in 2e4cd81. The API is modeled after `Array#permutation`. This means that rather than returning a list of permutations, it _yields_ the permutations. If you want a list of them, you need `list.permutations.to_list`.\n\nOn one hand, this API doesn't seem to \"fit\" with the existing `List` methods, which almost all return lazy lists; on the other hand, it may be a good way to cut down on unnecessary allocations.\n\nI think facilitating lazy processing of sequential data is the main purpose for `List`, and both compatibility with `Array` and performance come second. After all, when people need raw performance (if there is such a thing in Ruby),  they will turn to a plain `Array`.\n\nOn the other hand, the Ruby 1.9+ pattern of iterator methods which return an `Enumerator` if called without block _does_ facilitate lazy processing, of a sort. The advantage of a lazy list over an `Enumerator` is that when working with a lazy list, you can hold on to the head and use it again later. With an `Enumerator`, once you have passed an item by, you can't go back (short of `#rewind`, which just isn't the same).\n\n`List` also has the advantage that you can `#cons` onto the front in O(1) time, and also get the `#tail` in O(1) time. But then again, I have a concept for a `Cons` class which can take _any_ `Enumerable` as its tail, and which implements the `Enumerable` API. I also have an idea for how to implement the `#tail` operation on a `Vector` efficiently. (It would mean adding another helper class, so I'm not sure if it's worth it.)\n\nWhat started here as contemplation of whether `List#permutation` should emulate `Array#permutation` is leading to the question of whether `List` is \"worth it\" at all. It might be possible to bring the strengths of `List` to _all_ sequential collections. Then, if it happened to be convenient to build up a sequence by `cons`ing, you would end up with a linked list. Otherwise, you might end up with a `Vector` or even a frozen `Array`. In all cases, you could use the `List` API for lazy processing if you wanted to.\n\nIn any case, I will finish these additions to the `List` API first.\n. Added `List#subsequences` in 96b57ab.\n. Added `List#transpose` (finishing this to-do). Also added `List#delete_at`, `#delete`, and `#rotate` (all inspired by `Array`). I think `List` is \"full-featured\" now and probably won't undergo any API changes before the next major release.\n. `Set#sample` was added in 3f68ea4. `Set#cycle` is also there. I still want to look over the API for Ruby's built-in `Set` one more time, though, and see if there are any other methods which it would be good for `Hamster::Set` to implement.\n. Added `#add?`, `#delete?`, `#disjoint?`, `#intersect?`, `#proper_superset?`, `#proper_subset?`. I think `Hamster::Set` is pretty much \"full-featured\" now. I don't plan to add any more APIs to `Set` before the 1.0 release.\n. It seems that you would get all of this just by including the `Enumerable` module. You might have to make `Hamster::Hash` yield key-value pairs wrapped in Arrays, rather than yielding the key and value as 2 separate arguments.\n. I'd suggest that Hamster::Hash should match the latest Ruby Hash API fairly\nclosely, except in places where it doesn't make sense to do so. Ruby Hashes\nare also Enumerable, so make Hamster::Hash implement the \"Enumerable\"\nmethods in a way which is close to Ruby Hash.\n\nLikewise, Hamster::Vector could be brought close to compatibility with the\nlatest Ruby Array API.\n\nOn Thu, Jun 5, 2014 at 10:18 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Argh, you know what I realize also? If our goal is API compatability we\n> have to do one of two things:\n> 1. Make a release for each Ruby version we support (hamster\n>    1.0.0+mri2.1.1)\n> 2. Only support latest Ruby Array & Hash public API.\n> \n> Thoughts? I mean we clearly can't support 1.9's Enumerable, Array, and\n> Hash at the same time.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/42#issuecomment-45192786.\n. All of these are done.\n. `#grep`, `#partition`, `#group_by_with`, `#<=>`, and `#join` have been added to `Hamster::Enumerable`. That seems like all there is right now.\n. From c693d7d..fa7dae9, I have added tests checking that various `Set` methods don't mutate `Set`s. Every method which could reasonably be suspected of mutating a `Set` is now covered by tests.\n. Tests added from ffe605d..b67148d.\n. The existing specs already check that `#clear`, `#peek`, `#pop`, and `#push` leave the original object as is. There is no other method in the `Stack` API which reasonably could modify the original object.\n. Are there issues with the coding style of the existing `Trie` class? If not, I suggest we \"don't fix what's not broken\".\n. My assessment is that while the `Trie` code isn't perfect, it isn't bad either (and the class is small). A few comments would aid understanding, but rewriting the whole class is just unnecessary work. I suggest that if any specific problems are found with the current implementation, specific GH issues can be opened and worked on.\n. Right now, the main part which appears hard to understand is `#delete_at`. Other parts could also do with a few more explanatory comments here and there. Are there any other specific parts which you feel could be improved?\n. I am having trouble understanding what the purpose of this is.\n\nCircular buffers, or queues, are normally used for memory efficiency. If each item takes a machine word, and I can guarantee there will never be more than 1000 items in my circular buffer/queue, I can allocate 8000 bytes of memory (on a 64-bit machine) and never have to grow the structure. When (for example) programming embedded devices with small memories in C/assembly, this is great. Depending on the application, you may be able to allocate all memory statically and completely avoid using `malloc` and `free`.\n\nSince Hamster collections are immutable, you have to do at least some copying with every \"modification\". There is no possibility of keeping all versions of the structure in a single, static block of memory. So I am questioning what the utility of this structure is.\n\nIs there some application for a queue with limited size which I haven't thought of?\n. To answer my own question: one application of a bounded queue is for managing load in concurrent systems, applying back-pressure, etc. If a \"producer\" component overruns its consumer, you can avoid letting the queue between them grow without limit and crash your application by A) blocking when the queue is full, or B) dropping items from the queue.\n\nHowever, if that is what you want it for, a persistent, immutable queue would be a most unusual choice. So I still think that this does not need to be in Hamster.\n. Triaging this issue; if anyone feels this requires more discussion, please re-open.\n. Done.\n. Done.\n. Done.\n. Does this offer anything over the `memoize` method which already exists in `Hamster::Immutable`?\n. Another note: `#transform` and `#transform_unless` are surprisingly slow. I have gotten worthwhile speed boosts out of `Hash`, `Set`, `Vector`, `Queue`, and `Stack` by refactoring away from the use of `#transform`. `MutableHash`, `MutableSet`, etc. still use `#transform`.\n. Are you thinking of using Adamantium just for memoization, to replace the code in `Hamster::Immutable`? Or for some other purpose?\n. If this is about automatically deep-freezing anything which is inserted into a Hamster collection, I think that is heavy-handed and unnecessary. It won't be good for performance, and in some cases, it will get in the way of people who know what they're doing and can use mutability judiciously without causing problems. As regards `Hamster::Immutable`, I haven't looked at the `memoizable` gem, but if you look at it and think it can do what is needed, and do it better than the existing code, then let's use it. If it's no better or worse than the existing code, I don't feel strongly either way but would vote to stick with what we have.\n\nIf @sporkmonger feels that what we have in Hamster right now doesn't meet his use case, please speak up and let us know what is lacking, which bringing in a new dependency can improve.\n. Triaging this issue, please re-open if there is more to say.\n. This sounds pretty good, except for creating a separate file for each and every method. This will result in an explosion of redundant test files.\n. All the specs use `let` instead of instance vars now. Also, `context` is used everywhere where it is appropriate. Almost all of the `before` blocks are gone, so that is no longer such an issue.\n. This is not a problem. The \"problem\", if you can call it that, is that `lib/hamster/enumerable.rb` is completely redundant and not needed. It offers almost nothing over Ruby's built-in `Enumerable` module. The one thing I can see that it does add is `#product` and `#sum`, but those can easily be added where they make sense, and don't require a module of their own.\n. OK, I spoke too soon. There were a few other things in `Hamster::Enumerable` that were needed. For some reason, after I deleted it, the specs were passing (don't know what I did wrong). Now they are not. I am going through the failures and seeing if they can be fixed with a few small changes here and there, without the need for an entire extra module.\n. OK, I have the specs passing again, but just need to clean up a bit before committing.\n. Just reintroduced `Hamster::Enumerable`, but without all the bloat. Everything in that file is definitely needed now. Still need to prepare a couple more commits, then everything will be fixed.\n. OK, with 544783d, this is finally all sorted out.\n. I don't think we are ready for a \"1.0\" release, and the level of stability and maturity it implies.\n- The public API is 95% there. There are just a couple things to add. Of course, if anyone can review what we have and give some feedback, that is even better.\n- I am in the midst of a full review of all the specs; updating them to @krainboltgreene's preferred style, adding tests for public API methods which are not covered, and adding more test cases for those which are.\n- DOCUMENTATION is badly needed and will be my next project after finishing the current work on the specs.\n\nA \"0.7\" release right now would be entirely appropriate. Or else another RC. @renz45, if you want to hasten things, please go through the GH issues and see if there is anything which you can contribute work (or even just opinions) to.\n. @renz45, are you currently using Hamster in \"production\"? If you can try running the current \"edge\" Hamster and see if you discover any bugs, that will help push us closer to the 1.0 release. Any feedback you have about the API will also help.\n. Interesting to hear that Code School is using our stuff... I have gone through a few of your courses (used to have an employer who provided CS subscriptions for devs).\n. I have started working towards something like this with ca60a96.\n. The next step was 749def5.\n. `List` and `Stack` are both covered as of 94adcdf.\n. `Queue` is covered with 2feca6d.\n. `Hash` is covered with 5089c7.\n\nThe only remaining \"fly in the ointment\" is `Hamster::Tuple`. `Tuple#inspect` returns a string which _cannot_ be eval'd. It could easily be changed from `(...)` to `Hamster::Tuple[...]`, but I would prefer to eliminate `Tuple` and just use frozen `Array`s. They print concisely, and are idiomatic for Ruby. (Though we might prefer that Ruby was a more functional language, it is what it is.)\n. Done!\n. Note, similar speedups could be achieved for other methods like `Hash#merge`, `Hash#except`, and so on, using the same technique.\n. No problem. Would you like me to submit a different PR, and you can close\nthis one?\n\nOn Mon, Jun 2, 2014 at 9:07 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Rebase off master plez, that should fix the test problem.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/93#issuecomment-44877903.\n. Problem is that after rebasing, I can't push (unless I merge the rebased branch back with the old one, and that would be messy). I'll open a new PR.\n. @krainboltgreene, do you still prefer `spec/lib` over just `spec`? If so, I'll finish this.\n. Done in c2821d7.\n. I noticed that Travis is failing when running the specs against JRuby. This was caused by my recent PR which differentiates Hamster::Hash#== and Hamster::Hash#eql?.\n\nThe problem is that JRuby's implementation of Array#eql? does not work like MRI's. MRI returns false if both objects are not Arrays. JRuby looks at whether the other object responds to #to_ary, and if so, it falls back to #==.\n\nThe result is that `[\"A\"].eql?(Hamster.list(\"A\"))` is true.\n\nI'm going to report this as a bug against JRuby.\n. I just sent a PR for JRuby which will fix the Hamster build if accepted:\n\nhttps://github.com/jruby/jruby/pull/1725\n. Sorry, one thing I said wrong... the broken build was not caused by the recent changes to Hamster::Hash#eql?, it was caused by slightly earlier changes to Hamster::List#eql?. In either case, I think this is clearly a bug in JRuby, not in Hamster.\n. JRuby's developer docs state that they prefer tests to be added to Rubyspec, since they use Rubyspec to determine how close they are to compatibility with MRI.\n\nI sent a PR to Rubyspec to add a test which covers this:\n\nhttps://github.com/rubyspec/rubyspec/pull/276\n\nUnfortunately, the build for my JRuby PR is failing. It doesn't seem related to the PR, though. At https://github.com/jruby/jruby, you can see that the build is also failing for JRuby \"master\".\n. If you are retracting support for MRI 1.8.7, then this PR is not needed and can be closed. If you want to support 1.8.7, I just noticed that Ruby 1.9 hash syntax will also have to be removed.\n. I would also suggest you drop 1.8.7 and close this PR.\n. It could be, I hadn't tested against 1.9.2. I will do so right now.\n\nOn Wed, Jun 25, 2014 at 3:23 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> So the tests fail in 1.9.2, is that due to your change?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/97#issuecomment-47099704.\n. It's a bug in 1.9.2. I can reproduce it entirely apart from Hamster, with\nthe following code: `[1,2,3].to_enum.next`.\n\nPerhaps a bug fix has already been applied to 1.9.3 but needs to be\nbackported to 1.9.2. I'll have a look at the MRI bug tracker. If not, and\nsearching the repo doesn't reveal anything, I'll try to fix it and send a\npatch to MRI (hopefully they accept patches for 1.9.2).\n\nOn Wed, Jun 25, 2014 at 4:11 PM, Alex alexinbeijing@gmail.com wrote:\n\n> It could be, I hadn't tested against 1.9.2. I will do so right now.\n> \n> On Wed, Jun 25, 2014 at 3:23 PM, Kurtis Rainbolt-Greene <\n> notifications@github.com> wrote:\n> \n> > So the tests fail in 1.9.2, is that due to your change?\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/pull/97#issuecomment-47099704.\n. I've done some printf-debugging of MRI 1.9.2. The crash is happening where\nit swaps the machine stack when switching to a new Fiber (Enumerators are\nimplemented using fibers).\n\nI haven't figured out all the details, but it appears that when switching\nfibers, MRI saves the entire machine stack in a buffer, and overwrites it\nwith the stack for the new fiber. Later, when it switches back to the\noriginal fiber, it copies the saved stack back in place.\n\nIt segfaults when trying to do that copy, suggesting that either the\npointer to the bottom of the machine stack, the pointer to the buffer, or\nthe calculated stack size is incorrect. I don't know which one it is.\n\nIt's weird that this hasn't been noticed and fixed already.\n\nOn Wed, Jun 25, 2014 at 4:48 PM, Alex alexinbeijing@gmail.com wrote:\n\n> It's a bug in 1.9.2. I can reproduce it entirely apart from Hamster, with\n> the following code: `[1,2,3].to_enum.next`.\n> \n> Perhaps a bug fix has already been applied to 1.9.3 but needs to be\n> backported to 1.9.2. I'll have a look at the MRI bug tracker. If not, and\n> searching the repo doesn't reveal anything, I'll try to fix it and send a\n> patch to MRI (hopefully they accept patches for 1.9.2).\n> \n> On Wed, Jun 25, 2014 at 4:11 PM, Alex alexinbeijing@gmail.com wrote:\n> \n> > It could be, I hadn't tested against 1.9.2. I will do so right now.\n> > \n> > On Wed, Jun 25, 2014 at 3:23 PM, Kurtis Rainbolt-Greene <\n> > notifications@github.com> wrote:\n> > \n> > > So the tests fail in 1.9.2, is that due to your change?\n> > > \n> > > \u2014\n> > > Reply to this email directly or view it on GitHub\n> > > https://github.com/hamstergem/hamster/pull/97#issuecomment-47099704.\n. Thanks for pointing that out. This still bugs me. But maybe it's not worth\nburning more time chasing the bug down.\n\nOn Thu, Jun 26, 2014 at 9:46 AM, Arne Brasseur notifications@github.com\nwrote:\n\n> 1.9.2 end its \"extended maintenance period\" (whatever that means) in 4\n> days, it stopped taking security fixes a year ago. I think we can safely\n> call it dead.\n> \n> https://bugs.ruby-lang.org/projects/ruby/wiki/ReleaseEngineering\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/97#issuecomment-47196880.\n. I'll try it out a bit later.\n\nOn Thu, Jun 26, 2014 at 11:54 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Just noticed Rubinius 2 is also failing, for the same reason?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/97#issuecomment-47207551.\n. No comments seem to be forthcoming, and I don't think this is really a controversial change, so I am going ahead and merging it.\n. Implemented in 0dd7b07.\n. @krainboltgreene, any comment? Do you think conforming to the built-in `Hash` API (minus the \"mutable\" part) is a good idea?\n. Rebased onto `master`, cleaned things up, and merged.\n. Well, I have one or two significant optimizations for Hamster::Hash which I\nhaven't pushed yet. Optimizations for Hamster::Vector are also coming. In\nany case, setting up benchmarks sounds like a great idea.\n\nOn Thu, Jul 3, 2014 at 7:33 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> How many more of these improvements to performance do you think will come\n> over this month?\n> \n> I'm considering setting up built in benchmarks for the CI.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/102#issuecomment-47960328.\n. No comments seem to be forthcoming, so I'm going ahead and merging.\n. Sorry, my comment appeared to be duplicated in GH, but when I tried to delete one of the duplicates, both disappeared. In short, what I said was: defensive copying (even of a Ruby `Hash` or almost any data structure at all) doesn't help if you are mutating the values stored in the structure. So the issue of whether a defensive copy is needed or not is not related to the issue of whether the values stored in the structure are mutable.\n\nHaving said that, warning people not to (figuratively) point a gun at their foot and pull the trigger is still a good idea. I would recommend the following 2 points should come out somewhere in the README:\n- While Hamster collections are immutable, you can still mutate objects stored in them. We recommend that you don't do this, unless you are sure you know what you are doing.\n- Hamster collections are thread-safe and can be freely shared between threads, but you are responsible for making sure that the objects stored in them are used in a thread-safe manner.\n\nMaybe you can write something up and send a PR?\n. @krainboltgreene already added some text to the README making this clearer.\n. Just rebased onto `master`, the specs should pass now.\n. `cherry-pick`ed onto `master` manually.\n. All 6 of the Hamster collections can be pretty-printed as of 96fae6d.\n. Good point! Just thinking about this one.\n\nOn Sun, Jul 20, 2014 at 7:50 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> require \"hamster/set\"\n> class Tags < Hamster::Set\n>   def initialize(name:, context:)\n>     @name = name\n>     @context = context\n>     @trie = EmptyTrie\n>   endend\n> Tags.new() # ArgumentError: missing keywords: name, contextTags.new(name: \"foo\") # ArgumentError: missing keywords: name, contextTags.new(name: \"foo\", context: \"bar\") # ArgumentError: missing keywords: name, context\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/114.\n. A nitpick with the example: I think that `@trie` is an implementation detail and should not be set in a subclass constructor. Rather, the subclass should call `super` with the same args that are normally passed to `new`. The point of the example still remains the same.\n\nIn answer to your question, `new` has been overridden to provide a \"friendly\" interface for users, but I still needed a way to do \"raw\" allocation of new `Set` objects internally. Right now, that is done by `alloc`, which calls `#initialize` internally.\n\nI'm trying to think of a better way to achieve this aim.\n. One really gross way to get around this problem would be to do something like `if arg.is_a? Trie` in `Set#initialize`. I don't want to do that.\n. In some (statically typed) languages, the aim could be met using an undocumented, private constructor (in addition to the public one). In Ruby, there's no such thing.\n. Got it. `Class#allocate` will do what I need. I remember learning about this method a long time ago, but I never used it and had forgotten about it until now.\n. With this fix, we have lost the desirable property of `new` that it returns the canonical empty instance when called with no arguments. `new` _always_ allocates a new object instance now. But that is the only possible way we can make `#initialize` overrideable in a way which will be intuitive for Ruby programmers at large.\n. I applied the same fix to `Hash` and `Vector` in 7f95195 and 032f282. Once I get to working on `Stack`, `Queue`, and `List`, I will make them also subclassable using the same technique.\n. Comments please!\n. @krainboltgreene, could you clarify what you mean by \"writing the reason down somewhere\"? I explain the rationale for this change in the commit comment, which can be found in the project git history using `git grep`. Do you think this information should also be in a documentation page linked to from the GH page?\n\nPerhaps when version 1.0.0 of the gem is released, all these changes can be noted in `History.rdoc` (it will be a pretty massive list).\n. Since @krainboltgreene seems to approve, I have gone ahead and merged this change. KRG, if you want anything additional to be done as regards documentation, let me know and I will do it.\n. Tell them \"Ruby already has Arrays, which can be frozen, and which are CPU\nand memory-efficient\". Tuples are most useful in statically typed\nlanguages, especially when combined with destructuring assignment and\npattern matching. In dynamically-typed Ruby, they don't do much for you.\n\nOn Sat, Jul 26, 2014 at 1:04 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> I've been wanting to add a list of all the collection types we have, with\n> more documentation for each. Hmm.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/117#issuecomment-50231140.\n. I'm not sure what the methods for adding/removing from each end of the deque should be called. By analogy with `Array`, we could use `shift`/`unshift`/`push`/`pop`. Or we could dispense with the `Array` API and come up with our own names.\n\nDoes anyone have any good ideas for method names?\n. Huh. Interesting point. Didn't think of that.\n\nOn Fri, Aug 8, 2014 at 2:35 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> I will say that I've always disliked duplicated signatures:\n> \n> queue = Queue.newqueue.enqueue(object)\n> \n> Vs\n> \n> queue = Queue.newqueue.push(object)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/118#issuecomment-51594901.\n. http://en.wikipedia.org/wiki/Double-ended_queue helpfully provides a table of names which have been used in different programming languages.\n. Going with `Array`-like interface for now. There is still room to change, if anyone comes up with a better idea.\n. Rubyspec has been useful when writing specs for methods which are not yet covered by tests. It appears there were a number of them before I started working on the specs...\n. Added more test cases for `Hash` in e6fd874..3c141c1, inspired by Rubyspec test cases.\n. Done. The only other one which needed to be fixed was `SortedSet`.\n. Added `#assoc` and `#rassoc` in 76a4bf1.\n. Added `#fetch` in bff3ba2.\n. Added `#rindex` in 5750061.\n. Added `#shuffle` in 8392b61.\n. Added `#uniq` in 57fe020, `#rotate` in 412fc6f.\n. Added `#combination` in 1fe0936.\n. Added `#repeated_combination`, `#bsearch`, `#zip`, `#values_at`, `#flatten`. Just a few more left.\n. Added `#*` in 00ec63f.\n. Added `#permutation` and `#repeated_permutation`.\n. Added `#product` in 996b02d.\n. Added `#transpose` in f7b65dc.\n. Added `#slice` in 8496bbd. `#[]` can now take `index,count` arguments or a `Range`, just like `Array#[]`. \n. Added `#insert`, `#delete_at`, `#fill`, and `#concat`. All are relatively efficient. Inserting or deleting close to the beginning of a Vector is (unavoidable) quite a bit slower than doing the same operation on an `Array`, even if you copy the array first. If you insert or delete close to the _end_ of the Vector, though, it is much faster than copying and modifying an `Array`.\n. `Vector` is now feature-complete!\n. Any suggestions what the methods for iterating over keys less-than, less-than-or-equal, etc. to a given key should be called?\n\nIf a block is provided, I intend to make these methods `yield` the appropriate items and then return `self`. If no block is provided, they will return a new `SortedSet`. This can be done quite efficiently.\n. Added `#add?`, `#delete?`, `#reverse_each`, `#clear`, `#subset?`, `#superset?`, `#proper_subset?`, `#proper_superset?`, `#sample`, `#disjoint?`, `#intersect?`, `#group_by`, `#union`, `#intersection`, `#difference`, `#exclusion`. `SortedSet` has a full `Set` interface now.\n. Added `#at`, `#[]`, `#slice`, `#delete_at`, `#fetch`, `#values_at`, `#find_index`, `#take`, `#drop`, `#take_while`, `#drop_while`. Now `SortedSet` has all the `Array`-like functionality which makes sense for it to have.\n. @krainboltgreene, the cherry on the cake will be the methods for iterating over ranges defined by a key or pair of keys (or getting back a new `SortedSet` which includes that range only). Do you have any suggestions what to call those methods?\n. Added `#above`, `#below`, `#from`, `#up_to`, `#between`. See e5d60f9..119cd81.\n. I'm not saying we need to do something like this. It is just an idea for discussion.\n\nWhen C and Java implementations of Hamster are written, the performance and (multi-threaded) scalability benefits of something like this can be had without introducing extra dependencies. If desired, pure-Ruby Hamster can be left with the poor performance/scalability of a mutex per list node. People who care about performance will use the C or Java-based gems.\n. KRG, are you OK with using the `atomic` gem? Or using atomic-swap based code in Java/C, but not in pure Ruby?\n. OK. I just sent a PR for the `atomic` gem: https://github.com/ruby-concurrency/atomic/pull/4. If it is accepted, I will be a bit more confident that this code is really thread-safe. This patch also needs some more testing. When I have more confidence in it, I will merge it in.\n. Just spent some time testing this patch. Performance is horrendously bad if there is contention to realize a lazy list, and thread which is running the block _sleeps_. This is to be expected with spinlocks -- I'll have to make the contending threads sleep on a queue while they wait. Or I might make them spin a few times before giving up and going to sleep.\n. I've just been testing and examining the code more, and feel quite confident it is right. Performance also seems good. I'm merging it now.\n. The audit is finished now. A number of new test cases have been added as a result.\n. Clojr is a very thin wrapper over core Clojure classes, and as such doesn't have anything to offer to a library which must be usable apart from the JVM. Persistent::Vector has 2 interesting things: its `Vector` has a `#pop` method which Hamster doesn't at the moment, and the vector implementation has an array called the \"tail\" for each vector. The vector trie only contains full, 32-item leaf nodes. Any items at the end which are not enough to make a new 32-item leaf are kept in a separate array called the \"tail\".\n\nThis means that when adding items at the end, you don't need to traverse the trie and copy the path to the root for each `#add`, only once for 32 `#add`s. `#pop` is also efficient. The downside is an extra test during each `#get` (to see if the desired item is in the \"tail\"), plus adding a bit of extra code to almost every method to handle the \"tail\".\n. Thank you!\n\nOn Thu, Apr 30, 2015 at 3:14 PM, Ilya Lavrov notifications@github.com\nwrote:\n\n> Should we at first add JRuby and Rubinius support to current\n> implementation? See two tasks here\n> - Make all specs green for JRuby and Rubinius\n> - Add JRuby and Rubinius to Travis\n> \n> I launched current specs for JRuby and Rubinius. For Rubinius all are\n> green. For JRuby all specs except one are green. Ready to fix this one red.\n> \n> Thank you.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/126#issuecomment-97773166.\n. From some \"real-world\" use of my own, I have discovered that we _really_ need a method for updating nested collections. Hashes of hashes of hashes, etc.\n\nWith mutable Hashes, it's not a problem -- you just drill down to the \"bottom-level\" collection, and modify it. With immutable Hashes, you then have to \"reverse your steps\", inserting each child collection into its parent, until you get up to the \"root\".\n. About 6 months has past. The `-rc3` version gem has been downloaded >1000 times. No bug reports against that version have come in. How much more time do you think we should give before shipping it?\n. I also think it's ready.\nOn Jan 21, 2015 1:25 AM, \"Dov Murik\" notifications@github.com wrote:\n\n> I think it's ready.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-70755789.\n. @krainboltgreene, can you go ahead and cut the promised 1.0.0 gem?\n. @harukizaemon @krainboltgreene @dubek @gcapizzi @ryantm @misfo @kef @cstorey @baconpat @gfredericks Thank you for your contributions toward this gem! Congrats to all on the 1.0 release!\n. Done in dae141a.\n. So you like seeing `(also #blah)` rather than an additional method listing?\n. OK, I tried to get the best of both worlds. I used a new YARD handler, so that it is not necessary to bloat the code with tons of YARD directives. The handler treats `def_delegator :self` as creating an alias, not an independent method. But if `def_delegator` is used with a target other than `:self`, it is treated as creating an independent method.\n. To be frank, personally, I feel the use of `def_delegator` rather than `alias` is a mistake. The reason is: supposedly we use `def_delegator` for inheritance, so that (for example) a subclass can redefine `#empty?`, and `#null?` will also \"automatically\" change.\n\nThere are a couple problems with this. First, maybe the subclasser didn't _want_ `#null?` to automatically change. Maybe they wanted to retain one method with the original behavior. Second, unless they read the code, there is no way they would know that our collections behave this way. Even if they like this behavior, there is no way for them to know they should override `#empty?` rather than `#null?`. Third, I think that users are unlikely to use _both_ `#empty?` and `#null?`. They will probably just pick the one they like, and use that. So having 2 methods which \"change together\" is, I believe, of little utility.\n\nHowever, the bigger issue is: do we really want so many names for the same methods? If not, then there is no question of choosing _either_ `def_delegator` or `alias`.\n. For `Hash`, I would suggest:\n- Keep both `#size` and `#length`\n- Prefer `#empty?` over `#null?`\n- Drop `#maximum` and `#minimum`\n- Drop `#+`, keep `#merge`\n- Drop `#uniq`, `#nub`, and `#remove_duplicates`? Is there any reason to keep these?\n. @dubek, since you have expressed an interest in this, do you have any opinion on the above? Would you like to code up a PR?\n. I would like to clear as much as possible before 1.0, though we have to\ntake the jump sometimes. At least let's make whatever\ncompatibility-breaking changes we have to make.\n\nOn Tue, Oct 21, 2014 at 9:49 PM, Dov Murik notifications@github.com wrote:\n\n> I don't really have a strong opinion - I just ran into this library for\n> the first time today (but I really like it!).\n> \n> I'm now working on a small performance improvement from #136\n> https://github.com/hamstergem/hamster/issues/136 . After I'm done with\n> that, I'll take a look at clearing the Hamster::Hash interface (remove the\n> unused aliases as suggested here and converting to use pure alias instead\n> of def_delegator). Are you waiting with a 1.0 release for these interface\n> changes?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-59987225.\n. As per discussion above, I have removed some unneeded aliases from `Hash` in 0dfbdac.\n. Removed unneeded method aliases from `Set` in b226952 and 57e6426. The one remaining question about `Set`: do we want both `#conj` and `#conjoin`? These methods were previously added in an attempt to create a single interface for \"adding an item\" to _any_ collection.\n\nThis is a very useful thing, but I think we just need one or the other. Which one is it going to be?\n. That's true, just `#add` would also do the trick. Most of the collections already have `#add` anyways. `#conj` is a nod to Clojure, and will be familiar to anyone who has programmed in Clojure. `#conjoin` is like `#conj` but a bit more verbose (and more readable to non-Clojure programmers).\n\n`#add` is the most understandable of all to programmers who don't use Clojure.\n\n@dubek, do you have any input?\n. The idea of adding `#conj` in the first place was that yes, you could write generic code to build up _any_ collection. I also like the idea of using `#<<`. Somehow `hash << [key, val]` doesn't look as weird as `hash.add([key, val])`.\n\nHere's another one: do we want `#head` as an alias for `#first` everywhere? I think just `#first` is enough.\n. Oh! I just found one thing which is different about `#conj` and `#<<`.\n\n`#conj` is designed to add an element in the _most efficient_ way. For a `List`, that means prepending it onto the front. But `List#<<` appends an element on the end (as people would probably expect).\n. @dubek, in Clojure, standard functions like `into` are actually implemented using `conj`, using exactly the type of polymorphism which is demonstrated by your Ruby example.\n. @krainboltgreene, OK, that makes sense. I think `#<<` should be kept for ordered collections and `Set`, since Ruby programmers are accustomed to using it. It is not needed for `Hash`.\n. Just pushed a commit which removes `#conj` and `#conjoin`. `List#add` now adds an element to the _front_ of a list (the most efficient place to do it). `#group_by_with` (which `#conj` was originally intended to support) now uses `#add` instead of `#conj`.\n\n`Hash#group_by` is now broken (there are no tests for it though). To fix it, we need to add `Hash#add`. It would be good to also add tests for `Hash#group_by`.\n. For the current implementation of `#group_by` to work, it needs to be like: `hash.add([key, value])`. Perhaps we can just add a new implementation of `Hash#group_by` and forget `Hash#add`.\n. Removed `#head` from `Set`, `Vector`, `SortedSet`, `Deque` in 3b3ba86.\n. Removed `#foreach` alias for `#each`.\n. Removed `#elem?` alias for `#include?`.\n. Removed `#forall?` alias for `#all?`.\n. Any comments on `#exist?` and `#exists?` as aliases for `#any?`? I don't think they are needed. How about `#elem_index` for `#index` or `#contains?` for `#include?`?\n. Dropped `#exist?`, `#exists?`, `#elem_index`, `#contains`. Significant change: dropped `#remove` and `#filter`. Instead of `#select` and `#reject` being aliases, they are now the original method names. (All the built-in Ruby collections use `#select` and `#reject`, not `#filter` and `#remove`.)\n. OK, here's another one. `Hamster.range(from, to)` and `Hamster.interval(from, to)` are identical methods, returning a lazy list. Which one should be \"standard\"?\n. `Deque` is a bit of a mess. The following are groups of identical methods:\n- `#first`, `#front`\n- `#last`, `#peek`\n- `#push`, `#enqueue`, `#<<`, `#add`\n- `#shift`, `#dequeue`, `#tail`\n\nAs you can tell, some of these names were chosen by analogy with `Array`, some reflect the use of the structure as a stack, some reflect its use as a queue. `#tail` reflects the way that \"shifting\" an item out of the front of the deque behaves like taking the \"tail\" of a linked list.\n. I like it! Implementing now.\n. Removed unneeded aliases from Deque.\n. I took the liberty of removing `#fold` as an alias for `#reduce`. Without `#fold`, `#foldr` seems somehow out of place, so I removed it too. We don't have anything with the behavior of `#foldr` now, but I strongly suspect that no-one will use it anyways. If someone really needs it, it is as simple as `.reverse.reduce`.\n. We have trimmed down as far as I think we want to go. There don't seem to be any redundant aliases left.\n\nThe remaining question is if we are going to keep using `def_delegator :self`, or switch to the more conventional `alias`. Opinions?\n. Which option do you prefer? @dubek, do you have any input?\n. We are now converted over to `alias`! I think this issue can be closed now.\n\nAs a side bonus, trimming down on unnecessary method aliases has made the tests run noticeably faster! Changing from `def_delegator` to `alias` made them faster still.\n. I did think of the same idea. But would you want `Deque` permanently aliased as `Stack`? Or are you thinking of that as a transitional measure?\n\nSince Hamster is coming up to a major release, which users should expect to break backwards compatibility, I'd like to clean house. If aliasing collection classes under multiple names is something we would like to do for the long term, that is fine. If not, why not go all the way to where we would really like to be?\n\nIf aliasing is a good idea, `Deque` could also be aliased as `Queue`.\n. Hmm. I am still contemplating whether providing aliases is a good idea or not. In any case, if it is later decided that it is a good idea, it is trivial to add a `stack.rb` which reads like:\n\n```\nrequire \"hamster/deque\"\nHamster::Stack = Hamster::Deque\n```\n. Added some examples for `Hamster::List` in 042e11f. There is still more to do.\n. All that is left is `List#merge`, `#merge_by`, and `#fill`. I can't think of good examples for `#merge` and `#merge_by` at the moment.\n. We have an example for `#fill`, `#merge_by` and `#merge` are still missing. But I think good enough is good enough. Closing for now.\n. Awesome, thank you!\nOn Dec 31, 2014 6:34 PM, \"Dov Murik\" notifications@github.com wrote:\n\n> I added examples for List#merge and List#merge_by.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/133#issuecomment-68452524.\n. @xaviershay, you're right, there is no reason why `Hash#put` and `Hash#store` should not be aliases. To provide some background, `#store` was added to make the interface of `Hamster::Hash` match that of Ruby's built-in `Hash`. `#put` is common to all the `Hamster` collections.\n\nAny chances of sending a PR for this one?\n. I just pushed a fix for the YARD docs for `Hamster.replicate`, you may want to pull before continuing your review.\n. _\"Include expected operation cost...\"_\n\nHmm, sounds like a good idea.\n. @xaviershay, thanks for proofreading ALL the docs for the entire project! It is impressive to see how much better you made them!\n. The GitHub README and locally-generated Yardoc README are now distinct. The FAQ has been pulled out into a separate page in both GitHub and local Yardocs.\n\nThe FAQ still needs some editing though.\n. Great work, thanks!\n. @dubek, good find! I just pushed an optimization based on this: 6813845. Rather than delegating to `#shift`, I made `#drop` use an implementation similar to `#shift`.\n. @dubek, thanks for this suggestion. Please have a look at the latest `master`.\n. @dubek, the value of `@comparator` doesn't matter for an empty sorted set; its job is to determine the order of elements, but an empty set has no elements to order. (But if you can see some case where it would make a difference, please let me know.) _However_, you do have a good point: if called on a subclass, `#drop` and `#take` should return an instance of the subclass.\n\nDo you need assertions in the \"middle\" of methods? Or would checking assertions on method entry/exit be enough? If so, I can think of a way to do it with no performance impact in \"production\". (Write a class macro which \"hooks\" a method with pre/post assertions _only_ when the tests are running.)\n. PS. Just pushed a fix for the problem you noticed with `SortedSet#take` and `#drop`.\n. OK,  now I see why we need the `@comparator` _even for_ an empty sorted set. Do you think `#clear` should do the same?\n. OK. You are absolutely right about that.\n. @dubek, right now there is no way to check if 2 `SortedSet`s have the same order. If you want to do something like that, the best I can think of would be to check if both are using the default order, and switch to the faster code if they are. (Perhaps use a single, canonical `Proc` object for the default comparator.)\n. I just experimented with loosening the balance requirements for `SortedSet`. Surprisingly, it makes insertion performance slightly _worse_.\n\nRetrospect: Since our AVL trees are immutable, each insertion means copying all the nodes to the root, at the very least. Allocating a couple more nodes here and there to rebalance the trees doesn't add much overhead on top of that. And keeping the trees in very strict balance means you don't have to traverse down as far for the next insertion.\n. I've checked off the proposed optimization for `SortedSet#delete_at`, not because I've done anything about it, but because it is too trivial to worry about.\n. While working on one of these optimizations, I just discovered and fixed 2 bugs in `SortedSet`!\n. @eigenhombre, thanks very much for pointing this out. The intention is that `Vector#uniq` should behave like `Array#uniq`, unless a strong case can be made for doing otherwise. So the question is, does  Ruby's `#uniq` always choose the first of equivalent objects? If not, the test is in error and should be removed.\n. @eigenhombre, do you mind checking how MRI's `Array` handles this?\n. I suggest we just amend the test to check equality rather than identify `if RUBY_VERSION == '2.1.0'`. In either case, Hamster is matching the behavior of Ruby's collections.\n. OK, that's a good idea. Let's do that.\n\nOn Wed, Oct 22, 2014 at 5:51 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> I'd just rather drop 2.1.0 support.\n> On Oct 21, 2014 10:46 PM, \"Alex Dowad\" notifications@github.com wrote:\n> \n> > I suggest we just amend the test to check equality rather than identify\n> > if\n> > RUBY_VERSION == '2.1.0'. In either case, Hamster is matching the\n> > behavior\n> > of Ruby's collections.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/137#issuecomment-60033026.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/137#issuecomment-60033278.\n. @egnech, thanks for reporting this issue. When you say you \"can't require and use Hamster in an app\", what do you mean? What exactly happens when you `require 'hamster'`?\n. Can you please try to remove the `\"~> 1.0\"` version requirement? Version 1.0 of Hamster has not been released yet.\n. Version 1.0 is most of the way there. Do you want to help us finish it more quickly? Have a look at the outstanding issues.\n. `Hamster.from` is interesting, I hadn't thought of anything like that. I\nthink the code would read better as `nested2.get_in('a', 'b', 'c')` rather\nthan `nested2.get_in(['a', 'b', 'c'])` -- in other words, make the\nsignature `get_in(*keys)` rather than `get_in(keys)`. Likewise for\n`update_in`.\n\nIs `#merge_deep` only for nested `Hash`es? I'm guessing the answer is yes.\n\n@krainboltgreene, what do you think about this?\n\nOn Tue, Oct 21, 2014 at 10:01 PM, Dov Murik notifications@github.com\nwrote:\n\n> I'd like to suggest adding operations for handling nested Hash and Vector\n> data structures, more or less along the lines of\n> https://github.com/facebook/immutable-js#nested-structures ; here's a\n> suggestion (following closely the immutable-js interface):\n> \n> document = { \"a\" => { \"b\" => { \"c\" => [3, 4, 5] } } }nested = Hamster.from(document)# => Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => [3, 4, 5]]]]\n> nested2 = nested.merge_deep({ \"a\" => { \"b\" => { \"d\" => 6 } } })# => Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => [3, 4, 5], \"d\" => 6]]]\n> nested2.get_in(['a', 'b', 'd'])# => 6\n> nested3 = nested2.update_in(['a', 'b', 'd']) { |value| value + 1 }# => Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => [3, 4, 5], \"d\" => 7]]]\n> \n> Basically I want to use immutable data structures (Hash, Vector) to\n> manipulate JSON-like documents.\n> \n> I'd like to here your opinions.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/140.\n. `Hamster.from` does a \"deep\" conversion of Ruby Hashes, etc to\n`Hamster::Hash`es.\n\nThis proposal seems to be influenced by Clojure -- note that `get-in` and\n`update-in` are core functions in Clojure.\n\nOn Wed, Oct 22, 2014 at 6:52 AM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> What's the point of Hamster.from?\n> \n> As for Hash#merge_deep I'd rather have it as a toggleable thing on\n> Hash#merge. We need to talk about merge semantics, too.\n> \n> Finally, for Hash#get_in...I like it, but we're getting close to tackling\n> http://goessner.net/articles/JsonPath/. ;)\n> \n> Overall these are things I think _need_ to be in hamster, but we're going\n> to need to talk about _how_.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/140#issuecomment-60036461.\n. The issue here isn't just `[]=`. The issue is that because Hamster collections are immutable, once you drill down to a \"leaf\" collection and insert into it, you have to \"retrace your steps\" back up to the root, inserting each \"modified\" child collection into its original parent, to get a \"modified\" parent collection.\n\nI think that we should add `#update_in`.\n. \"Is there a way to overcome this\"?\n\nYes, there is. Divide up the incoming key-value pairs into groups with the same `(hash >> @significant_bits) & 31` value; there will be 32 groups at most. Recursively use `#bulk_put` to insert each group into the correct child node.\n\nIt's unfortunate that this virtually requires initializing a new `Array` to hold the key-value pairs, and sorting the `Array` (by hash code). You can avoid initializing a new `Array` for each recursive call -- just pass down the original array, with `from` and `to` indices to delineate the range of items to be inserted.\n\nSome benchmarking would be in order, to see if this actually makes things much faster. (I wrote an implementation of `Hamster::Hash` in C once, and it made a _big_ difference in C.) Even if it does, you'll probably want to use a conditional on the number of keys, and use something like the existing code (that is, your code, from the current PR) when there are only a few.\n\nOnce that is done, it may be possible to remove `Trie#put!`.\n\nTo @krainboltgreene, I would just suggest that since `Trie` is purely internal, raw performance counts for more than nice object-oriented design. Maybe we can extract some repetitive bits of code from various methods in `Trie`, and pull them out into new methods, without impacting performance much. If so, that might help to \"trim down\" some of those big methods.\n. It's interesting to see that the current patch is most effective when merging _small_ sets or hashes. That is because it only avoids unnecessary copies of the root, not of children. I'm looking forward to see what the benchmarks look like when avoiding unnecessary copies of children as well. \n. \"Instead of sorting\"... Yes, that is better.\n. ...Or maybe the best of all would be to try both and benchmark. In any case, if you can come up with something faster than what we have now, that will be an improvement.\n. @dubek, can you push the code you are working on to a branch on GH and I can look at it?\n. @dubek, I tried working on your latest code and seeing if I could make it faster, but it's still much slower than your original commit. Sorry that my idea was a failure. I suggest that we can merge your original commit in and close this PR.\n. @dubek, I have rebased your original commit onto the latest 'master' and merged it in. Would you like to do more work on this, or call it done?\n. @dubek, thanks!!! If you want to continue optimizing `Trie`, a method for bulk deletion would also be help.\n. @krainboltgreene, can you explain more about what kind of structure this is? I guess it's more than just an ordinary mutable dictionary, with `#delete`, etc. `undef`'d?\n. Is this still an issue we want to work on? If unsure, I suggest it can be triaged.\n. Closing for now, please re-open if anyone discovers this is really needed.\n. It would just be better if we have different READMEs for GitHub and for compiled RDoc documentation. When I run RDoc on my dev PC to produce local HTML documentation, it is irritating when it contains badges.\n. It's icky, but we could duplicate the README file, and make RDoc use the\nversion without badges.\n\nOn Sat, Oct 25, 2014 at 10:38 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Ideally I'd want first class support for badges at Github, but barring\n> that...What can we do?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/149#issuecomment-60496607.\n. The fact that you have written docs and tests is great. I like both `#put_in` and `.from`, but would like to hear what @krainboltgreene thinks as well.\n. As long as it's implemented using methods which both `Hash` and `Vector` respond to, you are fine. `#put_in` uses `#fetch` and `#put`. Are both of those implemented by `Hash` and `Vector`, and with the needed semantics? If so, just copy the definition of `#put_in` into `Vector`.\n. Using an EmptyHash seems most reasonable. I personally feel that extracting\nan extra module is just gratuitous complexity at this point, though others\nmay have a different opinion. If the number of shared methods was greater\nthen a module would start to make sense.\nOn Oct 30, 2014 8:22 PM, \"Dov Murik\" notifications@github.com wrote:\n\n> And there's an assumption that if a key doesn't exist create it with\n> EmptyHash. Do you think it's reasonable to leave it this way?\n> \n> Also: maybe extract #put_in to a NestedOperations module and include it\n> both classes?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/150#issuecomment-61143698.\n. This is rather unfortunate. It would be nice to have that symmetry between `Vector`s and `Hash`es, so you can also use them polymorphically in some cases. Do you think that as a verb, `#set` sounds more natural than `#put` for a `Vector`, or just the same? Would it be a good idea to alias?\n. Maybe update_in is the best compromise.\nOn Oct 31, 2014 6:55 PM, \"Dov Murik\" notifications@github.com wrote:\n\n> Or we can leave everything as-is (Hash#put and Vector#set) and call out\n> nested method update_in (in both) to celebrate it's Clojure origin :-)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/150#issuecomment-61291911.\n. Looking good. I just commented on one line where I think you can make a performance improvement. Otherwise I can't see anything else to improve. Really good work here.\n. Merged. Thank you!\n. Looks good!\n\nJust to provide some background: I added `Hash#store` simply to match the interface of Ruby's built-in `Hash`. So, for example, if you have a library which takes a Ruby `Hash` as an argument, but doesn't mutate it, you can pass a `Hamster::Hash` instead.\n\n`Hash#store` isn't really a frequently used method for Ruby `Hash`es, so maybe it doesn't make much of a difference. Anyways, that is why it was added.\n\nThe only difference now between `#put` and `#store` is that `#put` can take a block which can be used instead of the second argument. Ruby's `Hash#store` doesn't do that, so I made a new method which duplicates the behavior of Ruby's `Hash#store`, rather than aliasing `#put`.\n\nTo be honest, I don't really care much about how aliasing `#put` affects behavior as regards inheritance. We are not providing a spec of how each method behaves under inheritance. If people want to inherit and override existing methods, it is their job to read the code and understand how it works. (Just my opinion!)\n\nI'm merging your code in now.\n. Looks good, merging.\n. Looks good, merging.\n. The only thing I can think is that _maybe_ `Hash#filter` and `Set#filter` could build up an Array of keys to remove and then `#bulk_delete` them. I'd like to see how this affects the performance characteristics of `#filter` both for large/small collections and cases where filter keeps most keys/rejects most keys.\n. Otherwise, the code looks good!\n. Looks like a win across the board! Nice work! Merging now.\n. @krainboltgreene, what do you think of giving @dubek commit rights?\n. Ooh, nice catch. Merging.\n. That failure has nothing to do with this patch. Probably my clever (?) code for lazy lists performs badly under Ruby 2.0.0. Can you open an issue for that, and I'll look into it when I have time? In the meantime, I'll merge this patch.\n. Looks good, thank you. Merging.\n. It's fine either way. People who use the gem are affected more by the gem name, not the GH organization and repo name.\n. @krainboltgreene I have a fork of this gem going called `immutable-ruby`, repo is here: https://github.com/immutable-ruby/immutable-ruby. Not sure if it will garner much attention. If you want to work on it, just say the word and I will give you commit rights.\n. But `hamster` already has existing users, and we don't want to break things for them.\n. Just pushed a fix in 2d91299. Thanks for noticing this.\n\nIf we want to add tests to make sure this doesn't happen again, they can't run in the same Ruby process as RSpec. I guess they will have to look something like:\n\n```\ncode = <<END\n  require 'hamster/set';\n  set = Hamster::Set.new([1,2,3])\n  raise 'bad' unless set.group_by { |x| x }.eql?(Hamster::Hash.new({1 => 1, 2 => 2, 3 => 3}))\nEND\n`ruby -e \"#{code}\"`\n$?.exitstatus.should == 0\n```\n\n...Does anyone have a better idea?\n. Good work, I am applying this patch. The test for `#find_index(nil)` is broken; we simply never tested this before. It doesn't work, because `nil` can't be compared with a `String`. I don't think this is something we can fix.\n. It's great you are finding this stuff. These are exactly the kind of things I want to work through before the 1.0 release.\n. The fact that a `Vector` can be extended by only 1 was deliberate; I did it that way simply because it was easier to implement. If you want to improve this, that would be great.\n\nThe point about how an empty `Vector` can't be extended is a bug, and needs to be fixed.\n. Pushed a fix with e25f564. It is still only possible to extend by 1, feel free to fix that if you like.\n. We are pushing closer and closer to a major release. Which of the remaining issues should be resolved before a new major release?\n. Do you think that an existing Hamster structure, like the immutable `Hash`, might help you implement your immutable struct? If so, you could write your own library which relies on Hamster.\n\nIn any case, I think the relationship between an immutable struct and the existing Hamster structures is weak, and it would be better to write a separate library. Small is beautiful. Adding more features bloats both code size (making the library harder to maintain) and the documentation (making it harder to learn). If those new features have some inherent synergy with the existing features, if they combine in ways that makes the whole larger than the sum of its parts, then putting them together may be a good tradeoff. Otherwise, let them go their separate ways.\n. Thanks for the report... I'm trying to duplicate it but haven't been able to yet. `0.4.3` is positively ancient -- we want to release a `1.0.0` version but were trying to get the whole library really, really right first.\n\n@krainboltgreene, what would you think of cutting a `0.9.0` gem, so people will stop using `0.4.3`?\n. Just thinking about that some more... we have already broken backward compatibility with `0.4.3`. Would releasing `0.9.0` mean that some people unintentionally get upgraded when they `bundle upgrade`, thus breaking their code?\n. @joelmccracken, we have a _ton_ of bug fixes, performance upgrades, and enhancements of every kind in edge `hamster`. The biggest thing remaining before we ship `1.0.0` is [this](https://github.com/hamstergem/hamster/issues/128). Since it seems that you are using Hamster for \"real\" work, would you be willing to upgrade to edge and see how it works for you?\n. Even for \"just\" a game, it will help. Each person will use things in a way that others might not think of, so the more people who try it, the more bugs we are likely to find.\n. Anyone else want to make your voice heard, before the axe drops? @dubek? Others?\n. One advantage of the `List` methods is that they are lazy. In any case, I don't think we can have everything. If we want everything, the library will bloat, and probably nobody will actually learn and use all those methods.\n\nSo we are looking at either the brevity of `indices`, or else make things more similar to built-in classes with `find_indices`.\n. It is lazy -- if you just need 2 of the indices, it will only scan as much as of the List as is needed to find 2. That is what the `LazyList.new { ... }` block is for -- deferring execution until needed.\n\nI've gone ahead and cut down to just `#indices` in 9dd521c.\n. In any case, @xbeta, thank you for your interest in Hamster! (And thanks to @dubek for explaining things.) If you need a mutable queue, I suggest you use the one in the Ruby standard library.\n. @xbeta, nothing is stopping 2 threads from doing those things at the same time. You can \"stop\" them by locking, just the same as with a mutable queue. Or, you have another option, which doesn't exist with a mutable queue: you can retry an atomic compare-and-swap until it succeeds. Or, your queue might exist only on the stack of one thread, meaning it can never be shared with another thread.\n. This seems really useful. Although we have tried to make Hamster collections interface-compatible with built-in Ruby collections, there are times when you want one or the other. I'm just not sure about the name `Hamster.to` -- it is symmetrical with `Hamster.from`, which is nice, but it doesn't seem to describe what it does very well.\n\n`to(arg)` implies that you are converting something to... something described by `arg`. But actually `arg` is what is being converted. That's just English grammar; it might be different in other languages, but to an English-speaking programmer, that is what the syntax brings to mind.\n. We already have `Vector#to_a`, etc. If we are missing other obviously useful conversion methods, we could think about adding them. But this is something a bit different.\n\nAny opinion from @dubek?\n. \"Stack consistency error (sp: 153, bp: 154)\" on Ruby 2.3.0dev! This\nobviously has nothing to do with @elben's code, so it won't stop it from\nbeing merged in.\n\nOn Tue, Mar 17, 2015 at 3:48 AM, Elben Shira notifications@github.com\nwrote:\n\n> Also, the Travis CI build fails on ruby-head with what seems to be an\n> interpreter bug. Know anything about this?\n> \n> https://travis-ci.org/hamstergem/hamster/jobs/54632445#L3490\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82025852.\n. I think `#to_ruby` reads better than `#to_mutable`. Is it as clear and accurate?\n. A couple comments on the `Class[]` syntax: it was chosen for symmetry with Ruby's built-in `Hash[]`, `Array[]`, and `Set[]`. (If you didn't know about these before, try them in `irb`!)\n\nPreviously, a Hamster `Hash` used the same print syntax as a Ruby `Hash`. If you use both in the same program, this meant that when printing things in `irb` or using debug print statements, you couldn't tell which was which. Also, the print syntax could not be `eval`'ed to get an equivalent structure.\n\nThe primary disadvantage of the current print syntax is its verbosity. If we could extend Ruby core syntax and add our own data structure literals, that would be better, but it's not possible (not unless immutable data structures were merged into the Ruby interpreter itself).\n. We are making progress here but there is still some work to do. Some things I can see:\n- You define a `Convertable` module and then never use it. I would suggest it can just be removed. The method is so short there's not much point in pulling it out into a mixin.\n- Making `Hamster.from` support `SortedSet` is good, but you need to `require \"hamster/sorted_set\"`. Please pull the added support for `SortedSet` in `Hamster.from` out into a single commit of its own, along with the added tests.\n- All the work related to `Hamster.to_ruby` should be squashed into a single commit. `git rebase --interactive` is your friend here.\n- In your additions to `nested/construction_spec.rb`, the description for the tests for `Hamster.to_ruby` say that it \"should return Hamster data\". It would be more correct to say it \"should return Ruby data structures\".\n. One more tiny thing is to avoid whitespace changes which are unrelated to what you are doing, since they clutter up diffs. But I can clean that up myself when merging.\n. I think you are definitely right. It should return the value shown second in the comments.\n. Everything looks nice... merging...\n. OK, merged! I did some slight cleanup (moved `require \"hamster/sorted_set\"` to the commit which involves `SortedSet`, etc.), but naturally @elben is still credited as author and commit lines and dates are the same as I fetched from his repo.\n. @elben, there are lots of ways to work on git commit history, and my ways are probably not the best at all. In many cases I would do exactly what you just described. What I just did was a bit different:\n1. Fetch from your repo.\n2. From `master`, run `git format-patch master..remotes/elben/to-nested-ruby-collection`. Now there are a bunch of `.patch` files in the working directory.\n3. Apply the first patch with `git am`.\n4. Touch things up and `git commit --amend`.\n5. Look at it with `git show` to make sure everything looks good.\n6. Apply the next patch with `git am`...\n7. Repeat until done.\n. Hmm. Thanks for bringing this point up.\n\nI hate to pull in the whole `concurrent` library, which is quite large, for this one teeny-tiny little thing. If you ever have a look at the implementation of `Atomic`, you will see it is positively trivial. But vendoring our own version of `Atomic` would also be a pain.\n\nIn our case, we use `Atomic` to make sure that each node of a lazy list will be only be realized once, on one thread. In some cases, the code which is used to realize a lazy list may have side effects, so this is important.\n\nWhat do others think about this issue?\n. So do we just bite the bullet and pull in `concurrent`? Or do we detect whether the user has already `require`d `concurrent`, and use it if it is already available?\n. If there are no other objections, shall we go ahead with @dubek's suggestion?\n. Implemented @roryokane's suggestion in 25bda8c.\n. Sure, please do! Another option: instead of setting the atomic var to fixnums like 0, 1, or 2, use symbols. I'm pretty sure it will be just as fast (but a little benchmarking would be needed to confirm that).\n. Can you confirm whether === works with the string on the left side?\n. That is what I was also getting at. The `nil`s you are seeing when examining the structure of the trie are also normal.\n. _Is there a particular reason we create big nil-filled arrays?_\n\nYes. First of all, remember the key characteristic of any data structure used to implement a \"set\": it must support a fast inclusion test. You might think that you don't often use inclusion checks on your sets, and that all you really care about is that they never contain duplicate items. But, for that \"set\" to efficiently filter out duplicates, it needs a fast inclusion test.\n\nSo how is a fast inclusion test possible? Linear search won't cut it, as soon as you have any significant number of items. You need some way to find the desired item within the structure more or less \"directly\". We do this by hashing, and using the hash code to guide our search.\n\nFor a mutable \"set\", a traditional hash table using either chaining or linear probing would work fine. BUT, our \"sets\" are immutable. That means we need a way to do fast \"copies\" when an item is added or removed. That can be achieved using a **hash trie**. In our case, it's a tree with 32-way branching, with searches in the tree being directed by extracting groups of 5 bits from a hash code. @harukizaemon's implementation has the unique property of storing up to 32 child nodes _and_ up to 32 key-value pairs in each trie node.\n\nHow do we store those 32 items? You could use 32 instance variables, but the code would be grossly long and inefficient. Using a Ruby Array is much more reasonable.\n\nIn the example you showed, the \"query\" which you inserted in the set had 10100 in the 5 low-order bits of its hash code. Since the items stored in a trie node are numbered starting from zero, that meant it had to be stored as the 21st item. Now, when an object is stored into the 21st position in a Ruby Array, the lower positions have to filled with something, and that \"something\" is `nil`. We could use some other arbitrary object, but that wouldn't gain anything.\n\nMost implementations of a 32-way hash trie would actually allocate a 32-element array for _every_ node, regardless of whether the high-order positions were used or not. In our case, we save memory by only allocating an array of the needed size.\n\nIf we wanted to optimize for memory usage for programs which use huge numbers of very small sets, we could create one \"set\" class for small sets, and one for large sets. The \"small set\" class would pack its elements in an array and use linear search. As soon as the set got larger, it would automatically be converted to the class which uses hashing. I considered doing something like this, but decided it wasn't worth the effort.\n. Regarding `===`, what you actually need to try is something like this:\n\n```\n\"GET /accounts/1\" === earhart_route\n```\n\nIf that is false, then the behavior you are seeing from `#grep` is normal and intended. Please refer to the [documentation on Enumerable#grep](http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-grep).\n. `#find` is what you are looking for.\n\nNo, `Set` is not lazy. Only `List` is. Linked lists allow for a natural and efficient \"lazy\" implementation, but most other data structures do not. For comparison, Clojure has lazy lists which you can create using `lazy-seq`, but its other built-in structures are strict. Languages like Haskell achieve laziness not by providing a full set of \"lazy\" general-purpose data structures, but by delaying the evaluation of code until its results are needed.\n. The key point to take note of is that `#grep` calls `#===` with the pattern on the _left_ side. If `\"GET /accounts/\" === earhart_route` is true, then the behavior you are seeing is definitely a bug. However, in that case, it would be a bug in MRI, not in Hamster, because we are using the built-in implementation of `Enumerable#grep`.\n. Small is beautiful! :)\n. Is there any reason why we can't define a class method called \"new\" on List?\n. OK, fair enough. Agreed.\n. I just removed `Hamster.vector`, including updating all the documentation and specs, in f444320. Will push a commit which removes `Hamster.hash` next.\n. `Hamster.hash` removed in c102c1f. Now the `Hamster` module can be used as a key in a `Hash` or similar collection. (I doubt anybody ever tried this before.)\n\nQuestion: should `Hamster::Hash.[]` be able to take a default block? With `Hamster.hash` removed, people will have to use `Hamster::Hash.new` if they want to create a `Hash` with a default block.\n. `Hamster.set` removed in 8be58e3.\n. `Hamster.sorted_set` removed in 64261e6.\n. `Hamster.deque` removed in 809b6af.\n. `Hamster.list` removed in aba0a4b.\n. `.mutable_hash`, `.mutable_set`, and `.mutable_queue` shortcut methods have also been removed. This is now done.\n. Thanks for your input. I would actually like something like `Immutable::Set`, `Immutable::Vector`, and so on. `Hamster::ImmutableCollections::Set` is too long. Unfortunately, the name the project has inherited is \"hamster\". What would other contributors think about using `Immutable` as a namespace rather than `Hamster`? (Unfortunately, there is already an `immutable` gem. Not sure what they use for names.)\n\nBy the way, @nandosola, since you actually use this library, your input on the open PRs would be appreciated.\n. I've just created a fork of this gem called [immutable-ruby](https://github.com/immutable-ruby/immutable-ruby). It's unfortunate that the \"immutable\" gemname is taken...\n\nFunctionality is basically just like Hamster, but instead of `Hamster::Hash`, it's `Immutable::Hash`, and so on. Since there is no existing user base, I have \"cleaned up\" a bit by removing a few extraneous APIs. Otherwise it's just the same.\n\nI intend to continue maintaining both `hamster` and `immutable-ruby`. Any bugs reported against one gem will be fixed in the other. However, again, since there is no installed user base for `immutable-ruby`, it is a bit freer to evolve, at least until it hits its 1.0.0 release.\n\n@nandosola, please give it a try!\n. 2 points about this one:\n1. `LazyList` is not intended to be instantiated directly. That is why it is marked as `# @private`. Any code which directly uses a class marked `# @private` is not guaranteed to work. The behavior of these classes may be changed at any time, even in a minor release.\n2. When calling `LazyList.new`, you must provide a block. The block must return something which is also a list.\n\nLists are intended to be instantiated in 3 ways:\n1. By calling class methods on the `List` module, OR\n2. By calling `#to_list` on any `Enumerable`, OR\n3. By repeatedly `#cons`ing onto the canonical empty list.\n\nIf you would like to propose a different public API for the \"list\" code, please do so. Then the various contributors can discuss whether it is better than the API we have now, and whether it can be implemented efficiently.\n. Closing due to inactivity.\n. Please see the response to #172 to understand why it behaves this way.\n. Looks good. Merged (using fast-forward to avoid unnecessary branching in history).\n. So this issue will be fixed in the next release of JRuby?\n. This is a pretty brutal limitation of JRuby. I am surprised.\n\nThe PR looks good, I'll merge it.\n. Merged with fast-forward.\n. I'm not convinced that this is a JRuby GC bug. Looking at it now, the code is clearly not thread-safe.\n\nConcurrency is limited in MRI, and you can often get away without using any explicit memory barriers (to make sure that writes are visible from another thread). JRuby allows a lot more concurrency, which is likely why we are seeing this threading bug now. (It's painfully obvious, I don't know why I didn't see it before.) \n\nI'm going to try another fix... just a minute please.\n. @dzjuck, I have just pushed a branch called `attempted_race_fix` to this repo. Can you pull it and try running the JRuby specs again?\n. Thanks to @dubek for pointing out the issue with `List#span` -- I have pushed another commit to `attempted_race_fix`. (It would be nice if we had a spec which confirmed both the problem and the fix...)\n\nThanks to @dzjuck for finding the problem in the first place, and confirming the fix.\n\nRegarding the use of `remove_instance_variable` -- I wonder what the performance impact would be? Does anyone want to try benchmarking?\n. Well, it does use a Ruby method call, which must go through the (relatively slow) method dispatch mechanism.\n. Since the `attempted_race_fix` branch seems to have fixed the problem, and this thread has been quiet for a couple of days, I'm merging it in. Any other desired modifications can be done as new commits.\n. Looks good.\n. Merged.\n. Thank you for reporting this issue. A fix for the problem with\nSymbol#to_proc has been pushed to master (along with a regression test).\n\nYou are very right about the block being called more times than expected.\nWhat do you think is the most useful behavior here? Does it matter to you\nthat the block should only be called once? Or would just adjusting the\ndocumentation be enough?\n\nOn Mon, Jun 8, 2015 at 10:44 PM, Dov Murik notifications@github.com wrote:\n\n> Good catch!\n> \n> Indeed modifying the arity condition in\n> https://github.com/hamstergem/hamster/blob/master/lib/hamster/sorted_set.rb#L103\n> to:\n> \n> if block.arity <= 1\n> \n> fixes the problem (both with the &:name syntax and the weird |*a| block).\n> \n> I'm not sure about the promises about the number of times the block is\n> called.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/179#issuecomment-110132914.\n. OK, sounds good. I'll work on a patch.\n\nOn Wed, Jun 10, 2015 at 6:40 PM, Rafael Cabral Coutinho <\nnotifications@github.com> wrote:\n\n> I think it would be desirable that the behavior followed Array#sort_by.\n> Less surprising, and a better option for expensive key computations, since\n> currently there's no difference in using #sort or #sort_by for such keys.\n> Then, the docs are fine.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/179#issuecomment-110827061.\n. Fixed in 50eaf97. @rcabralc, please check whether the fix works for you and re-open this issue if not.\n. `Hamster::Vector.new` is different from the other 3 because it always initializes a new collection.\n\n`Hamster.vector` was supposed to be a shortcut to make initializing a vector more concise, like `Hamster.vector(1,2,3)`. I think this is redundant; people can define their own shortcuts if they want to. At the same time, you can get the canonical empty vector with `Hamster.vector`. But that doesn't communicate very well what it is doing. `Hamster::Vector.empty` or `Hamster::EmptyVector` is clearer.\n\n`Hamster::EmptyVector` is needed, because we need somewhere to store the canonical empty vector. (Well, a class variable could also be used.) But it could be marked `# @private` and not included in the official public API.\n\n`Hamster::Vector.empty` has the advantage of polymorphism; you can do something like `collection.class.empty` and get an empty collection of the same type as one which you already have. But we have `#clear` for that, and it can easily be reimplemented to avoid using `empty` if we want to remove it.\n. Dropping `Hamster.vector` is a good idea.\n\nPolymorphism _could_ be useful, but not for inheritance. Where it comes in handy is when creating generic collection-manipulating functions which can operate on any type of collection, and return the same type which is passed in. This is fairly common in Clojure. Though, as I said, you could remove `Vector.empty`, and this could still be done using `Vector#clear`. The only difference would be that rather than being implemented using `empty`, `#clear` would have a separate implementation for each collection type.\n. The `EmptyVector` (etc.) constants are now all marked as private. So they are now implementation details, not part of the API. The shortcut methods like `Hamster.vector` have all been removed.\n\nThat leaves us with `Vector.new` and `Vector.empty` which both return an empty collection. I think this resolves the issue of too many redundant API methods.\n. Wow, this is just the kind of thing I was hoping for when I opened this issue. Nice! Note that \"syntax\" is not a countable noun -- \"a syntax\" sounds strange.\n. \"data structure\" is 2 words, not 1.\n. \"Otherwise\", not \"Otherwie\".\n. \"calling the block with the key\", not \"called the block with the key\".\n. OK, I think this is good to merge. The one thing is that the documentation for `#to_ruby` is not quite accurate -- it says \"no Hamster structures will remain\", but `#to_ruby` doesn't convert `Hamster::Deque` into core Ruby structures. (Sounds like something we should fix...)\n. Merged. @xaviershay, thanks for your contribution. Please work on the docs for the other classes if you can.\n. I just fixed `Hamster.to_ruby` so it also converts `Hamster::Deque` structures.\n. Fixed. @xaviershay, thank you for reporting this issue! Your contribution is much appreciated.\n. Hmm. Do we really want to fix this?\n\nYour docs state: \"Behaviour is undefined when elements do not meet assumptions (i.e. are not indexable collections).\"\n\nI'm happy to leave this as \"undefined\". Or if you think it's better to match `Array` more closely, that is also fine.\n\nWhat MRI does: check whether each element is an `Array` (**or** is convertible to an `Array` using `#to_ary`), check whether it contains at least one item, and _only then_ compare the items, using `#==`. Any elements which do not pass the first 2 checks are ignored.\n\nThe docs should probably specify that `#==` is used for comparison.\n. @xaviershay, please have a look at the following branch:\n\nhttps://github.com/hamstergem/hamster/compare/vector_assoc_skips_bad_elements\n\nLook good?\n. I'd sooner let that fall under the umbrella of \"undefined behavior\". :smile:\n. 2 nice catches (both this and #183). Do you intend to fix both of these, or would you like me to?\n. Sounds good. Can you come up with an example where `Array#transpose` works but `Vector#transpose` doesn't?\n. Looking at this again, I don't think that calling `#to_ary` on all the sub-vectors is really desirable. It will add performance cost for no real gain.\n\nHave a look at this and see if you think it makes things better: https://github.com/alexdowad/hamster/commit/846b5889afbb19b396d811065f72adb08654c827\n. `to_ary` is used for implicit conversion... to a Ruby array. In some cases, when the Ruby interpreter wants an `Array`, but finds something else, it will call `#to_ary` on it and expect to get an `Array` back. So `#to_ary` needs to return an `Array`.\n\nIf there's something I'm missing, feel free to re-open this issue.\n. I see. That performance issue is a concern -- we want everything to be as fast as is practicable. But breaking `#to_ary` to make `#transpose` faster is not an option.\n\nRegarding \"implicit\" conversion to `Array`, that just means that the Ruby interpreter _internally_ converts an object to an `Array`. To see where and why this is done, consult the MRI code. (If you've never dug into it before, it's not that bad.)\n. Cool, sounds good.\n. Made this change to `Vector#uniq` in 1a73f23.\n. Wow, wow, wow. I didn't notice you had added so much here. Let me look through.\n. This was a lot of work! Thank you!! Let me go ahead and cherry-pick everything which is ready for merging right now.\n. I've merged most of these commits. Will comment on the ones which are not merged yet tomorrow. Thanks!!\n. Just added some more feedback.\n. OK, I've merged the last 3 commits (with a couple tiny edits). Thank you!! Great job!!\n. Just duplicated this with 2.3.0-dev. \"Stack consistency error (sp: 47, bp: 48)\". Intriguing!\n. I have a Ruby interpreter which I have built with full debug info, which makes the stack trace much better:\n\n```\n-- C level backtrace information -------------------------------------------\n/home/alex/Software/ruby/ruby(rb_vm_bugreport+0x51f) [0x55e28ea69acf] vm_dump.c:695\n/home/alex/Software/ruby/ruby(rb_bug+0xca) [0x55e28ead4f8a] error.c:414\n/home/alex/Software/ruby/ruby(vm_exec_core+0x59a6) [0x55e28ea5b856] insns.def:1031\n/home/alex/Software/ruby/ruby(vm_exec+0x72) [0x55e28ea5b902] vm.c:1472\n/home/alex/Software/ruby/ruby(invoke_block_from_c+0x5d4) [0x55e28ea5c634] vm.c:850\n/home/alex/Software/ruby/ruby(rb_yield+0x68) [0x55e28ea5c9e8] vm.c:888\n/home/alex/Software/ruby/ruby(rb_ary_each+0x3d) [0x55e28ea8609d] array.c:1820\n```\n. I've found what is causing this error. It would be nice if it was just a simple coding error, but unfortunately it seems to be more of a conceptual error in the design of the block-calling and argument-passing mechanism. If only I could wrap my mind around the right way to fix it up...\n. OK, sigh of relief. It seems that the fix wasn't as tricky as I had thought. Have a look: https://bugs.ruby-lang.org/issues/11451\n\n@xaviershay, I seriously doubted that this had anything to do with https://bugs.ruby-lang.org/issues/11071, but it turns out you were right! My patch also fixes that one.\n. @xaviershay, I said it in the Ruby core bug tracker, but I'll say it here too: thanks for reporting this problem!\n\nIf and when you run across a similar problem in the future, try to eliminate all gems and get a repro script which uses only core Ruby. You can do this by repeatedly inlining gem method calls (by hand), and checking each time to see if the problem still occurs (and backing up if it doesn't).\n\nAfter each inlining, you will usually be able to delete some unneeded code and simplify what remains. After each change, check again to see if the script still crashes or not. If inlining makes the crash \"disappear\" -- in other words, if the method call itself is part of the problem -- just copy-and-paste the gem code into the repro script. Then remove as much as you can, while checking that the crash still occurs.\n\nYour repro script was already quite small, which was a big help. But I reduced it further down to this:\n\n``` ruby\nclass Yielder\n  def each\n    yield [1,2]\n  end\nend\n\nclass Getter1\n  include Enumerable\n\n  def each(&block)\n    Yielder.new.each(&block)\n  end\nend\n\nclass Getter2\n  include Enumerable\n\n  def each\n    Yielder.new.each { |a,b| yield(a) }\n  end\nend\n\nGetter1.new.map { Getter2.new.map {} }\n```\n\n`Yielder` was originally `Hamster::Trie`, `Getter1` was `Hamster::Hash`, and `Getter2` was `Hamster::Set`. The core Ruby devs will appreciate it if they don't have to wade through 1000s of lines of gem code to track down a crash. (More realistically, they may actually look into it rather than ignoring it.)\n. So, having said all that, now we can look at fixing up Hamster. I would suggest that we apply @xaviershay's fix, _with a comment_ stating that the modified code is for MRI 2.2.2 compatibility and that the change will be reverted when 2.2.2 is sufficiently old. (Because the changed code will almost certainly be slower.) Whenever that time comes, we can add a warning message if someone uses the gem on MRI 2.2.2.\n\nComments from other contributors? @dubek @krainboltgreene \n. Already merged @xaviershay's fix.\n. Thanks for the fix -- but I would like to dig into the interpreter code and find out exactly why it is segfaulting before we merge any fix.\n. Looks great, let me merge.\n. Merged.\n. Don't worry about the \"barrage\". You are making the library better. We will examine each of your patches, though as you said it may not happen all at once.\n. Merged (with tweaked commit message for brevity). Thank you!\n. For `SortedSet`, the index is integral, starting from the far \"left\" of the tree. For `Set`, you could say that each item is its own index, but I don't know how useful that will actually be. Probably `Set` will not have `#update_in`.\n. Not needed, since we have identified what is causing the problem and can fix it right away.\n. Looking at the graph, I've also noticed that `hamster/version` is only `require`d from the main `hamster.rb` file. It should probably get pulled in by all of the individual structures as well.\n. Let me draw attention to another thing: `nested` pulls in _all_ the collection classes. And almost all the collection classes pull in `nested`. So loading any one of them results in all the others getting pulled in as well.\n\nOriginally, it was possible to load the `Hamster` collections selectively. This is not true any more. Do we care?\n\nWhat if the `nested` methods, like `Hamster.from`, were defined in `lib/hamster.rb`, and would only be available if the library was loaded with `require 'hamster'`, not if a specific collection was loaded with `require 'hamster/vector'` (for example)? Would that be better?\n. After discussion in another GH thread, `#to_ruby` was removed in 30a6aa8. Here is what the sourcefile dependency graph looks like now:\n\n![depgraph](https://cloud.githubusercontent.com/assets/1067359/9793594/6c8d7c64-57e6-11e5-81e3-aba8d0002d6f.gif)\n. Interesting -- comments from other contributors, please?\n. To add another comment: `List.from_enum` could also be called `List.new`... though that might confuse people by implying that `List` is a class, which it isn't... comments?\n. OK, it sounds like @dubek likes this, and the other contributors haven't commented. I guess we go ahead and merge?\n. OK, merged.\n. Again, very interesting. I hadn't thought of doing it this way. Comments from other contributors?\n. As an opinion, I don't think switching on object class is _always_ a \"code smell\". It's a question of how you want to organize your code: would you rather have all the code for `Vector` (as an example) together, or would you rather have all the code for conversion to Ruby structures together? The second consideration is whether new classes which should be convertible to Ruby structures are likely to be added frequently.\n\nI would be happy to just use `Hamster.to_ruby(obj)` rather than `obj.to_ruby`. It seems that @dubek likes this option. @xaviershay hasn't expressed an opinion. Preferences, anyone else?\n. @xaviershay, that's not a problem, since `#to_ruby` was not even included in the last gem release. (Have a look at the git history.)\n. It seems no further comments are forthcoming? So can we go ahead and remove the per-class `#to_ruby` methods, and let people use `Hamster.from` and `Hamster.to` instead?\n. @xaviershay, would you like to code up a patch for this? If you don't want to, I will go ahead and do it.\n. Just removed `#to_ruby` in 30a6aa8. Our problems with circular dependencies are greatly reduced. Have a look:\n\n![depgraph](https://cloud.githubusercontent.com/assets/1067359/9793532/2886fb44-57e6-11e5-9650-9ff0716a4953.gif)\n. @dubek I just updated the docstrings for `.to_ruby` and `.from`.\n. Ah, OK. That makes sense.\n. ACK\n. Applied with some minor cleanup. Thanks!\n. @Bill, list comprehensions are definitely a powerful feature. But can you propose a syntax which the Ruby interpreter can parse?\n. `instar` does look powerful, though I doubt that it is something which we would do in Ruby.\n\nI'm missing what `assoc-in` gives you which Hamster's `Vector#update_in` and `Hash#update_in` don't. Could you explain?\n. @Bill, thanks for this suggestion. Comments from other maintainers?\n. For better or worse, Ruby is an class-based OO language which relies heavily on class-based method dispatch. All the core Ruby classes work this way. Therefore, I suggest that we keep `#update_in` on `Vector` and `Hash`. But extracting the code into a module is a good idea.\n\n@Bill, would you like to code up a PR? Adding to the README at the same time would be good.\n. I second this! We have also fixed several bugs since `1.0.0` was released.\n. Yes, it's @krainboltgreene. `1.1.0` gem, please!\n. Committed with @dubek's suggested implementation.\n. Defining extra methods on `Object` and `BasicObject` in library code is to be avoided at all costs, _unless_ the purpose of the library is specifically to add those methods.\n\nSince all Ruby code in a process shares the same `Object` class, `Array` class, `Enumerator` class, and so on, adding methods to those classes is like adding them to the global namespace. We should \"tread lightly\" on the global namespace; adding methods at will tends to cause incompatibilities between libraries, and the application programmer may have had their own ideas about what they wanted to do in that global namespace.\n\nThat's why we don't add helper methods to `Enumerator` unless the user specifically requests them by requiring `hamster/core_ext/enumerator`.\n\nI can't speak for the other maintainers, but I am very open to suggestions about how better to implement `hamster/nested`. However, that \"better\" way should not just be \"better\" in stylistic purity while sacrificing things which really affect our users (like performance, etc).\n\nI haven't found an arguably better way yet.\n. @Bill, although it looks like we may keep `hamster/nested` as it is for now, please let us know any other ideas which you have for improvement! Your opinions are valued.\n. Looks good to me. I'd just like to adjust some spacing in `README.md` before merging.\n. Merged with some cleanup:\n- Made commit message a bit shorter\n- New docs in YARD-README.md also added to README.md (the latter is specifically for GitHub)\n- Syntax highlighting in README example\n- Code formatting in README example\n- Squashed the 2 commits here into 1\n. @Bill Thanks for the great work!\n. Looks nice!\n. The problem is that you are storing a mutable object in `Hamster::Hash`, and using destructive (mutating) methods on it.\n\nUse `name + 'sy'` instead and it will be fine.\n. The main GitHub page states about this:\n\n> While Hamster collections are immutable, you can still mutate objects stored in them. We recommend that you don't do this, unless you are sure you know what you are doing.\n. Thanks, but this is known and expected behavior, not a bug. As the documentation states:\n\n> While Hamster collections are immutable, you can still mutate objects stored in them. We recommend that you don't do this, unless you are sure you know what you are doing.\n. Thanks for bringing up what is a very real issue with using immutable data structures in Ruby!\n\nI think that `#put_if` is just a special case of a pattern which says: if some condition holds, get a modified copy of this immutable data, and if it doesn't, get the original. The modification could be `put`, or it could be deleting a key, filtering, mapping, etc.\n. Using Ruby's blocks, you could do something like:\n\n``` ruby\nhash.if(condition) { |h| h.put(:foo, :bar) }\n```\n. > feel free to close this\n\nI don't want to close it. I would like to keep it open and hopefully get ideas from other interested parties.\n\nI just hope we don't add more methods to the API without really making sure that it is the right decision.\n. > At this point, there is no win for using \"immutable\" data structures\u2014you're now mutating the pointer!\n\nMutating the pointer can still be a win in some cases. You don't have any aliasing bugs that way. Ask me how many times I have written code with aliasing bugs... (I can't count.)\n\nCertain algorithms are easier to code correctly and efficiently when you have immutable data structures like Hamster's.\n\nHamster has been very deliberately designed so that our structures integrate well with code which uses the core Ruby structures. At least, that is the goal. So you don't necessarily have to convert all your Ruby code to \"everything immutable, all the time\".\n\nMy preference would be to use the plain old mutable Ruby structures locally (such as a temporary structure which is used within a single method and then discarded, or a structure which is passed between a few `private` methods). This is akin to the use of \"transient\" structures in Clojure. The benefits of immutable structures are greater for data which is accessed in many disparate places. OR, when coding an algorithm which involves backtracking, etc.\n\nIf need be, you can convert an immutable structure to mutable on method entry, hammer on it, then convert it back to immutable before returning.\n\nOf course, if you want _all_ your code to use immutable structures, all the time, that is also OK. Definitely, some of Ruby's core language syntax (for control flow, etc.) may not serve you well in that case.\n\nIt might be possible to (partially) work around the problem using some of the ideas in this thread. However, I think that Hamster really exists just to provide immutable data structures, not as a general solution to all the problems of writing pure-functional code in Ruby.\n\nOf course, `#put_if` is a useful helper method, even if we are not trying to provide that \"general solution\". But I am concerned about the proliferation of `_if` methods which might ensue.\n\nI would suggest that:\n1. If you find that methods like `#put_if` really help a certain program, create a local extension for Hamster. Ruby has open classes for a reason, after all.\n2. Some of these other ideas could become little libraries of their own. (Like @Bill's hamstar -- I am happy to see this kind of cross-pollination of ideas, whereby the work done here enables people to explore and innovate in new directions of their own.)\n3. If you really find that `#put_if` is so compellingly useful that you keep coming back to it with every program you write, push harder to have it included in Hamster!\n\n> \"No More Ruby\" Bill\n\nI hope Hamster hasn't turned you off Ruby! Maybe there is another language which works better for your purposes?\n. > I could rewrite it to select the concurrent-ruby version that's installed on the machine, but that seems a bit brittle.\n\nIt would be nice for the users if Hamster \"just works\" with whatever version of `concurrent-ruby` they use. But maybe it's reasonable to expect that everybody should upgrade to at least version 1.\n\nWe should also accept `1.1`, `1.2`, and so on, when they are released. Let's not lock the users down to a very specific version of `concurrent-ruby`.\n. That should be `~> 1.0`, not `~> 1.0.0`.\n. Merged manually into `master`. @Ch4s3, thank you for your contribution!\n. :+1:\n. Thanks @dubek!\n. Nice catch! Looks like this problem dates back to 2013.\n. @xaviershay , do you want to amend the test so it actually checks that `#grep` maps results through the block? Or would you like this patch to be merged first?\n. I must have accidentally clicked \"Comment and close\" rather than \"Comment\". That wasn't my intention. Sorry.\n. Good catch. This is definitely a bug; a bug in specification.\n\nI would prefer just to bump the minor version number after applying a fix. @krainboltgreene?\n. I think this is ready to merge. Yes, it would be nice to unify the code between `Hash` and `Vector`, but I think that can be done in a separate PR. @dubek, would you like to merge?\n. > Does it make sense to add dig to the Associable module\n\nIt does. `dig` is about recursive retrieval from nested, associable structures.\n. Any comments from other contributors?\n. > I can't think of a good way of implementing this with fetch\n\nIf so, adding a dependency on `get` is not really a problem.\n. I think this is ready to merge.\n. I like it!\n. Thanks for the link!\n\nI just looked at the page, and the \"compact\" representation which they show is actually very similar to what JVM Clojure uses for nodes which are less than half full. The idea of separate buckets for key/value pairs and subnodes is similar to what Hamster uses. I need to read the paper for details, though.\n. Hmm. One issue with using a packed representation for nodes, is that Ruby doesn't have a fast, built-in popcount (count number of 1 bits in a number) operator. JVM Clojure uses popcount to convert logical indices to physical indices in a packed node, and this new CHAMP representation would need the same.\n\nI have created a gem called `bit-twiddle` which provides a fast popcount operation for Ruby; we could use it, but it would need to also have a pure-Ruby version for JRuby/RBX.\n. The pseudocode for deletion in Steindorfer and Vinju's paper is faulty; still, the idea is clear. And it is a good idea.\n. An alternative to using `bit-twiddle` would be for me to code up a C extension for Hamster, which replaces `Trie`. I was planning to do this for the `immutable-ruby` gem, but it doesn't seem to have much traction. Perhaps people like \"Hamster\" better?\n. > What is the difference between that\n> gem and hamster?\n\nIt's a fork of Hamster which uses a different namespace. Structures are `Immutable::Hash`, `Immutable::Set`, and so on. Otherwise everything is the same.\n. @dreammaker, any discussion of `immutable-ruby` can be done from its GH page. This location is for discussion of `hamster`.. @hzulla Thanks for your interest in Hamster. I have adjusted the gemspec to include the license file in the gem.\n\n@krainboltgreene New minor version?\n. @krainboltgreene There is a funny build failure whereby Travis CI can't install the Hamster gem on certain Ruby versions. I am looking at it.\n. Looks like Travis CI is using an old version of Bundler. From their output:\n\n```\n$ bundle --version\nBundler version 1.8.4\n```\n\nOn my PC:\n\n```\n21:42 ~prog/Ruby/parser % rbenv shell 2.3.0\n21:42 ~prog/Ruby/parser % bundle --version\nBundler version 1.11.2\n```\n\nIn [this thread](https://github.com/bundler/bundler/issues/3560), one of the Bundler devs stated that he thinks this bug should be fixed by a commit which made it into v1.11.2.\n. @hzulla Why not just submit a PR rather than patching the code downstream?\n. @krainboltgreene Can you go ahead and cut a new minor release? It looks like the Travis CI failure is a problem on their side.\n. @krainboltgreene New gem please!\n. Done. Thank you for pointing this out.\n. I am open to this.\n. I'm happy to merge this _once_ we see that the tests are still passing on all interpreters. Looks like the failure here is due to Travis, not your code. Is there some way you can make the Travis build run again?\n. It's sad that Travis CI has become so unreliable. Let me have a look at the failures. Maybe we can merge this anyways.\n. Just merged it in via a PR of my own. Sorry I didn't see this first.\n. (You are still credited in the commit logs, of course. Same commit, just merged via a different PR.)\n. Sounds like a good idea, though a dedicated implementation (perhaps based on `Hamster::Trie`) would be better than relying on `Vector`.\n\nThe first thing would be to come up with a POC and see if the performance advantage over just using frozen strings is compelling.\n. Travis CI failure has nothing to do with @no-reply's change. It's one of the random failures which has become all too common on their platform.\n. Looks good! Thanks!\n. I like this.\n. Merged.\n. Persistent data structures cannot be used in this way. Sorry. It's by design.\n. Personally, I don't care if tests fail on Rubinius. Rubinius is a buggy heap of... bugs.\n. Sorry, what was the motivation for the removal of all occurrences of `&block`?. Nice. When was this introduced in stdlib? Is it available in all the Rubies which Hamster supports?. In that case this PR looks fine to me.\n\nOn Sun, Mar 5, 2017 at 11:44 AM, Denis Defreyne <notifications@github.com>\nwrote:\n\n> It\u2019s been around at least since Ruby 1.9.3, so yes!\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/hamstergem/hamster/pull/234#issuecomment-284216837>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABBJX01ffdIVpt4zRvHmJuuJMIfQCvDBks5rioPqgaJpZM4MTXCH>\n> .\n>\n. Errr... I dunno. Make some noise?. Merged into `master`. Sorry for the delay.. Thanks for the question. As far as I am concerned, the library is finished.\nAny performance improvements would be welcome but I will not be the one to\nmake them.\n\nIf you or anyone else wants to submit a PR to update the dependencies, that\nwould be very welcome.\n\nAs far as the broken build, I think Travis used to work well for us, but\nlater we started to see so many spurious failures that we tired of even\nbothering to look into them.\n\nI think if you clone the repo and run the tests locally, you will see that\nthey all pass. If not, tell me and I will fix them.\n\nOn Aug 30, 2017 12:23 AM, \"Logan Campbell\" <notifications@github.com> wrote:\n\n> I saw build failing, deps out of date and most changes a year ago. Should\n> there be a depreciation/unmaintained warning in the readme? Or is it just\n> that the library is done and no further work needs doing?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/hamstergem/hamster/issues/236>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABBJX-FHsp_OS2X7X5PtseQR3CEa6exiks5sdOPOgaJpZM4PG2Zw>\n> .\n>\n. Looks good to me.. Merged into `master`. Can't merge into `core` because Travis CI failed.\r\n\r\nBitrot has caused our CI to become completely broken over time, although the Hamster codebase hasn't changed. Would be nice if someone could step in and help set Hamster up with another CI solution which works.. I wonder if we can just drop official support for 1.9.3. Any idea if the\nRuby development team still supports it or not?\n\nOn Oct 10, 2017 9:43 PM, \"kevgathuku\" <notifications@github.com> wrote:\n\n> Thanks @alexdowad <https://github.com/alexdowad>\n> I can check out the CI.\n> It seems the failure is happening only on ruby 1.9.3, and weird enough\n> after the tests pass.\n> [image: screen shot 2017-10-10 at 10 42 16 pm]\n> <https://user-images.githubusercontent.com/3721994/31407107-591cd980-ae0c-11e7-8838-4836d76b187f.png>\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/hamstergem/hamster/pull/237#issuecomment-335585788>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABBJX3CkCc4POmxs2ZyGpk9sLRDb0VAkks5sq8j5gaJpZM4P0Edi>\n> .\n>\n. Great, thank you!. ",
    "gfredericks": "Also it might be more consistent if #keys returned a list as well, in the same order as #values. I tried making this change but it broke Hash#slice.\n\nI also thought it might be even more ideal if #keys and #values returned a lazy enumeration. Is there a data structure in hamster that would be good for that?\n. Also it might be more consistent if #keys returned a list as well, in the same order as #values. I tried making this change but it broke Hash#slice.\n\nI also thought it might be even more ideal if #keys and #values returned a lazy enumeration. Is there a data structure in hamster that would be good for that?\n. ",
    "misfo": "I updated the spec to only use `Hash.new` from subclasses and `Hamster.hash` everywhere else.\n\nSubclassing _could_ be avoided by composition, but it seems like an extra layer that shouldn't be unnecessary. The idea is that if you subclass `Hamster::Hash`, the instances of that object _are_ the data (as opposed to being objects that _proxy_ to the data). Maybe I'm being pedantic...\n. I updated the spec to only use `Hash.new` from subclasses and `Hamster.hash` everywhere else.\n\nSubclassing _could_ be avoided by composition, but it seems like an extra layer that shouldn't be unnecessary. The idea is that if you subclass `Hamster::Hash`, the instances of that object _are_ the data (as opposed to being objects that _proxy_ to the data). Maybe I'm being pedantic...\n. ",
    "ms-tg": "Hi Simon,\n\nI was actually using it to answer this old StackOverflow question:\n    http://stackoverflow.com/a/14243026/967863\n\nI think the usage of the MutableHash as a sort of concurrent hash works pretty well, based on the numbers I was getting out of JRuby, so I thought it might be worth publicizing more (and finishing, if there's stuff left to do).\n\nAnd that made me realize -- why not implement []= ?\n\n-Marc\n\n---\n\nFrom: Simon Harris [notifications@github.com]\nSent: Wednesday, January 09, 2013 4:02 PM\nTo: harukizaemon/hamster\nCc: Marc Siegel\nSubject: Re: [hamster] Get MutableHash out of experimental (#16)\n\nHey Marc,\n\nThat's a very good question. I haven't looked into the experimental directory for a while. I'll do so today and see what I think.\n\nAre you using Hamster in anger, or just playing around with it?\n\nSimon\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/16#issuecomment-12066458.\n. Cool!\n\nWhat did you think of the usage I put hamster to, in that StackOverflow answer? I wonder how swapping the immutable hash on write does compared to the other proposed solutions there.\n\n-Marc\n\n---\n\nFrom: Simon Harris [notifications@github.com]\nSent: Wednesday, January 09, 2013 5:51 PM\nTo: harukizaemon/hamster\nCc: Marc Siegel\nSubject: Re: [hamster] Get MutableHash out of experimental (#16)\n\nHey Marc,\n\nOK so I made a start on moving stuff out of experimental and pushed it. I also added []= for you.\n\nThe next step is to build a list of tests and a list of methods that need wrapping in mutable variants.\n\nI might have a go at that later on today if I find the time. Of course, feel free to have a go yourself, although as you're not using it on any projects, I suspect your motivation is somewhat less than mine :)\n\nSimon\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/16#issuecomment-12071339.\n. Hi Simon,\n\nI was actually using it to answer this old StackOverflow question:\n    http://stackoverflow.com/a/14243026/967863\n\nI think the usage of the MutableHash as a sort of concurrent hash works pretty well, based on the numbers I was getting out of JRuby, so I thought it might be worth publicizing more (and finishing, if there's stuff left to do).\n\nAnd that made me realize -- why not implement []= ?\n\n-Marc\n\n---\n\nFrom: Simon Harris [notifications@github.com]\nSent: Wednesday, January 09, 2013 4:02 PM\nTo: harukizaemon/hamster\nCc: Marc Siegel\nSubject: Re: [hamster] Get MutableHash out of experimental (#16)\n\nHey Marc,\n\nThat's a very good question. I haven't looked into the experimental directory for a while. I'll do so today and see what I think.\n\nAre you using Hamster in anger, or just playing around with it?\n\nSimon\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/16#issuecomment-12066458.\n. Cool!\n\nWhat did you think of the usage I put hamster to, in that StackOverflow answer? I wonder how swapping the immutable hash on write does compared to the other proposed solutions there.\n\n-Marc\n\n---\n\nFrom: Simon Harris [notifications@github.com]\nSent: Wednesday, January 09, 2013 5:51 PM\nTo: harukizaemon/hamster\nCc: Marc Siegel\nSubject: Re: [hamster] Get MutableHash out of experimental (#16)\n\nHey Marc,\n\nOK so I made a start on moving stuff out of experimental and pushed it. I also added []= for you.\n\nThe next step is to build a list of tests and a list of methods that need wrapping in mutable variants.\n\nI might have a go at that later on today if I find the time. Of course, feel free to have a go yourself, although as you're not using it on any projects, I suspect your motivation is somewhat less than mine :)\n\nSimon\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/16#issuecomment-12071339.\n. ",
    "krainboltgreene": "I'm good with @alexdowad's answer.\n. If there's anything actionable, lets make PR's or new issues.\n. We're going to setup travis, once that passes I see nothing wrong with merging this.\n. Would love this. Lots of documentation missing.\n. We're going to be using YARD (Already have the gem listed) and markdown format for text.\n. Sounds like a full on feature, moving to 1.1.0.\n. I'll give you commit rights, so when you get the chance you can implement this.\n. Nevermind, you already had it? Or something.\n. This is @harukizaemon, but I'm betting the latter as other collection returns pump out Hamster objects.\n. A lot of these are from old todos, so we have to decide if they're worth it. I'm okay with stamping no. We can always come back.\n. Now you can check em off.\n. Best bet is `insert_if` or something.\n. If we can't figure it out, just remove it from the list.\n. Argh, you know what I realize also? If our goal is API compatability we have to do one of two things:\n1. Make a release for each Ruby version we support (`hamster 1.0.0+mri2.1.1`)\n2. Only support latest Ruby Array & Hash public API.\n\nThoughts? I mean we clearly can't support 1.9's `Enumerable`, `Array`, and `Hash` at the same time.\n. No idea, I copied this over from @harukizaemon's list?\n. Since I don't have access to configurations, this is a job for @harukizaemon \n. Yep, and I can fix em.\n. All you have to do for coveralls is setup the sync, I'll do the rest.\n\nGittip is an account thing, not a repository thing. I'd make a hamster.rb or hamstergem gittip account in case someone wants to reward your OSS with money.\n. I'm not sure how we handle travis, coveralls, gemnasium, and codeclimate transfers.\n. We've got all the services setup for now.\n. Add these straight to the Rakefile plez! :heart:\n. Thanks!\n. -You :rocket:-\n\nApparently github doesn't support :\\m/,: emoji. I'll file a report.\n. This seems like really interesting stuff. [Here's the repo, for note's sake](https://github.com/dkubb/adamantium#readme).\n\nOverall seems like a smart project, though I'm worried about the v0.1.0 version. I'll see about getting a working example.\n. This seems like a very easy win then, @sporkmonger do you want to implement this?\n\n@dkubb, at what point will this library be production ready? (AKA 1.X.Y)\n. That's great. Let's do this.\nOn Dec 13, 2013 11:22 AM, \"Dan Kubb\" notifications@github.com wrote:\n\n> @krainboltgreene https://github.com/krainboltgreene Sorry for the\n> delay. Adamantium is probably production ready now, but I will be releasing\n> a 1.0 within the next few weeks if the version number is important to you.\n> I don't suspect any interface changes between now and then, just some extra\n> polishing and refactoring.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/63#issuecomment-30535908\n> .\n. I've tested out Adamantium on some other projects. Have we decided where we're going with this?\n. So memoization actually got extracted out of adamantium, and we can just use the `memoizable` gem for that.\n\nWhat we'd really look at adamantium for is to handle #109.\n\nI gather your opinion on that issue is \"Don't spend effort to stop people from shooting their own foot.\" I partially agree. \n. We should at least discuss if our `Hamster::Immutable` is better and if it's wise to bring in a second gem.\n. Also, and I know this isn't Ruby normal, I have no problem literally copying `memoizable` directly into the project if it's better. Sometimes it's a good idea to avoid gem dependencies.\n. You've convinced me about Adamantium. It's not what we need, but could be a useful ancillary library (`hamster-adamantium` for instance).\n\nI'll look at `Hamster::Immutable` tonight and see what differences I can find.\n. I think this at the very least deserves to be a extension library if not a part of hamster. Do you need any help with the pull request? \n. Seems like more of a @harukizaemon question, but I think this is fine.\n. I would prefer the internal, just so we're not touching core objects. One of Hamster's big positives is zero dependency on anything else.\n. So I see two cases to be made here:\n1. We're making a method that's a combination of two normal methods, with an option for `flatten`.\n2. We're duck-typing stdlib methods.\n\nWhile I don't really like A I do like B.\n. Slipper slope, mostly. Where do we stop making connivence methods? Best judgement is fine, but we've got to have that judgement.\n. For what it's worth I'm totally ready to merge this.\n. Great work!\n. This seems like a good time to introduce rubycop.\n. Sorry, yeah, I meant https://github.com/bbatsov/rubocop. I'll go ahead and make a PR with it.\n. If anyone wants to help with this issue, please just submit a file change via pull request.\n. Best bet just use the straight up 2.0.0-patchlevel we're all using at the time. Next best thing: Gitignore .ruby-version after having added it, which allows others to modify/replace without worry.\n. Introducing each of those tools individually was always a plan,  so I'll\ndefinitely look that tool up.\nOn Dec 12, 2013 7:33 AM, \"Arne Brasseur\" notifications@github.com wrote:\n\n> In light of this it might be worth it to have a look at Devtoolshttps://github.com/rom-rb/devtools,\n> it provides a shared setup and rake tasks for flog, flay, reek, rubocop,\n> yardstick and mutant.\n> \n> I'm not advocating swithcing to it right away, but if you want more\n> \"metric driven development\" that really gives you the full package. On the\n> other hand it's brutal, I use it on some projects and after every set of\n> changes I have to take the time to adjust/fix the metrics.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/pull/70#issuecomment-30432172\n> .\n. @michaelneale Not sure I understand the comment?\n. I suggest we mimic drapergem/draper and create an organization called `hamstergem`.\n. This would allow us to do some nifty things, like splitting up the gem or handle different access contributors.\n. https://github.com/organizations/hamstergem\n. No idea why it didn't originaly make you an admin. Added now.\n. Go ahead and attempt to transfer them, otherwise just leave them be. Not sure how it works.\n. Good point, thanks!\n. Looks great to me!\n. Add conj everywhere, and if `#conj` is an shorthand way of saying of `#conjoin` please make that alias.\n. Alright, so I actually use coveralls locally to get a simple coverage print out. Do you have an alternative?\n. I'm entirely all for using coveralls only on travis and a abetter one locally. It just shows me per-file %, not terribly useful.\n. What branch did you work from?\n. Interesting. Not sure why the specs aren't working with failing code. Specs are something we're working on hard lately: https://github.com/hamstergem/hamster/issues/77\n\nDo you have time to maybe pair with me on the issue?\n. :+1:\n. I don't see anything wrong with this.\n. Absolutely, thank you.\n. Our next planned release would put us at 1.0.0 and I'm fairly sure we're ready for that.\n\nA large part of what we've been trying to do is improve the development tools (tests, build, services).\n\nTechnically our 1.0.0 milestone is based on [documentation efforts](https://github.com/hamstergem/hamster/issues?milestone=1&state=open) but there's nothing stopping us from just releasing with what we've got.\n\nThoughts?\n. Need to get push permission from @hamstergem/owners.\n. Er, I mean @harukizaemon\n. I need gemcutter access to hamster apparently using: http://guides.rubygems.org/command-reference/#gem_owner\n. Lets start the discussion on if we're willing to accept responsibility for\nthe current public API.\n\nOn Wed, Aug 20, 2014 at 10:34 AM, Adam Rensel notifications@github.com\nwrote:\n\n> Any news on this? I can link to a ref, but a release would be preferable.\n> :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/83#issuecomment-52795890.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Otherwise I'll do another RC.\n\nOn Wed, Aug 20, 2014 at 11:21 AM, Kurtis Rainbolt-Greene <\nme@kurtisrainboltgreene.name> wrote:\n\n> Lets start the discussion on if we're willing to accept responsibility for\n> the current public API.\n> \n> On Wed, Aug 20, 2014 at 10:34 AM, Adam Rensel notifications@github.com\n> wrote:\n> \n> > Any news on this? I can link to a ref, but a release would be preferable.\n> > :)\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/83#issuecomment-52795890.\n> \n> ## \n> \n> Kurtis Rainbolt-Greene, Hacker\n> Software Developer\n> 1631 8th St.\n> New Orleans, LA\n> 70115\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I shipped rc3, so feel free to drop that in and play with it.\n. Can you give me a working example of what you'd like and an example of how you'd do it currently?\n\nI think this would be a good addition but I want to make sure I know where you're going with this.\n. Interesting, so we're looking at modifying `Hamster#merge()` in order to accommodate this behavior.\n\nWhile I don't mind breaking public API (that's what major version bumps are designed to allow) I'm wondering if this should be the default behavior?\n. Alright, so now we just need a PR to accommodate this, yes?\n. While each object responds to similar methods, the result of that behavior is wildly different. Does this not break the behavior contract?\n. Alright, I'm okay with this, feel free to make a PR and it'll be in our 1.0.0-rc2 push.\n. Merged, but I'm not sold on the test structure. I prefer super explicitness. Since it passes it goes in though, good job!\n. This is the drawback of adding multiple public APIs that do the same exact thing (aka aliases): You end up having to maintain multiple public API contracts.\n\nIf we made `#[]` work slightly different from `#list`, we'd have to remember that you combine the tests and suddenly one becomes an untested public API.. (If I'm reading your example correctly).\n. I think we're getting confused. I'm talking about #86's test structure.\n. I am extremely for this kind of dynamic documentation effort. Hamster Lists aren't arrays, though they behave like them. That doesn't mean inspection should make them _look_ like Arrays.\n\nSubmit and I'll GLADLY accept.\n\nYou want a contrib bit as well?\n. Oh, minor nitpick but I'd rather have interpolation:\n\n``` ruby\ndef inspect\n  \"Hamster::List#{to_a.inspect}\"\nend\n```\n. Yeah, this seems saner.\n. Rebase off master plez, that should fix the test problem.\n. Nope, keep the PR, it'll autoupdate after you push.\n. You should be able to `git pull --rebase origin master && git pull --rebase . master && git push -f origin merge_ruby_hash`\n. @plexus The reason I do `spec/lib/foo` is because that puts the `spec_helper.rb` an any extras like `fixtures` and `support` on the `spec/` level, not next to the files inside of `lib/`.\n. Yep.\n\nOn Thu, Aug 14, 2014 at 2:56 AM, Alex Dowad notifications@github.com\nwrote:\n\n> @krainboltgreene https://github.com/krainboltgreene, do you still\n> prefer spec/lib over just spec? If so, I'll finish this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/94#issuecomment-52154004.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Thanks, I hit them up on twitter but didn't get quite any response.\n\nOn Wed, Jun 4, 2014 at 2:33 AM, Alex Dowad notifications@github.com wrote:\n\n> I just sent a PR for JRuby which will fix the Hamster build if accepted:\n> \n> jruby/jruby#1725 https://github.com/jruby/jruby/pull/1725\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/95#issuecomment-45059630.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. What a cluster fuck.\n\nOn Thu, Jun 5, 2014 at 2:29 AM, Alex Dowad notifications@github.com wrote:\n\n> JRuby's developer docs state that they prefer tests to be added to\n> Rubyspec, since they use Rubyspec to determine how close they are to\n> compatibility with MRI.\n> \n> I sent a PR to Rubyspec to add a test which covers this:\n> \n> rubyspec/rubyspec#276 https://github.com/rubyspec/rubyspec/pull/276\n> \n> Unfortunately, the build for my JRuby PR is failing. It doesn't seem\n> related to the PR, though. At https://github.com/jruby/jruby, you can see\n> that the build is also failing for JRuby \"master\".\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/95#issuecomment-45188845.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I've removed 1.8.7 from our testing layer because of issues, but I wonder does this fix it?\n. Thoughts @harukizaemon @plexus? Should we care about 1.8.7?\n. Rodger, thanks for the work though Alex.\n. Actually, just realized this patch is what I wanted anyways, regardless of 1.8 support.\n. So the tests fail in 1.9.2, is that due to your change?\n. Jesus, you're a machine Alex. Alright, I'll merge this but we're dropping 1.9.2. If anyone hasn't upped to 1.9.3 by now, well they can stick to the commit before this merge.\n. Alright, removing travis support.\n. Just noticed Rubinius 2 is also failing, for the same reason?\n. Agreed.\n. How many more of these improvements to performance do you think will come over this month?\n\nI'm considering setting up built in benchmarks for the CI.\n. Thanks!\n. Yeah, I haven't seen anything. Agreed.\n. Oooh nice catch.\n. I guess that's up to @harukizaemon.\n. Haha, we actually prefer double quotes, but I'll merge it all the same.\n. Oh, hey, thanks!\n. One of our goals is to use adamantium. This might be a good chance to nip this by actively deep freezing with that library. Thoughts?\n. So why is this stuff happening in `Set.new` instead of `Set#initialize`?\n. :+1: You're a genius!\n. Marked as 1.0.0.\n. I'm all for removing surface area. We should have a reason why it's not needed written down somewhere, if only a link to this thread.\n. I just imagine someone coming and saying \"Hey, Hamster does collections but doesn't have touples? Riot!\" which may or may not be realistic.\n. I've been wanting to add a list of all the collection types we have, with more documentation for each. Hmm.\n. Agreed.\n. Normally this is something I cherish doing, but I don't have any ideas. Consider this a weak vote for Array's API unless someone comes up with something juicy.\n. I will say that I've always disliked duplicated signatures:\n\n``` ruby\nqueue = Queue.new\nqueue.enqueue(object)\n```\n\nVs\n\n``` ruby\nqueue = Queue.new\nqueue.push(object)\n```\n. You're a god damn machine :P\n\nOn Wed, Aug 13, 2014 at 6:00 PM, Alex Dowad notifications@github.com\nwrote:\n\n> Closed #121 https://github.com/hamstergem/hamster/issues/121.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/121#event-152630365.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Hmm, this is the first time we're going to be brining in an external dependency.\n. Very good points. I'm OK with this then.\n. Using the atomic gem. The performance improvements are too good and the atomic people seem to be taking care of their project in terms of portability.\n. Agreed. I have a benchmark setup for some of my other gems, using\nbenchmark-ips and we can start on the benchmarks gem today.\n\nOn Wed, Aug 20, 2014 at 2:30 PM, Alex Dowad notifications@github.com\nwrote:\n\n> The benchmarks should cover the entire public APIs of all 7 Hamster\n> collections. It should be possible to compare results for 2 different git\n> revisions/branches. It should also be possible to see how results stack up\n> against comparable built-in Hash and Array-using code, or against other\n> libraries which provide similar data structures.\n> \n> To facilitate #126 https://github.com/hamstergem/hamster/issues/126, I\n> suggest the benchmarks should go into their own gem, which will become a\n> development dependency. They can be invoked through Rake tasks.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/127.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I've started improving the benchmarks in #144. I'll finish up over this weekend I think.\n. I shipped rc3.\n. I'm ready if you are.\n\nOn Tue Jan 20 2015 at 12:05:49 PM Alex Dowad notifications@github.com\nwrote:\n\n> About 6 months has past. The -rc3 version gem has been downloaded >1000\n> times. No bug reports against that version have come in. How much more time\n> do you think we should give before shipping it?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-70701649.\n. Alright, I'll release 1.0.0 tonight based on master.\n\nOn Tue Jan 20 2015 at 9:49:24 PM Alex Dowad notifications@github.com\nwrote:\n\n> I also think it's ready.\n> On Jan 21, 2015 1:25 AM, \"Dov Murik\" notifications@github.com wrote:\n> \n> > I think it's ready.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/128#issuecomment-70755789.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-70780382.\n. Yep.\n\nOn Sat, Mar 7, 2015 at 12:27 PM Alex Dowad notifications@github.com wrote:\n\n> @krainboltgreene https://github.com/krainboltgreene, can you go ahead\n> and cut the promised 1.0.0 gem?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-77702422.\n. Done.\n\nOn Sat, Mar 7, 2015 at 12:33 PM Kurtis Rainbolt-Greene <\nme@kurtisrainboltgreene.name> wrote:\n\n> Yep.\n> \n> On Sat, Mar 7, 2015 at 12:27 PM Alex Dowad notifications@github.com\n> wrote:\n> \n> > @krainboltgreene https://github.com/krainboltgreene, can you go ahead\n> > and cut the promised 1.0.0 gem?\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/128#issuecomment-77702422.\n. I prefer the plural over the singular.\n\n```\nfirends.permutations\n```\n\nBut if we need the singular, lets drop the plural.\n\nOn Wed, Aug 20, 2014 at 2:41 PM, Alex Dowad notifications@github.com\nwrote:\n\n> Ruby's core classes don't have #permutations and #combinations. Array\n> does have #permutation and #combination. Right now, Hamster::List\n> provides all of them, but Vector and SortedSet do not.\n> \n> Do we want to provide the same method under both names? Or, following the\n> example of Array, just provide #permutation and #combination?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/129.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. My thoughts have always been on removing as many additional methods as possible. Narrow down the public interface.\n\nBut until we do that we've got to document them. I suggest going with an `@!alias` directive.\n. I actually asked this question when I first came to this project!\n\nIt's because alias doesn't traverse inheritance.\n. My vote has always been to reduce the surface area, so we need to list the methods we want as core.\n\nPreferably those methods are as close to Enumerable spec as possible.\n. :+1:, except fuck length :P\n. What's wrong with \"add\"? ;)\n\nBut seriously, I prefer non-truncated methods if possible.\n\nOn Tue, Nov 4, 2014 at 1:56 PM, Alex Dowad notifications@github.com wrote:\n\n> Removed unneeded method aliases from Set in b226952\n> https://github.com/hamstergem/hamster/commit/b2269523fc23ed561c7fad113e8e61691a741dfc\n> and 57e6426\n> https://github.com/hamstergem/hamster/commit/57e642695c85e7c2657435ea3940cc67cf2bb52f.\n> The one remaining question about Set: do we want both #conj and #conjoin?\n> These methods were previously added in an attempt to create a single\n> interface for \"adding an item\" to _any_ collection.\n> \n> This is a very useful thing, but I think we just need one or the other.\n> Which one is it going to be?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-61703562.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. #add() should be a general function for putting an item in the collection,\nregardless of it's implementation (and always the most efficient).\n#unshift() and #push() can handle placement. I say drop #<<, #conj, and\n#conjoin.\n\nOn Tue Nov 04 2014 at 10:27:24 PM Dov Murik notifications@github.com\nwrote:\n\n> I'd stay with #first which is very Ruby-ish; but for List you probably\n> want #head and #tail (car and cdr ??).\n> \n> If you want to keep the requirement for efficient addition (O(1)), then\n> indeed #<< is not a good choice (because this method name hints at \"put\n> at end\" for ordered collections). If so, maybe #conj is indeed the better\n> choice.\n> \n> I guess this will allow to write code like this for any type of\n> empty_collection:\n> \n> my_enumerable_obj.reduce(empty_collection) { |c, e| c.conj(e) }\n> \n> I'm not entirely convinced this generality is needed at all... Can you\n> give an example usage (possible from Clojure)?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-61758383.\n. By the way, I'm not laying down an ultimatum, just my opinion on naming.\n\nOn Wed Nov 05 2014 at 12:34:26 AM Alex Dowad notifications@github.com\nwrote:\n\n> @krainboltgreene https://github.com/krainboltgreene, OK, that makes\n> sense. I think #<< should be kept for ordered collections and Set, since\n> Ruby programmers are accustomed to using it. It is not needed for Hash.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-61765740.\n. Agreed on keeping #<< for ordered collections.\n\nOn Wed Nov 05 2014 at 12:35:56 AM Kurtis Rainbolt-Greene <\nme@kurtisrainboltgreene.name> wrote:\n\n> By the way, I'm not laying down an ultimatum, just my opinion on naming.\n> \n> On Wed Nov 05 2014 at 12:34:26 AM Alex Dowad notifications@github.com\n> wrote:\n> \n> > @krainboltgreene https://github.com/krainboltgreene, OK, that makes\n> > sense. I think #<< should be kept for ordered collections and Set, since\n> > Ruby programmers are accustomed to using it. It is not needed for Hash.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/131#issuecomment-61765740.\n. We cool with Hash#add being #merge()?\n\nOn Fri Nov 07 2014 at 5:35:50 AM Alex Dowad notifications@github.com\nwrote:\n\n> Just pushed a commit which removes #conj and #conjoin. List#add now adds\n> an element to the _front_ of a list (the most efficient place to do it).\n> #group_by_with (which #conj was originally intended to support) now uses\n> #add instead of #conj.\n> \n> Hash#group_by is now broken (there are no tests for it though). To fix\n> it, we need to add Hash#add. It would be good to also add tests for\n> Hash#group_by.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-62130962.\n. @alexdowad right now:\n\n![](http://moviesmedia.ign.com/movies/image/article/116/1168874/assassins-creed-20110517003628556.jpg)\n. My vote: Drop exist, exists, elem_index, contains. We can always add more\ninterfaces if community demands.\n\nOn Fri Nov 14 2014 at 3:12:21 PM Alex Dowad notifications@github.com\nwrote:\n\n> Any comments on #exist? and #exists? as aliases for #any?? I don't think\n> they are needed. How about #elem_index for #index or #contains? for\n> #include??\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-63129693.\n. interval, if no standard exists. Avoids some small confusion I think.\n\nOn Fri Nov 21 2014 at 11:53:50 AM Alex Dowad notifications@github.com\nwrote:\n\n> OK, here's another one. Hamster.range(from, to) and Hamster.interval(from,\n> to) are identical methods, returning a lazy list. Which one should be\n> \"standard\"?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64010158.\n. - #first\n- #last\n- #push, #enqueue\n- #shift, #dequeue\n\nThat's about as far as I'm willing to go, personally.\n\nOn Fri Nov 21 2014 at 11:58:06 AM Alex Dowad notifications@github.com\nwrote:\n\n> Deque is a bit of a mess. The following are groups of identical methods:\n> - #first, #front\n> - #last, #peek\n> - #push, #enqueue, #<<, #add\n> - #shift, #dequeue, #tail\n> \n> As you can tell, some of these names were chosen by analogy with Array,\n> some reflect the use of the structure as a stack, some reflect its use as a\n> queue. #tail reflects the way that \"shifting\" an item out of the front of\n> the deque behaves like taking the \"tail\" of a linked list.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64010791.\n. Third option: Straight up copy/paste the methods.\n\nOn Fri Nov 21 2014 at 12:12:38 PM Alex Dowad notifications@github.com\nwrote:\n\n> We have trimmed down as far as I think we want to go. There don't seem to\n> be any redundant aliases left.\n> \n> The remaining question is if we are going to keep using def_delegator\n> :self, or switch to the more conventional alias. Opinions?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64012826.\n. Agreed.\n\nOn Fri Nov 21 2014 at 7:40:05 PM Dov Murik notifications@github.com wrote:\n\n> I prefer ruby's alias.\n> On Nov 21, 2014 1:17 PM, \"Alex Dowad\" notifications@github.com wrote:\n> \n> > Which option do you prefer? @dubek https://github.com/dubek, do you\n> > have any input?\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/131#issuecomment-64013472.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64063290.\n. That's amazing to hear. We can get an RC release this morning.\n\nOn Sat Nov 22 2014 at 4:37:00 AM Alex Dowad notifications@github.com\nwrote:\n\n> Closed #131 https://github.com/hamstergem/hamster/issues/131.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#event-197177901.\n. I am entirely OK with a commit that starts with `Hamster::Stack = Hamster::Deque`.\n. Fair point on the cleaning of house. Lets just get rid of Stack completely,\nmake a note of it in the Readme.\n\nOn Thu, Aug 28, 2014 at 2:23 PM, Alex Dowad notifications@github.com\nwrote:\n\n> I did think of the same idea. But would you want Deque permanently\n> aliased as Stack? Or are you thinking of that as a transitional measure?\n> \n> Since Hamster is coming up to a major release, which users should expect\n> to break backwards compatibility, I'd like to clean house. If aliasing\n> collection classes under multiple names is something we would like to do\n> for the long term, that is fine. If not, why not go all the way to where we\n> would really like to be?\n> \n> If aliasing is a good idea, Deque could also be aliased as Queue.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/132#issuecomment-53781951.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. This really only matters with non-trivial objects. Example:\n\n``` ruby\nclass Person\n  attr_reader :name\n  attr_reader :age\n\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  def =(other)\n    @age == other.age\n  end\nend\n\njohn = Person.new(\"John\", 34)\neve = Person.new(\"Eve\", 34)\n\nvector = Vector.new(john, eve).uniq\n```\n\nIf we do first kept, then it'll always be \"John\".\n. I'd just rather drop 2.1.0 support.\nOn Oct 21, 2014 10:46 PM, \"Alex Dowad\" notifications@github.com wrote:\n\n> I suggest we just amend the test to check equality rather than identify if\n> RUBY_VERSION == '2.1.0'. In either case, Hamster is matching the behavior\n> of Ruby's collections.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/137#issuecomment-60033026.\n. I dropped support in #142.\n. :+1:\n. So I removed this in a recent patch and I'm about to readd it. Do you have any pull at inch @rrrene? I'd like to see them get something at http://shields.io/\n. Your best bet is to use our pre-release version or straight from github.\n\nI'm guessing if you're using the git uri then whatever ruby program you're trying to run isn't being run within the context of bundler.\n\nThis means you probably need to prefix `bundle exec` to whatever you're running.\n. What's the point of `Hamster.from`?\n\nAs for `Hash#merge_deep` I'd rather have it as a toggleable thing on `Hash#merge`. We need to talk about merge semantics, too.\n\nFinally, for `Hash#get_in`...I like it, but we're getting close to tackling http://goessner.net/articles/JsonPath/. ;)\n\nOverall these are things I think _need_ to be in hamster, but we're going to need to talk about _how_.\n. Why doesn't this work for storing?\n. Oh fuck, right. Bleh. I totally forgot about Ruby's \"special\" rules for that method.\n. Agreed.\n\nOn Wed, Oct 22, 2014 at 10:29 PM, Alex Dowad notifications@github.com\nwrote:\n\n> The issue here isn't just []=. The issue is that because Hamster\n> collections are immutable, once you drill down to a \"leaf\" collection and\n> insert into it, you have to \"retrace your steps\" back up to the root,\n> inserting each \"modified\" child collection into its original parent, to get\n> a \"modified\" parent collection.\n> \n> I think that we should add #update_in.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/140#issuecomment-60188403.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. For future pull requests, I'd like to see benchmarks like this: https://gist.github.com/krainboltgreene/2433adbb60c0cdcd356c\n. Is it me or is this `#bulk_put` a rather large method? Seems like it could be it's own object?\n. @alexdowad Actually that sounds about right. It'd basically be a set of behavior that turns either turns off rewrite & delete behavior or returns coppies.\n. Unsure.\n\nOn Sun, Mar 15, 2015 at 1:36 AM Alex Dowad notifications@github.com wrote:\n\n> Is this still an issue we want to work on? If unsure, I suggest it can be\n> triaged.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/145#issuecomment-80878388.\n. We'll be using our own badge:\n\n![Gitter](http://img.shields.io/badge/discuss-join%20gitter-brightgreen.svg?style=flat-square)\n. Ideally I'd want first class support for badges at Github, but barring that...What can we do?\n. :+1:\n. :+1: \n. I defer to @alexdowad on this one.\n. Early returns have always been an a bug for me, but quite frankly it seems like it needs to happen in Hamster for performance reasons.\n. By the way, here's the failure on travis:\n\n```\n  1) Hamster::List doesn't give horrendously bad performance if thread realizing the list sleeps\n     Failure/Error: elapsed.should_not > 0.3\n       expected not: > 0.3\n                got:   0.332870754\n     # ./spec/lib/hamster/list/multithreading_spec.rb:46:in `block (2 levels) in <top (required)>'\n```\n\nOnly Ruby 2.0.0.\n. Because \"hamster\" is a really general term, and we don't need to be taking\nthat namespace for a collection library.\n\nAs for the {name}.gem, all of mine quite a few in plus\nhttps://github.com/search?utf8=%E2%9C%93&q=.gem&type=Repositories&ref=searchresults\n.\n\nOn Tue Nov 04 2014 at 7:06:32 PM Dov Murik notifications@github.com wrote:\n\n> (and add to the checklist: modify the github path in hamster.gemspec)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/157#issuecomment-61744049.\n. @hamstergem/contributors Any thoughts on just changing the name in general from `hamster`?\n. Sorry I meant to something more symbolic of the situation, like: \"immutable_collection\" or similar.\n. @alexdowad We could just redirect hamster to immutable-ruby.\n. Thanks for the report!\n\nOn Sat Nov 22 2014 at 8:24:13 PM Wayne Vucenic notifications@github.com\nwrote:\n\n> I realize this has been fixed in github, I just wanted to point out that\n> Windows users doing gem install will encounter a problem.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/161#issuecomment-64103883.\n. We do appreciate the suggestion, though. Let us know how your hamster usage\ngoes.\n\nOn Sat Dec 06 2014 at 3:07:26 PM Joel McCracken notifications@github.com\nwrote:\n\n> That sounds fine. I was thinking about using hash anyway -- so, great.\n> \n> Sent from my iPhone\n> \n> > On Dec 6, 2014, at 10:43 AM, Alex Dowad notifications@github.com\n> > wrote:\n> > \n> > Do you think that an existing Hamster structure, like the immutable\n> > Hash, might help you implement your immutable struct? If so, you could\n> > write your own library which relies on Hamster.\n> > \n> > In any case, I think the relationship between an immutable struct and\n> > the existing Hamster structures is weak, and it would be better to write a\n> > separate library. Small is beautiful. Adding more features bloats both code\n> > size (making the library harder to maintain) and the documentation (making\n> > it harder to learn). If those new features have some inherent synergy with\n> > the existing features, if they combine in ways that makes the whole larger\n> > than the sum of its parts, then putting them together may be a good\n> > tradeoff. Otherwise, let them go their separate ways.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/162#issuecomment-65913928.\n. For what it's worth I'd also love to see how you're using it in a game.\n\nOn Fri Dec 26 2014 at 7:43:11 AM Alex Dowad notifications@github.com\nwrote:\n\n> Closed #163 https://github.com/hamstergem/hamster/issues/163.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/163#event-212064254.\n. I vote B.\n\nOn Fri Dec 26 2014 at 1:37:36 PM Alex Dowad notifications@github.com\nwrote:\n\n> We have List#find_indices, which returns indices for which a provided\n> block returns true, #elem_indices, which returns indices where a given\n> object is found, and #indices, which does either (depending on whether\n> you pass an argument or provide a block).\n> \n> At first I thought this may have been for compatibility with Enumerable,\n> but it's not. It's just something we have made up.\n> \n> I recommend that we either A) drop #indices, since it just does the same\n> things as #find_indices and #elem_indices, or B) drop #find_indices and\n> #elem_indices.\n> \n> Opinions? I like #indices, simply because the name is short and\n> to-the-point.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/164.\n. I'm not afraid of breaking changes, 2.0.0 isn't a special number to me.\n\nOn Mon, Mar 16, 2015 at 2:04 PM Elben Shira notifications@github.com\nwrote:\n\n> Recursively convert Hamster data to a Ruby collection.\n> \n> A big use case is marshaling into JSON:\n> \n> require 'json'\n> Hamster.to(data).to_json\n> \n> An alternative idea is to make Hamster::Hash#to_hash recurse on itself,\n> \n> ## but this seems like an impractical breaking change.\n> \n> You can view, comment on, or merge this pull request online at:\n> \n>   https://github.com/hamstergem/hamster/pull/166\n> Commit Summary\n> - Hamster.to to convert to Ruby collection.\n> \n> File Changes\n> - _M_ lib/hamster/nested.rb\n>   https://github.com/hamstergem/hamster/pull/166/files#diff-0 (23)\n> - _M_ spec/lib/hamster/nested/construction_spec.rb\n>   https://github.com/hamstergem/hamster/pull/166/files#diff-1 (74)\n> \n> Patch Links:\n> - https://github.com/hamstergem/hamster/pull/166.patch\n> - https://github.com/hamstergem/hamster/pull/166.diff\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166.\n. I would rather to_array, but either works.\n\nOn Mon, Mar 16, 2015 at 3:15 PM Elben Shira notifications@github.com\nwrote:\n\n> @krainboltgreene https://github.com/krainboltgreene two other problem\n> with to_hash:\n> - It's not a unified interface across all the Hamster collections\u2014we\n>   would need Hamster::Vector#to_a, Hamster::Set#to_set (?).\n> - It may be expensive, depending on how deep the object is. I'm not\n>   sure what user expectations are on a method called to_hash.\n> \n> The json module, however, mixes in Object#to_json. Maybe Hamster we can\n> do Hamster::Hash#to_mutable (and the rest).\n> \n> @alexdowad https://github.com/alexdowad on top of the alternative\n> above, what about Hamster.to_mutable.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-81913069.\n. I do enjoy the idea of #to_mutable_x.\n\nOn Mon, Mar 16, 2015 at 7:28 PM Dov Murik notifications@github.com wrote:\n\n> Although JSON and Yaml modules add Array#to_json and Hash#to_yaml and so\n> on, I prefer not to go this way (that is, not to add method to basic Ruby\n> objects).\n> \n> I'd rather stay with Hamster::Vector#to_a as mentioned above. If needed,\n> add Hamster::Hash#to_h and Hamster::Set#to_set (or maybe #to_ruby_set ?)\n> as needed to convert to regular Ruby objects.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82004824.\n. Have I noted before how un-semantic `Hamster::Hash[]` is syntactically?\n\nAnyways, this looks great.\n\nOn Tue, Mar 17, 2015 at 6:39 PM Elben Shira notifications@github.com\nwrote:\n\n> Let me know what you think about these latest commits.\n> \n> h=Hamster::Hash[\n>             \"a\" => 1,\n>             \"b\" => Hamster::Vector[2, Hamster::Hash[\"c\" => 3], 4],\n>             \"d\" => Hamster::Set[5, 6, 7],\n>             \"e\" => Hamster::Hash[\"f\" => 8, \"g\" => 9],\n>             \"h\" => Regexp.new(\"ijk\"),\n>             \"l\" => Hamster::SortedSet.new([1, 2, 3])]\n> h.to_ruby# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n> Hamster.to_ruby(h)# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82641919.\n. I'm pretty annoyed the decided to bundle it. Like, at the very least do it\nthe way Rails does.\n\nOn Sun, Apr 5, 2015 at 9:09 PM Dov Murik notifications@github.com wrote:\n\n> Another option is to have two implementations:\n> 1. If the concurrent gem is installed, use it (require\n>    'concurrent/atomics' and use the Atomic class).\n> 2. Otherwise, build a naive (=slow) implementation using a Mutex for\n>    any read/write operation on @atomic https://github.com/atomic (which\n>    can then be a normal fixnum).\n> \n> This way hamster works out-of-the-box without other dependencies, and if\n> you need List to be faster then you just gem install concurrent.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/167#issuecomment-89889902.\n. Looking deeper:\n\n``` ruby\ncollection.grep(query)\n# From: hamster-1.0.0/lib/hamster/set.rb @ line 199 Hamster::Set#select:\n# \n#     199: def select\n#     200:   return enum_for(:select) unless block_given?\n#     201:   trie = @trie.select { |key, _| yield(key) }\n#     202:   new_trie(trie)\n#     203: end\n\nreturn enum_for(:select) unless block_given?\n# => nil\n\ntrie = @trie.select { |key, _| yield(key) }\n# => #<Hamster::Trie:0x007fa200abfa28\n#  @children=[],\n#  @entries=\n#   [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil],\n#  @significant_bits=0,\n#  @size=0>\n\nnew_trie(trie)\n# => Hamster::Set[]\n\n@trie\n# => #<Hamster::Trie:0x007fa2003c2c98\n#  @children=[],\n#  @entries=\n#   [nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    [#<Earhart::Route:0x007fa2009fc078 @pattern=/GET \\/accounts\\/(?<id>.+)/, @receiver=Object>, nil]],\n#  @significant_bits=0,\n#  @size=1>\n```\n. I don't think it's supposed to do that, obviously, but it makes sense now why the grep didn't work.\n\n``` ruby\nitems = []\n# => []\n@trie = Trie.new(0)\n# => #<Hamster::Trie:0x007fe42d186208 @children=[], @entries=[], @significant_bits=0, @size=0>\nitems.each { |item| @trie.put!(item, nil) }\n# => []\n@trie\n# => #<Hamster::Trie:0x007fe42d186208 @children=[], @entries=[], @significant_bits=0, @size=0>\n```\n\nSo it looks like this huge array with nils only happens when using `Hamster::Set::EmptySet`, which passes `[nil]` as an item to initialize.\n. Really? Is there a particular reason we create big nil-filled arrays? Isn't that memory wasteful?\n\nAnd I tried switching the method around:\n\n``` ruby\ndef ===(query)\n  query === pattern\nend\n```\n\nAnd got the same issue.\n. Another thing I wanted to ask is: Is this even the right function for me? I realized last night that select returns an array, but what I really want is the first result found. I thought Set was lazy?\n. That === example is what I did. I guess I still don't understand why my\ncode isn't working in this case, but frankly I'll want find on list anyways.\n\nOn Fri, Apr 17, 2015 at 1:05 AM Alex Dowad notifications@github.com wrote:\n\n> #find is what you are looking for.\n> \n> No, Set is not lazy. Only List is. Linked lists allow for a natural and\n> efficient \"lazy\" implementation, but most other data structures do not. For\n> comparison, Clojure has lazy lists which you can create using lazy-seq,\n> but its other built-in structures are strict. Languages like Haskell\n> achieve laziness not by providing a full set of \"lazy\" general-purpose data\n> structures, but by delaying the evaluation of code until its results are\n> needed.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/168#issuecomment-93901174.\n. Yes, at the moment.\n\nOn Thu, Apr 16, 2015 at 8:13 AM Dov Murik notifications@github.com wrote:\n\n> Generally I'm not against your suggestion, but these \"early returns\" are\n> very common throughout the Hamster code, and in some cases make the code\n> easier to read IMO. @krainboltgreene https://github.com/krainboltgreene\n> did you intend to modify all the similar occurrences of return ... unless\n> ...?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/169#issuecomment-93730908.\n. Yeah, the List class has all sorts of weird shortcut methods that involve\nCons, and I'm fine leaving it that way.\n\nOn Thu, Apr 16, 2015 at 9:12 AM Alex Dowad notifications@github.com wrote:\n\n> OK, fair enough. Agreed.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/170#issuecomment-93744487.\n. This is a WIP.\n\nOn Thu, Apr 16, 2015 at 3:05 PM Dov Murik notifications@github.com wrote:\n\n> OK sure. The README should be fixed though (line 200) to square brackets.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/170#issuecomment-93827927.\n. <3\nOn Sep 9, 2015 10:39 AM, \"Alex Dowad\" <notifications@github.com> wrote:\n\n> I just removed Hamster.vector, including updating all the documentation\n> and specs, in f444320\n> https://github.com/hamstergem/hamster/commit/f4443205ce9f8e9a6df661d1acb64e747b2640a1.\n> Will push a commit which removes Hamster.hash next.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/170#issuecomment-138986575.\n. God, I'd love to have that gemname. I'm going to see if I can grab it from the author.\n. We appreciate it either way.\n\nOn Wed, May 13, 2015 at 5:14 AM, Ilya Lavrov notifications@github.com\nwrote:\n\n> I just noticed JRuby-1.7.20 has already released and works fine with\n> original spec. Pull request does not make sense.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/175#issuecomment-101609834.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. If we could switch to `remove_instance_variable` that'd be great too.\n. If it's slower than setting to nil I'm going to laugh all the way to\ntwitter.\n\nOn Thu, May 14, 2015 at 2:22 PM, Alex Dowad notifications@github.com\nwrote:\n\n> Thanks to @dubek https://github.com/dubek for pointing out the issue\n> with List#span -- I have pushed another commit to attempted_race_fix. (It\n> would be nice if we had a spec which confirmed both the problem and the\n> fix...)\n> \n> Thanks to @dzjuck https://github.com/dzjuck for finding the problem in\n> the first place, and confirming the fix.\n> \n> Regarding the use of remove_instance_variable -- I wonder what the\n> performance impact would be? Does anyone want to try benchmarking?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/177#issuecomment-102143048.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Is polymorphism something we care about?\n\nCurrently I'm of the opinion that our collection objects are too complex to inherit from intelligently, and that users should wrap their specialized objects around a Hamster object.\n\nAdditionally, I'm almost tempted to say that the canonical way should be `Hamster::Vector::EMPTY`, and that `Hamster.vector()` _requires_ items.\n\nOf course I'm also tempted to just drop `Hamster.vector()` in lieu of `Hamster::Vector.new`. Giving us two ways to create an empty vector:\n\n``` ruby\nHamster::Vector::EMPTY # memoized\nHamster::Vector.new # fresh\n```\n. I'll work up a PR, good talk.\n. Sold.\n\nOn Mon, Aug 17, 2015 at 9:41 AM, Xavier Shay notifications@github.com\nwrote:\n\n> Nice find!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/189#issuecomment-131844954.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I'll do it tonight!\n\nOn Mon, Oct 26, 2015 at 6:22 AM, Alex Dowad notifications@github.com\nwrote:\n\n> Yes, it's @krainboltgreene https://github.com/krainboltgreene. 1.1.0\n> gem, please!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/201#issuecomment-151131400.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Released as v2.0.0, since we had breaking public API changes (detailed in CHANGELOG.md)\n. Awesome have at it :)\nOn Nov 16, 2015 9:33 AM, \"studiolo\" notifications@github.com wrote:\n\n> Hi, I saw this on Ruby Issues and would like to call dibs - to support the\n> good cause and to practice git bit.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/205#issuecomment-157111410.\n. me@kurtisrainboltgreene.name, I take personal responsibility.\n\nI appreciate the details, but we definitely agree with it.\n. @studiolo You're right, follow this example: https://github.com/krainboltgreene/blankgem.gem\n. <3 <3 <3\n. :+1:\n\nOn Fri, Dec 4, 2015 at 8:08 PM, Alex Dowad notifications@github.com wrote:\n\n> Good catch. This is definitely a bug; a bug in specification.\n> \n> I would prefer just to bump the minor version number after applying a fix.\n> @krainboltgreene https://github.com/krainboltgreene?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/215#issuecomment-162137494.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. :+1:\n. Weeeeeee. Thanks for checking on it.\n. Out!\n. @alexdowad It was a major release, actually, since we changed the behavior of values_at.\n. I'm good with @alexdowad's answer.\n. If there's anything actionable, lets make PR's or new issues.\n. We're going to setup travis, once that passes I see nothing wrong with merging this.\n. Would love this. Lots of documentation missing.\n. We're going to be using YARD (Already have the gem listed) and markdown format for text.\n. Sounds like a full on feature, moving to 1.1.0.\n. I'll give you commit rights, so when you get the chance you can implement this.\n. Nevermind, you already had it? Or something.\n. This is @harukizaemon, but I'm betting the latter as other collection returns pump out Hamster objects.\n. A lot of these are from old todos, so we have to decide if they're worth it. I'm okay with stamping no. We can always come back.\n. Now you can check em off.\n. Best bet is `insert_if` or something.\n. If we can't figure it out, just remove it from the list.\n. Argh, you know what I realize also? If our goal is API compatability we have to do one of two things:\n1. Make a release for each Ruby version we support (`hamster 1.0.0+mri2.1.1`)\n2. Only support latest Ruby Array & Hash public API.\n\nThoughts? I mean we clearly can't support 1.9's `Enumerable`, `Array`, and `Hash` at the same time.\n. No idea, I copied this over from @harukizaemon's list?\n. Since I don't have access to configurations, this is a job for @harukizaemon \n. Yep, and I can fix em.\n. All you have to do for coveralls is setup the sync, I'll do the rest.\n\nGittip is an account thing, not a repository thing. I'd make a hamster.rb or hamstergem gittip account in case someone wants to reward your OSS with money.\n. I'm not sure how we handle travis, coveralls, gemnasium, and codeclimate transfers.\n. We've got all the services setup for now.\n. Add these straight to the Rakefile plez! :heart:\n. Thanks!\n. -You :rocket:-\n\nApparently github doesn't support :\\m/,: emoji. I'll file a report.\n. This seems like really interesting stuff. [Here's the repo, for note's sake](https://github.com/dkubb/adamantium#readme).\n\nOverall seems like a smart project, though I'm worried about the v0.1.0 version. I'll see about getting a working example.\n. This seems like a very easy win then, @sporkmonger do you want to implement this?\n\n@dkubb, at what point will this library be production ready? (AKA 1.X.Y)\n. That's great. Let's do this.\nOn Dec 13, 2013 11:22 AM, \"Dan Kubb\" notifications@github.com wrote:\n\n> @krainboltgreene https://github.com/krainboltgreene Sorry for the\n> delay. Adamantium is probably production ready now, but I will be releasing\n> a 1.0 within the next few weeks if the version number is important to you.\n> I don't suspect any interface changes between now and then, just some extra\n> polishing and refactoring.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/63#issuecomment-30535908\n> .\n. I've tested out Adamantium on some other projects. Have we decided where we're going with this?\n. So memoization actually got extracted out of adamantium, and we can just use the `memoizable` gem for that.\n\nWhat we'd really look at adamantium for is to handle #109.\n\nI gather your opinion on that issue is \"Don't spend effort to stop people from shooting their own foot.\" I partially agree. \n. We should at least discuss if our `Hamster::Immutable` is better and if it's wise to bring in a second gem.\n. Also, and I know this isn't Ruby normal, I have no problem literally copying `memoizable` directly into the project if it's better. Sometimes it's a good idea to avoid gem dependencies.\n. You've convinced me about Adamantium. It's not what we need, but could be a useful ancillary library (`hamster-adamantium` for instance).\n\nI'll look at `Hamster::Immutable` tonight and see what differences I can find.\n. I think this at the very least deserves to be a extension library if not a part of hamster. Do you need any help with the pull request? \n. Seems like more of a @harukizaemon question, but I think this is fine.\n. I would prefer the internal, just so we're not touching core objects. One of Hamster's big positives is zero dependency on anything else.\n. So I see two cases to be made here:\n1. We're making a method that's a combination of two normal methods, with an option for `flatten`.\n2. We're duck-typing stdlib methods.\n\nWhile I don't really like A I do like B.\n. Slipper slope, mostly. Where do we stop making connivence methods? Best judgement is fine, but we've got to have that judgement.\n. For what it's worth I'm totally ready to merge this.\n. Great work!\n. This seems like a good time to introduce rubycop.\n. Sorry, yeah, I meant https://github.com/bbatsov/rubocop. I'll go ahead and make a PR with it.\n. If anyone wants to help with this issue, please just submit a file change via pull request.\n. Best bet just use the straight up 2.0.0-patchlevel we're all using at the time. Next best thing: Gitignore .ruby-version after having added it, which allows others to modify/replace without worry.\n. Introducing each of those tools individually was always a plan,  so I'll\ndefinitely look that tool up.\nOn Dec 12, 2013 7:33 AM, \"Arne Brasseur\" notifications@github.com wrote:\n\n> In light of this it might be worth it to have a look at Devtoolshttps://github.com/rom-rb/devtools,\n> it provides a shared setup and rake tasks for flog, flay, reek, rubocop,\n> yardstick and mutant.\n> \n> I'm not advocating swithcing to it right away, but if you want more\n> \"metric driven development\" that really gives you the full package. On the\n> other hand it's brutal, I use it on some projects and after every set of\n> changes I have to take the time to adjust/fix the metrics.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/pull/70#issuecomment-30432172\n> .\n. @michaelneale Not sure I understand the comment?\n. I suggest we mimic drapergem/draper and create an organization called `hamstergem`.\n. This would allow us to do some nifty things, like splitting up the gem or handle different access contributors.\n. https://github.com/organizations/hamstergem\n. No idea why it didn't originaly make you an admin. Added now.\n. Go ahead and attempt to transfer them, otherwise just leave them be. Not sure how it works.\n. Good point, thanks!\n. Looks great to me!\n. Add conj everywhere, and if `#conj` is an shorthand way of saying of `#conjoin` please make that alias.\n. Alright, so I actually use coveralls locally to get a simple coverage print out. Do you have an alternative?\n. I'm entirely all for using coveralls only on travis and a abetter one locally. It just shows me per-file %, not terribly useful.\n. What branch did you work from?\n. Interesting. Not sure why the specs aren't working with failing code. Specs are something we're working on hard lately: https://github.com/hamstergem/hamster/issues/77\n\nDo you have time to maybe pair with me on the issue?\n. :+1:\n. I don't see anything wrong with this.\n. Absolutely, thank you.\n. Our next planned release would put us at 1.0.0 and I'm fairly sure we're ready for that.\n\nA large part of what we've been trying to do is improve the development tools (tests, build, services).\n\nTechnically our 1.0.0 milestone is based on [documentation efforts](https://github.com/hamstergem/hamster/issues?milestone=1&state=open) but there's nothing stopping us from just releasing with what we've got.\n\nThoughts?\n. Need to get push permission from @hamstergem/owners.\n. Er, I mean @harukizaemon\n. I need gemcutter access to hamster apparently using: http://guides.rubygems.org/command-reference/#gem_owner\n. Lets start the discussion on if we're willing to accept responsibility for\nthe current public API.\n\nOn Wed, Aug 20, 2014 at 10:34 AM, Adam Rensel notifications@github.com\nwrote:\n\n> Any news on this? I can link to a ref, but a release would be preferable.\n> :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/83#issuecomment-52795890.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Otherwise I'll do another RC.\n\nOn Wed, Aug 20, 2014 at 11:21 AM, Kurtis Rainbolt-Greene <\nme@kurtisrainboltgreene.name> wrote:\n\n> Lets start the discussion on if we're willing to accept responsibility for\n> the current public API.\n> \n> On Wed, Aug 20, 2014 at 10:34 AM, Adam Rensel notifications@github.com\n> wrote:\n> \n> > Any news on this? I can link to a ref, but a release would be preferable.\n> > :)\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/83#issuecomment-52795890.\n> \n> ## \n> \n> Kurtis Rainbolt-Greene, Hacker\n> Software Developer\n> 1631 8th St.\n> New Orleans, LA\n> 70115\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I shipped rc3, so feel free to drop that in and play with it.\n. Can you give me a working example of what you'd like and an example of how you'd do it currently?\n\nI think this would be a good addition but I want to make sure I know where you're going with this.\n. Interesting, so we're looking at modifying `Hamster#merge()` in order to accommodate this behavior.\n\nWhile I don't mind breaking public API (that's what major version bumps are designed to allow) I'm wondering if this should be the default behavior?\n. Alright, so now we just need a PR to accommodate this, yes?\n. While each object responds to similar methods, the result of that behavior is wildly different. Does this not break the behavior contract?\n. Alright, I'm okay with this, feel free to make a PR and it'll be in our 1.0.0-rc2 push.\n. Merged, but I'm not sold on the test structure. I prefer super explicitness. Since it passes it goes in though, good job!\n. This is the drawback of adding multiple public APIs that do the same exact thing (aka aliases): You end up having to maintain multiple public API contracts.\n\nIf we made `#[]` work slightly different from `#list`, we'd have to remember that you combine the tests and suddenly one becomes an untested public API.. (If I'm reading your example correctly).\n. I think we're getting confused. I'm talking about #86's test structure.\n. I am extremely for this kind of dynamic documentation effort. Hamster Lists aren't arrays, though they behave like them. That doesn't mean inspection should make them _look_ like Arrays.\n\nSubmit and I'll GLADLY accept.\n\nYou want a contrib bit as well?\n. Oh, minor nitpick but I'd rather have interpolation:\n\n``` ruby\ndef inspect\n  \"Hamster::List#{to_a.inspect}\"\nend\n```\n. Yeah, this seems saner.\n. Rebase off master plez, that should fix the test problem.\n. Nope, keep the PR, it'll autoupdate after you push.\n. You should be able to `git pull --rebase origin master && git pull --rebase . master && git push -f origin merge_ruby_hash`\n. @plexus The reason I do `spec/lib/foo` is because that puts the `spec_helper.rb` an any extras like `fixtures` and `support` on the `spec/` level, not next to the files inside of `lib/`.\n. Yep.\n\nOn Thu, Aug 14, 2014 at 2:56 AM, Alex Dowad notifications@github.com\nwrote:\n\n> @krainboltgreene https://github.com/krainboltgreene, do you still\n> prefer spec/lib over just spec? If so, I'll finish this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/94#issuecomment-52154004.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Thanks, I hit them up on twitter but didn't get quite any response.\n\nOn Wed, Jun 4, 2014 at 2:33 AM, Alex Dowad notifications@github.com wrote:\n\n> I just sent a PR for JRuby which will fix the Hamster build if accepted:\n> \n> jruby/jruby#1725 https://github.com/jruby/jruby/pull/1725\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/95#issuecomment-45059630.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. What a cluster fuck.\n\nOn Thu, Jun 5, 2014 at 2:29 AM, Alex Dowad notifications@github.com wrote:\n\n> JRuby's developer docs state that they prefer tests to be added to\n> Rubyspec, since they use Rubyspec to determine how close they are to\n> compatibility with MRI.\n> \n> I sent a PR to Rubyspec to add a test which covers this:\n> \n> rubyspec/rubyspec#276 https://github.com/rubyspec/rubyspec/pull/276\n> \n> Unfortunately, the build for my JRuby PR is failing. It doesn't seem\n> related to the PR, though. At https://github.com/jruby/jruby, you can see\n> that the build is also failing for JRuby \"master\".\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/95#issuecomment-45188845.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I've removed 1.8.7 from our testing layer because of issues, but I wonder does this fix it?\n. Thoughts @harukizaemon @plexus? Should we care about 1.8.7?\n. Rodger, thanks for the work though Alex.\n. Actually, just realized this patch is what I wanted anyways, regardless of 1.8 support.\n. So the tests fail in 1.9.2, is that due to your change?\n. Jesus, you're a machine Alex. Alright, I'll merge this but we're dropping 1.9.2. If anyone hasn't upped to 1.9.3 by now, well they can stick to the commit before this merge.\n. Alright, removing travis support.\n. Just noticed Rubinius 2 is also failing, for the same reason?\n. Agreed.\n. How many more of these improvements to performance do you think will come over this month?\n\nI'm considering setting up built in benchmarks for the CI.\n. Thanks!\n. Yeah, I haven't seen anything. Agreed.\n. Oooh nice catch.\n. I guess that's up to @harukizaemon.\n. Haha, we actually prefer double quotes, but I'll merge it all the same.\n. Oh, hey, thanks!\n. One of our goals is to use adamantium. This might be a good chance to nip this by actively deep freezing with that library. Thoughts?\n. So why is this stuff happening in `Set.new` instead of `Set#initialize`?\n. :+1: You're a genius!\n. Marked as 1.0.0.\n. I'm all for removing surface area. We should have a reason why it's not needed written down somewhere, if only a link to this thread.\n. I just imagine someone coming and saying \"Hey, Hamster does collections but doesn't have touples? Riot!\" which may or may not be realistic.\n. I've been wanting to add a list of all the collection types we have, with more documentation for each. Hmm.\n. Agreed.\n. Normally this is something I cherish doing, but I don't have any ideas. Consider this a weak vote for Array's API unless someone comes up with something juicy.\n. I will say that I've always disliked duplicated signatures:\n\n``` ruby\nqueue = Queue.new\nqueue.enqueue(object)\n```\n\nVs\n\n``` ruby\nqueue = Queue.new\nqueue.push(object)\n```\n. You're a god damn machine :P\n\nOn Wed, Aug 13, 2014 at 6:00 PM, Alex Dowad notifications@github.com\nwrote:\n\n> Closed #121 https://github.com/hamstergem/hamster/issues/121.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/121#event-152630365.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Hmm, this is the first time we're going to be brining in an external dependency.\n. Very good points. I'm OK with this then.\n. Using the atomic gem. The performance improvements are too good and the atomic people seem to be taking care of their project in terms of portability.\n. Agreed. I have a benchmark setup for some of my other gems, using\nbenchmark-ips and we can start on the benchmarks gem today.\n\nOn Wed, Aug 20, 2014 at 2:30 PM, Alex Dowad notifications@github.com\nwrote:\n\n> The benchmarks should cover the entire public APIs of all 7 Hamster\n> collections. It should be possible to compare results for 2 different git\n> revisions/branches. It should also be possible to see how results stack up\n> against comparable built-in Hash and Array-using code, or against other\n> libraries which provide similar data structures.\n> \n> To facilitate #126 https://github.com/hamstergem/hamster/issues/126, I\n> suggest the benchmarks should go into their own gem, which will become a\n> development dependency. They can be invoked through Rake tasks.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/127.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I've started improving the benchmarks in #144. I'll finish up over this weekend I think.\n. I shipped rc3.\n. I'm ready if you are.\n\nOn Tue Jan 20 2015 at 12:05:49 PM Alex Dowad notifications@github.com\nwrote:\n\n> About 6 months has past. The -rc3 version gem has been downloaded >1000\n> times. No bug reports against that version have come in. How much more time\n> do you think we should give before shipping it?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-70701649.\n. Alright, I'll release 1.0.0 tonight based on master.\n\nOn Tue Jan 20 2015 at 9:49:24 PM Alex Dowad notifications@github.com\nwrote:\n\n> I also think it's ready.\n> On Jan 21, 2015 1:25 AM, \"Dov Murik\" notifications@github.com wrote:\n> \n> > I think it's ready.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/128#issuecomment-70755789.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-70780382.\n. Yep.\n\nOn Sat, Mar 7, 2015 at 12:27 PM Alex Dowad notifications@github.com wrote:\n\n> @krainboltgreene https://github.com/krainboltgreene, can you go ahead\n> and cut the promised 1.0.0 gem?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/128#issuecomment-77702422.\n. Done.\n\nOn Sat, Mar 7, 2015 at 12:33 PM Kurtis Rainbolt-Greene <\nme@kurtisrainboltgreene.name> wrote:\n\n> Yep.\n> \n> On Sat, Mar 7, 2015 at 12:27 PM Alex Dowad notifications@github.com\n> wrote:\n> \n> > @krainboltgreene https://github.com/krainboltgreene, can you go ahead\n> > and cut the promised 1.0.0 gem?\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/128#issuecomment-77702422.\n. I prefer the plural over the singular.\n\n```\nfirends.permutations\n```\n\nBut if we need the singular, lets drop the plural.\n\nOn Wed, Aug 20, 2014 at 2:41 PM, Alex Dowad notifications@github.com\nwrote:\n\n> Ruby's core classes don't have #permutations and #combinations. Array\n> does have #permutation and #combination. Right now, Hamster::List\n> provides all of them, but Vector and SortedSet do not.\n> \n> Do we want to provide the same method under both names? Or, following the\n> example of Array, just provide #permutation and #combination?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/129.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. My thoughts have always been on removing as many additional methods as possible. Narrow down the public interface.\n\nBut until we do that we've got to document them. I suggest going with an `@!alias` directive.\n. I actually asked this question when I first came to this project!\n\nIt's because alias doesn't traverse inheritance.\n. My vote has always been to reduce the surface area, so we need to list the methods we want as core.\n\nPreferably those methods are as close to Enumerable spec as possible.\n. :+1:, except fuck length :P\n. What's wrong with \"add\"? ;)\n\nBut seriously, I prefer non-truncated methods if possible.\n\nOn Tue, Nov 4, 2014 at 1:56 PM, Alex Dowad notifications@github.com wrote:\n\n> Removed unneeded method aliases from Set in b226952\n> https://github.com/hamstergem/hamster/commit/b2269523fc23ed561c7fad113e8e61691a741dfc\n> and 57e6426\n> https://github.com/hamstergem/hamster/commit/57e642695c85e7c2657435ea3940cc67cf2bb52f.\n> The one remaining question about Set: do we want both #conj and #conjoin?\n> These methods were previously added in an attempt to create a single\n> interface for \"adding an item\" to _any_ collection.\n> \n> This is a very useful thing, but I think we just need one or the other.\n> Which one is it going to be?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-61703562.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. #add() should be a general function for putting an item in the collection,\nregardless of it's implementation (and always the most efficient).\n#unshift() and #push() can handle placement. I say drop #<<, #conj, and\n#conjoin.\n\nOn Tue Nov 04 2014 at 10:27:24 PM Dov Murik notifications@github.com\nwrote:\n\n> I'd stay with #first which is very Ruby-ish; but for List you probably\n> want #head and #tail (car and cdr ??).\n> \n> If you want to keep the requirement for efficient addition (O(1)), then\n> indeed #<< is not a good choice (because this method name hints at \"put\n> at end\" for ordered collections). If so, maybe #conj is indeed the better\n> choice.\n> \n> I guess this will allow to write code like this for any type of\n> empty_collection:\n> \n> my_enumerable_obj.reduce(empty_collection) { |c, e| c.conj(e) }\n> \n> I'm not entirely convinced this generality is needed at all... Can you\n> give an example usage (possible from Clojure)?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-61758383.\n. By the way, I'm not laying down an ultimatum, just my opinion on naming.\n\nOn Wed Nov 05 2014 at 12:34:26 AM Alex Dowad notifications@github.com\nwrote:\n\n> @krainboltgreene https://github.com/krainboltgreene, OK, that makes\n> sense. I think #<< should be kept for ordered collections and Set, since\n> Ruby programmers are accustomed to using it. It is not needed for Hash.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-61765740.\n. Agreed on keeping #<< for ordered collections.\n\nOn Wed Nov 05 2014 at 12:35:56 AM Kurtis Rainbolt-Greene <\nme@kurtisrainboltgreene.name> wrote:\n\n> By the way, I'm not laying down an ultimatum, just my opinion on naming.\n> \n> On Wed Nov 05 2014 at 12:34:26 AM Alex Dowad notifications@github.com\n> wrote:\n> \n> > @krainboltgreene https://github.com/krainboltgreene, OK, that makes\n> > sense. I think #<< should be kept for ordered collections and Set, since\n> > Ruby programmers are accustomed to using it. It is not needed for Hash.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/131#issuecomment-61765740.\n. We cool with Hash#add being #merge()?\n\nOn Fri Nov 07 2014 at 5:35:50 AM Alex Dowad notifications@github.com\nwrote:\n\n> Just pushed a commit which removes #conj and #conjoin. List#add now adds\n> an element to the _front_ of a list (the most efficient place to do it).\n> #group_by_with (which #conj was originally intended to support) now uses\n> #add instead of #conj.\n> \n> Hash#group_by is now broken (there are no tests for it though). To fix\n> it, we need to add Hash#add. It would be good to also add tests for\n> Hash#group_by.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-62130962.\n. @alexdowad right now:\n\n![](http://moviesmedia.ign.com/movies/image/article/116/1168874/assassins-creed-20110517003628556.jpg)\n. My vote: Drop exist, exists, elem_index, contains. We can always add more\ninterfaces if community demands.\n\nOn Fri Nov 14 2014 at 3:12:21 PM Alex Dowad notifications@github.com\nwrote:\n\n> Any comments on #exist? and #exists? as aliases for #any?? I don't think\n> they are needed. How about #elem_index for #index or #contains? for\n> #include??\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-63129693.\n. interval, if no standard exists. Avoids some small confusion I think.\n\nOn Fri Nov 21 2014 at 11:53:50 AM Alex Dowad notifications@github.com\nwrote:\n\n> OK, here's another one. Hamster.range(from, to) and Hamster.interval(from,\n> to) are identical methods, returning a lazy list. Which one should be\n> \"standard\"?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64010158.\n. - #first\n- #last\n- #push, #enqueue\n- #shift, #dequeue\n\nThat's about as far as I'm willing to go, personally.\n\nOn Fri Nov 21 2014 at 11:58:06 AM Alex Dowad notifications@github.com\nwrote:\n\n> Deque is a bit of a mess. The following are groups of identical methods:\n> - #first, #front\n> - #last, #peek\n> - #push, #enqueue, #<<, #add\n> - #shift, #dequeue, #tail\n> \n> As you can tell, some of these names were chosen by analogy with Array,\n> some reflect the use of the structure as a stack, some reflect its use as a\n> queue. #tail reflects the way that \"shifting\" an item out of the front of\n> the deque behaves like taking the \"tail\" of a linked list.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64010791.\n. Third option: Straight up copy/paste the methods.\n\nOn Fri Nov 21 2014 at 12:12:38 PM Alex Dowad notifications@github.com\nwrote:\n\n> We have trimmed down as far as I think we want to go. There don't seem to\n> be any redundant aliases left.\n> \n> The remaining question is if we are going to keep using def_delegator\n> :self, or switch to the more conventional alias. Opinions?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64012826.\n. Agreed.\n\nOn Fri Nov 21 2014 at 7:40:05 PM Dov Murik notifications@github.com wrote:\n\n> I prefer ruby's alias.\n> On Nov 21, 2014 1:17 PM, \"Alex Dowad\" notifications@github.com wrote:\n> \n> > Which option do you prefer? @dubek https://github.com/dubek, do you\n> > have any input?\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/hamstergem/hamster/issues/131#issuecomment-64013472.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64063290.\n. That's amazing to hear. We can get an RC release this morning.\n\nOn Sat Nov 22 2014 at 4:37:00 AM Alex Dowad notifications@github.com\nwrote:\n\n> Closed #131 https://github.com/hamstergem/hamster/issues/131.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#event-197177901.\n. I am entirely OK with a commit that starts with `Hamster::Stack = Hamster::Deque`.\n. Fair point on the cleaning of house. Lets just get rid of Stack completely,\nmake a note of it in the Readme.\n\nOn Thu, Aug 28, 2014 at 2:23 PM, Alex Dowad notifications@github.com\nwrote:\n\n> I did think of the same idea. But would you want Deque permanently\n> aliased as Stack? Or are you thinking of that as a transitional measure?\n> \n> Since Hamster is coming up to a major release, which users should expect\n> to break backwards compatibility, I'd like to clean house. If aliasing\n> collection classes under multiple names is something we would like to do\n> for the long term, that is fine. If not, why not go all the way to where we\n> would really like to be?\n> \n> If aliasing is a good idea, Deque could also be aliased as Queue.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/132#issuecomment-53781951.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. This really only matters with non-trivial objects. Example:\n\n``` ruby\nclass Person\n  attr_reader :name\n  attr_reader :age\n\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  def =(other)\n    @age == other.age\n  end\nend\n\njohn = Person.new(\"John\", 34)\neve = Person.new(\"Eve\", 34)\n\nvector = Vector.new(john, eve).uniq\n```\n\nIf we do first kept, then it'll always be \"John\".\n. I'd just rather drop 2.1.0 support.\nOn Oct 21, 2014 10:46 PM, \"Alex Dowad\" notifications@github.com wrote:\n\n> I suggest we just amend the test to check equality rather than identify if\n> RUBY_VERSION == '2.1.0'. In either case, Hamster is matching the behavior\n> of Ruby's collections.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/137#issuecomment-60033026.\n. I dropped support in #142.\n. :+1:\n. So I removed this in a recent patch and I'm about to readd it. Do you have any pull at inch @rrrene? I'd like to see them get something at http://shields.io/\n. Your best bet is to use our pre-release version or straight from github.\n\nI'm guessing if you're using the git uri then whatever ruby program you're trying to run isn't being run within the context of bundler.\n\nThis means you probably need to prefix `bundle exec` to whatever you're running.\n. What's the point of `Hamster.from`?\n\nAs for `Hash#merge_deep` I'd rather have it as a toggleable thing on `Hash#merge`. We need to talk about merge semantics, too.\n\nFinally, for `Hash#get_in`...I like it, but we're getting close to tackling http://goessner.net/articles/JsonPath/. ;)\n\nOverall these are things I think _need_ to be in hamster, but we're going to need to talk about _how_.\n. Why doesn't this work for storing?\n. Oh fuck, right. Bleh. I totally forgot about Ruby's \"special\" rules for that method.\n. Agreed.\n\nOn Wed, Oct 22, 2014 at 10:29 PM, Alex Dowad notifications@github.com\nwrote:\n\n> The issue here isn't just []=. The issue is that because Hamster\n> collections are immutable, once you drill down to a \"leaf\" collection and\n> insert into it, you have to \"retrace your steps\" back up to the root,\n> inserting each \"modified\" child collection into its original parent, to get\n> a \"modified\" parent collection.\n> \n> I think that we should add #update_in.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/140#issuecomment-60188403.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. For future pull requests, I'd like to see benchmarks like this: https://gist.github.com/krainboltgreene/2433adbb60c0cdcd356c\n. Is it me or is this `#bulk_put` a rather large method? Seems like it could be it's own object?\n. @alexdowad Actually that sounds about right. It'd basically be a set of behavior that turns either turns off rewrite & delete behavior or returns coppies.\n. Unsure.\n\nOn Sun, Mar 15, 2015 at 1:36 AM Alex Dowad notifications@github.com wrote:\n\n> Is this still an issue we want to work on? If unsure, I suggest it can be\n> triaged.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/145#issuecomment-80878388.\n. We'll be using our own badge:\n\n![Gitter](http://img.shields.io/badge/discuss-join%20gitter-brightgreen.svg?style=flat-square)\n. Ideally I'd want first class support for badges at Github, but barring that...What can we do?\n. :+1:\n. :+1: \n. I defer to @alexdowad on this one.\n. Early returns have always been an a bug for me, but quite frankly it seems like it needs to happen in Hamster for performance reasons.\n. By the way, here's the failure on travis:\n\n```\n  1) Hamster::List doesn't give horrendously bad performance if thread realizing the list sleeps\n     Failure/Error: elapsed.should_not > 0.3\n       expected not: > 0.3\n                got:   0.332870754\n     # ./spec/lib/hamster/list/multithreading_spec.rb:46:in `block (2 levels) in <top (required)>'\n```\n\nOnly Ruby 2.0.0.\n. Because \"hamster\" is a really general term, and we don't need to be taking\nthat namespace for a collection library.\n\nAs for the {name}.gem, all of mine quite a few in plus\nhttps://github.com/search?utf8=%E2%9C%93&q=.gem&type=Repositories&ref=searchresults\n.\n\nOn Tue Nov 04 2014 at 7:06:32 PM Dov Murik notifications@github.com wrote:\n\n> (and add to the checklist: modify the github path in hamster.gemspec)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/157#issuecomment-61744049.\n. @hamstergem/contributors Any thoughts on just changing the name in general from `hamster`?\n. Sorry I meant to something more symbolic of the situation, like: \"immutable_collection\" or similar.\n. @alexdowad We could just redirect hamster to immutable-ruby.\n. Thanks for the report!\n\nOn Sat Nov 22 2014 at 8:24:13 PM Wayne Vucenic notifications@github.com\nwrote:\n\n> I realize this has been fixed in github, I just wanted to point out that\n> Windows users doing gem install will encounter a problem.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/161#issuecomment-64103883.\n. We do appreciate the suggestion, though. Let us know how your hamster usage\ngoes.\n\nOn Sat Dec 06 2014 at 3:07:26 PM Joel McCracken notifications@github.com\nwrote:\n\n> That sounds fine. I was thinking about using hash anyway -- so, great.\n> \n> Sent from my iPhone\n> \n> > On Dec 6, 2014, at 10:43 AM, Alex Dowad notifications@github.com\n> > wrote:\n> > \n> > Do you think that an existing Hamster structure, like the immutable\n> > Hash, might help you implement your immutable struct? If so, you could\n> > write your own library which relies on Hamster.\n> > \n> > In any case, I think the relationship between an immutable struct and\n> > the existing Hamster structures is weak, and it would be better to write a\n> > separate library. Small is beautiful. Adding more features bloats both code\n> > size (making the library harder to maintain) and the documentation (making\n> > it harder to learn). If those new features have some inherent synergy with\n> > the existing features, if they combine in ways that makes the whole larger\n> > than the sum of its parts, then putting them together may be a good\n> > tradeoff. Otherwise, let them go their separate ways.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/162#issuecomment-65913928.\n. For what it's worth I'd also love to see how you're using it in a game.\n\nOn Fri Dec 26 2014 at 7:43:11 AM Alex Dowad notifications@github.com\nwrote:\n\n> Closed #163 https://github.com/hamstergem/hamster/issues/163.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/163#event-212064254.\n. I vote B.\n\nOn Fri Dec 26 2014 at 1:37:36 PM Alex Dowad notifications@github.com\nwrote:\n\n> We have List#find_indices, which returns indices for which a provided\n> block returns true, #elem_indices, which returns indices where a given\n> object is found, and #indices, which does either (depending on whether\n> you pass an argument or provide a block).\n> \n> At first I thought this may have been for compatibility with Enumerable,\n> but it's not. It's just something we have made up.\n> \n> I recommend that we either A) drop #indices, since it just does the same\n> things as #find_indices and #elem_indices, or B) drop #find_indices and\n> #elem_indices.\n> \n> Opinions? I like #indices, simply because the name is short and\n> to-the-point.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/164.\n. I'm not afraid of breaking changes, 2.0.0 isn't a special number to me.\n\nOn Mon, Mar 16, 2015 at 2:04 PM Elben Shira notifications@github.com\nwrote:\n\n> Recursively convert Hamster data to a Ruby collection.\n> \n> A big use case is marshaling into JSON:\n> \n> require 'json'\n> Hamster.to(data).to_json\n> \n> An alternative idea is to make Hamster::Hash#to_hash recurse on itself,\n> \n> ## but this seems like an impractical breaking change.\n> \n> You can view, comment on, or merge this pull request online at:\n> \n>   https://github.com/hamstergem/hamster/pull/166\n> Commit Summary\n> - Hamster.to to convert to Ruby collection.\n> \n> File Changes\n> - _M_ lib/hamster/nested.rb\n>   https://github.com/hamstergem/hamster/pull/166/files#diff-0 (23)\n> - _M_ spec/lib/hamster/nested/construction_spec.rb\n>   https://github.com/hamstergem/hamster/pull/166/files#diff-1 (74)\n> \n> Patch Links:\n> - https://github.com/hamstergem/hamster/pull/166.patch\n> - https://github.com/hamstergem/hamster/pull/166.diff\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166.\n. I would rather to_array, but either works.\n\nOn Mon, Mar 16, 2015 at 3:15 PM Elben Shira notifications@github.com\nwrote:\n\n> @krainboltgreene https://github.com/krainboltgreene two other problem\n> with to_hash:\n> - It's not a unified interface across all the Hamster collections\u2014we\n>   would need Hamster::Vector#to_a, Hamster::Set#to_set (?).\n> - It may be expensive, depending on how deep the object is. I'm not\n>   sure what user expectations are on a method called to_hash.\n> \n> The json module, however, mixes in Object#to_json. Maybe Hamster we can\n> do Hamster::Hash#to_mutable (and the rest).\n> \n> @alexdowad https://github.com/alexdowad on top of the alternative\n> above, what about Hamster.to_mutable.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-81913069.\n. I do enjoy the idea of #to_mutable_x.\n\nOn Mon, Mar 16, 2015 at 7:28 PM Dov Murik notifications@github.com wrote:\n\n> Although JSON and Yaml modules add Array#to_json and Hash#to_yaml and so\n> on, I prefer not to go this way (that is, not to add method to basic Ruby\n> objects).\n> \n> I'd rather stay with Hamster::Vector#to_a as mentioned above. If needed,\n> add Hamster::Hash#to_h and Hamster::Set#to_set (or maybe #to_ruby_set ?)\n> as needed to convert to regular Ruby objects.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82004824.\n. Have I noted before how un-semantic `Hamster::Hash[]` is syntactically?\n\nAnyways, this looks great.\n\nOn Tue, Mar 17, 2015 at 6:39 PM Elben Shira notifications@github.com\nwrote:\n\n> Let me know what you think about these latest commits.\n> \n> h=Hamster::Hash[\n>             \"a\" => 1,\n>             \"b\" => Hamster::Vector[2, Hamster::Hash[\"c\" => 3], 4],\n>             \"d\" => Hamster::Set[5, 6, 7],\n>             \"e\" => Hamster::Hash[\"f\" => 8, \"g\" => 9],\n>             \"h\" => Regexp.new(\"ijk\"),\n>             \"l\" => Hamster::SortedSet.new([1, 2, 3])]\n> h.to_ruby# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n> Hamster.to_ruby(h)# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82641919.\n. I'm pretty annoyed the decided to bundle it. Like, at the very least do it\nthe way Rails does.\n\nOn Sun, Apr 5, 2015 at 9:09 PM Dov Murik notifications@github.com wrote:\n\n> Another option is to have two implementations:\n> 1. If the concurrent gem is installed, use it (require\n>    'concurrent/atomics' and use the Atomic class).\n> 2. Otherwise, build a naive (=slow) implementation using a Mutex for\n>    any read/write operation on @atomic https://github.com/atomic (which\n>    can then be a normal fixnum).\n> \n> This way hamster works out-of-the-box without other dependencies, and if\n> you need List to be faster then you just gem install concurrent.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/167#issuecomment-89889902.\n. Looking deeper:\n\n``` ruby\ncollection.grep(query)\n# From: hamster-1.0.0/lib/hamster/set.rb @ line 199 Hamster::Set#select:\n# \n#     199: def select\n#     200:   return enum_for(:select) unless block_given?\n#     201:   trie = @trie.select { |key, _| yield(key) }\n#     202:   new_trie(trie)\n#     203: end\n\nreturn enum_for(:select) unless block_given?\n# => nil\n\ntrie = @trie.select { |key, _| yield(key) }\n# => #<Hamster::Trie:0x007fa200abfa28\n#  @children=[],\n#  @entries=\n#   [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil],\n#  @significant_bits=0,\n#  @size=0>\n\nnew_trie(trie)\n# => Hamster::Set[]\n\n@trie\n# => #<Hamster::Trie:0x007fa2003c2c98\n#  @children=[],\n#  @entries=\n#   [nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    nil,\n#    [#<Earhart::Route:0x007fa2009fc078 @pattern=/GET \\/accounts\\/(?<id>.+)/, @receiver=Object>, nil]],\n#  @significant_bits=0,\n#  @size=1>\n```\n. I don't think it's supposed to do that, obviously, but it makes sense now why the grep didn't work.\n\n``` ruby\nitems = []\n# => []\n@trie = Trie.new(0)\n# => #<Hamster::Trie:0x007fe42d186208 @children=[], @entries=[], @significant_bits=0, @size=0>\nitems.each { |item| @trie.put!(item, nil) }\n# => []\n@trie\n# => #<Hamster::Trie:0x007fe42d186208 @children=[], @entries=[], @significant_bits=0, @size=0>\n```\n\nSo it looks like this huge array with nils only happens when using `Hamster::Set::EmptySet`, which passes `[nil]` as an item to initialize.\n. Really? Is there a particular reason we create big nil-filled arrays? Isn't that memory wasteful?\n\nAnd I tried switching the method around:\n\n``` ruby\ndef ===(query)\n  query === pattern\nend\n```\n\nAnd got the same issue.\n. Another thing I wanted to ask is: Is this even the right function for me? I realized last night that select returns an array, but what I really want is the first result found. I thought Set was lazy?\n. That === example is what I did. I guess I still don't understand why my\ncode isn't working in this case, but frankly I'll want find on list anyways.\n\nOn Fri, Apr 17, 2015 at 1:05 AM Alex Dowad notifications@github.com wrote:\n\n> #find is what you are looking for.\n> \n> No, Set is not lazy. Only List is. Linked lists allow for a natural and\n> efficient \"lazy\" implementation, but most other data structures do not. For\n> comparison, Clojure has lazy lists which you can create using lazy-seq,\n> but its other built-in structures are strict. Languages like Haskell\n> achieve laziness not by providing a full set of \"lazy\" general-purpose data\n> structures, but by delaying the evaluation of code until its results are\n> needed.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/168#issuecomment-93901174.\n. Yes, at the moment.\n\nOn Thu, Apr 16, 2015 at 8:13 AM Dov Murik notifications@github.com wrote:\n\n> Generally I'm not against your suggestion, but these \"early returns\" are\n> very common throughout the Hamster code, and in some cases make the code\n> easier to read IMO. @krainboltgreene https://github.com/krainboltgreene\n> did you intend to modify all the similar occurrences of return ... unless\n> ...?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/169#issuecomment-93730908.\n. Yeah, the List class has all sorts of weird shortcut methods that involve\nCons, and I'm fine leaving it that way.\n\nOn Thu, Apr 16, 2015 at 9:12 AM Alex Dowad notifications@github.com wrote:\n\n> OK, fair enough. Agreed.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/170#issuecomment-93744487.\n. This is a WIP.\n\nOn Thu, Apr 16, 2015 at 3:05 PM Dov Murik notifications@github.com wrote:\n\n> OK sure. The README should be fixed though (line 200) to square brackets.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/170#issuecomment-93827927.\n. <3\nOn Sep 9, 2015 10:39 AM, \"Alex Dowad\" <notifications@github.com> wrote:\n\n> I just removed Hamster.vector, including updating all the documentation\n> and specs, in f444320\n> https://github.com/hamstergem/hamster/commit/f4443205ce9f8e9a6df661d1acb64e747b2640a1.\n> Will push a commit which removes Hamster.hash next.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/170#issuecomment-138986575.\n. God, I'd love to have that gemname. I'm going to see if I can grab it from the author.\n. We appreciate it either way.\n\nOn Wed, May 13, 2015 at 5:14 AM, Ilya Lavrov notifications@github.com\nwrote:\n\n> I just noticed JRuby-1.7.20 has already released and works fine with\n> original spec. Pull request does not make sense.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/175#issuecomment-101609834.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. If we could switch to `remove_instance_variable` that'd be great too.\n. If it's slower than setting to nil I'm going to laugh all the way to\ntwitter.\n\nOn Thu, May 14, 2015 at 2:22 PM, Alex Dowad notifications@github.com\nwrote:\n\n> Thanks to @dubek https://github.com/dubek for pointing out the issue\n> with List#span -- I have pushed another commit to attempted_race_fix. (It\n> would be nice if we had a spec which confirmed both the problem and the\n> fix...)\n> \n> Thanks to @dzjuck https://github.com/dzjuck for finding the problem in\n> the first place, and confirming the fix.\n> \n> Regarding the use of remove_instance_variable -- I wonder what the\n> performance impact would be? Does anyone want to try benchmarking?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/177#issuecomment-102143048.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Is polymorphism something we care about?\n\nCurrently I'm of the opinion that our collection objects are too complex to inherit from intelligently, and that users should wrap their specialized objects around a Hamster object.\n\nAdditionally, I'm almost tempted to say that the canonical way should be `Hamster::Vector::EMPTY`, and that `Hamster.vector()` _requires_ items.\n\nOf course I'm also tempted to just drop `Hamster.vector()` in lieu of `Hamster::Vector.new`. Giving us two ways to create an empty vector:\n\n``` ruby\nHamster::Vector::EMPTY # memoized\nHamster::Vector.new # fresh\n```\n. I'll work up a PR, good talk.\n. Sold.\n\nOn Mon, Aug 17, 2015 at 9:41 AM, Xavier Shay notifications@github.com\nwrote:\n\n> Nice find!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/189#issuecomment-131844954.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. I'll do it tonight!\n\nOn Mon, Oct 26, 2015 at 6:22 AM, Alex Dowad notifications@github.com\nwrote:\n\n> Yes, it's @krainboltgreene https://github.com/krainboltgreene. 1.1.0\n> gem, please!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/201#issuecomment-151131400.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. Released as v2.0.0, since we had breaking public API changes (detailed in CHANGELOG.md)\n. Awesome have at it :)\nOn Nov 16, 2015 9:33 AM, \"studiolo\" notifications@github.com wrote:\n\n> Hi, I saw this on Ruby Issues and would like to call dibs - to support the\n> good cause and to practice git bit.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/205#issuecomment-157111410.\n. me@kurtisrainboltgreene.name, I take personal responsibility.\n\nI appreciate the details, but we definitely agree with it.\n. @studiolo You're right, follow this example: https://github.com/krainboltgreene/blankgem.gem\n. <3 <3 <3\n. :+1:\n\nOn Fri, Dec 4, 2015 at 8:08 PM, Alex Dowad notifications@github.com wrote:\n\n> Good catch. This is definitely a bug; a bug in specification.\n> \n> I would prefer just to bump the minor version number after applying a fix.\n> @krainboltgreene https://github.com/krainboltgreene?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/215#issuecomment-162137494.\n\n## \n\nKurtis Rainbolt-Greene, Hacker\nSoftware Developer\n1631 8th St.\nNew Orleans, LA\n70115\n. :+1:\n. Weeeeeee. Thanks for checking on it.\n. Out!\n. @alexdowad It was a major release, actually, since we changed the behavior of values_at.\n. ",
    "cstorey": "Aye. It looks like it's just a case of adding #marshal_dump and #marshal_load methods to the Trie class. The test case the fix will be a little weird, as it'll involve doing spawning a fresh ruby process. It's not often you need to fork when testing data structures! \n. Thanks!\n. Aye. It looks like it's just a case of adding #marshal_dump and #marshal_load methods to the Trie class. The test case the fix will be a little weird, as it'll involve doing spawning a fresh ruby process. It's not often you need to fork when testing data structures! \n. Thanks!\n. ",
    "stass": "It looks like your filesystem does not like the question mark in the file name, so it cannot extract. :-(\n. It looks like your filesystem does not like the question mark in the file name, so it cannot extract. :-(\n. ",
    "johntseng": "Thanks for looking into this. The file no longer has a question mark in the file name: https://github.com/harukizaemon/hamster/tree/master/spec/hamster/experimental/mutable_set\n. Thanks for looking into this. The file no longer has a question mark in the file name: https://github.com/harukizaemon/hamster/tree/master/spec/hamster/experimental/mutable_set\n. ",
    "spajus": "Oh, sorry then :)\n. Oh, sorry then :)\n. ",
    "plexus": "ok, I'll see what I can do.\n. Reopening to discuss some guidelines. \n\nWhat format are we going to use? I've become quite a fan of YARD style documentation as used by rom_rb, e.g.\n\nhttps://github.com/plexus/hexp/blob/master/lib/hexp/node.rb\n\nIt's characterized by using explicit `@param` and `@return` blocks. These contain type information, although that can be simply \"responds to message x\". All methods that are `@api public` are supposed to have an example. e.g.\n\n``` ruby\n    # Return a new node, with a different tag\n    #\n    # @example\n    #   H[:div, class: 'foo'].set_tag(:bar)\n    #   # => H[:bar, class: 'foo']\n    #\n    # @param tag [#to_sym] The new tag\n    # @return [Hexp::Node]\n    #\n    # @api public\n```\n\nWhen using that there's the `yardstick` tool to verify the docs and measure coverage.\n\nIs that cool with everyone, or do you prefer more class RDoc?\n. FYI, [http://rdoc.info/](http://rdoc.info/) lets you browse the docs of any project on Github. \n. I second this! This is the main incompatibility between Hamster::Hash and plain Hash. E.g. this doesn't work\n\n``` ruby\nHamster.hash.merge(:foo => :bar)\n```\n. Thanks! That would be handy. I'll probably still go through pull requests\nfor code review and feedback for bigger changes.\nOn 29 Dec 2013 21:12, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> I'll give you commit rights, so when you get the chance you can implement\n> this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/issues/31#issuecomment-31329090\n> .\n. there you go!\n. \\o/\n\nhttp://rdoc.info/github/harukizaemon/hamster/master/frames\n. I'm very excited about this project, I think it has a bright future. I also plan to mention it in the book I'm writing\n\nhttps://leanpub.com/happylambda\n\nI also started this which I intend to make interface-compatible with Hamster.\n\nhttps://github.com/plexus/clochard\n. I'll just need some time to clean it up, add docs, tests, etc. But I can\nmake an early PR once I start on it to incorporate feedback.\nOn 01 Dec 2013 18:49, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> I think this at the very least deserves to be a extension library if not a\n> part of hamster. Do you need any help with the pull request?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/64#issuecomment-29584115\n> .\n. Decided in the end to go for a \"microrb\" approach and make it its own gem: \"fzip\". [github repo](https://github.com/plexus/fzip), [rubygems](http://rubygems.org/gems/fzip)\n. They are not exactly the same, as the (Ruby default) flatten works recursively\n\n``` ruby\n[1,2,3].map{|i| [[i],[i*i]]}.flatten\n#=> [1, 1, 2, 4, 3, 9]\n[1,2,3].flat_map{|i| [[i],[i*i]]}\n#=> [[1], [1], [2], [4], [3], [9]]\n```\n\nI guess I should add a test case to specifiy this behavior :)\n\nA possible improvement would be to first implement a way to chain two lists, so have a data structure that has a reference to two lists, and delegates operations. With that implementing flat_map would become almost trivial.\n. Ah wait, `flatten(1)`. I didn't realize you could pass in a level there!\n. I totally agree on implementing this on top of an implementation of\nflatten, but don't think I'll get to that very soon.\nOn 10 Dec 2013 23:57, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> For what it's worth I'm totally ready to merge this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/pull/66#issuecomment-30290017\n> .\n. +1 for chruby!\n\nIf anyone is using Emacs, there's a chruby port for Emacs as well ;) [plexus/chruby.el](https://github.com/plexus/chruby.el)\n. In light of this it might be worth it to have a look at [Devtools](https://github.com/rom-rb/devtools), it provides a shared setup and rake tasks for flog, flay, reek, rubocop, yardstick and mutant.\n\nI'm not advocating swithcing to it right away, but if you want more \"metric driven development\" that really gives you the full package. On the other hand it's brutal, I use it on some projects and after every set of changes I have to take the time to adjust/fix the metrics.\n. :+1: \n. > before blocks should always have :each defined:\n\nInteresting. Do you know of other projects with this policy. I usually prefer a simple `before do`, since the alternative `before(:all) do` is in my experience rarely used, so no need to explicitly distinguish.\n. I see, I didn't realize it did anything locally. You can leave it in then.\nI'm using a custom formatter when running inside emacs, I can probably\nfigure out a better way for it to play together with coveralls.\nOn 29 Dec 2013 21:16, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> Alright, so I actually use coveralls locally to get a simple coverage\n> print out. Do you have an alternative?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/pull/79#issuecomment-31329154\n> .\n. If you're on Emacs I could pass some cool stuff I've been working on :)\n\n![2013-12-29-231012_624x433_scrot](https://f.cloud.github.com/assets/32212/1820603/876408e6-70f7-11e3-931b-0fdb2936cb9d.png)\n. Actually before I used simplecov (which is what Coveralls uses under the hood). By default it generates a HTML report with per-line coverage. Apart from having to go to a browser it's an elegant solution.\n. Sounds pretty good. Maybe you could already push a 1.0.0pre or 1.0.0rc1 or something. Rubygems will consider such a version name as being \"pre-release\" and so people will not automatically get updated, but they can opt in.\n\nA pre-release could be interesting to make some noise and gather some more feedback.\n\nBut just pushing 1.0.0 would be fine as well :)\n. I've looked at this before briefly, IIRC the root of the problem is that a Hamster.hash behaves differently from a plain hash when iterating over it\n\n```\nirb(main):003:0> {foo: :bar}.each {|*x| p x}\n[[:foo, :bar]]\nirb(main):004:0> Hamster.hash(foo: :bar).each {|*x| p x}\n[:foo, :bar]\n```\n\nHamster expects that the argument to merge can be iterated in the latter way.\n. I would personally **not** do type conversion on `eql?`, it's supposed to be a stricter equality than `==`, e.g. numbers do type conversion on `==` but not on `eql?`\n\n``` ruby\n9 == 9.0 #=> true\n9.eql?(9.0) #=> false\n```\n\nLooking at the [Object docs](http://ruby-doc.org/core-2.1.2/Object.html#method-i-eql-3F) this is not a general rule, but in this case I think it makes sense to use the distinction so users can choose from\n- `==` value equality, Hash and Hamster::Hash are equal if same contents\n- `eql?` strict equality (value and type equality)\n- `equal?` object-id equality (reference equality), built-in, don't touch\n- `===` case equality. Falls back to `==` by default, which is what ::Hash does as well. Can be overridden to be used in case statements (see e.g. Regexp, Class, Proc), but in this case I would mimic Hash/use the default and simply have it be an alias for `==`\n. See also #86 for a (IMHO) nice way to structure the tests.\n. Can you show how you would do it? I think for tests like these where you just want to test a bunch of different cases this is the cleanest way.\n\nThe original had\n\n``` ruby\n      [\n        [[], [], true],\n        [[], [nil], false],\n        [[\"A\"], [], false],\n        [[\"A\"], [\"A\"], true],\n        [[\"A\"], [\"B\"], false],\n        [%w[A B], [\"A\"], false],\n        [%w[A B C], %w[A B C], true],\n        [%w[C A B], %w[A B C], false],\n      ].each do |a, b, expected|\n```\n\nWhich I certainly like less. The alternative of writing every single test\n\n``` ruby\ndescribe \"a Hamster.list(1,2,3) and [1,2,3]\" do\n  it 'should be ==' ..\n  it 'should not be eql?' ...\nend\n```\n\nseems super repetitive without adding much value.\n. I'm guessing that comment was for #87 ?\n\nMy main point is to have a more clear inspect. I'm also fine with it outputting `\"Hamster.list(1,2,3)\"` instead of `\"Hamster::List[1,2,3]\"`.\n. In the case of #86 they are separate methods with different behavior, and\ntested separately. Although tests for eql? also check ==, because one\nshould imply the other, but not vice versa.\n\nSo I'm not sure what you're suggesting... Split tests for == and esp? in\nseparate files?\nOn May 17, 2014 12:20 PM, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> I think we're getting confused. I'm talking about #86https://github.com/hamstergem/hamster/pull/86's\n> test structure.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/issues/85#issuecomment-43397240\n> .\n. Ok, just need to add some specs and will put this in.\n\nI already have commit bit, but most of the time still prefer going through\nPR for feedback and visibility.\nOn May 17, 2014 12:19 PM, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> Oh, minor nitpick but I'd rather have interpolation:\n> \n> def inspect\n>   \"Hamster::List#{to_a.inspect}\"end\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/issues/87#issuecomment-43397209\n> .\n. :+1: \n. To be honest I've never seen this layout in Ruby projects. I believe `lib/foo` matching `spec/foo` is much more common.\n. It would be good form to include a test in that JRuby PR.\n. I'm absolutely fine with dropping 1.8 support. It's been dead for a while now. \n. 1.9.2 end its \"extended maintenance period\" (whatever that means) in 4 days, it stopped taking security fixes a year ago. I think we can safely call it dead.\n\nhttps://bugs.ruby-lang.org/projects/ruby/wiki/ReleaseEngineering\n. I prefer a memorable and marketable name like Hamster over something descriptive but bland. Hamster already has some mindshare, so my vote is on keeping the name. \n. ok, I'll see what I can do.\n. Reopening to discuss some guidelines. \n\nWhat format are we going to use? I've become quite a fan of YARD style documentation as used by rom_rb, e.g.\n\nhttps://github.com/plexus/hexp/blob/master/lib/hexp/node.rb\n\nIt's characterized by using explicit `@param` and `@return` blocks. These contain type information, although that can be simply \"responds to message x\". All methods that are `@api public` are supposed to have an example. e.g.\n\n``` ruby\n    # Return a new node, with a different tag\n    #\n    # @example\n    #   H[:div, class: 'foo'].set_tag(:bar)\n    #   # => H[:bar, class: 'foo']\n    #\n    # @param tag [#to_sym] The new tag\n    # @return [Hexp::Node]\n    #\n    # @api public\n```\n\nWhen using that there's the `yardstick` tool to verify the docs and measure coverage.\n\nIs that cool with everyone, or do you prefer more class RDoc?\n. FYI, [http://rdoc.info/](http://rdoc.info/) lets you browse the docs of any project on Github. \n. I second this! This is the main incompatibility between Hamster::Hash and plain Hash. E.g. this doesn't work\n\n``` ruby\nHamster.hash.merge(:foo => :bar)\n```\n. Thanks! That would be handy. I'll probably still go through pull requests\nfor code review and feedback for bigger changes.\nOn 29 Dec 2013 21:12, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> I'll give you commit rights, so when you get the chance you can implement\n> this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/issues/31#issuecomment-31329090\n> .\n. there you go!\n. \\o/\n\nhttp://rdoc.info/github/harukizaemon/hamster/master/frames\n. I'm very excited about this project, I think it has a bright future. I also plan to mention it in the book I'm writing\n\nhttps://leanpub.com/happylambda\n\nI also started this which I intend to make interface-compatible with Hamster.\n\nhttps://github.com/plexus/clochard\n. I'll just need some time to clean it up, add docs, tests, etc. But I can\nmake an early PR once I start on it to incorporate feedback.\nOn 01 Dec 2013 18:49, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> I think this at the very least deserves to be a extension library if not a\n> part of hamster. Do you need any help with the pull request?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/issues/64#issuecomment-29584115\n> .\n. Decided in the end to go for a \"microrb\" approach and make it its own gem: \"fzip\". [github repo](https://github.com/plexus/fzip), [rubygems](http://rubygems.org/gems/fzip)\n. They are not exactly the same, as the (Ruby default) flatten works recursively\n\n``` ruby\n[1,2,3].map{|i| [[i],[i*i]]}.flatten\n#=> [1, 1, 2, 4, 3, 9]\n[1,2,3].flat_map{|i| [[i],[i*i]]}\n#=> [[1], [1], [2], [4], [3], [9]]\n```\n\nI guess I should add a test case to specifiy this behavior :)\n\nA possible improvement would be to first implement a way to chain two lists, so have a data structure that has a reference to two lists, and delegates operations. With that implementing flat_map would become almost trivial.\n. Ah wait, `flatten(1)`. I didn't realize you could pass in a level there!\n. I totally agree on implementing this on top of an implementation of\nflatten, but don't think I'll get to that very soon.\nOn 10 Dec 2013 23:57, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> For what it's worth I'm totally ready to merge this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/harukizaemon/hamster/pull/66#issuecomment-30290017\n> .\n. +1 for chruby!\n\nIf anyone is using Emacs, there's a chruby port for Emacs as well ;) [plexus/chruby.el](https://github.com/plexus/chruby.el)\n. In light of this it might be worth it to have a look at [Devtools](https://github.com/rom-rb/devtools), it provides a shared setup and rake tasks for flog, flay, reek, rubocop, yardstick and mutant.\n\nI'm not advocating swithcing to it right away, but if you want more \"metric driven development\" that really gives you the full package. On the other hand it's brutal, I use it on some projects and after every set of changes I have to take the time to adjust/fix the metrics.\n. :+1: \n. > before blocks should always have :each defined:\n\nInteresting. Do you know of other projects with this policy. I usually prefer a simple `before do`, since the alternative `before(:all) do` is in my experience rarely used, so no need to explicitly distinguish.\n. I see, I didn't realize it did anything locally. You can leave it in then.\nI'm using a custom formatter when running inside emacs, I can probably\nfigure out a better way for it to play together with coveralls.\nOn 29 Dec 2013 21:16, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> Alright, so I actually use coveralls locally to get a simple coverage\n> print out. Do you have an alternative?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/pull/79#issuecomment-31329154\n> .\n. If you're on Emacs I could pass some cool stuff I've been working on :)\n\n![2013-12-29-231012_624x433_scrot](https://f.cloud.github.com/assets/32212/1820603/876408e6-70f7-11e3-931b-0fdb2936cb9d.png)\n. Actually before I used simplecov (which is what Coveralls uses under the hood). By default it generates a HTML report with per-line coverage. Apart from having to go to a browser it's an elegant solution.\n. Sounds pretty good. Maybe you could already push a 1.0.0pre or 1.0.0rc1 or something. Rubygems will consider such a version name as being \"pre-release\" and so people will not automatically get updated, but they can opt in.\n\nA pre-release could be interesting to make some noise and gather some more feedback.\n\nBut just pushing 1.0.0 would be fine as well :)\n. I've looked at this before briefly, IIRC the root of the problem is that a Hamster.hash behaves differently from a plain hash when iterating over it\n\n```\nirb(main):003:0> {foo: :bar}.each {|*x| p x}\n[[:foo, :bar]]\nirb(main):004:0> Hamster.hash(foo: :bar).each {|*x| p x}\n[:foo, :bar]\n```\n\nHamster expects that the argument to merge can be iterated in the latter way.\n. I would personally **not** do type conversion on `eql?`, it's supposed to be a stricter equality than `==`, e.g. numbers do type conversion on `==` but not on `eql?`\n\n``` ruby\n9 == 9.0 #=> true\n9.eql?(9.0) #=> false\n```\n\nLooking at the [Object docs](http://ruby-doc.org/core-2.1.2/Object.html#method-i-eql-3F) this is not a general rule, but in this case I think it makes sense to use the distinction so users can choose from\n- `==` value equality, Hash and Hamster::Hash are equal if same contents\n- `eql?` strict equality (value and type equality)\n- `equal?` object-id equality (reference equality), built-in, don't touch\n- `===` case equality. Falls back to `==` by default, which is what ::Hash does as well. Can be overridden to be used in case statements (see e.g. Regexp, Class, Proc), but in this case I would mimic Hash/use the default and simply have it be an alias for `==`\n. See also #86 for a (IMHO) nice way to structure the tests.\n. Can you show how you would do it? I think for tests like these where you just want to test a bunch of different cases this is the cleanest way.\n\nThe original had\n\n``` ruby\n      [\n        [[], [], true],\n        [[], [nil], false],\n        [[\"A\"], [], false],\n        [[\"A\"], [\"A\"], true],\n        [[\"A\"], [\"B\"], false],\n        [%w[A B], [\"A\"], false],\n        [%w[A B C], %w[A B C], true],\n        [%w[C A B], %w[A B C], false],\n      ].each do |a, b, expected|\n```\n\nWhich I certainly like less. The alternative of writing every single test\n\n``` ruby\ndescribe \"a Hamster.list(1,2,3) and [1,2,3]\" do\n  it 'should be ==' ..\n  it 'should not be eql?' ...\nend\n```\n\nseems super repetitive without adding much value.\n. I'm guessing that comment was for #87 ?\n\nMy main point is to have a more clear inspect. I'm also fine with it outputting `\"Hamster.list(1,2,3)\"` instead of `\"Hamster::List[1,2,3]\"`.\n. In the case of #86 they are separate methods with different behavior, and\ntested separately. Although tests for eql? also check ==, because one\nshould imply the other, but not vice versa.\n\nSo I'm not sure what you're suggesting... Split tests for == and esp? in\nseparate files?\nOn May 17, 2014 12:20 PM, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> I think we're getting confused. I'm talking about #86https://github.com/hamstergem/hamster/pull/86's\n> test structure.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/issues/85#issuecomment-43397240\n> .\n. Ok, just need to add some specs and will put this in.\n\nI already have commit bit, but most of the time still prefer going through\nPR for feedback and visibility.\nOn May 17, 2014 12:19 PM, \"Kurtis Rainbolt-Greene\" notifications@github.com\nwrote:\n\n> Oh, minor nitpick but I'd rather have interpolation:\n> \n> def inspect\n>   \"Hamster::List#{to_a.inspect}\"end\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/hamstergem/hamster/issues/87#issuecomment-43397209\n> .\n. :+1: \n. To be honest I've never seen this layout in Ruby projects. I believe `lib/foo` matching `spec/foo` is much more common.\n. It would be good form to include a test in that JRuby PR.\n. I'm absolutely fine with dropping 1.8 support. It's been dead for a while now. \n. 1.9.2 end its \"extended maintenance period\" (whatever that means) in 4 days, it stopped taking security fixes a year ago. I think we can safely call it dead.\n\nhttps://bugs.ruby-lang.org/projects/ruby/wiki/ReleaseEngineering\n. I prefer a memorable and marketable name like Hamster over something descriptive but bland. Hamster already has some mindshare, so my vote is on keeping the name. \n. ",
    "arbrown": "Do you mean instead of a Stream? And should it be a SortedSet type from the standard library?  Or a sorted Hamster::Set?  Or do you want a new Hamster::SortedSet class?\n\nPlease advise.\n. Do you mean instead of a Stream? And should it be a SortedSet type from the standard library?  Or a sorted Hamster::Set?  Or do you want a new Hamster::SortedSet class?\n\nPlease advise.\n. ",
    "dkubb": "Let me know if I can help. The memoization/freezing code in Adamantium was extracted from Axiom, which itself was I basically copied from Hamster. It's been changed and refactored since then, but I think it should still be mostly api compatible with Hamster. The only exceptions are `#transform` and `#transform_unless`, which I would be happy to add if needed.\n. @krainboltgreene Sorry for the delay. Adamantium is probably production ready now, but I will be releasing a 1.0 within the next few weeks if the version number is important to you. I don't suspect any interface changes between now and then, just some extra polishing and refactoring.\n. BTW, I've added `#transform` and `#transform_unless` to the master branch since it looks like hamster relies on them quite a lot.\n. Let me know if I can help. The memoization/freezing code in Adamantium was extracted from Axiom, which itself was I basically copied from Hamster. It's been changed and refactored since then, but I think it should still be mostly api compatible with Hamster. The only exceptions are `#transform` and `#transform_unless`, which I would be happy to add if needed.\n. @krainboltgreene Sorry for the delay. Adamantium is probably production ready now, but I will be releasing a 1.0 within the next few weeks if the version number is important to you. I don't suspect any interface changes between now and then, just some extra polishing and refactoring.\n. BTW, I've added `#transform` and `#transform_unless` to the master branch since it looks like hamster relies on them quite a lot.\n. ",
    "coveralls": "[![Coverage Status](https://coveralls.io/builds/373586/badge)](https://coveralls.io/builds/373586)\n\nChanges Unknown when pulling **6c846a3a9038a313813430cf1026e8674218ee45 on introducing-coveralls** into *\\* on master**.\n. [![Coverage Status](https://coveralls.io/builds/386861/badge)](https://coveralls.io/builds/386861)\n\nCoverage remained the same when pulling **824771461730f9472ecac8a21da05bb8a5f6d503 on rewriting-tests-and-syntax** into **aaf874b20bd31c2d984ae131dbf58d9a9bc2b379 on master**.\n. [![Coverage Status](https://coveralls.io/builds/373586/badge)](https://coveralls.io/builds/373586)\n\nChanges Unknown when pulling **6c846a3a9038a313813430cf1026e8674218ee45 on introducing-coveralls** into *\\* on master**.\n. [![Coverage Status](https://coveralls.io/builds/386861/badge)](https://coveralls.io/builds/386861)\n\nCoverage remained the same when pulling **824771461730f9472ecac8a21da05bb8a5f6d503 on rewriting-tests-and-syntax** into **aaf874b20bd31c2d984ae131dbf58d9a9bc2b379 on master**.\n. ",
    "michaelneale": "Needs more cowbell.\n. Needs more cowbell.\n. ",
    "gcapizzi": "Hi! :smiley: Is there anything keeping this from being merged? Should I proceed to add `#conj` everywhere?\n. ok! :+1: \n. Hi! :smiley: Is there anything keeping this from being merged? Should I proceed to add `#conj` everywhere?\n. ok! :+1: \n. ",
    "404pnf": "@krainboltgreene \n\nMy own branch.\n\nIf I am on master branch, spec failed.\n\nI made simple changes like this\n\n```\n def all?\n       return all? { |item| item } unless block_given?\n-      each { |item| return false unless yield(item) }\n-      true\n+      reduce(true) { |a, e| a && yield(e) }\n     end\n```\n\nCan I test it on a branch rather than master?  Thank you!\n. I know how to test.  1.  First merge master with my own branch 2. run rake spec\n\nI also know my changes are not compatible.  Since hamster expects literal true and false, my solutions with fold won't pass the test.\n\n```\na && yield(e)  # will return  false or nil or last yield(e)\n\nyield(e) && a  # will return nil or false or true\n```\n. I will do my best!  Though I don't know anything about how  \"pair programming\" work on github issues.\n\nI think the current spec makes sense. But it's not idiomatic for ruby programmers. \n\nBy forcing predict to return literal truth values rather than rely on the fact anything not nil or false is true, we are preparing ruby programmers to think more like programmers of typed functional languages, where only boolean type can be used with if/unless. \n. @krisleech  That's the solution (!!), thank you!\n\nSince not being able to run test is a false alarm, please re-lable and close the issue.\n. better solution is to use the '&' and '|' in NilClass\n\n```\n>> true & 3\n=> true\n>> true && 3\n=> 3\n```\n\nhttp://www.ruby-doc.org/core-2.1.0/NilClass.html\n. @krainboltgreene \n\nMy own branch.\n\nIf I am on master branch, spec failed.\n\nI made simple changes like this\n\n```\n def all?\n       return all? { |item| item } unless block_given?\n-      each { |item| return false unless yield(item) }\n-      true\n+      reduce(true) { |a, e| a && yield(e) }\n     end\n```\n\nCan I test it on a branch rather than master?  Thank you!\n. I know how to test.  1.  First merge master with my own branch 2. run rake spec\n\nI also know my changes are not compatible.  Since hamster expects literal true and false, my solutions with fold won't pass the test.\n\n```\na && yield(e)  # will return  false or nil or last yield(e)\n\nyield(e) && a  # will return nil or false or true\n```\n. I will do my best!  Though I don't know anything about how  \"pair programming\" work on github issues.\n\nI think the current spec makes sense. But it's not idiomatic for ruby programmers. \n\nBy forcing predict to return literal truth values rather than rely on the fact anything not nil or false is true, we are preparing ruby programmers to think more like programmers of typed functional languages, where only boolean type can be used with if/unless. \n. @krisleech  That's the solution (!!), thank you!\n\nSince not being able to run test is a false alarm, please re-lable and close the issue.\n. better solution is to use the '&' and '|' in NilClass\n\n```\n>> true & 3\n=> true\n>> true && 3\n=> 3\n```\n\nhttp://www.ruby-doc.org/core-2.1.0/NilClass.html\n. ",
    "krisleech": "IMHO predict methods should return literal true/false and not nil or some other object, I don't think this is a case where \"duck typing\" is of benefit.\n\nSo your solution would become:\n\n``` ruby\n!!yield(e) && a\n```\n. IMHO predict methods should return literal true/false and not nil or some other object, I don't think this is a case where \"duck typing\" is of benefit.\n\nSo your solution would become:\n\n``` ruby\n!!yield(e) && a\n```\n. ",
    "benhamill": "Aaaaaand it's fixed on it's own. So. :smile: \n. Aaaaaand it's fixed on it's own. So. :smile: \n. ",
    "renz45": "Any news on this? I can link to a ref, but a release would be preferable. :)\n. I can try to take a look at a few sometime next week, I'm a bit swamped with all the things right now though. :( Don't rush on my account, I can work around it with the current release.\n. I use it in our new course player over at code school in a very minimal capacity to get around some thread safety issues. The only feature I really wanted from the new release was the ability to turn Hamster hashes back into normal hashes (I like making deep copies with hamster instead of something like marshal).\n\nI have some wip stuff that that I'm working on that makes use of the Hash class a lot. I can try using edge after I finish my internal apis and catch up on my test coverage.\n\nI don't really have any complaints about the api, it would be nice to get around Ruby's hang up when using `[]=` but there really isn't a great way around that. All in all I like the library :) Thanks for the work on it.\n. Nice :D\n\nWe're pretty big on open source, its good stuff.\n. Any news on this? I can link to a ref, but a release would be preferable. :)\n. I can try to take a look at a few sometime next week, I'm a bit swamped with all the things right now though. :( Don't rush on my account, I can work around it with the current release.\n. I use it in our new course player over at code school in a very minimal capacity to get around some thread safety issues. The only feature I really wanted from the new release was the ability to turn Hamster hashes back into normal hashes (I like making deep copies with hamster instead of something like marshal).\n\nI have some wip stuff that that I'm working on that makes use of the Hash class a lot. I can try using edge after I finish my internal apis and catch up on my test coverage.\n\nI don't really have any complaints about the api, it would be nice to get around Ruby's hang up when using `[]=` but there really isn't a great way around that. All in all I like the library :) Thanks for the work on it.\n. Nice :D\n\nWe're pretty big on open source, its good stuff.\n. ",
    "jstoneham": "``` ruby\nrequire 'hamster'\n\n# I wish I could write:\ndef myfn(data)\n  case data[:remaining]\n  when 0; data.merge(g: \"h\", i: \"j\", k: \"l\")\n  else myfn(data.put(:remaining, &:pred))\n  end\nend\n\n# But I have to write:\ndef myfn(data)\n  case data[:remaining]\n  when 0; data.merge(Hamster.hash(g: \"h\", i: \"j\", k: \"l\"))\n  else myfn(data.put(:remaining, &:pred))\n  end\nend\n\n# or:\ndef myfn(data)\n  case data[:remaining]\n  when 0; data.put(:g, \"h\").put(:i, \"j\").put(:k, \"l\")\n  else myfn(data.put(:remaining, &:pred))\n  end\nend\n\noriginal = Hamster.hash(a: \"b\", c: \"d\", e: \"f\", remaining: 5)\nputs myfn(original).inspect\n```\n\nThe real example from my project has a chain of filters that call each other sequentially, where one of them may return the map passed in with keys added, or call the next filter with multiple keys added, and as I've been playing with using Hamster hashes I was disappointed at having to specifically call out Hamster repeatedly whenever I wanted to put multiple keys in a result.\n. Agreed with @plexus .\n. Initial cut, arrived at by experimentation: https://github.com/jstoneham/hamster/commit/f1a9a1645b121299997bd7a0296d460c4e2f9077\n\nNeeds unit tests before submitting PR.\n. After some looking, Ruby's contract is similar, as documented, but the MRI code tells a bit of a different story. Reading the first MRI code I found for this, http://rxr.whitequark.org/mri/source/hash.c?v=1.9.1-p431#1449, it would _seem_ that implementing `#to_hash` would get us there for `mri_hash == hamster_hash`, and we have control over the Hamster `==` implementation.\n. Take a look at https://github.com/jstoneham/hamster/commit/1c5cc47034dbe004297bd1cd8e9390005bbc556e, if you could. Things pass for `Hamster == ::Hash` and `Hamster.eql?(::Hash)` now, and `::Hash == Hamster` passes but not `::Hash.eql?(Hamster)`.\n\nI'm no deep expert on Ruby, but I can't understand why the test is failing - our `eql?` returns `true`, but as it pops back out of Ruby's `eql?`, it now returns `0`. This happens on Ruby 1.9.3, 2.0.0, and 2.1.1. I'm not sure the best way to try to debug through the MRI C code to find out what strangeness could be doing it, because it doesn't seem possible.\n. Thanks for the feedback. I'll try to revisit this soon and get you an updated PR.\n. ``` ruby\nrequire 'hamster'\n\n# I wish I could write:\ndef myfn(data)\n  case data[:remaining]\n  when 0; data.merge(g: \"h\", i: \"j\", k: \"l\")\n  else myfn(data.put(:remaining, &:pred))\n  end\nend\n\n# But I have to write:\ndef myfn(data)\n  case data[:remaining]\n  when 0; data.merge(Hamster.hash(g: \"h\", i: \"j\", k: \"l\"))\n  else myfn(data.put(:remaining, &:pred))\n  end\nend\n\n# or:\ndef myfn(data)\n  case data[:remaining]\n  when 0; data.put(:g, \"h\").put(:i, \"j\").put(:k, \"l\")\n  else myfn(data.put(:remaining, &:pred))\n  end\nend\n\noriginal = Hamster.hash(a: \"b\", c: \"d\", e: \"f\", remaining: 5)\nputs myfn(original).inspect\n```\n\nThe real example from my project has a chain of filters that call each other sequentially, where one of them may return the map passed in with keys added, or call the next filter with multiple keys added, and as I've been playing with using Hamster hashes I was disappointed at having to specifically call out Hamster repeatedly whenever I wanted to put multiple keys in a result.\n. Agreed with @plexus .\n. Initial cut, arrived at by experimentation: https://github.com/jstoneham/hamster/commit/f1a9a1645b121299997bd7a0296d460c4e2f9077\n\nNeeds unit tests before submitting PR.\n. After some looking, Ruby's contract is similar, as documented, but the MRI code tells a bit of a different story. Reading the first MRI code I found for this, http://rxr.whitequark.org/mri/source/hash.c?v=1.9.1-p431#1449, it would _seem_ that implementing `#to_hash` would get us there for `mri_hash == hamster_hash`, and we have control over the Hamster `==` implementation.\n. Take a look at https://github.com/jstoneham/hamster/commit/1c5cc47034dbe004297bd1cd8e9390005bbc556e, if you could. Things pass for `Hamster == ::Hash` and `Hamster.eql?(::Hash)` now, and `::Hash == Hamster` passes but not `::Hash.eql?(Hamster)`.\n\nI'm no deep expert on Ruby, but I can't understand why the test is failing - our `eql?` returns `true`, but as it pops back out of Ruby's `eql?`, it now returns `0`. This happens on Ruby 1.9.3, 2.0.0, and 2.1.1. I'm not sure the best way to try to debug through the MRI C code to find out what strangeness could be doing it, because it doesn't seem possible.\n. Thanks for the feedback. I'll try to revisit this soon and get you an updated PR.\n. ",
    "ryantm": "A copy of the license is also in the README.md file.\n. @krainboltgreene thank you for the comments. I made those changes and I changed the double quotes to single quotes.\n. oh, I'll change it.\n\nRyan\n\nOn Tue, Jul 15, 2014 at 7:15 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Haha, we actually prefer double quotes, but I'll merge it all the same.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/107#issuecomment-49116263.\n. I still got your first comment via email. Here it is:\n\n> While you have a good point, this problem is not generally solvable in a language which features mutable objects. Please also note that if you destructively modify the values stored in a Hash, even making a defensive copy of the Hash does not help. So I feel that this problem is not really related to the README's advice that defensive copies are not needed.\n. A copy of the license is also in the README.md file.\n. @krainboltgreene thank you for the comments. I made those changes and I changed the double quotes to single quotes.\n. oh, I'll change it.\n\nRyan\n\nOn Tue, Jul 15, 2014 at 7:15 PM, Kurtis Rainbolt-Greene <\nnotifications@github.com> wrote:\n\n> Haha, we actually prefer double quotes, but I'll merge it all the same.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/107#issuecomment-49116263.\n. I still got your first comment via email. Here it is:\n\n> While you have a good point, this problem is not generally solvable in a language which features mutable objects. Please also note that if you destructively modify the values stored in a Hash, even making a defensive copy of the Hash does not help. So I feel that this problem is not really related to the README's advice that defensive copies are not needed.\n. ",
    "dzjuck": "Should we at first add JRuby and Rubinius support to current implementation? See two tasks here\n- Make all specs green for JRuby and Rubinius\n- Add JRuby and Rubinius to Travis\n\nI launched current specs for JRuby and Rubinius. For Rubinius all are green. For JRuby all specs except one are green. Ready to fix this one red.\n\nThank you.\n. I just noticed JRuby-1.7.20 has already released and works fine with original spec. Pull request does not make sense.\n. It's great news. I spent 10 days trying to find root of problem.\n. @alexdowad sure, give me few hours, I will back to my laptop and will send you result\n. attempted_race_fix works correct with JRuby, both 1.7 and 9000\n. Should we at first add JRuby and Rubinius support to current implementation? See two tasks here\n- Make all specs green for JRuby and Rubinius\n- Add JRuby and Rubinius to Travis\n\nI launched current specs for JRuby and Rubinius. For Rubinius all are green. For JRuby all specs except one are green. Ready to fix this one red.\n\nThank you.\n. I just noticed JRuby-1.7.20 has already released and works fine with original spec. Pull request does not make sense.\n. It's great news. I spent 10 days trying to find root of problem.\n. @alexdowad sure, give me few hours, I will back to my laptop and will send you result\n. attempted_race_fix works correct with JRuby, both 1.7 and 9000\n. ",
    "dubek": "I think it's ready.\n. Related: why do you use `Forwardable` (as in `def_delegator :self, :size, :length`) instead of a simple Ruby alias (`alias length size`)?\n. OK. Note that using `Forwardable` is about 40% slower (from my measurements). I also see that the standard Ruby library (see set.rb) uses alias. Maybe we can use it for our \"final\" classes like Hash?\n. I don't really have a strong opinion - I just ran into this library for the first time today (but I really like it!).\n\nI'm now working on a small performance improvement from #136 . After I'm done with that, I'll take a look at clearing the Hamster::Hash interface (remove the unused aliases as suggested here and converting to use pure `alias` instead of `def_delegator`). Are you waiting with a 1.0 release for these interface changes?\n. I'd go for `#add` and alias `#<<` . Note that plain Ruby Array and Set both support `#<<` which is nice (Ruby Array doesn't have `#add`).\n. And we'll have to consider if we want it in `Hamster::Hash` too:\n\n```\nHamster::Hash[\"a\" => 1].add([\"b\", 2])\n# => Hamster::Hash[\"a\" => 1, \"b\" => 2]\n```\n\nFeels weird to me. But I read that's the behaviour of Clojure's `conj`.\n. I'd stay with `#first` which is very Ruby-ish; but for List you probably want `#head` and `#tail` (car and cdr ??).\n\nIf you want to keep the requirement for efficient addition (O(1)), then indeed `#<<` is not a good choice (because this method name hints at \"put at end\" for ordered collections). If so, maybe `#conj` is indeed the better choice.\n\nI guess this will allow to write code like this for any type of `empty_collection`:\n\n```\nmy_enumerable_obj.reduce(empty_collection) { |c, e| c.conj(e) }\n```\n\nI'm not entirely convinced this generality is needed at all... Can you give an example usage (possible from Clojure)?\n. Cool.\n. I think `#add` means \"add one element\" and therefore cannot be an alias to `Hash#merge` (which means \"add all the elements in `other` to `self`\"; and `other` must be a collection, usually a Hash but maybe also Enumerable of pairs).\n. I prefer ruby's alias.\n On Nov 21, 2014 1:17 PM, \"Alex Dowad\" notifications@github.com wrote:\n\n> Which option do you prefer? @dubek https://github.com/dubek, do you\n> have any input?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64013472.\n. Added examples for `Hamster::Set` in ceece15 .\n. Added examples for `Hamster::Vector` in b73230b01c70c33d433c1ff6a793a408b797a482 .\n. Added examples for `Hamster::Hash` in cf0612c1e2ce8d82d7fd43ac02ed756eee45fa02 .\n. Added examples for `Hamster::SortedSet` in 9751a1aa949ad7634cabbfa3d5f327ace2d2096c .\n. Added examples for `Hamster::Deque` in 4162a09b94ce9dc2497ca05f29810617b3dfbd84 .\n. I added examples for `List#merge` and `List#merge_by`.\n. One more possible optimization: \n\n[ ] A quick benchmark shows that `Vector#shift` is 1.2x - 1.8x faster than `Vector#drop(1)`, although semantically they are identical. Need to investigate for more params (are two `shift`s faster than `drop(2)`?).\n. Similar one: `SortedSet#drop` is _way_ slower than `SortedSet#above`, especially for large sorted sets. Consider something like (not tested!):\n\n```\ndef drop(n)\n  # verify n is positive, less than size, etc.\n  above(at(n - 1))\nend\n```\n\nand maybe similar for `SortedSet#take` (implement in terms of `#below`). If no one beats it to me, I might get a chance to try/implement tomorrow.\n. @alexdowad Looks good. I think you should return `clear` instead of `EmptySortedSet` (in `SortedSet#drop` and `SortedSet#take`) so the original `@comparator` is kept. And probably `SortedSet#clear` should be modified to handle cases when `@comparator` is set or not (like `Hash#clear`). Or am I missing something?\n\nAside: Might be a matter of taste, but I think we would have enjoyed a way to add assertions or invariants to our code (checked during testing). So after each call, verify for example that `@trie.size` equals to sum of all children and entries; and that `@comparator / @default_proc` is kept, and so on. Not sure if there's a clean way to do it in Ruby; there's this: https://github.com/jorgemanrubia/solid_assert but it's a bit old and I'm not sure about performance implications (ideally I'd add such an assert on each loop of Trie operations, for example). If you think it's valuable maybe we should have an open issue to look into it.\n. Sorry, still buggy (unless I'm missing something) on 435e4ca217c14eea9d80c02cffc98d20077a0bd6 :\n\n```\n2.1.3 :001 > sorted_set = Hamster::SortedSet.new([4,5,6]) { |a| -a }\n => Hamster::SortedSet[6, 5, 4] \n2.1.3 :002 > sorted_set.drop(3).add(5).add(4).add(6)\n => Hamster::SortedSet[4, 5, 6] \n```\n. I think that:\n- `#drop` and `#take` should return `clear` if they're about to return an empty SortedSet\n- `#clear` should act like `Hash#clear`: if there's a `@comparator` then alloc an empty node with it, otherwise return `self.class.empty`.\n. One more possible optimization:\n\nFor SortedSet it should be faster to determine `#subset?`, `#disjoint?`, `#intersect` and so on by walking on the two SortedSets together, in order. So for example for `#instersect` I can start by walking on the higher between the two sets' minimums, and stop walking when I reach the lower of the two sets' maximums (where walking means - advance the cursor who is pointing at the lower value; if there's a match between the two cursors, put the value in the intersection result). So if we have two SortedSets of sizes N and M (N > M) then `#intersect` should be O(lgN + lgM + M), whereas today it is O(M \\* lnN).\n\nThe problem with this suggested optimization is that it is only valid if the two SortedSets have the same order (comparator). Anyway we can check that?\n. Whoops, my last comment is regarding `#subset?`, not `#intersect`. I look at `#intersect` and it is implemented as AVL `keep_only` which performs the divide-and-conquer. Sorry.\n. We need C++ templates ;-)\n\nI found that `SortedSet#filter` can be made 3x faster with `@node.bulk_delete` ; committing it soon.\n. Pushed to master: fix for the `SortedSet#drop` and `#take` when clearing the collection, and optimization for `SortedSet#filter`.\n. I checked MRI source code. The `Array#uniq` algorithm is basically:\n1. Build empty helper hash\n2. Iterate over the array elements: For each element: If it already exists in the hash, skip it; otherwise, add it to hash (element => element).\n3. Take the helper hash values\n\nHowever, in Ruby 2.1.0 they don't check \"if it already exists in the hash\". So the _last_ element prevails. This was fixed in Ruby 2.1.1.\n. FYI: here's the Ruby 2.1.0 bug report: https://bugs.ruby-lang.org/issues/9340\n. Regarding `Hamster.from`:\n\nIndeed the idea is to take a big nested Hash \"document\" (like [Github Gists API response](https://developer.github.com/v3/gists/#response)) and to be able to process it with Hamster tools (keep it immutable).\n\nRegarding `get_in` and `update_in`:\n\nActually, since we support `h[key]` on `Hamster::Hash`, I now think that `#get_in` is not really needed because you can have:\n\n```\nnested2[\"a\"][\"b\"][\"d\"]\n# => 6\n```\n\n(identical to normal Ruby hash usage)\n\nHowever, for storing this doesn't work, of course; that's why `#update_in` is suggested; and maybe it should support Vector access (by index) too, so one can have \n\n```\nnested.update_in(\"a\", \"b, \"c\", 2) { |v| v + 1 }\n```\n\nWhich is the immutable parallel of the in-place Ruby code:\n\n```\nh[\"a\"][\"b\"][\"c\"][2] += 1\n```\n. Hamster doesn't support `[]=` on Hash (and Vector) because there's no way to return the new modified Hash (or Vector) from this method (I guess it's a special method in Ruby that returns the right-hand-side value and not the method return value). So:\n\n```\nh = Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => Hamster::Vector[3, 4, 5]]]]\nh[\"a\"][\"b\"][\"c\"][2]\n# => 5 \nh[\"a\"][\"b\"][\"c\"][2] = 8\n# NoMethodError: undefined method `[]=' for Hamster::Vector[3, 4, 5]:Hamster::Vector\n```\n. Code is in master (see #150). We now support `Hamster.from`, `Hash#update_in` and `Vector#update_in`.\n. I'll try to implement your suggestion.\n. And instead of sorting, don't you think it's better to hold 32 buckets (arrays) and push each element to the relevant bucket according to it's `hash >> sig & 31` ?\n. Just to update that I'm trying these approaches and so far I only managed to make it _worse_. Probably there's a bug in my implementation attempts; still working on it from time to time.\n. Pushed: https://github.com/dubek/hamster/blob/trie_bulk_put/lib/hamster/trie.rb\n\nOf course it's a WIP, still need to refactor. Look at bulk_put and bulk_put! .\n\nI'm measuring this (run this in `master` and in my branch):\n\n```\nrequire \"benchmark/ips\"\nrequire \"hamster/set\"\nset_size = 1000\nset_a = Hamster::Set.new((1..set_size).to_a)\nset_b = Hamster::Set.new(((set_size/2)..(set_size*3/2)).to_a)\nBenchmark.ips do |b|\n  b.report \"union(N=#{set_size})\" do\n    set_a.union(set_b)\n  end\nend\n```\n. OK, let me sort this out, clean up, rebase and squash.\n. @alexdowad OK that's enough. We said that `bulk_put` was a bit big (bulky?) and might want to split it to some internal methods; but I guess for now it's OK.\n\nThanks.\n. Thanks. Any idea how to handle a `Vector` in that nested structure? Say `hash.put_in(\"a\", 6, \"b\")` where `6` is the index to a `Vector` containing another `Hash` in it's 7th element (index 6)?\n. And there's an assumption that if a key doesn't exist create it with `EmptyHash`. Do you think it's reasonable to leave it this way?\n\nAlso: maybe extract `#put_in` to a `NestedOperations` module and include it both classes?\n. OK. Note the the `Vector` setter is called `set`, not `put`. So we'll need some special code to handle those. Also, should I call the method `Vector#put_in` or `Vector#set_in` ?\n. On the other thread we were talking about _minimizing_ the interface, so adding more names (=alias) doesn't seem like a good solution.\n\nRuby Array only supports setting elements with `[]=` which we can't use. Ruby Hash supports `[]=` and `store(key, value)`. So I guess if we want to stick with one name _and_ be somewhat compatible to the Ruby built-in classes, we should pick `store` and `store_in` for both Hamster::Hash and Hamster::Vector (though I agree that `#set` feels \"easier\" to me somehow).\n. Or we can leave everything as-is (`Hash#put` and `Vector#set`) and call out nested method `update_in` (in both) to celebrate it's Clojure origin :-)\n. Rebased, changed to `#update_in` and added implementation for `Vector` too.\n. Fixed `#from` to build one `Hamster::Hash`. force-pushed.\n. Good. So with my implementation of:\n\n```\ndef store(key, value)\n  put(key, value)\nend\n```\n\nthen `store` mandates the 2 arguments (without block) and put allows either 2 arguments or 1 argument and a block.\n. Your suggested `Set#filter` and `Hash#filter` implementations are indeed faster than what we have today: https://gist.github.com/dubek/f5c4e68febe2a7c80e77 (old_filter in both cases refers to the current implementation which performs `@trie.delete` on each element that doesn't pass the filter).\n\nI'll add this commit too in a few minutes.\n. Right now I have some free time, but I'm afraid soon it'll be over and I'll just have a few hours from time to time... So don't worry too much about it. Also I really appreciate your comments on the code I submit.\n. Why not follow the scheme used by other popular gems:\n- https://github.com/sinatra/sinatra\n- https://github.com/rack/rack\n- https://github.com/bundler/bundler\n\nCan you give examples of repos using the {name}.gem scheme?\n. (and add to the checklist: modify the github path in `hamster.gemspec`)\n. OK I don't mind either way.\n. I'm against changing the **repo** name. There are already 7 non-related github repos called \"hamster\". I don't see any reason we should clear this already-crowded space.\n\nAs for the **org** name, I'm indifferent: hamstergem / libhamster / ruby-immutable -- all work OK for me as the github org name. So I have no problem leaving it as-is (which is the least work).\n. Sorry about that; I should have seen it before pushing.\n. I'm considering calling `#fill` with `nil` for all the \"missing\" indexes, if needed. I'll try it out.\n. BTW the reason we didn't find this bug is that in `vector/get_spec.rb` we have `if rand(1) == 0` but `rand(1)` always returns 0; it should be `rand(2)`. Once you change that, you start to get IndexError exceptions...\n. Commit 00fc44189f99993ac131cc19351ec23cd23fc589 on master allows to set element past the end of the vector:\n\n``` ruby\nHamster::Vector[1,2,3].set(6, \"foo\")\n# => Hamster::Vector[1, 2, 3, nil, nil, nil, \"foo\"]\n```\n. One clarification: the immutable_struct gem offers a Struct that you can never change (it has no setters; can be achieved in plain Ruby with `#freeze` but you'll have to remember to call it). Hamster, on the other hand, gives you set/update/delete methods on the data structures, but those do not modify the original variable, but return a copy of the data structure with the requested modification (and it tries to make the copy as efficient as possible).\n. Ruby has `Enumerable#find_index` which accepts either a value or a block and returns the _first_ index that matches (either equal to the value or the block evaluates to non-false) - http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-find_index\n\nSo if we want to be \"similar\" to Enumerable, maybe that method (which in option B you can `indices`) can be called `find_indices` ... Not sure what it means in terms of backward-compatibility and how much we need to care.\n. One more idea: maybe we can remove this method altogether because users can\nuse: mylist.with_index.select { |e,i| ... }   ?\nOn Dec 27, 2014 12:33 AM, \"Alex Dowad\" notifications@github.com wrote:\n\n> Anyone else want to make your voice heard, before the axe drops? @dubek\n> https://github.com/dubek? Others?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/164#issuecomment-68169515.\n. As for the method name - I guess `indices` is OK because it is similar to Ruby Array's `index` (which is an alias to `find_index`). (Enumerable doesn't have `index`)\n\nHowever - I'm still in favor of dropping this method (sorry). It not really lazy because it has to scan the entire list anyway (or am I missing something?). And it can be implemented in terms of other methods like this:\n\n``` ruby\nHamster::List[1,2,3,4,5,6,7,8].each.with_index.select { |e,i| e % 3 == 0 }\n# => [[3, 2], [6, 5]] \n```\n\nwhich (I think) doesn't incur extra allocations of the entire list (but returns Array and not Hamster::List ...).\n\nYou have the last word (someone has to cut it :-).\n. @alexdowad thanks for clarifying.\n. @xbeta: This is intended. To quote from the README:\n\n> Hamster collections are immutable. Whenever you modify a Hamster collection, the original is preserved and a modified copy is returned. This makes them inherently thread-safe and shareable. At the same time, they remain CPU and memory-efficient by sharing between copies. \n\nThis is true for all Hamster's data structures: `Hamster::Hash`, `Hamster::Vector`, and so on. So a `#push` or a `#set` on a `Hamster::Vector` instance will return a new one, unlike Ruby's built-in `Array` which will modify the instance in-place.\n. Although JSON and Yaml modules add `Array#to_json` and `Hash#to_yaml` and so on, I prefer not to go this way (that is, not to add method to basic Ruby objects). \n\nI'd rather stay with `Hamster::Vector#to_a` as mentioned above. If needed, add `Hamster::Hash#to_h` and `Hamster::Set#to_set` (or maybe `#to_ruby_set` ?)  as needed to convert to regular Ruby objects.\n. Yes, you're right. #to_mutable is a good idea.\n\nI wish we had a better name, though. Haven't looked at the equivalent JS\nproject for ideas yet.\nOn Mar 17, 2015 3:48 AM, \"Elben Shira\" notifications@github.com wrote:\n\n> Would you still consider the class method Hamster.to_mutable to be a good\n> idea? Three good points I see about this are:\n> 1. Symmetry with Hamster.from.\n> 2. Accepts any Hamster object.\n> 3. The instance method way (to_set/to_h/to_a) can be implemented by\n>    calling Hamster.to_mutable.\n> \n> Otherwise, I can implement the to_x methods individually in each class.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82025560.\n. I agree with @alexdowad - `#to_ruby` which means \"convert to the equivalent built-in Ruby data structure\". Then users can have `my_hamster_data_var.to_ruby.to_json` if they wish (or `to_yaml` or whatever).\n. Another option is to have two implementations:\n1. If the `concurrent` gem is installed, use it (`require 'concurrent/atomics'` and use the `Atomic` class).\n2. Otherwise, build a naive (=slow) implementation using a Mutex for any read/write operation on @atomic (which can then be a normal fixnum).\n\nThis way hamster works out-of-the-box without other dependencies, and if you need List to be faster then you just `gem install concurrent`.\n. I'm good with adding dependency on `concurrent` (instead of `atomic`), and in our code adding `require \"concurrent/atomics\"`.\n. (It was @roryokane's suggestion, actually.)\n. Nice.\n\nBTW (not related to the concurrent gem): it might be clearer to extract those `if @atomic.get != 2` to something like:\n\n``` ruby\ndef head\n  realize unless realized?\n  @head\nend\n\nprivate\n\ndef realized?\n  @atomic.get == 2\nend\n```\n\nand so on for the other \"states\" of the `@atomic` var.\n\nI might pursue it in a separate PR for review.\n. @krainboltgreene I think you're confusing right and left sides of `===`. Basically you have a collection of _patterns_, so an equivalent example (without Earhart) would be:\n\n```\n2.2.1 :004 > myset = Hamster::Set.new([/a/, /b/, /c/])\n => Hamster::Set[/a/, /b/, /c/] \n2.2.1 :005 > myset.grep(\"aaa\")\n => Hamster::Set[] \n```\n\nwhich is fine; same behaviour for plain Ruby arrays:\n\n```\n2.2.1 :006 > myarray = [/a/, /b/, /c/]\n => [/a/, /b/, /c/] \n2.2.1 :007 > myarray.grep(\"aaa\")\n => [] \n```\n\nI don't really know your application but maybe you should resort to something along the lines of:\n\n```\nchosen_route = collection.find { |route| route === query }\n```\n\n(off-topic: for an interesting implementation of an efficient HTTP request router using prefix trees see https://github.com/julienschmidt/httprouter#how-does-it-work )\n. As a side note, in Ruby 2.x you can turn any enumerator to lazy, so:\n\n```\nmyvector = Hamster::Vector.new([\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"])\n# => Hamster::Vector[\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"] \n\nmyvector.each.lazy.select { |x| puts \"WORKING ON #{x}\"; x.match(/b/) }\n# => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator: Hamster::Vector[\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"]:each>>:select> \n\nmyvector.each.lazy.select { |x| puts \"WORKING ON #{x}\"; x.match(/b/) }.first\nWORKING ON aaa\nWORKING ON bbb\n# => \"bbb\" \n```\n\nAs opposed to normal iteration without `.lazy`:\n\n```\nmyvector = Hamster::Vector.new([\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"])\n# => Hamster::Vector[\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"] \n\nmyvector.select { |x| puts \"WORKING ON #{x}\"; x.match(/b/) }.first\nWORKING ON aaa\nWORKING ON bbb\nWORKING ON ccc\nWORKING ON bb\nWORKING ON d\n# => \"bbb\" \n```\n\nI haven't investigated effects on performance.\n. Generally I'm not against your suggestion, but these \"early `return`s\" are very common throughout the Hamster code, and in some cases make the code easier to read IMO. @krainboltgreene did you intend to modify all the similar occurrences of `return ... unless ...`?\n. @alexdowad I believe adding `List.new` will make things even more difficult to understand:\n\n``` ruby\n$ irb -Ilib -rhamster\n2.2.1 :001 > my_list = Hamster::List[1,2,3]    # Or, per suggestion:   Hamster::List.new(1,2,3)\n => Hamster::List[1, 2, 3] \n2.2.1 :002 > my_list.class\n => Hamster::Cons \n```\n. OK sure. The README should be fixed though (line 200) to square brackets.\n. @alexdowad I believe the same issue (and solution) are in `Splitter::Left` and `Splitter::Right` (in the same file).\n. In a standalone benchmark it looks about the same:\n\n``` ruby\nrequire \"benchmark/ips\"\n\nclass A\n  def initialize(m)\n    @m = m\n  end\n\n  def set_nil\n    @m = nil\n  end\n\n  def remove_var\n    remove_instance_variable :@m\n  end\nend\n\nBenchmark.ips do |b|\n  b.report(\"set_nil\") { A.new([]).set_nil }\n  b.report(\"remove_var\") { A.new([]).remove_var }\n  b.compare!\nend\n```\n\nResults:\n\n```\n$ ruby -v remove_inst_bench.rb  \nruby 2.2.1p85 (2015-02-26 revision 49769) [x86_64-linux]\nCalculating -------------------------------------\n             set_nil    86.017k i/100ms\n          remove_var    78.048k i/100ms\n-------------------------------------------------\n             set_nil      2.703M (\u00b1 1.8%) i/s -     13.591M\n          remove_var      2.561M (\u00b1 3.6%) i/s -     12.800M\n\nComparison:\n             set_nil:  2703019.0 i/s\n          remove_var:  2561488.4 i/s - 1.06x slower\n```\n\nI actually prefer the `@mutex = nil` version...\n. Good catch!\n\nIndeed modifying the arity condition in https://github.com/hamstergem/hamster/blob/master/lib/hamster/sorted_set.rb#L103 to:\n\n```\nif block.arity <= 1\n```\n\nfixes the problem (both with the `&:name` syntax and the weird `|*a|` block).\n\nI'm not sure about the promises about the number of times the block is called.\n. @no-reply Interesting. I remember reading (can't find the source) that actually adding a `&blk` parameter to a method slows things down, because Ruby converts the block into a Proc object (which is later `#call`-ed).\n\nSo, supposedly, the fastest would be to eliminate `&blk` parameter and use `yield` (and maybe `block_given?` to check if we have a block at all. Of course this need benchmarking and might change in different Rubies. Here's a simple benchmark (which probably means wrong benchmark :-) ) on my machine:\n\n``` ruby\nrequire 'benchmark/ips'\n\ndef f1(&blk)\n  blk.call\nend\n\ndef f2(&blk)\n  yield\nend\n\ndef f3\n  yield\nend\n\ndef f4\n  yield if block_given?\nend\n\nBenchmark.ips do |b|\n  b.report(\"blk.call\") { f1 { 100 * 100 } }\n  b.report(\"blk and yield\") { f2 { 100 * 100 } }\n  b.report(\"yield\") { f3 { 100 * 100 } }\n  b.report(\"block_given? and yield (with block)\") { f4 { 100 * 100 } }\n  b.report(\"block_given? and yield (without block)\") { f4 }\nend\n```\n\nResults:\n\n```\n            blk.call      1.779M (\u00b1 2.5%) i/s -      8.955M\n       blk and yield      2.215M (\u00b1 3.0%) i/s -     11.081M\n               yield      6.639M (\u00b1 3.2%) i/s -     33.206M\nblock_given? and yield (with block)\n                          4.570M (\u00b1 2.4%) i/s -     22.854M\nblock_given? and yield (without block)\n                          6.677M (\u00b1 2.4%) i/s -     33.451M\n```\n\nSo removing the `&blk` parameters improved from 2.2M i/s to 6.6M i/s. Get rid of those `&blk` ! :-)\n. Oops just saw I'm repeating the benchmark already above on this thread.... Too late I guess. Sorry.\n. Nowadays `#update_in` is part of the `Associable` module:\n\n``` ruby\n  # Including `Associable` in your container class gives it an `update_in`\n  # method.\n  #\n  # To mix in `Associable`, your class must implement two methods:\n  #\n  # * `fetch(index, default = (missing_default = true))`\n  # * `put(index, item = yield(get(index)))`\n  #\n  # See {Vector#fetch}, {Vector#put}, {Hash#fetch}, and {Hash#put} for examples.\n```\n\nSo for `List` we can implement `#fetch` (in terms of `#at`) and probably make some not-really-efficient `#put`.\n\nAs for `Set` and `SortedSet`, I'm not sure what these operations (fetch/put) mean. What is the index? What is the item's value?\n. Indeed there's already `SortedSet#fetch(index, default = (missing_default = true))` so this side is OK. \n\nAs for `#put`, it'll be something like `#delete` and then `#add`. Of course it's very weird because in the SortedSet `[\"a\", \"b\", \"c\", \"d\"]`    if your perform `s.put(2, \"z\")` you'll get `[\"a\", \"b\", \"d\", \"z\"]`, so a subsequent `s.fetch(2)` will return `\"d\"`...\n. Thanks @xaviershay for the contribution. I prefer the new suggested code in this PR.\n\nI'm not sure about undef-ing monkey-patched methods; I think the subprocess is a safer approach (in Lua you can have several \"global\" environments and shift between them...)\n. `.new` on non-classes is confusing. Also it might conflict with the existing `Cons#initialize` since `Cons` includes `List`? \n. Thanks for noticing this.\n\nAnother option is to completely remove the per-class `#to_ruby` methods. To look at another example, I really prefer `JSON.generate(obj)` instead of `obj.to_json`; that also allows having `JSON.pretty_generate(obj)`, `MessagePack.pack(obj)` and so on without further polluting the classes interface.\n\nTo contradict myself, the current `Hamster.to_ruby` has a code smell in which we switch over the argument's class, which is something that should classically be done with polymorphism. So another approach is that each class will implement its own `#to_ruby`, calling `.to_ruby` on each collection element (hmm, but what about plain Ruby classes?).\n. But if an object doesn't `respond_to?(:to_ruby)`, you'll need to implement the `when Hash ... when Array ...` etc. You _don't_ want that code duplicated in `Hamster::Hash#to_ruby` and `Hamster::Vector#to_ruby` and so on.\n\nMaybe the code smell I was referring to is unavoidable, because we want to support both the Hamster classes and the PORO collections.\n. I'm OK with it. The docs for `Hamster.to_ruby` should be updated, not sure if anyone tackled it already.\n. @Bill 's approach looks good to me. It should be in some \"generic\" file similar to `hamster/nested.rb` (but not there). At first step the current implementation of `Hash#update_in` and `Vector#update_in` can simply call the new suggested method. At a later stage we can deprecate and then erase them in favour of using only `Hamster.update_in(myhash, \"a\", \"b\", \"c\") { |val| val + 5 }` .\n\nI think in the past we had `Vector#put` and we removed it as part of the big clean-up prior to releasing 1.0... oops!\n. Hmmm, I think about it again. In Ruby the methods are \"duplicated\" for each class. So you have `Array#sort` and `Hash#sort` whose implementations are probably very similar - yet Ruby doesn't define a global `sort(my_data_structure)` function...\n\nSo maybe we should improve code reuse but leave the interface as `Hash#update_in` and `Vector#update_in` ?\n\n(sorry for contradicting myself)\n. Nice post. Your new module name is really confusing...\n\nBesides supporting `[:key, :expected_value]` and `\"*\"` (kleene star) you might want to support procs/lambdas. So the kleene star can be implemented by:\n\n```\nHamstar.update_having(x, ->{true}, :name)\n```\n\nand the key-expected value can be implemented as:\n\n```\nHamstar.update_having(x, ->(k,v){ v[:name] == \"Pat\" }, :name)\n```\n\nand you maybe can extend to stuff like \"update having an even-index\" etc.\n\n```\nHamstar.update_having(x, ->(k,v){ k.even? }, :name)\n```\n\n(I guess this discussion should move to the Hamstar repo...)\n. :+1: for releasing `1.1.0` with the added functionality.\n. Who has the gem release button? @krainboltgreene ? Can you release a 1.1.0.pre.rc1 ?\n. So `Hamster.from` and `Hamster::Whatever#to_ruby` are available in the hamster 2.0.0 gem released yesterday.\n\nClosing.\n. This approach looks good to me.\n. Since Hamster should only support converting the built-in Ruby data structures, I think 1 is OK - we should be able to cover them all, if we haven't already (up to new additions to the stdlib in the next Ruby version).\n. Thanks @Bill - it looks much better now. Two comments: \n1. in both READMEs - replace the `vector.set` example with `vector.put` (which is now the \"correct\" method).\n2. replace `spec/lib/hamster/vector/set_spec.rb` with `#put` specs, possibly leave a small `#set` spec until we decide to remove that alias. Also other specs that may use `Vector#set`. Possibly comment out the `set` alias and see what breaks.\n\nI'll probably have time tomorrow to fix those two things.\n\nSmall suggestion for the future - separate such changes to two commits: first - introduce `Vector#put` (with its relevant documentation and spec changes); second - introduce `Associable` which relies on `Vector#put`.\n. I pushed those small fixes in e7ad27709bcc22d6c5c29bb68de435a1e43f42b1 .\n. Would the following code work for these kind of scenarios?\n\n``` ruby\nhash = Hamster.from(some_calculation)\nhash = hash.put(:foo, :bar) if condition1\nhash = hash.put(:xyz, 123) if condition2\n```\n\nFor example, if `condition1` is false, the entire assignment `hash = hash.put(:foo, :bar)` is not executed and the variable `hash` keeps its original value.\n. Thanks you for the contribution!\n\nJust so everyone knows:\n- Current hamster code (before this PR) works with concurrent-ruby 0.8.0 but not with 1.0.0 (they removed the older Concurrent::Atomic class in 1.0.0).\n- The new hasmter code (as suggested in this PR) works with concurrent-ruby 1.0.0 but not with 0.8.0.\n\nI'm OK with this PR but we'll force dependency upgrade on our users (much in the same sense that now we enforce \"don't upgrade\"...).\n. Added `Hash#fetch_values` in ed887846f89f56f444ca2107c628372fc83f0070\n. Added `Hash#to_proc` in 7433f92a0943d64c2dd367c4c597f8c7016dbc68\n. Thanks to @HParker who added `Hash#dig` in 500928ea887793960977a000ae9a937197e1cbc1\n. Hash `>=` `>` `<` `<=` added in 8a70322c1603f58d9c5c14c254ef49ac20f8e950\n. Added `Hamster::Enumerable#grep_v` in  ba4a801b5e5f29d661fd6e2a9c753c1f3df453c5\n. Thanks to @HParker who added `Vector#dig` in 42fb988cc08171231165679204de3ff120316cba\n. Fixed by  @xaviershay in #218 .\n. The downcase should verify that the filtered results indeed are processed by the block (when given) - similar to #map behavior.\n. Yes, you're right. IMO there's no need to repeat all the scenarios again _with_ the block, maybe just verify that:\n\n```\nHamster::Set[\"A\", 2, \"C\"].grep(String) { |x| x.downcase }\n#=> Hamster::Set[\"a\", \"c\"]\n```\n. @alexdowad why was this closed? AFAIK the issue is still there:\n\n```\n$ rspec spec/lib/hamster/set/grep_spec.rb \nI, [2015-12-07T09:04:47.020231 #23152]  INFO -- : Not reporting to Code Climate because ENV['CODECLIMATE_REPO_TOKEN'] is not set.\nNo examples found.\n\nFinished in 0.00018 seconds (files took 1.5 seconds to load)\n0 examples, 0 failures\n\nTop 0 slowest examples (0 seconds, 0.0% of total time):\n```\n. @xaviershay Can you please rebase your branch on top of the current `master`, and add a verification that `#grep` processes results with the given block (as discussed above)?\n. Fixed in ae7e0b24c5dea0b0bfecb2d867f65b3e4bef7d36 with better specs.\n. Does it make sense to add dig to the Associable module we already have?\nOn Dec 7, 2015 00:56, \"Alex Dowad\" notifications@github.com wrote:\n\n> I think this is ready to merge. Yes, it would be nice to unify the code\n> between Hash and Vector, but I think that can be done in a separate PR.\n> @dubek https://github.com/dubek, would you like to merge?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/216#issuecomment-162418117.\n. Merged manually ( 500928ea887793960977a000ae9a937197e1cbc1 ).\n\n@HParker thanks a lot for your contribution to Hamster (and the explanations about Ruby 2.3 shenanigans)! If you'd like to continue working on it, I suggest (in a new PR):\n1. writing specs for `Vector#dig`\n2. implementing `#dig` in the `Associable` module and removing it from `Hamster::Hash`.\n. Besides my small code comments on the documentation, I just noticed this at the top of `associable.rb`:\n\n```\n   # To mix in `Associable`, your class must implement two methods:\n   #\n   # * `fetch(index, default = (missing_default = true))`\n   # * `put(index, item = yield(get(index)))`\n   #\n```\n\nHowever the new `#dig` method uses `[]` and not `fetch`. Can we change to `fetch` without breaking or making it over-complex?\n. Thanks for the quick fixes.\n\nI just thought about the case of Hash with default proc. In Ruby 2.3.0-preview1 it behaves as follows:\n\n```\n2.3.0-preview1 :001 > h = Hash.new { |h,k| \"#{k}-default-val\" }\n => {} \n2.3.0-preview1 :002 > h[:a]\n => \"a-default-val\" \n2.3.0-preview1 :003 > h.fetch(:a)\nKeyError: key not found: :a\n    from (irb):3:in `fetch'\n    from (irb):3\n    from /home/dmurik/.rvm/rubies/ruby-2.3.0-preview1/bin/irb:11:in `<main>'\n2.3.0-preview1 :004 > h.fetch(:a, nil)\n => nil \n2.3.0-preview1 :005 > h.dig(:a)\n => \"a-default-val\" \n```\n\n@HParker - Can you please check where the suggest `#dig` works similarly? Or will we need to resort to using `[]` as you originally suggested?\n\nIn any case we need to make sure the `Hamster::Hash#dig` specs indeed specify these cases (with and without default proc).\n. Yep, I agree. Just use `#get` and add it to the documentation of `Associable` as a required method.\n. Rebased and merged to master manually.\n\nThanks @HParker for dealing with all the back and forth! Great contribution.\n. Merged. Thank you @xaviershay !\n. Of course it'll need to have special YARD directive so it doesn't appear in the API docs.\n\n@xaviershay Your opinion about this suggestion? Any idea if any other library acts in a similar fashion?\n. @no-reply thanks for the contribution! I see you added this on Hamster::Hash. Can a similar method be added to Hamster::Vector ?\n. @guncha If your AST is really a tree, then it shouldn't have cycles... :-)\n. I think it's ready.\n. Related: why do you use `Forwardable` (as in `def_delegator :self, :size, :length`) instead of a simple Ruby alias (`alias length size`)?\n. OK. Note that using `Forwardable` is about 40% slower (from my measurements). I also see that the standard Ruby library (see set.rb) uses alias. Maybe we can use it for our \"final\" classes like Hash?\n. I don't really have a strong opinion - I just ran into this library for the first time today (but I really like it!).\n\nI'm now working on a small performance improvement from #136 . After I'm done with that, I'll take a look at clearing the Hamster::Hash interface (remove the unused aliases as suggested here and converting to use pure `alias` instead of `def_delegator`). Are you waiting with a 1.0 release for these interface changes?\n. I'd go for `#add` and alias `#<<` . Note that plain Ruby Array and Set both support `#<<` which is nice (Ruby Array doesn't have `#add`).\n. And we'll have to consider if we want it in `Hamster::Hash` too:\n\n```\nHamster::Hash[\"a\" => 1].add([\"b\", 2])\n# => Hamster::Hash[\"a\" => 1, \"b\" => 2]\n```\n\nFeels weird to me. But I read that's the behaviour of Clojure's `conj`.\n. I'd stay with `#first` which is very Ruby-ish; but for List you probably want `#head` and `#tail` (car and cdr ??).\n\nIf you want to keep the requirement for efficient addition (O(1)), then indeed `#<<` is not a good choice (because this method name hints at \"put at end\" for ordered collections). If so, maybe `#conj` is indeed the better choice.\n\nI guess this will allow to write code like this for any type of `empty_collection`:\n\n```\nmy_enumerable_obj.reduce(empty_collection) { |c, e| c.conj(e) }\n```\n\nI'm not entirely convinced this generality is needed at all... Can you give an example usage (possible from Clojure)?\n. Cool.\n. I think `#add` means \"add one element\" and therefore cannot be an alias to `Hash#merge` (which means \"add all the elements in `other` to `self`\"; and `other` must be a collection, usually a Hash but maybe also Enumerable of pairs).\n. I prefer ruby's alias.\n On Nov 21, 2014 1:17 PM, \"Alex Dowad\" notifications@github.com wrote:\n\n> Which option do you prefer? @dubek https://github.com/dubek, do you\n> have any input?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/131#issuecomment-64013472.\n. Added examples for `Hamster::Set` in ceece15 .\n. Added examples for `Hamster::Vector` in b73230b01c70c33d433c1ff6a793a408b797a482 .\n. Added examples for `Hamster::Hash` in cf0612c1e2ce8d82d7fd43ac02ed756eee45fa02 .\n. Added examples for `Hamster::SortedSet` in 9751a1aa949ad7634cabbfa3d5f327ace2d2096c .\n. Added examples for `Hamster::Deque` in 4162a09b94ce9dc2497ca05f29810617b3dfbd84 .\n. I added examples for `List#merge` and `List#merge_by`.\n. One more possible optimization: \n\n[ ] A quick benchmark shows that `Vector#shift` is 1.2x - 1.8x faster than `Vector#drop(1)`, although semantically they are identical. Need to investigate for more params (are two `shift`s faster than `drop(2)`?).\n. Similar one: `SortedSet#drop` is _way_ slower than `SortedSet#above`, especially for large sorted sets. Consider something like (not tested!):\n\n```\ndef drop(n)\n  # verify n is positive, less than size, etc.\n  above(at(n - 1))\nend\n```\n\nand maybe similar for `SortedSet#take` (implement in terms of `#below`). If no one beats it to me, I might get a chance to try/implement tomorrow.\n. @alexdowad Looks good. I think you should return `clear` instead of `EmptySortedSet` (in `SortedSet#drop` and `SortedSet#take`) so the original `@comparator` is kept. And probably `SortedSet#clear` should be modified to handle cases when `@comparator` is set or not (like `Hash#clear`). Or am I missing something?\n\nAside: Might be a matter of taste, but I think we would have enjoyed a way to add assertions or invariants to our code (checked during testing). So after each call, verify for example that `@trie.size` equals to sum of all children and entries; and that `@comparator / @default_proc` is kept, and so on. Not sure if there's a clean way to do it in Ruby; there's this: https://github.com/jorgemanrubia/solid_assert but it's a bit old and I'm not sure about performance implications (ideally I'd add such an assert on each loop of Trie operations, for example). If you think it's valuable maybe we should have an open issue to look into it.\n. Sorry, still buggy (unless I'm missing something) on 435e4ca217c14eea9d80c02cffc98d20077a0bd6 :\n\n```\n2.1.3 :001 > sorted_set = Hamster::SortedSet.new([4,5,6]) { |a| -a }\n => Hamster::SortedSet[6, 5, 4] \n2.1.3 :002 > sorted_set.drop(3).add(5).add(4).add(6)\n => Hamster::SortedSet[4, 5, 6] \n```\n. I think that:\n- `#drop` and `#take` should return `clear` if they're about to return an empty SortedSet\n- `#clear` should act like `Hash#clear`: if there's a `@comparator` then alloc an empty node with it, otherwise return `self.class.empty`.\n. One more possible optimization:\n\nFor SortedSet it should be faster to determine `#subset?`, `#disjoint?`, `#intersect` and so on by walking on the two SortedSets together, in order. So for example for `#instersect` I can start by walking on the higher between the two sets' minimums, and stop walking when I reach the lower of the two sets' maximums (where walking means - advance the cursor who is pointing at the lower value; if there's a match between the two cursors, put the value in the intersection result). So if we have two SortedSets of sizes N and M (N > M) then `#intersect` should be O(lgN + lgM + M), whereas today it is O(M \\* lnN).\n\nThe problem with this suggested optimization is that it is only valid if the two SortedSets have the same order (comparator). Anyway we can check that?\n. Whoops, my last comment is regarding `#subset?`, not `#intersect`. I look at `#intersect` and it is implemented as AVL `keep_only` which performs the divide-and-conquer. Sorry.\n. We need C++ templates ;-)\n\nI found that `SortedSet#filter` can be made 3x faster with `@node.bulk_delete` ; committing it soon.\n. Pushed to master: fix for the `SortedSet#drop` and `#take` when clearing the collection, and optimization for `SortedSet#filter`.\n. I checked MRI source code. The `Array#uniq` algorithm is basically:\n1. Build empty helper hash\n2. Iterate over the array elements: For each element: If it already exists in the hash, skip it; otherwise, add it to hash (element => element).\n3. Take the helper hash values\n\nHowever, in Ruby 2.1.0 they don't check \"if it already exists in the hash\". So the _last_ element prevails. This was fixed in Ruby 2.1.1.\n. FYI: here's the Ruby 2.1.0 bug report: https://bugs.ruby-lang.org/issues/9340\n. Regarding `Hamster.from`:\n\nIndeed the idea is to take a big nested Hash \"document\" (like [Github Gists API response](https://developer.github.com/v3/gists/#response)) and to be able to process it with Hamster tools (keep it immutable).\n\nRegarding `get_in` and `update_in`:\n\nActually, since we support `h[key]` on `Hamster::Hash`, I now think that `#get_in` is not really needed because you can have:\n\n```\nnested2[\"a\"][\"b\"][\"d\"]\n# => 6\n```\n\n(identical to normal Ruby hash usage)\n\nHowever, for storing this doesn't work, of course; that's why `#update_in` is suggested; and maybe it should support Vector access (by index) too, so one can have \n\n```\nnested.update_in(\"a\", \"b, \"c\", 2) { |v| v + 1 }\n```\n\nWhich is the immutable parallel of the in-place Ruby code:\n\n```\nh[\"a\"][\"b\"][\"c\"][2] += 1\n```\n. Hamster doesn't support `[]=` on Hash (and Vector) because there's no way to return the new modified Hash (or Vector) from this method (I guess it's a special method in Ruby that returns the right-hand-side value and not the method return value). So:\n\n```\nh = Hamster::Hash[\"a\" => Hamster::Hash[\"b\" => Hamster::Hash[\"c\" => Hamster::Vector[3, 4, 5]]]]\nh[\"a\"][\"b\"][\"c\"][2]\n# => 5 \nh[\"a\"][\"b\"][\"c\"][2] = 8\n# NoMethodError: undefined method `[]=' for Hamster::Vector[3, 4, 5]:Hamster::Vector\n```\n. Code is in master (see #150). We now support `Hamster.from`, `Hash#update_in` and `Vector#update_in`.\n. I'll try to implement your suggestion.\n. And instead of sorting, don't you think it's better to hold 32 buckets (arrays) and push each element to the relevant bucket according to it's `hash >> sig & 31` ?\n. Just to update that I'm trying these approaches and so far I only managed to make it _worse_. Probably there's a bug in my implementation attempts; still working on it from time to time.\n. Pushed: https://github.com/dubek/hamster/blob/trie_bulk_put/lib/hamster/trie.rb\n\nOf course it's a WIP, still need to refactor. Look at bulk_put and bulk_put! .\n\nI'm measuring this (run this in `master` and in my branch):\n\n```\nrequire \"benchmark/ips\"\nrequire \"hamster/set\"\nset_size = 1000\nset_a = Hamster::Set.new((1..set_size).to_a)\nset_b = Hamster::Set.new(((set_size/2)..(set_size*3/2)).to_a)\nBenchmark.ips do |b|\n  b.report \"union(N=#{set_size})\" do\n    set_a.union(set_b)\n  end\nend\n```\n. OK, let me sort this out, clean up, rebase and squash.\n. @alexdowad OK that's enough. We said that `bulk_put` was a bit big (bulky?) and might want to split it to some internal methods; but I guess for now it's OK.\n\nThanks.\n. Thanks. Any idea how to handle a `Vector` in that nested structure? Say `hash.put_in(\"a\", 6, \"b\")` where `6` is the index to a `Vector` containing another `Hash` in it's 7th element (index 6)?\n. And there's an assumption that if a key doesn't exist create it with `EmptyHash`. Do you think it's reasonable to leave it this way?\n\nAlso: maybe extract `#put_in` to a `NestedOperations` module and include it both classes?\n. OK. Note the the `Vector` setter is called `set`, not `put`. So we'll need some special code to handle those. Also, should I call the method `Vector#put_in` or `Vector#set_in` ?\n. On the other thread we were talking about _minimizing_ the interface, so adding more names (=alias) doesn't seem like a good solution.\n\nRuby Array only supports setting elements with `[]=` which we can't use. Ruby Hash supports `[]=` and `store(key, value)`. So I guess if we want to stick with one name _and_ be somewhat compatible to the Ruby built-in classes, we should pick `store` and `store_in` for both Hamster::Hash and Hamster::Vector (though I agree that `#set` feels \"easier\" to me somehow).\n. Or we can leave everything as-is (`Hash#put` and `Vector#set`) and call out nested method `update_in` (in both) to celebrate it's Clojure origin :-)\n. Rebased, changed to `#update_in` and added implementation for `Vector` too.\n. Fixed `#from` to build one `Hamster::Hash`. force-pushed.\n. Good. So with my implementation of:\n\n```\ndef store(key, value)\n  put(key, value)\nend\n```\n\nthen `store` mandates the 2 arguments (without block) and put allows either 2 arguments or 1 argument and a block.\n. Your suggested `Set#filter` and `Hash#filter` implementations are indeed faster than what we have today: https://gist.github.com/dubek/f5c4e68febe2a7c80e77 (old_filter in both cases refers to the current implementation which performs `@trie.delete` on each element that doesn't pass the filter).\n\nI'll add this commit too in a few minutes.\n. Right now I have some free time, but I'm afraid soon it'll be over and I'll just have a few hours from time to time... So don't worry too much about it. Also I really appreciate your comments on the code I submit.\n. Why not follow the scheme used by other popular gems:\n- https://github.com/sinatra/sinatra\n- https://github.com/rack/rack\n- https://github.com/bundler/bundler\n\nCan you give examples of repos using the {name}.gem scheme?\n. (and add to the checklist: modify the github path in `hamster.gemspec`)\n. OK I don't mind either way.\n. I'm against changing the **repo** name. There are already 7 non-related github repos called \"hamster\". I don't see any reason we should clear this already-crowded space.\n\nAs for the **org** name, I'm indifferent: hamstergem / libhamster / ruby-immutable -- all work OK for me as the github org name. So I have no problem leaving it as-is (which is the least work).\n. Sorry about that; I should have seen it before pushing.\n. I'm considering calling `#fill` with `nil` for all the \"missing\" indexes, if needed. I'll try it out.\n. BTW the reason we didn't find this bug is that in `vector/get_spec.rb` we have `if rand(1) == 0` but `rand(1)` always returns 0; it should be `rand(2)`. Once you change that, you start to get IndexError exceptions...\n. Commit 00fc44189f99993ac131cc19351ec23cd23fc589 on master allows to set element past the end of the vector:\n\n``` ruby\nHamster::Vector[1,2,3].set(6, \"foo\")\n# => Hamster::Vector[1, 2, 3, nil, nil, nil, \"foo\"]\n```\n. One clarification: the immutable_struct gem offers a Struct that you can never change (it has no setters; can be achieved in plain Ruby with `#freeze` but you'll have to remember to call it). Hamster, on the other hand, gives you set/update/delete methods on the data structures, but those do not modify the original variable, but return a copy of the data structure with the requested modification (and it tries to make the copy as efficient as possible).\n. Ruby has `Enumerable#find_index` which accepts either a value or a block and returns the _first_ index that matches (either equal to the value or the block evaluates to non-false) - http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-find_index\n\nSo if we want to be \"similar\" to Enumerable, maybe that method (which in option B you can `indices`) can be called `find_indices` ... Not sure what it means in terms of backward-compatibility and how much we need to care.\n. One more idea: maybe we can remove this method altogether because users can\nuse: mylist.with_index.select { |e,i| ... }   ?\nOn Dec 27, 2014 12:33 AM, \"Alex Dowad\" notifications@github.com wrote:\n\n> Anyone else want to make your voice heard, before the axe drops? @dubek\n> https://github.com/dubek? Others?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/164#issuecomment-68169515.\n. As for the method name - I guess `indices` is OK because it is similar to Ruby Array's `index` (which is an alias to `find_index`). (Enumerable doesn't have `index`)\n\nHowever - I'm still in favor of dropping this method (sorry). It not really lazy because it has to scan the entire list anyway (or am I missing something?). And it can be implemented in terms of other methods like this:\n\n``` ruby\nHamster::List[1,2,3,4,5,6,7,8].each.with_index.select { |e,i| e % 3 == 0 }\n# => [[3, 2], [6, 5]] \n```\n\nwhich (I think) doesn't incur extra allocations of the entire list (but returns Array and not Hamster::List ...).\n\nYou have the last word (someone has to cut it :-).\n. @alexdowad thanks for clarifying.\n. @xbeta: This is intended. To quote from the README:\n\n> Hamster collections are immutable. Whenever you modify a Hamster collection, the original is preserved and a modified copy is returned. This makes them inherently thread-safe and shareable. At the same time, they remain CPU and memory-efficient by sharing between copies. \n\nThis is true for all Hamster's data structures: `Hamster::Hash`, `Hamster::Vector`, and so on. So a `#push` or a `#set` on a `Hamster::Vector` instance will return a new one, unlike Ruby's built-in `Array` which will modify the instance in-place.\n. Although JSON and Yaml modules add `Array#to_json` and `Hash#to_yaml` and so on, I prefer not to go this way (that is, not to add method to basic Ruby objects). \n\nI'd rather stay with `Hamster::Vector#to_a` as mentioned above. If needed, add `Hamster::Hash#to_h` and `Hamster::Set#to_set` (or maybe `#to_ruby_set` ?)  as needed to convert to regular Ruby objects.\n. Yes, you're right. #to_mutable is a good idea.\n\nI wish we had a better name, though. Haven't looked at the equivalent JS\nproject for ideas yet.\nOn Mar 17, 2015 3:48 AM, \"Elben Shira\" notifications@github.com wrote:\n\n> Would you still consider the class method Hamster.to_mutable to be a good\n> idea? Three good points I see about this are:\n> 1. Symmetry with Hamster.from.\n> 2. Accepts any Hamster object.\n> 3. The instance method way (to_set/to_h/to_a) can be implemented by\n>    calling Hamster.to_mutable.\n> \n> Otherwise, I can implement the to_x methods individually in each class.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82025560.\n. I agree with @alexdowad - `#to_ruby` which means \"convert to the equivalent built-in Ruby data structure\". Then users can have `my_hamster_data_var.to_ruby.to_json` if they wish (or `to_yaml` or whatever).\n. Another option is to have two implementations:\n1. If the `concurrent` gem is installed, use it (`require 'concurrent/atomics'` and use the `Atomic` class).\n2. Otherwise, build a naive (=slow) implementation using a Mutex for any read/write operation on @atomic (which can then be a normal fixnum).\n\nThis way hamster works out-of-the-box without other dependencies, and if you need List to be faster then you just `gem install concurrent`.\n. I'm good with adding dependency on `concurrent` (instead of `atomic`), and in our code adding `require \"concurrent/atomics\"`.\n. (It was @roryokane's suggestion, actually.)\n. Nice.\n\nBTW (not related to the concurrent gem): it might be clearer to extract those `if @atomic.get != 2` to something like:\n\n``` ruby\ndef head\n  realize unless realized?\n  @head\nend\n\nprivate\n\ndef realized?\n  @atomic.get == 2\nend\n```\n\nand so on for the other \"states\" of the `@atomic` var.\n\nI might pursue it in a separate PR for review.\n. @krainboltgreene I think you're confusing right and left sides of `===`. Basically you have a collection of _patterns_, so an equivalent example (without Earhart) would be:\n\n```\n2.2.1 :004 > myset = Hamster::Set.new([/a/, /b/, /c/])\n => Hamster::Set[/a/, /b/, /c/] \n2.2.1 :005 > myset.grep(\"aaa\")\n => Hamster::Set[] \n```\n\nwhich is fine; same behaviour for plain Ruby arrays:\n\n```\n2.2.1 :006 > myarray = [/a/, /b/, /c/]\n => [/a/, /b/, /c/] \n2.2.1 :007 > myarray.grep(\"aaa\")\n => [] \n```\n\nI don't really know your application but maybe you should resort to something along the lines of:\n\n```\nchosen_route = collection.find { |route| route === query }\n```\n\n(off-topic: for an interesting implementation of an efficient HTTP request router using prefix trees see https://github.com/julienschmidt/httprouter#how-does-it-work )\n. As a side note, in Ruby 2.x you can turn any enumerator to lazy, so:\n\n```\nmyvector = Hamster::Vector.new([\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"])\n# => Hamster::Vector[\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"] \n\nmyvector.each.lazy.select { |x| puts \"WORKING ON #{x}\"; x.match(/b/) }\n# => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator: Hamster::Vector[\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"]:each>>:select> \n\nmyvector.each.lazy.select { |x| puts \"WORKING ON #{x}\"; x.match(/b/) }.first\nWORKING ON aaa\nWORKING ON bbb\n# => \"bbb\" \n```\n\nAs opposed to normal iteration without `.lazy`:\n\n```\nmyvector = Hamster::Vector.new([\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"])\n# => Hamster::Vector[\"aaa\", \"bbb\", \"ccc\", \"bb\", \"d\"] \n\nmyvector.select { |x| puts \"WORKING ON #{x}\"; x.match(/b/) }.first\nWORKING ON aaa\nWORKING ON bbb\nWORKING ON ccc\nWORKING ON bb\nWORKING ON d\n# => \"bbb\" \n```\n\nI haven't investigated effects on performance.\n. Generally I'm not against your suggestion, but these \"early `return`s\" are very common throughout the Hamster code, and in some cases make the code easier to read IMO. @krainboltgreene did you intend to modify all the similar occurrences of `return ... unless ...`?\n. @alexdowad I believe adding `List.new` will make things even more difficult to understand:\n\n``` ruby\n$ irb -Ilib -rhamster\n2.2.1 :001 > my_list = Hamster::List[1,2,3]    # Or, per suggestion:   Hamster::List.new(1,2,3)\n => Hamster::List[1, 2, 3] \n2.2.1 :002 > my_list.class\n => Hamster::Cons \n```\n. OK sure. The README should be fixed though (line 200) to square brackets.\n. @alexdowad I believe the same issue (and solution) are in `Splitter::Left` and `Splitter::Right` (in the same file).\n. In a standalone benchmark it looks about the same:\n\n``` ruby\nrequire \"benchmark/ips\"\n\nclass A\n  def initialize(m)\n    @m = m\n  end\n\n  def set_nil\n    @m = nil\n  end\n\n  def remove_var\n    remove_instance_variable :@m\n  end\nend\n\nBenchmark.ips do |b|\n  b.report(\"set_nil\") { A.new([]).set_nil }\n  b.report(\"remove_var\") { A.new([]).remove_var }\n  b.compare!\nend\n```\n\nResults:\n\n```\n$ ruby -v remove_inst_bench.rb  \nruby 2.2.1p85 (2015-02-26 revision 49769) [x86_64-linux]\nCalculating -------------------------------------\n             set_nil    86.017k i/100ms\n          remove_var    78.048k i/100ms\n-------------------------------------------------\n             set_nil      2.703M (\u00b1 1.8%) i/s -     13.591M\n          remove_var      2.561M (\u00b1 3.6%) i/s -     12.800M\n\nComparison:\n             set_nil:  2703019.0 i/s\n          remove_var:  2561488.4 i/s - 1.06x slower\n```\n\nI actually prefer the `@mutex = nil` version...\n. Good catch!\n\nIndeed modifying the arity condition in https://github.com/hamstergem/hamster/blob/master/lib/hamster/sorted_set.rb#L103 to:\n\n```\nif block.arity <= 1\n```\n\nfixes the problem (both with the `&:name` syntax and the weird `|*a|` block).\n\nI'm not sure about the promises about the number of times the block is called.\n. @no-reply Interesting. I remember reading (can't find the source) that actually adding a `&blk` parameter to a method slows things down, because Ruby converts the block into a Proc object (which is later `#call`-ed).\n\nSo, supposedly, the fastest would be to eliminate `&blk` parameter and use `yield` (and maybe `block_given?` to check if we have a block at all. Of course this need benchmarking and might change in different Rubies. Here's a simple benchmark (which probably means wrong benchmark :-) ) on my machine:\n\n``` ruby\nrequire 'benchmark/ips'\n\ndef f1(&blk)\n  blk.call\nend\n\ndef f2(&blk)\n  yield\nend\n\ndef f3\n  yield\nend\n\ndef f4\n  yield if block_given?\nend\n\nBenchmark.ips do |b|\n  b.report(\"blk.call\") { f1 { 100 * 100 } }\n  b.report(\"blk and yield\") { f2 { 100 * 100 } }\n  b.report(\"yield\") { f3 { 100 * 100 } }\n  b.report(\"block_given? and yield (with block)\") { f4 { 100 * 100 } }\n  b.report(\"block_given? and yield (without block)\") { f4 }\nend\n```\n\nResults:\n\n```\n            blk.call      1.779M (\u00b1 2.5%) i/s -      8.955M\n       blk and yield      2.215M (\u00b1 3.0%) i/s -     11.081M\n               yield      6.639M (\u00b1 3.2%) i/s -     33.206M\nblock_given? and yield (with block)\n                          4.570M (\u00b1 2.4%) i/s -     22.854M\nblock_given? and yield (without block)\n                          6.677M (\u00b1 2.4%) i/s -     33.451M\n```\n\nSo removing the `&blk` parameters improved from 2.2M i/s to 6.6M i/s. Get rid of those `&blk` ! :-)\n. Oops just saw I'm repeating the benchmark already above on this thread.... Too late I guess. Sorry.\n. Nowadays `#update_in` is part of the `Associable` module:\n\n``` ruby\n  # Including `Associable` in your container class gives it an `update_in`\n  # method.\n  #\n  # To mix in `Associable`, your class must implement two methods:\n  #\n  # * `fetch(index, default = (missing_default = true))`\n  # * `put(index, item = yield(get(index)))`\n  #\n  # See {Vector#fetch}, {Vector#put}, {Hash#fetch}, and {Hash#put} for examples.\n```\n\nSo for `List` we can implement `#fetch` (in terms of `#at`) and probably make some not-really-efficient `#put`.\n\nAs for `Set` and `SortedSet`, I'm not sure what these operations (fetch/put) mean. What is the index? What is the item's value?\n. Indeed there's already `SortedSet#fetch(index, default = (missing_default = true))` so this side is OK. \n\nAs for `#put`, it'll be something like `#delete` and then `#add`. Of course it's very weird because in the SortedSet `[\"a\", \"b\", \"c\", \"d\"]`    if your perform `s.put(2, \"z\")` you'll get `[\"a\", \"b\", \"d\", \"z\"]`, so a subsequent `s.fetch(2)` will return `\"d\"`...\n. Thanks @xaviershay for the contribution. I prefer the new suggested code in this PR.\n\nI'm not sure about undef-ing monkey-patched methods; I think the subprocess is a safer approach (in Lua you can have several \"global\" environments and shift between them...)\n. `.new` on non-classes is confusing. Also it might conflict with the existing `Cons#initialize` since `Cons` includes `List`? \n. Thanks for noticing this.\n\nAnother option is to completely remove the per-class `#to_ruby` methods. To look at another example, I really prefer `JSON.generate(obj)` instead of `obj.to_json`; that also allows having `JSON.pretty_generate(obj)`, `MessagePack.pack(obj)` and so on without further polluting the classes interface.\n\nTo contradict myself, the current `Hamster.to_ruby` has a code smell in which we switch over the argument's class, which is something that should classically be done with polymorphism. So another approach is that each class will implement its own `#to_ruby`, calling `.to_ruby` on each collection element (hmm, but what about plain Ruby classes?).\n. But if an object doesn't `respond_to?(:to_ruby)`, you'll need to implement the `when Hash ... when Array ...` etc. You _don't_ want that code duplicated in `Hamster::Hash#to_ruby` and `Hamster::Vector#to_ruby` and so on.\n\nMaybe the code smell I was referring to is unavoidable, because we want to support both the Hamster classes and the PORO collections.\n. I'm OK with it. The docs for `Hamster.to_ruby` should be updated, not sure if anyone tackled it already.\n. @Bill 's approach looks good to me. It should be in some \"generic\" file similar to `hamster/nested.rb` (but not there). At first step the current implementation of `Hash#update_in` and `Vector#update_in` can simply call the new suggested method. At a later stage we can deprecate and then erase them in favour of using only `Hamster.update_in(myhash, \"a\", \"b\", \"c\") { |val| val + 5 }` .\n\nI think in the past we had `Vector#put` and we removed it as part of the big clean-up prior to releasing 1.0... oops!\n. Hmmm, I think about it again. In Ruby the methods are \"duplicated\" for each class. So you have `Array#sort` and `Hash#sort` whose implementations are probably very similar - yet Ruby doesn't define a global `sort(my_data_structure)` function...\n\nSo maybe we should improve code reuse but leave the interface as `Hash#update_in` and `Vector#update_in` ?\n\n(sorry for contradicting myself)\n. Nice post. Your new module name is really confusing...\n\nBesides supporting `[:key, :expected_value]` and `\"*\"` (kleene star) you might want to support procs/lambdas. So the kleene star can be implemented by:\n\n```\nHamstar.update_having(x, ->{true}, :name)\n```\n\nand the key-expected value can be implemented as:\n\n```\nHamstar.update_having(x, ->(k,v){ v[:name] == \"Pat\" }, :name)\n```\n\nand you maybe can extend to stuff like \"update having an even-index\" etc.\n\n```\nHamstar.update_having(x, ->(k,v){ k.even? }, :name)\n```\n\n(I guess this discussion should move to the Hamstar repo...)\n. :+1: for releasing `1.1.0` with the added functionality.\n. Who has the gem release button? @krainboltgreene ? Can you release a 1.1.0.pre.rc1 ?\n. So `Hamster.from` and `Hamster::Whatever#to_ruby` are available in the hamster 2.0.0 gem released yesterday.\n\nClosing.\n. This approach looks good to me.\n. Since Hamster should only support converting the built-in Ruby data structures, I think 1 is OK - we should be able to cover them all, if we haven't already (up to new additions to the stdlib in the next Ruby version).\n. Thanks @Bill - it looks much better now. Two comments: \n1. in both READMEs - replace the `vector.set` example with `vector.put` (which is now the \"correct\" method).\n2. replace `spec/lib/hamster/vector/set_spec.rb` with `#put` specs, possibly leave a small `#set` spec until we decide to remove that alias. Also other specs that may use `Vector#set`. Possibly comment out the `set` alias and see what breaks.\n\nI'll probably have time tomorrow to fix those two things.\n\nSmall suggestion for the future - separate such changes to two commits: first - introduce `Vector#put` (with its relevant documentation and spec changes); second - introduce `Associable` which relies on `Vector#put`.\n. I pushed those small fixes in e7ad27709bcc22d6c5c29bb68de435a1e43f42b1 .\n. Would the following code work for these kind of scenarios?\n\n``` ruby\nhash = Hamster.from(some_calculation)\nhash = hash.put(:foo, :bar) if condition1\nhash = hash.put(:xyz, 123) if condition2\n```\n\nFor example, if `condition1` is false, the entire assignment `hash = hash.put(:foo, :bar)` is not executed and the variable `hash` keeps its original value.\n. Thanks you for the contribution!\n\nJust so everyone knows:\n- Current hamster code (before this PR) works with concurrent-ruby 0.8.0 but not with 1.0.0 (they removed the older Concurrent::Atomic class in 1.0.0).\n- The new hasmter code (as suggested in this PR) works with concurrent-ruby 1.0.0 but not with 0.8.0.\n\nI'm OK with this PR but we'll force dependency upgrade on our users (much in the same sense that now we enforce \"don't upgrade\"...).\n. Added `Hash#fetch_values` in ed887846f89f56f444ca2107c628372fc83f0070\n. Added `Hash#to_proc` in 7433f92a0943d64c2dd367c4c597f8c7016dbc68\n. Thanks to @HParker who added `Hash#dig` in 500928ea887793960977a000ae9a937197e1cbc1\n. Hash `>=` `>` `<` `<=` added in 8a70322c1603f58d9c5c14c254ef49ac20f8e950\n. Added `Hamster::Enumerable#grep_v` in  ba4a801b5e5f29d661fd6e2a9c753c1f3df453c5\n. Thanks to @HParker who added `Vector#dig` in 42fb988cc08171231165679204de3ff120316cba\n. Fixed by  @xaviershay in #218 .\n. The downcase should verify that the filtered results indeed are processed by the block (when given) - similar to #map behavior.\n. Yes, you're right. IMO there's no need to repeat all the scenarios again _with_ the block, maybe just verify that:\n\n```\nHamster::Set[\"A\", 2, \"C\"].grep(String) { |x| x.downcase }\n#=> Hamster::Set[\"a\", \"c\"]\n```\n. @alexdowad why was this closed? AFAIK the issue is still there:\n\n```\n$ rspec spec/lib/hamster/set/grep_spec.rb \nI, [2015-12-07T09:04:47.020231 #23152]  INFO -- : Not reporting to Code Climate because ENV['CODECLIMATE_REPO_TOKEN'] is not set.\nNo examples found.\n\nFinished in 0.00018 seconds (files took 1.5 seconds to load)\n0 examples, 0 failures\n\nTop 0 slowest examples (0 seconds, 0.0% of total time):\n```\n. @xaviershay Can you please rebase your branch on top of the current `master`, and add a verification that `#grep` processes results with the given block (as discussed above)?\n. Fixed in ae7e0b24c5dea0b0bfecb2d867f65b3e4bef7d36 with better specs.\n. Does it make sense to add dig to the Associable module we already have?\nOn Dec 7, 2015 00:56, \"Alex Dowad\" notifications@github.com wrote:\n\n> I think this is ready to merge. Yes, it would be nice to unify the code\n> between Hash and Vector, but I think that can be done in a separate PR.\n> @dubek https://github.com/dubek, would you like to merge?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/216#issuecomment-162418117.\n. Merged manually ( 500928ea887793960977a000ae9a937197e1cbc1 ).\n\n@HParker thanks a lot for your contribution to Hamster (and the explanations about Ruby 2.3 shenanigans)! If you'd like to continue working on it, I suggest (in a new PR):\n1. writing specs for `Vector#dig`\n2. implementing `#dig` in the `Associable` module and removing it from `Hamster::Hash`.\n. Besides my small code comments on the documentation, I just noticed this at the top of `associable.rb`:\n\n```\n   # To mix in `Associable`, your class must implement two methods:\n   #\n   # * `fetch(index, default = (missing_default = true))`\n   # * `put(index, item = yield(get(index)))`\n   #\n```\n\nHowever the new `#dig` method uses `[]` and not `fetch`. Can we change to `fetch` without breaking or making it over-complex?\n. Thanks for the quick fixes.\n\nI just thought about the case of Hash with default proc. In Ruby 2.3.0-preview1 it behaves as follows:\n\n```\n2.3.0-preview1 :001 > h = Hash.new { |h,k| \"#{k}-default-val\" }\n => {} \n2.3.0-preview1 :002 > h[:a]\n => \"a-default-val\" \n2.3.0-preview1 :003 > h.fetch(:a)\nKeyError: key not found: :a\n    from (irb):3:in `fetch'\n    from (irb):3\n    from /home/dmurik/.rvm/rubies/ruby-2.3.0-preview1/bin/irb:11:in `<main>'\n2.3.0-preview1 :004 > h.fetch(:a, nil)\n => nil \n2.3.0-preview1 :005 > h.dig(:a)\n => \"a-default-val\" \n```\n\n@HParker - Can you please check where the suggest `#dig` works similarly? Or will we need to resort to using `[]` as you originally suggested?\n\nIn any case we need to make sure the `Hamster::Hash#dig` specs indeed specify these cases (with and without default proc).\n. Yep, I agree. Just use `#get` and add it to the documentation of `Associable` as a required method.\n. Rebased and merged to master manually.\n\nThanks @HParker for dealing with all the back and forth! Great contribution.\n. Merged. Thank you @xaviershay !\n. Of course it'll need to have special YARD directive so it doesn't appear in the API docs.\n\n@xaviershay Your opinion about this suggestion? Any idea if any other library acts in a similar fashion?\n. @no-reply thanks for the contribution! I see you added this on Hamster::Hash. Can a similar method be added to Hamster::Vector ?\n. @guncha If your AST is really a tree, then it shouldn't have cycles... :-)\n. ",
    "xaviershay": "Link to online reading: http://www.rubydoc.info/github/hamstergem/hamster/master/Hamster\n\nI'm having a go at this.\n. Why are `Hash#put` and `Hash#store` not aliases of one another? Seems weird to have both, but maybe that's backwards compat?\n. thanks for background. Could send PR, but if `store` is supposed to match Ruby interface then maybe I'll just document it as such. Hoping to get a once over of all the `Hash` docs done today - will send that up and if you like it I can tackle the rest.\n. Will probably make a different issue for this, but given we are making performance claims (\"At the same time, they remain CPU and memory-efficient by sharing between copies.\") would probably be good to include expected operation cost in the YARD docs (`O(1)`, `O(n)`, etc). This is a thing I like about the [redis docs](http://redis.io/commands/bitcount).\n. thanks for feedback, will address tomorrow.\n. Updated. I think your last two comments were on the old version rather than the new (called, Otherwie).\n. great thanks, I'll start tackling the others!\n. Calling `to_a` on the final vector before `uniq` results in an array with the expected values.\n. weird, so the 32 thing was a red herring? I wonder what the difference was in my repro then...\n. Oh right, `BLOCK_SIZE` is 32. The `uniq!` code path was only being hit when their were multiple blocks (or something). Thanks for the quick fix!\n. should stay as undefined, but a method missing error coming from inside the library is pretty gross. Makes it looks like a bug.\n. possibly want a spec for empty array, since you mention it in the commit message. Otherwise, LGTM!\n. I'll fix them, just doing a full doc pass first.\n. Actual fix here is probably just calling `to_ary` on elements to match Ruby behaviour.\n. I think the implementation is correct, this is just to provide consistent exception types. So, pretty minor.\n. neat, kinda weird but I like it.\n. hrmm ok, let me poke around. My understanding was if it actually needed an `Array`, rather than just something that looked like one, it would use `#to_a`.\n. ... and the reason I brought this up is I think we want this to correctly implement https://github.com/hamstergem/hamster/issues/185 (and likely other methods) without having to pay the cost of converting sub-Vectors into arrays.\n. I have convinced myself that you are correct. Ruby does do an explicit type check.\n\n``` ruby\nclass MyVector\n  def to_ary\n    self\n  end\nend\n\nArray.new(MyVector.new)\n```\n\n```\ntest.rb:25:in `initialize': can't convert MyVector to Array (MyVector#to_ary gives MyVector) (TypeError)\n```\n. Same thing for `List#uniq`.\n. Actually hold off merging this, I'll just add all the other edits here as well.\n. Ready for review.\n. I think I've responded to all feedback.\n. https://github.com/hamstergem/hamster/commits/933781fa222e680995132b492803f6cbb740c6ae appears to be the first bad commit.\n. Maybe related to https://bugs.ruby-lang.org/issues/11071 ?\n. Nice find!\n. Micro-benchmark suggesting expected size of performance hit. Would be the difference between the final two cases, though obviously actual benchmark of this code is needed:\n\n``` ruby\nrequire 'benchmark/ips'\n\ndef a\n  yield\n  yield\nend\n\ndef b(&block)\n  yield\n  yield\nend\n\ndef c(&block)\n  yield\n  block.call\nend\n\ndef d(&block)\n  block.call\n  block.call\nend\n\nBenchmark.ips do |x|\n  y = 0\n  x.report(\"yield only\") { a { y + 1 } }\n  x.report(\"yield with &block\") { b { y + 1 } }\n  x.report(\"mixed with &block\") { c { y + 1 } }\n  x.report(\"&block only\") { d { y + 1 } }\nend\n```\n\n```\nCalculating -------------------------------------\n          yield only    61.039k i/100ms\n   yield with &block    34.155k i/100ms\n   mixed with &block    32.514k i/100ms\n         &block only    32.829k i/100ms\n-------------------------------------------------\n          yield only      2.188M (\u00b1 6.9%) i/s -     10.926M\n   yield with &block    710.589k (\u00b1 4.8%) i/s -      3.552M\n   mixed with &block    653.130k (\u00b1 3.7%) i/s -      3.284M\n         &block only    611.241k (\u00b1 3.6%) i/s -      3.053M\n```\n. I want to keep digging into details too, but having a red CI is really concerning to me. Would you accept marking this spec as pending instead?\n. Should revert https://github.com/hamstergem/hamster/pull/195 once this (or an alternate fix) is applied.\n. @alexdowad WDYT of this comment?\n. Because of `LazyList#realize` these aren't actually frozen. Another way of saying this is that the list can \"grow\" a tail as it is evaluated.\n. I noticed last night `hamster/list` depends on `hamster/core_ext/enumerable` (`.list` calls `.to_list`), that should be an easy one to break though.\n. I see two ways to solve the bulk of these:\n- Features that would require another data-structure (e.g. `Set#sort` needs `SortedSet`) raise \"feature not loaded\" if the type they require is not present.\n- Use monkey-patching to group cross-cutting features in a single file. You could fix the `nested` circular dependency by moving all the `to_ruby` definitions into it.\n\nProbably a mix of the two is best.\n\nThoughts on those? Any other ideas?\n. I verified this by commenting out `#to_list` and running list and deque specs independently. More work required to prevent those specs from actually loading `core_ext`.\n\nRSpec runs all specs that would monkey-patch in a subprocess. Maybe overkill here, we could perhaps just undef `#to_list` once done?\n. `List.new` is too weird I think.\n. @dubek for your first option, we could just remove all the `#to_ruby` methods. I'm actually on board with that, but needs a major version release.\n\nFor the latter, easy enough to do a `respond_to?(:to_ruby)` check?\n. `Hamster.to_ruby(obj)` works for me, but needs a major version bump coz it's backwards incompatible to remove the `to_ruby` methods. (Not sure what your release policy/cadence is...)\n. I don't have any free time until the weekend, if it's not done by then I'll have a look :)\n. we need to have non-core extensions equivalents of all of our monkey-patches, so users can opt not to include core extensions.\n. what @alexdowad said. I'd lean towards 1 or 2 (though as you said, maybe not much we can do there), 3 makes me nervous.\n. fix incoming\n. that might need to get pulled out of shared specs then, since `\"A\" != \"a\"`\n. sure, not going to get to this for a few days though.\n. Link to online reading: http://www.rubydoc.info/github/hamstergem/hamster/master/Hamster\n\nI'm having a go at this.\n. Why are `Hash#put` and `Hash#store` not aliases of one another? Seems weird to have both, but maybe that's backwards compat?\n. thanks for background. Could send PR, but if `store` is supposed to match Ruby interface then maybe I'll just document it as such. Hoping to get a once over of all the `Hash` docs done today - will send that up and if you like it I can tackle the rest.\n. Will probably make a different issue for this, but given we are making performance claims (\"At the same time, they remain CPU and memory-efficient by sharing between copies.\") would probably be good to include expected operation cost in the YARD docs (`O(1)`, `O(n)`, etc). This is a thing I like about the [redis docs](http://redis.io/commands/bitcount).\n. thanks for feedback, will address tomorrow.\n. Updated. I think your last two comments were on the old version rather than the new (called, Otherwie).\n. great thanks, I'll start tackling the others!\n. Calling `to_a` on the final vector before `uniq` results in an array with the expected values.\n. weird, so the 32 thing was a red herring? I wonder what the difference was in my repro then...\n. Oh right, `BLOCK_SIZE` is 32. The `uniq!` code path was only being hit when their were multiple blocks (or something). Thanks for the quick fix!\n. should stay as undefined, but a method missing error coming from inside the library is pretty gross. Makes it looks like a bug.\n. possibly want a spec for empty array, since you mention it in the commit message. Otherwise, LGTM!\n. I'll fix them, just doing a full doc pass first.\n. Actual fix here is probably just calling `to_ary` on elements to match Ruby behaviour.\n. I think the implementation is correct, this is just to provide consistent exception types. So, pretty minor.\n. neat, kinda weird but I like it.\n. hrmm ok, let me poke around. My understanding was if it actually needed an `Array`, rather than just something that looked like one, it would use `#to_a`.\n. ... and the reason I brought this up is I think we want this to correctly implement https://github.com/hamstergem/hamster/issues/185 (and likely other methods) without having to pay the cost of converting sub-Vectors into arrays.\n. I have convinced myself that you are correct. Ruby does do an explicit type check.\n\n``` ruby\nclass MyVector\n  def to_ary\n    self\n  end\nend\n\nArray.new(MyVector.new)\n```\n\n```\ntest.rb:25:in `initialize': can't convert MyVector to Array (MyVector#to_ary gives MyVector) (TypeError)\n```\n. Same thing for `List#uniq`.\n. Actually hold off merging this, I'll just add all the other edits here as well.\n. Ready for review.\n. I think I've responded to all feedback.\n. https://github.com/hamstergem/hamster/commits/933781fa222e680995132b492803f6cbb740c6ae appears to be the first bad commit.\n. Maybe related to https://bugs.ruby-lang.org/issues/11071 ?\n. Nice find!\n. Micro-benchmark suggesting expected size of performance hit. Would be the difference between the final two cases, though obviously actual benchmark of this code is needed:\n\n``` ruby\nrequire 'benchmark/ips'\n\ndef a\n  yield\n  yield\nend\n\ndef b(&block)\n  yield\n  yield\nend\n\ndef c(&block)\n  yield\n  block.call\nend\n\ndef d(&block)\n  block.call\n  block.call\nend\n\nBenchmark.ips do |x|\n  y = 0\n  x.report(\"yield only\") { a { y + 1 } }\n  x.report(\"yield with &block\") { b { y + 1 } }\n  x.report(\"mixed with &block\") { c { y + 1 } }\n  x.report(\"&block only\") { d { y + 1 } }\nend\n```\n\n```\nCalculating -------------------------------------\n          yield only    61.039k i/100ms\n   yield with &block    34.155k i/100ms\n   mixed with &block    32.514k i/100ms\n         &block only    32.829k i/100ms\n-------------------------------------------------\n          yield only      2.188M (\u00b1 6.9%) i/s -     10.926M\n   yield with &block    710.589k (\u00b1 4.8%) i/s -      3.552M\n   mixed with &block    653.130k (\u00b1 3.7%) i/s -      3.284M\n         &block only    611.241k (\u00b1 3.6%) i/s -      3.053M\n```\n. I want to keep digging into details too, but having a red CI is really concerning to me. Would you accept marking this spec as pending instead?\n. Should revert https://github.com/hamstergem/hamster/pull/195 once this (or an alternate fix) is applied.\n. @alexdowad WDYT of this comment?\n. Because of `LazyList#realize` these aren't actually frozen. Another way of saying this is that the list can \"grow\" a tail as it is evaluated.\n. I noticed last night `hamster/list` depends on `hamster/core_ext/enumerable` (`.list` calls `.to_list`), that should be an easy one to break though.\n. I see two ways to solve the bulk of these:\n- Features that would require another data-structure (e.g. `Set#sort` needs `SortedSet`) raise \"feature not loaded\" if the type they require is not present.\n- Use monkey-patching to group cross-cutting features in a single file. You could fix the `nested` circular dependency by moving all the `to_ruby` definitions into it.\n\nProbably a mix of the two is best.\n\nThoughts on those? Any other ideas?\n. I verified this by commenting out `#to_list` and running list and deque specs independently. More work required to prevent those specs from actually loading `core_ext`.\n\nRSpec runs all specs that would monkey-patch in a subprocess. Maybe overkill here, we could perhaps just undef `#to_list` once done?\n. `List.new` is too weird I think.\n. @dubek for your first option, we could just remove all the `#to_ruby` methods. I'm actually on board with that, but needs a major version release.\n\nFor the latter, easy enough to do a `respond_to?(:to_ruby)` check?\n. `Hamster.to_ruby(obj)` works for me, but needs a major version bump coz it's backwards incompatible to remove the `to_ruby` methods. (Not sure what your release policy/cadence is...)\n. I don't have any free time until the weekend, if it's not done by then I'll have a look :)\n. we need to have non-core extensions equivalents of all of our monkey-patches, so users can opt not to include core extensions.\n. what @alexdowad said. I'd lean towards 1 or 2 (though as you said, maybe not much we can do there), 3 makes me nervous.\n. fix incoming\n. that might need to get pulled out of shared specs then, since `\"A\" != \"a\"`\n. sure, not going to get to this for a few days though.\n. ",
    "eigenhombre": "Here is the failing test:\n\n```\nit \"keeps the first of each group of duplicate values\" do\n  x, y, z = 'a', 'a', 'a'\n  result = Hamster.vector(x, y, z).uniq\n  result.size.should == 1\n  result[0].should be(x)\nend\n```\n\n@alexdowad -- Do we care about the \"first\" value (identity semantics), or just that only one of the equal values is returned (equality semantics)?  If you look at the failing test, equality succeeds, but not identity.\n. Here is the failing test:\n\n```\nit \"keeps the first of each group of duplicate values\" do\n  x, y, z = 'a', 'a', 'a'\n  result = Hamster.vector(x, y, z).uniq\n  result.size.should == 1\n  result[0].should be(x)\nend\n```\n\n@alexdowad -- Do we care about the \"first\" value (identity semantics), or just that only one of the equal values is returned (equality semantics)?  If you look at the failing test, equality succeeds, but not identity.\n. ",
    "rrrene": "Yeah, the shields.io integration of inch-ci.org was briefly [discussed here](https://github.com/inch-ci/inch_ci-web/issues/19).\n\nIn the meantime: If you are shopping for flat-style badges, those are supported by Inch CI as well:\n\nFlat: [![Inline docs](http://inch-ci.org/github/hamstergem/hamster.svg?branch=master&style=flat)](http://inch-ci.org/github/hamstergem/hamster) Flat square: [![Inline docs](http://inch-ci.org/github/hamstergem/hamster.svg?branch=master&style=flat-square)](http://inch-ci.org/github/hamstergem/hamster)\n. Yeah, the shields.io integration of inch-ci.org was briefly [discussed here](https://github.com/inch-ci/inch_ci-web/issues/19).\n\nIn the meantime: If you are shopping for flat-style badges, those are supported by Inch CI as well:\n\nFlat: [![Inline docs](http://inch-ci.org/github/hamstergem/hamster.svg?branch=master&style=flat)](http://inch-ci.org/github/hamstergem/hamster) Flat square: [![Inline docs](http://inch-ci.org/github/hamstergem/hamster.svg?branch=master&style=flat-square)](http://inch-ci.org/github/hamstergem/hamster)\n. ",
    "egnech": "It just output that file not found\n`LoadError: cannot load such file -- hamster`\n. Yes, i try this. v0.4.3 is works fine, in all cases. \nBut I need v1.0.\n. Yep, `bundle exec` - and it works. Thx. \nWhen you plans to realise?\n. Thx for your assistance!\n. It just output that file not found\n`LoadError: cannot load such file -- hamster`\n. Yes, i try this. v0.4.3 is works fine, in all cases. \nBut I need v1.0.\n. Yep, `bundle exec` - and it works. Thx. \nWhen you plans to realise?\n. Thx for your assistance!\n. ",
    "rubycoder": "I realize this has been fixed in github, I just wanted to point out that Windows users doing gem install will encounter a problem.\n. I realize this has been fixed in github, I just wanted to point out that Windows users doing gem install will encounter a problem.\n. ",
    "joelmccracken": "That sounds fine. I was thinking about using hash anyway -- so, great. \n\nSent from my iPhone\n\n> On Dec 6, 2014, at 10:43 AM, Alex Dowad notifications@github.com wrote:\n> \n> Do you think that an existing Hamster structure, like the immutable Hash, might help you implement your immutable struct? If so, you could write your own library which relies on Hamster.\n> \n> In any case, I think the relationship between an immutable struct and the existing Hamster structures is weak, and it would be better to write a separate library. Small is beautiful. Adding more features bloats both code size (making the library harder to maintain) and the documentation (making it harder to learn). If those new features have some inherent synergy with the existing features, if they combine in ways that makes the whole larger than the sum of its parts, then putting them together may be a good tradeoff. Otherwise, let them go their separate ways.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Indeed; this was my main motivation for suggesting adding a Struct class, and not just using immutable_struct. I want some nice methods that will return new, slightly different structs.\n. depends upon how their gemfile is set up. if they use ~> 1.0, as it says in\nthe readme, then they'll be upgraded.\n\nIf this works correctly upstream, then I wouldn't worry about it. I hacked\naround the problem for the time being.\n\nOn Fri, Dec 26, 2014 at 12:43 AM, Alex Dowad notifications@github.com\nwrote:\n\n> Just thinking about that some more... we have already broken backward\n> compatibility with 0.4.3. Would releasing 0.9.0 mean that some people\n> unintentionally get upgraded when they bundle upgrade, thus breaking\n> their code?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/163#issuecomment-68124699.\n. I'm just using it for a game I'm working on :) But sure, I'll do that.\n\nOn Fri, Dec 26, 2014 at 6:05 AM, Alex Dowad notifications@github.com\nwrote:\n\n> @joelmccracken https://github.com/joelmccracken, we have a _ton_ of bug\n> fixes, performance upgrades, and enhancements of every kind in edge\n> hamster. The biggest thing remaining before we ship 1.0.0 is (this)[#128\n> https://github.com/hamstergem/hamster/issues/128]. Since it seems that\n> you are using Hamster for \"real\" work, would you be willing to upgrade to\n> edge and see how it works for you?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/163#issuecomment-68136119.\n. That sounds fine. I was thinking about using hash anyway -- so, great. \n\nSent from my iPhone\n\n> On Dec 6, 2014, at 10:43 AM, Alex Dowad notifications@github.com wrote:\n> \n> Do you think that an existing Hamster structure, like the immutable Hash, might help you implement your immutable struct? If so, you could write your own library which relies on Hamster.\n> \n> In any case, I think the relationship between an immutable struct and the existing Hamster structures is weak, and it would be better to write a separate library. Small is beautiful. Adding more features bloats both code size (making the library harder to maintain) and the documentation (making it harder to learn). If those new features have some inherent synergy with the existing features, if they combine in ways that makes the whole larger than the sum of its parts, then putting them together may be a good tradeoff. Otherwise, let them go their separate ways.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Indeed; this was my main motivation for suggesting adding a Struct class, and not just using immutable_struct. I want some nice methods that will return new, slightly different structs.\n. depends upon how their gemfile is set up. if they use ~> 1.0, as it says in\nthe readme, then they'll be upgraded.\n\nIf this works correctly upstream, then I wouldn't worry about it. I hacked\naround the problem for the time being.\n\nOn Fri, Dec 26, 2014 at 12:43 AM, Alex Dowad notifications@github.com\nwrote:\n\n> Just thinking about that some more... we have already broken backward\n> compatibility with 0.4.3. Would releasing 0.9.0 mean that some people\n> unintentionally get upgraded when they bundle upgrade, thus breaking\n> their code?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/163#issuecomment-68124699.\n. I'm just using it for a game I'm working on :) But sure, I'll do that.\n\nOn Fri, Dec 26, 2014 at 6:05 AM, Alex Dowad notifications@github.com\nwrote:\n\n> @joelmccracken https://github.com/joelmccracken, we have a _ton_ of bug\n> fixes, performance upgrades, and enhancements of every kind in edge\n> hamster. The biggest thing remaining before we ship 1.0.0 is (this)[#128\n> https://github.com/hamstergem/hamster/issues/128]. Since it seems that\n> you are using Hamster for \"real\" work, would you be willing to upgrade to\n> edge and see how it works for you?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/163#issuecomment-68136119.\n. ",
    "xbeta": "@dubek thanks for the explanation, but what's stopping one thread `push()` and another thread `pop()` at the same time in a concurrency world?\n\n``` ruby\ndef initialize()\n  @nums = Hamster::Deque.new()\nend\n..\ndef add(num)\n   # because hamster's deque is immutable\n   @nums = @nums.push(num)\nend\n```\n. @dubek thanks for the explanation, but what's stopping one thread `push()` and another thread `pop()` at the same time in a concurrency world?\n\n``` ruby\ndef initialize()\n  @nums = Hamster::Deque.new()\nend\n..\ndef add(num)\n   # because hamster's deque is immutable\n   @nums = @nums.push(num)\nend\n```\n. ",
    "elben": "@krainboltgreene two other problem with `to_hash`:\n- It's not a unified interface across all the Hamster collections\u2014we would need `Hamster::Vector#to_a`, `Hamster::Set#to_set` (?).\n- It may be expensive, depending on how deep the object is. I'm not sure what user expectations are on a method called `to_hash`.\n\nThe `json` module, however, mixes in `Object#to_json`. Maybe Hamster we can do `Hamster::Hash#to_mutable` (and the rest).\n\n@alexdowad on top of the alternative above, what about `Hamster.to_mutable`.\n. Would you still consider the class method `Hamster.to_mutable` to be a good idea? Three good points I see about this are:\n1. Symmetry with `Hamster.from`.\n2. Accepts any `Hamster` object.\n3. The instance method way (to_set/to_h/to_a) can be implemented by calling `Hamster.to_mutable`.\n\nOtherwise, I can implement the to_x methods individually in each class.\n. Also, the Travis CI build fails on ruby-head with what seems to be an interpreter bug. Know anything about this?\n\nhttps://travis-ci.org/hamstergem/hamster/jobs/54632445#L3490\n. From [immutable.js](https://github.com/facebook/immutable-js/blob/master/README.md):\n\nAll immutable Iterables can be converted to plain JavaScript Arrays and Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`. All Immutable Iterables also implement `toJSON()` allowing them to be passed to `JSON.stringify` directly.\n\n``` js\nvar deep = Immutable.Map({ a: 1, b: 2, c: Immutable.List.of(3, 4, 5) });\ndeep.toObject() // { a: 1, b: 2, c: List [ 3, 4, 5 ] }\ndeep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]\ndeep.toJS() // { a: 1, b: 2, c: [ 3, 4, 5 ] }\nJSON.stringify(deep) // '{\"a\":1,\"b\":2,\"c\":[3,4,5]}'\n```\n\n---\n\nIf we implemented `to_mutable` on each collection, that would result in a similar API (other than supporting `to_json`).\n\nI don't have a strong opinion on the name, but `to_ruby` isn't a bad alternative to `to_mutable`.\n. Let me know what you think about these latest commits.\n\n``` ruby\nh=Hamster::Hash[\n  \"a\" => 1,\n  \"b\" => Hamster::Vector[2, Hamster::Hash[\"c\" => 3], 4],\n  \"d\" => Hamster::Set[5, 6, 7],\n  \"e\" => Hamster::Hash[\"f\" => 8, \"g\" => 9],\n  \"h\" => Regexp.new(\"ijk\"),\n  \"l\" => Hamster::SortedSet.new([1, 2, 3])]\n\nh.to_ruby\n# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n\nHamster.to_ruby(h)\n# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n```\n. I don't like the `Class[]` style either\u2014very confusing. This was copy-pasted from a previous test ;).\n. Makes sense. I do like being able to paste the print syntax as code.\nHomoiconicity!\n\nLet me know if there's anything else I can do for this PR.\nOn Wed, Mar 18, 2015 at 12:54 AM Alex Dowad notifications@github.com\nwrote:\n\n> A couple comments on the Class[] syntax: it was chosen for symmetry with\n> Ruby's built-in Hash[], Array[], and Set[]. (If you didn't know about\n> these before, try them in irb!)\n> \n> Previously, a Hamster Hash used the same print syntax as a Ruby Hash. If\n> you use both in the same program, this meant that when printing things in\n> irb or using debug print statements, you couldn't tell which was which.\n> Also, the print syntax could not be eval'ed to get an equivalent\n> structure.\n> \n> The primary disadvantage of the current print syntax is its verbosity. If\n> we could extend Ruby core syntax and add our own data structure literals,\n> that would be better, but it's not possible (not unless immutable data\n> structures were merged into the Ruby interpreter itself).\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82758447.\n. Here's a question, what should this do:\n\n``` ruby\nHamster.from({a: :b, c: Hamster.vector(1, 2, {})})\n# Currently returns:\n# => Hamster::Hash[:a => :b, :c => Hamster::Vector[1, 2, {}]] \n#\n# But should it be:\n# => Hamster::Hash[:a => :b, :c => Hamster::Vector[1, 2, Hamster::EmptyHash]] \n```\n\n`to_ruby` also has this problem in the inverse.\n. Thanks!\n\nWhat is your workflow for such surgical commit blob modifications? My slow method to fix the dangling `require \"hamster/sorted_set\"` would have been to:\n- Create new commit that removes the require. Rebase with existing commit that didn't need the require.\n- Create new commit that re-adds the require. Rebase with sorted_set commit.\n. Good point on the generalized form.\n\nPreserving the chaining-style is also difficult unless the transformation methods are in the object itself, due to how Ruby OO ties data to its interface.\n\nIn Scala, we can first build a `Seq[Option[T]]`, then convert to a `Map`, ignoring all the `None` values. This doesn't seem practical here.\n\nIf I wanted to do this with the chaining-style, but via a mechanism outside of Hamster itself, I can't think of a way to do it without building my own chainable thing. Hence why it may make sense to allow it in Hamster.\n\nAnyways, feel free to close this\u2014I was just pondering a better way.\n. @dubek you're right that works.\n\n@alexdowad agreed, we shouldn't be adding new methods to the API w/o being sure of its usefulness. I think your `if` idea is interesting and would work with everything, but it feels a bit odd to basically write a backwards if statement just to get chaining. (Of course, this goes against my original idea, but hopefully this discussion sparks something useful.)\n\nIn languages where immutability is default, other data around you is immutable, so the code is structured to make transformation of immutable structures easier. In Ruby, I found it very awkward to \"add\" immutable data to a module full of mutation, because the structure is already very mutable.\n\nFor example, I found myself doing this a lot:\n\n``` ruby\nh = Hamster::Hash.empty\n\n... lots of mutations ...\n\nif condition_based_off_above_mutation\n  h = h.put(...)\nend\n\n.. more mutations ...\n\nh = h.whatever\n```\n\nAt this point, there is no win for using \"immutable\" data structures\u2014you're now mutating the pointer!\n. @krainboltgreene two other problem with `to_hash`:\n- It's not a unified interface across all the Hamster collections\u2014we would need `Hamster::Vector#to_a`, `Hamster::Set#to_set` (?).\n- It may be expensive, depending on how deep the object is. I'm not sure what user expectations are on a method called `to_hash`.\n\nThe `json` module, however, mixes in `Object#to_json`. Maybe Hamster we can do `Hamster::Hash#to_mutable` (and the rest).\n\n@alexdowad on top of the alternative above, what about `Hamster.to_mutable`.\n. Would you still consider the class method `Hamster.to_mutable` to be a good idea? Three good points I see about this are:\n1. Symmetry with `Hamster.from`.\n2. Accepts any `Hamster` object.\n3. The instance method way (to_set/to_h/to_a) can be implemented by calling `Hamster.to_mutable`.\n\nOtherwise, I can implement the to_x methods individually in each class.\n. Also, the Travis CI build fails on ruby-head with what seems to be an interpreter bug. Know anything about this?\n\nhttps://travis-ci.org/hamstergem/hamster/jobs/54632445#L3490\n. From [immutable.js](https://github.com/facebook/immutable-js/blob/master/README.md):\n\nAll immutable Iterables can be converted to plain JavaScript Arrays and Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`. All Immutable Iterables also implement `toJSON()` allowing them to be passed to `JSON.stringify` directly.\n\n``` js\nvar deep = Immutable.Map({ a: 1, b: 2, c: Immutable.List.of(3, 4, 5) });\ndeep.toObject() // { a: 1, b: 2, c: List [ 3, 4, 5 ] }\ndeep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]\ndeep.toJS() // { a: 1, b: 2, c: [ 3, 4, 5 ] }\nJSON.stringify(deep) // '{\"a\":1,\"b\":2,\"c\":[3,4,5]}'\n```\n\n---\n\nIf we implemented `to_mutable` on each collection, that would result in a similar API (other than supporting `to_json`).\n\nI don't have a strong opinion on the name, but `to_ruby` isn't a bad alternative to `to_mutable`.\n. Let me know what you think about these latest commits.\n\n``` ruby\nh=Hamster::Hash[\n  \"a\" => 1,\n  \"b\" => Hamster::Vector[2, Hamster::Hash[\"c\" => 3], 4],\n  \"d\" => Hamster::Set[5, 6, 7],\n  \"e\" => Hamster::Hash[\"f\" => 8, \"g\" => 9],\n  \"h\" => Regexp.new(\"ijk\"),\n  \"l\" => Hamster::SortedSet.new([1, 2, 3])]\n\nh.to_ruby\n# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n\nHamster.to_ruby(h)\n# => {\"d\"=>#<Set: {6, 7, 5}>, \"b\"=>[2, {\"c\"=>3}, 4], \"h\"=>/ijk/, \"a\"=>1, \"e\"=>{\"f\"=>8, \"g\"=>9}, \"l\"=>#<SortedSet: {1, 2, 3}>}\n```\n. I don't like the `Class[]` style either\u2014very confusing. This was copy-pasted from a previous test ;).\n. Makes sense. I do like being able to paste the print syntax as code.\nHomoiconicity!\n\nLet me know if there's anything else I can do for this PR.\nOn Wed, Mar 18, 2015 at 12:54 AM Alex Dowad notifications@github.com\nwrote:\n\n> A couple comments on the Class[] syntax: it was chosen for symmetry with\n> Ruby's built-in Hash[], Array[], and Set[]. (If you didn't know about\n> these before, try them in irb!)\n> \n> Previously, a Hamster Hash used the same print syntax as a Ruby Hash. If\n> you use both in the same program, this meant that when printing things in\n> irb or using debug print statements, you couldn't tell which was which.\n> Also, the print syntax could not be eval'ed to get an equivalent\n> structure.\n> \n> The primary disadvantage of the current print syntax is its verbosity. If\n> we could extend Ruby core syntax and add our own data structure literals,\n> that would be better, but it's not possible (not unless immutable data\n> structures were merged into the Ruby interpreter itself).\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/pull/166#issuecomment-82758447.\n. Here's a question, what should this do:\n\n``` ruby\nHamster.from({a: :b, c: Hamster.vector(1, 2, {})})\n# Currently returns:\n# => Hamster::Hash[:a => :b, :c => Hamster::Vector[1, 2, {}]] \n#\n# But should it be:\n# => Hamster::Hash[:a => :b, :c => Hamster::Vector[1, 2, Hamster::EmptyHash]] \n```\n\n`to_ruby` also has this problem in the inverse.\n. Thanks!\n\nWhat is your workflow for such surgical commit blob modifications? My slow method to fix the dangling `require \"hamster/sorted_set\"` would have been to:\n- Create new commit that removes the require. Rebase with existing commit that didn't need the require.\n- Create new commit that re-adds the require. Rebase with sorted_set commit.\n. Good point on the generalized form.\n\nPreserving the chaining-style is also difficult unless the transformation methods are in the object itself, due to how Ruby OO ties data to its interface.\n\nIn Scala, we can first build a `Seq[Option[T]]`, then convert to a `Map`, ignoring all the `None` values. This doesn't seem practical here.\n\nIf I wanted to do this with the chaining-style, but via a mechanism outside of Hamster itself, I can't think of a way to do it without building my own chainable thing. Hence why it may make sense to allow it in Hamster.\n\nAnyways, feel free to close this\u2014I was just pondering a better way.\n. @dubek you're right that works.\n\n@alexdowad agreed, we shouldn't be adding new methods to the API w/o being sure of its usefulness. I think your `if` idea is interesting and would work with everything, but it feels a bit odd to basically write a backwards if statement just to get chaining. (Of course, this goes against my original idea, but hopefully this discussion sparks something useful.)\n\nIn languages where immutability is default, other data around you is immutable, so the code is structured to make transformation of immutable structures easier. In Ruby, I found it very awkward to \"add\" immutable data to a module full of mutation, because the structure is already very mutable.\n\nFor example, I found myself doing this a lot:\n\n``` ruby\nh = Hamster::Hash.empty\n\n... lots of mutations ...\n\nif condition_based_off_above_mutation\n  h = h.put(...)\nend\n\n.. more mutations ...\n\nh = h.whatever\n```\n\nAt this point, there is no win for using \"immutable\" data structures\u2014you're now mutating the pointer!\n. ",
    "roryokane": "You can `require 'concurrent/atomics'` to load only atomic and thread synchronization classes. The whole `concurrent` gem will still have to be downloaded, but at least most of it won\u2019t be loaded at runtime.\n. You can `require 'concurrent/atomics'` to load only atomic and thread synchronization classes. The whole `concurrent` gem will still have to be downloaded, but at least most of it won\u2019t be loaded at runtime.\n. ",
    "davejacobs": "Awesome! Do you plan to push this out to RubyGems soon?\n. Awesome! Do you plan to push this out to RubyGems soon?\n. ",
    "rcabralc": "I think it would be desirable that the behavior followed `Array#sort_by`. Less surprising, and a better option for expensive key computations, since currently there's no difference in using #sort or #sort_by for such keys. Then, the docs are fine.\n. I think it would be desirable that the behavior followed `Array#sort_by`. Less surprising, and a better option for expensive key computations, since currently there's no difference in using #sort or #sort_by for such keys. Then, the docs are fine.\n. ",
    "no-reply": "@alexdowad I'm not sure if you want to revisit this yet, but I was playing with this while working on some benchmarks in a downstream project and pushed up [a branch](https://github.com/hamstergem/hamster/compare/core...no-reply:use-yield).\n\nI wasn't able to confirm that this has a real impact on performance (my `benchmark/ips` results vary too much), but raw calls to `block.call` do still seem as much as 4x slower than `yield` on Ruby 2.3.1.\n. @dubek :+1: My branch linked above now has a much more complete (if somewhat slapdash) rework of `&block` usage throughout.\n\nI'll open a new PR so the discussion can happen somewhere other than the bottom of a closed ticket.\n. Just saw this and wanted to put a word in for pure Ruby options.\n\nThe Ruby RDF core is moving to `Hamster` for its in-memory data storage in its 2.0 release (see the [release notes](https://github.com/ruby-rdf/rdf/releases/tag/2.0.0.beta1)), and is strongly invested in remaining pure Ruby.\n\nObviously, if the advantages promised in the paper materialize, we are :+1: to an optional C extension and/or `bit-twiddle` with a Ruby-only option.\n. Generally, it's possible for a repository owner to trigger a rebuild in Travis.\n\nIn this case, I think we could expect another failure; the failing tests in this PR are due to a bug in the version of Bundler Travis is using for those builds. The issue is fixed by dff86bb43be.\n\nA rebase and force push might be the best move.\n. These errors seem connected to the version of RubyGems/bundler pairing used. See https://github.com/bundler/bundler/issues/3558\n\nI pushed a change to force an upgrade to both. \n\nIf the upgraded `.travis.yml` should be a separate PR, let me know. I'm happy to split it out.\n. The `jruby-head` build is still broken after dff86bb. I'm not going to worry about it, since it's an allowed failure and probably a jruby and/or bundler problem.\n. Withdrawing, since Travis doesn't find a Ruby 2.3 binary. Probably there is some easy fix for this, but it's a saturday. :)\n. Merged by #230\n. Failed with \"horrendously bad performance\" on JRuby. I imagine this is just a quirk of the test run.\n\n:roller_coaster:\n. @dubek I'd be happy to throw together a PR in the next few days to add this to `Hamster::Vector`. \n\nI gave the other data structures a quick look, and it seems like `Vector` is the only one other than `Hash` that needs this. I'll also look for other places it would be useful to raise errors that call out differences from the core Ruby APIs.\n. This is failing on Rubinius 3.29 in CI. I can't repeat the failure with 3.30  At a glance, this looks like a bug in 3.29.\n\nI can't install 3.29 locally due to LLVM incompatibilities; but might be able to look into it another time. We should evaluate this more thoroughly before moving forward.\n. @alexdowad I'm not sure if you want to revisit this yet, but I was playing with this while working on some benchmarks in a downstream project and pushed up [a branch](https://github.com/hamstergem/hamster/compare/core...no-reply:use-yield).\n\nI wasn't able to confirm that this has a real impact on performance (my `benchmark/ips` results vary too much), but raw calls to `block.call` do still seem as much as 4x slower than `yield` on Ruby 2.3.1.\n. @dubek :+1: My branch linked above now has a much more complete (if somewhat slapdash) rework of `&block` usage throughout.\n\nI'll open a new PR so the discussion can happen somewhere other than the bottom of a closed ticket.\n. Just saw this and wanted to put a word in for pure Ruby options.\n\nThe Ruby RDF core is moving to `Hamster` for its in-memory data storage in its 2.0 release (see the [release notes](https://github.com/ruby-rdf/rdf/releases/tag/2.0.0.beta1)), and is strongly invested in remaining pure Ruby.\n\nObviously, if the advantages promised in the paper materialize, we are :+1: to an optional C extension and/or `bit-twiddle` with a Ruby-only option.\n. Generally, it's possible for a repository owner to trigger a rebuild in Travis.\n\nIn this case, I think we could expect another failure; the failing tests in this PR are due to a bug in the version of Bundler Travis is using for those builds. The issue is fixed by dff86bb43be.\n\nA rebase and force push might be the best move.\n. These errors seem connected to the version of RubyGems/bundler pairing used. See https://github.com/bundler/bundler/issues/3558\n\nI pushed a change to force an upgrade to both. \n\nIf the upgraded `.travis.yml` should be a separate PR, let me know. I'm happy to split it out.\n. The `jruby-head` build is still broken after dff86bb. I'm not going to worry about it, since it's an allowed failure and probably a jruby and/or bundler problem.\n. Withdrawing, since Travis doesn't find a Ruby 2.3 binary. Probably there is some easy fix for this, but it's a saturday. :)\n. Merged by #230\n. Failed with \"horrendously bad performance\" on JRuby. I imagine this is just a quirk of the test run.\n\n:roller_coaster:\n. @dubek I'd be happy to throw together a PR in the next few days to add this to `Hamster::Vector`. \n\nI gave the other data structures a quick look, and it seems like `Vector` is the only one other than `Hash` that needs this. I'll also look for other places it would be useful to raise errors that call out differences from the core Ruby APIs.\n. This is failing on Rubinius 3.29 in CI. I can't repeat the failure with 3.30  At a glance, this looks like a bug in 3.29.\n\nI can't install 3.29 locally due to LLVM incompatibilities; but might be able to look into it another time. We should evaluate this more thoroughly before moving forward.\n. ",
    "Bill": "Sorry I closed this because I thought I'd put it against the wrong branch. But `master` is right.\n. Thank you for Hamster!\n\nNow add comprehensions please.\n. Well @alexdowad used the wrong term there. As you say, comprehensions are nice. But what I had in mind was actually `assoc-in`. The family `assoc-in`, `update-in` and `dissoc-in` let us modify collections and collections of collections.\n\nThe `assoc-in` family is cool. And in researching it, I've found an interesting set of even more powerful transformation functions (mini-languages really). **Instar** is a really good example:\n\nhttps://github.com/boxed/instar/\n\nIt not only unifies the `assoc-in` family under a single `transform` function, it also provides a \"[capture groups](https://github.com/boxed/instar/#capture-groups)\" feature that lets you tag places in your structure and then get at that tagged content in your transformation function.\n\nThis wouldn't need to be part of Hamster of course. But I thought you might find it interesting.\n. Ahem, well, forgive me for being a Hamster noob. `Vector#update_in` and `Hash#update_in` look like they do exactly what I want.\n\nOn the other hand, it is kind of anomalous that the code for those two methods is identical. Coming from Clojure-land I didn't think to look in the individual classes for the function since the function operates on both types. Rather than maintaining two copies of the exact same code, I wonder if it would be worthwhile to factor those out. Maybe:\n\n```\nmodule Hamster\n  def update_in(c,*key_path, &block)\n    if key_path.empty?\n      raise ArgumentError, \"must have at least one key in path\"\n    end\n    key = key_path[0]\n    if key_path.size == 1\n      new_value = block.call(c.get(key))\n    else\n      value = c.fetch(key, EmptyHash)\n      new_value = update_in(value,*key_path[1..-1], &block)\n    end\n    c.put(key, new_value)\n  end\n  module_function :update_in\nend\n```\n\nIt would also allow us to have a single spec instead of the two specs.\n\nI just noticed that there is no `Vector#put`. Currently `Vector#update_in` calls `set`. It looks like `Vector#set` could be renamed `Vector#put` since it does the same thing to the Vector that `Hash#put` does to a Hash.\n\nDid I get that right?\n. I refined my proposal from yesterday. See above.\n. Yeah @dubek there is a tension here. I now see that `Vector` and `Hash` use `Enumerable`'s `sort` and `sort_by`. So if we did similarly for `update_in` we might stick it in a module and then include that module in both `Hash` and `Array`. Then a single update_in_spec could test various nested structures.\n\nThat would be an improvement. That, plus updating the README to prominently feature `update_in` because it's a killer feature.\n\nOn the other hand, the mutual recursion of such a solution seems kind of hokey to me. Hashes messaging Arrays messaging Hashes\u2026 I buy in to Rich Hickey's argument about separation of function from structure and I think this is a prime example. But I'm all for improvement over perfection.\n. I'll do it @alexdowad !\n. BTW `update_in()` didn't really do exactly what I originally wanted (in my app). I ended up implementing my own beefed-up version of `update_in()` (called `update_having()`) and the whole thing is described over here:\n\nhttp://memerocket.com/2015/11/01/hamstar-transforms-immutable-ruby-collections-better/\n\nSuper fun. And thanks especially to @alexdowad for all the help!\n. > Nice post.\n\nThanks @dubek.\n\n> Your new module name is really confusing...\n\nIndeed. It is kind of cutesy and perhaps too close to \"Hamster\". Then again, it is just defining a single function, so naming it in relation to Hamster might not be unwarranted.\n\n> \u2026you might want to support procs/lambdas\u2026\n\nIndubitably. The latest version, v0.0.4 adds `Proc` matcher support. Thanks for the suggestion. The implementation of association matching isn't quite as clean (yet) but it's getting there.\n. There, now it's cleaned up in v0.0.7. The `Proc` no longer requires the superfluous third parameter.\n. Did this happen?\n. goodun\n. Sorry I wasn't paying attention. But I notice that `Struct#to_h` is in Backports https://github.com/marcandre/backports\n. For (2) maybe for \"hashyness\" we just check `obj.respond_to(:to_h)` first and if that's truthy then we call to_h on it and convert the result to a `Hamster::Hash` otherwise we check\u2026\n\nThe what comes next part is tricky. It feels like we'd want to check for \"sorted setiness\" and \"setiness\" next. But `SortedSet` defines no new public methods at all (it inherits from `Set`). So approach (2) can't differentiate `SortedSets` from `Sets`.\n\nAnd there are other problems with (2). If we could get past `Set` and `SortedSet` I think the next thing we'd learn is that we had create a big, brittle, difficult to understand glob of code.\n\nMy early intuition is that (2) is probably a loser.\n. @alexdowad I've never used YARD before. When I ran `rake yard` the output led me to believe that it wasn't meant to be run locally. What is the process for generating and viewing the doc?\n. Woopsie: I had failed to save an update to the new example in the README. Added a commit.\n. You're welcome @alexdowad. That was fun.\n. Great @dubek. I agree on all counts and will be more diligent in the future to make PRs that are more focused. Thanks for stepping up to clean this up for me.\n. d'oh. Thank you @alexdowad!!\n. Here is an ugly little start perhaps:\n\n``` ruby\nclass Object\n def chain_conditionally( cond, meth, *args, &block)\n  if cond\n    send meth, *args, &block\n  else\n    self\n  end\nend\n\n'abc'.chain_conditionally(false, :+, 'd').chain_conditionally(true, :+, 'e')\n => \"abce\" \n```\n\nWith that, @elben's example could look like:\n\n``` ruby\nrequire 'hamster'\ncondition1 = false\ncondition2 = true\nHamster.from({}).put(:abc,1).chain_conditionally(condition1, :put, :foo, :bar).chain_conditionally(condition2, :put, :xyz, 123)\n => Hamster::Hash[:xyz => 123, :abc => 1] \n```\n\nMy distaste for `chain_conditionally` as presented may stem from it's object-orientedness. That gives rise to the three method parameters: `meth, *args, &block` where I might just like to take a closure. I feel like a closure would make for more readable code.\n\nOn the other hand, `chain_conditionally` is easy for most Ruby programmers to understand. It's just not all that composable, and I don't know if we've achieved improved readability versus @elben's original code. On the upside though, we eliminated the need for the (mutable) reference `hash`.\n\nI think that if we want to go further and explore better approaches, there is gold here:\n1. combinators in Ruby http://combinators.info/\n2. String#to_proc for clean lambda syntax http://weblog.raganwald.com/2007/10/stringtoproc.html\n\nIt all depends on how far down the functional rabbit hole we choose to go.\n\nSincerely,\n\"No More Ruby\" Bill\n. > > \"No More Ruby\" Bill\r\n> > I hope Hamster hasn't turned you off Ruby! Maybe there is another language which works better for your purposes?\r\n\r\nHamster is the only thing keeping me here (for a while longer) @alexdowad.\r\n\r\nThe `chain_conditionally` I offered is ugly because it turns code like this:\r\n\r\n`hash.put(:foo,:bar) if condition1`\r\n\r\nInto code like this:\r\n\r\n`hash.chain_conditionally(condition1, :put, :foo, :bar)`\r\n\r\nHow about if we had a method called `when` that would take a condition and if the condition were truthy, would return self but if it were falsy would return an object, which, no matter what message you sent it, always returned self, to wit:\r\n\r\n``` ruby\r\nclass NoOp < BasicObject\r\n  def initialize(target); @target = target; end\r\n  def respond_to_missing?(method, *)\r\n    @target.respond_to?(sym)\r\n  end\r\n  def method_missing(sym, *args, &block)\r\n    if @target.respond_to?(sym)\r\n      @target \r\n    else\r\n      # let target raise the MethodMIssing error\r\n      @target.send sym, *args, &block\r\n    end\r\n  end\r\nend\r\n\r\nclass Object\r\n  def when( cond)\r\n    if cond\r\n      self\r\n    else\r\n      NoOp.new(self)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWith `when` we can do this:\r\n\r\n`Hamster.from({}).put(:abc,1).when(false).put(:foo, :bar).when(true).put(:xyz, 123)`\r\n\r\nThe `NoOp` class seems to be related to `tap`/`returning` which in turn are related to the K (Kestrel) combinators described in http://combinators.info/#kestrels.\r\n\r\nI gotta observe here though that it feels like (once again) straddling OO design and functional design results in kind of a mess. At a minimum there is a lot to understand here. Take for example my reference to the K combinator. What does it really mean to call `tap` or `returning` K combinators? Well I think it means that you can think of those _methods_ like functions with a hidden first parameter, `self`. And if you do that then they certainly behave like K combinators: regardless of what other parameters you send, they always return the first parameter (`self`), possibly with side effects.\r\n\r\nWhat does it mean to say that `NoOp` is like a K combinator. Well that's pretty loose talk. What I should say is that a `NoOp` object is an object with the same methods (functions) as the target object. But each of the methods (functions) is converted into a K combinator with no side effects: a \"no-op\". Viewed this way, the `NoOp` constructor is a tool for creating families of K combinators. Each `NoOp` you construct makes a family of K combinators corresponding to the family of functions (methods) of the target object. Those K combinators become the methods of the newly constructed object. In Object terms that new object in some ways has the same identity as the original one because each of its methods returns the original object.\r\n\r\n@elben you could use this `when` to give you conditional, chained invocation of any method on any object (not just `put` on `Hash`).\r\n\r\n**update 12/8/2015**: I made `NoOp` generate `NoMethodError` if you invoke a method not defined on the target object. That was my original intention, but the original code didn't do that.\r\n\r\n**update 5/29/2017**: All that talk about K combinators above is based on a long-held misunderstanding of K combinators. [These Are Not the K Combinators You Are Looking For](http://memerocket.com/2017/05/25/these-are-not-the-k-combinators-you-are-looking-for). This is a good idea. I was surprised a week or so ago, when I found no `[]=` method on a Hamster Hash object. I thought I'd done something wrong until I went and confirmed my suspicion in the source code.\n. Sorry I closed this because I thought I'd put it against the wrong branch. But `master` is right.\n. Thank you for Hamster!\n\nNow add comprehensions please.\n. Well @alexdowad used the wrong term there. As you say, comprehensions are nice. But what I had in mind was actually `assoc-in`. The family `assoc-in`, `update-in` and `dissoc-in` let us modify collections and collections of collections.\n\nThe `assoc-in` family is cool. And in researching it, I've found an interesting set of even more powerful transformation functions (mini-languages really). **Instar** is a really good example:\n\nhttps://github.com/boxed/instar/\n\nIt not only unifies the `assoc-in` family under a single `transform` function, it also provides a \"[capture groups](https://github.com/boxed/instar/#capture-groups)\" feature that lets you tag places in your structure and then get at that tagged content in your transformation function.\n\nThis wouldn't need to be part of Hamster of course. But I thought you might find it interesting.\n. Ahem, well, forgive me for being a Hamster noob. `Vector#update_in` and `Hash#update_in` look like they do exactly what I want.\n\nOn the other hand, it is kind of anomalous that the code for those two methods is identical. Coming from Clojure-land I didn't think to look in the individual classes for the function since the function operates on both types. Rather than maintaining two copies of the exact same code, I wonder if it would be worthwhile to factor those out. Maybe:\n\n```\nmodule Hamster\n  def update_in(c,*key_path, &block)\n    if key_path.empty?\n      raise ArgumentError, \"must have at least one key in path\"\n    end\n    key = key_path[0]\n    if key_path.size == 1\n      new_value = block.call(c.get(key))\n    else\n      value = c.fetch(key, EmptyHash)\n      new_value = update_in(value,*key_path[1..-1], &block)\n    end\n    c.put(key, new_value)\n  end\n  module_function :update_in\nend\n```\n\nIt would also allow us to have a single spec instead of the two specs.\n\nI just noticed that there is no `Vector#put`. Currently `Vector#update_in` calls `set`. It looks like `Vector#set` could be renamed `Vector#put` since it does the same thing to the Vector that `Hash#put` does to a Hash.\n\nDid I get that right?\n. I refined my proposal from yesterday. See above.\n. Yeah @dubek there is a tension here. I now see that `Vector` and `Hash` use `Enumerable`'s `sort` and `sort_by`. So if we did similarly for `update_in` we might stick it in a module and then include that module in both `Hash` and `Array`. Then a single update_in_spec could test various nested structures.\n\nThat would be an improvement. That, plus updating the README to prominently feature `update_in` because it's a killer feature.\n\nOn the other hand, the mutual recursion of such a solution seems kind of hokey to me. Hashes messaging Arrays messaging Hashes\u2026 I buy in to Rich Hickey's argument about separation of function from structure and I think this is a prime example. But I'm all for improvement over perfection.\n. I'll do it @alexdowad !\n. BTW `update_in()` didn't really do exactly what I originally wanted (in my app). I ended up implementing my own beefed-up version of `update_in()` (called `update_having()`) and the whole thing is described over here:\n\nhttp://memerocket.com/2015/11/01/hamstar-transforms-immutable-ruby-collections-better/\n\nSuper fun. And thanks especially to @alexdowad for all the help!\n. > Nice post.\n\nThanks @dubek.\n\n> Your new module name is really confusing...\n\nIndeed. It is kind of cutesy and perhaps too close to \"Hamster\". Then again, it is just defining a single function, so naming it in relation to Hamster might not be unwarranted.\n\n> \u2026you might want to support procs/lambdas\u2026\n\nIndubitably. The latest version, v0.0.4 adds `Proc` matcher support. Thanks for the suggestion. The implementation of association matching isn't quite as clean (yet) but it's getting there.\n. There, now it's cleaned up in v0.0.7. The `Proc` no longer requires the superfluous third parameter.\n. Did this happen?\n. goodun\n. Sorry I wasn't paying attention. But I notice that `Struct#to_h` is in Backports https://github.com/marcandre/backports\n. For (2) maybe for \"hashyness\" we just check `obj.respond_to(:to_h)` first and if that's truthy then we call to_h on it and convert the result to a `Hamster::Hash` otherwise we check\u2026\n\nThe what comes next part is tricky. It feels like we'd want to check for \"sorted setiness\" and \"setiness\" next. But `SortedSet` defines no new public methods at all (it inherits from `Set`). So approach (2) can't differentiate `SortedSets` from `Sets`.\n\nAnd there are other problems with (2). If we could get past `Set` and `SortedSet` I think the next thing we'd learn is that we had create a big, brittle, difficult to understand glob of code.\n\nMy early intuition is that (2) is probably a loser.\n. @alexdowad I've never used YARD before. When I ran `rake yard` the output led me to believe that it wasn't meant to be run locally. What is the process for generating and viewing the doc?\n. Woopsie: I had failed to save an update to the new example in the README. Added a commit.\n. You're welcome @alexdowad. That was fun.\n. Great @dubek. I agree on all counts and will be more diligent in the future to make PRs that are more focused. Thanks for stepping up to clean this up for me.\n. d'oh. Thank you @alexdowad!!\n. Here is an ugly little start perhaps:\n\n``` ruby\nclass Object\n def chain_conditionally( cond, meth, *args, &block)\n  if cond\n    send meth, *args, &block\n  else\n    self\n  end\nend\n\n'abc'.chain_conditionally(false, :+, 'd').chain_conditionally(true, :+, 'e')\n => \"abce\" \n```\n\nWith that, @elben's example could look like:\n\n``` ruby\nrequire 'hamster'\ncondition1 = false\ncondition2 = true\nHamster.from({}).put(:abc,1).chain_conditionally(condition1, :put, :foo, :bar).chain_conditionally(condition2, :put, :xyz, 123)\n => Hamster::Hash[:xyz => 123, :abc => 1] \n```\n\nMy distaste for `chain_conditionally` as presented may stem from it's object-orientedness. That gives rise to the three method parameters: `meth, *args, &block` where I might just like to take a closure. I feel like a closure would make for more readable code.\n\nOn the other hand, `chain_conditionally` is easy for most Ruby programmers to understand. It's just not all that composable, and I don't know if we've achieved improved readability versus @elben's original code. On the upside though, we eliminated the need for the (mutable) reference `hash`.\n\nI think that if we want to go further and explore better approaches, there is gold here:\n1. combinators in Ruby http://combinators.info/\n2. String#to_proc for clean lambda syntax http://weblog.raganwald.com/2007/10/stringtoproc.html\n\nIt all depends on how far down the functional rabbit hole we choose to go.\n\nSincerely,\n\"No More Ruby\" Bill\n. > > \"No More Ruby\" Bill\r\n> > I hope Hamster hasn't turned you off Ruby! Maybe there is another language which works better for your purposes?\r\n\r\nHamster is the only thing keeping me here (for a while longer) @alexdowad.\r\n\r\nThe `chain_conditionally` I offered is ugly because it turns code like this:\r\n\r\n`hash.put(:foo,:bar) if condition1`\r\n\r\nInto code like this:\r\n\r\n`hash.chain_conditionally(condition1, :put, :foo, :bar)`\r\n\r\nHow about if we had a method called `when` that would take a condition and if the condition were truthy, would return self but if it were falsy would return an object, which, no matter what message you sent it, always returned self, to wit:\r\n\r\n``` ruby\r\nclass NoOp < BasicObject\r\n  def initialize(target); @target = target; end\r\n  def respond_to_missing?(method, *)\r\n    @target.respond_to?(sym)\r\n  end\r\n  def method_missing(sym, *args, &block)\r\n    if @target.respond_to?(sym)\r\n      @target \r\n    else\r\n      # let target raise the MethodMIssing error\r\n      @target.send sym, *args, &block\r\n    end\r\n  end\r\nend\r\n\r\nclass Object\r\n  def when( cond)\r\n    if cond\r\n      self\r\n    else\r\n      NoOp.new(self)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWith `when` we can do this:\r\n\r\n`Hamster.from({}).put(:abc,1).when(false).put(:foo, :bar).when(true).put(:xyz, 123)`\r\n\r\nThe `NoOp` class seems to be related to `tap`/`returning` which in turn are related to the K (Kestrel) combinators described in http://combinators.info/#kestrels.\r\n\r\nI gotta observe here though that it feels like (once again) straddling OO design and functional design results in kind of a mess. At a minimum there is a lot to understand here. Take for example my reference to the K combinator. What does it really mean to call `tap` or `returning` K combinators? Well I think it means that you can think of those _methods_ like functions with a hidden first parameter, `self`. And if you do that then they certainly behave like K combinators: regardless of what other parameters you send, they always return the first parameter (`self`), possibly with side effects.\r\n\r\nWhat does it mean to say that `NoOp` is like a K combinator. Well that's pretty loose talk. What I should say is that a `NoOp` object is an object with the same methods (functions) as the target object. But each of the methods (functions) is converted into a K combinator with no side effects: a \"no-op\". Viewed this way, the `NoOp` constructor is a tool for creating families of K combinators. Each `NoOp` you construct makes a family of K combinators corresponding to the family of functions (methods) of the target object. Those K combinators become the methods of the newly constructed object. In Object terms that new object in some ways has the same identity as the original one because each of its methods returns the original object.\r\n\r\n@elben you could use this `when` to give you conditional, chained invocation of any method on any object (not just `put` on `Hash`).\r\n\r\n**update 12/8/2015**: I made `NoOp` generate `NoMethodError` if you invoke a method not defined on the target object. That was my original intention, but the original code didn't do that.\r\n\r\n**update 5/29/2017**: All that talk about K combinators above is based on a long-held misunderstanding of K combinators. [These Are Not the K Combinators You Are Looking For](http://memerocket.com/2017/05/25/these-are-not-the-k-combinators-you-are-looking-for). This is a good idea. I was surprised a week or so ago, when I found no `[]=` method on a Hamster Hash object. I thought I'd done something wrong until I went and confirmed my suspicion in the source code.\n. ",
    "robinboening": "Just picked this issue for the upcoming 9th edition of https://rubyissues.ongoodbits.com :)\n. Just picked this issue for the upcoming 9th edition of https://rubyissues.ongoodbits.com :)\n. ",
    "studiolo": "Hi, I saw this on Ruby Issues and would like to call dibs - to support the good cause and to practice git bit.\n. The new CoC version asks for an email address where people can report incidents to the project maintainers. Please advise.\n. The new CoC version has additional clauses, listed below. Could I ask the project maintainers to discuss these and to let me know whether they accept them? Then I'll update the CoC file and send a pull request.\n- \"Publishing other's private information, such as physical or electronic addresses, without explicit permission\" is considered harassment.\n- Project maintainers can ban contributors that violate the CoC or exhibit \"other behaviors that they deem inappropriate, threatening, offensive, or harmful\", temporarily or permanently.\n- \" Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.\"\n- \"This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.\"\n. I have just seen that README.md quotes the CoC in full. My instinct would be to replace that with a link - but maybe you would like to keep it that way?\n. I think I've got it now: https://github.com/hamstergem/hamster/pull/209\n. replaced by better, new PR\n. Thx, it's been instructive :-)\n. Hi, I saw this on Ruby Issues and would like to call dibs - to support the good cause and to practice git bit.\n. The new CoC version asks for an email address where people can report incidents to the project maintainers. Please advise.\n. The new CoC version has additional clauses, listed below. Could I ask the project maintainers to discuss these and to let me know whether they accept them? Then I'll update the CoC file and send a pull request.\n- \"Publishing other's private information, such as physical or electronic addresses, without explicit permission\" is considered harassment.\n- Project maintainers can ban contributors that violate the CoC or exhibit \"other behaviors that they deem inappropriate, threatening, offensive, or harmful\", temporarily or permanently.\n- \" Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.\"\n- \"This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.\"\n. I have just seen that README.md quotes the CoC in full. My instinct would be to replace that with a link - but maybe you would like to keep it that way?\n. I think I've got it now: https://github.com/hamstergem/hamster/pull/209\n. replaced by better, new PR\n. Thx, it's been instructive :-)\n. ",
    "Ch4s3": "@dubek I could rewrite it to select the concurrent-ruby version that's installed on the machine, but that seems a bit brittle. Otherwise, perhaps it could go into the next major version of hamster? I think Rails 5 is going to have concurrent-ruby 1.0.0 as a dep, so it might make sense to have a version that targets that (IMO). \n. @alexdowad That sounds reasonable. Is there anything that needs to be changed in the pr?\n. @alexdowad fixed\n. @alexdowad happy to contribute!\n. Awesome! @hzulla I'm excited to see that the new version is used on Sonic Pi!\n. @dubek I could rewrite it to select the concurrent-ruby version that's installed on the machine, but that seems a bit brittle. Otherwise, perhaps it could go into the next major version of hamster? I think Rails 5 is going to have concurrent-ruby 1.0.0 as a dep, so it might make sense to have a version that targets that (IMO). \n. @alexdowad That sounds reasonable. Is there anything that needs to be changed in the pr?\n. @alexdowad fixed\n. @alexdowad happy to contribute!\n. Awesome! @hzulla I'm excited to see that the new version is used on Sonic Pi!\n. ",
    "HParker": "I responded to the comments and squished the commits.\n. Cool, I think the documentation makes more sense for Vector and Hash.\n. @dubek, it totally works with `fetch` only issue is we have to rescue `IndexError`s since indexing off the end of an array with `dig` returns `nil`, but `fetch` raises an error.\n\nLet me know if you prefer this, and I'll squish the commits.\n. ah, sorry disregard my previous comment. I just had to stare at the code for a minute longer. I always forget about `fetch` default.\n.  Thanks for all the great feedback.\ngood catch. I hadn't thought of that case.\nI can't think of a good way of implementing this with `fetch`. How would you feel about either another module with a dependency on `get` or adding a dependency on `get` to this module?\n\nDo you have any other ideas?\n. I came across another option. ruby hash's expose a `default` on hashes. If we had a similar method on hamster hashes, we could use that to get the correct default rather than assuming nil.\n\nEDIT: actually I am not sure this would completely solve the problem. I suppose we would also need a Vector `default` which doesn't seem right...\n. cool, we are back to the `get` implementation. Thanks for all the help everyone. Seriously good contribution experience.\n. I responded to the comments and squished the commits.\n. Cool, I think the documentation makes more sense for Vector and Hash.\n. @dubek, it totally works with `fetch` only issue is we have to rescue `IndexError`s since indexing off the end of an array with `dig` returns `nil`, but `fetch` raises an error.\n\nLet me know if you prefer this, and I'll squish the commits.\n. ah, sorry disregard my previous comment. I just had to stare at the code for a minute longer. I always forget about `fetch` default.\n.  Thanks for all the great feedback.\ngood catch. I hadn't thought of that case.\nI can't think of a good way of implementing this with `fetch`. How would you feel about either another module with a dependency on `get` or adding a dependency on `get` to this module?\n\nDo you have any other ideas?\n. I came across another option. ruby hash's expose a `default` on hashes. If we had a similar method on hamster hashes, we could use that to get the correct default rather than assuming nil.\n\nEDIT: actually I am not sure this would completely solve the problem. I suppose we would also need a Vector `default` which doesn't seem right...\n. cool, we are back to the `get` implementation. Thanks for all the help everyone. Seriously good contribution experience.\n. ",
    "dsisnero": "I didn't know about immutable-ruby.  What is the difference between that\ngem and hamster?\n\nOn Wed, Jan 13, 2016 at 5:49 AM, Alex Dowad notifications@github.com\nwrote:\n\n> An alternative to using bit-twiddle would be for me to code up a C\n> extension for Hamster, which replaces Trie. I was planning to do this for\n> the immutable-ruby gem, but it doesn't seem to have much traction.\n> Perhaps people like \"Hamster\" better?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/220#issuecomment-171281221.\n. I didn't know about immutable-ruby.  What is the difference between that\ngem and hamster?\n\nOn Wed, Jan 13, 2016 at 5:49 AM, Alex Dowad notifications@github.com\nwrote:\n\n> An alternative to using bit-twiddle would be for me to code up a C\n> extension for Hamster, which replaces Trie. I was planning to do this for\n> the immutable-ruby gem, but it doesn't seem to have much traction.\n> Perhaps people like \"Hamster\" better?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hamstergem/hamster/issues/220#issuecomment-171281221.\n. ",
    "dreammaker": "@alexdowad, with regard to naming, if you want to move, please put a big note at the top of the readme.  Otherwise, people don't know what the difference is.  I tried to figure it out on my own, and the only clue was that Hamster had more recent commits, so I figured this was the one to use.. @alexdowad, with regard to naming, if you want to move, please put a big note at the top of the readme.  Otherwise, people don't know what the difference is.  I tried to figure it out on my own, and the only clue was that Hamster had more recent commits, so I figured this was the one to use.. ",
    "hzulla": "Thanks!\n\nA new release would be helpful, as the current version 2.0.0 doesn't work with ruby-concurrent 1.0.0 and [needed to be patched](http://anonscm.debian.org/cgit/pkg-ruby-extras/ruby-hamster.git/tree/debian/patches/02-concurrent-ruby.patch?h=debian/2.0.0-2) for Debian.\n. @alexdowad the patch for Debian was taken from your current development version.\n\n@Ch4s3 patched this already [here](https://github.com/hamstergem/hamster/commit/74e89448d2c9051082547e1ae62e6b03f41623ce). You just didn't do a release of the gem since then.\n. So, new release coming?\n. Thanks!\n\nA new release would be helpful, as the current version 2.0.0 doesn't work with ruby-concurrent 1.0.0 and [needed to be patched](http://anonscm.debian.org/cgit/pkg-ruby-extras/ruby-hamster.git/tree/debian/patches/02-concurrent-ruby.patch?h=debian/2.0.0-2) for Debian.\n. @alexdowad the patch for Debian was taken from your current development version.\n\n@Ch4s3 patched this already [here](https://github.com/hamstergem/hamster/commit/74e89448d2c9051082547e1ae62e6b03f41623ce). You just didn't do a release of the gem since then.\n. So, new release coming?\n. ",
    "samaaron": "Hamster is wicked. Thanks so much for creating it. Immutability is such an important thing!\n. Hamster is wicked. Thanks so much for creating it. Immutability is such an important thing!\n. ",
    "stephencelis": "Couldn't find a way to request a rebuild in Travis, so hopefully a force-push will do.\n. Force-pushed. Build is passing.\n. Couldn't find a way to request a rebuild in Travis, so hopefully a force-push will do.\n. Force-pushed. Build is passing.\n. ",
    "gogainda": "@stephencelis Close and open this PR to start a rebuild\n. @stephencelis Close and open this PR to start a rebuild\n. ",
    "ddfreyne": "It\u2019s been around at least since Ruby 1.9.3, so yes!. @alexdowad What needs to be done to get this PR merged?. It\u2019s been around at least since Ruby 1.9.3, so yes!. @alexdowad What needs to be done to get this PR merged?. ",
    "kevgathuku": "Thanks @alexdowad \r\nI can check out the CI. \r\nIt seems the failure is happening only on ruby 1.9.3, and weird enough after the tests pass. \r\n<img width=\"947\" alt=\"screen shot 2017-10-10 at 10 42 16 pm\" src=\"https://user-images.githubusercontent.com/3721994/31407107-591cd980-ae0c-11e7-8838-4836d76b187f.png\">\r\n. @alexdowad It seems support for Ruby 1.9.3 officially ended on [February 23, 2015](https://www.ruby-lang.org/en/news/2014/01/10/ruby-1-9-3-will-end-on-2015/)\r\n\r\nI think it's safe to drop it.\r\nSupport for 2.0 also ended in 2016. We can also upgrade the supported versions list\r\n\r\nPR for dealing with the Ruby versions: https://github.com/hamstergem/hamster/pull/238. Aaaaaand we're back to a green build on Travis \ud83c\udf89 . Happy to help \ud83d\ude3a . Thanks @alexdowad \r\nI can check out the CI. \r\nIt seems the failure is happening only on ruby 1.9.3, and weird enough after the tests pass. \r\n<img width=\"947\" alt=\"screen shot 2017-10-10 at 10 42 16 pm\" src=\"https://user-images.githubusercontent.com/3721994/31407107-591cd980-ae0c-11e7-8838-4836d76b187f.png\">\r\n. @alexdowad It seems support for Ruby 1.9.3 officially ended on [February 23, 2015](https://www.ruby-lang.org/en/news/2014/01/10/ruby-1-9-3-will-end-on-2015/)\r\n\r\nI think it's safe to drop it.\r\nSupport for 2.0 also ended in 2016. We can also upgrade the supported versions list\r\n\r\nPR for dealing with the Ruby versions: https://github.com/hamstergem/hamster/pull/238. Aaaaaand we're back to a green build on Travis \ud83c\udf89 . Happy to help \ud83d\ude3a . "
}