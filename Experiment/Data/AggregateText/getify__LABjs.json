{
    "getify": "I've been unable to reproduce the problem. Can you post a link to a test page where this occurs so I can inspect further?\n. never heard back, so closing this issue.\n. OK, thanks to your further information, I have found and (I believe) fixed this issue... the new fLABjs posted here on Github has the fix in it. Please try and let me know if it resolves the issue.\n. do you have a site/page you can point me to where I can see this behavior happening? Is there a particular browser it happens in or all browsers?\n. i was never able to reproduce this. I believe the issue must've been related to JS errors being swallowed by the try/catch that runs around .wait() functions... i think there were race conditions present. In any case, if you can create a simple reproducible test case, resubmit another issue and I'll re-examine.\n. I have visited that site in both FF and IE8, and it appears to me to come up fine. But you've not given me any information that describes what SHOULD be happening on the site versus what IS happening.\n\nWhat I see is 3 boxes that say \"Title 1\", 2, and 3. When hovering over them, they turn to a gray background, and nothing happens when I click.\n\nCan you describe what's supposed to be happening, and what is instead happening, in more detail?\n\nAlso, it would be helpful if you could show the exact same demo/code but without the use of LABjs so I can compare both to see what the correct expectations should be.\n. I tried both links in IE8, FF3.5, and FF 3.6, all on windows... in all 3, the page loads and an alert says \"hey\". Is that what's supposed to happen? If so, no I can't reproduce your bug. :(\n. ok, so what i've narrowed down so far is this:\n\nthe reason you are seeing this behavior (which I'll loosely call a \"bug\") is because the dupe-checks don't fully work they way you'd probably expect between independent $LAB chains. Moreover, if you have an entire chain that loads all scripts which have already been loaded before, that seems to be what exposes this issue. If I add even one non-dupe to the nested $LAB chain (inside javascript.js), things load and execute fine.\n\nThe reason I say \"bug\" and not bug is because I'm not sure that I would necessarily say that the usage you're doing is an intended supported use case. The dupe-check in general was always a more problematic and basically not recommended feature. It was not really designed to be used across chains like you are doing, as it raises very sticky race conditions. It was certainly not designed to basically work that an entire $LAB chain would be ignored and a final .wait() would be the only executable item, which is essentially what this amounts to. Similarly, $LAB.wait(func); also is not a supported usage, for probably a similar reason.\n\nAt this point, I'm not sure if I'll be able to resolve this or not. I've reopened this bug, and as I get time I'll look into it.\n\nIf it helps, my suspicion is that the problem is related to the nested chain having the internal \"first_pass\" boolean staying true when it should eventually cycle to false. I haven't verified this yet, but knowing what I know about the brittle parts of the code, I think it's a decent candidate.\n. Definitely a known issue that separate $LAB chains (like when an extra $LAB chain is nested inside a script file loaded by another chain) operate totally separate and so there's no defined or reliable ordering between them. Textbook race conditions there. The only guarantee that LABjs makes about maintaining order is in a single chain.\n\nThere's future releases of LABjs and LABjs-server which are intended to address this use case, but the way you're trying to use it now is prone to such issues.\n. Multiple $LAB chains should be avoided. However, your usage is possibly safe since the two chains do not run in parallel.\n\nHowever, your first chain, you need at least an empty .wait() at the end. There's a known issue where not ending the chain in a .wait() can cause issues too.\n. closing.\n. FYI: bugs with \"allowduplicates\" between different $LAB chains is being addressed in 2.0.\n. dynamic script loading completely de-couples script loading (normally done with script tags) from the window's dom-ready and onload events. That's the \"Blocking\" in LABjs name in fact, that it removes (by default) such blocking behavior.\n\nThere's actually no way for any dynamic script loader of this nature to guarantee dom-ready/onload blocking when scripts are loading. So, essentially, those two events will proceed independent of whether a script loads quickly (from cache) or slowly (over the net).\n\nThe problem you're describing was, in a similar fashion, present in jQuery prior to version 1.4, in that jQuery was not, when loaded, checking if dom-ready had _already_ passed when it was loaded. As such, there was a race condition, that if jQuery got there before dom-ready, all the $(document).ready(...) waiting blocks worked. But if jQuery came in after dom-ready, and it didn't check for that, those waiting blocks would all just sit there forever hoping dom-ready would happen.\n\nStarting with jQuery 1.4+, the code base checks for a passed dom-ready by looking for document.readyState, which (for the most part) resolves this problem. In conjunction, because FF before 3.6 didn't have this property, LABjs added a little page-level hack to make that property present, so that the jQuery check would work correctly.\n\nA similar thing seems to be happening with your checking for \"onload\". The logic (I'm guessing) inside Event.observe(...) is simply waiting to hear if onload happens, and if it does, it fires. But I'm betting that onload is firing before this listener gets a chance to register, thus meaning it just waits forever in vain.\n\nThere's no \"window.loaded\" property to rely on like there was for dom-ready with \"readyState\", so the situation is a little tougher/more manual to correct for.\n\nBasically, my suggestion would be something like this:\n\n```\nvar isWindowLoaded = false;\nEvent.observe(window,'load',function(){ isWindowLoaded = true; });\n\n$LAB.script(\"...blah.js\").wait(function(){\n   if (isWindowLoaded) {\n      doSomethingNow();\n   }\n   else {\n      Event.observe(window,'load',doSomethingNow);\n   }\n});\n```\n\nThe key is to have an event listener that executes immediately during page-load (not in waiting for something to happen inside LABjs) that looks for when the \"onload\" happens... if it happens before $LAB has a chance to run, it sets a boolean property to true, so that when the $LAB.wait(...) call runs, it will see that the event has already passed and it'll just proceed immediately. Otherwise, it knows it needs to still wait for the event, so it registers a handler and waits for it to occur.\n\nI hope this is helpful. Let me know if you have other issues.\n. so glad that helped. hope your issues are resolved now! :)\n. It's the use of document.write() in that file. document.write() is _NOT_ compatible with dynamic loaders. There's a race condition inherent that if document.write() is executed before onload, then things are probably ok, but if it goes after that (which can happen intermittently) a document.write() will screw up the page. It can crash IE, and the behavior of seeing the page go blank is quite expected when document.write() runs after a page is loaded.\n\nThe solution is to load scriptaculous manually, then load any other files that don't have document.write() in them with LABjs.\n\nI really wish the frameworks would get their act together (like jQuery did) and get rid of this junk that makes dynamic loading impossible.\n. this failed one of the other test cases. turns out IE9 fixed the bug before their beta release, so no patch needed.\n. i tested this change and it breaks some other test cases. a forthcoming release of LABjs will attempt to fix the cross-chain \"AllowDuplicates\" behavior properly and completely.\n. there are a few plans along that line. more coming soon.\n. conditional chaining is helpful in this task, now, Also, a serever-side LABjs component is still on the horizon. Stay tuned,\n. many people have asked for this before. i have no plans to add it to LABjs at the moment, and here's why:\n1. actually determining if a dynamically loaded CSS file has finished loading is actually quite complicated and challenging to do cross-browser. The \"load\" events don't fire as one would hope/expect. so adding such support would add a non-trivial size to LABjs (or to a LABjs wrapper/plugin).\n2. I actually find it very rare that people need to sequence the loading (and \"executing\") of CSS in between the loading of other scripts. It's very common that someone says \"I want to load these scripts and this CSS file\" for widgets and things, but very rare that someone says \"I need to load this script, THEN this CSS file, THEN this other script .... \" LABjs is specifically for loading things in parallel and sequencing their execution for dependency sake. So it makes much less sense to mix in CSS loading (which usually doesn't need sequencing) into the API. Would be very much more confusing.\n3. Just the dynamic loading portion (not the load-detection or execution sequencing) of CSS files is actually _very_ easy to do. The code is like this:\n   \n   var link = document.createElement(\"link\");\n   link.setAttribute(\"rel\",\"stylesheet\");\n   link.setAttribute(\"type\",\"text/css\");\n   link.setAttribute(\"href\",\"http://link/to/file.css\");\n   document.getElementsByTagName(\"head\")[0].appendChild(link);\n\nBecause that code is so trivially easy for people to do themselves if they want to load CSS dynamically, I don't think it belongs in a tool which is designed for the specific purpose of performance-efficient script loading.\n\nAll this having been said, some other loaders do support CSS loading... like Dominoes and RequireJS.\n. The most straightforward way is to have a CSS style in the stylesheet and then to poll every 25 ms and look for the computed style of some element to see if that style has been applied. Obviously that's kind of ugly, but I've done that successfully before.\n\nIf you look in the source code for Dominoes there's a more complex solution that tries to actually detect if the stylesheet itself is loaded as a node in the DOM, and uses some interesting security behavior in various browsers.\n\nEither way, it's not straightforward or easy. That's one of the reasons I've not put it into LABjs. The complexity is not worth the payoff.\n. closing (for now)\n. Despite the fact that it may have worked in the past, it's not really a supported use case that you \"suspend\" the execution of a chain and then resume it later after some other logic. There's lots of potential race conditions such activity could introduce. Your usage is not really an intended or supported functionality, at least for now. Perhaps the re-write I'm working on will be more robust for it, but honestly that won't be a major design goal.\n\nMay I ask, why do you need to resume the $LAB chain later? Why not use another chain, or just execute the code right away?\n. But I'm still not sure I understand why this implies that you need to split up the $LAB chain? I understand using a script tag to blocking load of mootools (because of doc.write) and LABjs, but then just need one chain that loads all the other JS files, right? Also, how does loading in CSS in the middle of all that factor in?\n. closing.\n. FYI: resuming of $LAB chains will be supported in 2.0.\n. I have gone back and forth on if I want that behavior or not. I'm aware of the issue and the usefulness of the practice. Right now, I detect if a URL is absolute by looking for file:// or http:// or https:// at the beginning... I suppose I could add a second check for just // at the beginning, and then have that add on the page's protocol. \n\nI think the reason why I didn't implement this originally was worry that people would accidentally have \"//\" instead of \"/\" at the beginning of the URL (common issues with escaping and such in various templating engines) and instead of getting a root-relative path, they'd get an invalid path. Hmmm... will do more thinking to see if there's a way to protect and serve this use-case simultaneously.\n\nI'll probably add that to the list of to-do's for the rewrite that's in progress. Thanks for the note.\n. v 1.2.0 was released and addressed this request.\n. Unfortunately, you can't split up the $LAB.script() calls and the $LAB.wait() call like that, because that will act as two independent LAB chains and won't get your desired effect.\n\nYou could do it like this:\n\n```\n<script type=\"text/javascript\" src=\"http://d7.ttcn/sites/all/libraries/labjs/LAB.min.js?lekatr\"></script>\n<script type=\"text/javascript\">\n<!--//--><![CDATA[//><!--\nvar _lab = $LAB\n.setOptions({AlwaysPreserveOrder:true})\n.script(\"/misc/jquery.js\")\n.script(\"/misc/jquery.once.js\")\n.script(\"/misc/drupal.js\")\n.script(\"/misc/ui/jquery.ui.core.min.js\")\n.script(\"/misc/jquery.ba-bbq.js\")\n.script(\"/modules/overlay/overlay-parent.js\")\n.script(\"/modules/contextual/contextual.js\")\n.script(\"/misc/jquery.cookie.js\")\n.script(\"/modules/toolbar/toolbar.js\");\n//--><!]]>\n</script>\n\n<script type=\"text/javascript\">\n<!--//--><![CDATA[//><!--\n_lab.wait(function() {\n    jQuery.extend(Drupal.settings, {\"basePath\":\"\\/\"},\"overlay\":{\"... strip...\"});\n});\n//--><!]]>\n</script>\n```\n\nThe difference here is we \"continue\" the original $LAB chain by saving the ultimate return value (technically the return value from the last .script() call) int `_lab` variable, and we then chain the .wait() off it later.\n\nHowever, I would say in general, it's not a good idea to split the chains up like this, as there's a _possibility_ that you can create race conditions (not really a case I've tested extensively). So if you do it that way, be careful and test thoroughly.\n\nAnother approach, which should be a little more solid, but is based on a very similar concept (simulated chaining) is found here:\n\nhttps://gist.github.com/704226\n\n-OR-\n\nhttps://gist.github.com/475431\n. Initially, it was an important design decision for LABjs to have each $LAB chain completely independent. This is still currently my philosophy and it precludes features which deliberately tie the chains together, even for a single callback.\n\nSyntactically, it introduces an API complexity/confusion that is undesirable. If $LAB.ready() fires when all current chains are done, what happens if you start another $LAB chain after it (or inside it)... will it clear out that event? Lots of issues arise in this line of questioning.\n\nBasically, I'm not convinced that the use-case for multiple chains is all that strong (except in a few scenarios), and so I encourage people to consolidate their code into as few chains as possible. Really, you shouldn't have _any_ code in separate chains if that code has any relationship to code being loaded in another chain. There's [\"simulated chaining\"](https://gist.github.com/475431) (with a for-loop) if you have the need to build up parts of a chain in contextually separate blocks of code and run the chain all at once once the chains parts are all known.\n\nSo, while I've thought about a $LAB.ready() thing before, I think it's counter to the philosophy, API design, and best-practices that are put forth from LABjs.\n\nI'm not aware of any use-case that would be a strong argument for such a thing... can you explain why you think it's necessary?\n. I saw the Drupal LABjs project! Thanks so much for doing that!\n\nI understand that it's common (especially in CMS's) for people to strewn their &lt;script> tags (both inline script blocks and external script references) about the entire HTML.\n\nThat's why I gave you the link on the [\"queuing\"](https://gist.github.com/704226)... basically, you could have the drupal find all the different script blocks (inline and external src) and replace that with the appropriate call to $LAB.queue() as shown, just like you do with $LAB.script() or $LAB.wait() right now. \n\nThen, in the master footer of the page, you have one call to $LAB.executeQueue() which causes the entire set of all scripts from across all the different snippets to start loading and executing, just like if you'd done a single $LAB chain at the end manually.\n\nIn my opinion, this is the best of both worlds for CMS's, because plugins and content authors get to keep leaving their scripts inline strewn about their content as makes sense to them, and the CMS takes care of re-writing all &lt;script>...&lt;/script> and &lt;script src=\"...\">&lt;/script> blocks to calls to the $LAB.queue() manager, and the content/plugin authors never know the difference.\n. yeah, like i said, it's not particularly a supported use-case to have significant delays in the middle of a chain's operation. That's why queuing up all your script and inline scripts (into .wait()) and then firing off the chain all at once at the end is the preferred route. The two links I've sent you above show exactly how to do that.\n. i undersstand that you only want to load some scripts with LABjs. as far as i'm concerned, if you have to, that's fine. if there's a script that has a document.write in it, you should definitely only load that with a regular script tag. (hint: you shold also pressure the creator of that script to stop using document.write()... it's terrible for performance!) \n\nif you're wanting is to have a regular script block in the markup have some waiting affect on the code you're loading with LABjs, this is not possible. the definition of a dynamic script loader is that it makes script loading independent from the page's other resource loading (including manual script tags).\n\nif you're just wanting to sometimes use the queueing (for LABjs loadable scripts) and other times not, do something like this:\n\n```\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head><title>TTCN D7 test</title>\n<script src=\"http://d7.ttcn/sites/all/libraries/labjs/LAB.min.js?lenopg\"></script>\n<script type=\"text/javascript\">$LAB.setGlobalDefaults({AlwaysPreserveOrder:true});</script>\n...\n<script>$LAB.queue(\"http://d7.ttcn/file1.js\");</script>\n...\n<script src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n...\n<script>$LAB.queue(function() {\n  alert(0);\n});</script>\n...\n</head>\n<body>Test</body>\n...\n<script>$LAB.executeQueue();</script>\n</html>\n```\n\nAs for how, in your original markup, to distinguish what code should be queued for LABjs and what should be left alone, have it be something like this as the original markup before you alter it with your Drupal module:\n\n```\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head><title>TTCN D7 test</title>\n...\n<script rel=\"LABjs\" src=\"http://d7.ttcn/file1.js\"></script>\n...\n<script src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n...\n<script rel=\"LABjs\">\n  alert(0);\n</script>\n...\n</head>\n<body>Test</body>\n</html>\n```\n\nSo, your original markup just starts off with script blocks strewn throughout, like shown. For the script blocks where you want LABjs to attach and queue (either for an external `src` loading, or for an inline snippet), you just mark the tag with something like `rel=\"LABjs\"`, that way your Drupal module knows it should rewrite that tag. And you inject the LABjs loading at the beginning, including the setting of global defaults, and you inject the `executeQueue()` call at the very bottom of the page.\n\nI dunno if this helps or not, but that's how I'd approach a CMS module for LABjs.\n. At the moment, I don't have specific plans to include it \"officially\". It's not a lot of extra size, but it is only a functionality that's actually useful if people are using it inside CMS's like you are, and in that case, I think them adding in the little extra snippet is probably the best idea.\n\nPreviously, before I released v1.1.12 (actually, v1.1.11), we didn't have \"conditional chaining\", and there was a lot more of a use-case for this queuing. But now that conditoinal chaining is directly supported, this queuing is only necessary if you need to spread out the building of your chain across the entire HTML block. I don't generally recommend that approach, but in the specific case of CMS's, it's the best (or only) option.\n. queueing was added in 2.0\n. I don't really have a better solution than what you propose. :( That's why I keep saying \"document.write() must die\". BTW I don't have any current plans to suppor DOMWrite with LABjs. Other loaders have tried and I think it's still proving a fruitless effort hacky and error-prone at best. \n\nI suggest using regular &lt;script> tags for any scripts with doc.write in them and LABjs for everything else. Sorry I don't have a better answer.\n. The browser treats different ports on the same domain as different \"domains\" (in the FQDN, fully qualified domain name sense). As such, this implementation is correct, because those domains are considered different to the browser and are thus \"cross-domain\".\n\nTechnically, :80 being present and not being present (since it's assumed), or the same with :443 and not in the case of https, should be part of the implementation, to be fully correct. BUT, the implementation details were a little bit complicated to parse the URI for that type of info, and I didn't think the benefit outweighed the cost. If I had someone who really raised a need for that, I'd consider adding it.\n\nBut, :80 and :8080 are in fact different \"domains\" so the implementation is correct in the case you raise.\n. First of all, your code snippet looks a little incorrect to me. So let me correct it:\n\n```\n<script src=\"lab.js\"></script>\n<script>\n$LAB.setOptions({AlwaysPreserveOrder:true})\n  .script(\"jquery.js\")\n  .script(\"core.js\")\n  .wait(function(){ List.F1 = ... })\n  .wait(function(){ List.F2 = ... })\n;\n</script>\n```\n\nFirstly, I removed the double-load of \"core.js\". Secondly, you can't run code inside a `script()` statement, only inside a `wait()` statement. Unless what your code was intending to imply is not that actual inline code but the load of a separate file with that code in it, in which case the `script()` call is correct. Lastly, I used the chainable `setOptions()` form of option setting, since your code only shows one chain. If you indeed have other chains in the page, then your `setGlobalDefaults()` usage was more correct.\n\nIf indeed it's two `wait()` calls like I've shown, then you should just combine them into one. But if it's two `script()` calls loading separate files, obviously you keep them separate.\n\n---\n\nWith respect to your question about DOM-ready issues, my suggestion is not to use `$(document).ready()` to defer behavior that is really not related to the document being ready or not. That event should be used to defer behavior that needs to interact with the DOM, like event handling, DOM manip, etc. \n\nMany people have conflated that event with scripts finishing loading, because the regular &lt;script> tag just happens to be blocking that event in browsers. When they move to a script loader that specifically breaks the connection between the two, they're always surprised, and often try to jump through all kinds of hoops to fix restore that connection, many of which are more complicated than I think it should be.\n\nMy rule of thumb is, use DOM-ready event for DOM related things, and use your own \"events\" or callbacks for other purposes. In your case, I'd refactor core.js to remove the `$(document).ready()`, and not have it auto-execute anything. Then, you'd make your chain do this:\n\n```\n<script src=\"lab.js\"></script>\n<script>\n$LAB.setOptions({AlwaysPreserveOrder:true})\n  .script(\"jquery.js\")\n  .script(\"core.js\")\n  .wait(function(){ List.F1 = ... })\n  .wait(function(){ List.F2 = ... })\n  .wait(function(){\n    for each (List as f): run f();\n  })\n;\n</script>\n```\n\n(note: if you indeed end up with multiple subsequent .wait() calls like shown above, combine them if possible to avoid unnecessary waste/overhead)\n\nSo, bottom line, I'm suggesting the more difficult modification of core.js to remove the concept of the autorun as you've shown it, because I think it's a bad pattern to load several scripts that have dependencies on each other, and then rely on DOM-ready to be the \"they're all loaded\" event for you. Even without a script loader like LABjs, this is an error-prone and brittle pattern that should be avoided.\n\nBut especially with a script loader introduced, you should instead use the script loader's facilities for knowing when all scripts are finished running, and then you can execute whatever \"autorun\" behavior you want. This is cleaner and easier code to maintain, and will work solidly.\n. The other option, which still involves a modification to core.js, is to change from using DOM-ready to using a custom \"event\" of sorts. For instance, you might do something like this:\n\n```\n<script src=\"lab.js\"></script>\n<script>\n$LAB.setOptions({AlwaysPreserveOrder:true})\n  .script(\"jquery.js\")\n  .script(\"core.js\")\n  /*\n   inside of core.js, at the end, do:\n   $(document).bind(\"scripts-ready\", function(){\n     for each (List as f): run f();\n   });\n  */\n  .wait(function(){ List.F1 = ... })\n  .wait(function(){ List.F2 = ... })\n  .wait(function(){\n    $(document).trigger(\"scripts-ready\");\n  })\n;\n</script>\n```\n\nIn this way, you're using a custom event specifically for the purpose of indicating when scripts are done loading, rather than relying on the conflation with the DOM-ready event.\n. nothing for LABjs to do here.\n. I've considered this (and variations of it) before. Unfortunately, there's one major snag that's prevented me from putting something like that in: the browsers are all over the map in terms of their support for onerror and on not firing onload in error cases. As far as I know, there's no reliable way to guarantee that only an onerror handler will fire if a script fails to load. If both were to fire (as does happen), and in the wrong order (as does happen) it would be a strange and undefined state for the $LAB chain.\n\nAlso, and this is probably more troubling even: in some browsers, like FF and Opera, LABjs does not currently control the execution flow... meaning I could not interrupt the flow of execution (stop it, or inject something into it on-the-fly). The _best_ that could happen there is that you could simply be notified of the failure, but you couldn't do anything to adjust how the rest of the chain was going to work as a result.\n\nI believe the browsers and spec SHOULD standardize the load and error events properly and sanely, so we can do things like this. That's part of what I'm advocating for. But we're a long way off from having that.\n\nI'd welcome any further thoughts on the topic.\n. IMHO, having a feature in a lib that only partially works in various browsers/scenarios is a bad design idea. I don't think the other loaders should pretend to support something that doesn't actually work. When the browsers give us a consistent and reliable way to detect script errors, I'll add this to the API.\n. closing for now. this will be revisited in a later version of LABjs, when browser support is more solid.\n. I refer you to [this comment](#issuecomment-1008931) above. `script.onerror` isn't reliable/consistent cross browser, that's the whole reason I never used that in LABjs.\n. I'd be curious to know what you think LABjs would benefit from a noConflict() for? Are you concerned about people loading multiple (incompatible) versions of LABjs onto the page? Or of people extending one copy of LABjs but wanting another pristine un-changed copy? Or?\n\nI am generally hugely in favor of jQuery's noConflict() pattern. But I've always thought the extra complication was unnecessary for such a small script loader as LABjs. But it's worth considering for 2.0, nonetheless. Would be interested in your thoughts on what the real value proposition is for it.\n. FYI: `noConflict()` has landed in the 2.0 progress work.\n. this is working just fine in 2.0a.\n. I don't think the exception object is that consistent between browsers. I'm not positive, but I don't think it has line numbers and filenames exposed in most of the browsers. For instance, in V8, I know it tracks those values, so that the browser's error console can display them if an exception is left uncaught. But I don't think it exposes all of that data to the JS error object. Perhaps I'm wrong, not 100% positive.\n\nBut whatever properties are on the object, of course they could be serialized and displayed in the console.error() message. It might just be that in some browsers you don't get as helpful of information as in others.\n. there's going to be something like this feature in 2.0. Still not entirely decided on how it will look, but probably will be console.log()'ing that will be turned on only if you put $LAB into DEBUG mode.\n. there's now a DEBUG mode in LABjs 2.0a\n. You should not have errors as a matter of practice in production. If you have errors, you should have a way to find and FIX them, not a way to find and IGNORE them. That's the philosophy applied here. That's why LABjs comes with this optional debug build. Moreover, as explained in the thread above, LABjs' assumption is that by default, developers don't want errors leaking out into the consoles in production.\n\nSo, if you experience issues, either in dev or production, with your loading, swap in the debug LABjs, enable debug mode, and find them. And FIX them. Then swap back to non-debug production LABjs and go home and enjoy your weekend. :)\n\nMoreover, there's a simple fix to this problem which doesn't involve changing your LABjs file nor enabling a mode. It's putting your own `try..catch` error handling (or other robust feature testing!) around any code which, you know, might actually error if something's missing. I would suggest avoiding writing code which can error, and being more robust yourself. But to whatever extent that's not possible, it then becomes your responsibility to do the extra work to use LABjs' debug build to find and fix such errors.\n\nExample: Don't just use `$` assuming it's there, and let an error happen. Test if it's there first:\n\n``` js\nif (typeof $ !== \"undefined\") {\n   $(\"..\")...\n}\nelse {\n   logErrorToServer(\"Oops, jquery is missing.\");\n   ShowPoliteErrorMessageToUser();\n}\n```\n\n**Note:** I don't recommend running with the debug build of LABjs in production, even with the debug mode turned off. But, it's not much bigger, nor appreciably slower (same `try..catch`s in place regardless), so it might be your chosen option to always run with the debug build of LABjs in production, and then all you have to do to \"see\" the errors is turn debug mode on (no file switching necessary).\n. Also, I would remind you, you should avoid having very much code in `.wait(..)` callbacks. If it's more than a few lines here or there, you should consider moving that code into its own file, where the \"error handling\" (aka suppression) that LABjs does won't hurt you. Then you'll only have a few `.wait(..)` lines to worry about with errors and debug modes and builds and such. Your team and your future self will thank you for reducing the surface error of such issues. :)\n. First, I'd suggest reading [this thread #57](https://github.com/getify/LABjs/issues/57), specifically these two comments, for more back-story on my reasoning: [comment 1](https://github.com/getify/LABjs/issues/57#issuecomment-5054895)  [comment 2](https://github.com/getify/LABjs/issues/57#issuecomment-5055481)\n\n> if `queueWait()` is hiding them?\n\nI am not \"hiding them\", I am preventing them from affecting the rest of the `queueWait()`s which might come later in the chain.\n\nSince LABjs is driven by code, it has to be more sensitive to the fact that errors in user code could stop LABjs itself from doing the rest of its job.\n\nBy contrast, in native browser behavior, errors in one `<script>` element cannot stop other `<script>` elements from running (it just abandons execution of the first one and moves on).\n\nIf LABjs didn't catch the errors, any error thrown would cause the rest of the **LABjs controlled parts of the chain** to stop working. But, quite confusingly, the actual script load-and-run behavior (which the browser handles) would NOT be stopped, so some of the chain (`script()`s) would continue and some of the chain (`wait()`s) would not.\n\nTHAT kind of behavior would be far worse.\n\nI'm attempting to keep LABjs working as much like the native browser behavior as possible, with the least amount of surprise of possible. I know you think the current \"hiding errors\" behavior is surprising, but the other choice would be much more surprising. \n\nLet me illustrate. Let's take this series of markup:\n\n``` html\n<script src=\"script1.js\"></script>\n<script>\n   doSomethingInScript1(); // let's say this throws an error!\n</script>\n<script src=\"script2.js\"></script>\n<script>\n   doSomethingForScript3(); // no errors here!\n</script>\n<!-- requires `doSomethingForScript3()` to have completed successfully first! -->\n<script src=\"script3.js\"></script>\n```\n\nOK, so in normal browser behavior, `script1.js` loads and runs, then it tries to run the next inline `<script>` block, which throws an error. Then, `script2.js` runs, then the next inline `<script>` block runs (no errors), then `script3.js` runs.\n\nBut, hypothetically, what if the browser did this instead:\n\n`script1.js` loads and runs, then the first inline `<script>` block runs, which throws an error. Next, `script2.js` still loads and runs fine, but then the next inline `<script>` block **is never going to even be attempted**, because of the previous error. Lastly, `script3.js` loads, and tries to run, but since `doSomethingForScript3()` never even tried to run, now tons of errors in `script3.js` are going to spam your error logs.\n\nThink about that scenario for a moment. Is that scenario more or less surprising than the current native behavior (which you could describe as \"run as much of this stuff as you can\")?\n\nI'd say unequivocally that the current behavior is much better than this second hypothetical scenario.\n\n**That hypothetical scenario** is exactly what would happen if LABjs didn't catch-and-swallow errors inside of `wait()`. :(\n\nHopefully, that fully explains why we can't just let the errors be thrown.\n\n---\n\nNow, I bet the next thing you're wondering is, \"can't you just catch any errors but dump them all to the error log?\" Of course I can. That's what the debug build and debug mode is for!\n\nWhy didn't I just make the core do that? Because philosophically, I believe devs don't want, by default, to have errors that occur in production spamming the console logs of millions of users' browsers. By default, the production build of LABjs tries to be silent, while the debug build tries to be very chatty.\n\nYou have to specifically choose to do one of these things to opt into such verbose reporting:\n1. use the debug build and `DEBUG` mode of LABjs\n2. put your own `try..catch` around your inline `wait(..)` code that dumps errors yourself\n\nEither way, you are specifically saying, \"I want to see production errors\". I would hope you only do that when troubleshooting a problem, and not **all the time**, but even if you do it **all the time**, then it's you that had to opt-in to that, rather than having to opt-out.\n\nI call that [\"pit of success\"](http://blog.codinghorror.com/falling-into-the-pit-of-success/) rather than \"pit of failure\".\n\n---\n\nLastly...\n\n> how I'm supposed to know whether I'm having errors in production\n\nThis is a very important dev-ops type of question, but it's vastly more complicated than anything LABjs even remotely tries to tackle.\n\nYou'll note that just dumping stuff into the console of your users isn't telling you if you're having problems in production. If the kinds of problems you're trying to find are anything like the kinds I've run into, they don't happen for everyone, only some. So, you can't just rely on seeing the messages in **your console** when you run the production app.\n\nOdds are you're going to need to have a robust production monitoring solution in place. Perhaps something which sees if any JS errors happen and remotely logs those to your server logs.\n\nIf what happens by the error being swallowed is that some part of your app fails to get initialized, but the rest of it gets loaded, one thing that may occur is that other cascading errors will happen later when users click certain buttons (which your production monitoring would catch).\n\nAnother thing that could happen is that the error remains \"silent\". That is, most or all users don't even notice, or if they do, it's not a big enough deal that they care or complain.\n\nIf _that_ is the kind of error you're worried about missing, because you don't even know it's happening, stop and ask yourself, \"why am I so worried?\" If an error occurs, but no one notices, and it doesn't cause any other breakage, what is the big deal, and more importantly, why would dumping that into an error console help identify it?\n\n**I think the more likely scenario is** that you WILL hear about errors, through user complaints, or through your production monitoring solutions, or some other channel, and **THEN** you will know it's time to go (temporarily) flip on the debug mode of LABjs in production to start narrowing it down.\n\n**Bottom line: I doubt there really are that many \"hidden silent errors\" in production, when it comes down to real world scenarios playing out.**\n\nI'm sure I haven't convinced you, but hopefully this narrative helps explain more completely where my philosophy is coming from.\n. 1. You should always have at least an empty .wait() at the end of a chain, even if you have no logic to have it perform.\n2. Are you saying there's a 50ms delay before LABjs starts, or are you saying that each script starts 50ms after the one before it?\n. I don't really have an answer. There's no artificial delays inside of LABjs. It sounds possibly like a bug or network connection timing issue in IE8, especially since other browsers/versions don't exhibit the problem.\n. I appreciate your feedback. I agree with you that the documentation needs some love in both cases that you bring up. I have been kinda putting that off because 2.0 has been in development for awhile, and I planned to refresh the docs once 2.0 came out. Unfortunately, 2.0 has been more delayed than I would have hoped, because of issues with the browser vendors and the HTML spec.\n\nIn any case, I agree it needs attention, and if I can't get 2.0 resolved soon, I'll update the docs to more clearly state the situation as it applies to 1.2 (current release).\n\n---\n\nWith respect to your questions:\n1. Multiple $LAB chains are perfectly fine, and are encouraged. What is not fine, and is discouraged, is using the \"AllowDuplicates:false\" feature and relying on that across multiple chains. As several of the comments/issues threads reveal, this is not reliable. It's a major design goal of 2.0 to fix that. I just simply never considered in 1.x dev that this would be a common use case. Turns out it is.\n\nMoreover, if you're going to use separate chains, it's important to understand that they are in fact quite separate. If there's ever been a case where I implied to avoid them (not in the context of AllowDuplicates), it was almost certainly meant to say \"avoid using separate chains when one chain will do fine.\" This is because many people think that they should be able to load multiple scripts in different chains, and then get some sort of \"All Done\" message across the chains. I have had to explain numerous times that the intentional design of keeping the chains separate not only makes that quite awkward to do, but also violates the intended API design and usage.\n\nTo state more clearly: use indepedent chains when you have completely independent groups of scripts to load. If there's any depdendency at all, such as needing to \"gate\" to wait on both to finish, separate chains is perhaps not the best idea and a single chain is better.\n\nAlso, many people use LABjs in a \"CMS\" fashion, where they programmatically build up their script loading across many inline script blocks that the CMS includes into the final HTML from separate page templates, etc. Again, many people were in the habit of specifying a new chain for each snippet, and then were confused why the order preservation didn't occur. To them, also, I said \"avoid multiple chains\"... what they need is a single chain that they can conditionally build up across snippets, and then execute the whole chain. And for them, I built the \"queue\" mechanism. There's a gist for the \"queue\" functionality, to use now, in 1.2, but it's also going to be a native feature in LABjs 2.0.\n1. Should a chain be \"resumable\" later, meaning you could call .wait() on a chain that had already resolved itself? This is a dicey question. I understand the desire that people have to use the .wait() kinda like a special event emitter like jQuery's DOM-ready, where it will either queue and wait, or immediately fire if the event is already passed. I can understand the attractiveness of that design pattern.\n\nHowever, it partly violates the design principles that I had when building the API. The .wait() is not designed to be an \"event\"... it's a link in the chain when the chain executes. Once a chain finishes executing, resuming from it should really be an undefined behavior.\n\nTechnically, with some bug fixes I did in recent patches to LABjs, calling .wait() on a finished chain might very well work. But it's not really a supported or intended pattern. So I tell people to avoid trying to use the API in that way.\n\nMy answer to \"how do i do it?\" then is, keep track of a separate flag/event-signal externally to LABjs... and set that flag in your chain's final .wait(). When you later want to execute something, it's a simple check to see if the flag is set yet (in that case, execute immediately), or if not, THEN you can append to the in-progress chain, and it should work fine.\n\nThis roughly corresponds to how I'd recommend doing the same thing with jquery's DOM-ready... when you have some code to run, first check the document's readyState... if it's still loading, then queue up your code to wait for DOM-ready. If the document state indicates the DOM-ready has already passed, then you can just safely execute your code right away.\n\n---\n\nAnyway, I hope that dialog helps clear some things up. As I said, I agree that info would be useful in documentation. But, it's tough to figure out the level of detail and explicitness to put in such wording. On one hand, I want to discourage usage-patterns which are against the spirit of the API design... on the other hand, I want to inspire people to wrap $LAB with additional behavior as they see fit. $LAB was always intended to be a bare-bones building block for more complicated dependency management. In both of the questions you've asked above, the intention was that people would create wrappers around $LAB to manage those things. Problems started happening when people tried to massage the native API into doing it, in ways it wasn't intended.\n\nI welcome further feedback on how I can find that right balance for the documentation. In the meantime, I hope others do what you've done, when they have questions.. which is to first read the site documentation, then search the live discussion threads here to see deeper info.\n. Then why not:\n\n```\n<script>\n$LAB.script('framework.js').wait(function(){\n   $(document).ready(function(){ do_stuff(); });\n});\n</script>\n\n... <div id='important'></div> ....\n```\n\n?\n. \"because document.ready may take awhile to fire...\"\n\nUmm, `document.ready` fires pretty darn quick most of the time... it maybe takes a browser a few dozen milliseconds to parse the DOM and get DOMContentLoaded fired. `window.onload` may take longer, yes, because it has to wait on images to finish loading, etc. But in most cases, `document.ready` will fire quite quickly. The only known things that block `document.ready` are actual markup &lt;script> tags, but since you're using LABjs you probably don't have many or any of those. So, as long as you have your DOM pretty clean of stuff like that (you should anyway, for general user-experience), then `document.ready` will fire very quickly.\n\nMoreover, you shouldn't be making the assumption that just because you have a &lt;script> tag appearing after some DOM element, that this guarantees that the DOM element is ready for you to mess with. This is a common but flawed assumption. There are a number of factors (and older browsers) which invalidate that assumption. The best-practice and by far safer approach is to not do anything that interacts with your DOM until DOM-ready has fired.\n\n\"...furthermore, the point of this is decoupling the functions you call for a given dependency from the actual loading of them.\"\n\nThat may be _your_ point, but it's fundamentally opposite of the design goal of LABjs. LABjs is specifically about coupling your script loading to \"inline\" script logic, so that all your external and inline scripts will fire in the correct order, even though they are loading in parallel.\n\nThe primary/majority use-case for LABjs is not compatible with what you suggest. This is not something I forsee changing the API to support.\n. \"...I don't actually know whether or not I will want to call do_stuff() later in the page.\"\n\nSpecifically to this point, jQuery's implementation of `document.ready` is capable of doing what you suggest... you can have your code to interact with the DOM element wrapped, like so\n\n```\n$(document).ready(function(){ do_stuff(); });\n```\n\nAnd that code snippet can be called at any time in the life of the page, even minutes later. If DOM-ready has already passed, it'll execute right away. If DOM-ready hasn't passed yet, it'll wait for DOM-ready.\n\nThe only part of the scenario that YOU want that isn't possible with only the LABjs API, is a flag that tells you if a script has finished loading. Consider something like this, then:\n\n```\n<script>\nfunction func() {\n   $(document).ready(function(){ do_stuff(); });\n}\n\nvar framework_loaded = false, $L;\n$L = $LAB.script('framework.js').wait(function(){ \n   framework_loaded = true;\n});\n</script>\n\n... <div id='important'></div> ....\n\n<script>\n// at some later time, either during the \n// loading of the page, or much later, like \n// when a user clicks some button, etc\n          if (framework_loaded) func()\n          else $L.wait(func);\n</script>\n```\n\nPerhaps that comes closer to what you want to accomplish.\n. Does the snippet I posted in my previous response give you any possible approach that works?\n. FWIW, in LABjs 2.0, chains will be completely resumable, so your original snippet will work just fine (with a few minor tweaks):\n\n```\n<script>\nvar $L = $LAB.script('framework.js');\n</script>\n\n... <div id='important'></div> ....\n\n<script>\n$L.wait(function() {\n    do_stuff()\n});\n</script>\n```\n\nHope that helps.\n. LABjs 2.0 work is completely taking a different approach to the source code. For the most part, the source code will not have (m)any minification tricks in it (nothing crazy/ugly anyway).\n\nHowever, there will be a set of transform diffs (patches) run against the source code to \"ugly'ify\" it to make it more prepared for minification and gzip compression.\n. This is (unfortunately) a known issue, where \"AllowDuplicates\" does not work properly across multiple chains. It is only intended to work to de-duplicate within a single chain. A major design goal of 2.0 is to address this limitation.\n\nThe workarounds in the meantime:\n1. Rework your code to only use a single chain (sometimes possible, especially with the \"queueing\" add-on).\n2. Keep track of duplicates across chains by setting some external flag and using logic to delay until it's fully loaded.\n3. Load the framework in a single chain, and inside the .wait(), fire off the other chains... slight downside in that the framework isn't in parallel with the other chains, but it's not a terrible perf hit.\n. this issue with \"allowduplicates\" not working correctly between chains is being fixed in 2.0.\n. this is fixed now in 2.0a.\n. I think it's a good idea to have the \"id\" be a settable attribute. I'll add that in for 2.0.\n\nHowever, note that, cross-browser support for loading a resource type that is not \"text/javascript\" is not supported. So, the snippet you show above is not possible cross-browser, because some browsers won't load an external resource if the type attribute is \"text/x-jquery-tmpl\".\n. you can do so for local template loading, but not for cross-domain... because the LABjs API doesn't really distinguish between making local loads and cross-domain loads, it's not really something that LABjs would be focused on for its core API... LABjs is all about loading a JS file and executing it, so loading other non-JS resources is really outside the scope of what the library is focused on. Of course, you can do XHR to load external templates yourself. The code to load and inject is pretty small, maybe 10-15 lines of code.\n. To further elaborate... LABjs _could_ have logic in it that basically says, if the \"type\" is not \"text/javascript\", i'll only load it locally with XHR, and do an \"injection\" as normal. But then, the question is, how should the LABjs API respond if you ask for it from a cross-domain? (remember, it's quite common for people to host files on CDN's)\n\nI could refuse to load it, or throw some error, or something like that. But it complicates the API and makes it harder to use.\n\nI think the biggest problem is, people want to use LABjs as a \"resource loader\" when in fact, LABjs is only focused on being the best \"JavaScript loader\"... templates, CSS, etc... those are all good resources to load, but they're not the focus of LABjs.\n. i could consider having a \"debug\" mode where you'd get console.log()'s for each action that LABjs takes... would that be helpful?\n. Hmm... I'm not sure I'd want to be that invasive to the current LABjs namespace as to have a set of publicly available arrays, etc.\n\nI think you could solve what you're wanting even for IE<=8 with something like:\n\n```\nvar global_console = [];\nif (!window.console) {\n   window.console = { log: function() { global_console.push.apply(global_console,arguments); } };\n}\n```\n. there will be some sort of error logging and/or debug mode for LABjs 2.0. Still in the works.\n. LABjs does not support a native behavior to \"disable caching\". In fact, in some browsers, LABjs explicitly relies on caching for its preloading (as do most other loaders).\n\nThe behavior you describe is a well-known \"issue\", where the browser won't re-validate dynamically loaded resources under some conditions, forcing you to clear your cache and refresh, instead of a shift+refresh that would normally revalidate and reload changed resources. The behavior is quite unfortunate for developers who use dynamic resource loaders. I am personally tracking a couple of bugs at both Webkit and Chrome for this exact problem (and other browsers have it too). What we're asking for is a \"super refresh\" where all resources will unconditionally be revalidated, regardless of how they were loaded. I hope the browsers give us that soon.\n\nFor the time being, in development, the best I can suggest is:\n1. Disable preloading with `UsePreloading:false` (the other parameters are unnecessary, as this one trumps them).\n2. Append a \"cache bust\" param to the end of every URL, like `\"?_\"+Math.random()`, to force the browser to reload the resource new every page load.\n\nThis is of course terrible behavior/performance, and should only be used for development. In production, turn Preloading back on and don't add the cache-busting param.\n. I'm not sure if that feature makes sense, given the current reliance on caching. But I'll keep thinking about it.\n. So, as of LABjs 2.0, older webkit (prior to about 2 months ago) will be the only browser that LABjs uses \"cache preloading\" on. There will be other forms of parallel/preloading in other/newer browsers, but they won't be based on preloading into the cache.\n\nAs such, the question for this feature request becomes, should I give a feature to disable caching (which will work in most browsers)? I'm inclined to see the value here, so maybe, yes. \n\nBut, what should the feature do in older webkit? If you have it turned on, should it turn off preloading (and go to serial loading) for those older browsers? Or should the cache-disabling be ignored in those older browsers? It's clear that cache-preloading would be totally incompatible with cache-busting, so this question needs to be resolved before I can land such a feature. Frankly, I'm not quite sure which way to go on it. Thoughts?\n. There's now a \"CacheBust\" configuration parameter for this behavior in 2.0a\n. what's the use-case for appending the same query string to all scripts? Is this for cache-busting?\n. what's the use-case for appending the same query string to all scripts? Is this for cache-busting?\n. i'm considering this request:\n\nhttps://github.com/getify/LABjs/issues/27\n\nIf I do that, it should serve your use case, correct? Still have to figure out how things should behave in older webkit, but once that's resolved, I think \"disable-caching\" will make it in.\n. hmmmm... i see why you want this feature, but i'm not entirely convinced it should be baked into a script loader. seems like a fairly limited use case. The more common case seems to be to want a random cache-busting-everytime parameter added (like in dev). With implementing this feature as you've requested, I'd either have to implement both, or the (what i think is more common) use-case of always-cache-bust would require the user to do more \"work\" by calling `Math.random()` themselves (albeit only once, in the config setting).\n\nYour use case on the other hand, being (I think) less common, is easily solvable with a JS variable:\n\n```\nvar _ver = \"?_=20110515\";\n$LAB.script(src1+_ver).script(src2+_ver).wait(...).....;\n```\n\nYes, that's more work, but I'm inclined to believe that perhaps that's the way it should be, because a loader really shouldn't be doing (IMHO) semantic things to determine which resource URL you mean to load. LABjs is very strict and limited in what interpolation it does on a script URL... it only currently will do canonicalization (something browser already does, so LABjs just mimicks), but it won't do anything else to a script URL (even capitalization normalizations).\n\nThe suggested issue #27 is adding more on-the-fly modification of the source URL, but only in a completely clear use-case of disabling caching, not anything about specifically picking a particular script resource by query string.\n\nThis is a fine line subjective judgement call here, but I think LABjs should default to forcing the calling code to be explicit about which URL resource it wants loaded, rather than baking in features where LABjs automatically guesses. I could imagine someone asking for LABjs to automatically add the \".js\" extension, or automatically append other query string information like run-time variables (UA, etc) in the same vein, and I think those would ill-advised feature-creep for a script loader, so your request feels a tiny bit like the slippery slope toward that.\n\nI haven't made a final decision yet, just sharing my rationale at this point. Comments welcomed.\n. now that LABjs 2.0a is basically feature complete, i'm going to investigate what type of footprint (increase in size/complexity) it takes to accomplish this correctly. Then we'll have some numbers to debate about. More soon.\n. I think this request is a feature I'll consider for 2.1. 2.0 is complete and ready to go and I don't want to introduce any more changes to it. But I'll revisit this request for the next release, and see what of it makes sense.\n. I appreciate your time to explain your request for LABjs. I'm not really sure this use-case fits cleanly onto the intended API philosophy for LABjs. What you're asking for is a valid, but rather niche, use-case, which is two separate scripts that:\n1. have a common script (or scripts) as dependencies in the upstream of the chain; AND\n2. download in parallel; AND\n3. execute in first-come-first-served order; AND\n4. each has a different set of coupled-code that should execute after it finishes\n\nIt's specifically #4 which throws the wrench into the general design philosophy of LABjs, which is to organize trees of loading logic into separate, single-path branches (chains). Because you're basically trying to create a conditional-branching path chain with coupled code execution.\n\nIn LABjs' design philosophy (and achieving by default the maximum parallel loading performance), you can have 1+2+3 or 2+3+4, but not really 1+2+3+4.\n\n1+2+3:\n    $LAB.script(\"a.js\").wait()\n    .script(\"b.js\")\n    .script(\"c.js\")\n    .wait(...);\n\n2+3+4:\n    // notice, no upstream \"a.js\" dependency\n    $LAB.script(\"b.js\").wait(init_b); // these are totally separate chains, and thus execute first-come-first-served\n    $LAB.script(\"c.js\").wait(init_c);\n\nSo, how do we get 1+2+3+4:\n    $LAB.script(\"a.js\").wait(function(){\n        $LAB.script(\"b.js\").wait(init_b); // these are totally separate chains\n        $LAB.script(\"c.js\").wait(init_c);\n    });\n\nThis will work ok. BUT, it has the disadvantage that b.js and c.js will not be downloading in parallel with a.js. So, you lose some performance with that pattern. So that's the caveat with the 1+2+3+4 niche of use-cases.\n\n## Also of note... some browsers (FF, Opera) do not support the use-case of first-come-first-served execution , if any of the scripts are remote, without exceptional hacks (extreme brittle cache preloading) that LABjs does not employ. So this feature use-case would be irrelevant (meaning \"b.js\" would ALWAYS execute before, and thus block execution of, \"c.js\") for users in those browsers in that case. In general, I don't design a functionality unless it can reasonably be supported cross-browser.\n\nThe question remains... should I extend (and complicate) LABjs to support this use-case (for IE/Webkit)? In general, I'm leaning toward \"no\". I think it's a rarer use-case in the broad scope of things, with the additional negative of being limited to only some browsers. Simplicity of code (leads to smaller, faster loading code) _and_ simplicity of API design call for minimalism and for trying to serve, generally, the majority use-cases.\n\nThis is all to say, it's not an outright no, but I'd have to be more convinced that the use-case is less niche than it seems to me at the moment. I'd have to be convinced that the performance degradation of the workaround I provided is worse than the extra baggage of baking this natively into LABjs. If you find more concrete examples of why this is a necessary addition, please do share.\n. In your scenario, you didn't address why \"slider.js\" and \"lightbox.js\" have to be able to be initialized in \"first-come-first-served\" order... that's the specific part that I think makes your use-case more niche.\n\nLABjs will in fact run the files themselves in that fastest-first order (in IE/Webkit), if you do:\n\n```\n$LAB\n.script(\"jquery.js\").wait()\n.script(\"slider.js\")\n.script(\"lightbox.js\")\n.wait(function(){\n    init_slider();\n    init_lightbox();\n });\n```\n\nBut they won't initialize until both of them are ready to initialize. You still however get the most benefit out loading your scripts in parallel (all 3 will load in parallel), and the only tradeoff is that the initialization of one of the plugins may be held up until both are ready to initialize.\n\nBut, I'd argue this is better UX in general, for end users, rather than to have part of the page initialize but another part of the page be still unusable. When I go to sites like that, it's frustrating to me.\n\nKeep in mind: LABjs' simple design goal is to make loading and executing of scripts as fast as possible (for the general case). It's not so much about making scripts run as soon as humanly possible.\n\nIf two scripts really are completely independent, you can achieve complete separation by doing the separate chains. If they're not independent, then I think it's more trouble than it's worth (from the code and API perspective) to support this mixed mode where there's sort of run-time conditional dependencies within the chain.\n\nAs stated before, the other possible tradeoff to make is:\n\n```\n$LAB\n.script(\"jquery.js\").wait(function(){\n    $LAB.script(\"slider.js\").wait(init_slider);\n    $LAB.script(\"lightbox.js\").wait(init_lightbox);\n });\n```\n\nThat basically accomplishes what you want, except that the plugins wait to download until after jquery loads.\n\nI think either of those two (while a slight compromise performance wise) is a decent concession/work-around while preserving the design philosophy of the LABjs API.\n\n> Hmm, couldnt this possibly be solved for the hosting-yourself case, by xmlhttprequest the items, and then eval them?\n\nYes, you can easily accomplish it with XHR, if all the scripts in question are local. However, LABjs is focused on the general case, where some or all scripts come from remote locations. As such, it has to assume that it may not be able to use XHR.\n\nI generally don't design a feature for LABjs that only works if you happen to choose all your scripts to be local, because all the other people who use LABjs where some scripts are not local don't benefit from the feature, and in fact, in some cases, a feature may outright not work for them. So, I only consider features which have reasonable behavior for the general \"worst-case\" type scenario.\n. i just don't think the value outweighs the cost... yet. but i may be convinced otherwise if i see more use-cases.\n. this will likely not make it in for 2.0, as i still have doubts about the value compared to the extra script complexity. but i will revisit the topic after 2.0 is stable. closing for now, will re-examine later.\n. dynamic script loaders, by definition, unblock the script loading from affecting the page's initial processing/rendering (aka, they do not block DOM-ready). However, in most browsers, they do still block `window.onload`.\n\n`$L.block_rendering()` would be impossible to achieve, as the only way to do that would to either have a `&lt;script>` tag in the markup, or `document.write(..)` one, which wouldn't work if $LAB were being used dynamically to load scripts at a later time.\n\nI'm confused a bit by your code snippet. You're loading a file with LABjs called \"adscript.js\". Is this the file that has the `ad_server_function_uses_doc_write()` function defined in it? As it stands, you can't do it the way you've shown with LABjs, because the $L.script() call will be asynchronous, but your inline script block with that function call in it will execute immediately in the thread. You'd have to do something like:\n\n```\n$LAB.script(\"adscript.js\").wait(function(){ ad_server_function_uses_doc_write(); });\n```\n\nBut, since that script has (and requires) document.write(), it has to run in place, and is incompatible with being loaded/run by LABjs (or most script loaders, for that matter).\n\n```\n<script src=\"adscript.js\"></script>\n<script>ad_server_function_uses_doc_write();</script>\n```\n\n...is probably the best you can do, if `document.write()` is required.\n\n> Also, can i use LABjs as preloader? to download scripts and not execute them?\n\nThe browsers do not yet give us a consistent/non-hacky way to accomplish this. The only loaders which allow it are relying on ugly hacks like cache-preloading. I have not put in such a feature into LABjs because I don't think it's responsible to base functionality primarily on hacks, so I will wait to introduce such functionality until it's a directly supported feature in all current releases of the major browsers.\n\nThere's hope though, because IE _does_ support it directly (has since IE4), and the spec even suggests wording which makes an explicit preloading mechanism of that sort quite feasible. We just have to get other browsers to implement the suggestion (or get it turned into a requirement!). LABjs 2.0 includes future-thinking feature detection for this functionality, and in fact uses it for normal LABjs loading in all versions of IE (in replacement of cache-preloading for that browser use-case).\n\nMore info on explicit preloading proposals: http://wiki.whatwg.org/wiki/Script_Execution_Control\n. closing for now as unresolvable\n. i have to admit this is strange behavior that i would not expect. if you look at the firebug net panel, DOM-ready is in fact _not_ being blocked, but the `window.onload` is (obviously, as expected) blocked. what it seems like is that jQuery is waiting for `window.onload` to run the `$(document).ready(...)` stuff, which is bizarre. i can't think of anything that LABjs would be doing to cause this. needs further investigation, but i suspect it's something quirky in the internals of jquery.\n. As near as I can tell from my brief looks into this, LABjs is not the cause. LABjs does nothing to delay the DOM-ready of the page (in fact, it acts to unhinge script requests from the DOM-ready). This is especially true of any browsers that are not FF3.5 and below. In FF 3.5 below, LABjs does \"patch\" the _page_ for the fact that a `document.readyState` is not present in that browser. Doing so is to assist something like jQuery in doing DOM-ready detection.\n\nBut since this code only affects FF 3.5 and below, it is almost certainly not the cause of what you're seeing. I would suggest constructing a test page without LABjs where you manually load scripts dynamically with `document.createElement(\"script\")` and see how the page behaves with respect to the images blocking DOM-ready.\n\nWhat I believe this will boil down to is probably quirks/bugs with the browser(s) that will need to be filed, not with there being something that LABjs is doing to create this side-effect.\n\nFYI: please make sure any bugs you are reporting now are with LABjs 2.0, as 1.2 is now the old-stable, and 2.0 is the new version (about to be fully released).\n. Closing this for now, as I haven't been able to confirm it.\n. You can set the `BasePath` config variable, either globally (for all chains), or per-chain... why is that not sufficient?\n. Closing as BasePath seems to be sufficient for the OP\n. the debug code is simple to remove with regex pre-processor:\n\n/\\/*!START_DEBUG(?:.|\\n)+END_DEBUG*\\//\n\nThat's exactly how, in my editor, I prepared the code before running it through the minifier(s).\n\nThe other option is to just simply re-minify the non-debug minified LAB.min.js file...or, some build processes allow you to make exceptions to exempt files from minification.\n. what problem will reminification cause? YUIC is a safe compressor so it shouldn't do anything but rename a bunch of already shortened variables, and possibly inject a few extra semicolons that it believes are important.\n. I added a section to the documentation to make this more clear. Thanks for the question.\n\nhttp://labjs.com/documentation.php#builds\n. In your code snippet, the problem is that you're passing a function to `queueScript()`... passing functions to `script` or `queueScript` cause them to be executed immediately, so that the value they return is used as the src for which script to load. So your function is being run immediately, before jQuery has had a chance to run. This is by design.\n\nIf you want to queue up an inline block of code (that's what it appears from your block), and not have a function that is supposed to return a script URL, but instead have it wait for the appropriate sequence in the chain, then you want to pass that function to queueWait() instead. So, it would look like:\n\n```\n<script>\n$LAB.queueScript(\"/misc/jquery.js\");\n</script>\n<script>\n$LAB.queueWait(function() {x={};jQuery.extend(x, [test:1});});\n</script>\n```\n\nIn your example, there's no need for the empty `queueWait()` at the end of line 4 (though it doesn't really hurt anything being there or not).\n\nThe thing to remember is, $LAB chains work with `.script()` and `.wait()` calls... `.script()` calls specify URLs to load, whereas `.wait()` calls specify either/both where execution order needs to be preserved (as an `.wait()` call with no function passed to it), or where an inline script block needs to wait to run until that point in the chain. The queueing system is no different, except that the chain which you queue up isn't started/processed until you run `runQueue()`. But `queueScript()` corresponds to `script()` and `queueWait()` corresponds to `wait()`.\n\n---\n\nAs for your issue with scripts not running quickly enough... if you don't want queueing, which implies delaying the start of the processing of the queue until you call `runQueue()`, then simply use a regular `$LAB.script(..).wait(..)` type call, which will start loading right away. Your choice. But the purpose of the queue is so you can specify a chain ahead of time, but choose when you want to run that chain yourself. So you have that option if you use queuing.\n. closing for now, this doesn't appear to be a bug but incorrect usage. hopefully it's cleared up now.\n. The problem is it is not possible to load a script but not execute it, at least not in all browsers, and not without hacks. LABjs as of v2.0 is de-emphasizing hacks, and moving towards what is standardized and possible through intended and direct interfaces and functionality.\n\nEventually, we should be getting \"real preloading\" from the browsers, which means that we will in fact be able to preload the scripts but still choose when to execute them. But for now, this is only possible in IE, and so the LABjs API does not expose such functionality.\n\nAt that point, we can revisit if it makes sense to pre-emptively preload scripts while in queueing. However, even then, I'll be skeptical if that's the right approach, because someone might define several queues of scripts but only load one of them, in which case all the preloading of the non-used queues would be wasted.\n. NO, LABjs definitely loads all scripts in parallel (as much as the browser will allow it). It uses different tricks in different browsers to ensure that parallel-loaded scripts execute in order. But this is _not_ the same thing as being able to defer the execution until any arbitrary point in time. In most browsers now, LABjs uses \"ordered async\" (async=false), which tells the browser to load them all in parallel, but execute them in the requested order. The key point is \"tells the browser\", meaning the browser does it as soon as it can, not under LABjs' control.\n\nI assure you that LABjs' loading is at or faster than the browser will do by default with <script> tags. That's the whole point of the library.\n. The point you are missing is, there's only two options possible in browsers (consistent without hacks):\n1. Load right now, and execute right after... for this, use $LAB.script(..).wait(..) chains\n2. Load later, on-demand, and execute right after... for this, use queuing.\n\nNotice in both options, execution has to happen right after loading has finished. There's no choice about this. It's not possible in current technology (without hacks). When it's possible with standardized tech, then I will put that type of feature into a future release of LABjs.\n\nSo, the only choice you have to make is, do I want script loading to start right away (use $LAB chains), or do I want script loading to start at some point slightly later, when I want, on-demand (use queueing).\n\nI don't understand why you want queueing to start loading right away? $LAB chains start loading right away. So use them instead.\n\nIt seems like you think there should be some way for queuing to load now, but not execute until `runQueue` is called. This is just not possible.\n. chains are resumable, which means you can manually store the result of a chain, then add onto that chain later in another script element, like:\n\n```\n<script>\nvar $L = $LAB.script(\"script1.js\");\n</script>\n<!-- ... -->\n<script>\n$L = $L.script(\"script2.js\").wait(function(){ /*...*/ });\n</script>\n<!-- ... -->\n<script>\n$L = $L.script(\"script3.js\");\n</script>\n```\n\nThat should allow you to specify your chains across multiple script blocks, but still have the loading starting right away as soon as each `script()` call is made, instead of waiting using queueing.\n. In most browsers, the browser is in control of execution, not LABjs, and so ordered execution is expected behavior (the definition of ordered-async/async=false is exactly that). Again, until we get \"real preloading\", that's the best we can do (without hacks).\n\nAs for your claim that the `.wait()` callback is happening _after_ a subsequent `.script()` call is executed, that should definitely not be the case. Can you point me to a live demo that demonstrates that behavior? Is that in FF4? FF5?\n. fixed in 2.0.1\n. in progress. check your messages.\n. jpcarlino: what you are describing is not the same as the bug here, though I can see how it would seem that way from the small amount of info available in the description.\n\nIn your case, what you need to understand is that functions passed to `.script()` are all executed immediately (they don't \"wait\" like functions passed to `.wait()` do). The reason for this is that their primary purpose is to resolve (immediately) what scripts the chain should load, so that it can load in parallel.\n\nIn most cases, you can know what scripts you want to load all at once, and so LABjs can load them in parallel. In a few rare cases, you must wait to finish loading one script before you can know what the next script should be. In those cases, you should use a nested $LAB chain, instead of trying to load them all in one chain (because in that case, parallel is simply not possible -- chicken and the egg: how can you load a script now if you don't now know what the script URL is?)\n\nIn your case, you could approach it that way. But I think there's a 3rd option which I'd suggest, but you'll have to be very careful about some details. Consider:\n\n```\n(function () {\n   function load_my_scripts() {\n      var needs_jquery_142 = typeof jQuery === \"undefined\" || jQuery().jquery < \"1.4.2\";\n      var needs_jquery_ui_172 = needs_jquery_142 || typeof jQuery.ui === \"undefined\" || $.ui.version < \"1.7.2\";\n\n      var $ = (!needs_jquery_142) ? jQuery : null; // if we need to load jQuery 1.4.2, leave alias empty for now, otherwise set alias\n      var $ui = (!needs_jquery_ui_172) ? $.ui : null; // if we need to load jQuery-UI 1.7.2, leave alias empty for now, otherwise set alias\n\n      $LAB\n         .script(function(){\n            if (needs_jquery_142) {\n               console.log(\"loading jQuery 1.4.2\");\n               return \"http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js\";\n            }\n            else {\n               console.log(\"jQuery \" + jQuery().jquery + \" already loaded\");\n               return null; // no need to load anything\n            }       \n         })\n         .wait(function(){\n            if (needs_jquery_142) {\n               console.log(\"jQuery 1.4.2 now loaded\");\n            }\n            else {\n               console.log(\"using jQuery that was already loaded\");\n            }\n         })\n         .script(function(){\n            if (needs_jquery_ui_172) {\n               console.log(\"loading jQuery UI 1.7.2, with jQuery \" + (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n               return \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js\";\n            }\n            else{\n               console.log(\"jQuery UI \" + jQuery.ui.version + \" already loaded, with jQuery \" + (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n               return null; // no need to load anything\n            }\n        })\n        .wait(function(){\n           if (needs_jquery_ui_172) {\n              console.log(\"jQuery UI 1.7.2 now loaded\");\n              $ui = jQuery.ui; // now we can capture the alias for jQuery UI\n           }\n           else {\n              console.log(\"using jQuery UI that was already loaded\");\n           }\n           if (needs_jq_142) {\n              $ = jQuery.noConflict(true); // now we can capture the $ alias by calling `noConflict()`\n              $.ui = $ui; // restore jQuery UI alias lost in `noConflict()` call\n           }\n           console.log(\"jQuery >= 1.4.2 and jQuery UI >= 1.7.2 are ready\");\n        });\n   }\n\n   var LABjs_loaded = !(!$LAB);\n\n   if (LABjs_loaded) {\n      load_my_scripts();\n   }\n   else {\n      var script = document.createElement(\"script\");\n      script.src = \"lib/LAB.js\";\n      script.onload = script.onreadystatechange = function () {\n         if ((script.readyState && script.readyState != \"complete\" && script.readyState != \"loaded\") || LABjs_loaded) return;\n         script.onload = script.onreadystatechange = null;\n         LABjs_loaded = true;\n         load_my_scripts();\n      };\n      document.body.appendChild(script);\n   }\n})();\n```\n\nTry that out and see if that does what you want/expect.\n. The function you have listed here, which is passed to `.script()`, runs right away (before jquery 1.4.2 has loaded, IF it's even going to load -- won't load at all if >= 1.4.2 is already there).\n\nSo, inside that function, I'm asking some questions at the time of starting our loading requests:\n1. do we need to load jquery 1.4.2 (or are we using the existing copy of jquery that is >= 1.4.2)?\n2. are we also loading jquery-ui 1.7.2 (or are we using the existing copy of jquery-ui that is >= 1.7.2)?\n\nIf we need to load jquery 1.4.2, then we do. If we need to load jquery-ui 1.7.2 then we do. If not, to either of those, we simply skip over the `.script()` call for that particular resource, which lets LABjs just move on immediately. So, if jquery 1.4.2 is present, but jquery-ui 1.7.2 is not, then the first `.script()` call is basically a no-op (doesn't load anything), except that it prints to the console what's happening. If both are present, then both `.script()` calls are no-op's. If neither are present, then both `.script()` calls request their respective resources.\n\nThe `console.log()` statement that you reference means \"I am now loading jquery-ui 1.7.2, and i'm loading it on top of jquery x.x.x\", where \"x.x.x\" is either \"1.4.2\", since we requested to load that version, or it's whatever version of the jquery that's already present, which we know will be >= 1.4.2.\n\nAs for your question: how do I know if jquery-ui will run after jquery, and thus load on top of it? because that's how LABjs works... if you have a `$LAB.script(\"a\").wait(...).script(\"b\")` chain, then LABjs always ensures that \"a\" runs before \"b\". In your case, we're also combining in conditional logic, which says that \"a\" doesn't need to run if the \"a\" is already present on the page. \n\nBut either way, we're sure that \"a\" is present (in this case, jquery >= 1.4.2) before \"b\" (jquery-ui 1.7.2) runs. Furthermore, we're sure that if both \"a\" and \"b\" are already present in the page, and no loading is necessary, then the chain's final `.wait()` call will run after \"a\" and \"b\" are both satisified (either loaded and executed, or detected to already be present).\n. One final note... I make the assumption in my code snippet above that the case of \"jquery already present, but < 1.4.2\" and \"jquery-ui already present, but >= 1.7.2\" is either not possible, or if it happens, then it's still best to load both to be safe. In other words, there's not logic in there to load only jquery but not jquery-ui... if you have to load jquery, then you will have to load jquery-ui.\n\nThat logic is essentially enforced here:\n\n```\nvar needs_jquery_142 = ...\nvar needs_jquery_ui_172 = needs_jquery_142 || ...\n```\n\nSo, we determine that we need jquery-ui to load IF:\n- jquery is being loaded; OR\n- jquery-ui is missing; OR\n- jquery-ui is present, but a lower version\n. fixed in v2.0.2\n. looking into it. baffling really. Packer (without base62) is what I used (via compressorrater) since it was the smallest. But shouldn't have done anything remotely dangerous in terms of minification.\n. haven't been able to confirm this bug or not. closing for now. please re-open if you can provide a reproduce-test.\n. I think you're right, the splice call is needlessly verbose as written. it should just be `script_list.splice(splice_args)`.\n\nI'm not sure I understand your second question. `$LAB.script(\"test1.php\", [\"test2.php\", \"test3.php\"])` should in fact load all 3 scripts. Are you seeing it not do so?\n. I'm sorry, I still don't understand your question. In your example, is it loading all 3 scripts or not?\n. OK, I see and can reproduce the problem... very strange. But thank you for the bug report. I'll get on fixing it.\n. OK, I figured out what the bug was, and have fixed it (will come out in 2.0.2 when I get that release out, asap). Those few lines now read (including comments to explain what the heck I was doing!):\n\n```\nif (is_array(script_obj)) {\n   // set up an array of arguments to pass to splice()\n   splice_args = [].slice.call(script_obj); // first include the actual array elements we want to splice in\n   splice_args.unshift(j,1); // next, put the `index` and `howMany` parameters onto the beginning of the splice-arguments array\n   script_list.splice.apply(script_list,splice_args); // use the splice-arguments array as arguments for splice()\n   j--; // adjust `j` to account for the loop's subsequent `j++`, so that the next loop iteration uses the same `j` index value\n   continue;\n}\n```\n\nThanks again for helping find this bug!\n. fixed in v2.0.2\n. v2.0 includes two API functions for managing multiple LABjs instances. Unfortunately, neither of those were present in LAB 1.x, so if you happen to load 1.x onto a page over the top of a 2.x+ instance, it will pave over it mercilessly without recourse. :(\n\nBut, if you load 2.x+ on top of an existing LAB instance, you can call `noConflict()` on the most recent one, which will roll back LABjs to the previous one (the one it was when it loaded) and return you the new instance in case you want it. This works basically quite the same as jQuery's `noConflict()`, so I felt that was such a good pattern I just mirrored it.\n\nYou can also use the `sandbox()` API function on an existing copy of LABjs, which creates a new instance of LABjs that is not tied to the global `window.$LAB`. Whereas `noConflict()` is a reactive method that you call once a new LABjs has been loaded onto a page, `sandbox()` is a proactive method that you call defensively, when you first load LABjs. Basically what it does is give you a separate copy of LABjs from the global copy, which means all your internal state will be kept safe in that copy, as long as you keep a reference to that copy around.\n\nEither or both of those methods may be something that can help with your situation. BUT, I think it's possible there's a simpler approach that doesn't need either one.\n\nIf you simply capture a reference to the global `window.$LAB` before using it, and then everywhere that you use LABjs, always use that captured reference instead of relying on the global, then you will be sure to always keep your own copy of LABjs. When/if a second copy of LABjs is loaded and overwrites the global one, you still have reference to the copy, which means your copy will continue to function as you expect. The key is to make sure that you always reference $LAB using your reference, instead of the global reference.\n\nThat might look like this:\n\n```\n<script src=\"LAB.js\"></script>\n<script>\n(function($L){\n    // all my code inside here now uses $L instead of $LAB or window.$LAB\n    // so I'm safe if someone overwrites the main window.$LAB instance\n})($LAB);\n```\n\nLemme know if any of that helps address your issues.\n. The \"don't load LABjs twice\" part is actually contrary to the use-case that caused me to add `noConflict()` and `sandbox()`. I had many people with use-cases around needing to maintain separate copies of LABjs. So, I'm not quite sure how I could cleanly serve both the use-cases: \"do allow LABjs to gracefully load multiple times' and \"don't allow LABjs to load multiple times\".\n\nIn my original interpretation of your question, it seemed like you were in a non-trusting, non-cooperative scenario. By that, I mean, it seemed like you were in a case where some page or code you don't control might come along and load a LABjs instance over the top of yours without your consent. In response to that, the above 3 solutions I talked about are ways for you to protect yourself from such a case. And in that vein, you would actually want for that other code to not use the same copy of LABjs as you were using, because you'd want for the two to not be able to interfere with each other.\n\nConsider for example the case where your self-contained widget might get loaded into a \"hostile\" (that is, not one you know or control) page. That page may or may not use LABjs itself. But your widget should be able to use its own private copy of LABjs, regardless of what the page does or does not do with respect to LABjs. That's why `noConflict()` and `sandbox()` are useful, to allow silo'd copies of LABjs to work independently of each other.\n\nOn the flip side, if you're loading into an environment where there is explicit trust and control, and you can have the environments cooperate, then you don't need those defensive tactics at all. In that case, you want them to \"cooperate\" on their shared copy of LABjs, so as to take advantage of `AllowDuplicates`, etc.\n\nTo rephrase the cooperation issue... you need to have all pieces of your code that need LABjs to do a \"conditional load\" of LABjs... that is, each piece of code that uses LABjs needs to check and see if LAB is already loaded, and only load it if it's needed. That way, whichever piece of code runs first on a page, LABjs will be loaded, and all other pieces that run later will simply skip over loading LABjs.\n\nThis type of cooperative conditional loading is generally quite easy. And it DOES NOT require `document.write()`. :)\n\nTo conditionally load LABjs, all you have to do is this:\n\n```\nfunction LABjs_is_ready() {\n   // put your code to use LABjs here\n}\n\nif (!$LAB) {\n   var scriptElem = document.createElement(\"script\"), scriptdone = false;\n   scriptElem.onload = scriptElem.onreadystatechange = function () {\n      if ((scriptElem.readyState && scriptElem.readyState !== \"complete\" && scriptElem.readyState !== \"loaded\") || scriptdone) return false;\n      scriptElem.onload = scriptElem.onreadystatechange = null;\n      scriptdone = true;\n      LABjs_is_ready();\n   };\n   scriptElem.src = \"/path/to/LAB.js\";\n   document.head.insertBefore(scriptElem, document.head.firstChild);\n}\nelse LABjs_is_ready();\n```\n\nAll you need to do is make sure that any page or code which loads LABjs does so conditionally, like this, and your cooperation should be fine to make sure that `AllowDuplicates` functionality works for different consumers of the $LAB api.\n. > Isn't the answer to this straightforward? To get a new instance of lab, \n> you call $LAB.sandbox(). Manually loading LAB.js twice on one page would \n> not overwrite the $LAB global.\n\nBut there's a strong precedent in javascript libraries (jQuery, for instance) to overwrite when loaded again, and to allow rolling back with `noConflict()`. I have to believe there's a reason that most every other script out there doesn't do what you're suggesting.\n\nSpeaking of `noConflict()`, seems like it could solve quite trivially your issue, now that I think about it. Consider:\n\n```\n<script src=\"LAB.js\"></script>\n<script>\n(function(){\n   var $L = $LAB.noConflict();\n   if (!window.$LAB) window.$LAB = $L; // $LAB was rolled back too far, so restore it!\n})();\n</script>\n```\n\nIn that way, you ask to load LABjs every time, and you always roll it back with `noConflict()`, and only if you've rolled it back too far (that is, there's no $LAB anymore), then you re-assign the global. Now, in all your code, always use the global $LAB, and you should be fine. This makes sure there's only ever one instance of $LAB running on a page.\n. What you are asking for makes sense, and is a common request, however it's not possible (short of hacks) in today's browsers, because we don't have a way to load a script but tell it not to execute until we ask it to. That would be required in your pattern, to get \"bar.js\" to load, but not execute, and then we get to choose when bar.js executes. This is not possible without preloading, and preloading (currently) requires hacks (which LABjs now disavows). Preloading will eventually come to browsers, and when it does, this will be easy.\n\nThere are three options for you:\n1. use a loader that uses hacks (Steal being one such example)\n2. wrap all your files in function declarations, that way the file itself can execute in any order, but you get to choose when the payload is executed, by calling and executing the wrapper function at the appropriate time. This is basically like the AMD module format that RequireJS and others use. But you can come up with your format and call your own functions, instead of having to use AMD and RequireJS.\n3. You can load files serially (loss of performance) if there's dependencies... it gets a little messy, but basically you put into each file a \"trigger\" that tells the framework to load the next file when the file in question is done with all its dependencies. \n\nFor instance:\n\n```\nvar q = [\"foo.js\", \"bar.js\", \"baz.js\", ...], q_idx = 0, pause;\nfunction next_in_queue() {\n   pause = false;\n   if (q_idx < q.length) $LAB.script(q[q_idx++]).wait(function(){\n      if (!pause) next_in_queue();\n   });\n}\nnext_in_queue();\n```\n\nAnd then, in each file, like foo.js, you either do (if the file has dependencies) this to pause the global queue while you load some dependencies:\n\n```\npause = true;\n$LAB.script(\"foo_dependency.js\").wait(next_in_queue);\n```\n\nOr you leave the file with nothing extra added (meaning no dependencies, and thus no need to pause), in which case the global queue will automatically continue immediately after the script in question finishes running.\n\nDon't get me wrong, option 3 is messy and sub-optimal. BUT, it's not as bad as the hacks that people are currently using to simulate \"preloading\" (which is what we really need).\n. Just thought of a different approach to option 3, which will allow you have any level deep of dependencies. \n\n```\n(function(){\n   var q = [], q_idx = 0;\n   window.next_in_queue = function() {\n      if (q_idx < q.length) $LAB.script(q[q_idx++]).wait(next_in_queue);\n   };\n   window.load_scripts = function(scripts) {\n      var splice_args = [].slice.call(scripts); // copy the passed in array of scripts\n      splice_args.unshift(q_idx,0); // put the first two arguments to `splice()` onto the front of the array\n      [].splice.apply(q, splice_args); // send the arguments to `splice()`\n   };\n})();\n\nload_scripts([\"foo.js\",\"bar.js\",\"baz.js\"]);\nnext_in_queue();\n```\n\nAnd then, inside a file with dependencies, you just call the helper method, like in foo.js:\n\n```\nload_scripts([\"foo_dependency_1.js\", \"foo_dependency_2.js\", ...]);\n```\n\nThat's it for additions to the file (no need for the global variable `pause` as I showed in the previous comment). You will basically have inserted these files you just specified into the global queue at the appropriate index location, and then when this current script finishes, and `next_in_queue()` is called, it will start loading those files, again in order, and again allowing them to subsequently inject their own new scripts into the queue as needed.\n\nNow, again, you'll be losing all benefits to parallel loading with this approach, because everything will load serially. But, it sounded like nested dependency annotation (and the code maintenance benefits thereof) is more important to you than performance. So, if that's true, I recommend this option 3 approach.\n. For posterity sake, a more flexible version of the above... serial loading with nested depdendencies:\n\nhttps://gist.github.com/1174213\n. Can you try upgrading to LABjs 2.0.1?\n. please update to the newly released 2.0.2 and re-open this bug if your issue still persists\n. I like the idea of this patch, but I'm gonna have to think about this one a little more carefully. At first glance, what seems strange to me is that I'd put into the API a feature (setting `.text`) which works in some cases, and not in others. Specifically, if you are in an older webkit browser, and loading a local script, the method used (by default), is XHR, with script injection by setting the `.text` property on a script element. In that case, what should we then do if you've also set the `.text` property via the options? It'd be a possible race condition to set it first to the actual loaded code via XHR, and then afterwards set it to the option value passed in.\n\nNot sure about this one. Thoughts?\n. > It\u2019s probably not worth dirtying up your API just for the sake of this one use case.\n\nI am leaning toward agreeing that this is a feature that is harder to get \"right\" than its usefulness. Not out of the question to consider for the future, but more needs to be done to consider the situation I suggested above.\n\n> In other words, the plusone API does it\u2019s own deferred loading and sequencing. That being the case, I guess there\u2019s not much reason to load plusone.js using LABjs.\n\nSince it's just one script, and it does its own loading, it's possibly/probably a case where this might be most appropriate:\n\n```\n<script defer src=\"plusone.js\"></script>\n```\n\nBy using `defer`, you'll ensure that it's a low-priority script that doesn't start loading until DOM parsing is done (meaning other normal scripts, and even dynamic script loading, can proceed first). The other option is `async` which is very similar, but which has no \"delay\" to it (it's strictly ASAP). That'll possibly get it to start loading just a hair faster, but could clog up the bandwidth if you have other more important stuff you want loading in those first few critical moments.\n\n> Out of curiousity, I looked into how the parameters in the body of the script tag were accessed. I was thinking, that there would be some sort of official way for the external script to find its script tag. Apparentlyt, that\u2019s not the case. \n\nyeah there really is no way to get your current script element. it's pretty bad. Firefox has this:\n\nhttps://developer.mozilla.org/en/DOM/document.currentScript\n\nBut it's non-standard and I think they're the only ones AFAIK. It should be standardized, because it's actually an incredibly common use-case, and the workaround is quite ugly and inefficient.\n. > Another option would be for LABjs to disable loading via XHR if there is a .text specified for the script. (I.e. if there is a .text, treat local scripts as non-local.)\n\nFirstly, I think this violates the principle of least-surprise. People who are expecting XHR loading won't understand this bizarre round-about reason why XHR is disabled if they set the `text` property. Even with good documentation, that smells like a WTF. Now, granted, it's a very small niche audience that's ever gonna do this, but still.\n\nMore importantly, however, there's a reason why this type of functionality is simply not compatible with XHR loading+script injection. The functionality you describe relies on being able to scan the document to find a script element that has a `src` property that matches the expected URL. With XHR+script inject, a script element is indeed created, but its `src` property is not set (because we already have the code loaded, don't want to load it again). So, in the case of XHR+script injection, even if you did figure out a way to set the `text` property simultaneously, the code would never find that script element.\n\nYou can't really reliably create a script element, set its `src` attribute/property, but not have the browser start fetching it. So, I see no way to make a script that needs `text` setting functionality as you descibe compatible with XHR.\n\nSo we've thoroughly established that XHR and `text` setting simply cannot co-exist. \n\nBut the other problem with your idea (disabling XHR) is that it would force LABjs to use the ugliest of all the hacks: \"cache preloading\". \"Cache preloading\" is not only brittle, but it fails completely for scripts which are sent out with improper (or missing) caching headers. Recent studies have suggested that as much as 50% of scripts on the web are served in such a non-caching fashion.\n. > still need to make sure that plusone.js is loaded before calling gapi.plusone.render.\n\nSo, if I understand correctly, is this basically how you normally use g+1?\n\n```\n<script src=\"plusone.js\">config.setting=\"blah\";</script>\n<script>gapi.plusone.render();</script>\n```\n\nIf so, yeah, there's no reliable way to use `defer` or `async` on those two script blocks.\n\nDoes combining the two scripts like this work?\n\n```\n<script src=\"plusone.js\">config.setting=\"blah\"; gapi.plusone.render();</script>\n```\n\nAlso, found this:\n\nhttp://googlewebmastercentral.blogspot.com/2011/07/1-button-now-faster.html\n\nI don't see in there where they suggest how you do the \"config\" settings. But surely there's some way to do so that works with their async code.\n\nIF you can figure out how to set the config without using the inner text (which it seems there must be a way, since their async snippet doesn't set it), then you can load g+1 with LABjs, but set the config however they support it, thus not needing the `text` setting in the first place.\n. Can you provide the link/page that is causing this issue?\n. The whole test-suite passes in IE9. So not sure why it'd be breaking your page. is it breaking in any other browsers?\n. sent you a message. did you receive it?\n. excellent. i will do a little more testing this afternoon and then release that as v2.0.3. sorry for the regression.\n. fixed in 2.0.3\n. Which version of LABjs are you using? are you using 2.0.3? Or, are you setting the \"BasePath\" config to \"/photos/\", because that will indeed force LABjs to prepend the BasePath as you specify it.\n\nIf not, try this test-suite test in your browser:\n\nhttp://labjs.com/test_suite/test-LABjs-preloading.php?which=1\n\nNotice from the source that it loads a script using this relative URL: \"/test_suite/testscript2...\" The page itself is at \"/test_suite/\" directory, so the \"/\" correctly resolves the path as \"root-relative\", meaning relative to the domain and not to the page. It loads \"http://labjs.com/test_suite/testscript2...\", not \"http://labjs.com/test_suite/test_suite/testscript2...\" as your bug report would suggest.\n. I've been unable to reproduce your report, and haven't heard back from you yet. As such, I am marking this \"notabug\" for now. If you get more information, we can revisit and reopen.\n. > Has this anything to do with the \"IE 8 repair\" in version 2.0.3?\n\nNo, I don't think so. I think it's the fix applied in 2.0.1 for this bug:\n\nhttps://github.com/getify/LABjs/issues/35\n. What you're describing is in fact by design, but I can see how it's a bit confusing. There's a subtle difference between the type of chain where you call the queue methods (global) and the type of chain with setOptions() and script() and wait(), which is actually a loading-specific chain. The global queue methods are just that -- global...which means the chaining is sorta convenience only. The loading specific chains have internal state that is saved and is local only to that chain, which is critically reliant on the chaining.\n\nTo keep those two subtle-but-important functionalities separate and not confused, I specifically return a diff object for each chain type. To set options for global loading (the queues), use the setGlobalDefaults(), and for per-chain options, use setOptions(). Think of it this way...the global queue sets up what _will_ become a single local chain, but it doesn't become that type of chain until you call runQueue().\n\nSorry for that subtle confusion. I'll think about how I can clarify this topic in the docs.\n. closing for now. will revisit docs soon to clarify this.\n. Can you verify if you are using the latest 2.0.3 version of LABjs? If so, can you provide me with a live test URL that I can reproduce against?\n\nAnd do the test-suite tests work correctly in your install of Chrome?\n. hearing nothing for several days, closing for now. will reopen if further info comes to light.\n. (sorry for my delay in getting to responding to this thread)\n\n@scriby is correct in the design reasons of the queueing system as it applies to this question.\n\nFurthermore:\n1. DOMready and all-scripts-loaded are two distinct events/concepts, which prior to script loaders were unfortunately conflated to be one-in-the-same. This should not be. DOMready is for code that needs to interact with the DOM, and all-scripts-loaded is for, not surprisingly, when all scripts finish loading. Don't use one for the other's intended use. You're asking for problems if you do. If you need to wait for both, then compose both events by a variety of methods, by essentially listening for both events, and once they've both fired, then running some code.\n2. LABjs specifically does not do any DOM-ready detection, nor does it intend to. There is a hack in there right now to help jQuery do DOM-ready detection in older Firefox (<= 3.5), but that code is deprecated and being removed soon. In any case, LABjs has no capability to know when the DOM is or is not ready in a cross-browser way. That's a whole set of hacks that other frameworks (like jQuery) already tackle. If you want/need DOM-ready detection, use a lib/framework that does it (and load that framework with LABjs!). I do this on all my sites, with jQuery.\n3. Now, could LABjs do a \"all-scripts-are-done-loading\" type of event notification? Possibly. But it's uglier than you think it would be. As @scriby indicated, the free-form (and resumable chain) nature of LABjs is that you never really know that all scripts have been requested yet. So, the best LABjs could do is to fire that event every time all the current scripts are finished loading, but that means it would be more complicated for people because that event might fire many times. Rather than address that complicated use-case, I implemented queuing in part to give you explicit (I'm done requesting a set of scripts, and go ahead and load them).\n\nI just haven't seen enough evidence that this use-case is worth the ugliness/confusion such a feature would entail. Closing for now. Will revisit later if more evidence is surfaced to sway the discussion.\n. I think googlemaps uses (quite unfortunately) document.write(). Script loaders should not be used on any script with document.write() in it, because it will in fact crash/wipe out pages. The issue is that a document.write() called \"later\" (that is, after DOMready) will overwrite the page's content, and script loading specifically creates a scenario where scripts load independent (and thus possibly after) DOMready.\n. That thread concludes that googlemaps shouldn't be loaded by a script loader, because of document.write(), like I said. As said in that thread, I'd recommend loading googlemaps in a regular script-tag, and load all your other scripts with LABjs.\n. browsers do not reliably fire script.onerror for failed script loads. this is a long-standing problem that the spec needs to address, so that browsers can fix the inconsistencies. until they do, any attempt by a script loader to do this type of behavior, while admirable, is basically just a hack. :(\n\nhttp://www.w3.org/Bugs/Public/show_bug.cgi?id=14195\n\nclosing for now, will re-address when the functionality is spec'd and implemented consistently.\n. In earlier versions of LABjs (pre 2.x), the trailing .wait() was necessary to avoid a subtle race condition. The rewrite of LABjs removed that quirk, however, as of 2.0.\n\nAs it stands now, there is no reason at all to add an empty .wait() onto the end of a chain. It doesn't hurt anything, but it's kinda like a trailing comma... you might leave it there because it might make it easier to append to your chain later if you want to.\n\nIt's important to remember that a single $LAB.script().script().wait().script()... chain is completely independent. So ending it with a .wait() doesn't imply anything about affecting any other behavior in any other chain... behavior is completely localized only to that chain.\n\nWhat you suggest, about .wait() somehow affecting the execution of the surrounding code, is impossible to do in JavaScript (no code pre-emption), except with firefox's experimental `yield` statement. So, I can understand semantically why you would expect that, but it's not at all what .wait() does. It's only for controlling execution flow within the chain in question.\n. This feature has been requested before. Unfortunately, when you break it down, it doesn't make as much sense as it seems at first.\n\nAs of current generation browsers, only IE (and older webkit) will fetch external files into a &lt;script> tag if the type is an \"unrecognized script type\" such as \"text/html\". Moreover, even in IE, if you fetch a fake mime-type resource externally, you can't access its contents (especially cross-domain).\n\nAFAIK, jQuery templates require you to embed the template into an inline script element, or load it via XHR and manually inject it.\n\nSince LABjs isn't really concerned much with the creation of inline script elements, once you examine it from that angle, this feature becomes a lot less useful for LABjs to implement.\n\nThe only other possible approach (forcing loading/injecting with XHR) is something I've considered, but since it only works same domain (or cross-domain if CORS is in place), it's a tenuous feature to add because it will tend, in the general case, to lead to failure behavior for people unless they know what they're doing. So I haven't added such a feature yet. But it's open for discussion still, if it can be demonstrated that the benefits outweigh those negatives.\n. Can you give an example page where you're trying to use the two libs together, so I can see how it's failing specifically?\n. Again, happy to diagnose, but I need more context. I need to see an example/test site with the problem, and which browser(s) this is happening for you in.\n. just do the cache-busting yourself on the file(s) you only want it applied to:\n\n```\ncommonLoad\n.script('relies-on-commonLoad.js?_='+Math.random())\n.wait(function(){\n//some code\n});\n```\n. But I will say, I think cache-busting the \"relies-on-commonLoad.js\" file so that you don't get the race condition is probably the worst possible way to approach this problem.\n\nYou should not be conflating \"DOM-ready\" with \"scripts-are-loaded\". They are two entirely separate events. Mixing them up like this is bound to lead to race conditions like you're seeing.\n\nI think you should take a step back and analyze your functionality from each different event's perspective, and figure out how to handle each functionality separately.\n. Are you using the latest version of LABjs (2.0.3)? If not, upgrade and try again without the cache busting.\n. Unless I can see an example page myself, to test things out, I can't really diagnose any further. \n\nI can say that LABjs is well tested in its ability to ensure execution order of files in your chain. If you have two script() calls, separated by a .wait() call, they will always execute in that order, regardless of the state of the cache. If you're having to cache-bust to get the right order, something much more serious is wrong. I would strongly suggest you not just settle for that non-solution hack.\n. Ah, good. Glad it's resolved. :)\n. I received the email. I apologize for not getting back to you yet. I was essentially going to suggest you post it here anyway. :)\n\n---\n\nI just tried your test page in FF7 (windows), and with a bunch of refreshes (empty and full cache), and it always outputs this to the console:\n\nstart script load (ordered async): http://rewind.sgconsulting.it/test-lab/../js/mustache-min.js\nstart script load (ordered async): http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js\nstart script load (ordered async): http://rewind.sgconsulting.it/test-lab/../js/jquery.lightbox-0.5.min.js\nstart script load (ordered async): http://rewind.sgconsulting.it/test-lab/../js/s3slider.js\nscript execution finished: http://rewind.sgconsulting.it/test-lab/../js/mustache-min.js\nscript execution finished: http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js\nscript execution finished: http://rewind.sgconsulting.it/test-lab/../js/jquery.lightbox-0.5.min.js\nscript execution finished: http://rewind.sgconsulting.it/test-lab/../js/s3slider.js\n\nThat is exactly the output I would expect given the $LAB chain you're running, and it shows that jQuery executes at the proper sequence.\n\nSeeing your image, I'm really confused, because I can't see how it's possible for that to happen. It would seem that it's perhaps some bug in Firefox on that particular platform, because since FF4, \"ordered async\" has been there to ensure the order of scripts is the same as that requested. In the case of \"ordered async\", LABjs essentially doesn't do anything special at all, except request the scripts, and rely on the browser to do all the work. So, the browser appears to be doing something wrong here.\n\nWhich platform are you running on? It looks like linux?\n\nFirst thing we need to do is eliminate LABjs as the issue. I've created this little snippet of code for you to run (instead of LABjs) to see how it behaves. Can you try it?\n\nhttps://gist.github.com/1287385\n\nThat code snippet basically represents all that LABjs is doing internally in your particular scenario. By spec, it should always ensure the execution order. If we can observe it failing to do so, then it's clearly a bug in Firefox.\n. Bummer.\n\nThat clearly illustrates that either the browser or jquery has a bug. Can you make it happen with fewer scripts by any chance? Like just jquery and one other plugin? The further we can reduce the footprint, the better (less for someone to complain about).\n\nOnce you have it as minimal as you can to reproduce, I'd file this bug both with jquery and with firefox. If you don't mind, will you post the links to those two bugs back here after you file them?\n. Closing for now. Will revisit if the above linked bug reports ever lead to anything actionable for LABjs.\n. I'm confused about this bug report. Can you post a link to a page showing the issue, and explain reproduce steps and what to look for?\n. > \"Only force the client to release it's cache when there has been an update to the scripts.\"\n\nBut see, that's not actually doing what you claim here. You're not forcing that older element to be \"released\" from cache. You're simply telling your UI to request an entirely new file, which means that theoretically both files are now in cache. That's not cache-busting, in the proper sense of the term.\n\nIn fact, even the actual \"CacheBust\" feature in LABjs is probably a little misnamed, in that it doesn't really prevent (bust) caching. What it does though, in contrast to your requested feature, is to ensure that we **NEVER** use a cached version of the file (because every request is a new uncached version). So in that sense, I'm ok with calling it \"cache busting\", because it's actually \"cache ignoring\".\n\nBut in your sense, I don't think it's correct to call that \"cache busting\". If anything, it's \"cache versioning\" or \"cache conditioning\" or \"cache layering\" or something like that.\n\nAnyway, this is probably just going to deteriorate into some bikeshedding about what to call it., which frankly doesn't matter _that_ much.\n\nThe real question is whether the concerns I raised about encouraging \"bad practice\" are overcome by the usefulness (as was the case with BasePath, CacheBust, and relative-protocols)? I don't see that argument being made... yet.\n. After further thought, I can see how it's ok to call both the random number and the key as \"cache busting\". That's not how I originally thought about it, but it seems to be the more conventional (if not entirely accurate) way to describe what's going on. So, let's set aside the bikeshed of what to call it, and get back to the issue at hand. \n\nSome questions I'd like you to ponder and provide any insight you might have:\n1. There's clear precedent for \"best practice\" being that versioning should be in the file name (like CDN's require), not in the query string. This feature, as requested/implemented, breaks that best practice, and encourages a less robust pattern. Should such a \"less-good practice\" be built into the core of LABjs?\n2. Won't this eventually lead to people wanting LABjs to have an option put the `CacheBustKey` into the filename instead of into the query string, so that _they_ can follow best-practice? Won't that request be simultaneously logical/reasonable, but also much more complicated (do we use . or - separators, etc)?\n3. What if you don't want **all** your files to have the `CacheBustKey` (maybe most of them need it, but a few files you load from third-parties, and you certainly don't want them to have it). How would the API cleanly handle only applying it to some?\n4. If we start allowing some semantic behavior for rewriting/rearranging the file names of `script()` requests, won't that be a slippery slope where we end up with more intrusive behavior like people wanting to leave off the \".js\" and have it added automatically, or people wanting the automatic path calculation by specifying package names, etc. Where do we draw the line?\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. > we want to be able to use window.onerror to catch as much as possible in production.\n\nI think it's a poor development form to rely on errors bubbling up to window.onerror in production just so you can find them. You would be better off just wrapping every JS file in a big try/catch, if the \"sledge hammer, meet tiny nail\" approach is what you're going after.\n\nWhy not focus on proper code techniques for robust error handling, rather than haphazardly letting errors bubble up?\n\nMoreover, the problem is I can't just let an error happen, or it will break LAB's internal functionality (possibly putting it in an indeterminate state) and stop the rest of the chain from executing. LABjs has to swallow the errors to prevent them from interferring with itself. The problem with not doing so is that people will tend to blame LABjs (since the dev tools will often \"lie\" and say that the error occurred in LABjs code).\n\nBy contrast, swallowing the errors and then letting a debug mode let you see those errors if you want to is far more graceful, especially when production environments are considered. I have found that most people would rather have graceful \"most of the code\" load and run, rather than \"fail hard and early\".\n. > The error is thrown from within a setTimeout, so it won't affect the current execution.\n\nActually, this breaks error handling in a far worse way than what LABjs currently does. Not all browsers are smart enough to allow re-throwing an error and have it preserve the original context, so in many cases, your dev tools end up identifying the `throw` line as the offending error line, not the original line that was `catch`d. Moreover, if you wrap the error handling in a `setTimeout`, now you further exacerbate debugging problems because you eliminate the call-stack from what the dev-tools can report.\n\nOverall, I think it's a very bad idea to try and re-throw an error, and even worse to do so in a delayed fashion as you suggest.\n\nI'd be better off literally calling `window.onerror` manually and passing in the error object myself, because at least the call-stack would be preserved (although muddied).\n. Suggestion: before loading LAB.js, install a \"proxy\" on top of `console.error`. That way, when LABjs calls `console.error`, you'll be notified (much like if the JS engine calls `window.onerror`).\n\n```\nif (!console) console = {};\nif (!console.error) console.error = function(){};\n(function(){\n  var old_error = console.error;\n  console.error = function() {\n     old_error.apply(this,arguments);\n     alert(\"yay, I caught an error!\");\n  };\n})();\n```\n. I think it's a fair point that perhaps this issue needs more specific and direct attention in the documentation. It's inferred loosely by the \"Debug\" mode but not particularly called out. I will put it on my TODO list to make sure the documentation is more complete on the topic of error handling.\n\nI'm not sure I would call \"let the error bubble to the top so we make sure that end users get annoyed by it\" is the proper default pattern for handling errors. I also don't think the proper default is \"as soon as 1 error occurs, abandon all hope and do a full stop\". These are things that I think represent a greater surprise to most developers (especially the less adept technical audience) than is \"hey, if you wanna see what is going on under the covers, use 'Debug' mode\".\n\nI want the default behavior of LABjs to be that it does as much as it can, not that it gives up (because JS gives up) at first error.\n\n---\n\nThe technical consequences of LABjs bailing on its part early are, I think, MUCH harder to find and debug, and much more likely to be blamed on LABjs. The problem is that we can't \"fully abort\" when an error happens, we can only partially abort at best. This leads to crazy to diagnose errors almost instantaneously.\n\nFor instance, imagine you have 5 scripts you're loading, and for each one, you have a `.wait(..)` callback to run after that script runs. Now, let's say that a script error occurs in the first of those callbacks. What will the behavior be if LABjs doesn't try to robustly handle that case? All 5 scripts themselves will run, in order, because that part is handled by the browser, but the 4 subsequent callbacks will NOT fire, because LABjs was aborted (by the JS engine) with the first error.\n\nWhat will happen? Probably LOTS of errors will bubble up, from all of your scripts. And most of them will be WTF red herrings that lead you down the wrong path, because it won't be at all obvious that LABjs only ran 1 of the 5 callbacks, even though all 5 scripts themselves ran.\n\nWhat's the more sane behavior by default? To keep running what callbacks we can, so that the only errors which occur are those DIRECTLY related to the actual problem, and not artifacts of weird internal implementation details of LABjs and how browsers behave.\n\nFewer errors, even if you have to go looking for them in debug output, are easier to solve than more errors. That's why the default behavior is as it stands.\n. I would also say that _this_ feature request tracking (a per-chain callback) is not really fundamentally different than what I suggested earlier about overriding `console.log`. In both cases, you the developer have to, by virtue of good engineering practice, know what you're looking for and install the right listeners for it. In neither case will you just happen to find errors that you didn't know about.\n\nThis feature request makes it slightly more direct and graceful to detect them, and perhaps provide you an opportunity to \"recover\", but you would still have had to read the documentation thoroughly to even understand the implications of why such a thing would be necessary. There just is no clean way to make the default behavior be noisy.\n. It's a fair point that if you are using the debug-build of LABjs, perhaps the default then should be to have debug mode on. I'm willing to agree to the sense in that argument.\n\nI'm not sure if that would have helped in your case? I provide a debug version of LABjs, with this debug mode functionality in it, because I hope that most people will use it by default, in their dev environment. By contrast, I hope that people DON'T use that build in production, at least not by regular practice, because they're not only using a larger version of the code unnecessarily, but I also think it's bad practice to \"leak\" implementation data to the console in production environments.\n\nIn this scenario, I would have suggested, were I consulted, to first switch to using debug mode, and see what LABjs says. If you see errors, fix them. If not, you've eliminated anything that LABjs is doing from the equation.\n\nBut we're back to a fundamental assumption from earlier in this thread: you have to have good practice, and know about the tools you're using, before you'll see what you hoped you would see.\n. @jasonhinkle \n\nThe big discussion in this thread is not whether or not it's \"possible\" to fire an error callback... it was about whether it's proper to do so. My feeling is a library like LABjs should not expose a functionality as part of the API if it cannot expose that functionality in a reliable way across browsers.\n\nNot all browsers have the same behavior for \"error\" conditions, which means in some browsers an error handler would fire, and in other cases the error handle would sit silent (even though the error did occur). Moreover, some browsers would abort a chain at the point of an error, whereas other browsers the \"abort\" of a chain would not be possible. So, in some of your browser testings, you'd see an error, but the chain would complete still (which could be a good or bad thing, depending on your code and how much it's inter-dependent), and in other browser testings the error would abort the chain (which again might be desired or not).\n\nBy me not being able to guarantee the behavior of these error handling features, I think it detracts from LABjs rather than adds to it. Consider that most people who use LABjs don't understand all the internal quirks, and so if they see a feature documented, and try to use it and it doesn't work as expected, they will file bugs which I'll constantly be closing as \"can't fix\".\n. @scriby \n\nThat sounds like a reasonable expectation, until you dig a little deeper into its implications.\n1. As we have mentioned earlier in the thread, in some cases this error event will fire once (because the chain aborts at first error), and in some browsers the error event may fire many, many, many times, because the chain doesn't abort and keeps going, and now you probably have lots of \"reference undefined\" issues. This inconsistency cross-browser is almost certain to be a \"hidden\" (unexpected) behavior, one which I simply cannot correct for (if I could, we wouldn't be having this discussion). LABjs will get blamed for that unexpected behavior just like you blame LABjs for the unexpected error swallowing it currently does. This is a no-win from my perspective.\n2. The very definition of what constitutes an \"error\" is not easy to make obvious. script.onerror (which most people would mentally closely associate with a chain-specific error handler) fires for network loading issues (404's, etc). However, all browsers have somewhat different behavior on which loading errors they fire for or not. So, in some browsers you'll get an error event triggered for a 404 load, and in other browsers, you'll get no error fired at all, even with the 404. This is yet another unexpected inconsistency that's VERY hard to make obvious, or more to the point, make it so that people don't blame LABjs.\n3. Moreover, the browser's built-in script.onerror does NOT fire for run-time errors (that's window.onerror), so this LABjs error handler would be (I think somewhat confusingly) combining the behavior of window.onerror and script.onerror into one handler. Documentation can say that, but again, I don't think that's naturally what everyone will assume.\n\nAnd if we _don't_ try to respond to any of the network load errors at all, and only respond to the run-time errors we catch, then a failed load of a library won't be directly detectable (which is at least a major part of what people asking for these features want to detect for), and will only be indirectly obvious if it happens to cause an \"undefined reference\" error in the chain.\n\nWhat if the \"undefined reference\" call doesn't happen in the chain at all, but not until later? Then you didn't get any indication by LABjs that a problem occured with your chain.\n\nSo, you almost certainly have to do both kinds of errors.\n\nDo we combine them into one event, or do we publish two events (loadError, runtimeError)? Even if we do, how do we make it so the above browser inconsistencies don't create more problems than we are solving?\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. Yeah, was just logging on to explain that! BasePath will be prepended if the URL is not absolute (doesn't begin with \"http://\") AND doesn't begin with a root relative indicator, like \"/\". If you begin with any other character, even path relative, like \"../\" then it WILL append.\n\nCheers!\n. Can you please post exactly the console output you get (both before, including, and after) for this error?\n. Wrap the code inside your `.wait()` callback with a try/catch, and specifically output the error output from that. From what you've pasted, I'm almost entirely sure that it's an error in that code that LABjs is catching and telling you about. The \"ReferenceError\" is something wrong in your custom code there, inside of `Section_News.init()` or whatever, not a problem inside of LABjs.\n. Glad you were able to track it down! :)\n. I appreciate the pull request. I have not ruled out the possibility of adding an error handler functionality into LABjs, I've just been unhappy with the inconsistency it will invariably introduce.\n\nThe functionality you're providing in this patch is for calling an error handler whenever an error is trapped in a `wait()` callback. This (as I said in the other threads) is half of the \"error handling\" that most people expect from a script loader. My concern with this patch is that it implies that it's an overall error handler, when in fact it's only for the `wait()`'s. So, I might be inclined to have an error handler named `waitErrCallback` or something like that, so it was clear what its limited purpose is.\n\nI also am not sure this functionality belongs in the production (non-Debug) build/mode of LABjs. Right now, errors are only reported to the error console if you're using the debug build and have debug mode turned on (a previous suggestion I plan to implement will default debug mode on for debug build usage). While the relative file sizes aren't terribly different, the extra 200-400 bytes (minified) of code for debug mode is, I think, waste in the production builds.\n\nSo I may be inclined to add in the `waitErrCallback` functionality under the debug-mode plumbing.\n\nThis fits better with my philosophy that by default, production code should not be about reporting or exposing errors, it should be gracefully and silently handling them. If you need to troubleshoot a specific production problem, I think the better approach is to switch to using the debug build in production (thereby being able to catch errors however you wish), and then switch back to the production build when debugging is done. Philosophically, my opinion is that the default should not be to ship production code with debug-mode bits in it.\n\nOf course, an individual person could decide to always ship the debug mode to their production environment. That's fine for a case-by-case basis decision, but what this repo provides to the masses, I think should default to the more conservative approach.\n\nJust some thoughts. Thanks for the patch. It's under active consideration.\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. Thank you for the bug report. Unfortunately, this is not a straightforward bug, because the per-script \"AllowDup\" flag was inadvertently/accidentally removed in LABjs 2.x rewrite. That explains why this detail was not noted in the release notes, nor was the documentation updated to reflect that it had been removed.\n\nAt this point, well over a year since 2.x came out, I'm left with the decision of whether or not to consider this a regression bug (did I intend to keep the feature and I failed to), or a documentation bug of failing to note that I intentionally removed it. I honestly don't even remember if I thought about the detail during the rewrite or not, so I don't know which way to think about it.\n\nThat having been said, it's a very minor feature that to this point no one has even noticed missing or \"broken\", even with significant amounts of usage of the library. I'm inclined to believe that whether it was intentional or accidental, it's a feature that proved by de facto that it should have been deprecated/removed, because it has so little real-world usage.\n\nSo, I'm marking this as a \"not a bug\" and \"won't fix\", and I will update the documentation and release notes to indicate that the feature was indeed removed.\n. That is correct, and it's by design.\n. Can you do?\n\n```\n<script src=\"LAB.js\"></script>\n<script>\nvar LAB = window[\"$\"+\"LAB\"];\nLAB.script(..)...\n</script>\n```\n. I don't understand what this bug is claiming/asking about? Can you clarify exactly what it is you expect to be happening, which is not happening (or is happening differently)?\n. Actually, main.js doesn't have to load after jquery, it needs to EXECUTE after jQuery. The way LABjs works, it tries to load as many scripts as possible in parallel, and in some cases a smaller file will finish loading before a bigger file, even if the smaller file was requested \"after\" the bigger file.\n\nSo, if you're relying on the fact that the debugger tells you that \"main.js\" finishes its network loading before \"jquery.js\", that's a false signal.\n\nIf you have code inside of \"main.js\" that is running before \"jquery.js\" runs, THAT would be a symptom of a bug/problem.\n. > $LAB.runQueue(); is supposed to load previous queue (containing jQuery and everything else) and proceed to another.\n\nActually, no, this is not how LABjs is designed to work. The \"queue\" system is a totally separate chain (managed internally, but still a `$LAB` chain) from any other chain you create. The chains are totally independent, except for one caveat, and one special case condition, both of which I'll explain in a moment.\n\nBecause they are totally independent, you cannot rely on the fact that the queue is \"done\" in that it has both loaded **and** executed all the scripts, before moving onto the second chain you define. Both chains being independent means, in general, they will run in parallel, unaware of each other.\n\n> And actually that works flawlessly in any other browser except IE.\n\nThe reason for that is that IE uses a different loading technique than other browsers do, which is that IE has what I call \"true preloading\" meaning it can load a set of scripts and execute them (in order), independent of any other set of scripts that is loading. Other browsers do not have \"true preloading\", they have a slightly inferior (but still functional) behavior roughly called \"ordered async\".\n\nThe hallmark difference is that in \"ordered async\", all scripts (across all chains) will execute strictly in the order requested, so it has the side effect that \"accidentally\" your queue finishes executing before any scripts in your second chain can execute, even though in reality all your scripts in your second chain can finish loading and be ready to execute earlier.\n\nIn IE, once all the scripts in the second chain are ready, it executes, and is not \"blocked\" waiting on any other script executions on the page, so IE (ironically) has the truest **and most performant** behavior of all the browsers, compared to how LABjs is designed. With \"true preloading\", IE allows LABjs to have truly independent chains, whereas in other browsers, separate chains are logically (API-wise) independent but physically blocked on each other. So, that's the caveat mentioned above.\n\nBottom line, as your chains are designed currently, you have an inherent race condition, which is accidentally moot in other browsers but is exposed in IE. The solution is to avoid the inherent race condition, not rely on the accidental non-race condition in non-IE browsers.\n\n---\n\nI mentioned a special-case condition above, which I'll now explain. LABjs treats separate chains entirely logically independent, unless you create a condition where you want them to be logically \"connected\". Before I explain how to do so, let me say that this is basically not a great idea to do it this way. I would consider this a poor option, but it should work. I just mean to say that the better answer is to not create dependency between separate chains. Load everything in a single chain that depends on each other. If the queue system doesn't let you do that, don't use it, and instead do your own queueing (this is quite easy to do).\n\nAnyway, here's how you can create an implicit logical connection between two chains:\n\nThe `AllowDuplicates` option (which defaults to `false`) controls whether a LABjs chain will attempt to prevent the same script from being loaded multiple times. Naturally, if you set it to `true`, it will not do any checks, and will happily let as many in as you request. If you leave it at the default of `false`, it will check each time you request a script to see if that script has already been requested, and if so, will not load it.\n\nHere's the trick. If `AllowDuplicates` is set to `false` (again, that's the default, so no need to explicitly set it), and you have two chains that reference the same script URL (must match exactly!), then both chains will be forced to wait for that script as part of their normal defined execution order.\n\nSo, if both your queue and your second chain listed \"jquery.js\", and `AllowDuplicates` was indeed set as `false`, then the both the queue and the second chain will have to \"wait\" for \"jquery.js\" to execute, which would achieve the effect you want I believe. \"jquery.js\" will not be re-requested in this case, it will just create a logical dependency between the second chain and the queue.\n\n---\n\nTo reiterate my caution from above... taking advantage of this logical dependency between chains is not what I would consider \"best practice\". Not because it's gonna break (LABjs should function properly), but because it creates harder to debug code. It's much easier to debug, maintain, and debug based on the fact that independent chains are independent. When you create a subtle \"exception\" to this general rule, you create a footgun that could be \"dangerous\" in the future.\n\nIf LABjs had some sort of explicit way to logically link chains, that'd be a different story, because then it'd be obvious from examining code that the two chains are related. But because this is an extremely implicit, indirect side-effect behavior, it's not generally what I'd consider a good practice to rely on.\n\nIt's just slightly better than relying on observed browser behavior to moot a race condition. Most software developers would tell you not to rely on accidental behavior, and I consider this logical dependency between chains to be of that caliber. It will work, but if possible, I would encourage you to design to avoid it.\n. This is browser-dependent behavior that LABjs has no control over. There's poor spec'ing around how &lt;script> elements should behave with respect to loading errors. Some browsers will fire the `onload` handler even if it 404's, or 500's, others don't, or do so only for some errors and not others.\n\nLABjs is at the mercy of the browser. If it fires the load event, the chain will continue, if not, it won't. One of the many warts I wish the spec would iron out, but all my requests for them to do so have been ignored.\n\nFTR, in this particular scenario, I do _not_ think the chain should continue executing. Part of the \"promise\" that LABjs makes is that it will ensure execution order so you don't get cascading dependency issues. If you have two scripts which are separated by a `wait()`, LABjs needs to assume that's on purpose, because the first one is necessary for the second one. If the first one fails, there's no point in running the second one, only to create more failure, errors on the page, etc. Better to fail early.\n\nIf you have two scripts which are truly independent of each other, don't load them in the same chain with a `wait()` in between. Either use 2 chains, or remove the `wait()` so between them so the two scripts can execute \"in parallel\" and not block each other.\n. Will this work?\n\n```\n//added by child page\n$LAB.queueScript('/pageSpecific.js')\n      .queueWait(function(){alert('pageSpecific.js loaded!');});\n\n$LAB.script('/jquery.js')\n      .wait(function(){ \n         $LAB.runQueue();\n      });\n```\n\nNote that LABjs treats the \"queue\" system as an entirely separate chain, so there's no implied shared/cross-functionality between these two chains in your case. The only explicit relationship is that you're choosing not to run the queue until after your chain gets to a certain point (like the end). But other than that, LABjs will treat them as entirely separate chains.\n. `runQueue()` will run whenever you call it. So if you call it at the end of the chain, it will run then. If you call it earlier, it'll run then. There's no special logic inside it to defer or wait for any special event/time.\n\nHowever, the nature of script loading is asynchronous, which means that it won't COMPLETE its running right at that moment, but some little bit later, depending on loading speed, etc. So `runQueue()` starts the queue immediately, but it gives control back to your code (to finish other actions, like completing your $LAB chain) right after starting the queue, which means the end of the queue will come some time later.\n\nIf you need to wait until the end of the queue before you do something, you need to have a `queueWait()` call at the end of the queue, which does as it says on the label, and queues up a `wait()` to happen at the end of the queue's chain.\n\nI'm not entirely certain, but it sounds like what you actually have here is a case of two parallel asynchronous tasks, that you need to let both run in parallel, and finish in either order, and you just need to wait for both to complete before doing something else. In the parlance of your example, your two tasks would be: \"completion of the queue\" and \"completion of the $LAB chain\", and you have some set of code that you want to run ONLY once both those things are done.\n\nIn THAT case, you need a \"gate\", which means two or more parallel tasks (\"segments\"), where the gate doesn't open until all segments are complete. I happen to have written a small helper lib for exactly this kind of task, called \"asyncGate.js\": http://github.com/getify/asyncGate.js\n\nBasically, you could use it sorta like this:\n\n```\nvar gate = $AG(), \n      d1 = gate.and(),  // this is one gate segment trigger\n      d2 = gate.and()  // this is another gate segment trigger\n;\n\ngate.then(function(){\n   // run code that needs to wait on both segments of the gate to finish\n});\n\n$LAB.script(\"..\").script(\"..\").wait(function(){\n   /* ... */\n   d1();  // trigger one segment of the gate\n});\n\n$LAB.queueScript(\"..\").queueScript(\"..\").queueWait(function(){\n   /* ... */\n   d2();  // trigger second segment of the gate\n});\n```\n\nCheck the documentation for the \"asyncGate.js\" project, because there's multiple different ways you can use the API. I showed here a less common usage where you get the triggers directly and call them later. Another way is to create wrapper functions where the trigger is passed to you at the appropriate time. In either case, you call the trigger for each statement, and the gate's `then(...)` handler(s) will wait for all gate segments before firing.\n. Can you run the debug build of LABjs and turn on debug mode, and share what the debug output messages in the console say? Your analysis of the problem (about \"loaded\") doesn't make sense to me given what I know about how script load events happen, because LABjs doesn't rely the state of \"loaded\" to know a script has executed.\n\n---\n\nNOTE: I don't have an IE10 instance to have been testing on, so the last time I tested LABjs was 10pp2 (which was the last on win7), and back then, it passed. If it fails now, it's probably some sort of regression in IE. Unfortunately, that might mean what I was complaining so much about IE10 not being available on win7 for testing, which is that they introduced a breaking bug that noone caught, and now it's way too late to get them to fix it.\n. Thanks for the update. Breathing a sigh of relief to know it was something simple to resolve. :)\n. Oh, and btw, that same line/logic is in LABjs 2.x as well. But in 2.x, for IE, LABjs uses a precaching/preloading technique to make sure it's fully loaded before then attempting to have it execute (by inserting it into the DOM). Sounds like it could be possible for that to still be an issue with IE10, but perhaps that particular sequence of usage is safe. Hope so. :)\n. Are you trying to load the CSS files with LABjs as well? That's not supported.\n\nOtherwise, I'm not sure how LABjs loading JS files could affect your page's stylesheets. Seems a bit bizarre.\n\nWould definitely like to see the source.\n. BTW, as a side note to your question... I don't recommend loading \"LAB.min.js\" as a separate file like you've mentioned. I do like you do and create an \"init.js\" file that has my `$LAB` chains in it, but I just inline the minified LAB source at the top of that same file. I'd recommend you do the same. Reduces 2 script requests to 1. Since LABjs is so small, pretty minimal impact to parallelism or caching.\n. I'm fairly positive this is not LABjs because it's been long battle tested in IE 6+, and also because LABjs doesn't do anything with CSS stylesheets at all. However, I have been busy with other work and have not yet had a chance to check into your issue.\n. BTW, in your LAB chain above, are \"script1.js\" and \"script2.js\" at all dependent on jquery-ui? because your chain doesn't guarantee they'll run after jquery-ui since there's no wait after jquery-ui.\n. My working theory is that the error you said you were getting reported from jquery has something to do with your code building or modifying the DOM in such a way that the CSS in question should be applied, but for some reason your code execution order is different in IE than in other browsers (usually indicates a race condition).\n\nLike I've said, LABjs doesn't modify anything about how the browser deals with CSS, so I continue to be 99% sure this is a red herring and not the actual symptom/issue.\n\nIn any case, to determine is this might actually be a LABjs bug, I'd need a much more reduced and simple test case. Your use case is quite complex for testing and isolating a bug, so that's why the few minutes here and there that I've had to look at things haven't revealed anything useful.\n\nNOTE: you've indicated symptoms that if you load things with normal script tags, things work, but if you load them dynamically with LABjs, they don't work. That USUALLY means you have an execution race condition somewhere in your logic. Try setting the `AlwaysPreserveOrder` option to `true`, or put a `wait()` after each and every `script()` call, and see if that affects anything. The `wait()` only controls execution, not parallel loading, so even with them in place, you should still get the dynamic loading benefits.\n. Good catch, @joekaiser and @toxcct. I think this is definitely the issue. There are certain scripts that people use which cannot be dynamically loaded, because the nature of how they work is that they must be present at the very beginning of markup processing, which is contrary to what dynamic script loading does.\n\nModernizr is an example of this type script. It has to run before the `<body>` tag. It looks like this shiv is the same way, because it appears that the way it works is to actually patch the underlying DOM APIs of the browser so that when unrecognized tags are found, it fakes how they should be handled.\n\nAnother example of a script that is incompatible with dynamic loading would be any script which uses `document.write()` in it. Different reason, same result: can't load them dynamically.\n. The order they appear in the `<head>` is irrelevant. What matters is that LABjs requested them in the order you specified, which means they are executed in that same order (especially if you have all of them followed by a `wait()`). If you're seeing execution order problems, it's something else (like for instance a hidden inter-dependency you're not aware of, which is a race condition that shows up locally but not over the network, etc).\n\nBTW, if you want all scripts to have a `wait()` after them: rather than doing that in your chain yourself, just set the option \"AlwaysPreserveOrder\" to true.\n\n```\n$LAB.setOptions({AlwaysPreserveOrder:true})\n.script(\"1.js\")\n.script(\"2.js\")\n// ...\n```\n. I'm not outright \"against\" this suggestion, but I'm not totally convinced it's worth changing the core LABjs to do it. I'm at least willing to explore it.\n\n`<soapbox>`\nUsually when people make suggestions for changing LABjs, there end up being ways that they could wrap behavior and get the same outcome, which prevents any \"change tax\" from being imposed on the masses. Part of the reason LABjs is \"closed\" is basically because I think stability is a really strong virtue in such projects, and I don't like the strain and tax of other projects that just seem to constantly be updating and changing, for what seems like no reason. For instance, most of what jQuery keeps changing to do, I have no need for. But I have to keep changing because I need to keep up with whatever the latest jQuery does, for bug fixes, browser supports, plugin compat, etc. I find that annoying to an great extent.\n`</soapbox>`\n\nTo your particular feature request... I wonder if we could address this interesting use case by wrapping the `console.log()` statement to \"filter\" out the messages you don't want. For instance, running something like this snippet (of course, only in dev mode where you have LABjs set to debug mode) right before using LABjs (and perhaps restoring the `console.log` to its original form after the final `wait()` in your chain executes successfully):\n\n```\n(function(){\n   var clog;\n   if (console && console.log) {\n      clog = console.log;\n      console.log = function(msg) {\n         if (msg && (msg.match(/^(?:start\\s)?script\\s(?:(?:pre)?load|execution)/) || msg.match(/^\\$LAB\\.wait/))) return;\n         clog.apply(console,arguments);\n      };\n   }\n})();\n\nconsole.log(\"start script preload ...\")\nconsole.log(\"start script load ...\")\nconsole.log(\"script preload ...\")\nconsole.log(\"script execution ...\")\nconsole.log(\"$LAB.wait ...\")\nconsole.log(\"anything else...\")\nanything else...\n```\n\nWhat do you think about an approach like that?\n. @ramaralo LABjs only suppresses errors in `.wait(..)` handlers, not in the main scripts themselves. As for `console.log()` output, Firefox treats `console.log()` as a deferrable I/O operation for performance, AIUI, so you call it at a certain place in code, but it doesn't necessarily get processed exactly at that moment.\n\nIn any case, sounds like things are working for you now the way you need. If not, update with more specifics. :)\n. Unfortunately, standard script loading mechanisms (which the browser provides and LABjs relies upon) do not provide such a functionality. I've been petitioning the spec and browsers to give us more flexible script loading mechanisms. No such luck yet.\n\nOther script loading solutions rely on the AMD module pattern to wrap all scripts in a \"module definition\" wrapper, like Require.js and such. They get around the problem you're seeing by basically preventing ALL scripts from \"auto executing\" so you get to decide when you want to execute by declaring when and where you want to import a module to another module. That sort of pattern is, I think, overkill in almost all cases, but it is very popular for how a lot of people handle this.\n\nInstead of AMD (and Require.js) I would suggest you consider re-arranging how you load your scripts so you can avoid this problem.\n\nThe best way is NOT to list \"mobile_core.js\" to be loaded inside of \"core.js\", but instead have the check for whether \"mobile_core.js\" is needed out in the same place your main $LAB chain is listed, that way a single $LAB chain can do all your loading, either including the mobile file or not, at the appropriate location in the sequence.\n\nThe other slightly less optimal way is to always load this mobile file, but have THAT FILE do the check for whether it's needed or not, and if not, that file just skips all its stuff and does nothing.\n\nUnfortunately, LABjs can't solve this problem for you, but hopefully I've given you some ways to think about the problem differently so you can perhaps avoid it yourself.\n. An example of having the check in your $LAB chain:\n\n```\nvar needs_mobile = ...; // do your check logic here\n\n$LAB.setOptions({AlwaysPreserveOrder:true}) // do this instead of putting `wait()` between each `script()`\n.script(\"core.js\")\n.script(needs_mobile ? \"core_mobile.js\" : \"\") // an empty \"\" will be ignored by LABjs\n.script(\"public.js\")\n.script(\"private.js\");\n```\n\nHope that helps!\n. There are definitely bugs in 1.x as it's not maintained anymore and thus it's not at all surprising that 1.x would be broken in IE10.\n\nWhat we really need to do is diagnose why you were seeing performance problems with 2.0.3. Can you give me examples of what you were doing and what exactly you found? I'd sure love to tackle the problem at its root.\n. What are `$LAB.ready` and `$LAB.run`... those aren't part of the shipped API. How are they implemented?\n. Also, if you're putting a `wait()` after every `script()` call, it is probably easier to instead do:\n\n``` js\n$LAB.setOptions({AlwaysPreserveOrder:true})\n.script(...)\n.script(...)\n...\n```\n. When you say your \"page load times\" were increased by over a second, do you mean that the time when `$LAB.run` is executed is 1 second later than before, or do you mean that you're testing for the timing of `DOMContentLoaded` and/or `window.onload` events and those are taking longer?\n. 2.0 was a complete rearchitecture/rewrite of LABjs from the ground-up. In 2.0, there should have been nothing but performance improvements, though, ESPECIALLY for IE. The technique used in IE is what I call \"real preloading\" in that it actually preloads all the JS code and then executes them in order. So, in theory, this should perform better in IE than it would in say Firefox, which uses another trick.\n\nI'm pretty perplexed by what you're seeing. My guess is that you're getting false readings of the site being finished loading earlier in IE than it is (because of 1 or more scripts not finishing loading), and so the \"increase\" is actually just a correction to what it should have been. But, I have no way to back that up as more than a wild guess.\n\nI'd really have to take a look at your actual page in action, and monitor it in IE, and see. But even then, it's going to be nearly impossible to correlate that to aggregated stats from gomez. It's also going to be very hard to try something and then have to wait for new stats before we know if it helped or hurt.\n\nMoreover, LABjs does absolutely nothing to hold up (or change the hold-up) of window.onload, which is what I guess gomez is using to determine \"page load\".\n\nOne other wild guess is that perhaps you're loading duplicate scripts (and LABjs has different behavior around dupes in 1.x vs 2.0).\n\nBTW, why are you loading 17 scripts? Best practice would be to be loading 2-3 scripts at most. I usually recommend people combine all code into one file, then split that file in half (or something like that) and load the parts via LABjs. I'd say if a production site is having to load more than say 5 scripts, it's probably not doing what it could or should be doing for optimization.\n. Also, try the debug build of LABjs and then turn on debug mode with option `Debug:true`. Check what's printed to your output console to see if anything looks out of place in terms of sequencing. Paste that here too, if you think it might shed light on anything.\n. closing for now. if you find anything actionable we can address in LABjs, lemme know and we can re-open. :)\n. This question has been asked many times over the years, if we can provide a way of adding arbitrary attributes to script tags. I personally consider that to be an anti-pattern, so I've resisted... but the other point is that there's not always going to be a script tag to attach things to. For instance, if local XHR is used instead of a script tag.\n\nMoreover, it's a slippery slope where people will want to add more and more stuff to script tags if possible, so we'll have to have general attribute systems (like @fletc3her is suggesting). I'm not saying those things are bad, per se, just that I don't see why that's useful to a broad enough set of the users of LABjs to be in core.\n\nLastly, you can't necessarily guarantee that you can find the script element that has the attributes you're looking for, as there could be multiple tags with the same URL, or there could be script elements with no URL (like in the case of script injection from XHR), or the script elements might be removed from the DOM after use, etc. Given all these complications (and others), and since the fidelity of finding the script element you added this data too is pretty low, I don't see the point to adding this to core.\n\nWhy not just maintain some global variable with the data in question? I understand lots of libs do this anti-pattern of relying on adding attributes to script tags and so you can't help that. But that still doesn't make it a good pattern to follow/endorse, IMO.\n\n---\n\nI guess my bottom line is that the stability of LABjs (over 2 years now since last bug fix was needed) is more important than adding small features that only some side use cases would benefit from. The thousands of sites that would have to ask if they should upgrade or not isn't really worth the small gain, IMHO.\n\nBut that's part of why this code IS stable, and IS open-source and MIT licensed, so that it can encourage lots of forks for individual needs, and the barrier to you maintaining your own fork is low, because I don't change core at every possible chance to add things. Imagine how much harder it would be for people to maintain forks for their own needs if I was having the core be patched regularly with community requests.\n\nJust a balancing act against various tradeoffs. Thanks for the input and suggestions, though. :)\n. closing as duplicate of https://github.com/getify/LABjs/pull/81\n. Another point we'd probably want to consider is to feature-test for the feature, and only set on the script tag if supported. Reason being: it the attribute is added to a script element where the feature is not itself supported, that could be misleading when trying to debug LABjs behavior.\n. >  if we add this to core, this should only be in the debug build of LABjs and not the main minified build,\n> \n> > I disagree here, we want to use this feature for error logging on our live production site, for catching errors in the browser from our real users (where we have a setup with CDN and cross origin issues). It is not for debugging (when you typically don't work with a CDN and don't have cross origin issues).\n\nI have regularly over the years recommended to users of LABjs that they take the debug build of LABjs (which is a little bit bigger, and runs a few extra bits of logic at each step) and deploy it into their production site, so they can debug issues that seem to only be reproducible in their prod environment.\n\nBut note, this sort of action is still fundamentally a debugging step, and should be considered, IMO, a temporary step while you diagnose and fix issues. It should not be a permanent installation in a prod environment. For example, debug mode by default logs all the steps LABjs takes to the console, but that sort of logging is extraneous for a production environment, and moreover, could be considered a \"leak\" of implementation you would probably be best served avoiding for prod.\n\nAll the debug features of LABjs are specifically for the purpose of debugging issues and correcting them. That means all of those features should be temporary, not permanent, in prod. As such, I have a hard time believing we've come up with a new fundamentally \"debugging\" feature for LABjs that would be constantly running (and deployed) on a permanent basis in production. That sorta violates one of my fundamental principles of good software design.\n\n**CAN** you do that? Of course. It's not something I'd ever recommend. LABjs is not really designed to be a tool in the RUM toolbox, it's not for continuous monitoring or stats/error gathering, etc. If I were to design that sort of software, I'd probably approach it quite differently than how I built LABjs. By contrast, LABjs is as simple and stripped down and bare metal as it possibly can be, because it has one task and one task only: loading scripts. Any of its capabilities to track or provide assistance in debugging are intended for debugging purposes only.\n\nThis is a similar discussion (and mindset) to me as [issue #57](https://github.com/getify/LABjs/issues/57) where there was quite a bit of back-n-forth discussion about my design philosophy of defaulting to having the `wait()` method suppress errors by default, and only expose them when you choose to move into `Debug:true` mode (and of course, using the debug build of the lib). Several people in that thread definitely disagreed with that being the default behavior, but I considered that to be the more appropriate conservative default for simple production environments, while giving the power and flexibility to someone to use a different build/mode if they need to dig into an issue.\n\nMy mindset then, and now, is that LABjs is best served by being as stripped down, and conservative, as possible in the core minified build, and debug functionality is tucked away in the debug build, easily useable if necessary to track down and fix problems. Hopefully that helps elaborate on how I might tend to approach **this** feature request, if we do add it.\n. I'm definitely of a different mindset on this than when it was originally filed. I'm now inclined to support setting any attribute on the script element that you want, as discussed in #108. That work would roll into LABjs v3, though, not an update of 2.x. \r\n\r\nI made some decent progress on the 3.0 rewrite (#113) awhile back, but there's a long check list of stuff still to do. I would love any help with that list. :)\r\n\r\nIn the meantime, I guess my best suggestion is to edit your LABjs to add the attribute. I believe that would be inserted here: https://github.com/getify/LABjs/blob/master/LAB.src.js#L132. @toxcct \nYou are correct in your observation that some types of \"script failed to load\" will in fact cause a chain to break. Other types will let it keep going (though the lack of dependency can cause JS errors).\n\nHowever, this is not controlled by LABjs at all, thus it's not something I can fix. Browsers are inconsistent on how they handle the `load` event. Some of them will fire the load event even in a 404 condition (which, if you think about it, is totally wrong), and others (most, thankfully) won't. On the flip side, these same inconsistencies exist with the `error` event. You'd think that either the `load` or the `error` event should always fire. Unfortunately, that's not the case. Sometimes neither fires, sometimes both fire (bizarrest of all!).\n\nBottom line: LABjs can't really rely on either event, so it just assumes that `load` will definitely fire in a successful loading case, and it basically punts on handling the \"didn't correctly load\" case. So, unfortunately, I can't do anything about the fact that the chain stops when one fails to load.\n\nBTW: others in the past have addressed \"fallback\" behavior like this (ie, what to do when something fails to load) by setting up a timeout and just making some assumptions about a failed load if a certain amount of time goes by. I don't recommend that, per se, but that's how some people have gotten around this.\n. LABjs doesn't use XHR except in some rare fallback cases for old browsers. So we're reliant on the events that the `<script>` element can give. That's the unreliability I was talking about before.\n\nOne primary design goal of LABjs is to only expose as functionality in the API that which can actually be reliably implemented cross browser. If you can't do it reliably, I don't think you should make a \"maybe works\" kind of function in an API, as its exposing you to more problems and devs' blame.\n. I have to admit I'm not terribly certain I understand quite what you're asking for.\n\nOn the surface, it looks like you're asking for how to build a special type of framework for dependency loading that abstracts on the \"page\" (as seen in the URL by a router) as the unit of loading dependency. If that's what you're asking for, that's quite an ambitious task, and I just want to level-set that I won't be authoring that for you here, nor should you expect any other open-source project to just do that for you, in their documentation.\n\nOTOH, that's an admirable type of project to do, so I'd encourage you to build one to your suiting, and make sure you open-source it as you do, so that the community can contribute to and benefit from it as you explore those use cases.\n\nNow, at a simpler level, if you're asking how could my script loader (LABjs) used in such a theoretical project, that IS something I can speak to.\n\nLABjs is a dynamic script loader, which means you can load one or more scripts at any time, not just at page-load time. You can, at any time, request 1 or more scripts, using `.script(..)` API calls, and they will default to loading in parallel and running ASAP. If you need for there to be an enforced execution order, you can call `.wait(..)` calls in between them, which will not affect loading but will affect execution order to preserve it.\n\nSo, whatever higher-level abstractions you build in such a page-loader framework, at the point when you need to fetch a script, it's a simple as invoking `$LAB.script(..)` and then using a `.wait(..)` with a callback to be notified when it finishes. That's LABjs's strong suit, is making that sort of on-demand loading incredibly simple.\n\nIt would be up to you implement all the other abstraction on top of LABjs, however.\n. Maybe take a look at existing frameworks, many of which have routing built-in. For instance: Backbone http://backbonetutorials.com/what-is-a-router/\n. There are no \"undocumented features\" of LABjs. What you see (in the documentation) is what you get.\n\nAs such, the first link indicates that someone who has extended LABjs with some additional behavior. I'm not aware of how they did it. He mentions doing a follow-up blog post about that topic, but I didn't find it.\n\nThe second link is a gist that I wrote myself, in an attempt to help others see how to work-around the situation. What you see, clearly, from that snippet, is that it's based on a brittle set of assumptions about timeouts. Because the actual underlying web platform's functionality doesn't give us a way to do this directly, we have to do hacks. This was the level of hack that I deemed at the time to **_not**_ be worth rolling into the main core LABjs, but instead left to devs to do themselves as they see fit.\n\nFor example, here's a fork of my gist which adds in a bit more functionality: https://gist.github.com/mondaychen/1598350\n\nThis is the sort of task that I think belongs wrapped around the lib (LABjs) rather than inside it, because coming up with a single way to do it which most or all could agree on is extremely unlikely. If the web platform ever answers my call to add something like this natively, then I will wrap that into LABjs.\n. @sergeevabc \nWhat you've shown is conceptually similar to how I use LABjs in my own projects. I call it making a \"bootsrapper\" file, and I usually call it \"load.js\", but I inline the minified production LABjs code, then I include the $LAB chain as necessary for my own project. Then I load just that one file with a normal `<script>` tag, at the bottom of the `<body>`, and it's responsible for loading up the rest of the code for the page.\n\nI have some light conditional stuff in there, so what you're showing is much more complex/capable (deciding files based upon the page you're in), but conceptually it's the same idea. I endorse that as a good pattern.\n\nIf you got yourself a more and more complex/capable mechanism for doing conditional loading based on the page URL (routing), you might make yourself a little mini-lib (similar to LABjs) that you just drop in, instead of having that sort of ad-hoc custom code there. That'd make it easier for you to re-use on other projects later, and be a great candidate for releasing as open-source as a help to others in the community as a contrib.\n\nAs for how to do \"fallback\" style loading, \n\nWhat you may want to do in the above code is the same concept, but instead of using the `queueScript()` and `queueWait()` (which are simple helpers built statically onto the `$LAB` API), you'd want to do queueing yourself.\n\nFor example:\n\n``` js\n\n// NOTE: I've slightly modified this function to pass in a $LAB chain to use.\n\nfunction loadOrFallback($L,scripts,idx) {   \n   function testAndFallback() {   \n      clearTimeout(fallback_timeout);   \n      if (successfully_loaded) return; // already loaded successfully, so just bail   \n      try {   \n         scripts[idx].test();   \n         successfully_loaded = true; // won't execute if the previous \"test\" fails   \n         scripts[idx].success();   \n      } catch(err) {   \n         if (idx < scripts.length-1) loadOrFallback($L,scripts,idx+1);   \n      }   \n   }   \n\n   if (idx == null) idx = 0;   \n   $L = $L.script(scripts[idx].src).wait(testAndFallback);   \n   var fallback_timeout = setTimeout(testAndFallback,10*1000); // only wait 10 seconds\n   return $L;\n}\n\n\n\nvar _queue = [];\n\n// page 1?\nif (document.location.href.match(/ ... /)) {\n   _queue.push([\n      {src:\"http://mycdn.com/page-1.js\", test: ..., success: ...),   \n      {src:\"http://anothercdn.com/page-1.js\", test: ..., success: ...),   \n      {src:\"page-1.js\", test: ..., success: ...)\n   ]);\n}\n// page 2?\nelse if (...) {\n   _queue.push(\"page-2-dependency-a.js\", false, \"page-2-dependency-b.js\", false);\n   _queue.push([\n      {src:\"http://mycdn.com/page-2.js\", test: ..., success: ...),   \n      {src:\"http://anothercdn.com/page-2.js\", test: ..., success: ...),   \n      {src:\"page-2.js\", test: ..., success: ...)\n   ]);\n}\n// page 3?\n...\n\n// later, process the queue\nvar i, $L;\n\nfor (i=0; i<_queue.length; i++) {\n   if (Object.prototype.toString.call(_queue[i]) === \"[object Array]\") {\n      $L = loadOrFallback($L,_queue[i]);\n   }\n   else if (typeof _queue[i] === \"boolean\") {\n      $L = $L.wait();\n   }\n   else if (typeof _queue[i] === \"string\") {\n      $L = $L.script(_queue[i]);\n   }\n   else if (typeof _queue[i] === \"function\") {\n      $L = $L.wait(_queue[i]);\n   }\n}\n```\n\nNOTE: this for-loop process is what I call \"simulated chaining\", and I wrote about it awhile back in this blog post: http://blog.getify.com/simulated-chaining-in-javascript/\n\nNow, the huge caveat: $LAB does not allow you to basically \"pause\" a chain, because that functionality doesn't exist in the underlying web platform. What I mean by this is, we can't really combine the idea of having chained dependencies, as I've shown above, with the idea of having one part of the chain that sorta forks off and re-tries or tries other fallback URLs, while holding up the rest of the chain. You can't pause the main chain and fork off this child processing for one item in the main chain.\n\nBottom line: the above code might kinda work like you want, but you may also notice mal-behavior in the fallback case, because the way the above code works is that if a script has to fallback or be retried, it's doing that in a separate $LAB chain from the main chain processing the dependencies, and as such, you may have code that depends on your file having loaded, but that code didn't wait for all the different attempts at that one file.\n\nYou can probably see now why this topic is so complicated that it's not something I was ever going to bury inside of LABjs. You end up having to make a whole bunch of judgement calls about how to handle these functionality quirks and deficiencies. It's just one of those \"hard\" things you have to figure out how it works for you, even though there may be a dozen other ways to do it that others would prefer.\n. What you are describing is exactly correct and it's also got nothing to do with how LABjs works.\n\nLABjs relies entirely on the browser's `<script>` mechanism for loading. If a browser fires a load event, LABjs assumes the script loaded and ran, and if it doesn't fire the load event, LABjs just waits. LABjs has absolutely no control over what conditions the load or error events fire, and notably (as you're seeing), browsers don't agree on these conditions.\n\nI have multiple times tried to convince the WHATWG group that the spec needs to clearly define under what conditions exactly the load and error events fire, and that those conditions have no overlap or gap (there's always one or the other, and it's predictable). I have been told repeatedly that the spec already has as much detail as they intend, and that it's up to the browsers to decide to agree or not, as they see fit.\n\nSo, unfortunately, my bad news is for you is there's nothing I can do, and all my best efforts to advocate for the actual problem to be fixed have been rejected. :(\n. That's going to completely defeat the purpose of LABjs of ensuring execution order with parallel loads.\n\nI suspect that you seeing it as \"works\" is a red herring and that it will actually be quite the opposite of you want, because you'll have worse (aka, serial loading) performance in IE < 10, or possibly even broken entirely, and also old webkit (pre-Mar2011) is likely going to be completely broken. The other (modern) browsers will still work because they use the `async=false` \"ordered async\" loading.\n. What you're referring to is what I call \"nested dependency annotation\", which amounts to not having an external listing of the script dependencies, but instead of having dependencies only listed inside each file. As you note, because the page doesn't know about \"2.js\" and \"3.js\" until after \"1.js\" finishes loading, it can't do all 3 of them in parallel, it has to load \"1.js\" first, then \"2.js\" and \"3.js\".\n\nMoreover, no script loader is able to actually stop/pause the execution of 4 and 5 if 1 asks to load 2 and 3. There is simply no way to do this cross-browser using what the web platform gives to us. LABjs (and most other script loaders) rely on creating `<script>` elements and as I said before, we're not given any control over when those scripts execute (or delaying that execution). The scripts will always execute ASAP after loading. Sucks, but that's just what we've been given.\n\nI've petitioned the WHATWG group(s) for \"true script preloading\" (which is already present in IE 4+, btw!) which WOULD let you have this control. But they've rejected that effort for over 2+ years, and so none of other browsers support it.\n\nThe only way to do it is to XHR Ajax to load your scripts, and then execute them in the order you want, meaning you can defer when you execute 4 and 5 if necessary. But then, if you want to XHR files, they either have to be same-domain, or you can only cross-domain load in browsers that support CORS, which reduces the number of (old) browsers you can support.\n\nThe only other option is to do what AMD-style loaders do, which is that you force ALL of your scripts to be wrapped in `function() { ... }` wrappers. This allows scripts to load and run in any order, but the actual logic inside each file is wrapped in a function so it doesn't auto-execute, and then you can come along later and execute those payloads in the order you want.\n\nThe downside there is obvious: every file you load this way has to be wrapped.\n\n---\n\nWhat I tell people to do (and indeed, what I do myself) is not to rely on nested-dependency-annotation with LABjs. Instead, have a build tool that reads those files, and finds all the nested dependencies, and constructs a list of scripts that's complete and has the right order (like 1,2,3,4,5), and then have that build tool load all scripts at once, like using a LABjs chain.\n. FYI: found this write-up I did awhile back that explains how I load with \"nested dependencies\" using LABjs:\n\nhttp://stackoverflow.com/questions/15973784/wrong-execution-order-using-labjs/15977311#15977311\n. A whole bunch of people over the years have asked for \"error handling\" support in LABjs. Search through the closed issues archive and you'll probably find at least half a dozen threads on this topic.\n\nMy answer has always remained consistent: the problem with supporting an \"error handling\" API in LABjs is that the underlying platform is not consistent with respect to what constitutes an error or not. The `onerror` handler fires in different conditions depending on platform and browser and version. In fact, there are some bizarre cases where neither `onload` nor `onerror` fire, and possibly even cases where both fire.\n\nThis inconsistency is unacceptable. But it's not anything that LABjs can do anything about. We're just stuck until/if the web platform standards bodies agree to my repeated requests to fully standardize this behavior.\n\nI don't want to put an API into LABjs which behaves inconsistently. If I do that, invariably, LABjs will get blamed when some such error happens in Chrome and not IE, etc. I have no desire to field \"support\" such erroneous and misdirected \"bug reports\".\n\nLABjs' philosophy always has been \"load all scripts in parallel, preserve execution order where desired\". And that's it. It doesn't provide facilities for error handling, graceful recovery, etc. People have come up with all kinds of external work-arounds for such behaviors, as hacks, but I remain unconvinced that any of that belongs in LABjs core to weigh it down and to provide more surface area for people to misunderstand and misblame LABjs.\n. I still see huge chunks of red and green code. I would suggest if you really want me to see the changes, cancel this PR and submit a new clean one.\n. OK, I can now see a sensible depiction of the changes.\n\nAll this analysis I'm going to put down here, it's not new. I've been saying this same things, in parts, over and over again, for years on these threads. I've been very consistent in my perspective. But I continue to leave the door open if someone has any reasonable counter-arguments to change the balance. I don't think it'll happen, but open-source is partly about having these debates and always being willing to accept more evidence.\n\nHere's several thoughts:\n1. Error handling is not a _primary_ use-case for LABjs. At best, it's a secondary/lesser use-case, but in reality, given the tens of thousands who use it without error handling right now, and the few dozen who forked LABjs for error handling types of approaches, you could argue it's kind of niche.\n   \n   For niche or lesser use-cases, the bar is pretty high for the comparative of value to LoC. LABjs is small on purpose, because the major argument against script loading is not loading more code just to load your code. The bigger it is, even a couple of hundred bytes, the less it even makes sense for LABjs to even be used. It is currently, at 2k post-gzip, almost as big as is tolerable.\n   \n   There's lots of features and use-cases we _could_ put into LABjs. Many have asked over the years. I have remained unconvinced that the value overcomes the bloating (even a little bit) of the core LABjs.\n   \n   The code you've submitted looks to be sensible and of good quality. But there's 99 additions and 13 deletions. That's an **_awful lot of code**_ comparatively to be added to LABjs core. I'm not nearly convinced that this feature is useful enough to warrant such a change. Just by estimate, I've not tried it yet, my guess is that this change adds at least 200-300 of post-gzip bytes to the weight of LABjs. That may not sound like a lot, but 10-15% increase is huge in the world of script loaders.\n2. Similar to a bar being high to add stuff into LABjs making it bigger, there's also a very high bar for adding stuff into LABjs to create a new release.\n   \n   I've said a number of times, and I mean it, that the most useful feature of LABjs is its stability. I take the stability very seriously. The reason for that is that to make a change to a piece of code which has been embedded tens of thousands of times on sites across the web, IMO there has to be a really compelling reason to make a new release, and then force all those sites/apps/devs to think about whether or not they should update.\n   \n   If they do update, it's extra mental tax on them to re-validate that nothing changed. If they don't update, they risk getting out of sync with LABjs. Since there's a lot of people who use forked versions of LABjs where they've each added in their own little tweaks, the more I change the core LABjs, the more difficult I make it on them to manage the merge of those changes, and with such a widespread change as you've proposed, it almost certainly will create merge conflicts for some of them.\n   \n   To risk doing that to so many devs, there has to be a strong reason why. I'm not sure that adding a lesser use-case like error handling meets that bar. In fact, I feel like it doesn't, or at least I'm not convinced yet.\n3. There's a philosophical dissonance at play, too. What exactly is the point of having error handling in production code?\n   \n   Is it so you can monitor and report errors? I think there are plenty of other monitoring solutions that are better suited. If I was designing LABjs to be primarily a monitoring or remote-logging tool, I would have designed it quite differently than I did. Bolting on error handling so you can monitor real-time error conditions feels unnatural to the core purpose of LABjs.\n   \n   Is it so you can \"recover\" from errors more gracefully? That sounds nice in theory, but in practice it usually fails to be true. The web already has a built-in \"recover from errors\" and it's called \"refresh\". The chances are low that you had a temporary outage (for a brief few milliseconds) on one of your scripts loading, but only a few milliseconds later, now you can retry that load, and it'll work.\n   \n   When you start to analyze how you'd actually use error handling in the real world, this use-case becomes less and less concrete and more and more niche. I don't think there's more than a few dozen sites on the entire web that care so deeply about error handling and recovery in production that they'd go to all the manual trouble it would be to architect their entire app around the possibility of conditional script-load retries or other such exotic techniques.\n   \n   And for the tens of thousands of others who use LABjs, all this extra code you're proposing would be unnecessary dead weight, because they wouldn't use it, except for...\n4. **_If**_ we added this feature, it feels like it's a dev-mode/debug-mode feature at most. I can't see it being in the production core build.\n   \n   In other words, I have other code which is included only in the \"debug\" version of the code, which is intended only for debugging issues in dev, and not for production. This error handling seems like it **_might**_ make it easier to troubleshoot some types of problems while in dev mode (like wrong script paths, etc).\n5. The single biggest reason I've resisted \"error handling\" for LABjs is the lack of consistency it introduces. I said that earlier in the thread without explaining, so let me expand upon that.\n   \n   First, there's the question that `onerror` fires on script elements in different conditions in different browsers. Some browsers fire it when there's a 404, but not when there's a 500. Some fire it on 500's but not on 404's. You can imagine if you start chasing down other status codes, you find lots of other inconsistencies.\n   \n   The only thing worse than an intermittent error you're trying to debug is when that error is not even consistent in different browsers. This kind of weirdness is **_very opaque to end users of LABjs**_, so it's almost certainly going to lead to people blaming LABjs for bugs rather than the underlying browser.\n   \n   Second, **_and most important of all**_, is that the web platform does not allow us to stop the script loading of the rest of the chain when an unrecoverable error happens. The way the chain API of LABjs is designed, a dev would expect that if they are loading 5 scripts, and file 1 and 2 load, but file 3 fails, then 4 and 5 would be abandoned/aborted and **_not run**_. But this is impossible to accomplish through the library. The only hope is a dev who programs every single file very defensively, but that is not common, especially when you're using files from other third-parties.\n   \n   For example, if file 3 fails, and we report that error, but file 4 and 5 also try to run, and they depend on 3, and they certainly fail, but then do so in an extravagantly bad way, like they add an event handler on browser scroll or in a timer, and that handler is going to fail every single time it's called, then your error log in your browser can quickly fill up and overload, and obscure the actual root of the problem.\n   \n   Worse, the error handling message for the script failing to load can't be predicted when it will happen (because of various timings issues internally), so it could happen at the top, bottom, or smack in the middle of a big stack of other errors, making it likely very hard to find reliably, even across page loads.\n   \n   If you try to architect a scenario where you detect file 3 failing, and you try a fallback URL for file 3, or retry the load of file 3 a few times before giving up, and you want 4 and 5 to wait, you can't delay them while you try to recover from 3 failing. Unless you've taken **_lots**_ of extra care in the design of 4 and 5, this is almost certainly going to cause cascading and totally unrecoverable errors.\n   \n   In almost all cases, hitting refresh is going to be the only reliable recovery, which moots most of the usage of this error handling anyway.\n\n---\n\nBoiling all this down, on the surface error handling is extremely sensible (in theory), but in practice it really falls apart. There's just nowhere near the value-add to overcome all the caveats, bugs, inconsistencies, and extra bloat, to justify adding it to LABjs.\n\nBut again, that's just my _current_ view. I remain open to other evidence/arguments.\n. \"It's my bad...\"\n\nI don't think so, and that's not what I meant to suggest. I was just re-counting, for posterity sake, how I feel about it. Your code is fine and well done, it's just that I already have an opinion about the overall suggestion from many other discussions on it.\n\nAgain, as I said, I remain open to new evidence or arguments which sway the conversation back.\n. If code is stopping somehow, unexplainably, it's probably due to a JS error.\n\nTry this code:\n\n``` js\nif (true;) { \n        $LAB\n        .script(\"dataObject.js\")\n        .wait(function(){\n                  // if \" window.location.href \" was here, it worked! \n            for (var i in dataObject) {\n                    var example = i.match(\"a\");\n                    if (example != null){\n                        try {\n                            alert(\"ok here!\");   // reached here\n                            window.location.href = 'http://www.example.com';\n                            alert(\"not reached here...\");  // not reached here\n                            break;\n                        } catch (err) { alert(\"Error: \" + err); }\n                    } \n            }\n        });\n}\n```\n\nBasically, wrap your `window.location.href` redirect code in a try/catch. Does the try/catch error alert anything useful?\n. What version of LABjs are you using? Can you put this test up on a URL so I can reproduce?\n. It definitely shouldn't be doing what you're seeing. I find it quite bizarre. That having been said, I haven't seen or touched Opera 9 in years. All I know is that way back then, it did work. I dunno if they've broken something about their script loading mechanisms. Will take some investigation, but I'll try to see what I can figure out. Thanks for the test link.\n. Just level-setting expectation here: it's pretty unlikely this is a bug in LABjs, given how long LABjs has been stable (over 2 years and no valid bugs), and given the fact that LABjs used to work fine in Opera 9.x. I will certainly investigate what's going on and try to reproduce and diagnose.\n\nIf it's a bug that can be fixed in LABjs, the chances of a new release of LABjs to fix it are slim (given how minority/legacy a browser Opera 9.x is). The best you could probably expect is a suggestion on how to patch your copy of LABjs.\n\nMore likely though, it could be a newly introduced bug in a port of Opera to a newer platform, in which case that's completely the fault of the browser and may very well be nothing LABjs can do about it. At that point, you'd have to contact Opera about it, but since they have long since retired support for Opera 9.x, I'm not sure how much help they'd be.\n\nNot trying to scare you off. I'll do my best to figure it out, as soon as I get some free time. It may be a bit. And I just wanted to warn you that the resolution may be less than desirable. But we'll see. :)\n. I have not been able to reproduce. Please provide more information if this problem is still persistent for you, and we can re-open.\n. LABjs stands for \"Loading and Blocking JS\". By design, the library blocks execution of script B until after script A has successfully run, _if_ you have specified via a `wait()` call in between the two `script()` calls that there _is_ such an execution order dependency.\n\nThere's an implicit assumption with the usage of LABjs that if B depends on A, and you therefore use `wait()` to tell B not to execute until A completes, then B cannot and should not run if A doesn't successfully run, no matter what. So the question becomes, in your case, does B depend on A, or not?\n\nIf B _does_ depend on A, then LABjs is doing the correct thing by not letting B run if A never runs. If B _doesn't_ depend on A, then don't put B after A in a chain with a `wait()` in between them. If they are execution-order independent, then either load them in parallel (aka, with no `wait()` in between them) or load them in two separate `$LAB` chains.\n. The \"queue\" mechanism (`queueScript()` and `queueWait()`) constructs a _single chain_ of loading and blocking. Making separate calls to the queue functions doesn't create separate internal queues.\n\nIf you need to create multiple queues, which it appears you're trying to do, you can do so manually rather than with the single queue mechanism, like this:\n\n``` js\nvar q1 = [];\nvar q2 = [];\n\n// later\nq1.push(\"A.js\",false,\"C.js\",function(){ alert(\"A and C done\"); });\n\n// later\nq2.push(\"B.js\",\"D.js\",false,\"E.js\",function(){ alert(\"B, D, and E done\"); });\n\nfunction loadQueue(q) {\n   var i, $chain = $LAB;\n   for (i=0; i<q.length; i++) {\n      if (typeof q[i] === \"string\") $chain = $chain.script(q[i]);\n      else if (!q[i]) $chain = $chain.wait();\n      else if (typeof q[i] === \"function\") $chain = $chain.wait(q[i]);\n   }\n}\n\n// load separate queues independently\nloadQueue(q1);\nloadQueue(q2);\n```\n\nBasically, that's doing exactly what the internal built-in queue mechanism does, so if you create separate chains without any interdependency, they should behave basically independently.\n. If the script loads, then that usually means LABjs did its job. I'm not familiar with why it's not working. If you can provide a URL with a complete reduced test-case showing the problem, I can take a look, but based on the code you've shown, nothing is obvious.\n. I have been asked to do this before, but it was an intentional design choice way back at the beginning, not a mistake, not to support LABjs being relative to the `<base>` tag of a page. Back then, `<base>` tags were a big problem for IE6, and moreover, back then (at least), IE didn't support `document.baseURI`. \n\nSo I elected to instead add the `BasePath` [configuration](http://labjs.com/documentation.php#setglobaldefaults) to allow relative URLs. **Note:** the `BasePath` should be absolute, and not relative (as it itself would be considered relative to the page, which will likely produce strange results).\n\n``` js\nLAB.setGlobalDefaults({ BasePath: \"http://some.tld/other/path\" });\n\n// or\n\nLAB.setOptions({ BasePath: \"http://some.tld/other/path\" })\n.script(...)\n...\n```\n\nSo, if you set the LAB configuration `BasePath` to the same as the absolute value in your `<base>` tag, you should get your desired behavior, and that should be reliable across all browsers. Moreover, if you're using `<base>` for only your script tags, LABjs' configuration makes `<base>` unnecessary. :)\n. Unfortunately, this is not really directly possible, cross-browser, at least by the LABjs library. The problem is, browsers are inconsistent about how they handle a \"failed to load\" script. Some fire an error, some never fire anything, some fire a load under certain network error conditions (older browsers I believe).\n\nSo, LABjs really cannot tell if it _didn't_ load, only if it _did_ successfully load.\n\nThe assumption with the normal use of LABjs is that you do not want other code to run if previous code fails to run, as this is **usually** a bad idea, and will just cause cascading errors.\n\nSince you're in an exception case, you'll need to do something different, manually.\n\nMy suggestion is to use a timeout interval, perhaps like this:\n\n``` js\n(function(){\n   var flagged = false;\n   var timer = setTimeout(loadCSLibrary, 10000); // give it 10 secs max to load\n\n   $LAB\n   .script(\"https://.....wa_config.js\")\n   .wait(function(){\n      loadSCLibrary();\n   });\n\n   function loadSCLibrary(){\n      clearTimeout(timer);\n      timer = null;\n      if (!flagged) {\n         flagged = true; // mark this code as having run already\n\n         // ... your code\n\n      }   \n   }\n})();\n```\n\nHopefully that kind of helps illustrate how to construct a timeout for your scenario. :)\n. Never heard of this use-case before now. But yeah, we definitely don't want to rely on the `<base>` tag. So I don't know what an automatic solution would be. \n\nCan you try manually setting, in the HTML of the srcdoc, `location.href = \"\"` or something like that _before_ you include the LABjs code, to see if it prevents the JS error that LABjs encounters? Then, if you set the `BasePath` config variable to some absolute, it should substitute for `<base>` and it should work for you.\n. For security reasons, there doesn't appear to be any way to hijack/override `location` or `location.href`. So that monkey patching won't work.\n\nI'm yet to be convinced that there is a good work-around for URL handling when you're in an iframe that's essentially URL-less. I'm not convinced of what a good clean fall-back is, but I know that `<base>` is not what I'd want.\n\nOne option is if there's no location, then LABjs **doesn't** try to do any URL resolving/canonicalization. This sounds good on the surface, until you realize that LABjs does this only so you get the kind of behavior you expect around \"duplicates\" handling, especially when referencing the same script with different types of relative URLs. Users expect the tool to \"know\" these are the same, and the only way to do that is to resolve them all against a base URL, the window location being the appropriate one.\n\nNot doing canonicalization of the URLs will likely lead to strange gotchas around duplicates, so it is similarly a bad route to head down, IMO.\n\nAnother option is to fake some base URL like \"http://some.tld\" in the case of a missing one, so that all the logic works correctly. But then there's issues where a protocol-relative URL like \"//someother.tld/foo/bar\" URL would expect the correct http vs. https switching, which we really can't do. So this is a bad route.\n\nAnother option is to have LABjs try to look up to a parent frame if the current page has no URL, under the assumption that some frame in the heirarchy in the browser must have a URL. But I'm not sure if security things like CSP would prevent this sort of thing from inside a srcdoc iframe. That would take a lot of research and proving. But it's the only option I see so far which is remotely plausible.\n\n---\n\nThen, we have to step back and ask if benefits of this fix, niche as it is, justifies the \"pain\" of the fix. I'm not really convinced it does. This is the first time in 4-1/2 years someone's asked for it. The stability of LABjs is every bit as important a feature as any other, at this point.\n\nSo I think we could research _if_ there's a fix, but then you'd probably just need to run your own patched version of LABjs with such a fix. If we got a bunch of people asking for this, and if we had other bugs or features that were waiting and could be collected into a compelling enough of a set for a justifiable release, we could consider it some day.\n. bower is dead, apparently. or dying. or something.\n. What's the motivation for this change? It seems you are saying that chrome extensions have urls like \"---://some.tld/...\" with literal - dashes instead of http/https/file/etc? That seems bizarre, if I'm interpreting your code change correctly.\n\nAlso, shouldn't you just be able to use LABjs with explicit URLs, or by setting the `BasePath` configuration, thereby ignoring any of the automatic URL negotiation?\n. Interesting. This may be related to #93. I might make a separate fork branch with slight tweaks that deal with non-standard/unexpected `location` values in a more robust way.\n\nI'm not sure when/if those changes would roll into the main branch and necessitate an update (not sure I think these niche cases justify a 2.0.4 patch release). But at least the separate branch would provide an alternate copy for those who need to use LABjs in those unusual conditions.\n\nI think there will someday be a LAB 2.1 release (or whatever), as over the years several tiny things have been requested. None of them are enough to justify a new release, but taken altogether, I think we'll eventually get to the point where another release comes out, and we'll certainly pull this one in at that time.\n. There are two ways to do what you're suggesting:\n\nMethod 1:\n\n``` js\nvar chain = $LAB.script(..).script(..).wait(..)...;\n\n// later\n\nchain.script(..).wait(..)...\n\n// later\n\nchain.wait(..)...\n```\n\nMethod 2 (more canonical for this situation):\n\n``` js\n$LAB.queueScript(..).queueScript(..).queueWait(..)...;\n\n// later\n\n$LAB.queueScript(..).queueWait(..)..;\n\n// later\n\n$LAB.queueWait(..)...;\n\n// finally\n\n$LAB.runQueue();\n```\n\nThe `queueScript(..)` and `queueWait(..)` functions apply toward an internal queue (like the `chain` var from the method 1 snippet), so it's a little cleaner than doing your own.\n\nOne note of difference: in method 2, none of the loading starts until you call `runQueue()`, but in method 2, scripts start pretty much right after calling `script(..)`. Method 2 should be thought of as an internal queue. Method 1 is a manual external queue.\n\nHope that helps. :)\n. > I know you don't want to add cache busting\n\nSee: `CacheBust` option here: http://labjs.com/documentation.php#setglobaldefaults\n\nI don't have a problem with LABjs truly cache busting, with random numbers. What I don't think LABjs should be doing is munging URLs with higher level abstractions like version numbers. To me that still seems like it should be handled by your build process, or your templating engine, or ... etc.\n\n> Trying to do : `$LAB.script_cb = function(path) {return this.script(path + '?v{{last_build_date}}')` will not work\n\nCorrect, it won't, as you provided it, return your wrapper each time, it'll just return the `$LAB` chain.\n\nBut with a little extra work, you should be able to achieve what (I think) you're hoping for:\n\n``` js\nvar $LAB_wrapper = (function(version){\n   var $L = $LAB, publicAPI = {\n      script: function(src) {\n         $L = $L.script(src + \"?v\" + version);\n         return publicAPI;\n      },\n      wait: function() {\n         $L = $L.wait.apply(null,arguments);\n         return publicAPI;\n      }\n   };\n   return publicAPI;\n})(\"{{last_build_date}}\");\n\n// later\n\n$LAB_wrapper.script(\"foo.js\").wait().(\"bar.js\");\n// loads \"foo.js?v1234\" and \"bar.js?v1234\"\n```\n\nHopefully that helps get you on the path you're looking for. :)\n. First, this is somewhat related to #93.\n\nAlso, your proposed regex doesn't actually work:\n\n``` js\n/^[a-z][\\w\\+-\\/]+\\:\\/\\/\\/?[^\\/]+/.test(\"chrome-extension:mmjeglkkcnglojkjoomifokhekiiiioe/www/index.html\"); // false\n```\n\nWe'd have to tweak the regex to make the `//` part optional, or something like that.\n\nMoreover, the question is: could we actually assume to detect against URLs that don't look like normal web URL's and not break other important behavior (namely absolute/relative URL handling)?\n\nIn addition to the `root_domain` matching with `/^\\w+\\:\\/\\/\\/?[^\\/]+/`, loaded script URLs are canonicalized to the page by testing against `absolute_regex`: `/^\\w+\\:\\/\\//`. So, if we're going to make the change to one regex, we have to change both regexes.\n\nBut, imagine if we did that, and then someone had this URL: `foo:bar/baz.js` to load some script, while inside a chrome extension.\n\nAny generic regex that matches your chrome-extension URL would have to also match that `foo:bar..` URL. However, that URL might in fact be intended as a relative URL, where they want it to be canonicalized to the root chrome-extension URI, so that it would be loaded as `chrome-extension:aosnsldk24rl2ksada/foo:bar/baz.js`.\n\nHow could we know that this URL should have been taken to be as absolute instead: `foo:bar/baz.js`, rather than relative?\n\nWe couldn't. Right now, \"absolute\" requires something like `http://` at the beginning, which is an easy assumption. But that assumption would totally go away with the proposed change.\n\nUnless, and this is the part I'm dubious on, the regex only allowed a specific safe-list of scheme names, not just a `w+` type regex match... like `chrome-extension:`, `about:`, etc.\n\nHow would we decide which scheme names should be explicitly listed? What happens if someone later comes along and says, \"hey, my page is running under this `wxyz:..` scheme, can you whitelist it?\" And what happens if that accidentally collides with someone else's relative URL design?\n\nSeems like a future maintenance nightmare, that ensures we have to keep updating LABjs rather than keeping it stable and unchanging as much as possible, and that we're asking for breakages.\n\nNot sure what a good general solution to this would be.\n\nMy initial reaction is similar to what I said in #93, which is that this is a case where you should tweak LABjs for your own needs, since it's a pretty niche use-case, and the pain (of this one specifically) is disproportionately high.\n. OTOH, perhaps the more appropriate logic is, if the current page is a scheme type, you couldn't do an absolute regex that was also a scheme (unless it was an exact match). You'd have to do a normal web URL like \"http://\", or otherwise the URL could be reasonably assumed to definitely be relative to the scheme URI.\n\nEven if we could construct such special case logic, I'm not sure if the niche'ness of this deserves to be elevated to the core code.\n\nUndecided for now.\n. Interesting. So the only thing missing is the allowance for `-` in it?\n. OK, this will be queued up to be fixed. But, just to set expectations, we're collecting several small niche things like this together before releasing again. As you can tell, I release quite rarely, as stability is one of the main features of this library.\n\nI would recommend for now that you patch your own copy of LABjs. I'll leave this issue open until such a time as it's appropriate to fix for that next release (probably 2.1).\n\nThanks!\n. @mttcr thanks! to clarify, you're talking about?\n1. using LABjs to load a blob URL? --OR--\n2. using LABjs inside a page that came from a blob URL?\n. thanks!\n. LABjs only supports generating random numbers to append to the end of the query string (for cache busting). If you're implementing logic that gives meaning to the values in your URLs, you need to manage that in a layer that produces the URLs you feed to LABjs.\n. My guess is you have a execution race condition with a silent error that stops the chain. Can you post your `$LAB` chain exactly as you use it in the page?\n. How is the LABjs script file being included in the page?\n. I don't understand how a `<script src=\"..\"></script>` tag can't be guaranteed to have loaded and run before the rest of your code. The whole `setInterval(..)` thing is wholly inappropriate to use here. It speaks to a deeper issue that you would ever need to try something like that. We need to dig deeper on this, I don't suspect that it has _anything_ to do with LABjs itself.\n\nCan you post here, or email me privately (same name but on gmail) a full HTML dump (from view-source) of your page, so I can see what actually the browser is trying to run, and in what order? Alternatively, a URL to the page would be useful.\n. Glad to hear you've worked through some of those issues. Let me know if I can help elsewhere. :)\n. LABjs doesn't load anything that you don't explicitly pass to a `script(..)` call on the API. So I'm confused as to what need LABjs would need to ignore? Just don't pass it something you don't want it to load.\n. Cheers! :)\n. LABjs doesn't have any code in it that even includes the word \"nestable\", so it's definitely not filtering out those files. Your issue must be related to something else, either software on your computer or something in your server configuration, or something like that.\n. Closing for now. Reopen if there's more specific evidence to share.\n. done. :)\n. Perhaps try the `CacheBust` option in LABjs?\n\n``` js\n$LAB.setOptions({ CacheBust: true }).script(..)\n```\n. LABjs doesn't do any loading or logic around caching. It simply causes a `<script src>` tag to request a specific URL. The browser and the server (by way of its response headers -- caching, etc) are entirely in control of how and when those files will be loaded, reloaded, or pulled from cache.\n\nThe `CacheBust` option only prevents caching by making sure the URL is always different, which effectively defeats any caching that may otherwise have happened. But it doesn't have any direct control over the loading itself.\n. duplicate\n. This seems like a reasonable thing to consider for a future update.\n. That's what I was going to point you to. :) Cheers.\n. uhhh... i have no idea what that would be. since LABjs just does loading via normal `<script>` tags in all modern browsers, I would think this would be an issue that was replicatable outside of LABjs' code. Any chance we could get an affected file to test with?\n. Closing for now. Feel free to add more details if this crops up again and seems to be LABjs related.\n. LABjs places no limits (or controls) over how parallel a browser will load requested resources. So there's nothing to change in LABjs for that.\n\nIt remains an unknown to me how to tell the browser (if anything) that you want requests to be interleaved on a single connection. I believe that may happen automatically, but I suppose it's possible it may need a client-side change. I've not heard any details about that. It's also possible that it requires no extra work on the client, but may require changes to the server to recognize these requests and combine the responses into one connection. Again, I have not investigated any of these specific details.\n\nIf there ends up being something specific LABjs would need to change to adopt HTTP2 conventions for parallelism of connections, I'm happy to entertain discussion.\n. Please see: https://github.com/getify/LABjs/issues/19#issuecomment-50981147 (and other closed issue threads)\n. @dudesl can you be more specific?\n. The goal is the 3.x launch will be on npm\n. it's started... there's a separate branch for the 3.0 work. it's in progress. just haven't had much time lately. \n. I appreciate that several people have interest in this project. I do definitely want to complete the 3.0 rewrite (I'm about 1/3 of the way through that). However, the project is lower on my priority list. I have several other projects that are more pressing.\r\n\r\n@finetype the site (http://labjs.com) is down, but it's up on http://archive.org so you can consult the docs there. They should have the info you're inquiring about. Part of the rewrite will be to migrate all that documentation over to this repo.. I've just pushed up my long-in-progress work on the 3.0 rewrite. It's at bare minimum functioning status. Still very much pre/alpha, but at least it's coming along finally. :). See below for a checklist. Theoretically, others can help with this coding.\r\n\r\nTBH, I still expect most likely to be the one to do (most of) the code for the core library. It's not a particularly simple flow control to fully understand, and it's not documented anywhere, so I'm not expecting other contributors to fully understand what I'm juggling in my head. :)\r\n\r\nBut there's several extra projects (like the server util, the mock DOM, etc) that definitely are good for others to tackle. Definitely will also appreciate help eventually with docs and tests. :)\r\n\r\nFor now, please take a look at the code and see if you spot anything or have any suggestions. That much I'm happy to have help with, for sure!. Gonna start a checklist here (in no particular order) for the rest of the stuff I think will need to be done for 3.0... expect this list to grow significantly:\r\n\r\n- [ ] fix `script(..)` and `wait(..)` to also take arrays of arguments\r\n- [ ] add methods (similar to `script(..)`) for loading other resources besides scripts (like stylesheets, images, etc)\r\n- [ ] add back in the `queue*(..)` / `runQueue(..)` mechanism from 2.x\r\n- [ ] explore adding back in the \"AllowDuplicates\" mechanism from 2.x -- not sure if possible, nor even worth it\r\n- [ ] modules (https://jakearchibald.com/2017/es-modules-in-browsers/) \r\n- [ ] figure out correct handling for \"CacheBust\" (especially as it relates to `<link rel=preload>` preloading)\r\n- [ ] figure out which additional options make sense for `script(..)` (and/or other resource loading types), such as a whitelist of attributes to be added to the element, etc\r\n- [ ] add `error` event handling for script/link elements\r\n- [ ] address all the TODO comments in the code\r\n- [ ] rebuild a whole new test suite\r\n   \r\n   NOTE: this is particularly challenging because to avoid needing a test server to load resources from, we need to build a mock of (some parts of) the DOM. We can't really just use an existing virtual/mock DOM for this purpose, because we need to actually control it (what APIs are present, how they behave, etc) for our different test simulations.\r\n\r\n   - affected DOM APIs / properties:\r\n      - `getElementsByTagName(..)`\r\n      - `createElement(..)`\r\n      - `head`\r\n      - `appendChild(..)`\r\n      - `removeChild(..)`\r\n      - `baseURI`\r\n      - `setAttribute(..)`\r\n      - `getAttribute(..)`\r\n      - `addEventListener(..)`\r\n      - `removeEventListener(..)`\r\n      - `relList`\r\n      - `supports(..)`\r\n      - `performance.getEntriesByName(..)`\r\n   - we need to be able to simulate a variety of different browser environment scenarios by changing the behavior of these APIs, for example:\r\n      - preloading vs no-preloading\r\n      - script ordered-async vs not\r\n      - `<link rel=preload>` tags already present in the page vs not\r\n      - \"random\" server/network timing variations (and errors!)\r\n- [ ] rebuild the docs\r\n- [ ] revisit feature requests from the last N number of years of issue threads, examine feasibility\r\n- [ ] explore Debug mode and what that means for 3.0+ -- is there a debug build with extra code, what changes in debug mode, etc?\r\n- [ ] explore replacing `canonicalURL(..)` with [`URL(..)`](https://developer.mozilla.org/en-US/docs/Web/API/URL), probably with some sort of polyfill-fallback (for older browsers)\r\n- [ ] change the usages of timers (`setTimeout(..)`) to a scheduling queue (like [this one](https://github.com/getify/asynquence/blob/master/asq.src.js#L19-L59)), backed by one of these async timing mechanisms (in order of precedence): [`requestIdleCallback(..)`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), [`setImmediate(..)`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate), [`process.nextTick(..)`](https://nodejs.org/api/process.html#process_process_nexttick_callback_args), or [`setTimeout(..)`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)\r\n- [ ] using [getify/ScanTree](https://github.com/getify/ScanTree), build a server-side LABjs utility that can scan a code base and compile a list of resources to be loaded, and produce not only the `$LAB` code chain to load it, but also produce the `<link rel=preload>` markup to inject into an HTML page to start the preloading early (parser stage)\r\n\r\n   NOTE: this utility needs to (eventually) be able to parse ES6 modules `import` syntax as well, something that ScanTree doesn't currently support. That may mean needing to extend ScanTree in some way.. FYI: I've moved the mock-DOM thing to its own separate project:\r\n\r\nhttps://github.com/getify/mock-DOM-resources. [Mock-DOM-Resources](https://github.com/getify/mock-DOM-resources) is now capable (enough) to sit at 1.0.0. It's ready to use for a LABjs test suite.\r\n\r\nEdit: it's matured to 7.0.0 now and has a full test suite of its own, so it's definitely reliable enough now for LABjs to use.. @jbmonroe Pretty sure the `src/index.js` file doesn't have any ES6 in it. My goal is definitely to target ES5. The test suite does require ES6 at the moment.. @jbmonroe \r\n\r\nAh, I thought you were talking about LABjs since that's this repo and the main topic of the thread.\r\n\r\nYes, \"Mock-DOM-Resources\" uses ES6 because it's primarily designed to be run in node. It's only used by LABjs' test suite, so again the tests are ES6 but LABjs itself should be ES5.\r\n\r\n> ES6-looking get/set code\r\n\r\nBTW, getters/setters are ES5 not ES6. But there are a few other ES6 features in Mock-DOM-Resources, indeed, such as concise properties in object literals.. LGTM. Thanks!\n. @xaddict why does it matter where LABjs adds the scripts?\n. Those audits or whatever they are, are being rather naive if they're penalizing you for dynamically added scripts in the `<head>`. It's true it's not a great idea for that in the orig source code, but this is all dynamic, so its placement won't have any difference or impact at all.\n\nNot sure this kind of feature would be useful to a broad enough audience to make it worth the bytes. But perhaps.\n. LABjs is going to append resource requests to the end of the `<head>` from 3.0 onward.. LABjs is undergoing a rewrite to 3.x. I'm not going to accept PRs while that is happening. Error handling is under consideration as a feature for the next version. I'm not sure yet how it will appear. Thank you for your interest, though!\n. Chrome does not block inline scripts, unless the server it's served from is sending CSP policy to prevent it -- in which case there's nothing we can do to fix that.. I appreciate these fixes... but just so you know, the code on the branch is entirely still WIP. I think I probably have local changes not even pushed up to the branch yet. It's a substantial re-write and I'm only 5-10% of the way through. That's why all these things are still so rough.\n. There are other ways such as script injection. Thay said, I'm not really wild about doing our own caching. Browsers are better at it. . That's awfully vague. If you can talk about specific details with caching, perhaps we can identify other causes (poor caching headers, etc). But I don't think we should fix our problem of a thumbtack by pulling out a sledgehammer. :). Any control you'd like to have over caching should be handled with service workers, IMO. I don't plan to build any caching behavior into the loader. It is possible eventually LABjs will ship a service worker for assistance, but that's far down the priority list, if ever.. My servers have been down since last July. I haven't had time to rebuild them. The data wasn't lost, but I don't have anything to put up right now.\r\n\r\nIn the interim, the whole site should be available for review (docs wise) here: http://web.archive.org/web/20160521005010/http://labjs.com/. Error handling on resource requests is notoriously inconsistent (differences between 4xx and 5xx HTTP error codes, for example). As such, I don't want to try to bake reliance on that inconsistent behavior into LABjs.\r\n\r\nHowever, in 3.0, LABjs is going to support an error notification (of some sort), so you can at least be notified if any error events are fired against the resource elements. That probably won't help much in recovery, but at least you could log the failure.. It's illegal as of strict mode. It should be refactored. Easy fix is to name the function expression (passed to the setTimeout) and use that function name.\r\n\r\nNOTE: the library is undergoing a complete rewrite for 3.0, so there's no need to PR to fix this, because it'll be fixed in that rewrite.. Based on your description, this doesn't sound like a bug in LABjs. First off, we'd need to know which browser are you using for this test? If it's a modern one, I can virtually guarantee it's not a LABjs bug, because under the covers, LABjs delegates to the browser to enforce loading order (using the `async = false` \"ordered async\" feature).\r\n\r\n> Understandable, script loaders undermine the normal document.ready event.\r\n\r\nNo, I wouldn't characterize this as undermining anything. Expose false assumptions? Yes.\r\n\r\nHistorically there have always been race conditions, and always will be, when people (ie, developers of projects) conflate \"DOM ready\" with \"scripts have loaded\". I ranted about this countless times ages ago. Here's [one relevant issue thread](https://github.com/getify/LABjs/issues/16#issuecomment-690070) I found in my searching.\r\n\r\nIt sounds like Angular is assuming that DOM ready means \"all dependency scripts have loaded\". That's not at all what DOM ready means, and even less so when there's dynamic script loading involved.\r\n\r\n> So, I try to use $.holdReady(true) and $.holdReady(false)\r\n\r\nI don't know what these are, as I'm not an Angular dev. I can't really comment on whether they're safe for dynamic script loading or not.\r\n\r\n> That makes it seem like a race condition, but given that I'm passing in the order flag\r\n\r\nIt probably is a race condition, but it sounds like it's not a race condition between scripts but rather a race condition between scripts finishing loading and the DOM ready event being assumed to mean the scripts finished loading.\r\n\r\nMy advice continues to be: stop relying on DOM ready to mean \"scripts are loaded\". Any framework that does that is being openly dismissive of reality.. > These false assumptions are those of the angular code here, not my own code.\r\n\r\nI didn't mean to suggest it was your fault or poor assumptions. The fault is with tools that make these decisions, always has been and always will be. :)\r\n\r\nMoreover, these bad assumptions make those tools unfriendly to **any** dynamic resource loader, even a manual inline snippet inside a `<script>` tag. Dynamic resource loading, which has been a thing for a really long time, is antithetical to these assumptions. It's similar to tools that rely on `document.write(..)`. I've literally had such tools just tell their users \"don't dynamically load\".\r\n\r\n> It's a jquery event (it's not the same as window.onload, and is not a real DOM event as far as I am aware; it has its own characteristics in its attempts to be cross-browser and support its assumptions)\r\n\r\nAre you talking about `$.ready(..)` here? I'm assuming so. \"DOM ready\" is otherwise known as [\"DOMContentLoaded\"](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded)  and is absolutely a real DOM event thing. All `$.ready(..)` does is provide a dedicated event handler interface for it.\r\n\r\nAnd BTW, jquery's `$.ready(..)` is patched (as of jQuery 1.4 years ago) to handle the use case where jQuery itself is dynamically loaded after DOMContentLoaded has already passed. What jQuery does (or at least used to do, I haven't looked at their source code in half a decade) is check the [`document.readyState`](https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState) property (again, totally standard DOM stuff) to check to see if the document load has already occurred. If so, jQuery always fires your `$.ready(..)` right away.\r\n\r\nBut all of this is actually orthogonal to your problem. The problem is not whether `$.ready(..)` works or not. In fact, `$.holdReady(..)` is not fixing anything \"broken\" about `$.ready(..)`. It's making `$.ready(..)` work in an entirely different way than it was designed, because the authors of these frameworks/tools insist on using it differently. But DOM-ready has worked -- as designed -- for a really, really long time.\r\n\r\nIn fact, the proof that it \"works\" is that it's firing for you, even though it's firing \"too early\". The separate problem is that this event will, in general, ***always be able to fire before resources*** that don't *block* the event -- any dynamically loaded resource, any resource that `defer`s its loading (like `<script defer>`, etc), and more -- has finished loading.\r\n\r\nIf a resource doesn't block the event, obviously there's a race condition.\r\n\r\n> as its name tells us, its intention was to signal that code running then can expect everything to have loaded\r\n\r\nEh, no. Though the name `DOMContentLoaded` says \"Content\", the \"content\" here isn't about external resources. It's about the internal DOM element structure. And \"Loaded\" means the HTML itself has loaded and been parsed into those DOM element objects.\r\n\r\nQuoting [the MDN page](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded):\r\n\r\n>> The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. A very different event `load` should be used only to detect a fully-loaded page.\r\n\r\nSo `document.ready` is definitely not about \"resources have finished loading.\" `window.onload` was originally meant for resource loading completion, even though it also won't wait for (some kinds of) dynamically loaded resources.\r\n\r\nThe crux of the mal-assumption around `DOMContentLoaded` has always been related to `<script>` elements. Because `document.write(..)` needs to run synchronously, the browser has always ensured that any `<script src=..>` or `<script>..</script>` element would execute (regardless of loading order) in the **same order as listed in the DOM**.\r\n\r\nThus, the logical reasoning goes: \"if the current line of code is executing, then any other code that was 'requested' (listed in the DOM) earlier *must* already have finished loading **AND EXECUTING**.\" From that, it's a natural extension to assume, \"if i declare a DOM-ready handler in a piece of code, then all the code -- at least the code 'before' me -- must already have loaded and run, because I couldn't have gotten to this line of code if that previous code hadn't already run.\"\r\n\r\nLong before resource loaders came around, this assumption was already broken when HTML added `<script async>` and `<script defer>`. In both those cases, you're telling the browser to take that script resource and treat it as a separate thing that doesn't hold to those rules. So it's really always been a terrible assumption and conflation, but resource loaders painfully expose it for what it is: **junk science**.\r\n\r\n> $.holdReady() is a jquery tool to manipulate the $(document).ready event\r\n\r\nYour bug may just be that this plugin is broken or incomplete. I don't know.\r\n\r\nBut in theory, if it lets you \"hold off and artificially fire jquery's `ready` event whenever\" you want, then you should be able to \"delay\" until the final `.wait(..)` in your `$LAB` chain. That may be what you were trying to do, not sure, but at least in theory it seems reasonable. Well... hacky patchy ill-advised... but not irrational.\r\n\r\nNow that I think about it... if `$.holdReady` is a jQuery plugin -- it modifies jQuery at run time -- the race condition could just be that jQuery is firing its ready event before `$.holdReady` has a chance to modify jQuery to hold the event off. It could be that you need to package jQuery and `$.holdReady` in the same file so they're ensured to run together. I dunno.\r\n\r\nI still really feel like this is a bug that has nothing to do with LABjs, but more about the process of resource loading in general, and perhaps a failure to hack things to work differently than designed.\r\n\r\nIOW, I'm pretty sure I could expose this bug without using LABjs at all, just using basic resource loading logic.\r\n\r\n---------\r\n\r\nAny chance you could pull out the part of angular that is creating the problem (I guess along with `$.holdReady(..)`) and show a standalone minimal reproduce test case that I could analyze, instead of needing to grok all of angular's internals?. Cheers! :) . Cheers! :) . I've been unable to reproduce the problem. Can you post a link to a test page where this occurs so I can inspect further?\n. never heard back, so closing this issue.\n. OK, thanks to your further information, I have found and (I believe) fixed this issue... the new fLABjs posted here on Github has the fix in it. Please try and let me know if it resolves the issue.\n. do you have a site/page you can point me to where I can see this behavior happening? Is there a particular browser it happens in or all browsers?\n. i was never able to reproduce this. I believe the issue must've been related to JS errors being swallowed by the try/catch that runs around .wait() functions... i think there were race conditions present. In any case, if you can create a simple reproducible test case, resubmit another issue and I'll re-examine.\n. I have visited that site in both FF and IE8, and it appears to me to come up fine. But you've not given me any information that describes what SHOULD be happening on the site versus what IS happening.\n\nWhat I see is 3 boxes that say \"Title 1\", 2, and 3. When hovering over them, they turn to a gray background, and nothing happens when I click.\n\nCan you describe what's supposed to be happening, and what is instead happening, in more detail?\n\nAlso, it would be helpful if you could show the exact same demo/code but without the use of LABjs so I can compare both to see what the correct expectations should be.\n. I tried both links in IE8, FF3.5, and FF 3.6, all on windows... in all 3, the page loads and an alert says \"hey\". Is that what's supposed to happen? If so, no I can't reproduce your bug. :(\n. ok, so what i've narrowed down so far is this:\n\nthe reason you are seeing this behavior (which I'll loosely call a \"bug\") is because the dupe-checks don't fully work they way you'd probably expect between independent $LAB chains. Moreover, if you have an entire chain that loads all scripts which have already been loaded before, that seems to be what exposes this issue. If I add even one non-dupe to the nested $LAB chain (inside javascript.js), things load and execute fine.\n\nThe reason I say \"bug\" and not bug is because I'm not sure that I would necessarily say that the usage you're doing is an intended supported use case. The dupe-check in general was always a more problematic and basically not recommended feature. It was not really designed to be used across chains like you are doing, as it raises very sticky race conditions. It was certainly not designed to basically work that an entire $LAB chain would be ignored and a final .wait() would be the only executable item, which is essentially what this amounts to. Similarly, $LAB.wait(func); also is not a supported usage, for probably a similar reason.\n\nAt this point, I'm not sure if I'll be able to resolve this or not. I've reopened this bug, and as I get time I'll look into it.\n\nIf it helps, my suspicion is that the problem is related to the nested chain having the internal \"first_pass\" boolean staying true when it should eventually cycle to false. I haven't verified this yet, but knowing what I know about the brittle parts of the code, I think it's a decent candidate.\n. Definitely a known issue that separate $LAB chains (like when an extra $LAB chain is nested inside a script file loaded by another chain) operate totally separate and so there's no defined or reliable ordering between them. Textbook race conditions there. The only guarantee that LABjs makes about maintaining order is in a single chain.\n\nThere's future releases of LABjs and LABjs-server which are intended to address this use case, but the way you're trying to use it now is prone to such issues.\n. Multiple $LAB chains should be avoided. However, your usage is possibly safe since the two chains do not run in parallel.\n\nHowever, your first chain, you need at least an empty .wait() at the end. There's a known issue where not ending the chain in a .wait() can cause issues too.\n. closing.\n. FYI: bugs with \"allowduplicates\" between different $LAB chains is being addressed in 2.0.\n. dynamic script loading completely de-couples script loading (normally done with script tags) from the window's dom-ready and onload events. That's the \"Blocking\" in LABjs name in fact, that it removes (by default) such blocking behavior.\n\nThere's actually no way for any dynamic script loader of this nature to guarantee dom-ready/onload blocking when scripts are loading. So, essentially, those two events will proceed independent of whether a script loads quickly (from cache) or slowly (over the net).\n\nThe problem you're describing was, in a similar fashion, present in jQuery prior to version 1.4, in that jQuery was not, when loaded, checking if dom-ready had _already_ passed when it was loaded. As such, there was a race condition, that if jQuery got there before dom-ready, all the $(document).ready(...) waiting blocks worked. But if jQuery came in after dom-ready, and it didn't check for that, those waiting blocks would all just sit there forever hoping dom-ready would happen.\n\nStarting with jQuery 1.4+, the code base checks for a passed dom-ready by looking for document.readyState, which (for the most part) resolves this problem. In conjunction, because FF before 3.6 didn't have this property, LABjs added a little page-level hack to make that property present, so that the jQuery check would work correctly.\n\nA similar thing seems to be happening with your checking for \"onload\". The logic (I'm guessing) inside Event.observe(...) is simply waiting to hear if onload happens, and if it does, it fires. But I'm betting that onload is firing before this listener gets a chance to register, thus meaning it just waits forever in vain.\n\nThere's no \"window.loaded\" property to rely on like there was for dom-ready with \"readyState\", so the situation is a little tougher/more manual to correct for.\n\nBasically, my suggestion would be something like this:\n\n```\nvar isWindowLoaded = false;\nEvent.observe(window,'load',function(){ isWindowLoaded = true; });\n\n$LAB.script(\"...blah.js\").wait(function(){\n   if (isWindowLoaded) {\n      doSomethingNow();\n   }\n   else {\n      Event.observe(window,'load',doSomethingNow);\n   }\n});\n```\n\nThe key is to have an event listener that executes immediately during page-load (not in waiting for something to happen inside LABjs) that looks for when the \"onload\" happens... if it happens before $LAB has a chance to run, it sets a boolean property to true, so that when the $LAB.wait(...) call runs, it will see that the event has already passed and it'll just proceed immediately. Otherwise, it knows it needs to still wait for the event, so it registers a handler and waits for it to occur.\n\nI hope this is helpful. Let me know if you have other issues.\n. so glad that helped. hope your issues are resolved now! :)\n. It's the use of document.write() in that file. document.write() is _NOT_ compatible with dynamic loaders. There's a race condition inherent that if document.write() is executed before onload, then things are probably ok, but if it goes after that (which can happen intermittently) a document.write() will screw up the page. It can crash IE, and the behavior of seeing the page go blank is quite expected when document.write() runs after a page is loaded.\n\nThe solution is to load scriptaculous manually, then load any other files that don't have document.write() in them with LABjs.\n\nI really wish the frameworks would get their act together (like jQuery did) and get rid of this junk that makes dynamic loading impossible.\n. this failed one of the other test cases. turns out IE9 fixed the bug before their beta release, so no patch needed.\n. i tested this change and it breaks some other test cases. a forthcoming release of LABjs will attempt to fix the cross-chain \"AllowDuplicates\" behavior properly and completely.\n. there are a few plans along that line. more coming soon.\n. conditional chaining is helpful in this task, now, Also, a serever-side LABjs component is still on the horizon. Stay tuned,\n. many people have asked for this before. i have no plans to add it to LABjs at the moment, and here's why:\n1. actually determining if a dynamically loaded CSS file has finished loading is actually quite complicated and challenging to do cross-browser. The \"load\" events don't fire as one would hope/expect. so adding such support would add a non-trivial size to LABjs (or to a LABjs wrapper/plugin).\n2. I actually find it very rare that people need to sequence the loading (and \"executing\") of CSS in between the loading of other scripts. It's very common that someone says \"I want to load these scripts and this CSS file\" for widgets and things, but very rare that someone says \"I need to load this script, THEN this CSS file, THEN this other script .... \" LABjs is specifically for loading things in parallel and sequencing their execution for dependency sake. So it makes much less sense to mix in CSS loading (which usually doesn't need sequencing) into the API. Would be very much more confusing.\n3. Just the dynamic loading portion (not the load-detection or execution sequencing) of CSS files is actually _very_ easy to do. The code is like this:\n   \n   var link = document.createElement(\"link\");\n   link.setAttribute(\"rel\",\"stylesheet\");\n   link.setAttribute(\"type\",\"text/css\");\n   link.setAttribute(\"href\",\"http://link/to/file.css\");\n   document.getElementsByTagName(\"head\")[0].appendChild(link);\n\nBecause that code is so trivially easy for people to do themselves if they want to load CSS dynamically, I don't think it belongs in a tool which is designed for the specific purpose of performance-efficient script loading.\n\nAll this having been said, some other loaders do support CSS loading... like Dominoes and RequireJS.\n. The most straightforward way is to have a CSS style in the stylesheet and then to poll every 25 ms and look for the computed style of some element to see if that style has been applied. Obviously that's kind of ugly, but I've done that successfully before.\n\nIf you look in the source code for Dominoes there's a more complex solution that tries to actually detect if the stylesheet itself is loaded as a node in the DOM, and uses some interesting security behavior in various browsers.\n\nEither way, it's not straightforward or easy. That's one of the reasons I've not put it into LABjs. The complexity is not worth the payoff.\n. closing (for now)\n. Despite the fact that it may have worked in the past, it's not really a supported use case that you \"suspend\" the execution of a chain and then resume it later after some other logic. There's lots of potential race conditions such activity could introduce. Your usage is not really an intended or supported functionality, at least for now. Perhaps the re-write I'm working on will be more robust for it, but honestly that won't be a major design goal.\n\nMay I ask, why do you need to resume the $LAB chain later? Why not use another chain, or just execute the code right away?\n. But I'm still not sure I understand why this implies that you need to split up the $LAB chain? I understand using a script tag to blocking load of mootools (because of doc.write) and LABjs, but then just need one chain that loads all the other JS files, right? Also, how does loading in CSS in the middle of all that factor in?\n. closing.\n. FYI: resuming of $LAB chains will be supported in 2.0.\n. I have gone back and forth on if I want that behavior or not. I'm aware of the issue and the usefulness of the practice. Right now, I detect if a URL is absolute by looking for file:// or http:// or https:// at the beginning... I suppose I could add a second check for just // at the beginning, and then have that add on the page's protocol. \n\nI think the reason why I didn't implement this originally was worry that people would accidentally have \"//\" instead of \"/\" at the beginning of the URL (common issues with escaping and such in various templating engines) and instead of getting a root-relative path, they'd get an invalid path. Hmmm... will do more thinking to see if there's a way to protect and serve this use-case simultaneously.\n\nI'll probably add that to the list of to-do's for the rewrite that's in progress. Thanks for the note.\n. v 1.2.0 was released and addressed this request.\n. Unfortunately, you can't split up the $LAB.script() calls and the $LAB.wait() call like that, because that will act as two independent LAB chains and won't get your desired effect.\n\nYou could do it like this:\n\n```\n<script type=\"text/javascript\" src=\"http://d7.ttcn/sites/all/libraries/labjs/LAB.min.js?lekatr\"></script>\n<script type=\"text/javascript\">\n<!--//--><![CDATA[//><!--\nvar _lab = $LAB\n.setOptions({AlwaysPreserveOrder:true})\n.script(\"/misc/jquery.js\")\n.script(\"/misc/jquery.once.js\")\n.script(\"/misc/drupal.js\")\n.script(\"/misc/ui/jquery.ui.core.min.js\")\n.script(\"/misc/jquery.ba-bbq.js\")\n.script(\"/modules/overlay/overlay-parent.js\")\n.script(\"/modules/contextual/contextual.js\")\n.script(\"/misc/jquery.cookie.js\")\n.script(\"/modules/toolbar/toolbar.js\");\n//--><!]]>\n</script>\n\n<script type=\"text/javascript\">\n<!--//--><![CDATA[//><!--\n_lab.wait(function() {\n    jQuery.extend(Drupal.settings, {\"basePath\":\"\\/\"},\"overlay\":{\"... strip...\"});\n});\n//--><!]]>\n</script>\n```\n\nThe difference here is we \"continue\" the original $LAB chain by saving the ultimate return value (technically the return value from the last .script() call) int `_lab` variable, and we then chain the .wait() off it later.\n\nHowever, I would say in general, it's not a good idea to split the chains up like this, as there's a _possibility_ that you can create race conditions (not really a case I've tested extensively). So if you do it that way, be careful and test thoroughly.\n\nAnother approach, which should be a little more solid, but is based on a very similar concept (simulated chaining) is found here:\n\nhttps://gist.github.com/704226\n\n-OR-\n\nhttps://gist.github.com/475431\n. Initially, it was an important design decision for LABjs to have each $LAB chain completely independent. This is still currently my philosophy and it precludes features which deliberately tie the chains together, even for a single callback.\n\nSyntactically, it introduces an API complexity/confusion that is undesirable. If $LAB.ready() fires when all current chains are done, what happens if you start another $LAB chain after it (or inside it)... will it clear out that event? Lots of issues arise in this line of questioning.\n\nBasically, I'm not convinced that the use-case for multiple chains is all that strong (except in a few scenarios), and so I encourage people to consolidate their code into as few chains as possible. Really, you shouldn't have _any_ code in separate chains if that code has any relationship to code being loaded in another chain. There's [\"simulated chaining\"](https://gist.github.com/475431) (with a for-loop) if you have the need to build up parts of a chain in contextually separate blocks of code and run the chain all at once once the chains parts are all known.\n\nSo, while I've thought about a $LAB.ready() thing before, I think it's counter to the philosophy, API design, and best-practices that are put forth from LABjs.\n\nI'm not aware of any use-case that would be a strong argument for such a thing... can you explain why you think it's necessary?\n. I saw the Drupal LABjs project! Thanks so much for doing that!\n\nI understand that it's common (especially in CMS's) for people to strewn their &lt;script> tags (both inline script blocks and external script references) about the entire HTML.\n\nThat's why I gave you the link on the [\"queuing\"](https://gist.github.com/704226)... basically, you could have the drupal find all the different script blocks (inline and external src) and replace that with the appropriate call to $LAB.queue() as shown, just like you do with $LAB.script() or $LAB.wait() right now. \n\nThen, in the master footer of the page, you have one call to $LAB.executeQueue() which causes the entire set of all scripts from across all the different snippets to start loading and executing, just like if you'd done a single $LAB chain at the end manually.\n\nIn my opinion, this is the best of both worlds for CMS's, because plugins and content authors get to keep leaving their scripts inline strewn about their content as makes sense to them, and the CMS takes care of re-writing all &lt;script>...&lt;/script> and &lt;script src=\"...\">&lt;/script> blocks to calls to the $LAB.queue() manager, and the content/plugin authors never know the difference.\n. yeah, like i said, it's not particularly a supported use-case to have significant delays in the middle of a chain's operation. That's why queuing up all your script and inline scripts (into .wait()) and then firing off the chain all at once at the end is the preferred route. The two links I've sent you above show exactly how to do that.\n. i undersstand that you only want to load some scripts with LABjs. as far as i'm concerned, if you have to, that's fine. if there's a script that has a document.write in it, you should definitely only load that with a regular script tag. (hint: you shold also pressure the creator of that script to stop using document.write()... it's terrible for performance!) \n\nif you're wanting is to have a regular script block in the markup have some waiting affect on the code you're loading with LABjs, this is not possible. the definition of a dynamic script loader is that it makes script loading independent from the page's other resource loading (including manual script tags).\n\nif you're just wanting to sometimes use the queueing (for LABjs loadable scripts) and other times not, do something like this:\n\n```\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head><title>TTCN D7 test</title>\n<script src=\"http://d7.ttcn/sites/all/libraries/labjs/LAB.min.js?lenopg\"></script>\n<script type=\"text/javascript\">$LAB.setGlobalDefaults({AlwaysPreserveOrder:true});</script>\n...\n<script>$LAB.queue(\"http://d7.ttcn/file1.js\");</script>\n...\n<script src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n...\n<script>$LAB.queue(function() {\n  alert(0);\n});</script>\n...\n</head>\n<body>Test</body>\n...\n<script>$LAB.executeQueue();</script>\n</html>\n```\n\nAs for how, in your original markup, to distinguish what code should be queued for LABjs and what should be left alone, have it be something like this as the original markup before you alter it with your Drupal module:\n\n```\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head><title>TTCN D7 test</title>\n...\n<script rel=\"LABjs\" src=\"http://d7.ttcn/file1.js\"></script>\n...\n<script src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n...\n<script rel=\"LABjs\">\n  alert(0);\n</script>\n...\n</head>\n<body>Test</body>\n</html>\n```\n\nSo, your original markup just starts off with script blocks strewn throughout, like shown. For the script blocks where you want LABjs to attach and queue (either for an external `src` loading, or for an inline snippet), you just mark the tag with something like `rel=\"LABjs\"`, that way your Drupal module knows it should rewrite that tag. And you inject the LABjs loading at the beginning, including the setting of global defaults, and you inject the `executeQueue()` call at the very bottom of the page.\n\nI dunno if this helps or not, but that's how I'd approach a CMS module for LABjs.\n. At the moment, I don't have specific plans to include it \"officially\". It's not a lot of extra size, but it is only a functionality that's actually useful if people are using it inside CMS's like you are, and in that case, I think them adding in the little extra snippet is probably the best idea.\n\nPreviously, before I released v1.1.12 (actually, v1.1.11), we didn't have \"conditional chaining\", and there was a lot more of a use-case for this queuing. But now that conditoinal chaining is directly supported, this queuing is only necessary if you need to spread out the building of your chain across the entire HTML block. I don't generally recommend that approach, but in the specific case of CMS's, it's the best (or only) option.\n. queueing was added in 2.0\n. I don't really have a better solution than what you propose. :( That's why I keep saying \"document.write() must die\". BTW I don't have any current plans to suppor DOMWrite with LABjs. Other loaders have tried and I think it's still proving a fruitless effort hacky and error-prone at best. \n\nI suggest using regular &lt;script> tags for any scripts with doc.write in them and LABjs for everything else. Sorry I don't have a better answer.\n. The browser treats different ports on the same domain as different \"domains\" (in the FQDN, fully qualified domain name sense). As such, this implementation is correct, because those domains are considered different to the browser and are thus \"cross-domain\".\n\nTechnically, :80 being present and not being present (since it's assumed), or the same with :443 and not in the case of https, should be part of the implementation, to be fully correct. BUT, the implementation details were a little bit complicated to parse the URI for that type of info, and I didn't think the benefit outweighed the cost. If I had someone who really raised a need for that, I'd consider adding it.\n\nBut, :80 and :8080 are in fact different \"domains\" so the implementation is correct in the case you raise.\n. First of all, your code snippet looks a little incorrect to me. So let me correct it:\n\n```\n<script src=\"lab.js\"></script>\n<script>\n$LAB.setOptions({AlwaysPreserveOrder:true})\n  .script(\"jquery.js\")\n  .script(\"core.js\")\n  .wait(function(){ List.F1 = ... })\n  .wait(function(){ List.F2 = ... })\n;\n</script>\n```\n\nFirstly, I removed the double-load of \"core.js\". Secondly, you can't run code inside a `script()` statement, only inside a `wait()` statement. Unless what your code was intending to imply is not that actual inline code but the load of a separate file with that code in it, in which case the `script()` call is correct. Lastly, I used the chainable `setOptions()` form of option setting, since your code only shows one chain. If you indeed have other chains in the page, then your `setGlobalDefaults()` usage was more correct.\n\nIf indeed it's two `wait()` calls like I've shown, then you should just combine them into one. But if it's two `script()` calls loading separate files, obviously you keep them separate.\n\n---\n\nWith respect to your question about DOM-ready issues, my suggestion is not to use `$(document).ready()` to defer behavior that is really not related to the document being ready or not. That event should be used to defer behavior that needs to interact with the DOM, like event handling, DOM manip, etc. \n\nMany people have conflated that event with scripts finishing loading, because the regular &lt;script> tag just happens to be blocking that event in browsers. When they move to a script loader that specifically breaks the connection between the two, they're always surprised, and often try to jump through all kinds of hoops to fix restore that connection, many of which are more complicated than I think it should be.\n\nMy rule of thumb is, use DOM-ready event for DOM related things, and use your own \"events\" or callbacks for other purposes. In your case, I'd refactor core.js to remove the `$(document).ready()`, and not have it auto-execute anything. Then, you'd make your chain do this:\n\n```\n<script src=\"lab.js\"></script>\n<script>\n$LAB.setOptions({AlwaysPreserveOrder:true})\n  .script(\"jquery.js\")\n  .script(\"core.js\")\n  .wait(function(){ List.F1 = ... })\n  .wait(function(){ List.F2 = ... })\n  .wait(function(){\n    for each (List as f): run f();\n  })\n;\n</script>\n```\n\n(note: if you indeed end up with multiple subsequent .wait() calls like shown above, combine them if possible to avoid unnecessary waste/overhead)\n\nSo, bottom line, I'm suggesting the more difficult modification of core.js to remove the concept of the autorun as you've shown it, because I think it's a bad pattern to load several scripts that have dependencies on each other, and then rely on DOM-ready to be the \"they're all loaded\" event for you. Even without a script loader like LABjs, this is an error-prone and brittle pattern that should be avoided.\n\nBut especially with a script loader introduced, you should instead use the script loader's facilities for knowing when all scripts are finished running, and then you can execute whatever \"autorun\" behavior you want. This is cleaner and easier code to maintain, and will work solidly.\n. The other option, which still involves a modification to core.js, is to change from using DOM-ready to using a custom \"event\" of sorts. For instance, you might do something like this:\n\n```\n<script src=\"lab.js\"></script>\n<script>\n$LAB.setOptions({AlwaysPreserveOrder:true})\n  .script(\"jquery.js\")\n  .script(\"core.js\")\n  /*\n   inside of core.js, at the end, do:\n   $(document).bind(\"scripts-ready\", function(){\n     for each (List as f): run f();\n   });\n  */\n  .wait(function(){ List.F1 = ... })\n  .wait(function(){ List.F2 = ... })\n  .wait(function(){\n    $(document).trigger(\"scripts-ready\");\n  })\n;\n</script>\n```\n\nIn this way, you're using a custom event specifically for the purpose of indicating when scripts are done loading, rather than relying on the conflation with the DOM-ready event.\n. nothing for LABjs to do here.\n. I've considered this (and variations of it) before. Unfortunately, there's one major snag that's prevented me from putting something like that in: the browsers are all over the map in terms of their support for onerror and on not firing onload in error cases. As far as I know, there's no reliable way to guarantee that only an onerror handler will fire if a script fails to load. If both were to fire (as does happen), and in the wrong order (as does happen) it would be a strange and undefined state for the $LAB chain.\n\nAlso, and this is probably more troubling even: in some browsers, like FF and Opera, LABjs does not currently control the execution flow... meaning I could not interrupt the flow of execution (stop it, or inject something into it on-the-fly). The _best_ that could happen there is that you could simply be notified of the failure, but you couldn't do anything to adjust how the rest of the chain was going to work as a result.\n\nI believe the browsers and spec SHOULD standardize the load and error events properly and sanely, so we can do things like this. That's part of what I'm advocating for. But we're a long way off from having that.\n\nI'd welcome any further thoughts on the topic.\n. IMHO, having a feature in a lib that only partially works in various browsers/scenarios is a bad design idea. I don't think the other loaders should pretend to support something that doesn't actually work. When the browsers give us a consistent and reliable way to detect script errors, I'll add this to the API.\n. closing for now. this will be revisited in a later version of LABjs, when browser support is more solid.\n. I refer you to [this comment](#issuecomment-1008931) above. `script.onerror` isn't reliable/consistent cross browser, that's the whole reason I never used that in LABjs.\n. I'd be curious to know what you think LABjs would benefit from a noConflict() for? Are you concerned about people loading multiple (incompatible) versions of LABjs onto the page? Or of people extending one copy of LABjs but wanting another pristine un-changed copy? Or?\n\nI am generally hugely in favor of jQuery's noConflict() pattern. But I've always thought the extra complication was unnecessary for such a small script loader as LABjs. But it's worth considering for 2.0, nonetheless. Would be interested in your thoughts on what the real value proposition is for it.\n. FYI: `noConflict()` has landed in the 2.0 progress work.\n. this is working just fine in 2.0a.\n. I don't think the exception object is that consistent between browsers. I'm not positive, but I don't think it has line numbers and filenames exposed in most of the browsers. For instance, in V8, I know it tracks those values, so that the browser's error console can display them if an exception is left uncaught. But I don't think it exposes all of that data to the JS error object. Perhaps I'm wrong, not 100% positive.\n\nBut whatever properties are on the object, of course they could be serialized and displayed in the console.error() message. It might just be that in some browsers you don't get as helpful of information as in others.\n. there's going to be something like this feature in 2.0. Still not entirely decided on how it will look, but probably will be console.log()'ing that will be turned on only if you put $LAB into DEBUG mode.\n. there's now a DEBUG mode in LABjs 2.0a\n. You should not have errors as a matter of practice in production. If you have errors, you should have a way to find and FIX them, not a way to find and IGNORE them. That's the philosophy applied here. That's why LABjs comes with this optional debug build. Moreover, as explained in the thread above, LABjs' assumption is that by default, developers don't want errors leaking out into the consoles in production.\n\nSo, if you experience issues, either in dev or production, with your loading, swap in the debug LABjs, enable debug mode, and find them. And FIX them. Then swap back to non-debug production LABjs and go home and enjoy your weekend. :)\n\nMoreover, there's a simple fix to this problem which doesn't involve changing your LABjs file nor enabling a mode. It's putting your own `try..catch` error handling (or other robust feature testing!) around any code which, you know, might actually error if something's missing. I would suggest avoiding writing code which can error, and being more robust yourself. But to whatever extent that's not possible, it then becomes your responsibility to do the extra work to use LABjs' debug build to find and fix such errors.\n\nExample: Don't just use `$` assuming it's there, and let an error happen. Test if it's there first:\n\n``` js\nif (typeof $ !== \"undefined\") {\n   $(\"..\")...\n}\nelse {\n   logErrorToServer(\"Oops, jquery is missing.\");\n   ShowPoliteErrorMessageToUser();\n}\n```\n\n**Note:** I don't recommend running with the debug build of LABjs in production, even with the debug mode turned off. But, it's not much bigger, nor appreciably slower (same `try..catch`s in place regardless), so it might be your chosen option to always run with the debug build of LABjs in production, and then all you have to do to \"see\" the errors is turn debug mode on (no file switching necessary).\n. Also, I would remind you, you should avoid having very much code in `.wait(..)` callbacks. If it's more than a few lines here or there, you should consider moving that code into its own file, where the \"error handling\" (aka suppression) that LABjs does won't hurt you. Then you'll only have a few `.wait(..)` lines to worry about with errors and debug modes and builds and such. Your team and your future self will thank you for reducing the surface error of such issues. :)\n. First, I'd suggest reading [this thread #57](https://github.com/getify/LABjs/issues/57), specifically these two comments, for more back-story on my reasoning: [comment 1](https://github.com/getify/LABjs/issues/57#issuecomment-5054895)  [comment 2](https://github.com/getify/LABjs/issues/57#issuecomment-5055481)\n\n> if `queueWait()` is hiding them?\n\nI am not \"hiding them\", I am preventing them from affecting the rest of the `queueWait()`s which might come later in the chain.\n\nSince LABjs is driven by code, it has to be more sensitive to the fact that errors in user code could stop LABjs itself from doing the rest of its job.\n\nBy contrast, in native browser behavior, errors in one `<script>` element cannot stop other `<script>` elements from running (it just abandons execution of the first one and moves on).\n\nIf LABjs didn't catch the errors, any error thrown would cause the rest of the **LABjs controlled parts of the chain** to stop working. But, quite confusingly, the actual script load-and-run behavior (which the browser handles) would NOT be stopped, so some of the chain (`script()`s) would continue and some of the chain (`wait()`s) would not.\n\nTHAT kind of behavior would be far worse.\n\nI'm attempting to keep LABjs working as much like the native browser behavior as possible, with the least amount of surprise of possible. I know you think the current \"hiding errors\" behavior is surprising, but the other choice would be much more surprising. \n\nLet me illustrate. Let's take this series of markup:\n\n``` html\n<script src=\"script1.js\"></script>\n<script>\n   doSomethingInScript1(); // let's say this throws an error!\n</script>\n<script src=\"script2.js\"></script>\n<script>\n   doSomethingForScript3(); // no errors here!\n</script>\n<!-- requires `doSomethingForScript3()` to have completed successfully first! -->\n<script src=\"script3.js\"></script>\n```\n\nOK, so in normal browser behavior, `script1.js` loads and runs, then it tries to run the next inline `<script>` block, which throws an error. Then, `script2.js` runs, then the next inline `<script>` block runs (no errors), then `script3.js` runs.\n\nBut, hypothetically, what if the browser did this instead:\n\n`script1.js` loads and runs, then the first inline `<script>` block runs, which throws an error. Next, `script2.js` still loads and runs fine, but then the next inline `<script>` block **is never going to even be attempted**, because of the previous error. Lastly, `script3.js` loads, and tries to run, but since `doSomethingForScript3()` never even tried to run, now tons of errors in `script3.js` are going to spam your error logs.\n\nThink about that scenario for a moment. Is that scenario more or less surprising than the current native behavior (which you could describe as \"run as much of this stuff as you can\")?\n\nI'd say unequivocally that the current behavior is much better than this second hypothetical scenario.\n\n**That hypothetical scenario** is exactly what would happen if LABjs didn't catch-and-swallow errors inside of `wait()`. :(\n\nHopefully, that fully explains why we can't just let the errors be thrown.\n\n---\n\nNow, I bet the next thing you're wondering is, \"can't you just catch any errors but dump them all to the error log?\" Of course I can. That's what the debug build and debug mode is for!\n\nWhy didn't I just make the core do that? Because philosophically, I believe devs don't want, by default, to have errors that occur in production spamming the console logs of millions of users' browsers. By default, the production build of LABjs tries to be silent, while the debug build tries to be very chatty.\n\nYou have to specifically choose to do one of these things to opt into such verbose reporting:\n1. use the debug build and `DEBUG` mode of LABjs\n2. put your own `try..catch` around your inline `wait(..)` code that dumps errors yourself\n\nEither way, you are specifically saying, \"I want to see production errors\". I would hope you only do that when troubleshooting a problem, and not **all the time**, but even if you do it **all the time**, then it's you that had to opt-in to that, rather than having to opt-out.\n\nI call that [\"pit of success\"](http://blog.codinghorror.com/falling-into-the-pit-of-success/) rather than \"pit of failure\".\n\n---\n\nLastly...\n\n> how I'm supposed to know whether I'm having errors in production\n\nThis is a very important dev-ops type of question, but it's vastly more complicated than anything LABjs even remotely tries to tackle.\n\nYou'll note that just dumping stuff into the console of your users isn't telling you if you're having problems in production. If the kinds of problems you're trying to find are anything like the kinds I've run into, they don't happen for everyone, only some. So, you can't just rely on seeing the messages in **your console** when you run the production app.\n\nOdds are you're going to need to have a robust production monitoring solution in place. Perhaps something which sees if any JS errors happen and remotely logs those to your server logs.\n\nIf what happens by the error being swallowed is that some part of your app fails to get initialized, but the rest of it gets loaded, one thing that may occur is that other cascading errors will happen later when users click certain buttons (which your production monitoring would catch).\n\nAnother thing that could happen is that the error remains \"silent\". That is, most or all users don't even notice, or if they do, it's not a big enough deal that they care or complain.\n\nIf _that_ is the kind of error you're worried about missing, because you don't even know it's happening, stop and ask yourself, \"why am I so worried?\" If an error occurs, but no one notices, and it doesn't cause any other breakage, what is the big deal, and more importantly, why would dumping that into an error console help identify it?\n\n**I think the more likely scenario is** that you WILL hear about errors, through user complaints, or through your production monitoring solutions, or some other channel, and **THEN** you will know it's time to go (temporarily) flip on the debug mode of LABjs in production to start narrowing it down.\n\n**Bottom line: I doubt there really are that many \"hidden silent errors\" in production, when it comes down to real world scenarios playing out.**\n\nI'm sure I haven't convinced you, but hopefully this narrative helps explain more completely where my philosophy is coming from.\n. 1. You should always have at least an empty .wait() at the end of a chain, even if you have no logic to have it perform.\n2. Are you saying there's a 50ms delay before LABjs starts, or are you saying that each script starts 50ms after the one before it?\n. I don't really have an answer. There's no artificial delays inside of LABjs. It sounds possibly like a bug or network connection timing issue in IE8, especially since other browsers/versions don't exhibit the problem.\n. I appreciate your feedback. I agree with you that the documentation needs some love in both cases that you bring up. I have been kinda putting that off because 2.0 has been in development for awhile, and I planned to refresh the docs once 2.0 came out. Unfortunately, 2.0 has been more delayed than I would have hoped, because of issues with the browser vendors and the HTML spec.\n\nIn any case, I agree it needs attention, and if I can't get 2.0 resolved soon, I'll update the docs to more clearly state the situation as it applies to 1.2 (current release).\n\n---\n\nWith respect to your questions:\n1. Multiple $LAB chains are perfectly fine, and are encouraged. What is not fine, and is discouraged, is using the \"AllowDuplicates:false\" feature and relying on that across multiple chains. As several of the comments/issues threads reveal, this is not reliable. It's a major design goal of 2.0 to fix that. I just simply never considered in 1.x dev that this would be a common use case. Turns out it is.\n\nMoreover, if you're going to use separate chains, it's important to understand that they are in fact quite separate. If there's ever been a case where I implied to avoid them (not in the context of AllowDuplicates), it was almost certainly meant to say \"avoid using separate chains when one chain will do fine.\" This is because many people think that they should be able to load multiple scripts in different chains, and then get some sort of \"All Done\" message across the chains. I have had to explain numerous times that the intentional design of keeping the chains separate not only makes that quite awkward to do, but also violates the intended API design and usage.\n\nTo state more clearly: use indepedent chains when you have completely independent groups of scripts to load. If there's any depdendency at all, such as needing to \"gate\" to wait on both to finish, separate chains is perhaps not the best idea and a single chain is better.\n\nAlso, many people use LABjs in a \"CMS\" fashion, where they programmatically build up their script loading across many inline script blocks that the CMS includes into the final HTML from separate page templates, etc. Again, many people were in the habit of specifying a new chain for each snippet, and then were confused why the order preservation didn't occur. To them, also, I said \"avoid multiple chains\"... what they need is a single chain that they can conditionally build up across snippets, and then execute the whole chain. And for them, I built the \"queue\" mechanism. There's a gist for the \"queue\" functionality, to use now, in 1.2, but it's also going to be a native feature in LABjs 2.0.\n1. Should a chain be \"resumable\" later, meaning you could call .wait() on a chain that had already resolved itself? This is a dicey question. I understand the desire that people have to use the .wait() kinda like a special event emitter like jQuery's DOM-ready, where it will either queue and wait, or immediately fire if the event is already passed. I can understand the attractiveness of that design pattern.\n\nHowever, it partly violates the design principles that I had when building the API. The .wait() is not designed to be an \"event\"... it's a link in the chain when the chain executes. Once a chain finishes executing, resuming from it should really be an undefined behavior.\n\nTechnically, with some bug fixes I did in recent patches to LABjs, calling .wait() on a finished chain might very well work. But it's not really a supported or intended pattern. So I tell people to avoid trying to use the API in that way.\n\nMy answer to \"how do i do it?\" then is, keep track of a separate flag/event-signal externally to LABjs... and set that flag in your chain's final .wait(). When you later want to execute something, it's a simple check to see if the flag is set yet (in that case, execute immediately), or if not, THEN you can append to the in-progress chain, and it should work fine.\n\nThis roughly corresponds to how I'd recommend doing the same thing with jquery's DOM-ready... when you have some code to run, first check the document's readyState... if it's still loading, then queue up your code to wait for DOM-ready. If the document state indicates the DOM-ready has already passed, then you can just safely execute your code right away.\n\n---\n\nAnyway, I hope that dialog helps clear some things up. As I said, I agree that info would be useful in documentation. But, it's tough to figure out the level of detail and explicitness to put in such wording. On one hand, I want to discourage usage-patterns which are against the spirit of the API design... on the other hand, I want to inspire people to wrap $LAB with additional behavior as they see fit. $LAB was always intended to be a bare-bones building block for more complicated dependency management. In both of the questions you've asked above, the intention was that people would create wrappers around $LAB to manage those things. Problems started happening when people tried to massage the native API into doing it, in ways it wasn't intended.\n\nI welcome further feedback on how I can find that right balance for the documentation. In the meantime, I hope others do what you've done, when they have questions.. which is to first read the site documentation, then search the live discussion threads here to see deeper info.\n. Then why not:\n\n```\n<script>\n$LAB.script('framework.js').wait(function(){\n   $(document).ready(function(){ do_stuff(); });\n});\n</script>\n\n... <div id='important'></div> ....\n```\n\n?\n. \"because document.ready may take awhile to fire...\"\n\nUmm, `document.ready` fires pretty darn quick most of the time... it maybe takes a browser a few dozen milliseconds to parse the DOM and get DOMContentLoaded fired. `window.onload` may take longer, yes, because it has to wait on images to finish loading, etc. But in most cases, `document.ready` will fire quite quickly. The only known things that block `document.ready` are actual markup &lt;script> tags, but since you're using LABjs you probably don't have many or any of those. So, as long as you have your DOM pretty clean of stuff like that (you should anyway, for general user-experience), then `document.ready` will fire very quickly.\n\nMoreover, you shouldn't be making the assumption that just because you have a &lt;script> tag appearing after some DOM element, that this guarantees that the DOM element is ready for you to mess with. This is a common but flawed assumption. There are a number of factors (and older browsers) which invalidate that assumption. The best-practice and by far safer approach is to not do anything that interacts with your DOM until DOM-ready has fired.\n\n\"...furthermore, the point of this is decoupling the functions you call for a given dependency from the actual loading of them.\"\n\nThat may be _your_ point, but it's fundamentally opposite of the design goal of LABjs. LABjs is specifically about coupling your script loading to \"inline\" script logic, so that all your external and inline scripts will fire in the correct order, even though they are loading in parallel.\n\nThe primary/majority use-case for LABjs is not compatible with what you suggest. This is not something I forsee changing the API to support.\n. \"...I don't actually know whether or not I will want to call do_stuff() later in the page.\"\n\nSpecifically to this point, jQuery's implementation of `document.ready` is capable of doing what you suggest... you can have your code to interact with the DOM element wrapped, like so\n\n```\n$(document).ready(function(){ do_stuff(); });\n```\n\nAnd that code snippet can be called at any time in the life of the page, even minutes later. If DOM-ready has already passed, it'll execute right away. If DOM-ready hasn't passed yet, it'll wait for DOM-ready.\n\nThe only part of the scenario that YOU want that isn't possible with only the LABjs API, is a flag that tells you if a script has finished loading. Consider something like this, then:\n\n```\n<script>\nfunction func() {\n   $(document).ready(function(){ do_stuff(); });\n}\n\nvar framework_loaded = false, $L;\n$L = $LAB.script('framework.js').wait(function(){ \n   framework_loaded = true;\n});\n</script>\n\n... <div id='important'></div> ....\n\n<script>\n// at some later time, either during the \n// loading of the page, or much later, like \n// when a user clicks some button, etc\n          if (framework_loaded) func()\n          else $L.wait(func);\n</script>\n```\n\nPerhaps that comes closer to what you want to accomplish.\n. Does the snippet I posted in my previous response give you any possible approach that works?\n. FWIW, in LABjs 2.0, chains will be completely resumable, so your original snippet will work just fine (with a few minor tweaks):\n\n```\n<script>\nvar $L = $LAB.script('framework.js');\n</script>\n\n... <div id='important'></div> ....\n\n<script>\n$L.wait(function() {\n    do_stuff()\n});\n</script>\n```\n\nHope that helps.\n. LABjs 2.0 work is completely taking a different approach to the source code. For the most part, the source code will not have (m)any minification tricks in it (nothing crazy/ugly anyway).\n\nHowever, there will be a set of transform diffs (patches) run against the source code to \"ugly'ify\" it to make it more prepared for minification and gzip compression.\n. This is (unfortunately) a known issue, where \"AllowDuplicates\" does not work properly across multiple chains. It is only intended to work to de-duplicate within a single chain. A major design goal of 2.0 is to address this limitation.\n\nThe workarounds in the meantime:\n1. Rework your code to only use a single chain (sometimes possible, especially with the \"queueing\" add-on).\n2. Keep track of duplicates across chains by setting some external flag and using logic to delay until it's fully loaded.\n3. Load the framework in a single chain, and inside the .wait(), fire off the other chains... slight downside in that the framework isn't in parallel with the other chains, but it's not a terrible perf hit.\n. this issue with \"allowduplicates\" not working correctly between chains is being fixed in 2.0.\n. this is fixed now in 2.0a.\n. I think it's a good idea to have the \"id\" be a settable attribute. I'll add that in for 2.0.\n\nHowever, note that, cross-browser support for loading a resource type that is not \"text/javascript\" is not supported. So, the snippet you show above is not possible cross-browser, because some browsers won't load an external resource if the type attribute is \"text/x-jquery-tmpl\".\n. you can do so for local template loading, but not for cross-domain... because the LABjs API doesn't really distinguish between making local loads and cross-domain loads, it's not really something that LABjs would be focused on for its core API... LABjs is all about loading a JS file and executing it, so loading other non-JS resources is really outside the scope of what the library is focused on. Of course, you can do XHR to load external templates yourself. The code to load and inject is pretty small, maybe 10-15 lines of code.\n. To further elaborate... LABjs _could_ have logic in it that basically says, if the \"type\" is not \"text/javascript\", i'll only load it locally with XHR, and do an \"injection\" as normal. But then, the question is, how should the LABjs API respond if you ask for it from a cross-domain? (remember, it's quite common for people to host files on CDN's)\n\nI could refuse to load it, or throw some error, or something like that. But it complicates the API and makes it harder to use.\n\nI think the biggest problem is, people want to use LABjs as a \"resource loader\" when in fact, LABjs is only focused on being the best \"JavaScript loader\"... templates, CSS, etc... those are all good resources to load, but they're not the focus of LABjs.\n. i could consider having a \"debug\" mode where you'd get console.log()'s for each action that LABjs takes... would that be helpful?\n. Hmm... I'm not sure I'd want to be that invasive to the current LABjs namespace as to have a set of publicly available arrays, etc.\n\nI think you could solve what you're wanting even for IE<=8 with something like:\n\n```\nvar global_console = [];\nif (!window.console) {\n   window.console = { log: function() { global_console.push.apply(global_console,arguments); } };\n}\n```\n. there will be some sort of error logging and/or debug mode for LABjs 2.0. Still in the works.\n. LABjs does not support a native behavior to \"disable caching\". In fact, in some browsers, LABjs explicitly relies on caching for its preloading (as do most other loaders).\n\nThe behavior you describe is a well-known \"issue\", where the browser won't re-validate dynamically loaded resources under some conditions, forcing you to clear your cache and refresh, instead of a shift+refresh that would normally revalidate and reload changed resources. The behavior is quite unfortunate for developers who use dynamic resource loaders. I am personally tracking a couple of bugs at both Webkit and Chrome for this exact problem (and other browsers have it too). What we're asking for is a \"super refresh\" where all resources will unconditionally be revalidated, regardless of how they were loaded. I hope the browsers give us that soon.\n\nFor the time being, in development, the best I can suggest is:\n1. Disable preloading with `UsePreloading:false` (the other parameters are unnecessary, as this one trumps them).\n2. Append a \"cache bust\" param to the end of every URL, like `\"?_\"+Math.random()`, to force the browser to reload the resource new every page load.\n\nThis is of course terrible behavior/performance, and should only be used for development. In production, turn Preloading back on and don't add the cache-busting param.\n. I'm not sure if that feature makes sense, given the current reliance on caching. But I'll keep thinking about it.\n. So, as of LABjs 2.0, older webkit (prior to about 2 months ago) will be the only browser that LABjs uses \"cache preloading\" on. There will be other forms of parallel/preloading in other/newer browsers, but they won't be based on preloading into the cache.\n\nAs such, the question for this feature request becomes, should I give a feature to disable caching (which will work in most browsers)? I'm inclined to see the value here, so maybe, yes. \n\nBut, what should the feature do in older webkit? If you have it turned on, should it turn off preloading (and go to serial loading) for those older browsers? Or should the cache-disabling be ignored in those older browsers? It's clear that cache-preloading would be totally incompatible with cache-busting, so this question needs to be resolved before I can land such a feature. Frankly, I'm not quite sure which way to go on it. Thoughts?\n. There's now a \"CacheBust\" configuration parameter for this behavior in 2.0a\n. what's the use-case for appending the same query string to all scripts? Is this for cache-busting?\n. what's the use-case for appending the same query string to all scripts? Is this for cache-busting?\n. i'm considering this request:\n\nhttps://github.com/getify/LABjs/issues/27\n\nIf I do that, it should serve your use case, correct? Still have to figure out how things should behave in older webkit, but once that's resolved, I think \"disable-caching\" will make it in.\n. hmmmm... i see why you want this feature, but i'm not entirely convinced it should be baked into a script loader. seems like a fairly limited use case. The more common case seems to be to want a random cache-busting-everytime parameter added (like in dev). With implementing this feature as you've requested, I'd either have to implement both, or the (what i think is more common) use-case of always-cache-bust would require the user to do more \"work\" by calling `Math.random()` themselves (albeit only once, in the config setting).\n\nYour use case on the other hand, being (I think) less common, is easily solvable with a JS variable:\n\n```\nvar _ver = \"?_=20110515\";\n$LAB.script(src1+_ver).script(src2+_ver).wait(...).....;\n```\n\nYes, that's more work, but I'm inclined to believe that perhaps that's the way it should be, because a loader really shouldn't be doing (IMHO) semantic things to determine which resource URL you mean to load. LABjs is very strict and limited in what interpolation it does on a script URL... it only currently will do canonicalization (something browser already does, so LABjs just mimicks), but it won't do anything else to a script URL (even capitalization normalizations).\n\nThe suggested issue #27 is adding more on-the-fly modification of the source URL, but only in a completely clear use-case of disabling caching, not anything about specifically picking a particular script resource by query string.\n\nThis is a fine line subjective judgement call here, but I think LABjs should default to forcing the calling code to be explicit about which URL resource it wants loaded, rather than baking in features where LABjs automatically guesses. I could imagine someone asking for LABjs to automatically add the \".js\" extension, or automatically append other query string information like run-time variables (UA, etc) in the same vein, and I think those would ill-advised feature-creep for a script loader, so your request feels a tiny bit like the slippery slope toward that.\n\nI haven't made a final decision yet, just sharing my rationale at this point. Comments welcomed.\n. now that LABjs 2.0a is basically feature complete, i'm going to investigate what type of footprint (increase in size/complexity) it takes to accomplish this correctly. Then we'll have some numbers to debate about. More soon.\n. I think this request is a feature I'll consider for 2.1. 2.0 is complete and ready to go and I don't want to introduce any more changes to it. But I'll revisit this request for the next release, and see what of it makes sense.\n. I appreciate your time to explain your request for LABjs. I'm not really sure this use-case fits cleanly onto the intended API philosophy for LABjs. What you're asking for is a valid, but rather niche, use-case, which is two separate scripts that:\n1. have a common script (or scripts) as dependencies in the upstream of the chain; AND\n2. download in parallel; AND\n3. execute in first-come-first-served order; AND\n4. each has a different set of coupled-code that should execute after it finishes\n\nIt's specifically #4 which throws the wrench into the general design philosophy of LABjs, which is to organize trees of loading logic into separate, single-path branches (chains). Because you're basically trying to create a conditional-branching path chain with coupled code execution.\n\nIn LABjs' design philosophy (and achieving by default the maximum parallel loading performance), you can have 1+2+3 or 2+3+4, but not really 1+2+3+4.\n\n1+2+3:\n    $LAB.script(\"a.js\").wait()\n    .script(\"b.js\")\n    .script(\"c.js\")\n    .wait(...);\n\n2+3+4:\n    // notice, no upstream \"a.js\" dependency\n    $LAB.script(\"b.js\").wait(init_b); // these are totally separate chains, and thus execute first-come-first-served\n    $LAB.script(\"c.js\").wait(init_c);\n\nSo, how do we get 1+2+3+4:\n    $LAB.script(\"a.js\").wait(function(){\n        $LAB.script(\"b.js\").wait(init_b); // these are totally separate chains\n        $LAB.script(\"c.js\").wait(init_c);\n    });\n\nThis will work ok. BUT, it has the disadvantage that b.js and c.js will not be downloading in parallel with a.js. So, you lose some performance with that pattern. So that's the caveat with the 1+2+3+4 niche of use-cases.\n\n## Also of note... some browsers (FF, Opera) do not support the use-case of first-come-first-served execution , if any of the scripts are remote, without exceptional hacks (extreme brittle cache preloading) that LABjs does not employ. So this feature use-case would be irrelevant (meaning \"b.js\" would ALWAYS execute before, and thus block execution of, \"c.js\") for users in those browsers in that case. In general, I don't design a functionality unless it can reasonably be supported cross-browser.\n\nThe question remains... should I extend (and complicate) LABjs to support this use-case (for IE/Webkit)? In general, I'm leaning toward \"no\". I think it's a rarer use-case in the broad scope of things, with the additional negative of being limited to only some browsers. Simplicity of code (leads to smaller, faster loading code) _and_ simplicity of API design call for minimalism and for trying to serve, generally, the majority use-cases.\n\nThis is all to say, it's not an outright no, but I'd have to be more convinced that the use-case is less niche than it seems to me at the moment. I'd have to be convinced that the performance degradation of the workaround I provided is worse than the extra baggage of baking this natively into LABjs. If you find more concrete examples of why this is a necessary addition, please do share.\n. In your scenario, you didn't address why \"slider.js\" and \"lightbox.js\" have to be able to be initialized in \"first-come-first-served\" order... that's the specific part that I think makes your use-case more niche.\n\nLABjs will in fact run the files themselves in that fastest-first order (in IE/Webkit), if you do:\n\n```\n$LAB\n.script(\"jquery.js\").wait()\n.script(\"slider.js\")\n.script(\"lightbox.js\")\n.wait(function(){\n    init_slider();\n    init_lightbox();\n });\n```\n\nBut they won't initialize until both of them are ready to initialize. You still however get the most benefit out loading your scripts in parallel (all 3 will load in parallel), and the only tradeoff is that the initialization of one of the plugins may be held up until both are ready to initialize.\n\nBut, I'd argue this is better UX in general, for end users, rather than to have part of the page initialize but another part of the page be still unusable. When I go to sites like that, it's frustrating to me.\n\nKeep in mind: LABjs' simple design goal is to make loading and executing of scripts as fast as possible (for the general case). It's not so much about making scripts run as soon as humanly possible.\n\nIf two scripts really are completely independent, you can achieve complete separation by doing the separate chains. If they're not independent, then I think it's more trouble than it's worth (from the code and API perspective) to support this mixed mode where there's sort of run-time conditional dependencies within the chain.\n\nAs stated before, the other possible tradeoff to make is:\n\n```\n$LAB\n.script(\"jquery.js\").wait(function(){\n    $LAB.script(\"slider.js\").wait(init_slider);\n    $LAB.script(\"lightbox.js\").wait(init_lightbox);\n });\n```\n\nThat basically accomplishes what you want, except that the plugins wait to download until after jquery loads.\n\nI think either of those two (while a slight compromise performance wise) is a decent concession/work-around while preserving the design philosophy of the LABjs API.\n\n> Hmm, couldnt this possibly be solved for the hosting-yourself case, by xmlhttprequest the items, and then eval them?\n\nYes, you can easily accomplish it with XHR, if all the scripts in question are local. However, LABjs is focused on the general case, where some or all scripts come from remote locations. As such, it has to assume that it may not be able to use XHR.\n\nI generally don't design a feature for LABjs that only works if you happen to choose all your scripts to be local, because all the other people who use LABjs where some scripts are not local don't benefit from the feature, and in fact, in some cases, a feature may outright not work for them. So, I only consider features which have reasonable behavior for the general \"worst-case\" type scenario.\n. i just don't think the value outweighs the cost... yet. but i may be convinced otherwise if i see more use-cases.\n. this will likely not make it in for 2.0, as i still have doubts about the value compared to the extra script complexity. but i will revisit the topic after 2.0 is stable. closing for now, will re-examine later.\n. dynamic script loaders, by definition, unblock the script loading from affecting the page's initial processing/rendering (aka, they do not block DOM-ready). However, in most browsers, they do still block `window.onload`.\n\n`$L.block_rendering()` would be impossible to achieve, as the only way to do that would to either have a `&lt;script>` tag in the markup, or `document.write(..)` one, which wouldn't work if $LAB were being used dynamically to load scripts at a later time.\n\nI'm confused a bit by your code snippet. You're loading a file with LABjs called \"adscript.js\". Is this the file that has the `ad_server_function_uses_doc_write()` function defined in it? As it stands, you can't do it the way you've shown with LABjs, because the $L.script() call will be asynchronous, but your inline script block with that function call in it will execute immediately in the thread. You'd have to do something like:\n\n```\n$LAB.script(\"adscript.js\").wait(function(){ ad_server_function_uses_doc_write(); });\n```\n\nBut, since that script has (and requires) document.write(), it has to run in place, and is incompatible with being loaded/run by LABjs (or most script loaders, for that matter).\n\n```\n<script src=\"adscript.js\"></script>\n<script>ad_server_function_uses_doc_write();</script>\n```\n\n...is probably the best you can do, if `document.write()` is required.\n\n> Also, can i use LABjs as preloader? to download scripts and not execute them?\n\nThe browsers do not yet give us a consistent/non-hacky way to accomplish this. The only loaders which allow it are relying on ugly hacks like cache-preloading. I have not put in such a feature into LABjs because I don't think it's responsible to base functionality primarily on hacks, so I will wait to introduce such functionality until it's a directly supported feature in all current releases of the major browsers.\n\nThere's hope though, because IE _does_ support it directly (has since IE4), and the spec even suggests wording which makes an explicit preloading mechanism of that sort quite feasible. We just have to get other browsers to implement the suggestion (or get it turned into a requirement!). LABjs 2.0 includes future-thinking feature detection for this functionality, and in fact uses it for normal LABjs loading in all versions of IE (in replacement of cache-preloading for that browser use-case).\n\nMore info on explicit preloading proposals: http://wiki.whatwg.org/wiki/Script_Execution_Control\n. closing for now as unresolvable\n. i have to admit this is strange behavior that i would not expect. if you look at the firebug net panel, DOM-ready is in fact _not_ being blocked, but the `window.onload` is (obviously, as expected) blocked. what it seems like is that jQuery is waiting for `window.onload` to run the `$(document).ready(...)` stuff, which is bizarre. i can't think of anything that LABjs would be doing to cause this. needs further investigation, but i suspect it's something quirky in the internals of jquery.\n. As near as I can tell from my brief looks into this, LABjs is not the cause. LABjs does nothing to delay the DOM-ready of the page (in fact, it acts to unhinge script requests from the DOM-ready). This is especially true of any browsers that are not FF3.5 and below. In FF 3.5 below, LABjs does \"patch\" the _page_ for the fact that a `document.readyState` is not present in that browser. Doing so is to assist something like jQuery in doing DOM-ready detection.\n\nBut since this code only affects FF 3.5 and below, it is almost certainly not the cause of what you're seeing. I would suggest constructing a test page without LABjs where you manually load scripts dynamically with `document.createElement(\"script\")` and see how the page behaves with respect to the images blocking DOM-ready.\n\nWhat I believe this will boil down to is probably quirks/bugs with the browser(s) that will need to be filed, not with there being something that LABjs is doing to create this side-effect.\n\nFYI: please make sure any bugs you are reporting now are with LABjs 2.0, as 1.2 is now the old-stable, and 2.0 is the new version (about to be fully released).\n. Closing this for now, as I haven't been able to confirm it.\n. You can set the `BasePath` config variable, either globally (for all chains), or per-chain... why is that not sufficient?\n. Closing as BasePath seems to be sufficient for the OP\n. the debug code is simple to remove with regex pre-processor:\n\n/\\/*!START_DEBUG(?:.|\\n)+END_DEBUG*\\//\n\nThat's exactly how, in my editor, I prepared the code before running it through the minifier(s).\n\nThe other option is to just simply re-minify the non-debug minified LAB.min.js file...or, some build processes allow you to make exceptions to exempt files from minification.\n. what problem will reminification cause? YUIC is a safe compressor so it shouldn't do anything but rename a bunch of already shortened variables, and possibly inject a few extra semicolons that it believes are important.\n. I added a section to the documentation to make this more clear. Thanks for the question.\n\nhttp://labjs.com/documentation.php#builds\n. In your code snippet, the problem is that you're passing a function to `queueScript()`... passing functions to `script` or `queueScript` cause them to be executed immediately, so that the value they return is used as the src for which script to load. So your function is being run immediately, before jQuery has had a chance to run. This is by design.\n\nIf you want to queue up an inline block of code (that's what it appears from your block), and not have a function that is supposed to return a script URL, but instead have it wait for the appropriate sequence in the chain, then you want to pass that function to queueWait() instead. So, it would look like:\n\n```\n<script>\n$LAB.queueScript(\"/misc/jquery.js\");\n</script>\n<script>\n$LAB.queueWait(function() {x={};jQuery.extend(x, [test:1});});\n</script>\n```\n\nIn your example, there's no need for the empty `queueWait()` at the end of line 4 (though it doesn't really hurt anything being there or not).\n\nThe thing to remember is, $LAB chains work with `.script()` and `.wait()` calls... `.script()` calls specify URLs to load, whereas `.wait()` calls specify either/both where execution order needs to be preserved (as an `.wait()` call with no function passed to it), or where an inline script block needs to wait to run until that point in the chain. The queueing system is no different, except that the chain which you queue up isn't started/processed until you run `runQueue()`. But `queueScript()` corresponds to `script()` and `queueWait()` corresponds to `wait()`.\n\n---\n\nAs for your issue with scripts not running quickly enough... if you don't want queueing, which implies delaying the start of the processing of the queue until you call `runQueue()`, then simply use a regular `$LAB.script(..).wait(..)` type call, which will start loading right away. Your choice. But the purpose of the queue is so you can specify a chain ahead of time, but choose when you want to run that chain yourself. So you have that option if you use queuing.\n. closing for now, this doesn't appear to be a bug but incorrect usage. hopefully it's cleared up now.\n. The problem is it is not possible to load a script but not execute it, at least not in all browsers, and not without hacks. LABjs as of v2.0 is de-emphasizing hacks, and moving towards what is standardized and possible through intended and direct interfaces and functionality.\n\nEventually, we should be getting \"real preloading\" from the browsers, which means that we will in fact be able to preload the scripts but still choose when to execute them. But for now, this is only possible in IE, and so the LABjs API does not expose such functionality.\n\nAt that point, we can revisit if it makes sense to pre-emptively preload scripts while in queueing. However, even then, I'll be skeptical if that's the right approach, because someone might define several queues of scripts but only load one of them, in which case all the preloading of the non-used queues would be wasted.\n. NO, LABjs definitely loads all scripts in parallel (as much as the browser will allow it). It uses different tricks in different browsers to ensure that parallel-loaded scripts execute in order. But this is _not_ the same thing as being able to defer the execution until any arbitrary point in time. In most browsers now, LABjs uses \"ordered async\" (async=false), which tells the browser to load them all in parallel, but execute them in the requested order. The key point is \"tells the browser\", meaning the browser does it as soon as it can, not under LABjs' control.\n\nI assure you that LABjs' loading is at or faster than the browser will do by default with <script> tags. That's the whole point of the library.\n. The point you are missing is, there's only two options possible in browsers (consistent without hacks):\n1. Load right now, and execute right after... for this, use $LAB.script(..).wait(..) chains\n2. Load later, on-demand, and execute right after... for this, use queuing.\n\nNotice in both options, execution has to happen right after loading has finished. There's no choice about this. It's not possible in current technology (without hacks). When it's possible with standardized tech, then I will put that type of feature into a future release of LABjs.\n\nSo, the only choice you have to make is, do I want script loading to start right away (use $LAB chains), or do I want script loading to start at some point slightly later, when I want, on-demand (use queueing).\n\nI don't understand why you want queueing to start loading right away? $LAB chains start loading right away. So use them instead.\n\nIt seems like you think there should be some way for queuing to load now, but not execute until `runQueue` is called. This is just not possible.\n. chains are resumable, which means you can manually store the result of a chain, then add onto that chain later in another script element, like:\n\n```\n<script>\nvar $L = $LAB.script(\"script1.js\");\n</script>\n<!-- ... -->\n<script>\n$L = $L.script(\"script2.js\").wait(function(){ /*...*/ });\n</script>\n<!-- ... -->\n<script>\n$L = $L.script(\"script3.js\");\n</script>\n```\n\nThat should allow you to specify your chains across multiple script blocks, but still have the loading starting right away as soon as each `script()` call is made, instead of waiting using queueing.\n. In most browsers, the browser is in control of execution, not LABjs, and so ordered execution is expected behavior (the definition of ordered-async/async=false is exactly that). Again, until we get \"real preloading\", that's the best we can do (without hacks).\n\nAs for your claim that the `.wait()` callback is happening _after_ a subsequent `.script()` call is executed, that should definitely not be the case. Can you point me to a live demo that demonstrates that behavior? Is that in FF4? FF5?\n. fixed in 2.0.1\n. in progress. check your messages.\n. jpcarlino: what you are describing is not the same as the bug here, though I can see how it would seem that way from the small amount of info available in the description.\n\nIn your case, what you need to understand is that functions passed to `.script()` are all executed immediately (they don't \"wait\" like functions passed to `.wait()` do). The reason for this is that their primary purpose is to resolve (immediately) what scripts the chain should load, so that it can load in parallel.\n\nIn most cases, you can know what scripts you want to load all at once, and so LABjs can load them in parallel. In a few rare cases, you must wait to finish loading one script before you can know what the next script should be. In those cases, you should use a nested $LAB chain, instead of trying to load them all in one chain (because in that case, parallel is simply not possible -- chicken and the egg: how can you load a script now if you don't now know what the script URL is?)\n\nIn your case, you could approach it that way. But I think there's a 3rd option which I'd suggest, but you'll have to be very careful about some details. Consider:\n\n```\n(function () {\n   function load_my_scripts() {\n      var needs_jquery_142 = typeof jQuery === \"undefined\" || jQuery().jquery < \"1.4.2\";\n      var needs_jquery_ui_172 = needs_jquery_142 || typeof jQuery.ui === \"undefined\" || $.ui.version < \"1.7.2\";\n\n      var $ = (!needs_jquery_142) ? jQuery : null; // if we need to load jQuery 1.4.2, leave alias empty for now, otherwise set alias\n      var $ui = (!needs_jquery_ui_172) ? $.ui : null; // if we need to load jQuery-UI 1.7.2, leave alias empty for now, otherwise set alias\n\n      $LAB\n         .script(function(){\n            if (needs_jquery_142) {\n               console.log(\"loading jQuery 1.4.2\");\n               return \"http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js\";\n            }\n            else {\n               console.log(\"jQuery \" + jQuery().jquery + \" already loaded\");\n               return null; // no need to load anything\n            }       \n         })\n         .wait(function(){\n            if (needs_jquery_142) {\n               console.log(\"jQuery 1.4.2 now loaded\");\n            }\n            else {\n               console.log(\"using jQuery that was already loaded\");\n            }\n         })\n         .script(function(){\n            if (needs_jquery_ui_172) {\n               console.log(\"loading jQuery UI 1.7.2, with jQuery \" + (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n               return \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js\";\n            }\n            else{\n               console.log(\"jQuery UI \" + jQuery.ui.version + \" already loaded, with jQuery \" + (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n               return null; // no need to load anything\n            }\n        })\n        .wait(function(){\n           if (needs_jquery_ui_172) {\n              console.log(\"jQuery UI 1.7.2 now loaded\");\n              $ui = jQuery.ui; // now we can capture the alias for jQuery UI\n           }\n           else {\n              console.log(\"using jQuery UI that was already loaded\");\n           }\n           if (needs_jq_142) {\n              $ = jQuery.noConflict(true); // now we can capture the $ alias by calling `noConflict()`\n              $.ui = $ui; // restore jQuery UI alias lost in `noConflict()` call\n           }\n           console.log(\"jQuery >= 1.4.2 and jQuery UI >= 1.7.2 are ready\");\n        });\n   }\n\n   var LABjs_loaded = !(!$LAB);\n\n   if (LABjs_loaded) {\n      load_my_scripts();\n   }\n   else {\n      var script = document.createElement(\"script\");\n      script.src = \"lib/LAB.js\";\n      script.onload = script.onreadystatechange = function () {\n         if ((script.readyState && script.readyState != \"complete\" && script.readyState != \"loaded\") || LABjs_loaded) return;\n         script.onload = script.onreadystatechange = null;\n         LABjs_loaded = true;\n         load_my_scripts();\n      };\n      document.body.appendChild(script);\n   }\n})();\n```\n\nTry that out and see if that does what you want/expect.\n. The function you have listed here, which is passed to `.script()`, runs right away (before jquery 1.4.2 has loaded, IF it's even going to load -- won't load at all if >= 1.4.2 is already there).\n\nSo, inside that function, I'm asking some questions at the time of starting our loading requests:\n1. do we need to load jquery 1.4.2 (or are we using the existing copy of jquery that is >= 1.4.2)?\n2. are we also loading jquery-ui 1.7.2 (or are we using the existing copy of jquery-ui that is >= 1.7.2)?\n\nIf we need to load jquery 1.4.2, then we do. If we need to load jquery-ui 1.7.2 then we do. If not, to either of those, we simply skip over the `.script()` call for that particular resource, which lets LABjs just move on immediately. So, if jquery 1.4.2 is present, but jquery-ui 1.7.2 is not, then the first `.script()` call is basically a no-op (doesn't load anything), except that it prints to the console what's happening. If both are present, then both `.script()` calls are no-op's. If neither are present, then both `.script()` calls request their respective resources.\n\nThe `console.log()` statement that you reference means \"I am now loading jquery-ui 1.7.2, and i'm loading it on top of jquery x.x.x\", where \"x.x.x\" is either \"1.4.2\", since we requested to load that version, or it's whatever version of the jquery that's already present, which we know will be >= 1.4.2.\n\nAs for your question: how do I know if jquery-ui will run after jquery, and thus load on top of it? because that's how LABjs works... if you have a `$LAB.script(\"a\").wait(...).script(\"b\")` chain, then LABjs always ensures that \"a\" runs before \"b\". In your case, we're also combining in conditional logic, which says that \"a\" doesn't need to run if the \"a\" is already present on the page. \n\nBut either way, we're sure that \"a\" is present (in this case, jquery >= 1.4.2) before \"b\" (jquery-ui 1.7.2) runs. Furthermore, we're sure that if both \"a\" and \"b\" are already present in the page, and no loading is necessary, then the chain's final `.wait()` call will run after \"a\" and \"b\" are both satisified (either loaded and executed, or detected to already be present).\n. One final note... I make the assumption in my code snippet above that the case of \"jquery already present, but < 1.4.2\" and \"jquery-ui already present, but >= 1.7.2\" is either not possible, or if it happens, then it's still best to load both to be safe. In other words, there's not logic in there to load only jquery but not jquery-ui... if you have to load jquery, then you will have to load jquery-ui.\n\nThat logic is essentially enforced here:\n\n```\nvar needs_jquery_142 = ...\nvar needs_jquery_ui_172 = needs_jquery_142 || ...\n```\n\nSo, we determine that we need jquery-ui to load IF:\n- jquery is being loaded; OR\n- jquery-ui is missing; OR\n- jquery-ui is present, but a lower version\n. fixed in v2.0.2\n. looking into it. baffling really. Packer (without base62) is what I used (via compressorrater) since it was the smallest. But shouldn't have done anything remotely dangerous in terms of minification.\n. haven't been able to confirm this bug or not. closing for now. please re-open if you can provide a reproduce-test.\n. I think you're right, the splice call is needlessly verbose as written. it should just be `script_list.splice(splice_args)`.\n\nI'm not sure I understand your second question. `$LAB.script(\"test1.php\", [\"test2.php\", \"test3.php\"])` should in fact load all 3 scripts. Are you seeing it not do so?\n. I'm sorry, I still don't understand your question. In your example, is it loading all 3 scripts or not?\n. OK, I see and can reproduce the problem... very strange. But thank you for the bug report. I'll get on fixing it.\n. OK, I figured out what the bug was, and have fixed it (will come out in 2.0.2 when I get that release out, asap). Those few lines now read (including comments to explain what the heck I was doing!):\n\n```\nif (is_array(script_obj)) {\n   // set up an array of arguments to pass to splice()\n   splice_args = [].slice.call(script_obj); // first include the actual array elements we want to splice in\n   splice_args.unshift(j,1); // next, put the `index` and `howMany` parameters onto the beginning of the splice-arguments array\n   script_list.splice.apply(script_list,splice_args); // use the splice-arguments array as arguments for splice()\n   j--; // adjust `j` to account for the loop's subsequent `j++`, so that the next loop iteration uses the same `j` index value\n   continue;\n}\n```\n\nThanks again for helping find this bug!\n. fixed in v2.0.2\n. v2.0 includes two API functions for managing multiple LABjs instances. Unfortunately, neither of those were present in LAB 1.x, so if you happen to load 1.x onto a page over the top of a 2.x+ instance, it will pave over it mercilessly without recourse. :(\n\nBut, if you load 2.x+ on top of an existing LAB instance, you can call `noConflict()` on the most recent one, which will roll back LABjs to the previous one (the one it was when it loaded) and return you the new instance in case you want it. This works basically quite the same as jQuery's `noConflict()`, so I felt that was such a good pattern I just mirrored it.\n\nYou can also use the `sandbox()` API function on an existing copy of LABjs, which creates a new instance of LABjs that is not tied to the global `window.$LAB`. Whereas `noConflict()` is a reactive method that you call once a new LABjs has been loaded onto a page, `sandbox()` is a proactive method that you call defensively, when you first load LABjs. Basically what it does is give you a separate copy of LABjs from the global copy, which means all your internal state will be kept safe in that copy, as long as you keep a reference to that copy around.\n\nEither or both of those methods may be something that can help with your situation. BUT, I think it's possible there's a simpler approach that doesn't need either one.\n\nIf you simply capture a reference to the global `window.$LAB` before using it, and then everywhere that you use LABjs, always use that captured reference instead of relying on the global, then you will be sure to always keep your own copy of LABjs. When/if a second copy of LABjs is loaded and overwrites the global one, you still have reference to the copy, which means your copy will continue to function as you expect. The key is to make sure that you always reference $LAB using your reference, instead of the global reference.\n\nThat might look like this:\n\n```\n<script src=\"LAB.js\"></script>\n<script>\n(function($L){\n    // all my code inside here now uses $L instead of $LAB or window.$LAB\n    // so I'm safe if someone overwrites the main window.$LAB instance\n})($LAB);\n```\n\nLemme know if any of that helps address your issues.\n. The \"don't load LABjs twice\" part is actually contrary to the use-case that caused me to add `noConflict()` and `sandbox()`. I had many people with use-cases around needing to maintain separate copies of LABjs. So, I'm not quite sure how I could cleanly serve both the use-cases: \"do allow LABjs to gracefully load multiple times' and \"don't allow LABjs to load multiple times\".\n\nIn my original interpretation of your question, it seemed like you were in a non-trusting, non-cooperative scenario. By that, I mean, it seemed like you were in a case where some page or code you don't control might come along and load a LABjs instance over the top of yours without your consent. In response to that, the above 3 solutions I talked about are ways for you to protect yourself from such a case. And in that vein, you would actually want for that other code to not use the same copy of LABjs as you were using, because you'd want for the two to not be able to interfere with each other.\n\nConsider for example the case where your self-contained widget might get loaded into a \"hostile\" (that is, not one you know or control) page. That page may or may not use LABjs itself. But your widget should be able to use its own private copy of LABjs, regardless of what the page does or does not do with respect to LABjs. That's why `noConflict()` and `sandbox()` are useful, to allow silo'd copies of LABjs to work independently of each other.\n\nOn the flip side, if you're loading into an environment where there is explicit trust and control, and you can have the environments cooperate, then you don't need those defensive tactics at all. In that case, you want them to \"cooperate\" on their shared copy of LABjs, so as to take advantage of `AllowDuplicates`, etc.\n\nTo rephrase the cooperation issue... you need to have all pieces of your code that need LABjs to do a \"conditional load\" of LABjs... that is, each piece of code that uses LABjs needs to check and see if LAB is already loaded, and only load it if it's needed. That way, whichever piece of code runs first on a page, LABjs will be loaded, and all other pieces that run later will simply skip over loading LABjs.\n\nThis type of cooperative conditional loading is generally quite easy. And it DOES NOT require `document.write()`. :)\n\nTo conditionally load LABjs, all you have to do is this:\n\n```\nfunction LABjs_is_ready() {\n   // put your code to use LABjs here\n}\n\nif (!$LAB) {\n   var scriptElem = document.createElement(\"script\"), scriptdone = false;\n   scriptElem.onload = scriptElem.onreadystatechange = function () {\n      if ((scriptElem.readyState && scriptElem.readyState !== \"complete\" && scriptElem.readyState !== \"loaded\") || scriptdone) return false;\n      scriptElem.onload = scriptElem.onreadystatechange = null;\n      scriptdone = true;\n      LABjs_is_ready();\n   };\n   scriptElem.src = \"/path/to/LAB.js\";\n   document.head.insertBefore(scriptElem, document.head.firstChild);\n}\nelse LABjs_is_ready();\n```\n\nAll you need to do is make sure that any page or code which loads LABjs does so conditionally, like this, and your cooperation should be fine to make sure that `AllowDuplicates` functionality works for different consumers of the $LAB api.\n. > Isn't the answer to this straightforward? To get a new instance of lab, \n> you call $LAB.sandbox(). Manually loading LAB.js twice on one page would \n> not overwrite the $LAB global.\n\nBut there's a strong precedent in javascript libraries (jQuery, for instance) to overwrite when loaded again, and to allow rolling back with `noConflict()`. I have to believe there's a reason that most every other script out there doesn't do what you're suggesting.\n\nSpeaking of `noConflict()`, seems like it could solve quite trivially your issue, now that I think about it. Consider:\n\n```\n<script src=\"LAB.js\"></script>\n<script>\n(function(){\n   var $L = $LAB.noConflict();\n   if (!window.$LAB) window.$LAB = $L; // $LAB was rolled back too far, so restore it!\n})();\n</script>\n```\n\nIn that way, you ask to load LABjs every time, and you always roll it back with `noConflict()`, and only if you've rolled it back too far (that is, there's no $LAB anymore), then you re-assign the global. Now, in all your code, always use the global $LAB, and you should be fine. This makes sure there's only ever one instance of $LAB running on a page.\n. What you are asking for makes sense, and is a common request, however it's not possible (short of hacks) in today's browsers, because we don't have a way to load a script but tell it not to execute until we ask it to. That would be required in your pattern, to get \"bar.js\" to load, but not execute, and then we get to choose when bar.js executes. This is not possible without preloading, and preloading (currently) requires hacks (which LABjs now disavows). Preloading will eventually come to browsers, and when it does, this will be easy.\n\nThere are three options for you:\n1. use a loader that uses hacks (Steal being one such example)\n2. wrap all your files in function declarations, that way the file itself can execute in any order, but you get to choose when the payload is executed, by calling and executing the wrapper function at the appropriate time. This is basically like the AMD module format that RequireJS and others use. But you can come up with your format and call your own functions, instead of having to use AMD and RequireJS.\n3. You can load files serially (loss of performance) if there's dependencies... it gets a little messy, but basically you put into each file a \"trigger\" that tells the framework to load the next file when the file in question is done with all its dependencies. \n\nFor instance:\n\n```\nvar q = [\"foo.js\", \"bar.js\", \"baz.js\", ...], q_idx = 0, pause;\nfunction next_in_queue() {\n   pause = false;\n   if (q_idx < q.length) $LAB.script(q[q_idx++]).wait(function(){\n      if (!pause) next_in_queue();\n   });\n}\nnext_in_queue();\n```\n\nAnd then, in each file, like foo.js, you either do (if the file has dependencies) this to pause the global queue while you load some dependencies:\n\n```\npause = true;\n$LAB.script(\"foo_dependency.js\").wait(next_in_queue);\n```\n\nOr you leave the file with nothing extra added (meaning no dependencies, and thus no need to pause), in which case the global queue will automatically continue immediately after the script in question finishes running.\n\nDon't get me wrong, option 3 is messy and sub-optimal. BUT, it's not as bad as the hacks that people are currently using to simulate \"preloading\" (which is what we really need).\n. Just thought of a different approach to option 3, which will allow you have any level deep of dependencies. \n\n```\n(function(){\n   var q = [], q_idx = 0;\n   window.next_in_queue = function() {\n      if (q_idx < q.length) $LAB.script(q[q_idx++]).wait(next_in_queue);\n   };\n   window.load_scripts = function(scripts) {\n      var splice_args = [].slice.call(scripts); // copy the passed in array of scripts\n      splice_args.unshift(q_idx,0); // put the first two arguments to `splice()` onto the front of the array\n      [].splice.apply(q, splice_args); // send the arguments to `splice()`\n   };\n})();\n\nload_scripts([\"foo.js\",\"bar.js\",\"baz.js\"]);\nnext_in_queue();\n```\n\nAnd then, inside a file with dependencies, you just call the helper method, like in foo.js:\n\n```\nload_scripts([\"foo_dependency_1.js\", \"foo_dependency_2.js\", ...]);\n```\n\nThat's it for additions to the file (no need for the global variable `pause` as I showed in the previous comment). You will basically have inserted these files you just specified into the global queue at the appropriate index location, and then when this current script finishes, and `next_in_queue()` is called, it will start loading those files, again in order, and again allowing them to subsequently inject their own new scripts into the queue as needed.\n\nNow, again, you'll be losing all benefits to parallel loading with this approach, because everything will load serially. But, it sounded like nested dependency annotation (and the code maintenance benefits thereof) is more important to you than performance. So, if that's true, I recommend this option 3 approach.\n. For posterity sake, a more flexible version of the above... serial loading with nested depdendencies:\n\nhttps://gist.github.com/1174213\n. Can you try upgrading to LABjs 2.0.1?\n. please update to the newly released 2.0.2 and re-open this bug if your issue still persists\n. I like the idea of this patch, but I'm gonna have to think about this one a little more carefully. At first glance, what seems strange to me is that I'd put into the API a feature (setting `.text`) which works in some cases, and not in others. Specifically, if you are in an older webkit browser, and loading a local script, the method used (by default), is XHR, with script injection by setting the `.text` property on a script element. In that case, what should we then do if you've also set the `.text` property via the options? It'd be a possible race condition to set it first to the actual loaded code via XHR, and then afterwards set it to the option value passed in.\n\nNot sure about this one. Thoughts?\n. > It\u2019s probably not worth dirtying up your API just for the sake of this one use case.\n\nI am leaning toward agreeing that this is a feature that is harder to get \"right\" than its usefulness. Not out of the question to consider for the future, but more needs to be done to consider the situation I suggested above.\n\n> In other words, the plusone API does it\u2019s own deferred loading and sequencing. That being the case, I guess there\u2019s not much reason to load plusone.js using LABjs.\n\nSince it's just one script, and it does its own loading, it's possibly/probably a case where this might be most appropriate:\n\n```\n<script defer src=\"plusone.js\"></script>\n```\n\nBy using `defer`, you'll ensure that it's a low-priority script that doesn't start loading until DOM parsing is done (meaning other normal scripts, and even dynamic script loading, can proceed first). The other option is `async` which is very similar, but which has no \"delay\" to it (it's strictly ASAP). That'll possibly get it to start loading just a hair faster, but could clog up the bandwidth if you have other more important stuff you want loading in those first few critical moments.\n\n> Out of curiousity, I looked into how the parameters in the body of the script tag were accessed. I was thinking, that there would be some sort of official way for the external script to find its script tag. Apparentlyt, that\u2019s not the case. \n\nyeah there really is no way to get your current script element. it's pretty bad. Firefox has this:\n\nhttps://developer.mozilla.org/en/DOM/document.currentScript\n\nBut it's non-standard and I think they're the only ones AFAIK. It should be standardized, because it's actually an incredibly common use-case, and the workaround is quite ugly and inefficient.\n. > Another option would be for LABjs to disable loading via XHR if there is a .text specified for the script. (I.e. if there is a .text, treat local scripts as non-local.)\n\nFirstly, I think this violates the principle of least-surprise. People who are expecting XHR loading won't understand this bizarre round-about reason why XHR is disabled if they set the `text` property. Even with good documentation, that smells like a WTF. Now, granted, it's a very small niche audience that's ever gonna do this, but still.\n\nMore importantly, however, there's a reason why this type of functionality is simply not compatible with XHR loading+script injection. The functionality you describe relies on being able to scan the document to find a script element that has a `src` property that matches the expected URL. With XHR+script inject, a script element is indeed created, but its `src` property is not set (because we already have the code loaded, don't want to load it again). So, in the case of XHR+script injection, even if you did figure out a way to set the `text` property simultaneously, the code would never find that script element.\n\nYou can't really reliably create a script element, set its `src` attribute/property, but not have the browser start fetching it. So, I see no way to make a script that needs `text` setting functionality as you descibe compatible with XHR.\n\nSo we've thoroughly established that XHR and `text` setting simply cannot co-exist. \n\nBut the other problem with your idea (disabling XHR) is that it would force LABjs to use the ugliest of all the hacks: \"cache preloading\". \"Cache preloading\" is not only brittle, but it fails completely for scripts which are sent out with improper (or missing) caching headers. Recent studies have suggested that as much as 50% of scripts on the web are served in such a non-caching fashion.\n. > still need to make sure that plusone.js is loaded before calling gapi.plusone.render.\n\nSo, if I understand correctly, is this basically how you normally use g+1?\n\n```\n<script src=\"plusone.js\">config.setting=\"blah\";</script>\n<script>gapi.plusone.render();</script>\n```\n\nIf so, yeah, there's no reliable way to use `defer` or `async` on those two script blocks.\n\nDoes combining the two scripts like this work?\n\n```\n<script src=\"plusone.js\">config.setting=\"blah\"; gapi.plusone.render();</script>\n```\n\nAlso, found this:\n\nhttp://googlewebmastercentral.blogspot.com/2011/07/1-button-now-faster.html\n\nI don't see in there where they suggest how you do the \"config\" settings. But surely there's some way to do so that works with their async code.\n\nIF you can figure out how to set the config without using the inner text (which it seems there must be a way, since their async snippet doesn't set it), then you can load g+1 with LABjs, but set the config however they support it, thus not needing the `text` setting in the first place.\n. Can you provide the link/page that is causing this issue?\n. The whole test-suite passes in IE9. So not sure why it'd be breaking your page. is it breaking in any other browsers?\n. sent you a message. did you receive it?\n. excellent. i will do a little more testing this afternoon and then release that as v2.0.3. sorry for the regression.\n. fixed in 2.0.3\n. Which version of LABjs are you using? are you using 2.0.3? Or, are you setting the \"BasePath\" config to \"/photos/\", because that will indeed force LABjs to prepend the BasePath as you specify it.\n\nIf not, try this test-suite test in your browser:\n\nhttp://labjs.com/test_suite/test-LABjs-preloading.php?which=1\n\nNotice from the source that it loads a script using this relative URL: \"/test_suite/testscript2...\" The page itself is at \"/test_suite/\" directory, so the \"/\" correctly resolves the path as \"root-relative\", meaning relative to the domain and not to the page. It loads \"http://labjs.com/test_suite/testscript2...\", not \"http://labjs.com/test_suite/test_suite/testscript2...\" as your bug report would suggest.\n. I've been unable to reproduce your report, and haven't heard back from you yet. As such, I am marking this \"notabug\" for now. If you get more information, we can revisit and reopen.\n. > Has this anything to do with the \"IE 8 repair\" in version 2.0.3?\n\nNo, I don't think so. I think it's the fix applied in 2.0.1 for this bug:\n\nhttps://github.com/getify/LABjs/issues/35\n. What you're describing is in fact by design, but I can see how it's a bit confusing. There's a subtle difference between the type of chain where you call the queue methods (global) and the type of chain with setOptions() and script() and wait(), which is actually a loading-specific chain. The global queue methods are just that -- global...which means the chaining is sorta convenience only. The loading specific chains have internal state that is saved and is local only to that chain, which is critically reliant on the chaining.\n\nTo keep those two subtle-but-important functionalities separate and not confused, I specifically return a diff object for each chain type. To set options for global loading (the queues), use the setGlobalDefaults(), and for per-chain options, use setOptions(). Think of it this way...the global queue sets up what _will_ become a single local chain, but it doesn't become that type of chain until you call runQueue().\n\nSorry for that subtle confusion. I'll think about how I can clarify this topic in the docs.\n. closing for now. will revisit docs soon to clarify this.\n. Can you verify if you are using the latest 2.0.3 version of LABjs? If so, can you provide me with a live test URL that I can reproduce against?\n\nAnd do the test-suite tests work correctly in your install of Chrome?\n. hearing nothing for several days, closing for now. will reopen if further info comes to light.\n. (sorry for my delay in getting to responding to this thread)\n\n@scriby is correct in the design reasons of the queueing system as it applies to this question.\n\nFurthermore:\n1. DOMready and all-scripts-loaded are two distinct events/concepts, which prior to script loaders were unfortunately conflated to be one-in-the-same. This should not be. DOMready is for code that needs to interact with the DOM, and all-scripts-loaded is for, not surprisingly, when all scripts finish loading. Don't use one for the other's intended use. You're asking for problems if you do. If you need to wait for both, then compose both events by a variety of methods, by essentially listening for both events, and once they've both fired, then running some code.\n2. LABjs specifically does not do any DOM-ready detection, nor does it intend to. There is a hack in there right now to help jQuery do DOM-ready detection in older Firefox (<= 3.5), but that code is deprecated and being removed soon. In any case, LABjs has no capability to know when the DOM is or is not ready in a cross-browser way. That's a whole set of hacks that other frameworks (like jQuery) already tackle. If you want/need DOM-ready detection, use a lib/framework that does it (and load that framework with LABjs!). I do this on all my sites, with jQuery.\n3. Now, could LABjs do a \"all-scripts-are-done-loading\" type of event notification? Possibly. But it's uglier than you think it would be. As @scriby indicated, the free-form (and resumable chain) nature of LABjs is that you never really know that all scripts have been requested yet. So, the best LABjs could do is to fire that event every time all the current scripts are finished loading, but that means it would be more complicated for people because that event might fire many times. Rather than address that complicated use-case, I implemented queuing in part to give you explicit (I'm done requesting a set of scripts, and go ahead and load them).\n\nI just haven't seen enough evidence that this use-case is worth the ugliness/confusion such a feature would entail. Closing for now. Will revisit later if more evidence is surfaced to sway the discussion.\n. I think googlemaps uses (quite unfortunately) document.write(). Script loaders should not be used on any script with document.write() in it, because it will in fact crash/wipe out pages. The issue is that a document.write() called \"later\" (that is, after DOMready) will overwrite the page's content, and script loading specifically creates a scenario where scripts load independent (and thus possibly after) DOMready.\n. That thread concludes that googlemaps shouldn't be loaded by a script loader, because of document.write(), like I said. As said in that thread, I'd recommend loading googlemaps in a regular script-tag, and load all your other scripts with LABjs.\n. browsers do not reliably fire script.onerror for failed script loads. this is a long-standing problem that the spec needs to address, so that browsers can fix the inconsistencies. until they do, any attempt by a script loader to do this type of behavior, while admirable, is basically just a hack. :(\n\nhttp://www.w3.org/Bugs/Public/show_bug.cgi?id=14195\n\nclosing for now, will re-address when the functionality is spec'd and implemented consistently.\n. In earlier versions of LABjs (pre 2.x), the trailing .wait() was necessary to avoid a subtle race condition. The rewrite of LABjs removed that quirk, however, as of 2.0.\n\nAs it stands now, there is no reason at all to add an empty .wait() onto the end of a chain. It doesn't hurt anything, but it's kinda like a trailing comma... you might leave it there because it might make it easier to append to your chain later if you want to.\n\nIt's important to remember that a single $LAB.script().script().wait().script()... chain is completely independent. So ending it with a .wait() doesn't imply anything about affecting any other behavior in any other chain... behavior is completely localized only to that chain.\n\nWhat you suggest, about .wait() somehow affecting the execution of the surrounding code, is impossible to do in JavaScript (no code pre-emption), except with firefox's experimental `yield` statement. So, I can understand semantically why you would expect that, but it's not at all what .wait() does. It's only for controlling execution flow within the chain in question.\n. This feature has been requested before. Unfortunately, when you break it down, it doesn't make as much sense as it seems at first.\n\nAs of current generation browsers, only IE (and older webkit) will fetch external files into a &lt;script> tag if the type is an \"unrecognized script type\" such as \"text/html\". Moreover, even in IE, if you fetch a fake mime-type resource externally, you can't access its contents (especially cross-domain).\n\nAFAIK, jQuery templates require you to embed the template into an inline script element, or load it via XHR and manually inject it.\n\nSince LABjs isn't really concerned much with the creation of inline script elements, once you examine it from that angle, this feature becomes a lot less useful for LABjs to implement.\n\nThe only other possible approach (forcing loading/injecting with XHR) is something I've considered, but since it only works same domain (or cross-domain if CORS is in place), it's a tenuous feature to add because it will tend, in the general case, to lead to failure behavior for people unless they know what they're doing. So I haven't added such a feature yet. But it's open for discussion still, if it can be demonstrated that the benefits outweigh those negatives.\n. Can you give an example page where you're trying to use the two libs together, so I can see how it's failing specifically?\n. Again, happy to diagnose, but I need more context. I need to see an example/test site with the problem, and which browser(s) this is happening for you in.\n. just do the cache-busting yourself on the file(s) you only want it applied to:\n\n```\ncommonLoad\n.script('relies-on-commonLoad.js?_='+Math.random())\n.wait(function(){\n//some code\n});\n```\n. But I will say, I think cache-busting the \"relies-on-commonLoad.js\" file so that you don't get the race condition is probably the worst possible way to approach this problem.\n\nYou should not be conflating \"DOM-ready\" with \"scripts-are-loaded\". They are two entirely separate events. Mixing them up like this is bound to lead to race conditions like you're seeing.\n\nI think you should take a step back and analyze your functionality from each different event's perspective, and figure out how to handle each functionality separately.\n. Are you using the latest version of LABjs (2.0.3)? If not, upgrade and try again without the cache busting.\n. Unless I can see an example page myself, to test things out, I can't really diagnose any further. \n\nI can say that LABjs is well tested in its ability to ensure execution order of files in your chain. If you have two script() calls, separated by a .wait() call, they will always execute in that order, regardless of the state of the cache. If you're having to cache-bust to get the right order, something much more serious is wrong. I would strongly suggest you not just settle for that non-solution hack.\n. Ah, good. Glad it's resolved. :)\n. I received the email. I apologize for not getting back to you yet. I was essentially going to suggest you post it here anyway. :)\n\n---\n\nI just tried your test page in FF7 (windows), and with a bunch of refreshes (empty and full cache), and it always outputs this to the console:\n\nstart script load (ordered async): http://rewind.sgconsulting.it/test-lab/../js/mustache-min.js\nstart script load (ordered async): http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js\nstart script load (ordered async): http://rewind.sgconsulting.it/test-lab/../js/jquery.lightbox-0.5.min.js\nstart script load (ordered async): http://rewind.sgconsulting.it/test-lab/../js/s3slider.js\nscript execution finished: http://rewind.sgconsulting.it/test-lab/../js/mustache-min.js\nscript execution finished: http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js\nscript execution finished: http://rewind.sgconsulting.it/test-lab/../js/jquery.lightbox-0.5.min.js\nscript execution finished: http://rewind.sgconsulting.it/test-lab/../js/s3slider.js\n\nThat is exactly the output I would expect given the $LAB chain you're running, and it shows that jQuery executes at the proper sequence.\n\nSeeing your image, I'm really confused, because I can't see how it's possible for that to happen. It would seem that it's perhaps some bug in Firefox on that particular platform, because since FF4, \"ordered async\" has been there to ensure the order of scripts is the same as that requested. In the case of \"ordered async\", LABjs essentially doesn't do anything special at all, except request the scripts, and rely on the browser to do all the work. So, the browser appears to be doing something wrong here.\n\nWhich platform are you running on? It looks like linux?\n\nFirst thing we need to do is eliminate LABjs as the issue. I've created this little snippet of code for you to run (instead of LABjs) to see how it behaves. Can you try it?\n\nhttps://gist.github.com/1287385\n\nThat code snippet basically represents all that LABjs is doing internally in your particular scenario. By spec, it should always ensure the execution order. If we can observe it failing to do so, then it's clearly a bug in Firefox.\n. Bummer.\n\nThat clearly illustrates that either the browser or jquery has a bug. Can you make it happen with fewer scripts by any chance? Like just jquery and one other plugin? The further we can reduce the footprint, the better (less for someone to complain about).\n\nOnce you have it as minimal as you can to reproduce, I'd file this bug both with jquery and with firefox. If you don't mind, will you post the links to those two bugs back here after you file them?\n. Closing for now. Will revisit if the above linked bug reports ever lead to anything actionable for LABjs.\n. I'm confused about this bug report. Can you post a link to a page showing the issue, and explain reproduce steps and what to look for?\n. > \"Only force the client to release it's cache when there has been an update to the scripts.\"\n\nBut see, that's not actually doing what you claim here. You're not forcing that older element to be \"released\" from cache. You're simply telling your UI to request an entirely new file, which means that theoretically both files are now in cache. That's not cache-busting, in the proper sense of the term.\n\nIn fact, even the actual \"CacheBust\" feature in LABjs is probably a little misnamed, in that it doesn't really prevent (bust) caching. What it does though, in contrast to your requested feature, is to ensure that we **NEVER** use a cached version of the file (because every request is a new uncached version). So in that sense, I'm ok with calling it \"cache busting\", because it's actually \"cache ignoring\".\n\nBut in your sense, I don't think it's correct to call that \"cache busting\". If anything, it's \"cache versioning\" or \"cache conditioning\" or \"cache layering\" or something like that.\n\nAnyway, this is probably just going to deteriorate into some bikeshedding about what to call it., which frankly doesn't matter _that_ much.\n\nThe real question is whether the concerns I raised about encouraging \"bad practice\" are overcome by the usefulness (as was the case with BasePath, CacheBust, and relative-protocols)? I don't see that argument being made... yet.\n. After further thought, I can see how it's ok to call both the random number and the key as \"cache busting\". That's not how I originally thought about it, but it seems to be the more conventional (if not entirely accurate) way to describe what's going on. So, let's set aside the bikeshed of what to call it, and get back to the issue at hand. \n\nSome questions I'd like you to ponder and provide any insight you might have:\n1. There's clear precedent for \"best practice\" being that versioning should be in the file name (like CDN's require), not in the query string. This feature, as requested/implemented, breaks that best practice, and encourages a less robust pattern. Should such a \"less-good practice\" be built into the core of LABjs?\n2. Won't this eventually lead to people wanting LABjs to have an option put the `CacheBustKey` into the filename instead of into the query string, so that _they_ can follow best-practice? Won't that request be simultaneously logical/reasonable, but also much more complicated (do we use . or - separators, etc)?\n3. What if you don't want **all** your files to have the `CacheBustKey` (maybe most of them need it, but a few files you load from third-parties, and you certainly don't want them to have it). How would the API cleanly handle only applying it to some?\n4. If we start allowing some semantic behavior for rewriting/rearranging the file names of `script()` requests, won't that be a slippery slope where we end up with more intrusive behavior like people wanting to leave off the \".js\" and have it added automatically, or people wanting the automatic path calculation by specifying package names, etc. Where do we draw the line?\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. > we want to be able to use window.onerror to catch as much as possible in production.\n\nI think it's a poor development form to rely on errors bubbling up to window.onerror in production just so you can find them. You would be better off just wrapping every JS file in a big try/catch, if the \"sledge hammer, meet tiny nail\" approach is what you're going after.\n\nWhy not focus on proper code techniques for robust error handling, rather than haphazardly letting errors bubble up?\n\nMoreover, the problem is I can't just let an error happen, or it will break LAB's internal functionality (possibly putting it in an indeterminate state) and stop the rest of the chain from executing. LABjs has to swallow the errors to prevent them from interferring with itself. The problem with not doing so is that people will tend to blame LABjs (since the dev tools will often \"lie\" and say that the error occurred in LABjs code).\n\nBy contrast, swallowing the errors and then letting a debug mode let you see those errors if you want to is far more graceful, especially when production environments are considered. I have found that most people would rather have graceful \"most of the code\" load and run, rather than \"fail hard and early\".\n. > The error is thrown from within a setTimeout, so it won't affect the current execution.\n\nActually, this breaks error handling in a far worse way than what LABjs currently does. Not all browsers are smart enough to allow re-throwing an error and have it preserve the original context, so in many cases, your dev tools end up identifying the `throw` line as the offending error line, not the original line that was `catch`d. Moreover, if you wrap the error handling in a `setTimeout`, now you further exacerbate debugging problems because you eliminate the call-stack from what the dev-tools can report.\n\nOverall, I think it's a very bad idea to try and re-throw an error, and even worse to do so in a delayed fashion as you suggest.\n\nI'd be better off literally calling `window.onerror` manually and passing in the error object myself, because at least the call-stack would be preserved (although muddied).\n. Suggestion: before loading LAB.js, install a \"proxy\" on top of `console.error`. That way, when LABjs calls `console.error`, you'll be notified (much like if the JS engine calls `window.onerror`).\n\n```\nif (!console) console = {};\nif (!console.error) console.error = function(){};\n(function(){\n  var old_error = console.error;\n  console.error = function() {\n     old_error.apply(this,arguments);\n     alert(\"yay, I caught an error!\");\n  };\n})();\n```\n. I think it's a fair point that perhaps this issue needs more specific and direct attention in the documentation. It's inferred loosely by the \"Debug\" mode but not particularly called out. I will put it on my TODO list to make sure the documentation is more complete on the topic of error handling.\n\nI'm not sure I would call \"let the error bubble to the top so we make sure that end users get annoyed by it\" is the proper default pattern for handling errors. I also don't think the proper default is \"as soon as 1 error occurs, abandon all hope and do a full stop\". These are things that I think represent a greater surprise to most developers (especially the less adept technical audience) than is \"hey, if you wanna see what is going on under the covers, use 'Debug' mode\".\n\nI want the default behavior of LABjs to be that it does as much as it can, not that it gives up (because JS gives up) at first error.\n\n---\n\nThe technical consequences of LABjs bailing on its part early are, I think, MUCH harder to find and debug, and much more likely to be blamed on LABjs. The problem is that we can't \"fully abort\" when an error happens, we can only partially abort at best. This leads to crazy to diagnose errors almost instantaneously.\n\nFor instance, imagine you have 5 scripts you're loading, and for each one, you have a `.wait(..)` callback to run after that script runs. Now, let's say that a script error occurs in the first of those callbacks. What will the behavior be if LABjs doesn't try to robustly handle that case? All 5 scripts themselves will run, in order, because that part is handled by the browser, but the 4 subsequent callbacks will NOT fire, because LABjs was aborted (by the JS engine) with the first error.\n\nWhat will happen? Probably LOTS of errors will bubble up, from all of your scripts. And most of them will be WTF red herrings that lead you down the wrong path, because it won't be at all obvious that LABjs only ran 1 of the 5 callbacks, even though all 5 scripts themselves ran.\n\nWhat's the more sane behavior by default? To keep running what callbacks we can, so that the only errors which occur are those DIRECTLY related to the actual problem, and not artifacts of weird internal implementation details of LABjs and how browsers behave.\n\nFewer errors, even if you have to go looking for them in debug output, are easier to solve than more errors. That's why the default behavior is as it stands.\n. I would also say that _this_ feature request tracking (a per-chain callback) is not really fundamentally different than what I suggested earlier about overriding `console.log`. In both cases, you the developer have to, by virtue of good engineering practice, know what you're looking for and install the right listeners for it. In neither case will you just happen to find errors that you didn't know about.\n\nThis feature request makes it slightly more direct and graceful to detect them, and perhaps provide you an opportunity to \"recover\", but you would still have had to read the documentation thoroughly to even understand the implications of why such a thing would be necessary. There just is no clean way to make the default behavior be noisy.\n. It's a fair point that if you are using the debug-build of LABjs, perhaps the default then should be to have debug mode on. I'm willing to agree to the sense in that argument.\n\nI'm not sure if that would have helped in your case? I provide a debug version of LABjs, with this debug mode functionality in it, because I hope that most people will use it by default, in their dev environment. By contrast, I hope that people DON'T use that build in production, at least not by regular practice, because they're not only using a larger version of the code unnecessarily, but I also think it's bad practice to \"leak\" implementation data to the console in production environments.\n\nIn this scenario, I would have suggested, were I consulted, to first switch to using debug mode, and see what LABjs says. If you see errors, fix them. If not, you've eliminated anything that LABjs is doing from the equation.\n\nBut we're back to a fundamental assumption from earlier in this thread: you have to have good practice, and know about the tools you're using, before you'll see what you hoped you would see.\n. @jasonhinkle \n\nThe big discussion in this thread is not whether or not it's \"possible\" to fire an error callback... it was about whether it's proper to do so. My feeling is a library like LABjs should not expose a functionality as part of the API if it cannot expose that functionality in a reliable way across browsers.\n\nNot all browsers have the same behavior for \"error\" conditions, which means in some browsers an error handler would fire, and in other cases the error handle would sit silent (even though the error did occur). Moreover, some browsers would abort a chain at the point of an error, whereas other browsers the \"abort\" of a chain would not be possible. So, in some of your browser testings, you'd see an error, but the chain would complete still (which could be a good or bad thing, depending on your code and how much it's inter-dependent), and in other browser testings the error would abort the chain (which again might be desired or not).\n\nBy me not being able to guarantee the behavior of these error handling features, I think it detracts from LABjs rather than adds to it. Consider that most people who use LABjs don't understand all the internal quirks, and so if they see a feature documented, and try to use it and it doesn't work as expected, they will file bugs which I'll constantly be closing as \"can't fix\".\n. @scriby \n\nThat sounds like a reasonable expectation, until you dig a little deeper into its implications.\n1. As we have mentioned earlier in the thread, in some cases this error event will fire once (because the chain aborts at first error), and in some browsers the error event may fire many, many, many times, because the chain doesn't abort and keeps going, and now you probably have lots of \"reference undefined\" issues. This inconsistency cross-browser is almost certain to be a \"hidden\" (unexpected) behavior, one which I simply cannot correct for (if I could, we wouldn't be having this discussion). LABjs will get blamed for that unexpected behavior just like you blame LABjs for the unexpected error swallowing it currently does. This is a no-win from my perspective.\n2. The very definition of what constitutes an \"error\" is not easy to make obvious. script.onerror (which most people would mentally closely associate with a chain-specific error handler) fires for network loading issues (404's, etc). However, all browsers have somewhat different behavior on which loading errors they fire for or not. So, in some browsers you'll get an error event triggered for a 404 load, and in other browsers, you'll get no error fired at all, even with the 404. This is yet another unexpected inconsistency that's VERY hard to make obvious, or more to the point, make it so that people don't blame LABjs.\n3. Moreover, the browser's built-in script.onerror does NOT fire for run-time errors (that's window.onerror), so this LABjs error handler would be (I think somewhat confusingly) combining the behavior of window.onerror and script.onerror into one handler. Documentation can say that, but again, I don't think that's naturally what everyone will assume.\n\nAnd if we _don't_ try to respond to any of the network load errors at all, and only respond to the run-time errors we catch, then a failed load of a library won't be directly detectable (which is at least a major part of what people asking for these features want to detect for), and will only be indirectly obvious if it happens to cause an \"undefined reference\" error in the chain.\n\nWhat if the \"undefined reference\" call doesn't happen in the chain at all, but not until later? Then you didn't get any indication by LABjs that a problem occured with your chain.\n\nSo, you almost certainly have to do both kinds of errors.\n\nDo we combine them into one event, or do we publish two events (loadError, runtimeError)? Even if we do, how do we make it so the above browser inconsistencies don't create more problems than we are solving?\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. Yeah, was just logging on to explain that! BasePath will be prepended if the URL is not absolute (doesn't begin with \"http://\") AND doesn't begin with a root relative indicator, like \"/\". If you begin with any other character, even path relative, like \"../\" then it WILL append.\n\nCheers!\n. Can you please post exactly the console output you get (both before, including, and after) for this error?\n. Wrap the code inside your `.wait()` callback with a try/catch, and specifically output the error output from that. From what you've pasted, I'm almost entirely sure that it's an error in that code that LABjs is catching and telling you about. The \"ReferenceError\" is something wrong in your custom code there, inside of `Section_News.init()` or whatever, not a problem inside of LABjs.\n. Glad you were able to track it down! :)\n. I appreciate the pull request. I have not ruled out the possibility of adding an error handler functionality into LABjs, I've just been unhappy with the inconsistency it will invariably introduce.\n\nThe functionality you're providing in this patch is for calling an error handler whenever an error is trapped in a `wait()` callback. This (as I said in the other threads) is half of the \"error handling\" that most people expect from a script loader. My concern with this patch is that it implies that it's an overall error handler, when in fact it's only for the `wait()`'s. So, I might be inclined to have an error handler named `waitErrCallback` or something like that, so it was clear what its limited purpose is.\n\nI also am not sure this functionality belongs in the production (non-Debug) build/mode of LABjs. Right now, errors are only reported to the error console if you're using the debug build and have debug mode turned on (a previous suggestion I plan to implement will default debug mode on for debug build usage). While the relative file sizes aren't terribly different, the extra 200-400 bytes (minified) of code for debug mode is, I think, waste in the production builds.\n\nSo I may be inclined to add in the `waitErrCallback` functionality under the debug-mode plumbing.\n\nThis fits better with my philosophy that by default, production code should not be about reporting or exposing errors, it should be gracefully and silently handling them. If you need to troubleshoot a specific production problem, I think the better approach is to switch to using the debug build in production (thereby being able to catch errors however you wish), and then switch back to the production build when debugging is done. Philosophically, my opinion is that the default should not be to ship production code with debug-mode bits in it.\n\nOf course, an individual person could decide to always ship the debug mode to their production environment. That's fine for a case-by-case basis decision, but what this repo provides to the masses, I think should default to the more conservative approach.\n\nJust some thoughts. Thanks for the patch. It's under active consideration.\n. https://github.com/getify/LABjs/commit/001781117ddefb1fea7388479d3c614e523ac880\n. Thank you for the bug report. Unfortunately, this is not a straightforward bug, because the per-script \"AllowDup\" flag was inadvertently/accidentally removed in LABjs 2.x rewrite. That explains why this detail was not noted in the release notes, nor was the documentation updated to reflect that it had been removed.\n\nAt this point, well over a year since 2.x came out, I'm left with the decision of whether or not to consider this a regression bug (did I intend to keep the feature and I failed to), or a documentation bug of failing to note that I intentionally removed it. I honestly don't even remember if I thought about the detail during the rewrite or not, so I don't know which way to think about it.\n\nThat having been said, it's a very minor feature that to this point no one has even noticed missing or \"broken\", even with significant amounts of usage of the library. I'm inclined to believe that whether it was intentional or accidental, it's a feature that proved by de facto that it should have been deprecated/removed, because it has so little real-world usage.\n\nSo, I'm marking this as a \"not a bug\" and \"won't fix\", and I will update the documentation and release notes to indicate that the feature was indeed removed.\n. That is correct, and it's by design.\n. Can you do?\n\n```\n<script src=\"LAB.js\"></script>\n<script>\nvar LAB = window[\"$\"+\"LAB\"];\nLAB.script(..)...\n</script>\n```\n. I don't understand what this bug is claiming/asking about? Can you clarify exactly what it is you expect to be happening, which is not happening (or is happening differently)?\n. Actually, main.js doesn't have to load after jquery, it needs to EXECUTE after jQuery. The way LABjs works, it tries to load as many scripts as possible in parallel, and in some cases a smaller file will finish loading before a bigger file, even if the smaller file was requested \"after\" the bigger file.\n\nSo, if you're relying on the fact that the debugger tells you that \"main.js\" finishes its network loading before \"jquery.js\", that's a false signal.\n\nIf you have code inside of \"main.js\" that is running before \"jquery.js\" runs, THAT would be a symptom of a bug/problem.\n. > $LAB.runQueue(); is supposed to load previous queue (containing jQuery and everything else) and proceed to another.\n\nActually, no, this is not how LABjs is designed to work. The \"queue\" system is a totally separate chain (managed internally, but still a `$LAB` chain) from any other chain you create. The chains are totally independent, except for one caveat, and one special case condition, both of which I'll explain in a moment.\n\nBecause they are totally independent, you cannot rely on the fact that the queue is \"done\" in that it has both loaded **and** executed all the scripts, before moving onto the second chain you define. Both chains being independent means, in general, they will run in parallel, unaware of each other.\n\n> And actually that works flawlessly in any other browser except IE.\n\nThe reason for that is that IE uses a different loading technique than other browsers do, which is that IE has what I call \"true preloading\" meaning it can load a set of scripts and execute them (in order), independent of any other set of scripts that is loading. Other browsers do not have \"true preloading\", they have a slightly inferior (but still functional) behavior roughly called \"ordered async\".\n\nThe hallmark difference is that in \"ordered async\", all scripts (across all chains) will execute strictly in the order requested, so it has the side effect that \"accidentally\" your queue finishes executing before any scripts in your second chain can execute, even though in reality all your scripts in your second chain can finish loading and be ready to execute earlier.\n\nIn IE, once all the scripts in the second chain are ready, it executes, and is not \"blocked\" waiting on any other script executions on the page, so IE (ironically) has the truest **and most performant** behavior of all the browsers, compared to how LABjs is designed. With \"true preloading\", IE allows LABjs to have truly independent chains, whereas in other browsers, separate chains are logically (API-wise) independent but physically blocked on each other. So, that's the caveat mentioned above.\n\nBottom line, as your chains are designed currently, you have an inherent race condition, which is accidentally moot in other browsers but is exposed in IE. The solution is to avoid the inherent race condition, not rely on the accidental non-race condition in non-IE browsers.\n\n---\n\nI mentioned a special-case condition above, which I'll now explain. LABjs treats separate chains entirely logically independent, unless you create a condition where you want them to be logically \"connected\". Before I explain how to do so, let me say that this is basically not a great idea to do it this way. I would consider this a poor option, but it should work. I just mean to say that the better answer is to not create dependency between separate chains. Load everything in a single chain that depends on each other. If the queue system doesn't let you do that, don't use it, and instead do your own queueing (this is quite easy to do).\n\nAnyway, here's how you can create an implicit logical connection between two chains:\n\nThe `AllowDuplicates` option (which defaults to `false`) controls whether a LABjs chain will attempt to prevent the same script from being loaded multiple times. Naturally, if you set it to `true`, it will not do any checks, and will happily let as many in as you request. If you leave it at the default of `false`, it will check each time you request a script to see if that script has already been requested, and if so, will not load it.\n\nHere's the trick. If `AllowDuplicates` is set to `false` (again, that's the default, so no need to explicitly set it), and you have two chains that reference the same script URL (must match exactly!), then both chains will be forced to wait for that script as part of their normal defined execution order.\n\nSo, if both your queue and your second chain listed \"jquery.js\", and `AllowDuplicates` was indeed set as `false`, then the both the queue and the second chain will have to \"wait\" for \"jquery.js\" to execute, which would achieve the effect you want I believe. \"jquery.js\" will not be re-requested in this case, it will just create a logical dependency between the second chain and the queue.\n\n---\n\nTo reiterate my caution from above... taking advantage of this logical dependency between chains is not what I would consider \"best practice\". Not because it's gonna break (LABjs should function properly), but because it creates harder to debug code. It's much easier to debug, maintain, and debug based on the fact that independent chains are independent. When you create a subtle \"exception\" to this general rule, you create a footgun that could be \"dangerous\" in the future.\n\nIf LABjs had some sort of explicit way to logically link chains, that'd be a different story, because then it'd be obvious from examining code that the two chains are related. But because this is an extremely implicit, indirect side-effect behavior, it's not generally what I'd consider a good practice to rely on.\n\nIt's just slightly better than relying on observed browser behavior to moot a race condition. Most software developers would tell you not to rely on accidental behavior, and I consider this logical dependency between chains to be of that caliber. It will work, but if possible, I would encourage you to design to avoid it.\n. This is browser-dependent behavior that LABjs has no control over. There's poor spec'ing around how &lt;script> elements should behave with respect to loading errors. Some browsers will fire the `onload` handler even if it 404's, or 500's, others don't, or do so only for some errors and not others.\n\nLABjs is at the mercy of the browser. If it fires the load event, the chain will continue, if not, it won't. One of the many warts I wish the spec would iron out, but all my requests for them to do so have been ignored.\n\nFTR, in this particular scenario, I do _not_ think the chain should continue executing. Part of the \"promise\" that LABjs makes is that it will ensure execution order so you don't get cascading dependency issues. If you have two scripts which are separated by a `wait()`, LABjs needs to assume that's on purpose, because the first one is necessary for the second one. If the first one fails, there's no point in running the second one, only to create more failure, errors on the page, etc. Better to fail early.\n\nIf you have two scripts which are truly independent of each other, don't load them in the same chain with a `wait()` in between. Either use 2 chains, or remove the `wait()` so between them so the two scripts can execute \"in parallel\" and not block each other.\n. Will this work?\n\n```\n//added by child page\n$LAB.queueScript('/pageSpecific.js')\n      .queueWait(function(){alert('pageSpecific.js loaded!');});\n\n$LAB.script('/jquery.js')\n      .wait(function(){ \n         $LAB.runQueue();\n      });\n```\n\nNote that LABjs treats the \"queue\" system as an entirely separate chain, so there's no implied shared/cross-functionality between these two chains in your case. The only explicit relationship is that you're choosing not to run the queue until after your chain gets to a certain point (like the end). But other than that, LABjs will treat them as entirely separate chains.\n. `runQueue()` will run whenever you call it. So if you call it at the end of the chain, it will run then. If you call it earlier, it'll run then. There's no special logic inside it to defer or wait for any special event/time.\n\nHowever, the nature of script loading is asynchronous, which means that it won't COMPLETE its running right at that moment, but some little bit later, depending on loading speed, etc. So `runQueue()` starts the queue immediately, but it gives control back to your code (to finish other actions, like completing your $LAB chain) right after starting the queue, which means the end of the queue will come some time later.\n\nIf you need to wait until the end of the queue before you do something, you need to have a `queueWait()` call at the end of the queue, which does as it says on the label, and queues up a `wait()` to happen at the end of the queue's chain.\n\nI'm not entirely certain, but it sounds like what you actually have here is a case of two parallel asynchronous tasks, that you need to let both run in parallel, and finish in either order, and you just need to wait for both to complete before doing something else. In the parlance of your example, your two tasks would be: \"completion of the queue\" and \"completion of the $LAB chain\", and you have some set of code that you want to run ONLY once both those things are done.\n\nIn THAT case, you need a \"gate\", which means two or more parallel tasks (\"segments\"), where the gate doesn't open until all segments are complete. I happen to have written a small helper lib for exactly this kind of task, called \"asyncGate.js\": http://github.com/getify/asyncGate.js\n\nBasically, you could use it sorta like this:\n\n```\nvar gate = $AG(), \n      d1 = gate.and(),  // this is one gate segment trigger\n      d2 = gate.and()  // this is another gate segment trigger\n;\n\ngate.then(function(){\n   // run code that needs to wait on both segments of the gate to finish\n});\n\n$LAB.script(\"..\").script(\"..\").wait(function(){\n   /* ... */\n   d1();  // trigger one segment of the gate\n});\n\n$LAB.queueScript(\"..\").queueScript(\"..\").queueWait(function(){\n   /* ... */\n   d2();  // trigger second segment of the gate\n});\n```\n\nCheck the documentation for the \"asyncGate.js\" project, because there's multiple different ways you can use the API. I showed here a less common usage where you get the triggers directly and call them later. Another way is to create wrapper functions where the trigger is passed to you at the appropriate time. In either case, you call the trigger for each statement, and the gate's `then(...)` handler(s) will wait for all gate segments before firing.\n. Can you run the debug build of LABjs and turn on debug mode, and share what the debug output messages in the console say? Your analysis of the problem (about \"loaded\") doesn't make sense to me given what I know about how script load events happen, because LABjs doesn't rely the state of \"loaded\" to know a script has executed.\n\n---\n\nNOTE: I don't have an IE10 instance to have been testing on, so the last time I tested LABjs was 10pp2 (which was the last on win7), and back then, it passed. If it fails now, it's probably some sort of regression in IE. Unfortunately, that might mean what I was complaining so much about IE10 not being available on win7 for testing, which is that they introduced a breaking bug that noone caught, and now it's way too late to get them to fix it.\n. Thanks for the update. Breathing a sigh of relief to know it was something simple to resolve. :)\n. Oh, and btw, that same line/logic is in LABjs 2.x as well. But in 2.x, for IE, LABjs uses a precaching/preloading technique to make sure it's fully loaded before then attempting to have it execute (by inserting it into the DOM). Sounds like it could be possible for that to still be an issue with IE10, but perhaps that particular sequence of usage is safe. Hope so. :)\n. Are you trying to load the CSS files with LABjs as well? That's not supported.\n\nOtherwise, I'm not sure how LABjs loading JS files could affect your page's stylesheets. Seems a bit bizarre.\n\nWould definitely like to see the source.\n. BTW, as a side note to your question... I don't recommend loading \"LAB.min.js\" as a separate file like you've mentioned. I do like you do and create an \"init.js\" file that has my `$LAB` chains in it, but I just inline the minified LAB source at the top of that same file. I'd recommend you do the same. Reduces 2 script requests to 1. Since LABjs is so small, pretty minimal impact to parallelism or caching.\n. I'm fairly positive this is not LABjs because it's been long battle tested in IE 6+, and also because LABjs doesn't do anything with CSS stylesheets at all. However, I have been busy with other work and have not yet had a chance to check into your issue.\n. BTW, in your LAB chain above, are \"script1.js\" and \"script2.js\" at all dependent on jquery-ui? because your chain doesn't guarantee they'll run after jquery-ui since there's no wait after jquery-ui.\n. My working theory is that the error you said you were getting reported from jquery has something to do with your code building or modifying the DOM in such a way that the CSS in question should be applied, but for some reason your code execution order is different in IE than in other browsers (usually indicates a race condition).\n\nLike I've said, LABjs doesn't modify anything about how the browser deals with CSS, so I continue to be 99% sure this is a red herring and not the actual symptom/issue.\n\nIn any case, to determine is this might actually be a LABjs bug, I'd need a much more reduced and simple test case. Your use case is quite complex for testing and isolating a bug, so that's why the few minutes here and there that I've had to look at things haven't revealed anything useful.\n\nNOTE: you've indicated symptoms that if you load things with normal script tags, things work, but if you load them dynamically with LABjs, they don't work. That USUALLY means you have an execution race condition somewhere in your logic. Try setting the `AlwaysPreserveOrder` option to `true`, or put a `wait()` after each and every `script()` call, and see if that affects anything. The `wait()` only controls execution, not parallel loading, so even with them in place, you should still get the dynamic loading benefits.\n. Good catch, @joekaiser and @toxcct. I think this is definitely the issue. There are certain scripts that people use which cannot be dynamically loaded, because the nature of how they work is that they must be present at the very beginning of markup processing, which is contrary to what dynamic script loading does.\n\nModernizr is an example of this type script. It has to run before the `<body>` tag. It looks like this shiv is the same way, because it appears that the way it works is to actually patch the underlying DOM APIs of the browser so that when unrecognized tags are found, it fakes how they should be handled.\n\nAnother example of a script that is incompatible with dynamic loading would be any script which uses `document.write()` in it. Different reason, same result: can't load them dynamically.\n. The order they appear in the `<head>` is irrelevant. What matters is that LABjs requested them in the order you specified, which means they are executed in that same order (especially if you have all of them followed by a `wait()`). If you're seeing execution order problems, it's something else (like for instance a hidden inter-dependency you're not aware of, which is a race condition that shows up locally but not over the network, etc).\n\nBTW, if you want all scripts to have a `wait()` after them: rather than doing that in your chain yourself, just set the option \"AlwaysPreserveOrder\" to true.\n\n```\n$LAB.setOptions({AlwaysPreserveOrder:true})\n.script(\"1.js\")\n.script(\"2.js\")\n// ...\n```\n. I'm not outright \"against\" this suggestion, but I'm not totally convinced it's worth changing the core LABjs to do it. I'm at least willing to explore it.\n\n`<soapbox>`\nUsually when people make suggestions for changing LABjs, there end up being ways that they could wrap behavior and get the same outcome, which prevents any \"change tax\" from being imposed on the masses. Part of the reason LABjs is \"closed\" is basically because I think stability is a really strong virtue in such projects, and I don't like the strain and tax of other projects that just seem to constantly be updating and changing, for what seems like no reason. For instance, most of what jQuery keeps changing to do, I have no need for. But I have to keep changing because I need to keep up with whatever the latest jQuery does, for bug fixes, browser supports, plugin compat, etc. I find that annoying to an great extent.\n`</soapbox>`\n\nTo your particular feature request... I wonder if we could address this interesting use case by wrapping the `console.log()` statement to \"filter\" out the messages you don't want. For instance, running something like this snippet (of course, only in dev mode where you have LABjs set to debug mode) right before using LABjs (and perhaps restoring the `console.log` to its original form after the final `wait()` in your chain executes successfully):\n\n```\n(function(){\n   var clog;\n   if (console && console.log) {\n      clog = console.log;\n      console.log = function(msg) {\n         if (msg && (msg.match(/^(?:start\\s)?script\\s(?:(?:pre)?load|execution)/) || msg.match(/^\\$LAB\\.wait/))) return;\n         clog.apply(console,arguments);\n      };\n   }\n})();\n\nconsole.log(\"start script preload ...\")\nconsole.log(\"start script load ...\")\nconsole.log(\"script preload ...\")\nconsole.log(\"script execution ...\")\nconsole.log(\"$LAB.wait ...\")\nconsole.log(\"anything else...\")\nanything else...\n```\n\nWhat do you think about an approach like that?\n. @ramaralo LABjs only suppresses errors in `.wait(..)` handlers, not in the main scripts themselves. As for `console.log()` output, Firefox treats `console.log()` as a deferrable I/O operation for performance, AIUI, so you call it at a certain place in code, but it doesn't necessarily get processed exactly at that moment.\n\nIn any case, sounds like things are working for you now the way you need. If not, update with more specifics. :)\n. Unfortunately, standard script loading mechanisms (which the browser provides and LABjs relies upon) do not provide such a functionality. I've been petitioning the spec and browsers to give us more flexible script loading mechanisms. No such luck yet.\n\nOther script loading solutions rely on the AMD module pattern to wrap all scripts in a \"module definition\" wrapper, like Require.js and such. They get around the problem you're seeing by basically preventing ALL scripts from \"auto executing\" so you get to decide when you want to execute by declaring when and where you want to import a module to another module. That sort of pattern is, I think, overkill in almost all cases, but it is very popular for how a lot of people handle this.\n\nInstead of AMD (and Require.js) I would suggest you consider re-arranging how you load your scripts so you can avoid this problem.\n\nThe best way is NOT to list \"mobile_core.js\" to be loaded inside of \"core.js\", but instead have the check for whether \"mobile_core.js\" is needed out in the same place your main $LAB chain is listed, that way a single $LAB chain can do all your loading, either including the mobile file or not, at the appropriate location in the sequence.\n\nThe other slightly less optimal way is to always load this mobile file, but have THAT FILE do the check for whether it's needed or not, and if not, that file just skips all its stuff and does nothing.\n\nUnfortunately, LABjs can't solve this problem for you, but hopefully I've given you some ways to think about the problem differently so you can perhaps avoid it yourself.\n. An example of having the check in your $LAB chain:\n\n```\nvar needs_mobile = ...; // do your check logic here\n\n$LAB.setOptions({AlwaysPreserveOrder:true}) // do this instead of putting `wait()` between each `script()`\n.script(\"core.js\")\n.script(needs_mobile ? \"core_mobile.js\" : \"\") // an empty \"\" will be ignored by LABjs\n.script(\"public.js\")\n.script(\"private.js\");\n```\n\nHope that helps!\n. There are definitely bugs in 1.x as it's not maintained anymore and thus it's not at all surprising that 1.x would be broken in IE10.\n\nWhat we really need to do is diagnose why you were seeing performance problems with 2.0.3. Can you give me examples of what you were doing and what exactly you found? I'd sure love to tackle the problem at its root.\n. What are `$LAB.ready` and `$LAB.run`... those aren't part of the shipped API. How are they implemented?\n. Also, if you're putting a `wait()` after every `script()` call, it is probably easier to instead do:\n\n``` js\n$LAB.setOptions({AlwaysPreserveOrder:true})\n.script(...)\n.script(...)\n...\n```\n. When you say your \"page load times\" were increased by over a second, do you mean that the time when `$LAB.run` is executed is 1 second later than before, or do you mean that you're testing for the timing of `DOMContentLoaded` and/or `window.onload` events and those are taking longer?\n. 2.0 was a complete rearchitecture/rewrite of LABjs from the ground-up. In 2.0, there should have been nothing but performance improvements, though, ESPECIALLY for IE. The technique used in IE is what I call \"real preloading\" in that it actually preloads all the JS code and then executes them in order. So, in theory, this should perform better in IE than it would in say Firefox, which uses another trick.\n\nI'm pretty perplexed by what you're seeing. My guess is that you're getting false readings of the site being finished loading earlier in IE than it is (because of 1 or more scripts not finishing loading), and so the \"increase\" is actually just a correction to what it should have been. But, I have no way to back that up as more than a wild guess.\n\nI'd really have to take a look at your actual page in action, and monitor it in IE, and see. But even then, it's going to be nearly impossible to correlate that to aggregated stats from gomez. It's also going to be very hard to try something and then have to wait for new stats before we know if it helped or hurt.\n\nMoreover, LABjs does absolutely nothing to hold up (or change the hold-up) of window.onload, which is what I guess gomez is using to determine \"page load\".\n\nOne other wild guess is that perhaps you're loading duplicate scripts (and LABjs has different behavior around dupes in 1.x vs 2.0).\n\nBTW, why are you loading 17 scripts? Best practice would be to be loading 2-3 scripts at most. I usually recommend people combine all code into one file, then split that file in half (or something like that) and load the parts via LABjs. I'd say if a production site is having to load more than say 5 scripts, it's probably not doing what it could or should be doing for optimization.\n. Also, try the debug build of LABjs and then turn on debug mode with option `Debug:true`. Check what's printed to your output console to see if anything looks out of place in terms of sequencing. Paste that here too, if you think it might shed light on anything.\n. closing for now. if you find anything actionable we can address in LABjs, lemme know and we can re-open. :)\n. This question has been asked many times over the years, if we can provide a way of adding arbitrary attributes to script tags. I personally consider that to be an anti-pattern, so I've resisted... but the other point is that there's not always going to be a script tag to attach things to. For instance, if local XHR is used instead of a script tag.\n\nMoreover, it's a slippery slope where people will want to add more and more stuff to script tags if possible, so we'll have to have general attribute systems (like @fletc3her is suggesting). I'm not saying those things are bad, per se, just that I don't see why that's useful to a broad enough set of the users of LABjs to be in core.\n\nLastly, you can't necessarily guarantee that you can find the script element that has the attributes you're looking for, as there could be multiple tags with the same URL, or there could be script elements with no URL (like in the case of script injection from XHR), or the script elements might be removed from the DOM after use, etc. Given all these complications (and others), and since the fidelity of finding the script element you added this data too is pretty low, I don't see the point to adding this to core.\n\nWhy not just maintain some global variable with the data in question? I understand lots of libs do this anti-pattern of relying on adding attributes to script tags and so you can't help that. But that still doesn't make it a good pattern to follow/endorse, IMO.\n\n---\n\nI guess my bottom line is that the stability of LABjs (over 2 years now since last bug fix was needed) is more important than adding small features that only some side use cases would benefit from. The thousands of sites that would have to ask if they should upgrade or not isn't really worth the small gain, IMHO.\n\nBut that's part of why this code IS stable, and IS open-source and MIT licensed, so that it can encourage lots of forks for individual needs, and the barrier to you maintaining your own fork is low, because I don't change core at every possible chance to add things. Imagine how much harder it would be for people to maintain forks for their own needs if I was having the core be patched regularly with community requests.\n\nJust a balancing act against various tradeoffs. Thanks for the input and suggestions, though. :)\n. closing as duplicate of https://github.com/getify/LABjs/pull/81\n. Another point we'd probably want to consider is to feature-test for the feature, and only set on the script tag if supported. Reason being: it the attribute is added to a script element where the feature is not itself supported, that could be misleading when trying to debug LABjs behavior.\n. >  if we add this to core, this should only be in the debug build of LABjs and not the main minified build,\n> \n> > I disagree here, we want to use this feature for error logging on our live production site, for catching errors in the browser from our real users (where we have a setup with CDN and cross origin issues). It is not for debugging (when you typically don't work with a CDN and don't have cross origin issues).\n\nI have regularly over the years recommended to users of LABjs that they take the debug build of LABjs (which is a little bit bigger, and runs a few extra bits of logic at each step) and deploy it into their production site, so they can debug issues that seem to only be reproducible in their prod environment.\n\nBut note, this sort of action is still fundamentally a debugging step, and should be considered, IMO, a temporary step while you diagnose and fix issues. It should not be a permanent installation in a prod environment. For example, debug mode by default logs all the steps LABjs takes to the console, but that sort of logging is extraneous for a production environment, and moreover, could be considered a \"leak\" of implementation you would probably be best served avoiding for prod.\n\nAll the debug features of LABjs are specifically for the purpose of debugging issues and correcting them. That means all of those features should be temporary, not permanent, in prod. As such, I have a hard time believing we've come up with a new fundamentally \"debugging\" feature for LABjs that would be constantly running (and deployed) on a permanent basis in production. That sorta violates one of my fundamental principles of good software design.\n\n**CAN** you do that? Of course. It's not something I'd ever recommend. LABjs is not really designed to be a tool in the RUM toolbox, it's not for continuous monitoring or stats/error gathering, etc. If I were to design that sort of software, I'd probably approach it quite differently than how I built LABjs. By contrast, LABjs is as simple and stripped down and bare metal as it possibly can be, because it has one task and one task only: loading scripts. Any of its capabilities to track or provide assistance in debugging are intended for debugging purposes only.\n\nThis is a similar discussion (and mindset) to me as [issue #57](https://github.com/getify/LABjs/issues/57) where there was quite a bit of back-n-forth discussion about my design philosophy of defaulting to having the `wait()` method suppress errors by default, and only expose them when you choose to move into `Debug:true` mode (and of course, using the debug build of the lib). Several people in that thread definitely disagreed with that being the default behavior, but I considered that to be the more appropriate conservative default for simple production environments, while giving the power and flexibility to someone to use a different build/mode if they need to dig into an issue.\n\nMy mindset then, and now, is that LABjs is best served by being as stripped down, and conservative, as possible in the core minified build, and debug functionality is tucked away in the debug build, easily useable if necessary to track down and fix problems. Hopefully that helps elaborate on how I might tend to approach **this** feature request, if we do add it.\n. I'm definitely of a different mindset on this than when it was originally filed. I'm now inclined to support setting any attribute on the script element that you want, as discussed in #108. That work would roll into LABjs v3, though, not an update of 2.x. \r\n\r\nI made some decent progress on the 3.0 rewrite (#113) awhile back, but there's a long check list of stuff still to do. I would love any help with that list. :)\r\n\r\nIn the meantime, I guess my best suggestion is to edit your LABjs to add the attribute. I believe that would be inserted here: https://github.com/getify/LABjs/blob/master/LAB.src.js#L132. @toxcct \nYou are correct in your observation that some types of \"script failed to load\" will in fact cause a chain to break. Other types will let it keep going (though the lack of dependency can cause JS errors).\n\nHowever, this is not controlled by LABjs at all, thus it's not something I can fix. Browsers are inconsistent on how they handle the `load` event. Some of them will fire the load event even in a 404 condition (which, if you think about it, is totally wrong), and others (most, thankfully) won't. On the flip side, these same inconsistencies exist with the `error` event. You'd think that either the `load` or the `error` event should always fire. Unfortunately, that's not the case. Sometimes neither fires, sometimes both fire (bizarrest of all!).\n\nBottom line: LABjs can't really rely on either event, so it just assumes that `load` will definitely fire in a successful loading case, and it basically punts on handling the \"didn't correctly load\" case. So, unfortunately, I can't do anything about the fact that the chain stops when one fails to load.\n\nBTW: others in the past have addressed \"fallback\" behavior like this (ie, what to do when something fails to load) by setting up a timeout and just making some assumptions about a failed load if a certain amount of time goes by. I don't recommend that, per se, but that's how some people have gotten around this.\n. LABjs doesn't use XHR except in some rare fallback cases for old browsers. So we're reliant on the events that the `<script>` element can give. That's the unreliability I was talking about before.\n\nOne primary design goal of LABjs is to only expose as functionality in the API that which can actually be reliably implemented cross browser. If you can't do it reliably, I don't think you should make a \"maybe works\" kind of function in an API, as its exposing you to more problems and devs' blame.\n. I have to admit I'm not terribly certain I understand quite what you're asking for.\n\nOn the surface, it looks like you're asking for how to build a special type of framework for dependency loading that abstracts on the \"page\" (as seen in the URL by a router) as the unit of loading dependency. If that's what you're asking for, that's quite an ambitious task, and I just want to level-set that I won't be authoring that for you here, nor should you expect any other open-source project to just do that for you, in their documentation.\n\nOTOH, that's an admirable type of project to do, so I'd encourage you to build one to your suiting, and make sure you open-source it as you do, so that the community can contribute to and benefit from it as you explore those use cases.\n\nNow, at a simpler level, if you're asking how could my script loader (LABjs) used in such a theoretical project, that IS something I can speak to.\n\nLABjs is a dynamic script loader, which means you can load one or more scripts at any time, not just at page-load time. You can, at any time, request 1 or more scripts, using `.script(..)` API calls, and they will default to loading in parallel and running ASAP. If you need for there to be an enforced execution order, you can call `.wait(..)` calls in between them, which will not affect loading but will affect execution order to preserve it.\n\nSo, whatever higher-level abstractions you build in such a page-loader framework, at the point when you need to fetch a script, it's a simple as invoking `$LAB.script(..)` and then using a `.wait(..)` with a callback to be notified when it finishes. That's LABjs's strong suit, is making that sort of on-demand loading incredibly simple.\n\nIt would be up to you implement all the other abstraction on top of LABjs, however.\n. Maybe take a look at existing frameworks, many of which have routing built-in. For instance: Backbone http://backbonetutorials.com/what-is-a-router/\n. There are no \"undocumented features\" of LABjs. What you see (in the documentation) is what you get.\n\nAs such, the first link indicates that someone who has extended LABjs with some additional behavior. I'm not aware of how they did it. He mentions doing a follow-up blog post about that topic, but I didn't find it.\n\nThe second link is a gist that I wrote myself, in an attempt to help others see how to work-around the situation. What you see, clearly, from that snippet, is that it's based on a brittle set of assumptions about timeouts. Because the actual underlying web platform's functionality doesn't give us a way to do this directly, we have to do hacks. This was the level of hack that I deemed at the time to **_not**_ be worth rolling into the main core LABjs, but instead left to devs to do themselves as they see fit.\n\nFor example, here's a fork of my gist which adds in a bit more functionality: https://gist.github.com/mondaychen/1598350\n\nThis is the sort of task that I think belongs wrapped around the lib (LABjs) rather than inside it, because coming up with a single way to do it which most or all could agree on is extremely unlikely. If the web platform ever answers my call to add something like this natively, then I will wrap that into LABjs.\n. @sergeevabc \nWhat you've shown is conceptually similar to how I use LABjs in my own projects. I call it making a \"bootsrapper\" file, and I usually call it \"load.js\", but I inline the minified production LABjs code, then I include the $LAB chain as necessary for my own project. Then I load just that one file with a normal `<script>` tag, at the bottom of the `<body>`, and it's responsible for loading up the rest of the code for the page.\n\nI have some light conditional stuff in there, so what you're showing is much more complex/capable (deciding files based upon the page you're in), but conceptually it's the same idea. I endorse that as a good pattern.\n\nIf you got yourself a more and more complex/capable mechanism for doing conditional loading based on the page URL (routing), you might make yourself a little mini-lib (similar to LABjs) that you just drop in, instead of having that sort of ad-hoc custom code there. That'd make it easier for you to re-use on other projects later, and be a great candidate for releasing as open-source as a help to others in the community as a contrib.\n\nAs for how to do \"fallback\" style loading, \n\nWhat you may want to do in the above code is the same concept, but instead of using the `queueScript()` and `queueWait()` (which are simple helpers built statically onto the `$LAB` API), you'd want to do queueing yourself.\n\nFor example:\n\n``` js\n\n// NOTE: I've slightly modified this function to pass in a $LAB chain to use.\n\nfunction loadOrFallback($L,scripts,idx) {   \n   function testAndFallback() {   \n      clearTimeout(fallback_timeout);   \n      if (successfully_loaded) return; // already loaded successfully, so just bail   \n      try {   \n         scripts[idx].test();   \n         successfully_loaded = true; // won't execute if the previous \"test\" fails   \n         scripts[idx].success();   \n      } catch(err) {   \n         if (idx < scripts.length-1) loadOrFallback($L,scripts,idx+1);   \n      }   \n   }   \n\n   if (idx == null) idx = 0;   \n   $L = $L.script(scripts[idx].src).wait(testAndFallback);   \n   var fallback_timeout = setTimeout(testAndFallback,10*1000); // only wait 10 seconds\n   return $L;\n}\n\n\n\nvar _queue = [];\n\n// page 1?\nif (document.location.href.match(/ ... /)) {\n   _queue.push([\n      {src:\"http://mycdn.com/page-1.js\", test: ..., success: ...),   \n      {src:\"http://anothercdn.com/page-1.js\", test: ..., success: ...),   \n      {src:\"page-1.js\", test: ..., success: ...)\n   ]);\n}\n// page 2?\nelse if (...) {\n   _queue.push(\"page-2-dependency-a.js\", false, \"page-2-dependency-b.js\", false);\n   _queue.push([\n      {src:\"http://mycdn.com/page-2.js\", test: ..., success: ...),   \n      {src:\"http://anothercdn.com/page-2.js\", test: ..., success: ...),   \n      {src:\"page-2.js\", test: ..., success: ...)\n   ]);\n}\n// page 3?\n...\n\n// later, process the queue\nvar i, $L;\n\nfor (i=0; i<_queue.length; i++) {\n   if (Object.prototype.toString.call(_queue[i]) === \"[object Array]\") {\n      $L = loadOrFallback($L,_queue[i]);\n   }\n   else if (typeof _queue[i] === \"boolean\") {\n      $L = $L.wait();\n   }\n   else if (typeof _queue[i] === \"string\") {\n      $L = $L.script(_queue[i]);\n   }\n   else if (typeof _queue[i] === \"function\") {\n      $L = $L.wait(_queue[i]);\n   }\n}\n```\n\nNOTE: this for-loop process is what I call \"simulated chaining\", and I wrote about it awhile back in this blog post: http://blog.getify.com/simulated-chaining-in-javascript/\n\nNow, the huge caveat: $LAB does not allow you to basically \"pause\" a chain, because that functionality doesn't exist in the underlying web platform. What I mean by this is, we can't really combine the idea of having chained dependencies, as I've shown above, with the idea of having one part of the chain that sorta forks off and re-tries or tries other fallback URLs, while holding up the rest of the chain. You can't pause the main chain and fork off this child processing for one item in the main chain.\n\nBottom line: the above code might kinda work like you want, but you may also notice mal-behavior in the fallback case, because the way the above code works is that if a script has to fallback or be retried, it's doing that in a separate $LAB chain from the main chain processing the dependencies, and as such, you may have code that depends on your file having loaded, but that code didn't wait for all the different attempts at that one file.\n\nYou can probably see now why this topic is so complicated that it's not something I was ever going to bury inside of LABjs. You end up having to make a whole bunch of judgement calls about how to handle these functionality quirks and deficiencies. It's just one of those \"hard\" things you have to figure out how it works for you, even though there may be a dozen other ways to do it that others would prefer.\n. What you are describing is exactly correct and it's also got nothing to do with how LABjs works.\n\nLABjs relies entirely on the browser's `<script>` mechanism for loading. If a browser fires a load event, LABjs assumes the script loaded and ran, and if it doesn't fire the load event, LABjs just waits. LABjs has absolutely no control over what conditions the load or error events fire, and notably (as you're seeing), browsers don't agree on these conditions.\n\nI have multiple times tried to convince the WHATWG group that the spec needs to clearly define under what conditions exactly the load and error events fire, and that those conditions have no overlap or gap (there's always one or the other, and it's predictable). I have been told repeatedly that the spec already has as much detail as they intend, and that it's up to the browsers to decide to agree or not, as they see fit.\n\nSo, unfortunately, my bad news is for you is there's nothing I can do, and all my best efforts to advocate for the actual problem to be fixed have been rejected. :(\n. That's going to completely defeat the purpose of LABjs of ensuring execution order with parallel loads.\n\nI suspect that you seeing it as \"works\" is a red herring and that it will actually be quite the opposite of you want, because you'll have worse (aka, serial loading) performance in IE < 10, or possibly even broken entirely, and also old webkit (pre-Mar2011) is likely going to be completely broken. The other (modern) browsers will still work because they use the `async=false` \"ordered async\" loading.\n. What you're referring to is what I call \"nested dependency annotation\", which amounts to not having an external listing of the script dependencies, but instead of having dependencies only listed inside each file. As you note, because the page doesn't know about \"2.js\" and \"3.js\" until after \"1.js\" finishes loading, it can't do all 3 of them in parallel, it has to load \"1.js\" first, then \"2.js\" and \"3.js\".\n\nMoreover, no script loader is able to actually stop/pause the execution of 4 and 5 if 1 asks to load 2 and 3. There is simply no way to do this cross-browser using what the web platform gives to us. LABjs (and most other script loaders) rely on creating `<script>` elements and as I said before, we're not given any control over when those scripts execute (or delaying that execution). The scripts will always execute ASAP after loading. Sucks, but that's just what we've been given.\n\nI've petitioned the WHATWG group(s) for \"true script preloading\" (which is already present in IE 4+, btw!) which WOULD let you have this control. But they've rejected that effort for over 2+ years, and so none of other browsers support it.\n\nThe only way to do it is to XHR Ajax to load your scripts, and then execute them in the order you want, meaning you can defer when you execute 4 and 5 if necessary. But then, if you want to XHR files, they either have to be same-domain, or you can only cross-domain load in browsers that support CORS, which reduces the number of (old) browsers you can support.\n\nThe only other option is to do what AMD-style loaders do, which is that you force ALL of your scripts to be wrapped in `function() { ... }` wrappers. This allows scripts to load and run in any order, but the actual logic inside each file is wrapped in a function so it doesn't auto-execute, and then you can come along later and execute those payloads in the order you want.\n\nThe downside there is obvious: every file you load this way has to be wrapped.\n\n---\n\nWhat I tell people to do (and indeed, what I do myself) is not to rely on nested-dependency-annotation with LABjs. Instead, have a build tool that reads those files, and finds all the nested dependencies, and constructs a list of scripts that's complete and has the right order (like 1,2,3,4,5), and then have that build tool load all scripts at once, like using a LABjs chain.\n. FYI: found this write-up I did awhile back that explains how I load with \"nested dependencies\" using LABjs:\n\nhttp://stackoverflow.com/questions/15973784/wrong-execution-order-using-labjs/15977311#15977311\n. A whole bunch of people over the years have asked for \"error handling\" support in LABjs. Search through the closed issues archive and you'll probably find at least half a dozen threads on this topic.\n\nMy answer has always remained consistent: the problem with supporting an \"error handling\" API in LABjs is that the underlying platform is not consistent with respect to what constitutes an error or not. The `onerror` handler fires in different conditions depending on platform and browser and version. In fact, there are some bizarre cases where neither `onload` nor `onerror` fire, and possibly even cases where both fire.\n\nThis inconsistency is unacceptable. But it's not anything that LABjs can do anything about. We're just stuck until/if the web platform standards bodies agree to my repeated requests to fully standardize this behavior.\n\nI don't want to put an API into LABjs which behaves inconsistently. If I do that, invariably, LABjs will get blamed when some such error happens in Chrome and not IE, etc. I have no desire to field \"support\" such erroneous and misdirected \"bug reports\".\n\nLABjs' philosophy always has been \"load all scripts in parallel, preserve execution order where desired\". And that's it. It doesn't provide facilities for error handling, graceful recovery, etc. People have come up with all kinds of external work-arounds for such behaviors, as hacks, but I remain unconvinced that any of that belongs in LABjs core to weigh it down and to provide more surface area for people to misunderstand and misblame LABjs.\n. I still see huge chunks of red and green code. I would suggest if you really want me to see the changes, cancel this PR and submit a new clean one.\n. OK, I can now see a sensible depiction of the changes.\n\nAll this analysis I'm going to put down here, it's not new. I've been saying this same things, in parts, over and over again, for years on these threads. I've been very consistent in my perspective. But I continue to leave the door open if someone has any reasonable counter-arguments to change the balance. I don't think it'll happen, but open-source is partly about having these debates and always being willing to accept more evidence.\n\nHere's several thoughts:\n1. Error handling is not a _primary_ use-case for LABjs. At best, it's a secondary/lesser use-case, but in reality, given the tens of thousands who use it without error handling right now, and the few dozen who forked LABjs for error handling types of approaches, you could argue it's kind of niche.\n   \n   For niche or lesser use-cases, the bar is pretty high for the comparative of value to LoC. LABjs is small on purpose, because the major argument against script loading is not loading more code just to load your code. The bigger it is, even a couple of hundred bytes, the less it even makes sense for LABjs to even be used. It is currently, at 2k post-gzip, almost as big as is tolerable.\n   \n   There's lots of features and use-cases we _could_ put into LABjs. Many have asked over the years. I have remained unconvinced that the value overcomes the bloating (even a little bit) of the core LABjs.\n   \n   The code you've submitted looks to be sensible and of good quality. But there's 99 additions and 13 deletions. That's an **_awful lot of code**_ comparatively to be added to LABjs core. I'm not nearly convinced that this feature is useful enough to warrant such a change. Just by estimate, I've not tried it yet, my guess is that this change adds at least 200-300 of post-gzip bytes to the weight of LABjs. That may not sound like a lot, but 10-15% increase is huge in the world of script loaders.\n2. Similar to a bar being high to add stuff into LABjs making it bigger, there's also a very high bar for adding stuff into LABjs to create a new release.\n   \n   I've said a number of times, and I mean it, that the most useful feature of LABjs is its stability. I take the stability very seriously. The reason for that is that to make a change to a piece of code which has been embedded tens of thousands of times on sites across the web, IMO there has to be a really compelling reason to make a new release, and then force all those sites/apps/devs to think about whether or not they should update.\n   \n   If they do update, it's extra mental tax on them to re-validate that nothing changed. If they don't update, they risk getting out of sync with LABjs. Since there's a lot of people who use forked versions of LABjs where they've each added in their own little tweaks, the more I change the core LABjs, the more difficult I make it on them to manage the merge of those changes, and with such a widespread change as you've proposed, it almost certainly will create merge conflicts for some of them.\n   \n   To risk doing that to so many devs, there has to be a strong reason why. I'm not sure that adding a lesser use-case like error handling meets that bar. In fact, I feel like it doesn't, or at least I'm not convinced yet.\n3. There's a philosophical dissonance at play, too. What exactly is the point of having error handling in production code?\n   \n   Is it so you can monitor and report errors? I think there are plenty of other monitoring solutions that are better suited. If I was designing LABjs to be primarily a monitoring or remote-logging tool, I would have designed it quite differently than I did. Bolting on error handling so you can monitor real-time error conditions feels unnatural to the core purpose of LABjs.\n   \n   Is it so you can \"recover\" from errors more gracefully? That sounds nice in theory, but in practice it usually fails to be true. The web already has a built-in \"recover from errors\" and it's called \"refresh\". The chances are low that you had a temporary outage (for a brief few milliseconds) on one of your scripts loading, but only a few milliseconds later, now you can retry that load, and it'll work.\n   \n   When you start to analyze how you'd actually use error handling in the real world, this use-case becomes less and less concrete and more and more niche. I don't think there's more than a few dozen sites on the entire web that care so deeply about error handling and recovery in production that they'd go to all the manual trouble it would be to architect their entire app around the possibility of conditional script-load retries or other such exotic techniques.\n   \n   And for the tens of thousands of others who use LABjs, all this extra code you're proposing would be unnecessary dead weight, because they wouldn't use it, except for...\n4. **_If**_ we added this feature, it feels like it's a dev-mode/debug-mode feature at most. I can't see it being in the production core build.\n   \n   In other words, I have other code which is included only in the \"debug\" version of the code, which is intended only for debugging issues in dev, and not for production. This error handling seems like it **_might**_ make it easier to troubleshoot some types of problems while in dev mode (like wrong script paths, etc).\n5. The single biggest reason I've resisted \"error handling\" for LABjs is the lack of consistency it introduces. I said that earlier in the thread without explaining, so let me expand upon that.\n   \n   First, there's the question that `onerror` fires on script elements in different conditions in different browsers. Some browsers fire it when there's a 404, but not when there's a 500. Some fire it on 500's but not on 404's. You can imagine if you start chasing down other status codes, you find lots of other inconsistencies.\n   \n   The only thing worse than an intermittent error you're trying to debug is when that error is not even consistent in different browsers. This kind of weirdness is **_very opaque to end users of LABjs**_, so it's almost certainly going to lead to people blaming LABjs for bugs rather than the underlying browser.\n   \n   Second, **_and most important of all**_, is that the web platform does not allow us to stop the script loading of the rest of the chain when an unrecoverable error happens. The way the chain API of LABjs is designed, a dev would expect that if they are loading 5 scripts, and file 1 and 2 load, but file 3 fails, then 4 and 5 would be abandoned/aborted and **_not run**_. But this is impossible to accomplish through the library. The only hope is a dev who programs every single file very defensively, but that is not common, especially when you're using files from other third-parties.\n   \n   For example, if file 3 fails, and we report that error, but file 4 and 5 also try to run, and they depend on 3, and they certainly fail, but then do so in an extravagantly bad way, like they add an event handler on browser scroll or in a timer, and that handler is going to fail every single time it's called, then your error log in your browser can quickly fill up and overload, and obscure the actual root of the problem.\n   \n   Worse, the error handling message for the script failing to load can't be predicted when it will happen (because of various timings issues internally), so it could happen at the top, bottom, or smack in the middle of a big stack of other errors, making it likely very hard to find reliably, even across page loads.\n   \n   If you try to architect a scenario where you detect file 3 failing, and you try a fallback URL for file 3, or retry the load of file 3 a few times before giving up, and you want 4 and 5 to wait, you can't delay them while you try to recover from 3 failing. Unless you've taken **_lots**_ of extra care in the design of 4 and 5, this is almost certainly going to cause cascading and totally unrecoverable errors.\n   \n   In almost all cases, hitting refresh is going to be the only reliable recovery, which moots most of the usage of this error handling anyway.\n\n---\n\nBoiling all this down, on the surface error handling is extremely sensible (in theory), but in practice it really falls apart. There's just nowhere near the value-add to overcome all the caveats, bugs, inconsistencies, and extra bloat, to justify adding it to LABjs.\n\nBut again, that's just my _current_ view. I remain open to other evidence/arguments.\n. \"It's my bad...\"\n\nI don't think so, and that's not what I meant to suggest. I was just re-counting, for posterity sake, how I feel about it. Your code is fine and well done, it's just that I already have an opinion about the overall suggestion from many other discussions on it.\n\nAgain, as I said, I remain open to new evidence or arguments which sway the conversation back.\n. If code is stopping somehow, unexplainably, it's probably due to a JS error.\n\nTry this code:\n\n``` js\nif (true;) { \n        $LAB\n        .script(\"dataObject.js\")\n        .wait(function(){\n                  // if \" window.location.href \" was here, it worked! \n            for (var i in dataObject) {\n                    var example = i.match(\"a\");\n                    if (example != null){\n                        try {\n                            alert(\"ok here!\");   // reached here\n                            window.location.href = 'http://www.example.com';\n                            alert(\"not reached here...\");  // not reached here\n                            break;\n                        } catch (err) { alert(\"Error: \" + err); }\n                    } \n            }\n        });\n}\n```\n\nBasically, wrap your `window.location.href` redirect code in a try/catch. Does the try/catch error alert anything useful?\n. What version of LABjs are you using? Can you put this test up on a URL so I can reproduce?\n. It definitely shouldn't be doing what you're seeing. I find it quite bizarre. That having been said, I haven't seen or touched Opera 9 in years. All I know is that way back then, it did work. I dunno if they've broken something about their script loading mechanisms. Will take some investigation, but I'll try to see what I can figure out. Thanks for the test link.\n. Just level-setting expectation here: it's pretty unlikely this is a bug in LABjs, given how long LABjs has been stable (over 2 years and no valid bugs), and given the fact that LABjs used to work fine in Opera 9.x. I will certainly investigate what's going on and try to reproduce and diagnose.\n\nIf it's a bug that can be fixed in LABjs, the chances of a new release of LABjs to fix it are slim (given how minority/legacy a browser Opera 9.x is). The best you could probably expect is a suggestion on how to patch your copy of LABjs.\n\nMore likely though, it could be a newly introduced bug in a port of Opera to a newer platform, in which case that's completely the fault of the browser and may very well be nothing LABjs can do about it. At that point, you'd have to contact Opera about it, but since they have long since retired support for Opera 9.x, I'm not sure how much help they'd be.\n\nNot trying to scare you off. I'll do my best to figure it out, as soon as I get some free time. It may be a bit. And I just wanted to warn you that the resolution may be less than desirable. But we'll see. :)\n. I have not been able to reproduce. Please provide more information if this problem is still persistent for you, and we can re-open.\n. LABjs stands for \"Loading and Blocking JS\". By design, the library blocks execution of script B until after script A has successfully run, _if_ you have specified via a `wait()` call in between the two `script()` calls that there _is_ such an execution order dependency.\n\nThere's an implicit assumption with the usage of LABjs that if B depends on A, and you therefore use `wait()` to tell B not to execute until A completes, then B cannot and should not run if A doesn't successfully run, no matter what. So the question becomes, in your case, does B depend on A, or not?\n\nIf B _does_ depend on A, then LABjs is doing the correct thing by not letting B run if A never runs. If B _doesn't_ depend on A, then don't put B after A in a chain with a `wait()` in between them. If they are execution-order independent, then either load them in parallel (aka, with no `wait()` in between them) or load them in two separate `$LAB` chains.\n. The \"queue\" mechanism (`queueScript()` and `queueWait()`) constructs a _single chain_ of loading and blocking. Making separate calls to the queue functions doesn't create separate internal queues.\n\nIf you need to create multiple queues, which it appears you're trying to do, you can do so manually rather than with the single queue mechanism, like this:\n\n``` js\nvar q1 = [];\nvar q2 = [];\n\n// later\nq1.push(\"A.js\",false,\"C.js\",function(){ alert(\"A and C done\"); });\n\n// later\nq2.push(\"B.js\",\"D.js\",false,\"E.js\",function(){ alert(\"B, D, and E done\"); });\n\nfunction loadQueue(q) {\n   var i, $chain = $LAB;\n   for (i=0; i<q.length; i++) {\n      if (typeof q[i] === \"string\") $chain = $chain.script(q[i]);\n      else if (!q[i]) $chain = $chain.wait();\n      else if (typeof q[i] === \"function\") $chain = $chain.wait(q[i]);\n   }\n}\n\n// load separate queues independently\nloadQueue(q1);\nloadQueue(q2);\n```\n\nBasically, that's doing exactly what the internal built-in queue mechanism does, so if you create separate chains without any interdependency, they should behave basically independently.\n. If the script loads, then that usually means LABjs did its job. I'm not familiar with why it's not working. If you can provide a URL with a complete reduced test-case showing the problem, I can take a look, but based on the code you've shown, nothing is obvious.\n. I have been asked to do this before, but it was an intentional design choice way back at the beginning, not a mistake, not to support LABjs being relative to the `<base>` tag of a page. Back then, `<base>` tags were a big problem for IE6, and moreover, back then (at least), IE didn't support `document.baseURI`. \n\nSo I elected to instead add the `BasePath` [configuration](http://labjs.com/documentation.php#setglobaldefaults) to allow relative URLs. **Note:** the `BasePath` should be absolute, and not relative (as it itself would be considered relative to the page, which will likely produce strange results).\n\n``` js\nLAB.setGlobalDefaults({ BasePath: \"http://some.tld/other/path\" });\n\n// or\n\nLAB.setOptions({ BasePath: \"http://some.tld/other/path\" })\n.script(...)\n...\n```\n\nSo, if you set the LAB configuration `BasePath` to the same as the absolute value in your `<base>` tag, you should get your desired behavior, and that should be reliable across all browsers. Moreover, if you're using `<base>` for only your script tags, LABjs' configuration makes `<base>` unnecessary. :)\n. Unfortunately, this is not really directly possible, cross-browser, at least by the LABjs library. The problem is, browsers are inconsistent about how they handle a \"failed to load\" script. Some fire an error, some never fire anything, some fire a load under certain network error conditions (older browsers I believe).\n\nSo, LABjs really cannot tell if it _didn't_ load, only if it _did_ successfully load.\n\nThe assumption with the normal use of LABjs is that you do not want other code to run if previous code fails to run, as this is **usually** a bad idea, and will just cause cascading errors.\n\nSince you're in an exception case, you'll need to do something different, manually.\n\nMy suggestion is to use a timeout interval, perhaps like this:\n\n``` js\n(function(){\n   var flagged = false;\n   var timer = setTimeout(loadCSLibrary, 10000); // give it 10 secs max to load\n\n   $LAB\n   .script(\"https://.....wa_config.js\")\n   .wait(function(){\n      loadSCLibrary();\n   });\n\n   function loadSCLibrary(){\n      clearTimeout(timer);\n      timer = null;\n      if (!flagged) {\n         flagged = true; // mark this code as having run already\n\n         // ... your code\n\n      }   \n   }\n})();\n```\n\nHopefully that kind of helps illustrate how to construct a timeout for your scenario. :)\n. Never heard of this use-case before now. But yeah, we definitely don't want to rely on the `<base>` tag. So I don't know what an automatic solution would be. \n\nCan you try manually setting, in the HTML of the srcdoc, `location.href = \"\"` or something like that _before_ you include the LABjs code, to see if it prevents the JS error that LABjs encounters? Then, if you set the `BasePath` config variable to some absolute, it should substitute for `<base>` and it should work for you.\n. For security reasons, there doesn't appear to be any way to hijack/override `location` or `location.href`. So that monkey patching won't work.\n\nI'm yet to be convinced that there is a good work-around for URL handling when you're in an iframe that's essentially URL-less. I'm not convinced of what a good clean fall-back is, but I know that `<base>` is not what I'd want.\n\nOne option is if there's no location, then LABjs **doesn't** try to do any URL resolving/canonicalization. This sounds good on the surface, until you realize that LABjs does this only so you get the kind of behavior you expect around \"duplicates\" handling, especially when referencing the same script with different types of relative URLs. Users expect the tool to \"know\" these are the same, and the only way to do that is to resolve them all against a base URL, the window location being the appropriate one.\n\nNot doing canonicalization of the URLs will likely lead to strange gotchas around duplicates, so it is similarly a bad route to head down, IMO.\n\nAnother option is to fake some base URL like \"http://some.tld\" in the case of a missing one, so that all the logic works correctly. But then there's issues where a protocol-relative URL like \"//someother.tld/foo/bar\" URL would expect the correct http vs. https switching, which we really can't do. So this is a bad route.\n\nAnother option is to have LABjs try to look up to a parent frame if the current page has no URL, under the assumption that some frame in the heirarchy in the browser must have a URL. But I'm not sure if security things like CSP would prevent this sort of thing from inside a srcdoc iframe. That would take a lot of research and proving. But it's the only option I see so far which is remotely plausible.\n\n---\n\nThen, we have to step back and ask if benefits of this fix, niche as it is, justifies the \"pain\" of the fix. I'm not really convinced it does. This is the first time in 4-1/2 years someone's asked for it. The stability of LABjs is every bit as important a feature as any other, at this point.\n\nSo I think we could research _if_ there's a fix, but then you'd probably just need to run your own patched version of LABjs with such a fix. If we got a bunch of people asking for this, and if we had other bugs or features that were waiting and could be collected into a compelling enough of a set for a justifiable release, we could consider it some day.\n. bower is dead, apparently. or dying. or something.\n. What's the motivation for this change? It seems you are saying that chrome extensions have urls like \"---://some.tld/...\" with literal - dashes instead of http/https/file/etc? That seems bizarre, if I'm interpreting your code change correctly.\n\nAlso, shouldn't you just be able to use LABjs with explicit URLs, or by setting the `BasePath` configuration, thereby ignoring any of the automatic URL negotiation?\n. Interesting. This may be related to #93. I might make a separate fork branch with slight tweaks that deal with non-standard/unexpected `location` values in a more robust way.\n\nI'm not sure when/if those changes would roll into the main branch and necessitate an update (not sure I think these niche cases justify a 2.0.4 patch release). But at least the separate branch would provide an alternate copy for those who need to use LABjs in those unusual conditions.\n\nI think there will someday be a LAB 2.1 release (or whatever), as over the years several tiny things have been requested. None of them are enough to justify a new release, but taken altogether, I think we'll eventually get to the point where another release comes out, and we'll certainly pull this one in at that time.\n. There are two ways to do what you're suggesting:\n\nMethod 1:\n\n``` js\nvar chain = $LAB.script(..).script(..).wait(..)...;\n\n// later\n\nchain.script(..).wait(..)...\n\n// later\n\nchain.wait(..)...\n```\n\nMethod 2 (more canonical for this situation):\n\n``` js\n$LAB.queueScript(..).queueScript(..).queueWait(..)...;\n\n// later\n\n$LAB.queueScript(..).queueWait(..)..;\n\n// later\n\n$LAB.queueWait(..)...;\n\n// finally\n\n$LAB.runQueue();\n```\n\nThe `queueScript(..)` and `queueWait(..)` functions apply toward an internal queue (like the `chain` var from the method 1 snippet), so it's a little cleaner than doing your own.\n\nOne note of difference: in method 2, none of the loading starts until you call `runQueue()`, but in method 2, scripts start pretty much right after calling `script(..)`. Method 2 should be thought of as an internal queue. Method 1 is a manual external queue.\n\nHope that helps. :)\n. > I know you don't want to add cache busting\n\nSee: `CacheBust` option here: http://labjs.com/documentation.php#setglobaldefaults\n\nI don't have a problem with LABjs truly cache busting, with random numbers. What I don't think LABjs should be doing is munging URLs with higher level abstractions like version numbers. To me that still seems like it should be handled by your build process, or your templating engine, or ... etc.\n\n> Trying to do : `$LAB.script_cb = function(path) {return this.script(path + '?v{{last_build_date}}')` will not work\n\nCorrect, it won't, as you provided it, return your wrapper each time, it'll just return the `$LAB` chain.\n\nBut with a little extra work, you should be able to achieve what (I think) you're hoping for:\n\n``` js\nvar $LAB_wrapper = (function(version){\n   var $L = $LAB, publicAPI = {\n      script: function(src) {\n         $L = $L.script(src + \"?v\" + version);\n         return publicAPI;\n      },\n      wait: function() {\n         $L = $L.wait.apply(null,arguments);\n         return publicAPI;\n      }\n   };\n   return publicAPI;\n})(\"{{last_build_date}}\");\n\n// later\n\n$LAB_wrapper.script(\"foo.js\").wait().(\"bar.js\");\n// loads \"foo.js?v1234\" and \"bar.js?v1234\"\n```\n\nHopefully that helps get you on the path you're looking for. :)\n. First, this is somewhat related to #93.\n\nAlso, your proposed regex doesn't actually work:\n\n``` js\n/^[a-z][\\w\\+-\\/]+\\:\\/\\/\\/?[^\\/]+/.test(\"chrome-extension:mmjeglkkcnglojkjoomifokhekiiiioe/www/index.html\"); // false\n```\n\nWe'd have to tweak the regex to make the `//` part optional, or something like that.\n\nMoreover, the question is: could we actually assume to detect against URLs that don't look like normal web URL's and not break other important behavior (namely absolute/relative URL handling)?\n\nIn addition to the `root_domain` matching with `/^\\w+\\:\\/\\/\\/?[^\\/]+/`, loaded script URLs are canonicalized to the page by testing against `absolute_regex`: `/^\\w+\\:\\/\\//`. So, if we're going to make the change to one regex, we have to change both regexes.\n\nBut, imagine if we did that, and then someone had this URL: `foo:bar/baz.js` to load some script, while inside a chrome extension.\n\nAny generic regex that matches your chrome-extension URL would have to also match that `foo:bar..` URL. However, that URL might in fact be intended as a relative URL, where they want it to be canonicalized to the root chrome-extension URI, so that it would be loaded as `chrome-extension:aosnsldk24rl2ksada/foo:bar/baz.js`.\n\nHow could we know that this URL should have been taken to be as absolute instead: `foo:bar/baz.js`, rather than relative?\n\nWe couldn't. Right now, \"absolute\" requires something like `http://` at the beginning, which is an easy assumption. But that assumption would totally go away with the proposed change.\n\nUnless, and this is the part I'm dubious on, the regex only allowed a specific safe-list of scheme names, not just a `w+` type regex match... like `chrome-extension:`, `about:`, etc.\n\nHow would we decide which scheme names should be explicitly listed? What happens if someone later comes along and says, \"hey, my page is running under this `wxyz:..` scheme, can you whitelist it?\" And what happens if that accidentally collides with someone else's relative URL design?\n\nSeems like a future maintenance nightmare, that ensures we have to keep updating LABjs rather than keeping it stable and unchanging as much as possible, and that we're asking for breakages.\n\nNot sure what a good general solution to this would be.\n\nMy initial reaction is similar to what I said in #93, which is that this is a case where you should tweak LABjs for your own needs, since it's a pretty niche use-case, and the pain (of this one specifically) is disproportionately high.\n. OTOH, perhaps the more appropriate logic is, if the current page is a scheme type, you couldn't do an absolute regex that was also a scheme (unless it was an exact match). You'd have to do a normal web URL like \"http://\", or otherwise the URL could be reasonably assumed to definitely be relative to the scheme URI.\n\nEven if we could construct such special case logic, I'm not sure if the niche'ness of this deserves to be elevated to the core code.\n\nUndecided for now.\n. Interesting. So the only thing missing is the allowance for `-` in it?\n. OK, this will be queued up to be fixed. But, just to set expectations, we're collecting several small niche things like this together before releasing again. As you can tell, I release quite rarely, as stability is one of the main features of this library.\n\nI would recommend for now that you patch your own copy of LABjs. I'll leave this issue open until such a time as it's appropriate to fix for that next release (probably 2.1).\n\nThanks!\n. @mttcr thanks! to clarify, you're talking about?\n1. using LABjs to load a blob URL? --OR--\n2. using LABjs inside a page that came from a blob URL?\n. thanks!\n. LABjs only supports generating random numbers to append to the end of the query string (for cache busting). If you're implementing logic that gives meaning to the values in your URLs, you need to manage that in a layer that produces the URLs you feed to LABjs.\n. My guess is you have a execution race condition with a silent error that stops the chain. Can you post your `$LAB` chain exactly as you use it in the page?\n. How is the LABjs script file being included in the page?\n. I don't understand how a `<script src=\"..\"></script>` tag can't be guaranteed to have loaded and run before the rest of your code. The whole `setInterval(..)` thing is wholly inappropriate to use here. It speaks to a deeper issue that you would ever need to try something like that. We need to dig deeper on this, I don't suspect that it has _anything_ to do with LABjs itself.\n\nCan you post here, or email me privately (same name but on gmail) a full HTML dump (from view-source) of your page, so I can see what actually the browser is trying to run, and in what order? Alternatively, a URL to the page would be useful.\n. Glad to hear you've worked through some of those issues. Let me know if I can help elsewhere. :)\n. LABjs doesn't load anything that you don't explicitly pass to a `script(..)` call on the API. So I'm confused as to what need LABjs would need to ignore? Just don't pass it something you don't want it to load.\n. Cheers! :)\n. LABjs doesn't have any code in it that even includes the word \"nestable\", so it's definitely not filtering out those files. Your issue must be related to something else, either software on your computer or something in your server configuration, or something like that.\n. Closing for now. Reopen if there's more specific evidence to share.\n. done. :)\n. Perhaps try the `CacheBust` option in LABjs?\n\n``` js\n$LAB.setOptions({ CacheBust: true }).script(..)\n```\n. LABjs doesn't do any loading or logic around caching. It simply causes a `<script src>` tag to request a specific URL. The browser and the server (by way of its response headers -- caching, etc) are entirely in control of how and when those files will be loaded, reloaded, or pulled from cache.\n\nThe `CacheBust` option only prevents caching by making sure the URL is always different, which effectively defeats any caching that may otherwise have happened. But it doesn't have any direct control over the loading itself.\n. duplicate\n. This seems like a reasonable thing to consider for a future update.\n. That's what I was going to point you to. :) Cheers.\n. uhhh... i have no idea what that would be. since LABjs just does loading via normal `<script>` tags in all modern browsers, I would think this would be an issue that was replicatable outside of LABjs' code. Any chance we could get an affected file to test with?\n. Closing for now. Feel free to add more details if this crops up again and seems to be LABjs related.\n. LABjs places no limits (or controls) over how parallel a browser will load requested resources. So there's nothing to change in LABjs for that.\n\nIt remains an unknown to me how to tell the browser (if anything) that you want requests to be interleaved on a single connection. I believe that may happen automatically, but I suppose it's possible it may need a client-side change. I've not heard any details about that. It's also possible that it requires no extra work on the client, but may require changes to the server to recognize these requests and combine the responses into one connection. Again, I have not investigated any of these specific details.\n\nIf there ends up being something specific LABjs would need to change to adopt HTTP2 conventions for parallelism of connections, I'm happy to entertain discussion.\n. Please see: https://github.com/getify/LABjs/issues/19#issuecomment-50981147 (and other closed issue threads)\n. @dudesl can you be more specific?\n. The goal is the 3.x launch will be on npm\n. it's started... there's a separate branch for the 3.0 work. it's in progress. just haven't had much time lately. \n. I appreciate that several people have interest in this project. I do definitely want to complete the 3.0 rewrite (I'm about 1/3 of the way through that). However, the project is lower on my priority list. I have several other projects that are more pressing.\r\n\r\n@finetype the site (http://labjs.com) is down, but it's up on http://archive.org so you can consult the docs there. They should have the info you're inquiring about. Part of the rewrite will be to migrate all that documentation over to this repo.. I've just pushed up my long-in-progress work on the 3.0 rewrite. It's at bare minimum functioning status. Still very much pre/alpha, but at least it's coming along finally. :). See below for a checklist. Theoretically, others can help with this coding.\r\n\r\nTBH, I still expect most likely to be the one to do (most of) the code for the core library. It's not a particularly simple flow control to fully understand, and it's not documented anywhere, so I'm not expecting other contributors to fully understand what I'm juggling in my head. :)\r\n\r\nBut there's several extra projects (like the server util, the mock DOM, etc) that definitely are good for others to tackle. Definitely will also appreciate help eventually with docs and tests. :)\r\n\r\nFor now, please take a look at the code and see if you spot anything or have any suggestions. That much I'm happy to have help with, for sure!. Gonna start a checklist here (in no particular order) for the rest of the stuff I think will need to be done for 3.0... expect this list to grow significantly:\r\n\r\n- [ ] fix `script(..)` and `wait(..)` to also take arrays of arguments\r\n- [ ] add methods (similar to `script(..)`) for loading other resources besides scripts (like stylesheets, images, etc)\r\n- [ ] add back in the `queue*(..)` / `runQueue(..)` mechanism from 2.x\r\n- [ ] explore adding back in the \"AllowDuplicates\" mechanism from 2.x -- not sure if possible, nor even worth it\r\n- [ ] modules (https://jakearchibald.com/2017/es-modules-in-browsers/) \r\n- [ ] figure out correct handling for \"CacheBust\" (especially as it relates to `<link rel=preload>` preloading)\r\n- [ ] figure out which additional options make sense for `script(..)` (and/or other resource loading types), such as a whitelist of attributes to be added to the element, etc\r\n- [ ] add `error` event handling for script/link elements\r\n- [ ] address all the TODO comments in the code\r\n- [ ] rebuild a whole new test suite\r\n   \r\n   NOTE: this is particularly challenging because to avoid needing a test server to load resources from, we need to build a mock of (some parts of) the DOM. We can't really just use an existing virtual/mock DOM for this purpose, because we need to actually control it (what APIs are present, how they behave, etc) for our different test simulations.\r\n\r\n   - affected DOM APIs / properties:\r\n      - `getElementsByTagName(..)`\r\n      - `createElement(..)`\r\n      - `head`\r\n      - `appendChild(..)`\r\n      - `removeChild(..)`\r\n      - `baseURI`\r\n      - `setAttribute(..)`\r\n      - `getAttribute(..)`\r\n      - `addEventListener(..)`\r\n      - `removeEventListener(..)`\r\n      - `relList`\r\n      - `supports(..)`\r\n      - `performance.getEntriesByName(..)`\r\n   - we need to be able to simulate a variety of different browser environment scenarios by changing the behavior of these APIs, for example:\r\n      - preloading vs no-preloading\r\n      - script ordered-async vs not\r\n      - `<link rel=preload>` tags already present in the page vs not\r\n      - \"random\" server/network timing variations (and errors!)\r\n- [ ] rebuild the docs\r\n- [ ] revisit feature requests from the last N number of years of issue threads, examine feasibility\r\n- [ ] explore Debug mode and what that means for 3.0+ -- is there a debug build with extra code, what changes in debug mode, etc?\r\n- [ ] explore replacing `canonicalURL(..)` with [`URL(..)`](https://developer.mozilla.org/en-US/docs/Web/API/URL), probably with some sort of polyfill-fallback (for older browsers)\r\n- [ ] change the usages of timers (`setTimeout(..)`) to a scheduling queue (like [this one](https://github.com/getify/asynquence/blob/master/asq.src.js#L19-L59)), backed by one of these async timing mechanisms (in order of precedence): [`requestIdleCallback(..)`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), [`setImmediate(..)`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate), [`process.nextTick(..)`](https://nodejs.org/api/process.html#process_process_nexttick_callback_args), or [`setTimeout(..)`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)\r\n- [ ] using [getify/ScanTree](https://github.com/getify/ScanTree), build a server-side LABjs utility that can scan a code base and compile a list of resources to be loaded, and produce not only the `$LAB` code chain to load it, but also produce the `<link rel=preload>` markup to inject into an HTML page to start the preloading early (parser stage)\r\n\r\n   NOTE: this utility needs to (eventually) be able to parse ES6 modules `import` syntax as well, something that ScanTree doesn't currently support. That may mean needing to extend ScanTree in some way.. FYI: I've moved the mock-DOM thing to its own separate project:\r\n\r\nhttps://github.com/getify/mock-DOM-resources. [Mock-DOM-Resources](https://github.com/getify/mock-DOM-resources) is now capable (enough) to sit at 1.0.0. It's ready to use for a LABjs test suite.\r\n\r\nEdit: it's matured to 7.0.0 now and has a full test suite of its own, so it's definitely reliable enough now for LABjs to use.. @jbmonroe Pretty sure the `src/index.js` file doesn't have any ES6 in it. My goal is definitely to target ES5. The test suite does require ES6 at the moment.. @jbmonroe \r\n\r\nAh, I thought you were talking about LABjs since that's this repo and the main topic of the thread.\r\n\r\nYes, \"Mock-DOM-Resources\" uses ES6 because it's primarily designed to be run in node. It's only used by LABjs' test suite, so again the tests are ES6 but LABjs itself should be ES5.\r\n\r\n> ES6-looking get/set code\r\n\r\nBTW, getters/setters are ES5 not ES6. But there are a few other ES6 features in Mock-DOM-Resources, indeed, such as concise properties in object literals.. LGTM. Thanks!\n. @xaddict why does it matter where LABjs adds the scripts?\n. Those audits or whatever they are, are being rather naive if they're penalizing you for dynamically added scripts in the `<head>`. It's true it's not a great idea for that in the orig source code, but this is all dynamic, so its placement won't have any difference or impact at all.\n\nNot sure this kind of feature would be useful to a broad enough audience to make it worth the bytes. But perhaps.\n. LABjs is going to append resource requests to the end of the `<head>` from 3.0 onward.. LABjs is undergoing a rewrite to 3.x. I'm not going to accept PRs while that is happening. Error handling is under consideration as a feature for the next version. I'm not sure yet how it will appear. Thank you for your interest, though!\n. Chrome does not block inline scripts, unless the server it's served from is sending CSP policy to prevent it -- in which case there's nothing we can do to fix that.. I appreciate these fixes... but just so you know, the code on the branch is entirely still WIP. I think I probably have local changes not even pushed up to the branch yet. It's a substantial re-write and I'm only 5-10% of the way through. That's why all these things are still so rough.\n. There are other ways such as script injection. Thay said, I'm not really wild about doing our own caching. Browsers are better at it. . That's awfully vague. If you can talk about specific details with caching, perhaps we can identify other causes (poor caching headers, etc). But I don't think we should fix our problem of a thumbtack by pulling out a sledgehammer. :). Any control you'd like to have over caching should be handled with service workers, IMO. I don't plan to build any caching behavior into the loader. It is possible eventually LABjs will ship a service worker for assistance, but that's far down the priority list, if ever.. My servers have been down since last July. I haven't had time to rebuild them. The data wasn't lost, but I don't have anything to put up right now.\r\n\r\nIn the interim, the whole site should be available for review (docs wise) here: http://web.archive.org/web/20160521005010/http://labjs.com/. Error handling on resource requests is notoriously inconsistent (differences between 4xx and 5xx HTTP error codes, for example). As such, I don't want to try to bake reliance on that inconsistent behavior into LABjs.\r\n\r\nHowever, in 3.0, LABjs is going to support an error notification (of some sort), so you can at least be notified if any error events are fired against the resource elements. That probably won't help much in recovery, but at least you could log the failure.. It's illegal as of strict mode. It should be refactored. Easy fix is to name the function expression (passed to the setTimeout) and use that function name.\r\n\r\nNOTE: the library is undergoing a complete rewrite for 3.0, so there's no need to PR to fix this, because it'll be fixed in that rewrite.. Based on your description, this doesn't sound like a bug in LABjs. First off, we'd need to know which browser are you using for this test? If it's a modern one, I can virtually guarantee it's not a LABjs bug, because under the covers, LABjs delegates to the browser to enforce loading order (using the `async = false` \"ordered async\" feature).\r\n\r\n> Understandable, script loaders undermine the normal document.ready event.\r\n\r\nNo, I wouldn't characterize this as undermining anything. Expose false assumptions? Yes.\r\n\r\nHistorically there have always been race conditions, and always will be, when people (ie, developers of projects) conflate \"DOM ready\" with \"scripts have loaded\". I ranted about this countless times ages ago. Here's [one relevant issue thread](https://github.com/getify/LABjs/issues/16#issuecomment-690070) I found in my searching.\r\n\r\nIt sounds like Angular is assuming that DOM ready means \"all dependency scripts have loaded\". That's not at all what DOM ready means, and even less so when there's dynamic script loading involved.\r\n\r\n> So, I try to use $.holdReady(true) and $.holdReady(false)\r\n\r\nI don't know what these are, as I'm not an Angular dev. I can't really comment on whether they're safe for dynamic script loading or not.\r\n\r\n> That makes it seem like a race condition, but given that I'm passing in the order flag\r\n\r\nIt probably is a race condition, but it sounds like it's not a race condition between scripts but rather a race condition between scripts finishing loading and the DOM ready event being assumed to mean the scripts finished loading.\r\n\r\nMy advice continues to be: stop relying on DOM ready to mean \"scripts are loaded\". Any framework that does that is being openly dismissive of reality.. > These false assumptions are those of the angular code here, not my own code.\r\n\r\nI didn't mean to suggest it was your fault or poor assumptions. The fault is with tools that make these decisions, always has been and always will be. :)\r\n\r\nMoreover, these bad assumptions make those tools unfriendly to **any** dynamic resource loader, even a manual inline snippet inside a `<script>` tag. Dynamic resource loading, which has been a thing for a really long time, is antithetical to these assumptions. It's similar to tools that rely on `document.write(..)`. I've literally had such tools just tell their users \"don't dynamically load\".\r\n\r\n> It's a jquery event (it's not the same as window.onload, and is not a real DOM event as far as I am aware; it has its own characteristics in its attempts to be cross-browser and support its assumptions)\r\n\r\nAre you talking about `$.ready(..)` here? I'm assuming so. \"DOM ready\" is otherwise known as [\"DOMContentLoaded\"](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded)  and is absolutely a real DOM event thing. All `$.ready(..)` does is provide a dedicated event handler interface for it.\r\n\r\nAnd BTW, jquery's `$.ready(..)` is patched (as of jQuery 1.4 years ago) to handle the use case where jQuery itself is dynamically loaded after DOMContentLoaded has already passed. What jQuery does (or at least used to do, I haven't looked at their source code in half a decade) is check the [`document.readyState`](https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState) property (again, totally standard DOM stuff) to check to see if the document load has already occurred. If so, jQuery always fires your `$.ready(..)` right away.\r\n\r\nBut all of this is actually orthogonal to your problem. The problem is not whether `$.ready(..)` works or not. In fact, `$.holdReady(..)` is not fixing anything \"broken\" about `$.ready(..)`. It's making `$.ready(..)` work in an entirely different way than it was designed, because the authors of these frameworks/tools insist on using it differently. But DOM-ready has worked -- as designed -- for a really, really long time.\r\n\r\nIn fact, the proof that it \"works\" is that it's firing for you, even though it's firing \"too early\". The separate problem is that this event will, in general, ***always be able to fire before resources*** that don't *block* the event -- any dynamically loaded resource, any resource that `defer`s its loading (like `<script defer>`, etc), and more -- has finished loading.\r\n\r\nIf a resource doesn't block the event, obviously there's a race condition.\r\n\r\n> as its name tells us, its intention was to signal that code running then can expect everything to have loaded\r\n\r\nEh, no. Though the name `DOMContentLoaded` says \"Content\", the \"content\" here isn't about external resources. It's about the internal DOM element structure. And \"Loaded\" means the HTML itself has loaded and been parsed into those DOM element objects.\r\n\r\nQuoting [the MDN page](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded):\r\n\r\n>> The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. A very different event `load` should be used only to detect a fully-loaded page.\r\n\r\nSo `document.ready` is definitely not about \"resources have finished loading.\" `window.onload` was originally meant for resource loading completion, even though it also won't wait for (some kinds of) dynamically loaded resources.\r\n\r\nThe crux of the mal-assumption around `DOMContentLoaded` has always been related to `<script>` elements. Because `document.write(..)` needs to run synchronously, the browser has always ensured that any `<script src=..>` or `<script>..</script>` element would execute (regardless of loading order) in the **same order as listed in the DOM**.\r\n\r\nThus, the logical reasoning goes: \"if the current line of code is executing, then any other code that was 'requested' (listed in the DOM) earlier *must* already have finished loading **AND EXECUTING**.\" From that, it's a natural extension to assume, \"if i declare a DOM-ready handler in a piece of code, then all the code -- at least the code 'before' me -- must already have loaded and run, because I couldn't have gotten to this line of code if that previous code hadn't already run.\"\r\n\r\nLong before resource loaders came around, this assumption was already broken when HTML added `<script async>` and `<script defer>`. In both those cases, you're telling the browser to take that script resource and treat it as a separate thing that doesn't hold to those rules. So it's really always been a terrible assumption and conflation, but resource loaders painfully expose it for what it is: **junk science**.\r\n\r\n> $.holdReady() is a jquery tool to manipulate the $(document).ready event\r\n\r\nYour bug may just be that this plugin is broken or incomplete. I don't know.\r\n\r\nBut in theory, if it lets you \"hold off and artificially fire jquery's `ready` event whenever\" you want, then you should be able to \"delay\" until the final `.wait(..)` in your `$LAB` chain. That may be what you were trying to do, not sure, but at least in theory it seems reasonable. Well... hacky patchy ill-advised... but not irrational.\r\n\r\nNow that I think about it... if `$.holdReady` is a jQuery plugin -- it modifies jQuery at run time -- the race condition could just be that jQuery is firing its ready event before `$.holdReady` has a chance to modify jQuery to hold the event off. It could be that you need to package jQuery and `$.holdReady` in the same file so they're ensured to run together. I dunno.\r\n\r\nI still really feel like this is a bug that has nothing to do with LABjs, but more about the process of resource loading in general, and perhaps a failure to hack things to work differently than designed.\r\n\r\nIOW, I'm pretty sure I could expose this bug without using LABjs at all, just using basic resource loading logic.\r\n\r\n---------\r\n\r\nAny chance you could pull out the part of angular that is creating the problem (I guess along with `$.holdReady(..)`) and show a standalone minimal reproduce test case that I could analyze, instead of needing to grok all of angular's internals?. Cheers! :) . Cheers! :) . ",
    "icoloma": "I have been able to reproduce this with a simple test case:\n\n```\n<script src=\"LAB.src.js\" type=\"text/javascript\"></script>\n<script src=\"fLAB.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\n$LAB\n.setOptions({})\n.script(\"http://maps.google.com/maps/api/js?sensor=false\")\n.wait(function() {\n    // do my thing\n});\n</script>\n```\n\nTesting with file:// prefix:\n- If I omit setOptions(), I get the \"opts is undefined\" message.\n- With setOptions(),  my code never gets invoked.\n\nTested with Firefox 3.5\n\nBTW, the documentation of flab.js is not linked anywhere in the LABjs documentation nor the source file, so you can only find it by googling.\n. I have been able to reproduce this with a simple test case:\n\n```\n<script src=\"LAB.src.js\" type=\"text/javascript\"></script>\n<script src=\"fLAB.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\n$LAB\n.setOptions({})\n.script(\"http://maps.google.com/maps/api/js?sensor=false\")\n.wait(function() {\n    // do my thing\n});\n</script>\n```\n\nTesting with file:// prefix:\n- If I omit setOptions(), I get the \"opts is undefined\" message.\n- With setOptions(),  my code never gets invoked.\n\nTested with Firefox 3.5\n\nBTW, the documentation of flab.js is not linked anywhere in the LABjs documentation nor the source file, so you can only find it by googling.\n. ",
    "wirecash": "https://www.atmcash.com/bug/\nThe issue occurs in FF 3.6 and IE8, didn't test in any other browsers.\nWe narrowed the issue down to the duplicates, whenever there is a script that is being attempted to load twice it freaks out.\nIf we set the allowDuplicates to true, or get rid of the .wait() it works.\nThanks in advance!\n. We were able to fix the issue, however, not sure if it was a problem with the original code or we just fixed it in the expense of something else.\nUsing firebug we were able to figure out the issue. Whenever there are more than one scripts that are already loaded, it doesn't execute a function within a .wait().\nThanks\n. In the provided link https://www.atmcash.com/bug/ you can't replicate the issue?\n. https://www.atmcash.com/bug/working.html\nHere is the page without labjs, \nhttps://www.atmcash.com/bug/\nWith labjs\n\nThanks!\n. Is there any other assistance we can provide you with to resolve the issue?\n. Both of them would have an alert of \"hey\".\nHowever, the working.html one, once clicking the buttons it should show some content while the labjs doesn't.\n. I see.\nWell, I would appreciate it if you'd keep us posted if you decide to handle this case in any future releases.\nThanks for great work.\n- Ran\n. https://www.atmcash.com/bug/\nThe issue occurs in FF 3.6 and IE8, didn't test in any other browsers.\nWe narrowed the issue down to the duplicates, whenever there is a script that is being attempted to load twice it freaks out.\nIf we set the allowDuplicates to true, or get rid of the .wait() it works.\nThanks in advance!\n. We were able to fix the issue, however, not sure if it was a problem with the original code or we just fixed it in the expense of something else.\nUsing firebug we were able to figure out the issue. Whenever there are more than one scripts that are already loaded, it doesn't execute a function within a .wait().\nThanks\n. In the provided link https://www.atmcash.com/bug/ you can't replicate the issue?\n. https://www.atmcash.com/bug/working.html\nHere is the page without labjs, \nhttps://www.atmcash.com/bug/\nWith labjs\n\nThanks!\n. Is there any other assistance we can provide you with to resolve the issue?\n. Both of them would have an alert of \"hey\".\nHowever, the working.html one, once clicking the buttons it should show some content while the labjs doesn't.\n. I see.\nWell, I would appreciate it if you'd keep us posted if you decide to handle this case in any future releases.\nThanks for great work.\n- Ran\n. ",
    "partoa": "Hi all I believe my latest commit fixes this issue, I have created a pull request for it, so, feel free.\nWhat I did was modify the duplicate checks so that for scripts loaded via XHR would not be loaded more than once, I also added the url as a title for the the same.\n\nYou should be able to diff and see the rest of the changes, but it seem to work perfectly, if there are any issues with my fix kindly let me know.\n. True about the alert, but if you have firebug and run console.log, the order of execution seem OK. What I suspect is that there's a race condition somewhere.\n. Hi all I believe my latest commit fixes this issue, I have created a pull request for it, so, feel free.\nWhat I did was modify the duplicate checks so that for scripts loaded via XHR would not be loaded more than once, I also added the url as a title for the the same.\n\nYou should be able to diff and see the rest of the changes, but it seem to work perfectly, if there are any issues with my fix kindly let me know.\n. True about the alert, but if you have firebug and run console.log, the order of execution seem OK. What I suspect is that there's a race condition somewhere.\n. ",
    "prabirshrestha": "assume we have 3 js libraries -> jquery.js, jquery.ui.js and jquery.tabs.js\n\njquery.js doesnt depend on anything.\njquery.ui.js depends on jquery.js\njquery.tabs.js depends on jquery.ui.js (which also depends on jquery.js)\nindex.html - the website - depends on jquery.tabs.js (which depends on jquery.ui.js and \n\njquery.js)\n\n(Note: original2 is before original)\n\n# \n\n[original2 folder]\n\nin 'jquery.tabs.js'\n  since it depends on jquery.ui.js and jquery.js\n\n  we would add the following script and put wait function in appropriate places.\n  once the jquery.tabs.js is loaded we alert by telling the jquery.tabs.js is loaded\n\n$LAB\n    .script('../scripts/jquery.js').wait()\n    .script('../scripts/jquery.ui.js').wait(function(){\n        alert('jquery.tabs.js loaded');\n    });\n\nin 'index.html\n  set allow duplicates to false\n\n$LAB.setGlobalDefaults({AllowDuplicates:false});\n\n  since we need to use jquery.tabs.js we code as follows.\n\n$LAB.script('jquery.tabs.js');\n\n---\n\nalert would occur in this following order\njquery.js loaded\n[click ok]\njquery.ui.js loaded\n[click ok]\njquery.tabs.js loaded\n[click ok]\n\nboth IE9Beta and chrome 6.0.172.63 behaves the same way,\nbut firefox 3.6.10 (& FF4Beta) behaves diffrently.\n\njquery.js loaded\njquery.ui.js loaded\n[shows : click ok - for jquery.js, click ok - for jquery.ui.js]\nonce i click ok for jquery.ui.js then\njquery.tabs.js is loaded\n\nfor some reason in FF, jquery.ui.js code is executed without waiting for jquery.js alert to be \n\nclicked ok. (this must be FF own way of handling in which it allows a page to have more than \n\none alert, so can ignore it. the main point is that LABjs got loaded in order. So basically \n\noriginal2 works in the way it is supposed to work.)\n\n# \n\n[original folder]\nlets say i want to optimize the original2 to original\nall the files jquery.js,jquery.ui.js and jquery.tabs.js is the same as original2, only the html \n\nfile is different.\nthis time i try want to make the script download faster be preloading.\nsince i know that jquery.tabs.js requires jquery.ui.js which requires jquery.js, i chain them \n\nalong with jquery.tabs.js (what this allows to do is instead of downloading jquery.tabs.js \n\nfirst and letting it figure out what it needs, i preload those dependencies coz i know it is \n\nrequired, so i dont have to wait for jquery.tabs.js to be downloaded before jquery.ui.js and \n\njquery.js is downloaded.)\n\nso now i change the code in html to \n$LAB.setGlobalDefaults({AllowDuplicates:false});\n$LAB\n    .script('../scripts/jquery.js').wait()\n    .script('../scripts/jquery.ui.js').wait()\n    .script('jquery.tabs.js');\n\nnow the problem arises, this code fails to execute.\njquery.js is alert is shown then jquery.ui.js which is fine, but it doesn't show the \n\njquery.tabs.js alert.\nlooking at firebug, it seems to download jquery.tabs.js. but for some reason it doesn't execute \n\njquery.tabs.js code.\n\nIt would be very great if this senario would work or am I doing something wrong.\n\n# \n\nYou can download the codes in zip file at http://prabir.me/sandbox/labjs/1/1.zip\nor see a live example at \nhttp://prabir.me/sandbox/labjs/1/original/\nhttp://prabir.me/sandbox/labjs/1/original2/\n\ni tried downloading labjs fork from @partoa, but it doesnt work with this senario.\n\nlike @atmcash said, it works fine if we remove the {AllowDuplicates:false} option, but that would make the script execute twice,\nwhen i got the latest fix from http://github.com/atmcash/LABjs, my [original] sample seems to work. live example can be found at http://prabir.me/sandbox/labjs/1/fix/ this is the expected behavior.\n. great to hear its planned for future release.\n\nyou also mentioned about LABjs-server could u explain a bit more about it. (sorry for branching the topic, excited)\n. lets say i set AllowDuplicates:true.\n\ni type the following in html page.\n\n$LAB\n.script('../scripts/jquery.js').wait()\n.script('../scripts/jquery.ui.js').wait()\n.script('jquery.tabs.js');\n\nthan jquery.tabs.js contains\n$LAB\n.script('../scripts/jquery.js').wait()\n.script('../scripts/jquery.ui.js').wait(function(){\n  if(!JQueryTabs){\n     // define jquery tabs and its src\n  }\n});\n\nwould this be a better way so that the each of these js files are not defined twice or more. same goes to jquery.js and jquery.ui.js they define only if its not yet defined.\n\nlooking at firebug, the jquery.ui.js gets downloaded twice, but the second request is 304 not modified. so might be we can trade of between js paring and downloading.\n. is there a way to know when the css has been loaded. so that i can make the div visible only when the callback has been fired.\n. assume we have 3 js libraries -> jquery.js, jquery.ui.js and jquery.tabs.js\n\njquery.js doesnt depend on anything.\njquery.ui.js depends on jquery.js\njquery.tabs.js depends on jquery.ui.js (which also depends on jquery.js)\nindex.html - the website - depends on jquery.tabs.js (which depends on jquery.ui.js and \n\njquery.js)\n\n(Note: original2 is before original)\n\n# \n\n[original2 folder]\n\nin 'jquery.tabs.js'\n  since it depends on jquery.ui.js and jquery.js\n\n  we would add the following script and put wait function in appropriate places.\n  once the jquery.tabs.js is loaded we alert by telling the jquery.tabs.js is loaded\n\n$LAB\n    .script('../scripts/jquery.js').wait()\n    .script('../scripts/jquery.ui.js').wait(function(){\n        alert('jquery.tabs.js loaded');\n    });\n\nin 'index.html\n  set allow duplicates to false\n\n$LAB.setGlobalDefaults({AllowDuplicates:false});\n\n  since we need to use jquery.tabs.js we code as follows.\n\n$LAB.script('jquery.tabs.js');\n\n---\n\nalert would occur in this following order\njquery.js loaded\n[click ok]\njquery.ui.js loaded\n[click ok]\njquery.tabs.js loaded\n[click ok]\n\nboth IE9Beta and chrome 6.0.172.63 behaves the same way,\nbut firefox 3.6.10 (& FF4Beta) behaves diffrently.\n\njquery.js loaded\njquery.ui.js loaded\n[shows : click ok - for jquery.js, click ok - for jquery.ui.js]\nonce i click ok for jquery.ui.js then\njquery.tabs.js is loaded\n\nfor some reason in FF, jquery.ui.js code is executed without waiting for jquery.js alert to be \n\nclicked ok. (this must be FF own way of handling in which it allows a page to have more than \n\none alert, so can ignore it. the main point is that LABjs got loaded in order. So basically \n\noriginal2 works in the way it is supposed to work.)\n\n# \n\n[original folder]\nlets say i want to optimize the original2 to original\nall the files jquery.js,jquery.ui.js and jquery.tabs.js is the same as original2, only the html \n\nfile is different.\nthis time i try want to make the script download faster be preloading.\nsince i know that jquery.tabs.js requires jquery.ui.js which requires jquery.js, i chain them \n\nalong with jquery.tabs.js (what this allows to do is instead of downloading jquery.tabs.js \n\nfirst and letting it figure out what it needs, i preload those dependencies coz i know it is \n\nrequired, so i dont have to wait for jquery.tabs.js to be downloaded before jquery.ui.js and \n\njquery.js is downloaded.)\n\nso now i change the code in html to \n$LAB.setGlobalDefaults({AllowDuplicates:false});\n$LAB\n    .script('../scripts/jquery.js').wait()\n    .script('../scripts/jquery.ui.js').wait()\n    .script('jquery.tabs.js');\n\nnow the problem arises, this code fails to execute.\njquery.js is alert is shown then jquery.ui.js which is fine, but it doesn't show the \n\njquery.tabs.js alert.\nlooking at firebug, it seems to download jquery.tabs.js. but for some reason it doesn't execute \n\njquery.tabs.js code.\n\nIt would be very great if this senario would work or am I doing something wrong.\n\n# \n\nYou can download the codes in zip file at http://prabir.me/sandbox/labjs/1/1.zip\nor see a live example at \nhttp://prabir.me/sandbox/labjs/1/original/\nhttp://prabir.me/sandbox/labjs/1/original2/\n\ni tried downloading labjs fork from @partoa, but it doesnt work with this senario.\n\nlike @atmcash said, it works fine if we remove the {AllowDuplicates:false} option, but that would make the script execute twice,\nwhen i got the latest fix from http://github.com/atmcash/LABjs, my [original] sample seems to work. live example can be found at http://prabir.me/sandbox/labjs/1/fix/ this is the expected behavior.\n. great to hear its planned for future release.\n\nyou also mentioned about LABjs-server could u explain a bit more about it. (sorry for branching the topic, excited)\n. lets say i set AllowDuplicates:true.\n\ni type the following in html page.\n\n$LAB\n.script('../scripts/jquery.js').wait()\n.script('../scripts/jquery.ui.js').wait()\n.script('jquery.tabs.js');\n\nthan jquery.tabs.js contains\n$LAB\n.script('../scripts/jquery.js').wait()\n.script('../scripts/jquery.ui.js').wait(function(){\n  if(!JQueryTabs){\n     // define jquery tabs and its src\n  }\n});\n\nwould this be a better way so that the each of these js files are not defined twice or more. same goes to jquery.js and jquery.ui.js they define only if its not yet defined.\n\nlooking at firebug, the jquery.ui.js gets downloaded twice, but the second request is 304 not modified. so might be we can trade of between js paring and downloading.\n. is there a way to know when the css has been loaded. so that i can make the div visible only when the callback has been fired.\n. ",
    "haarts": "That was ... amazing. You have no idea how much you helped me out. Thank you for your clear explaination and solution. \n. Actually this is a Webkit issue. Safari is also affected.\n. Yet another reason to switch to jQuery. :S \n\nThanks for the explaination. I got around the problem by hacking Scriptaculous and removing the dynamic loading of the modules. I then loaded them myself by pointing LABjs to the correct files.\n. That is what I ended up doing.\n. That was ... amazing. You have no idea how much you helped me out. Thank you for your clear explaination and solution. \n. Actually this is a Webkit issue. Safari is also affected.\n. Yet another reason to switch to jQuery. :S \n\nThanks for the explaination. I got around the problem by hacking Scriptaculous and removing the dynamic loading of the modules. I then loaded them myself by pointing LABjs to the correct files.\n. That is what I ended up doing.\n. ",
    "gbakernet": "This helped me too. Although, I had to include a cross browser solution for window onload in the initial JS loader footprint.\n. This helped me too. Although, I had to include a cross browser solution for window onload in the initial JS loader footprint.\n. ",
    "aakoch": "Isn't the right fix to remove the document.write() statements?\n. I don't understand why you can't do this:\n    var asyncjs = $LAB\n        .script('mootools-more').wait()\n        .script('clientcode').wait()\n        .script('my own modules').wait(function() { \n            alert('Scripts Loaded'); \n            alert('first call');\n            alert('second call');\n            alert('third call');\n    });\nthen some CSS via link tag.\n\nYou mentioned something about inline Javascript. If you're trying to prevent that code from being run until all of the scripts are loaded, why not just use the &lt;script> tag to load all of the scripts? This would prevent the domready event from being fired until your own modules are loaded.\n. Isn't the right fix to remove the document.write() statements?\n. I don't understand why you can't do this:\n    var asyncjs = $LAB\n        .script('mootools-more').wait()\n        .script('clientcode').wait()\n        .script('my own modules').wait(function() { \n            alert('Scripts Loaded'); \n            alert('first call');\n            alert('second call');\n            alert('third call');\n    });\nthen some CSS via link tag.\n\nYou mentioned something about inline Javascript. If you're trying to prevent that code from being run until all of the scripts are loaded, why not just use the &lt;script> tag to load all of the scripts? This would prevent the domready event from being fired until your own modules are loaded.\n. ",
    "a-run": "Hi again,\n\nI downloaded the latest release of jquery.validate (1.7, I was using validate1.6 with jquery.1.4.2) and this problem went away!\nI\u2019m in love with LABjs speeds up loading like magic!!! :D\n\nThanks a lot again!\n\nAnd sorry to have bothered you for jquery.validate\u2019s incompatibility issue. Hope you don\u2019t mind \n\nThanks\nArun\n. Hi again,\n\nI downloaded the latest release of jquery.validate (1.7, I was using validate1.6 with jquery.1.4.2) and this problem went away!\nI\u2019m in love with LABjs speeds up loading like magic!!! :D\n\nThanks a lot again!\n\nAnd sorry to have bothered you for jquery.validate\u2019s incompatibility issue. Hope you don\u2019t mind \n\nThanks\nArun\n. ",
    "lunetics": "Currently i load mootools core and LABjs via standard script tag, then the additional JS like mootools-more, clientcide and my own modules, so the domready occurs before my own modules are loaded via script tag.\n\nSo with the instance - chain i can make sure that my modules are loaded before i try to use it in inline code, otherwise it can happen that js don't know the module / class cause its not loaded yet.\n\nAt least i would wish there was a .completed() function which (similar to wait, but fires parallel)\n. The CSS breaks the chain somehow, don't know why.\nI built a lablsloaded Eventhandler for mootools, so when the scriptchain is loaded. i set at the footer async.wait(function() {Browser.labjsloaded = true} and check via the handler. Maybe i set different breakpoints for different modules, don't know if that complexity is worth the few microseconds gain then.\n. well i have another approch now with mootools.\n <pre><code> \n$Lab\n.script(mootools...).wait()\n.script(...).wait(function() {\nBrowser.labjsloaded = true;\n}\n</code></pre>\nand a custom eventhandler:\n\n<pre><code>\nElement.Events.labjsloaded = {\n    onAdd: function(fn){        \n        if (Browser.labjsloaded) fn.call(this);\n    }\n};\n(function(){\n    var labjsloaded = function(){\n        console.log('Labs Ready')\n        window.fireEvent('labjsloaded');\n        document.fireEvent('labjsloaded');\n    };            \n    var repeat = function(){\n        (Browser.labjsloaded == true) ? labjsloaded() : repeat.delay(10);\n    }\n    repeat();\n})();\n</code></pre>\n\nso i can use now:\n\n<pre><code>\nwindow.addEvent('labjsloaded',function() {\n// do this after the scripts are loaded...\n});\n</code></pre>\n. Currently i load mootools core and LABjs via standard script tag, then the additional JS like mootools-more, clientcide and my own modules, so the domready occurs before my own modules are loaded via script tag.\n\nSo with the instance - chain i can make sure that my modules are loaded before i try to use it in inline code, otherwise it can happen that js don't know the module / class cause its not loaded yet.\n\nAt least i would wish there was a .completed() function which (similar to wait, but fires parallel)\n. The CSS breaks the chain somehow, don't know why.\nI built a lablsloaded Eventhandler for mootools, so when the scriptchain is loaded. i set at the footer async.wait(function() {Browser.labjsloaded = true} and check via the handler. Maybe i set different breakpoints for different modules, don't know if that complexity is worth the few microseconds gain then.\n. well i have another approch now with mootools.\n <pre><code> \n$Lab\n.script(mootools...).wait()\n.script(...).wait(function() {\nBrowser.labjsloaded = true;\n}\n</code></pre>\nand a custom eventhandler:\n\n<pre><code>\nElement.Events.labjsloaded = {\n    onAdd: function(fn){        \n        if (Browser.labjsloaded) fn.call(this);\n    }\n};\n(function(){\n    var labjsloaded = function(){\n        console.log('Labs Ready')\n        window.fireEvent('labjsloaded');\n        document.fireEvent('labjsloaded');\n    };            \n    var repeat = function(){\n        (Browser.labjsloaded == true) ? labjsloaded() : repeat.delay(10);\n    }\n    repeat();\n})();\n</code></pre>\n\nso i can use now:\n\n<pre><code>\nwindow.addEvent('labjsloaded',function() {\n// do this after the scripts are loaded...\n});\n</code></pre>\n. ",
    "cayasso": "Hi Kyle, any thoughts about this suggestion?\n\nJB\n. Hi Kyle, any thoughts about this suggestion?\n\nJB\n. ",
    "ralphholzmann": "I appreciate the consideration. I actively develop on an app that goes from non-secure to secure and back again during its flow, and have come accustomed to using these protocol-less paths. Not having to use <pre>document.location.protocol</pre> would be ideal. Thanks.\n. I appreciate the consideration. I actively develop on an app that goes from non-secure to secure and back again during its flow, and have come accustomed to using these protocol-less paths. Not having to use <pre>document.location.protocol</pre> would be ideal. Thanks.\n. ",
    "jcisio": "Thanks, Kyle, that works.\n\nAbout the queuing, I can't use it. Developers put inline JS everywhere. I can grab all JS files and put in one chain without side effect, but for inline JS blocks, it's more difficult. However, I'll do more test about merging all inline JS blocks.\n. Anyway, is it better to have an event callback like this?\n    $LAB.ready(function() {\n      // code will be executed when all scripts are executed\n      // ...\n    });\nIt is like _lab.wait() but we can have many $LAB.script().script()... chains.\n. When I think about $LAB.ready(), I suppose that there is no $LAB.script() inside it. I didn't thought about the case when there is a $LAB.script() after a $LAB.ready(). Indeed, I thought that the browser is fast enough (or there is a small delay before $LAB.ready()) so that all $LAB.script() are called (that mean LABjs knows all scripts in the page) before $LAB.ready().\n\nWhen you ask about this case, I know that I'm wrong ;-) because your decision is \"as fast as the browser will allow\", then there is no delay... But I wonder if a few ms delay for $LAB.ready() could be enough so that all $LAB.script() are called before .ready()?\n\nIn a page there are many JS: some is in header, some is in footer, some is in the content for inline ads (the availability of JS depends on content, not on page, not all content have ads). But in fact I can postprocess to consolidate all JS file in one call, reorder JS (normally ads JS does not depend on other JS, thus it is placed 1st). So, currently I don't have any use case for multiple chain, it's just for convenient.\n\nThanks for your help. FYI I've created a new project page to enable LABjs in Drupal automatically http://drupal.org/project/labjs . Version for Drupal 7 was out, for Drupal 6 is coming soon. Maybe there will be more use cases.\n. The following code doesnot work:\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <head><title>TTCN D7 test</title>\n    <script type=\"text/javascript\" src=\"http://d7.ttcn/sites/all/libraries/labjs/LAB.min.js?lenopg\"></script>\n    <script type=\"text/javascript\">\n    var _lab = $LAB\n    .setOptions({AlwaysPreserveOrder:true})\n    .script(\"http://d7.ttcn/file1.js\");\n    </script>\n    <script type=\"text/javascript\" src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n    <script type=\"text/javascript\">\n    _lab.wait(function() {\n      alert(0);\n    });\n    </script>\n    </head>\n    <body>Test</body>\n    </html>\nI load all scripts with LABjs, but not google_server.js (I want it to be blocking one, and there are ads block with document.write() that requires this file that I can't put in .wait()). If all files are in cache, the code \"alert(0)\" is not executed.\n. I've reread the [queuing](https://gist.github.com/704226) code snipset, but sorry I can't figure how to use it in my case.\n\nI don't want (or it is impossible) to load all scripts with LABjs. There is an inline JS block that I can't put in .wait() because of document.write(). This inline block requires an external script. Thus I have to load this external script in the traditional way.\n. That helps much! I try with queuing and it works. The conclusion could be we shouldn't use `var _lab = $LAB...` because it is not stable. About the `document.write()`, that's Google and I don't bother to tell...\n\nThe working code is as follow, I try to make it more comprehensive:\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <head><title>TTCN D7 test</title>\n    <script type=\"text/javascript\" src=\"http://d7.ttcn/LAB.min.js\"></script>\n    <script type=\"text/javascript\">$LAB.setGlobalDefaults({AlwaysPreserveOrder:true});</script>\n    <script>\n    $LAB.queue(\"http://d7.ttcn/file1.js\");\n    $LAB.queue(\"http://d7.ttcn/file2.js\");\n    </script>\n    <script type=\"text/javascript\" src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n    <script type=\"text/javascript\">\n    $LAB.queue(function() {\n      // do some good thing\n    });\n    </script>\n    </head>\n    <body>\n    Test\n    <script type=\"text/javascript\">\n      // this is evil, and it requires google_service.js\n      // it calls a function to add more JS file and do some document.write()\n    </script>\n    <script type=\"text/javascript\">$LAB.executeQueue();</script>\n    </body>\n    </html>\nMy approach to rewrite a JavaScript is to verify if there is a comment `// LABjs exclude` at the begin, that way it get a great penetration with zero conf for mostly other modules.\n\nThen when will the queuing functionality officially get in? ;-)\n. I've just changed the code a little to reflect more correctly the reality. I can add a code right after loading of core.js to override the autorun() function (it's a method in an object). But with the race condition, that overriding might happen after domready!\n\nIf I replace the domready() of jQuery (add my code before between jquery.js and core.js), that will help. But then the only benefice is loading scripts in parallel, as my own domready only fires after all scripts is loaded, to make sure that my List is complete.\n. Sorry that my code was wrong. I was using .queue() and I forgot when converted it into .script() and .wait().\n\nThen that looks like that I should follow the more difficult way. Thanks!\n. Another issue that I forgot to mention (the old queueing system also had this problem): scripts are not loaded until there is a $LAB.runQueue(). In some heavy websites (usually those who need LABjs), the delay is a few seconds because there is dozens of ads banner to load between the first $LAB.queueScript() and the $LAB.runQueue().\n. Thanks for the clarification. For the first problem, it's ok. For the second, I always think that LABjs should load script right after $LAB.queueScript(). When there is a $LAB.queueScript(), there is always (or almost) a $LAB.executeQueue() later. So, why don't load that script ahead?\n\nThe problem with $LAB.script().wait() is that it loads script right away, but also executes it. If there is only one chain, it's ok. But if there are many, and as they are independant (with LABjs 1.x, and I've just tested with 2.x it's the same), there is no way to control script execution order between chains.\n. > The problem is it is not possible to load a script but not execute it\n\nIt means that since 2.0 we can't load script without immediate execution? Does it means something like:\n    $LAB.script('script1.js').wait.script(script2.js').wait();\nwon't load script2.js until script1.js is executed?\n\nIf it is the case, LABjs is then non blocking but could be slower, because many browsers preload scripts, and LABjs does not.\n. Yes, that's the point I wanted to make ;-) And it means I don't understand what you said.\n\nBrief (suppose that we have global setting for preserving order):\n    $LAB.script('script1.js').script(script2.js');\nwill load in parallel and execute in correct order.\n\nBut:\n    $LAB.queueScript('script1.js');\n    $LAB.queueScript('script2.js');\n    $LAB.executeQueue();\ndoes the same, but it only starts its job after the executeQueue()? Because there is no way to let the scripts loaded first and executed only after executeQueue()? Then in that case, the LABjs could be slower. Because scripts are loaded (then executed) only after almost the webpage is executed and rendered.\n\nWhat's a pity, but I understand there is no choice. About:\n\n> because someone might define several queues of scripts but only load one of them\n> It's too complex and I can't see any use case.\n. > I don't understand why you want queueing to start loading right away? $LAB chains start loading right away. So use them instead.\n\nI can't use chaining because there are chains everywhere, also there are inline script in chains. Because chains are independant, I must use queueing to order the execution across chains.\n\nIf it is impossible, then I think I should use buffer to aggregate all scripts in one chain and put it in <head>.\n. I've just tried with Firefox 5 (Kubuntu 11.04) and discovered a problem: scripts are not executed in parallel. Test:\n\ntest.js\n\n```\nconsole.log(\"test.js\");\n```\n\ntest2.js\n\n```\nconsole.log(\"test2.js start\");var now = new Date().getTime();\nvar x=[];for (var k=1;k<20000000;k++){x[k]=k;}\nconsole.log(\"test2.js end \" + (new Date().getTime() - now));\n```\n\ntest.html\n\n```\n<!DOCTYPE html>\n<html>\n<head><title>Create Article | drupal d7a</title>\n<script type=\"text/javascript\" src=\"http://drupal/d7a/sites/all/libraries/labjs/LAB.min.js?lokmmn\"></script>\n<script type=\"text/javascript\">\n$LAB.script(\"http://drupal/test2.js\").script(\"http://drupal/test.js\");\n</script>\n</head>\n<body>Blabla</body>\n</html>\n```\n\nWe can look at the console log and see that test.js is only executed after test2.js completes. But that's another problem. The one that I tries to make it work here is: change from\n\n```\n$LAB.script(\"http://drupal/test2.js\").script(\"http://drupal/test.js\");\n```\n\nto\n\n```\n$LAB.script(\"http://drupal/test2.js\").wait(function() {console.log('right after test2.js');}).script(\"http://drupal/test.js\");\n```\n\nThe code in wait() is executed after test.js, that's not what I want. In general, how to order scripts and inline blocks, in this case test.js depends on the inline block that does some initialization.\n\nThanks!\n. Hello,\n\nHave you got any hint?\n. In your example, I replace it with\n\n```\n<script type=\"text/javascript\" src=\"https://raw.github.com/getify/LABjs/master/LAB.js\"></script>\n<script type=\"text/javascript\" src=\"https://www.google.com/jsapi\"></script>\n<script type=\"text/javascript\" src=\"./labtest.js\"></script>\n```\n\nand it does not work. So maybe it is not LABjs problem at all, but the problem with putting google.load in a JS file.\n. I think it is not necessary and it make LABjs bigger, unless it is optional and LABjs is modularized. To debug, just use Firebug (or Webkit Developer Tools), disable cache and you'll get a list of loaded scripts.\n. Thanks, Kyle, that works.\n\nAbout the queuing, I can't use it. Developers put inline JS everywhere. I can grab all JS files and put in one chain without side effect, but for inline JS blocks, it's more difficult. However, I'll do more test about merging all inline JS blocks.\n. Anyway, is it better to have an event callback like this?\n    $LAB.ready(function() {\n      // code will be executed when all scripts are executed\n      // ...\n    });\nIt is like _lab.wait() but we can have many $LAB.script().script()... chains.\n. When I think about $LAB.ready(), I suppose that there is no $LAB.script() inside it. I didn't thought about the case when there is a $LAB.script() after a $LAB.ready(). Indeed, I thought that the browser is fast enough (or there is a small delay before $LAB.ready()) so that all $LAB.script() are called (that mean LABjs knows all scripts in the page) before $LAB.ready().\n\nWhen you ask about this case, I know that I'm wrong ;-) because your decision is \"as fast as the browser will allow\", then there is no delay... But I wonder if a few ms delay for $LAB.ready() could be enough so that all $LAB.script() are called before .ready()?\n\nIn a page there are many JS: some is in header, some is in footer, some is in the content for inline ads (the availability of JS depends on content, not on page, not all content have ads). But in fact I can postprocess to consolidate all JS file in one call, reorder JS (normally ads JS does not depend on other JS, thus it is placed 1st). So, currently I don't have any use case for multiple chain, it's just for convenient.\n\nThanks for your help. FYI I've created a new project page to enable LABjs in Drupal automatically http://drupal.org/project/labjs . Version for Drupal 7 was out, for Drupal 6 is coming soon. Maybe there will be more use cases.\n. The following code doesnot work:\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <head><title>TTCN D7 test</title>\n    <script type=\"text/javascript\" src=\"http://d7.ttcn/sites/all/libraries/labjs/LAB.min.js?lenopg\"></script>\n    <script type=\"text/javascript\">\n    var _lab = $LAB\n    .setOptions({AlwaysPreserveOrder:true})\n    .script(\"http://d7.ttcn/file1.js\");\n    </script>\n    <script type=\"text/javascript\" src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n    <script type=\"text/javascript\">\n    _lab.wait(function() {\n      alert(0);\n    });\n    </script>\n    </head>\n    <body>Test</body>\n    </html>\nI load all scripts with LABjs, but not google_server.js (I want it to be blocking one, and there are ads block with document.write() that requires this file that I can't put in .wait()). If all files are in cache, the code \"alert(0)\" is not executed.\n. I've reread the [queuing](https://gist.github.com/704226) code snipset, but sorry I can't figure how to use it in my case.\n\nI don't want (or it is impossible) to load all scripts with LABjs. There is an inline JS block that I can't put in .wait() because of document.write(). This inline block requires an external script. Thus I have to load this external script in the traditional way.\n. That helps much! I try with queuing and it works. The conclusion could be we shouldn't use `var _lab = $LAB...` because it is not stable. About the `document.write()`, that's Google and I don't bother to tell...\n\nThe working code is as follow, I try to make it more comprehensive:\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <head><title>TTCN D7 test</title>\n    <script type=\"text/javascript\" src=\"http://d7.ttcn/LAB.min.js\"></script>\n    <script type=\"text/javascript\">$LAB.setGlobalDefaults({AlwaysPreserveOrder:true});</script>\n    <script>\n    $LAB.queue(\"http://d7.ttcn/file1.js\");\n    $LAB.queue(\"http://d7.ttcn/file2.js\");\n    </script>\n    <script type=\"text/javascript\" src=\"http://partner.googleadservices.com/gampad/google_service.js\"></script>\n    <script type=\"text/javascript\">\n    $LAB.queue(function() {\n      // do some good thing\n    });\n    </script>\n    </head>\n    <body>\n    Test\n    <script type=\"text/javascript\">\n      // this is evil, and it requires google_service.js\n      // it calls a function to add more JS file and do some document.write()\n    </script>\n    <script type=\"text/javascript\">$LAB.executeQueue();</script>\n    </body>\n    </html>\nMy approach to rewrite a JavaScript is to verify if there is a comment `// LABjs exclude` at the begin, that way it get a great penetration with zero conf for mostly other modules.\n\nThen when will the queuing functionality officially get in? ;-)\n. I've just changed the code a little to reflect more correctly the reality. I can add a code right after loading of core.js to override the autorun() function (it's a method in an object). But with the race condition, that overriding might happen after domready!\n\nIf I replace the domready() of jQuery (add my code before between jquery.js and core.js), that will help. But then the only benefice is loading scripts in parallel, as my own domready only fires after all scripts is loaded, to make sure that my List is complete.\n. Sorry that my code was wrong. I was using .queue() and I forgot when converted it into .script() and .wait().\n\nThen that looks like that I should follow the more difficult way. Thanks!\n. Another issue that I forgot to mention (the old queueing system also had this problem): scripts are not loaded until there is a $LAB.runQueue(). In some heavy websites (usually those who need LABjs), the delay is a few seconds because there is dozens of ads banner to load between the first $LAB.queueScript() and the $LAB.runQueue().\n. Thanks for the clarification. For the first problem, it's ok. For the second, I always think that LABjs should load script right after $LAB.queueScript(). When there is a $LAB.queueScript(), there is always (or almost) a $LAB.executeQueue() later. So, why don't load that script ahead?\n\nThe problem with $LAB.script().wait() is that it loads script right away, but also executes it. If there is only one chain, it's ok. But if there are many, and as they are independant (with LABjs 1.x, and I've just tested with 2.x it's the same), there is no way to control script execution order between chains.\n. > The problem is it is not possible to load a script but not execute it\n\nIt means that since 2.0 we can't load script without immediate execution? Does it means something like:\n    $LAB.script('script1.js').wait.script(script2.js').wait();\nwon't load script2.js until script1.js is executed?\n\nIf it is the case, LABjs is then non blocking but could be slower, because many browsers preload scripts, and LABjs does not.\n. Yes, that's the point I wanted to make ;-) And it means I don't understand what you said.\n\nBrief (suppose that we have global setting for preserving order):\n    $LAB.script('script1.js').script(script2.js');\nwill load in parallel and execute in correct order.\n\nBut:\n    $LAB.queueScript('script1.js');\n    $LAB.queueScript('script2.js');\n    $LAB.executeQueue();\ndoes the same, but it only starts its job after the executeQueue()? Because there is no way to let the scripts loaded first and executed only after executeQueue()? Then in that case, the LABjs could be slower. Because scripts are loaded (then executed) only after almost the webpage is executed and rendered.\n\nWhat's a pity, but I understand there is no choice. About:\n\n> because someone might define several queues of scripts but only load one of them\n> It's too complex and I can't see any use case.\n. > I don't understand why you want queueing to start loading right away? $LAB chains start loading right away. So use them instead.\n\nI can't use chaining because there are chains everywhere, also there are inline script in chains. Because chains are independant, I must use queueing to order the execution across chains.\n\nIf it is impossible, then I think I should use buffer to aggregate all scripts in one chain and put it in <head>.\n. I've just tried with Firefox 5 (Kubuntu 11.04) and discovered a problem: scripts are not executed in parallel. Test:\n\ntest.js\n\n```\nconsole.log(\"test.js\");\n```\n\ntest2.js\n\n```\nconsole.log(\"test2.js start\");var now = new Date().getTime();\nvar x=[];for (var k=1;k<20000000;k++){x[k]=k;}\nconsole.log(\"test2.js end \" + (new Date().getTime() - now));\n```\n\ntest.html\n\n```\n<!DOCTYPE html>\n<html>\n<head><title>Create Article | drupal d7a</title>\n<script type=\"text/javascript\" src=\"http://drupal/d7a/sites/all/libraries/labjs/LAB.min.js?lokmmn\"></script>\n<script type=\"text/javascript\">\n$LAB.script(\"http://drupal/test2.js\").script(\"http://drupal/test.js\");\n</script>\n</head>\n<body>Blabla</body>\n</html>\n```\n\nWe can look at the console log and see that test.js is only executed after test2.js completes. But that's another problem. The one that I tries to make it work here is: change from\n\n```\n$LAB.script(\"http://drupal/test2.js\").script(\"http://drupal/test.js\");\n```\n\nto\n\n```\n$LAB.script(\"http://drupal/test2.js\").wait(function() {console.log('right after test2.js');}).script(\"http://drupal/test.js\");\n```\n\nThe code in wait() is executed after test.js, that's not what I want. In general, how to order scripts and inline blocks, in this case test.js depends on the inline block that does some initialization.\n\nThanks!\n. Hello,\n\nHave you got any hint?\n. In your example, I replace it with\n\n```\n<script type=\"text/javascript\" src=\"https://raw.github.com/getify/LABjs/master/LAB.js\"></script>\n<script type=\"text/javascript\" src=\"https://www.google.com/jsapi\"></script>\n<script type=\"text/javascript\" src=\"./labtest.js\"></script>\n```\n\nand it does not work. So maybe it is not LABjs problem at all, but the problem with putting google.load in a JS file.\n. I think it is not necessary and it make LABjs bigger, unless it is optional and LABjs is modularized. To debug, just use Firebug (or Webkit Developer Tools), disable cache and you'll get a list of loaded scripts.\n. ",
    "paulwalker": "This is one feature I appreciate with $script.js.  It would be nice to allow a callback as second argument or named option to wait that is executed whenever the \"success\" callback is not called.\n\n```\nfunction(init) {\n$LAB\n.script('//ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js')\n.wait(init, function() { // fallback to local on fail\n    $LAB\n    .script('/js/jquery-1.5.2.min.js')\n    .wait(init);\n});\n})(function() {\n$LAB.script('/js/script.js');\n});\n```\n. This is one feature I appreciate with $script.js.  It would be nice to allow a callback as second argument or named option to wait that is executed whenever the \"success\" callback is not called.\n\n```\nfunction(init) {\n$LAB\n.script('//ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js')\n.wait(init, function() { // fallback to local on fail\n    $LAB\n    .script('/js/jquery-1.5.2.min.js')\n    .wait(init);\n});\n})(function() {\n$LAB.script('/js/script.js');\n});\n```\n. ",
    "outaTiME": "Hi agaaain =)\n\nwhat about of the use of script error event (http://www.quirksmode.org/dom/events/error.html) and notify how many files was loaded success and how many fails ... what do you think with that ?? \n\n``` js\n$LAB\n  .script(\n    [\n      '//www.google.com/resource1.js',\n      '//www.google.com/resource2.js',\n      '//www.google.com/resource3.js',\n      '//www.google.com/resource4.js'\n    ])\n  .wait(\n    function (success, fail) {\n      if (fail > 0) {\n        console.warn('%s file(s) have failed to load', fail);\n      }\n    }\n  );\n```\n\ni need some way to detect bad resource loading (like http codes 404, 502, 500) ...\n\nthks !\n. yup, you are right but if will be a great feature for those using newer browsers (like me ^^) ...\nnot be possible to put some optional flag or a note saying that the feature only works in certain browsers ?? \n. Hi agaaain =)\n\nwhat about of the use of script error event (http://www.quirksmode.org/dom/events/error.html) and notify how many files was loaded success and how many fails ... what do you think with that ?? \n\n``` js\n$LAB\n  .script(\n    [\n      '//www.google.com/resource1.js',\n      '//www.google.com/resource2.js',\n      '//www.google.com/resource3.js',\n      '//www.google.com/resource4.js'\n    ])\n  .wait(\n    function (success, fail) {\n      if (fail > 0) {\n        console.warn('%s file(s) have failed to load', fail);\n      }\n    }\n  );\n```\n\ni need some way to detect bad resource loading (like http codes 404, 502, 500) ...\n\nthks !\n. yup, you are right but if will be a great feature for those using newer browsers (like me ^^) ...\nnot be possible to put some optional flag or a note saying that the feature only works in certain browsers ?? \n. ",
    "JAAulde": "How consistent is the exception object from browser to browser for run time messages? In Firefox you get file, line, stack, etc. If there is enough info between the browsers you could log as much as possible to help us find line, etc. I also thought about a config option that lets us ask the whole stack to quit on error.\n. How consistent is the exception object from browser to browser for run time messages? In Firefox you get file, line, stack, etc. If there is enough info between the browsers you could log as much as possible to help us find line, etc. I also thought about a config option that lets us ask the whole stack to quit on error.\n. ",
    "frosas": "Does it mean we have to run LABjs in debug mode in production if we don't want errors to be swallowed? \n\nWhat about simply throwing the error outside of the chain? E.g. with a `setTimeout(function() { throw error }, 0)`. It would pretty much mimic the behavior when using `<script>` (i.e. an \"uncaught error\" is thrown, having the option to use `window.onerror` to track it). Check this for a comparison: [`<script>`](http://jsfiddle.net/9LRDX/2/) vs [LABjs](http://jsfiddle.net/6v625/1/).\n. Sorry if I'm not nicer in the following lines, it's late and I'm tired so I'll try go straight to the point(s).\n\n> You should not have errors as a matter of practice in production. If you have errors, you should have a way to find and FIX them, not a way to find and IGNORE them. That's the philosophy applied here. That's why LABjs comes with this optional debug build. Moreover, as explained in the thread above, LABjs' assumption is that by default, developers don't want errors leaking out into the consoles in production.\n\nI must have expressed very bad if you understood I'm trying to hide any error, cause my goal it's exactly the opposite.\n\nI'm not going to argue whether hiding errors is what you want to do by default (but probably you're already guessing I think this is just a bad programming practice). But please, tell me, how I'm supposed to know whether I'm having errors in production if queueWait() is hiding them? As said before, am I supposed to run LABjs in debug mode in production the whole time in order to achieve this?\n\n> Moreover, there's a simple fix to this problem which doesn't involve changing your LABjs file nor enabling a mode. It's putting your own try..catch error handling (or other robust feature testing!) around any code which, you know, might actually error if something's missing. I would suggest avoiding writing code which can error, and being more robust yourself. But to whatever extent that's not possible, it then becomes your responsibility to do the extra work to use LABjs' debug build to find and fix such errors.\n\nThanks for recommending me to don't write faulty code, it's something I already try to do, but not even with all the tests in the world one can avoid sh*t happening in unpredictable ways with any of the millions of users we currently have.\n\nRegarding to your suggestion of using try/catch, currently I'm working in monkey patching LABjs in the following way:\n\n``` js\n(function() {\n  var originalQueueWait = $LAB.queueWait;\n  $LAB.queueWait = function(callback) {\n    return originalQueueWait.call($LAB, function() {\n      try {\n        callback();\n      } catch (error) {\n        setTimeout(function() { throw error; }, 0);\n      }\n    });\n  };\n})();\n```\n\n> Example: Don't just use $ assuming it's there, and let an error happen. Test if it's there first:\n\nI really hope I'll never have to write such a defensive code! Compare it to the following (considering LABjs whould be throwing the errors):\n\n``` js\nonerror = function(message, file, line, column, error) {\n  logErrorToServer(error && error.message || error || message);\n  ShowPoliteErrorMessageToUser();\n};\n```\n\nI'm not saying this is the best approach for any given case but this would act as a good enough safety net for 99% of the cases.\n\n> I would remind you, you should avoid having very much code in .wait(..) callbacks. If it's more than a few lines here or there, you should consider moving that code into its own file, where the \"error handling\" (aka suppression) that LABjs does won't hurt you. Then you'll only have a few .wait(..) lines to worry about with errors and debug modes and builds and such.\n\nPlease, consider this example:\n\n``` js\n$LAB.script('main.js').wait(function() {\n  someFunctionInMainJs();\n});\n```\n\nEven in this minimalistic `wait()` callback thousands of instructions can be executed because of it, so I'm afraid I can't just \"avoid having much code in it\".\n\nAnd now I see you're proposing to move my code to its own file a new question comes to my mind. Why such a different error handling between `script()` and `wait()`?\n\nHope I've been clearer this time!\n. Does it mean we have to run LABjs in debug mode in production if we don't want errors to be swallowed? \n\nWhat about simply throwing the error outside of the chain? E.g. with a `setTimeout(function() { throw error }, 0)`. It would pretty much mimic the behavior when using `<script>` (i.e. an \"uncaught error\" is thrown, having the option to use `window.onerror` to track it). Check this for a comparison: [`<script>`](http://jsfiddle.net/9LRDX/2/) vs [LABjs](http://jsfiddle.net/6v625/1/).\n. Sorry if I'm not nicer in the following lines, it's late and I'm tired so I'll try go straight to the point(s).\n\n> You should not have errors as a matter of practice in production. If you have errors, you should have a way to find and FIX them, not a way to find and IGNORE them. That's the philosophy applied here. That's why LABjs comes with this optional debug build. Moreover, as explained in the thread above, LABjs' assumption is that by default, developers don't want errors leaking out into the consoles in production.\n\nI must have expressed very bad if you understood I'm trying to hide any error, cause my goal it's exactly the opposite.\n\nI'm not going to argue whether hiding errors is what you want to do by default (but probably you're already guessing I think this is just a bad programming practice). But please, tell me, how I'm supposed to know whether I'm having errors in production if queueWait() is hiding them? As said before, am I supposed to run LABjs in debug mode in production the whole time in order to achieve this?\n\n> Moreover, there's a simple fix to this problem which doesn't involve changing your LABjs file nor enabling a mode. It's putting your own try..catch error handling (or other robust feature testing!) around any code which, you know, might actually error if something's missing. I would suggest avoiding writing code which can error, and being more robust yourself. But to whatever extent that's not possible, it then becomes your responsibility to do the extra work to use LABjs' debug build to find and fix such errors.\n\nThanks for recommending me to don't write faulty code, it's something I already try to do, but not even with all the tests in the world one can avoid sh*t happening in unpredictable ways with any of the millions of users we currently have.\n\nRegarding to your suggestion of using try/catch, currently I'm working in monkey patching LABjs in the following way:\n\n``` js\n(function() {\n  var originalQueueWait = $LAB.queueWait;\n  $LAB.queueWait = function(callback) {\n    return originalQueueWait.call($LAB, function() {\n      try {\n        callback();\n      } catch (error) {\n        setTimeout(function() { throw error; }, 0);\n      }\n    });\n  };\n})();\n```\n\n> Example: Don't just use $ assuming it's there, and let an error happen. Test if it's there first:\n\nI really hope I'll never have to write such a defensive code! Compare it to the following (considering LABjs whould be throwing the errors):\n\n``` js\nonerror = function(message, file, line, column, error) {\n  logErrorToServer(error && error.message || error || message);\n  ShowPoliteErrorMessageToUser();\n};\n```\n\nI'm not saying this is the best approach for any given case but this would act as a good enough safety net for 99% of the cases.\n\n> I would remind you, you should avoid having very much code in .wait(..) callbacks. If it's more than a few lines here or there, you should consider moving that code into its own file, where the \"error handling\" (aka suppression) that LABjs does won't hurt you. Then you'll only have a few .wait(..) lines to worry about with errors and debug modes and builds and such.\n\nPlease, consider this example:\n\n``` js\n$LAB.script('main.js').wait(function() {\n  someFunctionInMainJs();\n});\n```\n\nEven in this minimalistic `wait()` callback thousands of instructions can be executed because of it, so I'm afraid I can't just \"avoid having much code in it\".\n\nAnd now I see you're proposing to move my code to its own file a new question comes to my mind. Why such a different error handling between `script()` and `wait()`?\n\nHope I've been clearer this time!\n. ",
    "sajal": "just added the .wait()\nim saying that there is ~50ms delay between the start of each script after the one before it has started.\n    <script type=\"text/javascript\">\n      var asyncjsscripts = [];\n      asyncjsscripts.push('http://mediacdn.disqus.com/1298421702/build/system/embed.js');\n      asyncjsscripts.push('http://platform.twitter.com/widgets.js');\n      asyncjsscripts.push('http://www.google-analytics.com/ga.js');\n      asyncjsscripts.push('http://connect.facebook.net/en_US/all.js#xfbml=1');\n      asyncjsscripts.push('http://static.poptattle.com/js/trafficpace.js');\n      asyncjsscripts.push('http://mediacdn.disqus.com/1298421702/build/system/count.js');\n    </script>\nI use the async snippet from https://gist.github.com/603980\nmy function f() from line 5 reads as:-\n    function f(){  \n      $LAB.script(asyncjsscripts).wait();\n    }\n\nhttp://www.webpagetest.org/result/110228_4D_3bb68ed39c46b859b9a84778f4c530a9/5/details/ (see #8 to #13)\n\nInternet Explorer 7(and 9) does not have this issue, they start downloading as soon as a download slot is available in the browser.\n. Thanks for your replies. On poking further it looks like a bug in webpagetest.org...\nive posted it here http://www.webpagetest.org/forums/showthread.php?tid=558\n\nBasically the tcpdump shows that the requests are made instantly as expected.. so its not a LABjs issue..\n. why not?\n\n```\n... <div id='important'></div> ....\n\n<script>\n$LAB.script('framework.js').wait(function(){\n    do_stuff();\n});\n</script>\n```\n. just added the .wait()\nim saying that there is ~50ms delay between the start of each script after the one before it has started.\n    <script type=\"text/javascript\">\n      var asyncjsscripts = [];\n      asyncjsscripts.push('http://mediacdn.disqus.com/1298421702/build/system/embed.js');\n      asyncjsscripts.push('http://platform.twitter.com/widgets.js');\n      asyncjsscripts.push('http://www.google-analytics.com/ga.js');\n      asyncjsscripts.push('http://connect.facebook.net/en_US/all.js#xfbml=1');\n      asyncjsscripts.push('http://static.poptattle.com/js/trafficpace.js');\n      asyncjsscripts.push('http://mediacdn.disqus.com/1298421702/build/system/count.js');\n    </script>\nI use the async snippet from https://gist.github.com/603980\nmy function f() from line 5 reads as:-\n    function f(){  \n      $LAB.script(asyncjsscripts).wait();\n    }\n\nhttp://www.webpagetest.org/result/110228_4D_3bb68ed39c46b859b9a84778f4c530a9/5/details/ (see #8 to #13)\n\nInternet Explorer 7(and 9) does not have this issue, they start downloading as soon as a download slot is available in the browser.\n. Thanks for your replies. On poking further it looks like a bug in webpagetest.org...\nive posted it here http://www.webpagetest.org/forums/showthread.php?tid=558\n\nBasically the tcpdump shows that the requests are made instantly as expected.. so its not a LABjs issue..\n. why not?\n\n```\n... <div id='important'></div> ....\n\n<script>\n$LAB.script('framework.js').wait(function(){\n    do_stuff();\n});\n</script>\n```\n. ",
    "scriptninja": "With your reassurances and further explanation, it is easier now for me to see that the context of the comment in which you said multiple chains were to be avoided was indeed concerned with cross-thread interdependence. That is very reassuring. And while my own thought process had not gotten that far, your explanation that appending to a chain before it has finished executing should work makes my use case trivial to support; I don't even need to add a separate flag in this particular case...all I need to do is check for the existence of the library function; I can set up the events immediately if it's there, append to the chain that is loading the library otherwise.\n\nIn light of your explanations, I think you could cover the specific points I brought up pretty easily. If you added to the documentation (perhaps rephrased) this passage from your response to me:\n\n> Multiple $LAB chains are perfectly fine, and are encouraged. What is not fine, and is \n> discouraged, is using the \"AllowDuplicates:false\" feature and relying on that across \n> multiple chains. As several of the comments/issues threads reveal, this is not \n> reliable. It's a major design goal of 2.0 to fix that. I just simply never considered in \n> 1.x dev that this would be a common use case. Turns out it is.\n\n...and added one simple example in which you set a flag as you describe, then check for it later to determine whether to execute immediately or append to the chain (with the note that appending to an already-completed chain is unsupported behavior, and may not continue to work even if it currently does), I think you'd have covered both points sufficiently for most people. Certainly sufficiently for me.\n\nOn the other hand, depending on how close the 2.0 release looms, this issue and its comments...and the explicit mention I'm making now that this conversation took place at version 1.2...may be plenty. I'm inclined to think that the target audience of LABjs is probably largely composed of people who would find this if they ran into any difficulty.\n. With your reassurances and further explanation, it is easier now for me to see that the context of the comment in which you said multiple chains were to be avoided was indeed concerned with cross-thread interdependence. That is very reassuring. And while my own thought process had not gotten that far, your explanation that appending to a chain before it has finished executing should work makes my use case trivial to support; I don't even need to add a separate flag in this particular case...all I need to do is check for the existence of the library function; I can set up the events immediately if it's there, append to the chain that is loading the library otherwise.\n\nIn light of your explanations, I think you could cover the specific points I brought up pretty easily. If you added to the documentation (perhaps rephrased) this passage from your response to me:\n\n> Multiple $LAB chains are perfectly fine, and are encouraged. What is not fine, and is \n> discouraged, is using the \"AllowDuplicates:false\" feature and relying on that across \n> multiple chains. As several of the comments/issues threads reveal, this is not \n> reliable. It's a major design goal of 2.0 to fix that. I just simply never considered in \n> 1.x dev that this would be a common use case. Turns out it is.\n\n...and added one simple example in which you set a flag as you describe, then check for it later to determine whether to execute immediately or append to the chain (with the note that appending to an already-completed chain is unsupported behavior, and may not continue to work even if it currently does), I think you'd have covered both points sufficiently for most people. Certainly sufficiently for me.\n\nOn the other hand, depending on how close the 2.0 release looms, this issue and its comments...and the explicit mention I'm making now that this conversation took place at version 1.2...may be plenty. I'm inclined to think that the target audience of LABjs is probably largely composed of people who would find this if they ran into any difficulty.\n. ",
    "asuth": "Because I want to get framework.js starting to load before all that HTML happens. I `<?php flush() ?>` the `<head>` to the user early and they can start loading scripts with that, then more html gets printed, then I want to do_stuff().\n. because document.ready may take awhile to fire, and I want to control when do_stuff() happens...furthermore, the point of this is decoupling the functions you call for a given dependency from the actual loading of them. So when I call script('framework.js') I don't actually know whether or not I will want to call do_stuff() later in the page.\n. Thanks for the well-thought-out response.\n1. `document.ready` can actually take a long time. We have pages that can take awhile to render, but because we flush() html incrementally, people can actually use the page before domready fires.\n2. Assuming DOM elements are usable: I was aware of some issues with unclosed elements and IE6, but nothing else. We don't support IE6 anymore (~1% of traffic). What else is there? Because DOM ready is a lot of hocus-pocus in the major implementations anyway, it doesn't seem like it should make a big difference. You may have more experience than I do with this...What bugs have you seen?\n3. Hmm...Maybe we don't understand each other. I want to couple inline scripts to external scripts and make them fire in the correct order. That is definitely my goal. However, I don't want to have to place my inline scripts in the same place as my LABjs code. It seems to me I should still be able to have the labjs semantics of firing in the correct order but without putting all the code in the same place. It's easy to hack what I want by saying:\n   \n   ```\n   FrameReady = [];\n   $LAB.script('framework.js').wait(function() {\n       FrameReady.each(function(func) { func() });\n       FrameReady = { push : function(func) { func(); };\n   });\n   ```\n\nThen anywhere I want I can say `FrameReady.push(do_stuff)` and have it fire either instantly if framework.js is loaded or if not, as soon as it does load. However, I don't want to write this code for any given $LAB.script() load.\n. I came up with my own general solution along the lines of #3 from my post above. If I get around to it I'll blog it.\n. Also, minor: closure compiler has been updated, and gets slightly better compression over what you have now in LAB.min.js\n. We've been frequently seeing something like this. I built a debug tool to detect when DOM doesn't fire after 15 seconds, and we're getting thousands of requests where DOM doesn't fire in this time frame, even though it appears all of our js has come in. We're seeing this across webkit, FF4 and IE. We're also using mootools, not jquery. We also added a backup that if domready never fired, at least window.onload would, and that helped in some cases but not all. How should we go about debugging this? FYI this is LAB 1.2\n. +1 really would love this, been having problems with JS failures with our CDN.\n. Because I want to get framework.js starting to load before all that HTML happens. I `<?php flush() ?>` the `<head>` to the user early and they can start loading scripts with that, then more html gets printed, then I want to do_stuff().\n. because document.ready may take awhile to fire, and I want to control when do_stuff() happens...furthermore, the point of this is decoupling the functions you call for a given dependency from the actual loading of them. So when I call script('framework.js') I don't actually know whether or not I will want to call do_stuff() later in the page.\n. Thanks for the well-thought-out response.\n1. `document.ready` can actually take a long time. We have pages that can take awhile to render, but because we flush() html incrementally, people can actually use the page before domready fires.\n2. Assuming DOM elements are usable: I was aware of some issues with unclosed elements and IE6, but nothing else. We don't support IE6 anymore (~1% of traffic). What else is there? Because DOM ready is a lot of hocus-pocus in the major implementations anyway, it doesn't seem like it should make a big difference. You may have more experience than I do with this...What bugs have you seen?\n3. Hmm...Maybe we don't understand each other. I want to couple inline scripts to external scripts and make them fire in the correct order. That is definitely my goal. However, I don't want to have to place my inline scripts in the same place as my LABjs code. It seems to me I should still be able to have the labjs semantics of firing in the correct order but without putting all the code in the same place. It's easy to hack what I want by saying:\n   \n   ```\n   FrameReady = [];\n   $LAB.script('framework.js').wait(function() {\n       FrameReady.each(function(func) { func() });\n       FrameReady = { push : function(func) { func(); };\n   });\n   ```\n\nThen anywhere I want I can say `FrameReady.push(do_stuff)` and have it fire either instantly if framework.js is loaded or if not, as soon as it does load. However, I don't want to write this code for any given $LAB.script() load.\n. I came up with my own general solution along the lines of #3 from my post above. If I get around to it I'll blog it.\n. Also, minor: closure compiler has been updated, and gets slightly better compression over what you have now in LAB.min.js\n. We've been frequently seeing something like this. I built a debug tool to detect when DOM doesn't fire after 15 seconds, and we're getting thousands of requests where DOM doesn't fire in this time frame, even though it appears all of our js has come in. We're seeing this across webkit, FF4 and IE. We're also using mootools, not jquery. We also added a backup that if domready never fired, at least window.onload would, and that helped in some cases but not all. How should we go about debugging this? FYI this is LAB 1.2\n. +1 really would love this, been having problems with JS failures with our CDN.\n. ",
    "wikt0r": "Thank you for you quick answer, and specially for the workarounds. I choose the third option, I hope I can manage the rewrite. :)\n\nThank you again!\n. Thank you for you quick answer, and specially for the workarounds. I choose the third option, I hope I can manage the rewrite. :)\n\nThank you again!\n. ",
    "amasad": "Is there anyway around this, like what you are doing with the XHR, to get the responseText then slap a script tag with the attributes around it? in my case the templates are local.\n. I see,\nI totally understand why the library should be focused and small, thats why I use it.\nThanks.\n. I like LABjs for being small and straight to the point. I'd hate it if lots of features like this one would creep in and make it as bloated as other script loaders. \nMaybe making LABjs extensible or better yet having another branch that is feature rich would solve the problem, but for now I like it the way it is.\n. Is there anyway around this, like what you are doing with the XHR, to get the responseText then slap a script tag with the attributes around it? in my case the templates are local.\n. I see,\nI totally understand why the library should be focused and small, thats why I use it.\nThanks.\n. I like LABjs for being small and straight to the point. I'd hate it if lots of features like this one would creep in and make it as bloated as other script loaders. \nMaybe making LABjs extensible or better yet having another branch that is feature rich would solve the problem, but for now I like it the way it is.\n. ",
    "rhyolight": "Kyle, I'm not concerned about the script type necessarily, I just want to be able to specify an id for the script tag that LABjs creates for a resource. In fact, it seems reasonable to allow a map of attributes for the script tag.\n\n```\n$LAB.script({src: '/path/to/script.js', type: 'text/whatever', attrs: {id: 'my-id'}});\n```\n\nI don't want LABjs to make any assumptions about what type of script I want to load, I just want to specify the attributes of the script HTMLElement that is appended to the DOM.\n. Kyle, I'm not concerned about the script type necessarily, I just want to be able to specify an id for the script tag that LABjs creates for a resource. In fact, it seems reasonable to allow a map of attributes for the script tag.\n\n```\n$LAB.script({src: '/path/to/script.js', type: 'text/whatever', attrs: {id: 'my-id'}});\n```\n\nI don't want LABjs to make any assumptions about what type of script I want to load, I just want to specify the attributes of the script HTMLElement that is appended to the DOM.\n. ",
    "fbuchinger": "I'd prefer some combined array/console logging like described here: http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/, as IE7 doesn't have a console and in IE8 console.log only seems to work with an open console window.\n\nBy storing the log in an array, i can inspect it later e.g. in a firebug lite session.\n. I could reproduce the bug with lab.js 2.0, but not with 2.0.3 (using Internet Explorer 8 and IIS 7.5). For the test i loaded labjs through labjs using an absolute url path:\n\n```\n<script type=\"text/javascript\">\n    $LAB\n    .setOptions({AlwaysPreserveOrder:true,UseLocalXHR:false})\n    .script(\"/dev/labjstest/js/lab.min.js\")\n</script>\n```\n\nand tracked the requests with fiddler. lab.js 2.0 made a request for `/dev/labjstest/docs//dev/labjstest/js/lab.min.js`, while lab.js 2.0.3 resolved the url correctly: `/dev/labjstest/js/lab.min.js`. \n\nHas this anything to do with the \"IE 8 repair\" in version 2.0.3?\n. I'd prefer some combined array/console logging like described here: http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/, as IE7 doesn't have a console and in IE8 console.log only seems to work with an open console window.\n\nBy storing the log in an array, i can inspect it later e.g. in a firebug lite session.\n. I could reproduce the bug with lab.js 2.0, but not with 2.0.3 (using Internet Explorer 8 and IIS 7.5). For the test i loaded labjs through labjs using an absolute url path:\n\n```\n<script type=\"text/javascript\">\n    $LAB\n    .setOptions({AlwaysPreserveOrder:true,UseLocalXHR:false})\n    .script(\"/dev/labjstest/js/lab.min.js\")\n</script>\n```\n\nand tracked the requests with fiddler. lab.js 2.0 made a request for `/dev/labjstest/docs//dev/labjstest/js/lab.min.js`, while lab.js 2.0.3 resolved the url correctly: `/dev/labjstest/js/lab.min.js`. \n\nHas this anything to do with the \"IE 8 repair\" in version 2.0.3?\n. ",
    "jdalton": "I know IE has a stylesheet limit of smth like ~32. Maybe the same is true for scripts.\n. I'll try to get something together.\n. :sunglasses: \n. I know IE has a stylesheet limit of smth like ~32. Maybe the same is true for scripts.\n. I'll try to get something together.\n. :sunglasses: \n. ",
    "manuelmeurer": "Thanks for the explanation! I will try your suggestions. Would it make sense for LAB.js to have a DisableCaching parameter that automatically adds the cache bust param?\n. I'd definitely vote yes for a \"disable caching\" feature but I don't have enough insight to make a suggestion on how to handle older Webkit browsers, sorry...\n. Thanks for the explanation! I will try your suggestions. Would it make sense for LAB.js to have a DisableCaching parameter that automatically adds the cache bust param?\n. I'd definitely vote yes for a \"disable caching\" feature but I don't have enough insight to make a suggestion on how to handle older Webkit browsers, sorry...\n. ",
    "rixth": "Precisely. I believe this is a relatively common use case.\n. I don't think our use case would be covered by that issue (though I believe the reverse is true).\n\nOur use case is that we release every week, and need a way to bust the cache of our users, but only once. Therefore, we set the AppendPath to the date of the release.\n\nIf you want to do cache-busting in dev, you could set the global AppendPath to Math.random().\n. Precisely. I believe this is a relatively common use case.\n. I don't think our use case would be covered by that issue (though I believe the reverse is true).\n\nOur use case is that we release every week, and need a way to bust the cache of our users, but only once. Therefore, we set the AppendPath to the date of the release.\n\nIf you want to do cache-busting in dev, you could set the global AppendPath to Math.random().\n. ",
    "jaequery": "I think all one needs is a single feature-rich lazy loading js file. This is where I think more is better.\nI don't mind more features on LABjs to be honest. Things like disabling cache, is a good one to have imo as I think it'd save developers a lot of headaches. \nOverall though, I don't think there is a whole lot more that I can think of that should be added, other than me wanting LABjs to load CSS as well. :)\n. I think all one needs is a single feature-rich lazy loading js file. This is where I think more is better.\nI don't mind more features on LABjs to be honest. Things like disabling cache, is a good one to have imo as I think it'd save developers a lot of headaches. \nOverall though, I don't think there is a whole lot more that I can think of that should be added, other than me wanting LABjs to load CSS as well. :)\n. ",
    "trainiac": "I think adding this would be totally useful, especially for the beginners out there. How much weight would this add ~0-500B, meh \n. I think adding this would be totally useful, especially for the beginners out there. How much weight would this add ~0-500B, meh \n. ",
    "Redeeman": "As i see it, this use case is fairly common. not niche at all. lets put some realworld names on this thing.\n\na.js: jquery-1.5.2.js\nb.js: somecaoursel_or_slider.jquery.js\nc.js: lightbox.jquery.js\n\nb.js depends only on a.js\nc.js depends only on a.js\n\ni have multiple pages, most using lightbox and slider/carousel on same page. this is the scenario the example proceeds with.\n\non each of these pages, it is different elements that needs to be activated with the slider and lightbox, in addition, there are callbacks for various events of the sliders/lightbox(IE user cclicks on carousel, or views a lightbox, for whatever reason). The callbacks are also different on a pr-page basis\n\nfeatures of a.js are framework, all my javascript depends on it.\n\nI extend a.js with b.js and c.js to give additional features\n\nb.js and c.js adds unique and separate features. these all have equal importance on my pages.\nb.js and c.js are upstream features, meaning, they are found on CDNs and all sorts of stuff, thousands are using them.\n\nmy choices as of now are these:\n\n1:\nload a.js, block until done\nload b.js, c.js, block until done, execute my code that initiates b.js and c.js features.\n\nthis way, they will both be activated simultaneously, however, this also means that one of the features will inevitably be waiting for the other.\n\n2:\nload a.js, block until done\nload b.js, block until done, load my initiate code\nload c.js, block and load initiate code.\n\n## i have manually decided which feature is most important, and which will be loaded and run first.\n\nI could also combine my initiate code with the b.js and c.js directly, but that would lead to multiple copies for each page, and as far as i see, only downsides compared to 1 and 2.\n\nso my proposal is alterations so that i can add a callback for each script that is executed, and a method of specifying equal priority scripts.\n\nAs to how much realworld performance is gained, i cannot say, however, this is a scenario that hits nearly all jquery/mootools etc using sites, also, the fact that as of now, things are done in a way that screams \"suboptimal\", which to me is very unappealing\n. Hmm, couldnt this possibly be solved for the hosting-yourself case, by xmlhttprequest the items, and then eval them?\n. the xmlhttprequest comment was more of a curiosity question, i also think its bad to have it work only local.\n\nessentially, i dont think this is bad for usability. consider the things its doing here, a slider or carousel, theres no reason one shouldnt start as soon as its done.\n\ni am well aware of the options you mention for doing this, and it is indeed the only way i see of doing it now, allthough i would prefer to do it in the way i specified. nevertheless, if you feel its too much of a hassle for too little good, then okay\n. As i see it, this use case is fairly common. not niche at all. lets put some realworld names on this thing.\n\na.js: jquery-1.5.2.js\nb.js: somecaoursel_or_slider.jquery.js\nc.js: lightbox.jquery.js\n\nb.js depends only on a.js\nc.js depends only on a.js\n\ni have multiple pages, most using lightbox and slider/carousel on same page. this is the scenario the example proceeds with.\n\non each of these pages, it is different elements that needs to be activated with the slider and lightbox, in addition, there are callbacks for various events of the sliders/lightbox(IE user cclicks on carousel, or views a lightbox, for whatever reason). The callbacks are also different on a pr-page basis\n\nfeatures of a.js are framework, all my javascript depends on it.\n\nI extend a.js with b.js and c.js to give additional features\n\nb.js and c.js adds unique and separate features. these all have equal importance on my pages.\nb.js and c.js are upstream features, meaning, they are found on CDNs and all sorts of stuff, thousands are using them.\n\nmy choices as of now are these:\n\n1:\nload a.js, block until done\nload b.js, c.js, block until done, execute my code that initiates b.js and c.js features.\n\nthis way, they will both be activated simultaneously, however, this also means that one of the features will inevitably be waiting for the other.\n\n2:\nload a.js, block until done\nload b.js, block until done, load my initiate code\nload c.js, block and load initiate code.\n\n## i have manually decided which feature is most important, and which will be loaded and run first.\n\nI could also combine my initiate code with the b.js and c.js directly, but that would lead to multiple copies for each page, and as far as i see, only downsides compared to 1 and 2.\n\nso my proposal is alterations so that i can add a callback for each script that is executed, and a method of specifying equal priority scripts.\n\nAs to how much realworld performance is gained, i cannot say, however, this is a scenario that hits nearly all jquery/mootools etc using sites, also, the fact that as of now, things are done in a way that screams \"suboptimal\", which to me is very unappealing\n. Hmm, couldnt this possibly be solved for the hosting-yourself case, by xmlhttprequest the items, and then eval them?\n. the xmlhttprequest comment was more of a curiosity question, i also think its bad to have it work only local.\n\nessentially, i dont think this is bad for usability. consider the things its doing here, a slider or carousel, theres no reason one shouldnt start as soon as its done.\n\ni am well aware of the options you mention for doing this, and it is indeed the only way i see of doing it now, allthough i would prefer to do it in the way i specified. nevertheless, if you feel its too much of a hassle for too little good, then okay\n. ",
    "benekastah": "It is sufficient. I just missed it. Thanks!\n. It is sufficient. I just missed it. Thanks!\n. ",
    "dimkalinux": "In archive LAB.js file is identical with LAB.min.js.\n\nMaybe LAB.js will be \u00abNon-minified version without any debug\u00bb?\n. Reminified is can (maybe) produce problem.\nRegexp is not automaticaly method.\n. Ok. i try to reminification.\n. Thanks.\n\nIdeal case is Lab.src.js without any debug, like in 1.2 version.\nWe cant modify our build scripts (https://github.com/punbb/punbb/tree/master/.dev/build) for adding regexp or skip minified logic.\n. Looks like error happened when page still loading and user click Back button or link to another page.\n. It vary rare error - i can reproduce it only on one host (maybe slow) and in 1 per 10 page loading.\nI thinks it is not bug. Thanks.\n. In archive LAB.js file is identical with LAB.min.js.\n\nMaybe LAB.js will be \u00abNon-minified version without any debug\u00bb?\n. Reminified is can (maybe) produce problem.\nRegexp is not automaticaly method.\n. Ok. i try to reminification.\n. Thanks.\n\nIdeal case is Lab.src.js without any debug, like in 1.2 version.\nWe cant modify our build scripts (https://github.com/punbb/punbb/tree/master/.dev/build) for adding regexp or skip minified logic.\n. Looks like error happened when page still loading and user click Back button or link to another page.\n. It vary rare error - i can reproduce it only on one host (maybe slow) and in 1 per 10 page loading.\nI thinks it is not bug. Thanks.\n. ",
    "jpcarlino": "Not sure if this is the same issue, but i think it relates with the bug description. Basically i wrote a simple 'load.js' file responsible for managing the load chain for my needed libraries. My application needs jQuery >= 1.4.2 and jQuery UI **but** it must run as a guest widget inside a host page that could have loaded jQuery previously, so i can't make assumptions about what libraries are used by the host page.\nI've created a plain html page with jQuery 1.4.1 (simulating the potential conflict i could met) and jQuery UI. Also, I've added an inline just including my 'load.js' file, which is similar to this:\n\n``` javascript\n(function () {\n        var script = document.createElement(\"script\");\n        script.src = \"lib/LAB.js\";\n        script.onload = script.onreadystatechange = function () {\n            $LAB\n            .script(function(){\n                if ( (typeof jQuery === 'undefined') || (jQuery().jquery < '1.4.2') ) {\n                    console.log(\"loading jQuery 1.4.2...\");\n                    return \"http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js\";\n                }\n                else {\n                    console.log(\"jQuery >= 1.4.2 already loaded\");\n                    return null;\n                }       \n            }).wait(function(){console.log('wait for jQuery...');}) // wait for jQuery\n            .script(function(){\n                (function ($) {\n                    if ((typeof $.ui === 'undefined') || ($.ui.version < '1.7.2' )){\n                        console.log(\"loading jQuery UI with jQuery version \" + $().jquery);\n                        return \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js\";\n                    }else{\n                        console.log(\"jQuery UI already loaded with jQuery version \" + $().jquery);\n                        return null;\n                    }\n                })(jQuery.noConflict(true));\n            });\n        };\n        document.body.appendChild(script);\n})();\n```\n\nOn the other hand, this is the output from my console (both FF 5 and Chrome 12.0.742.124):\n\nload.js:12  loading jQuery 1.4.2...\nload.js:26  jQuery UI already loaded with jQuery version 1.4.1\nload.js:19  wait for jQuery...\n\nas you can see, the second 'script' call is executed before jQuery 1.4.2 is ready. Maybe I'm doing something wrong?\n. Thank you very much for your response! I didn't expect such detailed answer :)\n\nAnyway, after a detailed reading and testing of your code, i'm not sure if the behaviour is exactly what i need. Or maybe is that i don't understand the second `script` call:\n\n``` javascript\nfunction() {\n    if (needs_jquery_ui_172) {\n        console.log(\"loading jQuery UI 1.7.2, with jQuery \" + \n                 (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n        return \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js\";\n    } else {\n        console.log(\"jQuery UI \" + jQuery.ui.version + \n                 \" already loaded, with jQuery \" + \n                 (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n        return null; // no need to load anything\n    }\n}\n```\n\nspecifically this statement:\n\n``` javascript\nconsole.log(\"loading jQuery UI 1.7.2, with jQuery \" + (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n```\n\nActually i don't see why jQuery UI 1.7.2 (we always refer to this example) is **said** to be loaded with jQuery 1.4.2. Yes, my component could need jQuery 1.4.2, so the corresponding boolean value is true, but now that i understood how `script` and `wait` methods work... what guarantees that the first step of the chain (responsible for loading jQuery 1.4.2) has actually ended? I mean, the second `script` call is running in paralell with the first one. Maybe jQuery UI file loads and executes first. So i don't see where is the mechanism that ensures that jQuery UI is loaded with the right jQuery library. And actually this is my biggest problem, because i would need to load a thrid library (the real component i have developed) **if and only if** I can use the right jQuery and jQuery UI versions.\n\nAgain, please excuse me if I'm asking something trivial :)\n. Fine. Thank you for your answer.\n\nWell, my question was based then on a second misunderstanding of how `script` and `wait` works, after your first answer:\n\n> functions passed to .script() are all executed immediately (they don't \"wait\" like functions passed to .wait() do). The reason for this is that their primary purpose is to resolve (immediately) what scripts the chain should load, so that it can load in parallel.\n\nbut now you say in your last comment:\n\n> if you have a $LAB.script(\"a\").wait(...).script(\"b\") chain, then LABjs always ensures that \"a\" runs before \"b\". In your case, we're also combining in conditional logic, which says that \"a\" doesn't need to run if the \"a\" is already present on the page. \n\nI think this missconception was produced by the difference between `.script(function)` and `.wait(function)` semantics. In the first case the function is called immediately to determine _what_ to load (conditional). In the second case, the function is intended to execute business logic _ensuring_ the scripts above were all loaded.\n\nThank you!\n. I'm experiencing a strange behaviour when i test your loading scheme on FF 3.6.18 (Ubuntu 10.10). It works excellent on FF 5.0. I think it relates with the fact that my component library has a main `$(callback)` function, which means it should be executed when DOM is ready.\n\nTo simplify, assume my main librarary file (`component.js`) has the following content:\n\n``` javascript\n$(function() {\n    console.log(\"using jQuery version: \" + $().jquery);\n}\n```\n\non the other hand, i'm using your suggested load chain, except i've added my `component.js` file at last place:\n\n``` javascript\n    // .....\n    .script(\"component.js\")\n    .wait(function(){\n        console(\"component.js loaded ...\");\n        // ... trigger a startup event to start my component\n    });\n\n```\n\non FF 3.6.18, the first time (i mean, before it is cached by the browser for subsequent requests) LAB loads the `component.js` file everything works as expected, which means: the aforementioned message says jQuery version is 1.4.2 (the library version i'm loading specifically for this component) **and** the console.log message on the last `wait()` is printed last before the component is started. But on subsequent attempts the 'on document ready' callback inside `component.js` is invoked before the `wait()` function, it breaks (because jQuery version is lower) and the `console.log` on the last `wait()` is never shown. In case `console.log` is asynchronous i have tried replacing it with an `alert()`, which of course is never shown.\n\nDo you know if this could be a bug on the library when executed on older FF versions and the library has an 'on document ready' callback?\n. Not sure if this is the same issue, but i think it relates with the bug description. Basically i wrote a simple 'load.js' file responsible for managing the load chain for my needed libraries. My application needs jQuery >= 1.4.2 and jQuery UI **but** it must run as a guest widget inside a host page that could have loaded jQuery previously, so i can't make assumptions about what libraries are used by the host page.\nI've created a plain html page with jQuery 1.4.1 (simulating the potential conflict i could met) and jQuery UI. Also, I've added an inline just including my 'load.js' file, which is similar to this:\n\n``` javascript\n(function () {\n        var script = document.createElement(\"script\");\n        script.src = \"lib/LAB.js\";\n        script.onload = script.onreadystatechange = function () {\n            $LAB\n            .script(function(){\n                if ( (typeof jQuery === 'undefined') || (jQuery().jquery < '1.4.2') ) {\n                    console.log(\"loading jQuery 1.4.2...\");\n                    return \"http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js\";\n                }\n                else {\n                    console.log(\"jQuery >= 1.4.2 already loaded\");\n                    return null;\n                }       \n            }).wait(function(){console.log('wait for jQuery...');}) // wait for jQuery\n            .script(function(){\n                (function ($) {\n                    if ((typeof $.ui === 'undefined') || ($.ui.version < '1.7.2' )){\n                        console.log(\"loading jQuery UI with jQuery version \" + $().jquery);\n                        return \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js\";\n                    }else{\n                        console.log(\"jQuery UI already loaded with jQuery version \" + $().jquery);\n                        return null;\n                    }\n                })(jQuery.noConflict(true));\n            });\n        };\n        document.body.appendChild(script);\n})();\n```\n\nOn the other hand, this is the output from my console (both FF 5 and Chrome 12.0.742.124):\n\nload.js:12  loading jQuery 1.4.2...\nload.js:26  jQuery UI already loaded with jQuery version 1.4.1\nload.js:19  wait for jQuery...\n\nas you can see, the second 'script' call is executed before jQuery 1.4.2 is ready. Maybe I'm doing something wrong?\n. Thank you very much for your response! I didn't expect such detailed answer :)\n\nAnyway, after a detailed reading and testing of your code, i'm not sure if the behaviour is exactly what i need. Or maybe is that i don't understand the second `script` call:\n\n``` javascript\nfunction() {\n    if (needs_jquery_ui_172) {\n        console.log(\"loading jQuery UI 1.7.2, with jQuery \" + \n                 (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n        return \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js\";\n    } else {\n        console.log(\"jQuery UI \" + jQuery.ui.version + \n                 \" already loaded, with jQuery \" + \n                 (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n        return null; // no need to load anything\n    }\n}\n```\n\nspecifically this statement:\n\n``` javascript\nconsole.log(\"loading jQuery UI 1.7.2, with jQuery \" + (needs_jquery_142 ? \"1.4.2\" : jQuery().jquery));\n```\n\nActually i don't see why jQuery UI 1.7.2 (we always refer to this example) is **said** to be loaded with jQuery 1.4.2. Yes, my component could need jQuery 1.4.2, so the corresponding boolean value is true, but now that i understood how `script` and `wait` methods work... what guarantees that the first step of the chain (responsible for loading jQuery 1.4.2) has actually ended? I mean, the second `script` call is running in paralell with the first one. Maybe jQuery UI file loads and executes first. So i don't see where is the mechanism that ensures that jQuery UI is loaded with the right jQuery library. And actually this is my biggest problem, because i would need to load a thrid library (the real component i have developed) **if and only if** I can use the right jQuery and jQuery UI versions.\n\nAgain, please excuse me if I'm asking something trivial :)\n. Fine. Thank you for your answer.\n\nWell, my question was based then on a second misunderstanding of how `script` and `wait` works, after your first answer:\n\n> functions passed to .script() are all executed immediately (they don't \"wait\" like functions passed to .wait() do). The reason for this is that their primary purpose is to resolve (immediately) what scripts the chain should load, so that it can load in parallel.\n\nbut now you say in your last comment:\n\n> if you have a $LAB.script(\"a\").wait(...).script(\"b\") chain, then LABjs always ensures that \"a\" runs before \"b\". In your case, we're also combining in conditional logic, which says that \"a\" doesn't need to run if the \"a\" is already present on the page. \n\nI think this missconception was produced by the difference between `.script(function)` and `.wait(function)` semantics. In the first case the function is called immediately to determine _what_ to load (conditional). In the second case, the function is intended to execute business logic _ensuring_ the scripts above were all loaded.\n\nThank you!\n. I'm experiencing a strange behaviour when i test your loading scheme on FF 3.6.18 (Ubuntu 10.10). It works excellent on FF 5.0. I think it relates with the fact that my component library has a main `$(callback)` function, which means it should be executed when DOM is ready.\n\nTo simplify, assume my main librarary file (`component.js`) has the following content:\n\n``` javascript\n$(function() {\n    console.log(\"using jQuery version: \" + $().jquery);\n}\n```\n\non the other hand, i'm using your suggested load chain, except i've added my `component.js` file at last place:\n\n``` javascript\n    // .....\n    .script(\"component.js\")\n    .wait(function(){\n        console(\"component.js loaded ...\");\n        // ... trigger a startup event to start my component\n    });\n\n```\n\non FF 3.6.18, the first time (i mean, before it is cached by the browser for subsequent requests) LAB loads the `component.js` file everything works as expected, which means: the aforementioned message says jQuery version is 1.4.2 (the library version i'm loading specifically for this component) **and** the console.log message on the last `wait()` is printed last before the component is started. But on subsequent attempts the 'on document ready' callback inside `component.js` is invoked before the `wait()` function, it breaks (because jQuery version is lower) and the `console.log` on the last `wait()` is never shown. In case `console.log` is asynchronous i have tried replacing it with an `alert()`, which of course is never shown.\n\nDo you know if this could be a bug on the library when executed on older FF versions and the library has an 'on document ready' callback?\n. ",
    "dexbol": "$LAB.script(['test1.php',['test2.php','test3.php']]);\n\nit just has one parameter ['test1.php',['test2.php','test3.php']] ,not two parameters \"test1.php\" and [\"test2.php\", \"test3.php\"]\n. ...  I try it again , that may be my mistake\n. I push the example to internet .http://dexbol.sinaapp.com/labjs/\n. OK\uff0cthanks for your code and explain too.\n. $LAB.script(['test1.php',['test2.php','test3.php']]);\n\nit just has one parameter ['test1.php',['test2.php','test3.php']] ,not two parameters \"test1.php\" and [\"test2.php\", \"test3.php\"]\n. ...  I try it again , that may be my mistake\n. I push the example to internet .http://dexbol.sinaapp.com/labjs/\n. OK\uff0cthanks for your code and explain too.\n. ",
    "scriby": "Thanks for the response. Your solutions all make sense, but isn't quite what I want for my particular case.\n\nOur application is set up to allow pages to either be loaded as a normal web page, or as a dialog within another page. In the case of a normal page load, we want to load LAB.js and load scripts normally. In the case of a dialog within another page, we want LAB to load only the scripts the new page references that aren't already loaded, which AllowDuplicates=false already handles very well.\n\nIt's true that we could test for the existence of the $LAB variable, and document.write a script tag to load it if it didn't exist to also solve the problem. But, it would just be simpler for us if the library handled the \"don't load myself twice on a page\" part of it. If it's not a change you want introduced into lab, I understand and we'll work around it another way.\n\nThanks,\n\nChris\n. Thanks for the other workaround. We should be able to build a solution which uses that idea.\n\nTo address \"So, I'm not quite sure how I could cleanly serve both the use-cases: 'do allow LABjs to gracefully load multiple times' and 'don't allow LABjs to load multiple times'.\"\n\nIsn't the answer to this straightforward? To get a new instance of lab, you call $LAB.sandbox(). Manually loading LAB.js twice on one page would not overwrite the $LAB global. As I mentioned in my first post, you can have the first instance of LAB loaded on the page include some special value that it checks for to determine if the current $LAB variable is the same script.\n\nSo, you could set an instance variable \"detect\" within LAB to a special value, like \"oshdf893y23\". Then, when LAB loads, you can check if there's already a $LAB variable with that detect value, and if so, don't do anything. If that value doesn't exist, you continue loading like normal.\n\nI think that solves both cases of getting a new copy of lab when you need it, and not getting one accidentally when you don't.\n\nI appreciate your time considering this problem.\n\nChris\n. I was ultimately hoping for a solution that didn't require boilerplate code each time LAB was included. We might just end up modifying our copy of LAB to behave like we want (hooray open source).\n\nThanks for spending time thinking about this! I'm going to go ahead and close the issue.\n\nChris\n. Use queueScript and queueWait instead. At the bottom of the page, call runQueue and it will process all the scripts added to the queue.\n. No, you have to use queueScript and queueWait to use runQueue. I'm using the pattern in an application we're developing and it works well.\n. The fundamental problem with a function like lab.ready is that lab doesn't know when you're done requesting scripts. If you use lab.script, they load immediately, and lab doesn't know when you're not going to request any more.\n\nSo I think that's why it exposes queues, to give you some control over the loading process.\n\nWe use queues on the initial page load to load scripts dependent on framework scripts. But, we use .script to load one-off scripts later on.\n. I'm not the implementor of LAB, so it's probably best if we don't get into a discussion of the relative merits of each solution.\n\nI do like the way it's implemented now, though. \n\nGood luck!\n\nChris\n. We were having an issue with runtime errors getting swallowed in scripts loaded by LABjs. I thought I had uncovered a browser issue with not always outputting the error messages. This is a pretty big deal for us, and anyone writing a serious javascript front-end.\n\nI ran across https://github.com/getify/LABjs/issues/19 and noticed the debug mode.\n\nThis is better than nothing, but we want to be able to use window.onerror to catch as much as possible in production. LABjs's behavior will prevent errors in scripts loaded with LAB from being caught by onerror.\n\nI think one solution might look like this...\n\n``` javascript\ntry {\n    //run script\n} catch(e) {\n    //whatever LAB normally does\n\n    //Throw the exception from another context so the browser's usual error handling can occur\n    setTimeout(function(){\n        throw e;\n    });\n}\n```\n\nIf that doesn't work, then a way to specify an error handling function would also be welcome.\n\nThanks,\n\nChris\n. Did you notice the solution I provided will still allow LAB.js to work? The error is thrown from within a setTimeout, so it won't affect the current execution. But it will allow the error to behave like errors normally do in javascript ... I don't understand why we must accept different error behavior for code that's run from LAB. \n\nI just tried doing it from your catch block and it works fine.\n\nI appreciate your opinions on the best way to do error handling, but please understand that all projects are different and have different needs, constraints, and trade-offs. I simply want to be notified of errors that come up in production that were missed through other means so they can be resolved.\n. Ok, I'll just leave you with one parting thought.\n\nThe current default behavior is much worse. We've had a very hard time debugging our app because some scripts would just stop executing with no information. We didn't even know an error was occurring.\n\nAfter weeks of guessing I finally figured out the pattern that it only occurs in scripts loaded from LAB. The default behavior cost my team some serious time (others came to me asking about things breaking with no details).\n\nNo matter what you do, I encourage you to make the default behavior less surprising. I did read through available documentation when we adopted LAB, and don't recall reading anything about errors getting swallowed. But even if it is in the docs, it's a terrible thing to miss.\n\nThanks for all your hard work on this library.\n\nChris\n. If the default behavior was to print something to the console, I think you would be on to something.\n\nWe're talking about development here, where we can't expect perfect error handling (maybe we should never expect it...). We need to iterate on the app, find and fix problems quickly.\n\nGetting some indication an error occurred is critical, even if it's not perfect. Things not working and no console output is even more head scratching confusing.\n\nAnd the first error reported would be the one worth looking at ... which is what I think everyone is used to when debugging.\n. Yeah, the fundamental problem was that I didn't know about LAB's behavior. I would guess most people adopting the library wouldn't be aware of it.\n\nNow that I know about the debug version, we can make that work.\n. I ended up forking and adding an extension so it can call a method on error...\n\nOn May 29, 2012, at 8:31 PM, jasonhinkle\nreply@reply.github.com\nwrote:\n\n> I don't understand the problem with adding a callback so that devs can choose to listen for errors or not?  I can appreciate a separate debug build for outputting debug info, but even on the production build i'd want to know about errors.  (though I wouldn't want the library writing directly to console.error)\n> \n> Obviously you've put way more thought into it than I have so perhaps I'm missing something.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/57#issuecomment-5999559\n. As a user of the library, here's what I think is the most reasonable behavior.\n1. Expose an \"event\" on lab which is fired when an error occurs (from\n   your catch block). Allow client code to register handlers for the\n   event.\n2. If no handlers are registered, print the error to console.error\n   with some help text about how to use the event. (Testing if\n   console.error exists first)\n\nThis prevents users of your library from wasting debugging time on\nmysterious problems where no issues are apparent. It also allows the\napp to handle errors however it normally does, such as logging them\nsomewhere.\n\nIn the majority of cases I've seen, if an error occurs in a js file on\nload, the page is broken anyway. It doesn't matter what your library\ndoes as long as it surfaces the information that there was some\nproblem and how to get more info.\n\nSimply swallowing errors is in my opinion the worst default behavior\nas it makes it practically impossible to debug. Any solution that can\nat least surface the fact that an error occurred is an improvement.\n\nChris\n\nOn May 29, 2012, at 9:39 PM, Kyle Simpson\nreply@reply.github.com\nwrote:\n\n> @jasonhinkle\n> \n> The big discussion in this thread is not whether or not it's \"possible\" to fire an error callback... it was about whether it's proper to do so. My feeling is a library like LABjs should not expose a functionality as part of the API if it cannot expose that functionality in a reliable way across browsers.\n> \n> Not all browsers have the same behavior for \"error\" conditions, which means in some browsers an error handler would fire, and in other cases the error handle would sit silent (even though the error did occur). Moreover, some browsers would abort a chain at the point of an error, whereas other browsers the \"abort\" of a chain would not be possible. So, in some of your browser testings, you'd see an error, but the chain would complete still (which could be a good or bad thing, depending on your code and how much it's inter-dependent), and in other browser testings the error would abort the chain (which again might be desired or not).\n> \n> By me not being able to guarantee the behavior of these error handling features, I think it detracts from LABjs rather than adds to it. Consider that most people who use LABjs don't understand all the internal quirks, and so if they see a feature documented, and try to use it and it doesn't work as expected, they will file bugs which I'll constantly be closing as \"can't fix\".\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/57#issuecomment-6000369\n. All I can say is that since I added something to lab's catch block to\ncall a registered method, I haven't missed any errors I care about.\n\nMaybe you're overthinking it?\n\nChris\n\nOn May 29, 2012, at 10:36 PM, Kyle Simpson\nreply@reply.github.com\nwrote:\n\n> @scriby\n> \n> That sounds like a reasonable expectation, until you dig a little deeper into its implications.\n> 1. As we have mentioned earlier in the thread, in some cases this error event will fire once (because the chain aborts at first error), and in some browsers the error event may fire many, many, many times, because the chain doesn't abort and keeps going, and now you probably have lots of \"reference undefined\" issues. This inconsistency cross-browser is almost certain to be a \"hidden\" (unexpected) behavior, one which I simply cannot correct for (if I could, we wouldn't be having this discussion).\n> 2. The very definition of what constitutes an \"error\" is not easy to make obvious. script.onerror (which most people would mentally closely associate with a chain-specific error handler) fires for network loading issues (404's, etc). However, all browsers have somewhat different behavior on which loading errors they fire for or not. So, in some browsers you'll get an error event triggered for a 404 load, and in other browsers, you'll get no error fired at all, even with the 404. This is yet another unexpected inconsistency that's VERY hard to make obvious, or more to the point, make it so that people don't blame LABjs.\n> 3. Moreover, the browser's built-in script.onerror does NOT fire for run-time errors (that's window.onerror), so this LABjs error handler would be (I think somewhat confusingly) combining the behavior of window.onerror and script.onerror into one handler. Documentation can say that, but again, I don't think that's naturally what everyone will assume.\n> \n> And if we _don't_ try to respond to any of the network load errors at all, and only respond to the run-time errors we catch, then a failed load of a library won't be directly detectable (which is at least a major part of what people asking for these features want to detect for), and will only be indirectly obvious if it happens to cause an \"undefined reference\" error in the chain.\n> \n> What if the \"undefined reference\" call doesn't happen in the chain at all, but not until later? Then you didn't get any indication by LABjs that a problem occured with your chain.\n> \n> So, you almost certainly have to do both kinds of errors.\n> \n> Do we combine them into one event, or do we publish two events (loadError, runtimeError)? Even if we do, how do we make it so the above browser inconsistencies don't create more problems than we are solving?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/57#issuecomment-6000984\n. It's probably a separate issue, but I noticed something like this in IE10. I had a script that was getting loaded with .script().wait(), and if I browsed away from the page, it seemed to cause the .wait function to get triggered immediately (sometimes, depending on timing). It didn't really affect behavior, but ended up triggering an error.\n. Thanks for the response. Your solutions all make sense, but isn't quite what I want for my particular case.\n\nOur application is set up to allow pages to either be loaded as a normal web page, or as a dialog within another page. In the case of a normal page load, we want to load LAB.js and load scripts normally. In the case of a dialog within another page, we want LAB to load only the scripts the new page references that aren't already loaded, which AllowDuplicates=false already handles very well.\n\nIt's true that we could test for the existence of the $LAB variable, and document.write a script tag to load it if it didn't exist to also solve the problem. But, it would just be simpler for us if the library handled the \"don't load myself twice on a page\" part of it. If it's not a change you want introduced into lab, I understand and we'll work around it another way.\n\nThanks,\n\nChris\n. Thanks for the other workaround. We should be able to build a solution which uses that idea.\n\nTo address \"So, I'm not quite sure how I could cleanly serve both the use-cases: 'do allow LABjs to gracefully load multiple times' and 'don't allow LABjs to load multiple times'.\"\n\nIsn't the answer to this straightforward? To get a new instance of lab, you call $LAB.sandbox(). Manually loading LAB.js twice on one page would not overwrite the $LAB global. As I mentioned in my first post, you can have the first instance of LAB loaded on the page include some special value that it checks for to determine if the current $LAB variable is the same script.\n\nSo, you could set an instance variable \"detect\" within LAB to a special value, like \"oshdf893y23\". Then, when LAB loads, you can check if there's already a $LAB variable with that detect value, and if so, don't do anything. If that value doesn't exist, you continue loading like normal.\n\nI think that solves both cases of getting a new copy of lab when you need it, and not getting one accidentally when you don't.\n\nI appreciate your time considering this problem.\n\nChris\n. I was ultimately hoping for a solution that didn't require boilerplate code each time LAB was included. We might just end up modifying our copy of LAB to behave like we want (hooray open source).\n\nThanks for spending time thinking about this! I'm going to go ahead and close the issue.\n\nChris\n. Use queueScript and queueWait instead. At the bottom of the page, call runQueue and it will process all the scripts added to the queue.\n. No, you have to use queueScript and queueWait to use runQueue. I'm using the pattern in an application we're developing and it works well.\n. The fundamental problem with a function like lab.ready is that lab doesn't know when you're done requesting scripts. If you use lab.script, they load immediately, and lab doesn't know when you're not going to request any more.\n\nSo I think that's why it exposes queues, to give you some control over the loading process.\n\nWe use queues on the initial page load to load scripts dependent on framework scripts. But, we use .script to load one-off scripts later on.\n. I'm not the implementor of LAB, so it's probably best if we don't get into a discussion of the relative merits of each solution.\n\nI do like the way it's implemented now, though. \n\nGood luck!\n\nChris\n. We were having an issue with runtime errors getting swallowed in scripts loaded by LABjs. I thought I had uncovered a browser issue with not always outputting the error messages. This is a pretty big deal for us, and anyone writing a serious javascript front-end.\n\nI ran across https://github.com/getify/LABjs/issues/19 and noticed the debug mode.\n\nThis is better than nothing, but we want to be able to use window.onerror to catch as much as possible in production. LABjs's behavior will prevent errors in scripts loaded with LAB from being caught by onerror.\n\nI think one solution might look like this...\n\n``` javascript\ntry {\n    //run script\n} catch(e) {\n    //whatever LAB normally does\n\n    //Throw the exception from another context so the browser's usual error handling can occur\n    setTimeout(function(){\n        throw e;\n    });\n}\n```\n\nIf that doesn't work, then a way to specify an error handling function would also be welcome.\n\nThanks,\n\nChris\n. Did you notice the solution I provided will still allow LAB.js to work? The error is thrown from within a setTimeout, so it won't affect the current execution. But it will allow the error to behave like errors normally do in javascript ... I don't understand why we must accept different error behavior for code that's run from LAB. \n\nI just tried doing it from your catch block and it works fine.\n\nI appreciate your opinions on the best way to do error handling, but please understand that all projects are different and have different needs, constraints, and trade-offs. I simply want to be notified of errors that come up in production that were missed through other means so they can be resolved.\n. Ok, I'll just leave you with one parting thought.\n\nThe current default behavior is much worse. We've had a very hard time debugging our app because some scripts would just stop executing with no information. We didn't even know an error was occurring.\n\nAfter weeks of guessing I finally figured out the pattern that it only occurs in scripts loaded from LAB. The default behavior cost my team some serious time (others came to me asking about things breaking with no details).\n\nNo matter what you do, I encourage you to make the default behavior less surprising. I did read through available documentation when we adopted LAB, and don't recall reading anything about errors getting swallowed. But even if it is in the docs, it's a terrible thing to miss.\n\nThanks for all your hard work on this library.\n\nChris\n. If the default behavior was to print something to the console, I think you would be on to something.\n\nWe're talking about development here, where we can't expect perfect error handling (maybe we should never expect it...). We need to iterate on the app, find and fix problems quickly.\n\nGetting some indication an error occurred is critical, even if it's not perfect. Things not working and no console output is even more head scratching confusing.\n\nAnd the first error reported would be the one worth looking at ... which is what I think everyone is used to when debugging.\n. Yeah, the fundamental problem was that I didn't know about LAB's behavior. I would guess most people adopting the library wouldn't be aware of it.\n\nNow that I know about the debug version, we can make that work.\n. I ended up forking and adding an extension so it can call a method on error...\n\nOn May 29, 2012, at 8:31 PM, jasonhinkle\nreply@reply.github.com\nwrote:\n\n> I don't understand the problem with adding a callback so that devs can choose to listen for errors or not?  I can appreciate a separate debug build for outputting debug info, but even on the production build i'd want to know about errors.  (though I wouldn't want the library writing directly to console.error)\n> \n> Obviously you've put way more thought into it than I have so perhaps I'm missing something.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/57#issuecomment-5999559\n. As a user of the library, here's what I think is the most reasonable behavior.\n1. Expose an \"event\" on lab which is fired when an error occurs (from\n   your catch block). Allow client code to register handlers for the\n   event.\n2. If no handlers are registered, print the error to console.error\n   with some help text about how to use the event. (Testing if\n   console.error exists first)\n\nThis prevents users of your library from wasting debugging time on\nmysterious problems where no issues are apparent. It also allows the\napp to handle errors however it normally does, such as logging them\nsomewhere.\n\nIn the majority of cases I've seen, if an error occurs in a js file on\nload, the page is broken anyway. It doesn't matter what your library\ndoes as long as it surfaces the information that there was some\nproblem and how to get more info.\n\nSimply swallowing errors is in my opinion the worst default behavior\nas it makes it practically impossible to debug. Any solution that can\nat least surface the fact that an error occurred is an improvement.\n\nChris\n\nOn May 29, 2012, at 9:39 PM, Kyle Simpson\nreply@reply.github.com\nwrote:\n\n> @jasonhinkle\n> \n> The big discussion in this thread is not whether or not it's \"possible\" to fire an error callback... it was about whether it's proper to do so. My feeling is a library like LABjs should not expose a functionality as part of the API if it cannot expose that functionality in a reliable way across browsers.\n> \n> Not all browsers have the same behavior for \"error\" conditions, which means in some browsers an error handler would fire, and in other cases the error handle would sit silent (even though the error did occur). Moreover, some browsers would abort a chain at the point of an error, whereas other browsers the \"abort\" of a chain would not be possible. So, in some of your browser testings, you'd see an error, but the chain would complete still (which could be a good or bad thing, depending on your code and how much it's inter-dependent), and in other browser testings the error would abort the chain (which again might be desired or not).\n> \n> By me not being able to guarantee the behavior of these error handling features, I think it detracts from LABjs rather than adds to it. Consider that most people who use LABjs don't understand all the internal quirks, and so if they see a feature documented, and try to use it and it doesn't work as expected, they will file bugs which I'll constantly be closing as \"can't fix\".\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/57#issuecomment-6000369\n. All I can say is that since I added something to lab's catch block to\ncall a registered method, I haven't missed any errors I care about.\n\nMaybe you're overthinking it?\n\nChris\n\nOn May 29, 2012, at 10:36 PM, Kyle Simpson\nreply@reply.github.com\nwrote:\n\n> @scriby\n> \n> That sounds like a reasonable expectation, until you dig a little deeper into its implications.\n> 1. As we have mentioned earlier in the thread, in some cases this error event will fire once (because the chain aborts at first error), and in some browsers the error event may fire many, many, many times, because the chain doesn't abort and keeps going, and now you probably have lots of \"reference undefined\" issues. This inconsistency cross-browser is almost certain to be a \"hidden\" (unexpected) behavior, one which I simply cannot correct for (if I could, we wouldn't be having this discussion).\n> 2. The very definition of what constitutes an \"error\" is not easy to make obvious. script.onerror (which most people would mentally closely associate with a chain-specific error handler) fires for network loading issues (404's, etc). However, all browsers have somewhat different behavior on which loading errors they fire for or not. So, in some browsers you'll get an error event triggered for a 404 load, and in other browsers, you'll get no error fired at all, even with the 404. This is yet another unexpected inconsistency that's VERY hard to make obvious, or more to the point, make it so that people don't blame LABjs.\n> 3. Moreover, the browser's built-in script.onerror does NOT fire for run-time errors (that's window.onerror), so this LABjs error handler would be (I think somewhat confusingly) combining the behavior of window.onerror and script.onerror into one handler. Documentation can say that, but again, I don't think that's naturally what everyone will assume.\n> \n> And if we _don't_ try to respond to any of the network load errors at all, and only respond to the run-time errors we catch, then a failed load of a library won't be directly detectable (which is at least a major part of what people asking for these features want to detect for), and will only be indirectly obvious if it happens to cause an \"undefined reference\" error in the chain.\n> \n> What if the \"undefined reference\" call doesn't happen in the chain at all, but not until later? Then you didn't get any indication by LABjs that a problem occured with your chain.\n> \n> So, you almost certainly have to do both kinds of errors.\n> \n> Do we combine them into one event, or do we publish two events (loadError, runtimeError)? Even if we do, how do we make it so the above browser inconsistencies don't create more problems than we are solving?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/57#issuecomment-6000984\n. It's probably a separate issue, but I noticed something like this in IE10. I had a script that was getting loaded with .script().wait(), and if I browsed away from the page, it seemed to cause the .wait function to get triggered immediately (sometimes, depending on timing). It didn't really affect behavior, but ended up triggering an error.\n. ",
    "btraut": "That may just do the trick for us! Thanks for taking the time.\n. That may just do the trick for us! Thanks for taking the time.\n. ",
    "dairiki": "Good point.  I had sort of thought of that, but not hard enough.\n\nI think this is a pretty esoteric case.  It\u2019s probably not worth dirtying up your API just for the sake of this one use case.\n\nGoogle's plusone API is the only one I've seen that wants parameters in the script body like this.   I've dug a little further into google\u2019s code.  It turns out that https://apis.google.com/js/plusone.js is just a small bootloader (~3kb), it does it's own deferred loading of the main code.  Calls to, e.g. `gapi.plusone.render` just go into a queue until the main code is loaded\n\nIn other words, the plusone API does it\u2019s own deferred loading and sequencing.  That being the case, I guess there\u2019s not much reason to load `plusone.js` using `LABjs`.\n\n(Out of curiousity, I looked into how the parameters in the body of the script tag were accessed.  I was thinking, that there would be some sort of official way for the external script to find its script tag. Apparentlyt, that\u2019s not the case. Google\u2019s code just iterates through all the SCRIPT tags in the document until it finds the one with the right `src` attribute; then it has to eval the body text.  Kinda funky...)\n. ...or...\n\nAnother option would be for LABjs to disable loading via XHR if there is a `.text` specified for the script.  (I.e. if there is a `.text`, treat local scripts as non-local.)\n\n---\n\n> Since it's just one script, and it does its own loading, it's possibly/probably a case where this might be most appropriate:\n> \n> `<script defer src=\"plusone.js\"></script>`\n> \n> By using defer, you'll ensure that it's a low-priority script that doesn't start loading until DOM parsing is done (meaning other normal scripts, and even dynamic script loading, can proceed first). The other option is async which is very similar, but which has no \"delay\" to it (it's strictly ASAP).\n\nI still need to make sure that `plusone.js` is loaded before calling `gapi.plusone.render`.  I\u2019d guess there is a straight-forward way to do that, but I don't know what it is.  Is there an easy way to do that, or is [this](https://gist.github.com/603980) about the minimum required for that?\n. > Does combining the two scripts like this work?\n> \n> `<script src=\"plusone.js\">config.setting=\"blah\"; gapi.plusone.render();</script>`\n\nNot quite, but after some futzing around, I got this to work:\n\n```\n<script defer='defer' type=\"text/javascript\" src=\"https://apis.google.com/js/plusone.js\">\n  gapi.plusone.render('p1', {\"count\": \"false\"}),\n  {'gwidget':{'parsetags':'explicit'}}\n</script>\n```\n\nNote that one has to add the extra 'gwidget' level to the returned config object.  Normally the plusone code adds that itself (if it is not there), but calling `render` from the script body prevents it from doing so for reasons that I only partially understand.\n\nAnyhow, that works!   Thank you!\n\n> Also, found this:\n> http://googlewebmastercentral.blogspot.com/2011/07/1-button-now-faster.html\n> \n> I don't see in there where they suggest how you do the \"config\" settings. But surely there's some way to do so that works with their async code.\n\n(You can set the inner text of the script element `po.text=\"{'parsetags':'explicit'}\"'.)\n\n> IF you can figure out how to set the config without using the inner text (which it seems there must be a way, since their async snippet doesn't set it), then you can load g+1 with LABjs, but set the config however they support it, thus not needing the text setting in the first place.\n\nI haven't been able to figure that out yet.  [Google says](http://code.google.com/apis/+1button/#async-load) that you should be able to set `window.___gcfg`.  For setting `lang` (as per their example) it works, but for setting `parsetags` (which is what I care about) it does not seem to work for me. :-/\n. > Firstly, I think this violates the principle of least-surprise. People who are expecting XHR loading won't understand this bizarre round-about reason why XHR is disabled if they set the text property. Even with good documentation, that smells like a WTF. Now, granted, it's a very small niche audience that's ever gonna do this, but still.\n\nMy (clearly flawed) understanding was that XHR was pretty much an implementation detail, used (only for local scripts) because (for reasons I hadn't completely grokked, but am now starting to) it is more efficient. I.e. one tells LABjs what script to load and LABjs loads it in the most appropriate manner.  E.g. if the script is not local, XHR is not used because XHR won't work in that case.   I was thinking that the script body case was analogous if one specifies a script body, then XHR should be disabled, since it won't work in that case.\n\n> You can't really reliably create a script element, set its src attribute/property, but not have the browser start fetching it. So, I see no way to make a script that needs text setting functionality as you descibe compatible with XHR.\n\nMostly out of curiosity, does the hack used [here](http://bezen.org/javascript/src/bezen.domwrite.js) (in `appendScriptClone`) work reliably?  (Set the scripts `type` to `\"any\"` before adding it to the DOM tree, then update the `type` after inserting the new element.)\n\n> But the other problem with your idea (disabling XHR) is that it would force LABjs to use the ugliest of all the hacks: \"cache preloading\".\n\nYeah, I was figuring that in this case (non-empty script body) would be rare enough that this wouldn't be a big issue. And besides, I was thinking this would mostly come up for loading external scripts, in which case XHR is not really an option in the first place, right?\n. Good point.  I had sort of thought of that, but not hard enough.\n\nI think this is a pretty esoteric case.  It\u2019s probably not worth dirtying up your API just for the sake of this one use case.\n\nGoogle's plusone API is the only one I've seen that wants parameters in the script body like this.   I've dug a little further into google\u2019s code.  It turns out that https://apis.google.com/js/plusone.js is just a small bootloader (~3kb), it does it's own deferred loading of the main code.  Calls to, e.g. `gapi.plusone.render` just go into a queue until the main code is loaded\n\nIn other words, the plusone API does it\u2019s own deferred loading and sequencing.  That being the case, I guess there\u2019s not much reason to load `plusone.js` using `LABjs`.\n\n(Out of curiousity, I looked into how the parameters in the body of the script tag were accessed.  I was thinking, that there would be some sort of official way for the external script to find its script tag. Apparentlyt, that\u2019s not the case. Google\u2019s code just iterates through all the SCRIPT tags in the document until it finds the one with the right `src` attribute; then it has to eval the body text.  Kinda funky...)\n. ...or...\n\nAnother option would be for LABjs to disable loading via XHR if there is a `.text` specified for the script.  (I.e. if there is a `.text`, treat local scripts as non-local.)\n\n---\n\n> Since it's just one script, and it does its own loading, it's possibly/probably a case where this might be most appropriate:\n> \n> `<script defer src=\"plusone.js\"></script>`\n> \n> By using defer, you'll ensure that it's a low-priority script that doesn't start loading until DOM parsing is done (meaning other normal scripts, and even dynamic script loading, can proceed first). The other option is async which is very similar, but which has no \"delay\" to it (it's strictly ASAP).\n\nI still need to make sure that `plusone.js` is loaded before calling `gapi.plusone.render`.  I\u2019d guess there is a straight-forward way to do that, but I don't know what it is.  Is there an easy way to do that, or is [this](https://gist.github.com/603980) about the minimum required for that?\n. > Does combining the two scripts like this work?\n> \n> `<script src=\"plusone.js\">config.setting=\"blah\"; gapi.plusone.render();</script>`\n\nNot quite, but after some futzing around, I got this to work:\n\n```\n<script defer='defer' type=\"text/javascript\" src=\"https://apis.google.com/js/plusone.js\">\n  gapi.plusone.render('p1', {\"count\": \"false\"}),\n  {'gwidget':{'parsetags':'explicit'}}\n</script>\n```\n\nNote that one has to add the extra 'gwidget' level to the returned config object.  Normally the plusone code adds that itself (if it is not there), but calling `render` from the script body prevents it from doing so for reasons that I only partially understand.\n\nAnyhow, that works!   Thank you!\n\n> Also, found this:\n> http://googlewebmastercentral.blogspot.com/2011/07/1-button-now-faster.html\n> \n> I don't see in there where they suggest how you do the \"config\" settings. But surely there's some way to do so that works with their async code.\n\n(You can set the inner text of the script element `po.text=\"{'parsetags':'explicit'}\"'.)\n\n> IF you can figure out how to set the config without using the inner text (which it seems there must be a way, since their async snippet doesn't set it), then you can load g+1 with LABjs, but set the config however they support it, thus not needing the text setting in the first place.\n\nI haven't been able to figure that out yet.  [Google says](http://code.google.com/apis/+1button/#async-load) that you should be able to set `window.___gcfg`.  For setting `lang` (as per their example) it works, but for setting `parsetags` (which is what I care about) it does not seem to work for me. :-/\n. > Firstly, I think this violates the principle of least-surprise. People who are expecting XHR loading won't understand this bizarre round-about reason why XHR is disabled if they set the text property. Even with good documentation, that smells like a WTF. Now, granted, it's a very small niche audience that's ever gonna do this, but still.\n\nMy (clearly flawed) understanding was that XHR was pretty much an implementation detail, used (only for local scripts) because (for reasons I hadn't completely grokked, but am now starting to) it is more efficient. I.e. one tells LABjs what script to load and LABjs loads it in the most appropriate manner.  E.g. if the script is not local, XHR is not used because XHR won't work in that case.   I was thinking that the script body case was analogous if one specifies a script body, then XHR should be disabled, since it won't work in that case.\n\n> You can't really reliably create a script element, set its src attribute/property, but not have the browser start fetching it. So, I see no way to make a script that needs text setting functionality as you descibe compatible with XHR.\n\nMostly out of curiosity, does the hack used [here](http://bezen.org/javascript/src/bezen.domwrite.js) (in `appendScriptClone`) work reliably?  (Set the scripts `type` to `\"any\"` before adding it to the DOM tree, then update the `type` after inserting the new element.)\n\n> But the other problem with your idea (disabling XHR) is that it would force LABjs to use the ugliest of all the hacks: \"cache preloading\".\n\nYeah, I was figuring that in this case (non-empty script body) would be rare enough that this wouldn't be a big issue. And besides, I was thinking this would mostly come up for loading external scripts, in which case XHR is not really an option in the first place, right?\n. ",
    "jonkemp": "I think the issue may be IE7. We are using the IE7 compatibility meta tag on our site. This means that it defaults to IE7 standards mode. Changing this to IE9 in the developer tools fixes the problem.\n\nDoes the test suite pass IE7?\n. Yes, testing now.\n. Testing your changes on my local fixed the issue for me in IE7. Works fine in IE8 mode as well.\n. I think the issue may be IE7. We are using the IE7 compatibility meta tag on our site. This means that it defaults to IE7 standards mode. Changing this to IE9 in the developer tools fixes the problem.\n\nDoes the test suite pass IE7?\n. Yes, testing now.\n. Testing your changes on my local fixed the issue for me in IE7. Works fine in IE8 mode as well.\n. ",
    "mflaschen-entech": "After experiencing problems, I verified this by setting a global variable at the end of custom1, then logging it in the page-specific script.  It works most of the time, but not always.\n. After experiencing problems, I verified this by setting a global variable at the end of custom1, then logging it in the page-specific script.  It works most of the time, but not always.\n. ",
    "milimetric": "I see the same behaviour.  Is the wait function not supposed to be used that way?\n. sorry, i'm off the project momentarily as I'm getting married.  I'll try to\nadd more info and testing when I get back.\n\nOn Wed, Sep 14, 2011 at 12:12 PM, Kyle Simpson <\nreply@reply.github.com>wrote:\n\n> hearing nothing for several days, closing for now. will reopen if further\n> info comes to light.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/46#issuecomment-2094825\n. I see the same behaviour.  Is the wait function not supposed to be used that way?\n. sorry, i'm off the project momentarily as I'm getting married.  I'll try to\nadd more info and testing when I get back.\n\nOn Wed, Sep 14, 2011 at 12:12 PM, Kyle Simpson <\nreply@reply.github.com>wrote:\n\n> hearing nothing for several days, closing for now. will reopen if further\n> info comes to light.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/getify/LABjs/issues/46#issuecomment-2094825\n. ",
    "andyscott12": "@scriby - can I use `$LAB.runQueue` without using `queueScript` and `queueWait` ?\n\nAla\n\n`$LAB\n.script(\"jquery.min.js\").wait()\n.script('myscript2').wait()\n.script('myscript3');`\n\n`$LAB.runQueue(function() {\n//my cool function\n});`\n\nThat is, will it automatically queue all the other scripts for me and recognize I want to run this \"last\" ?\n. yeah the only problem I see with that is then you have to commit to using it _everywhere_ as opposed to something like \"ready\" where you don't ? \n\nthat is - you are free to use anything else in $LAB and you know that it will only load once all scripts are loaded ?\n. @scriby - why couldn't `lab.ready` [or something similar] - simply automatically queue all previous scripts and then handle the function inside ? that is, just handle all previous `.script` and `.wait` as required and then fire the function ? even detecting / counting all `.script` calls on the page and then firing the function after all these have been called - would work ? perhaps even a `$lab.last(..` etc\n\nbasically, recording the scripts after they have been fired or totaling the queue - once all previous in the queue are fired - `allLoaded == true` and you can fire the function inside `$lab.ready(..` etc.\n\nI really do think it has merit ?\n. Thanks for the response :)\n\nGenerally, it's on the \"back and forward\" buttons that my code seems to get errors ? Any idea why this would be ? i.e. basically if I refresh the page it works no problem, but as soon as go back or forward then I get JS errors from LAB like\n\n`Uncaught TypeError: Object [object Object] has no method 'imagesLoaded'`\n\nI have defined some scripts on my `Master.Page` like\n\n`var commonLoad = \n$LAB\n.script('script1.js').wait();\n.script('script2.js').wait();\n.script('script3.js');`\n\nThen I use on the page Im working on\n\n`commonLoad\n.script('relies-on-commonLoad.js').wait()\n.wait(function() {\n//some code\n});`\n\nHowever, when I use the back and forward buttons - I get errors ? All I am doing is loading code via `jQuery()` which applies to the page images ? Is this something related to caching maybe or the DOM not being ready or ?\n\nCan't understand why ?\n\n[p.s - why oh why can't Github move \"Comment & Close\" to `float:left` ??? or near \"Close Issue\" :P]\n. OK - think I figured this out - but it is a bit of a PITA.\n\nBasically, back and forward is using the cached scripts and accessing them faster than the DOM is loading and causing issues.\n\nPer my comment above I'm using like\n\n`var commonLoad = \n$LAB\n.script('script1.js').wait();\n.script('script2.js').wait();\n.script('script3.js');`\n\nThen I use on the page Im working on\n\n`commonLoad\n.script('relies-on-commonLoad.js').wait()\n.wait(function() {\n//some code\n});`\n\nThe problem is that LAB doesn't allow me to use this within chains \n\n`commonLoad\n.setOptions({ CacheBust: true })\n.script('relies-on-commonLoad.js').wait()\n.wait(function() {\n//some code\n});`\n\nin the lower function - it gives me instead an error like \n\n`commonLoad.setOptions is not a function`\n\ni.e. I want to only cache bust a single script - not all those contained within the initial `var commonLoad`?\n. Thanks for the response again :) \n\nThe problem is that `relies-on-commonLoad.js` relies on 2 scripts contained in `script2.js` - and when using the back and forward buttons - it seems that the chaining doesn't work ? \n\ni.e. that is - that the scripts contained in `script2.js` don't load generating the\n\n`imagesLoaded is not a function` in Firefox. In Chrome it generates `TypeError: Object [object Object] has no method 'imagesLoaded'`\n\nIf I cache bust `script2.js` - then it forces it to reload and this seems to work ? Can't figure out how else to resolve it ?\n. Sorry, it seems if force cache bust script2.js - then it forces it to reload and this seems to work ? Can't figure out how else to resolve it ?\n. Yeah I am already using the latest version of LABjs - so I think the only way to resolve this is to force a reload of `script2.js` ?\n. I've played with this more - it actually seems using the \"back and forward\" buttons with chaining - doesn't seem to properly execute the `commonLoad` scripts ?\n\nThat is - I extracted the function from `relies-on-commonLoad.js` and just pasted it like below exactly\n\n`var commonLoad = \n$LAB\n.script('script1.js').wait();\n.script('script2.js').wait();\n.script('script3.js').wait();\n.wait(function() {\n//Code relying on script3.js\n});`\n\n`commonLoad\n.wait(function(){\n//function here which uses 2 plugins from script2.js\n});`\n\nThe later simply executes the function within `.wait()` and doesn't properly execute the order from `commonLoad` ?\n. So maybe retrieving from the cache has some issue ? That is, the order being retrieved from the cache on forward/back buttons isn't following correctly - because it doesn't make sense that I am getting \n\n`imagesLoaded is not a function` in Firefox and in Chrome `TypeError: Object [object Object] has no method 'imagesLoaded'`\n\nusing `var commonLoad` at the top of the page and `commonLoad.wait(function() ...` at the bottom ? \n\ni.e. it should just work [and it does work if I refresh the page] which leads me to believe it's something with cache retrieval ?\n. The only other reason I can think - is that the function is loading too fast for the images ? The only way I can solve it - it seems is to use\n\n`+ '?_=' + Math.random())` - can't understand why this resolves it\n\nI removed LAB all together from the page - it works without any problems\n. To put your mind at rest :) Thanks for pointing me in the right direction\n\nTurned out to be a x-domain request that was causing all sorts of issue as it was inserting a script which wasn't within the `$LAB` scope - meaning that it was changing things `during` LAB's operation.\n\nI ended up isolating line-by-line and then totally had a \"AHHHHHHHHHH FKKKKKKKKKKKK\" moment :) \n\nThanks again for being patient - love `LABjs` \n. Yep - thanks! You're a legend :P\n. @scriby - can I use `$LAB.runQueue` without using `queueScript` and `queueWait` ?\n\nAla\n\n`$LAB\n.script(\"jquery.min.js\").wait()\n.script('myscript2').wait()\n.script('myscript3');`\n\n`$LAB.runQueue(function() {\n//my cool function\n});`\n\nThat is, will it automatically queue all the other scripts for me and recognize I want to run this \"last\" ?\n. yeah the only problem I see with that is then you have to commit to using it _everywhere_ as opposed to something like \"ready\" where you don't ? \n\nthat is - you are free to use anything else in $LAB and you know that it will only load once all scripts are loaded ?\n. @scriby - why couldn't `lab.ready` [or something similar] - simply automatically queue all previous scripts and then handle the function inside ? that is, just handle all previous `.script` and `.wait` as required and then fire the function ? even detecting / counting all `.script` calls on the page and then firing the function after all these have been called - would work ? perhaps even a `$lab.last(..` etc\n\nbasically, recording the scripts after they have been fired or totaling the queue - once all previous in the queue are fired - `allLoaded == true` and you can fire the function inside `$lab.ready(..` etc.\n\nI really do think it has merit ?\n. Thanks for the response :)\n\nGenerally, it's on the \"back and forward\" buttons that my code seems to get errors ? Any idea why this would be ? i.e. basically if I refresh the page it works no problem, but as soon as go back or forward then I get JS errors from LAB like\n\n`Uncaught TypeError: Object [object Object] has no method 'imagesLoaded'`\n\nI have defined some scripts on my `Master.Page` like\n\n`var commonLoad = \n$LAB\n.script('script1.js').wait();\n.script('script2.js').wait();\n.script('script3.js');`\n\nThen I use on the page Im working on\n\n`commonLoad\n.script('relies-on-commonLoad.js').wait()\n.wait(function() {\n//some code\n});`\n\nHowever, when I use the back and forward buttons - I get errors ? All I am doing is loading code via `jQuery()` which applies to the page images ? Is this something related to caching maybe or the DOM not being ready or ?\n\nCan't understand why ?\n\n[p.s - why oh why can't Github move \"Comment & Close\" to `float:left` ??? or near \"Close Issue\" :P]\n. OK - think I figured this out - but it is a bit of a PITA.\n\nBasically, back and forward is using the cached scripts and accessing them faster than the DOM is loading and causing issues.\n\nPer my comment above I'm using like\n\n`var commonLoad = \n$LAB\n.script('script1.js').wait();\n.script('script2.js').wait();\n.script('script3.js');`\n\nThen I use on the page Im working on\n\n`commonLoad\n.script('relies-on-commonLoad.js').wait()\n.wait(function() {\n//some code\n});`\n\nThe problem is that LAB doesn't allow me to use this within chains \n\n`commonLoad\n.setOptions({ CacheBust: true })\n.script('relies-on-commonLoad.js').wait()\n.wait(function() {\n//some code\n});`\n\nin the lower function - it gives me instead an error like \n\n`commonLoad.setOptions is not a function`\n\ni.e. I want to only cache bust a single script - not all those contained within the initial `var commonLoad`?\n. Thanks for the response again :) \n\nThe problem is that `relies-on-commonLoad.js` relies on 2 scripts contained in `script2.js` - and when using the back and forward buttons - it seems that the chaining doesn't work ? \n\ni.e. that is - that the scripts contained in `script2.js` don't load generating the\n\n`imagesLoaded is not a function` in Firefox. In Chrome it generates `TypeError: Object [object Object] has no method 'imagesLoaded'`\n\nIf I cache bust `script2.js` - then it forces it to reload and this seems to work ? Can't figure out how else to resolve it ?\n. Sorry, it seems if force cache bust script2.js - then it forces it to reload and this seems to work ? Can't figure out how else to resolve it ?\n. Yeah I am already using the latest version of LABjs - so I think the only way to resolve this is to force a reload of `script2.js` ?\n. I've played with this more - it actually seems using the \"back and forward\" buttons with chaining - doesn't seem to properly execute the `commonLoad` scripts ?\n\nThat is - I extracted the function from `relies-on-commonLoad.js` and just pasted it like below exactly\n\n`var commonLoad = \n$LAB\n.script('script1.js').wait();\n.script('script2.js').wait();\n.script('script3.js').wait();\n.wait(function() {\n//Code relying on script3.js\n});`\n\n`commonLoad\n.wait(function(){\n//function here which uses 2 plugins from script2.js\n});`\n\nThe later simply executes the function within `.wait()` and doesn't properly execute the order from `commonLoad` ?\n. So maybe retrieving from the cache has some issue ? That is, the order being retrieved from the cache on forward/back buttons isn't following correctly - because it doesn't make sense that I am getting \n\n`imagesLoaded is not a function` in Firefox and in Chrome `TypeError: Object [object Object] has no method 'imagesLoaded'`\n\nusing `var commonLoad` at the top of the page and `commonLoad.wait(function() ...` at the bottom ? \n\ni.e. it should just work [and it does work if I refresh the page] which leads me to believe it's something with cache retrieval ?\n. The only other reason I can think - is that the function is loading too fast for the images ? The only way I can solve it - it seems is to use\n\n`+ '?_=' + Math.random())` - can't understand why this resolves it\n\nI removed LAB all together from the page - it works without any problems\n. To put your mind at rest :) Thanks for pointing me in the right direction\n\nTurned out to be a x-domain request that was causing all sorts of issue as it was inserting a script which wasn't within the `$LAB` scope - meaning that it was changing things `during` LAB's operation.\n\nI ended up isolating line-by-line and then totally had a \"AHHHHHHHHHH FKKKKKKKKKKKK\" moment :) \n\nThanks again for being patient - love `LABjs` \n. Yep - thanks! You're a legend :P\n. ",
    "allentong": "I was looking around a bit more and some people found this as a solution: https://github.com/SlexAxton/yepnope.js/issues/11\n\nI guess LABjs isn't right for this current project.  Thanks for your fast response and awesome loader!  I'm not sure if someone else has a response so I'll leave this open for a day.\n. I was looking around a bit more and some people found this as a solution: https://github.com/SlexAxton/yepnope.js/issues/11\n\nI guess LABjs isn't right for this current project.  Thanks for your fast response and awesome loader!  I'm not sure if someone else has a response so I'll leave this open for a day.\n. ",
    "michaelBenin": "```\n$LAB\n  .setOptions({AlwaysPreserveOrder:true})\n  .script(\"http://maps.google.com/maps/api/js?v=3.exp&sensor=false&async=2\")\n  .script(\"http://maps.gstatic.com/intl/en_us/mapfiles/api-3/13/6/main.js\")\n  .script(\"script.js\");\n```\n\nInside of script.js initialize your map without googles load method for example:\n\n```\nNamespace.map = (function(){\n\n    var map;\n\n    return{\n        init: function(){\n                var myLatlng = new google.maps.LatLng(-25.363882,131.044922);\n                var mapOptions = {\n                    zoom: 4,\n                    center: myLatlng,\n                    mapTypeId: google.maps.MapTypeId.ROADMAP\n                }\n                var map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);\n\n                var marker = new google.maps.Marker({\n                    position: myLatlng,\n                    map: map,\n                    title: 'Hello World!'\n                });\n            }\n    };\n\n}());\n```\n\nInside of script.js:\n\n```\nNamespace.map.init();\n\n// Don't use: google.maps.event.addDomListener(window, 'load', initialize);\n```\n. ```\n$LAB\n  .setOptions({AlwaysPreserveOrder:true})\n  .script(\"http://maps.google.com/maps/api/js?v=3.exp&sensor=false&async=2\")\n  .script(\"http://maps.gstatic.com/intl/en_us/mapfiles/api-3/13/6/main.js\")\n  .script(\"script.js\");\n```\n\nInside of script.js initialize your map without googles load method for example:\n\n```\nNamespace.map = (function(){\n\n    var map;\n\n    return{\n        init: function(){\n                var myLatlng = new google.maps.LatLng(-25.363882,131.044922);\n                var mapOptions = {\n                    zoom: 4,\n                    center: myLatlng,\n                    mapTypeId: google.maps.MapTypeId.ROADMAP\n                }\n                var map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);\n\n                var marker = new google.maps.Marker({\n                    position: myLatlng,\n                    map: map,\n                    title: 'Hello World!'\n                });\n            }\n    };\n\n}());\n```\n\nInside of script.js:\n\n```\nNamespace.map.init();\n\n// Don't use: google.maps.event.addDomListener(window, 'load', initialize);\n```\n. ",
    "filippo": "Thanks. I did several tests with my previous script and it works perfectly with these combinations:\n- Chrome and Opera on Linux\n- FF and Safari on Mac\n- IE on windows\n\nSo the only combination having problems is FF7 on Linux. \nI also tested your gist and it's not working with FF7 on Linux\nhttp://rewind.sgconsulting.it/test-lab/test2.png\n. It's getting strange. \nNow I'm at home same Firefox version, Linux again, but I can't reproduce the bug.\nI'll work on it on monday at the office following your suggestions and see if I can narrow the problem.\n\nThanks\n. I've filed a firefox bug report.\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=694940\n\nI think I've understood what's happening. See my last comment in the bug report:\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=694940#c3\n. Thanks. I did several tests with my previous script and it works perfectly with these combinations:\n- Chrome and Opera on Linux\n- FF and Safari on Mac\n- IE on windows\n\nSo the only combination having problems is FF7 on Linux. \nI also tested your gist and it's not working with FF7 on Linux\nhttp://rewind.sgconsulting.it/test-lab/test2.png\n. It's getting strange. \nNow I'm at home same Firefox version, Linux again, but I can't reproduce the bug.\nI'll work on it on monday at the office following your suggestions and see if I can narrow the problem.\n\nThanks\n. I've filed a firefox bug report.\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=694940\n\nI think I've understood what's happening. See my last comment in the bug report:\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=694940#c3\n. ",
    "nerrve": "I did some more digging into the issue and it turns out that i'm doing div.innerHTML = \"some html\" right before calling the script function of LAB. This html replace is a code that gets executed as a part of a synchronous ajax response from jquery.\n\nAlso i noticed that there is a request in the servlet for the \"resource that fails\" but there is no invocation on the wait function\n. another interesting thing is that after the innerHTML replace is done, i cant see any of my console.log statements on the console  and neither the alerts! but the LAB code for getting that resource is executed!\n. i'm sorry if i've confused you. i must admit that i did some edits to my original comments posted above as and when i found out new things.\n\nthe real issue turned out to be with innerHTML replaces in IE. if the html is malformed such as nested form tags etc\nhttp://jadendreamer.wordpress.com/2009/06/02/internet-explorer-fix-unknown-runtime-error-using-innerhtml-ajax/\n\n...then, the behavior is unpredictable in IE. \nin my case, i was using LAB right after doing an innerHTML replace. A lot of things were unpredictable after doing that replace, such as console statements not showing up, alerts not showing up but surprisingly, the subsequent js code (LAB) was being executed albiet in an unpredictable fashion....\n. closing this issue as it is not an issue with LAB\n. I did some more digging into the issue and it turns out that i'm doing div.innerHTML = \"some html\" right before calling the script function of LAB. This html replace is a code that gets executed as a part of a synchronous ajax response from jquery.\n\nAlso i noticed that there is a request in the servlet for the \"resource that fails\" but there is no invocation on the wait function\n. another interesting thing is that after the innerHTML replace is done, i cant see any of my console.log statements on the console  and neither the alerts! but the LAB code for getting that resource is executed!\n. i'm sorry if i've confused you. i must admit that i did some edits to my original comments posted above as and when i found out new things.\n\nthe real issue turned out to be with innerHTML replaces in IE. if the html is malformed such as nested form tags etc\nhttp://jadendreamer.wordpress.com/2009/06/02/internet-explorer-fix-unknown-runtime-error-using-innerhtml-ajax/\n\n...then, the behavior is unpredictable in IE. \nin my case, i was using LAB right after doing an innerHTML replace. A lot of things were unpredictable after doing that replace, such as console statements not showing up, alerts not showing up but surprisingly, the subsequent js code (LAB) was being executed albiet in an unpredictable fashion....\n. closing this issue as it is not an issue with LAB\n. ",
    "AlexChittock": "Only force the client to release it's cache when there has been an update to the scripts. We use our git revision as the cache buster, which ensures that the latest files are used when we do a release, but continue to be cached for the duration of that release.\n. Only force the client to release it's cache when there has been an update to the scripts. We use our git revision as the cache buster, which ensures that the latest files are used when we do a release, but continue to be cached for the duration of that release.\n. ",
    "aaronpeters": "Yes!\n. +10   We want this Kyle!\n. Yes!\n. +10   We want this Kyle!\n. ",
    "Spotnyk": "Yes! Yes!\n. @getify \n\n``` javascript\n$LAB.wait() error caught:  \nReferenceError\n$LAB.wait() executing: function () {\n                        Comments.init({\n    containerSelector: '#news-comments',\n        rootContentType: 32768,\n    rootContentId: 2989,\n        displayStyle: 'thread',\n    itemsOrder: 'ASC',\n    itemsPerPage: 10,\n    itemsSpanMax: 10,\n    nestLimit: 4,\n    formTop: true,\n    formBottom: true});\n        }\n```\n\nI have not fixed any indenting issues. This is a direct copy out of chrome's console. (sans the filename/line number)\n\nAlso, there is nothing else after this output, other than chrome complaining about Quantcast's js not serving with the right mime type.\n\nIf you need expanded view on the ReferenceError object, I can get you that as well.\n\nIf you can tell me what I'm doing wrong, I will greatly appreciate it.\n\nThanks!\n. I'm sorry, you asked for the information before it as well.\n\nThis is the output right before the ReferenceError\n\n``` javascript\nscript execution finished: http://private.internaldomain.com/?p=rc&s=riotcore2&r=spot&debug=1&cache=0&q=/sections/news.js\n$LAB.wait() executing: function () {\n                        Section_News.init(detail);      }\n```\n. @getify Okay. Thank you sir.\n. @getify \n\nI did locate this problem. Knowing that it can throw from deeper in the call stack was vital in finding it.\n\nThanks again for your time.\n. Yes! Yes!\n. @getify \n\n``` javascript\n$LAB.wait() error caught:  \nReferenceError\n$LAB.wait() executing: function () {\n                        Comments.init({\n    containerSelector: '#news-comments',\n        rootContentType: 32768,\n    rootContentId: 2989,\n        displayStyle: 'thread',\n    itemsOrder: 'ASC',\n    itemsPerPage: 10,\n    itemsSpanMax: 10,\n    nestLimit: 4,\n    formTop: true,\n    formBottom: true});\n        }\n```\n\nI have not fixed any indenting issues. This is a direct copy out of chrome's console. (sans the filename/line number)\n\nAlso, there is nothing else after this output, other than chrome complaining about Quantcast's js not serving with the right mime type.\n\nIf you need expanded view on the ReferenceError object, I can get you that as well.\n\nIf you can tell me what I'm doing wrong, I will greatly appreciate it.\n\nThanks!\n. I'm sorry, you asked for the information before it as well.\n\nThis is the output right before the ReferenceError\n\n``` javascript\nscript execution finished: http://private.internaldomain.com/?p=rc&s=riotcore2&r=spot&debug=1&cache=0&q=/sections/news.js\n$LAB.wait() executing: function () {\n                        Section_News.init(detail);      }\n```\n. @getify Okay. Thank you sir.\n. @getify \n\nI did locate this problem. Knowing that it can throw from deeper in the call stack was vital in finding it.\n\nThanks again for your time.\n. ",
    "paulm17": "I would totally love this! :)\n. I would totally love this! :)\n. ",
    "jasonhinkle": "I don't understand the problem with adding a callback so that devs can choose to listen for errors or not?  I can appreciate a separate debug build for outputting debug info, but even on the production build i'd want to know about errors.  (though I wouldn't want the library writing directly to console.error)\n\nObviously you've put way more thought into it than I have so perhaps I'm missing something.\n. Thanks for the response.  I added the following which works great for my purposes.  All that I really care about is whether an error occurred.  I'd prefer if execution halts at that point but from what you say that's not guaranteed depending on what browser you're working with.  I wouldn't see this as a way of actually \"handling\" errors in order to keep the app in a known state - if this fires I'd assume everything is fubar, but at least I can log it or during development just visually see there was a problem. A try/catch that swallows the error seems dangerous to me and makes it a lot tougher during development.\n\nI'd be interested to know if you think this changes LAB.js functionality in a negative way?  From what I can see it has no impact on anything unless you implement the ErrorHandler function.\n\nhttps://github.com/jasonhinkle/LABjs/blob/master/LAB.src.js  (relevant line 346)\n\nIn my application code I put the following:\n\n``` javascript\n$LAB.setGlobalDefaults({'ErrorHandler': function(err){\n    throw err;\n}});\n```\n\nObviously this is a drastic example of a handler, but for development on Chrome it's exactly what I want.  Are you saying that on other browsers this would not work at all - never get fired?  Or are you just worried that people will use something like this to try to recover from errors - when that is not reliable due to browser differences..?  Or that they will use it and it'll result in a bunch of false error reports for LABjs?\n. I think all of the reasons you mention are absolutely legit, but they are all lesser evils than masking errors.  if you implement it as a handler, then it's not really LABjs's problem to deal with the different browser behaviors.\n\nIf it's mainly about avoiding people blaming LABjs for bugs in their own code - I think good naming of the handler and instructions for it's purpose would help to let people know it is meant only as notification only - and not for handling and recovering from errors.\n. me too\n. Thanks for the though-out reply. I can see the importance of not allowing devs to think that this is an acceptable way to recover from errors because the behavior is not consistent across browsers.  Having a better name that makes it more clear that this is only for observing errors to help with debugging.  I'd welcome the addition.\n\nI'd respectfully suggest that with a handler method you could keep it in your prod build and leave it up to the developer as to what they want to do.  The debug build could perhaps have the callback is defaulted to a function that logs to the console.  The prod build could have the callback defaulted to an empty function.  That way the builds would both be 100% backwards compatible, there would just be a new capability to handle errors differently if the user chose to override the default callback.\n\nTo make a case for having it in the prod build - what I actually plan to do in my handler is make a post to our logging service.  That way if this error ever gets triggered (due to errors in our coded that makes it out the door, specific browser issues, etc) I would see it happening via the error logs.\n\nThanks for the reply and for the code, it's made a huge improvement in load time on an app.  We have certain scripts that load only when you click certain parts of the page (for example clicking on a video will lazy load the necessary video streaming API script files).  I have LABjs loading the basic layout scripts on page load, and then loading more scripts in reaction to user input. It's really amazing how well it works!\n. Thanks for the mention ;-)  Blast from the past, Kyle and I have had this discussion a few times already!\n\nI think we both agree that you shouldn't try to recover from a loading error, but we just have a different philosophy as to what should happen.  Kyle is protecting you from yourself.  My fork, which is really just a very minor tweak, gives you enough rope to hang yourself.  I don't encourage anybody to try to recover from loading errors, though.  From our discussions that's why I understand Kyle doesn't feel it belongs in the main branch - because it would encourage people to do exactly that.  \n\nI use it only so that my app will crash in a more visible way when something goes wrong.  At the end of the day it just making debugging a little easier (for me anyway).  It doesn't make an app any more robust or error-proof.\n. I don't understand the problem with adding a callback so that devs can choose to listen for errors or not?  I can appreciate a separate debug build for outputting debug info, but even on the production build i'd want to know about errors.  (though I wouldn't want the library writing directly to console.error)\n\nObviously you've put way more thought into it than I have so perhaps I'm missing something.\n. Thanks for the response.  I added the following which works great for my purposes.  All that I really care about is whether an error occurred.  I'd prefer if execution halts at that point but from what you say that's not guaranteed depending on what browser you're working with.  I wouldn't see this as a way of actually \"handling\" errors in order to keep the app in a known state - if this fires I'd assume everything is fubar, but at least I can log it or during development just visually see there was a problem. A try/catch that swallows the error seems dangerous to me and makes it a lot tougher during development.\n\nI'd be interested to know if you think this changes LAB.js functionality in a negative way?  From what I can see it has no impact on anything unless you implement the ErrorHandler function.\n\nhttps://github.com/jasonhinkle/LABjs/blob/master/LAB.src.js  (relevant line 346)\n\nIn my application code I put the following:\n\n``` javascript\n$LAB.setGlobalDefaults({'ErrorHandler': function(err){\n    throw err;\n}});\n```\n\nObviously this is a drastic example of a handler, but for development on Chrome it's exactly what I want.  Are you saying that on other browsers this would not work at all - never get fired?  Or are you just worried that people will use something like this to try to recover from errors - when that is not reliable due to browser differences..?  Or that they will use it and it'll result in a bunch of false error reports for LABjs?\n. I think all of the reasons you mention are absolutely legit, but they are all lesser evils than masking errors.  if you implement it as a handler, then it's not really LABjs's problem to deal with the different browser behaviors.\n\nIf it's mainly about avoiding people blaming LABjs for bugs in their own code - I think good naming of the handler and instructions for it's purpose would help to let people know it is meant only as notification only - and not for handling and recovering from errors.\n. me too\n. Thanks for the though-out reply. I can see the importance of not allowing devs to think that this is an acceptable way to recover from errors because the behavior is not consistent across browsers.  Having a better name that makes it more clear that this is only for observing errors to help with debugging.  I'd welcome the addition.\n\nI'd respectfully suggest that with a handler method you could keep it in your prod build and leave it up to the developer as to what they want to do.  The debug build could perhaps have the callback is defaulted to a function that logs to the console.  The prod build could have the callback defaulted to an empty function.  That way the builds would both be 100% backwards compatible, there would just be a new capability to handle errors differently if the user chose to override the default callback.\n\nTo make a case for having it in the prod build - what I actually plan to do in my handler is make a post to our logging service.  That way if this error ever gets triggered (due to errors in our coded that makes it out the door, specific browser issues, etc) I would see it happening via the error logs.\n\nThanks for the reply and for the code, it's made a huge improvement in load time on an app.  We have certain scripts that load only when you click certain parts of the page (for example clicking on a video will lazy load the necessary video streaming API script files).  I have LABjs loading the basic layout scripts on page load, and then loading more scripts in reaction to user input. It's really amazing how well it works!\n. Thanks for the mention ;-)  Blast from the past, Kyle and I have had this discussion a few times already!\n\nI think we both agree that you shouldn't try to recover from a loading error, but we just have a different philosophy as to what should happen.  Kyle is protecting you from yourself.  My fork, which is really just a very minor tweak, gives you enough rope to hang yourself.  I don't encourage anybody to try to recover from loading errors, though.  From our discussions that's why I understand Kyle doesn't feel it belongs in the main branch - because it would encourage people to do exactly that.  \n\nI use it only so that my app will crash in a more visible way when something goes wrong.  At the end of the day it just making debugging a little easier (for me anyway).  It doesn't make an app any more robust or error-proof.\n. ",
    "DebugXYZ": "Looks like there's a handy little fork here https://github.com/jasonhinkle/LABjs-eh\n\nI hope that this can be added as an option in the future.\n. For reference: https://github.com/jasonhinkle/LABjs-eh\n. Looks like there's a handy little fork here https://github.com/jasonhinkle/LABjs-eh\n\nI hope that this can be added as an option in the future.\n. For reference: https://github.com/jasonhinkle/LABjs-eh\n. ",
    "RyanRoberts": "I'd love this!\n. I'd love this!\n. ",
    "jobelenus": "I just had to do this actually... you want:\n\n\"https://www.google.com/jsapi?callback=foo\", where foo is a globally accessible function... then you can use google.load whenever you'd like\n. Just wanted to double-check, this loading failure being discussed here is the same thing a mixed-content (http-in-a-https) warning would trigger, right?\n. I just had to do this actually... you want:\n\n\"https://www.google.com/jsapi?callback=foo\", where foo is a globally accessible function... then you can use google.load whenever you'd like\n. Just wanted to double-check, this loading failure being discussed here is the same thing a mixed-content (http-in-a-https) warning would trigger, right?\n. ",
    "jockster": "Sorry - just noticed that my files already were prefixed with a path and that `LABjs` is intelligent enough to dont add paths to already prefixed files !\n. Sorry - just noticed that my files already were prefixed with a path and that `LABjs` is intelligent enough to dont add paths to already prefixed files !\n. ",
    "GordeevArt": "The \"main.js\" should be loaded after jQuery, not before it. But according to IE debugger it is not happening. Sometimes it is loaded right, but most of the time - wrong.\n. Thanks for the answer. I've updated the question\n. Thank you for the answer\n. The \"main.js\" should be loaded after jQuery, not before it. But according to IE debugger it is not happening. Sometimes it is loaded right, but most of the time - wrong.\n. Thanks for the answer. I've updated the question\n. Thank you for the answer\n. ",
    "joekaiser": "That almost works. What I think is happening is the Queue isn't running until the first chain ends. I have a bit of an interesting scenario, so let me go deeper.\n\nI want to defer all jquery stuff as well, at the top of my page i have \n\n``` javascript\nwindow.global = {}; global.buffer = []; global.ready = function (f) { global.buffer.push(f); };\n```\n\nso instead of doing a `$(function(){})` i do `global.ready(function(){})` and then later I have\n\n``` javascript\n\n//added by child page\n$LAB.queueScript('/pageSpecific.js')\n      .queueWait(function(){\n            global.ready(\n                function(){\n                  pageSpecific.init();\n                });\n        });\n\n$LAB.script('/jquery.js')\n      .wait(function(){ \n         $LAB.runQueue();\n      })\n      .wait(function(){\n              $.each(global.buffer, function (index, f) {\n                    $(f)\n              });\n      });\n```\n\nWith that I can queue up calls to init jquery plugins, or whatever and have them all executed at the very end. But like I mentioned at the beginning, it would appear as if the `.runQueue` call is not getting executed until the very end of the $LAB chain. \n\nThe problem is that the end of the first chain enumerates my buffer and executes all the functions I put in there. I think I can work around it by doing something like\n\n``` javascript\n$LAB.script().wait().....wait(function(){\n        $LAB.runQueue()\n              .wait(function(){\n                    $.each(global.buffer, function (index, f) {\n                         $(f)\n              });\n      });\n});\n```\n\ncan you confirm my suspicion on when runQueue is executed, and do you have any better solution to what I am trying to do?\n. Thanks!\n. I have been following this issue, and feel like adding my thoughts on this :)\n\nI am pretty sure that the Html5Shiv needs to be loaded _outside of_ Lab.JS. Consider this flow\n1. Browser downloads the page\n2. It applys the style\n   - Browser runs into an HTML5 tag and doesn't know what it is...the tag is ignored\n3. Lab chain runs and executes the HTML5 shiv\n\nHow would the browser know to style the HTML5 element without the shiv being loaded? You need to load the shiv BEFORE the lab chain runs to make the execution flow like\n1. Browser downloads the page\n2. Scripts are executed...Html5Shiv loaded \n3. It applys the style\n   - Browser runs into an HTML5 tag and _now knows_ what to do\n4. Lab chain runs the rest of the JS\n\nThis is how I do it, and I don't really notice any performance impact. Essential scripts like the Html5Shiv just need to be loaded like this. If you have your server set up properly the shiv will be cached and the user won't have to download it with every request.  (or use a CDN). In fact, the Html5Shiv site even says\n\n> It must be included before the < body > element (i.e. in the < head >) \n\nLoading it via LAB.js just isn't going to work. Sorry :/\n. @getify  +1!\n\nIt is your stance on stability over small features that keeps me on LAB.js over any other library out there. \n. I a small effort to save @getify from answering this again, please see https://github.com/getify/LABjs/pull/85#issuecomment-20476024 :)\n. That almost works. What I think is happening is the Queue isn't running until the first chain ends. I have a bit of an interesting scenario, so let me go deeper.\n\nI want to defer all jquery stuff as well, at the top of my page i have \n\n``` javascript\nwindow.global = {}; global.buffer = []; global.ready = function (f) { global.buffer.push(f); };\n```\n\nso instead of doing a `$(function(){})` i do `global.ready(function(){})` and then later I have\n\n``` javascript\n\n//added by child page\n$LAB.queueScript('/pageSpecific.js')\n      .queueWait(function(){\n            global.ready(\n                function(){\n                  pageSpecific.init();\n                });\n        });\n\n$LAB.script('/jquery.js')\n      .wait(function(){ \n         $LAB.runQueue();\n      })\n      .wait(function(){\n              $.each(global.buffer, function (index, f) {\n                    $(f)\n              });\n      });\n```\n\nWith that I can queue up calls to init jquery plugins, or whatever and have them all executed at the very end. But like I mentioned at the beginning, it would appear as if the `.runQueue` call is not getting executed until the very end of the $LAB chain. \n\nThe problem is that the end of the first chain enumerates my buffer and executes all the functions I put in there. I think I can work around it by doing something like\n\n``` javascript\n$LAB.script().wait().....wait(function(){\n        $LAB.runQueue()\n              .wait(function(){\n                    $.each(global.buffer, function (index, f) {\n                         $(f)\n              });\n      });\n});\n```\n\ncan you confirm my suspicion on when runQueue is executed, and do you have any better solution to what I am trying to do?\n. Thanks!\n. I have been following this issue, and feel like adding my thoughts on this :)\n\nI am pretty sure that the Html5Shiv needs to be loaded _outside of_ Lab.JS. Consider this flow\n1. Browser downloads the page\n2. It applys the style\n   - Browser runs into an HTML5 tag and doesn't know what it is...the tag is ignored\n3. Lab chain runs and executes the HTML5 shiv\n\nHow would the browser know to style the HTML5 element without the shiv being loaded? You need to load the shiv BEFORE the lab chain runs to make the execution flow like\n1. Browser downloads the page\n2. Scripts are executed...Html5Shiv loaded \n3. It applys the style\n   - Browser runs into an HTML5 tag and _now knows_ what to do\n4. Lab chain runs the rest of the JS\n\nThis is how I do it, and I don't really notice any performance impact. Essential scripts like the Html5Shiv just need to be loaded like this. If you have your server set up properly the shiv will be cached and the user won't have to download it with every request.  (or use a CDN). In fact, the Html5Shiv site even says\n\n> It must be included before the < body > element (i.e. in the < head >) \n\nLoading it via LAB.js just isn't going to work. Sorry :/\n. @getify  +1!\n\nIt is your stance on stability over small features that keeps me on LAB.js over any other library out there. \n. I a small effort to save @getify from answering this again, please see https://github.com/getify/LABjs/pull/85#issuecomment-20476024 :)\n. ",
    "dmethvin": "Okay, they were using version 1.2, which does seem to be broken for IE10. Upgrading to 2.0 fixes the problem.\n\nhttps://github.com/getify/LABjs/blob/172887ec2e753a44b74f03f8a048c5f2f701778b/LAB.src.js#L113\n. Oh and I completely agree about the IE10 issues, it's impossible to debug them without Windows 8. I have a Windows 8 system now but before that I was using Browserstack with reasonable success.\n. Okay, they were using version 1.2, which does seem to be broken for IE10. Upgrading to 2.0 fixes the problem.\n\nhttps://github.com/getify/LABjs/blob/172887ec2e753a44b74f03f8a048c5f2f701778b/LAB.src.js#L113\n. Oh and I completely agree about the IE10 issues, it's impossible to debug them without Windows 8. I have a Windows 8 system now but before that I was using Browserstack with reasonable success.\n. ",
    "toxcct": "No no, as I mentioned, the html contains in its `<head>` the two `<style>` tags to load the CSS files, anf afterward, the two `<script>` related to _lab.min.js_ and to _init.js_.\n\nI'll provide more info tomorrow when I can put a hand back on those sources.\n\nIs there a private way I could also send you some screenshots and maybe the _init.js_ file if you will ?\n. Hello Kyle,\n\nI removed as you suggested the `<script>` that was to load _lab.min.js_, and added its content directly within my init.js file. Now, my `<head>` looks like this, but the strange behavior still happens in IE7 and IE8, but not on Chrome:\n\n``` html\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-cache\">\n    <title>Whatever title</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./css/general.css\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./css/ui-lightness/jquery-ui.css\">\n    <script type=\"text/javascript\" src=\"./js/init.js\"></script>\n</head>\n<body>\n    ...\n</body>\n</html>\n```\n\nand within my init.js:\n\n``` javascript\n(function(o){/*...lab.js source code minified here...*/})(this);\n\n$LAB.setGlobalDefaults({BasePath:\"./js/\"});\n$LAB.script(\"libs/jquery-1.8.0.min.js\").wait()\n    .script(\"libs/jquery-ui-1.8.23.min.js\")\n    .script(\"script1.js\")\n    .script(\"script2.js\")\n\n    //...and much more loaded here...\n\n    .wait(function(){\n        $(function(){\n            //Actual init code here, to be executed on DOM ready...\n            //...\n        });\n    });\n```\n\nIn Chrome, the interesting thing I observe however is that in the DOM, the `<head>` element contains the `<script>` tags in the opposite order to what i asked them to be loaded. I guess that doesn't matter much, as their execution is constrained by the final `.wait()`, but I would intend to see the scripts appended to the `<head>` rather than prepended. Is this a desired behavior ?\n\nBTW, email sent with some screenshots explaining the actual issue.\n\nThanks for you help\n. Hello,\n\nCan you tell me if you're not replying because you have no clue, or if you're just busy doing something else ?\nI'd like to know if in the end, this issue is from my code or from LABjs's.\n\nThanks and regards,\nToxcct\n. Some of the scripts are, indeed, dependant of the jqUI, but they are all built as modules and they actually build namespaces rather than directly modifying the DOM. All those modules have a .init() function that is called in the very last .wait() of the chain, so I don't feel the need to put a .wait() after the jqueryUI file too. Should have I ?\n\nAlso, the CSS rules that are not applied in my case (the page header background for instance in the screenshots I sent you) are coded in the CSS file, and not applied with any JS script that would be using jQuery. And I'm not getting any error in the console, which I guess would have been the case if my modules would attempt to use a script that is not yet loaded. Am I right ?\n. Hi Kyle,\n\nI've tried several tests in regard to your advices, and the result is quite surprising.\n\nI first tried to use the `AlwaysPreserveOrder`, to put a `.wait()` after every `.script()` call, and even both, but noneworked better.\n\nSo I then tried to test with a minimal test case to have your step in my weird bus :)\nThe thing is, I even commented out almost everything, and I noticed that my script that is having a hard time working with LABjs is `html5shiv.js` (A project to be able to use HTML5 tags in old browers : http://code.google.com/p/html5shiv/ ).\nIf in my html page, I load that script using `<script type=\"text/javascript\" src=\"html5shiv.js\"></script>`, then the page styles correctly those HTML5 elements.\nHowever, if I use the following code, then the file is not loaded (or at least, not at the right moment regarding the browser's CSS rules application):\n\n``` html\n<!DOCTYPE html>\n<html>\n    <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    <title>...</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"general.css\"/>\n    <script type=\"text/javascript\" src=\"init.js\"></script>\n</head>\n<body>\n    ...\n```\n\nand then **init.js**:\n\n``` javascript\n(function(o){...LAB.min.js copied inline here...})(this);\n\n$LAB.setGlobalDefaults({ AlwaysPreserveOrder : true });\n$LAB.script(\"html5shiv.js\");\n```\n\nSo we're coming close I believe, but then I can't figure out why LABjs is troubling the browser that way...\nCurrently then, I forced the `html5shiv.js` to be loaded in a &lt;script> tag before my `init.js` which loads every other modules. The page now displays fine in every browsers and every versions.\nI'd prefer anyway to have it loaded like all the other scripts, and not having to make an exception of its case...\n\nWhat you think ?\n. @getify \nWell for the load event not always sent regarding the browser, that can be an endless philosophical discussion. For my part, I wouldn't mind if the load event is fired if the page requested in the address bar is retrieved but not all the relative contents, like images (but you got me unprepared on this question, and never really thought about that anyway :-) ).\n\nFor the error event, I was more thinking of a way to get the status of the XHR object. This way, you could have a first serious check on how a script was retrieved (if the status is \"OK\", then you can proceed, but if the status is \"Not found\", then the chain could fall back in an error callback if provided, or continue with the default behavior if not).\nI'm especially thinking of how jQuery is allowing to retrieve content and to handle the success and error cases...\n\nI've barelly seen how @jasonhinkle forked LABjs to add his own handling, but i'm not sure this is what i'm after though.\n. No no, as I mentioned, the html contains in its `<head>` the two `<style>` tags to load the CSS files, anf afterward, the two `<script>` related to _lab.min.js_ and to _init.js_.\n\nI'll provide more info tomorrow when I can put a hand back on those sources.\n\nIs there a private way I could also send you some screenshots and maybe the _init.js_ file if you will ?\n. Hello Kyle,\n\nI removed as you suggested the `<script>` that was to load _lab.min.js_, and added its content directly within my init.js file. Now, my `<head>` looks like this, but the strange behavior still happens in IE7 and IE8, but not on Chrome:\n\n``` html\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-cache\">\n    <title>Whatever title</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./css/general.css\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./css/ui-lightness/jquery-ui.css\">\n    <script type=\"text/javascript\" src=\"./js/init.js\"></script>\n</head>\n<body>\n    ...\n</body>\n</html>\n```\n\nand within my init.js:\n\n``` javascript\n(function(o){/*...lab.js source code minified here...*/})(this);\n\n$LAB.setGlobalDefaults({BasePath:\"./js/\"});\n$LAB.script(\"libs/jquery-1.8.0.min.js\").wait()\n    .script(\"libs/jquery-ui-1.8.23.min.js\")\n    .script(\"script1.js\")\n    .script(\"script2.js\")\n\n    //...and much more loaded here...\n\n    .wait(function(){\n        $(function(){\n            //Actual init code here, to be executed on DOM ready...\n            //...\n        });\n    });\n```\n\nIn Chrome, the interesting thing I observe however is that in the DOM, the `<head>` element contains the `<script>` tags in the opposite order to what i asked them to be loaded. I guess that doesn't matter much, as their execution is constrained by the final `.wait()`, but I would intend to see the scripts appended to the `<head>` rather than prepended. Is this a desired behavior ?\n\nBTW, email sent with some screenshots explaining the actual issue.\n\nThanks for you help\n. Hello,\n\nCan you tell me if you're not replying because you have no clue, or if you're just busy doing something else ?\nI'd like to know if in the end, this issue is from my code or from LABjs's.\n\nThanks and regards,\nToxcct\n. Some of the scripts are, indeed, dependant of the jqUI, but they are all built as modules and they actually build namespaces rather than directly modifying the DOM. All those modules have a .init() function that is called in the very last .wait() of the chain, so I don't feel the need to put a .wait() after the jqueryUI file too. Should have I ?\n\nAlso, the CSS rules that are not applied in my case (the page header background for instance in the screenshots I sent you) are coded in the CSS file, and not applied with any JS script that would be using jQuery. And I'm not getting any error in the console, which I guess would have been the case if my modules would attempt to use a script that is not yet loaded. Am I right ?\n. Hi Kyle,\n\nI've tried several tests in regard to your advices, and the result is quite surprising.\n\nI first tried to use the `AlwaysPreserveOrder`, to put a `.wait()` after every `.script()` call, and even both, but noneworked better.\n\nSo I then tried to test with a minimal test case to have your step in my weird bus :)\nThe thing is, I even commented out almost everything, and I noticed that my script that is having a hard time working with LABjs is `html5shiv.js` (A project to be able to use HTML5 tags in old browers : http://code.google.com/p/html5shiv/ ).\nIf in my html page, I load that script using `<script type=\"text/javascript\" src=\"html5shiv.js\"></script>`, then the page styles correctly those HTML5 elements.\nHowever, if I use the following code, then the file is not loaded (or at least, not at the right moment regarding the browser's CSS rules application):\n\n``` html\n<!DOCTYPE html>\n<html>\n    <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    <title>...</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"general.css\"/>\n    <script type=\"text/javascript\" src=\"init.js\"></script>\n</head>\n<body>\n    ...\n```\n\nand then **init.js**:\n\n``` javascript\n(function(o){...LAB.min.js copied inline here...})(this);\n\n$LAB.setGlobalDefaults({ AlwaysPreserveOrder : true });\n$LAB.script(\"html5shiv.js\");\n```\n\nSo we're coming close I believe, but then I can't figure out why LABjs is troubling the browser that way...\nCurrently then, I forced the `html5shiv.js` to be loaded in a &lt;script> tag before my `init.js` which loads every other modules. The page now displays fine in every browsers and every versions.\nI'd prefer anyway to have it loaded like all the other scripts, and not having to make an exception of its case...\n\nWhat you think ?\n. @getify \nWell for the load event not always sent regarding the browser, that can be an endless philosophical discussion. For my part, I wouldn't mind if the load event is fired if the page requested in the address bar is retrieved but not all the relative contents, like images (but you got me unprepared on this question, and never really thought about that anyway :-) ).\n\nFor the error event, I was more thinking of a way to get the status of the XHR object. This way, you could have a first serious check on how a script was retrieved (if the status is \"OK\", then you can proceed, but if the status is \"Not found\", then the chain could fall back in an error callback if provided, or continue with the default behavior if not).\nI'm especially thinking of how jQuery is allowing to retrieve content and to handle the success and error cases...\n\nI've barelly seen how @jasonhinkle forked LABjs to add his own handling, but i'm not sure this is what i'm after though.\n. ",
    "webbird": "Hmmm... seems to be a local problem, same thing works on another server... Strange.\n. Thanks for the hint!\n. Hmmm... seems to be a local problem, same thing works on another server... Strange.\n. Thanks for the hint!\n. ",
    "ramaralo": "I just found that exceptions are being thrown even with\n\n$LAB.setGlobalDefaults({Debug: false});\n\nI must have been doing something wrong that made exceptions silent. Perhaps something on the wr4j (http://code.google.com/p/wro4j/).\n\nAnyway, behavior in FF12 is different than in IE8. In FF, exceptions are visible in console only after all scripts have been loaded, while in IE, they are visible at the moment they are fired. This is good enough for me!\n\nI completely agree with your approach to upgrades management! LAB wasn't designed for me. So my needs may not be everyone's needs and it is in my own interests to have a stable LAB ;)\n\nKeep up the good work, and thanks for you suggestion!\n\nBest regards.\n. Yes I confirm that things are working as desired. Thanks a lot! ;)\n. I just found that exceptions are being thrown even with\n\n$LAB.setGlobalDefaults({Debug: false});\n\nI must have been doing something wrong that made exceptions silent. Perhaps something on the wr4j (http://code.google.com/p/wro4j/).\n\nAnyway, behavior in FF12 is different than in IE8. In FF, exceptions are visible in console only after all scripts have been loaded, while in IE, they are visible at the moment they are fired. This is good enough for me!\n\nI completely agree with your approach to upgrades management! LAB wasn't designed for me. So my needs may not be everyone's needs and it is in my own interests to have a stable LAB ;)\n\nKeep up the good work, and thanks for you suggestion!\n\nBest regards.\n. Yes I confirm that things are working as desired. Thanks a lot! ;)\n. ",
    "jasonday": "Hey Getify, \n\nthanks for responding so quickly. Below is our setup, which we did not change when we upgraded from 1.2 to 2.0.\n\n$LAB ready function with a check for myFunction which is in promo.js (loaded with $LAB)\n\n``` javascript\n$LAB.ready(function(){\n    if(myFunction){\n        $ajax call\n    }\n```\n\n$LAB call:\n\n``` javascript\n// Load all js files with $LAB                          \n        $LAB    \n        .script(\"/js/jquery.min.js\").wait() \n        .script(\"/js/jquery-ui-light.min.js\").wait()\n        /*... 17 more scripts ...*/\n        .script(\"/js/promo.js\").wait()\n        .wait($LAB.run);\n```\n\nWe use $LAB.ready quite a bit on our homepage, to ensure proper sequencing as the page is mainly a header/footer with a big unstructured content area.\n\nSo with the above setup, when we went to version 2.0, our page load times increased by 1 second over a large dataset. So we reverted to 1.2, but are taking the hit with the IE10 issue. In IE10, the reference to if(myFunction) is returning an error - myFunction is undefined.\n\nSo the biggest issue for us is figuring out what was causing the increase in page load times.\n. `$LAB.ready` and `$LAB.run` are custom events that a prior developer put together. I'm not sure what issue they were attempting to address.\n\n``` javascript\n(function () {\n    var a = {\n        events: [],\n        registerEvent: function (c) {\n            a.events.push(c)\n        },\n        executeAllEvents: function () {\n            for (var c = a.events.length, b = 0; b < c; b++) {\n                try {\n                    if (typeof a.events[b] === \"function\") {\n                        a.events[b]();\n                    } else {\n                        if (window.console) {\n                            console.log(\"error in LAB.js: \" + err);\n                        }\n                    }\n                } catch (err) {\n                    if (window.console) {\n                        console.log(\"error in LAB.js: \" + err);\n                    }\n                }\n            }\n        }\n    };\n    $LAB.ready = a.registerEvent;\n    $LAB.run = a.executeAllEvents\n})();\n\n```\n. We have a monitoring tool - gomez (gomez.com) - that measures page performance/response time for the page load and reports an average from data collected across our servers. In IE8 we were seeing a reported spike of an additional 1+ seconds on full page load time.\n\nI assume for this to work there's some additional trickery for IE8, so I'm hoping you can shed some light on the IE8 mechanics and potential causes for the increase.\n. Dupe scripts is a possibility due to how the content structure works. Although a check is typically added to see if the script has been loaded, but it's possible that the logic somewhere is off.\n\nAdditionally, on the rest of the site, we concatenate scripts heavily and we actually don't use LAB in those scenarios.  However, to increase our homepage perceived and actual load times, we use LAB. Our typical times were in the 1.4-1.5 seconds, and when we implemented 2.0 it jumped to 2.5. \n\nI will do some additional digging - track down additional numbers and see if there are conflicts elsewhere.\n\nA colleague may join in the conversation here as well.\n. thanks Kyle. I'll try it in a dev/staging environment and post back.\n. thanks! Sorry, I got sidetracked on other issues/projects. I will round back with this with my team.\n. Hey Getify, \n\nthanks for responding so quickly. Below is our setup, which we did not change when we upgraded from 1.2 to 2.0.\n\n$LAB ready function with a check for myFunction which is in promo.js (loaded with $LAB)\n\n``` javascript\n$LAB.ready(function(){\n    if(myFunction){\n        $ajax call\n    }\n```\n\n$LAB call:\n\n``` javascript\n// Load all js files with $LAB                          \n        $LAB    \n        .script(\"/js/jquery.min.js\").wait() \n        .script(\"/js/jquery-ui-light.min.js\").wait()\n        /*... 17 more scripts ...*/\n        .script(\"/js/promo.js\").wait()\n        .wait($LAB.run);\n```\n\nWe use $LAB.ready quite a bit on our homepage, to ensure proper sequencing as the page is mainly a header/footer with a big unstructured content area.\n\nSo with the above setup, when we went to version 2.0, our page load times increased by 1 second over a large dataset. So we reverted to 1.2, but are taking the hit with the IE10 issue. In IE10, the reference to if(myFunction) is returning an error - myFunction is undefined.\n\nSo the biggest issue for us is figuring out what was causing the increase in page load times.\n. `$LAB.ready` and `$LAB.run` are custom events that a prior developer put together. I'm not sure what issue they were attempting to address.\n\n``` javascript\n(function () {\n    var a = {\n        events: [],\n        registerEvent: function (c) {\n            a.events.push(c)\n        },\n        executeAllEvents: function () {\n            for (var c = a.events.length, b = 0; b < c; b++) {\n                try {\n                    if (typeof a.events[b] === \"function\") {\n                        a.events[b]();\n                    } else {\n                        if (window.console) {\n                            console.log(\"error in LAB.js: \" + err);\n                        }\n                    }\n                } catch (err) {\n                    if (window.console) {\n                        console.log(\"error in LAB.js: \" + err);\n                    }\n                }\n            }\n        }\n    };\n    $LAB.ready = a.registerEvent;\n    $LAB.run = a.executeAllEvents\n})();\n\n```\n. We have a monitoring tool - gomez (gomez.com) - that measures page performance/response time for the page load and reports an average from data collected across our servers. In IE8 we were seeing a reported spike of an additional 1+ seconds on full page load time.\n\nI assume for this to work there's some additional trickery for IE8, so I'm hoping you can shed some light on the IE8 mechanics and potential causes for the increase.\n. Dupe scripts is a possibility due to how the content structure works. Although a check is typically added to see if the script has been loaded, but it's possible that the logic somewhere is off.\n\nAdditionally, on the rest of the site, we concatenate scripts heavily and we actually don't use LAB in those scenarios.  However, to increase our homepage perceived and actual load times, we use LAB. Our typical times were in the 1.4-1.5 seconds, and when we implemented 2.0 it jumped to 2.5. \n\nI will do some additional digging - track down additional numbers and see if there are conflicts elsewhere.\n\nA colleague may join in the conversation here as well.\n. thanks Kyle. I'll try it in a dev/staging environment and post back.\n. thanks! Sorry, I got sidetracked on other issues/projects. I will round back with this with my team.\n. ",
    "fletc3her": "I'm finding myself in need of something similar.  Pinterest is recommending the following tag to load their button decorator.  I've been loading the tag through LABjs plain, but I don't see any way to add the data-pin-hover parameter.\n\n<script type=\"text/javascript\" data-pin-hover=\"true\" src=\"//assets.pinterest.com/js/pinit.js\"></script>\n\nI was considering patching the two lines where charset is added to the script tag with something like the following.\n\nif (script_obj.params) for(x in script_obj.params) script.setAttribute(x, script_obj.params[x]);\n\nAnd then calling\n\n$LAB.queueScript(\"//assets.pinterest.com/js/pinit.js\",params={data-pin-hover:true})\n\nI haven't been able to test whether this is sound yet though.\n. I'm finding myself in need of something similar.  Pinterest is recommending the following tag to load their button decorator.  I've been loading the tag through LABjs plain, but I don't see any way to add the data-pin-hover parameter.\n\n<script type=\"text/javascript\" data-pin-hover=\"true\" src=\"//assets.pinterest.com/js/pinit.js\"></script>\n\nI was considering patching the two lines where charset is added to the script tag with something like the following.\n\nif (script_obj.params) for(x in script_obj.params) script.setAttribute(x, script_obj.params[x]);\n\nAnd then calling\n\n$LAB.queueScript(\"//assets.pinterest.com/js/pinit.js\",params={data-pin-hover:true})\n\nI haven't been able to test whether this is sound yet though.\n. ",
    "soxofaan": "Hi,\n\nhttp://blog.errorception.com/2012/12/catching-cross-domain-js-errors.html gives some more real-world background about this feature request.\n\n> if we add this to core, this should only be in the debug build of LABjs and not the main minified build,\n\nI disagree here, we want to use this feature for error logging on our live production site, for catching errors in the browser from our real users (where we have a setup with CDN and cross origin issues). It is not for debugging (when you typically don't work with a CDN and don't have cross origin issues).\n. Hi,\n\nhttp://blog.errorception.com/2012/12/catching-cross-domain-js-errors.html gives some more real-world background about this feature request.\n\n> if we add this to core, this should only be in the debug build of LABjs and not the main minified build,\n\nI disagree here, we want to use this feature for error logging on our live production site, for catching errors in the browser from our real users (where we have a setup with CDN and cross origin issues). It is not for debugging (when you typically don't work with a CDN and don't have cross origin issues).\n. ",
    "alexstanbury": "Did this ever make it into the debug build? I can't see anything in the docs or from a quick scan of the code. . Did this ever make it into the debug build? I can't see anything in the docs or from a quick scan of the code. . ",
    "Enalmada": "I don't believe it is safe for any website supporting service workers to use LABjs in production without crossorigin functionality.  I have just learned the hard way that a service worker can't see the response code of scripts loaded from external cdn unless crossorigin=\"anonymous\" is added:\r\n`<script src=\"https://cdn.example.com/foo.js\" crossorigin=\"anonymous\">`\r\n\r\nWithout crossorigin, the service worker just sees result status 0 \"opaque\" for everything and if there happens to be an error, it will cache the error response in the client browser till cache timeout (which people usually set very long since these are static assets).  \r\n\r\nI came here in hopes that there was a flag to enable LABjs crossorigin and found this pull request.  Because the landscape has changed since this pull request was opened and service workers are a thing now, I am hoping that it makes for crossorigin to be officially supported.  . That insert suggestion is perfect!  Thank you @getify (and @MassiveMedia) for keeping me going with LABjs until 3.0 is ready.  I love it very much and am very grateful for such a fantastic contribution to the community.. I don't believe it is safe for any website supporting service workers to use LABjs in production without crossorigin functionality.  I have just learned the hard way that a service worker can't see the response code of scripts loaded from external cdn unless crossorigin=\"anonymous\" is added:\r\n`<script src=\"https://cdn.example.com/foo.js\" crossorigin=\"anonymous\">`\r\n\r\nWithout crossorigin, the service worker just sees result status 0 \"opaque\" for everything and if there happens to be an error, it will cache the error response in the client browser till cache timeout (which people usually set very long since these are static assets).  \r\n\r\nI came here in hopes that there was a flag to enable LABjs crossorigin and found this pull request.  Because the landscape has changed since this pull request was opened and service workers are a thing now, I am hoping that it makes for crossorigin to be officially supported.  . That insert suggestion is perfect!  Thank you @getify (and @MassiveMedia) for keeping me going with LABjs until 3.0 is ready.  I love it very much and am very grateful for such a fantastic contribution to the community.. ",
    "sergeevabc": "@getify, thank you for sharing your thoughts.\n\nYou see, I'm just an end-user seeking for a way to simplify small projects management. That's why I switched from plain hierarchy (with numerous index.php inside subfolders) to PHP microframework with routes (single index.php in root serves everything) and template engine (which inheritance feature is a true time-saver). Then I mastered CSS preprocessor. \n\nNow it's time for javascripts \u2014 _it's convenient to keep all rules in one file instead of writing lazyloads per page, isn't it?_ \nHowever, even major loaders like **LABjs** have no built-in functionality to solve the problem, right?\n\nYour point is clear: if condition is true, then scriptloader will gladly serve any scripts.\nBut the core question is what's the best way to create conditional route system in `init.js`?\n. @getify , is there a fallback functionality built-in (still speaking about **LABjs**)?\nI'm confused as one developer [says yes](http://www.mostlylucid.co.uk/archive/2010/07/09/of-the-beginninghellip.aspx), another says no and offers a tricky, but [enormous workaround](https://gist.github.com/getify/670840).\n. @getify, as a developer wannabe and a foreigner, I appreciate your comprehensive replies in plain English.\n\nLet me share a basic solution to original case I have come up with.\n\n1) Download _lab.min.js_.\n2) Rename it to _init.js_.\n3) Add `<script src=\"/js/init.js\"></script>` into `<HEAD>` of all pages.\n4) Add the following code inside _init.js_.  \n\n```\n...original lab.min.js goes here...\n\n// Parse URL to get last argument before trailing slash as page name, or set / for root page\n// e.g. http://domain.tld/portfolio/dell/ -> dell, http://domain.tld/ -> /\nvar path = location.pathname.split(\"/\"),\n    page = path[path.length-2] || \"/\";\n\n// Scripts for all pages\n$LAB\n        .queueScript(\"/js/lib/jquery.js\")\n        .queueWait();\n\n// Scripts per page\nswitch (page) {\n    case '/':\n        $LAB\n        .queueScript(\"/js/lib/soundmanager2.js\");\n        break;\n    case 'portfolio':\n        $LAB\n        .queueScript(\"/js/lib/lightbox.js\");\n        break;\n    case 'contacts':\n        $LAB\n        .queueScript(\"/js/lib/forms.js\");\n        break;\n}\n\n// Load last instructions and execute the queue, cutie\n$LAB\n        .queueScript(\"/js/letsrock.js\")\n        .runQueue();\n```\n\nSolution is basic indeed, yet it serves the purpose without overhead of extra `<script>` attributes and 3rd-party routers.\nUnfortunately, fallback is not built-in and it's not that obvious how to use gist fork you mentioned above with this chain.\n. @getify, thank you for sharing your thoughts.\n\nYou see, I'm just an end-user seeking for a way to simplify small projects management. That's why I switched from plain hierarchy (with numerous index.php inside subfolders) to PHP microframework with routes (single index.php in root serves everything) and template engine (which inheritance feature is a true time-saver). Then I mastered CSS preprocessor. \n\nNow it's time for javascripts \u2014 _it's convenient to keep all rules in one file instead of writing lazyloads per page, isn't it?_ \nHowever, even major loaders like **LABjs** have no built-in functionality to solve the problem, right?\n\nYour point is clear: if condition is true, then scriptloader will gladly serve any scripts.\nBut the core question is what's the best way to create conditional route system in `init.js`?\n. @getify , is there a fallback functionality built-in (still speaking about **LABjs**)?\nI'm confused as one developer [says yes](http://www.mostlylucid.co.uk/archive/2010/07/09/of-the-beginninghellip.aspx), another says no and offers a tricky, but [enormous workaround](https://gist.github.com/getify/670840).\n. @getify, as a developer wannabe and a foreigner, I appreciate your comprehensive replies in plain English.\n\nLet me share a basic solution to original case I have come up with.\n\n1) Download _lab.min.js_.\n2) Rename it to _init.js_.\n3) Add `<script src=\"/js/init.js\"></script>` into `<HEAD>` of all pages.\n4) Add the following code inside _init.js_.  \n\n```\n...original lab.min.js goes here...\n\n// Parse URL to get last argument before trailing slash as page name, or set / for root page\n// e.g. http://domain.tld/portfolio/dell/ -> dell, http://domain.tld/ -> /\nvar path = location.pathname.split(\"/\"),\n    page = path[path.length-2] || \"/\";\n\n// Scripts for all pages\n$LAB\n        .queueScript(\"/js/lib/jquery.js\")\n        .queueWait();\n\n// Scripts per page\nswitch (page) {\n    case '/':\n        $LAB\n        .queueScript(\"/js/lib/soundmanager2.js\");\n        break;\n    case 'portfolio':\n        $LAB\n        .queueScript(\"/js/lib/lightbox.js\");\n        break;\n    case 'contacts':\n        $LAB\n        .queueScript(\"/js/lib/forms.js\");\n        break;\n}\n\n// Load last instructions and execute the queue, cutie\n$LAB\n        .queueScript(\"/js/letsrock.js\")\n        .runQueue();\n```\n\nSolution is basic indeed, yet it serves the purpose without overhead of extra `<script>` attributes and 3rd-party routers.\nUnfortunately, fallback is not built-in and it's not that obvious how to use gist fork you mentioned above with this chain.\n. ",
    "pllee": "Thanks for the quick and thorough response.  I was able to get IE to behave like the other browsers by setting can_use_preloading `can_use_preloading = real_preloading || xhr_or_cache_preloading,` to false.  Seems like not a very good hack but it looks like it works.  Thanks again for the response.\n. Thanks for the input and the warning about cross browser issues.  I am writing our serial scriptloader to load and execute an array of scripts but keep the order if other scripts are loaded within the scripts.  \nFor example\n\n```\n1.js \nload(2,3);\n\nload(1,4,5)\n\n```\n\nIn our old scriptloader load(1,4,5) would load 1,4,5 in parallel and then execute them in order which would cause the order to be 1,4,5,2,3.\n\nTo solve this non-trivial problem (and sadly not take advantage of a great feature of lab) serial scripts are loaded one at a time.  I don't know what scripts are loading and if any of them container other script loads.   To do it in parallel the loader would be able to load 1,4,5 parallel, execute 1 when 5 is ready see that 1 loads 2 and 3 and then wait to execute 4,5 till after 2 and 3 load.  Is this possible to do with Lab?  Thanks again for the input.\n. Thanks again for the input, much appreciated.  I think you just saved us some nightmares for our devs and support team.  \n. Thanks for the quick and thorough response.  I was able to get IE to behave like the other browsers by setting can_use_preloading `can_use_preloading = real_preloading || xhr_or_cache_preloading,` to false.  Seems like not a very good hack but it looks like it works.  Thanks again for the response.\n. Thanks for the input and the warning about cross browser issues.  I am writing our serial scriptloader to load and execute an array of scripts but keep the order if other scripts are loaded within the scripts.  \nFor example\n\n```\n1.js \nload(2,3);\n\nload(1,4,5)\n\n```\n\nIn our old scriptloader load(1,4,5) would load 1,4,5 in parallel and then execute them in order which would cause the order to be 1,4,5,2,3.\n\nTo solve this non-trivial problem (and sadly not take advantage of a great feature of lab) serial scripts are loaded one at a time.  I don't know what scripts are loading and if any of them container other script loads.   To do it in parallel the loader would be able to load 1,4,5 parallel, execute 1 when 5 is ready see that 1 loads 2 and 3 and then wait to execute 4,5 till after 2 and 3 load.  Is this possible to do with Lab?  Thanks again for the input.\n. Thanks again for the input, much appreciated.  I think you just saved us some nightmares for our devs and support team.  \n. ",
    "omerduzyol": "Yes, I mistakenly changed the whitespaces but now i fixed. You can simply compare the changes.\n\nI added failure handling listeners to your registry item and fail() method added to chain. I remained your chaining and cursor execution system but I did some simple touches on advance_exec_cursor() method to trigger fail callback.\n\nI can understand your concerns about consistency and standards but I think you should check the feature first :)\n. I can see the actual changes by https://github.com/getify/LABjs/pull/85/files\n. I would not try to convince you by answering your thoughts one by one. \n\nIt's my bad and the case is closed. \n. Yes, I mistakenly changed the whitespaces but now i fixed. You can simply compare the changes.\n\nI added failure handling listeners to your registry item and fail() method added to chain. I remained your chaining and cursor execution system but I did some simple touches on advance_exec_cursor() method to trigger fail callback.\n\nI can understand your concerns about consistency and standards but I think you should check the feature first :)\n. I can see the actual changes by https://github.com/getify/LABjs/pull/85/files\n. I would not try to convince you by answering your thoughts one by one. \n\nIt's my bad and the case is closed. \n. ",
    "JollyWizard": "I see what you're saying about inherent inconsistency and it makes a lot of sense.  The point of the library is not to define new standards, it's to standardize disparate solutions.  I made my request assuming that there was better functionality in browsers in general.\n. Sorry, I missed that, I'll continue my thought process there.\n. I see what you're saying about inherent inconsistency and it makes a lot of sense.  The point of the library is not to define new standards, it's to standardize disparate solutions.  I made my request assuming that there was better functionality in browsers in general.\n. Sorry, I missed that, I'll continue my thought process there.\n. ",
    "cuizeng247": "Thank you very much.\nWe've known where the problem is and will take time to rewrite the code. \nLABjs is good to use!\n. Thank you very much.\nWe've known where the problem is and will take time to rewrite the code. \nLABjs is good to use!\n. ",
    "vajrayanu": "@getify  how to send parameter to controller by 'window.location.href'\n. @getify  how to send parameter to controller by 'window.location.href'\n. ",
    "mklepaczewski": "Wow, I knew that You still provide support for the library but wasn't expecting so quick response! Thanks!\n\nI'm using v2.0.3, here's the test on the web:\nhttp://www.data-diggers.com/test/test.html\n\nNote: It gets even bit more stranger. In Opera 9.63 if I hit Refresh the script executes as expected, but if I just load it again (type the address again without refreshing it ) the script misbahaves and wait() body is executed immediately. Maybe it's caching issue? It seems that if the script is cached control to .wait() is passed right away without waiting for script execution to finish.\n. Thanks, it will be great if You will be able to fix it.\n. Wow, I knew that You still provide support for the library but wasn't expecting so quick response! Thanks!\n\nI'm using v2.0.3, here's the test on the web:\nhttp://www.data-diggers.com/test/test.html\n\nNote: It gets even bit more stranger. In Opera 9.63 if I hit Refresh the script executes as expected, but if I just load it again (type the address again without refreshing it ) the script misbahaves and wait() body is executed immediately. Maybe it's caching issue? It seems that if the script is cached control to .wait() is passed right away without waiting for script execution to finish.\n. Thanks, it will be great if You will be able to fix it.\n. ",
    "hungrytom": "Hi,\n\nI am also experiencing this with LABjs (v1.2.0) in IE10. Interestingly, it does not appear to have this problem in earlier versions of IE (or any other browser that I've tried so far)...\n\nMy LABjs loader code looks something like this:\n\n$LAB.setOptions({AlwaysPreserveOrder:true})\n        .script([BASE_URL,'js/jquery-1.5.2.min.js'].join(''))\n        .script([BASE_URL,'js/jquery-ui-1.8.11.custom.min.js'].join(''))\n        .script([BASE_URL,'js/otherstuff1.js'].join(''))\n        .script([BASE_URL,'js/otherstuff2.js'].join(''))\n        .script([BASE_URL,'js/mainstuff.js'].join(''))\n        .wait(function() {\n            jQuery(function(){MainThing.go();});\n        });\n\nThe code inside the anonymous function in wait() fails with an error indicated that MainThing is not defined (which \"mainstuff.js\" should do). \n\nWhen I look at mainstuff.js in the IE dev tools (via the Network capture) I can see that it has received the response containing the code..\n\nHowever, when I try to look at mainstuff.js in the Script view (of the IE dev tools), the file appears empty...\n\nAny ideas?\n\nThanks,\nTom\n. FYI I've implemented a simple workaround for my problem as a temporary solution. My script executes a function which checks for the definition of MainThing, if it is not there yet, it yields for 200ms and calls itself again until MainThing is defined.\n\nI appreciate this introduces a potentially infinite loop, but without MainThing, the application is completely worthless anyway so it is an acceptable trade-off from my perspective.\n\n// Define my namespace\nif(typeof MyNameSpace=== 'undefined') {\n    MyNameSpace = function () { \"use strict\"; };\n}\n\n// Repeatedly attempt to launch the application to get around the LABjs wait() bug in IE10\nMyNameSpace.go = function() {\n    if(typeof MainThing === \"undefined\") {\n        setTimeout(MyNameSpace.go, 200);\n    } else {\n        MainThing.go();\n    }\n};\n\n$LAB.setOptions({AlwaysPreserveOrder:true})\n.script([BASE_URL,'js/jquery-1.5.2.min.js'].join(''))\n.script([BASE_URL,'js/jquery-ui-1.8.11.custom.min.js'].join(''))\n.script([BASE_URL,'js/otherstuff1.js'].join(''))\n.script([BASE_URL,'js/otherstuff2.js'].join(''))\n.script([BASE_URL,'js/mainstuff.js'].join(''))\n.wait(function() {\n  jQuery(function(){MyNameSpace.go();});\n});\n. Hi,\n\nI am also experiencing this with LABjs (v1.2.0) in IE10. Interestingly, it does not appear to have this problem in earlier versions of IE (or any other browser that I've tried so far)...\n\nMy LABjs loader code looks something like this:\n\n$LAB.setOptions({AlwaysPreserveOrder:true})\n        .script([BASE_URL,'js/jquery-1.5.2.min.js'].join(''))\n        .script([BASE_URL,'js/jquery-ui-1.8.11.custom.min.js'].join(''))\n        .script([BASE_URL,'js/otherstuff1.js'].join(''))\n        .script([BASE_URL,'js/otherstuff2.js'].join(''))\n        .script([BASE_URL,'js/mainstuff.js'].join(''))\n        .wait(function() {\n            jQuery(function(){MainThing.go();});\n        });\n\nThe code inside the anonymous function in wait() fails with an error indicated that MainThing is not defined (which \"mainstuff.js\" should do). \n\nWhen I look at mainstuff.js in the IE dev tools (via the Network capture) I can see that it has received the response containing the code..\n\nHowever, when I try to look at mainstuff.js in the Script view (of the IE dev tools), the file appears empty...\n\nAny ideas?\n\nThanks,\nTom\n. FYI I've implemented a simple workaround for my problem as a temporary solution. My script executes a function which checks for the definition of MainThing, if it is not there yet, it yields for 200ms and calls itself again until MainThing is defined.\n\nI appreciate this introduces a potentially infinite loop, but without MainThing, the application is completely worthless anyway so it is an acceptable trade-off from my perspective.\n\n// Define my namespace\nif(typeof MyNameSpace=== 'undefined') {\n    MyNameSpace = function () { \"use strict\"; };\n}\n\n// Repeatedly attempt to launch the application to get around the LABjs wait() bug in IE10\nMyNameSpace.go = function() {\n    if(typeof MainThing === \"undefined\") {\n        setTimeout(MyNameSpace.go, 200);\n    } else {\n        MainThing.go();\n    }\n};\n\n$LAB.setOptions({AlwaysPreserveOrder:true})\n.script([BASE_URL,'js/jquery-1.5.2.min.js'].join(''))\n.script([BASE_URL,'js/jquery-ui-1.8.11.custom.min.js'].join(''))\n.script([BASE_URL,'js/otherstuff1.js'].join(''))\n.script([BASE_URL,'js/otherstuff2.js'].join(''))\n.script([BASE_URL,'js/mainstuff.js'].join(''))\n.wait(function() {\n  jQuery(function(){MyNameSpace.go();});\n});\n. ",
    "ChristophBoget": "Ok, go ahead and make sense why don't you!! :p \n\nTo answer your question, B does _not_ depend on A.  I'm not sure if you went to the fiddle page and saw the code, but the anonymous function is part of it's on separate $LAB.queueWait() call.  The implication being that it should be queued and executed in turn but is not dependent upon the previous $LAB.queueScript() call.  At least, that is my understanding of the documentation (which, I'm perfectly fine with admitting that understanding is flawed if, in fact, I'm incorrect).  \n\nThanks for your reply!\n\nthnx,\nChristoph\n. Ok, go ahead and make sense why don't you!! :p \n\nTo answer your question, B does _not_ depend on A.  I'm not sure if you went to the fiddle page and saw the code, but the anonymous function is part of it's on separate $LAB.queueWait() call.  The implication being that it should be queued and executed in turn but is not dependent upon the previous $LAB.queueScript() call.  At least, that is my understanding of the documentation (which, I'm perfectly fine with admitting that understanding is flawed if, in fact, I'm incorrect).  \n\nThanks for your reply!\n\nthnx,\nChristoph\n. ",
    "Moon-batch": "Thank you for confirming that it is not a labjs issue. Now it work like a charm.\nRegards\n. Thank you for confirming that it is not a labjs issue. Now it work like a charm.\nRegards\n. ",
    "karanave": "thanks for clarification... this will help....\n. thanks for clarification... this will help....\n. ",
    "angloc": "Thanks for such a rapid response Kyle.\n\nI\u2019m afraid setting location.href doesn\u2019t work because it effectively refreshes the page with the contents of whatever is the new value of location.href. Setting it to blank is probably not defined behaviour in the DOM spec \u2013 and in any case causes LAB initialisation to fail because it doesn\u2019t match the RE executed on line 18.\n\nI hadn\u2019t RTFM properly so I didn\u2019t see the BasePath variable. I expect that will work once LAB is loaded, but LAB won\u2019t load unless the RE in line 18 returns a match.\n\nI fear this can\u2019t be made to work with the present sources. A fix might be to attempt to match the RE and if that fails then to look at any <base> element present before giving up. The code would need quite significant change I think because the chain of variable definitions needs to be broken. Depends how important you feel this issue is.\n. I hear what you say and I understand this is an obscure situation. I have a patch that works well for me when I supply a base, so that\u2019s fine. My situation is I generate some information on the client side I want to incorporate in the page coming into the iframe from (my tame) server. This is too bulky to incorporate in the URL for the iframe, and waiting until the iframe DOM is complete to insert it involves changing the server side code and some complex synchronisation issues at the client end. So what I do is generate the page that the server would have generated if it only had the information that I have in the client, and provide that as the srcdoc for the iframe. The only problem is this page needs to be re-based to the server root address so all the resources of the page load correctly. The browsers seem to cope fine with this but LAB.js fails because it needs the location.href.\n\nWriting this it occurs to me that maybe I could insert as the srcdoc some Javascript code that would make a POST request to the server incorporating all the data I want, and using the resulting HTML text to replace its own document. This should then behave in the ordinary manner without needing a base and an unpatched LAB.js should work fine.\n\nAnyway it\u2019s my problem and I really appreciate the time you\u2019ve taken to consider and respond. I submitted the issue in case it was of interest elsewhere and so that hopefully if someone else is affected they will find this dialogue and save some time.\n. Thanks for such a rapid response Kyle.\n\nI\u2019m afraid setting location.href doesn\u2019t work because it effectively refreshes the page with the contents of whatever is the new value of location.href. Setting it to blank is probably not defined behaviour in the DOM spec \u2013 and in any case causes LAB initialisation to fail because it doesn\u2019t match the RE executed on line 18.\n\nI hadn\u2019t RTFM properly so I didn\u2019t see the BasePath variable. I expect that will work once LAB is loaded, but LAB won\u2019t load unless the RE in line 18 returns a match.\n\nI fear this can\u2019t be made to work with the present sources. A fix might be to attempt to match the RE and if that fails then to look at any <base> element present before giving up. The code would need quite significant change I think because the chain of variable definitions needs to be broken. Depends how important you feel this issue is.\n. I hear what you say and I understand this is an obscure situation. I have a patch that works well for me when I supply a base, so that\u2019s fine. My situation is I generate some information on the client side I want to incorporate in the page coming into the iframe from (my tame) server. This is too bulky to incorporate in the URL for the iframe, and waiting until the iframe DOM is complete to insert it involves changing the server side code and some complex synchronisation issues at the client end. So what I do is generate the page that the server would have generated if it only had the information that I have in the client, and provide that as the srcdoc for the iframe. The only problem is this page needs to be re-based to the server root address so all the resources of the page load correctly. The browsers seem to cope fine with this but LAB.js fails because it needs the location.href.\n\nWriting this it occurs to me that maybe I could insert as the srcdoc some Javascript code that would make a POST request to the server incorporating all the data I want, and using the resulting HTML text to replace its own document. This should then behave in the ordinary manner without needing a base and an unpatched LAB.js should work fine.\n\nAnyway it\u2019s my problem and I really appreciate the time you\u2019ve taken to consider and respond. I submitted the issue in case it was of interest elsewhere and so that hopefully if someone else is affected they will find this dialogue and save some time.\n. ",
    "texnikru": "++\n. ++\n. ",
    "jacksonrayhamilton": "+1\n. +1\n. ",
    "huhai463127310": "The location.href mybe like this \"chrome-extension://kkpoepbkjgkbbaahccibkoibcnfbbdbc/index.html\" in an chrome extension app.When LAB.js was used in chome extension app.The \\w in the regexp of line 19th will lead an error, because of that the character \"-\" will not match \\w.The error message is:\nUncaught TypeError: Cannot read property '0' of null LAB.js:19\n\n[source code]\n18 root_page = /^[^?#]*\\//.exec(location.href)[0]\n19 root_domain = /^\\w+:\\/\\/\\/?[^\\/]+/.exec(root_page)[0]\n\nin this case:\nroot_page=\"chrome-extension://kkpoepbkjgkbbaahccibkoibcnfbbdbc/\"\n\nI use [\\w|-] instead of \\w to support pattern like \"chrome-extension\" .\n. 3q for your patient reply\n. The location.href mybe like this \"chrome-extension://kkpoepbkjgkbbaahccibkoibcnfbbdbc/index.html\" in an chrome extension app.When LAB.js was used in chome extension app.The \\w in the regexp of line 19th will lead an error, because of that the character \"-\" will not match \\w.The error message is:\nUncaught TypeError: Cannot read property '0' of null LAB.js:19\n\n[source code]\n18 root_page = /^[^?#]*\\//.exec(location.href)[0]\n19 root_domain = /^\\w+:\\/\\/\\/?[^\\/]+/.exec(root_page)[0]\n\nin this case:\nroot_page=\"chrome-extension://kkpoepbkjgkbbaahccibkoibcnfbbdbc/\"\n\nI use [\\w|-] instead of \\w to support pattern like \"chrome-extension\" .\n. 3q for your patient reply\n. ",
    "roplet": "JFYI,\n\nI am also experiencing this issue in Apache Cordova applications for Windows Phone. The urls there have a dash in the 'ms-appx' prefix. For instance: _ms-appx://com.mycompany.myapp/www/index.html_\n. JFYI,\n\nI am also experiencing this issue in Apache Cordova applications for Windows Phone. The urls there have a dash in the 'ms-appx' prefix. For instance: _ms-appx://com.mycompany.myapp/www/index.html_\n. ",
    "asnyder": "Thanks so much! This definitely helped.\n. Alternatively, I can wrap the string in a global function and always call something like .script(_cb(...)), but that seems bad.\n. Thanks so much! This definitely helped.\n. Alternatively, I can wrap the string in a global function and always call something like .script(_cb(...)), but that seems bad.\n. ",
    "derflocki": "Thanks for the extremely long explanation! The URL is actually properly formatted `chrome-extension://mmjeglkkcnglojkjoomifokhekiiiioe/www/index.html`. The slashes got lost in copy and paste, sorry for wasting your time. So i guess the propsed fix should work...\n. Correct. The scheme was the problem. Additionally, as mentioned im my\ninitial post, `+` and `/` would also be legal characters according to the\nRFC.\n\nAnd since I tend to take these things seriously, the RFC also states that\nthe first char is an ALPHA, thus the `[a-z]`.\n\nWhat I just now realize, is that the check should actually be case\ninsensitive.\n. Thanks for the extremely long explanation! The URL is actually properly formatted `chrome-extension://mmjeglkkcnglojkjoomifokhekiiiioe/www/index.html`. The slashes got lost in copy and paste, sorry for wasting your time. So i guess the propsed fix should work...\n. Correct. The scheme was the problem. Additionally, as mentioned im my\ninitial post, `+` and `/` would also be legal characters according to the\nRFC.\n\nAnd since I tend to take these things seriously, the RFC also states that\nthe first char is an ALPHA, thus the `[a-z]`.\n\nWhat I just now realize, is that the check should actually be case\ninsensitive.\n. ",
    "mttcr": "Hello,\nTo add some interests to this issue, LAB does not correctly handle the `blob:` URL scheme used here: https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\nThis issue corrects that behavior I guess.\nWhile waiting for 3.0, I tweaked the regex like that : `var absolute_regex = /^(?:\\w+\\:\\/\\/|blob\\:)/`\n. The first one. I have some raw source in a string that I convert into a blob, then I load it with LABjs.\n\n```\nlet blob = new Blob( [plainSource], [{ type: \"text/javascript\" }] );\nlet objectURL = window.URL.createObjectURL( blob );\n$LAB\n    .script( objectURL )\n    .wait(() =>\n       {\n            window.URL.revokeObjectURL( objectURL );\n       });\n```\n. Hello,\nTo add some interests to this issue, LAB does not correctly handle the `blob:` URL scheme used here: https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\nThis issue corrects that behavior I guess.\nWhile waiting for 3.0, I tweaked the regex like that : `var absolute_regex = /^(?:\\w+\\:\\/\\/|blob\\:)/`\n. The first one. I have some raw source in a string that I convert into a blob, then I load it with LABjs.\n\n```\nlet blob = new Blob( [plainSource], [{ type: \"text/javascript\" }] );\nlet objectURL = window.URL.createObjectURL( blob );\n$LAB\n    .script( objectURL )\n    .wait(() =>\n       {\n            window.URL.revokeObjectURL( objectURL );\n       });\n```\n. ",
    "joshdance": "I will, left the office for the night. I will post first thing tomorrow\nmorning. Thank you!\n\nOn Mon, Nov 17, 2014 at 10:22 PM, Kyle Simpson notifications@github.com\nwrote:\n\n> My guess is you have a execution race condition with a silent error that\n> stops the chain. Can you post your $LAB chain exactly as you use it in\n> the page?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/getify/LABjs/issues/101#issuecomment-63424252.\n\n## \n\n-J\n\n---\n\nJoshua Dance | Problem Solver | 425-301-9137 | [image: Twitter]\nhttp://www.twitter.com/joshdance [image: YouTube]\nhttp://www.youtube.com/joshuajaydan\njoshdance.me/\nhelpcapeverde.org/\n. ```\n<script type=\"text/javascript\">\n    var lab_load_interval = setInterval(function() {\n        if (typeof $LAB != \"undefined\") {\n            clearInterval(lab_load_interval);\n            $LAB.setGlobalDefaults({AlwaysPreserveOrder: true});\n            $LAB\n            .script(\"{$url.js_nexus}/functions.js\")\n            .script(\"{$url.js_lib}/jquery.min.js\")\n            .script(\"{$url.js_lib}/persist.js\")\n            .script(\"{$url.js_lib}/swfobject.js\")\n            .script(\"{$url.js_lib}/jquery-ui-1.8.9.custom.min.js\")\n            .script(\"{$url.js_lib}/jsonp.js\")\n            .script(\"{$url.js_lib}/jquery.json.js\")\n            .script(\"{$url.js_lib}/jcookie.js\")\n            .script(\"{$url.js_lib}/jstorage.min.js\")\n            .script(\"{$url.js_lib}/jquery.postmessage.js\")\n            .script(\"{$url.js_lib}/jquery.timePicker.min.js\")\n            .script(\"{$url.js_nexus}/BarbitratorBase.js\")\n            .script(\"{$url.js_nexus}/BarbitratorClient.js\")\n            .script(\"{$url.js_nexus}/DSConference.js\")\n            .script(\"{$url.js_nexus}/DSDataStore.js\")\n            .script(\"{$url.js_nexus}/{$ds_addon}.js\")\n            .script(\"{$url.js_nexus}/c2c/DSClickToCall.js\")\n            .script(\"{$url.js}/{$c2c_addon}.js\")\n            .script(\"{$url.js_nexus}/CommsClient.js\")\n            .script(\"{$url.js_nexus}/DialerStateManager.js\")\n            .script(\"{$url.js_nexus}/InboundService.js\")\n            .script(\"{$url.js_nexus}/c2c/{$new_com_addon}.js\")\n            .script(\"{$url.js_nexus}/c2c/c2c.js\")\n            .script(\"{$url.js_nexus}/DSConference.jQuery.js\")\n            .wait(function() {\n                pd.popup_opening_position = (\"{$show_toolbox}\" == \"right\" || \"{$show_toolbox}\" == \"righttoggle\") ? 'left' : 'right';\n            });\n        }\n    }, 50);\n</script>\n```\n\nWe found that sometimes LAB would not load first, so we added the interval to keep checking, once it is available, it enters the LAB chain. \n\nThe elements in curly braces `{$url.js_nexus}` get replaced in a build script with relative URLs. \n\nAnother wrinkle in the issue is we are operating in Salesforce. Using a relative URL would point the resource to `/js/file.js` which resolves to `salesforce.com/js/file.js` which Salesforce then redirects to `visual.force.com/js/file.js`. It appears that on a redirect IE 9 and 10 load the resource enough to cache it, but not enough to execute it. Thanks!\n. `<script type=\"text/javascript\" src=\"cdn.example.url.com/LAB.js\"></script>`\n. I agree with your findings. After looking at it more we have found some serious issues. I am working on fixing problems in legacy code.  And unfortunately company owned so I can't post it :( \n\nBut we do have serious issues. We have resolved them and LABjs is working well for us, outside of our legacy problems. I will close this issue, and you have been so much help. :+1:  Thank you for the time. \n. I will, left the office for the night. I will post first thing tomorrow\nmorning. Thank you!\n\nOn Mon, Nov 17, 2014 at 10:22 PM, Kyle Simpson notifications@github.com\nwrote:\n\n> My guess is you have a execution race condition with a silent error that\n> stops the chain. Can you post your $LAB chain exactly as you use it in\n> the page?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/getify/LABjs/issues/101#issuecomment-63424252.\n\n## \n\n-J\n\n---\n\nJoshua Dance | Problem Solver | 425-301-9137 | [image: Twitter]\nhttp://www.twitter.com/joshdance [image: YouTube]\nhttp://www.youtube.com/joshuajaydan\njoshdance.me/\nhelpcapeverde.org/\n. ```\n<script type=\"text/javascript\">\n    var lab_load_interval = setInterval(function() {\n        if (typeof $LAB != \"undefined\") {\n            clearInterval(lab_load_interval);\n            $LAB.setGlobalDefaults({AlwaysPreserveOrder: true});\n            $LAB\n            .script(\"{$url.js_nexus}/functions.js\")\n            .script(\"{$url.js_lib}/jquery.min.js\")\n            .script(\"{$url.js_lib}/persist.js\")\n            .script(\"{$url.js_lib}/swfobject.js\")\n            .script(\"{$url.js_lib}/jquery-ui-1.8.9.custom.min.js\")\n            .script(\"{$url.js_lib}/jsonp.js\")\n            .script(\"{$url.js_lib}/jquery.json.js\")\n            .script(\"{$url.js_lib}/jcookie.js\")\n            .script(\"{$url.js_lib}/jstorage.min.js\")\n            .script(\"{$url.js_lib}/jquery.postmessage.js\")\n            .script(\"{$url.js_lib}/jquery.timePicker.min.js\")\n            .script(\"{$url.js_nexus}/BarbitratorBase.js\")\n            .script(\"{$url.js_nexus}/BarbitratorClient.js\")\n            .script(\"{$url.js_nexus}/DSConference.js\")\n            .script(\"{$url.js_nexus}/DSDataStore.js\")\n            .script(\"{$url.js_nexus}/{$ds_addon}.js\")\n            .script(\"{$url.js_nexus}/c2c/DSClickToCall.js\")\n            .script(\"{$url.js}/{$c2c_addon}.js\")\n            .script(\"{$url.js_nexus}/CommsClient.js\")\n            .script(\"{$url.js_nexus}/DialerStateManager.js\")\n            .script(\"{$url.js_nexus}/InboundService.js\")\n            .script(\"{$url.js_nexus}/c2c/{$new_com_addon}.js\")\n            .script(\"{$url.js_nexus}/c2c/c2c.js\")\n            .script(\"{$url.js_nexus}/DSConference.jQuery.js\")\n            .wait(function() {\n                pd.popup_opening_position = (\"{$show_toolbox}\" == \"right\" || \"{$show_toolbox}\" == \"righttoggle\") ? 'left' : 'right';\n            });\n        }\n    }, 50);\n</script>\n```\n\nWe found that sometimes LAB would not load first, so we added the interval to keep checking, once it is available, it enters the LAB chain. \n\nThe elements in curly braces `{$url.js_nexus}` get replaced in a build script with relative URLs. \n\nAnother wrinkle in the issue is we are operating in Salesforce. Using a relative URL would point the resource to `/js/file.js` which resolves to `salesforce.com/js/file.js` which Salesforce then redirects to `visual.force.com/js/file.js`. It appears that on a redirect IE 9 and 10 load the resource enough to cache it, but not enough to execute it. Thanks!\n. `<script type=\"text/javascript\" src=\"cdn.example.url.com/LAB.js\"></script>`\n. I agree with your findings. After looking at it more we have found some serious issues. I am working on fixing problems in legacy code.  And unfortunately company owned so I can't post it :( \n\nBut we do have serious issues. We have resolved them and LABjs is working well for us, outside of our legacy problems. I will close this issue, and you have been so much help. :+1:  Thank you for the time. \n. ",
    "JordanMagnuson": "Sorry, getify, I'm using the [Drupal LabJS module](https://www.drupal.org/project/labjs), which grabs all the js on the page... I thought the issue was with LabJS itself, but I see it's the module that's responsible for this behavior. Apologies for my hasty post.\n. Sorry, getify, I'm using the [Drupal LabJS module](https://www.drupal.org/project/labjs), which grabs all the js on the page... I thought the issue was with LabJS itself, but I see it's the module that's responsible for this behavior. Apologies for my hasty post.\n. ",
    "Piicksarn": "thanks :D\n. thanks :D\n. ",
    "lessfish": "Thanks very much for answering. I have learned CacheBust option, by adding this every time it will load the materials from the server ignoring cache, but I wonder if I can do this as usual, I mean when I press f5, it will return HTTP 304 if not modified and HTTP200 when modified, can I? I also wonder it's an issue of wampserver or labjs? \n. thanks very much for your detailed answer! \n. Thanks very much for answering. I have learned CacheBust option, by adding this every time it will load the materials from the server ignoring cache, but I wonder if I can do this as usual, I mean when I press f5, it will return HTTP 304 if not modified and HTTP200 when modified, can I? I also wonder it's an issue of wampserver or labjs? \n. thanks very much for your detailed answer! \n. ",
    "albertvp": "Ok I see your comment there https://github.com/getify/LABjs/pull/85#issuecomment-20476024 and your solution gist https://gist.github.com/getify/670840\n. Ok I see your comment there https://github.com/getify/LABjs/pull/85#issuecomment-20476024 and your solution gist https://gist.github.com/getify/670840\n. ",
    "ralfbecker": "Thanks for the quick response :-)\nI expected so much, as I could not find anything in your code.\nI believe, if LABjs is not restricting the number of parallel loads, browsers supporting HTTP2 or SPDY which is basically everything, but IE < 11, will do the rest automatic, when talking to a HTTP2/SPDY supporting server.\n. Thanks for the quick response :-)\nI expected so much, as I could not find anything in your code.\nI believe, if LABjs is not restricting the number of parallel loads, browsers supporting HTTP2 or SPDY which is basically everything, but IE < 11, will do the rest automatic, when talking to a HTTP2/SPDY supporting server.\n. ",
    "devilking15292": "@getify I'm interested in this\n. if you want to add the downloaded scripts to the end of the head tag .. just open LAB.src.js\nand replace this line \n\n`append_to.insertBefore(script,append_to.firstChild);`\n with \n `append_to.appendChild(script);` \n\nin line numbers  174, 183, 190 and 244. \n\n hope it satisfies your need .. \n\n**Note**:  this is a non tested solution .\n. @getify I'm interested in this\n. if you want to add the downloaded scripts to the end of the head tag .. just open LAB.src.js\nand replace this line \n\n`append_to.insertBefore(script,append_to.firstChild);`\n with \n `append_to.appendChild(script);` \n\nin line numbers  174, 183, 190 and 244. \n\n hope it satisfies your need .. \n\n**Note**:  this is a non tested solution .\n. ",
    "dudesl": "Maybe its time to CORS support?\n. Maybe its time to CORS support?\n. ",
    "pihvi": "I'd like to help, what could I do?\n\nI'd like to see LABjs in NPM as I'm using it for version management. Should I just add it there or would you like to be the owner of that?\n. Great, what should happen next to get things started? How can I help?\n. I'd like to help, what could I do?\n\nI'd like to see LABjs in NPM as I'm using it for version management. Should I just add it there or would you like to be the owner of that?\n. Great, what should happen next to get things started? How can I help?\n. ",
    "nyrosmith": "@getify is there anything I could help with?\n. @getify is there anything I could help with?\n. ",
    "fatso83": "@getify To get some help on this you should make it easy to contribute. Make a list of issues that you need help with, possible from a overview issue \"3.0 release\", and mark them with \"help wanted\". As this thread shows there are many folks who would like to help out, but don't know where to start.\n. @artknight, you don't link to to any script and there are no comments in this issue that mentions anything about drawbacks. mind elaborating?. @getify To get some help on this you should make it easy to contribute. Make a list of issues that you need help with, possible from a overview issue \"3.0 release\", and mark them with \"help wanted\". As this thread shows there are many folks who would like to help out, but don't know where to start.\n. @artknight, you don't link to to any script and there are no comments in this issue that mentions anything about drawbacks. mind elaborating?. ",
    "artknight": "lets add local storage to cache the scripts!\n. @jbmonroe I recently wrote a script to use localStorage to cache JS & CSS scripts. The way it works is to store the JS/CSS content as a STRING and inject it into the header on subsequent page loads. I added a cache buster to force cache reloads when needed ( version changes, etc... ). The performance is amazing but I do realize that it has some drawbacks as mentioned in the comments. . @getify the issue with browser caching is that sometimes the scripts are not getting cached very well and keep on getting reloaded every single time. . lets add local storage to cache the scripts!\n. @jbmonroe I recently wrote a script to use localStorage to cache JS & CSS scripts. The way it works is to store the JS/CSS content as a STRING and inject it into the header on subsequent page loads. I added a cache buster to force cache reloads when needed ( version changes, etc... ). The performance is amazing but I do realize that it has some drawbacks as mentioned in the comments. . @getify the issue with browser caching is that sometimes the scripts are not getting cached very well and keep on getting reloaded every single time. . ",
    "jbmonroe": "@artknight How will you load scripts from local storage?. This is sort of a mix of ES5 and ES6.  I don't know if support for IE11 is required, but if it is, some of the property definitions will have to be downgraded to the ES5 style.. Dunno about that.  Mock-DOM index.js has some ES6-looking get/set code in Object.addProperty:\r\n\r\nget() { return thing; },\r\n\r\nvs\r\n\r\nget() : function () { return thing; },\r\n\r\nAlso in an obj = {} setup as well.\r\n\r\nJSHint also wasn't happy here:\r\n\r\n\tfunction setupLocation(location) {\r\n\t\tvar loc = {\r\n\t\t\ttoString() {  // <<---\r\n\t\t\t\treturn location;\r\n\t\t\t},\r\n\t\t\tget href() {    // <<---\r\n\t\t\t\treturn location;\r\n\t\t\t},\r\n\t\t\tset href(val) {  // <<---\r\n\t\t\t\tlocation = val;\r\n\t\t\t\tparseLocation();\r\n\t\t\t},\r\n\t\t\tassign: function assign(val){\r\n\t\t\t\tthis.href = val;\r\n\t\t\t},\r\n\t\t\treload: function(){},\r\n\t\t\treplace: function replace(val){\r\n\t\t\t\tthis.href = val;\r\n\t\t\t}\r\n\t\t};\r\n\r\nThose look very ES-sixy to me, too.. Erm...what?  Are you saying that if you open Chrome with the following\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title>Chrome Not Blocking an Inline Script</title>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"description\" content=\"\">\r\n    <meta name=\"keywords\" content=\"\">\r\n    <style>\r\n        body { font-family : Arial }\r\n    </style>\r\n</head>\r\n<body>\r\n    <script>\r\n        const div = document.createElement(\"div\");\r\n        div.textContent = `Hi, I'm ${navigator.userAgent} and I'm not blocking this inline script`;\r\n        document.body.appendChild(div);\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\nyou get a blank page?. IIRC, you can't load them back in from localStorage without using eval() to inject them into a page.  I think I'd have that filed under \"Dubious Practices.\". I agree with that.  To some extent I'm not even sure caching is a good idea because I've already seen software break because non-cached transaction pages assumed that a new method would be available in a script and got nailed because the cached version of the script loaded.  I told the team to refactor in order to apply cache-breaking on the script loads.  (Unique environment, not running in a consumer browser.). @artknight How will you load scripts from local storage?. This is sort of a mix of ES5 and ES6.  I don't know if support for IE11 is required, but if it is, some of the property definitions will have to be downgraded to the ES5 style.. Dunno about that.  Mock-DOM index.js has some ES6-looking get/set code in Object.addProperty:\r\n\r\nget() { return thing; },\r\n\r\nvs\r\n\r\nget() : function () { return thing; },\r\n\r\nAlso in an obj = {} setup as well.\r\n\r\nJSHint also wasn't happy here:\r\n\r\n\tfunction setupLocation(location) {\r\n\t\tvar loc = {\r\n\t\t\ttoString() {  // <<---\r\n\t\t\t\treturn location;\r\n\t\t\t},\r\n\t\t\tget href() {    // <<---\r\n\t\t\t\treturn location;\r\n\t\t\t},\r\n\t\t\tset href(val) {  // <<---\r\n\t\t\t\tlocation = val;\r\n\t\t\t\tparseLocation();\r\n\t\t\t},\r\n\t\t\tassign: function assign(val){\r\n\t\t\t\tthis.href = val;\r\n\t\t\t},\r\n\t\t\treload: function(){},\r\n\t\t\treplace: function replace(val){\r\n\t\t\t\tthis.href = val;\r\n\t\t\t}\r\n\t\t};\r\n\r\nThose look very ES-sixy to me, too.. Erm...what?  Are you saying that if you open Chrome with the following\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title>Chrome Not Blocking an Inline Script</title>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"description\" content=\"\">\r\n    <meta name=\"keywords\" content=\"\">\r\n    <style>\r\n        body { font-family : Arial }\r\n    </style>\r\n</head>\r\n<body>\r\n    <script>\r\n        const div = document.createElement(\"div\");\r\n        div.textContent = `Hi, I'm ${navigator.userAgent} and I'm not blocking this inline script`;\r\n        document.body.appendChild(div);\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\nyou get a blank page?. IIRC, you can't load them back in from localStorage without using eval() to inject them into a page.  I think I'd have that filed under \"Dubious Practices.\". I agree with that.  To some extent I'm not even sure caching is a good idea because I've already seen software break because non-cached transaction pages assumed that a new method would be available in a script and got nailed because the cached version of the script loaded.  I told the team to refactor in order to apply cache-breaking on the script loads.  (Unique environment, not running in a consumer browser.). ",
    "kylebakerio": "What's the word on this, @getify?\r\n\r\nAlso, I can't seem to find any comprehensive 'how-to' on using this library. I can derive most of it from the examples, but there are mention of features in the README.md regarding e.g. queuing, where there is no code example and no illustration. Are we just expected to look through the source, or am I missing some obvious file?. that blending in scantree feature looks awesome. . I've run into your rants while researching this issue, actually, haha. You could say it was poor word choice to say \"undermine\", but even then I think I'd defend the word--it undermines their (faulty) assumptions. I'm not saying it's LABjs' responsibility to respect those assumptions, mind you.\r\n\r\nThat being said,\r\n1. These false assumptions are those of the angular code here, not my own code. I'm trying to accomodate Angular here. LAB.js just seems to not play nicely with Angular. (I am no angular fan, this is legacy code I'm trying to patch up well enough to get a rewrite underway.)\r\n2. It's a jquery event (it's not the same as window.onload, and is not a real DOM event as far as I am aware; it has its own characteristics in its attempts to be cross-browser and support its assumptions), and as its name tells us, its intention was to signal that code running then can expect everything to have loaded, so yours can run when things are \"ready\".\r\n\r\nI agree that it's poorly conceived, because it bakes those assumptions straight in.\r\n\r\n[$.holdReady()](https://api.jquery.com/jquery.holdready/) is a jquery tool to manipulate the $(document).ready event, a patch attempt at handling the broken $().ready implementation. It has nothing to do with Angular.\r\n\r\nI totally agree that Angular is broken here, and has a shockingly poor assumption built in, but I'm really baffled at how LAB.js seems to somehow be _interfering_ with jquery--not just by undermining its assumption, but for the fact that for some reason, when I use LABjs, the $.holdReady functionality and the $(document).ready flag seem to completely _break_, not just be undermined.\r\n\r\nRegardless, thanks for your time. Always appreciate your input.. jQuery's ready is indeed a proxy for DOMContentLoaded, except for old IE. I thought it had some other checks in there, but I suppose it's just those ie checks and the late-event-listener support.\r\n\r\nSince scripts can modify the DOM, you can't know if the DOM is in a final state until all ajax requests have returned and the results have executed. This is your point, of course--there is no guarantee on DOM state, you have to handle that yourself.\r\n\r\nSo I hear what you're saying, but I guess I was trying to say that I was under the impression that DOMContentLoaded was around before ajax in javascript was. I can't tell for sure, and it seems like that might not be true (iframe technically enabled a crude form of ajax back in '98, even if ajax as we know it today wasn't around until gmail came out, really), but it was around before the async script attribute (2010?) was for sure. (can't tell exactly when DOMContentLoaded, but it was in v 1.0 of ff... but [Wikipedia says it was unofficial before HTML5](https://en.wikipedia.org/wiki/DOM_events#Other_events), which is interesting.) Mypoint is that my guess had been that the spec writers didn't think about the possibility of async JS code modifying the DOM, or that that wasn't possible yet, but I now think I'm probably mistaken in that belief.\r\n\r\nThis is what I meant by saying \"ready\" was \"broken\", but if you instead postulate it was correctly defined all along, then yes, it's just its widespread use that is broken.\r\n\r\n...though at that point one has to wonder whether something that is so widely misunderstood has an inherent flaw, no? I adhere to your principles of 'code is written for humans first', shouldn't this really be called DOMResourcesExecuted or something that makes it a bit more clear, since one can never know if the DOM is actually \"Loaded\" (semi-ambiguous word that carries a sense of synchronous finality within an async environment)?\r\n\r\nAnyways, I'm fascinated by discussions like this, but I don't mean to waste your time. It's been an enlightening digression for me.\r\n\r\n> I've literally had such tools just tell their users \"don't dynamically load\".\r\n\r\nYeah, that seems to basically be the case with Angular here. All they would have to do is have their stuff execute on a given event, and tell users to fire that event when ready.\r\n\r\n> But in theory, if it lets you \"hold off and artificially fire jquery's ready event whenever\" you want, then you should be able to \"delay\" until the final .wait(..) in your $LAB chain. That may be what you were trying to do, not sure, but at least in theory it seems reasonable. Well... hacky patchy ill-advised... but not irrational.\r\n\r\nThat's exactly what I was doing, indeed. Agreed somewhat hacky, intercepting the jquery.ready event, which is why I referred to it as a \"patch attempt\"... though, to be fair, jquery supports it itself, and jquery.ready is their own API. Though, to be fairer still, shit doesn't work right now, probably because it's all hacky.\r\n\r\n> But in theory, if it lets you \"hold off and artificially fire jquery's ready event whenever\" you want, then you should be able to \"delay\" until the final .wait(..) in your $LAB chain. That may be what you were trying to do, not sure, but at least in theory it seems reasonable. Well... hacky patchy ill-advised... but not irrational.\r\n\r\nI was able to produce this bug even though I was putting the script tag for jquery at the top of my head, and an onload=\"$.holdReady(true)\" attr for it. I read in a couple places (but did not see it mentioned on MDN's documentation for <script>...) that script tags in the header are async by default, ~~so I moved it to the body, but saw the same issue, unfortunately, no difference~~ <-- I was accidentally loading jquery twice from moving things around during that experiment, whoops. That does seem to have potentially made a difference, and that seems like pretty poor design upon that discovery; I wouldn't expect async=true default in one place and async=false in another. Alas, I'm sure that was likely a part of things, I'll experiment more and report in the next comment rather than pollute this with edits.\r\n\r\n\r\nHere's the angular code bits:\r\n\r\n```\r\n  if (window.angular.bootstrap) {\r\n    //AngularJS is already loaded, so we can return here...\r\n    console.log('WARNING: Tried to load angular more than once.');\r\n    return;\r\n  }\r\n  //try to bind to jquery now so that one can write angular.element().read()\r\n  //but we will rebind on bootstrap again.\r\n  bindJQuery();\r\n\r\n  publishExternalAPI(angular);\r\n\r\n  jqLite(document).ready(function() {\r\n    angularInit(document, bootstrap);\r\n   // this eventually fails because it expects things like angular.module(\"appname\").controller('controllerName') to have been called by this point.\r\n  });\r\n```\r\n```\r\nfunction bindJQuery() {\r\n  // bind to jQuery if present;\r\n  jQuery = window.jQuery;\r\n  // Use jQuery if it exists with proper functionality, otherwise default to us.\r\n  // Angular 1.2+ requires jQuery 1.7.1+ for on()/off() support.\r\n  if (jQuery && jQuery.fn.on) {\r\n    jqLite = jQuery;\r\n    extend(jQuery.fn, {\r\n      scope: JQLitePrototype.scope,\r\n      isolateScope: JQLitePrototype.isolateScope,\r\n      controller: JQLitePrototype.controller,\r\n      injector: JQLitePrototype.injector,\r\n      inheritedData: JQLitePrototype.inheritedData\r\n    });\r\n    // Method signature:\r\n    //     jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)\r\n    jqLitePatchJQueryRemove('remove', true, true, false);\r\n    jqLitePatchJQueryRemove('empty', false, false, false);\r\n    jqLitePatchJQueryRemove('html', false, false, true);\r\n  } else {\r\n    jqLite = JQLite;\r\n  }\r\n  angular.element = jqLite;\r\n}\r\n```\r\nThe bind seems to work, and angular seems to use it, because in the console `angular.element === $` yields `true`, and `$().jquery` yields `2.2.4` (the version I specify in my script, which wouldn't correspond to jqLite).\r\n\r\nBy the way, perusing the source of LABjs, I ran into this at the bottom... any thoughts on this coming into play, potentially?\r\n\r\n```\r\n/* The following \"hack\" was suggested by Andrea Giammarchi and adapted from: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.\r\nNOTE: this hack only operates in FF and then only in versions where document.readyState is not present (FF < 3.6?).\r\n\t   \r\nThe hack essentially \"patches\" the **page** that LABjs is loaded onto so that it has a proper conforming document.readyState, so that if a script which does \r\nproper and safe dom-ready detection is loaded onto a page, after dom-ready has passed, it will still be able to detect this state, by inspecting the now hacked \r\ndocument.readyState property. The loaded script in question can then immediately trigger any queued code executions that were waiting for the DOM to be ready. \r\nFor instance, jQuery 1.4+ has been patched to take advantage of document.readyState, which is enabled by this hack. But 1.3.2 and before are **not** safe or \r\nfixed by this hack, and should therefore **not** be lazy-loaded by script loader tools such as LABjs.\r\n*/ \r\n\t(function(addEvent,domLoaded,handler){\r\n\t\tif (document.readyState == null && document[addEvent]){\r\n\t\t\tdocument.readyState = \"loading\";\r\n\t\t\tdocument[addEvent](domLoaded,handler = function(){\r\n\t\t\t\tdocument.removeEventListener(domLoaded,handler,false);\r\n\t\t\t\tdocument.readyState = \"complete\";\r\n\t\t\t},false);\r\n\t\t}\r\n\t})(\"addEventListener\",\"DOMContentLoaded\");\r\n\r\n```. Actually, based on all the research I've done before and during this discussion, and the hunch that that snipped is interferring in some way, I decided to try `$.holdReady()` right before angular gets loaded. That fixed it, everything seems to work... Now going to try putting it right before, and right after, the LABjs script.. You know what, suddenly I can't reproduce the issue. That's really frustrating, and leads me to believe that I had just included jquery twice somehow, though I feel quite certain that I wasn't doing that... yet that would make sense with the symptoms I was seeing. A little embarrassing. The $(document).ready issue in angular was real, but it should have just been resolved by using $.holdReady, aside from some uncaught simple mistake on my part.\r\n\r\nCheers, and thanks for the conversation. Talking this through led to the solution one way or another. :). What's the word on this, @getify?\r\n\r\nAlso, I can't seem to find any comprehensive 'how-to' on using this library. I can derive most of it from the examples, but there are mention of features in the README.md regarding e.g. queuing, where there is no code example and no illustration. Are we just expected to look through the source, or am I missing some obvious file?. that blending in scantree feature looks awesome. . I've run into your rants while researching this issue, actually, haha. You could say it was poor word choice to say \"undermine\", but even then I think I'd defend the word--it undermines their (faulty) assumptions. I'm not saying it's LABjs' responsibility to respect those assumptions, mind you.\r\n\r\nThat being said,\r\n1. These false assumptions are those of the angular code here, not my own code. I'm trying to accomodate Angular here. LAB.js just seems to not play nicely with Angular. (I am no angular fan, this is legacy code I'm trying to patch up well enough to get a rewrite underway.)\r\n2. It's a jquery event (it's not the same as window.onload, and is not a real DOM event as far as I am aware; it has its own characteristics in its attempts to be cross-browser and support its assumptions), and as its name tells us, its intention was to signal that code running then can expect everything to have loaded, so yours can run when things are \"ready\".\r\n\r\nI agree that it's poorly conceived, because it bakes those assumptions straight in.\r\n\r\n[$.holdReady()](https://api.jquery.com/jquery.holdready/) is a jquery tool to manipulate the $(document).ready event, a patch attempt at handling the broken $().ready implementation. It has nothing to do with Angular.\r\n\r\nI totally agree that Angular is broken here, and has a shockingly poor assumption built in, but I'm really baffled at how LAB.js seems to somehow be _interfering_ with jquery--not just by undermining its assumption, but for the fact that for some reason, when I use LABjs, the $.holdReady functionality and the $(document).ready flag seem to completely _break_, not just be undermined.\r\n\r\nRegardless, thanks for your time. Always appreciate your input.. jQuery's ready is indeed a proxy for DOMContentLoaded, except for old IE. I thought it had some other checks in there, but I suppose it's just those ie checks and the late-event-listener support.\r\n\r\nSince scripts can modify the DOM, you can't know if the DOM is in a final state until all ajax requests have returned and the results have executed. This is your point, of course--there is no guarantee on DOM state, you have to handle that yourself.\r\n\r\nSo I hear what you're saying, but I guess I was trying to say that I was under the impression that DOMContentLoaded was around before ajax in javascript was. I can't tell for sure, and it seems like that might not be true (iframe technically enabled a crude form of ajax back in '98, even if ajax as we know it today wasn't around until gmail came out, really), but it was around before the async script attribute (2010?) was for sure. (can't tell exactly when DOMContentLoaded, but it was in v 1.0 of ff... but [Wikipedia says it was unofficial before HTML5](https://en.wikipedia.org/wiki/DOM_events#Other_events), which is interesting.) Mypoint is that my guess had been that the spec writers didn't think about the possibility of async JS code modifying the DOM, or that that wasn't possible yet, but I now think I'm probably mistaken in that belief.\r\n\r\nThis is what I meant by saying \"ready\" was \"broken\", but if you instead postulate it was correctly defined all along, then yes, it's just its widespread use that is broken.\r\n\r\n...though at that point one has to wonder whether something that is so widely misunderstood has an inherent flaw, no? I adhere to your principles of 'code is written for humans first', shouldn't this really be called DOMResourcesExecuted or something that makes it a bit more clear, since one can never know if the DOM is actually \"Loaded\" (semi-ambiguous word that carries a sense of synchronous finality within an async environment)?\r\n\r\nAnyways, I'm fascinated by discussions like this, but I don't mean to waste your time. It's been an enlightening digression for me.\r\n\r\n> I've literally had such tools just tell their users \"don't dynamically load\".\r\n\r\nYeah, that seems to basically be the case with Angular here. All they would have to do is have their stuff execute on a given event, and tell users to fire that event when ready.\r\n\r\n> But in theory, if it lets you \"hold off and artificially fire jquery's ready event whenever\" you want, then you should be able to \"delay\" until the final .wait(..) in your $LAB chain. That may be what you were trying to do, not sure, but at least in theory it seems reasonable. Well... hacky patchy ill-advised... but not irrational.\r\n\r\nThat's exactly what I was doing, indeed. Agreed somewhat hacky, intercepting the jquery.ready event, which is why I referred to it as a \"patch attempt\"... though, to be fair, jquery supports it itself, and jquery.ready is their own API. Though, to be fairer still, shit doesn't work right now, probably because it's all hacky.\r\n\r\n> But in theory, if it lets you \"hold off and artificially fire jquery's ready event whenever\" you want, then you should be able to \"delay\" until the final .wait(..) in your $LAB chain. That may be what you were trying to do, not sure, but at least in theory it seems reasonable. Well... hacky patchy ill-advised... but not irrational.\r\n\r\nI was able to produce this bug even though I was putting the script tag for jquery at the top of my head, and an onload=\"$.holdReady(true)\" attr for it. I read in a couple places (but did not see it mentioned on MDN's documentation for <script>...) that script tags in the header are async by default, ~~so I moved it to the body, but saw the same issue, unfortunately, no difference~~ <-- I was accidentally loading jquery twice from moving things around during that experiment, whoops. That does seem to have potentially made a difference, and that seems like pretty poor design upon that discovery; I wouldn't expect async=true default in one place and async=false in another. Alas, I'm sure that was likely a part of things, I'll experiment more and report in the next comment rather than pollute this with edits.\r\n\r\n\r\nHere's the angular code bits:\r\n\r\n```\r\n  if (window.angular.bootstrap) {\r\n    //AngularJS is already loaded, so we can return here...\r\n    console.log('WARNING: Tried to load angular more than once.');\r\n    return;\r\n  }\r\n  //try to bind to jquery now so that one can write angular.element().read()\r\n  //but we will rebind on bootstrap again.\r\n  bindJQuery();\r\n\r\n  publishExternalAPI(angular);\r\n\r\n  jqLite(document).ready(function() {\r\n    angularInit(document, bootstrap);\r\n   // this eventually fails because it expects things like angular.module(\"appname\").controller('controllerName') to have been called by this point.\r\n  });\r\n```\r\n```\r\nfunction bindJQuery() {\r\n  // bind to jQuery if present;\r\n  jQuery = window.jQuery;\r\n  // Use jQuery if it exists with proper functionality, otherwise default to us.\r\n  // Angular 1.2+ requires jQuery 1.7.1+ for on()/off() support.\r\n  if (jQuery && jQuery.fn.on) {\r\n    jqLite = jQuery;\r\n    extend(jQuery.fn, {\r\n      scope: JQLitePrototype.scope,\r\n      isolateScope: JQLitePrototype.isolateScope,\r\n      controller: JQLitePrototype.controller,\r\n      injector: JQLitePrototype.injector,\r\n      inheritedData: JQLitePrototype.inheritedData\r\n    });\r\n    // Method signature:\r\n    //     jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)\r\n    jqLitePatchJQueryRemove('remove', true, true, false);\r\n    jqLitePatchJQueryRemove('empty', false, false, false);\r\n    jqLitePatchJQueryRemove('html', false, false, true);\r\n  } else {\r\n    jqLite = JQLite;\r\n  }\r\n  angular.element = jqLite;\r\n}\r\n```\r\nThe bind seems to work, and angular seems to use it, because in the console `angular.element === $` yields `true`, and `$().jquery` yields `2.2.4` (the version I specify in my script, which wouldn't correspond to jqLite).\r\n\r\nBy the way, perusing the source of LABjs, I ran into this at the bottom... any thoughts on this coming into play, potentially?\r\n\r\n```\r\n/* The following \"hack\" was suggested by Andrea Giammarchi and adapted from: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.\r\nNOTE: this hack only operates in FF and then only in versions where document.readyState is not present (FF < 3.6?).\r\n\t   \r\nThe hack essentially \"patches\" the **page** that LABjs is loaded onto so that it has a proper conforming document.readyState, so that if a script which does \r\nproper and safe dom-ready detection is loaded onto a page, after dom-ready has passed, it will still be able to detect this state, by inspecting the now hacked \r\ndocument.readyState property. The loaded script in question can then immediately trigger any queued code executions that were waiting for the DOM to be ready. \r\nFor instance, jQuery 1.4+ has been patched to take advantage of document.readyState, which is enabled by this hack. But 1.3.2 and before are **not** safe or \r\nfixed by this hack, and should therefore **not** be lazy-loaded by script loader tools such as LABjs.\r\n*/ \r\n\t(function(addEvent,domLoaded,handler){\r\n\t\tif (document.readyState == null && document[addEvent]){\r\n\t\t\tdocument.readyState = \"loading\";\r\n\t\t\tdocument[addEvent](domLoaded,handler = function(){\r\n\t\t\t\tdocument.removeEventListener(domLoaded,handler,false);\r\n\t\t\t\tdocument.readyState = \"complete\";\r\n\t\t\t},false);\r\n\t\t}\r\n\t})(\"addEventListener\",\"DOMContentLoaded\");\r\n\r\n```. Actually, based on all the research I've done before and during this discussion, and the hunch that that snipped is interferring in some way, I decided to try `$.holdReady()` right before angular gets loaded. That fixed it, everything seems to work... Now going to try putting it right before, and right after, the LABjs script.. You know what, suddenly I can't reproduce the issue. That's really frustrating, and leads me to believe that I had just included jquery twice somehow, though I feel quite certain that I wasn't doing that... yet that would make sense with the symptoms I was seeing. A little embarrassing. The $(document).ready issue in angular was real, but it should have just been resolved by using $.holdReady, aside from some uncaught simple mistake on my part.\r\n\r\nCheers, and thanks for the conversation. Talking this through led to the solution one way or another. :). ",
    "ptomasroos": "Awesome! Do you need a hand with anything @getify ?. Awesome! Do you need a hand with anything @getify ?. ",
    "xaddict": "Well, for one, Audits by Google wants scripts in a certain place and having\nto ignore a bunch of rules just because LABjs does it that way can be\nannoying if you have loads of projects all running through audits and\npagespeed. Plus, it's common esthetic practice to not put them before the\ntitle or base tags\nOn Fri, 25 Mar 2016 at 19:38 Kyle Simpson notifications@github.com wrote:\n\n> @xaddict https://github.com/xaddict why does it matter where LABjs adds\n> the scripts?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/getify/LABjs/issues/115#issuecomment-201411660\n. Awesome!\r\n---\r\n@getify \r\nI hate to be a stick-in-the-mud but could it be an option to add resources to:\r\n\r\n1. the end of the `<head>`\r\n2. the end of the `<body>`\r\n\r\nI know LABjs is async and deferred by design (defer the loading of LABjs and the script that calls LABjs) but PageSpeed Insights, WooRank, Feed the Bot, and other SEO tools are real bitches about order and placement of inserted scripts. For example, scripts that are before stylesheets or in order one after another (script, stylesheet, script, stylesheet) negatively impact the reports from these tools. It's very annoying but could be stopped by injecting scripts at the end of the `<body>` and stylesheets at the end of the `<head>`.. Well, for one, Audits by Google wants scripts in a certain place and having\nto ignore a bunch of rules just because LABjs does it that way can be\nannoying if you have loads of projects all running through audits and\npagespeed. Plus, it's common esthetic practice to not put them before the\ntitle or base tags\nOn Fri, 25 Mar 2016 at 19:38 Kyle Simpson notifications@github.com wrote:\n\n> @xaddict https://github.com/xaddict why does it matter where LABjs adds\n> the scripts?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/getify/LABjs/issues/115#issuecomment-201411660\n. Awesome!\r\n---\r\n@getify \r\nI hate to be a stick-in-the-mud but could it be an option to add resources to:\r\n\r\n1. the end of the `<head>`\r\n2. the end of the `<body>`\r\n\r\nI know LABjs is async and deferred by design (defer the loading of LABjs and the script that calls LABjs) but PageSpeed Insights, WooRank, Feed the Bot, and other SEO tools are real bitches about order and placement of inserted scripts. For example, scripts that are before stylesheets or in order one after another (script, stylesheet, script, stylesheet) negatively impact the reports from these tools. It's very annoying but could be stopped by injecting scripts at the end of the `<body>` and stylesheets at the end of the `<head>`.. ",
    "tonyporto": "Thank you for all the work you put into this, I actively use labjs & great to see that your back to actively making it better then what it already is.... Thank you for all the work you put into this, I actively use labjs & great to see that your back to actively making it better then what it already is.... ",
    "xymostech": "@getify Oops! I meant to make this a pull request to Khan/LABjs! Sorry!\n. @getify Oops! I meant to make this a pull request to Khan/LABjs! Sorry!\n. ",
    "dmp42": "That's fine. Just submitting the PR since I carry these changes in my fork, but really no urge/need to merge them.\n. That's fine. Just submitting the PR since I carry these changes in my fork, but really no urge/need to merge them.\n. "
}