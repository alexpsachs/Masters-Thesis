{
    "hueniverse": "Already done. Needs documentation.\n. Handled by hawk.\n. As soon as it is in a stable state. Basically, no README means don't use it yet...\n. This is actually going to be an issue in Hawk as this logic is being replaced by it. However, the problem is that if the header includes a list, it is not possible knowing which host was used in the original request. This is a case where you will need to figure out your deployment and retain the true original header in some other custom header at the first proxy. I'm open to other suggestions, but please open them in [Hawk](https://github.com/hueniverse/hawk).\n. Probably just a bug. Oz is in a very raw state right now. It fell to the bottom of my priority list with all the hapi 1.0 work.\n. Oz isn't done... hence lack of docs. It uses Hawk as its message authentication so you can use both without any issues. It's better than OAuth 2 because it's an actual protocol with implementation, not a loose framework that you are more likely to get wrong than right.\n. I've been focusing on the lower components of it like hawk. It is not currently used by anyone other than my postmile project. I really want to finish it but just don't have time to get back to it. It works but missing a bunch of important use cases. The lack of docs is a sign you should not use it, but feel free to document your understanding and I'll review if you want.\n. @Dynom this project is pretty much of no public interest until I find the time to formally document it. I understand the curiosity and the code is open, but it is not a priority for me at this point and increasing engagement would be counter productive when I don't have the time to engage.\n. Probably better to start with a description of the protocol and flow than jumping to how to use the API...\n. @geek gave up? :-)\n. When the user authorizes third party access, you reflect that access using a grant object.\n. The app ticket can be used for additional rsvp exchanges as well as accessing app-specific resources. The method through which the user is redirected is not specified at this time. There are plenty of well-established ways to do that. Also see new docs.\n. Not actually worth the effort.\n. The only tool I am aware of with hawk support is the request module. I don't know of a manual sandbox (though postmile does include a developer console page for just that). Postmile is the only current example of oz but it's out dated. This is on my todo list.\n. I don't think this belongs here. One of the things I am trying to do with Oz is keep things simple at this level. I also not sure that at the end, these kind of complex systems are sustainable. Can't really help with your specific questions, but I would implement that as a separate layer on top of auth, basically it's own service.\n. Nice! You should rename it `express.js` since it is specific to that framework (with hapi you just use the scarecrow plugin). Also need to fix the linting issues.\n. The key is used by the underlying hawk layer for making authenticated requests. It's sent once over TLS to the client and then only used to generate a hash the server can validate.\n. I'm pretty sure it wants a 256bits key.\n. Those are different keys. Each ticket comes with its own key.\n. Oz uses tickets. In order to get a ticket, we need to bootstrap the process and we're using the client Hawk credentials. But once we got those, we exchange them for a ticket which includes all the application state we need, scope, expiration, etc.\n. I am probably not going to get to this for a while. Just want to set expectations.\n. I think this needs to live somewhere else. I don't want to maintain it moving forward as it is time consuming and I don't use express. If you post this somewhere else, I'll link to the example from the readme.. Why use oz at all for client-server auth? Just use hawk directly.\n. @patchthecode it's practically impossible to give you quality advice on this. There are just so many ways to mess things up here. Both oz and hawk are useful for app to server communication. The right solution depends on how you manage access, what your users use to login, etc. For example, if they enter a username and password on the app and then need to get back some token they can use to make api calls, hawk would be enough. If you don't want to do a token lookup every request, you can use iron to encode information into the token. I really can't help you beyond this. I suggest you find someone who has time to help who knows this space well. You should not design your system security based on this. Good luck.\n. Not yet. I'll work on it as I need it which as you can see from the history of this repo is unpredictable...\n. Nope. There is  no way to protect client-side secrets. All you can do is issue session-specific credentials via user involvement so that there is some extra sanity but beyond that, nope.\n. I like this.\n. Thanks. I'll try to get to this in a couple of weeks. If you don't hear from me by mid April, ping me.\n. I know... I am launching my startup these days so that's where my focus is right now. This is the right direction so I will get to it but can't promise when.\n. @richardolsson I am not planning on reviewing this for at least another month. It is very low on my list.\n. I am going to look into this again after the move to async api.. You don't need `Oz.client` in the browser. You just need to use the **hawk** browser code directly. I have no idea about using it with browerify. I would never try that.\n. In theory it could, but it was written for node, not the browser. If you are going to use it in the browser, you are on your own. I don't use it on the browser, I have my own browser logic code to handle it which I cannot share because it's too integrated into our logic. We just use hawk directly.\n. Probably not. I am not a fan of using browserify.\n. If by allowing passwords you mean no requiring buffer keys that are fed directly into iron, I don't see the harm in that. These tools are designed to be used by people who fully understand the security properties of the protocol. Iron usage of password makes sense for the many other use cases it is used for.. Why would you add a redirection endpoint?. Redirection is needed but you don't need a special endpoint for it. You just do it from the authorization page. The security properties are the same as in OAuth 1 and 2. You want to only redirect to previously registered endpoint.. The flow is correct but make sure app B passes the correct app and dlg options when creating the header. The goal is to make sure app B doesn't get handled any random credentials and then use them. It must know what these credentials are for and where they came from.. There is no identity layer, but since this is based on the same best practices and architecture, it should be easy to add it if someone wanted to. I do not plan on adding that to the core module.. I have no intention of writing a specification for oz or hawk. Both projects are working well and cover all my needs. As I find new use cases or bugs, I will publish new versions to address them.. Sorry but the main source of information are the tests. I have no plans on adding examples. This work is presented as-is.... Already done. Needs documentation.\n. Handled by hawk.\n. As soon as it is in a stable state. Basically, no README means don't use it yet...\n. This is actually going to be an issue in Hawk as this logic is being replaced by it. However, the problem is that if the header includes a list, it is not possible knowing which host was used in the original request. This is a case where you will need to figure out your deployment and retain the true original header in some other custom header at the first proxy. I'm open to other suggestions, but please open them in [Hawk](https://github.com/hueniverse/hawk).\n. Probably just a bug. Oz is in a very raw state right now. It fell to the bottom of my priority list with all the hapi 1.0 work.\n. Oz isn't done... hence lack of docs. It uses Hawk as its message authentication so you can use both without any issues. It's better than OAuth 2 because it's an actual protocol with implementation, not a loose framework that you are more likely to get wrong than right.\n. I've been focusing on the lower components of it like hawk. It is not currently used by anyone other than my postmile project. I really want to finish it but just don't have time to get back to it. It works but missing a bunch of important use cases. The lack of docs is a sign you should not use it, but feel free to document your understanding and I'll review if you want.\n. @Dynom this project is pretty much of no public interest until I find the time to formally document it. I understand the curiosity and the code is open, but it is not a priority for me at this point and increasing engagement would be counter productive when I don't have the time to engage.\n. Probably better to start with a description of the protocol and flow than jumping to how to use the API...\n. @geek gave up? :-)\n. When the user authorizes third party access, you reflect that access using a grant object.\n. The app ticket can be used for additional rsvp exchanges as well as accessing app-specific resources. The method through which the user is redirected is not specified at this time. There are plenty of well-established ways to do that. Also see new docs.\n. Not actually worth the effort.\n. The only tool I am aware of with hawk support is the request module. I don't know of a manual sandbox (though postmile does include a developer console page for just that). Postmile is the only current example of oz but it's out dated. This is on my todo list.\n. I don't think this belongs here. One of the things I am trying to do with Oz is keep things simple at this level. I also not sure that at the end, these kind of complex systems are sustainable. Can't really help with your specific questions, but I would implement that as a separate layer on top of auth, basically it's own service.\n. Nice! You should rename it `express.js` since it is specific to that framework (with hapi you just use the scarecrow plugin). Also need to fix the linting issues.\n. The key is used by the underlying hawk layer for making authenticated requests. It's sent once over TLS to the client and then only used to generate a hash the server can validate.\n. I'm pretty sure it wants a 256bits key.\n. Those are different keys. Each ticket comes with its own key.\n. Oz uses tickets. In order to get a ticket, we need to bootstrap the process and we're using the client Hawk credentials. But once we got those, we exchange them for a ticket which includes all the application state we need, scope, expiration, etc.\n. I am probably not going to get to this for a while. Just want to set expectations.\n. I think this needs to live somewhere else. I don't want to maintain it moving forward as it is time consuming and I don't use express. If you post this somewhere else, I'll link to the example from the readme.. Why use oz at all for client-server auth? Just use hawk directly.\n. @patchthecode it's practically impossible to give you quality advice on this. There are just so many ways to mess things up here. Both oz and hawk are useful for app to server communication. The right solution depends on how you manage access, what your users use to login, etc. For example, if they enter a username and password on the app and then need to get back some token they can use to make api calls, hawk would be enough. If you don't want to do a token lookup every request, you can use iron to encode information into the token. I really can't help you beyond this. I suggest you find someone who has time to help who knows this space well. You should not design your system security based on this. Good luck.\n. Not yet. I'll work on it as I need it which as you can see from the history of this repo is unpredictable...\n. Nope. There is  no way to protect client-side secrets. All you can do is issue session-specific credentials via user involvement so that there is some extra sanity but beyond that, nope.\n. I like this.\n. Thanks. I'll try to get to this in a couple of weeks. If you don't hear from me by mid April, ping me.\n. I know... I am launching my startup these days so that's where my focus is right now. This is the right direction so I will get to it but can't promise when.\n. @richardolsson I am not planning on reviewing this for at least another month. It is very low on my list.\n. I am going to look into this again after the move to async api.. You don't need `Oz.client` in the browser. You just need to use the **hawk** browser code directly. I have no idea about using it with browerify. I would never try that.\n. In theory it could, but it was written for node, not the browser. If you are going to use it in the browser, you are on your own. I don't use it on the browser, I have my own browser logic code to handle it which I cannot share because it's too integrated into our logic. We just use hawk directly.\n. Probably not. I am not a fan of using browserify.\n. If by allowing passwords you mean no requiring buffer keys that are fed directly into iron, I don't see the harm in that. These tools are designed to be used by people who fully understand the security properties of the protocol. Iron usage of password makes sense for the many other use cases it is used for.. Why would you add a redirection endpoint?. Redirection is needed but you don't need a special endpoint for it. You just do it from the authorization page. The security properties are the same as in OAuth 1 and 2. You want to only redirect to previously registered endpoint.. The flow is correct but make sure app B passes the correct app and dlg options when creating the header. The goal is to make sure app B doesn't get handled any random credentials and then use them. It must know what these credentials are for and where they came from.. There is no identity layer, but since this is based on the same best practices and architecture, it should be easy to add it if someone wanted to. I do not plan on adding that to the core module.. I have no intention of writing a specification for oz or hawk. Both projects are working well and cover all my needs. As I find new use cases or bugs, I will publish new versions to address them.. Sorry but the main source of information are the tests. I have no plans on adding examples. This work is presented as-is.... ",
    "Dynom": "If you could write some documentation about why OZ is a better idea for mobile/browser implementations, than for example oAuth. I'd be most interested and the project will open up to a whole community that might be very interested in participating. I understand that time is an issue, but I also think the web is in dire need of continuous improvement for security related implementations. And who knows, OZ might be an answer to many.\n\nIf you could answer the questions:\n- What are the differences with oAuth\n- What work needs to be done\n- What use-cases will work for OZ and which won't\n. >  [...] These tools are designed to be used by people who fully understand the security properties of the protocol. [...]\r\n\r\nSo was oAuth2 @hueniverse (-;. If you could write some documentation about why OZ is a better idea for mobile/browser implementations, than for example oAuth. I'd be most interested and the project will open up to a whole community that might be very interested in participating. I understand that time is an issue, but I also think the web is in dire need of continuous improvement for security related implementations. And who knows, OZ might be an answer to many.\n\nIf you could answer the questions:\n- What are the differences with oAuth\n- What work needs to be done\n- What use-cases will work for OZ and which won't\n. >  [...] These tools are designed to be used by people who fully understand the security properties of the protocol. [...]\r\n\r\nSo was oAuth2 @hueniverse (-;. ",
    "mdxs": "@Dynon see http://vimeo.com/52882780 for the first two bullets (and maybe part of the third as well)\n. @Dynon see http://vimeo.com/52882780 for the first two bullets (and maybe part of the third as well)\n. ",
    "shawm11": "It seems that the encryption password is supposed to be generated and stored by the server (service provider) and kept secret. The encryption password is not shared with the app (client) or the user (resource owner).\n. I thought a redirection endpoint would be necessary for the steps 2 and 3 of the the workflow. So if a redirection endpoint is not necessary, how is the RSVP supposed to get to the application after the server gives the RSVP to the user? In other words, how does the user give the RSVP to the application?\r\n. It seems that the encryption password is supposed to be generated and stored by the server (service provider) and kept secret. The encryption password is not shared with the app (client) or the user (resource owner).\n. I thought a redirection endpoint would be necessary for the steps 2 and 3 of the the workflow. So if a redirection endpoint is not necessary, how is the RSVP supposed to get to the application after the server gives the RSVP to the user? In other words, how does the user give the RSVP to the application?\r\n. ",
    "yury": "Thank you!\n. Thank you!\n. ",
    "kidtronnix": "@hueniverse I can see you've been up to a lot recently so totally understand the lack of examples and kudos for pumping out more awesome open source joy. I would be happy to try and help on the examples front, I am now considering implementing Oz in a user service i am devving called [lummox](https://github.com/smaxwellstewart/lummox).\n\nI am designing it as a microservice, and basically it is respnsible for the bits that Oz leaves out, CRUD of users and authenticating them. I was deliberately not going down the OAuth2 route as I hate it, so was using a JWT auth mechanism with refresh and access tokens. But Oz seems to have similar benefits (possibility of stateless session) with more layers of security.\n\nAnyway be great to see if I could implement it in this project but wandering what's the best place to start understanding it. I imagine just source code for now eh...\n. Ok so i think I got my head around the protocol. Going to try and put together a simple example of a server and an app.\n\nNot sure if you wanna close this issue and make 2 different issues, one for examples and one for tooling.\n\nAlso I found this postmanlabs/postman-app-support#839 look like a very promising feature for postman which is my go to rest client.\n. @ryansobol I've been busy completing a related project, so no examples yet. However I will be focusing on this soon.\n\n@hueniverse Seems like there is progress on the postman issue and Hawk auth will soon be added to postman.\n. So i have had a bit of time to look at things and am trying to put together a working example of an application to server example using scarecrow for hapi.\n\nI started a repo if others want to contribute, [oz-examples](https://github.com/smaxwellstewart/oz-examples), until we have a working example to merge back in to this repo.\n\nBeen getting my head around Hawk auth again, and taking the time to try and understand the protocol. Seems like there is a lot of layers of security, which is really good but does demand a fair amount of careful understanding of exactly what protection each is offering.\n\nHaving a working rest client for Hawk auth would really speed up dev as well. Last time i checked it had been selected for active dev :)\n. Also thank you @ryansobol  your example really helps!\n. @hueniverse I can see you've been up to a lot recently so totally understand the lack of examples and kudos for pumping out more awesome open source joy. I would be happy to try and help on the examples front, I am now considering implementing Oz in a user service i am devving called [lummox](https://github.com/smaxwellstewart/lummox).\n\nI am designing it as a microservice, and basically it is respnsible for the bits that Oz leaves out, CRUD of users and authenticating them. I was deliberately not going down the OAuth2 route as I hate it, so was using a JWT auth mechanism with refresh and access tokens. But Oz seems to have similar benefits (possibility of stateless session) with more layers of security.\n\nAnyway be great to see if I could implement it in this project but wandering what's the best place to start understanding it. I imagine just source code for now eh...\n. Ok so i think I got my head around the protocol. Going to try and put together a simple example of a server and an app.\n\nNot sure if you wanna close this issue and make 2 different issues, one for examples and one for tooling.\n\nAlso I found this postmanlabs/postman-app-support#839 look like a very promising feature for postman which is my go to rest client.\n. @ryansobol I've been busy completing a related project, so no examples yet. However I will be focusing on this soon.\n\n@hueniverse Seems like there is progress on the postman issue and Hawk auth will soon be added to postman.\n. So i have had a bit of time to look at things and am trying to put together a working example of an application to server example using scarecrow for hapi.\n\nI started a repo if others want to contribute, [oz-examples](https://github.com/smaxwellstewart/oz-examples), until we have a working example to merge back in to this repo.\n\nBeen getting my head around Hawk auth again, and taking the time to try and understand the protocol. Seems like there is a lot of layers of security, which is really good but does demand a fair amount of careful understanding of exactly what protection each is offering.\n\nHaving a working rest client for Hawk auth would really speed up dev as well. Last time i checked it had been selected for active dev :)\n. Also thank you @ryansobol  your example really helps!\n. ",
    "ryansobol": "@smaxwellstewart I'd love to see your examples when they're ready.\n. @smaxwellstewart Awesome. BTW, a few weekends ago, I wrote up a little single-file program that implements the basic Oz workflow and submitted it as a [pull request](https://github.com/hueniverse/oz/pull/37). It really helped me understand some of the nitty gritty workflow details (and also raised a bunch more questions).\n. One of the things I really like about the Oz\u00a0protocol is how flexible it is. After whipping up a [working example in express](#37), the next thing I'd really love to see is an actual server-side app with an Oz implementation that mirrors the OAuth 1.0a server-side workflow.\n. The file has been renamed and the code has been linted. :white_check_mark: \n\nGoing into this, my goal was to demonstrate how to implement the Oz workflow with as little code and dependencies as possible. I started with a simple Node `http` server, but quickly got annoyed with parsing methods and URIs manually. I considered using `hapi`, but settled on `express` as it's the most minimal of the two.\n\nI hope you don't mind that I have a bunch of questions for you about this protocol. I'll start off with just one. :smile: \n\nWhen an Oz ticket is generated, it's given a `key` property that's a [random, 32-byte String](https://github.com/hueniverse/oz/blob/master/lib/ticket.js#L344-L349). For the life of me, I can't figure out how this secret key is used! It's not even really that secret as it's included, in plain text, within both\u00a0the app ticket and user ticket JSON responses. Can you help me understand what's going on here?\n. Okay, I understand. \n\nBut if Oz's default algorithm for generating HMACs is sha256, why use a 32-byte String? Isn't the key just going to be padded with zeros until it reaches the algorithm's desired key length of 64 bytes?\n. You know, that's what I thought too! Given the name sha**256** in all. Then I read this and got all confused.\n\n> Block size:  the size of the data block the underlying hash algorithm operates upon. **For SHA-256, this is 512 bits**, for SHA-384 and SHA-512, this is 1024 bits.\n\nhttps://tools.ietf.org/html/rfc4868#section-2.1\n\n> If the length of the key is exactly the algorithm block size, use it as-is. If the key is shorter than the block size, lengthen it to exactly the block size by padding it on the right with zero bits.\n\nhttps://tools.ietf.org/html/rfc4868#section-2.1.2\n\nHonestly, I'm probably just misinterpreting something about this document. But I wanted to ask you because I figured you knew better.\n\nMy next question is this: When requesting an RSVP, what's the benefit of using the `key` property embedded in the App ticket vs the original `key` in the App credentials?\n\n(BTW - Thank you for taking the time to answer these questions. You don't know how much I appreciate it. It's been a long time since I've looked this deeply into security\u00a0protocols. It's fascinating!)\n. Right, but why have different keys? In other words, what's the security benefit?\n. Hey @hueniverse, thanks for being a patient sport. Feel free to merge this pull request in, if you're satisfied. I'm going to play around with Oz some more and write up an Oz authentication provider web app based on the OAuth 1.0a workflow for fun. I'll probably have more questions then.  :)\n. @ycpatel813 The current status of the express example is that it works. Sorry it's taken me so long to incorporate the feedback. I've separated the example's dependencies from Oz's dependencies. Also, I've separated the server code from the client code as well as demonstrated how to store the encryption password in an environment variable. Feedback is very welcome.\n\nPS - Once your satisfied, @hueniverse, I'm happy to add a `client_with_connection_manager.js` example to this PR that demonstrates how to use the new `Oz.client.Connection()` API.\n. @smaxwellstewart I'd love to see your examples when they're ready.\n. @smaxwellstewart Awesome. BTW, a few weekends ago, I wrote up a little single-file program that implements the basic Oz workflow and submitted it as a [pull request](https://github.com/hueniverse/oz/pull/37). It really helped me understand some of the nitty gritty workflow details (and also raised a bunch more questions).\n. One of the things I really like about the Oz\u00a0protocol is how flexible it is. After whipping up a [working example in express](#37), the next thing I'd really love to see is an actual server-side app with an Oz implementation that mirrors the OAuth 1.0a server-side workflow.\n. The file has been renamed and the code has been linted. :white_check_mark: \n\nGoing into this, my goal was to demonstrate how to implement the Oz workflow with as little code and dependencies as possible. I started with a simple Node `http` server, but quickly got annoyed with parsing methods and URIs manually. I considered using `hapi`, but settled on `express` as it's the most minimal of the two.\n\nI hope you don't mind that I have a bunch of questions for you about this protocol. I'll start off with just one. :smile: \n\nWhen an Oz ticket is generated, it's given a `key` property that's a [random, 32-byte String](https://github.com/hueniverse/oz/blob/master/lib/ticket.js#L344-L349). For the life of me, I can't figure out how this secret key is used! It's not even really that secret as it's included, in plain text, within both\u00a0the app ticket and user ticket JSON responses. Can you help me understand what's going on here?\n. Okay, I understand. \n\nBut if Oz's default algorithm for generating HMACs is sha256, why use a 32-byte String? Isn't the key just going to be padded with zeros until it reaches the algorithm's desired key length of 64 bytes?\n. You know, that's what I thought too! Given the name sha**256** in all. Then I read this and got all confused.\n\n> Block size:  the size of the data block the underlying hash algorithm operates upon. **For SHA-256, this is 512 bits**, for SHA-384 and SHA-512, this is 1024 bits.\n\nhttps://tools.ietf.org/html/rfc4868#section-2.1\n\n> If the length of the key is exactly the algorithm block size, use it as-is. If the key is shorter than the block size, lengthen it to exactly the block size by padding it on the right with zero bits.\n\nhttps://tools.ietf.org/html/rfc4868#section-2.1.2\n\nHonestly, I'm probably just misinterpreting something about this document. But I wanted to ask you because I figured you knew better.\n\nMy next question is this: When requesting an RSVP, what's the benefit of using the `key` property embedded in the App ticket vs the original `key` in the App credentials?\n\n(BTW - Thank you for taking the time to answer these questions. You don't know how much I appreciate it. It's been a long time since I've looked this deeply into security\u00a0protocols. It's fascinating!)\n. Right, but why have different keys? In other words, what's the security benefit?\n. Hey @hueniverse, thanks for being a patient sport. Feel free to merge this pull request in, if you're satisfied. I'm going to play around with Oz some more and write up an Oz authentication provider web app based on the OAuth 1.0a workflow for fun. I'll probably have more questions then.  :)\n. @ycpatel813 The current status of the express example is that it works. Sorry it's taken me so long to incorporate the feedback. I've separated the example's dependencies from Oz's dependencies. Also, I've separated the server code from the client code as well as demonstrated how to store the encryption password in an environment variable. Feedback is very welcome.\n\nPS - Once your satisfied, @hueniverse, I'm happy to add a `client_with_connection_manager.js` example to this PR that demonstrates how to use the new `Oz.client.Connection()` API.\n. ",
    "mikalai-silivonik": "For anyone interested I have an example of Oz usage: https://github.com/mikalai-silivonik/hapi-oz-example that does server-to-server auth.\n. For anyone interested I have an example of Oz usage: https://github.com/mikalai-silivonik/hapi-oz-example that does server-to-server auth.\n. ",
    "hazcod": "A client example would be awesome too!\n. A client example would be awesome too!\n. ",
    "ycpatel813": "@ryansobol may i know what is the final status of express example??\n. @ryansobol may i know what is the final status of express example??\n. ",
    "imta11": "Awesome, I'll take a look tomorrow. Would it include any ability to bind to\nan enterprise identity management solution like active directory? I'm\nthinking of the case where you need to suddenly add 10,000 users overnight\nand include a default roles profile, and add additional user roles based on\nresponsibility.\n\nI.e., the partner grants additional permissions and their authorization\nservice is allowed to add/subtract roles from a list that both parties\nagree on.\n\nCM\nOn Nov 21, 2015 2:16 PM, \"Simon Maxwell-Stewart\" notifications@github.com\nwrote:\n\n> So recently I have been trying to solve a similar problem to your attempt\n> with Oz, ie:\n> \n> Making a secure but flexible authorization protocol between applications\n> and some kind of grant / scope server.\n> \n> So i came up with lummox https://github.com/smaxwellstewart/lummox. It\n> differs from Oz in the following ways:\n> - It is designed as a highly configurable user management,\n>   authentication and authorization service for distributed systems; it deals\n>   with user's CRUD and authentication.\n> - Once authenticated, a user generates a JSON web token with an\n>   embedded scope claim (the user's scope). This scope claim is used to\n>   authorize the user for other systems.\n> - It does not deal with secure storage of this token.\n> - It does not deal with securing the transport layer.\n> \n> While I like the simplicity of just dealing with JSON web tokens, a well\n> known standard, i am concerned about the lack of layers of security in my\n> solution.\n> \n> So I could implement Oz as lummox authorization protocol, keeping the user\n> management and authentication components.\n> \n> Would love to know whether people think this would be a good idea? Do you\n> see potnential security concerns with this kind of solution?\n> \n> The code is 100% unit tested so should make changing it's functionality\n> manageable.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hueniverse/oz/issues/39.\n. Awesome, I'll take a look tomorrow. Would it include any ability to bind to\nan enterprise identity management solution like active directory? I'm\nthinking of the case where you need to suddenly add 10,000 users overnight\nand include a default roles profile, and add additional user roles based on\nresponsibility.\n\nI.e., the partner grants additional permissions and their authorization\nservice is allowed to add/subtract roles from a list that both parties\nagree on.\n\nCM\nOn Nov 21, 2015 2:16 PM, \"Simon Maxwell-Stewart\" notifications@github.com\nwrote:\n\n> So recently I have been trying to solve a similar problem to your attempt\n> with Oz, ie:\n> \n> Making a secure but flexible authorization protocol between applications\n> and some kind of grant / scope server.\n> \n> So i came up with lummox https://github.com/smaxwellstewart/lummox. It\n> differs from Oz in the following ways:\n> - It is designed as a highly configurable user management,\n>   authentication and authorization service for distributed systems; it deals\n>   with user's CRUD and authentication.\n> - Once authenticated, a user generates a JSON web token with an\n>   embedded scope claim (the user's scope). This scope claim is used to\n>   authorize the user for other systems.\n> - It does not deal with secure storage of this token.\n> - It does not deal with securing the transport layer.\n> \n> While I like the simplicity of just dealing with JSON web tokens, a well\n> known standard, i am concerned about the lack of layers of security in my\n> solution.\n> \n> So I could implement Oz as lummox authorization protocol, keeping the user\n> management and authentication components.\n> \n> Would love to know whether people think this would be a good idea? Do you\n> see potnential security concerns with this kind of solution?\n> \n> The code is 100% unit tested so should make changing it's functionality\n> manageable.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/hueniverse/oz/issues/39.\n. ",
    "patchthecode": "Don't flame me for my extremely noobish question, but I am just a programmer trying to:\n1. Make sense of all the authentication stuff\n2. Understand how `Oz`, `Iron` and `Hawk` work together.\n3. Find out which of the Tri (`Oz`, `hawk`, `Iron`) I should be using and when.\n\nI am an ok coder for non-web related stuff, but I'm no security expert.\nAfter seeing your F\\* OAuth video, I figured that one of the instrumental devs on OAuth must have had a point, so i'm here checking out this repo. \n\nI have an iOS app where users can sign in. I have a server, and I have a database where user-login info/data is stored. From the way you responded to @shawm11, I guess that:\n1. The type of setup I have is considered a 2-legged workflow \n2. and that `Hawk` is the one (of the trio) I should be using if my workflow is only 2-legged?\n\nIf this is true then when is `Iron` needed?\n\nThe server will be based on a PHP port of your Hawk. I will be using -> https://github.com/dflydev/dflydev-hawk\nThanks.\n. Understood. And thanks for your work.\n. Don't flame me for my extremely noobish question, but I am just a programmer trying to:\n1. Make sense of all the authentication stuff\n2. Understand how `Oz`, `Iron` and `Hawk` work together.\n3. Find out which of the Tri (`Oz`, `hawk`, `Iron`) I should be using and when.\n\nI am an ok coder for non-web related stuff, but I'm no security expert.\nAfter seeing your F\\* OAuth video, I figured that one of the instrumental devs on OAuth must have had a point, so i'm here checking out this repo. \n\nI have an iOS app where users can sign in. I have a server, and I have a database where user-login info/data is stored. From the way you responded to @shawm11, I guess that:\n1. The type of setup I have is considered a 2-legged workflow \n2. and that `Hawk` is the one (of the trio) I should be using if my workflow is only 2-legged?\n\nIf this is true then when is `Iron` needed?\n\nThe server will be based on a PHP port of your Hawk. I will be using -> https://github.com/dflydev/dflydev-hawk\nThanks.\n. Understood. And thanks for your work.\n. ",
    "rs22": "Let me take this one back: I think there _are_ use cases for delegating app tickets, so I've added the missing functionality. After all this workflow is about delegating tickets, not only user grants.\n. Ping! (finally...)\n\nMeanwhile I've tried to come up with an App-to-App authentication mechanism that also uses this workflow. If you have time to look at it, I'd be happy to hear your thoughts: [https://github.com/rs22/fluffy](https://github.com/rs22/fluffy).\n. Let me take this one back: I think there _are_ use cases for delegating app tickets, so I've added the missing functionality. After all this workflow is about delegating tickets, not only user grants.\n. Ping! (finally...)\n\nMeanwhile I've tried to come up with an App-to-App authentication mechanism that also uses this workflow. If you have time to look at it, I'd be happy to hear your thoughts: [https://github.com/rs22/fluffy](https://github.com/rs22/fluffy).\n. ",
    "richardolsson": "What's the status of this? It looks well-tested and the tests seems to be passing. Should I feel comfortable using this branch while waiting for it to be merged?\n. Thank you for your swift reply!\n\nMaybe I'm missing something, but isn't `Oz.client.Connection` intended to help with the entire lifecycle, ticket reissue workflow, et c? Are you saying that should never happen in the browser, even for a client-side only application?\n\nOther than the fact that app keys would not be secret in a browser app, I don't as of yet see why the entire workflow couldn't happen directly in the browser. Please help me understand.\n. Thanks for the update. I'm thinking `Oz.client.Connection` would be very useful in any setting, including the browser.\n\nWould you consider accepting a PR which solves this? Using the node `http`/`https` modules generally works fine with tools like Browserify, so I'm guessing the issue is somewhere in the way Wreck uses these modules, and could be remedied either by small changes to Wreck or using `http`/`https` directly in `Oz.client.Connection`.\n. What's the status of this? It looks well-tested and the tests seems to be passing. Should I feel comfortable using this branch while waiting for it to be merged?\n. Thank you for your swift reply!\n\nMaybe I'm missing something, but isn't `Oz.client.Connection` intended to help with the entire lifecycle, ticket reissue workflow, et c? Are you saying that should never happen in the browser, even for a client-side only application?\n\nOther than the fact that app keys would not be secret in a browser app, I don't as of yet see why the entire workflow couldn't happen directly in the browser. Please help me understand.\n. Thanks for the update. I'm thinking `Oz.client.Connection` would be very useful in any setting, including the browser.\n\nWould you consider accepting a PR which solves this? Using the node `http`/`https` modules generally works fine with tools like Browserify, so I'm guessing the issue is somewhere in the way Wreck uses these modules, and could be remedied either by small changes to Wreck or using `http`/`https` directly in `Oz.client.Connection`.\n. ",
    "AJamesPhillips": "@richardolsson the hawk package.json lists \"browser\" pointing to `dist/browser.js`.  If you use `require('oz/lib/client')` in browser code with webpack, then `dist/browser.js` will be referenced as opposed to Hawk's `lib/index.js` with its `lib/client.js`.\r\n\r\nThe authenticate function signature in `browser.js` accepts 4 arguments and synchronously returns a boolean.  The `client.js` authenticate accepts a 5th argument of a callback.  Thus the callback is never being called:\r\n\r\n    const OzClient = require('oz/lib/client');\r\n    new OzClient.Connection({uri, credentials}).request(\"/protected\", user_ticket, {}, (err, result, code, ticket) => {\r\n        // never reached\r\n    });\r\n\r\nThat might be the problem you're experiencing?  Anyway, if I can't iron (no pun intended ;) ) it out I will follow hueniverse's advice and build my own wrapper around hawk.  Though as you also said it would be nice to avoid copy and pasting the work hueniverse has put into the client.Connection helper for client-side applications.. Hi @tjmcclure0501 , [this article](https://hueniverse.com/auth-to-see-the-wizard-4a7c3572f618) may no longer be accurate but at the time of writing hueniverse stated, well I paraphrase:\r\n\r\nHe wrote a JavaScript module providing a full authentication and authorization solution for building web applications.  He did not write a protocol because the \"problem with security protocols is that they are useless without an equally solid implementation. The only point in a protocol is interoperability and I don\u2019t care about interoperability.\" He just wants to, and with Oz also allows us to, build great and secure web products.\r\n\r\nI don't understand the \"unsupported propriety [sic] security technology\".  Whilst the license mentions yahoo's postmile, the copyright is owned by the contributors.  So it is proprietary but contribute and you become an owner.  Perhaps there is some relevant legalese I'm missing in your jurisdiction?   If so perhaps open a new issue or preferably submit a PR to the license to start a conversation.\r\n\r\nIs it dead?  Hueniverse interacted with it at least a month ago... I feel like I've misunderstood your point again though.\r\n\r\nRe: Complete spec / roadmap.  I believe the implementation is compete, (and that is the spec)\r\n\r\n> integrated with frameworks such as Kong\r\n\r\nThis would not live in this repo nor in the Kong repo but in a Kong-Oz repo surely?  And I'd have thought this would be very well received.. @richardolsson the hawk package.json lists \"browser\" pointing to `dist/browser.js`.  If you use `require('oz/lib/client')` in browser code with webpack, then `dist/browser.js` will be referenced as opposed to Hawk's `lib/index.js` with its `lib/client.js`.\r\n\r\nThe authenticate function signature in `browser.js` accepts 4 arguments and synchronously returns a boolean.  The `client.js` authenticate accepts a 5th argument of a callback.  Thus the callback is never being called:\r\n\r\n    const OzClient = require('oz/lib/client');\r\n    new OzClient.Connection({uri, credentials}).request(\"/protected\", user_ticket, {}, (err, result, code, ticket) => {\r\n        // never reached\r\n    });\r\n\r\nThat might be the problem you're experiencing?  Anyway, if I can't iron (no pun intended ;) ) it out I will follow hueniverse's advice and build my own wrapper around hawk.  Though as you also said it would be nice to avoid copy and pasting the work hueniverse has put into the client.Connection helper for client-side applications.. Hi @tjmcclure0501 , [this article](https://hueniverse.com/auth-to-see-the-wizard-4a7c3572f618) may no longer be accurate but at the time of writing hueniverse stated, well I paraphrase:\r\n\r\nHe wrote a JavaScript module providing a full authentication and authorization solution for building web applications.  He did not write a protocol because the \"problem with security protocols is that they are useless without an equally solid implementation. The only point in a protocol is interoperability and I don\u2019t care about interoperability.\" He just wants to, and with Oz also allows us to, build great and secure web products.\r\n\r\nI don't understand the \"unsupported propriety [sic] security technology\".  Whilst the license mentions yahoo's postmile, the copyright is owned by the contributors.  So it is proprietary but contribute and you become an owner.  Perhaps there is some relevant legalese I'm missing in your jurisdiction?   If so perhaps open a new issue or preferably submit a PR to the license to start a conversation.\r\n\r\nIs it dead?  Hueniverse interacted with it at least a month ago... I feel like I've misunderstood your point again though.\r\n\r\nRe: Complete spec / roadmap.  I believe the implementation is compete, (and that is the spec)\r\n\r\n> integrated with frameworks such as Kong\r\n\r\nThis would not live in this repo nor in the Kong repo but in a Kong-Oz repo surely?  And I'd have thought this would be very well received.. "
}