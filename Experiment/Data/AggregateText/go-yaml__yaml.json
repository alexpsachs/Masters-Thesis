{
    "niemeyer": "That doesn't yet work indeed, but it should. Here is the documentation reference:\n\nhttp://yaml.org/type/merge.html\n. LGTM, thank you.\n. FWIW, the point of the loop was not because Replace would remove only a single entry. Note how it actually breaks out of the loop when it finds the first one. The point was to not call Replace in the first place, if it would do nothing. The change is probably making it slower. But Replace still avoids the allocation these days, if there's nothing to do, so hopefully not much slower.\n. This should also consider streams with multiple documents.\n. How's that different from #4?\n. Okay, it sounds like this is effectively the same as #4.\n. That was previously reported as #1, and was just fixed.\n. Thanks for the report.\n. I'm changing the subject to reflect the pointer bug. We have #10 covering the time.Time support.\n. Thanks!\n. I'm happy to merge this. Can you please sign the contribution agreement:\n\n```\nhttp://www.canonical.com/contributor-license-agreement\n```\n\nIt's a straightforward/non-draconian one.\n. Thanks!  Can you include the decoding side, now that the non-pointer bug is fixed?\n. Ah, we have to look at something else too. The time.Time encoding and decoding format must match the standard yaml timestamp type: http://yaml.org/type/timestamp.html\n. We can just try them all in sequence, starting by the format we marshal out so that the default encode/decode sequence hits on the first try.\n. We need time handling, but we need both sides of it. I'm closing this for lack of activity. Please feel free to push the complete change once you're ready.\n. I have originally advocated having a generic \"key\" tag that would be used by multiple packages, but the core Go team favored an approach where each package would have its own namespace. The yaml package is following that recommended convention.\n\nIn terms of the type of maps, yaml accepts non-string keys, which json does not, so both packages are correct with the respective types.\n. The problem with yaml.RawMessage is that unlike JSON, YAML is context-dependent. One cannot properly encode a piece of raw YAML without knowing what the surrounding data is, due to indentation.\n\nCan the +1 voters please detail a bit how this is intended to be used that isn't solved by the current system?  Maybe we can design something else that solves the problem.\n. Yeah, it should be easy to use a MapSlice, and one can even marshal it back into yaml and then unmarshal it again to get the exact semantics of a RawMessage. That said, I'll keep this issue open so we can consider the idea of a RawMessage-like feature further.\n. Thanks for all the feedback, by the way!\n. @dvirsky That goes beyond the goals of the yaml package, but there are other packages available for such direct map-to-struct conversion (e.g. https://github.com/mitchellh/mapstructure).\n. Yes, that's similar to what [bson.Raw](http://gopkg.in/mgo.v2/bson#Raw) does, but it's not quite the same, and it's not the same as `json.RawMessage` either. The problem is that unlike bson and json, you cannot marshal it back as-is, because yaml marshaling is context sensitive.\n\nIt's likely the direction we'll take, though. We'll just need some further work on the marshaling side.\n. And not very _\"Raw\",_ if you see what I mean. We'll likely end up with a similar abstraction that can lazily unmarshal and re-marshal appropriately, but not provide direct access to the text.\n. @thockin The value you get into SetYAML corresponds exactly to the value that is in the YAML document in the position of the respective field. We have another issue open to improve the documentation there, but either way the best way to learn how to use it is to play a bit with the method and some data.\n. Ah, and in terms of validation of content, that's outside the scope for the yaml package. There are packages for dealing just with that problem alone, though. For example: https://github.com/juju/schema\n. That's not supported, but you can easily have two fields and copy the data from one to the other in application logic.\n. You do have two fields in the document, so there's no reason to avoid having two fields in the struct you are using to manipulate the document. This is application logic.\n. +1\n\nPlease consider submitting them in an examples_test.go file which is properly handled by godoc:\n\nhttps://blog.golang.org/examples\n. You are right, the documentation is definitely lacking. I'm sorry.\n\nThe tag is a YAML tag: http://yaml.org/spec/1.1/#id858600\n\nSince you don't know what it is for, it means you probably don't care, so leaving it empty will likely produce the result you expect.\n. Documentation and the interfaces themselves were improved in yaml.v2, as described in the announcement:\n\nhttp://blog.labix.org/2014/09/22/announcing-yaml-v2-for-go\n. Will do on a future change.\n\nThanks.\n. Yeah, arrays are not yet supported. Unmarshal into a slice ([]int) and it should be fine.\n. That's why it's still open.\n. Most applications actually don't care about the ordering of maps in either JSON or YAML, and all parsers I know will also unmarshal into a first class hash map of the host language, which is pretty much always unordered, with the notable exception of JavaScript. For example, this is Python:\n\n```\n>>> import yaml\n>>> yaml.load(\"{b: 2, a: 1}\")\n{'a': 1, 'b': 2}\n```\n\nThe YAML [specification](http://yaml.org/spec/1.1/#id932806) is also pretty clear about what maps are:\n\n> A mapping node is an unordered collection of key: value pairs.\n\nWith all that said, we can support ordered maps. I have documented in #30 the plan for that. Let's please follow up the conversation on that issue.\n. This should be easy to implement, but is not yet supported right now.\n. Closing this as we're tracking that need in #4 already.\n. You mean you have something like this:\n\n```\nField Type `yaml:\",omitempty,omitempty\"`\n```\n\n?\n\nThat looks like a bogus declaration. Why would that be desirable?\n. Sorry, but I still don't understand what you mean. This works fine:\n\n```\ntype Foo struct {\n    Bar string `yaml:\"a,omitempty\"`\n    Foo string `yaml:\"b,omitempty\"`\n}\n\nfunc main() {\n    var foo Foo\n    err := yaml.Unmarshal([]byte(\"{a: bar, b: foo}\"), &foo)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(foo.Bar)\n    fmt.Println(foo.Foo)\n}\n```\n. A map for which you can never anticipate the key is not a very useful building block.\n\nThe proper way to support this would be with something like:\n\n```\ntype MapSlice []MapItem\n\ntype MapItem struct {\n        Key, Value interface{}\n}\n```\n\nand then implement first-class marshalling and unmarshalling of maps onto it.\n. Opened issue #30 to track the work. Closing the pull request as that's not the right direction.\n. The default development branch is v1, which reflects the current version of the API. We also prevent people incorrectly importing the package from github.com/go-yaml/yaml by having a clear error message via the error.go file.\n. I'm not missing this right now, but please feel free to contribute the setup.\n. The go-yaml package does sort by default when marshaling as well, and has always done so. I have changed the summary to clarify that the feature I was considering is a different one.\n\nThis also makes me wonder about what was being originally requested. Pull request #27 implies that the ordering is random, which is not true. So maybe there's nothing to be done here.\n\nRegarding JSON-the-spec, no it [does not](http://json.org) assert key ordering either:\n\n> An object is an unordered set of name/value pairs.\n. @termie Most people that talk about JSON are referring to [the specification](http://json.org), not general JavaScript objects.\n. @termie Sorry, I was just clarifying the question, which was about JSON rather than JavaScript, but we disagree on a few different fronts. For example, I don't think people expect ordering out of JSON in general, and the absolute majority of applications couldn't care less. Python also reflects that and does not respect the ordering by default either:\n\n```\n>>> import json\n>>> json.dumps(json.loads('{\"b\": 2, \"a\": 1}'))\n'{\"a\": 1, \"b\": 2}'\n```\n\nWith all that said, I would still like to make the Go yaml package work for you, but I don't think I really understand the problem I'm trying to solve. In what way is the current logic breaking your application?\n. Okay, thanks for the example. It makes the issue clear. The application internally depends on the order of the keys based on attributed semantics.\n\nSupport for this is coming via `yaml.MapSlice` as described, then.\n. @ingydotnet The JSON spec says it's unordered, and thankfully the vast majority of applications follow suit. I find it quite poor style to depend on orderings for maps that are meant to be used as a key/value mechanism, and have practical experience with multiple bugs and general confusion generated by using them in that fashion in the only application I have seen depending on them for certain things (MongoDB).\n\nThat said, this is the go-yaml package, and I'll support the optional use of ordered values to allow people to preserve their logic working and interact with external content.\n. @ingydotnet Out of curiosity, what was the use case you considered YAML best for?\n. @ingydotnet Several reasons for porting it:\n- It plays much better with Go concurrency (no C stack, no thread takeover, etc)\n- It becomes memory-safe (no corruption, no buffer overflows, etc) \n- It makes better use of the memory management capabilities of Go\n- It runs faster since there's a cost associated with bridging with C\n- It becomes trivial to cross-compile into other OSes\n- It compiles much faster, although that's a minor convenience in this case\n- etc\n. @ingydotnet Oh, welcome to the team then. :-) And thanks for the background.\n\nI suspect lack of more suitable options is one of the reasons why YAML became so popular as a configuration format. There's still no other good human-oriented format that can represent nesting of the common set of types and other related needs (text line blocks, etc) in a pleasant way. On the other hand, I wish it was slightly more strict in a few places.\n\nRegarding being a superset of JSON, I don't find it so much of a coincidence to be honest. The JSON spec itself is pretty strict, the ECMA standard behind it is pre-2000 and was already popular at the time, and the general syntax style behind it is ancient. On the other side, YAML is very accepting (with 22 ways to say true or false, it's hard to get wrong ;-).\n\nThat's probably one of the reasons that kept its use purely as a cross-language conduit low, actually. I would also look for something much simpler and more strict for that, while I can pay a higher price to keep another human happy when reading or writing content.\n. @ingydotnet Ah, certainly, will join you there.\n. This feature was implemented. Details in the announcement for yaml.v2:\n\nhttp://blog.labix.org/2014/09/22/announcing-yaml-v2-for-go\n. Binary data is currently unsupported, but looping forever is the worst possible outcome in that scenario. Sorry about that.\n\nI'll get that fixed by implementing proper support for binary data.\n. This has to be marshalled as binary data, which I'm working on right now.\n. It's not a \"behind-the-scenes change\".. it's simply marshalling exactly the data provided into standard YAML form.\n. Also merged in v2 on b6b591a3.\n. They're not flawed, strictly speaking. They're just following version 1.1 of the specification, which amusingly [defines](http://yaml.org/type/float.html) _base 60 floats:_\n\n> Using \u201c:\u201d allows expressing the integer part in base 60, which is convenient for time and angle values (the fractional part is always in base 10).\n\nVery convenient. Of course everybody saying `1:1` want that decoded as `61.0`, right? Nuts, and that's what you get in those parsers you've been testing.\n\nThankfully, someone [got rid](http://yaml.org/spec/1.2/spec.html#id2804092) of them in 1.2:\n\n> Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression `-? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?`.\n\nand more [generally](http://yaml.org/spec/1.2/spec.html):\n\n> Normally, YAML insists the \u201c:\u201d mapping value indicator be separated from the value by white space. A benefit of this restriction is that the \u201c:\u201d character can be used inside plain scalars, as long as it is not followed by white space. This allows for unquoted URLs and timestamps. It is also a potential source for confusion as \u201ca:1\u201d is a plain scalar and not a key: value pair.\n. Sounds fair.\n. The logic in decoder.setter is tricky indeed, but in this case you've probably struggled more because the issue isn't actually there.\n\nThanks for filing the bug.\n. It supports struct tags, as per the documentation:\n\nhttp://gopkg.in/yaml.v2#Marshal\n. You need the `,inline` flag for that, as per the documentation:\n\nhttp://gopkg.in/yaml.v2#Marshal\n\nYou can use that flag both on normal and on anonymous fields.\n. No problem. ;-)\n\nAnd thanks for submitting the issues. They might well be valid problems.\n. Initial plan is to support v2 only.. there's really no big reason to stick on v1, so I'd rather give people more reasons to move on instead.\n. I've moved the implementation of the binary marshaling half onto issue #40. \n. Yes, that's the nested map type hinting doing ~~its job~~ something wrong. Why isn't X a map?\n. This means supporting types that implement that interface. The support for types that implement a different interface won't make that work.\n. Sorry, I wouldn't have done it if I knew you were already working on it. Just felt simple enough that discussing would take more time than doing it.\n. I believe this behavior was already fixed as a side effect of  0885984. I've added a test to ensure this is the case in bef53ef. If you find the bug again with the current code, please let me know.\n. Yes, the commits referenced above are up right now.\n. This should be fixed, but it's not clear this is the right fix. Shouldn't it be quoted rather than turned into a literal? Also, can we please have a test for this?\n. Closing for lack testing and lack of feedback. I cannot reproduce this issue, and have added a test at 71e7ede to ensure it continues to be the case. Please feel free to reopen or open an issue if you have a test case for it.\n. That error implies an SSL negotiation error with the website. You can try the git command by hand and debug it to see what is wrong. Ensure you're not behind a capturing proxy of some kind that is diverting the request to a different place.\n\nYou can also check that the website's certificate is alright by simply navigating to it with a browser.\n\nJust tried it out, and it works fine:\n\n```\n$ GOPATH=$PWD/foo go get gopkg.in/yaml.v2\n$\n```\n\nPlease feel free to reopen if you get any evidence that this is a problem with the service.\n. Can you please provide an example with code, expected output, actual output?\n. This is intended behavior for the moment. There's already plenty of flexibility by omitting or not (or renaming, etc) individual fields of the inlined document.\n\nBasically, inlining means actual inlining. Fields of the inlined document are seen as being in the outer document.\n\nI'll keep the issue open to have a second consideration of this on another day, but in principle I don't see the demand for the additional logic.\n. Yeah, the current behavior looks correct. Inline will pick the omitempty semantics from the inlined fields themselves, which is the correct thing to do in this case.\n. Needs to be fixed. Thanks for the report.\n. Thanks for the contribution. I'll provide comments inline.\n\nBesides any comments, though, we need to apply such changes to v2 rather than v1. There's no good reason not to move on from v1.\n. This looks good and I'm happy to merge it. Just see what you think of the suggestion above please.\n. Jordan, I got a bit ahead of myself here. I should have asked you to sign the contributor agreement first:\n\nhttp://www.ubuntu.com/legal/contributors\n\nIt's a straightforward agreement, easy to sign online. Can you please have a look and see if it makes sense?  We need that for contributions.\n. I'll need to back out the change if I don't get the signature this week. Sorry for the trouble, but this is required and I screwed up by not requesting beforehand.\n. Actually, to avoid creating a larger problem for people that update now, I have backed out the change right now. Please just ping me once you get the signature in place, and I'll happily reapply.\n. Thanks, and sorry for the trouble.\n. Any news there?\n. Please leave it with me. I'll just reapply the change.\n\nThanks for handling the bureaucracy.\n. Thanks for submitting this. Can we have a test covering the need for the change, please?\n\nAlso, would you mind to sign the contribution agreement if you haven't already done so?\n\n```\nhttps://www.ubuntu.com/legal/contributors\n```\n\nIt's straightforward/non-draconian, and easy to sign online.\n\nThanks!\n. Thanks, and sorry for the long delay on this.\n. Sorry, this got over my holidays and got delayed. It's now in.\n. The code isn't right, but the idea is fine.\n. The problem in the sample code is that only fields that are exported should be considered. I have the same logic working in the mgo/bson parser and will copy it over.\n. No big reason other than implementation convenience. It means all fields are already in memory rather than having to consider the nil case and initialize it appropriately.\n\nIt's a wart we should eventually fix.\n. Thanks, but this had been fixed on #52 already. I was just slow there, sorry.\n. I don't understand why \"\" would result in calling an unmarshaler while an implicit \"\" would not. This is very inconsistent. I'm happy to fix the bug, but not like that.\n\nGiven the discussion in that ticket referenced above, I'm assuming are not interested in contributing to the project anymore, and will close this and fix the bug.\n. Yes, you're right. I forgot \"a:\" actually implies a is null in YAML.\n\nI'm happy to accept this in. For that, can you please:\n\na) Sign the contributor agreement at:\n- http://www.ubuntu.com/legal/contributors\n\nb) Preserve the original formatting of the line (no unnecessary parenthesis, as usual in Go) while adding the intended change?\n\nThanks for these.\n. Ping?\n. Thanks for the submission.\n\nI don't think we're ready to accept the inline change at this time. This would break compatibility with existent code, and introduce a redundant way to define inlining, which is currently done via the \"inline\" tag flag (for historical context, that implementation was done before Go's json pacakge supported inlining).\n\nThe struct pointer might be acceptable, but not as part of this change, and I'm also slightly unsure about whether it is properly implemented. When we have a pointer, we need to worry about initialization of nil pointers appropriately. I haven't checked in detail the correctness of the suggestion as we cannot accept this for the above reason.  \n. Thanks\n. Thanks for getting on board and contributing code to the project. This is very welcome.\n\nA couple of points on the submission: first, can you please sign the contributor agreement so that I can integrate any changes you do to this project or any other Canonical project?  It's a straightforward CLA, and easy to sign online:\n- http://www.ubuntu.com/legal/contributors\n\nThen, above you report a problem which I don't quite understand. The errors that are appended to the slice are those returned by the function, so it's fine to call unmarshal multiple times in theory. We have test cases covering this:\n- https://github.com/go-yaml/yaml/blob/1bf6a7c/decode_test.go#L785\n\nYour test cases apparently do not include anything about this.\n\nFinally, when submitting pull requests, can you please make sure they are about a specific problem or feature proposal, rather than several unrelated changes?  It's problematic for reviewing and it's going to be frustrating for you as well.\n\nI'm closing this ticket but please do resubmit the independent changes so we can get them in.\n\nExcept for the regexp validator. To save your time, this is not a task for the unmarshaling package. It should be done by custom logic after unmarshaling.\n. For 3.3, I'm happy to include a feature equivalent to http://gopkg.in/mgo.v2/bson#Unmarshal which allows you to inline a map or struct into the document (part of the logic is already in, actually), but picking what to do with the values that do not map any of the fields is a task for the application, not the parser.\n\nIf you are in control of the file format, it also feels like YAML is being misused. If there are a bunch of keys with a common prefix, these should be put under a common key instead of doing that sort of matching logic.\n\nFor everything else, again, unrelated changes should be pushed independently. It's a bad practice to discuss all of these unrelated points at the same time.\n. Finished the support for inline maps, if you're interested: 5d6f7e0\n. This is indeed inconsistent with the standard json package, and the main reason why it is inconsistent is because it was implemented before the json package supported that feature.\n\nThat said, I actually prefer the way it works in the yaml package, to be honest. This allows keeping the fact of whether the fields of the B type in your example should be exported or not orthogonal to whether you want them inlined in the yaml output.\n\nFor example, this works:\n\n```\nfoo Foo `yaml:\",inline\"`\n```\n\nIt correctly inlines the field in the yaml output, despite the fact that in Go this is not an anonymous field.\n\nIn either case, this is all theory and background. We're not changing this now because this would break existent code in a hard way to anticipate, which is really bad for a package to do. I hope we can agree on that one, whether you consider this behavior a feature or a wart.\n. Sorry about that. This was already handled by #52. I was just too slow to respond due to the holidays season, but I should have taken care of it earlier.\n. When you do:\n\n```\nf = &format\n```\n\nWhat is actually happening is that you are assigning a new value to the local f pointer, rather than changing the memory that f used to point to, which is what you really want.\n\nTry this instead:\n\n```\n*f = format\n```\n. Given that it actually decodes it correctly, it doesn't feel like breaking it would benefit anyone.\n\nAs an aside, the provided example is invalid YAML. It errors with:\n\n```\nyaml: map merge requires map or sequence of maps as the value\n```\n. It doesn't seem fair to attribute that problem to the fact Go _can_ handle these files. If the package was _generating_ broken files, then I'd agree this was a problem, but that's not the case.\n. You can use a field tag to tell exactly how the name should look like:\n\n```\nReportSeconds int64 `yaml:\"reportSeconds\"`\n```\n. By the way, there's full documentation for these options at:\n\nhttp://gopkg.in/yaml.v2#Marshal\n. It is correct, but I agree it's not ideal. Let's fix it so that it marshals as a literal.\n. Can you please make the key just \"e\" in the yaml, and use \"AltE\" as a field name in the struct? This will be more clear.\n. Thanks, and sorry for not returning much earlier to this. I've added a renamed field to address #122, without introducing new data (this is in https://github.com/go-yaml/yaml/commit/2bf60357b89cbc6044dde700cf63bab94a615bf7)\n. Thanks!\n. No, there are no such options at this time, and we cannot have a global flag to switch as that would render other importers incompatible. We may think about changes at some point, but right now the change is still not in sight.\n. Yeah, sorry about that. As noticed elsewhere, this last year of mine was specially busy with work elsewhere. But we've just made the critical release a couple of weeks ago and I'm slowly picking up on the work I left behind. go-yaml is next in line.. Thanks.\n. Please see the discussion here: https://github.com/go-yaml/yaml/issues/63\n. Sorry, I appreciate the intent, but when it's just about a very subtle difference about variable naming, let's please not bikeshed over it.\n. Right, that's exactly the spirit. Renaming variables for questionable reasons is not worth your time or mine.\n. Tests are still working fine for me in tip at d0fefed. We'll need some local investigation to tell why your tests are failing. Please feel free to reopen if you can attribute the failures to the repository code somehow.\n. Can you please provide a self-contained snippet demonstrating the problem? It seems to work fine here, and I just added a couple of tests in 50f7813 which confirm it. The format may not be the proper one since yaml has a well-defined format for timestamps, but this at least confirms that the current behavior which happens naturally due to the support of text marshaling interfaces, is basically sane.\n\nI'm closing this based on the above tests, but please feel free to reopen with more details and a reproducer. \n. Sorry, indeed I'll have to fix the test so it runs on a consistent timezone.\n\nRegarding the string format, can you please confirm what version and revision of go-yaml you have locally? This format is time.RFC3339Nano, which is the only possible format coming out of MarshalText, and unrelated to whether you're using time.Now() or not. Hack the test to use that function and you can confirm that the format is still the same.\n. Can you provide some self-contained sample code that breaks?\n. No problem. Glad you figured it out.\n. This has been sorted out.\n. Issue has been fixed upstream, apparently. Please reopen if you see issues.\n. Yes, this is the appropriate place to submit patches, and my apologies for the lack of feedback. It wasn't immediately obvious what to do about this, and then it just got out of my critical path.\n\nThis doesn't sound like functionality that should be inside the yaml package. If you want to do some specific marshaling to fix some situation you have, use a custom marshaler for that specific case via the [yaml.Unmarshaler](http://gopkg.in/yaml.v2#Unmarshaler) interface. If you want arbitrary manipulation of keys, then this can be done at a map level. In other words, unmarshal the document into a map and then do whatever is necessary to it.\n. Having loose keys as suggested seems indeed like an edge case, and it seems sensible to not add functionality until we feel like there are more common cases that would benefit from the overhead.\n\nFor the time being, I'd suggest doing a pre-process step: unmarshal into a map, manipulate as necessary, remarshal, and unmarshal into the final location. This is surely a suboptimal workaround, but it feels worth paying the price where the cumbersome strategy is being observed before we have a better reason to have everyone paying the price.\n. I see, there's a problem indeed. To be clear, though, the issue here is that the implementation seems to be trusting on invalid YAML files. It wouldn't be the first time, but accounting it as \"the most likely type\" and saying that the YAML doesn't require quotes to interpret \"off\" as a string isn't correct. There's only one type the YAML should be read as, and the package is doing that job correctly.\n\nLoading it in Python, for example:\n\n```\n>>> yaml.load(\"nick: off\")\n{'nick': False}\n```\n\nSo if users are providing that file expecting it to be a string, that's a broken YAML file which will be handled incorrectly by other implementations.\n\nDespite that, one thing we can do to fix this and which I'd be happier pursuing, is to introduce the notion of raw values, and make sure they marshal out unchanged. This is being discussed in #13.\n. > I never said that. I said \"YAML doesn't require quotes around strings\" which is absolutely true.\n\nYou said that _\"and because YAML doesn't require quotes around strings\"_ while describing your case which was with the \"off\" string. That can't be \"absolutely true\" when it is false for the very case you're talking about.\n\n> But there is a difference in behavior between unmarshalling into a typed container vs an untyped container. This is the underlying problem.\n\nThe real underlying problem is that invalid YAML is being used. This will be an issue with any correct YAML parser you use.\n\n> That being said, RawMessage is the correct solution. I'm fine tossing this in favor of #13.\n\nSounds good. Thanks for the conversation.\n. This is handled automatically. For example, this:\n\n```\n data, err := yaml.Marshal(&Test{TestString: \"\\x80\"})\n```\n\nwill output this:\n\n```\nteststring: !!binary gA==\n```\n. The current behavior matches the specification, unfortunately. Example from Python:\n\n```\n>>> yaml.load(\"on: 1\")\n{True: 1}\n```\n\nLuckily, with the yaml Go package you can _force_ the keys to be strings by providing a typed map.\n. This would break existing applications that rely on the current behavior. We can eventually switch off to do that by default, but not without a major version change.\n. The fact the import path may be opened in a browser in a useful way is lost in this change.\n. Hi, sorry for not getting back to you on this timely. I'll fix the issue.\n. Tested and fixed in 7ad95dd. Thanks for the report.\n. This is likely a network error:\n\n```\n% go get somethingrandom.com/foo\npackage somethingrandom.com/foo: unrecognized import path \"somethingrandom.com/foo\"\n```\n. Please see #63.\n. Thanks for all the feedback. This is definitely going in.\n. @Songmu If you haven't yet done so, can you please sign the contributors agreement so I can integrate this:\n\nhttp://www.ubuntu.com/legal/contributors\n\nIt's a non-draconian license agreement which should be a straightforward read, and can be easily signed online.\n. Thanks!\n. This is the specification for YAML 1.1, though:\n\nhttp://yaml.org/type/bool.html\n. There's indeed a difference in behavior, but we cannot simply break compatibility to make the behavior of the yaml package match the json package, as that would break the expectation of existing applications trusting on the implemented behavior.\n. Hi Zachary,\n\nIt's not clear what is happening there, but we have had these exact lines in decode_test.go for a very long time, and tests pass fine:\n\nhttps://github.com/go-yaml/yaml/blob/v2/decode_test.go#L142\n\nDo tests pass for you if you don't change anything?\n. Sorry, your example uses pointers as values rather than `interface{}`, so I went ahead and copied your lines into the test file. They still pass.\n\nIs your code up to date?\n. Sorry, I can reproduce the bug. I did that in a rush yesterday and tested on yaml.v1 instead of yaml.v2.\n\nI will fix that, thanks.\n. Regarding the number of tests, you didn't actually add a new test. You added an entry to a slice that is used by one of the tests.\n. This is likely a network error:\n\n```\n% go get somethingrandom.com/foo\npackage somethingrandom.com/foo: unrecognized import path \"somethingrandom.com/foo\"\n```\n. Try to run go get with the option -v to get more details of the operation.\n. This change breaks current code using MapItem and thus MapSlice, so we have it in as-is. It's also concerning that this data won't be used when marshaling the items back.\n\nCan you also please describe what is the use case for this?\n. Sure, I'm certainly not against the idea of exposing the feature somehow, if we find a good way.\n. As was pointed out here, omitempty behaves in a way consistent with conventional practices elsewhere.\n. Yes, this is expected behavior because these values are generally interpreted as boolean, per the YAML specification. If you don't quote them, they mean something else.\n. Yes, the license does allow you to do that. Please refer to the LICENSE and LICENSE.libyaml file for full details on what's accepted or not.\n. Nice typo. :-)\n. The original idea was to match the most popular format for yaml files, which is by far lowercase fields. If I had to do it again, I'd probably have followed what is now the most common convention, but it's a bit late to change this now. Keeping people's code working is more important.\n. The assumption isn't valid in two different ways:\n1. The `\\@` string is not a valid escape sequence. If you try to decode this, it must error out.\n2. yaml only interprets escape sequences inside double quoted strings. Per [the spec](http://www.yaml.org/spec/1.2/spec.html#id2776092):\n\n> Note that escape sequences are only interpreted in double-quoted scalars. In all other scalar styles, the \u201c\\\u201d character has no special meaning and non-printable characters are not available.\n. If that was true the error message out of your example would not contain that character.\n. Thanks for the change. Indeed it'd be nice to have a better example of tag renaming in the documentation, but we co do that with a more trivial change. I've done that in 2bf6035. Please let me know if it solves your needs.\n. The current behaviorismo is part of the specification. Please ser section 5.4 on normalization of line-break characters.\n. And that's what I get for typing on a phone. Sorry for the typos.\n. The spec has several defects, most notably bloat, but I would say this is one thing it got right. It is definitely a data exchange format, but luckily not one that preserves invisible EOL characters as something meaningful. If you want bit by bit preservation, encode the data, quote it, or simply pick a binary data exchange format.\n. Yeah, sorry, this feels like an unexpected meaning for line/column which people will be confused about. I'm closing this PR for the time being. Feel free to discuss further.\n. Last I looked Travis required custom access to my projects for being able to build them, which doesn't sound entirely reasonable. Has that changed?\n. There's no way it can possibly guess what concrete type you'd want under that interface. You can achieve what you want by implementing aa type with a yaml.Unmarshaler interface and unmarshaling the value into it, though.\n. Hi there,\n\nI'm missing some high-level context for what this addressing and how it is addressing it.\n\nCan you point me to the section of the specification that describes what you are doing, and how you are implementing support for it, including some more clear examples?\n\nThanks!\n. We can certainly support comment manipulation, but we'll need to design this a little bit better first.\n\nNamingly, we need to ignore the internal implementation completely and look from the perspective of someone using the feature both to consume comments and to produce them back into the expected locations. We also need to outline which cases we'll try to support when writing, and which cases are going to cause clear havoc in the output.\n\nI'm closing this PR but I'd be happy to see an issue opened to discuss these details.\n. The functionality is sane, but the names should be Decoder and Encoder, and we need proper tests.\n\nIf we don't get @oec to fix that soonish, I'll add the equivalent functionality myself over the next few days.\n. One of the most important points of having that interface is fixing streaming of multiple documents, as @jeffjen mentions. The other would be having custom flags that can act per Decoder/Encoder instance, so we can have behavior changes (e.g. non-lowercase field names) without breaking existing code.\n. @oec About breaking semantics of encoding/xml, I'm not quite sure about what you're describing, but have a look at the [example of encoding/json](https://golang.org/pkg/encoding/json/#Decoder). We want the same for yaml, except we'd respect the spec in terms of how to split docs.\n. Let's just close this PR and I'll try to get to it over the next few days then.\n\nThanks for your help here @oec.\n. Without comments surviving a roundtrip it sounds like a very bad idea to support them at all.\n\nIn terms of the specification recommending against attributing meaning to them, that doesn't mean we shouldn't attempt to preserve comments. That's equivalent to how Go itself handles comments in its specification and its standard parser.\n\nRegarding handling end of line comments, this sounds like the easiest to handle, semantically, as it's very clearly assigned to the value on that line.\n. Either we ignore comments, or we don't. If comments are not relevant to be marshaled and unmarshaled, then we ignore them completely which is what we do today. If we decide to not ignore them, then we can't pretend they are irrelevant.\n\nNo, I haven't had a chance to stop and design it considering all the problems that may surface.\n. Interested in offering a patch for this?\n. Changing it on my side would also involve talking to lawyers, so without any proper reasoning other than \"they don't like LGPL\" I'm somewhat empty-handed to get into that conversation on my side.\n. After much internal debate, we've finally managed to get agreement to move the license towards the Apache License v2. Reopening #160 until the license lands.\n. Erroring in that case would be unacceptable, but we can do something similar to what I've used elsewhere: support the inline tag in maps too. This is useful in a number of cases as it allows mixing previously known key with custom ones, and if you want to error when the map is not empty that's easy too.\n. @vincentbernat The real solution for that is inline maps, as suggested above. Didn't get to it yet, sorry. \n. Unfortunately not.. Unlike json, yaml can take keys of arbitrary types.\n. See referenced issue.\n. @rjeczalik No problem, but can it stop? :)\r\n\r\nAbout the issue, I think the best approach is introducing an explicit Decoder type, as already planned/proposed/long overdue, and on that type have some sort of UseStringKeys or similar.\r\n\r\nWill look into this.. No worries, it's indeed an obscure and unexpected consequence which I would easily get into as well.. Looks like a certificate issue. Try to access that same URL from an up-to-date browser. Seems to work fine from here. Probably indicates the system trying to go get doesn't have access to a proper certificate bundle.\n. We can't change the default behavior like this, but we can have a mode on a `Decoder` that enables it.\n. Sounds good, thanks for that.\n\nMy most pressing deadlines elsewhere are due this month, so you can expect some good amount of love in go-yaml soon.\n. Please see #120 for motivation details. Will comment on the PR too.\n. This is definitely a breaking change, as it's modifying the prototype of a public function. That said, it's not too far from what I want to do.\n\nWe need to implement a Encoder/Decoder types that have a method (not a flag list) to enable the standard behavior. The global marshaling/unmarshaling functions simply call an internal global that contains the default encoder/decoder, and their prototype should not change to prevent breaking people's code out there.\n\nWe do want to keep the type metadata cache global as well, as the list of types is very limited, and it makes no sense to be paying the cost to recompute that metadata all the time.\n\nAlso, please note we need a contributor agreement signed to accept patches: http://www.ubuntu.com/legal/contributors - it's a straightforward non-draconian agreement, easy to sign online, but do read it through to make sure you're comfortable with the clauses there.\n\nI'm closing this for the time being, but please do reopen it if you sort out the above details.\n. Ah, one side note if you decide to pursue it: please have a look at the interface of Decoder/Encoder in encoding/json. We want to mimic it, for the same reason you want to mimic its field-naming behavior.\n. Thanks for signing, Sam, and looking forward to your contributions.\n\n> Alternatively, there could be a global YAMLCodec\n\nYes, that's what I had in mind too.\n\n> WRT versioning, I think the cleanest thing to do would probably be to start work on a v3\n\nFirst thing is to get these features into v2 itself. There's no benefit in breaking out right now and making these improvements incompatible from the get go.\n\n> Unfortunately I don't have time to contribute that right now, but I will eventually if no one gets there first :)\n\nUnderstood. I'll close this PR for the time being then.\n\n> Out of interest @niemeyer what is your workflow when using imported from gopkg.in\n\nNothing fancy. I just have my branch inside the proper gopkg.in location in $GOPATH.\n\nThanks for your collaboration, Sam.\n. Thanks!\n. Pong. Sorry, need to do a full pass on go-yaml. Will try to get to it tomorrow.\n. Hi Sam. The rationale sounds sensible, and the current list of changes sounds good too. We should talk a bit more about these other issues before spending time on them, to make sure no time is wasted on it.\n\nBefore we release v3, we also need to consider a migration tool. It doesn't have to actually migrate the code, but should at least point out where to look for potential incompatibilities.\n. Yes, quite possibly not trivial. But the opposite of that is letting every other developer figure out by themselves what is going to break. Instead, what people will most likely do is stick to v2, which is not great either.\n\nBy the way, the actual changes listed above are all trivial by themselves. Under 30 minutes, I'd say.\n. > Hmm, I think that basically anything using v2's Marshal or Unmarshal would be considered broken in the proposed v3 until it is tested. (...)\n\nThis is not just a technical issue. There's a very natural tendency for code to not be updated, ever. If there's known-for-sure breakage, the inertia increases significantly. If there's unknown known-for-sure breakage, the inertia is so high we may as well not do it.\n\nWe can't have a global flag, because in a same application different packages may depend on different behavior. That said, we can have a local flag, for a yaml.Decoder and yaml.Encoder, akin to json.Encoder/Decoder. This is actually where I would start. Introduce into v2 a compatibility flag. This benefits everyone, with no breakage. Eventually we can introduce a v3 which has this mode by default, and kill the old logic. \n. Merged #171.. This is already merged. Are you seeing any issues on the latest?\n. That's quite ironic. That project is a rip-off from go-yaml.. I can see parts that which were clearly \"inspired\" by go-yaml. If you are worried about licenses, you are switching from someone that is trying to support you to someone that is copying logic unlicensed.\n\nGo for it. :-)\n. After much internal debate, we've finally managed to get agreement to move the license towards the Apache License v2. Reopening until the license lands.\n. The main problem is being legally allowed to do so, which isn't something I can help you with in detail. As one point to observe, if you got contributions to your project without a license agreement that allows you to do that, you can't change the license without asking explicit permission to all of your contributors, because they implicitly licensed the work under that same license to you.\n. Just committed the text on e4d366f, apologies for the delay.\n. Thanks Jeff.\n\nCan you please have a look at the contributor agreement here and sign if you're comfortable:\n- http://www.ubuntu.com/legal/contributors\n\nIt's a non-draconian agreement which is hopefully okay, and may be signed online.\n\nThen, we'll need a few tests and docs, and perhaps some simple tweaks. But the direction is good.\n. @jeffjen Can you please have a look at:\n\nhttps://www.ubuntu.com/legal/contributors\n. The functionality and the API look reasonable. Would be good to have some conventional comments on the public pieces.\n. We've discussed this multiple times in other PRs and issues. We can't have a global option like this, because it would break other packages that are being imported into the same binary and have different expectations. The proper path here is to have an Encoder and Decoder which may be tuned. We already have in progress in other PRs, and I'll move it forward once I get the unrelated work I'm doing out of the door.\n. Sorry, yes, you are right. I misread the API as setting global options instead of unmarshaling in place.\n\nThe idea which seems best is still the one we discussed in that thread, though, which differs from what was presented as the follow up:\n\n> We need to implement a Encoder/Decoder types that have a method (not a flag list) to enable the standard behavior. The global marshaling/unmarshaling functions simply call an internal global that contains the default encoder/decoder, and their prototype should not change to prevent breaking people's code out there.\n. > Do you mean a global function called e.g. yaml.NoLowercase() that would affect all encoding/decoding?\n\nNo, per the quoted sentence: _\"We need to implement a Encoder/Decoder types that have a method (not a flag list) to enable the standard behavior.\"_\n\nPlease have a look at encoding/json, for example. Perhaps `UseFieldNames` for the method name.\n. Thanks, and sorry for the long delay.. Sorted out in #249.. You can use a pointer or an interface{} so you can tell it was unset (nil).\n. @purpleidea There isn't much to it, really.. if you have a field that is a pointer type (say, `*string`) the field isn't set if the field is missing from the input or set to YAML's `null`. \n. @mogthesprog Why do we need the additional go get call in travis?. @mogthesprog Yes.. #173 was exactly that, but unfortunately it got removed after this PR.\r\n\r\nHappy to merge if you can redo it.. Sorted out in #249.. Done!\n. Thanks for this.\n. This a backwards incompatible change, and not clearly a bug in the sense that a time.Duration is in fact a number and not a string. So the main question is whether we want to do it at all. I can see it going both ways at the moment.. The output is a valid yaml file. Suggestions to improve that are welcome, but please keep in mind that we won't be able to please everyone's preferred style with the default rules. Some tuning may be offered via the upcoming Encoder and Decoder types, but we also don't want to go overboard with flags.\n\nWith all that said, adding some extra spacing before nested lists sounds like a better default indeed. I'll look into that.\n. No, this is valid yaml with the content you intended it to have. Give it a try by unmarshaling it onto an `interface{}` and print it out.\n. Thanks for the note.\n. This matches the upstream libyaml code. Please submit it there first so comparing the two is easier.\n. Thanks!. Thanks!. It's not clear to me how this is fixing the referenced issue in a proper way. What's the actual specification of the float format in yaml, and how is this handling it? Where are the tests for it showing details of the problem being fixed?. Note that this changed from yaml 1.1 to 1.2. It might be okay, but we may also end up breaking existing code. In Python:\r\n```\r\n>>> import yaml\r\n>>> yaml.load(\"01.1\")\r\n1.1\r\n```\r\nThanks for the tests.. Curiously, Python float resolution seems broken in other ways:\r\n```\r\n>>> yaml.load(\"-2E+05\")\r\n'-2E+05'\r\n```. Indeed, merged #171. Thanks for your help on this.. It is very much alive, yes. We depend on it for several of our main projects.\r\n\r\nThe fact it's been staggering for a while is due to my own agenda being overwhelmed, but the main deadlines have passed and it will see attention over the following days. . Yes, I realize the queue is far from ideal right now. I have it on my \"urgent\" queue, yet keep pushing it back in favor of more urgent things. I'll try to work through some of the most critical items this week still.\r\n\r\nAbout more maintainers, that's always welcome obviously. The problem is precisely the question you ask: finding good long term maintainers.. Not sure about what that means. This works fine here:\r\n```\r\ntype T struct {\r\n        Foo string\r\n}\r\n\r\nfunc main() {\r\n        var v T\r\n        err := yaml.Unmarshal([]byte(\"foo: 2.94\"), &v)\r\n        fmt.Println(err, v.Foo)\r\n}       \r\n```\r\n. Thanks!. Thanks!. Several weeks back I had a conversation with @rogpeppe and we agreed he'd allocate some of his time to keeping this library up-to-date and well taken care of. This seems to be taking slightly more time than expected to happen, though.\r\n\r\n@rogpeppe Do you have any news there?. The parser is really an implementation detail which shouldn't be exposed at this point. If you need to reuse the code, I suggest just copying it over. . LGTM, but I don't think we need the NOTICE file if we're adding the license explicitly.. Thanks!. This is a divergence that doesn't sound worth fixing to be honest. People can break their documents by simply copy & pasting a section of a document which is a map of unordered fields. So this behavior breaks the idea of the lack of order there, and creates more problems than it solves.\r\n\r\nWe also never produce such documents by marshaling from the package, which means the broken document was produced some other way, most likely by hand.\r\n\r\nIt sounds fine to introduce a more strict checker, though, when one wants to make sure that documents comply to that rule. But again I'd prefer and recommend not failing to parse these documents.. @prateek From the [spec](http://www.yaml.org/spec/1.2/spec.html#id2765608):\r\n\r\n> 3.2.2.1. Keys Order\r\n>\r\n> In the representation model, mapping keys do not have an order. To serialize a mapping, it is necessary to impose an ordering on its keys. This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, (...)\r\n\r\nThe vast majority of YAML documents have such a mapping at the top level, so it's very reasonable that people think about it as something that lacks ordering. The fact you can dig further data to prove that this is in fact ordered in certain cases is beyond the point here.. > The fact you can dig further data to prove that this is in fact ordered in certain cases is beyond the point here.. That doesn't yet work indeed, but it should. Here is the documentation reference:\n\nhttp://yaml.org/type/merge.html\n. LGTM, thank you.\n. FWIW, the point of the loop was not because Replace would remove only a single entry. Note how it actually breaks out of the loop when it finds the first one. The point was to not call Replace in the first place, if it would do nothing. The change is probably making it slower. But Replace still avoids the allocation these days, if there's nothing to do, so hopefully not much slower.\n. This should also consider streams with multiple documents.\n. How's that different from #4?\n. Okay, it sounds like this is effectively the same as #4.\n. That was previously reported as #1, and was just fixed.\n. Thanks for the report.\n. I'm changing the subject to reflect the pointer bug. We have #10 covering the time.Time support.\n. Thanks!\n. I'm happy to merge this. Can you please sign the contribution agreement:\n\n```\nhttp://www.canonical.com/contributor-license-agreement\n```\n\nIt's a straightforward/non-draconian one.\n. Thanks!  Can you include the decoding side, now that the non-pointer bug is fixed?\n. Ah, we have to look at something else too. The time.Time encoding and decoding format must match the standard yaml timestamp type: http://yaml.org/type/timestamp.html\n. We can just try them all in sequence, starting by the format we marshal out so that the default encode/decode sequence hits on the first try.\n. We need time handling, but we need both sides of it. I'm closing this for lack of activity. Please feel free to push the complete change once you're ready.\n. I have originally advocated having a generic \"key\" tag that would be used by multiple packages, but the core Go team favored an approach where each package would have its own namespace. The yaml package is following that recommended convention.\n\nIn terms of the type of maps, yaml accepts non-string keys, which json does not, so both packages are correct with the respective types.\n. The problem with yaml.RawMessage is that unlike JSON, YAML is context-dependent. One cannot properly encode a piece of raw YAML without knowing what the surrounding data is, due to indentation.\n\nCan the +1 voters please detail a bit how this is intended to be used that isn't solved by the current system?  Maybe we can design something else that solves the problem.\n. Yeah, it should be easy to use a MapSlice, and one can even marshal it back into yaml and then unmarshal it again to get the exact semantics of a RawMessage. That said, I'll keep this issue open so we can consider the idea of a RawMessage-like feature further.\n. Thanks for all the feedback, by the way!\n. @dvirsky That goes beyond the goals of the yaml package, but there are other packages available for such direct map-to-struct conversion (e.g. https://github.com/mitchellh/mapstructure).\n. Yes, that's similar to what [bson.Raw](http://gopkg.in/mgo.v2/bson#Raw) does, but it's not quite the same, and it's not the same as `json.RawMessage` either. The problem is that unlike bson and json, you cannot marshal it back as-is, because yaml marshaling is context sensitive.\n\nIt's likely the direction we'll take, though. We'll just need some further work on the marshaling side.\n. And not very _\"Raw\",_ if you see what I mean. We'll likely end up with a similar abstraction that can lazily unmarshal and re-marshal appropriately, but not provide direct access to the text.\n. @thockin The value you get into SetYAML corresponds exactly to the value that is in the YAML document in the position of the respective field. We have another issue open to improve the documentation there, but either way the best way to learn how to use it is to play a bit with the method and some data.\n. Ah, and in terms of validation of content, that's outside the scope for the yaml package. There are packages for dealing just with that problem alone, though. For example: https://github.com/juju/schema\n. That's not supported, but you can easily have two fields and copy the data from one to the other in application logic.\n. You do have two fields in the document, so there's no reason to avoid having two fields in the struct you are using to manipulate the document. This is application logic.\n. +1\n\nPlease consider submitting them in an examples_test.go file which is properly handled by godoc:\n\nhttps://blog.golang.org/examples\n. You are right, the documentation is definitely lacking. I'm sorry.\n\nThe tag is a YAML tag: http://yaml.org/spec/1.1/#id858600\n\nSince you don't know what it is for, it means you probably don't care, so leaving it empty will likely produce the result you expect.\n. Documentation and the interfaces themselves were improved in yaml.v2, as described in the announcement:\n\nhttp://blog.labix.org/2014/09/22/announcing-yaml-v2-for-go\n. Will do on a future change.\n\nThanks.\n. Yeah, arrays are not yet supported. Unmarshal into a slice ([]int) and it should be fine.\n. That's why it's still open.\n. Most applications actually don't care about the ordering of maps in either JSON or YAML, and all parsers I know will also unmarshal into a first class hash map of the host language, which is pretty much always unordered, with the notable exception of JavaScript. For example, this is Python:\n\n```\n>>> import yaml\n>>> yaml.load(\"{b: 2, a: 1}\")\n{'a': 1, 'b': 2}\n```\n\nThe YAML [specification](http://yaml.org/spec/1.1/#id932806) is also pretty clear about what maps are:\n\n> A mapping node is an unordered collection of key: value pairs.\n\nWith all that said, we can support ordered maps. I have documented in #30 the plan for that. Let's please follow up the conversation on that issue.\n. This should be easy to implement, but is not yet supported right now.\n. Closing this as we're tracking that need in #4 already.\n. You mean you have something like this:\n\n```\nField Type `yaml:\",omitempty,omitempty\"`\n```\n\n?\n\nThat looks like a bogus declaration. Why would that be desirable?\n. Sorry, but I still don't understand what you mean. This works fine:\n\n```\ntype Foo struct {\n    Bar string `yaml:\"a,omitempty\"`\n    Foo string `yaml:\"b,omitempty\"`\n}\n\nfunc main() {\n    var foo Foo\n    err := yaml.Unmarshal([]byte(\"{a: bar, b: foo}\"), &foo)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(foo.Bar)\n    fmt.Println(foo.Foo)\n}\n```\n. A map for which you can never anticipate the key is not a very useful building block.\n\nThe proper way to support this would be with something like:\n\n```\ntype MapSlice []MapItem\n\ntype MapItem struct {\n        Key, Value interface{}\n}\n```\n\nand then implement first-class marshalling and unmarshalling of maps onto it.\n. Opened issue #30 to track the work. Closing the pull request as that's not the right direction.\n. The default development branch is v1, which reflects the current version of the API. We also prevent people incorrectly importing the package from github.com/go-yaml/yaml by having a clear error message via the error.go file.\n. I'm not missing this right now, but please feel free to contribute the setup.\n. The go-yaml package does sort by default when marshaling as well, and has always done so. I have changed the summary to clarify that the feature I was considering is a different one.\n\nThis also makes me wonder about what was being originally requested. Pull request #27 implies that the ordering is random, which is not true. So maybe there's nothing to be done here.\n\nRegarding JSON-the-spec, no it [does not](http://json.org) assert key ordering either:\n\n> An object is an unordered set of name/value pairs.\n. @termie Most people that talk about JSON are referring to [the specification](http://json.org), not general JavaScript objects.\n. @termie Sorry, I was just clarifying the question, which was about JSON rather than JavaScript, but we disagree on a few different fronts. For example, I don't think people expect ordering out of JSON in general, and the absolute majority of applications couldn't care less. Python also reflects that and does not respect the ordering by default either:\n\n```\n>>> import json\n>>> json.dumps(json.loads('{\"b\": 2, \"a\": 1}'))\n'{\"a\": 1, \"b\": 2}'\n```\n\nWith all that said, I would still like to make the Go yaml package work for you, but I don't think I really understand the problem I'm trying to solve. In what way is the current logic breaking your application?\n. Okay, thanks for the example. It makes the issue clear. The application internally depends on the order of the keys based on attributed semantics.\n\nSupport for this is coming via `yaml.MapSlice` as described, then.\n. @ingydotnet The JSON spec says it's unordered, and thankfully the vast majority of applications follow suit. I find it quite poor style to depend on orderings for maps that are meant to be used as a key/value mechanism, and have practical experience with multiple bugs and general confusion generated by using them in that fashion in the only application I have seen depending on them for certain things (MongoDB).\n\nThat said, this is the go-yaml package, and I'll support the optional use of ordered values to allow people to preserve their logic working and interact with external content.\n. @ingydotnet Out of curiosity, what was the use case you considered YAML best for?\n. @ingydotnet Several reasons for porting it:\n- It plays much better with Go concurrency (no C stack, no thread takeover, etc)\n- It becomes memory-safe (no corruption, no buffer overflows, etc) \n- It makes better use of the memory management capabilities of Go\n- It runs faster since there's a cost associated with bridging with C\n- It becomes trivial to cross-compile into other OSes\n- It compiles much faster, although that's a minor convenience in this case\n- etc\n. @ingydotnet Oh, welcome to the team then. :-) And thanks for the background.\n\nI suspect lack of more suitable options is one of the reasons why YAML became so popular as a configuration format. There's still no other good human-oriented format that can represent nesting of the common set of types and other related needs (text line blocks, etc) in a pleasant way. On the other hand, I wish it was slightly more strict in a few places.\n\nRegarding being a superset of JSON, I don't find it so much of a coincidence to be honest. The JSON spec itself is pretty strict, the ECMA standard behind it is pre-2000 and was already popular at the time, and the general syntax style behind it is ancient. On the other side, YAML is very accepting (with 22 ways to say true or false, it's hard to get wrong ;-).\n\nThat's probably one of the reasons that kept its use purely as a cross-language conduit low, actually. I would also look for something much simpler and more strict for that, while I can pay a higher price to keep another human happy when reading or writing content.\n. @ingydotnet Ah, certainly, will join you there.\n. This feature was implemented. Details in the announcement for yaml.v2:\n\nhttp://blog.labix.org/2014/09/22/announcing-yaml-v2-for-go\n. Binary data is currently unsupported, but looping forever is the worst possible outcome in that scenario. Sorry about that.\n\nI'll get that fixed by implementing proper support for binary data.\n. This has to be marshalled as binary data, which I'm working on right now.\n. It's not a \"behind-the-scenes change\".. it's simply marshalling exactly the data provided into standard YAML form.\n. Also merged in v2 on b6b591a3.\n. They're not flawed, strictly speaking. They're just following version 1.1 of the specification, which amusingly [defines](http://yaml.org/type/float.html) _base 60 floats:_\n\n> Using \u201c:\u201d allows expressing the integer part in base 60, which is convenient for time and angle values (the fractional part is always in base 10).\n\nVery convenient. Of course everybody saying `1:1` want that decoded as `61.0`, right? Nuts, and that's what you get in those parsers you've been testing.\n\nThankfully, someone [got rid](http://yaml.org/spec/1.2/spec.html#id2804092) of them in 1.2:\n\n> Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression `-? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?`.\n\nand more [generally](http://yaml.org/spec/1.2/spec.html):\n\n> Normally, YAML insists the \u201c:\u201d mapping value indicator be separated from the value by white space. A benefit of this restriction is that the \u201c:\u201d character can be used inside plain scalars, as long as it is not followed by white space. This allows for unquoted URLs and timestamps. It is also a potential source for confusion as \u201ca:1\u201d is a plain scalar and not a key: value pair.\n. Sounds fair.\n. The logic in decoder.setter is tricky indeed, but in this case you've probably struggled more because the issue isn't actually there.\n\nThanks for filing the bug.\n. It supports struct tags, as per the documentation:\n\nhttp://gopkg.in/yaml.v2#Marshal\n. You need the `,inline` flag for that, as per the documentation:\n\nhttp://gopkg.in/yaml.v2#Marshal\n\nYou can use that flag both on normal and on anonymous fields.\n. No problem. ;-)\n\nAnd thanks for submitting the issues. They might well be valid problems.\n. Initial plan is to support v2 only.. there's really no big reason to stick on v1, so I'd rather give people more reasons to move on instead.\n. I've moved the implementation of the binary marshaling half onto issue #40. \n. Yes, that's the nested map type hinting doing ~~its job~~ something wrong. Why isn't X a map?\n. This means supporting types that implement that interface. The support for types that implement a different interface won't make that work.\n. Sorry, I wouldn't have done it if I knew you were already working on it. Just felt simple enough that discussing would take more time than doing it.\n. I believe this behavior was already fixed as a side effect of  0885984. I've added a test to ensure this is the case in bef53ef. If you find the bug again with the current code, please let me know.\n. Yes, the commits referenced above are up right now.\n. This should be fixed, but it's not clear this is the right fix. Shouldn't it be quoted rather than turned into a literal? Also, can we please have a test for this?\n. Closing for lack testing and lack of feedback. I cannot reproduce this issue, and have added a test at 71e7ede to ensure it continues to be the case. Please feel free to reopen or open an issue if you have a test case for it.\n. That error implies an SSL negotiation error with the website. You can try the git command by hand and debug it to see what is wrong. Ensure you're not behind a capturing proxy of some kind that is diverting the request to a different place.\n\nYou can also check that the website's certificate is alright by simply navigating to it with a browser.\n\nJust tried it out, and it works fine:\n\n```\n$ GOPATH=$PWD/foo go get gopkg.in/yaml.v2\n$\n```\n\nPlease feel free to reopen if you get any evidence that this is a problem with the service.\n. Can you please provide an example with code, expected output, actual output?\n. This is intended behavior for the moment. There's already plenty of flexibility by omitting or not (or renaming, etc) individual fields of the inlined document.\n\nBasically, inlining means actual inlining. Fields of the inlined document are seen as being in the outer document.\n\nI'll keep the issue open to have a second consideration of this on another day, but in principle I don't see the demand for the additional logic.\n. Yeah, the current behavior looks correct. Inline will pick the omitempty semantics from the inlined fields themselves, which is the correct thing to do in this case.\n. Needs to be fixed. Thanks for the report.\n. Thanks for the contribution. I'll provide comments inline.\n\nBesides any comments, though, we need to apply such changes to v2 rather than v1. There's no good reason not to move on from v1.\n. This looks good and I'm happy to merge it. Just see what you think of the suggestion above please.\n. Jordan, I got a bit ahead of myself here. I should have asked you to sign the contributor agreement first:\n\nhttp://www.ubuntu.com/legal/contributors\n\nIt's a straightforward agreement, easy to sign online. Can you please have a look and see if it makes sense?  We need that for contributions.\n. I'll need to back out the change if I don't get the signature this week. Sorry for the trouble, but this is required and I screwed up by not requesting beforehand.\n. Actually, to avoid creating a larger problem for people that update now, I have backed out the change right now. Please just ping me once you get the signature in place, and I'll happily reapply.\n. Thanks, and sorry for the trouble.\n. Any news there?\n. Please leave it with me. I'll just reapply the change.\n\nThanks for handling the bureaucracy.\n. Thanks for submitting this. Can we have a test covering the need for the change, please?\n\nAlso, would you mind to sign the contribution agreement if you haven't already done so?\n\n```\nhttps://www.ubuntu.com/legal/contributors\n```\n\nIt's straightforward/non-draconian, and easy to sign online.\n\nThanks!\n. Thanks, and sorry for the long delay on this.\n. Sorry, this got over my holidays and got delayed. It's now in.\n. The code isn't right, but the idea is fine.\n. The problem in the sample code is that only fields that are exported should be considered. I have the same logic working in the mgo/bson parser and will copy it over.\n. No big reason other than implementation convenience. It means all fields are already in memory rather than having to consider the nil case and initialize it appropriately.\n\nIt's a wart we should eventually fix.\n. Thanks, but this had been fixed on #52 already. I was just slow there, sorry.\n. I don't understand why \"\" would result in calling an unmarshaler while an implicit \"\" would not. This is very inconsistent. I'm happy to fix the bug, but not like that.\n\nGiven the discussion in that ticket referenced above, I'm assuming are not interested in contributing to the project anymore, and will close this and fix the bug.\n. Yes, you're right. I forgot \"a:\" actually implies a is null in YAML.\n\nI'm happy to accept this in. For that, can you please:\n\na) Sign the contributor agreement at:\n- http://www.ubuntu.com/legal/contributors\n\nb) Preserve the original formatting of the line (no unnecessary parenthesis, as usual in Go) while adding the intended change?\n\nThanks for these.\n. Ping?\n. Thanks for the submission.\n\nI don't think we're ready to accept the inline change at this time. This would break compatibility with existent code, and introduce a redundant way to define inlining, which is currently done via the \"inline\" tag flag (for historical context, that implementation was done before Go's json pacakge supported inlining).\n\nThe struct pointer might be acceptable, but not as part of this change, and I'm also slightly unsure about whether it is properly implemented. When we have a pointer, we need to worry about initialization of nil pointers appropriately. I haven't checked in detail the correctness of the suggestion as we cannot accept this for the above reason.  \n. Thanks\n. Thanks for getting on board and contributing code to the project. This is very welcome.\n\nA couple of points on the submission: first, can you please sign the contributor agreement so that I can integrate any changes you do to this project or any other Canonical project?  It's a straightforward CLA, and easy to sign online:\n- http://www.ubuntu.com/legal/contributors\n\nThen, above you report a problem which I don't quite understand. The errors that are appended to the slice are those returned by the function, so it's fine to call unmarshal multiple times in theory. We have test cases covering this:\n- https://github.com/go-yaml/yaml/blob/1bf6a7c/decode_test.go#L785\n\nYour test cases apparently do not include anything about this.\n\nFinally, when submitting pull requests, can you please make sure they are about a specific problem or feature proposal, rather than several unrelated changes?  It's problematic for reviewing and it's going to be frustrating for you as well.\n\nI'm closing this ticket but please do resubmit the independent changes so we can get them in.\n\nExcept for the regexp validator. To save your time, this is not a task for the unmarshaling package. It should be done by custom logic after unmarshaling.\n. For 3.3, I'm happy to include a feature equivalent to http://gopkg.in/mgo.v2/bson#Unmarshal which allows you to inline a map or struct into the document (part of the logic is already in, actually), but picking what to do with the values that do not map any of the fields is a task for the application, not the parser.\n\nIf you are in control of the file format, it also feels like YAML is being misused. If there are a bunch of keys with a common prefix, these should be put under a common key instead of doing that sort of matching logic.\n\nFor everything else, again, unrelated changes should be pushed independently. It's a bad practice to discuss all of these unrelated points at the same time.\n. Finished the support for inline maps, if you're interested: 5d6f7e0\n. This is indeed inconsistent with the standard json package, and the main reason why it is inconsistent is because it was implemented before the json package supported that feature.\n\nThat said, I actually prefer the way it works in the yaml package, to be honest. This allows keeping the fact of whether the fields of the B type in your example should be exported or not orthogonal to whether you want them inlined in the yaml output.\n\nFor example, this works:\n\n```\nfoo Foo `yaml:\",inline\"`\n```\n\nIt correctly inlines the field in the yaml output, despite the fact that in Go this is not an anonymous field.\n\nIn either case, this is all theory and background. We're not changing this now because this would break existent code in a hard way to anticipate, which is really bad for a package to do. I hope we can agree on that one, whether you consider this behavior a feature or a wart.\n. Sorry about that. This was already handled by #52. I was just too slow to respond due to the holidays season, but I should have taken care of it earlier.\n. When you do:\n\n```\nf = &format\n```\n\nWhat is actually happening is that you are assigning a new value to the local f pointer, rather than changing the memory that f used to point to, which is what you really want.\n\nTry this instead:\n\n```\n*f = format\n```\n. Given that it actually decodes it correctly, it doesn't feel like breaking it would benefit anyone.\n\nAs an aside, the provided example is invalid YAML. It errors with:\n\n```\nyaml: map merge requires map or sequence of maps as the value\n```\n. It doesn't seem fair to attribute that problem to the fact Go _can_ handle these files. If the package was _generating_ broken files, then I'd agree this was a problem, but that's not the case.\n. You can use a field tag to tell exactly how the name should look like:\n\n```\nReportSeconds int64 `yaml:\"reportSeconds\"`\n```\n. By the way, there's full documentation for these options at:\n\nhttp://gopkg.in/yaml.v2#Marshal\n. It is correct, but I agree it's not ideal. Let's fix it so that it marshals as a literal.\n. Can you please make the key just \"e\" in the yaml, and use \"AltE\" as a field name in the struct? This will be more clear.\n. Thanks, and sorry for not returning much earlier to this. I've added a renamed field to address #122, without introducing new data (this is in https://github.com/go-yaml/yaml/commit/2bf60357b89cbc6044dde700cf63bab94a615bf7)\n. Thanks!\n. No, there are no such options at this time, and we cannot have a global flag to switch as that would render other importers incompatible. We may think about changes at some point, but right now the change is still not in sight.\n. Yeah, sorry about that. As noticed elsewhere, this last year of mine was specially busy with work elsewhere. But we've just made the critical release a couple of weeks ago and I'm slowly picking up on the work I left behind. go-yaml is next in line.. Thanks.\n. Please see the discussion here: https://github.com/go-yaml/yaml/issues/63\n. Sorry, I appreciate the intent, but when it's just about a very subtle difference about variable naming, let's please not bikeshed over it.\n. Right, that's exactly the spirit. Renaming variables for questionable reasons is not worth your time or mine.\n. Tests are still working fine for me in tip at d0fefed. We'll need some local investigation to tell why your tests are failing. Please feel free to reopen if you can attribute the failures to the repository code somehow.\n. Can you please provide a self-contained snippet demonstrating the problem? It seems to work fine here, and I just added a couple of tests in 50f7813 which confirm it. The format may not be the proper one since yaml has a well-defined format for timestamps, but this at least confirms that the current behavior which happens naturally due to the support of text marshaling interfaces, is basically sane.\n\nI'm closing this based on the above tests, but please feel free to reopen with more details and a reproducer. \n. Sorry, indeed I'll have to fix the test so it runs on a consistent timezone.\n\nRegarding the string format, can you please confirm what version and revision of go-yaml you have locally? This format is time.RFC3339Nano, which is the only possible format coming out of MarshalText, and unrelated to whether you're using time.Now() or not. Hack the test to use that function and you can confirm that the format is still the same.\n. Can you provide some self-contained sample code that breaks?\n. No problem. Glad you figured it out.\n. This has been sorted out.\n. Issue has been fixed upstream, apparently. Please reopen if you see issues.\n. Yes, this is the appropriate place to submit patches, and my apologies for the lack of feedback. It wasn't immediately obvious what to do about this, and then it just got out of my critical path.\n\nThis doesn't sound like functionality that should be inside the yaml package. If you want to do some specific marshaling to fix some situation you have, use a custom marshaler for that specific case via the [yaml.Unmarshaler](http://gopkg.in/yaml.v2#Unmarshaler) interface. If you want arbitrary manipulation of keys, then this can be done at a map level. In other words, unmarshal the document into a map and then do whatever is necessary to it.\n. Having loose keys as suggested seems indeed like an edge case, and it seems sensible to not add functionality until we feel like there are more common cases that would benefit from the overhead.\n\nFor the time being, I'd suggest doing a pre-process step: unmarshal into a map, manipulate as necessary, remarshal, and unmarshal into the final location. This is surely a suboptimal workaround, but it feels worth paying the price where the cumbersome strategy is being observed before we have a better reason to have everyone paying the price.\n. I see, there's a problem indeed. To be clear, though, the issue here is that the implementation seems to be trusting on invalid YAML files. It wouldn't be the first time, but accounting it as \"the most likely type\" and saying that the YAML doesn't require quotes to interpret \"off\" as a string isn't correct. There's only one type the YAML should be read as, and the package is doing that job correctly.\n\nLoading it in Python, for example:\n\n```\n>>> yaml.load(\"nick: off\")\n{'nick': False}\n```\n\nSo if users are providing that file expecting it to be a string, that's a broken YAML file which will be handled incorrectly by other implementations.\n\nDespite that, one thing we can do to fix this and which I'd be happier pursuing, is to introduce the notion of raw values, and make sure they marshal out unchanged. This is being discussed in #13.\n. > I never said that. I said \"YAML doesn't require quotes around strings\" which is absolutely true.\n\nYou said that _\"and because YAML doesn't require quotes around strings\"_ while describing your case which was with the \"off\" string. That can't be \"absolutely true\" when it is false for the very case you're talking about.\n\n> But there is a difference in behavior between unmarshalling into a typed container vs an untyped container. This is the underlying problem.\n\nThe real underlying problem is that invalid YAML is being used. This will be an issue with any correct YAML parser you use.\n\n> That being said, RawMessage is the correct solution. I'm fine tossing this in favor of #13.\n\nSounds good. Thanks for the conversation.\n. This is handled automatically. For example, this:\n\n```\n data, err := yaml.Marshal(&Test{TestString: \"\\x80\"})\n```\n\nwill output this:\n\n```\nteststring: !!binary gA==\n```\n. The current behavior matches the specification, unfortunately. Example from Python:\n\n```\n>>> yaml.load(\"on: 1\")\n{True: 1}\n```\n\nLuckily, with the yaml Go package you can _force_ the keys to be strings by providing a typed map.\n. This would break existing applications that rely on the current behavior. We can eventually switch off to do that by default, but not without a major version change.\n. The fact the import path may be opened in a browser in a useful way is lost in this change.\n. Hi, sorry for not getting back to you on this timely. I'll fix the issue.\n. Tested and fixed in 7ad95dd. Thanks for the report.\n. This is likely a network error:\n\n```\n% go get somethingrandom.com/foo\npackage somethingrandom.com/foo: unrecognized import path \"somethingrandom.com/foo\"\n```\n. Please see #63.\n. Thanks for all the feedback. This is definitely going in.\n. @Songmu If you haven't yet done so, can you please sign the contributors agreement so I can integrate this:\n\nhttp://www.ubuntu.com/legal/contributors\n\nIt's a non-draconian license agreement which should be a straightforward read, and can be easily signed online.\n. Thanks!\n. This is the specification for YAML 1.1, though:\n\nhttp://yaml.org/type/bool.html\n. There's indeed a difference in behavior, but we cannot simply break compatibility to make the behavior of the yaml package match the json package, as that would break the expectation of existing applications trusting on the implemented behavior.\n. Hi Zachary,\n\nIt's not clear what is happening there, but we have had these exact lines in decode_test.go for a very long time, and tests pass fine:\n\nhttps://github.com/go-yaml/yaml/blob/v2/decode_test.go#L142\n\nDo tests pass for you if you don't change anything?\n. Sorry, your example uses pointers as values rather than `interface{}`, so I went ahead and copied your lines into the test file. They still pass.\n\nIs your code up to date?\n. Sorry, I can reproduce the bug. I did that in a rush yesterday and tested on yaml.v1 instead of yaml.v2.\n\nI will fix that, thanks.\n. Regarding the number of tests, you didn't actually add a new test. You added an entry to a slice that is used by one of the tests.\n. This is likely a network error:\n\n```\n% go get somethingrandom.com/foo\npackage somethingrandom.com/foo: unrecognized import path \"somethingrandom.com/foo\"\n```\n. Try to run go get with the option -v to get more details of the operation.\n. This change breaks current code using MapItem and thus MapSlice, so we have it in as-is. It's also concerning that this data won't be used when marshaling the items back.\n\nCan you also please describe what is the use case for this?\n. Sure, I'm certainly not against the idea of exposing the feature somehow, if we find a good way.\n. As was pointed out here, omitempty behaves in a way consistent with conventional practices elsewhere.\n. Yes, this is expected behavior because these values are generally interpreted as boolean, per the YAML specification. If you don't quote them, they mean something else.\n. Yes, the license does allow you to do that. Please refer to the LICENSE and LICENSE.libyaml file for full details on what's accepted or not.\n. Nice typo. :-)\n. The original idea was to match the most popular format for yaml files, which is by far lowercase fields. If I had to do it again, I'd probably have followed what is now the most common convention, but it's a bit late to change this now. Keeping people's code working is more important.\n. The assumption isn't valid in two different ways:\n1. The `\\@` string is not a valid escape sequence. If you try to decode this, it must error out.\n2. yaml only interprets escape sequences inside double quoted strings. Per [the spec](http://www.yaml.org/spec/1.2/spec.html#id2776092):\n\n> Note that escape sequences are only interpreted in double-quoted scalars. In all other scalar styles, the \u201c\\\u201d character has no special meaning and non-printable characters are not available.\n. If that was true the error message out of your example would not contain that character.\n. Thanks for the change. Indeed it'd be nice to have a better example of tag renaming in the documentation, but we co do that with a more trivial change. I've done that in 2bf6035. Please let me know if it solves your needs.\n. The current behaviorismo is part of the specification. Please ser section 5.4 on normalization of line-break characters.\n. And that's what I get for typing on a phone. Sorry for the typos.\n. The spec has several defects, most notably bloat, but I would say this is one thing it got right. It is definitely a data exchange format, but luckily not one that preserves invisible EOL characters as something meaningful. If you want bit by bit preservation, encode the data, quote it, or simply pick a binary data exchange format.\n. Yeah, sorry, this feels like an unexpected meaning for line/column which people will be confused about. I'm closing this PR for the time being. Feel free to discuss further.\n. Last I looked Travis required custom access to my projects for being able to build them, which doesn't sound entirely reasonable. Has that changed?\n. There's no way it can possibly guess what concrete type you'd want under that interface. You can achieve what you want by implementing aa type with a yaml.Unmarshaler interface and unmarshaling the value into it, though.\n. Hi there,\n\nI'm missing some high-level context for what this addressing and how it is addressing it.\n\nCan you point me to the section of the specification that describes what you are doing, and how you are implementing support for it, including some more clear examples?\n\nThanks!\n. We can certainly support comment manipulation, but we'll need to design this a little bit better first.\n\nNamingly, we need to ignore the internal implementation completely and look from the perspective of someone using the feature both to consume comments and to produce them back into the expected locations. We also need to outline which cases we'll try to support when writing, and which cases are going to cause clear havoc in the output.\n\nI'm closing this PR but I'd be happy to see an issue opened to discuss these details.\n. The functionality is sane, but the names should be Decoder and Encoder, and we need proper tests.\n\nIf we don't get @oec to fix that soonish, I'll add the equivalent functionality myself over the next few days.\n. One of the most important points of having that interface is fixing streaming of multiple documents, as @jeffjen mentions. The other would be having custom flags that can act per Decoder/Encoder instance, so we can have behavior changes (e.g. non-lowercase field names) without breaking existing code.\n. @oec About breaking semantics of encoding/xml, I'm not quite sure about what you're describing, but have a look at the [example of encoding/json](https://golang.org/pkg/encoding/json/#Decoder). We want the same for yaml, except we'd respect the spec in terms of how to split docs.\n. Let's just close this PR and I'll try to get to it over the next few days then.\n\nThanks for your help here @oec.\n. Without comments surviving a roundtrip it sounds like a very bad idea to support them at all.\n\nIn terms of the specification recommending against attributing meaning to them, that doesn't mean we shouldn't attempt to preserve comments. That's equivalent to how Go itself handles comments in its specification and its standard parser.\n\nRegarding handling end of line comments, this sounds like the easiest to handle, semantically, as it's very clearly assigned to the value on that line.\n. Either we ignore comments, or we don't. If comments are not relevant to be marshaled and unmarshaled, then we ignore them completely which is what we do today. If we decide to not ignore them, then we can't pretend they are irrelevant.\n\nNo, I haven't had a chance to stop and design it considering all the problems that may surface.\n. Interested in offering a patch for this?\n. Changing it on my side would also involve talking to lawyers, so without any proper reasoning other than \"they don't like LGPL\" I'm somewhat empty-handed to get into that conversation on my side.\n. After much internal debate, we've finally managed to get agreement to move the license towards the Apache License v2. Reopening #160 until the license lands.\n. Erroring in that case would be unacceptable, but we can do something similar to what I've used elsewhere: support the inline tag in maps too. This is useful in a number of cases as it allows mixing previously known key with custom ones, and if you want to error when the map is not empty that's easy too.\n. @vincentbernat The real solution for that is inline maps, as suggested above. Didn't get to it yet, sorry. \n. Unfortunately not.. Unlike json, yaml can take keys of arbitrary types.\n. See referenced issue.\n. @rjeczalik No problem, but can it stop? :)\r\n\r\nAbout the issue, I think the best approach is introducing an explicit Decoder type, as already planned/proposed/long overdue, and on that type have some sort of UseStringKeys or similar.\r\n\r\nWill look into this.. No worries, it's indeed an obscure and unexpected consequence which I would easily get into as well.. Looks like a certificate issue. Try to access that same URL from an up-to-date browser. Seems to work fine from here. Probably indicates the system trying to go get doesn't have access to a proper certificate bundle.\n. We can't change the default behavior like this, but we can have a mode on a `Decoder` that enables it.\n. Sounds good, thanks for that.\n\nMy most pressing deadlines elsewhere are due this month, so you can expect some good amount of love in go-yaml soon.\n. Please see #120 for motivation details. Will comment on the PR too.\n. This is definitely a breaking change, as it's modifying the prototype of a public function. That said, it's not too far from what I want to do.\n\nWe need to implement a Encoder/Decoder types that have a method (not a flag list) to enable the standard behavior. The global marshaling/unmarshaling functions simply call an internal global that contains the default encoder/decoder, and their prototype should not change to prevent breaking people's code out there.\n\nWe do want to keep the type metadata cache global as well, as the list of types is very limited, and it makes no sense to be paying the cost to recompute that metadata all the time.\n\nAlso, please note we need a contributor agreement signed to accept patches: http://www.ubuntu.com/legal/contributors - it's a straightforward non-draconian agreement, easy to sign online, but do read it through to make sure you're comfortable with the clauses there.\n\nI'm closing this for the time being, but please do reopen it if you sort out the above details.\n. Ah, one side note if you decide to pursue it: please have a look at the interface of Decoder/Encoder in encoding/json. We want to mimic it, for the same reason you want to mimic its field-naming behavior.\n. Thanks for signing, Sam, and looking forward to your contributions.\n\n> Alternatively, there could be a global YAMLCodec\n\nYes, that's what I had in mind too.\n\n> WRT versioning, I think the cleanest thing to do would probably be to start work on a v3\n\nFirst thing is to get these features into v2 itself. There's no benefit in breaking out right now and making these improvements incompatible from the get go.\n\n> Unfortunately I don't have time to contribute that right now, but I will eventually if no one gets there first :)\n\nUnderstood. I'll close this PR for the time being then.\n\n> Out of interest @niemeyer what is your workflow when using imported from gopkg.in\n\nNothing fancy. I just have my branch inside the proper gopkg.in location in $GOPATH.\n\nThanks for your collaboration, Sam.\n. Thanks!\n. Pong. Sorry, need to do a full pass on go-yaml. Will try to get to it tomorrow.\n. Hi Sam. The rationale sounds sensible, and the current list of changes sounds good too. We should talk a bit more about these other issues before spending time on them, to make sure no time is wasted on it.\n\nBefore we release v3, we also need to consider a migration tool. It doesn't have to actually migrate the code, but should at least point out where to look for potential incompatibilities.\n. Yes, quite possibly not trivial. But the opposite of that is letting every other developer figure out by themselves what is going to break. Instead, what people will most likely do is stick to v2, which is not great either.\n\nBy the way, the actual changes listed above are all trivial by themselves. Under 30 minutes, I'd say.\n. > Hmm, I think that basically anything using v2's Marshal or Unmarshal would be considered broken in the proposed v3 until it is tested. (...)\n\nThis is not just a technical issue. There's a very natural tendency for code to not be updated, ever. If there's known-for-sure breakage, the inertia increases significantly. If there's unknown known-for-sure breakage, the inertia is so high we may as well not do it.\n\nWe can't have a global flag, because in a same application different packages may depend on different behavior. That said, we can have a local flag, for a yaml.Decoder and yaml.Encoder, akin to json.Encoder/Decoder. This is actually where I would start. Introduce into v2 a compatibility flag. This benefits everyone, with no breakage. Eventually we can introduce a v3 which has this mode by default, and kill the old logic. \n. Merged #171.. This is already merged. Are you seeing any issues on the latest?\n. That's quite ironic. That project is a rip-off from go-yaml.. I can see parts that which were clearly \"inspired\" by go-yaml. If you are worried about licenses, you are switching from someone that is trying to support you to someone that is copying logic unlicensed.\n\nGo for it. :-)\n. After much internal debate, we've finally managed to get agreement to move the license towards the Apache License v2. Reopening until the license lands.\n. The main problem is being legally allowed to do so, which isn't something I can help you with in detail. As one point to observe, if you got contributions to your project without a license agreement that allows you to do that, you can't change the license without asking explicit permission to all of your contributors, because they implicitly licensed the work under that same license to you.\n. Just committed the text on e4d366f, apologies for the delay.\n. Thanks Jeff.\n\nCan you please have a look at the contributor agreement here and sign if you're comfortable:\n- http://www.ubuntu.com/legal/contributors\n\nIt's a non-draconian agreement which is hopefully okay, and may be signed online.\n\nThen, we'll need a few tests and docs, and perhaps some simple tweaks. But the direction is good.\n. @jeffjen Can you please have a look at:\n\nhttps://www.ubuntu.com/legal/contributors\n. The functionality and the API look reasonable. Would be good to have some conventional comments on the public pieces.\n. We've discussed this multiple times in other PRs and issues. We can't have a global option like this, because it would break other packages that are being imported into the same binary and have different expectations. The proper path here is to have an Encoder and Decoder which may be tuned. We already have in progress in other PRs, and I'll move it forward once I get the unrelated work I'm doing out of the door.\n. Sorry, yes, you are right. I misread the API as setting global options instead of unmarshaling in place.\n\nThe idea which seems best is still the one we discussed in that thread, though, which differs from what was presented as the follow up:\n\n> We need to implement a Encoder/Decoder types that have a method (not a flag list) to enable the standard behavior. The global marshaling/unmarshaling functions simply call an internal global that contains the default encoder/decoder, and their prototype should not change to prevent breaking people's code out there.\n. > Do you mean a global function called e.g. yaml.NoLowercase() that would affect all encoding/decoding?\n\nNo, per the quoted sentence: _\"We need to implement a Encoder/Decoder types that have a method (not a flag list) to enable the standard behavior.\"_\n\nPlease have a look at encoding/json, for example. Perhaps `UseFieldNames` for the method name.\n. Thanks, and sorry for the long delay.. Sorted out in #249.. You can use a pointer or an interface{} so you can tell it was unset (nil).\n. @purpleidea There isn't much to it, really.. if you have a field that is a pointer type (say, `*string`) the field isn't set if the field is missing from the input or set to YAML's `null`. \n. @mogthesprog Why do we need the additional go get call in travis?. @mogthesprog Yes.. #173 was exactly that, but unfortunately it got removed after this PR.\r\n\r\nHappy to merge if you can redo it.. Sorted out in #249.. Done!\n. Thanks for this.\n. This a backwards incompatible change, and not clearly a bug in the sense that a time.Duration is in fact a number and not a string. So the main question is whether we want to do it at all. I can see it going both ways at the moment.. The output is a valid yaml file. Suggestions to improve that are welcome, but please keep in mind that we won't be able to please everyone's preferred style with the default rules. Some tuning may be offered via the upcoming Encoder and Decoder types, but we also don't want to go overboard with flags.\n\nWith all that said, adding some extra spacing before nested lists sounds like a better default indeed. I'll look into that.\n. No, this is valid yaml with the content you intended it to have. Give it a try by unmarshaling it onto an `interface{}` and print it out.\n. Thanks for the note.\n. This matches the upstream libyaml code. Please submit it there first so comparing the two is easier.\n. Thanks!. Thanks!. It's not clear to me how this is fixing the referenced issue in a proper way. What's the actual specification of the float format in yaml, and how is this handling it? Where are the tests for it showing details of the problem being fixed?. Note that this changed from yaml 1.1 to 1.2. It might be okay, but we may also end up breaking existing code. In Python:\r\n```\r\n>>> import yaml\r\n>>> yaml.load(\"01.1\")\r\n1.1\r\n```\r\nThanks for the tests.. Curiously, Python float resolution seems broken in other ways:\r\n```\r\n>>> yaml.load(\"-2E+05\")\r\n'-2E+05'\r\n```. Indeed, merged #171. Thanks for your help on this.. It is very much alive, yes. We depend on it for several of our main projects.\r\n\r\nThe fact it's been staggering for a while is due to my own agenda being overwhelmed, but the main deadlines have passed and it will see attention over the following days. . Yes, I realize the queue is far from ideal right now. I have it on my \"urgent\" queue, yet keep pushing it back in favor of more urgent things. I'll try to work through some of the most critical items this week still.\r\n\r\nAbout more maintainers, that's always welcome obviously. The problem is precisely the question you ask: finding good long term maintainers.. Not sure about what that means. This works fine here:\r\n```\r\ntype T struct {\r\n        Foo string\r\n}\r\n\r\nfunc main() {\r\n        var v T\r\n        err := yaml.Unmarshal([]byte(\"foo: 2.94\"), &v)\r\n        fmt.Println(err, v.Foo)\r\n}       \r\n```\r\n. Thanks!. Thanks!. Several weeks back I had a conversation with @rogpeppe and we agreed he'd allocate some of his time to keeping this library up-to-date and well taken care of. This seems to be taking slightly more time than expected to happen, though.\r\n\r\n@rogpeppe Do you have any news there?. The parser is really an implementation detail which shouldn't be exposed at this point. If you need to reuse the code, I suggest just copying it over. . LGTM, but I don't think we need the NOTICE file if we're adding the license explicitly.. Thanks!. This is a divergence that doesn't sound worth fixing to be honest. People can break their documents by simply copy & pasting a section of a document which is a map of unordered fields. So this behavior breaks the idea of the lack of order there, and creates more problems than it solves.\r\n\r\nWe also never produce such documents by marshaling from the package, which means the broken document was produced some other way, most likely by hand.\r\n\r\nIt sounds fine to introduce a more strict checker, though, when one wants to make sure that documents comply to that rule. But again I'd prefer and recommend not failing to parse these documents.. @prateek From the [spec](http://www.yaml.org/spec/1.2/spec.html#id2765608):\r\n\r\n> 3.2.2.1. Keys Order\r\n>\r\n> In the representation model, mapping keys do not have an order. To serialize a mapping, it is necessary to impose an ordering on its keys. This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, (...)\r\n\r\nThe vast majority of YAML documents have such a mapping at the top level, so it's very reasonable that people think about it as something that lacks ordering. The fact you can dig further data to prove that this is in fact ordered in certain cases is beyond the point here.. > The fact you can dig further data to prove that this is in fact ordered in certain cases is beyond the point here.. ",
    "james-lawrence": "+1\n. +1\n. ",
    "at15": "There is a PR https://github.com/go-yaml/yaml/pull/163/ for this issue, but got stuck on CLA. There is a PR https://github.com/go-yaml/yaml/pull/163/ for this issue, but got stuck on CLA. ",
    "im-kulikov": "#288 Workaround Encoder/Decoder. https://github.com/go-yaml/yaml/pull/288 commits + would fix some issues . I have some troubles with writing test cases for NewEncoder.. mb few days and I commit changes. ping @niemeyer, @rogpeppe . @niemeyer, @rogpeppe is there changes, what I can do for approve?. ping @niemeyer, @rogpeppe?. #288 Workaround Encoder/Decoder. https://github.com/go-yaml/yaml/pull/288 commits + would fix some issues . I have some troubles with writing test cases for NewEncoder.. mb few days and I commit changes. ping @niemeyer, @rogpeppe . @niemeyer, @rogpeppe is there changes, what I can do for approve?. ping @niemeyer, @rogpeppe?. ",
    "beatgammit": "This issue was meant to be a minimally invasive as possible to the current API, whereas I prefer the approach in #4 better, especially since this can be implemented with `bufio.Scanner` (that's what I'm currently doing).\n\nI'm undecided as to how parsing multiple documents should work with `Decode`. I think the best approach is to have `Decode` decode a single document, consuming the document delimiter before returning. This way the user could handle multiple documents in a simple loop:\n\n```\ndec = yaml.NewDecoder(r)\nfor dec.Decode(&doc) == nil {\n}\n```\n\nThere could also be a `DecodeAll([]interface{})` to do everything at once.\n. This issue was meant to be a minimally invasive as possible to the current API, whereas I prefer the approach in #4 better, especially since this can be implemented with `bufio.Scanner` (that's what I'm currently doing).\n\nI'm undecided as to how parsing multiple documents should work with `Decode`. I think the best approach is to have `Decode` decode a single document, consuming the document delimiter before returning. This way the user could handle multiple documents in a simple loop:\n\n```\ndec = yaml.NewDecoder(r)\nfor dec.Decode(&doc) == nil {\n}\n```\n\nThere could also be a `DecodeAll([]interface{})` to do everything at once.\n. ",
    "ewalk153": "I'm also confused by the Setter interface; it appears that it can only be used in conjunction with pointer fields.\n\nHere is a simple example:\nhttps://gist.github.com/ewalk153/11043842\n. Pull request for time.Time -> YAML encoding https://github.com/go-yaml/yaml/pull/10\n. So far, I haven't figured out the YAML -> time.Time decoding.\n. It should be properly filled out.\n. Yeah, I'll take another look.\n. Fixing the formatting should be quick here.\n\nThe decoding looks to be a little more complicated. I'm not sure how to infer the type of the target field. Any suggestions?\n. I'm getting stuck using reflection to assign the out value.\n\nAs a `time.Time` struct has only exported fields, I'm not sure out to assign to it.\n\nhttp://play.golang.org/p/Z-pI2fm_Fa\n. I'm also confused by the Setter interface; it appears that it can only be used in conjunction with pointer fields.\n\nHere is a simple example:\nhttps://gist.github.com/ewalk153/11043842\n. Pull request for time.Time -> YAML encoding https://github.com/go-yaml/yaml/pull/10\n. So far, I haven't figured out the YAML -> time.Time decoding.\n. It should be properly filled out.\n. Yeah, I'll take another look.\n. Fixing the formatting should be quick here.\n\nThe decoding looks to be a little more complicated. I'm not sure how to infer the type of the target field. Any suggestions?\n. I'm getting stuck using reflection to assign the out value.\n\nAs a `time.Time` struct has only exported fields, I'm not sure out to assign to it.\n\nhttp://play.golang.org/p/Z-pI2fm_Fa\n. ",
    "spf13": "I found the same issue and was beginning to draft a similar fix. If you can send this as a PR it would help me... even if it's only the first half of the entire solution.\n. I found the same issue and was beginning to draft a similar fix. If you can send this as a PR it would help me... even if it's only the first half of the entire solution.\n. ",
    "purohit": "Thank you!\nOn Sep 23, 2014 5:51 AM, \"Gustavo Niemeyer\" notifications@github.com\nwrote:\n\n> Closed #11 https://github.com/go-yaml/yaml/issues/11 via de3643d\n> https://github.com/go-yaml/yaml/commit/de3643d77b438c6f0f69f350c437639a300b5e73\n> .\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/issues/11#event-168727684.\n. Thank you!\nOn Sep 23, 2014 5:51 AM, \"Gustavo Niemeyer\" notifications@github.com\nwrote:\n\n> Closed #11 https://github.com/go-yaml/yaml/issues/11 via de3643d\n> https://github.com/go-yaml/yaml/commit/de3643d77b438c6f0f69f350c437639a300b5e73\n> .\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/issues/11#event-168727684.\n. ",
    "ghost": "On the topic of compatibility, if maps should be map[string]interface{} instead of map[interface{}]interface{}, that would be most helpful.  At the moment, they aren't, which deviates from the behavior of encoding/json.\n. Another example that will cause panic:\n\n```\npackage main\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v1\"\n)\nfunc main() {\n    var x interface{}\n    msg := `{[]}`\n    yaml.Unmarshal([]byte(msg), &x)\n    fmt.Println(x)\n}\n```\n. I meet the situation , too.  So I am very confused...\n\n```\ntest_ring_yaml = ` \n                datetime:   2015-01-01 13:00        # be precise to minute\n                protocol_version:   1.0    \n                owner:    zhaoxi\n                alert_receivers:\n                migration: \n                app_names:    \n                    - CPC_Ad    \n                    - Search-Ad\n                shards:\n                    - # one shard is one object \n                      master: 10.11.1.1:6379,1      # ip:port,weight\n                      slaves:\n                            - 10.11.2.1:6379,1\n                            - 10.11.3.1:6379,1\n                    -   \n                      master: 10.11.1.2:6379,1      # ip:port,weight\n                      slaves: []                    # empty content\n                    -   \n                      master: 10.11.1.3:6379,1\n                    -   \n                      master: 10.11.1.10:6379,2    \n`\n\nif actual.Shards[1].Slaves == nil {\n    log.Println(\"Nil pointer\")   \n}\nif !reflect.DeepEqual(actual, expectedRing) {\n    t.Errorf(\"Not equal. Expected:%q, Actual:%q\\n\", expectedRing, actual)\n}\n```\n\n---\n\nmy struct :\n\n<pre>\n// ------------------------------------------------------\n// YAML -- Begin\ntype AppNames []string\ntype Migration struct {\n} //TODO extension\ntype Shard struct {\n    // IP:Port,Weight\n    Master string   `yaml:\"master\"`\n    Slaves []string `yaml:\"slaves,omitempty\"`\n}\ntype RingYAML struct {\n    Name            string     `yaml:\"name\"`\n    Datetime        string     `yaml:\"datetime\"`\n    ProtocolVersion string     `yaml:\"protocol_version\"`\n    Owner           string     `yaml:\"owner,omitempty\"`\n    AlertReceivers  []string   `yaml:\"alert_receivers,omitempty\"`\n    Migration       *Migration `yaml:\"migration\"`\n    AppNames        AppNames   `yaml:\"app_names\"` // simple ACL implementation\n    Shards          []*Shard   `yaml:\"shards\"`\n}\n// YAML -- End\n// ------------------------------------------------------\n</pre>\n\n== go test -v :\n=== RUN TestDecodeRingYAML\n2015/01/16 15:56:33 Nil pointer\n--- PASS: TestDecodeRingYAML (0.00s)\n. yaml \"gopkg.in/yaml.v2\"\n\nI am eagerly waiting for the bugfix.\n. When do you put your fixed into gopkg.in/yaml.v2? \nIs it ready for Users.?\n. On the topic of compatibility, if maps should be map[string]interface{} instead of map[interface{}]interface{}, that would be most helpful.  At the moment, they aren't, which deviates from the behavior of encoding/json.\n. Another example that will cause panic:\n\n```\npackage main\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v1\"\n)\nfunc main() {\n    var x interface{}\n    msg := `{[]}`\n    yaml.Unmarshal([]byte(msg), &x)\n    fmt.Println(x)\n}\n```\n. I meet the situation , too.  So I am very confused...\n\n```\ntest_ring_yaml = ` \n                datetime:   2015-01-01 13:00        # be precise to minute\n                protocol_version:   1.0    \n                owner:    zhaoxi\n                alert_receivers:\n                migration: \n                app_names:    \n                    - CPC_Ad    \n                    - Search-Ad\n                shards:\n                    - # one shard is one object \n                      master: 10.11.1.1:6379,1      # ip:port,weight\n                      slaves:\n                            - 10.11.2.1:6379,1\n                            - 10.11.3.1:6379,1\n                    -   \n                      master: 10.11.1.2:6379,1      # ip:port,weight\n                      slaves: []                    # empty content\n                    -   \n                      master: 10.11.1.3:6379,1\n                    -   \n                      master: 10.11.1.10:6379,2    \n`\n\nif actual.Shards[1].Slaves == nil {\n    log.Println(\"Nil pointer\")   \n}\nif !reflect.DeepEqual(actual, expectedRing) {\n    t.Errorf(\"Not equal. Expected:%q, Actual:%q\\n\", expectedRing, actual)\n}\n```\n\n---\n\nmy struct :\n\n<pre>\n// ------------------------------------------------------\n// YAML -- Begin\ntype AppNames []string\ntype Migration struct {\n} //TODO extension\ntype Shard struct {\n    // IP:Port,Weight\n    Master string   `yaml:\"master\"`\n    Slaves []string `yaml:\"slaves,omitempty\"`\n}\ntype RingYAML struct {\n    Name            string     `yaml:\"name\"`\n    Datetime        string     `yaml:\"datetime\"`\n    ProtocolVersion string     `yaml:\"protocol_version\"`\n    Owner           string     `yaml:\"owner,omitempty\"`\n    AlertReceivers  []string   `yaml:\"alert_receivers,omitempty\"`\n    Migration       *Migration `yaml:\"migration\"`\n    AppNames        AppNames   `yaml:\"app_names\"` // simple ACL implementation\n    Shards          []*Shard   `yaml:\"shards\"`\n}\n// YAML -- End\n// ------------------------------------------------------\n</pre>\n\n== go test -v :\n=== RUN TestDecodeRingYAML\n2015/01/16 15:56:33 Nil pointer\n--- PASS: TestDecodeRingYAML (0.00s)\n. yaml \"gopkg.in/yaml.v2\"\n\nI am eagerly waiting for the bugfix.\n. When do you put your fixed into gopkg.in/yaml.v2? \nIs it ready for Users.?\n. ",
    "GeorgeMac": "I would like to +1 this. Would be very useful for writing config files in my projects!\n. I would like to +1 this. Would be very useful for writing config files in my projects!\n. ",
    "fgrosse": "Yeah I am missing that too so I can delay the actual decoding of some fields.\nIs there a known work around? I don't get how the Unmarshaller interface[1](http://godoc.org/gopkg.in/yaml.v2#Unmarshaler) is supposed to work.\n. I have the exact same use case as @missedone\n. Oh I didnt know there is no way I can use `@` in an unquoted string\nThanks for clearing that up :)\n. Yeah I am missing that too so I can delay the actual decoding of some fields.\nIs there a known work around? I don't get how the Unmarshaller interface[1](http://godoc.org/gopkg.in/yaml.v2#Unmarshaler) is supposed to work.\n. I have the exact same use case as @missedone\n. Oh I didnt know there is no way I can use `@` in an unquoted string\nThanks for clearing that up :)\n. ",
    "tay10r": "+1 for yaml.RawMessage\n\n<b>edit</b>\n\nThe `yaml.MapSlice` structure seems to be a much better solution than `json.RawMessage`\n. @niemeyer The problem I had intended to solve using `RawMessage` I had later solved using `MapSlice`. I am relatively new to golang, so this wasn't immediately obvious to me.\n\nI think most problems people intend to solve with a `json.RawMessage` equivalent may be solved with `yaml.MapSlice`, but there isn't much documentation or example usages of it. If there was perhaps more of  this, people will find that they do not need a `yaml.RawMessage`.\n. +1 for yaml.RawMessage\n\n<b>edit</b>\n\nThe `yaml.MapSlice` structure seems to be a much better solution than `json.RawMessage`\n. @niemeyer The problem I had intended to solve using `RawMessage` I had later solved using `MapSlice`. I am relatively new to golang, so this wasn't immediately obvious to me.\n\nI think most problems people intend to solve with a `json.RawMessage` equivalent may be solved with `yaml.MapSlice`, but there isn't much documentation or example usages of it. If there was perhaps more of  this, people will find that they do not need a `yaml.RawMessage`.\n. ",
    "missedone": "+1 for yaml.RawMessage\n. @niemeyer In my case, I have a lot of yaml configuration files, each includes some common definition and plugin settings, for plugin settings it's variant from plugin to plugin, i want to delay the parse and pass the RawMessage to leave the plugin implementation do it.\ni know i can extract the plugin settings into separate yaml file, but it's really annoying i need to reference them in the parent yaml file.\n. +1 for yaml.RawMessage\n. @niemeyer In my case, I have a lot of yaml configuration files, each includes some common definition and plugin settings, for plugin settings it's variant from plugin to plugin, i want to delay the parse and pass the RawMessage to leave the plugin implementation do it.\ni know i can extract the plugin settings into separate yaml file, but it's really annoying i need to reference them in the parent yaml file.\n. ",
    "dvirsky": "It would be great if you could just have a method mapping a MapSlice (or a plain `map[string]interface{}` for that matter) directly into a struct, without the need to re-marshal it.\n. It would be great if you could just have a method mapping a MapSlice (or a plain `map[string]interface{}` for that matter) directly into a struct, without the need to re-marshal it.\n. ",
    "tchap": "Isn't it enough to implement `UnmarshalYAML` and store the `unmarshal` function for later use and just immediately return from the function? I tried this and it works to just call the function later.\n\n``` go\ntype RawMessage struct {\n    unmarshal func(interface{}) error\n}\n\nfunc (msg *RawMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {\n    msg.unmarshal = unmarshal\n    return nil\n}\n\nfunc (msg *RawMessage) Unmarshal(v interace{}) error {\n    return msg.unmarshal(v)\n}\n```\n\nThen you can call `RawMessage.Unmarshal(v)` later and perform the actual unmarshalling, right?\n. True, I only needed to defer unmarshalling, was not really thinking about marshalling, but sure, it's obviously not symmetrical.\n. Yep.\n. The funny part is that the test passes or fails depending on the time zone :D\n. So why is it so that when I marshal `time.Now()` I get `2015-02-24 22:31:53.04541655 +0100 CET`? Doesn't look at all like the string mentioned in the tests. Is it some kind of local setting?\n. Pulled to use the latest `v2`.\n\nStill getting `parsing time \"2015-02-24 23:39:59.39193313 +0100 CET\" as \"2006-01-02T15:04:05Z07:00\": cannot parse \" 23:39:59.39193313 +0100 CET\" as \"T\"`. The only thing that I am doing is to encode `time.Time` and then read it again...\n\nLooks weird, gonna keep researching...\n. Will try...\n. OMG never mind, I am seriously retarded sometimes. The file is generated from a template (`text/template`), which obviously uses `Time.String()` to marshal `time.Time`. Dunno why it's not using `Time.MarshalText`. But I am sorry to waste your time :facepalm:\n. That is why I did this hack the other day to make `Time.String` behave like `Time.MarshalText`... Not even sure why these two methods return different representations, though...\n. Isn't it enough to implement `UnmarshalYAML` and store the `unmarshal` function for later use and just immediately return from the function? I tried this and it works to just call the function later.\n\n``` go\ntype RawMessage struct {\n    unmarshal func(interface{}) error\n}\n\nfunc (msg *RawMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {\n    msg.unmarshal = unmarshal\n    return nil\n}\n\nfunc (msg *RawMessage) Unmarshal(v interace{}) error {\n    return msg.unmarshal(v)\n}\n```\n\nThen you can call `RawMessage.Unmarshal(v)` later and perform the actual unmarshalling, right?\n. True, I only needed to defer unmarshalling, was not really thinking about marshalling, but sure, it's obviously not symmetrical.\n. Yep.\n. The funny part is that the test passes or fails depending on the time zone :D\n. So why is it so that when I marshal `time.Now()` I get `2015-02-24 22:31:53.04541655 +0100 CET`? Doesn't look at all like the string mentioned in the tests. Is it some kind of local setting?\n. Pulled to use the latest `v2`.\n\nStill getting `parsing time \"2015-02-24 23:39:59.39193313 +0100 CET\" as \"2006-01-02T15:04:05Z07:00\": cannot parse \" 23:39:59.39193313 +0100 CET\" as \"T\"`. The only thing that I am doing is to encode `time.Time` and then read it again...\n\nLooks weird, gonna keep researching...\n. Will try...\n. OMG never mind, I am seriously retarded sometimes. The file is generated from a template (`text/template`), which obviously uses `Time.String()` to marshal `time.Time`. Dunno why it's not using `Time.MarshalText`. But I am sorry to waste your time :facepalm:\n. That is why I did this hack the other day to make `Time.String` behave like `Time.MarshalText`... Not even sure why these two methods return different representations, though...\n. ",
    "andrewrynhard": "Are there any good examples of how to use `yaml.MapSlice`? \n. Are there any good examples of how to use `yaml.MapSlice`? \n. ",
    "perj": "What I wanted to use `json.RawMessage` for was to have a json dictionary in the middle of the YAML output. That's still valid yaml. E.g. to output this:\n\n```\nfoo:\n  bar: { \"a\" : 1 }\n  baz:\n    b: 2\n```\n\nUsing only `map[string]interface{}` types the code would look like this (untested):\n\n``` go\ntopdata := make(map[string]interface{})\nfoodata := make(map[string]interface{})\ntopdata[\"foo\"] = foodata\nfoodata[\"bar\"] = json.RawMessage(`{ \"a\" : 1 }`)\nfoodata[\"baz\"] = map[string]interface{}{ \"b\" : 2 }\nenc, _ := yaml.Marshal(topdata)\nprintln(enc)\n```\n\nInstead, the json.RawMessage seems to be interpreted as a slice of bytes and each byte output as an integer element.\n\nThis package should at least support some way of doing the output above. As far as I can tell it isn't possible right now.\n. What I wanted to use `json.RawMessage` for was to have a json dictionary in the middle of the YAML output. That's still valid yaml. E.g. to output this:\n\n```\nfoo:\n  bar: { \"a\" : 1 }\n  baz:\n    b: 2\n```\n\nUsing only `map[string]interface{}` types the code would look like this (untested):\n\n``` go\ntopdata := make(map[string]interface{})\nfoodata := make(map[string]interface{})\ntopdata[\"foo\"] = foodata\nfoodata[\"bar\"] = json.RawMessage(`{ \"a\" : 1 }`)\nfoodata[\"baz\"] = map[string]interface{}{ \"b\" : 2 }\nenc, _ := yaml.Marshal(topdata)\nprintln(enc)\n```\n\nInstead, the json.RawMessage seems to be interpreted as a slice of bytes and each byte output as an integer element.\n\nThis package should at least support some way of doing the output above. As far as I can tell it isn't possible right now.\n. ",
    "RichMorin": "In my current use case, the input file looks like this:\n\n```\nPredicates:\n# ns_name                             P  PT  I  Expansion\n  owl_disjointWith:                 [ _, __, _, 'disjoint with' ]\n  owl_equivalentClass:              [ _, __, _, 'equivalent class' ]\n...\n```\n\nSo, I guess I can use a type such as this:  type  T map[string] map[string] []string\nHowever, in some cases, I may not know in advance how many levels are involved.\n. In my current use case, the input file looks like this:\n\n```\nPredicates:\n# ns_name                             P  PT  I  Expansion\n  owl_disjointWith:                 [ _, __, _, 'disjoint with' ]\n  owl_equivalentClass:              [ _, __, _, 'equivalent class' ]\n...\n```\n\nSo, I guess I can use a type such as this:  type  T map[string] map[string] []string\nHowever, in some cases, I may not know in advance how many levels are involved.\n. ",
    "codepushr": "I'm not sure if I fully understood your question but if you don't know the exact structure you can parse it into a map (associative array) like so:\n\n```\nm := make(map[interface{}]interface{})\nerr = yaml.Unmarshal([]byte(data), &m)\n```\n. +1 More examples would be great.\n. I'm not sure if I fully understood your question but if you don't know the exact structure you can parse it into a map (associative array) like so:\n\n```\nm := make(map[interface{}]interface{})\nerr = yaml.Unmarshal([]byte(data), &m)\n```\n. +1 More examples would be great.\n. ",
    "gravis": "btw, Unmarshal API is broken, it's never returning an error:\n\nhttps://github.com/go-yaml/yaml/blob/1ff37a7d30b085dc643dee7adb18759e3511661a/yaml.go#L87\n\n:)\n. Indeed, sorry :)\n. btw, Unmarshal API is broken, it's never returning an error:\n\nhttps://github.com/go-yaml/yaml/blob/1ff37a7d30b085dc643dee7adb18759e3511661a/yaml.go#L87\n\n:)\n. Indeed, sorry :)\n. ",
    "rogpeppe": "On 26 June 2014 22:13, Philippe Lafoucri\u00e8re notifications@github.com wrote:\n\n> btw, Unmarshal API is broken, it's never returning an error:\n> \n> https://github.com/go\n> -yaml/yaml/blob/1ff37a7d30b085dc643dee7adb18759e3511661a/yaml.go#L87\n> \n> :)\n\nThat's not true. See the handleErr function.\n. Fixed by feb4ca7\n. I'd be OK if this drew an error actually. If I expect to be marshalling into a bson string type, I'm not sure that a behind-the-scenes change to binary data is great. I'm sure there are arguments the other way too though.\n. X isn't a map because the content doesn't always hold a map in X.\n\nThanks for the fix!\n. Fixed by #103 . PR #88 is resolved, so closing this.. @vinzenz I cannot find a description of the `<<` operator in any of the YAML 1.x specifications.\r\n\r\nShould this actually be a supported feature?\r\n. @vinzenz How many other \"working drafts\" are actually part of the YAML spec without being mentioned there? How is one supposed to know what YAML actually is without a full specification?. Thanks very much for doing this. Unfortunately it doesn't go as far as the\r\nspec (http://yaml.org/type/timestamp.html) allows, and it breaks\r\nthe tests, but it's still useful - I've used it as the basis of new PR.\r\nSee PR #273.\r\n. I'd love to do a patch but there are at least 10 things that I need to do more than this that I know no-one else is ever going to do... Perhaps on a flight sometime, unless I find this bug blocking some other task.\n. @tyangliu \r\n> This results in unusable yaml output like in the example below.\r\n\r\nWhat do you mean by \"unusable yaml output\" there? By my reading of the specification, that YAML looks valid. See section 8.1.3 in http://yaml.org/spec/1.2/spec.html, which says \"Folding allows long lines to be broken anywhere a single space character separates two non-space characters.\". That means that the example is perfectly valid YAML and the map value holds exactly the string you produced.\r\n\r\nThe Go YAML marshaler uses heuristics to try to produce decent looking output for any possible string. There are so many possible output style choices in YAML, that I'm not sure it's a good idea to start down the slippery slope of allowing string style choices to be specified with struct tags.\r\n\r\nThat said, suggestions are welcome - any such struct tag would need to be applicable to all possible strings.\r\n\r\n\r\n\r\n\r\n. > I understand this is valid according to the specification, but not compatible in all implementations\r\n\r\nHow hard should go-yaml try to produce YAML that is compatible with other broken YAML implementations? As the YAML spec is insanely complex, I wouldn't be surprised if every single implementation was broken in some way.\r\n\r\nIf we decide that we want to be compatible with perl's broken implementation, the right answer I think would be to avoid breaking lines like this at all. Providing a tag so that the behaviour can be changed in individual cases doesn't seem like the right fix (what if some other field happens to have a long value with spaces in?).\r\n\r\ntbh, if you're marshalling YAML for data interchange, I'd suggest not using YAML but using JSON instead - it's simple enough that most implrmentations get it right, and it's also compatible (mostly) with YAML.. I'm afraid I don't think that having a global variable that modifies YAML unmarshaling behaviour is a good idea. It means that if you have several packages that use YAML in different ways, they can step on each others' toes. In general, package-level mutable variables should be considered a bad idea.. The current behaviour seems reasonable to me, but I'm open to arguments the other way. Can anyone cite the relevant part of the spec that would allow an unquoted `<<` as a mapping key?. LGTM, thanks.. Closed by #289 . Yes, there are many possible values for boolean, because go-yaml supports YAML 1.1.\r\nSee http://yaml.org/type/bool.html for the full list. I agree that this is not ideal - I've been caught by it many times in the past.\r\n\r\nI think this is essentially a duplicate of #214, so closing in favour of that.. Thanks for this. I updated it slightly before merging.. LGTM; thanks very much.. @alexjh @aarondl What do you think?\r\n. The documentation for \"omitempty\" the qualifier says:\r\n\r\n    Only include the field if it's not set to the zero value for the type \r\n\r\nFalse is the zero of the boolean type. Why is this not expected behaviour?\r\n. On 26 June 2014 22:13, Philippe Lafoucri\u00e8re notifications@github.com wrote:\n\n> btw, Unmarshal API is broken, it's never returning an error:\n> \n> https://github.com/go\n> -yaml/yaml/blob/1ff37a7d30b085dc643dee7adb18759e3511661a/yaml.go#L87\n> \n> :)\n\nThat's not true. See the handleErr function.\n. Fixed by feb4ca7\n. I'd be OK if this drew an error actually. If I expect to be marshalling into a bson string type, I'm not sure that a behind-the-scenes change to binary data is great. I'm sure there are arguments the other way too though.\n. X isn't a map because the content doesn't always hold a map in X.\n\nThanks for the fix!\n. Fixed by #103 . PR #88 is resolved, so closing this.. @vinzenz I cannot find a description of the `<<` operator in any of the YAML 1.x specifications.\r\n\r\nShould this actually be a supported feature?\r\n. @vinzenz How many other \"working drafts\" are actually part of the YAML spec without being mentioned there? How is one supposed to know what YAML actually is without a full specification?. Thanks very much for doing this. Unfortunately it doesn't go as far as the\r\nspec (http://yaml.org/type/timestamp.html) allows, and it breaks\r\nthe tests, but it's still useful - I've used it as the basis of new PR.\r\nSee PR #273.\r\n. I'd love to do a patch but there are at least 10 things that I need to do more than this that I know no-one else is ever going to do... Perhaps on a flight sometime, unless I find this bug blocking some other task.\n. @tyangliu \r\n> This results in unusable yaml output like in the example below.\r\n\r\nWhat do you mean by \"unusable yaml output\" there? By my reading of the specification, that YAML looks valid. See section 8.1.3 in http://yaml.org/spec/1.2/spec.html, which says \"Folding allows long lines to be broken anywhere a single space character separates two non-space characters.\". That means that the example is perfectly valid YAML and the map value holds exactly the string you produced.\r\n\r\nThe Go YAML marshaler uses heuristics to try to produce decent looking output for any possible string. There are so many possible output style choices in YAML, that I'm not sure it's a good idea to start down the slippery slope of allowing string style choices to be specified with struct tags.\r\n\r\nThat said, suggestions are welcome - any such struct tag would need to be applicable to all possible strings.\r\n\r\n\r\n\r\n\r\n. > I understand this is valid according to the specification, but not compatible in all implementations\r\n\r\nHow hard should go-yaml try to produce YAML that is compatible with other broken YAML implementations? As the YAML spec is insanely complex, I wouldn't be surprised if every single implementation was broken in some way.\r\n\r\nIf we decide that we want to be compatible with perl's broken implementation, the right answer I think would be to avoid breaking lines like this at all. Providing a tag so that the behaviour can be changed in individual cases doesn't seem like the right fix (what if some other field happens to have a long value with spaces in?).\r\n\r\ntbh, if you're marshalling YAML for data interchange, I'd suggest not using YAML but using JSON instead - it's simple enough that most implrmentations get it right, and it's also compatible (mostly) with YAML.. I'm afraid I don't think that having a global variable that modifies YAML unmarshaling behaviour is a good idea. It means that if you have several packages that use YAML in different ways, they can step on each others' toes. In general, package-level mutable variables should be considered a bad idea.. The current behaviour seems reasonable to me, but I'm open to arguments the other way. Can anyone cite the relevant part of the spec that would allow an unquoted `<<` as a mapping key?. LGTM, thanks.. Closed by #289 . Yes, there are many possible values for boolean, because go-yaml supports YAML 1.1.\r\nSee http://yaml.org/type/bool.html for the full list. I agree that this is not ideal - I've been caught by it many times in the past.\r\n\r\nI think this is essentially a duplicate of #214, so closing in favour of that.. Thanks for this. I updated it slightly before merging.. LGTM; thanks very much.. @alexjh @aarondl What do you think?\r\n. The documentation for \"omitempty\" the qualifier says:\r\n\r\n    Only include the field if it's not set to the zero value for the type \r\n\r\nFalse is the zero of the boolean type. Why is this not expected behaviour?\r\n. ",
    "thockin": "That's what I was trying to avoid doing. :-/\n\nOn Wed, Sep 17, 2014 at 11:32 AM, Gustavo Niemeyer <notifications@github.com\n\n> wrote:\n> \n> Closed #16 https://github.com/go-yaml/yaml/issues/16.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/issues/16#event-166793090.\n. Ah!  I thought Tag was the key.  I did use \"\" and it did work, but I did\nnot know why.\n\nOn Thu, Jul 10, 2014 at 12:08 PM, Gustavo Niemeyer <notifications@github.com\n\n> wrote:\n> \n> You are right, the documentation is definitely lacking. I'm sorry.\n> \n> The tag is a YAML tag: http://yaml.org/spec/1.1/#id858600\n> \n> Since you don't know what it is for, it means you probably don't care, so\n> leaving it empty will likely produce the result you expect.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/issues/18#issuecomment-48649769.\n. That's what I was trying to avoid doing. :-/\n\nOn Wed, Sep 17, 2014 at 11:32 AM, Gustavo Niemeyer <notifications@github.com\n\n> wrote:\n> \n> Closed #16 https://github.com/go-yaml/yaml/issues/16.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/issues/16#event-166793090.\n. Ah!  I thought Tag was the key.  I did use \"\" and it did work, but I did\nnot know why.\n\nOn Thu, Jul 10, 2014 at 12:08 PM, Gustavo Niemeyer <notifications@github.com\n\n> wrote:\n> \n> You are right, the documentation is definitely lacking. I'm sorry.\n> \n> The tag is a YAML tag: http://yaml.org/spec/1.1/#id858600\n> \n> Since you don't know what it is for, it means you probably don't care, so\n> leaving it empty will likely produce the result you expect.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/issues/18#issuecomment-48649769.\n. ",
    "HamOnBry": "+1 too for more examples\n. +1 too for more examples\n. ",
    "luebken": "+1\n(trying to parse a sequence)\n. +1\n(trying to parse a sequence)\n. ",
    "jackspirou": "+1 - More examples would be great.\n\nWhat did help me was to first make a mock struct with example data relevant to what I was trying to do and then marshal/print it out.\n. +1 - More examples would be great.\n\nWhat did help me was to first make a mock struct with example data relevant to what I was trying to do and then marshal/print it out.\n. ",
    "qwertmax": "+1\n. +1\n. ",
    "purpleidea": "+1 (since this seems to be a +1 fest :P -- an example to parse a list of different structs which fill the same interface would be welcomed! )\n. Issue #215  with patch available!! https://github.com/go-yaml/yaml/pull/218 should be part of V3 if not sooner :)\n. @vincentbernat Great tips, I was wondering about both these approaches, and they work great! Small typo, I think you need an = sign:\n\n```\n  var stuff = Stuff{Max: 2147483647, Min: -147483648} # type is infered\n```\n\nThanks again!\n. How do you do this for more complex structs where the sub structs should have a default... Eg:\n\n```\ntype SomeStruct struct {\n    A     string `yaml:\"a\"`\n    Things struct {\n        Foo []*Stuff `yaml:\"foo\"`\n    } `yaml:\"things\"`\n    Comment string `yaml:\"comment\"`\n}\n```\n\nAnd if I want the elements in the Foo array to have defaults...\n. ... It seems it looks like I need to implement the unmarshaler interface... https://godoc.org/gopkg.in/yaml.v2#Unmarshaler and do that per struct... Working on that...\n. @vincentbernat Cool...\n\nSo it seems this:\n\n`type rawStuff Stuff`\n\nis basically an indirection to \"cheat\" and as a result, avoid the infinite recursion I was seeing when I didn't substitute in the temporary \"raw\" type... Is that analysis correct?\n\nIs this the idiomatic pattern for this sort of thing?\n\nThanks again!\n\nPS: This is now two projects that I'm using where I've seen your name pop up. I suppose I owe you a beverage at this point!\n. @niemeyer Is there an example of this that you can point me to? Thanks in advance.\n. @vinzenz This is awesome work, thanks! +1\n. +1 (since this seems to be a +1 fest :P -- an example to parse a list of different structs which fill the same interface would be welcomed! )\n. Issue #215  with patch available!! https://github.com/go-yaml/yaml/pull/218 should be part of V3 if not sooner :)\n. @vincentbernat Great tips, I was wondering about both these approaches, and they work great! Small typo, I think you need an = sign:\n\n```\n  var stuff = Stuff{Max: 2147483647, Min: -147483648} # type is infered\n```\n\nThanks again!\n. How do you do this for more complex structs where the sub structs should have a default... Eg:\n\n```\ntype SomeStruct struct {\n    A     string `yaml:\"a\"`\n    Things struct {\n        Foo []*Stuff `yaml:\"foo\"`\n    } `yaml:\"things\"`\n    Comment string `yaml:\"comment\"`\n}\n```\n\nAnd if I want the elements in the Foo array to have defaults...\n. ... It seems it looks like I need to implement the unmarshaler interface... https://godoc.org/gopkg.in/yaml.v2#Unmarshaler and do that per struct... Working on that...\n. @vincentbernat Cool...\n\nSo it seems this:\n\n`type rawStuff Stuff`\n\nis basically an indirection to \"cheat\" and as a result, avoid the infinite recursion I was seeing when I didn't substitute in the temporary \"raw\" type... Is that analysis correct?\n\nIs this the idiomatic pattern for this sort of thing?\n\nThanks again!\n\nPS: This is now two projects that I'm using where I've seen your name pop up. I suppose I owe you a beverage at this point!\n. @niemeyer Is there an example of this that you can point me to? Thanks in advance.\n. @vinzenz This is awesome work, thanks! +1\n. ",
    "vanloswang": "+1. +1. ",
    "balanatarajan": "@tj  and @niemeyer : Willing to write examples here. Can one of you please help me with samples that would serve as examples? I plan to start off with examples in http://www.yaml.org/spec/1.2/spec.html#id2759572. I know that would be insufficient. Any examples of samples that you need would be appreciated. @niemeyer What is the expected commitment for maintaining this? I can see whether someone in my team would be willing to help as well. @tj  and @niemeyer : Willing to write examples here. Can one of you please help me with samples that would serve as examples? I plan to start off with examples in http://www.yaml.org/spec/1.2/spec.html#id2759572. I know that would be insufficient. Any examples of samples that you need would be appreciated. @niemeyer What is the expected commitment for maintaining this? I can see whether someone in my team would be willing to help as well. ",
    "andrei-m": "+1 - I found this confusing as well.\n. +1 - I found this confusing as well.\n. ",
    "robert-zaremba": "Yes, but it doesn't resolve the issue.\n. Yes, but it doesn't resolve the issue.\n. ",
    "mattes": "run into this as well today\n. ```\n// Example usage:\n//    type T map[yaml.IndexMap0]interface{}\n//    t := T{}\n//    yaml.Unmarshal(data, &t)\n```\n. Ah this patch fixes `decode_test.go` and `encode_test.go` as well.\n. Default branch should be set to master, too?\n. Ah, just read: https://github.com/go-yaml/yaml/blob/master/error.go\nHmm. this is confusing.\n. I think this approach wins! (but requires substantial amount of code changes, I guess). \n. run into this as well today\n. ```\n// Example usage:\n//    type T map[yaml.IndexMap0]interface{}\n//    t := T{}\n//    yaml.Unmarshal(data, &t)\n```\n. Ah this patch fixes `decode_test.go` and `encode_test.go` as well.\n. Default branch should be set to master, too?\n. Ah, just read: https://github.com/go-yaml/yaml/blob/master/error.go\nHmm. this is confusing.\n. I think this approach wins! (but requires substantial amount of code changes, I guess). \n. ",
    "niedbalski": "Gustavo,\n\nI updated the initial issue comment. Sorry for the bad explanation, but would be desirable to being able to have more than one field using the 'omitempty' flag on a structure.\n. Ooops, sorry, my fault, I just noticed that one of the structs i was missing the  yaml: prefix, and just tagging the members with `omitempty`\n\nThanks for your time.\n\nClosing this bug.\n. Gustavo,\n\nI updated the initial issue comment. Sorry for the bad explanation, but would be desirable to being able to have more than one field using the 'omitempty' flag on a structure.\n. Ooops, sorry, my fault, I just noticed that one of the structs i was missing the  yaml: prefix, and just tagging the members with `omitempty`\n\nThanks for your time.\n\nClosing this bug.\n. ",
    "termie": "some other things on this subject: \n\nhttp://pyyaml.org/ticket/29\nhttp://stackoverflow.com/questions/5956473/preserve-key-order-loading-yaml-from-a-file-in-ruby\n\nthanks for looking into it, i feel that human readable formats deserve some ordering expectations even if @ingydotnet never intended them to :p\n. @ingydotnet thanks for the response :) re: JSON, Javascript objects preserve order (for whatever reason) despite not really claiming that they need to so everybody who used JSON from javascript came to expect that, the python implementations of json use OrderedDict-like objects to hold them and I suspect the other languages do as well despite the spec saying that they are unordered.\n\nI agree the \"real\" solution is a schema with preferred order, though in my specific example my use case for ordered results is people defining env variables that might reference other env variables defined before so the schema solution would have to be a list of pairs in a world where map/hash/object order is being randomized\n. @niemeyer I think we may be talking about different things (and I also pointed out the difference between the spec and javascript and said the same thing as you so I don't know whether you missed that and are arguing about something I didn't say).\n\nAnyway, the point for me is that given a yaml file with a map where (arbitrary) keys were entered in a particular order, I would like to be able to, in any way, find out the order that those keys were represented in the yaml file, whether this means a separate index, additional metadata or a different parser hint I am fine with it, hell i'd even be willing to listen for parse events (a la SAX back in the day). If this is possible now I'd be happy to use it, in my investigations I couldn't find a way to get it from go-yaml but I may have missed something.\n. @niemeyer a solution like python's would work fine for me:\n\n(from: https://docs.python.org/2/library/json.html specifically the json.load method)\n\n---snip---\n\nobject_pairs_hook is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of object_pairs_hook will be used instead of the dict. This feature can be used to implement custom decoders that rely on the order that the key and value pairs are decoded (for example, collections.OrderedDict() will remember the order of insertion). If object_hook is also defined, the object_pairs_hook takes priority.\n\n---end snip---\n\nThe specific thing I am trying to solve is:\n\n---snip---\nin my specific example my use case for ordered results is people defining env variables that might reference other env variables defined before\n---endsnip---\n\ntake for example:\n\n{{{\n  actions:\n    - setup_home:\n         USERNAME: %server_variable_username%\n         NEWHOME: /home/$USERNAME\n         WEBDIR: $NEWHOME/www\n}}}\n\nIf we wanted to execute those in a shell as export USERNAME=termie, etc the order would matter.\n\nNow, there are clearly a variety of workarounds if I were allowed to change the format the users input or get them to expand all their variables themselves, but as I can't the ideal situation for me would be to have any information about which order those keys were specified so that I can add them to the environment in the correct order and preserve their expectations.\n. some other things on this subject: \n\nhttp://pyyaml.org/ticket/29\nhttp://stackoverflow.com/questions/5956473/preserve-key-order-loading-yaml-from-a-file-in-ruby\n\nthanks for looking into it, i feel that human readable formats deserve some ordering expectations even if @ingydotnet never intended them to :p\n. @ingydotnet thanks for the response :) re: JSON, Javascript objects preserve order (for whatever reason) despite not really claiming that they need to so everybody who used JSON from javascript came to expect that, the python implementations of json use OrderedDict-like objects to hold them and I suspect the other languages do as well despite the spec saying that they are unordered.\n\nI agree the \"real\" solution is a schema with preferred order, though in my specific example my use case for ordered results is people defining env variables that might reference other env variables defined before so the schema solution would have to be a list of pairs in a world where map/hash/object order is being randomized\n. @niemeyer I think we may be talking about different things (and I also pointed out the difference between the spec and javascript and said the same thing as you so I don't know whether you missed that and are arguing about something I didn't say).\n\nAnyway, the point for me is that given a yaml file with a map where (arbitrary) keys were entered in a particular order, I would like to be able to, in any way, find out the order that those keys were represented in the yaml file, whether this means a separate index, additional metadata or a different parser hint I am fine with it, hell i'd even be willing to listen for parse events (a la SAX back in the day). If this is possible now I'd be happy to use it, in my investigations I couldn't find a way to get it from go-yaml but I may have missed something.\n. @niemeyer a solution like python's would work fine for me:\n\n(from: https://docs.python.org/2/library/json.html specifically the json.load method)\n\n---snip---\n\nobject_pairs_hook is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of object_pairs_hook will be used instead of the dict. This feature can be used to implement custom decoders that rely on the order that the key and value pairs are decoded (for example, collections.OrderedDict() will remember the order of insertion). If object_hook is also defined, the object_pairs_hook takes priority.\n\n---end snip---\n\nThe specific thing I am trying to solve is:\n\n---snip---\nin my specific example my use case for ordered results is people defining env variables that might reference other env variables defined before\n---endsnip---\n\ntake for example:\n\n{{{\n  actions:\n    - setup_home:\n         USERNAME: %server_variable_username%\n         NEWHOME: /home/$USERNAME\n         WEBDIR: $NEWHOME/www\n}}}\n\nIf we wanted to execute those in a shell as export USERNAME=termie, etc the order would matter.\n\nNow, there are clearly a variety of workarounds if I were allowed to change the format the users input or get them to expand all their variables themselves, but as I can't the ideal situation for me would be to have any information about which order those keys were specified so that I can add them to the environment in the correct order and preserve their expectations.\n. ",
    "ingydotnet": "@termie, My YAML implementations always order by default! :P\n\nMy feeling is that key order should be thrown away as late as possible in the Load process, and added (via sort or marshalling code) during the Dump process, when it is known that the data is not already key order ready.\n\nSo YNY (yaml\u2192native\u2192yaml) roundtripping preserves key order in languages that preserve hash key order, and is predictable in languages that don't.\n\nThe long term solution is to process YAML documents according to a \"schema\" specification (document) that includes a preferred sort order for each type.\n\nfwiw, The verbiage in the YAML spec about key ordering was more influenced by Clark and Oren. I think the concept (and other details like it) need to be revisited.\n\nMy basic stance is this:\n1. All YAML processing happens according to a **Schema**.\n2. In 2014 this Schema idea is conceptual. It _could_ be encoded as a (possibly more than one) YAML Schema format. It could be encoded in code. It could be encoded as configuration.\n3. Currently/normally, the Schema for a YAML document is effectively the code in the implementation/processor that is processing it (and the config options used).\n4. The default Schema should be close to the implicit JSON Schema.\n5. Key order and other details should be able to have their effects and desires encoded into a Schema.\n\nBTW, Does JSON make any assertions on key order?\n. A couple minor points:\n\n@termie : The YAML format is intended to to be processed via streaming. `libyaml` is a streaming parser. The Go yaml implementation seems to be a port of it. Cannot Go bind to C libraries? Anyway, SAX style processing is encouraged. It's always sad to me how high YAML aimed to be suitable for, and it has become mostly a config file format (a use case we thought it wasn't the best for :-).\n\n@niemeyer: I for one expect key order preservation from JS and more recent Ruby. I'll often shell out to them for yaml/json processing when I care about key order, because I know they do it. (I've only ever seen one JS implementation that didn't preserve key order. (rhino or spidermonkey or some other dead server-side implementation).\n. @niemeyer It makes sense for JSON to not guarantee order, since many languages are incapable of doing so (without a lot of extra work). I just call out to Node.js to say turn YAML to JSON without botching key order, since I know that Node works that way.\n\nSo I was wondering why you ported libyaml instead of linking to it?\n. @niemeyer, I personally think that YAML does really well in places where humans need to read data, and also write data (though to a lesser degree). YAML is also a full serialization language with a complete type system, references (including circular) and supports any node as a mapping key. Like:\n\n```\n{{a: key}:{a, set, of, values}}\n```\n\n(That's valid YAML, though I suspect very few people would guess correctly what it loads as.)\n\nYAML was designed to work well for non-terminating message streaming and the like. And of course the main goal was cross language data sharing. This was a big goal back in 2001 when we started out, since JSON was not to arrive on the scene until years later. It was a completely huge coincidence that JSON turned out to be a subset of YAML!\n\nre config: We thought it might be too finicky for config files, since tabs aren't allowed and indentation changes meaning. ie, Usage by non-programmers. I think it's great that it gets used for config, but I'd like to see it used for more intense cross-language data purposes. Maybe it's not ready yet.\n\nBTW, I just wrote my first Go code yesterday. :)\n. @niemeyer That's the weird thing. JS/ECMA had nothing to do with the YAML \"flow\" syntax choices. Python (via Clark Evans) was the main influence for that. And it was close enough to Perl, another big influencer. JS wasn't considered. In fact it only got a decent implementation in the past few years. Also I can't even begin to tell you the number of syntax permutations we put on the table. So it really was a pleasant coincidence. There were only a handful of edge cases where JSON was not a strict subset of YAML 1.1, so we \"fixed\" that for YAML 1.2. :)\n\nIf you do IRC, join #yaml on freenode. I'd like to converse about the implicit types. Too much detail to get into here.\n. @termie, My YAML implementations always order by default! :P\n\nMy feeling is that key order should be thrown away as late as possible in the Load process, and added (via sort or marshalling code) during the Dump process, when it is known that the data is not already key order ready.\n\nSo YNY (yaml\u2192native\u2192yaml) roundtripping preserves key order in languages that preserve hash key order, and is predictable in languages that don't.\n\nThe long term solution is to process YAML documents according to a \"schema\" specification (document) that includes a preferred sort order for each type.\n\nfwiw, The verbiage in the YAML spec about key ordering was more influenced by Clark and Oren. I think the concept (and other details like it) need to be revisited.\n\nMy basic stance is this:\n1. All YAML processing happens according to a **Schema**.\n2. In 2014 this Schema idea is conceptual. It _could_ be encoded as a (possibly more than one) YAML Schema format. It could be encoded in code. It could be encoded as configuration.\n3. Currently/normally, the Schema for a YAML document is effectively the code in the implementation/processor that is processing it (and the config options used).\n4. The default Schema should be close to the implicit JSON Schema.\n5. Key order and other details should be able to have their effects and desires encoded into a Schema.\n\nBTW, Does JSON make any assertions on key order?\n. A couple minor points:\n\n@termie : The YAML format is intended to to be processed via streaming. `libyaml` is a streaming parser. The Go yaml implementation seems to be a port of it. Cannot Go bind to C libraries? Anyway, SAX style processing is encouraged. It's always sad to me how high YAML aimed to be suitable for, and it has become mostly a config file format (a use case we thought it wasn't the best for :-).\n\n@niemeyer: I for one expect key order preservation from JS and more recent Ruby. I'll often shell out to them for yaml/json processing when I care about key order, because I know they do it. (I've only ever seen one JS implementation that didn't preserve key order. (rhino or spidermonkey or some other dead server-side implementation).\n. @niemeyer It makes sense for JSON to not guarantee order, since many languages are incapable of doing so (without a lot of extra work). I just call out to Node.js to say turn YAML to JSON without botching key order, since I know that Node works that way.\n\nSo I was wondering why you ported libyaml instead of linking to it?\n. @niemeyer, I personally think that YAML does really well in places where humans need to read data, and also write data (though to a lesser degree). YAML is also a full serialization language with a complete type system, references (including circular) and supports any node as a mapping key. Like:\n\n```\n{{a: key}:{a, set, of, values}}\n```\n\n(That's valid YAML, though I suspect very few people would guess correctly what it loads as.)\n\nYAML was designed to work well for non-terminating message streaming and the like. And of course the main goal was cross language data sharing. This was a big goal back in 2001 when we started out, since JSON was not to arrive on the scene until years later. It was a completely huge coincidence that JSON turned out to be a subset of YAML!\n\nre config: We thought it might be too finicky for config files, since tabs aren't allowed and indentation changes meaning. ie, Usage by non-programmers. I think it's great that it gets used for config, but I'd like to see it used for more intense cross-language data purposes. Maybe it's not ready yet.\n\nBTW, I just wrote my first Go code yesterday. :)\n. @niemeyer That's the weird thing. JS/ECMA had nothing to do with the YAML \"flow\" syntax choices. Python (via Clark Evans) was the main influence for that. And it was close enough to Perl, another big influencer. JS wasn't considered. In fact it only got a decent implementation in the past few years. Also I can't even begin to tell you the number of syntax permutations we put on the table. So it really was a pleasant coincidence. There were only a handful of edge cases where JSON was not a strict subset of YAML 1.1, so we \"fixed\" that for YAML 1.2. :)\n\nIf you do IRC, join #yaml on freenode. I'd like to converse about the implicit types. Too much detail to get into here.\n. ",
    "natefinch": "The problem is definitely the 2222:22 value... I can reduce it to just this part of the yaml:\n\n``` yaml\nexpose:\n- 80:80\n- 2222:22\n```\n\nyaml.v1 can loop this data through its parser no problem, as this program indicates:\nhttp://pastebin.ubuntu.com/8357053/\n\nHowever, it seems other parsers have more difficulty.  All the other parsers I could find convert it into this value:\n\n``` yaml\nexpose: \n  - \"80:80\"\n  - 133342\n```\n\nHere's a list of online validators that I tried:\nhttp://yaml-online-parser.appspot.com/ \nhttp://YAMLlint.com\nhttp://instantyaml.appspot.com/\nhttp://nodeca.github.io/js-yaml/\n\nMaybe they're all using the same flawed library, I don't know.  But it seems suspicious that these, and whatever discourse is using, and PyYaml all have problems.\n. This still seems like a bug.  It means the output in this case is incorrect as far as other yaml 1.1 parsers are concerned.  While I don't think it's super important to support base 60 floats, it still seems important to make goyaml's output compatible with other parsers for something like a generic string that happens to look like a base 60 float.   Always quoting the string if it contains a colon would a trivial fix to ensure that the output is correctly interpreted by other parsers.\n. Awesome, thanks!\n. The problem is definitely the 2222:22 value... I can reduce it to just this part of the yaml:\n\n``` yaml\nexpose:\n- 80:80\n- 2222:22\n```\n\nyaml.v1 can loop this data through its parser no problem, as this program indicates:\nhttp://pastebin.ubuntu.com/8357053/\n\nHowever, it seems other parsers have more difficulty.  All the other parsers I could find convert it into this value:\n\n``` yaml\nexpose: \n  - \"80:80\"\n  - 133342\n```\n\nHere's a list of online validators that I tried:\nhttp://yaml-online-parser.appspot.com/ \nhttp://YAMLlint.com\nhttp://instantyaml.appspot.com/\nhttp://nodeca.github.io/js-yaml/\n\nMaybe they're all using the same flawed library, I don't know.  But it seems suspicious that these, and whatever discourse is using, and PyYaml all have problems.\n. This still seems like a bug.  It means the output in this case is incorrect as far as other yaml 1.1 parsers are concerned.  While I don't think it's super important to support base 60 floats, it still seems important to make goyaml's output compatible with other parsers for something like a generic string that happens to look like a base 60 float.   Always quoting the string if it contains a colon would a trivial fix to ensure that the output is correctly interpreted by other parsers.\n. Awesome, thanks!\n. ",
    "rnix": ":+1: Sorry, I know: RTFM @rnix :gun: \n. :+1: Sorry, I know: RTFM @rnix :gun: \n. ",
    "nictuku": "Nice. This would allow easy serialization of net.IP. Are you planning to add this to v1 also or only v2?\n. If someone would contribute to this, would you take PRs for v1 or only v2?\n. Thanks for doing it so quickly :).\n. ah, never mind. \n. @niemeyer next time, consider assigning the issue to indicate you're working on it.\n. Nice. This would allow easy serialization of net.IP. Are you planning to add this to v1 also or only v2?\n. If someone would contribute to this, would you take PRs for v1 or only v2?\n. Thanks for doing it so quickly :).\n. ah, never mind. \n. @niemeyer next time, consider assigning the issue to indicate you're working on it.\n. ",
    "advance512": "Is this considerably different from the support that already exists for TextMarshaler/TextUnmarshaler?\n\nWhat use cases does this have?\n. Note that your YAML is equivalent to:\n\n```\ncurrent: batman\noptions: { batman: something, robin: another }\n```\n\nYou are trying to unmarshal a YAML mapping into a Go slice. You could try this with:\n\n```\ncurrent: batman\noptions:\n  - batman: something\n  - robin: another\n```\n\nBut it still won't work. The problem lies in that the yaml lib looks in Target for a field name 'batman' or 'robin' to put the values into, and of course none exists. (inline only affects structs contained by other structs and isn't relevant here afaik.)\n\nThe problem is that the slice is of the element type Target. Change it to:\n\n```\ntype Target map[string]string\n```\n\nAnd things will start working. Or, use this kind of YAML:\n\n```\ncurrent: batman\noptions:\n  - label: batman\n    endpoint: something\n  - label: robin\n    endpoint: another\n```\n. Please note that the tests won't work since decode_tests.go imports \"gopkg.in/yaml.v2\" instead of \"github.com/advance512/yaml\" which has the regexp flag.\n\nChange it temporarily to \"github.com/advance512/yaml\" to see it in action.\n. Any update on this? \n. Hi,\n1. I signed the agreement.\n2. The bug was actually already fixed in #52 (and #58, and here, https://github.com/advance512/yaml/commit/e401b2b026855a4fa8e7014d553ae5bdfccb21cd#diff-e51f89b39d976550831afb510a926be0L93, too), and though it allowed calling unmarshal() multiples times in theory, it prevented it in practice (if any of the calls failed).\n3. The 3 actual code changes in the big commit are:\n   - Fix of the bug already fixed in #52\n   - More strict handling of badly formatted YAML tags (https://github.com/advance512/yaml/commit/e401b2b026855a4fa8e7014d553ae5bdfccb21cd#diff-e51f89b39d976550831afb510a926be0R338)\n   - Add support for Regexp /matching/, not validation. \n     I agree I should have split the changes into several different commits. Noted for next time.\n4. The rest of the changes are mostly improved documentation and code comments, and some formatting fixes (a la gofmt).\n\nRegarding the Regexp matching, I think it is a very useful feature. Here's a concrete use case: a RAML parser, RAML being a YAML-based language that describes RESTful APIs. Study the following example RAML document:\n\n```\n#%RAML 0.8\ntitle: GitHub API\nversion: v3\nbaseUri: https://api.github.com\n/gists:\n  displayName: Gists\n  /public:\n    displayName: Public Gists\n```\n\nAs the RAML [spec](http://raml.org/spec.html#resources-and-nested-resources) specifies:\n\n  _Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property._\n\nSo, using the existing code base - how do you unmarshal the document root mapping (which contains: title, version, baseUri and the various resource properties) into a struct? What would /gists map into? A field? Or into a map/slice? How would the go-yaml tag look? Please advice.\n\nOne way to go would be to unmarshal into trees of map[interface{}]interface{}, and then run over them and manually parse them and create the go-raml data structure. That, besides being very inelegant, defeats the point of unmarshaling into specific types. I assume that isn't what you meant when you referred to custom logic.\n\nI could not have written the [go-raml parser](https://github.com/go-raml/raml) without the regexp matching feature.\n. This works:\n\n``` go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n\n    \"gopkg.in/yaml.v2\"\n)\n\ntype A struct {\n    ValueA int `json:\"a\" yaml:\"a\"`\n}\ntype B struct {\n    A      `yaml:\",inline\"`\n    ValueB int `json:\"b\" yaml:\"b\"`\n}\n\nconst jsonData = `{ \"a\" : 1, \"b\" : 2 }`\nconst yamlData = `\na : 1\nb : 2\n`\n\nfunc main() {\n    jdata := B{}\n    ydata := B{}\n\n    json.Unmarshal([]byte(jsonData), &jdata)\n    yaml.Unmarshal([]byte(yamlData), &ydata)\n\n    // $ go run main.go\n    // json: {{1} 2}\n    // yaml: {{1} 2}\n    fmt.Printf(\"json: %v\\n\", jdata)\n    fmt.Printf(\"yaml: %v\\n\", ydata)\n}\n```\n. (I just added a tag on the A anonymous field.) Whether or not this is \"good behavior\" or not depends. I agree that, generally, go-yaml should work in a similar way to go-json. In this case, however, I don't really like the way go-json works - it just seems too \"magicky\".\n\nThat being said, adding `yaml:\",inline\"` isn't a pretty solution either.\n. On second thought, perhaps setting anonymous fields to automatically be \"inline\" does make sense. \n. @bcronin - go-yaml uses pkg.in to offer the standardized package versioning you speak of.\n\nYou'll notice the correct way to import the library is:\n\n```\nimport \"gopkg.in/yaml.v2\"\n```\n\nwhich means - version 2. It would be very easy to create a new branch, let's call it - v3, and break backwards compatibility there. No one would expect it to work like v2, just like no one expects v2 to work exactly like v1.\n\nSo, even though I agree with @niemeyer about the existing behavior being nicer (in my opinion), I don't his comment about breaking backwards compatibility. Just that this change probably doesn't warrant a v3 on its own.\n. I've been trying to rebase advance512/yaml on the latest version, and I've noticed this too in my own fork. \n+1 merge in\n. Is this considerably different from the support that already exists for TextMarshaler/TextUnmarshaler?\n\nWhat use cases does this have?\n. Note that your YAML is equivalent to:\n\n```\ncurrent: batman\noptions: { batman: something, robin: another }\n```\n\nYou are trying to unmarshal a YAML mapping into a Go slice. You could try this with:\n\n```\ncurrent: batman\noptions:\n  - batman: something\n  - robin: another\n```\n\nBut it still won't work. The problem lies in that the yaml lib looks in Target for a field name 'batman' or 'robin' to put the values into, and of course none exists. (inline only affects structs contained by other structs and isn't relevant here afaik.)\n\nThe problem is that the slice is of the element type Target. Change it to:\n\n```\ntype Target map[string]string\n```\n\nAnd things will start working. Or, use this kind of YAML:\n\n```\ncurrent: batman\noptions:\n  - label: batman\n    endpoint: something\n  - label: robin\n    endpoint: another\n```\n. Please note that the tests won't work since decode_tests.go imports \"gopkg.in/yaml.v2\" instead of \"github.com/advance512/yaml\" which has the regexp flag.\n\nChange it temporarily to \"github.com/advance512/yaml\" to see it in action.\n. Any update on this? \n. Hi,\n1. I signed the agreement.\n2. The bug was actually already fixed in #52 (and #58, and here, https://github.com/advance512/yaml/commit/e401b2b026855a4fa8e7014d553ae5bdfccb21cd#diff-e51f89b39d976550831afb510a926be0L93, too), and though it allowed calling unmarshal() multiples times in theory, it prevented it in practice (if any of the calls failed).\n3. The 3 actual code changes in the big commit are:\n   - Fix of the bug already fixed in #52\n   - More strict handling of badly formatted YAML tags (https://github.com/advance512/yaml/commit/e401b2b026855a4fa8e7014d553ae5bdfccb21cd#diff-e51f89b39d976550831afb510a926be0R338)\n   - Add support for Regexp /matching/, not validation. \n     I agree I should have split the changes into several different commits. Noted for next time.\n4. The rest of the changes are mostly improved documentation and code comments, and some formatting fixes (a la gofmt).\n\nRegarding the Regexp matching, I think it is a very useful feature. Here's a concrete use case: a RAML parser, RAML being a YAML-based language that describes RESTful APIs. Study the following example RAML document:\n\n```\n#%RAML 0.8\ntitle: GitHub API\nversion: v3\nbaseUri: https://api.github.com\n/gists:\n  displayName: Gists\n  /public:\n    displayName: Public Gists\n```\n\nAs the RAML [spec](http://raml.org/spec.html#resources-and-nested-resources) specifies:\n\n  _Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property._\n\nSo, using the existing code base - how do you unmarshal the document root mapping (which contains: title, version, baseUri and the various resource properties) into a struct? What would /gists map into? A field? Or into a map/slice? How would the go-yaml tag look? Please advice.\n\nOne way to go would be to unmarshal into trees of map[interface{}]interface{}, and then run over them and manually parse them and create the go-raml data structure. That, besides being very inelegant, defeats the point of unmarshaling into specific types. I assume that isn't what you meant when you referred to custom logic.\n\nI could not have written the [go-raml parser](https://github.com/go-raml/raml) without the regexp matching feature.\n. This works:\n\n``` go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n\n    \"gopkg.in/yaml.v2\"\n)\n\ntype A struct {\n    ValueA int `json:\"a\" yaml:\"a\"`\n}\ntype B struct {\n    A      `yaml:\",inline\"`\n    ValueB int `json:\"b\" yaml:\"b\"`\n}\n\nconst jsonData = `{ \"a\" : 1, \"b\" : 2 }`\nconst yamlData = `\na : 1\nb : 2\n`\n\nfunc main() {\n    jdata := B{}\n    ydata := B{}\n\n    json.Unmarshal([]byte(jsonData), &jdata)\n    yaml.Unmarshal([]byte(yamlData), &ydata)\n\n    // $ go run main.go\n    // json: {{1} 2}\n    // yaml: {{1} 2}\n    fmt.Printf(\"json: %v\\n\", jdata)\n    fmt.Printf(\"yaml: %v\\n\", ydata)\n}\n```\n. (I just added a tag on the A anonymous field.) Whether or not this is \"good behavior\" or not depends. I agree that, generally, go-yaml should work in a similar way to go-json. In this case, however, I don't really like the way go-json works - it just seems too \"magicky\".\n\nThat being said, adding `yaml:\",inline\"` isn't a pretty solution either.\n. On second thought, perhaps setting anonymous fields to automatically be \"inline\" does make sense. \n. @bcronin - go-yaml uses pkg.in to offer the standardized package versioning you speak of.\n\nYou'll notice the correct way to import the library is:\n\n```\nimport \"gopkg.in/yaml.v2\"\n```\n\nwhich means - version 2. It would be very easy to create a new branch, let's call it - v3, and break backwards compatibility there. No one would expect it to work like v2, just like no one expects v2 to work exactly like v1.\n\nSo, even though I agree with @niemeyer about the existing behavior being nicer (in my opinion), I don't his comment about breaking backwards compatibility. Just that this change probably doesn't warrant a v3 on its own.\n. I've been trying to rebase advance512/yaml on the latest version, and I've noticed this too in my own fork. \n+1 merge in\n. ",
    "kagb": "I met this problem and solved it by this command:\n`git config --global http.sslVerify true`\n\nOpen your git verfiy config for https\n. I met this problem and solved it by this command:\n`git config --global http.sslVerify true`\n\nOpen your git verfiy config for https\n. ",
    "erjoalgo": "package main\n\nimport (\n    \"gopkg.in/yaml.v2\"\n    \"fmt\"\n)\n\ntype Parent struct  {\n    Name string \n    MaybeChild Child `yaml:\",inline,omitempty\"` //should only be included if non-zero\n}\ntype Child struct   {\n    Property1, Property2 string\n}\nfunc marshalyaml ( y interface{} ) string   {\n    str, err := yaml.Marshal(y)\n    if err != nil   {\n        fmt.Printf( \"error marshalling: %s\\n\", err )\n    }\n    return string(str)\n}\nfunc main (  )  {\n    parentWithChild := Parent{MaybeChild:Child{\"prop1\", \"prop2\"}, Name:\"parent with child\"}\n    parentNoChild := Parent{Name:\"parent without child\"}\n\n```\nfmt.Printf( \"%s\\n\", marshalyaml(parentWithChild) )\nfmt.Printf( \"%s\\n\", marshalyaml(parentNoChild) )\n```\n\n}\n. output:\n\nname: parent with child\nproperty1: prop1\nproperty2: prop2\n\nname: parent without child\nproperty1: \"\"\nproperty2: \"\"\n. expected: second yaml should not include zero-valued Child struct\n. package main\n\nimport (\n    \"gopkg.in/yaml.v2\"\n    \"fmt\"\n)\n\ntype Parent struct  {\n    Name string \n    MaybeChild Child `yaml:\",inline,omitempty\"` //should only be included if non-zero\n}\ntype Child struct   {\n    Property1, Property2 string\n}\nfunc marshalyaml ( y interface{} ) string   {\n    str, err := yaml.Marshal(y)\n    if err != nil   {\n        fmt.Printf( \"error marshalling: %s\\n\", err )\n    }\n    return string(str)\n}\nfunc main (  )  {\n    parentWithChild := Parent{MaybeChild:Child{\"prop1\", \"prop2\"}, Name:\"parent with child\"}\n    parentNoChild := Parent{Name:\"parent without child\"}\n\n```\nfmt.Printf( \"%s\\n\", marshalyaml(parentWithChild) )\nfmt.Printf( \"%s\\n\", marshalyaml(parentNoChild) )\n```\n\n}\n. output:\n\nname: parent with child\nproperty1: prop1\nproperty2: prop2\n\nname: parent without child\nproperty1: \"\"\nproperty2: \"\"\n. expected: second yaml should not include zero-valued Child struct\n. ",
    "dougrad": "OK, I had missed the \",inline\" option - that does fix it.  But it's still an unexpected difference from xml / json encoding and should probably be the default.\n. OK, I had missed the \",inline\" option - that does fix it.  But it's still an unexpected difference from xml / json encoding and should probably be the default.\n. ",
    "cpliakas": "@dougrad This saved me a bunch of time, and protected the remaining hair I have left :-). Thanks for posting the solution!. @dougrad This saved me a bunch of time, and protected the remaining hair I have left :-). Thanks for posting the solution!. ",
    "liggitt": "output of the test case:\n\n```\n$ go run yaml.go \n\nTesting loss of precision\n=======================================\nOriginal (base-2):      1010101101010100101010011000110011101011000111110000101011010010\nOriginal (base-10):     12345678901234567890\n\nMarshalled YAML:     x: 12345678901234567890\n\nUnmarshalled (base-2):  1010101101010100101010011000110011101011000111110000100000000000\nUnmarshalled (base-10): 12345678901234567168\n\n\nTesting uint64 max\n=======================================\nOriginal (base-2):      1111111111111111111111111111111111111111111111111111111111111111\nOriginal (base-10):     18446744073709551615\n\nMarshalled YAML:     x: 18446744073709551615\n\nUnmarshalled (base-2):  0\nUnmarshalled (base-10): 0\n```\n. @niemeyer ok, I'll open a PR against v2 if you want to wait a minute before commenting...\n. See https://github.com/go-yaml/yaml/pull/51\n. @niemeyer removed uint cases, left uint64 handling. Also inlined testcases as literal values to make it easier to follow, and added 64-bit support to the binary int decoding.\n. @niemeyer ready for merge\n. Let me check, and I'll let you know as soon as I get the go ahead\n. No problem, I'll update as soon as I can\n. Haven't forgotten... still waiting to hear back, sorry\n. @niemeyer just got approval and signed the contributor agreement. Sorry for the delay.\n. @niemeyer you want me to open another PR or do you want to re-open/merge this one?\n. @niemeyer thanks... I'd already spawned #53, in case that makes it easier\n. @niemeyer bump.. anything you want updated on my end?\n. output of the test case:\n\n```\n$ go run yaml.go \n\nTesting loss of precision\n=======================================\nOriginal (base-2):      1010101101010100101010011000110011101011000111110000101011010010\nOriginal (base-10):     12345678901234567890\n\nMarshalled YAML:     x: 12345678901234567890\n\nUnmarshalled (base-2):  1010101101010100101010011000110011101011000111110000100000000000\nUnmarshalled (base-10): 12345678901234567168\n\n\nTesting uint64 max\n=======================================\nOriginal (base-2):      1111111111111111111111111111111111111111111111111111111111111111\nOriginal (base-10):     18446744073709551615\n\nMarshalled YAML:     x: 18446744073709551615\n\nUnmarshalled (base-2):  0\nUnmarshalled (base-10): 0\n```\n. @niemeyer ok, I'll open a PR against v2 if you want to wait a minute before commenting...\n. See https://github.com/go-yaml/yaml/pull/51\n. @niemeyer removed uint cases, left uint64 handling. Also inlined testcases as literal values to make it easier to follow, and added 64-bit support to the binary int decoding.\n. @niemeyer ready for merge\n. Let me check, and I'll let you know as soon as I get the go ahead\n. No problem, I'll update as soon as I can\n. Haven't forgotten... still waiting to hear back, sorry\n. @niemeyer just got approval and signed the contributor agreement. Sorry for the delay.\n. @niemeyer you want me to open another PR or do you want to re-open/merge this one?\n. @niemeyer thanks... I'd already spawned #53, in case that makes it easier\n. @niemeyer bump.. anything you want updated on my end?\n. ",
    "BrianBland": "Ok, I've added a test which fails before the patch and signed the agreement.\n. Can I get an update on this PR? Thanks.\n. Ok, I've added a test which fails before the patch and signed the agreement.\n. Can I get an update on this PR? Thanks.\n. ",
    "stevvooe": "@niemeyer Ping!\n. @niemeyer Thank you!\n. @niemeyer Ping!\n. @niemeyer Thank you!\n. ",
    "rabarar": "Why isn't it right - it worked when I added it?\n\n> On Nov 14, 2014, at 4:29 AM, Gustavo Niemeyer notifications@github.com wrote:\n> \n> The code isn't right, but the idea is fine.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. And I should have said it earlier, thanks for sharing yaml! It's great stuff!!\n\n> On Nov 14, 2014, at 4:29 AM, Gustavo Niemeyer notifications@github.com wrote:\n> \n> The code isn't right, but the idea is fine.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Thanks\n\n> On Jan 16, 2015, at 1:46 PM, Gustavo Niemeyer notifications@github.com wrote:\n> \n> Closed #54 via 26b8825.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Why isn't it right - it worked when I added it?\n\n> On Nov 14, 2014, at 4:29 AM, Gustavo Niemeyer notifications@github.com wrote:\n> \n> The code isn't right, but the idea is fine.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. And I should have said it earlier, thanks for sharing yaml! It's great stuff!!\n\n> On Nov 14, 2014, at 4:29 AM, Gustavo Niemeyer notifications@github.com wrote:\n> \n> The code isn't right, but the idea is fine.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Thanks\n\n> On Jan 16, 2015, at 1:46 PM, Gustavo Niemeyer notifications@github.com wrote:\n> \n> Closed #54 via 26b8825.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "ghodss": "> I don't understand why \"\" would result in calling an unmarshaler while an implicit \"\" would not. This is very inconsistent. I'm happy to fix the bug, but not like that.\n\nBecause an empty string is not the same as null in Go. How do you propose fixing it instead?\n\n> Given the discussion in that ticket referenced above, I'm assuming are not interested in contributing to the project anymore, and will close this and fix the bug.\n\nAs I commented, we are still using go-yaml/yaml for parsing YAML, but not for marshaling/unmarshaling. If the behavior were made to be more strongly consistent with how Golang marshals and unmarshals, we would consider switching back.\n. My bad, I got caught up with a few things - I will definitely take care of\nthis within the next day. Thanks!\n\nOn Tue, Jan 20, 2015 at 10:51 AM, Gustavo Niemeyer <notifications@github.com\n\n> wrote:\n> \n> Ping?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/pull/57#issuecomment-70709482.\n\n## \n\nSam\n. I rebased and had some issues - I will update the commits here shortly as soon as I get a moment to fix it up.\n. @niemeyer, can you reopen the issue? I updated my `ghodss:fix-unmarshal-yaml` branch with the changes but I think the changes may not show up in this PR until it's reopened.\n. Also I believe I signed the agreement, let me know if it came through okay.\n. I figured out what was happening - I was doing development in github.com/go-yaml/yaml, but the test files in that directory were referring to the gopkg.in/yaml.v2 package in my GOPATH. I suppose the right way to do this is to do all development in the gopkg.in/yaml.v2 package.\n. @vinzenz What is the latest on this PR? Is it up to date with the latest commits? Is it ready to be merged if we can get it reviewed?. > I don't understand why \"\" would result in calling an unmarshaler while an implicit \"\" would not. This is very inconsistent. I'm happy to fix the bug, but not like that.\n\nBecause an empty string is not the same as null in Go. How do you propose fixing it instead?\n\n> Given the discussion in that ticket referenced above, I'm assuming are not interested in contributing to the project anymore, and will close this and fix the bug.\n\nAs I commented, we are still using go-yaml/yaml for parsing YAML, but not for marshaling/unmarshaling. If the behavior were made to be more strongly consistent with how Golang marshals and unmarshals, we would consider switching back.\n. My bad, I got caught up with a few things - I will definitely take care of\nthis within the next day. Thanks!\n\nOn Tue, Jan 20, 2015 at 10:51 AM, Gustavo Niemeyer <notifications@github.com\n\n> wrote:\n> \n> Ping?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-yaml/yaml/pull/57#issuecomment-70709482.\n\n## \n\nSam\n. I rebased and had some issues - I will update the commits here shortly as soon as I get a moment to fix it up.\n. @niemeyer, can you reopen the issue? I updated my `ghodss:fix-unmarshal-yaml` branch with the changes but I think the changes may not show up in this PR until it's reopened.\n. Also I believe I signed the agreement, let me know if it came through okay.\n. I figured out what was happening - I was doing development in github.com/go-yaml/yaml, but the test files in that directory were referring to the gopkg.in/yaml.v2 package in my GOPATH. I suppose the right way to do this is to do all development in the gopkg.in/yaml.v2 package.\n. @vinzenz What is the latest on this PR? Is it up to date with the latest commits? Is it ready to be merged if we can get it reviewed?. ",
    "albertoleal": "Great, thank you a lot!\n. Great, thank you a lot!\n. ",
    "bcronin": "The backward compatibility issue is certainly an important consideration.  Thanks for the explanation.\n\n(Tangential aside not directly related to go-yaml: I wish Go had a standardized package versioning mechanism so that a backwards incompatible change like this could be considered and still rolled out smoothly without unexpectedly interfering with the existing users of the library.)\n\n@niemeyer Thanks for your work on this library, by the way. It's much appreciated.\n. The backward compatibility issue is certainly an important consideration.  Thanks for the explanation.\n\n(Tangential aside not directly related to go-yaml: I wish Go had a standardized package versioning mechanism so that a backwards incompatible change like this could be considered and still rolled out smoothly without unexpectedly interfering with the existing users of the library.)\n\n@niemeyer Thanks for your work on this library, by the way. It's much appreciated.\n. ",
    "coxx": "Oops, there is pull request (https://github.com/go-yaml/yaml/pull/64) that doing exactly the same.\n. Oops, there is pull request (https://github.com/go-yaml/yaml/pull/64) that doing exactly the same.\n. ",
    "kisielk": "I was a bit lazy with the example, should have put some keys in the dictionaries :)\n\nAnyway according to the spec *bar should only be used in future occurrences after &bar, see http://www.yaml.org/spec/1.2/spec.html#id2785586\n\nWe had some real cases where this caused problems, there were yaml files we were using with Go programs that worked fine but the same files would fail to parse with the Python yaml parser which was more true to the spec. A fairly easy fix of course but since our Go tools will never warn us about this error in the future there's the chance it will happen again.\n. I was a bit lazy with the example, should have put some keys in the dictionaries :)\n\nAnyway according to the spec *bar should only be used in future occurrences after &bar, see http://www.yaml.org/spec/1.2/spec.html#id2785586\n\nWe had some real cases where this caused problems, there were yaml files we were using with Go programs that worked fine but the same files would fail to parse with the Python yaml parser which was more true to the spec. A fairly easy fix of course but since our Go tools will never warn us about this error in the future there's the chance it will happen again.\n. ",
    "vrecan": "Oh sorry, thanks for the help!\n. Oh sorry, thanks for the help!\n. ",
    "gogolok": "@niemeyer I've changed the example\n. @niemeyer I've changed the example\n. ",
    "bronze1man": "Thanks for your feedback.\nI have to use my own fork right now.\n. Thanks for your feedback.\nI have to use my own fork right now.\n. ",
    "charleslaw": "I believe it is a http://yaml.org/spec/1.2/spec.html#id2785512 tag issue.  Changing ! to !yaml! also works.\n. I believe it is a http://yaml.org/spec/1.2/spec.html#id2785512 tag issue.  Changing ! to !yaml! also works.\n. ",
    "andreychernih": "This bugs me too :+1: \n. This bugs me too :+1: \n. ",
    "hashmap": "Pull request has been submitted https://github.com/go-yaml/yaml/pull/133\n. Pull request has been submitted https://github.com/go-yaml/yaml/pull/133\n. ",
    "emosbaugh": "+1\n. +1\n. +1\n. +1\n. +1\n. +1\n. ",
    "geofffranks": "It's been a year, and this hasn't been merged, or really discussed. Is there a timeline for getting this fixed?\n. I would love to see this merged as well\n. It's been a year, and this hasn't been merged, or really discussed. Is there a timeline for getting this fixed?\n. I would love to see this merged as well\n. ",
    "nmiyake": "+1 -- ran into this issue as well and confirmed that the PR that is currently open resolves this issue. This seems strictly better/more correct from a correctness standpoint. Is there any reason that this issue/PR isn't being advanced?. If this issue is still being considered at any level, then another item I would add is to add support for marshalling `json.Number` objects as numbers rather than as strings to match the behavior of `encoding/json`.\r\n\r\nHere's an example program that demonstrates the difference in behavior between `yaml.v2` and `encoding/json`:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"strings\"\r\n\r\n\t\"gopkg.in/yaml.v2\"\r\n)\r\n\r\nfunc main() {\r\n\tjsonObj := `{\"num\":13}`\r\n\r\n\tdecoder := json.NewDecoder(strings.NewReader(jsonObj))\r\n\tdecoder.UseNumber()\r\n\r\n\tvar unmarshalled map[string]interface{}\r\n\tif err := decoder.Decode(&unmarshalled); err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Printf(\"%+v\\n\", unmarshalled)       // map[num:13]\r\n\tfmt.Printf(\"%T\\n\", unmarshalled[\"num\"]) // json.Number\r\n\r\n\tbytes, err := json.Marshal(unmarshalled)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Println(string(bytes)) // {\"num\":13}\r\n\r\n\tbytes, err = yaml.Marshal(unmarshalled)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Println(string(bytes)) // num: \"13\"\r\n}\r\n```\r\n\r\nThe desired behavior would be for the last line to output `num: 13` rather than `num: \"13\"`.. #231 is another open issue having to do with making the behavior more consistent with `encoding/json`.. Happy to do a pass on some of these things -- we make extensive use of this library and find it very valuable and would love to see some more movement on some of the open issues/PRs.\r\n\r\nWhat's the best way to flag issues that should be closed? Is there someone I can `@` to flag to who can close out things that are stale/resolved?. +1 -- ran into this issue as well and confirmed that the PR that is currently open resolves this issue. This seems strictly better/more correct from a correctness standpoint. Is there any reason that this issue/PR isn't being advanced?. If this issue is still being considered at any level, then another item I would add is to add support for marshalling `json.Number` objects as numbers rather than as strings to match the behavior of `encoding/json`.\r\n\r\nHere's an example program that demonstrates the difference in behavior between `yaml.v2` and `encoding/json`:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"strings\"\r\n\r\n\t\"gopkg.in/yaml.v2\"\r\n)\r\n\r\nfunc main() {\r\n\tjsonObj := `{\"num\":13}`\r\n\r\n\tdecoder := json.NewDecoder(strings.NewReader(jsonObj))\r\n\tdecoder.UseNumber()\r\n\r\n\tvar unmarshalled map[string]interface{}\r\n\tif err := decoder.Decode(&unmarshalled); err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Printf(\"%+v\\n\", unmarshalled)       // map[num:13]\r\n\tfmt.Printf(\"%T\\n\", unmarshalled[\"num\"]) // json.Number\r\n\r\n\tbytes, err := json.Marshal(unmarshalled)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Println(string(bytes)) // {\"num\":13}\r\n\r\n\tbytes, err = yaml.Marshal(unmarshalled)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Println(string(bytes)) // num: \"13\"\r\n}\r\n```\r\n\r\nThe desired behavior would be for the last line to output `num: 13` rather than `num: \"13\"`.. #231 is another open issue having to do with making the behavior more consistent with `encoding/json`.. Happy to do a pass on some of these things -- we make extensive use of this library and find it very valuable and would love to see some more movement on some of the open issues/PRs.\r\n\r\nWhat's the best way to flag issues that should be closed? Is there someone I can `@` to flag to who can close out things that are stale/resolved?. ",
    "igorwwwwwwwwwwwwwwwwwwww": "Just ran into this too, any updates?. Just ran into this too, any updates?. ",
    "robx": "Compare http://play.golang.org/p/a65jCwme9y\n. Whatever.\n. Compare http://play.golang.org/p/a65jCwme9y\n. Whatever.\n. ",
    "nqv": "Working with `inline` flag. This should be in README somewhere\n\n``` go\ntype T struct {\n    B `yaml:\",inline\"`\n}\n```\n. Working with `inline` flag. This should be in README somewhere\n\n``` go\ntype T struct {\n    B `yaml:\",inline\"`\n}\n```\n. ",
    "crawford": "Bump. Is this not the appropriate place to submit patches?\n. The particular case that I had in mind was unmarshalling cloud-configs, where `-` and `_` can be used interchangeably. Using yaml.Unmarshaler seems like it would be very cumbersome. Unless I am mistaken, all non-leaf elements would need to have a custom Unmarshaler, in which it would need to unmarshal into a map as an intermediate step. I want to avoid using a map altogether since that basically throws away the type system. I depend heavily on the structured types in order to validate user input.\n\nI agree that applying transforms to YAML keys is fairly uncommon, but I couldn't think of a better way to solve this issue.\n. My first implementation was almost exactly what you suggested. This doesn't work unfortunately because of YAML's type coercion. Consider the following example:\n\n``` yaml\nperson:\n  name: crawford\n  nick: off\n  phone: 0123456701\n```\n\nIf I were to unmarshal this into a map I would get the following:\n\n``` go\nmap[interface{}]interface{} {\n    \"person\": map[interface{}]interface{} {\n        \"name\":  \"crawford\",\n        \"nick\":  \"false\",\n        \"phone\": 21913025,\n    },\n}\n```\n\ninstead of:\n\n``` go\nPerson {\n    Name:  \"crawford\",\n    Nick:  \"off\",\n    Phone: \"0123456701\",\n}\n```\n\nYes this is a little contrived, but it illustrates two problems we have actually run into. Without a type to unmarshal into, and because YAML doesn't require quotes around strings, the parser chooses the most likely type (a boolean for the nick and an integer for the phone number) which is incorrect in this particular case. We need to hint to the parser which type to use when unmarshalling each value. Of course, the easy solution is to just write correct YAML in the first place, but unfortunately this is user provided.\n. > saying that the YAML doesn't require quotes to interpret \"off\" as a string isn't correct\n\nI never said that. I said \"YAML doesn't require quotes around strings\" which is absolutely true.\n\n> There's only one type the YAML should be read as, and the package is doing that job correctly.\n\nBut there is a difference in behavior between unmarshalling into a typed container vs an untyped container. This is the underlying problem.\n\nThat being said, RawMessage is the correct solution. I'm fine tossing this in favor of #13.\n. Bump. Is this not the appropriate place to submit patches?\n. The particular case that I had in mind was unmarshalling cloud-configs, where `-` and `_` can be used interchangeably. Using yaml.Unmarshaler seems like it would be very cumbersome. Unless I am mistaken, all non-leaf elements would need to have a custom Unmarshaler, in which it would need to unmarshal into a map as an intermediate step. I want to avoid using a map altogether since that basically throws away the type system. I depend heavily on the structured types in order to validate user input.\n\nI agree that applying transforms to YAML keys is fairly uncommon, but I couldn't think of a better way to solve this issue.\n. My first implementation was almost exactly what you suggested. This doesn't work unfortunately because of YAML's type coercion. Consider the following example:\n\n``` yaml\nperson:\n  name: crawford\n  nick: off\n  phone: 0123456701\n```\n\nIf I were to unmarshal this into a map I would get the following:\n\n``` go\nmap[interface{}]interface{} {\n    \"person\": map[interface{}]interface{} {\n        \"name\":  \"crawford\",\n        \"nick\":  \"false\",\n        \"phone\": 21913025,\n    },\n}\n```\n\ninstead of:\n\n``` go\nPerson {\n    Name:  \"crawford\",\n    Nick:  \"off\",\n    Phone: \"0123456701\",\n}\n```\n\nYes this is a little contrived, but it illustrates two problems we have actually run into. Without a type to unmarshal into, and because YAML doesn't require quotes around strings, the parser chooses the most likely type (a boolean for the nick and an integer for the phone number) which is incorrect in this particular case. We need to hint to the parser which type to use when unmarshalling each value. Of course, the easy solution is to just write correct YAML in the first place, but unfortunately this is user provided.\n. > saying that the YAML doesn't require quotes to interpret \"off\" as a string isn't correct\n\nI never said that. I said \"YAML doesn't require quotes around strings\" which is absolutely true.\n\n> There's only one type the YAML should be read as, and the package is doing that job correctly.\n\nBut there is a difference in behavior between unmarshalling into a typed container vs an untyped container. This is the underlying problem.\n\nThat being said, RawMessage is the correct solution. I'm fine tossing this in favor of #13.\n. ",
    "amolokoedov": "Not yet fixed. Is there a patch for this? \n. Not yet fixed. Is there a patch for this? \n. ",
    "vinzenz": "@mattes @amolokoedov Would be cool if you could check that your use cases are covered with the PR I have sent\n. @rogpeppe http://yaml.org/type/merge.html. @rogpeppe Well I don't know, YAML is a beast ;-) I just added the support for MapSlice - Merge support was there already before. This one addresses decoding not encoding, encoding is handled by PR#221\n. This is a duplicate of #130 I can see now\n. @bradrydzewski could you please try with #220 \nThis issue might be related to #91\n. @bradrydzewski @Mange Its fixed by #220 I took the liberty to add the above test cases to the tests\n. Actually this is not a problem with numbers. This is just this: \n\n> When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next. Since Go 1 the runtime randomizes map iteration order, as programmers relied on the stable iteration order of the previous implementation. If you require a stable iteration order you must maintain a separate data structure that specifies that order. This example uses a separate sorted slice of keys to print a map[int]string in key order:\n\nSee: https://blog.golang.org/go-maps-in-action # Iteration order\n. @prashantv right, my bad didn't realize ;-)\n. @autrilla It's fixed by #217 - It's a change in the time stdlib\n. > It's not clear to me how this is fixing the referenced issue in a proper way. \r\n\r\nParseFloat is  behaving oddly by discarding the leading 0 and make the rest of the number a float.\r\n\r\n> What's the actual specification of the float format in yaml, and how is this handling it? \r\n\r\nhttp://yaml.org/spec/1.2/spec.html#tag/repository/float\r\nA leading 0 is only allowed when followed by a dot, which it checks for and then passes the string on to really try a float. (tryFloat)\r\n\r\n> Where are the tests for it showing details of the problem being fixed?\r\n\r\nI will add some test that would fail before\r\n.  #171  seems to actually fix this already. And we can also add this as a parser option (Strict floats) like it was introduced as another PR\r\n. @mattes @amolokoedov Would be cool if you could check that your use cases are covered with the PR I have sent\n. @rogpeppe http://yaml.org/type/merge.html. @rogpeppe Well I don't know, YAML is a beast ;-) I just added the support for MapSlice - Merge support was there already before. This one addresses decoding not encoding, encoding is handled by PR#221\n. This is a duplicate of #130 I can see now\n. @bradrydzewski could you please try with #220 \nThis issue might be related to #91\n. @bradrydzewski @Mange Its fixed by #220 I took the liberty to add the above test cases to the tests\n. Actually this is not a problem with numbers. This is just this: \n\n> When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next. Since Go 1 the runtime randomizes map iteration order, as programmers relied on the stable iteration order of the previous implementation. If you require a stable iteration order you must maintain a separate data structure that specifies that order. This example uses a separate sorted slice of keys to print a map[int]string in key order:\n\nSee: https://blog.golang.org/go-maps-in-action # Iteration order\n. @prashantv right, my bad didn't realize ;-)\n. @autrilla It's fixed by #217 - It's a change in the time stdlib\n. > It's not clear to me how this is fixing the referenced issue in a proper way. \r\n\r\nParseFloat is  behaving oddly by discarding the leading 0 and make the rest of the number a float.\r\n\r\n> What's the actual specification of the float format in yaml, and how is this handling it? \r\n\r\nhttp://yaml.org/spec/1.2/spec.html#tag/repository/float\r\nA leading 0 is only allowed when followed by a dot, which it checks for and then passes the string on to really try a float. (tryFloat)\r\n\r\n> Where are the tests for it showing details of the problem being fixed?\r\n\r\nI will add some test that would fail before\r\n.  #171  seems to actually fix this already. And we can also add this as a parser option (Strict floats) like it was introduced as another PR\r\n. ",
    "mvo5": "Thanks, I see the risk here. I created a small branch that adds a example how to do the decoding instead to help users to find it more easily.\n. Hey Gustavo, I'm sorry for this mistake. I re-pushed with only the relevant revision.\n. Thanks, I see the risk here. I created a small branch that adds a example how to do the decoding instead to help users to find it more easily.\n. Hey Gustavo, I'm sorry for this mistake. I re-pushed with only the relevant revision.\n. ",
    "kentoj": "+1\nI have an example that parses a map from an embedded structure. I can add that later as well.\n. +1\nI have an example that parses a map from an embedded structure. I can add that later as well.\n. ",
    "gyuho": "Hello, thanks for the great YAML package.\n\nI just ran into an issue of **NOT** omitting the zero float values.\nIt happens when I `Unmarshal` the data with zero float64 values and `Marshal` back to YAML format.\n\nThe master branch does **NOT** check the zero values of float types. (https://github.com/go-yaml/yaml/blob/v2/yaml.go#L328)\n\nCould we add a line to check zero float values? Otherwise, 0 or 0.0 on float types will never be omitted when `Marshal`ing.\n\nPlease let me know.\n\nThanks,\n. Thanks @niemeyer !\n. Hello, thanks for the great YAML package.\n\nI just ran into an issue of **NOT** omitting the zero float values.\nIt happens when I `Unmarshal` the data with zero float64 values and `Marshal` back to YAML format.\n\nThe master branch does **NOT** check the zero values of float types. (https://github.com/go-yaml/yaml/blob/v2/yaml.go#L328)\n\nCould we add a line to check zero float values? Otherwise, 0 or 0.0 on float types will never be omitted when `Marshal`ing.\n\nPlease let me know.\n\nThanks,\n. Thanks @niemeyer !\n. ",
    "erichnascimento": "Today works fine.\n. Today works fine.\n. ",
    "wuhao1542": "```\n$ go get -u gopkg.in/yaml.v2\npackage gopkg.in/yaml.v2: unrecognized import path \"gopkg.in/yaml.v2\"\n```\n\nthe same error\n. ```\n$ go get -u gopkg.in/yaml.v2\npackage gopkg.in/yaml.v2: unrecognized import path \"gopkg.in/yaml.v2\"\n```\n\nthe same error\n. ",
    "jonbonazza": "So I just realized that in order to make this work, I'd need to do something like:\n\n``` yaml\nconfiga:\n    addr: 0.0.0.0:8080\notherfield: blah\n```\n\nThis is so ugly and inconsistent with hour the default json package works. Is there any way to change this behavior? This makes switching between json and yaml difficult.\n. So I just realized that in order to make this work, I'd need to do something like:\n\n``` yaml\nconfiga:\n    addr: 0.0.0.0:8080\notherfield: blah\n```\n\nThis is so ugly and inconsistent with hour the default json package works. Is there any way to change this behavior? This makes switching between json and yaml difficult.\n. ",
    "aanm": "I have the exact same issue! Wishing to be solved.\n. Same with `[2]int`\n\n```\npanic: cannot marshal type: [2]int [recovered]\n        panic: cannot marshal type: [2]int [recovered]\n        panic: cannot marshal type: [2]int\n```\n. I have the exact same issue! Wishing to be solved.\n. Same with `[2]int`\n\n```\npanic: cannot marshal type: [2]int [recovered]\n        panic: cannot marshal type: [2]int [recovered]\n        panic: cannot marshal type: [2]int\n```\n. ",
    "pe-vsn": "I too am facing this issue. Here is some more code to demonstrate the issue:\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v2\"\n)\n\ntype Post struct {\n    File string `yaml:\"file\"`\n}\n\ntype More struct {\n    Post\n    Slug string `yaml:\"slug\"`\n}\n\nfunc main() {\n    var more = &More{}\n    err := yaml.Unmarshal([]byte(`{\"slug\": \"bar\", \"file\": \"foo\"}`), more)\n    if err != nil {\n        panic(err)\n    }   \n\n    fmt.Println(more) // Prints &{{} bar}\n}\n```\n\nThe following works (using json):\n\n``` go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Post struct {\n    File string `json:\"file\"`\n}\n\ntype More struct {\n    Post\n    Slug string `json:\"slug\"`\n}\n\nfunc main() {\n    var more = &More{}\n    err := json.Unmarshal([]byte(`{\"slug\": \"bar\", \"file\": \"foo\"}`), more)\n    if err != nil {\n        panic(err)\n    }   \n\n    fmt.Println(more) // Prints &{{foo} bar}\n}\n```\n. I too am facing this issue. Here is some more code to demonstrate the issue:\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v2\"\n)\n\ntype Post struct {\n    File string `yaml:\"file\"`\n}\n\ntype More struct {\n    Post\n    Slug string `yaml:\"slug\"`\n}\n\nfunc main() {\n    var more = &More{}\n    err := yaml.Unmarshal([]byte(`{\"slug\": \"bar\", \"file\": \"foo\"}`), more)\n    if err != nil {\n        panic(err)\n    }   \n\n    fmt.Println(more) // Prints &{{} bar}\n}\n```\n\nThe following works (using json):\n\n``` go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Post struct {\n    File string `json:\"file\"`\n}\n\ntype More struct {\n    Post\n    Slug string `json:\"slug\"`\n}\n\nfunc main() {\n    var more = &More{}\n    err := json.Unmarshal([]byte(`{\"slug\": \"bar\", \"file\": \"foo\"}`), more)\n    if err != nil {\n        panic(err)\n    }   \n\n    fmt.Println(more) // Prints &{{foo} bar}\n}\n```\n. ",
    "dmacvicar": "I have the same problem. Did you find a solution meanwhile?\n. I managed to get something working using the Unmarshall interface\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v2\"\n)\n\nconst (\n    data = `\nattrs:\n  foo: bar\n  bar:\n   - 1\n   - 2\n   - 3\n`\n)\n\ntype SingleOrMulti struct {\n    Values []string\n}\n\nfunc (sm *SingleOrMulti) UnmarshalYAML(unmarshal func(interface{}) error) error {\n    var multi []string\n    err := unmarshal(&multi)\n    if err != nil {\n        var single string\n        err := unmarshal(&single)\n        if err != nil {\n            return err\n        }\n        sm.Values = make([]string, 1)\n        sm.Values[0] = single\n    } else {\n        sm.Values = multi\n    }\n    return nil\n}\n\ntype Data struct {\n    Attrs map[string]SingleOrMulti\n}\n\nfunc main() {\n    var t Data\n    yaml.Unmarshal([]byte(data), &t)\n    fmt.Printf(\"%d\\n\", len(t.Attrs))\n    for k, e := range t.Attrs {\n        fmt.Printf(\"%v: %v\\n\", k, e.Values)\n    }\n}\n```\n\nUsing this I always have a slice in the unmarshaled struct, which gets a single element in case the YAML was a single value.\n\nNote that in this example, attrs: had arbitrary key names so I used a map. You can as well use a struct, if the names are fixed:\n\n``` go\ntype Data struct {\n    Foo SingleOrMulti\n    Bar SingleOrMulti\n}\n```\n. You closed the issue, but I still think this is an issue. It would be great if one could do something like:\n\n``` go\ntype Data struct {\n   Field []string `yaml:\"alwaysarray\"`\n}\n```\n\nAnd no matter if someone writes:\n\n``` yaml\nfield: foobar\n```\n\nThat would put the value as the only element of the array.\n. I have the same problem. Did you find a solution meanwhile?\n. I managed to get something working using the Unmarshall interface\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v2\"\n)\n\nconst (\n    data = `\nattrs:\n  foo: bar\n  bar:\n   - 1\n   - 2\n   - 3\n`\n)\n\ntype SingleOrMulti struct {\n    Values []string\n}\n\nfunc (sm *SingleOrMulti) UnmarshalYAML(unmarshal func(interface{}) error) error {\n    var multi []string\n    err := unmarshal(&multi)\n    if err != nil {\n        var single string\n        err := unmarshal(&single)\n        if err != nil {\n            return err\n        }\n        sm.Values = make([]string, 1)\n        sm.Values[0] = single\n    } else {\n        sm.Values = multi\n    }\n    return nil\n}\n\ntype Data struct {\n    Attrs map[string]SingleOrMulti\n}\n\nfunc main() {\n    var t Data\n    yaml.Unmarshal([]byte(data), &t)\n    fmt.Printf(\"%d\\n\", len(t.Attrs))\n    for k, e := range t.Attrs {\n        fmt.Printf(\"%v: %v\\n\", k, e.Values)\n    }\n}\n```\n\nUsing this I always have a slice in the unmarshaled struct, which gets a single element in case the YAML was a single value.\n\nNote that in this example, attrs: had arbitrary key names so I used a map. You can as well use a struct, if the names are fixed:\n\n``` go\ntype Data struct {\n    Foo SingleOrMulti\n    Bar SingleOrMulti\n}\n```\n. You closed the issue, but I still think this is an issue. It would be great if one could do something like:\n\n``` go\ntype Data struct {\n   Field []string `yaml:\"alwaysarray\"`\n}\n```\n\nAnd no matter if someone writes:\n\n``` yaml\nfield: foobar\n```\n\nThat would put the value as the only element of the array.\n. ",
    "ldesplat": "@dmacvicar I had left this as a todo for later on so thank you very much for finding a solution. You have just taught me how to use this library even more effectively. I did not realize there was an Unmarshaler type! I can now parse some other more complex values right from the beginning. Very awesome.\n. @dmacvicar I had left this as a todo for later on so thank you very much for finding a solution. You have just taught me how to use this library even more effectively. I did not realize there was an Unmarshaler type! I can now parse some other more complex values right from the beginning. Very awesome.\n. ",
    "dolfelt": "@dmacvicar A slightly modified version of the code above gives you something similar to what you're asking for.\r\n\r\n```go\r\ntype StringArray []string\r\n\r\nfunc (a *StringArray) UnmarshalYAML(unmarshal func(interface{}) error) error {\r\n\tvar multi []string\r\n\terr := unmarshal(&multi)\r\n\tif err != nil {\r\n\t\tvar single string\r\n\t\terr := unmarshal(&single)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*a = []string{single}\r\n\t} else {\r\n\t\t*a = multi\r\n\t}\r\n\treturn nil\r\n}\r\n\r\ntype Data struct {\r\n   Field StringArray\r\n}\r\n```\r\n\r\nNow you can access `Data.Field` as a string array no matter what.. @dmacvicar A slightly modified version of the code above gives you something similar to what you're asking for.\r\n\r\n```go\r\ntype StringArray []string\r\n\r\nfunc (a *StringArray) UnmarshalYAML(unmarshal func(interface{}) error) error {\r\n\tvar multi []string\r\n\terr := unmarshal(&multi)\r\n\tif err != nil {\r\n\t\tvar single string\r\n\t\terr := unmarshal(&single)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*a = []string{single}\r\n\t} else {\r\n\t\t*a = multi\r\n\t}\r\n\treturn nil\r\n}\r\n\r\ntype Data struct {\r\n   Field StringArray\r\n}\r\n```\r\n\r\nNow you can access `Data.Field` as a string array no matter what.. ",
    "blubberdiblub": "It's probably because your YAML document has a sequence (indicated by the hyphen) as top level element, not a map. Does it work if you try to `Unmarshal()` it into a `[]interface{}` or `[]map[string]interface{}`?\n. It's probably because your YAML document has a sequence (indicated by the hyphen) as top level element, not a map. Does it work if you try to `Unmarshal()` it into a `[]interface{}` or `[]map[string]interface{}`?\n. ",
    "chonthu": "It does not, unfortunately \n. :+1: \n. It does not, unfortunately \n. :+1: \n. ",
    "dmage": "```\npackage main\n\nimport (\n    \"gopkg.in/yaml.v2\"\n    \"log\"\n)\n\nfunc main() {\n    data := []byte(`---\n- k: val\n  k2: val2\n`)\n    var out []map[string]interface{}\n    err := yaml.Unmarshal(data, &out)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"%+v\", out)\n}\n```\n\nOutput:\n\n```\n2016/02/02 23:03:20 [map[k:val k2:val2]]\n```\n\nLooks good, don't you?\n. You have an extra space after the colon, it should be as follows: ``yaml:\"stemcell_criteria\"``\nhttps://golang.org/pkg/reflect/#StructTag\n. ```\npackage main\n\nimport (\n    \"gopkg.in/yaml.v2\"\n    \"log\"\n)\n\nfunc main() {\n    data := []byte(`---\n- k: val\n  k2: val2\n`)\n    var out []map[string]interface{}\n    err := yaml.Unmarshal(data, &out)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"%+v\", out)\n}\n```\n\nOutput:\n\n```\n2016/02/02 23:03:20 [map[k:val k2:val2]]\n```\n\nLooks good, don't you?\n. You have an extra space after the colon, it should be as follows: ``yaml:\"stemcell_criteria\"``\nhttps://golang.org/pkg/reflect/#StructTag\n. ",
    "daiksy": ":+1: \n. :+1: \n. ",
    "yuuki": ":+1:\n. :+1:\n. ",
    "Sixeight": ":+1: \n. :+1: \n. ",
    "Songmu": "@niemeyer How about it?\n\nThis is trivial, careless and frequent index bug, but it is\nserious bug in multi-byte environment.\n\nFor example, `map[string]string{\"a\": \"\u4f60\u597d #not-a-comment\"}` is marshaled to `a: \u4f60\u597d #not-a-comment`,\nbut, this result `a: \u4f60\u597d #not-a-comment` is unmarshaled to `map[string]string{\"a\": \"\u4f60\u597d\"}` and `#not-a-comment` is removed.\n. It seems to be done. Could you check it?\n. Thank you!\n. @niemeyer How about it?\n\nThis is trivial, careless and frequent index bug, but it is\nserious bug in multi-byte environment.\n\nFor example, `map[string]string{\"a\": \"\u4f60\u597d #not-a-comment\"}` is marshaled to `a: \u4f60\u597d #not-a-comment`,\nbut, this result `a: \u4f60\u597d #not-a-comment` is unmarshaled to `map[string]string{\"a\": \"\u4f60\u597d\"}` and `#not-a-comment` is removed.\n. It seems to be done. Could you check it?\n. Thank you!\n. ",
    "zstewar1": "I tried again on a different machine, and still go the same result. I'm using a freshly-pulled version of the repository on master (7ad95dd0798a40da1ccdff6dff35fd177b5edf40) with go 1.4.2. My bash output and patch file are shown below, if they help.\n\nOne thing that I find strange is that even after I added 6 new tests (to see whether this is just a problem with `*string`, or pointers in general), the output from `go test` still only says it ran 21 tests. Does the test runner only run the first 21 tests for some reason?\n\n``` bash\nzachary $ go version\ngo version go1.4.2 linux/amd64\nzachary $ export GOPATH=~/yaml-test/\nzachary $ go get gopkg.in/yaml.v2\nzachary $ go get gopkg.in/check.v1\nzachary $ cd ~/yaml-test/src/gopkg.in/yaml.v2\nzachary $ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nnothing to commit, working directory clean\nzachary $ git show --name-only\ncommit 7ad95dd0798a40da1ccdff6dff35fd177b5edf40\nAuthor: Gustavo Niemeyer <gustavo@niemeyer.net>\nDate:   Wed Jun 24 11:29:02 2015 +0100\n\n    Fix omitempty support for floats.\n\nencode_test.go\nyaml.go\nzachary $ go test\nOK: 21 passed\nPASS\nok      gopkg.in/yaml.v2    0.015s\nzachary $ patch decode_test.go < ~/decode_test.patch \npatching file decode_test.go\nzachary $ go test\n\n----------------------------------------------------------------------\nFAIL: decode_test.go:596: S.TestUnmarshal\n\ndecode_test.go:617:\n    c.Assert(value, DeepEquals, item.value)\n... obtained map[string]*string = map[string]*string{\"canonical\":(*string)(0xc2080a2140)}\n... expected map[string]*string = map[string]*string{\"canonical\":(*string)(nil)}\n\nOOPS: 20 passed, 1 FAILED\n--- FAIL: Test (0.01s)\nFAIL\nexit status 1\nFAIL    gopkg.in/yaml.v2    0.014s\nzachary $ \n```\n\n``` diff\n--- gopkg.in/yaml.v2/decode_test.go 2015-06-25 09:33:53.192381256 -0700\n+++ decode_test.go  2015-06-25 09:42:41.837811088 -0700\n@@ -152,6 +152,27 @@\n        map[string]*bool{\"empty\": nil},\n    },\n\n+   // For issue 109\n+   {\n+       \"canonical: ~\",\n+       map[string]*string{\"canonical\": nil},\n+   }, {\n+       \"english: null\",\n+       map[string]*string{\"english\": nil},\n+   }, {\n+       \"canonical: ~\",\n+       map[string]*int{\"canonical\": nil},\n+   }, {\n+       \"english: null\",\n+       map[string]*int{\"english\": nil},\n+   }, {\n+       \"canonical: ~\",\n+       map[string]*struct{}{\"canonical\": nil},\n+   }, {\n+       \"english: null\",\n+       map[string]*struct{}{\"english\": nil},\n+   },\n+   \n    // Flow sequence\n    {\n        \"seq: [A,B]\",\n```\n. Ah, I see.\n\nAnyway, thanks for being responsive.\n. I tried again on a different machine, and still go the same result. I'm using a freshly-pulled version of the repository on master (7ad95dd0798a40da1ccdff6dff35fd177b5edf40) with go 1.4.2. My bash output and patch file are shown below, if they help.\n\nOne thing that I find strange is that even after I added 6 new tests (to see whether this is just a problem with `*string`, or pointers in general), the output from `go test` still only says it ran 21 tests. Does the test runner only run the first 21 tests for some reason?\n\n``` bash\nzachary $ go version\ngo version go1.4.2 linux/amd64\nzachary $ export GOPATH=~/yaml-test/\nzachary $ go get gopkg.in/yaml.v2\nzachary $ go get gopkg.in/check.v1\nzachary $ cd ~/yaml-test/src/gopkg.in/yaml.v2\nzachary $ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nnothing to commit, working directory clean\nzachary $ git show --name-only\ncommit 7ad95dd0798a40da1ccdff6dff35fd177b5edf40\nAuthor: Gustavo Niemeyer <gustavo@niemeyer.net>\nDate:   Wed Jun 24 11:29:02 2015 +0100\n\n    Fix omitempty support for floats.\n\nencode_test.go\nyaml.go\nzachary $ go test\nOK: 21 passed\nPASS\nok      gopkg.in/yaml.v2    0.015s\nzachary $ patch decode_test.go < ~/decode_test.patch \npatching file decode_test.go\nzachary $ go test\n\n----------------------------------------------------------------------\nFAIL: decode_test.go:596: S.TestUnmarshal\n\ndecode_test.go:617:\n    c.Assert(value, DeepEquals, item.value)\n... obtained map[string]*string = map[string]*string{\"canonical\":(*string)(0xc2080a2140)}\n... expected map[string]*string = map[string]*string{\"canonical\":(*string)(nil)}\n\nOOPS: 20 passed, 1 FAILED\n--- FAIL: Test (0.01s)\nFAIL\nexit status 1\nFAIL    gopkg.in/yaml.v2    0.014s\nzachary $ \n```\n\n``` diff\n--- gopkg.in/yaml.v2/decode_test.go 2015-06-25 09:33:53.192381256 -0700\n+++ decode_test.go  2015-06-25 09:42:41.837811088 -0700\n@@ -152,6 +152,27 @@\n        map[string]*bool{\"empty\": nil},\n    },\n\n+   // For issue 109\n+   {\n+       \"canonical: ~\",\n+       map[string]*string{\"canonical\": nil},\n+   }, {\n+       \"english: null\",\n+       map[string]*string{\"english\": nil},\n+   }, {\n+       \"canonical: ~\",\n+       map[string]*int{\"canonical\": nil},\n+   }, {\n+       \"english: null\",\n+       map[string]*int{\"english\": nil},\n+   }, {\n+       \"canonical: ~\",\n+       map[string]*struct{}{\"canonical\": nil},\n+   }, {\n+       \"english: null\",\n+       map[string]*struct{}{\"english\": nil},\n+   },\n+   \n    // Flow sequence\n    {\n        \"seq: [A,B]\",\n```\n. Ah, I see.\n\nAnyway, thanks for being responsive.\n. ",
    "fschuetz04": "A change to solve this issue is suggested in #265, I'll probably open a pull request.. It would be best to open a pull request for that, maybe the maintainers will merge it.. A change to solve this issue is suggested in #265, I'll probably open a pull request.. It would be best to open a pull request for that, maybe the maintainers will merge it.. ",
    "yobert": "I think this is a useful feature. For me I would use it for reporting an error in a YAML config file. Not a YAML syntax error, but an error specific to my config syntax.\n\nWhat if we did a modified version of this where it left MapItem and MapSlice alone, but still allowed the custom struct tag mode? Then it's a bit more explicit and it doesn't break any compatibility.\n. Yeah, makes sense. This fix is too specific to our use cases. I wish there was a clean way to get the line/column down to the level of a string inside an array of strings...\n. If anyone else stumbles on this thread, for now I'm going to maintain github.com/yobert/yaml for this behavior.\n. So, this tells me we need to do everything through an AST first. Then the AST nodes can keep full roundtrip information for comments, line numbers from the source file, etc.\n\nMost people who don't need that could use the regular API, but other people could do something to get a parse tree before unmarshal?\n\nThat sounds like a giant rewrite though... :(\n. I think this is a useful feature. For me I would use it for reporting an error in a YAML config file. Not a YAML syntax error, but an error specific to my config syntax.\n\nWhat if we did a modified version of this where it left MapItem and MapSlice alone, but still allowed the custom struct tag mode? Then it's a bit more explicit and it doesn't break any compatibility.\n. Yeah, makes sense. This fix is too specific to our use cases. I wish there was a clean way to get the line/column down to the level of a string inside an array of strings...\n. If anyone else stumbles on this thread, for now I'm going to maintain github.com/yobert/yaml for this behavior.\n. So, this tells me we need to do everything through an AST first. Then the AST nodes can keep full roundtrip information for comments, line numbers from the source file, etc.\n\nMost people who don't need that could use the regular API, but other people could do something to get a parse tree before unmarshal?\n\nThat sounds like a giant rewrite though... :(\n. ",
    "kyessenov": "This would really help with usability when dealing with large structured YAML files, such as Kubernetes manifests. Line numbers, FTW!. This would really help with usability when dealing with large structured YAML files, such as Kubernetes manifests. Line numbers, FTW!. ",
    "packrat386": "This is consistent with the function of omitempty in standard library packages such as `encoding/json`\n\n```\npackage main\n\nimport \"fmt\"\nimport \"encoding/json\"\n\ntype Test struct {\n    A int `json:\"a,omitempty\"`\n    B int\n    C bool `json:\"c,omitempty\"`\n    D bool\n}\n\nfunc main() {\n    b, _ := json.Marshal(&Test{A: 0, B: 0, C: false, D: false})\n\n    fmt.Println(string(b))\n}\n```\n\ngives output `{\"B\":0,\"D\":false}` (http://play.golang.org/p/_3gwocwQFJ)\n\nUnfortunately, `0` and `false` have to be treated as the empty values for `int` and `bool` since otherwise there would be no value by which they could be considered empty. If you need to have those types exported conditionally, I would suggest using `*int` and `*bool` since then the only empty value is for the pointer to be `nil`\n. Do you have the `json` tag? Because you need the `yaml` tag for this library to work.\n. This is consistent with the function of omitempty in standard library packages such as `encoding/json`\n\n```\npackage main\n\nimport \"fmt\"\nimport \"encoding/json\"\n\ntype Test struct {\n    A int `json:\"a,omitempty\"`\n    B int\n    C bool `json:\"c,omitempty\"`\n    D bool\n}\n\nfunc main() {\n    b, _ := json.Marshal(&Test{A: 0, B: 0, C: false, D: false})\n\n    fmt.Println(string(b))\n}\n```\n\ngives output `{\"B\":0,\"D\":false}` (http://play.golang.org/p/_3gwocwQFJ)\n\nUnfortunately, `0` and `false` have to be treated as the empty values for `int` and `bool` since otherwise there would be no value by which they could be considered empty. If you need to have those types exported conditionally, I would suggest using `*int` and `*bool` since then the only empty value is for the pointer to be `nil`\n. Do you have the `json` tag? Because you need the `yaml` tag for this library to work.\n. ",
    "samsalisbury": "I think this issue should be closed now, cc @niemeyer \n. @niemeyer OK thanks for the feedback. This is a non-breaking change for the standard use-case (i.e. calling the Marshal and Unmarshal methods directly). I know if you pass those methods around they have a different signature, so fair enough it's not completely safe.\n\nI don't agree with using global variables for the struct cache, unless you also index them by the passed-in options, which IMO is a more fiddly things to manage. (I actually tried this whilst working on the PR, but it was messy.) Alternatively, there could be a _global YAMLCodec_, with a new one only being created for different option sets. With no options being passed in, it would be the same as having a global cache.\n\nWRT the Encoder/Decoder interfaces in `encoding/json` I totally agree it would be great to get this library following similar/the same interfaces, it was on my list for the next PR... Unfortunately I don't have time to contribute that right now, but I will eventually if no one gets there first :)\n\nWRT versioning, I think the cleanest thing to do would probably be to start work on a v3 that has `encoding/json` style behaviour as standard, and provides options for going back to the behaviour exhibited in v2. I'd be very happy to contribute towards that.\n\nSo, I'm going to use my fork in the short term, as I really need that behaviour for a project I'm working on, but I'll revisit this when I get a chance (likely in a few weeks' time).\n. Out of interest @niemeyer what is your workflow when using imported from `gopkg.in` that are hosted in GitHub? I.e. how do you use the correct import paths locally?\n\nI have been symlinking `$GOPATH/src/github.com/blah/yaml` dir into `$GOPATH/src/gopkg.in/blah/yaml.v2` but it doesn't feel like a very good way to do it for some reason... Any tips much appreciated :)\n. @niemeyer I've signed the contributor agreement, I named you as the contact I hope that's OK. What do you think about starting on a v3, with `encoding/json` style behaviour as default, and options to enable field name transformations? I think that would follow the principle of least surprise for new users of the project...\n. OK, sounds good @niemeyer, but would a simple changelog listing the breaking changes explicitly not be enough, after all no one would be broken if they keep using v2... Just thinking that writing that tool might be quite a complex endeavour to get it right.\n. Hmm, I think that basically anything using v2's `Marshal` or `Unmarshal` would be considered broken in the proposed v3 until it is tested. In most cases Unmarshal will still work, but will additionally unmarshal un-inlined anonymous struct members, but Marshal will produce completely different output... I can't see a general way to check brokenness without knowing the what the consumers of the data produced by this library are expecting...\n\nOne feature I think will be important will be having the library configurable to treat field names, anonymous structs, etc, in different ways. In fact, it will probably be quite easy to provide 2 default configurations, one which is `json/encoding`-like, and will be turned on by default, and one which it `go-yaml/yaml.v2`-like. E.g.:\n\n``` go\nV2Config := yaml.Config{FieldNameTransform: yaml.LowercaseFieldNameTransform, AutoInlineAnonymousStructFields: false}\nyaml.Configure(V2Config)\n// or, just to tweak a single parameter away from default...\nyaml.Configure(yaml.Config{AutoInlineAnonymousStructFields: false})\n```\n\n**EDIT: The code above was edited for clarity**\n\nThat way, if we added a hard-coded yaml.V2Config, there would be a really easy upgrade path for those wanting the new library, but with the old config without risking breaking anything.\n\nHowever, the change suggested above is not completely trivial, especially to add enough test cases for the different config combinations. I made a stab at it in #149, and probably I can just tweak that PR to achieve something like the above. Note that it requires an abolition of the global struct cache, and its replacement with a default global codec, with its own cache, that gets invalidated any time the config is changed.\n. I would obviously really like to get this change made as well, I've been using my own fork for ages because of this. @niemeyer any reason not to merge this?\n. @niemeyer this does not add any global options, just 3 new package-level functions `UnmarshalWithOptions`, `MarshalWithOptions` and `NewYAMLCodec`. It also adds a couple of public constants, but code not using these functions or constants will still work. The original public package functions `Marshal` and `Unmarshal` are unchanged in this PR, so _this PR would not break any usages of v2 at all_. We had a conversation about my original change in #149 which could have broken usages, but this PR addresses those issues so that no usages can be broken.\n. So, I should change \"YAMLCodec\" to 2 types \"Encoder\" and \"Decoder\", that's easy enough to do, although I'm not sure the benefit. What should the function/method be called that \"enables the standard behaviour\"? Do you mean a global function called e.g. `yaml.NoLowercase()` that would affect all encoding/decoding?\n\nIt seems best not to use globals for that setting, since I may have a program that needs to use both behaviours. The idea of the YAMLCodec is to encapsulate YAML formatting options that enable a complete roundtrip of YAML following whichever convention is decided per codec (I am assuming that usually you want to read and write in the same format.) These codecs can be used as singletons, so you only need one codec of each kind per execution. I am happy to add the global setting as well if that will get the PR merged, and I am also happy to drop the flags if they are a problem (to me they are descriptive, but that's just an opinion).\n. I think this issue should be closed now, cc @niemeyer \n. @niemeyer OK thanks for the feedback. This is a non-breaking change for the standard use-case (i.e. calling the Marshal and Unmarshal methods directly). I know if you pass those methods around they have a different signature, so fair enough it's not completely safe.\n\nI don't agree with using global variables for the struct cache, unless you also index them by the passed-in options, which IMO is a more fiddly things to manage. (I actually tried this whilst working on the PR, but it was messy.) Alternatively, there could be a _global YAMLCodec_, with a new one only being created for different option sets. With no options being passed in, it would be the same as having a global cache.\n\nWRT the Encoder/Decoder interfaces in `encoding/json` I totally agree it would be great to get this library following similar/the same interfaces, it was on my list for the next PR... Unfortunately I don't have time to contribute that right now, but I will eventually if no one gets there first :)\n\nWRT versioning, I think the cleanest thing to do would probably be to start work on a v3 that has `encoding/json` style behaviour as standard, and provides options for going back to the behaviour exhibited in v2. I'd be very happy to contribute towards that.\n\nSo, I'm going to use my fork in the short term, as I really need that behaviour for a project I'm working on, but I'll revisit this when I get a chance (likely in a few weeks' time).\n. Out of interest @niemeyer what is your workflow when using imported from `gopkg.in` that are hosted in GitHub? I.e. how do you use the correct import paths locally?\n\nI have been symlinking `$GOPATH/src/github.com/blah/yaml` dir into `$GOPATH/src/gopkg.in/blah/yaml.v2` but it doesn't feel like a very good way to do it for some reason... Any tips much appreciated :)\n. @niemeyer I've signed the contributor agreement, I named you as the contact I hope that's OK. What do you think about starting on a v3, with `encoding/json` style behaviour as default, and options to enable field name transformations? I think that would follow the principle of least surprise for new users of the project...\n. OK, sounds good @niemeyer, but would a simple changelog listing the breaking changes explicitly not be enough, after all no one would be broken if they keep using v2... Just thinking that writing that tool might be quite a complex endeavour to get it right.\n. Hmm, I think that basically anything using v2's `Marshal` or `Unmarshal` would be considered broken in the proposed v3 until it is tested. In most cases Unmarshal will still work, but will additionally unmarshal un-inlined anonymous struct members, but Marshal will produce completely different output... I can't see a general way to check brokenness without knowing the what the consumers of the data produced by this library are expecting...\n\nOne feature I think will be important will be having the library configurable to treat field names, anonymous structs, etc, in different ways. In fact, it will probably be quite easy to provide 2 default configurations, one which is `json/encoding`-like, and will be turned on by default, and one which it `go-yaml/yaml.v2`-like. E.g.:\n\n``` go\nV2Config := yaml.Config{FieldNameTransform: yaml.LowercaseFieldNameTransform, AutoInlineAnonymousStructFields: false}\nyaml.Configure(V2Config)\n// or, just to tweak a single parameter away from default...\nyaml.Configure(yaml.Config{AutoInlineAnonymousStructFields: false})\n```\n\n**EDIT: The code above was edited for clarity**\n\nThat way, if we added a hard-coded yaml.V2Config, there would be a really easy upgrade path for those wanting the new library, but with the old config without risking breaking anything.\n\nHowever, the change suggested above is not completely trivial, especially to add enough test cases for the different config combinations. I made a stab at it in #149, and probably I can just tweak that PR to achieve something like the above. Note that it requires an abolition of the global struct cache, and its replacement with a default global codec, with its own cache, that gets invalidated any time the config is changed.\n. I would obviously really like to get this change made as well, I've been using my own fork for ages because of this. @niemeyer any reason not to merge this?\n. @niemeyer this does not add any global options, just 3 new package-level functions `UnmarshalWithOptions`, `MarshalWithOptions` and `NewYAMLCodec`. It also adds a couple of public constants, but code not using these functions or constants will still work. The original public package functions `Marshal` and `Unmarshal` are unchanged in this PR, so _this PR would not break any usages of v2 at all_. We had a conversation about my original change in #149 which could have broken usages, but this PR addresses those issues so that no usages can be broken.\n. So, I should change \"YAMLCodec\" to 2 types \"Encoder\" and \"Decoder\", that's easy enough to do, although I'm not sure the benefit. What should the function/method be called that \"enables the standard behaviour\"? Do you mean a global function called e.g. `yaml.NoLowercase()` that would affect all encoding/decoding?\n\nIt seems best not to use globals for that setting, since I may have a program that needs to use both behaviours. The idea of the YAMLCodec is to encapsulate YAML formatting options that enable a complete roundtrip of YAML following whichever convention is decided per codec (I am assuming that usually you want to read and write in the same format.) These codecs can be used as singletons, so you only need one codec of each kind per execution. I am happy to add the global setting as well if that will get the PR merged, and I am also happy to drop the flags if they are a problem (to me they are descriptive, but that's just an opinion).\n. ",
    "mihai-chiorean": "I have a case where \n\n```\nfield []string `json:\",omitempty\"`\n```\n\ntranslates to\n\n```\nfield: []\n```\n\ninstead of being ignored\n. I have a case where \n\n```\nfield []string `json:\",omitempty\"`\n```\n\ntranslates to\n\n```\nfield: []\n```\n\ninstead of being ignored\n. ",
    "mvryan": "Why was this closed? What was the solution?\n. Why was this closed? What was the solution?\n. ",
    "asib": "Found a couple more myself\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"gopkg.in/yaml.v2\"\n)\n\nfunc main() {\n    data := [][]byte{[]byte(\"0: \\n  0: [0\\n0]0\"),\n        []byte(\"  0: [\\n0]0\")}\n\n    for _, d := range data {\n        doTest(d)\n    }\n}\n\nfunc doTest(d []byte) {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"recovered panic: \", r)\n        }\n    }()\n\n    yaml.Unmarshal(d, &struct{}{})\n}\n```\n. Found a couple more myself\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"gopkg.in/yaml.v2\"\n)\n\nfunc main() {\n    data := [][]byte{[]byte(\"0: \\n  0: [0\\n0]0\"),\n        []byte(\"  0: [\\n0]0\")}\n\n    for _, d := range data {\n        doTest(d)\n    }\n}\n\nfunc doTest(d []byte) {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"recovered panic: \", r)\n        }\n    }()\n\n    yaml.Unmarshal(d, &struct{}{})\n}\n```\n. ",
    "jorinvo": "I was also running go-fuzzer and I can confirm that the above errors still exist.\r\n\r\nAdditionally I found two index out of range errors:\r\n\r\n```\r\n\"{\\n0: \\\"00\\\\\\r\\n\",\r\n\"0: \\\"0\\\\\\r\\n\",\r\n\"{\\\"0\\\\\\r\\n\",\r\n```\r\n\r\nThese strings alle cause the following error:\r\n\r\n```\r\npanic: runtime error: index out of range [recovered]\r\n\tpanic: runtime error: index out of range\r\n\r\ngoroutine 1 [running]:\r\ngopkg.in/yaml%2ev2.handleErr(0xc4200fbbe8)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/yaml.go:153 +0xf7\r\npanic(0x14743a0, 0x1706050)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/goroot/src/runtime/panic.go:489 +0x2cf\r\ngopkg.in/yaml%2ev2.yaml_parser_scan_flow_scalar(0xc4200e8840, 0xc4200fb388, 0x0, 0x1)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:2483 +0x2c1d\r\ngopkg.in/yaml%2ev2.yaml_parser_fetch_flow_scalar(0xc4200e8840, 0x0, 0x1)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:1407 +0xe2\r\n```\r\n\r\nThis string causes a different out of range error:\r\n```\r\n\"\\u0085\\ufeff\\u0085\"\r\n```\r\n\r\n```\r\npanic: runtime error: index out of range [recovered]\r\n\tpanic: runtime error: index out of range\r\n\r\ngoroutine 1 [running]:\r\ngopkg.in/yaml%2ev2.handleErr(0xc42004bbe8)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/yaml.go:153 +0xf7\r\npanic(0x14743a0, 0x1706050)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/goroot/src/runtime/panic.go:489 +0x2cf\r\ngopkg.in/yaml%2ev2.yaml_parser_scan_to_next_token(0xc4204242c0, 0xc4204242c0)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:1455 +0x4e0\r\ngopkg.in/yaml%2ev2.yaml_parser_fetch_next_token(0xc4204242c0, 0x1)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:677 +0xc5\r\n```. I was also running go-fuzzer and I can confirm that the above errors still exist.\r\n\r\nAdditionally I found two index out of range errors:\r\n\r\n```\r\n\"{\\n0: \\\"00\\\\\\r\\n\",\r\n\"0: \\\"0\\\\\\r\\n\",\r\n\"{\\\"0\\\\\\r\\n\",\r\n```\r\n\r\nThese strings alle cause the following error:\r\n\r\n```\r\npanic: runtime error: index out of range [recovered]\r\n\tpanic: runtime error: index out of range\r\n\r\ngoroutine 1 [running]:\r\ngopkg.in/yaml%2ev2.handleErr(0xc4200fbbe8)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/yaml.go:153 +0xf7\r\npanic(0x14743a0, 0x1706050)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/goroot/src/runtime/panic.go:489 +0x2cf\r\ngopkg.in/yaml%2ev2.yaml_parser_scan_flow_scalar(0xc4200e8840, 0xc4200fb388, 0x0, 0x1)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:2483 +0x2c1d\r\ngopkg.in/yaml%2ev2.yaml_parser_fetch_flow_scalar(0xc4200e8840, 0x0, 0x1)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:1407 +0xe2\r\n```\r\n\r\nThis string causes a different out of range error:\r\n```\r\n\"\\u0085\\ufeff\\u0085\"\r\n```\r\n\r\n```\r\npanic: runtime error: index out of range [recovered]\r\n\tpanic: runtime error: index out of range\r\n\r\ngoroutine 1 [running]:\r\ngopkg.in/yaml%2ev2.handleErr(0xc42004bbe8)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/yaml.go:153 +0xf7\r\npanic(0x14743a0, 0x1706050)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/goroot/src/runtime/panic.go:489 +0x2cf\r\ngopkg.in/yaml%2ev2.yaml_parser_scan_to_next_token(0xc4204242c0, 0xc4204242c0)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:1455 +0x4e0\r\ngopkg.in/yaml%2ev2.yaml_parser_fetch_next_token(0xc4204242c0, 0x1)\r\n\t/var/folders/km/kqlfxy2j64dd_9gqb373c0hm0000gn/T/go-fuzz-build867195819/gopath/src/gopkg.in/yaml.v2/scannerc.go:677 +0xc5\r\n```. ",
    "nathanleclaire": "> I'd probably have followed what is now the most common convention, but it's a bit late to change this now. Keeping people's code working is more important.\n\nSure, no problem, thanks for the reply!\n. > I'd probably have followed what is now the most common convention, but it's a bit late to change this now. Keeping people's code working is more important.\n\nSure, no problem, thanks for the reply!\n. ",
    "hvnsweeting": "yes, it's good. Thanks\n. yes, it's good. Thanks\n. ",
    "dhiltonp": "For this, I'm running ToLower on the input data; considering that case sensitivity is part of the yaml spec, I think it's a better solution than changing the library (although it may be less convenient).\n. +1\n. For this, I'm running ToLower on the input data; considering that case sensitivity is part of the yaml spec, I think it's a better solution than changing the library (although it may be less convenient).\n. +1\n. ",
    "coryb": "Thanks for the feedback, and spec section.  It is surprising as it makes YAML useless as a data exchange format since it does not preserve the original data.  I guess I will maintain my fork.\n. Thanks for the feedback, and spec section.  It is surprising as it makes YAML useless as a data exchange format since it does not preserve the original data.  I guess I will maintain my fork.\n. ",
    "3rf": "+1 I hit this today\n. +1 I hit this today\n. ",
    "index0h": "+1\n. +1\n. ",
    "jsha": "It needs to be added as a Service Hook (\nhttps://developer.github.com/webhooks/#service-hooks), which means GitHub\nnotifies it on pushes and pull requests, but it does not get access to\nmodify your repository.\u200b\n. It needs to be added as a Service Hook (\nhttps://developer.github.com/webhooks/#service-hooks), which means GitHub\nnotifies it on pushes and pull requests, but it does not get access to\nmodify your repository.\u200b\n. ",
    "eidge": "Thanks!\n. Thanks!\n. ",
    "DirectXMan12": "Intro to comments: http://yaml.org/spec/1.2/spec.html#id2767100\nComment specification: http://yaml.org/spec/1.2/spec.html#id2780069 (this commit, for the moment, only supports emitting comments on their own line, not at the end of a line)\nSee also http://yaml.org/spec/1.2/spec.html#id2762313\n\nComments are useful in that they allow extra \"human-readable\" information to be attached without changing the structure of the document.  For instance, suppose a program returns a piece of stored configuration.  Using comments, it could add detailed descriptions of each of the fields in the configuration, in case the person reading them was not fully familiar with the format.  Additionally, comments could be used when \"interactively\" editing configuration -- the configuration is opened in an editor, the user saves/quits, the configuration is validated, and the editor is reopened with comments above any lines with issues.\n\nThe approach is as such:\n- At the low-level (in `emitterc.go`), I introduced a new event type -- `yaml_COMMENT_EVENT`.  This event does not change the current state, and only generates any output when waiting for a key (or list item) and in the block style (you can't have a comment in the middle of a flow-style object, and also can't have a comment in between a key and a value).\n- At the high levels, comments may be inserted either through the use of a struct field tag (`yamlComment`) for when static comments are sufficient, or through the use of an extend variant of the `MapItem`: `CommentedMapItem`.  This support \"dynamic\" comments, such as in the validation example.  When a user attempts to marshal a `CommentedMapItem`, the encoder checks it for a non-empty comment.  If it finds a non-empty comment, it emits a comment event.  In either case, it then proceeds as usual for a `MapItem` (I didn't modify the existing MapItem so as to preserve API backwards-compatibility).\n\nTechnically, the low-level code supports adding comments above list items.  However, I didn't see an easy way to expose this to the high level.\n\nIt shouldn't be too hard to add support for postfix comments -- I can add this if you want.  However, there's not really a good way to support them from the high-level without introducing more configuration and/or tags (and then things start to get annoyingly verbose), and this functionality is not strictly necessary for what I'm trying to accomplish (which is, basically, the two example cases described above).\n. > We can certainly support comment manipulation, but we'll need to design this a little bit better first.\n> \n> Namingly, we need to ignore the internal implementation completely and look from the perspective of someone using the feature both to consume comments and to produce them back into the expected locations.\n\nAccording to the YAML 1.2 specification, comments are not supposed to live anywhere but the presentation form (see http://yaml.org/spec/1.2/spec.html#id2762140 , http://yaml.org/spec/1.2/spec.html#id2767100 , http://yaml.org/spec/1.2/spec.html#id2766150), and are not supposed to be \"attached\" to any particular node.\n\nSince comments are not supposed to survive into the unmarshaled data structure, and other presentation details (e.g. style) don't survive a round trip of unmarshaling into `interface{}` and then remarshaling, IMO we don't need to worry about presenting deserialized comments to the user or having the \"survive\" a round trip.\n\nCurrently, it appears that go-yaml supports three ways of influencing the marshaling process:\n- Using `MarshalYAML` (and/or `MarshalText`), the user can control the representation stage\n- Using struct tags, the user can affect the representation stage (`inline` and `omitempty`) and the presentation stage (`flow`).\n- Using `MapItem` and `MapSlice`, the user can affect the serialization phase (specifically the key ordering part)\n\nIn my opinion, the ability to have \"dynamic\" (i.e. not hard-coded) comments is required (e.g. in the case of indicating validation errors, as I described above).  Ergo, while the struct tag method could be an option for adding comments, it cannot be the only option.  If we wish to utilize the existing machinery, this means we are left with two options -- either an extension to `MarshalYAML` that somehow adds in comment comments (this allows for some degree of dynamic comments but makes certain things hard), or attaching comments to `MapItem` values (as I implemented in #129).\n\nAll three of the options presented above, however, suffer from the fact that they necessarily \"attach\" comments to nodes.  According to the specification, this is not fully correct behavior.  One solution to this issue would be to implement some sort of callback or filter mechanism that would allow users to influence the low-level event stream used to produce the output.  This has a couple benefits: it allows comments to be inserted at arbitrary points in the documents and it would allow users to control other style decisions on the fly.  The downsides of this approach is that extra validation would be needed to ensure that the user did not modify the event stream in an invalid way.  It's also a bit more complicated for users who have the \"annotate fields in their YAML document\" use case.\n\n> We also need to outline which cases we'll try to support when writing, and which cases are going to cause clear havoc in the output.\n\nThe \"simplest\" case is the case where a comment is on a new line.  The slightly more complicated case is for an \"end-of-line\" comment (scalar values and flow-style values would have to be shifted to the next line if it appeared between a key and a scalar value or flow-style value etc), and the indentation should match up for comment lines after the end-of-line comment.  The former case is a must-have, IMO.  The latter case would be nice to have.\n. > Without comments surviving a roundtrip it sounds like a very bad idea to support them at all.\n\nWhile I'm certainly willing to implement this, it seems strange, IMO to preserve some presentation details and not others -- why preserve comments and not style, for instance?\n\nDid you have any ideas about how to allow users to specify comments (such as the ideas I presented above?)\n. @yobert I've been hacking around at exposing a \"user-friendly\" version of the underlying events-based model (then you could just emit or receive a \"comment\" event).  This way, users that need/want to can build stuff using the event-based model, or by mixing it in with the traditional \"use struct tags and/or dicts and slices\" model for specific objects.  I'll post some code when it's a bit more fleshed out.\n\nThe main issue that I've encountered so far is that certain design decisions of the underlying model are not conducive to comments in certain places (e.g. the ':' gets written by the value in a map, so the following is not immediately doable:\n\n```\nfoo: # some comment\n     # continues here\n  bar\n```\n\n(as shown in 6.11)\n. @jvehent I have a more complete patch around somewhere, but I didn't quite get time to finish it.  I'll see if I can dig it up.\n. I don't think I ever *quite* finished the full round-trip patch, but I'll see if I can dig it up (it had mostly slipped my mind at this point).. Intro to comments: http://yaml.org/spec/1.2/spec.html#id2767100\nComment specification: http://yaml.org/spec/1.2/spec.html#id2780069 (this commit, for the moment, only supports emitting comments on their own line, not at the end of a line)\nSee also http://yaml.org/spec/1.2/spec.html#id2762313\n\nComments are useful in that they allow extra \"human-readable\" information to be attached without changing the structure of the document.  For instance, suppose a program returns a piece of stored configuration.  Using comments, it could add detailed descriptions of each of the fields in the configuration, in case the person reading them was not fully familiar with the format.  Additionally, comments could be used when \"interactively\" editing configuration -- the configuration is opened in an editor, the user saves/quits, the configuration is validated, and the editor is reopened with comments above any lines with issues.\n\nThe approach is as such:\n- At the low-level (in `emitterc.go`), I introduced a new event type -- `yaml_COMMENT_EVENT`.  This event does not change the current state, and only generates any output when waiting for a key (or list item) and in the block style (you can't have a comment in the middle of a flow-style object, and also can't have a comment in between a key and a value).\n- At the high levels, comments may be inserted either through the use of a struct field tag (`yamlComment`) for when static comments are sufficient, or through the use of an extend variant of the `MapItem`: `CommentedMapItem`.  This support \"dynamic\" comments, such as in the validation example.  When a user attempts to marshal a `CommentedMapItem`, the encoder checks it for a non-empty comment.  If it finds a non-empty comment, it emits a comment event.  In either case, it then proceeds as usual for a `MapItem` (I didn't modify the existing MapItem so as to preserve API backwards-compatibility).\n\nTechnically, the low-level code supports adding comments above list items.  However, I didn't see an easy way to expose this to the high level.\n\nIt shouldn't be too hard to add support for postfix comments -- I can add this if you want.  However, there's not really a good way to support them from the high-level without introducing more configuration and/or tags (and then things start to get annoyingly verbose), and this functionality is not strictly necessary for what I'm trying to accomplish (which is, basically, the two example cases described above).\n. > We can certainly support comment manipulation, but we'll need to design this a little bit better first.\n> \n> Namingly, we need to ignore the internal implementation completely and look from the perspective of someone using the feature both to consume comments and to produce them back into the expected locations.\n\nAccording to the YAML 1.2 specification, comments are not supposed to live anywhere but the presentation form (see http://yaml.org/spec/1.2/spec.html#id2762140 , http://yaml.org/spec/1.2/spec.html#id2767100 , http://yaml.org/spec/1.2/spec.html#id2766150), and are not supposed to be \"attached\" to any particular node.\n\nSince comments are not supposed to survive into the unmarshaled data structure, and other presentation details (e.g. style) don't survive a round trip of unmarshaling into `interface{}` and then remarshaling, IMO we don't need to worry about presenting deserialized comments to the user or having the \"survive\" a round trip.\n\nCurrently, it appears that go-yaml supports three ways of influencing the marshaling process:\n- Using `MarshalYAML` (and/or `MarshalText`), the user can control the representation stage\n- Using struct tags, the user can affect the representation stage (`inline` and `omitempty`) and the presentation stage (`flow`).\n- Using `MapItem` and `MapSlice`, the user can affect the serialization phase (specifically the key ordering part)\n\nIn my opinion, the ability to have \"dynamic\" (i.e. not hard-coded) comments is required (e.g. in the case of indicating validation errors, as I described above).  Ergo, while the struct tag method could be an option for adding comments, it cannot be the only option.  If we wish to utilize the existing machinery, this means we are left with two options -- either an extension to `MarshalYAML` that somehow adds in comment comments (this allows for some degree of dynamic comments but makes certain things hard), or attaching comments to `MapItem` values (as I implemented in #129).\n\nAll three of the options presented above, however, suffer from the fact that they necessarily \"attach\" comments to nodes.  According to the specification, this is not fully correct behavior.  One solution to this issue would be to implement some sort of callback or filter mechanism that would allow users to influence the low-level event stream used to produce the output.  This has a couple benefits: it allows comments to be inserted at arbitrary points in the documents and it would allow users to control other style decisions on the fly.  The downsides of this approach is that extra validation would be needed to ensure that the user did not modify the event stream in an invalid way.  It's also a bit more complicated for users who have the \"annotate fields in their YAML document\" use case.\n\n> We also need to outline which cases we'll try to support when writing, and which cases are going to cause clear havoc in the output.\n\nThe \"simplest\" case is the case where a comment is on a new line.  The slightly more complicated case is for an \"end-of-line\" comment (scalar values and flow-style values would have to be shifted to the next line if it appeared between a key and a scalar value or flow-style value etc), and the indentation should match up for comment lines after the end-of-line comment.  The former case is a must-have, IMO.  The latter case would be nice to have.\n. > Without comments surviving a roundtrip it sounds like a very bad idea to support them at all.\n\nWhile I'm certainly willing to implement this, it seems strange, IMO to preserve some presentation details and not others -- why preserve comments and not style, for instance?\n\nDid you have any ideas about how to allow users to specify comments (such as the ideas I presented above?)\n. @yobert I've been hacking around at exposing a \"user-friendly\" version of the underlying events-based model (then you could just emit or receive a \"comment\" event).  This way, users that need/want to can build stuff using the event-based model, or by mixing it in with the traditional \"use struct tags and/or dicts and slices\" model for specific objects.  I'll post some code when it's a bit more fleshed out.\n\nThe main issue that I've encountered so far is that certain design decisions of the underlying model are not conducive to comments in certain places (e.g. the ':' gets written by the value in a map, so the following is not immediately doable:\n\n```\nfoo: # some comment\n     # continues here\n  bar\n```\n\n(as shown in 6.11)\n. @jvehent I have a more complete patch around somewhere, but I didn't quite get time to finish it.  I'll see if I can dig it up.\n. I don't think I ever *quite* finished the full round-trip patch, but I'll see if I can dig it up (it had mostly slipped my mind at this point).. ",
    "jeffjen": "Its been awhile since the owner had any comment on this.\n\nThe document states that Unmarshal decodes the **first** document found.  I wanted the Decoder and Encoder interface to match semantics of **encoding/json** package's.\n\nI do have a change that will address this problem, but it will take more time for me to figure out how to not deplete user's memory during decode phase in a real **streaming** scenario, where the input buffer is expected to be unbounded.\n. @oec I missed the discussion!!  Anyway I submitted a pull request #163  to add and Deocder/Encoder struct to handle streaming cases, but I didn't wrote test for it.\n. Need help with \"contributor agreement\".  I don't know if I am clear on that front.\n. Its been awhile since the owner had any comment on this.\n\nThe document states that Unmarshal decodes the **first** document found.  I wanted the Decoder and Encoder interface to match semantics of **encoding/json** package's.\n\nI do have a change that will address this problem, but it will take more time for me to figure out how to not deplete user's memory during decode phase in a real **streaming** scenario, where the input buffer is expected to be unbounded.\n. @oec I missed the discussion!!  Anyway I submitted a pull request #163  to add and Deocder/Encoder struct to handle streaming cases, but I didn't wrote test for it.\n. Need help with \"contributor agreement\".  I don't know if I am clear on that front.\n. ",
    "oec": "@niemeyer, I can change the names and write some tests until Wednesday.  @jeffjen, handling multiple documents would break semantics with encoding/xml, AFAIK.   Maybe a switch in the (yaml-)en/decoder would be appropriate to give control over the behavior to the consumer of the API.\n. @niemeyer, @jeffjen, I got your point and it should easily be possible to implement that behavior.\n\nThe semantic issue I ran into was different: decoder.xml requires the top-level tag to be part of the stream (in your example it would be < Message >), see http://play.golang.org/p/s3MCpzvsBG.  But this is independent of what you want.\n. @niemeyer, how shall we proceed?  I think I won't be able to implement streaming support and tests before Friday.\n. Of course, another - more complex - patch would be to implement something similar as the \",any\"-tag in encoding/xml.  Unmarshaling into struct _without_ a field with that tag would silently ignore extra fields in the input (as it is now).  A field of type map[string]interface{} with the tag \",any\" could serve as a catch-all and consumers could decide what to do with it.\n. @niemeyer, I can change the names and write some tests until Wednesday.  @jeffjen, handling multiple documents would break semantics with encoding/xml, AFAIK.   Maybe a switch in the (yaml-)en/decoder would be appropriate to give control over the behavior to the consumer of the API.\n. @niemeyer, @jeffjen, I got your point and it should easily be possible to implement that behavior.\n\nThe semantic issue I ran into was different: decoder.xml requires the top-level tag to be part of the stream (in your example it would be < Message >), see http://play.golang.org/p/s3MCpzvsBG.  But this is independent of what you want.\n. @niemeyer, how shall we proceed?  I think I won't be able to implement streaming support and tests before Friday.\n. Of course, another - more complex - patch would be to implement something similar as the \",any\"-tag in encoding/xml.  Unmarshaling into struct _without_ a field with that tag would silently ignore extra fields in the input (as it is now).  A field of type map[string]interface{} with the tag \",any\" could serve as a catch-all and consumers could decide what to do with it.\n. ",
    "jvehent": "Has there been more interest in implementing comment encoding/decoding support? I found this [patch](https://github.com/DirectXMan12/go-yaml/commit/4c95efea86311a44556aad1cc58f449bb5b7e65f) from @DirectXMan12 which doesn't appear to work yet, but is an interesting starting point. I'm looking at porting [sops](https://github.com/mozilla/sops/) over to Go and comment preservation is something we care a lot about.\n. Tests are failing due to https://github.com/go-yaml/yaml/pull/223/commits/e09b2a6483d4262d3b5cadc8a6f81d539981fc22, therefore this is blocked on merging #223. I am guilty of the same issue and reviews tend to sit in my queue for far too long, so no stone is being thrown here.\r\n\r\nA solution I found satisfying is protecting sensitive branches to only allow admins to merge, and let contributors review and manage other branches. That doesn't solve the fact that people need to step up, but I believe that making it easier for co-maintainers to participate is a good place to start. It worked for me on a couple projects.. Has there been more interest in implementing comment encoding/decoding support? I found this [patch](https://github.com/DirectXMan12/go-yaml/commit/4c95efea86311a44556aad1cc58f449bb5b7e65f) from @DirectXMan12 which doesn't appear to work yet, but is an interesting starting point. I'm looking at porting [sops](https://github.com/mozilla/sops/) over to Go and comment preservation is something we care a lot about.\n. Tests are failing due to https://github.com/go-yaml/yaml/pull/223/commits/e09b2a6483d4262d3b5cadc8a6f81d539981fc22, therefore this is blocked on merging #223. I am guilty of the same issue and reviews tend to sit in my queue for far too long, so no stone is being thrown here.\r\n\r\nA solution I found satisfying is protecting sensitive branches to only allow admins to merge, and let contributors review and manage other branches. That doesn't solve the fact that people need to step up, but I believe that making it easier for co-maintainers to participate is a good place to start. It worked for me on a couple projects.. ",
    "alexbrand": "@DirectXMan12 what's the status of this issue? It would be great to be able to (un)marshal comments.\n. @DirectXMan12 what's the status of this issue? It would be great to be able to (un)marshal comments.\n. ",
    "jmreicha": "Any update on this?  I also have a use case where I'd like to preserve comments.. Any update on this?  I also have a use case where I'd like to preserve comments.. ",
    "HeavyWombat": "+1\n. +1\n. ",
    "sigmonsays": "I am interested in getting this fixed too. +1\n. I am interested in getting this fixed too. +1\n. ",
    "josephbuchma": "Why  `MarshalYAML` method of `Marshaler` interface returns `interface{}` rather than `[]byte` like in `encoding/json` ?\n. Why  `MarshalYAML` method of `Marshaler` interface returns `interface{}` rather than `[]byte` like in `encoding/json` ?\n. ",
    "ibuildthecloud": "Okay, fair enough.\n. Okay, fair enough.\n. ",
    "abligh": "+1 - at least an option to error this would be good.\n. +1 - at least an option to error this would be good.\n. ",
    "wfarner": "Are there any plans to accept the above patch, possibly with added plumbing to make the behavior optional/non-default?  Happy to pitch in.\n. @niemeyer can you elaborate?  I'm not following how inlining maps helps to address the use case @oec demonstrated in the original issue filing.\n. Are there any plans to accept the above patch, possibly with added plumbing to make the behavior optional/non-default?  Happy to pitch in.\n. @niemeyer can you elaborate?  I'm not following how inlining maps helps to address the use case @oec demonstrated in the original issue filing.\n. ",
    "vincentbernat": "Is there a known workaround for this bug/feature?\n. @douglaswth Thanks! I was hoping there would be a way to do that without a modified version. I have tried to extract all the keys and check if there are unknown ones, but this requires some reflection and redo the work already done by this package to correctly parse tags.\n. You can easily set default values if you provide a non-zero value:\n\n``` go\ntype Stuff struct {\n  Max int32\n  Min int32\n}\n\nfunc Parse(in []byte) error {\n  var stuff = Stuff{Max: 2147483647, Min: -147483648}\n  if err := yaml.Unmarshal(in, &stuff); err != nil {\n    return err\n  }\n  ...\n  return nil\n}\n```\n. Another option would be tu use:\n\n``` go\ntype Stuff struct {\n  Max *int32\n  Min *int32\n}\n```\n\nYou can then detect that the value has not been set and correct it.\n. You need to implement `UnmarshalYAML` for `Stuff`:\n\n``` go\nfunc (s *Stuff) UnmarshalYAML(unmarshal func(interface{}) error) error {\n    type rawStuff Stuff\n    raw := rawStuff{} // Put your defaults here\n    if err := unmarshal(&raw); err != nil {\n        return err\n    }\n\n    *s = Stuff(raw)\n    return nil\n}\n```\n. Yes, your analysis is correct. I can't say about the idiomatic part as I am just a regular user (and not a very experienced one yet). I'll take the beverage at any point, but I am likely to forget in two weeks. :)\n. Is there a known workaround for this bug/feature?\n. @douglaswth Thanks! I was hoping there would be a way to do that without a modified version. I have tried to extract all the keys and check if there are unknown ones, but this requires some reflection and redo the work already done by this package to correctly parse tags.\n. You can easily set default values if you provide a non-zero value:\n\n``` go\ntype Stuff struct {\n  Max int32\n  Min int32\n}\n\nfunc Parse(in []byte) error {\n  var stuff = Stuff{Max: 2147483647, Min: -147483648}\n  if err := yaml.Unmarshal(in, &stuff); err != nil {\n    return err\n  }\n  ...\n  return nil\n}\n```\n. Another option would be tu use:\n\n``` go\ntype Stuff struct {\n  Max *int32\n  Min *int32\n}\n```\n\nYou can then detect that the value has not been set and correct it.\n. You need to implement `UnmarshalYAML` for `Stuff`:\n\n``` go\nfunc (s *Stuff) UnmarshalYAML(unmarshal func(interface{}) error) error {\n    type rawStuff Stuff\n    raw := rawStuff{} // Put your defaults here\n    if err := unmarshal(&raw); err != nil {\n        return err\n    }\n\n    *s = Stuff(raw)\n    return nil\n}\n```\n. Yes, your analysis is correct. I can't say about the idiomatic part as I am just a regular user (and not a very experienced one yet). I'll take the beverage at any point, but I am likely to forget in two weeks. :)\n. ",
    "douglaswth": "@vincentbernat there's my branch with these changes: #146.\n. Does this fix #136/#146? I noticed that #210 was closed probably because of this PR.. @vincentbernat there's my branch with these changes: #146.\n. Does this fix #136/#146? I noticed that #210 was closed probably because of this PR.. ",
    "atombender": "Can we get this merged? The inline map solution isn't great because it moves the burden of error checking to the target struct. When you have a bunch of structs, this becomes onerous to have to implement a `UnmarshalYAML` that checks for unknown keys.\n\nAs far as I can tell, there's no way to create a helper struct (e.g. `StrictKeys`) that cleanly implements `UnmarshalYAML`, since it requires a type alias to avoid recursive unmarshaling. Might be possible using reflection, but I'd like to avoid that.\n. Can we get this merged? The inline map solution isn't great because it moves the burden of error checking to the target struct. When you have a bunch of structs, this becomes onerous to have to implement a `UnmarshalYAML` that checks for unknown keys.\n\nAs far as I can tell, there's no way to create a helper struct (e.g. `StrictKeys`) that cleanly implements `UnmarshalYAML`, since it requires a type alias to avoid recursive unmarshaling. Might be possible using reflection, but I'd like to avoid that.\n. ",
    "sparkprime": "Most YAML parsers don't support that as it's incompatible with JSON.  I've never seen it used in practice.\n. Most YAML parsers don't support that as it's incompatible with JSON.  I've never seen it used in practice.\n. ",
    "jszroberto": "+1. +1. ",
    "danprince": "I'm having trouble with this too. Even if I unmarshal into a `map[string]interface{}` the nested maps are of type `map[interface{}]interface{}`, meaning I can't then marshal to JSON (which must have string keys).\n\nIs it possible to analyse the type of the interface passed to unmarshal then use the same type for recursively unmarshalling all the way down?\n. I'm having trouble with this too. Even if I unmarshal into a `map[string]interface{}` the nested maps are of type `map[interface{}]interface{}`, meaning I can't then marshal to JSON (which must have string keys).\n\nIs it possible to analyse the type of the interface passed to unmarshal then use the same type for recursively unmarshalling all the way down?\n. ",
    "magnusbaeck": "> Is it possible to analyse the type of the interface passed to unmarshal then use the same type for recursively unmarshalling all the way down?\n\nI'm not sure that would work in all cases. I also had this problem and made a custom unmarshaller in [github.com/elastic/beats:libbeat/common/mapstr.go](https://github.com/elastic/beats/blob/6435194af9f42cbf778ca0a1a92276caf41a0da8/libbeat/common/mapstr.go) that converts the keys of nested maps to strings so that the unmarshalled data can always be marshalled into JSON.\n. > Is it possible to analyse the type of the interface passed to unmarshal then use the same type for recursively unmarshalling all the way down?\n\nI'm not sure that would work in all cases. I also had this problem and made a custom unmarshaller in [github.com/elastic/beats:libbeat/common/mapstr.go](https://github.com/elastic/beats/blob/6435194af9f42cbf778ca0a1a92276caf41a0da8/libbeat/common/mapstr.go) that converts the keys of nested maps to strings so that the unmarshalled data can always be marshalled into JSON.\n. ",
    "sontags": "The approach of @magnusbaeck works like a charm! I changed unmarshalYAML a bit as well as cleanUpMapValue in order to fit my needs (eg. it has now the same signature as yaml.Unmarshal() and ints, bool et al are not quoted since this works fine with encoding/json)... \n\nhttps://github.com/unprofession-al/gerty/blob/master/api/helpers.go\n\n It would be nice to see this in go-yaml as \"compatibility mode\".\n. The approach of @magnusbaeck works like a charm! I changed unmarshalYAML a bit as well as cleanUpMapValue in order to fit my needs (eg. it has now the same signature as yaml.Unmarshal() and ints, bool et al are not quoted since this works fine with encoding/json)... \n\nhttps://github.com/unprofession-al/gerty/blob/master/api/helpers.go\n\n It would be nice to see this in go-yaml as \"compatibility mode\".\n. ",
    "maciejmrowiec": "+1\n. +1\n. ",
    "ns-cweber": "+1\n. +1\n. ",
    "mickep76": "+1\n. I modified the code from the suggestion above and it works nicely. Would be nicer not having to do it thought.\n\n``` go\n// Copyright (c) 2015-2016 Michael Persson\n// Copyright (c) 2012\u20132015 Elasticsearch <http://www.elastic.co>\n//\n// Originally distributed as part of \"beats\" repository (https://github.com/elastic/beats).\n// Modified specifically for \"iodatafmt\" package.\n//\n// Distributed underneath \"Apache License, Version 2.0\" which is compatible with the LICENSE for this package.\n\npackage yaml_mapstr\n\nimport (\n    // Base packages.\n    \"fmt\"\n\n    // Third party packages.\n    \"gopkg.in/yaml.v2\"\n)\n\n// Unmarshal YAML to map[string]interface{} instead of map[interface{}]interface{}.\nfunc Unmarshal(in []byte, out interface{}) error {\n    var res interface{}\n\n    if err := yaml.Unmarshal(in, &res); err != nil {\n        return err\n    }\n    *out.(*interface{}) = cleanupMapValue(res)\n\n    return nil\n}\n\n// Marshal YAML wrapper function.\nfunc Marshal(in interface{}) ([]byte, error) {\n    return yaml.Marshal(in)\n}\n\nfunc cleanupInterfaceArray(in []interface{}) []interface{} {\n    res := make([]interface{}, len(in))\n    for i, v := range in {\n        res[i] = cleanupMapValue(v)\n    }\n    return res\n}\n\nfunc cleanupInterfaceMap(in map[interface{}]interface{}) map[string]interface{} {\n    res := make(map[string]interface{})\n    for k, v := range in {\n        res[fmt.Sprintf(\"%v\", k)] = cleanupMapValue(v)\n    }\n    return res\n}\n\nfunc cleanupMapValue(v interface{}) interface{} {\n    switch v := v.(type) {\n    case []interface{}:\n        return cleanupInterfaceArray(v)\n    case map[interface{}]interface{}:\n        return cleanupInterfaceMap(v)\n    case string:\n        return v\n    default:\n        return fmt.Sprintf(\"%v\", v)\n    }\n}\n```\n. +1\n. I modified the code from the suggestion above and it works nicely. Would be nicer not having to do it thought.\n\n``` go\n// Copyright (c) 2015-2016 Michael Persson\n// Copyright (c) 2012\u20132015 Elasticsearch <http://www.elastic.co>\n//\n// Originally distributed as part of \"beats\" repository (https://github.com/elastic/beats).\n// Modified specifically for \"iodatafmt\" package.\n//\n// Distributed underneath \"Apache License, Version 2.0\" which is compatible with the LICENSE for this package.\n\npackage yaml_mapstr\n\nimport (\n    // Base packages.\n    \"fmt\"\n\n    // Third party packages.\n    \"gopkg.in/yaml.v2\"\n)\n\n// Unmarshal YAML to map[string]interface{} instead of map[interface{}]interface{}.\nfunc Unmarshal(in []byte, out interface{}) error {\n    var res interface{}\n\n    if err := yaml.Unmarshal(in, &res); err != nil {\n        return err\n    }\n    *out.(*interface{}) = cleanupMapValue(res)\n\n    return nil\n}\n\n// Marshal YAML wrapper function.\nfunc Marshal(in interface{}) ([]byte, error) {\n    return yaml.Marshal(in)\n}\n\nfunc cleanupInterfaceArray(in []interface{}) []interface{} {\n    res := make([]interface{}, len(in))\n    for i, v := range in {\n        res[i] = cleanupMapValue(v)\n    }\n    return res\n}\n\nfunc cleanupInterfaceMap(in map[interface{}]interface{}) map[string]interface{} {\n    res := make(map[string]interface{})\n    for k, v := range in {\n        res[fmt.Sprintf(\"%v\", k)] = cleanupMapValue(v)\n    }\n    return res\n}\n\nfunc cleanupMapValue(v interface{}) interface{} {\n    switch v := v.(type) {\n    case []interface{}:\n        return cleanupInterfaceArray(v)\n    case map[interface{}]interface{}:\n        return cleanupInterfaceMap(v)\n    case string:\n        return v\n    default:\n        return fmt.Sprintf(\"%v\", v)\n    }\n}\n```\n. ",
    "matiasinsaurralde": "+1\n. +1\n. ",
    "jveski": "+1\n\nI'm currently maintaining a fork with a one line change to work around this issue.\nhttps://github.com/Navops/yaml/commit/85482c8b225b4cb87bcb8532d2bf81b72b2f4c3c\n\nTo be clear: I believe the library's design is correct given the way YAML handles boolean keys. However, I'd be willing to guess that a majority of implementations don't care about boolean keys and would rather have map keys default to strings.\n\nMaybe exporting `defaultMapType` to allow implementations to mutate it (like my fork) is in order?\n. +1\n\nI'm currently maintaining a fork with a one line change to work around this issue.\nhttps://github.com/Navops/yaml/commit/85482c8b225b4cb87bcb8532d2bf81b72b2f4c3c\n\nTo be clear: I believe the library's design is correct given the way YAML handles boolean keys. However, I'd be willing to guess that a majority of implementations don't care about boolean keys and would rather have map keys default to strings.\n\nMaybe exporting `defaultMapType` to allow implementations to mutate it (like my fork) is in order?\n. ",
    "rjeczalik": "Oh my, extremely sorry for this massive spam. Rebases \u00af\\\\_(\u30c4)_/\u00af. > No problem, but can it stop? :)\r\n\r\nI think it should stop now, apparently github also links on merges, which I can't really do much about. Lesson learned, I'll think twice before linking to external issue.\r\n\r\nOnce again, sorry!. Oh my, extremely sorry for this massive spam. Rebases \u00af\\\\_(\u30c4)_/\u00af. > No problem, but can it stop? :)\r\n\r\nI think it should stop now, apparently github also links on merges, which I can't really do much about. Lesson learned, I'll think twice before linking to external issue.\r\n\r\nOnce again, sorry!. ",
    "msvechla": "Any updates here? Exporting `defaultMapType` would still be an easy / nice fix.. Any updates here? Exporting `defaultMapType` would still be an easy / nice fix.. ",
    "jdonboch": "+1\n. @niemeyer We opened another PR #210 that doesn't change the default behavior and adds the concept of a moded Decoder\n. +1\n. @niemeyer We opened another PR #210 that doesn't change the default behavior and adds the concept of a moded Decoder\n. ",
    "gemcdaniel": "I would like to see a mode on a `Decode` for strict decoding that would be thread-safe.\n. Looks like a newer version has been used instead of this one. I'll be closing this PR.. I would like to see a mode on a `Decode` for strict decoding that would be thread-safe.\n. Looks like a newer version has been used instead of this one. I'll be closing this PR.. ",
    "tomdeering-wf": "Upon further review, it looks to me like the YAML 1.2 spec defines \"quoted scalar indicators\" to be quoted using either straight single or double quotes.\n\nhttp://www.yaml.org/spec/1.2/spec.html#c-single-quote\n. Upon further review, it looks to me like the YAML 1.2 spec defines \"quoted scalar indicators\" to be quoted using either straight single or double quotes.\n\nhttp://www.yaml.org/spec/1.2/spec.html#c-single-quote\n. ",
    "aelsabbahy": "Did you ever find an answer to this?. Did you ever find an answer to this?. ",
    "lox": "Nope, unfortunately not.\n\n\nOn Fri., 9 Dec. 2016 at 9:59 am, Ahmed Elsabbahy <notifications@github.com>\nwrote:\n\n> Did you ever find an answer to this?\n>\n>\n>\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-yaml/yaml/issues/150#issuecomment-265881505>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AAA9jhhjmDrMUD3ijVT_CvyraiGgXau8ks5rGIvegaJpZM4Gto9F>\n> .\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n. Nope, unfortunately not.\n\n\nOn Fri., 9 Dec. 2016 at 9:59 am, Ahmed Elsabbahy <notifications@github.com>\nwrote:\n\n> Did you ever find an answer to this?\n>\n>\n>\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-yaml/yaml/issues/150#issuecomment-265881505>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AAA9jhhjmDrMUD3ijVT_CvyraiGgXau8ks5rGIvegaJpZM4Gto9F>\n> .\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n. ",
    "mwhudson": "Ping.\n. One fix would be to not probe for MarshalYAML on anonymous fields -- it doesn't make a great deal of sense I think?\n. Ping.\n. One fix would be to not probe for MarshalYAML on anonymous fields -- it doesn't make a great deal of sense I think?\n. ",
    "geramirez": "ahh, the solution is here: #94 please merge that :)\n. ahh, the solution is here: #94 please merge that :)\n. ",
    "davidje13": "We have created a new pull request to resolve this; it includes tests for the situation described, and tests for valid cases (e.g. duplicate values are OK; only check for duplicate keys). We have created a new pull request to resolve this; it includes tests for the situation described, and tests for valid cases (e.g. duplicate values are OK; only check for duplicate keys). ",
    "stub42": "Can this land on the v2 branch, or does this fix break backwards compatibility and need to land on a v3 branch?. Can this land on the v2 branch, or does this fix break backwards compatibility and need to land on a v3 branch?. ",
    "blaubaer": "Out of date and not easily mergeable. Create a new one.\n. Out of date and not easily mergeable. Create a new one.\n. ",
    "excilsploft": "As someone who uses the library, I want to say first off thank you for the library and the work you have done. Speaking only for myself, I would really like to see the Encoder and Decoder exported for streaming use.  That in my view would solve the issue #154 and would actually behave a lot more like the python and ruby yaml packages ( ie update the underlying keys value with the new value effectively disregarding the former).  Let the user implement their own business logic for handling duplicate keys.  Anyway I know I am not saying anything you do not know but that is what I would like to see in a v3 go-yaml package.  Thanks again.\n. As someone who uses the library, I want to say first off thank you for the library and the work you have done. Speaking only for myself, I would really like to see the Encoder and Decoder exported for streaming use.  That in my view would solve the issue #154 and would actually behave a lot more like the python and ruby yaml packages ( ie update the underlying keys value with the new value effectively disregarding the former).  Let the user implement their own business logic for handling duplicate keys.  Anyway I know I am not saying anything you do not know but that is what I would like to see in a v3 go-yaml package.  Thanks again.\n. ",
    "jbiel": "This is an issue for me.\n. This is an issue for me.\n. ",
    "qix": "I'm seeing this issue in an unlucky git commit hash that contained only digits `0787904`.\n\nPython serializes it to an unquoted string, which I don't like _but_ is technically okay I believe.\n\n```\nprint yaml.safe_dump({'test': '0787904'}, default_flow_style=False)\ntest: 0787904\n```\n. I'm seeing this issue in an unlucky git commit hash that contained only digits `0787904`.\n\nPython serializes it to an unquoted string, which I don't like _but_ is technically okay I believe.\n\n```\nprint yaml.safe_dump({'test': '0787904'}, default_flow_style=False)\ntest: 0787904\n```\n. ",
    "CpuID": "This would be awesome to have resolved, docker-compose.yml ports are recommended to be defined as strings instead of integers.\n. This would be awesome to have resolved, docker-compose.yml ports are recommended to be defined as strings instead of integers.\n. ",
    "dsegan": "FWIW, the spec seems to confirm this is wrong: http://yaml.org/spec/1.2/spec.html#id2803828\r\n\r\nIntegers are  0 | -? [1-9] [0-9]*. FWIW, the spec seems to confirm this is wrong: http://yaml.org/spec/1.2/spec.html#id2803828\r\n\r\nIntegers are  0 | -? [1-9] [0-9]*. ",
    "howbazaar": "PR #171 doesn't actually fix this issue.. PR #171 doesn't actually fix this issue.. ",
    "jameinel": "The regex in #171 uses: var yamlStyleFloat = regexp.MustCompile(`^[-+]?[0-9]*\\.?[0-9]+([eE][-+][0-9]+)?$`)\r\nThe linked spec says for integers: http://yaml.org/spec/1.2/spec.html#id2803828\r\n0 | -? [1-9] [0-9]*\r\n\r\nWhich would be \"0\" *or* negative *or* must not start with a 0 character.\r\n\r\nIOW, Octal integers are disallowed. As is '-0'.  The YAML spec also doesn't allow a leading \"+\" sign.\r\n\r\nFor floats it allows:\r\n-? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?\r\n\r\nWhich again doesn't allow a leading +, only in the exponent section, and it also doesn't allow a leading 0.. The regex in #171 uses: var yamlStyleFloat = regexp.MustCompile(`^[-+]?[0-9]*\\.?[0-9]+([eE][-+][0-9]+)?$`)\r\nThe linked spec says for integers: http://yaml.org/spec/1.2/spec.html#id2803828\r\n0 | -? [1-9] [0-9]*\r\n\r\nWhich would be \"0\" *or* negative *or* must not start with a 0 character.\r\n\r\nIOW, Octal integers are disallowed. As is '-0'.  The YAML spec also doesn't allow a leading \"+\" sign.\r\n\r\nFor floats it allows:\r\n-? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?\r\n\r\nWhich again doesn't allow a leading +, only in the exponent section, and it also doesn't allow a leading 0.. ",
    "ebrady": "This seems to be solved in this existing PR: \"make compatible with Go 1.6 #152\"\n\nOnce that's accepted (or something like it) this should go away it seems...\n. This seems to be solved in this existing PR: \"make compatible with Go 1.6 #152\"\n\nOnce that's accepted (or something like it) this should go away it seems...\n. ",
    "tony": "Why pick a license more restrictive than golang and libyaml's C implementation?\n\nThe license isn't backwards compatible... You have to end up reinventing the wheel rewriting code under a portable license.\n\nI recommend changing the license or contributing to a different project with a more permissive license. 2, 5, 10 years down the line, if you find your predicament isn't compatible with LGPL - you'll have no choice but to start over and write from scratch.\n. As an update, I found an alternative, https://github.com/cloudfoundry-incubator/candiedyaml. docker/libcompose switch from this project to it in https://github.com/docker/libcompose/pull/91.\n. Why pick a license more restrictive than golang and libyaml's C implementation?\n\nThe license isn't backwards compatible... You have to end up reinventing the wheel rewriting code under a portable license.\n\nI recommend changing the license or contributing to a different project with a more permissive license. 2, 5, 10 years down the line, if you find your predicament isn't compatible with LGPL - you'll have no choice but to start over and write from scratch.\n. As an update, I found an alternative, https://github.com/cloudfoundry-incubator/candiedyaml. docker/libcompose switch from this project to it in https://github.com/docker/libcompose/pull/91.\n. ",
    "zubairhamed": "good to hear. hey i would appreciate it if you also state, whenever you can, if there were any specific steps you took to relicense this. I'm just curious to know if there are any specifics to changing the licenses of a project (other than the obvious license file change).\n. good to hear. hey i would appreciate it if you also state, whenever you can, if there were any specific steps you took to relicense this. I'm just curious to know if there are any specifics to changing the licenses of a project (other than the obvious license file change).\n. ",
    "hairyhenderson": "@niemeyer - good to hear the license is being changed! Are there any updates on the effort?\n. @niemeyer - good to hear the license is being changed! Are there any updates on the effort?\n. ",
    "marcosnils": "Any updates on this?. Looking forward for this functionality. @niemeyer \n. Any updates on this?. Looking forward for this functionality. @niemeyer \n. ",
    "guilhem": "Gentle ping?. Gentle ping?. ",
    "mjs": "FWIW, encoding/json will only call MarshalJSON on an anonymous field when there's exactly one anonymous field. MarshalJSON on embedded types is ignored when there's more than one. \n\nI'm not convinced honouring MarshalJSON/MarshalYAML is a good idea for _any_ anonymous field as this means the contents of the containing struct aren't included in the YAML output.\n. FWIW, encoding/json will only call MarshalJSON on an anonymous field when there's exactly one anonymous field. MarshalJSON on embedded types is ignored when there's more than one. \n\nI'm not convinced honouring MarshalJSON/MarshalYAML is a good idea for _any_ anonymous field as this means the contents of the containing struct aren't included in the YAML output.\n. ",
    "rezxv": "Is the first option actually supported? I've tested it and the property's value resets to its type's default if the value is not provided in the yaml.\n\nEdit: I've also searched the tests and unable to find one for this case.\n. Is the first option actually supported? I've tested it and the property's value resets to its type's default if the value is not provided in the yaml.\n\nEdit: I've also searched the tests and unable to find one for this case.\n. ",
    "deitch": "Been banging my head on this for the last while. Is there any way to force it *not* to break? It should be perfectly legitimate to say, \"give me a really long line\".. Been banging my head on this for the last while. Is there any way to force it *not* to break? It should be perfectly legitimate to say, \"give me a really long line\".. ",
    "wayt": "I'm facing the same issue. A tag would be very nice.. I understand this is valid according to the specification, but not compatible in all implementations (Perl for instance).\r\nA fallback option would be appreciated.. I'm facing the same issue. A tag would be very nice.. I understand this is valid according to the specification, but not compatible in all implementations (Perl for instance).\r\nA fallback option would be appreciated.. ",
    "petercolberg": "Debian packages each Go package repository as a separate Debian source package. The version of a Debian package includes an upstream part (e.g. \"1.0.0\") and a Debian part (e.g. \"-1\"). If an upstream author does not tag releases, we need to make up an upstream version number based on the git commit and date, which yields unwieldy versions that are cumbersome to compare. \n\nAll you would have to do is regularly tag releases, which yields handy Debian package versions and makes it easy to automatically [notice new upstream releases](https://tracker.debian.org/pkg/golang-gopkg-tylerb-graceful.v1) using the Debian package tracker.\n. Debian packages each Go package repository as a separate Debian source package. The version of a Debian package includes an upstream part (e.g. \"1.0.0\") and a Debian part (e.g. \"-1\"). If an upstream author does not tag releases, we need to make up an upstream version number based on the git commit and date, which yields unwieldy versions that are cumbersome to compare. \n\nAll you would have to do is regularly tag releases, which yields handy Debian package versions and makes it easy to automatically [notice new upstream releases](https://tracker.debian.org/pkg/golang-gopkg-tylerb-graceful.v1) using the Debian package tracker.\n. ",
    "Nerdmaster": "Yes, and also consider tagging with the \"v\" prefix (\"v1.0.0\") - then tools like \"gb\" can pull stable releases without the need for gopkg.in (which I'm finding is down or unresponsive a lot more than github)\n. Yes, and also consider tagging with the \"v\" prefix (\"v1.0.0\") - then tools like \"gb\" can pull stable releases without the need for gopkg.in (which I'm finding is down or unresponsive a lot more than github)\n. ",
    "akshayjshah": "This would be extremely helpful - I know that the authors of this package prefer the `gopkg.in` approach to versioning, but most of the community is converging on tagged releases.. This would be extremely helpful - I know that the authors of this package prefer the `gopkg.in` approach to versioning, but most of the community is converging on tagged releases.. ",
    "jackman0": "FYI, this isn't a problem with the following library:\nhttps://github.com/ghodss/yaml\n. FYI, this isn't a problem with the following library:\nhttps://github.com/ghodss/yaml\n. ",
    "iigorr": "Hi @jackmanlabs,\n\nthis is by design (https://github.com/go-yaml/yaml/issues/63). There is the `inline` annotation for that. See docs for annotations https://godoc.org/gopkg.in/yaml.v2\n\nIn your example:\n\n``` go\ntype OuterType struct {\n    InnerType `yaml:\",inline\"`\n    Population Exp `yaml:\"population\" json:\"population\"`\n}\n```\n. Hi @jackmanlabs,\n\nthis is by design (https://github.com/go-yaml/yaml/issues/63). There is the `inline` annotation for that. See docs for annotations https://godoc.org/gopkg.in/yaml.v2\n\nIn your example:\n\n``` go\ntype OuterType struct {\n    InnerType `yaml:\",inline\"`\n    Population Exp `yaml:\"population\" json:\"population\"`\n}\n```\n. ",
    "kindlyseth": "Current v2 is unable to parse the files I already have directly into the 3rd party data structures they need to be loaded into because it only tries the case converted names.\n\nI could convert the files, but simply converting the field names to lower case would be the wrong conversion. Converting to snake case would be correct, although not better in this case, but then the files still wouldn't load. I'll end up using an intermediate data structure, but that's effort I wouldn't have to spend if this pull request had been merged.\n\nIt's been 5 months since this PR was submitted and there's no record of feedback, so it doesn't appear that sufficient resources are being applied. If someone's time needs to be sponsored, I might be able to apply resources. If the problem is lack of recruiting trusted people, I'm less able.\n. I ended up going the same route, creating https://github.com/kindlyops/yaml which I expect to make track the v2 branch but with the one line change to match field names exactly applied.\n. Current v2 is unable to parse the files I already have directly into the 3rd party data structures they need to be loaded into because it only tries the case converted names.\n\nI could convert the files, but simply converting the field names to lower case would be the wrong conversion. Converting to snake case would be correct, although not better in this case, but then the files still wouldn't load. I'll end up using an intermediate data structure, but that's effort I wouldn't have to spend if this pull request had been merged.\n\nIt's been 5 months since this PR was submitted and there's no record of feedback, so it doesn't appear that sufficient resources are being applied. If someone's time needs to be sponsored, I might be able to apply resources. If the problem is lack of recruiting trusted people, I'm less able.\n. I ended up going the same route, creating https://github.com/kindlyops/yaml which I expect to make track the v2 branch but with the one line change to match field names exactly applied.\n. ",
    "alexjh": "~~I'm looking into the CLA agreements that HPE Cloud has with Canonical, will update when I have more info.~~\n\nSigned the individual agreement as we don't have an org-wide one set up.\n. @niemeyer Just wanted to ping you on this, I realized that I edited the comment but that may not have generated a new notification.\n. @niemeyer Since the license changed, should I close and resubmit this PR? I'm fine with my change being Apache 2 licensed, so I can also leave it as is.\n. > treat it as a float if there's a decimal point in the mantissa or a + or - sign before the exponent.\r\n\r\n@rogpeppe I think that's reasonable from our use case. A git commit ID shouldn't have those characters :). ~~I'm looking into the CLA agreements that HPE Cloud has with Canonical, will update when I have more info.~~\n\nSigned the individual agreement as we don't have an org-wide one set up.\n. @niemeyer Just wanted to ping you on this, I realized that I edited the comment but that may not have generated a new notification.\n. @niemeyer Since the license changed, should I close and resubmit this PR? I'm fine with my change being Apache 2 licensed, so I can also leave it as is.\n. > treat it as a float if there's a decimal point in the mantissa or a + or - sign before the exponent.\r\n\r\n@rogpeppe I think that's reasonable from our use case. A git commit ID shouldn't have those characters :). ",
    "aarondl": "Could really use this. It prevents yaml generated from other languages from being consumed by Go.\n. Could really use this. It prevents yaml generated from other languages from being consumed by Go.\n. ",
    "dmitris": "fixed in https://github.com/go-yaml/yaml/pull/181/files - @niemeyer , could you take a look, please - would you accept the PR? \n. fixed in https://github.com/go-yaml/yaml/pull/181/files - @niemeyer , could you take a look, please - would you accept the PR? \n. ",
    "y0ssar1an": "Fixed in #181, with additional fixes for the Travis build.\n. Fixed in #181, with additional fixes for the Travis build.\n. ",
    "abelino": "\ud83d\udc4d \n. \ud83d\udc4d \n. ",
    "mrbuk": "Hey Eric,\n\nI think this is related to the git version that CentOS 6.x is using (1.7.1). I fixed that issue on my CentOS machine by installing the newest git manually. See the following lines in my Dockerfile\n\nfrom\n https://gist.github.com/mrbuk/8b0bb7a34391c8f67ce90c23db631b00#file-dockerfile-L19\n\nto\nhttps://gist.github.com/mrbuk/8b0bb7a34391c8f67ce90c23db631b00#file-dockerfile-L34\n\nBR\nMarkus\n. Hey Eric,\n\nI think this is related to the git version that CentOS 6.x is using (1.7.1). I fixed that issue on my CentOS machine by installing the newest git manually. See the following lines in my Dockerfile\n\nfrom\n https://gist.github.com/mrbuk/8b0bb7a34391c8f67ce90c23db631b00#file-dockerfile-L19\n\nto\nhttps://gist.github.com/mrbuk/8b0bb7a34391c8f67ce90c23db631b00#file-dockerfile-L34\n\nBR\nMarkus\n. ",
    "mogthesprog": "Is it possible to get this merged? . I hadn't noticed that. I'm pretty sure it's not needed at all. I can raise another PR without that change in it?. Sure, no worries. Bear with me a sec... Cheers! :) . Is it possible to get this merged? . I hadn't noticed that. I'm pretty sure it's not needed at all. I can raise another PR without that change in it?. Sure, no worries. Bear with me a sec... Cheers! :) . ",
    "bradrydzewski": "@niemeyer if we send a patch for this what is the process for getting it merged? Is the v2 branch frozen or are you accepting changes? If not, is there a timeline for v3?\n\ncc @donny-dont\n. @vinzenz yep, that did the trick. I'm vendoring your patch at the moment, but hopefully the pull request can get merged in the near future. Thanks! \n. @vinzenz I confirmed this PR fixes issue #184 as well. Thanks!\n. @niemeyer if we send a patch for this what is the process for getting it merged? Is the v2 branch frozen or are you accepting changes? If not, is there a timeline for v3?\n\ncc @donny-dont\n. @vinzenz yep, that did the trick. I'm vendoring your patch at the moment, but hopefully the pull request can get merged in the near future. Thanks! \n. @vinzenz I confirmed this PR fixes issue #184 as well. Thanks!\n. ",
    "Mange": "Thank you! \n. Thank you! \n. ",
    "akutz": "Hi,\n\nI was wondering if there are any thoughts on this? Thanks!\n. Hi,\n\nI was wondering if there are any thoughts on this? Thanks!\n. Hi there. I suppose this is just a dead repository then.. Hi,\n\nI was wondering if there are any thoughts on this? Thanks!\n. Hi,\n\nI was wondering if there are any thoughts on this? Thanks!\n. Hi there. I suppose this is just a dead repository then.. ",
    "zythosec": "I see this PR for #154 has been sitting since August, is there anything that can be done to get it moving forward?. I see this PR for #154 has been sitting since August, is there anything that can be done to get it moving forward?. ",
    "justinclift": "As a thought, this looks related to #189.\n. As a thought, this looks related to #189.\n. ",
    "brosander": "[LGPL is a blocker for Apache projects.](http://www.apache.org/legal/resolved.html#category-x)\n\nI'm exploring using this library but it would be awesome if #189 could be merged to clear up the ambiguity.\n\nThanks!\n. @niemeyer thank you sir \ud83d\ude04 \n. \ud83d\udc4d \n. @niemeyer Looks like I missed the boat, #189 already has same change \ud83d\ude04 \n. [LGPL is a blocker for Apache projects.](http://www.apache.org/legal/resolved.html#category-x)\n\nI'm exploring using this library but it would be awesome if #189 could be merged to clear up the ambiguity.\n\nThanks!\n. @niemeyer thank you sir \ud83d\ude04 \n. \ud83d\udc4d \n. @niemeyer Looks like I missed the boat, #189 already has same change \ud83d\ude04 \n. ",
    "benfleis": "+1\n\nCan this get some love?\n. +1\n\nCan this get some love?\n. ",
    "prashantv": "@niemeyer Would you be able to take a look at this?\n. @vinzenz The yaml marshaller produces a stable output by iterating over keys in sorted order, if you saw the code here:\nhttps://github.com/prashantv/yaml/blob/v2/sorter.go\n\nI am aware of map iteration order being undefined, but marshallers typically have stable output (try `json.Marshal`), which is typically achieved by iterating over the map in sorted key order. The issue here is that the sorting has a bug when dealing with numbers.\n\nI have a fix for this issue in https://github.com/go-yaml/yaml/issues/195 which requires a minor change to the sorter. I was just hoping that @niemeyer would be able to review that change, since I'd like to avoid using a fork of this library.\n. Hi @niemeyer, would you be able to look at this change? I'd love to get this merged in and avoid maintaining a fork!\n. @niemeyer Would you be able to take a look at this?\n. @vinzenz The yaml marshaller produces a stable output by iterating over keys in sorted order, if you saw the code here:\nhttps://github.com/prashantv/yaml/blob/v2/sorter.go\n\nI am aware of map iteration order being undefined, but marshallers typically have stable output (try `json.Marshal`), which is typically achieved by iterating over the map in sorted key order. The issue here is that the sorting has a bug when dealing with numbers.\n\nI have a fix for this issue in https://github.com/go-yaml/yaml/issues/195 which requires a minor change to the sorter. I was just hoping that @niemeyer would be able to review that change, since I'd like to avoid using a fork of this library.\n. Hi @niemeyer, would you be able to look at this change? I'd love to get this merged in and avoid maintaining a fork!\n. ",
    "paulmach": "I was also curious and the answer is yes, code:\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\r\n\tyaml \"gopkg.in/yaml.v2\"\r\n)\r\n\r\nvar raw string = `default: &default\r\n  adapter: postgresql\r\n  encoding: unicode\r\n  pool: 5\r\n  host: localhost\r\n  username: postgres\r\n  password: 9841\r\n\r\ndevelopment:\r\n  <<: *default\r\n  database: db_dev\r\n  host: localhost\r\n  username: postgres\r\n  password: 1234`\r\n\r\nfunc main() {\r\n\tm := make(map[interface{}]interface{})\r\n\terr := yaml.Unmarshal([]byte(raw), &m)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"error: %v\", err)\r\n\t}\r\n\r\n\tlog.Printf(\"%+v\", m)\r\n\tlog.Printf(\"%+v\", m[\"development\"])\r\n}\r\n```\r\n\r\noutput:\r\n```\r\n2017/03/29 15:01:25 map[default:map[adapter:postgresql encoding:unicode pool:5 host:localhost username:postgres password:9841] development:map[host:localhost username:postgres password:1234 database:db_dev adapter:postgresql encoding:unicode pool:5]]\r\n2017/03/29 15:01:25 map[database:db_dev adapter:postgresql encoding:unicode pool:5 host:localhost username:postgres password:1234]\r\n```. I was also curious and the answer is yes, code:\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\r\n\tyaml \"gopkg.in/yaml.v2\"\r\n)\r\n\r\nvar raw string = `default: &default\r\n  adapter: postgresql\r\n  encoding: unicode\r\n  pool: 5\r\n  host: localhost\r\n  username: postgres\r\n  password: 9841\r\n\r\ndevelopment:\r\n  <<: *default\r\n  database: db_dev\r\n  host: localhost\r\n  username: postgres\r\n  password: 1234`\r\n\r\nfunc main() {\r\n\tm := make(map[interface{}]interface{})\r\n\terr := yaml.Unmarshal([]byte(raw), &m)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"error: %v\", err)\r\n\t}\r\n\r\n\tlog.Printf(\"%+v\", m)\r\n\tlog.Printf(\"%+v\", m[\"development\"])\r\n}\r\n```\r\n\r\noutput:\r\n```\r\n2017/03/29 15:01:25 map[default:map[adapter:postgresql encoding:unicode pool:5 host:localhost username:postgres password:9841] development:map[host:localhost username:postgres password:1234 database:db_dev adapter:postgresql encoding:unicode pool:5]]\r\n2017/03/29 15:01:25 map[database:db_dev adapter:postgresql encoding:unicode pool:5 host:localhost username:postgres password:1234]\r\n```. ",
    "m-masataka": "@niemeyer @azylman Why don't you merge this commit?\r\nIt's critical issue for another product that include ``go-yaml/yaml``.\r\n\r\n. @niemeyer\r\nThanks for reply.\r\nI make sure your answer and changed my mind.\r\nIt's not go-yaml's  job.\r\nHowever, it's couse some bugs. Does go-yaml has any documents? If not, we should generate warning for omitting the unit of time.\r\nIf you need, I implement the warning function or add the documentation.\r\n. @niemeyer @azylman Why don't you merge this commit?\r\nIt's critical issue for another product that include ``go-yaml/yaml``.\r\n\r\n. @niemeyer\r\nThanks for reply.\r\nI make sure your answer and changed my mind.\r\nIt's not go-yaml's  job.\r\nHowever, it's couse some bugs. Does go-yaml has any documents? If not, we should generate warning for omitting the unit of time.\r\nIf you need, I implement the warning function or add the documentation.\r\n. ",
    "jlozano": "NVM guess this is part of the YAML spec\n. NVM guess this is part of the YAML spec\n. ",
    "technosophos": "I'd like this feature as well.. I'd like this feature as well.. ",
    "tomnz": "We're trying to support custom parsing into decimals with go-yaml. Currently we have to special case it (look for a particular structure e.g. `{ decimal: \"0.123\" }` in the YML), but it would be much cleaner to parse it as `!dec \"0.123\"` instead. Looks like this diff would work great! It's a shame we can't use custom YAML tags currently.. We're trying to support custom parsing into decimals with go-yaml. Currently we have to special case it (look for a particular structure e.g. `{ decimal: \"0.123\" }` in the YML), but it would be much cleaner to parse it as `!dec \"0.123\"` instead. Looks like this diff would work great! It's a shame we can't use custom YAML tags currently.. ",
    "jdamick": "@niemeyer any chance we can get this feature added?. @niemeyer any chance we can get this feature added?. ",
    "predatorian3": "@niemeyer I always thought that YAML needed to have the spaces for proper indentation to be valid yaml. Reading the output yaml it would seem that its just making an empty object and then two following arrays. \n. You're right, it did work, and marshal properly. I guess that this can be closed as a non-issue. I just had to think about how the yaml is actually parsed. \n. @niemeyer I always thought that YAML needed to have the spaces for proper indentation to be valid yaml. Reading the output yaml it would seem that its just making an empty object and then two following arrays. \n. You're right, it did work, and marshal properly. I guess that this can be closed as a non-issue. I just had to think about how the yaml is actually parsed. \n. ",
    "kevinburke": "FWIW, I wrote about this problem recently - you may want to try the xml, hcl, or protobuf parsers. https://kev.inburke.com/kevin/more-comment-preserving-configuration-parsers/\n. triaging bugs would probably help, indicating issues that should be closed would help, performing code reviews on open issues would probably help. FWIW, I wrote about this problem recently - you may want to try the xml, hcl, or protobuf parsers. https://kev.inburke.com/kevin/more-comment-preserving-configuration-parsers/\n. triaging bugs would probably help, indicating issues that should be closed would help, performing code reviews on open issues would probably help. ",
    "nf": "I would like to see this merged if possible, @niemeyer.\n. I would like to see this merged if possible, @niemeyer.\n. ",
    "autrilla": "I'm not sure why this is broken on tip\n. The tests now pass, cc @jvehent . Yes, that's what's happening here. Keeping the comment where it was\ninitially place is a harder problem, and it's specially harder considering\niirc currently the library doesn't keep tokens on the same \"style\" they\nwere in. So a round trip might change indentation, or even string style\n(not particularly sure about this last one).\n\nOn Tue, Apr 25, 2017 at 7:25 PM Alex Buchanan <notifications@github.com>\nwrote:\n\n> Oh, I actually just noticed that the \"Database path\" comment is actually\n> bumped up a level, incorrectly, to the \"database\" key.\n>\n> Perhaps this is related to the original comment in this PR:\n>\n> We don't retain indentation information for comments. Comments are placed\n> at the same indentation level as the previous token.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-yaml/yaml/pull/219#issuecomment-297104424>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/ACJ-V-IM2mNtcXsUE0clFEWgUkeiYXbDks5rziyLgaJpZM4Knlz9>\n> .\n>\n. @josephholsten this is probably never going to get to the level of ruaml.yaml's round trip parser. go-yaml doesn't keep style information, and changing it so it does would be hard. Using this to reformat your yaml will remove some information. I'm not sure if this answers your question, but the progress you see here is all the progress we've made.. Well, this PR has been open for a while now and hasn't received any comments from contributors, so I don't know if there's any plan to ever maintain presentation layer information such as comments. A fork that keeps this info would be great, and you might consider starting from what I worked on. A PR back to mozilla-services' fork that retains more presentation information would be amazing \ud83d\ude04 . I'm not sure why this is broken on tip\n. The tests now pass, cc @jvehent . Yes, that's what's happening here. Keeping the comment where it was\ninitially place is a harder problem, and it's specially harder considering\niirc currently the library doesn't keep tokens on the same \"style\" they\nwere in. So a round trip might change indentation, or even string style\n(not particularly sure about this last one).\n\nOn Tue, Apr 25, 2017 at 7:25 PM Alex Buchanan <notifications@github.com>\nwrote:\n\n> Oh, I actually just noticed that the \"Database path\" comment is actually\n> bumped up a level, incorrectly, to the \"database\" key.\n>\n> Perhaps this is related to the original comment in this PR:\n>\n> We don't retain indentation information for comments. Comments are placed\n> at the same indentation level as the previous token.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-yaml/yaml/pull/219#issuecomment-297104424>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/ACJ-V-IM2mNtcXsUE0clFEWgUkeiYXbDks5rziyLgaJpZM4Knlz9>\n> .\n>\n. @josephholsten this is probably never going to get to the level of ruaml.yaml's round trip parser. go-yaml doesn't keep style information, and changing it so it does would be hard. Using this to reformat your yaml will remove some information. I'm not sure if this answers your question, but the progress you see here is all the progress we've made.. Well, this PR has been open for a while now and hasn't received any comments from contributors, so I don't know if there's any plan to ever maintain presentation layer information such as comments. A fork that keeps this info would be great, and you might consider starting from what I worked on. A PR back to mozilla-services' fork that retains more presentation information would be amazing \ud83d\ude04 . ",
    "fabianofranz": "Here's the initial motivation for this in Kubernetes, and one possible idea for \"fixing\" it:\n\nhttps://github.com/kubernetes/kubernetes/issues/34146#issuecomment-255821722\n. Here's the initial motivation for this in Kubernetes, and one possible idea for \"fixing\" it:\n\nhttps://github.com/kubernetes/kubernetes/issues/34146#issuecomment-255821722\n. ",
    "elopio": "fwiw: https://github.com/yaml/libyaml/commit/37c92e06f887c85d39633ae2a055381ebe1c3d63. fwiw: https://github.com/yaml/libyaml/commit/37c92e06f887c85d39633ae2a055381ebe1c3d63. ",
    "dsnet": "\\cc @niemeyer, can we get this merged?\nThanks.\n. \\cc @niemeyer, can we get this merged?\nThanks.\n. ",
    "joshwget": "Nice work! We had to implement a quick and dirty patch similar to this to avoid the massive memory consumption that came from copied references. Much better to have upstream fixed.. Nice work! We had to implement a quick and dirty patch similar to this to avoid the massive memory consumption that came from copied references. Much better to have upstream fixed.. ",
    "buchanae": "I'm missing a comment from the \"path\" key in the test program below. Notice the comment **do** show up for all other keys (e.g. \"server\")\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\nimport \"github.com/mozilla-services/yaml\"\r\n\r\nvar data = `\r\n# Database\r\ndatabase:\r\n  # Database path\r\n  path: 'path/to/db'\r\n  # Server port\r\n  server: 9090\r\n  # Sub comment\r\n  sub:\r\n    val: foo\r\n`\r\n\r\nfunc main() {\r\n  b := []byte(data)\r\n  unmarshaler := yaml.CommentUnmarshaler{}\r\n  doc := yaml.MapSlice{}\r\n  err := unmarshaler.Unmarshal(b, &doc)\r\n  if err != nil {\r\n    panic(err)\r\n  }\r\n\r\n  ob, _ := yaml.Marshal(doc)\r\n  fmt.Println(doc)\r\n  fmt.Println(string(ob))\r\n\r\n  if string(ob) != data {\r\n    panic(\"Failed assertion\")\r\n  }\r\n}\r\n```\r\n\r\nand the output\r\n```\r\n[{{ Database path} <nil>} {database [{path path/to/db} {{ Server port} <nil>} {server 9090} {{ Sub comment} <nil>} {sub [{val foo} {{ Slice comment} <nil>}]} {sl [one { Two} two]}]}]\r\n# Database path\r\ndatabase:\r\n  path: path/to/db\r\n  # Server port\r\n  server: 9090\r\n  # Sub comment\r\n  sub:\r\n    val: foo\r\n    # Slice comment\r\n  sl:\r\n  - one\r\n  # Two\r\n  - two\r\n\r\npanic: Failed assertion\r\n\r\ngoroutine 1 [running]:\r\nmain.main()\r\n\t/Users/buchanae/go/src/scratch/potato/potato.go:37 +0x387\r\nexit status 2\r\n```\r\n\r\nThanks for doing this. I'm hoping to use this to better manage YAML config files. Let me know I can help move this along somehow.. Oh, I actually just noticed that the \"Database path\" comment is actually bumped up a level, incorrectly, to the \"database\" key.\r\n\r\nPerhaps this is related to the original comment in this PR:\r\n\r\n> We don't retain indentation information for comments. Comments are placed at the same indentation level as the previous token.. I'm missing a comment from the \"path\" key in the test program below. Notice the comment **do** show up for all other keys (e.g. \"server\")\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\nimport \"github.com/mozilla-services/yaml\"\r\n\r\nvar data = `\r\n# Database\r\ndatabase:\r\n  # Database path\r\n  path: 'path/to/db'\r\n  # Server port\r\n  server: 9090\r\n  # Sub comment\r\n  sub:\r\n    val: foo\r\n`\r\n\r\nfunc main() {\r\n  b := []byte(data)\r\n  unmarshaler := yaml.CommentUnmarshaler{}\r\n  doc := yaml.MapSlice{}\r\n  err := unmarshaler.Unmarshal(b, &doc)\r\n  if err != nil {\r\n    panic(err)\r\n  }\r\n\r\n  ob, _ := yaml.Marshal(doc)\r\n  fmt.Println(doc)\r\n  fmt.Println(string(ob))\r\n\r\n  if string(ob) != data {\r\n    panic(\"Failed assertion\")\r\n  }\r\n}\r\n```\r\n\r\nand the output\r\n```\r\n[{{ Database path} <nil>} {database [{path path/to/db} {{ Server port} <nil>} {server 9090} {{ Sub comment} <nil>} {sub [{val foo} {{ Slice comment} <nil>}]} {sl [one { Two} two]}]}]\r\n# Database path\r\ndatabase:\r\n  path: path/to/db\r\n  # Server port\r\n  server: 9090\r\n  # Sub comment\r\n  sub:\r\n    val: foo\r\n    # Slice comment\r\n  sl:\r\n  - one\r\n  # Two\r\n  - two\r\n\r\npanic: Failed assertion\r\n\r\ngoroutine 1 [running]:\r\nmain.main()\r\n\t/Users/buchanae/go/src/scratch/potato/potato.go:37 +0x387\r\nexit status 2\r\n```\r\n\r\nThanks for doing this. I'm hoping to use this to better manage YAML config files. Let me know I can help move this along somehow.. Oh, I actually just noticed that the \"Database path\" comment is actually bumped up a level, incorrectly, to the \"database\" key.\r\n\r\nPerhaps this is related to the original comment in this PR:\r\n\r\n> We don't retain indentation information for comments. Comments are placed at the same indentation level as the previous token.. ",
    "josephholsten": "@autrilla any progress with this? I'm really keen on replacing my usage of https://pypi.python.org/pypi/yamlfmt/0.1.5 with this. ah, that's good to know. how would you feel about a fork that did keep that info? Would it make sense for that to live in a separate package, or do you think that might be worth being part of go-yaml?. @autrilla any progress with this? I'm really keen on replacing my usage of https://pypi.python.org/pypi/yamlfmt/0.1.5 with this. ah, that's good to know. how would you feel about a fork that did keep that info? Would it make sense for that to live in a separate package, or do you think that might be worth being part of go-yaml?. ",
    "donny-dont": "@niemeyer any chance you could give this a review? It getting merged will save us a goofy workaround in Drone.\n. @niemeyer any chance you could give this a review? It getting merged will save us a goofy workaround in Drone.\n. ",
    "mbndr": "Same problem here. It would be nice that if something fails, I will get it through the `err` return value.. Same problem here. It would be nice that if something fails, I will get it through the `err` return value.. ",
    "vschoener": "Would be nice to know which field is throwing this error, just got the same and I don't know why, need to use debug I think. Would be nice to know which field is throwing this error, just got the same and I don't know why, need to use debug I think. ",
    "jan0022": "I was getting the same error until I passed struct by address \"&c\"\r\n_ = yaml.Unmarshal([]byte(problemYaml), &c)\r\n. I was getting the same error until I passed struct by address \"&c\"\r\n_ = yaml.Unmarshal([]byte(problemYaml), &c)\r\n. ",
    "robbrockbank": "Apologies - opened PR against the wrong repo.. Apologies - opened PR against the wrong repo.. ",
    "cppforlife": "looks like fixed by https://github.com/go-yaml/yaml/commit/a5b47d31c556af34a302ce5d659e6fea44d90de0.. looks like fixed by https://github.com/go-yaml/yaml/commit/a5b47d31c556af34a302ce5d659e6fea44d90de0.. ",
    "alexforever86": "@vanloswang I'm getting this same error. How did you solve this?. @vanloswang I'm getting this same error. How did you solve this?. ",
    "jeppewelling": "Hi Alan,\r\nWhat is the status on this? \r\nIm looking for a YAML AST for GO too, maybe there something I can do to help progress on this pull request?. Hi Alan,\r\nWhat is the status on this? \r\nIm looking for a YAML AST for GO too, maybe there something I can do to help progress on this pull request?. ",
    "nalanj": "I've got a repo here that I've been using for quite a while at work: https://github.com/commondream/yamlast. Hopefully that helps!. I've got a repo here that I've been using for quite a while at work: https://github.com/commondream/yamlast. Hopefully that helps!. ",
    "samczsun": "@commondream Is this PR something you're still interested in maintaining? I see the Travis build is failing and it's been nearly a month but this particular feature is something I'd love to see in this library and I'd rather not abandon all this progress.\r\n\r\n@niemeyer I know you mentioned in #261 that you've asked your friend to help maintain this library but if time is an issue for both of you I'd be happy to contribute mine.. @commondream Is this PR something you're still interested in maintaining? I see the Travis build is failing and it's been nearly a month but this particular feature is something I'd love to see in this library and I'd rather not abandon all this progress.\r\n\r\n@niemeyer I know you mentioned in #261 that you've asked your friend to help maintain this library but if time is an issue for both of you I'd be happy to contribute mine.. ",
    "LLParse": "+1 Would like to see this added. +1 Would like to see this added. ",
    "bbengfort": "Some more information, it looks like the source of the error is the [`isZero()`](https://github.com/go-yaml/yaml/blob/v2/yaml.go#L315) function, though I have not tested this. The time module has a non-standard zero value (e.g. not nil), and as a result provides it's own [`IsZero`](https://golang.org/pkg/time/#Time.IsZero) method. When the yaml method sees the time.Time struct, it iterates through all of its fields to check if they're zero, but since all the time fields are private, it declares the struct zeroed. \r\n\r\nI did some brief research into the reflection package; it looks like we'd have to modify the struct case to detect if it was a time.Time, then use the time.Time.IsZero method in order to have this work correctly; but at the moment I'm not sure how to do that. . Some more information, it looks like the source of the error is the [`isZero()`](https://github.com/go-yaml/yaml/blob/v2/yaml.go#L315) function, though I have not tested this. The time module has a non-standard zero value (e.g. not nil), and as a result provides it's own [`IsZero`](https://golang.org/pkg/time/#Time.IsZero) method. When the yaml method sees the time.Time struct, it iterates through all of its fields to check if they're zero, but since all the time fields are private, it declares the struct zeroed. \r\n\r\nI did some brief research into the reflection package; it looks like we'd have to modify the struct case to detect if it was a time.Time, then use the time.Time.IsZero method in order to have this work correctly; but at the moment I'm not sure how to do that. . ",
    "asheidan": "According to the YAML cookbook I think you need to use \"<<\" as key instead\r\n\r\n```yaml\r\n\"<<\": value\r\n```\r\n\r\nhttp://yaml.org/YAML_for_ruby.html#merge_key. According to the YAML cookbook I think you need to use \"<<\" as key instead\r\n\r\n```yaml\r\n\"<<\": value\r\n```\r\n\r\nhttp://yaml.org/YAML_for_ruby.html#merge_key. ",
    "pierrec": "The struct tag is invalid, it should be (no coma separating the various tags):\r\n`json:\"ip_address\" yaml:\"ip_address\"`. The struct tag is invalid, it should be (no coma separating the various tags):\r\n`json:\"ip_address\" yaml:\"ip_address\"`. ",
    "yacc2007": "thank you for reply. thank you for reply. ",
    "kbalk": "Oh, shoot.  This is not a problem.  I incorrectly specified the tag following the struct name.  It should have been `yaml:\"catalog-url\"`, i.e., the name wasn't in quotes.  Plus my example had underscores not hyphens.  My apologies.. Oh, shoot.  This is not a problem.  I incorrectly specified the tag following the struct name.  It should have been `yaml:\"catalog-url\"`, i.e., the name wasn't in quotes.  Plus my example had underscores not hyphens.  My apologies.. ",
    "lutzhorn": "related: https://github.com/go-yaml/yaml/pull/253. related: https://github.com/go-yaml/yaml/pull/253. ",
    "doroginin": "+1. +1. ",
    "paralin": "It seems the issue is that it doesn't know how to handle arrays of fixed length, I.e. `[2]uint`. It seems the issue is that it doesn't know how to handle arrays of fixed length, I.e. `[2]uint`. ",
    "hiveminded": "You're welcome, good job with the library!. You're welcome, good job with the library!. ",
    "vealexeev": "My fault\r\nhttps://golang.org/pkg/reflect/#StructTag\r\n> By convention, tag strings are a concatenation of optionally space-separated key:\"value\" pairs\r\n\r\nhttps://godoc.org/gopkg.in/yaml.v2\r\n> Struct fields are only unmarshalled if they are exported (have an upper case first letter), and are unmarshalled using the field name lowercased as the default key\r\n\r\nUnmarshalling works as documented.. My fault\r\nhttps://golang.org/pkg/reflect/#StructTag\r\n> By convention, tag strings are a concatenation of optionally space-separated key:\"value\" pairs\r\n\r\nhttps://godoc.org/gopkg.in/yaml.v2\r\n> Struct fields are only unmarshalled if they are exported (have an upper case first letter), and are unmarshalled using the field name lowercased as the default key\r\n\r\nUnmarshalling works as documented.. ",
    "firelizzard18": "So what you're saying is that this package is not \"YAML support for the Go language\" but rather just encoding/decoding support with absolutely no other YAML support?. So what you're saying is that this package is not \"YAML support for the Go language\" but rather just encoding/decoding support with absolutely no other YAML support?. ",
    "jfrabaute": "Any chance to have this merged?\r\n\r\nThanks.. Any chance to have this merged?\r\n\r\nThanks.. ",
    "mattyw": "LGTM. LGTM. ",
    "king-jam": "@niemeyer updated per your note. Was being very detailed. \ud83d\ude03 Should be good to merge now then.. @niemeyer updated per your note. Was being very detailed. \ud83d\ude03 Should be good to merge now then.. ",
    "prateek": "Just a heads up, I'm sure many people have application code which relies on this behaviour. I certainly do. Changing this is going to cause issues for some end-users. . Happy to post a patch if you're good with changing the behaviour. . @niemeyer I understand where you're coming from. Breaking documents that already parse is probably not acceptable, so the strict mode seems like a good path forward. \r\n\r\nA `yaml` file is **not** a map of unordered fields, it has to follow the rules dictated by spec. The rule I mentioned is important as the spec allows for multiple nodes to be aliased with the same identifier. The ordering constraint is required to be deterministic about which anchor node is referenced by an aliased node. For e.g. both the PyYAML (Python's YAML library) and Psych (Ruby's YAML library) both fail at parsing the example I posted for this reason. \r\n. @niemeyer The spec details three distinct models: `representation`, `serialisation`, and `presentation`. The bits you quoted are talking about a `representation` model.  A file on disk must be treated as `presentation` model at the start of parsing, again, explicitly pointed out in the [spec](http://www.yaml.org/spec/1.2/spec.html#id2762107). \r\n\r\nWe do not need to discuss whether the current `go-yaml` behaviour is non-conformant. As the original post points out, it is called out in the spec as non-conformant. \r\n\r\nThe point of a spec is portability. It doesn't matter whether the file was created by hand, the same library or another library. The spec dictates conforming behaviour. [Section 3.2](http://www.yaml.org/spec/1.2/spec.html#id2763452) makes this point clearly. \r\n> This section specifies the formal details of the results of the above processes. To maximise data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation. Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation. By carefully separating properties needed for serialization and presentation, YAML representations of application information will be consistent and portable between various programming environments.\r\n\r\n. Just a heads up, I'm sure many people have application code which relies on this behaviour. I certainly do. Changing this is going to cause issues for some end-users. . Happy to post a patch if you're good with changing the behaviour. . @niemeyer I understand where you're coming from. Breaking documents that already parse is probably not acceptable, so the strict mode seems like a good path forward. \r\n\r\nA `yaml` file is **not** a map of unordered fields, it has to follow the rules dictated by spec. The rule I mentioned is important as the spec allows for multiple nodes to be aliased with the same identifier. The ordering constraint is required to be deterministic about which anchor node is referenced by an aliased node. For e.g. both the PyYAML (Python's YAML library) and Psych (Ruby's YAML library) both fail at parsing the example I posted for this reason. \r\n. @niemeyer The spec details three distinct models: `representation`, `serialisation`, and `presentation`. The bits you quoted are talking about a `representation` model.  A file on disk must be treated as `presentation` model at the start of parsing, again, explicitly pointed out in the [spec](http://www.yaml.org/spec/1.2/spec.html#id2762107). \r\n\r\nWe do not need to discuss whether the current `go-yaml` behaviour is non-conformant. As the original post points out, it is called out in the spec as non-conformant. \r\n\r\nThe point of a spec is portability. It doesn't matter whether the file was created by hand, the same library or another library. The spec dictates conforming behaviour. [Section 3.2](http://www.yaml.org/spec/1.2/spec.html#id2763452) makes this point clearly. \r\n> This section specifies the formal details of the results of the above processes. To maximise data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation. Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation. By carefully separating properties needed for serialization and presentation, YAML representations of application information will be consistent and portable between various programming environments.\r\n\r\n. ",
    "tolidano": "Bump. I was hoping for examples.. Bump. I was hoping for examples.. ",
    "houshengbo": "@niemeyer @rogpeppe I believe this is a valid issue, and I have already submitted a PR #281 to resolve it. Please review it.. @niemeyer @rogpeppe I believe this is a valid issue to resolve.  Please review it.. @niemeyer @rogpeppe I believe this is a valid issue, and I have already submitted a PR #281 to resolve it. Please review it.. @niemeyer @rogpeppe I believe this is a valid issue to resolve.  Please review it.. ",
    "akerl": "I've double checked to confirm this isn't a global issue with interfaces that I wasn't aware of:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n)\r\n\r\nfunc main() {\r\n    a := []string{\"foo\", \"bar\", \"baz\"}\r\n    foo(a)\r\n}\r\n\r\nfunc foo(x interface{}) {\r\n    y := x.([]string)\r\n    fmt.Println(y[0])\r\n}\r\n```\r\n\r\n```\r\n\u276f go run main.go\r\nfoo\r\n```. Did some more poking, it seems like the issue is that it's being returned to me as a slice of interfaces rather than an interface that contains a slice?\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"reflect\"\r\n\r\n    \"gopkg.in/yaml.v2\"\r\n)\r\n\r\nvar data = `\r\ndata:\r\n- foo\r\n- bar\r\n- baz\r\n`\r\n\r\ntype doc struct {\r\n    Data interface{}\r\n}\r\n\r\nfunc main() {\r\n    d := doc{}\r\n    err := yaml.Unmarshal([]byte(data), &d)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    fmt.Println(reflect.TypeOf(d.Data))\r\n\r\n    a := reflect.ValueOf(d.Data)\r\n    fmt.Println(a.Len())\r\n    for i := 0; i < a.Len(); i++ {\r\n        fmt.Println(a.Index(i))\r\n    }\r\n}\r\n```\r\n\r\n```\r\n\u276f go run main.go\r\n[]interface {}\r\n3\r\nfoo\r\nbar\r\nbaz\r\n```. Ahha! And with that, the solution:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n\r\n    \"gopkg.in/yaml.v2\"\r\n)\r\n\r\nvar data = `\r\ndata:\r\n- foo\r\n- bar\r\n- baz\r\n`\r\n\r\ntype doc struct {\r\n    Data interface{}\r\n}\r\n\r\nfunc main() {\r\n    d := doc{}\r\n    err := yaml.Unmarshal([]byte(data), &d)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    a, _ := d.Data.([]interface{})\r\n    fmt.Println(len(a))\r\n    for _, x := range a {\r\n        y := x.(string)\r\n        fmt.Println(y)\r\n    }\r\n}\r\n```\r\n\r\n```\r\n\u276f go run main.go\r\n3\r\nfoo\r\nbar\r\nbaz\r\n```\r\n\r\nNot what I'd have expected it to do, but I can live with having to cast first to `[]interface {}`. I've double checked to confirm this isn't a global issue with interfaces that I wasn't aware of:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n)\r\n\r\nfunc main() {\r\n    a := []string{\"foo\", \"bar\", \"baz\"}\r\n    foo(a)\r\n}\r\n\r\nfunc foo(x interface{}) {\r\n    y := x.([]string)\r\n    fmt.Println(y[0])\r\n}\r\n```\r\n\r\n```\r\n\u276f go run main.go\r\nfoo\r\n```. Did some more poking, it seems like the issue is that it's being returned to me as a slice of interfaces rather than an interface that contains a slice?\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"reflect\"\r\n\r\n    \"gopkg.in/yaml.v2\"\r\n)\r\n\r\nvar data = `\r\ndata:\r\n- foo\r\n- bar\r\n- baz\r\n`\r\n\r\ntype doc struct {\r\n    Data interface{}\r\n}\r\n\r\nfunc main() {\r\n    d := doc{}\r\n    err := yaml.Unmarshal([]byte(data), &d)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    fmt.Println(reflect.TypeOf(d.Data))\r\n\r\n    a := reflect.ValueOf(d.Data)\r\n    fmt.Println(a.Len())\r\n    for i := 0; i < a.Len(); i++ {\r\n        fmt.Println(a.Index(i))\r\n    }\r\n}\r\n```\r\n\r\n```\r\n\u276f go run main.go\r\n[]interface {}\r\n3\r\nfoo\r\nbar\r\nbaz\r\n```. Ahha! And with that, the solution:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n\r\n    \"gopkg.in/yaml.v2\"\r\n)\r\n\r\nvar data = `\r\ndata:\r\n- foo\r\n- bar\r\n- baz\r\n`\r\n\r\ntype doc struct {\r\n    Data interface{}\r\n}\r\n\r\nfunc main() {\r\n    d := doc{}\r\n    err := yaml.Unmarshal([]byte(data), &d)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    a, _ := d.Data.([]interface{})\r\n    fmt.Println(len(a))\r\n    for _, x := range a {\r\n        y := x.(string)\r\n        fmt.Println(y)\r\n    }\r\n}\r\n```\r\n\r\n```\r\n\u276f go run main.go\r\n3\r\nfoo\r\nbar\r\nbaz\r\n```\r\n\r\nNot what I'd have expected it to do, but I can live with having to cast first to `[]interface {}`. ",
    "aeijdenberg": "Related: <https://github.com/go-yaml/yaml/issues/154>. Related: <https://github.com/go-yaml/yaml/issues/154>. ",
    "gbbr": "No problem. Thanks for maintaining.. No problem. Thanks for maintaining.. "
}