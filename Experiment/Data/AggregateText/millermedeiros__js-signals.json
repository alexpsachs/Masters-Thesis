{
    "millermedeiros": "done!\n. implemented and renamed method to `detach()` to avoid confusions - since Signal.remove requires a listener parameter - see commit: e777b1ebf81dc745f9012e185dccbcfffe02a116\n. not sure what would happen if you try to set a listener that already exists, maybe proper approach would be just having a getter and not a setter, simpler and the user has option to detach and create a new binding anyways. cases where you need to swap handlers should be really uncommon and I don't think worth the trouble.\n. fixed at commit af477d9c0b29c9c0cb8da25590a0cf7852e51853\n. changed name to `context` because of brevity and also because I think it makes sense.- see: 5bde61e229280d029fbaf5e81e37acab2efda1de\n. fixed. see commit: 36df9eae2f8fcc56e0e8c2f970aba450174e7b6a\n. Calling `Signal.removeAll()` should be enough to the garbage collector delete all SignalBindings.\n\nDetaching binding and deleting local reference to it should be enough for garbage collector.\n. since I don't know how big/complex the apps built using signals can be I guess it may be a good idea to implement `dispose` on the `Signal` object to give users more control about it, specially since user can store references to the signal in many places blocking garbage collection. (even not being required on most cases)\n. implemented dispose into `Signal.prototype` and kept `SignalBinding.prototype.dipose`: 635641375c40c0cb5049c5f8910bcf208bf71a9b\n. not a good idea, will have to check if it is an Object or Function all the times (unnecessarily) and if you have a reference to the `SignalBinding` you can just call `SignalBinding.detach()` (way easier)\n\nPS: this entry was just to remind myself why I created the `detach` method, I'm sure in a couple months someone would ask for the same thing and I wouldn't remind why I didn't implemented it.\n. for now the best solution seems to be setting the first argument of the handler to be a reference to the `SignalBinding` - since it has references to everything else..\n\ndidn't implemented this way since the beginning because AS3-Signals doesn't do this way (it only passes the variables that you are dispatching).\n. will probably wait for some opinions and maybe even contact Penner and Joa about it.\n. since I didn't got any feedback about it in the last 2 months I'm probably going to add SignalBinding as the first parameter of callbacks even if that cause existing code to break... this library didn't reached v1.0 so I guess it's better to fix this problem sooner than later.\n. implemented in a new branch: 8d4dc6c18ff5f1c55be74f0b7968ed05bd0c899a  - not sure if I will merge into master yet...\n. I had this idea when I was planning to create a display list for canvas and I thought that having a way to access the binding from inside the handler could help to easily detach listeners and stop propagation, specially since JS have the same scope issues as AS2... another reason is that having access to the binding on the parameters you could potentially use the same handler for multiple signals (like mouseover/mouseout) and still be able to detach/halt and know which signal is triggering the handler.\n\nI think most of the use cases for this feature that I could think off are just bad practices or edge-cases. As you said, creating a new kind of Signal would probably be a better solution or just change the application structure to circumvent this. I probably won't add this feature unless I need it or someone asks for it. I was keeping it as open because I was waiting for feedback...\n. not sure if really required since the amount of methods is really small and by looking at examples user can easily see the differences.\n. invalid since I'm already telling that project isn't a direct port.\n. implemented: 8eece1fa709f2bdd82e68c9079b826702d5c7f54\n. added on commit 23fc01ec3cfd0a5f186a9ecc032b57bf520586ca\n. added JSLint on commit 116a285929b9285d8a6e3d9cf83cf2c5090af907\n. fixed on commit 116a285929b9285d8a6e3d9cf83cf2c5090af907\n. instead of making it private, it would be better to delete it and just compare to `void(0)`... it's only being called twice and the method doesn't make code cleaner..\n. fixed on commit a724d6d24951bb0b2d30d8775806f85280692f48\n. fixed on commit 6d5bb0c3d231fb8af3de99a09cd14c7df7dd1482\n. probably migrate to [joDoc](https://github.com/davebalmer/joDoc) since it have the option to use external markdown files.\n. I will keep JSDoc since it is already on use and creating an external documentation takes a lot of time...\n. implemented on e94a140190d16ec49ba5011f73a9fc4625f4269d\n. implemented on 2c0d0cf2dea86aebf2beb59353f3ed8fb36f6870\n. implemented on commit 77cb7934a72122b4ff92a41aa048028a08cb62b0\n. I will take a look on it, but for now it isn't on my priority list. Thanks for the heads up.\n. ready to be used! http://search.npmjs.org/#/signals\n. thanks a lot, I will merge it later this week and add the keywords as well.. \n\nI will keep the package name as `signals` as @secoif noted to match the namespace - maybe I should even change the name of the distribution files to `signals.js` so if you are loading it as an AMD module you can just `require('signals')` the same way you would do with the common JS module.\n. ready to be used! http://search.npmjs.org/#/signals\n\nI would delay forever to look into how to publish to npm without the request... thanks.\n. not sure how to do that.. do you have any example of another project that does what you want? I also didn't understood how do you use the NPM files for the browser..\n\nThe easiest way that I can think right now is to change the closure wrapper and use the same version for browser and Node... something like this:\n\n``` js\n(function(exports){\n  ...\n  exports.signals = signals;\n}((typeof module !== 'undefined' && module.exports? module.exports : null) || window || this));\n```\n\nBut I'm trying to avoid adding complex wrappers, specially like [this one](http://www.sitepen.com/blog/2010/09/30/run-anywhere-javascript-modules-boilerplate-code/), that's why I created 3 different files.\n. ohh... now I realized that you just want to keep the regular version of signals inside the package and I excluded it using the [.npmignore](https://github.com/millermedeiros/js-signals/blob/master/.npmignore) file...\n\nstill not sure how are you using the files and if it makes sense to keep the whole `/dist` folder since npm is target only for node...\n. nice catch, I will create a test to ensure it still work in the future and merge the changes. thanks.\n. ohh, just realized why there is no check., I considered that `_listener` would be always available since the user isn't supposed to change it (variables starting with underscore are pseudo-private) and there is [no way to create a binding without a listener](https://github.com/paullewis/js-signals/blob/master/dist/signals.js#L203-205)\n\ndo you have any example on how to make it fail?\n. makes sense and I will integrate it on the next few days and add tests that match your description. thanks!\n. ignored.. just improved other error messages.. don't think the overhead pays-off.. will need checks everywhere and calling methods after `dispose()` shouldn't be that common.. error message + doc should be enough... releasing v0.6.3 without this.\n. maybe a \"better\" solution would be to simply add a new property to the SignalBinding called `params` or `curried` or `curriedParams` and **do not** add the option to pass curried parameters on the `add()` and `addOnce()` methods. I think it is too confusing to have that many parameters... 3 already seems too much. \n. `params` seems a good and concise name and implementation is trivial... just need to check if arrays exist and `concat` arrays during `SignalBinding.execute()`, it already uses `apply()`...\n\nwill implement it on a separate branch and merge it later.\n. I thought a lot about it and I think the best way to implement it is by creating a new kind of Signal, that way we avoid storing references to unneeded values and also make it harder to mess with the default behavior of third-party code (since it may break things badly). I also think that creating a new Signal type will make it clearer that it works differently.\n\nproposal:\n\n``` js\n//AsyncSignal keeps previous dispatch \"in memory\"\nvar intialized = new signals.AsyncSignal();\n\n//won't log anything for now since signal wasn't dispatched yet\ninitialized.add(function(t){\n  console.log('1: '+ t);\n});\n\n//log \"1: lorem-ipsum\"\ninitialized.dispatch('lorem-ipsum');\n\n//will log \"2: lorem-ipsum\" even tho the signal was dispatched before adding the listener\ninitialized.add(function(t){\n  console.log('2: '+ t);\n});\n\n//log \"1: foo\"\n//log \"2: foo\"\ninitialized.dispatch('foo');\n\n//will log \"3: foo\" (it uses previous dispatched value if it does exist)\ninitialized.add(function(t){\n  console.log('3: '+ t);\n});\n```\n\ncan probably re-use most of the regular `Signal` logic and just augment `add`, `addOnce` and `dispatch` logic.\n. see [diff between branches](https://github.com/millermedeiros/js-signals/compare/master...iss29#diff-23) to understand what changed.\n. maybe add a public method `reset()` to clear `_prevParams`... it will increase flexibility.\n. decided to simplify the logic.. instead of creating a new kind of signal just created a new public property `memorize`.\n\n``` js\nvar intialized = new signals.Signal();\ninitialized.memorize = true; //default is `false`\n```\n\nway less code and simpler to use.. (this is JavaScript! not Java!)\n\nmerged into the [develop](https://github.com/millermedeiros/js-signals/tree/develop) branch.\n. so far I think it isn't required... it will probably cause more problem than solve.. setting properties of the binding is easy enough and shouldn't be that common. I like this style way better:\n\n``` js\n//priority isn't that common but should be passed on \"constructor\" since it simplifies \n//dispatch logic a lot, it can't be set afterwards.\n//context is second param of `add()` & `addOnce()` since it is very common to use it, \n//it can also be set/changed afterward if needed.\nvar b = myObj.clicked.add(doSomething, otherScope, 5);\nb.active = false;\nb.params = ['foo', 123];\n...\n```\n\nI will wait for issue #29 implementation to decide..\n. closing this issue for now, decided to implement issue #29 as a new type of Signal and I think the current setup is easy enough to use and a preferred practice.\n. jasmine seems a good option as well: http://pivotal.github.com/jasmine/\n. definitely use jasmine for tests.. really liked the syntax and the idea of describing what code should do, helped me to find some edge cases on another project... only problem now is to find time to port all tests..\n. If someone want to help I've created a tool to help the process: http://millermedeiros.github.com/YUI_to_Jasmine/\n\nuse [crossroads specs](https://github.com/millermedeiros/crossroads.js/tree/master/dev/tests/spec) as reference\n. This can simplify unit tests a lot: https://github.com/AdamNowotny/js-signals-logger\n. @AdamNowotny nice! this task is on my todo list since forever. will use jasmine-signals for sure, will be good to clean the tests. Thanks for sharing it.\n. In the end I didn't refactored it to use jasmine-signals since it was simpler to just apply some RegExp and macros. I removed some redundant specs and improved others as well. I added a link to jasmine-signals on the README. Cheers!\n. install using NPM:\n\n```\nnpm install signals\n```\n\nand it works almost the same way, just need to require the module before using it:\n\n``` js\nvar Signal = require('signals').Signal;\n\nvar somethingHappened = new Signal();\n```\n\ngood luck!\n. note that the `when()` alias isn't required for chaining, you are just accessing a property/method of the returned object, the `when` example desugars to:\n\n``` js\n(new CompoundSignal( myObj.endedAnimation, otherObj.completedSomething ))\n    .addOnce( doSomethingOnCompletedManyThings );\n```\n. a signal can be dispatched multiple times, a promise can only be resolved once, maybe the CompoundSignal should have an option to get only the first value or the last one dispatched:\n\n``` js\nvar loaded = new Signal();\nvar closed = new Signal();\n\nvar loadedAndClosed = new CompoundSignal(loaded, closed);\nloadedAndClosed.shouldOverride = true;\n\nvar loadedAndClosed2 = new CompoundSignal(loaded, closed);\nloadedAndClosed2.shouldOverride = false; //default\n\nloadedAndClosed.addOnce(function(loadedParams, closedParams){\n  console.log('override true:', loadedParams, closedParams);\n});\n\nloadedAndClosed2.addOnce(function(loadedParams, closedParams){\n  console.log('override false:', loadedParams, closedParams);\n});\n\nclosed.dispatch(1);\nclosed.dispatch(2);\nloaded.dispatch('foo.jpg');\n\n//override true: ['foo.jpg'], [2]\n//override false: ['foo.jpg'], [1]\n```\n\nanother complex thing is how the CompoundSignal should behave after first dispatch... maybe it should be dispatched only once and behave similar to an [AsyncSignal](https://github.com/millermedeiros/js-signals/issues/29) (adding listener after dispatch will trigger listener automatically) or should \"reset\" after each dispatch (clear reference of previously dispatched values) and dispatch again every time all signals are dispatched...  - maybe add an option to toggle behavior.\n\n``` js\ncompound.unique = true; // if it should be dispatched only once, default = true\n```\n. CompoundSignal should also have a method `reset()` to clear reference to previously dispatched values and start listening the signals again.\n. didn't created the `signals.when()` alias, I don't think it is necessary..\n. I'm considering a name like `forget()` for clearing the _memorized_ arguments and using `reset()` on the CompoundSignal..\n. broken into a separate project: https://github.com/millermedeiros/CompoundSignal\n. marking as invalid.. `memorize` is just fine..\n. implemented it quickly but didn't had time to check performance yet. \n. @r4j4h execution and filesize should be considered, I would be against keeping both storage methods, it should be one or the other. I still haven't profiled it, the current implementation is already VERY fast.\n\nThe linked list implementation could be even simpler (and faster) than the one I proposed 11 months ago, there are a lot of unnecessary method calls on 661a53b - the \"fast linked list\" isn't as \"fast\" as it could be...\n\nLeaving it open in case someone want to do the tests and also because I was sure someone would ask for a pull request like this in the future.\n. it will surely break a lot of code (including `CompoundSignal` and some of my old apps) so I guess this ship already sailed... ignoring it.\n. I've also questioned myself about this decision :D - at the beginning I was thinking about adding different kinds of signals to this object (AS3-signals has [many diff types](https://github.com/robertpenner/as3-signals/tree/master/src/org/osflash/signals)) but I ended up adding all the features into the same \"class\" (priority, addOnce, memorize) and created a [diff kind of signal](https://github.com/millermedeiros/CompoundSignal) as a separate project.\n\nMaybe the solution is to keep the namespace for the browser but register the signal itself for AMD and node.js... the only problem is that this change will break all AMD and node.js code that is already using signals... For now you can do like this:\n\n``` js\nvar Signal = require('vendor/signals').Signal;\nvar mySignal = new Signal();\n```\n\nThe namespace is more _future-proof_ since we can add new properties to the object at will, but I will keep this issue open to see if more people agree with the change and maybe that's the change that will motivate a `v1.0.0` release (since it's a breaking change).\n. ahhh I just found a non-breaking solution after hitting the send button! hehe\n\nIn JavaScript Functions are first-class objects, which means we can add properties to the function, so we could change the code to be:\n\n``` js\nfunction Signal(){\n  // ... regular code here\n}\n\n// expose constructor as a property as well\nSignal.Signal = Signal;\n```\n\nAnd just expose the `Signal` constructor for AMD and node.js without breaking legacy code! #winning\n\n``` js\nvar Signal = require('signals');\nvar mySignal = new Signal(); // works!\n// legacy support\nvar signals = require('signals');\nvar mySignal = new signals.Signal(); // still works\n```\n\nThis should definitely ship in the next version since it's non-breaking and will be less verbose... For the browser I think we should keep the current name `signals` for the namespace since it's weird to have lowercase constructors and user can just create an alias like [showed in the examples](https://github.com/millermedeiros/js-signals/wiki/Examples). The namespace is important for the browser since user might be using the `CompoundSignal` as well (which requires the global `signals` object)\n. @conradz and @jonnyreeves  sorry for the delay. This just landed on v0.8.0. Now on node.js you can do:\n\n``` js\nvar Signal = require('signals');\nvar onAwesome = new Signal();\n// ...\n```\n\nand on AMD:\n\n``` js\ndefine(['signals'], function(Signal){\n   var onAwesome = new Signal();\n   // ...\n});\n```\n\nOn the browser it still exposes a single global `signals`.\n\n``` js\nvar onAwesome = new signals.Signal();\n```\n\nLegacy code should keep working since the `Signal` constructor is also exposed as a property of itself:\n\n``` js\n// this will keep working\nvar Signal = require('signals').Signal;\n```\n. yes, `console.log` isn't a function on IE9 unless you have the dev tools opened. This check is exactly to avoid adding listeners that doesn't exist (fail early) but it is only really helpful when you see the call stack (so you can see which `add()` call that caused the issue).\n\nPS: `typeof foo === \"function\"` works properly on all environments. `Array`, `Date` and `new Number`/`new String` that needs the `Object.prototype.toString.call()` check (since they all return `typeof` as `\"object\"`).\n. damn, totally forgot about it and only tested on node.js and on the browser.. now I already pushed to NPM and added the tag. Will need to bump version to 0.8.1 thanks for the fix!\n. version 0.8.1 just released including this patch. thanks!\n. Another solution is to add a new method to the `dispatch()` function that does the binding:\n\n``` js\nfunction Signal(){\n  var self = this;\n  this.dispatch.bind = function(){\n    return function(){\n      self.dispatch.apply(self, arguments);\n    };\n  };\n  // ...\n}\n```\n\nWhich would be used like this:\n\n``` js\n$('#foo').fadeOut( 500, ended.dispatch.bind() );\n```\n\nI like the _automagical_ approach better - calling `bind()` without any argument fells weird and user might not know he needs to do that.\n. this shipped on [v0.9.0](https://github.com/millermedeiros/js-signals/compare/v0.8.1...v0.9.0)\n. should probably add it here:  https://github.com/borisyankov/DefinitelyTyped\n. I'm on a Mac and didn't had time to do it / test it yet...\n\nthere are 2 TypeScript ports already: https://github.com/photonstorm/typescript-signals and https://github.com/jonopus/typescript-signals\n. duplicate, check #49 instead\n. The getters/setters would be just for these 3 properties:\n\n``` js\nchanged.memorize(true);\nchanged.active(true);\nchanged.defaultArguments(123, 456);\n```\n\nThey aren't that common tho... just putting the thoughts out there so in the future we remind why it wasn't coded like this and what I was thinking at the time... Outside feedback is great for putting these things in perspective.\n. ahh, forgot to say.. another option would be add a \"flag\" to signals to toggle the behavior, something like a `signals.neuroticMode = true;` which would make all signals to be _frozen_ during instantiation... no backwards incompatibility and just a way to enhance development... (could be disabled before deploy) would also not cause issues if used in previous versions (it would fail silently - no side effects)\n. closing this in favor of #60 \n. I agree that this doesn't seem like a good idea. Like @andy-law said it can be confusing. Closing it.\n. it's a github pages issue. it doesn't display any files that starts with \"_\". There are no globals besides `signals` - and only expose globals if you don't use RequireJS/node to load the code.\n\nThat's how `JSDoc` outputs the files..\n. I followed the _least astonishment principle_. If we add something like `memorySize` what is the desired behavior with multiple listeners?\n\n``` js\nvar initialized = new Signal();\niniltialized.memorize = true;\ninitialized.memorySize = -1; // lets suppose this feature exists\ninitialized.dispatch('lorem');\ninitialized.dispatch('ipsum');\ninitialized.add(console.log, console);\n// > \"lorem\"\n// > \"ipsum\"\n// should `echo` be called once or twice?\ninitialized.add(echo);\n```\n\nI can see the use for a feature like that - specially if you want to implement something like a `Stream` (and don't want to lose any data) - but it would increase complexity a little bit. Any special use case for it that justifies the overhead?\n. that is because all instances of `Emitter` share the same object `on` (objects are passed by reference even if defined on the prototype). You need to create the `on` object inside the constructor.\n. I added a `bower.json` file and removed some unnecessary files and updated git tag v1.0.0 to match latest changes.\n\nplease confirm if that works for you:\n\n``` sh\nbower install js-signals\n```\n. It doesn't use anything new/different so it should work everywhere.\n\nOn the last release I tested on\nIE 6+, chrome, safari 4+, firefox, node.js\n. thanks!\n. @explorigin just saw the `waitFor` implementation and it's really weird.. If I need things to happen in sequence I would probably just use a single handler that call the functions in sequence (better IMO) or set a different `priority` when adding the listeners.. but I'll try to understand better why Flux decided to add this and consider something similar for the future.\n. @Hypercubed sorry for not replying to your messages.. I'm moving next week and having to deal with a lot of paperwork and other assorted things for the move.. I did not had time to look at your implementation, yet.\n\nI kinda stopped changing signals because I believe there are many projects relying on the current API/behavior.. That's why I never spent time implementing the features/changes highlighted above.\n. done!\n. implemented and renamed method to `detach()` to avoid confusions - since Signal.remove requires a listener parameter - see commit: e777b1ebf81dc745f9012e185dccbcfffe02a116\n. not sure what would happen if you try to set a listener that already exists, maybe proper approach would be just having a getter and not a setter, simpler and the user has option to detach and create a new binding anyways. cases where you need to swap handlers should be really uncommon and I don't think worth the trouble.\n. fixed at commit af477d9c0b29c9c0cb8da25590a0cf7852e51853\n. changed name to `context` because of brevity and also because I think it makes sense.- see: 5bde61e229280d029fbaf5e81e37acab2efda1de\n. fixed. see commit: 36df9eae2f8fcc56e0e8c2f970aba450174e7b6a\n. Calling `Signal.removeAll()` should be enough to the garbage collector delete all SignalBindings.\n\nDetaching binding and deleting local reference to it should be enough for garbage collector.\n. since I don't know how big/complex the apps built using signals can be I guess it may be a good idea to implement `dispose` on the `Signal` object to give users more control about it, specially since user can store references to the signal in many places blocking garbage collection. (even not being required on most cases)\n. implemented dispose into `Signal.prototype` and kept `SignalBinding.prototype.dipose`: 635641375c40c0cb5049c5f8910bcf208bf71a9b\n. not a good idea, will have to check if it is an Object or Function all the times (unnecessarily) and if you have a reference to the `SignalBinding` you can just call `SignalBinding.detach()` (way easier)\n\nPS: this entry was just to remind myself why I created the `detach` method, I'm sure in a couple months someone would ask for the same thing and I wouldn't remind why I didn't implemented it.\n. for now the best solution seems to be setting the first argument of the handler to be a reference to the `SignalBinding` - since it has references to everything else..\n\ndidn't implemented this way since the beginning because AS3-Signals doesn't do this way (it only passes the variables that you are dispatching).\n. will probably wait for some opinions and maybe even contact Penner and Joa about it.\n. since I didn't got any feedback about it in the last 2 months I'm probably going to add SignalBinding as the first parameter of callbacks even if that cause existing code to break... this library didn't reached v1.0 so I guess it's better to fix this problem sooner than later.\n. implemented in a new branch: 8d4dc6c18ff5f1c55be74f0b7968ed05bd0c899a  - not sure if I will merge into master yet...\n. I had this idea when I was planning to create a display list for canvas and I thought that having a way to access the binding from inside the handler could help to easily detach listeners and stop propagation, specially since JS have the same scope issues as AS2... another reason is that having access to the binding on the parameters you could potentially use the same handler for multiple signals (like mouseover/mouseout) and still be able to detach/halt and know which signal is triggering the handler.\n\nI think most of the use cases for this feature that I could think off are just bad practices or edge-cases. As you said, creating a new kind of Signal would probably be a better solution or just change the application structure to circumvent this. I probably won't add this feature unless I need it or someone asks for it. I was keeping it as open because I was waiting for feedback...\n. not sure if really required since the amount of methods is really small and by looking at examples user can easily see the differences.\n. invalid since I'm already telling that project isn't a direct port.\n. implemented: 8eece1fa709f2bdd82e68c9079b826702d5c7f54\n. added on commit 23fc01ec3cfd0a5f186a9ecc032b57bf520586ca\n. added JSLint on commit 116a285929b9285d8a6e3d9cf83cf2c5090af907\n. fixed on commit 116a285929b9285d8a6e3d9cf83cf2c5090af907\n. instead of making it private, it would be better to delete it and just compare to `void(0)`... it's only being called twice and the method doesn't make code cleaner..\n. fixed on commit a724d6d24951bb0b2d30d8775806f85280692f48\n. fixed on commit 6d5bb0c3d231fb8af3de99a09cd14c7df7dd1482\n. probably migrate to [joDoc](https://github.com/davebalmer/joDoc) since it have the option to use external markdown files.\n. I will keep JSDoc since it is already on use and creating an external documentation takes a lot of time...\n. implemented on e94a140190d16ec49ba5011f73a9fc4625f4269d\n. implemented on 2c0d0cf2dea86aebf2beb59353f3ed8fb36f6870\n. implemented on commit 77cb7934a72122b4ff92a41aa048028a08cb62b0\n. I will take a look on it, but for now it isn't on my priority list. Thanks for the heads up.\n. ready to be used! http://search.npmjs.org/#/signals\n. thanks a lot, I will merge it later this week and add the keywords as well.. \n\nI will keep the package name as `signals` as @secoif noted to match the namespace - maybe I should even change the name of the distribution files to `signals.js` so if you are loading it as an AMD module you can just `require('signals')` the same way you would do with the common JS module.\n. ready to be used! http://search.npmjs.org/#/signals\n\nI would delay forever to look into how to publish to npm without the request... thanks.\n. not sure how to do that.. do you have any example of another project that does what you want? I also didn't understood how do you use the NPM files for the browser..\n\nThe easiest way that I can think right now is to change the closure wrapper and use the same version for browser and Node... something like this:\n\n``` js\n(function(exports){\n  ...\n  exports.signals = signals;\n}((typeof module !== 'undefined' && module.exports? module.exports : null) || window || this));\n```\n\nBut I'm trying to avoid adding complex wrappers, specially like [this one](http://www.sitepen.com/blog/2010/09/30/run-anywhere-javascript-modules-boilerplate-code/), that's why I created 3 different files.\n. ohh... now I realized that you just want to keep the regular version of signals inside the package and I excluded it using the [.npmignore](https://github.com/millermedeiros/js-signals/blob/master/.npmignore) file...\n\nstill not sure how are you using the files and if it makes sense to keep the whole `/dist` folder since npm is target only for node...\n. nice catch, I will create a test to ensure it still work in the future and merge the changes. thanks.\n. ohh, just realized why there is no check., I considered that `_listener` would be always available since the user isn't supposed to change it (variables starting with underscore are pseudo-private) and there is [no way to create a binding without a listener](https://github.com/paullewis/js-signals/blob/master/dist/signals.js#L203-205)\n\ndo you have any example on how to make it fail?\n. makes sense and I will integrate it on the next few days and add tests that match your description. thanks!\n. ignored.. just improved other error messages.. don't think the overhead pays-off.. will need checks everywhere and calling methods after `dispose()` shouldn't be that common.. error message + doc should be enough... releasing v0.6.3 without this.\n. maybe a \"better\" solution would be to simply add a new property to the SignalBinding called `params` or `curried` or `curriedParams` and **do not** add the option to pass curried parameters on the `add()` and `addOnce()` methods. I think it is too confusing to have that many parameters... 3 already seems too much. \n. `params` seems a good and concise name and implementation is trivial... just need to check if arrays exist and `concat` arrays during `SignalBinding.execute()`, it already uses `apply()`...\n\nwill implement it on a separate branch and merge it later.\n. I thought a lot about it and I think the best way to implement it is by creating a new kind of Signal, that way we avoid storing references to unneeded values and also make it harder to mess with the default behavior of third-party code (since it may break things badly). I also think that creating a new Signal type will make it clearer that it works differently.\n\nproposal:\n\n``` js\n//AsyncSignal keeps previous dispatch \"in memory\"\nvar intialized = new signals.AsyncSignal();\n\n//won't log anything for now since signal wasn't dispatched yet\ninitialized.add(function(t){\n  console.log('1: '+ t);\n});\n\n//log \"1: lorem-ipsum\"\ninitialized.dispatch('lorem-ipsum');\n\n//will log \"2: lorem-ipsum\" even tho the signal was dispatched before adding the listener\ninitialized.add(function(t){\n  console.log('2: '+ t);\n});\n\n//log \"1: foo\"\n//log \"2: foo\"\ninitialized.dispatch('foo');\n\n//will log \"3: foo\" (it uses previous dispatched value if it does exist)\ninitialized.add(function(t){\n  console.log('3: '+ t);\n});\n```\n\ncan probably re-use most of the regular `Signal` logic and just augment `add`, `addOnce` and `dispatch` logic.\n. see [diff between branches](https://github.com/millermedeiros/js-signals/compare/master...iss29#diff-23) to understand what changed.\n. maybe add a public method `reset()` to clear `_prevParams`... it will increase flexibility.\n. decided to simplify the logic.. instead of creating a new kind of signal just created a new public property `memorize`.\n\n``` js\nvar intialized = new signals.Signal();\ninitialized.memorize = true; //default is `false`\n```\n\nway less code and simpler to use.. (this is JavaScript! not Java!)\n\nmerged into the [develop](https://github.com/millermedeiros/js-signals/tree/develop) branch.\n. so far I think it isn't required... it will probably cause more problem than solve.. setting properties of the binding is easy enough and shouldn't be that common. I like this style way better:\n\n``` js\n//priority isn't that common but should be passed on \"constructor\" since it simplifies \n//dispatch logic a lot, it can't be set afterwards.\n//context is second param of `add()` & `addOnce()` since it is very common to use it, \n//it can also be set/changed afterward if needed.\nvar b = myObj.clicked.add(doSomething, otherScope, 5);\nb.active = false;\nb.params = ['foo', 123];\n...\n```\n\nI will wait for issue #29 implementation to decide..\n. closing this issue for now, decided to implement issue #29 as a new type of Signal and I think the current setup is easy enough to use and a preferred practice.\n. jasmine seems a good option as well: http://pivotal.github.com/jasmine/\n. definitely use jasmine for tests.. really liked the syntax and the idea of describing what code should do, helped me to find some edge cases on another project... only problem now is to find time to port all tests..\n. If someone want to help I've created a tool to help the process: http://millermedeiros.github.com/YUI_to_Jasmine/\n\nuse [crossroads specs](https://github.com/millermedeiros/crossroads.js/tree/master/dev/tests/spec) as reference\n. This can simplify unit tests a lot: https://github.com/AdamNowotny/js-signals-logger\n. @AdamNowotny nice! this task is on my todo list since forever. will use jasmine-signals for sure, will be good to clean the tests. Thanks for sharing it.\n. In the end I didn't refactored it to use jasmine-signals since it was simpler to just apply some RegExp and macros. I removed some redundant specs and improved others as well. I added a link to jasmine-signals on the README. Cheers!\n. install using NPM:\n\n```\nnpm install signals\n```\n\nand it works almost the same way, just need to require the module before using it:\n\n``` js\nvar Signal = require('signals').Signal;\n\nvar somethingHappened = new Signal();\n```\n\ngood luck!\n. note that the `when()` alias isn't required for chaining, you are just accessing a property/method of the returned object, the `when` example desugars to:\n\n``` js\n(new CompoundSignal( myObj.endedAnimation, otherObj.completedSomething ))\n    .addOnce( doSomethingOnCompletedManyThings );\n```\n. a signal can be dispatched multiple times, a promise can only be resolved once, maybe the CompoundSignal should have an option to get only the first value or the last one dispatched:\n\n``` js\nvar loaded = new Signal();\nvar closed = new Signal();\n\nvar loadedAndClosed = new CompoundSignal(loaded, closed);\nloadedAndClosed.shouldOverride = true;\n\nvar loadedAndClosed2 = new CompoundSignal(loaded, closed);\nloadedAndClosed2.shouldOverride = false; //default\n\nloadedAndClosed.addOnce(function(loadedParams, closedParams){\n  console.log('override true:', loadedParams, closedParams);\n});\n\nloadedAndClosed2.addOnce(function(loadedParams, closedParams){\n  console.log('override false:', loadedParams, closedParams);\n});\n\nclosed.dispatch(1);\nclosed.dispatch(2);\nloaded.dispatch('foo.jpg');\n\n//override true: ['foo.jpg'], [2]\n//override false: ['foo.jpg'], [1]\n```\n\nanother complex thing is how the CompoundSignal should behave after first dispatch... maybe it should be dispatched only once and behave similar to an [AsyncSignal](https://github.com/millermedeiros/js-signals/issues/29) (adding listener after dispatch will trigger listener automatically) or should \"reset\" after each dispatch (clear reference of previously dispatched values) and dispatch again every time all signals are dispatched...  - maybe add an option to toggle behavior.\n\n``` js\ncompound.unique = true; // if it should be dispatched only once, default = true\n```\n. CompoundSignal should also have a method `reset()` to clear reference to previously dispatched values and start listening the signals again.\n. didn't created the `signals.when()` alias, I don't think it is necessary..\n. I'm considering a name like `forget()` for clearing the _memorized_ arguments and using `reset()` on the CompoundSignal..\n. broken into a separate project: https://github.com/millermedeiros/CompoundSignal\n. marking as invalid.. `memorize` is just fine..\n. implemented it quickly but didn't had time to check performance yet. \n. @r4j4h execution and filesize should be considered, I would be against keeping both storage methods, it should be one or the other. I still haven't profiled it, the current implementation is already VERY fast.\n\nThe linked list implementation could be even simpler (and faster) than the one I proposed 11 months ago, there are a lot of unnecessary method calls on 661a53b - the \"fast linked list\" isn't as \"fast\" as it could be...\n\nLeaving it open in case someone want to do the tests and also because I was sure someone would ask for a pull request like this in the future.\n. it will surely break a lot of code (including `CompoundSignal` and some of my old apps) so I guess this ship already sailed... ignoring it.\n. I've also questioned myself about this decision :D - at the beginning I was thinking about adding different kinds of signals to this object (AS3-signals has [many diff types](https://github.com/robertpenner/as3-signals/tree/master/src/org/osflash/signals)) but I ended up adding all the features into the same \"class\" (priority, addOnce, memorize) and created a [diff kind of signal](https://github.com/millermedeiros/CompoundSignal) as a separate project.\n\nMaybe the solution is to keep the namespace for the browser but register the signal itself for AMD and node.js... the only problem is that this change will break all AMD and node.js code that is already using signals... For now you can do like this:\n\n``` js\nvar Signal = require('vendor/signals').Signal;\nvar mySignal = new Signal();\n```\n\nThe namespace is more _future-proof_ since we can add new properties to the object at will, but I will keep this issue open to see if more people agree with the change and maybe that's the change that will motivate a `v1.0.0` release (since it's a breaking change).\n. ahhh I just found a non-breaking solution after hitting the send button! hehe\n\nIn JavaScript Functions are first-class objects, which means we can add properties to the function, so we could change the code to be:\n\n``` js\nfunction Signal(){\n  // ... regular code here\n}\n\n// expose constructor as a property as well\nSignal.Signal = Signal;\n```\n\nAnd just expose the `Signal` constructor for AMD and node.js without breaking legacy code! #winning\n\n``` js\nvar Signal = require('signals');\nvar mySignal = new Signal(); // works!\n// legacy support\nvar signals = require('signals');\nvar mySignal = new signals.Signal(); // still works\n```\n\nThis should definitely ship in the next version since it's non-breaking and will be less verbose... For the browser I think we should keep the current name `signals` for the namespace since it's weird to have lowercase constructors and user can just create an alias like [showed in the examples](https://github.com/millermedeiros/js-signals/wiki/Examples). The namespace is important for the browser since user might be using the `CompoundSignal` as well (which requires the global `signals` object)\n. @conradz and @jonnyreeves  sorry for the delay. This just landed on v0.8.0. Now on node.js you can do:\n\n``` js\nvar Signal = require('signals');\nvar onAwesome = new Signal();\n// ...\n```\n\nand on AMD:\n\n``` js\ndefine(['signals'], function(Signal){\n   var onAwesome = new Signal();\n   // ...\n});\n```\n\nOn the browser it still exposes a single global `signals`.\n\n``` js\nvar onAwesome = new signals.Signal();\n```\n\nLegacy code should keep working since the `Signal` constructor is also exposed as a property of itself:\n\n``` js\n// this will keep working\nvar Signal = require('signals').Signal;\n```\n. yes, `console.log` isn't a function on IE9 unless you have the dev tools opened. This check is exactly to avoid adding listeners that doesn't exist (fail early) but it is only really helpful when you see the call stack (so you can see which `add()` call that caused the issue).\n\nPS: `typeof foo === \"function\"` works properly on all environments. `Array`, `Date` and `new Number`/`new String` that needs the `Object.prototype.toString.call()` check (since they all return `typeof` as `\"object\"`).\n. damn, totally forgot about it and only tested on node.js and on the browser.. now I already pushed to NPM and added the tag. Will need to bump version to 0.8.1 thanks for the fix!\n. version 0.8.1 just released including this patch. thanks!\n. Another solution is to add a new method to the `dispatch()` function that does the binding:\n\n``` js\nfunction Signal(){\n  var self = this;\n  this.dispatch.bind = function(){\n    return function(){\n      self.dispatch.apply(self, arguments);\n    };\n  };\n  // ...\n}\n```\n\nWhich would be used like this:\n\n``` js\n$('#foo').fadeOut( 500, ended.dispatch.bind() );\n```\n\nI like the _automagical_ approach better - calling `bind()` without any argument fells weird and user might not know he needs to do that.\n. this shipped on [v0.9.0](https://github.com/millermedeiros/js-signals/compare/v0.8.1...v0.9.0)\n. should probably add it here:  https://github.com/borisyankov/DefinitelyTyped\n. I'm on a Mac and didn't had time to do it / test it yet...\n\nthere are 2 TypeScript ports already: https://github.com/photonstorm/typescript-signals and https://github.com/jonopus/typescript-signals\n. duplicate, check #49 instead\n. The getters/setters would be just for these 3 properties:\n\n``` js\nchanged.memorize(true);\nchanged.active(true);\nchanged.defaultArguments(123, 456);\n```\n\nThey aren't that common tho... just putting the thoughts out there so in the future we remind why it wasn't coded like this and what I was thinking at the time... Outside feedback is great for putting these things in perspective.\n. ahh, forgot to say.. another option would be add a \"flag\" to signals to toggle the behavior, something like a `signals.neuroticMode = true;` which would make all signals to be _frozen_ during instantiation... no backwards incompatibility and just a way to enhance development... (could be disabled before deploy) would also not cause issues if used in previous versions (it would fail silently - no side effects)\n. closing this in favor of #60 \n. I agree that this doesn't seem like a good idea. Like @andy-law said it can be confusing. Closing it.\n. it's a github pages issue. it doesn't display any files that starts with \"_\". There are no globals besides `signals` - and only expose globals if you don't use RequireJS/node to load the code.\n\nThat's how `JSDoc` outputs the files..\n. I followed the _least astonishment principle_. If we add something like `memorySize` what is the desired behavior with multiple listeners?\n\n``` js\nvar initialized = new Signal();\niniltialized.memorize = true;\ninitialized.memorySize = -1; // lets suppose this feature exists\ninitialized.dispatch('lorem');\ninitialized.dispatch('ipsum');\ninitialized.add(console.log, console);\n// > \"lorem\"\n// > \"ipsum\"\n// should `echo` be called once or twice?\ninitialized.add(echo);\n```\n\nI can see the use for a feature like that - specially if you want to implement something like a `Stream` (and don't want to lose any data) - but it would increase complexity a little bit. Any special use case for it that justifies the overhead?\n. that is because all instances of `Emitter` share the same object `on` (objects are passed by reference even if defined on the prototype). You need to create the `on` object inside the constructor.\n. I added a `bower.json` file and removed some unnecessary files and updated git tag v1.0.0 to match latest changes.\n\nplease confirm if that works for you:\n\n``` sh\nbower install js-signals\n```\n. It doesn't use anything new/different so it should work everywhere.\n\nOn the last release I tested on\nIE 6+, chrome, safari 4+, firefox, node.js\n. thanks!\n. @explorigin just saw the `waitFor` implementation and it's really weird.. If I need things to happen in sequence I would probably just use a single handler that call the functions in sequence (better IMO) or set a different `priority` when adding the listeners.. but I'll try to understand better why Flux decided to add this and consider something similar for the future.\n. @Hypercubed sorry for not replying to your messages.. I'm moving next week and having to deal with a lot of paperwork and other assorted things for the move.. I did not had time to look at your implementation, yet.\n\nI kinda stopped changing signals because I believe there are many projects relying on the current API/behavior.. That's why I never spent time implementing the features/changes highlighted above.\n. ",
    "robertpenner": "Could you elaborate on the necessity of sending the SignalBinding through every signal dispatch? \n. In other words, I would rather keep a general-purpose Signal that can dispatch anything or nothing, and have a different signal class that enforces a convention.\n. Could you elaborate on the necessity of sending the SignalBinding through every signal dispatch? \n. In other words, I would rather keep a general-purpose Signal that can dispatch anything or nothing, and have a different signal class that enforces a convention.\n. ",
    "tomyan": "Also really interested in getting js-signals via npm (love the library btw). In particular I'd like to be able to depend on it from a couple of modules that I publish via npm. Let me know if there are any contributions I could make to help with this.\n\nThanks\n\nTom\n. See https://github.com/millermedeiros/js-signals/pull/21\n\nThanks\n\nTom\n. Sounds good to me - I'd prefer to write:\n\n```\nvar signals = require('signals');\n```\n\nIf you add:\n\n```\n\"keywords\" : [ \"js-signals\" ]\n```\n\n..into the package.json meta-data file, then it will still come up when people search for \"js-signals\" in npm.\n\nTom\n. Very cool - thank you.\n\nTom\n. Also really interested in getting js-signals via npm (love the library btw). In particular I'd like to be able to depend on it from a couple of modules that I publish via npm. Let me know if there are any contributions I could make to help with this.\n\nThanks\n\nTom\n. See https://github.com/millermedeiros/js-signals/pull/21\n\nThanks\n\nTom\n. Sounds good to me - I'd prefer to write:\n\n```\nvar signals = require('signals');\n```\n\nIf you add:\n\n```\n\"keywords\" : [ \"js-signals\" ]\n```\n\n..into the package.json meta-data file, then it will still come up when people search for \"js-signals\" in npm.\n\nTom\n. Very cool - thank you.\n\nTom\n. ",
    "timoxley": "@tomyan, perhaps if you have the npm publishing knowhow, you could package signals in a forked signals branch and issue a pull request to @millermedeiros for your branch, which could then be submitted to npm? I'd do it but I haven't looked at publishing via npm yet so it may be easier for you to do it.\n. Awesome work! Though should probably just call the package 'signals'.\n. Nice. Yes, would be best to keep it as consistent as possible.\n. Awesome, I'm really looking forward to seeing signals in more libraries now. Yeehaw.\n. @tomyan, perhaps if you have the npm publishing knowhow, you could package signals in a forked signals branch and issue a pull request to @millermedeiros for your branch, which could then be submitted to npm? I'd do it but I haven't looked at publishing via npm yet so it may be easier for you to do it.\n. Awesome work! Though should probably just call the package 'signals'.\n. Nice. Yes, would be best to keep it as consistent as possible.\n. Awesome, I'm really looking forward to seeing signals in more libraries now. Yeehaw.\n. ",
    "mrjjwright": "Exactly that will work. I wrote a cake task that parses my package.json dependencies and concatenates a JS file. I wrote a bit of an extension to package.json that specifies whether the file is local or in npm and I look inside node_modules for npm packages. I look inside lib, dist, or the root, so wherever you want to put it.\n\n## Thanks! \n\nJohn Wright\nSent with Sparrow\n\nOn Wednesday, May 25, 2011 at 10:58 AM, millermedeiros wrote: \n\n> ohh... now I realized that you just want to keep the regular version of signals inside the package and I excluded it using the [.npmignore](https://github.com/millermedeiros/js-signals/blob/master/.npmignore) file...\n> \n> still not sure how are you using the files and if it makes sense to keep the whole `/dist` folder since npm is target only for node...\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/millermedeiros/js-signals/issues/23#comment_1236548\n. Exactly that will work. I wrote a cake task that parses my package.json dependencies and concatenates a JS file. I wrote a bit of an extension to package.json that specifies whether the file is local or in npm and I look inside node_modules for npm packages. I look inside lib, dist, or the root, so wherever you want to put it.\n\n## Thanks! \n\nJohn Wright\nSent with Sparrow\n\nOn Wednesday, May 25, 2011 at 10:58 AM, millermedeiros wrote: \n\n> ohh... now I realized that you just want to keep the regular version of signals inside the package and I excluded it using the [.npmignore](https://github.com/millermedeiros/js-signals/blob/master/.npmignore) file...\n> \n> still not sure how are you using the files and if it makes sense to keep the whole `/dist` folder since npm is target only for node...\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/millermedeiros/js-signals/issues/23#comment_1236548\n. ",
    "paullewis": "Not now, no. The code I've got is for a client so I can't just push it up. But the general idea is this:\n1. Bind two listeners to a signal\n2. Dispatch the signal\n3. In the first listener unbind the second listener, or actually delete the object with the listener function in it\n\nIn this case the loop through in the dispatch expects the second binding to be there, which it is. But if the _listener property has been deleted it's going to bail, which is what happened for me :)\n. Yeah, definitely the right behaviour as far as I'm concerned. I think your idea of improving the error message is a good one, but it shouldn't silently fail, that's for sure :)\n. Not now, no. The code I've got is for a client so I can't just push it up. But the general idea is this:\n1. Bind two listeners to a signal\n2. Dispatch the signal\n3. In the first listener unbind the second listener, or actually delete the object with the listener function in it\n\nIn this case the loop through in the dispatch expects the second binding to be there, which it is. But if the _listener property has been deleted it's going to bail, which is what happened for me :)\n. Yeah, definitely the right behaviour as far as I'm concerned. I think your idea of improving the error message is a good one, but it shouldn't silently fail, that's for sure :)\n. ",
    "ghost": "I would use a message bus!\n. I would use a message bus!\n. ",
    "AdamNowotny": "Just improved js-signal-logger and created new project https://github.com/AdamNowotny/jasmine-signals\nThis should be even easier to use with Jasmine.\n. You can find sample usage at https://github.com/AdamNowotny/BuildReactor, I'll keep this project up-to-date with jasmine-signals.\nThis should make it easier to configure js-signals, jasmine and require-js (just follow the SpecRunner.html file) and get started with the specs :) Note I'm including js-signals, jasmine and jasmine-signals in the page and not as AMD module.\n. Just improved js-signal-logger and created new project https://github.com/AdamNowotny/jasmine-signals\nThis should be even easier to use with Jasmine.\n. You can find sample usage at https://github.com/AdamNowotny/BuildReactor, I'll keep this project up-to-date with jasmine-signals.\nThis should make it easier to configure js-signals, jasmine and require-js (just follow the SpecRunner.html file) and get started with the specs :) Note I'm including js-signals, jasmine and jasmine-signals in the page and not as AMD module.\n. ",
    "r4j4h": "I haven't checked it out and done any tests myself, but just some food for thought: \n\nPerhaps it could be a switch flag on a Signal that can let the user choose on a per signal basis?\n\nOr perhaps some \"intelliswitching\" could be implemented after performance tests so that if the number of subscribers hits a given threshold then it switches its logic. There would need to be some logic to protect against bouncing, as I presume switching from one storage format to the other would have a cost, and if the threshold was say 1,000 and you were at 999 and quickly added and removed a couple of handlers, you wouldn't want it converting back and forth automatically. Perhaps a large sigma type check, like that used in comparing floating point numbers could be of use, so they'd have to go down to like 980 after hitting the 1,000 mark to convert back? May be best to just leave it up to user to decide though.\n. Thanks for the feedback, I agree too. I've been using Signals in several projects and agree that it is very fast and usable as is.\n\nProfiling sounds like the eventual final answer. \n. Sounds like you are on the right track but just wanted to add another outside perspective's concern for performance hits. :) (Even if v8 ameliorates performance hits that doesn't help other browsers' JS engines)\n. I haven't checked it out and done any tests myself, but just some food for thought: \n\nPerhaps it could be a switch flag on a Signal that can let the user choose on a per signal basis?\n\nOr perhaps some \"intelliswitching\" could be implemented after performance tests so that if the number of subscribers hits a given threshold then it switches its logic. There would need to be some logic to protect against bouncing, as I presume switching from one storage format to the other would have a cost, and if the threshold was say 1,000 and you were at 999 and quickly added and removed a couple of handlers, you wouldn't want it converting back and forth automatically. Perhaps a large sigma type check, like that used in comparing floating point numbers could be of use, so they'd have to go down to like 980 after hitting the 1,000 mark to convert back? May be best to just leave it up to user to decide though.\n. Thanks for the feedback, I agree too. I've been using Signals in several projects and agree that it is very fast and usable as is.\n\nProfiling sounds like the eventual final answer. \n. Sounds like you are on the right track but just wanted to add another outside perspective's concern for performance hits. :) (Even if v8 ameliorates performance hits that doesn't help other browsers' JS engines)\n. ",
    "jonnyreeves": "Sounds like a good solution to - continue to export the `signals` namespace in the browser whilst allowing those using AMD to require the Constructor directly :) +1\n. Sounds like a good solution to - continue to export the `signals` namespace in the browser whilst allowing those using AMD to require the Constructor directly :) +1\n. ",
    "sork": "As a user of js-signals as an AMD module, I think this is a good idea. I agree that the signals namespace is not necessary in that context.\n. As a user of js-signals as an AMD module, I think this is a good idea. I agree that the signals namespace is not necessary in that context.\n. ",
    "conradz": "@millermedeiros Is this change going to be made soon? This would really make it nicer to use.\n. No problem :)\n. @millermedeiros Is this change going to be made soon? This would really make it nicer to use.\n. No problem :)\n. ",
    "sgentile": "perhaps the way I'm adding the listener is invalid, it works in other browsers, so I will report back more details of how I'm adding a listener\n. I have validated - I get this error:\nLine: 172\nError: listener is a required param of add() and should be a Function.\n\ncode:\nvar Signal = signals.Signal;\n\nvar errorNotification = {\n    started: new Signal(),\n    stopped: new Signal()\n};\nfunction onStarted(param1, param2) {\n    alert(param1 + param2);\n}\n\nerrorNotification.started.add(onStarted);\nerrorNotification.started.dispatch('foo', 'bar');\n. my apologies, I discovered the actual source - the above did fire, but later in my code where I'm using hasher it was actually failing:\n\ncrossroads.routed.add(console.log, console); //log all routes\n\nThat failed in IE for me\n. perhaps the way I'm adding the listener is invalid, it works in other browsers, so I will report back more details of how I'm adding a listener\n. I have validated - I get this error:\nLine: 172\nError: listener is a required param of add() and should be a Function.\n\ncode:\nvar Signal = signals.Signal;\n\nvar errorNotification = {\n    started: new Signal(),\n    stopped: new Signal()\n};\nfunction onStarted(param1, param2) {\n    alert(param1 + param2);\n}\n\nerrorNotification.started.add(onStarted);\nerrorNotification.started.dispatch('foo', 'bar');\n. my apologies, I discovered the actual source - the above did fire, but later in my code where I'm using hasher it was actually failing:\n\ncrossroads.routed.add(console.log, console); //log all routes\n\nThat failed in IE for me\n. ",
    "shovemedia": "If you're using signals, you really ought to understand scope. That said, I'm down. \n. If you're using signals, you really ought to understand scope. That said, I'm down. \n. ",
    "wookieb": "\"since most people don't understand how scope works in JS\" I understand your point but that's their problem. Additionally the change is not consistent - why not autobind other methods like halt, forget? They can also be used as callbacks.\n\nIMHO autobinding for dispatch should be removed.\n. IMO this examples are fine https://github.com/millermedeiros/js-signals/wiki/Examples\n. \"since most people don't understand how scope works in JS\" I understand your point but that's their problem. Additionally the change is not consistent - why not autobind other methods like halt, forget? They can also be used as callbacks.\n\nIMHO autobinding for dispatch should be removed.\n. IMO this examples are fine https://github.com/millermedeiros/js-signals/wiki/Examples\n. ",
    "stasberkov": "If I introduce `typings` https://www.npmjs.com/package/typings for signals will you accept pull request?\n. If I introduce `typings` https://www.npmjs.com/package/typings for signals will you accept pull request?\n. ",
    "JohnSword": "how do I use this with typescript?\nI added the signals.min.js and the declaration file in VSCode, but when running the script in a browser I keep getting a ReferenceError: signals is not defined.\n. ok now it's working, I had to put this on the top of my ts file:\nimport signals = require(\"signals\");\n. how do I use this with typescript?\nI added the signals.min.js and the declaration file in VSCode, but when running the script in a browser I keep getting a ReferenceError: signals is not defined.\n. ok now it's working, I had to put this on the top of my ts file:\nimport signals = require(\"signals\");\n. ",
    "drkibitz": "keep as is. My autocomplete works ;)\nI don't know if v8 will fix the perf impact.\nAnd getters and setters introduce and unnecessary function call for most people.\nI use events for a lot, including games, which must dispatch quite a few signals at 60 fps. Introducing extra function calls can hurt things quite a big in these situations.\n. -1\n. keep as is. My autocomplete works ;)\nI don't know if v8 will fix the perf impact.\nAnd getters and setters introduce and unnecessary function call for most people.\nI use events for a lot, including games, which must dispatch quite a few signals at 60 fps. Introducing extra function calls can hurt things quite a big in these situations.\n. -1\n. ",
    "andy-law": "My initial thought on that is that it could become more confusing, as I'd expect calling mySignal() would more likely dispatch the signal than subscribe to it. \n. My initial thought on that is that it could become more confusing, as I'd expect calling mySignal() would more likely dispatch the signal than subscribe to it. \n. ",
    "auchenberg": "Confirmed. \n\nAwesome, thanks! :sunglasses:\n. Confirmed. \n\nAwesome, thanks! :sunglasses:\n. ",
    "kenvunz": "perfect! cheers\n. perfect! cheers\n. ",
    "SBoudrias": "> binding.detach() is kinda weird.. maybe a better name would be binding.cancel().\n\nAs you're going for `listen`. `stopListening` might be a better name (like Backbone done it).\n. > binding.detach() is kinda weird.. maybe a better name would be binding.cancel().\n\nAs you're going for `listen`. `stopListening` might be a better name (like Backbone done it).\n. ",
    "db": "Hi - thanks for porting Signals to JS. Nice work.\nI'm not sure if you're still considering this topic, but some feedback on the API change ideas. _Listen_ doesn't make as much sense to me. It reads like the signal is to listen to the listening function. IMO it is clearer that the listening function is _added_ to the signal bindings.\n. Hi - thanks for porting Signals to JS. Nice work.\nI'm not sure if you're still considering this topic, but some feedback on the API change ideas. _Listen_ doesn't make as much sense to me. It reads like the signal is to listen to the listening function. IMO it is clearer that the listening function is _added_ to the signal bindings.\n. ",
    "explorigin": "I love signals.  It has the best API concept of all that I've seen.  But there is one lacking feature that I would love to see.  Facebook's flux pattern introduces a \"dispatcher\" concept.  JS-signals could almost follow that role except for the \"dispatcher.waitFor()\" method.  You can read about it here (https://facebook.github.io/flux/docs/dispatcher.html).  It may be taking JS-signals in a direction that you don't want it to go, but I think it would be a nice addition.\n. I love signals.  It has the best API concept of all that I've seen.  But there is one lacking feature that I would love to see.  Facebook's flux pattern introduces a \"dispatcher\" concept.  JS-signals could almost follow that role except for the \"dispatcher.waitFor()\" method.  You can read about it here (https://facebook.github.io/flux/docs/dispatcher.html).  It may be taking JS-signals in a direction that you don't want it to go, but I think it would be a nice addition.\n. ",
    "sompylasar": "Looks like the concept behind the Flux Dispatcher is a queue with a\nbuffered input: the next payload won't be processed until all the callbacks\nhave processed the current payload.\n\nThe concept behind `waitFor` looks like is to reorder the queue of\ncallbacks in one dispatch cycle to guarantee the required order of payload\nprocessing. The classic pub-sub does not allow to define the order of\ncallback execution: the calls go in the order the components have\nsubscribed to the event which can be inconsistent (depends on the order of\ncomponents loading and instantiation, e.g. with async loading or lazy\ninstantiation).\n\nThese are my own observations, I may be wrong, just wanted to share my\nthoughts.\n. @AlexGalays `removeAll` is required to implement a destructor in a component that owns the signal instance (it could be reworked to be a true `destroy` that forgets all the handlers, releases all the resources it takes and marks itself as a destroyed object to avoid `add`-ing more handlers to it later).\n. FYI: http://www.youtube.com/watch?v=65-RbBwZQdU\n. Sure, looking at the real outcome of the vm is the key for optimizing the\nright way.\n. Looks like the concept behind the Flux Dispatcher is a queue with a\nbuffered input: the next payload won't be processed until all the callbacks\nhave processed the current payload.\n\nThe concept behind `waitFor` looks like is to reorder the queue of\ncallbacks in one dispatch cycle to guarantee the required order of payload\nprocessing. The classic pub-sub does not allow to define the order of\ncallback execution: the calls go in the order the components have\nsubscribed to the event which can be inconsistent (depends on the order of\ncomponents loading and instantiation, e.g. with async loading or lazy\ninstantiation).\n\nThese are my own observations, I may be wrong, just wanted to share my\nthoughts.\n. @AlexGalays `removeAll` is required to implement a destructor in a component that owns the signal instance (it could be reworked to be a true `destroy` that forgets all the handlers, releases all the resources it takes and marks itself as a destroyed object to avoid `add`-ing more handlers to it later).\n. FYI: http://www.youtube.com/watch?v=65-RbBwZQdU\n. Sure, looking at the real outcome of the vm is the key for optimizing the\nright way.\n. ",
    "AlexGalays": "Looks good;\n- `removeAll` could indeed be removed; it's invasive and personnaly never had a use case for it.\n- `add` could simply return an unsub function ? SignalBinding seems like an implementation detail that shouldn't be exposed.\n. Looks good;\n- `removeAll` could indeed be removed; it's invasive and personnaly never had a use case for it.\n- `add` could simply return an unsub function ? SignalBinding seems like an implementation detail that shouldn't be exposed.\n. ",
    "speigg": "I think `clicked.once().then(event => doSomething())` would be nice (basically, `signal.once()` returns a promise which is fulfilled the next time the event happens. Returning a promise here would be more flexible than `signal.listenOnce(doSomething)`. \n. Also, my suggestions for the api in general: \n\n``` javascript\nvar myObject = {\n  clicked: new signals.Signal()\n};\n// listening to a signal\nvar handle = myObject.clicked(doSomething)\n// emit a signal\nmyObject.clicked.emit({some: 'thing'})\n// listening for the next signal\nvar promise = object.clicked.once() // or object.clicked.next()\npromise.then(event => doSomething())\n// destroying a handle (remove listener)\nhandle.destroy()\n// remove all listeners\nmyObject.clicked.destroy()\n```\n. I think `clicked.once().then(event => doSomething())` would be nice (basically, `signal.once()` returns a promise which is fulfilled the next time the event happens. Returning a promise here would be more flexible than `signal.listenOnce(doSomething)`. \n. Also, my suggestions for the api in general: \n\n``` javascript\nvar myObject = {\n  clicked: new signals.Signal()\n};\n// listening to a signal\nvar handle = myObject.clicked(doSomething)\n// emit a signal\nmyObject.clicked.emit({some: 'thing'})\n// listening for the next signal\nvar promise = object.clicked.once() // or object.clicked.next()\npromise.then(event => doSomething())\n// destroying a handle (remove listener)\nhandle.destroy()\n// remove all listeners\nmyObject.clicked.destroy()\n```\n. ",
    "QuentinRoy": "I agree with@AlexGalays about SignalBinding being something user shouldn't be bothered with.\nHowever I don't see why `Signal#remove` should be removed.\nActually at the contrary I came to this thread because I would love an enhancement mimicking the functioning of `Backone.Events#off` (http://backbonejs.org/#Events-off). One could remove a callback by giving the callback, the callback and the context or only the context (which removes all callback for the given context, very useful as callback can be provided anonymously).\nPersonally, I never experienced the multi-context problem you were talking about.\n. I agree with@AlexGalays about SignalBinding being something user shouldn't be bothered with.\nHowever I don't see why `Signal#remove` should be removed.\nActually at the contrary I came to this thread because I would love an enhancement mimicking the functioning of `Backone.Events#off` (http://backbonejs.org/#Events-off). One could remove a callback by giving the callback, the callback and the context or only the context (which removes all callback for the given context, very useful as callback can be provided anonymously).\nPersonally, I never experienced the multi-context problem you were talking about.\n. ",
    "Hypercubed": "Just a comment that I would love to see a new version.  One thing I would very much like to see in a 2.0 would be performance testing and optomization.  For example I suspect dispatch is not optomized in v8:  http://www.slideshare.net/up2soul/planet-html5gameengine-javascript-performance-enhancement/9  \n. @divmgl   I created an alternative version (https://github.com/Hypercubed/mini-signals) that implements some of the v2.0 features discussed here.  I have contacted @millermedeiros to ask if he would like to merge or perhaps converge on an API, but I haven't heard back.\n. @millermedeiros I completely understand... on both points.\n. I forgot to mention you need to run the test using the following command:\n\n```\nnode --trace_opt --trace_deopt test.js\n```\n. FYI: http://jsperf.com/shotgun-js-vs-js-signals/4\n. Yep, I've seen this.  I don't entirely trust the jsperf myself.... what I do notice though is messages in the browser that signal.dispatch is being skipped by the v8 optimizer.  Some of the other github issue I listed above seam to think it can be significant.\n. Still slower than the loop I think... but surprisingly does appear to allow v8 optimization.\n. Maybe can do even better.  Apparently the one time you should can use `arguments` in a functional call without causing de-optimization is Function#apply (source https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#what-is-safe-arguments-usage).  I saw  huge boost here: https://github.com/Hypercubed/mini-signals\n. You're right.  In both cases v8 optimization works because of `Function#apply`.  I can use the binding function directly because I am not adding any saved params.  This is something that cannot be done in EventEmiiters because they need to remove the event name.\n. Do you mean add a comment in the code or in the commit message?\n. Just a comment that I would love to see a new version.  One thing I would very much like to see in a 2.0 would be performance testing and optomization.  For example I suspect dispatch is not optomized in v8:  http://www.slideshare.net/up2soul/planet-html5gameengine-javascript-performance-enhancement/9  \n. @divmgl   I created an alternative version (https://github.com/Hypercubed/mini-signals) that implements some of the v2.0 features discussed here.  I have contacted @millermedeiros to ask if he would like to merge or perhaps converge on an API, but I haven't heard back.\n. @millermedeiros I completely understand... on both points.\n. I forgot to mention you need to run the test using the following command:\n\n```\nnode --trace_opt --trace_deopt test.js\n```\n. FYI: http://jsperf.com/shotgun-js-vs-js-signals/4\n. Yep, I've seen this.  I don't entirely trust the jsperf myself.... what I do notice though is messages in the browser that signal.dispatch is being skipped by the v8 optimizer.  Some of the other github issue I listed above seam to think it can be significant.\n. Still slower than the loop I think... but surprisingly does appear to allow v8 optimization.\n. Maybe can do even better.  Apparently the one time you should can use `arguments` in a functional call without causing de-optimization is Function#apply (source https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#what-is-safe-arguments-usage).  I saw  huge boost here: https://github.com/Hypercubed/mini-signals\n. You're right.  In both cases v8 optimization works because of `Function#apply`.  I can use the binding function directly because I am not adding any saved params.  This is something that cannot be done in EventEmiiters because they need to remove the event name.\n. Do you mean add a comment in the code or in the commit message?\n. ",
    "divmgl": "So what's going on with this project? I'm actually looking for a simple event library as I'm not using Crossroads.js and Hasher in a new project. I'd be willing to contribute!\n. Hey @Hypercubed I like your library. I will continue discussion there. @millermedeiros Signals is actually working fine, I was just wondering about the state of the project. Thanks!\n. So what's going on with this project? I'm actually looking for a simple event library as I'm not using Crossroads.js and Hasher in a new project. I'd be willing to contribute!\n. Hey @Hypercubed I like your library. I will continue discussion there. @millermedeiros Signals is actually working fine, I was just wondering about the state of the project. Thanks!\n. ",
    "changfuguo": "tks so much ~~very helpful ~~~\n\n------------------ \u539f\u59cb\u90ae\u4ef6 ------------------\n\u53d1\u4ef6\u4eba: \"\u0141ukasz Ku\u017cy\u0144ski\";notifications@github.com;\n\u53d1\u9001\u65f6\u95f4: 2014\u5e747\u67089\u65e5(\u661f\u671f\u4e09) \u51cc\u66683:08\n\u6536\u4ef6\u4eba: \"millermedeiros/js-signals\"js-signals@noreply.github.com; \n\u6284\u9001: \"\u8042\u98ce\"changfuguo@qq.com; \n\u4e3b\u9898: Re: [js-signals] can you give us some examples? (#61)\n\nIMO these examples are fine https://github.com/millermedeiros/js-signals/wiki/Examples\n\n\u2014\nReply to this email directly or view it on GitHub.\n. tks so much ~~very helpful ~~~\n\n------------------ \u539f\u59cb\u90ae\u4ef6 ------------------\n\u53d1\u4ef6\u4eba: \"\u0141ukasz Ku\u017cy\u0144ski\";notifications@github.com;\n\u53d1\u9001\u65f6\u95f4: 2014\u5e747\u67089\u65e5(\u661f\u671f\u4e09) \u51cc\u66683:08\n\u6536\u4ef6\u4eba: \"millermedeiros/js-signals\"js-signals@noreply.github.com; \n\u6284\u9001: \"\u8042\u98ce\"changfuguo@qq.com; \n\u4e3b\u9898: Re: [js-signals] can you give us some examples? (#61)\n\nIMO these examples are fine https://github.com/millermedeiros/js-signals/wiki/Examples\n\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "mhofman": "Looks like Array.prototype.push.apply is not subject deoptimization and is decently fast so the following should work too:\n\n```\nvar paramsArr = [];\nArray.prototype.push.apply(paramsArr, arguments);\n```\n\nSee http://jsperf.com/copy-fn-arguments-test/16\n. Not that surprising. When you think about it, second argument of `Function.apply` is guaranteed to not be modified, so no reason to deoptimize.\nIt seems to be about half the speed of pre-allocated copy in Chrome, but strangely in Node it's much closer to the un-allocated copy, which makes much more sense.\n\nOh Arrays and their dark magic performances...\n\n```\nCopy to pre-allocated x 9,517,368 ops/sec \u00b10.31% (99 runs sampled)\nCopy to un-allocated x 7,222,102 ops/sec \u00b10.31% (99 runs sampled)\nCopy using Slice x 1,219,995 ops/sec \u00b10.53% (98 runs sampled)\nCopy using Slice Indirect x 1,149,504 ops/sec \u00b10.48% (91 runs sampled)\nCopy using Push apply x 7,130,480 ops/sec \u00b10.36% (96 runs sampled)\nManual Copy x 10,188,893 ops/sec \u00b10.49% (95 runs sampled)\n```\n. @Hypercubed, from what I understand your library doesn't allow for a binding to have its own prepended/saved params.\n\nRegardless, the `Function#apply` approach is the same that I suggested in my previous [comment](https://github.com/millermedeiros/js-signals/issues/67#issuecomment-110565241), just that you use it to invoke the binding's function directly, where here it has to be used to make a copy of the params using `Array#push`. While in Chrome it is faster than `slice.call()`, it still isn't as fast as a manual copy as you originally suggested, so in that sense it isn't better. However it sure is more readable IMHO.\n. Looks like Array.prototype.push.apply is not subject deoptimization and is decently fast so the following should work too:\n\n```\nvar paramsArr = [];\nArray.prototype.push.apply(paramsArr, arguments);\n```\n\nSee http://jsperf.com/copy-fn-arguments-test/16\n. Not that surprising. When you think about it, second argument of `Function.apply` is guaranteed to not be modified, so no reason to deoptimize.\nIt seems to be about half the speed of pre-allocated copy in Chrome, but strangely in Node it's much closer to the un-allocated copy, which makes much more sense.\n\nOh Arrays and their dark magic performances...\n\n```\nCopy to pre-allocated x 9,517,368 ops/sec \u00b10.31% (99 runs sampled)\nCopy to un-allocated x 7,222,102 ops/sec \u00b10.31% (99 runs sampled)\nCopy using Slice x 1,219,995 ops/sec \u00b10.53% (98 runs sampled)\nCopy using Slice Indirect x 1,149,504 ops/sec \u00b10.48% (91 runs sampled)\nCopy using Push apply x 7,130,480 ops/sec \u00b10.36% (96 runs sampled)\nManual Copy x 10,188,893 ops/sec \u00b10.49% (95 runs sampled)\n```\n. @Hypercubed, from what I understand your library doesn't allow for a binding to have its own prepended/saved params.\n\nRegardless, the `Function#apply` approach is the same that I suggested in my previous [comment](https://github.com/millermedeiros/js-signals/issues/67#issuecomment-110565241), just that you use it to invoke the binding's function directly, where here it has to be used to make a copy of the params using `Array#push`. While in Chrome it is faster than `slice.call()`, it still isn't as fast as a manual copy as you originally suggested, so in that sense it isn't better. However it sure is more readable IMHO.\n. ",
    "thesunlover": "its normal \"this\" to refer to window in your case. you are not binding the function to \"self\"\nyou'd better check your repo-history\n. its normal \"this\" to refer to window in your case. you are not binding the function to \"self\"\nyou'd better check your repo-history\n. ",
    "AndyCJ": "That'd be a good change.\r\n\r\nIt is documented over in the examples, but it would be best if it was in both places.\r\n\r\n[Stop/Halt Propagation (method 2)](https://github.com/millermedeiros/js-signals/wiki/Examples#stophalt-propagation-method-2)\r\n\r\n. That'd be a good change.\r\n\r\nIt is documented over in the examples, but it would be best if it was in both places.\r\n\r\n[Stop/Halt Propagation (method 2)](https://github.com/millermedeiros/js-signals/wiki/Examples#stophalt-propagation-method-2)\r\n\r\n. ",
    "felixnielsen": "@shubham93goyal will check, thanks.. @shubham93goyal will check, thanks.. "
}