{
    "coopernurse": "Hi there,\n\nare you using mymysql as your exp/sql driver?  If so, there's a patch I submitted to that project that is required to map bool values.  This patch also pools prepared statements, which is important to avoid running out of prepared statement handles in mysql.\n\nhttps://github.com/ziutek/mymysql/pull/5\n\nalso, there are probably some other issues you'll run into with gorp if you're using the weekly.  I have a pending patch into the exp/sql project that is needed to define all the Nullable types:\n\nhttp://codereview.appspot.com/5534048/\n. Oh, by the way, in my local environment, your test above passes.  So I think the problem is probably due to one of the two issues above (probably the bool marshalling).  Here's my test code:\n\n```\n// this passes for me\nfunc TestPersistentUser(t *testing.T) {\n    dbmap := &DbMap{Db: connect(), Dialect: dialect}\n    dbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n    table := dbmap.AddTable(PersistentUser{}).SetKeys(false, \"Key\")\n    table.ColMap(\"Key\").Rename(\"mykey\")\n    err := dbmap.CreateTables()\n    if err != nil {\n        panic(err)\n    }\n    pu := &PersistentUser{43,\"33r\",false}\n    err = dbmap.Insert(pu)\n    if err!=nil {\n        panic(err)\n    }\n}  \n```\n. the sql.Open(\"\", \"\") parameters are dependent on what exp/sql driver you use.  that line isn't a gorp call.  I can certainly update the example in the docs though.\n\nmultithreading isn't something I've tested, but based on my read of the exp/sql source code, connections to the database are acquired each time a query is run, and then released (exp/sql pools connections transparently).  consequently you _should_ be able to share a *DbMap across many goroutines.\n\nPlease try it out and let me know if you run into issues.  I would also graciously accept a unit test for this if you'd like to contribute one. \n. Interesting.  I would expect the non-threadsafe driver to still work if you have a single *DbMap shared across goroutines.  exp/sql will lock connections when in use, which should prevent concurrent use of the same connection.  \n\nI'm going to work on gorp today.  I'll try writing a test that spawns multiple goroutines and see if they fail with the non-thread safe mysql driver.  If they do I'll see if I can figure out the cause, as I don't think exp/sql requires thread safe drivers.\n. Hmm., well it's been 2 years and I never wrote the above test.  No one else has chimed in on this ticket so I'm guessing it's not causing trouble for folks at this point.\n. Hi,\n\nCan you send me the exact \"create table\" command that gorp generated?  Turn on trace logging to trap all the sql statements:\n\ndbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n\nthanks\n\n-- James\n. Ah, \"key\" is a reserved word in mysql.  Try using the Rename() method to alias that property to a different column name.\n. Hi there!\n\nI haven't thought about slices yet.   Postgres supports array columns it looks like.  Is that a SQL standard, or a Postgres extension?  I'm curious of how to handle it in the general case.  Open to suggestions on this.\n\ncheers\n\n-- James\n. Hi there. I'm not too familiar with how these Postgresql. ARRAY types work.  SQLite and MySQL don't support ARRAYs as far as I know, so this feature would only be available for Postgresql.\n\nA first step that would help would be to write a .go file (perhaps as a gist) that just does a simple INSERT / UPDATE / SELECT sequence against a table that has an ARRAY field using the pql driver directly (i.e. no gorp).  That example would help me understand how this data type works and would prove that the go postgres driver supports them.\n\nOnce we have that example I suspect we could figure out how to bolt it into the SQL generator in gorp.\n\nWhat do you think?\n. Sorry I've been quiet on this ticket.  @adharris, thanks for the example.  I just pushed a mechanism that allows you to write custom type converters for struct fields.  I wonder if this would be a good way to handle slices.\n\nIf anyone has a moment, take a look at the `gorp_test.go` `testTypeConverter` type, and related `TestTypeConversionExample()` \n. Not to my knowledge.\n. Hi there,\n\nThe issue is that sql.Open() is failing, so the db value is nil.  Here's a few things to fix in your code:\n\n1) You need to import a database driver.  for example, change the import to:\n\n```\nimport (\n    \"database/sql\"\n    \"github.com/coopernurse/gorp\" \n    _ \"github.com/ziutek/mymysql/godrv\"\n)\n```\n\n2) You should check the error return values from various calls.  Your code was ignoring the err value from sql.Open(), so you inadvertently passed the nil db value to the gorp.DbMap.\n\n3) If you're using the mymysql driver, the sql.Open() call should look like this:\n\n```\ndb, err := sql.Open(\"mymysql\", \"dbname/myuser/mypassword\")\nif err != nil {\npanic(err)\n}\n```\n\n4) Not a clear bug, but perhaps a misunderstanding: If you define Id as a primary key, gorp will ignore the value on insert.  So the 3 you're passing in will be ignored. So it may be more clear to write:\n\n```\np1 := &Sexo{Nombre:\"otro\"}\n```\n\nor\n\n```\np1 := &Sexo{0, \"otro\"}\n```\n\n---\n\nMy working version of your program looks like this:\n\n``` go\npackage main\n\nimport (\n    \"database/sql\"\n    \"github.com/coopernurse/gorp\"\n    _ \"github.com/ziutek/mymysql/godrv\"\n)\n\nfunc main() {\n    probarGORP()\n}\n\nfunc probarGORP() {\n    // construct a gorp DbMap\n    //dbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n    db, err := sql.Open(\"mymysql\", \"pds/pds/123456\")\n    if err != nil {\n        panic(err)\n    }\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{\"InnoDB\", \"UTF8\"}}\n    table := dbmap.AddTableWithName(Sexo{}, \"Sexo\").SetKeys(true, \"Id\")\n    table.ColMap(\"Id\").Rename(\"id\")\n    table.ColMap(\"Nombre\").Rename(\"nombre\")\n    p1 := &Sexo{Nombre:\"otro\"}\n\n    err = dbmap.Insert(p1) // Version is now 1\n    if err != nil {\n        panic(err)\n    }\n}\n\ntype Sexo struct {\n    Id     int64\n    Nombre string\n}\n```\n. Hi there,\n\nSee: `gorp_test.go` for an example.  The Transaction type implements the SqlExecutor interface, so you can call all the same methods on it that you could outside of a transaction context (e.g. Insert(), Update(), Delete()).  They don't take effect until you call: `trans.Commit()`\n\n```\ntrans, err := dbmap.Begin()\nif err != nil {\n    panic(err)\n}\ntrans.Insert(inv1, inv2)\nerr = trans.Commit()\nif err != nil {\n    panic(err)\n}\n```\n. Hi there,\n\nIt doesn't support embedding yet, but it's a worthy enhancement.  I'll keep this ticket open.  \n\nthanks.\n. Yep, this was merged. Closing this ticket.\n. Thanks for the patch.  I also modified Get() to use this mechanism, and cleaned up some of the column->Field mapping in rawselect.  If you have a moment, please pull the latest from master and verify that it looks good on your side.\n\ncheers\n. Hi there.  Interesting idea.  I agree that many shops standardize on naming conventions like this, but I think it would be hard for us to make everyone happy.\n\nWhat if we define an interface that lets users programmatically hook the mapping sequence.\n\nSomething like:\n\n``` go\n    // not sold on this name\n    type Mapper interface {\n        // returns table name for struct i. if no change desired, implementation should return mappedName\n        TableName(i interface{}, mappedName string) string\n\n        // returns customized ColumnMap for a field\n        ColumnMap(tableName string, field reflect.Value, column ColumnMap) ColumnMap\n    }\n\n    // modify DbMap to optionally hold a Mapper\n    type DbMap struct {\n        // new field\n        mapper Mapper\n    }\n\n    // Modify DbMap.AddTableWithName() to call Mapper methods\n```\n\nWe could also provide an exported convenience function for some common things.  Like:\n\n``` go\n    // turns:  MyTable into: my_table\n    func CamelCaseToUnderscore(s string) string { }\n```\n\nAnd that would enable you to satisfy your original desire by doing something like:\n\n``` go\n    type CamelCaseMapper struct { }\n\n    func (me CamelCaseMapper) TableName(i interface{}, mappedName) {\n        return gorp.CamelCaseToUnderscore(mappedName)\n    }\n\n    func (me CamelCaseMapper) ColumnMap(tableName string, field reflect.Value, column gorp.ColumnMap) gorp.ColumnMap {\n        column.ColumnName = gorp.CamelCaseToUnderscore(column.ColumnName)\n        return column\n    }\n\n    dbmap := &DbMap{Db: db, Dialect: dialect, Mapper: mapper}\n    dbmap.AddTable(MyStruct{})\n```\n\nToo complicated?\n. Yeah, good idea.  My slight preference is for a 2nd return value.  true=include column, false=ignore.  and perhaps the interface methods should be verbs.  how about:\n\n``` go\n    type Mapper interface {\n        // returns table name for struct i. if no change desired, implementation should return mappedName\n        MapTableName(i interface{}, mappedName string) string\n\n        // returns customized ColumnMap for a field\n        // bool return value species whether to include this field in the table mapping (true==yes, false==no, skip field)\n        MapColumn(tableName string, field reflect.Value, column ColumnMap) (ColumnMap, bool)\n    }\n```\n. It's a good idea.  I'm curious if this is mostly an issue for the driver implementations though.  For example, mymysql appears to support Scan() into time.Time:\n\nhttps://github.com/ziutek/mymysql/blob/master/godrv/driver.go\n\nDo you see any place where gorp would need to handle this type specially?  It seems we could pass it through like all other types and let the driver Scan into it.  Perhaps the sqlite driver doesn't support it and we should fork/patch that?\n. I think that change makes sense.  Honestly I'm not sure gorp has explicitly defined behavior for time.Time types.  When I first wrote it, Go1 wasn't out yet, and time.Time didn't exist.\n\nPerhaps we should just start a \"breaking changes\" section of the README and make it clear when we add something like this.  Every once in a while we'll need to break current behavior for the sake of progress/sanity.\n. I tried modifying the Postgres and Mysql dialects today and wrote a trivial test for it.  This test passes for postgres, but fails for mysql.  It appears the timezone gets set to the local timezone instead of UTC.  Anyone have an opinion on why this would occur? \n\nI don't want to commit this patch until I understand why a trivial insert/select isn't symmetric.\n\n``` go\nfunc TestWithTime(t *testing.T) {\n    dbmap := initDbMap()\n    defer dbmap.DropTables()\n\n    t1, err := time.Parse(\"2006-01-02 15:04\", \"2011-01-19 22:15\")\n    if err != nil {\n        panic(err)\n    }\n\n    w1 := WithTime{-1, t1, \"hi\"}\n    _insert(dbmap, &w1)\n\n    obj := _get(dbmap, WithTime{}, w1.Id)\n    w2 := obj.(*WithTime)\n    if w1.Date.UnixNano() != w2.Date.UnixNano() {\n        t.Errorf(\"%v != %v\", w1, w2)\n    }\n}\n```\n\nOutput from mysql:\n\n```\n--- FAIL: TestWithTime (0.05 seconds)\ngorp_test.go:875:   {1 2011-01-19 22:15:00 +0000 UTC hi} != &{1 2011-01-19 22:15:00 -0800 PST hi}\nFAIL\nexit status 1\n```\n. To clarify, for Mysql I mapped `time.Time` to `datetime`.  The create table command was:\n\n```\ngorptest: 14:46:59.983278 create table `time_test` (`Id` bigint not null primary key auto_increment, `Date` datetime, `Name` varchar(255))  engine=InnoDB charset=UTF8; [[]]\n```\n. merged to master and released in v1.1\n. Sounds useful.  Are we looking to do something like query by example?\n\nhttp://en.wikipedia.org/wiki/Query_by_Example\n. I'm thoughtful about this.  Is your need motivated only be queries that return single columns (and potentially a single row)?\n\nFor the count example I could imagine adding something like:\n\n   var count int64\n   err := dbmap.SelectRow(&count, \"select count(*) from foo where blah=?\", blah)\n\nSingle column queries could be handled by Query if we allow primitive types to be passed in.\n\n```\n// rows is []string\nrows, err := dbmap.Select(\"\", \"select email from people where id > 300\")\n```\n\nthoughts?\n. Hi there.  I have just pushed a change that adds a few new functions:  SelectInt(), SelectNullInt(), SelectStr(), SelectNullStr()\n\nThis allows you to run \"select count(*)\" style queries without any custom scanning.  e.g.:\n\n```\ncount, err := dbmap.SelectInt(\"select count(*) from foo where bar > ?\", barVal)\n```\n\nLet me know how that looks, and if it satisfies your use case we can close out this ticket.\n. This should be fixed now in master.  \"go test\" passes for me local against Postgresql\n. thanks for the fix!\n. This should be fixed now in master.\n. Thanks for reporting this, and for the very complete analysis.  I wonder if this could be fixed by replacing the Exec/LastInsertId calls in insert (lines 1350-1361) with an ExecAndReturnId call that combined the two, using the same db handle.\n\nOr is the issue more complex?\n. I'm also curious if you've tried using a gorp transaction around the code experiencing this issue.  Looking a bit more closely it appears that gorp would probably need to start a transaction on the *sql.Db handle to do this insert/select atomically.  I don't see a way to re-use a statement handle using Go's sql package without a transaction, but I could be missing it. \n. Great.  I'll take a pass at adding `ExecAndFetchLastInsertId` to the SqlExecutor interface.  The Transaction implementation can simply do what the current code does.  The non-transactional impl will start a transaction and perform the two operations in a transactional context.\n\nI wonder if this is worth elevating to the Go maintainers.  The connection pool is actually implemented in the Go sql package, so the behavior you're seeing would occur with any code that simply does an Exec() and LastInsertId() call in sequence using the standard Go sql API.  Unless I'm missing something gorp isn't doing anything exotic here, and this bug could be considered a design flaw in the Go sql package.  Ideally the sql package would expose an atomic operation for the insert and get last insert id pair.\n. derp.  It's clear I haven't been looking at gorp in a while.  now that I read dialect.go, I see that this isn't Go's fault.\n\nDo you know if the postgres go driver has added support for res.LastInsertId() ?   Perhaps that's not possible given how Postgres deals with sequences.\n\nAlternate approach: rework the Dialect.LastInsertId() call to be the atomic operation.  That would allow vendor specific approaches, such as the `INSERT .. RETURNING` approach.\n. Ok, I just pushed changes that rework the LastInsertId mechanism.  I went with the `INSERT .. RETURNING` approach as you suggested.  \n\nI'll leave this ticket open for a bit.  If you have a moment please try using master, or merging the changes to your fork and see if you like what you see.\n. No news is good news I think.  Closing this out for now.  Re-open if there's an issue with the changes I made a few months ago.\n. Apologies I haven't commented.  I like the idea, but I wonder if we should use the same \"db\" tag for all of these attributes, rather than introducing another tag.  For example:\n\n```\ntype Product struct {\n    Id int64 db:\"product_id,pk,autoincrement\"\n    Price int64 db:\"unit_price\"\n    IgnoreMe string db:\"-\"\n}\n```\n\nThat would follow the convention used in the `encoding/json` package (and probably others).\n\nThoughts?\n. I should clarify: the first item in the comma separated list would always be the column name, similar to the way the json tag works.\n. Hi,\n\nYou're passing the MySQL params into the SqliteDialect{}, try this:\n\n``` go\ndbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}\n```\n. It sounds like a useful addition, but I'm wondering about the naming.  If we're going to just use a boolean then I'd prefer two functions:\n\n``` go\n// same behavior as current implementation\nfunc (m *DbMap) CreateTables() error { }\n\n// adds the \"if not exists\" clause\nfunc (m *DbMap) CreateTablesIfNotExists() error\n```\n\nFeel free to update your pull request, or leave a comment and I can implement this change.  \n\nAdding a test for this would be great too.\n\ncheers\n. Ok, CreateTablesIfNotExists() has been added to DbMap and pushed to master.\n. Good idea. \n. Ok, this is fixed in master.  Insert() will return an error in this case.  The autoincr bindable types are: Int, Int16, Int32, Int64\n. The `ToSqlType()` command in the default dialects is primarily provided as an example.  You can easily write your own dialect that implements `ToSqlType()` with any rules you like.\n\nIf you'd like to extend the default dialect, one option is to add an optional field to PostgresDialect that specifies the cutoff for maxsize that would dictate whether to use a text field.  But this is a slippery slope that may further reinforce the idea that the provided dialect implementations are intended to satisfy all use cases.\n. Could you elaborate on your question?  Or provide an example of what you're trying to do?\n. That completely makes sense.  I would happily merge a pull request with that  :-)\n\nIt would be ideal to figure out how to implement this without breaking backwards compatibility. If Select() is passed a pointer to a slice, then automatically populate the slice, otherwise behave as it currently does.  Would that work?\n. Excellent.  I'll review this code in a couple of days.  Thanks guys.\n. Hey guys,\n\n@robig yes, if you have some time to take a stab at making that backwards compatible, that'd be excellent.  a test or two would also be nice.\n\nthanks again\n. I was able to compile cleanly from gorp/master using Go 1.1 on windows.\n\nIs anyone else able to repro these build failures?\n. Ok. I'm going to close this out for now unless we get more details.\n. #41 has been merged in, so I'm closing this ticket.\n. Ok, CreateTablesIfNotExists() has been added to DbMap\n. Could you reproduce this bug in a test?  I just tried this and it worked on all 3 supported databases:\n\n``` go\nfunc TestAutoIncrMultipleRows(t *testing.T) {\n    inv1 := &Invoice{0, 100, 200, \"my memo 1\", 0, false}\n    inv2 := &Invoice{0, 100, 200, \"my memo 2\", 0, false}\n    inv3 := &Invoice{0, 100, 200, \"my memo 3\", 0, false}\n\n    dbmap := initDbMap()\n    defer dbmap.DropTables()\n\n    insert(dbmap, inv1, inv2, inv3)\n\n    if inv1.Id != 1 {\n        t.Errorf(\"inv1.Id is 0\")\n    }\n    if inv2.Id != 2 {\n        t.Errorf(\"inv2.Id is 0\")\n    }\n    if inv3.Id != 3 {\n        t.Errorf(\"inv3.Id is 0\")\n    }\n}\n```\n. Oops!  sorry I completely misunderstood.   Yes, I can repro this issue in test.  I'll try merging in your patch.\n. Wow, thanks for the quick turnaround.  I don't think I'll have time to review this tonight, but hopefully in the next day or two.\n. Hey guys.  I'm merging this stuff into master now.  @sqs I have integrated your patch+test from 6dfc2ee.\n\nI think the only outstanding item is the error message: \"gorp: Cannot SELECT into non-struct type: []*MyType\"\n\nI'm inclined to just get these commits into master, and open a separate issue for that.  Just so we don't keep this work sequestered too long.\n\nthanks guys for all your work on this!  great addition.\n\n-- James\n. Thanks, this is in master now!\n. Great stuff.  I'll work on merging this over the weekend.  But first I want to get some docs in place for the slice scanning work that was just merged (#40).\n\ncheers\n. ok, I started working on this.  I've got it merged locally and the tests are passing on all 3 databases.  nice work.\n\nI want to read the code a bit before I push it, but so far it looks great.\n. Interesting case.  What's the expected behavior here?  Perhaps detected that we don't have any non-PK columns and simply return 0, nil from Update()?\n. I think it's a good ticket.  gorp shouldn't blow up in this case.  I'll take a stab at reproducing this in a test today.\n. Cool, here's my first take at a patch.  I renamed `x` to `bindCount` for clarity.  If there are no bound columns in the SET clause, then `bindUpdate()` doesn't compute the rest of the query. Update() will skip the SQL operation entirely when bindArgs is empty.\n\nThis still allows the pre/post update hooks to run, and provides driver independent behavior.  I noticed that if we execute a no-op sql statement in this case.e.g.: `update foo set id=id where id=?` then MySQL reports 0 rows updated, and Postgresql reports 1 row updated.\n\n``` diff\ndiff --git a/gorp.go b/gorp.go\nindex 7371ee7..c3fcd46 100644\n--- a/gorp.go\n+++ b/gorp.go\n@@ -315,17 +315,19 @@ func (t *TableMap) bindUpdate(elem reflect.Value) (bindInstance, error) {\n\n                s := bytes.Buffer{}\n                s.WriteString(fmt.Sprintf(\"update %s set \", t.dbmap.Dialect.QuoteField(t.TableName)))\n-               x := 0\n+\n+               bindCount := 0\n\n                for y := range t.columns {\n                        col := t.columns[y]\n                        if !col.isPK && !col.Transient {\n-                               if x > 0 {\n+                               if bindCount > 0 {\n                                        s.WriteString(\", \")\n                                }\n+\n                                s.WriteString(t.dbmap.Dialect.QuoteField(col.ColumnName))\n                                s.WriteString(\"=\")\n-                               s.WriteString(t.dbmap.Dialect.BindVar(x))\n+                               s.WriteString(t.dbmap.Dialect.BindVar(bindCount))\n\n                                if col == t.version {\n                                        plan.versField = col.fieldName\n@@ -333,10 +335,11 @@ func (t *TableMap) bindUpdate(elem reflect.Value) (bindInstance, error) {\n                                } else {\n                                        plan.argFields = append(plan.argFields, col.fieldName)\n                                }\n-                               x++\n+                               bindCount++\n                        }\n                }\n\n+               if bindCount > 0 {\n                        s.WriteString(\" where \")\n                        for y := range t.keys {\n                                col := t.keys[y]\n@@ -345,20 +348,21 @@ func (t *TableMap) bindUpdate(elem reflect.Value) (bindInstance, error) {\n                                }\n                                s.WriteString(t.dbmap.Dialect.QuoteField(col.ColumnName))\n                                s.WriteString(\"=\")\n-                       s.WriteString(t.dbmap.Dialect.BindVar(x))\n+                               s.WriteString(t.dbmap.Dialect.BindVar(bindCount))\n\n                                plan.argFields = append(plan.argFields, col.fieldName)\n                                plan.keyFields = append(plan.keyFields, col.fieldName)\n-                       x++\n+                               bindCount++\n                        }\n                        if plan.versField != \"\" {\n                                s.WriteString(\" and \")\n                                s.WriteString(t.dbmap.Dialect.QuoteField(t.version.ColumnName))\n                                s.WriteString(\"=\")\n-                       s.WriteString(t.dbmap.Dialect.BindVar(x))\n+                               s.WriteString(t.dbmap.Dialect.BindVar(bindCount))\n                                plan.argFields = append(plan.argFields, plan.versField)\n                        }\n                        s.WriteString(\";\")\n+               }\n\n                plan.query = s.String()\n                t.updatePlan = plan\n@@ -1384,6 +1388,7 @@ func update(m *DbMap, exec SqlExecutor, list ...interface{}) (int64, error) {\n                        return -1, err\n                }\n\n+               if len(bi.args) > 0 {\n                        res, err := exec.Exec(bi.query, bi.args...)\n                        if err != nil {\n                                return -1, err\n@@ -1404,6 +1409,7 @@ func update(m *DbMap, exec SqlExecutor, list ...interface{}) (int64, error) {\n                        }\n\n                        count += rows\n+               }\n\n                err = runHook(\"PostUpdate\", eptr, hookarg)\n                if err != nil {\n```\n. This is fixed now and tested across the 3 supported databases.\n. This was fixed in: fce0ecf6b40d439c9e22213423f6125d2126d151\n. ok, this is in master now.  README is also cleaned up and restructured for better readability.\n. wow, good catch. I just pushed this patch to master.  I don't see a downside.\n. Implemented in master.\n. Makes sense to me.  I'l update the doc comment to indicate that we'll panic in this case.\n. Hi there,\n\n`SelectInt` is a bit of a hack.  One option would be to add a new method: `SelectInto()` that accepts a pointer to scan the result into.  This would be a generalization of the enhancement in #40.  \n\n`SelectInto` would be added to `SqlExecutor` so you could use it with transactions.  Example code might look like:\n\n``` go\nfunc (u *User) NumRecords(s gorp.SqlExecutor) int {\n    var count int64\n    err := s.SelectInto(&count, \"SELECT COUNT(*) as Count FROM Queue WHERE User_Id = $1\", u.Id)\n    // handle err\n    return count\n}\n```\n\nMy guess is we've got all the pieces for this in place.  It will just be a simple matter of moving them around.  :-)\n. @robfig good point, I agree that SelectInt fixes this issue.  If someone disagrees, please re-open, but you should be able to write this now:\n\n``` go\nfunc (u *User) NumRecords(s gorp.SqlExecutor) int {\n    count, err := s.SelectInt(\"SELECT COUNT(*) as Count FROM Queue WHERE User_Id = $1\", u.Id)\n    // handle err\n    return count\n}\n```\n. ah, good observation.  The placeholder variable (\"?\" vs \"$1\") is database dependent (gorp doesn't do that substitution).  \n\nat a minimum, the docs should reflect this.  the examples with ? would work for mysql or sqlite, but not postgres, as you noted.\n. I'm going to close this out -- the README now has a \"known issues\" section that clarifies this.  If you need fully portable queries, you can use the keyword \":foo\" placeholder syntax + maps/structs instead of positional placeholders.\n. Have you tried using `sql.NullInt64` for the nullable values?  For example:\n\n``` go\ntype MyModel struct {\n    Id             int    `db:\"id\"`\n    Name           string `db:\"name\"`\n    ProjectId      sql.NullInt64    `db:\"project_id\"`    // Allows NULL\n    CustomerId     sql.NullInt64    `db:\"customer_id\"`    // Allows NULL\n}\n```\n\ngorp _should_ do the right thing with these (we have a basic test for this case at least).\n. Interesting. So that error is coming from gorp.  search for that string in gorp's dialect.go and you'll see what we're trying to do.\n\nIs `activities.id` definitely defined as a serial or bigserial column?  If not, that would explain the error.  If so, then I'm at a bit of a loss at the moment and would probably have to reproduce it in test and fiddle with it to narrow it down.\n. Could you turn tracing on (see \"SQL Logging\" in the README) and post the generated SQL for those two examples?\n\nI don't see an obvious reason to explain this.\n. Thanks for the thoughtful post.\n\nI like the ideas for tags.  My only initial comment is that we'd have to carefully define the enum of types that are supported.\n\nRe: Codec: there's actually a (poorly documented) solution for this in master.  See this interface:\n\n``` go\ntype TypeConverter interface {\n    // ToDb converts val to another type. Called before INSERT/UPDATE operations\n    ToDb(val interface{}) (interface{}, error)\n\n    // FromDb returns a CustomScanner appropriate for this type. This will be used\n    // to hold values returned from SELECT queries.\n    //\n    // In particular the CustomScanner returned should implement a Binder\n    // function appropriate for the Go type you wish to convert the db value to\n    //\n    // If bool==false, then no custom scanner will be used for this field.\n    FromDb(target interface{}) (CustomScanner, bool)\n}\n```\n\nAnd this example in `gorp_test.go`\n\n``` go\nfunc TestTypeConversionExample(t *testing.T) {\n    dbmap := initDbMap()\n    defer dbmap.DropTables()\n\n    p := Person{FName: \"Bob\", LName: \"Smith\"}\n    tc := &TypeConversionExample{-1, p, CustomStringType(\"hi\")}\n    _insert(dbmap, tc)\n\n    expected := &TypeConversionExample{1, p, CustomStringType(\"hi\")}\n    tc2 := _get(dbmap, TypeConversionExample{}, tc.Id).(*TypeConversionExample)\n    if !reflect.DeepEqual(expected, tc2) {\n        t.Errorf(\"tc2 %v != %v\", expected, tc2)\n    }\n\n    tc2.Name = CustomStringType(\"hi2\")\n    tc2.PersonJSON = Person{FName: \"Jane\", LName: \"Doe\"}\n    _update(dbmap, tc2)\n\n    expected = &TypeConversionExample{1, tc2.PersonJSON, CustomStringType(\"hi2\")}\n    tc3 := _get(dbmap, TypeConversionExample{}, tc.Id).(*TypeConversionExample)\n    if !reflect.DeepEqual(expected, tc3) {\n        t.Errorf(\"tc3 %v != %v\", expected, tc3)\n    }\n\n    if _del(dbmap, tc) != 1 {\n        t.Errorf(\"Did not delete row with Id: %d\", tc.Id)\n    }\n\n}\n```\n. You raise some good points. It seems the two approaches aren't mutually exclusive.   We could check if the type implements TypeCodec, and if so, use that for conversion, else delegate to the TypeConverter if one is registered.\n\nIs that what you have in mind?\n. I think we should consider a name other than transient.  Today setting transient=true on a field will exclude it from all generated INSERT/UPDATE/SELECT queries.\n\nIt sounds like the goal here is to tell gorp to only use this column for SELECT statements.  Is that right?\n\nIf so, perhaps something like `readonly` or `selectonly` would be more descriptive?\n. This is looking good.  Could you please update the README to include an example of usage?\n. Sorry I never commented on this @robfig .  I like your latter examples (I don't have a strong opinion on using `...` vs `{}`).  \n\nI would gladly merge a PR that implemented this.\n\nNote that I'm starting to use a develop branch, so if you implement this please do it on a feature branch, and I'll merge it to develop. \n\nthanks!\n. Agreed, I'll remove it\n. Done.\n. I agree with @purohit - you'll need to export the fields.  Here's a SO thread about this.  The reflect package won't let gorp see your non-exported fields:\n\nhttp://stackoverflow.com/questions/11126793/golang-json-and-dealing-with-unexported-fields\n. Excellent.  Glad you got it working!\n. I've created a \"develop\" branch.  I'm going to merge into that and test locally.  If tests pass I'll push this branch along with a set of other pending pull requests so we can test all of them together before merging to master.\n. postgres and sqlite are passing now.  mysql still fails, due to tz issues that @seehuhn notes.\n\nI'm ok with merging this, but I'm going to modify the gorp README to warn users about using time.Time in their mapped structs, particularly on MySQL.\n\nSince the test fails I'm also going to disable the test for now (change it to lowercase so go test doesn't run it).  I'll file another issue to remind us to add it back in when https://github.com/ziutek/mymysql/pull/77  lands.\n. Good idea. Thanks.\n. merged to master and released.\n. Thanks for the contributions.\n\nRe: b7d1729:  I think it's an interesting idea, but I want to think about it more.  It changes existing behavior, which may surprise some users, and it impacts portability.  Also, since Dialect is an interface, it's pretty easy to just make your own with this (or any other) behavior.  If you feel strongly about it, please open a separate issue for this so we can get opinions from other folks watching this repo.\n\nRe d9421a6: Looks good.  I'm going to merge this into the develop branch, which is where I'm starting to stage changes in batch before folding into master.\n\nRe 76d12f3: Good ideas here, but there's a lot of activity in this general area (2-3 other PRs).  So I'm going to hold off on this too.  I'm going to create a master ticket for the \"grand tag enhancement\" feature so we can hash out the best way to deal with this and get feedback from everyone.\n\ncheers\n. I'm going to close this out, but I opened #79 to track the d9421a6 commit\n\nthanks\n. Hi,\n\nsql.Result has two methods:\n\n``` go\ntype Result interface {\n    LastInsertId() (int64, error)\n    RowsAffected() (int64, error)\n}\n```\n\n`LastInsertId()` is automatically bound to your struct if you specify an autoIncr key via TableMap.SetKeys().  RowsAffected() isn't currently mapped, but I'm curious when that would be useful.\n\nWhat's your use case where you need the raw sql.Result?\n. Thanks, this has been merged into the \"develop\" branch.  I'm now using that to batch up sets of changes before merging into master.\n. One issue I see here is that if you mutate `isAutoIncr` then the `TableMap.insertPlan` is potentially invalid and needs to be regenerated.\n\nSo I think we'd need to expose this via a method, which can regenerate that SQL statement.\n. Hi there,\n\nThe `database/sql` package provides some \"null\" types that you can use for this purpose. For example:\n\n``` go\ntype Person struct {\n    Id      int64\n    Name sql.NullString\n    Age sql.NullInt64\n}\n```\n\nName and Age can both be null in the db, and will scan properly.  You would get the value via:   person.Name.String.   \n. Hi Rob,\n\nthis has been merged into the \"develop\" branch and pushed.  I'm going to mark #70 as a v1.1 item (v1.1 will reflect the merge from develop to master) and close this PR out now.\n\nthanks!\n. merged to master and released in v1.1\n. hey Rob,\n\nThis is pretty sweet.  Does it work on the other methods that accept raw SQL selects (e.g. \"SelectInt\")?  Or just Select()?\n\nI'll have more time to review this on Friday.  As I mentioned on twitter, I'm rolling all these PRs into the develop branch now, testing there, and then will merge together into master and tag as a release.\n. Great stuff.  Tests pass on all 3 dbs.  I think this may also address portability concerns (see: #53), as folks can write queries with `where foo = :foo` instead of `where foo = ?` and have it still work on postgresql.\n. btw, this was merged into develop, just for the record.\n. I'm not sure if I understand the question, but you could simply change the dbmap.Db reference to point at a different database connection.  Have you tried that?\n. Hi there,\n\nThis was merged into develop and will appear in master in the next release (probably today).\n. Hi Otto,\n\nThanks for the report.  I'll try to write a test that replicates your query.  I think your code looks fine and this is something gorp should handle correctly.\n. Hi there,\n\nThis test passes for me against PostgreSql 9.1.4 on my mac.  It also passes on sqlite.\n\nDoes this pass for you?  If not, what driver are you using? I'm using `github.com/lib/pq`\n\n``` go\ntype Times struct {\n    One time.Time\n    Two time.Time\n}\n\ntype EmbeddedTime struct {\n    Id string\n    Times\n}\n\n// See: https://github.com/coopernurse/gorp/issues/86\nfunc TestEmbeddedTime(t *testing.T) {\n    dbmap := newDbMap()\n    dbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n    dbmap.AddTable(EmbeddedTime{}).SetKeys(false, \"Id\")\n    defer dbmap.DropTables()\n    err := dbmap.CreateTables()\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    time1 := parseTimeOrPanic(\"2006-01-02 15:04:05\", \"2013-08-09 21:30:43\")\n\n    t1 := &EmbeddedTime{Id: \"abc\", Times: Times{One: time1, Two: time1.Add(10 * time.Second)}}\n    _insert(dbmap, t1)\n\n    x := _get(dbmap, EmbeddedTime{}, t1.Id)\n    t2, _ := x.(*EmbeddedTime)\n    if t1.One.UnixNano() != t2.One.UnixNano() || t1.Two.UnixNano() != t2.Two.UnixNano() {\n        t.Errorf(\"%v != %v\", t1, t2)\n    }\n}\n```\n. Hi guys,\n\nI like the idea as well. I also like the `Select` vs `SelectOne` idea -- If a non-slice pointer is provided to `Select` it returns the first row found, whereas `SelectOne` raises an error if there is more than one row.\n\nI'm partial to keeping the `SelectInt`, `SelectStr` family of methods, simply for convenience (you don't have to forward declare the return variable), but they could be modified internally to use `Select`\n. Howdy,\n\nSee the above commit -- it's on the develop branch, so it's still unreleased.\n\nWhat do you think?  Rob, if you can kick the tires on it a bit with your local tree that would be great.\n\nthanks\n\n-- James\n. I've merged this into master as part of v1.2\n. Hi there.  No, there's currently no support for foreign keys in gorp.  Your first example looks good (aside from ignoring the err values). \n\nOn the develop branch there's a new `SelectOne()` method (see #87) which lets you avoid the type assertion, but doesn't auto-generate the SQL string.\n\n``` go\nvar first First\nvar second Second\n// ? placeholders for mysql/sqlite, use $1 for postgres, or use the map syntax if you \n// need full portability\nerr := dbmap.SelectOne(&first, \"select * from First where Id=?\", first_id)\n// handle err\nerr = dbmap.SelectOne(&second, \"select * from Second where Id=?\", first.SecondId)\n// handle err\n```\n. Looks good.  I'm going to cherry pick these commits and apply them to the develop branch.\n. Ok this has been merged into master.  Thank you!\n. Makes sense.  I'd like to think a bit about the API for this. In general should the philosophy be to specify the column names, or the struct fields?  Is there any way to provide type safety?\n. See #115 - I think you guys are attacking similar problems.  Anyone else have an opinion?  I'm leaning towards #115 at this point, but I'm not a Postgresql user so I want to defer to those who are.\n. #115 was released as part of v1.4 today. Closing this ticket out.\n. Thanks for the submission.  I'll review this next week.\n. Hi there. Sorry I'm currently on vacation. I haven't reviewed your PR yet but I will. Sorry for the delay. \n. Ok, I've cherry picked these commits into develop and pushed.  I'm going to release this, #115 and #108 together into master as v1.4\n\nPlease merge develop into your fork and verify that things look good to you.  I'm going to run my current work project against this branch for a few days as well.\n. This was merged into master today as part of v1.4. thanks again.\n. Thanks for patching this.  I'm going to do some gorp work on Monday so I'll review this and get it merged into master then.\n. Ah, that's an oversight.  Yes, let's add it.\n. sorry for the delay in reviewing -- this is a pretty big PR, so I agree it would be helpful to have the commits squashed so that the diff is easier to review.\n\nI looked through it and saw at least one instance where the SqlDialect was inspected in the code -- may be good to factor that case into the Dialect interface.  I can comment more specifically on that when we have the new diff.\n. Thanks for the contribution.  Unfortunately once I document a public API I generally avoid non backwards compatible changes.  Your change makes sense, but folks may rely on the present behavior (although SelectOne() is quite new).\n\nI've opened #101 to track the discussion for this.  I'm going to close this PR, but keep that issue open for discussion.\n\ncheers\n\n-- James\n. Yeah I agree that an error is probably more sensible. SelectOne() is new enough that backwards compatibility may not be a major concern.\n. Ok, I've cherry-picked the commit on #98  --  so SelectOne() will now return an error if no row is found.\n\nThanks for the comments here - I may have kept this open a little longer than I should have, but I'm happy that we had a more or less unanimous vote.\n. This is merged into master\n. SQL statements fully generated by gorp (e.g. Get, Insert, Update, Delete) should be safe, as they use prepared statements with all variables passed as bind arguments.\n\nBut Exec and the Select\\* methods accept SQL strings you pass in.  If you use placeholders for all variables (as opposed to including user input in the SQL string itself) then you're fine.  But since gorp exposes the raw abstraction, you could write code that is vulnerable.\n\nHope that clarifies things.\n. I agree that the #92 is a good compromise here.  \n\nA tag could work -- I would use the `omitempty` tag to match the Go json tag.  The semantics seem similar to me -- drop nil/zero values.\n. @chbrown I agree with the comparisons to `encoding/json`.\n\nWe have a pending PR for #92, but I would still welcome a PR for the `omitempty` case.\n\nOne note: I would want API support for omitempty in addition to a tag.  Tags are sugar for the API, but it should always be possible to set mapping rules programmatically (for types you don't have source control over).\n. Since Go doesn't have polymorphism we'd need a new name for this, perhaps:\n\n``` go\nfunc (m *DbMap) SelectMap(query string, args ...interface{}) (map[string]interface{}, error)\n```\n\nGiven that you'll have to type assert the values in the map, I'm not sure how convenient this method will be though.  I suppose if you have a case where you don't know the columns returned until runtime it may be useful.\n\nAnyone else feel this is worth adding?\n. #108 fixes this. Released to master today in v1.4\n. Since your PR was done from master I cherry picked it into develop and re-did the merge.  \n\nI haven't merged develop to master yet.  I'll do that next week after I get feedback on #115 and #94.  If you could modify your fork to track develop that would be great.  Details here: https://help.github.com/articles/syncing-a-fork\n. This was merged to master today as part of v1.4. Thanks.\n. Ah, that's a good catch. Kind() may work for aliases of built in types.  In theory you could alias a struct at which point we'd need the Type (both would have Kind() equal to \"Struct\" I think).\n\nThe test above looks like a good start.  When I have some free time I'll see if I can get it passing.  Others who read this, feel free to do the same and send a pull request.\n. @iwek `html/template` `Template` struct is a parse tree AFAIK.  You'd probably want to persist the actual HTML document as a string or byte slice.\n. Is your DbMap using the gorp.MySQLDialect?  If so, identifiers should be backtick escaped, not double quoted.\n\nYou want to do something like:\n\n``` go\ndbmap := &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{\"InnoDB\", \"UTF8\"}}\n```\n. Hi, I just ran the test suite using that driver and it passed.  The puzzling part to me is you're getting double quotes around identifiers.  The MysqlDialect won't do that.\n\nPlease paste some code that reproduces this and perhaps we can figure it out.  But right now I'm unclear how you're getting that SQL from gorp if you're using the MysqlDialect.\n. Are you running the latest version of gorp in master?\n\nGiven the change made in commit e17cc11 to panic if Engine or Encoding is empty, you need to change the last line of openorm() to:\n\n``` go\nreturn &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{Engine: \"InnoDB\", Encoding: \"UTF8\"}}, nil\n```\n\nWith that change \"go test\" on this file runs fine on my machine. \n. Hi Rob,\n\nAre you sure that doesn't work?  I'm using non-pointer slices with Select() on a project and it's working for me.  Maybe something else is going on?\n. I've cherry picked this commit and added some docs to the README.  Thanks.\n. Thanks.  Overlaps with #93 - I like your approach, but I want to get some more comments from other users.\n. Ok I've cherry picked this commit into the develop branch. \n\nPlease try this branch with your project and comment here if you see issues.  I'll be merging develop to master some time next week.\n. This was merged into master today as part of v1.4\n. Docs are here: http://godoc.org/github.com/coopernurse/gorp\n- Primary key:  use TableMap.SetKeys()\n- Not null:  use ColumnMap.NotNull()\n- Default: not supported directly, but you could use the PreInsert/PreUpdate hooks for this\n. Are you checking the error return value from CreateTablesIfNotExists()?\n. Ok I cherry picked b6b7bba into master.  gofmt will be run in develop along with some other PRs that I'm merging.\n\nthanks.\n. I'm not a Postgres user so I'm not sure why this was added.  It was done in 84cf915 as part of #22 \n\nLooking at this: http://stackoverflow.com/questions/7262795/postgresql-table-name-schema-confusion\n\nIt looks like if we quote the identifier it becomes case-sensitive, which means using ToLower() is a bad idea.\n\nAny Postgres users disagree?  I'm inclined to remove ToLower() here.\n. @jordan-wright I agree, some change is required here.  \n\nI'm leaning towards removing ToLower() -- are there any major objections?  I realize this departs for existing behavior, but unfortunately I think that's unavoidable to move forward.\n\nI'm not going to change this for 1.4, but I'd like to get a commit in for 1.5 that resolves this ticket one way or another.\n. I've never tried it.  How do you do it with the `database/sql` interface?\n. Closing due to inactivity.\n. Now that I look at `database/sql` I'm unclear where the \"Nullable*\" names came from.  Maybe these were the `exp/sql` names prior to Go 1?  \n\nAnyone think we need to keep the \"NullableInt64\" type names.  I don't see a reason for them at this point.\n. Ok, this has been cherry picked into develop.  I had to make another patch to get things working with postgres (`double precision` needs to be used for `float64` values).  \n\nFeel free to pull develop locally and test.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. I've cherry picked this commit into develop.  It will go out in the next release.\n\nThanks.\n. Thanks for the contribution.  \n\nI'm thoughtful about adding this feature.  I wonder if we should consider adding support to gorp for this package:  https://github.com/lann/squirrel\n\nI haven't spent much time thinking about it, but one approach would be to provide a Select() variant that accepts a squirrel Sqlizer and a bind target.\n\nIf we really wanted to go crazy, we could think about using this project to replace the current ad hoc bind\\* caches, which relates to #124 \n\nAnyone else have opinions on this?  It's a somewhat big change.\n. Ok this is in develop now. Feel free to pull locally and test.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. This is in develop now.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. Interesting.  That's currently an unsupported case.  Feel free to propose a solution on this ticket. \n. SchemaName is simply a string that will be prefixed to tables.  Some databases don't use this.  What database are you using?\n\nIf you want to run your own CREATE TABLE command as a db migration, just call Exec() with a hand written CREATE TABLE command.  \n. Hi there. There's a few SelectOne() examples in the README.  Which one(s) are you referring to?\n\nthanks\n. Interesting. The tests have an example that is very similar:\n\nhttps://github.com/coopernurse/gorp/blob/develop/gorp_test.go#L1375\n\nI'm curious how your example differs, as that test cases is passing for me.\n. Yep, I test locally with Go 1.2.  The issue might be with transactions.  If you have time to write a test case that uses SelectOne in a transaction, please post it on this issue and I'll take a look.\n. This is in develop now.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. Hi there. Your PR adds two ColumnMap fields: `Autogenerate` and `UpdateOnInsert`.  It looks like your `Autogenerate` overlaps with the `selectonly` tag being considered for #59  Is that true?\n\n`UpdateOnInsert` seems very special purpose. I could imagine someone also wanting `UpdateOnUpdate` (e.g. for a timestamp field, or something set via trigger).  \n\nI'm wondering if there are other ways to express this.  Anyone else have opinions?\n. Good catch.  Now that I look at DbMap.Exec(), it appears to be doing the same thing.  I'll clean that up as part of this merge.\n. This is in develop now.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. See #175 for the full explanation, but this PR caused a regression when combined with tags in a particular way (see: AliasTransientField in gorp_test.go).\n\nI have modified `SelectAliasTest` to demonstrate a different way to achieve your goal.  If you want Select to return values that aren't in the underlying table, then I'd suggest using a 2nd type for this, similar to the `InvoicePersonView` example in the joins section of the README\n. @zhengjia excellent, thanks.  This change is in master now.\n. Hi there.  I'm not sure what sources you ran this from, but gofmt is clean in develop and master right now.  `gofmt -d *.go` reports no differences.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Good catch Rob.\n\nPresumably we don't want the semantics of SelectInt, SelectFloat, SelectStr, etc to change.  \n\nIf we want those functions to continue to return zero values, then we could:\n- modify selectVal() to return sql.ErrNoRows (fixes SelectOne())\n- modify the other selectVal() callers to ignore sql.ErrNoRows if err is non-nil\n\nAnother option is to return a 2nd value from selectVal() that indicates whether a row was found, but that doesn't seem necessary.  \n\nAny opinions?\n. I haven't merged it to master yet.  If folks think it looks good I'll promote it to master this week.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Good question.  @JonPulfer I think this is an interesting enhancement for cases where you want to deal with large data sets without buffering the whole resultset in RAM.\n\nWould you mind writing a test that demonstrates usage?  \n. Do we need a separate mutex per method on TableMap?  What if we just had a single mutex and used it on each of the relevant methods\n\nAny other opinions?\n. That makes sense, although the contention would likely still occur with 4 mutexes instead of one.\n\nIf we're worried about contention (and it's a valid concern I think) we may want to move the lock inside that the code that checks for empty string.  For example:\n\n``` go\nfunc (t *TableMap) bindInsert(elem reflect.Value) (bindInstance, error) {\n    plan := t.insertPlan\n    if plan.query == \"\" {\n\n```\n. That makes sense.  Thanks.\n. Thank you - I have a similar fix in develop that forces the string to lower case. Apologies I didn't merge this but I think our solutions are similar.\n\nMy change is pushed in develop now and will get merged into master in the next push (~1 week from now)\n. Apologies for the delay in reviewing this.  \n\nI'm probably being dense, but what's the use case here? I see the failing test, and I think your patch is safe, but the generated SQL will always no-op right? Here's the generated SQL from the test:\n\n```\nupdate \"single_column_table\" set \"SomeId\"=? where \"SomeId\"=?; \n   [A Unique Id String A Unique Id String]\n```\n\nJust to be clear - the goal is to avoid the invalid SQL statement generated before the patch.  Is that right? Or are there cases where this patch would actually result in a productive (i.e. state mutating) update on a table?\n\nthanks\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. I suspect this could be supported.  A first step would be to submit a PR with one or more failing tests that exercise this.  I'll merge it in and disable the test so CI still runs, but we can then track potential solutions against this test case.\n. Hi there.  Good stuff.  It's a huge PR though so it's hard for me to digest it.  Also, splitting up gorp.go, while probably long overdue, is something I'd want to do in a PR on its own since it makes it hard for me to merge any other pending PRs.\n\nSo I'm wondering if we can split this work up into smaller PRs:\n- #158 changes - I'm guessing this is a pretty small change and easy merge\n- #157 changes - Probably bigger - hard for me to tell given the large number of commits here\n- gorp.go split \n\nDo you have time/interest to work together on that?  Thanks again.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. In theory if you use SelectOne with a pointer to an existing value you could wire things bi-directionally.  This issue would depend on resolution of #164  Then you could do something like:\n\n``` go\n\ntype Group struct {\n    Id string \n    //  not sure how you're mapping this, I'm assuming it's wired manually\n    User User  `db:\"-\"`\n}\n\nfunc (me *Group) PostGet(ex SqlExecutor) error {\n  if me.User.Id == \"\" {\n     me.User.Group = *me\n     return ex.SelectOne(&me.User, \"select * from User where GroupId=?\", me.Id)\n  }\n  return nil\n}\n\ntype User struct {\n    Id string\n    Group Group  `db:\"-\"`\n}\n\nfunc (me *User) PostGet(ex SqlExecutor) error {\n  if me.Group.Id == \"\" {\n     me.Group.User = *me\n     return ex.SelectOne(&me.Group, \"select * from Group where UserId=?\", me.Id)\n  }\n  return nil\n}\n```\n\nWould that work?  Again, due to #164 that code won't work today, but once fixed it should work.\n. Hi there,\n\nThanks for the thoughtful post.  I don't have any great insight on a solution, but let's see if others have ideas.\n\nI think a concrete first incremental step would be to send a PR with a failing test case that we can check into the build (commented out) which we can use as a foil to judge potential solutions against.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Hi, do you have an example?  What DbMap methods are you seeing this on?\n. I think this is a bug.  `SelectOne` is calling `hookedselect` which calls `rawselect` which assumes a list return.  Line 1467 creates a new struct to bind into: `v := reflect.New(t)`\n\nAnd then line 1326 of `SelectOne` binds the returned element to the pointer passed to it: `dest.Elem().Set(src.Elem())`\n\nThat explains the behavior you're seeing -- your pointer now points to a new struct, so the transient fields are zeroed out.  And I would agree that behavior is unexpected.\n\nNot sure what the easiest fix is.  One possibility might be to define a new interface for appending results and pass an instance of that to `rawselect` instead of `i interface{}`.  This would let us clean up the `appendToSlice`, `intoStruct` flags.  `SelectOne` would provide an implementation that appends to the pointer passed in, and errors out if more than one row is found.\n\nSorry I don't have an easy solution for this, but this is a good ticket and one that could prompt some code re-work that will have some other hygenic benefits.\n. Yes, you can use a DbMap.Select across multiple goroutines.  There currently aren't mutexes on the operations that configure the mapping rules (e.g. ColumnMap.SetXXX(), TableMap.SetXXX()) so behavior is undefined if you call those methods concurrently from multiple goroutines. \n\nBut all the common SQL operations (Select, Exec, Insert/Update/Delete) are all safe to use from multiple goroutines.\n. I'm merging this now as part of the v1.6 release\n\nWhat Go SQL Server driver do you recommend / test with?  I'll add that to the README, as I have no easy way to test this stuff locally.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Thanks - I've added `QuerySuffix` and updated the README.  I also added lines to gorp_test.go to ensure that dialect structs match the interface so this will be compile error in the future.\n. I'm merging this now a part of the v1.6 release.\n\nWhat Go / Oracle driver do you suggest folks use?  I'll add that to the README\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Howdy.  This has been rebased onto develop. I added some docs for DbMap.TableFor, since it's now exported.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. v1.6 was merged to master today.\n. Hi.  Off the top of my head, you could do it in one query if you defined a type with the all the fields in the join, and then did the group by in Go. \n\nTotally untested code, and may not compile.. But hopefully gives you the idea.\n\n``` sql\ncreate table Car (\n    id    bigint primary key,\n   name   varchar(255)\n);\n\ncreate table Wheel (\n    id       bigint  primary key,\n    carId    bigint not null,\n    type     varchar(255)\n);\n```\n\n``` go\ntype Car struct {\n        Id     uint64\n        Name   string\n        Wheels []Wheel\n}\n\ntype Wheel struct {\n        Id       uint64\n        CarId    uint64\n        Type     string\n}\n\ntype CarWheel struct {\n        CarId      uint64\n        CarName    string\n        WheelId    uint64\n        WheelType  string\n}\n\nvar rows []CarWheel\n_, err := dbmap.Select(&rows, \n    `select c.id CarId, c.name CarName, w.Id WheelId, w.Type WheelType,\n    from Car c, Wheel w  \n    where c.id = w.carId\n    order by c.id`)\nif err != nil {\n  // blow up\n}\n\n// group rows by carId - maybe factor to a function\nvar cars []*Car\nvar current *Car\nfor _, r := range rows {\n    wheel := Wheel{Id: r.WheelId, CarId: r.CarId, Type: r.WheelType}\n    if current == nil || r.CarId != current.Id {\n        current = &Car{Id: r.CarId, Name: r.CarName, Wheels: []Wheel{}}\n        cars = append(cars, current)\n    }\n    current.Wheels = append(current.Wheels, wheel)\n}\n```\n. Re naming: \"Put\" is another option.  \"Upsert\" doesn't bother me that much -- I realize the MongoDb folks use that name.\n\nMy main comment on this implementation is that it relies on mysql-specific behavior.  In theory this could be done in a generic manner using a transaction.  Has anyone looked at how other ORMs implement this type of call?\n. How do other implementations decide to do the insert vs update?  Do they look for an existing row by PK first?  If so, then this smells like something that could be done using the existing gorp Get/Insert/Update operations inside a transaction.  Could it be that simple?\n. Interesting.  Can you add a test case that reproduces this?  \n\ntravis-ci is running the tests against Go tip and 1.1, so I assume tip should reproduce this behavior if we get a test case in.\n. Thanks - I have reproduced this in test. I'm glad you supplied a test case above, as it looks like this happens when a struct field is aliased to a column name which matches another field in the struct that is marked transient.\n\nI'll get a fix for this later today and push it to master.\n. The plot thickens.  You're correct that #146 introduced this behavior change.  I need to study that PR more closely before I can fix this issue.  My first attempt broke `TestSelectAlias` and I'm trying to figure out if there's a simple way to fix #175 and keep #146.\n. Ok I've reverted #146 but modified the `TestSelectAlias` included in that PR to demonstrate a way to accomplish the same goal.\n\nI also added test cases for your case.\n\nPlease take a look - if you can build/test against my develop branch that would be helpful.  Otherwise I'll plan to cherry pick this commit into master later today or tomorrow and tag as v1.6.1\n. Ok this is in master now\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. The reason the 2nd `Insert` fails is that you created a new DbMap and then didn't add call `AddTableWithName`.  \n\nI'm a little confused by this example.  Is there a reason you're re-opening the connection and recreating the DbMap? I assume this would work:\n\n``` go\n// initialize connection and DbMap\ndb, err := sql.Open(\"sqlite3\", \"./cloud.db\")\ndbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}    \ndefer dbmap.Db.Close()\ndbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")\n\n// first insert\nerr = dbmap.Insert(&user{})\nif err != nil {\n   log.Fatal(err)\n}\n\n// second insert\nerr = dbmap.Insert(&user{})\nif err != nil {\n   log.Fatal(err)\n}\n```\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. All Postgres support was community contributed, so I don't have a strong opinion on the desired semantics.  This is the line that's causing you trouble:\n\nhttps://github.com/coopernurse/gorp/blob/develop/dialect.go#L270\n\nIf I'm reading the Postgres docs correctly, quoting avoids reserved word conflicts, but also makes the string literal case sensitive.  I can see times when either use case (case insensitivity or avoiding reserved word issues) is desired.\n\nBut I'll defer to Postgres users on how they want this to work.  The dialect could allow the caller to specify which behavior they want.  But I want some other Postgres users to weigh in.\n. Hmm.. no reason I can think of.  Please send a PR if you have time to make those changes.\n. Awesome, thanks for catching this!\n. Could you post some example code?  If you're using bind variables then you shouldn't have a problem.\n. ok that should be all set.\n. Hi there,\n\nThanks for prodding me to do this.  I've been procrastinating.  I'll push an update to the README asking for folks to volunteer.  There may be an active fork that we can simply begin pointing folks at.\n. @GeertJohan has kindly created an organization (go-gorp) so I'm considering moving this repo there.  \n\nAny other opinions on this before I do that?  Seems like the right solution.\n. Hi there,\n\nare you using mymysql as your exp/sql driver?  If so, there's a patch I submitted to that project that is required to map bool values.  This patch also pools prepared statements, which is important to avoid running out of prepared statement handles in mysql.\n\nhttps://github.com/ziutek/mymysql/pull/5\n\nalso, there are probably some other issues you'll run into with gorp if you're using the weekly.  I have a pending patch into the exp/sql project that is needed to define all the Nullable types:\n\nhttp://codereview.appspot.com/5534048/\n. Oh, by the way, in my local environment, your test above passes.  So I think the problem is probably due to one of the two issues above (probably the bool marshalling).  Here's my test code:\n\n```\n// this passes for me\nfunc TestPersistentUser(t *testing.T) {\n    dbmap := &DbMap{Db: connect(), Dialect: dialect}\n    dbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n    table := dbmap.AddTable(PersistentUser{}).SetKeys(false, \"Key\")\n    table.ColMap(\"Key\").Rename(\"mykey\")\n    err := dbmap.CreateTables()\n    if err != nil {\n        panic(err)\n    }\n    pu := &PersistentUser{43,\"33r\",false}\n    err = dbmap.Insert(pu)\n    if err!=nil {\n        panic(err)\n    }\n}  \n```\n. the sql.Open(\"\", \"\") parameters are dependent on what exp/sql driver you use.  that line isn't a gorp call.  I can certainly update the example in the docs though.\n\nmultithreading isn't something I've tested, but based on my read of the exp/sql source code, connections to the database are acquired each time a query is run, and then released (exp/sql pools connections transparently).  consequently you _should_ be able to share a *DbMap across many goroutines.\n\nPlease try it out and let me know if you run into issues.  I would also graciously accept a unit test for this if you'd like to contribute one. \n. Interesting.  I would expect the non-threadsafe driver to still work if you have a single *DbMap shared across goroutines.  exp/sql will lock connections when in use, which should prevent concurrent use of the same connection.  \n\nI'm going to work on gorp today.  I'll try writing a test that spawns multiple goroutines and see if they fail with the non-thread safe mysql driver.  If they do I'll see if I can figure out the cause, as I don't think exp/sql requires thread safe drivers.\n. Hmm., well it's been 2 years and I never wrote the above test.  No one else has chimed in on this ticket so I'm guessing it's not causing trouble for folks at this point.\n. Hi,\n\nCan you send me the exact \"create table\" command that gorp generated?  Turn on trace logging to trap all the sql statements:\n\ndbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n\nthanks\n\n-- James\n. Ah, \"key\" is a reserved word in mysql.  Try using the Rename() method to alias that property to a different column name.\n. Hi there!\n\nI haven't thought about slices yet.   Postgres supports array columns it looks like.  Is that a SQL standard, or a Postgres extension?  I'm curious of how to handle it in the general case.  Open to suggestions on this.\n\ncheers\n\n-- James\n. Hi there. I'm not too familiar with how these Postgresql. ARRAY types work.  SQLite and MySQL don't support ARRAYs as far as I know, so this feature would only be available for Postgresql.\n\nA first step that would help would be to write a .go file (perhaps as a gist) that just does a simple INSERT / UPDATE / SELECT sequence against a table that has an ARRAY field using the pql driver directly (i.e. no gorp).  That example would help me understand how this data type works and would prove that the go postgres driver supports them.\n\nOnce we have that example I suspect we could figure out how to bolt it into the SQL generator in gorp.\n\nWhat do you think?\n. Sorry I've been quiet on this ticket.  @adharris, thanks for the example.  I just pushed a mechanism that allows you to write custom type converters for struct fields.  I wonder if this would be a good way to handle slices.\n\nIf anyone has a moment, take a look at the `gorp_test.go` `testTypeConverter` type, and related `TestTypeConversionExample()` \n. Not to my knowledge.\n. Hi there,\n\nThe issue is that sql.Open() is failing, so the db value is nil.  Here's a few things to fix in your code:\n\n1) You need to import a database driver.  for example, change the import to:\n\n```\nimport (\n    \"database/sql\"\n    \"github.com/coopernurse/gorp\" \n    _ \"github.com/ziutek/mymysql/godrv\"\n)\n```\n\n2) You should check the error return values from various calls.  Your code was ignoring the err value from sql.Open(), so you inadvertently passed the nil db value to the gorp.DbMap.\n\n3) If you're using the mymysql driver, the sql.Open() call should look like this:\n\n```\ndb, err := sql.Open(\"mymysql\", \"dbname/myuser/mypassword\")\nif err != nil {\npanic(err)\n}\n```\n\n4) Not a clear bug, but perhaps a misunderstanding: If you define Id as a primary key, gorp will ignore the value on insert.  So the 3 you're passing in will be ignored. So it may be more clear to write:\n\n```\np1 := &Sexo{Nombre:\"otro\"}\n```\n\nor\n\n```\np1 := &Sexo{0, \"otro\"}\n```\n\n---\n\nMy working version of your program looks like this:\n\n``` go\npackage main\n\nimport (\n    \"database/sql\"\n    \"github.com/coopernurse/gorp\"\n    _ \"github.com/ziutek/mymysql/godrv\"\n)\n\nfunc main() {\n    probarGORP()\n}\n\nfunc probarGORP() {\n    // construct a gorp DbMap\n    //dbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n    db, err := sql.Open(\"mymysql\", \"pds/pds/123456\")\n    if err != nil {\n        panic(err)\n    }\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{\"InnoDB\", \"UTF8\"}}\n    table := dbmap.AddTableWithName(Sexo{}, \"Sexo\").SetKeys(true, \"Id\")\n    table.ColMap(\"Id\").Rename(\"id\")\n    table.ColMap(\"Nombre\").Rename(\"nombre\")\n    p1 := &Sexo{Nombre:\"otro\"}\n\n    err = dbmap.Insert(p1) // Version is now 1\n    if err != nil {\n        panic(err)\n    }\n}\n\ntype Sexo struct {\n    Id     int64\n    Nombre string\n}\n```\n. Hi there,\n\nSee: `gorp_test.go` for an example.  The Transaction type implements the SqlExecutor interface, so you can call all the same methods on it that you could outside of a transaction context (e.g. Insert(), Update(), Delete()).  They don't take effect until you call: `trans.Commit()`\n\n```\ntrans, err := dbmap.Begin()\nif err != nil {\n    panic(err)\n}\ntrans.Insert(inv1, inv2)\nerr = trans.Commit()\nif err != nil {\n    panic(err)\n}\n```\n. Hi there,\n\nIt doesn't support embedding yet, but it's a worthy enhancement.  I'll keep this ticket open.  \n\nthanks.\n. Yep, this was merged. Closing this ticket.\n. Thanks for the patch.  I also modified Get() to use this mechanism, and cleaned up some of the column->Field mapping in rawselect.  If you have a moment, please pull the latest from master and verify that it looks good on your side.\n\ncheers\n. Hi there.  Interesting idea.  I agree that many shops standardize on naming conventions like this, but I think it would be hard for us to make everyone happy.\n\nWhat if we define an interface that lets users programmatically hook the mapping sequence.\n\nSomething like:\n\n``` go\n    // not sold on this name\n    type Mapper interface {\n        // returns table name for struct i. if no change desired, implementation should return mappedName\n        TableName(i interface{}, mappedName string) string\n\n        // returns customized ColumnMap for a field\n        ColumnMap(tableName string, field reflect.Value, column ColumnMap) ColumnMap\n    }\n\n    // modify DbMap to optionally hold a Mapper\n    type DbMap struct {\n        // new field\n        mapper Mapper\n    }\n\n    // Modify DbMap.AddTableWithName() to call Mapper methods\n```\n\nWe could also provide an exported convenience function for some common things.  Like:\n\n``` go\n    // turns:  MyTable into: my_table\n    func CamelCaseToUnderscore(s string) string { }\n```\n\nAnd that would enable you to satisfy your original desire by doing something like:\n\n``` go\n    type CamelCaseMapper struct { }\n\n    func (me CamelCaseMapper) TableName(i interface{}, mappedName) {\n        return gorp.CamelCaseToUnderscore(mappedName)\n    }\n\n    func (me CamelCaseMapper) ColumnMap(tableName string, field reflect.Value, column gorp.ColumnMap) gorp.ColumnMap {\n        column.ColumnName = gorp.CamelCaseToUnderscore(column.ColumnName)\n        return column\n    }\n\n    dbmap := &DbMap{Db: db, Dialect: dialect, Mapper: mapper}\n    dbmap.AddTable(MyStruct{})\n```\n\nToo complicated?\n. Yeah, good idea.  My slight preference is for a 2nd return value.  true=include column, false=ignore.  and perhaps the interface methods should be verbs.  how about:\n\n``` go\n    type Mapper interface {\n        // returns table name for struct i. if no change desired, implementation should return mappedName\n        MapTableName(i interface{}, mappedName string) string\n\n        // returns customized ColumnMap for a field\n        // bool return value species whether to include this field in the table mapping (true==yes, false==no, skip field)\n        MapColumn(tableName string, field reflect.Value, column ColumnMap) (ColumnMap, bool)\n    }\n```\n. It's a good idea.  I'm curious if this is mostly an issue for the driver implementations though.  For example, mymysql appears to support Scan() into time.Time:\n\nhttps://github.com/ziutek/mymysql/blob/master/godrv/driver.go\n\nDo you see any place where gorp would need to handle this type specially?  It seems we could pass it through like all other types and let the driver Scan into it.  Perhaps the sqlite driver doesn't support it and we should fork/patch that?\n. I think that change makes sense.  Honestly I'm not sure gorp has explicitly defined behavior for time.Time types.  When I first wrote it, Go1 wasn't out yet, and time.Time didn't exist.\n\nPerhaps we should just start a \"breaking changes\" section of the README and make it clear when we add something like this.  Every once in a while we'll need to break current behavior for the sake of progress/sanity.\n. I tried modifying the Postgres and Mysql dialects today and wrote a trivial test for it.  This test passes for postgres, but fails for mysql.  It appears the timezone gets set to the local timezone instead of UTC.  Anyone have an opinion on why this would occur? \n\nI don't want to commit this patch until I understand why a trivial insert/select isn't symmetric.\n\n``` go\nfunc TestWithTime(t *testing.T) {\n    dbmap := initDbMap()\n    defer dbmap.DropTables()\n\n    t1, err := time.Parse(\"2006-01-02 15:04\", \"2011-01-19 22:15\")\n    if err != nil {\n        panic(err)\n    }\n\n    w1 := WithTime{-1, t1, \"hi\"}\n    _insert(dbmap, &w1)\n\n    obj := _get(dbmap, WithTime{}, w1.Id)\n    w2 := obj.(*WithTime)\n    if w1.Date.UnixNano() != w2.Date.UnixNano() {\n        t.Errorf(\"%v != %v\", w1, w2)\n    }\n}\n```\n\nOutput from mysql:\n\n```\n--- FAIL: TestWithTime (0.05 seconds)\ngorp_test.go:875:   {1 2011-01-19 22:15:00 +0000 UTC hi} != &{1 2011-01-19 22:15:00 -0800 PST hi}\nFAIL\nexit status 1\n```\n. To clarify, for Mysql I mapped `time.Time` to `datetime`.  The create table command was:\n\n```\ngorptest: 14:46:59.983278 create table `time_test` (`Id` bigint not null primary key auto_increment, `Date` datetime, `Name` varchar(255))  engine=InnoDB charset=UTF8; [[]]\n```\n. merged to master and released in v1.1\n. Sounds useful.  Are we looking to do something like query by example?\n\nhttp://en.wikipedia.org/wiki/Query_by_Example\n. I'm thoughtful about this.  Is your need motivated only be queries that return single columns (and potentially a single row)?\n\nFor the count example I could imagine adding something like:\n\n   var count int64\n   err := dbmap.SelectRow(&count, \"select count(*) from foo where blah=?\", blah)\n\nSingle column queries could be handled by Query if we allow primitive types to be passed in.\n\n```\n// rows is []string\nrows, err := dbmap.Select(\"\", \"select email from people where id > 300\")\n```\n\nthoughts?\n. Hi there.  I have just pushed a change that adds a few new functions:  SelectInt(), SelectNullInt(), SelectStr(), SelectNullStr()\n\nThis allows you to run \"select count(*)\" style queries without any custom scanning.  e.g.:\n\n```\ncount, err := dbmap.SelectInt(\"select count(*) from foo where bar > ?\", barVal)\n```\n\nLet me know how that looks, and if it satisfies your use case we can close out this ticket.\n. This should be fixed now in master.  \"go test\" passes for me local against Postgresql\n. thanks for the fix!\n. This should be fixed now in master.\n. Thanks for reporting this, and for the very complete analysis.  I wonder if this could be fixed by replacing the Exec/LastInsertId calls in insert (lines 1350-1361) with an ExecAndReturnId call that combined the two, using the same db handle.\n\nOr is the issue more complex?\n. I'm also curious if you've tried using a gorp transaction around the code experiencing this issue.  Looking a bit more closely it appears that gorp would probably need to start a transaction on the *sql.Db handle to do this insert/select atomically.  I don't see a way to re-use a statement handle using Go's sql package without a transaction, but I could be missing it. \n. Great.  I'll take a pass at adding `ExecAndFetchLastInsertId` to the SqlExecutor interface.  The Transaction implementation can simply do what the current code does.  The non-transactional impl will start a transaction and perform the two operations in a transactional context.\n\nI wonder if this is worth elevating to the Go maintainers.  The connection pool is actually implemented in the Go sql package, so the behavior you're seeing would occur with any code that simply does an Exec() and LastInsertId() call in sequence using the standard Go sql API.  Unless I'm missing something gorp isn't doing anything exotic here, and this bug could be considered a design flaw in the Go sql package.  Ideally the sql package would expose an atomic operation for the insert and get last insert id pair.\n. derp.  It's clear I haven't been looking at gorp in a while.  now that I read dialect.go, I see that this isn't Go's fault.\n\nDo you know if the postgres go driver has added support for res.LastInsertId() ?   Perhaps that's not possible given how Postgres deals with sequences.\n\nAlternate approach: rework the Dialect.LastInsertId() call to be the atomic operation.  That would allow vendor specific approaches, such as the `INSERT .. RETURNING` approach.\n. Ok, I just pushed changes that rework the LastInsertId mechanism.  I went with the `INSERT .. RETURNING` approach as you suggested.  \n\nI'll leave this ticket open for a bit.  If you have a moment please try using master, or merging the changes to your fork and see if you like what you see.\n. No news is good news I think.  Closing this out for now.  Re-open if there's an issue with the changes I made a few months ago.\n. Apologies I haven't commented.  I like the idea, but I wonder if we should use the same \"db\" tag for all of these attributes, rather than introducing another tag.  For example:\n\n```\ntype Product struct {\n    Id int64 db:\"product_id,pk,autoincrement\"\n    Price int64 db:\"unit_price\"\n    IgnoreMe string db:\"-\"\n}\n```\n\nThat would follow the convention used in the `encoding/json` package (and probably others).\n\nThoughts?\n. I should clarify: the first item in the comma separated list would always be the column name, similar to the way the json tag works.\n. Hi,\n\nYou're passing the MySQL params into the SqliteDialect{}, try this:\n\n``` go\ndbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}\n```\n. It sounds like a useful addition, but I'm wondering about the naming.  If we're going to just use a boolean then I'd prefer two functions:\n\n``` go\n// same behavior as current implementation\nfunc (m *DbMap) CreateTables() error { }\n\n// adds the \"if not exists\" clause\nfunc (m *DbMap) CreateTablesIfNotExists() error\n```\n\nFeel free to update your pull request, or leave a comment and I can implement this change.  \n\nAdding a test for this would be great too.\n\ncheers\n. Ok, CreateTablesIfNotExists() has been added to DbMap and pushed to master.\n. Good idea. \n. Ok, this is fixed in master.  Insert() will return an error in this case.  The autoincr bindable types are: Int, Int16, Int32, Int64\n. The `ToSqlType()` command in the default dialects is primarily provided as an example.  You can easily write your own dialect that implements `ToSqlType()` with any rules you like.\n\nIf you'd like to extend the default dialect, one option is to add an optional field to PostgresDialect that specifies the cutoff for maxsize that would dictate whether to use a text field.  But this is a slippery slope that may further reinforce the idea that the provided dialect implementations are intended to satisfy all use cases.\n. Could you elaborate on your question?  Or provide an example of what you're trying to do?\n. That completely makes sense.  I would happily merge a pull request with that  :-)\n\nIt would be ideal to figure out how to implement this without breaking backwards compatibility. If Select() is passed a pointer to a slice, then automatically populate the slice, otherwise behave as it currently does.  Would that work?\n. Excellent.  I'll review this code in a couple of days.  Thanks guys.\n. Hey guys,\n\n@robig yes, if you have some time to take a stab at making that backwards compatible, that'd be excellent.  a test or two would also be nice.\n\nthanks again\n. I was able to compile cleanly from gorp/master using Go 1.1 on windows.\n\nIs anyone else able to repro these build failures?\n. Ok. I'm going to close this out for now unless we get more details.\n. #41 has been merged in, so I'm closing this ticket.\n. Ok, CreateTablesIfNotExists() has been added to DbMap\n. Could you reproduce this bug in a test?  I just tried this and it worked on all 3 supported databases:\n\n``` go\nfunc TestAutoIncrMultipleRows(t *testing.T) {\n    inv1 := &Invoice{0, 100, 200, \"my memo 1\", 0, false}\n    inv2 := &Invoice{0, 100, 200, \"my memo 2\", 0, false}\n    inv3 := &Invoice{0, 100, 200, \"my memo 3\", 0, false}\n\n    dbmap := initDbMap()\n    defer dbmap.DropTables()\n\n    insert(dbmap, inv1, inv2, inv3)\n\n    if inv1.Id != 1 {\n        t.Errorf(\"inv1.Id is 0\")\n    }\n    if inv2.Id != 2 {\n        t.Errorf(\"inv2.Id is 0\")\n    }\n    if inv3.Id != 3 {\n        t.Errorf(\"inv3.Id is 0\")\n    }\n}\n```\n. Oops!  sorry I completely misunderstood.   Yes, I can repro this issue in test.  I'll try merging in your patch.\n. Wow, thanks for the quick turnaround.  I don't think I'll have time to review this tonight, but hopefully in the next day or two.\n. Hey guys.  I'm merging this stuff into master now.  @sqs I have integrated your patch+test from 6dfc2ee.\n\nI think the only outstanding item is the error message: \"gorp: Cannot SELECT into non-struct type: []*MyType\"\n\nI'm inclined to just get these commits into master, and open a separate issue for that.  Just so we don't keep this work sequestered too long.\n\nthanks guys for all your work on this!  great addition.\n\n-- James\n. Thanks, this is in master now!\n. Great stuff.  I'll work on merging this over the weekend.  But first I want to get some docs in place for the slice scanning work that was just merged (#40).\n\ncheers\n. ok, I started working on this.  I've got it merged locally and the tests are passing on all 3 databases.  nice work.\n\nI want to read the code a bit before I push it, but so far it looks great.\n. Interesting case.  What's the expected behavior here?  Perhaps detected that we don't have any non-PK columns and simply return 0, nil from Update()?\n. I think it's a good ticket.  gorp shouldn't blow up in this case.  I'll take a stab at reproducing this in a test today.\n. Cool, here's my first take at a patch.  I renamed `x` to `bindCount` for clarity.  If there are no bound columns in the SET clause, then `bindUpdate()` doesn't compute the rest of the query. Update() will skip the SQL operation entirely when bindArgs is empty.\n\nThis still allows the pre/post update hooks to run, and provides driver independent behavior.  I noticed that if we execute a no-op sql statement in this case.e.g.: `update foo set id=id where id=?` then MySQL reports 0 rows updated, and Postgresql reports 1 row updated.\n\n``` diff\ndiff --git a/gorp.go b/gorp.go\nindex 7371ee7..c3fcd46 100644\n--- a/gorp.go\n+++ b/gorp.go\n@@ -315,17 +315,19 @@ func (t *TableMap) bindUpdate(elem reflect.Value) (bindInstance, error) {\n\n                s := bytes.Buffer{}\n                s.WriteString(fmt.Sprintf(\"update %s set \", t.dbmap.Dialect.QuoteField(t.TableName)))\n-               x := 0\n+\n+               bindCount := 0\n\n                for y := range t.columns {\n                        col := t.columns[y]\n                        if !col.isPK && !col.Transient {\n-                               if x > 0 {\n+                               if bindCount > 0 {\n                                        s.WriteString(\", \")\n                                }\n+\n                                s.WriteString(t.dbmap.Dialect.QuoteField(col.ColumnName))\n                                s.WriteString(\"=\")\n-                               s.WriteString(t.dbmap.Dialect.BindVar(x))\n+                               s.WriteString(t.dbmap.Dialect.BindVar(bindCount))\n\n                                if col == t.version {\n                                        plan.versField = col.fieldName\n@@ -333,10 +335,11 @@ func (t *TableMap) bindUpdate(elem reflect.Value) (bindInstance, error) {\n                                } else {\n                                        plan.argFields = append(plan.argFields, col.fieldName)\n                                }\n-                               x++\n+                               bindCount++\n                        }\n                }\n\n+               if bindCount > 0 {\n                        s.WriteString(\" where \")\n                        for y := range t.keys {\n                                col := t.keys[y]\n@@ -345,20 +348,21 @@ func (t *TableMap) bindUpdate(elem reflect.Value) (bindInstance, error) {\n                                }\n                                s.WriteString(t.dbmap.Dialect.QuoteField(col.ColumnName))\n                                s.WriteString(\"=\")\n-                       s.WriteString(t.dbmap.Dialect.BindVar(x))\n+                               s.WriteString(t.dbmap.Dialect.BindVar(bindCount))\n\n                                plan.argFields = append(plan.argFields, col.fieldName)\n                                plan.keyFields = append(plan.keyFields, col.fieldName)\n-                       x++\n+                               bindCount++\n                        }\n                        if plan.versField != \"\" {\n                                s.WriteString(\" and \")\n                                s.WriteString(t.dbmap.Dialect.QuoteField(t.version.ColumnName))\n                                s.WriteString(\"=\")\n-                       s.WriteString(t.dbmap.Dialect.BindVar(x))\n+                               s.WriteString(t.dbmap.Dialect.BindVar(bindCount))\n                                plan.argFields = append(plan.argFields, plan.versField)\n                        }\n                        s.WriteString(\";\")\n+               }\n\n                plan.query = s.String()\n                t.updatePlan = plan\n@@ -1384,6 +1388,7 @@ func update(m *DbMap, exec SqlExecutor, list ...interface{}) (int64, error) {\n                        return -1, err\n                }\n\n+               if len(bi.args) > 0 {\n                        res, err := exec.Exec(bi.query, bi.args...)\n                        if err != nil {\n                                return -1, err\n@@ -1404,6 +1409,7 @@ func update(m *DbMap, exec SqlExecutor, list ...interface{}) (int64, error) {\n                        }\n\n                        count += rows\n+               }\n\n                err = runHook(\"PostUpdate\", eptr, hookarg)\n                if err != nil {\n```\n. This is fixed now and tested across the 3 supported databases.\n. This was fixed in: fce0ecf6b40d439c9e22213423f6125d2126d151\n. ok, this is in master now.  README is also cleaned up and restructured for better readability.\n. wow, good catch. I just pushed this patch to master.  I don't see a downside.\n. Implemented in master.\n. Makes sense to me.  I'l update the doc comment to indicate that we'll panic in this case.\n. Hi there,\n\n`SelectInt` is a bit of a hack.  One option would be to add a new method: `SelectInto()` that accepts a pointer to scan the result into.  This would be a generalization of the enhancement in #40.  \n\n`SelectInto` would be added to `SqlExecutor` so you could use it with transactions.  Example code might look like:\n\n``` go\nfunc (u *User) NumRecords(s gorp.SqlExecutor) int {\n    var count int64\n    err := s.SelectInto(&count, \"SELECT COUNT(*) as Count FROM Queue WHERE User_Id = $1\", u.Id)\n    // handle err\n    return count\n}\n```\n\nMy guess is we've got all the pieces for this in place.  It will just be a simple matter of moving them around.  :-)\n. @robfig good point, I agree that SelectInt fixes this issue.  If someone disagrees, please re-open, but you should be able to write this now:\n\n``` go\nfunc (u *User) NumRecords(s gorp.SqlExecutor) int {\n    count, err := s.SelectInt(\"SELECT COUNT(*) as Count FROM Queue WHERE User_Id = $1\", u.Id)\n    // handle err\n    return count\n}\n```\n. ah, good observation.  The placeholder variable (\"?\" vs \"$1\") is database dependent (gorp doesn't do that substitution).  \n\nat a minimum, the docs should reflect this.  the examples with ? would work for mysql or sqlite, but not postgres, as you noted.\n. I'm going to close this out -- the README now has a \"known issues\" section that clarifies this.  If you need fully portable queries, you can use the keyword \":foo\" placeholder syntax + maps/structs instead of positional placeholders.\n. Have you tried using `sql.NullInt64` for the nullable values?  For example:\n\n``` go\ntype MyModel struct {\n    Id             int    `db:\"id\"`\n    Name           string `db:\"name\"`\n    ProjectId      sql.NullInt64    `db:\"project_id\"`    // Allows NULL\n    CustomerId     sql.NullInt64    `db:\"customer_id\"`    // Allows NULL\n}\n```\n\ngorp _should_ do the right thing with these (we have a basic test for this case at least).\n. Interesting. So that error is coming from gorp.  search for that string in gorp's dialect.go and you'll see what we're trying to do.\n\nIs `activities.id` definitely defined as a serial or bigserial column?  If not, that would explain the error.  If so, then I'm at a bit of a loss at the moment and would probably have to reproduce it in test and fiddle with it to narrow it down.\n. Could you turn tracing on (see \"SQL Logging\" in the README) and post the generated SQL for those two examples?\n\nI don't see an obvious reason to explain this.\n. Thanks for the thoughtful post.\n\nI like the ideas for tags.  My only initial comment is that we'd have to carefully define the enum of types that are supported.\n\nRe: Codec: there's actually a (poorly documented) solution for this in master.  See this interface:\n\n``` go\ntype TypeConverter interface {\n    // ToDb converts val to another type. Called before INSERT/UPDATE operations\n    ToDb(val interface{}) (interface{}, error)\n\n    // FromDb returns a CustomScanner appropriate for this type. This will be used\n    // to hold values returned from SELECT queries.\n    //\n    // In particular the CustomScanner returned should implement a Binder\n    // function appropriate for the Go type you wish to convert the db value to\n    //\n    // If bool==false, then no custom scanner will be used for this field.\n    FromDb(target interface{}) (CustomScanner, bool)\n}\n```\n\nAnd this example in `gorp_test.go`\n\n``` go\nfunc TestTypeConversionExample(t *testing.T) {\n    dbmap := initDbMap()\n    defer dbmap.DropTables()\n\n    p := Person{FName: \"Bob\", LName: \"Smith\"}\n    tc := &TypeConversionExample{-1, p, CustomStringType(\"hi\")}\n    _insert(dbmap, tc)\n\n    expected := &TypeConversionExample{1, p, CustomStringType(\"hi\")}\n    tc2 := _get(dbmap, TypeConversionExample{}, tc.Id).(*TypeConversionExample)\n    if !reflect.DeepEqual(expected, tc2) {\n        t.Errorf(\"tc2 %v != %v\", expected, tc2)\n    }\n\n    tc2.Name = CustomStringType(\"hi2\")\n    tc2.PersonJSON = Person{FName: \"Jane\", LName: \"Doe\"}\n    _update(dbmap, tc2)\n\n    expected = &TypeConversionExample{1, tc2.PersonJSON, CustomStringType(\"hi2\")}\n    tc3 := _get(dbmap, TypeConversionExample{}, tc.Id).(*TypeConversionExample)\n    if !reflect.DeepEqual(expected, tc3) {\n        t.Errorf(\"tc3 %v != %v\", expected, tc3)\n    }\n\n    if _del(dbmap, tc) != 1 {\n        t.Errorf(\"Did not delete row with Id: %d\", tc.Id)\n    }\n\n}\n```\n. You raise some good points. It seems the two approaches aren't mutually exclusive.   We could check if the type implements TypeCodec, and if so, use that for conversion, else delegate to the TypeConverter if one is registered.\n\nIs that what you have in mind?\n. I think we should consider a name other than transient.  Today setting transient=true on a field will exclude it from all generated INSERT/UPDATE/SELECT queries.\n\nIt sounds like the goal here is to tell gorp to only use this column for SELECT statements.  Is that right?\n\nIf so, perhaps something like `readonly` or `selectonly` would be more descriptive?\n. This is looking good.  Could you please update the README to include an example of usage?\n. Sorry I never commented on this @robfig .  I like your latter examples (I don't have a strong opinion on using `...` vs `{}`).  \n\nI would gladly merge a PR that implemented this.\n\nNote that I'm starting to use a develop branch, so if you implement this please do it on a feature branch, and I'll merge it to develop. \n\nthanks!\n. Agreed, I'll remove it\n. Done.\n. I agree with @purohit - you'll need to export the fields.  Here's a SO thread about this.  The reflect package won't let gorp see your non-exported fields:\n\nhttp://stackoverflow.com/questions/11126793/golang-json-and-dealing-with-unexported-fields\n. Excellent.  Glad you got it working!\n. I've created a \"develop\" branch.  I'm going to merge into that and test locally.  If tests pass I'll push this branch along with a set of other pending pull requests so we can test all of them together before merging to master.\n. postgres and sqlite are passing now.  mysql still fails, due to tz issues that @seehuhn notes.\n\nI'm ok with merging this, but I'm going to modify the gorp README to warn users about using time.Time in their mapped structs, particularly on MySQL.\n\nSince the test fails I'm also going to disable the test for now (change it to lowercase so go test doesn't run it).  I'll file another issue to remind us to add it back in when https://github.com/ziutek/mymysql/pull/77  lands.\n. Good idea. Thanks.\n. merged to master and released.\n. Thanks for the contributions.\n\nRe: b7d1729:  I think it's an interesting idea, but I want to think about it more.  It changes existing behavior, which may surprise some users, and it impacts portability.  Also, since Dialect is an interface, it's pretty easy to just make your own with this (or any other) behavior.  If you feel strongly about it, please open a separate issue for this so we can get opinions from other folks watching this repo.\n\nRe d9421a6: Looks good.  I'm going to merge this into the develop branch, which is where I'm starting to stage changes in batch before folding into master.\n\nRe 76d12f3: Good ideas here, but there's a lot of activity in this general area (2-3 other PRs).  So I'm going to hold off on this too.  I'm going to create a master ticket for the \"grand tag enhancement\" feature so we can hash out the best way to deal with this and get feedback from everyone.\n\ncheers\n. I'm going to close this out, but I opened #79 to track the d9421a6 commit\n\nthanks\n. Hi,\n\nsql.Result has two methods:\n\n``` go\ntype Result interface {\n    LastInsertId() (int64, error)\n    RowsAffected() (int64, error)\n}\n```\n\n`LastInsertId()` is automatically bound to your struct if you specify an autoIncr key via TableMap.SetKeys().  RowsAffected() isn't currently mapped, but I'm curious when that would be useful.\n\nWhat's your use case where you need the raw sql.Result?\n. Thanks, this has been merged into the \"develop\" branch.  I'm now using that to batch up sets of changes before merging into master.\n. One issue I see here is that if you mutate `isAutoIncr` then the `TableMap.insertPlan` is potentially invalid and needs to be regenerated.\n\nSo I think we'd need to expose this via a method, which can regenerate that SQL statement.\n. Hi there,\n\nThe `database/sql` package provides some \"null\" types that you can use for this purpose. For example:\n\n``` go\ntype Person struct {\n    Id      int64\n    Name sql.NullString\n    Age sql.NullInt64\n}\n```\n\nName and Age can both be null in the db, and will scan properly.  You would get the value via:   person.Name.String.   \n. Hi Rob,\n\nthis has been merged into the \"develop\" branch and pushed.  I'm going to mark #70 as a v1.1 item (v1.1 will reflect the merge from develop to master) and close this PR out now.\n\nthanks!\n. merged to master and released in v1.1\n. hey Rob,\n\nThis is pretty sweet.  Does it work on the other methods that accept raw SQL selects (e.g. \"SelectInt\")?  Or just Select()?\n\nI'll have more time to review this on Friday.  As I mentioned on twitter, I'm rolling all these PRs into the develop branch now, testing there, and then will merge together into master and tag as a release.\n. Great stuff.  Tests pass on all 3 dbs.  I think this may also address portability concerns (see: #53), as folks can write queries with `where foo = :foo` instead of `where foo = ?` and have it still work on postgresql.\n. btw, this was merged into develop, just for the record.\n. I'm not sure if I understand the question, but you could simply change the dbmap.Db reference to point at a different database connection.  Have you tried that?\n. Hi there,\n\nThis was merged into develop and will appear in master in the next release (probably today).\n. Hi Otto,\n\nThanks for the report.  I'll try to write a test that replicates your query.  I think your code looks fine and this is something gorp should handle correctly.\n. Hi there,\n\nThis test passes for me against PostgreSql 9.1.4 on my mac.  It also passes on sqlite.\n\nDoes this pass for you?  If not, what driver are you using? I'm using `github.com/lib/pq`\n\n``` go\ntype Times struct {\n    One time.Time\n    Two time.Time\n}\n\ntype EmbeddedTime struct {\n    Id string\n    Times\n}\n\n// See: https://github.com/coopernurse/gorp/issues/86\nfunc TestEmbeddedTime(t *testing.T) {\n    dbmap := newDbMap()\n    dbmap.TraceOn(\"\", log.New(os.Stdout, \"gorptest: \", log.Lmicroseconds))\n    dbmap.AddTable(EmbeddedTime{}).SetKeys(false, \"Id\")\n    defer dbmap.DropTables()\n    err := dbmap.CreateTables()\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    time1 := parseTimeOrPanic(\"2006-01-02 15:04:05\", \"2013-08-09 21:30:43\")\n\n    t1 := &EmbeddedTime{Id: \"abc\", Times: Times{One: time1, Two: time1.Add(10 * time.Second)}}\n    _insert(dbmap, t1)\n\n    x := _get(dbmap, EmbeddedTime{}, t1.Id)\n    t2, _ := x.(*EmbeddedTime)\n    if t1.One.UnixNano() != t2.One.UnixNano() || t1.Two.UnixNano() != t2.Two.UnixNano() {\n        t.Errorf(\"%v != %v\", t1, t2)\n    }\n}\n```\n. Hi guys,\n\nI like the idea as well. I also like the `Select` vs `SelectOne` idea -- If a non-slice pointer is provided to `Select` it returns the first row found, whereas `SelectOne` raises an error if there is more than one row.\n\nI'm partial to keeping the `SelectInt`, `SelectStr` family of methods, simply for convenience (you don't have to forward declare the return variable), but they could be modified internally to use `Select`\n. Howdy,\n\nSee the above commit -- it's on the develop branch, so it's still unreleased.\n\nWhat do you think?  Rob, if you can kick the tires on it a bit with your local tree that would be great.\n\nthanks\n\n-- James\n. I've merged this into master as part of v1.2\n. Hi there.  No, there's currently no support for foreign keys in gorp.  Your first example looks good (aside from ignoring the err values). \n\nOn the develop branch there's a new `SelectOne()` method (see #87) which lets you avoid the type assertion, but doesn't auto-generate the SQL string.\n\n``` go\nvar first First\nvar second Second\n// ? placeholders for mysql/sqlite, use $1 for postgres, or use the map syntax if you \n// need full portability\nerr := dbmap.SelectOne(&first, \"select * from First where Id=?\", first_id)\n// handle err\nerr = dbmap.SelectOne(&second, \"select * from Second where Id=?\", first.SecondId)\n// handle err\n```\n. Looks good.  I'm going to cherry pick these commits and apply them to the develop branch.\n. Ok this has been merged into master.  Thank you!\n. Makes sense.  I'd like to think a bit about the API for this. In general should the philosophy be to specify the column names, or the struct fields?  Is there any way to provide type safety?\n. See #115 - I think you guys are attacking similar problems.  Anyone else have an opinion?  I'm leaning towards #115 at this point, but I'm not a Postgresql user so I want to defer to those who are.\n. #115 was released as part of v1.4 today. Closing this ticket out.\n. Thanks for the submission.  I'll review this next week.\n. Hi there. Sorry I'm currently on vacation. I haven't reviewed your PR yet but I will. Sorry for the delay. \n. Ok, I've cherry picked these commits into develop and pushed.  I'm going to release this, #115 and #108 together into master as v1.4\n\nPlease merge develop into your fork and verify that things look good to you.  I'm going to run my current work project against this branch for a few days as well.\n. This was merged into master today as part of v1.4. thanks again.\n. Thanks for patching this.  I'm going to do some gorp work on Monday so I'll review this and get it merged into master then.\n. Ah, that's an oversight.  Yes, let's add it.\n. sorry for the delay in reviewing -- this is a pretty big PR, so I agree it would be helpful to have the commits squashed so that the diff is easier to review.\n\nI looked through it and saw at least one instance where the SqlDialect was inspected in the code -- may be good to factor that case into the Dialect interface.  I can comment more specifically on that when we have the new diff.\n. Thanks for the contribution.  Unfortunately once I document a public API I generally avoid non backwards compatible changes.  Your change makes sense, but folks may rely on the present behavior (although SelectOne() is quite new).\n\nI've opened #101 to track the discussion for this.  I'm going to close this PR, but keep that issue open for discussion.\n\ncheers\n\n-- James\n. Yeah I agree that an error is probably more sensible. SelectOne() is new enough that backwards compatibility may not be a major concern.\n. Ok, I've cherry-picked the commit on #98  --  so SelectOne() will now return an error if no row is found.\n\nThanks for the comments here - I may have kept this open a little longer than I should have, but I'm happy that we had a more or less unanimous vote.\n. This is merged into master\n. SQL statements fully generated by gorp (e.g. Get, Insert, Update, Delete) should be safe, as they use prepared statements with all variables passed as bind arguments.\n\nBut Exec and the Select\\* methods accept SQL strings you pass in.  If you use placeholders for all variables (as opposed to including user input in the SQL string itself) then you're fine.  But since gorp exposes the raw abstraction, you could write code that is vulnerable.\n\nHope that clarifies things.\n. I agree that the #92 is a good compromise here.  \n\nA tag could work -- I would use the `omitempty` tag to match the Go json tag.  The semantics seem similar to me -- drop nil/zero values.\n. @chbrown I agree with the comparisons to `encoding/json`.\n\nWe have a pending PR for #92, but I would still welcome a PR for the `omitempty` case.\n\nOne note: I would want API support for omitempty in addition to a tag.  Tags are sugar for the API, but it should always be possible to set mapping rules programmatically (for types you don't have source control over).\n. Since Go doesn't have polymorphism we'd need a new name for this, perhaps:\n\n``` go\nfunc (m *DbMap) SelectMap(query string, args ...interface{}) (map[string]interface{}, error)\n```\n\nGiven that you'll have to type assert the values in the map, I'm not sure how convenient this method will be though.  I suppose if you have a case where you don't know the columns returned until runtime it may be useful.\n\nAnyone else feel this is worth adding?\n. #108 fixes this. Released to master today in v1.4\n. Since your PR was done from master I cherry picked it into develop and re-did the merge.  \n\nI haven't merged develop to master yet.  I'll do that next week after I get feedback on #115 and #94.  If you could modify your fork to track develop that would be great.  Details here: https://help.github.com/articles/syncing-a-fork\n. This was merged to master today as part of v1.4. Thanks.\n. Ah, that's a good catch. Kind() may work for aliases of built in types.  In theory you could alias a struct at which point we'd need the Type (both would have Kind() equal to \"Struct\" I think).\n\nThe test above looks like a good start.  When I have some free time I'll see if I can get it passing.  Others who read this, feel free to do the same and send a pull request.\n. @iwek `html/template` `Template` struct is a parse tree AFAIK.  You'd probably want to persist the actual HTML document as a string or byte slice.\n. Is your DbMap using the gorp.MySQLDialect?  If so, identifiers should be backtick escaped, not double quoted.\n\nYou want to do something like:\n\n``` go\ndbmap := &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{\"InnoDB\", \"UTF8\"}}\n```\n. Hi, I just ran the test suite using that driver and it passed.  The puzzling part to me is you're getting double quotes around identifiers.  The MysqlDialect won't do that.\n\nPlease paste some code that reproduces this and perhaps we can figure it out.  But right now I'm unclear how you're getting that SQL from gorp if you're using the MysqlDialect.\n. Are you running the latest version of gorp in master?\n\nGiven the change made in commit e17cc11 to panic if Engine or Encoding is empty, you need to change the last line of openorm() to:\n\n``` go\nreturn &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{Engine: \"InnoDB\", Encoding: \"UTF8\"}}, nil\n```\n\nWith that change \"go test\" on this file runs fine on my machine. \n. Hi Rob,\n\nAre you sure that doesn't work?  I'm using non-pointer slices with Select() on a project and it's working for me.  Maybe something else is going on?\n. I've cherry picked this commit and added some docs to the README.  Thanks.\n. Thanks.  Overlaps with #93 - I like your approach, but I want to get some more comments from other users.\n. Ok I've cherry picked this commit into the develop branch. \n\nPlease try this branch with your project and comment here if you see issues.  I'll be merging develop to master some time next week.\n. This was merged into master today as part of v1.4\n. Docs are here: http://godoc.org/github.com/coopernurse/gorp\n- Primary key:  use TableMap.SetKeys()\n- Not null:  use ColumnMap.NotNull()\n- Default: not supported directly, but you could use the PreInsert/PreUpdate hooks for this\n. Are you checking the error return value from CreateTablesIfNotExists()?\n. Ok I cherry picked b6b7bba into master.  gofmt will be run in develop along with some other PRs that I'm merging.\n\nthanks.\n. I'm not a Postgres user so I'm not sure why this was added.  It was done in 84cf915 as part of #22 \n\nLooking at this: http://stackoverflow.com/questions/7262795/postgresql-table-name-schema-confusion\n\nIt looks like if we quote the identifier it becomes case-sensitive, which means using ToLower() is a bad idea.\n\nAny Postgres users disagree?  I'm inclined to remove ToLower() here.\n. @jordan-wright I agree, some change is required here.  \n\nI'm leaning towards removing ToLower() -- are there any major objections?  I realize this departs for existing behavior, but unfortunately I think that's unavoidable to move forward.\n\nI'm not going to change this for 1.4, but I'd like to get a commit in for 1.5 that resolves this ticket one way or another.\n. I've never tried it.  How do you do it with the `database/sql` interface?\n. Closing due to inactivity.\n. Now that I look at `database/sql` I'm unclear where the \"Nullable*\" names came from.  Maybe these were the `exp/sql` names prior to Go 1?  \n\nAnyone think we need to keep the \"NullableInt64\" type names.  I don't see a reason for them at this point.\n. Ok, this has been cherry picked into develop.  I had to make another patch to get things working with postgres (`double precision` needs to be used for `float64` values).  \n\nFeel free to pull develop locally and test.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. I've cherry picked this commit into develop.  It will go out in the next release.\n\nThanks.\n. Thanks for the contribution.  \n\nI'm thoughtful about adding this feature.  I wonder if we should consider adding support to gorp for this package:  https://github.com/lann/squirrel\n\nI haven't spent much time thinking about it, but one approach would be to provide a Select() variant that accepts a squirrel Sqlizer and a bind target.\n\nIf we really wanted to go crazy, we could think about using this project to replace the current ad hoc bind\\* caches, which relates to #124 \n\nAnyone else have opinions on this?  It's a somewhat big change.\n. Ok this is in develop now. Feel free to pull locally and test.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. This is in develop now.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. Interesting.  That's currently an unsupported case.  Feel free to propose a solution on this ticket. \n. SchemaName is simply a string that will be prefixed to tables.  Some databases don't use this.  What database are you using?\n\nIf you want to run your own CREATE TABLE command as a db migration, just call Exec() with a hand written CREATE TABLE command.  \n. Hi there. There's a few SelectOne() examples in the README.  Which one(s) are you referring to?\n\nthanks\n. Interesting. The tests have an example that is very similar:\n\nhttps://github.com/coopernurse/gorp/blob/develop/gorp_test.go#L1375\n\nI'm curious how your example differs, as that test cases is passing for me.\n. Yep, I test locally with Go 1.2.  The issue might be with transactions.  If you have time to write a test case that uses SelectOne in a transaction, please post it on this issue and I'll take a look.\n. This is in develop now.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. Hi there. Your PR adds two ColumnMap fields: `Autogenerate` and `UpdateOnInsert`.  It looks like your `Autogenerate` overlaps with the `selectonly` tag being considered for #59  Is that true?\n\n`UpdateOnInsert` seems very special purpose. I could imagine someone also wanting `UpdateOnUpdate` (e.g. for a timestamp field, or something set via trigger).  \n\nI'm wondering if there are other ways to express this.  Anyone else have opinions?\n. Good catch.  Now that I look at DbMap.Exec(), it appears to be doing the same thing.  I'll clean that up as part of this merge.\n. This is in develop now.  I'll merge to master later in the week as v1.5.\n. This has been merged to master as v1.5\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. See #175 for the full explanation, but this PR caused a regression when combined with tags in a particular way (see: AliasTransientField in gorp_test.go).\n\nI have modified `SelectAliasTest` to demonstrate a different way to achieve your goal.  If you want Select to return values that aren't in the underlying table, then I'd suggest using a 2nd type for this, similar to the `InvoicePersonView` example in the joins section of the README\n. @zhengjia excellent, thanks.  This change is in master now.\n. Hi there.  I'm not sure what sources you ran this from, but gofmt is clean in develop and master right now.  `gofmt -d *.go` reports no differences.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Good catch Rob.\n\nPresumably we don't want the semantics of SelectInt, SelectFloat, SelectStr, etc to change.  \n\nIf we want those functions to continue to return zero values, then we could:\n- modify selectVal() to return sql.ErrNoRows (fixes SelectOne())\n- modify the other selectVal() callers to ignore sql.ErrNoRows if err is non-nil\n\nAnother option is to return a 2nd value from selectVal() that indicates whether a row was found, but that doesn't seem necessary.  \n\nAny opinions?\n. I haven't merged it to master yet.  If folks think it looks good I'll promote it to master this week.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Good question.  @JonPulfer I think this is an interesting enhancement for cases where you want to deal with large data sets without buffering the whole resultset in RAM.\n\nWould you mind writing a test that demonstrates usage?  \n. Do we need a separate mutex per method on TableMap?  What if we just had a single mutex and used it on each of the relevant methods\n\nAny other opinions?\n. That makes sense, although the contention would likely still occur with 4 mutexes instead of one.\n\nIf we're worried about contention (and it's a valid concern I think) we may want to move the lock inside that the code that checks for empty string.  For example:\n\n``` go\nfunc (t *TableMap) bindInsert(elem reflect.Value) (bindInstance, error) {\n    plan := t.insertPlan\n    if plan.query == \"\" {\n\n```\n. That makes sense.  Thanks.\n. Thank you - I have a similar fix in develop that forces the string to lower case. Apologies I didn't merge this but I think our solutions are similar.\n\nMy change is pushed in develop now and will get merged into master in the next push (~1 week from now)\n. Apologies for the delay in reviewing this.  \n\nI'm probably being dense, but what's the use case here? I see the failing test, and I think your patch is safe, but the generated SQL will always no-op right? Here's the generated SQL from the test:\n\n```\nupdate \"single_column_table\" set \"SomeId\"=? where \"SomeId\"=?; \n   [A Unique Id String A Unique Id String]\n```\n\nJust to be clear - the goal is to avoid the invalid SQL statement generated before the patch.  Is that right? Or are there cases where this patch would actually result in a productive (i.e. state mutating) update on a table?\n\nthanks\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. I suspect this could be supported.  A first step would be to submit a PR with one or more failing tests that exercise this.  I'll merge it in and disable the test so CI still runs, but we can then track potential solutions against this test case.\n. Hi there.  Good stuff.  It's a huge PR though so it's hard for me to digest it.  Also, splitting up gorp.go, while probably long overdue, is something I'd want to do in a PR on its own since it makes it hard for me to merge any other pending PRs.\n\nSo I'm wondering if we can split this work up into smaller PRs:\n- #158 changes - I'm guessing this is a pretty small change and easy merge\n- #157 changes - Probably bigger - hard for me to tell given the large number of commits here\n- gorp.go split \n\nDo you have time/interest to work together on that?  Thanks again.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. In theory if you use SelectOne with a pointer to an existing value you could wire things bi-directionally.  This issue would depend on resolution of #164  Then you could do something like:\n\n``` go\n\ntype Group struct {\n    Id string \n    //  not sure how you're mapping this, I'm assuming it's wired manually\n    User User  `db:\"-\"`\n}\n\nfunc (me *Group) PostGet(ex SqlExecutor) error {\n  if me.User.Id == \"\" {\n     me.User.Group = *me\n     return ex.SelectOne(&me.User, \"select * from User where GroupId=?\", me.Id)\n  }\n  return nil\n}\n\ntype User struct {\n    Id string\n    Group Group  `db:\"-\"`\n}\n\nfunc (me *User) PostGet(ex SqlExecutor) error {\n  if me.Group.Id == \"\" {\n     me.Group.User = *me\n     return ex.SelectOne(&me.Group, \"select * from Group where UserId=?\", me.Id)\n  }\n  return nil\n}\n```\n\nWould that work?  Again, due to #164 that code won't work today, but once fixed it should work.\n. Hi there,\n\nThanks for the thoughtful post.  I don't have any great insight on a solution, but let's see if others have ideas.\n\nI think a concrete first incremental step would be to send a PR with a failing test case that we can check into the build (commented out) which we can use as a foil to judge potential solutions against.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Hi, do you have an example?  What DbMap methods are you seeing this on?\n. I think this is a bug.  `SelectOne` is calling `hookedselect` which calls `rawselect` which assumes a list return.  Line 1467 creates a new struct to bind into: `v := reflect.New(t)`\n\nAnd then line 1326 of `SelectOne` binds the returned element to the pointer passed to it: `dest.Elem().Set(src.Elem())`\n\nThat explains the behavior you're seeing -- your pointer now points to a new struct, so the transient fields are zeroed out.  And I would agree that behavior is unexpected.\n\nNot sure what the easiest fix is.  One possibility might be to define a new interface for appending results and pass an instance of that to `rawselect` instead of `i interface{}`.  This would let us clean up the `appendToSlice`, `intoStruct` flags.  `SelectOne` would provide an implementation that appends to the pointer passed in, and errors out if more than one row is found.\n\nSorry I don't have an easy solution for this, but this is a good ticket and one that could prompt some code re-work that will have some other hygenic benefits.\n. Yes, you can use a DbMap.Select across multiple goroutines.  There currently aren't mutexes on the operations that configure the mapping rules (e.g. ColumnMap.SetXXX(), TableMap.SetXXX()) so behavior is undefined if you call those methods concurrently from multiple goroutines. \n\nBut all the common SQL operations (Select, Exec, Insert/Update/Delete) are all safe to use from multiple goroutines.\n. I'm merging this now as part of the v1.6 release\n\nWhat Go SQL Server driver do you recommend / test with?  I'll add that to the README, as I have no easy way to test this stuff locally.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Thanks - I've added `QuerySuffix` and updated the README.  I also added lines to gorp_test.go to ensure that dialect structs match the interface so this will be compile error in the future.\n. I'm merging this now a part of the v1.6 release.\n\nWhat Go / Oracle driver do you suggest folks use?  I'll add that to the README\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. Howdy.  This has been rebased onto develop. I added some docs for DbMap.TableFor, since it's now exported.\n. Hi,\n\nThis issue has been resolved in develop.  Please test your project\nusing the latest from github.com/coopernurse/gorp's develop branch\nand post a comment on this ticket if things look good to you:\n\nhttps://github.com/coopernurse/gorp/issues/170\n\nIf nothing is found, v1.6 will be merged to master on May 23\n\nthanks, -- James\n. v1.6 was merged to master today.\n. Hi.  Off the top of my head, you could do it in one query if you defined a type with the all the fields in the join, and then did the group by in Go. \n\nTotally untested code, and may not compile.. But hopefully gives you the idea.\n\n``` sql\ncreate table Car (\n    id    bigint primary key,\n   name   varchar(255)\n);\n\ncreate table Wheel (\n    id       bigint  primary key,\n    carId    bigint not null,\n    type     varchar(255)\n);\n```\n\n``` go\ntype Car struct {\n        Id     uint64\n        Name   string\n        Wheels []Wheel\n}\n\ntype Wheel struct {\n        Id       uint64\n        CarId    uint64\n        Type     string\n}\n\ntype CarWheel struct {\n        CarId      uint64\n        CarName    string\n        WheelId    uint64\n        WheelType  string\n}\n\nvar rows []CarWheel\n_, err := dbmap.Select(&rows, \n    `select c.id CarId, c.name CarName, w.Id WheelId, w.Type WheelType,\n    from Car c, Wheel w  \n    where c.id = w.carId\n    order by c.id`)\nif err != nil {\n  // blow up\n}\n\n// group rows by carId - maybe factor to a function\nvar cars []*Car\nvar current *Car\nfor _, r := range rows {\n    wheel := Wheel{Id: r.WheelId, CarId: r.CarId, Type: r.WheelType}\n    if current == nil || r.CarId != current.Id {\n        current = &Car{Id: r.CarId, Name: r.CarName, Wheels: []Wheel{}}\n        cars = append(cars, current)\n    }\n    current.Wheels = append(current.Wheels, wheel)\n}\n```\n. Re naming: \"Put\" is another option.  \"Upsert\" doesn't bother me that much -- I realize the MongoDb folks use that name.\n\nMy main comment on this implementation is that it relies on mysql-specific behavior.  In theory this could be done in a generic manner using a transaction.  Has anyone looked at how other ORMs implement this type of call?\n. How do other implementations decide to do the insert vs update?  Do they look for an existing row by PK first?  If so, then this smells like something that could be done using the existing gorp Get/Insert/Update operations inside a transaction.  Could it be that simple?\n. Interesting.  Can you add a test case that reproduces this?  \n\ntravis-ci is running the tests against Go tip and 1.1, so I assume tip should reproduce this behavior if we get a test case in.\n. Thanks - I have reproduced this in test. I'm glad you supplied a test case above, as it looks like this happens when a struct field is aliased to a column name which matches another field in the struct that is marked transient.\n\nI'll get a fix for this later today and push it to master.\n. The plot thickens.  You're correct that #146 introduced this behavior change.  I need to study that PR more closely before I can fix this issue.  My first attempt broke `TestSelectAlias` and I'm trying to figure out if there's a simple way to fix #175 and keep #146.\n. Ok I've reverted #146 but modified the `TestSelectAlias` included in that PR to demonstrate a way to accomplish the same goal.\n\nI also added test cases for your case.\n\nPlease take a look - if you can build/test against my develop branch that would be helpful.  Otherwise I'll plan to cherry pick this commit into master later today or tomorrow and tag as v1.6.1\n. Ok this is in master now\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. The reason the 2nd `Insert` fails is that you created a new DbMap and then didn't add call `AddTableWithName`.  \n\nI'm a little confused by this example.  Is there a reason you're re-opening the connection and recreating the DbMap? I assume this would work:\n\n``` go\n// initialize connection and DbMap\ndb, err := sql.Open(\"sqlite3\", \"./cloud.db\")\ndbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}    \ndefer dbmap.Db.Close()\ndbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")\n\n// first insert\nerr = dbmap.Insert(&user{})\nif err != nil {\n   log.Fatal(err)\n}\n\n// second insert\nerr = dbmap.Insert(&user{})\nif err != nil {\n   log.Fatal(err)\n}\n```\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. Please test your application against the develop branch.  I've merged several PRs in.  Please open a new ticket if you run into any problems.  If no problems are reported by Aug 30 I'll merge to master.\n. All Postgres support was community contributed, so I don't have a strong opinion on the desired semantics.  This is the line that's causing you trouble:\n\nhttps://github.com/coopernurse/gorp/blob/develop/dialect.go#L270\n\nIf I'm reading the Postgres docs correctly, quoting avoids reserved word conflicts, but also makes the string literal case sensitive.  I can see times when either use case (case insensitivity or avoiding reserved word issues) is desired.\n\nBut I'll defer to Postgres users on how they want this to work.  The dialect could allow the caller to specify which behavior they want.  But I want some other Postgres users to weigh in.\n. Hmm.. no reason I can think of.  Please send a PR if you have time to make those changes.\n. Awesome, thanks for catching this!\n. Could you post some example code?  If you're using bind variables then you shouldn't have a problem.\n. ok that should be all set.\n. Hi there,\n\nThanks for prodding me to do this.  I've been procrastinating.  I'll push an update to the README asking for folks to volunteer.  There may be an active fork that we can simply begin pointing folks at.\n. @GeertJohan has kindly created an organization (go-gorp) so I'm considering moving this repo there.  \n\nAny other opinions on this before I do that?  Seems like the right solution.\n. ",
    "dmitrykim": "Thank you for the two links, will use them for now. Yes I was using https://github.com/ziutek/mymysql . \n. Fix of https://github.com/ziutek/mymysql/pull/5 fixed this. \n.  jsn, sorry, i only changed own email settings. i'm new to github. concurrency safety now completely depends on driver used. when using mymysql, it seems to be safe if you use threadsafe mymysql package:\n    \"github.com/ziutek/mymysql/mysql\"\n    _ \"github.com/ziutek/mymysql/thrsafe\"\ninstead of native one. without mature exp/sql drivers we can't say much more now. James, it's up to you to close the issue or not. i just know correct way now with respect to specific driver. \n. The output is:\ngorptest: 10:49:24.158085 create table PersistentUser (Key int not null auto_increment, Id varchar(255), PassedTraining varchar(255), primary key (Key))  engine=InnoDB charset=UTF8; [[]]\npanic: Fatal error: Received #1064 error from MySQL server: \"You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'int not null auto_increment, Id varchar(255), PassedTraining varchar(255), prima' at line 1\"\n. sorry )\n. Thank you for the two links, will use them for now. Yes I was using https://github.com/ziutek/mymysql . \n. Fix of https://github.com/ziutek/mymysql/pull/5 fixed this. \n.  jsn, sorry, i only changed own email settings. i'm new to github. concurrency safety now completely depends on driver used. when using mymysql, it seems to be safe if you use threadsafe mymysql package:\n    \"github.com/ziutek/mymysql/mysql\"\n    _ \"github.com/ziutek/mymysql/thrsafe\"\ninstead of native one. without mature exp/sql drivers we can't say much more now. James, it's up to you to close the issue or not. i just know correct way now with respect to specific driver. \n. The output is:\ngorptest: 10:49:24.158085 create table PersistentUser (Key int not null auto_increment, Id varchar(255), PassedTraining varchar(255), primary key (Key))  engine=InnoDB charset=UTF8; [[]]\npanic: Fatal error: Received #1064 error from MySQL server: \"You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'int not null auto_increment, Id varchar(255), PassedTraining varchar(255), prima' at line 1\"\n. sorry )\n. ",
    "jsn": "dmitrykim, why am I receiving all these notifications via email? did you specify your email as \"dmitry.kim@gmail.com\"? because all the followups for the discussions you're taking part in on github go straight into my gmail inbox with that address.\n. dmitrykim, why am I receiving all these notifications via email? did you specify your email as \"dmitry.kim@gmail.com\"? because all the followups for the discussions you're taking part in on github go straight into my gmail inbox with that address.\n. ",
    "geoah": "This indeed does seem to be an issue at least when using mymysql.\nI'll try to create a test to reproduce this but it seems that we need to be using autorc to create and retrieve the db connection -- at least according to example number 6 of mymysql.\nhttps://github.com/ziutek/mymysql#example-6---autoreconn-interface\n. This indeed does seem to be an issue at least when using mymysql.\nI'll try to create a test to reproduce this but it seems that we need to be using autorc to create and retrieve the db connection -- at least according to example number 6 of mymysql.\nhttps://github.com/ziutek/mymysql#example-6---autoreconn-interface\n. ",
    "alecloudenback": "I'm a self-taught programmer, who's especially new to databases. But what I think would be causing the issue is the structure of slices, which consist of of [a pointer to the array, the length of the segment, and its capacity](http://blog.golang.org/2011/01/go-slices-usage-and-internals.html). I would suppose that if the slice's array was sent as an argument to the DB, it would work. \n\nOne could detect the type of the Go struct field and decide whether or not it was a slice via the `reflect` package. I will attempt to make inroads into this strategy, but if this adds insight to you I can almost assure you that someone else could turn this around better and faster than myself.\n. I'm a self-taught programmer, who's especially new to databases. But what I think would be causing the issue is the structure of slices, which consist of of [a pointer to the array, the length of the segment, and its capacity](http://blog.golang.org/2011/01/go-slices-usage-and-internals.html). I would suppose that if the slice's array was sent as an argument to the DB, it would work. \n\nOne could detect the type of the Go struct field and decide whether or not it was a slice via the `reflect` package. I will attempt to make inroads into this strategy, but if this adds insight to you I can almost assure you that someone else could turn this around better and faster than myself.\n. ",
    "adharris": "I took a stab at implementing some of the array functionality using the driver: \nhttps://gist.github.com/4163702\n\nlet me know if there is anything I can add there\n. I took a stab at implementing some of the array functionality using the driver: \nhttps://gist.github.com/4163702\n\nlet me know if there is anything I can add there\n. ",
    "cy137": "Does anyone know if this has been worked on?\n\nThanks!\n. Does anyone know if this has been worked on?\n\nThanks!\n. ",
    "lenw": "The type converter interface is happening at the wrong level afaics for this to work. \n\nIn pg (http://www.postgresql.org/docs/9.3/static/arrays.html) this sort of insert would need to be generated : \n\n```\nCREATE TABLE sal_emp (\n    name            text,\n    pay_by_quarter  integer[],\n    schedule        text[][]\n);\n\n\nINSERT INTO sal_emp\n    VALUES ('Bill',\n    '{10000, 10000, 10000, 10000}',\n    '{{\"meeting\", \"lunch\"}, {\"training\", \"presentation\"}}');\n\nINSERT INTO sal_emp\n    VALUES ('Carol',\n    '{20000, 25000, 25000, 25000}',\n    '{{\"breakfast\", \"consulting\"}, {\"meeting\", \"lunch\"}}');\n```\n\nI guess Dialect.BindVar(x) would need to do the work there based on the column type ?\n. The type converter interface is happening at the wrong level afaics for this to work. \n\nIn pg (http://www.postgresql.org/docs/9.3/static/arrays.html) this sort of insert would need to be generated : \n\n```\nCREATE TABLE sal_emp (\n    name            text,\n    pay_by_quarter  integer[],\n    schedule        text[][]\n);\n\n\nINSERT INTO sal_emp\n    VALUES ('Bill',\n    '{10000, 10000, 10000, 10000}',\n    '{{\"meeting\", \"lunch\"}, {\"training\", \"presentation\"}}');\n\nINSERT INTO sal_emp\n    VALUES ('Carol',\n    '{20000, 25000, 25000, 25000}',\n    '{{\"breakfast\", \"consulting\"}, {\"meeting\", \"lunch\"}}');\n```\n\nI guess Dialect.BindVar(x) would need to do the work there based on the column type ?\n. ",
    "siliconsenthil": "Any update on this? Am I missing something. Is there a way to register a custom mapper to convert to value string, otherwise? Or any other workaround?\n. Any update on this? Am I missing something. Is there a way to register a custom mapper to convert to value string, otherwise? Or any other workaround?\n. ",
    "GeertJohan": "We'll have to pick this up in `v2-phase3` (see #270). @siliconsenthil \n. This would be realy usefull. Gorp could ship with a `CamelCaseMapper` and an `UnderscoreMapper`, and anyone could implement a default `mapper`.\n. @meetmauro Can you see if the requested changes can be made to this PR? I'd be happy to add this feature to the codebase.\nIf so, please:\n- Rebase the PR on the latest master\n- Use attributes in the same `db` tag\n- Change `pk` to `primarykey`\n. New PR: #233 \n. I'm not sure if it is smart to allow this. TableMap could (potentially) cache information that is depending on the used dialect. It isn't that bad performance-wise to re-create the TableMap three times. I've put this in milestone v2.1-maybe, so it'll come up again when we get to v2.1.\n. This looks like a nice feature!\n. After looking at this again I think this needs some discussion. I'm not sure wether the use case for a `selectonly` (or rather: `scanonly`) field is large enough. Should be discussed again in phase3.\n. #188 was merged. Closing this issue.\n. #188 didn't address the initial request, which is related to #133.\n. @joeshaw I think this would be a nice feature, but as pointed out by coopernurse it requires to be modified by a method. If you're still interested in this could you please:\n- Add a method to change the field, and regenerate insert plan SQL statement\n- Rebase this PR on the latest master branch\n. @joeshaw If you're not interested anymore, please let us know. So we can either close this issue or work on it ourselves.\n. Better late then never (and because someone else might find this useful):\n\nIt looks like you are using `go-sql-mysql/mysql` and do not have the `parseTime` parameter set to true.\nPlease see: https://github.com/go-sql-driver/mysql/#parsetime\n\nI assume this answers your question, if not: please re-open this issue.\n. Closing this PR, it's continued as #201 .\n. Closing this. gorp has very basic create/drop table support which is very handy to quickly setup a database, but migrations go a lot further. Currently it is out of scope, there are a lot of tools better qualified for this. (goose, sql-migrate)\n. I agree with coopernurse that this wouldn't be very convenient. The goal with gorp is to map values into a struct or slice type.\nClosing this issue.\n. So what we want here is more freedom with types (`type myString string`), and gorp being smart enough to see that it's actually a string..\n\nAnother 'solution' might be a good explanation on how to use custom types with gorp (driver.Valuer).\n. Related to #192 \n. Fixed in #300 \n. I agree. Required columns should be specified explicitly. What could be added though is a method to automatically query all required columns based on the struct.\n. Related to #133 \n. There is some overlapping with other tools such as gorq (extension for gorp) and squirrel. So we should also consider adding support for one of those. For now I'm post-phoning this PR to v2.1 (see #270).\n. The implementation in #174 is very interesting, we could definitely use that to implement this in `v2.1`.\n. I agree with @tobz, closing this issue. @rvenugopal please re-open this issue if you feel there is a valid use case for this.\n. Gorp isn't meant to be a sql generation package. Having said that: I would still like to consider this basic use case. Gorp also generates the insert statement, so why not a simple sql select.. The select part could be cached for performance, and only the where needs to be appended.\nThinking out loud: `Select(&tbl, \"WHERE a = 42\")`\n. @go-gorp/maintainers what do you think?\n. #62 contains some good thoughts on how we might implement this.\n. I'm splitting your issue into two issues.\n. Why do you have two tables with different names having the same schema? Is it maybe meant for some load balancing purposes? That would also explain the need for a custom `sql.DB`.\n. I'm not sure if we should add load balancing features to gorp. But lets think about this after v2 was released (see #270).\n. Yes this could be a good addition. I'm setting this for v2.1-maybe, please see #270 \n. Related to #139 \n. I'll close this issue and continue with #139 \n. So, it looks like time.Time handling for postgres requires some more work.\n\n@gwitmond Would you be able to clean up this PR a bit (remove the README.md modification and use `timestamp with time zone`?) I'd be happy to merge it in!\n\n@manugarri Could you open a separate issue for your problem, preferably with a failing test case?\n. Time was already added.\nAdded NullTime in f2a9a30809d67ca10d35893c49df78ba89af6f99\nAdding tests in #226.\n. @JonPulfer I'm very interested in this feature, but sadly the PR seems to be messed up a bit.\nI think the feature could be best added in a new `SelectFoobar` method. \nWe're now cleaning up the issue and PR backlog (see #270), so I think this feature would best be added after we're done with that. I think it will require a new PR as at that point code will be separated into multiple files and more changes applied. Keeping this PR open so we will look at it again. Please let me know if you're still interested in seeing this merged.\n. We've stopped using the `develop` branch, all development now takes place at `master`. I think it would be best to wait until we have cleaned up the codebase and have released v2, that will also make development easier for you. We can then work out the API spec.\n. I think we need to take a good look at this, it is very important to make sure gorp is concurrency safe!\n. Superseded by #301, which uses `sync.Once`.\n. Commented-out failing tests have been merged, fix needs to happen in v2-phase3 (#270)\n. It looks like this is still relevant. How to solve this problem?\n. I will merge these in soon, the fix will have to wait until v2-phase1. Please see #270 \n. Nevermind, merging now to the master branch.\n. Merged in 6301df302a3a74f171646fa294d57c17b8e9b822\n. I would be happy to merge this PR, but could you please:\n- Add a test case for varchar vs text\n- Squash commits\n- Rebase this PR on master (we've deprecated the develop branch, sorry)\n\nThanks!\n. I'll merge these now without test case, that will come in v2-phase3 (see #270).\n. Merged as 0ca02be3238d9c48a9ab715870354e7acdf063ba\n. I would still like to see this feature. I think a transaction with select by primary key, then insert or update would work.. \n. \"Upsert\" is a good name, I think it's very descriptive. Any plans to make this work @spencerkimball ?\n. I'm closing this PR for now (see #270). However, I would still like to see this feature so #130 will stay open and there's a good chance I'll re-use code from this PR to add the feature after `v2.0`/#270\n. I agree that the comma is only required to skip the first argument: the field name.\n\n```\nTag = Name { ','  Option }\nOption = OptionKey [ ':' OptionValue ]\n```\n. I'm not sure if gorp should convert a null to a zero int.\nHow do you propose to solve this problem?\n. The query returns null, which is not the same as zero. Use `*int` or a custom type to use with `sql.Scan`.\n#221 might introduce these types into the package.\n. Discussion in #181 \n. We can bring these back in v2.1 after #270 is done.\nThis request is related to #221.\n. Looks good!\n@billmccord  Can you please rebase this PR and base it on master instead of develop? (We've deprecated the develop branch)\n. Thanks, I'm closing this one.\n. Update for followers here: #220 was merged.\n. Could you please share your actual code? That way we can check the code itself, and reproduce the problem.\n. Hi @klaidliadon, thanks for your PR!\n\nCan the `TargetQueryInserter` be an unexpored interface? I don't think it adds value to the exported API.\n. Merged it anyway. Chances are that the dialects are moved to their own packages (#272) so the dialect interface (and friends) need to be exported anyway.\n. Thanks :+1: \n. This PR needs some work, but it's best to merge in at `v2-phase1` (see #270). Merging after phase2 will be a mess..\n. @umisama Please fix the failing tests and rebase this PR on the `master` branch (we've deprecated `develop`, sorry).\n. @umisama  Great! Thanks!\n. Hi @umisama \nThanks for making the changes!\nI want to give this a good test drive before merging. It seems time is a nasty subject (See #226),\nThanks again!\n. This might actually fix time scanning for other drivers too :+1: \n. Great, thanks!\n. Oh, yes you're right! I forgot to check if the PR was aimed at master..\nCould you maybe rebase this on master and open a new PR?\n. Thanks :+1: \n. This PR modifies a lot of code (move from gorp.go to schema.go), which will probably break a lot of other PR's.\n\nI've opened a discussion about how we approach the list of open PR's here: https://groups.google.com/forum/#!topic/gorp-dev/rEsu0efgUfw\n. Hey @rickb777,\n\nThanks for this PR!\nThe last commit (423a897) moves a lot of code from gorp.go to schema.go. I agree with the concept of splitting the code into multiple smaller files, but right now it will probably break a lot of open PR's. Can you undo the moving of code and squash/overwrite that commit? We've also deprecated the `develop` branch, but you should be able to rebase on `master` without any problems.\n\nWe will split the code in separate files once the open PR's are closed.\n. Hi @rickb777\nAny chance you can work a bit more on this so we can merge it into master?\n. This will need some work and manual merging before it can be added. Could be done in `v2-phase3` (see #270).\n. @ipartner Not that I am aware of. I haven't bumped into this issue myself yet, could you maybe share example code to reproduce the problem?\n. Please add test cases and re-open this PR on master branch (we've deprecated the `develop` branch)\n. @zallwu If you could add a testcase and docs, as well as rebase to master, then we could merge this at `v2-phase1` (see #270). Otherwise we'll have to postphone it to `v2.1`, at which point the codebase will have changed a lot.\n. Looked at the code again. I think it would be better to add default as a part of the db tag:\n`db:\"name, default:uuid()\"`\n. I'll merge and add open an issue so we can work it out in phase3.\n. Merged at 96583e83d36be671cc76657afdc7f61ba5986661\n. Actually added the default option to the db tag just now..\n. Would `InsertSelect` be a good feature? e.g.:\n\n```\nInsertSelect(&insertStruct, &selectStruct, \"returning stmt\")\n```\n\nSo @nelsam's example would become:\n\n``` go\nsomething := someType{Name: \"foobar\"}\nInsertSelect(&something,  someType{}, \"all, the, things\")\n```\n. Wouldn't it be better to merge gorp and modl? From what I can see so far they're largely the same, but modl is rewritten to use sqlx instead of database/sql.\nI think almost everyone would benefit if the two projects are merged.\n. I now also see that merging modl and gorp isn't as smart as I initially thought. Although gorp could possibly benefit from some improvements made in modl, I think the main/first goal for the go-gorp organization should be addressing the existing/open issues and PR's.\n\nI've asked @coopernurse to fork go-gorp/gorp back to coopernurse/gorp (if it gets moved), so existing users' code won't break. I've named the organization go-gorp so it is compatible with gopkg.in, but whether or not (and how) to use gopkg.in should first be discussed openly.\n. Also, to be clear: I don't plan to maintain gorp all by myself. I believe it would be best to have multiple maintainers in the go-gorp organization.\n. @begizi @benprew \nAre you still interested in helping with maintaining this project?\n. Great, I'll email you both.\n. We've moved the repository and new maintainers have been added.\nA development mailing list has been opened at https://groups.google.com/forum/#!forum/gorp-dev\n. @mhkt What do you mean? I just checked the audit logs for go-gorp and could not find any unintended invites.\n. Won't this break a lot of existing code out there which are expecting the automagic behavoiur?\n. Maybe we should add a warning message for people expecting the old behavior?\n. I think `readStructColumns` should return just one value. So the detection of the Version field can be removed all together. Also please update the README and add the migration guide.\n\nAnd the PR should be pointed at the `master` branch, not `develop`.\n. Any update on this? We can already merge it in master without affecting v1.\n. @nd2s note that master is unstable and can break your code! I think an option to disable the warning would be a better option. \nOr, (@sqdk), maybe we should fall back to the explicit logger set by `(*DbMap).TraceOn(..)`... \n. I have registered the channel #gorp at freenode. Which do we use?\n. Great\n. I think you shouldn't select a field if it's not going to be scanned into your struct.\nCan you give an example of a case where this problem happens, or maybe provide PR with a failing test case?\n. I'm adding tests about time, also added a parseTime=true run in the automated testing for mysql. #226\nCould you provide a failing test case for this with parseTime=true? \n. I'm not sure we should ignore unused values. There is an issue about generating a select statement with just the fields you need. See #133. Using `select *` is bad practice, especially when not reading all fields.. Furthermore, this PR now also contains `SelectMapCollection()` and other stuff, I guess that is because you used the master branch and added more commits to it for personal use. Do you think a solution for #133 would be sufficient for your use-case?\n. Merged through #277 \n. Hmm I don't think we should log to stdout because some programs use stdout for inter-process communication. Maybe use the Dbmap.logger for this?\n. Maybe it's better to create a migration guide/document where we note all breaking changes between v1 and v2. That way we don't interrupt v1 users, and they will have to go through such a guide anyway when migrating from v1 to v2.\n. Yes! Release as v1.7.1? (patch +1)\n. Created `v1` branch as `gopkg-in-releases` is a strange name. Tagged v1.7.1 which is now the latest v1: http://gopkg.in/gorp.v1\n. I think the `type Executor interface { ..` can be unexported. I don't see a need for this to be exported right now, and would like to keep the API clean.\n. Thanks!\n. I would actually be in favor of only supporting the last 2 minor releases, so 1.3.x and 1.4.x.\nMaybe we should open an issue for this to poll support?\n. Well if we merge this, then all other builds will fail and we'll have to manually inspect what fails.\nSo I'd rather see the travis config updated first to fix the build. I think we can drop support for 1.1 right now, and I'll open a poll issue about the policy.\n. I've changed the .travis.yml already in a different PR to do 1.2 (best effort), 1.3 and 1.4.\n\nI think this PR needs a rebase and squash, it's a bit dirty with all the merge commits.\n. Yes, lets merge it in when build succeeds :smile: \nWhat do you think about adding this functionality as a struct tag option too?\nI think it's good to have a consistent user experience to alter dbmapping options such as primary key and autoincrement and version..\n. Some backstory: this issue originates from #224, where @sqdk noticed that the go1.1 build fails because go-sql-driver/mysql uses a function introduced in go1.2.\n. This poll has been open long enough. I suggest we go ahead with implementing these changes. I'll open a PR.\n. PR is #234 (which is a pretty nice number since it's introducing travis checks for go 1.**2**, 1.**3** and 1.**4** :smile: )\n. gomysql fails when `?parseTime=true` is not set.\n\n```\n--- FAIL: TestDatesTypes (0.20s)\npanic: sql: Scan error on column index 0: unsupported driver -> Scan pair: []uint8 -> *time.Time [recovered]\n    panic: sql: Scan error on column index 0: unsupported driver -> Scan pair: []uint8 -> *time.Time\n```\n\nDoes this mean that, to work with time.Time values, gomysql should always be used with `?parseTime=true`? Or is this a bug on our side?\nI always have `parseTime` it enabled.\n. :+1: \nI suggest we start work on this once the majority of the PR's and issues have been merged and/or closed.\n. Thanks!\n. Thanks. Travis failed because go 1.1 isn't supported by go-mysql anymore (we're dropping support too).\n. You will need to manually format the dates as time.Time uses RFC 3339. Maybe if you wrap time.Time and provide a custom MarshalJSON() function it wlil work, but I have not tried that.\n\nUnrelated to gorp: if you don't want the accounts.json service to be read by javascript code served from servers other than your own (for instance becaues you do auth using basic auth or cookies/session on your web page, and the accounts.json should have access restricted to authenticated users), then don't send an array as root object in json.  Read http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/\n\nI assume this answers your question. If not: feel free to re-open the issue.\n. The tests failed with\n\n```\n--- FAIL: TestCrud (0.01s)\n\ngorp_test.go:1092: val.GetId() was not set on INSERT\n```\n\nAny thoughts why this happens?\n. @meetmauro Can you make the changes requested by @sqdk? If so we can still merge this in in at `v2-phase1` (see #270), otherwise it will be v2.1, and at that point the codebase will have changed a lot!\n. I'll merge right now.\n. Hmm, I think we should stick with the last minor versions for each major version.\nThe minor versions tend to only include bug and security fixes, which might affect us. I think developers should always update to the last minor version of the go major version they're developing for.\n. Sure, looks good! thx :smile: \n. Thanks!\n. @truongminh So you're saying that the returned error should be clearer? We could change this issue to be about that..\n. I agree with @nelsam. This is an implementation detail and might change. We could spec this though.. If we do, it might be best to add a getter method that takes an int and returns the field. It needs to be thought over though, because I wonder what the use case for this would be and it looks like it is adding to API bloat.\n. Note that this is not in the gopkg.in/gorp.v1 yet, we will probably release this in v2.\n. Great addition, thanks!\n. PR was merged via 27556ff8f1124b8aaa7926f11ac7ec2c4d62bf61\n. LGTM but I'm also very tired..\nMaybe squash the commits for a cleaner history?\nThanks @jsanc623!\n. Merged in 27556ff8f1124b8aaa7926f11ac7ec2c4d62bf61\n. Thanks for addressing this @qrawl.\n\nThe field tag is probably the right place to do this, yes. Although I'm thinking about what would happen when more options are added.\n\nWhat if we define the tag to be something like this:\n\n```\nTag = Name { ','  }\nOption = OptionKey [ ':' OptionValue ]\n```\n\nA valid `OptionKey` would be `size`. Code would look like this:\n\n``` go\ntype SomeTable struct {\n    Firstname string `db:\"firstname,size:1024\"`\n}\n```\n\nImplementation could be a simple `for _, option := range cArguments[1:]`, then split on \":\", then a `switch` on optionKey.\n\nWhat do you think @qrawl @nelsam ?\n. @qrawl, apologies for not looking at this, must've totally missed the notification.\nI have no knowledge of SQL Server at all, but since you wrote the dialect I trust the changes are good and will merge them now.\nWould you like to come on board as a collaborator to maintain the SQL Server part and, if you have time for it, more?\n. @qrawl  In issue #245 you wrote: \n\n```\nIt seems like you can't use a nvchar(max) field as primary key. Do you have such experience?\n```\n\nIs this relevant to this PR? Does this mean that it shouldn't return nvchar(max) when the field is used as primary key?\n. Ah okay, if behavior hasn't changed with this PR, then lets leave it this way.\nCould it be interesting to add in documentation?\n. I assume you mean the sql-server test hangs indefinitely on travis?\nCould we maybe use build flags to enable/disable sql-server in the tests?\n. @qrawl If you think this is still good to go, please go ahead and add it. Great to have sqlserver in automated tests!\n. It would be good to have this, it would help a lot with the testing of the upcoming changes and cleanup.\n. Agreed :+1:\n. So you're saying that older versions of go-sqlite3 returns the value as string instead of []byte?\nWith which versions do you encounter this behaviour?\n. Okay cool. We'll pull it up if it becomes an issue again.\n. @fbjork does nelsam's reply answer your question?\n. Looks good!\n. Good catch, thanks!\n. ping @TheInsideMan \n. Merged #264\n. Thanks :+1: \n. In MySQL, a varchar can't exceed 255 characters. That looks like your problem @furio. \n\n@cs2dsb you are having a different issue. Please open a new issue with a compiling example as @qrawl asked so we can reproduce and fix your problem.\n. @cs2dsb Thanks!\n\n@furio I misread, you're using sqlite3, not MySQL. And the table name is also wrong.. This really seems like an old version of gorp.. Is the binary built with the same `gopath` as where you run `go get -u`?\n. @furio I know what's going on. v1 doesn't have the size tag at all. It was added to the master branch recently and is scheduled to be released with v2. I wouldn't recommend using the master branch in production or any other software that should be stable. We're going to clean up the codebase and work towards v2 on the master branch. v1 won't change in the meantime.\n\nSqlite doesn't enforce the size set to varchar(N), according to the docs a varchar(50) could contain 10-milion chars. If you need enforced size, I suggest doing this manually at application level.\n\nI assume this answers your question. If you have any further questions please do no hesitate to re-open this issue again.\n. Thanks @cs2dsb for creating a detailed report\n. Oops! Well we did say master was the non-stable development branch.. \n. I've just assigned all open issues/pr's that are not a question to a milestone as defined above. All preparations are done, `v2-phase1` has started.\n. Phase 1 has been completed! :cake:\n. @fwang2002 could you please explain a bit more detailed what you mean by this? You want to set the auto-increment starting point on a table when it's created?\n. Right. Although I believe that reserving numbers for special users isn't really a good database design choice, I can see how it can be useful. I think a better example would be order numbers, where it would be nice if each number has the same length and so you start them at one million.\nI think this could be added to the autoincrement tag; `db:\"autoincrement:1000\"`.\nThis issue will come up again after v2 was released (see #270).\n. I totally agree! I dont care much for a stable master branch at this point because of the phase1.. But this should definitly happen in phase3, its essential for a stable v2 release. Maybe Ill just apply this now, still in phase1 (I dont see why not, but its late and I need sleep first).\n\nThere will be a lot more changes in phase3 regarding testing etc.\n. Fixes #218 \n. I've tried some strategies. gocheck seemed nice at first, with the builtin support to run the suite with different contexts. But I found that there is no convenient way to write to logs in which context the test failed.\n\ngoconvey doesn't support contexts out of the box, but it's very easy to add them manually. However, then also the context is not displayed in the `go test` results. Could be done by adding a prefix on each context that is used..\n\nSo, I'm still not really satisfied with either solution..\nWhat we could do too is using any of these above without requiring multiple contexts/dialects in the testing code. Then we'll add a tasks script (I like [slurp](https://github.com/omeid/slurp)) that runs the tests one time for each database we have. We'll need to be able to change the connection string for databases anyway, no-one has the same testing environment, so why bother with contexts IN the tests?\n\n((Sidenote: I would like to have a slurp tasks script anyway to setup and test with databases in docker containers. That should make it really easy to setup, test and destroy with most databases without installing them on the local machine.))\n\nI've created a tmp repo for these tryouts: https://github.com/GeertJohan/gorp-tests\n. Work in progress on shell script alternative, the `gorptool`: https://github.com/GeertJohan/gorp/tree/gorptool/gorptool\n\nAt this time, it can run tests for mysql and postgres and can set up docker containers for mysql and postgres. (`gorptool test all-docker`, run in github.com/go-gorp/gorp folder)\n. LGTM\n. Thanks @bhenderson :+1: \n. Thanks :+1: \n. I think this is best addressed when we have released v2 (https://github.com/go-gorp/gorp/issues/270).\nSadly, development on that has stalled a bit, I hope to find time to continue soon.\n. This PR is not building on travis... A rebase could work?\n. @vinceyuan \n. Sorry for the late late reply.\n\nIt looks like `github.com/mattn/go-sqlite3` dropped go1.2 support, as did we by the way.\nIf you could rebase on master, the tests on travis-ci will be without 1.2.\n. Thanks @vinceyuan !\n. @mauleyzaola Sorry for breaking your build. I hope most people have updated to the v1 on gopkg.in by now. I've actually manually contacted all public projects using gorp and asked them to update to gopkg.in, but I'm sure there are still some private projects using the master branch. I hope updating isn't too much of a problem for you. Cheers!\n. Fixed by #301 \n. Thanks for the feature!\n. Looks good, thanks!\n. I think we need to define what the default actually does. The behaviour for default in db is different from only setting the default in gorp inserts. I think we should just do one, not both.\n. Thanks!\n. We'll have to pick this up in `v2-phase3` (see #270). @siliconsenthil \n. This would be realy usefull. Gorp could ship with a `CamelCaseMapper` and an `UnderscoreMapper`, and anyone could implement a default `mapper`.\n. @meetmauro Can you see if the requested changes can be made to this PR? I'd be happy to add this feature to the codebase.\nIf so, please:\n- Rebase the PR on the latest master\n- Use attributes in the same `db` tag\n- Change `pk` to `primarykey`\n. New PR: #233 \n. I'm not sure if it is smart to allow this. TableMap could (potentially) cache information that is depending on the used dialect. It isn't that bad performance-wise to re-create the TableMap three times. I've put this in milestone v2.1-maybe, so it'll come up again when we get to v2.1.\n. This looks like a nice feature!\n. After looking at this again I think this needs some discussion. I'm not sure wether the use case for a `selectonly` (or rather: `scanonly`) field is large enough. Should be discussed again in phase3.\n. #188 was merged. Closing this issue.\n. #188 didn't address the initial request, which is related to #133.\n. @joeshaw I think this would be a nice feature, but as pointed out by coopernurse it requires to be modified by a method. If you're still interested in this could you please:\n- Add a method to change the field, and regenerate insert plan SQL statement\n- Rebase this PR on the latest master branch\n. @joeshaw If you're not interested anymore, please let us know. So we can either close this issue or work on it ourselves.\n. Better late then never (and because someone else might find this useful):\n\nIt looks like you are using `go-sql-mysql/mysql` and do not have the `parseTime` parameter set to true.\nPlease see: https://github.com/go-sql-driver/mysql/#parsetime\n\nI assume this answers your question, if not: please re-open this issue.\n. Closing this PR, it's continued as #201 .\n. Closing this. gorp has very basic create/drop table support which is very handy to quickly setup a database, but migrations go a lot further. Currently it is out of scope, there are a lot of tools better qualified for this. (goose, sql-migrate)\n. I agree with coopernurse that this wouldn't be very convenient. The goal with gorp is to map values into a struct or slice type.\nClosing this issue.\n. So what we want here is more freedom with types (`type myString string`), and gorp being smart enough to see that it's actually a string..\n\nAnother 'solution' might be a good explanation on how to use custom types with gorp (driver.Valuer).\n. Related to #192 \n. Fixed in #300 \n. I agree. Required columns should be specified explicitly. What could be added though is a method to automatically query all required columns based on the struct.\n. Related to #133 \n. There is some overlapping with other tools such as gorq (extension for gorp) and squirrel. So we should also consider adding support for one of those. For now I'm post-phoning this PR to v2.1 (see #270).\n. The implementation in #174 is very interesting, we could definitely use that to implement this in `v2.1`.\n. I agree with @tobz, closing this issue. @rvenugopal please re-open this issue if you feel there is a valid use case for this.\n. Gorp isn't meant to be a sql generation package. Having said that: I would still like to consider this basic use case. Gorp also generates the insert statement, so why not a simple sql select.. The select part could be cached for performance, and only the where needs to be appended.\nThinking out loud: `Select(&tbl, \"WHERE a = 42\")`\n. @go-gorp/maintainers what do you think?\n. #62 contains some good thoughts on how we might implement this.\n. I'm splitting your issue into two issues.\n. Why do you have two tables with different names having the same schema? Is it maybe meant for some load balancing purposes? That would also explain the need for a custom `sql.DB`.\n. I'm not sure if we should add load balancing features to gorp. But lets think about this after v2 was released (see #270).\n. Yes this could be a good addition. I'm setting this for v2.1-maybe, please see #270 \n. Related to #139 \n. I'll close this issue and continue with #139 \n. So, it looks like time.Time handling for postgres requires some more work.\n\n@gwitmond Would you be able to clean up this PR a bit (remove the README.md modification and use `timestamp with time zone`?) I'd be happy to merge it in!\n\n@manugarri Could you open a separate issue for your problem, preferably with a failing test case?\n. Time was already added.\nAdded NullTime in f2a9a30809d67ca10d35893c49df78ba89af6f99\nAdding tests in #226.\n. @JonPulfer I'm very interested in this feature, but sadly the PR seems to be messed up a bit.\nI think the feature could be best added in a new `SelectFoobar` method. \nWe're now cleaning up the issue and PR backlog (see #270), so I think this feature would best be added after we're done with that. I think it will require a new PR as at that point code will be separated into multiple files and more changes applied. Keeping this PR open so we will look at it again. Please let me know if you're still interested in seeing this merged.\n. We've stopped using the `develop` branch, all development now takes place at `master`. I think it would be best to wait until we have cleaned up the codebase and have released v2, that will also make development easier for you. We can then work out the API spec.\n. I think we need to take a good look at this, it is very important to make sure gorp is concurrency safe!\n. Superseded by #301, which uses `sync.Once`.\n. Commented-out failing tests have been merged, fix needs to happen in v2-phase3 (#270)\n. It looks like this is still relevant. How to solve this problem?\n. I will merge these in soon, the fix will have to wait until v2-phase1. Please see #270 \n. Nevermind, merging now to the master branch.\n. Merged in 6301df302a3a74f171646fa294d57c17b8e9b822\n. I would be happy to merge this PR, but could you please:\n- Add a test case for varchar vs text\n- Squash commits\n- Rebase this PR on master (we've deprecated the develop branch, sorry)\n\nThanks!\n. I'll merge these now without test case, that will come in v2-phase3 (see #270).\n. Merged as 0ca02be3238d9c48a9ab715870354e7acdf063ba\n. I would still like to see this feature. I think a transaction with select by primary key, then insert or update would work.. \n. \"Upsert\" is a good name, I think it's very descriptive. Any plans to make this work @spencerkimball ?\n. I'm closing this PR for now (see #270). However, I would still like to see this feature so #130 will stay open and there's a good chance I'll re-use code from this PR to add the feature after `v2.0`/#270\n. I agree that the comma is only required to skip the first argument: the field name.\n\n```\nTag = Name { ','  Option }\nOption = OptionKey [ ':' OptionValue ]\n```\n. I'm not sure if gorp should convert a null to a zero int.\nHow do you propose to solve this problem?\n. The query returns null, which is not the same as zero. Use `*int` or a custom type to use with `sql.Scan`.\n#221 might introduce these types into the package.\n. Discussion in #181 \n. We can bring these back in v2.1 after #270 is done.\nThis request is related to #221.\n. Looks good!\n@billmccord  Can you please rebase this PR and base it on master instead of develop? (We've deprecated the develop branch)\n. Thanks, I'm closing this one.\n. Update for followers here: #220 was merged.\n. Could you please share your actual code? That way we can check the code itself, and reproduce the problem.\n. Hi @klaidliadon, thanks for your PR!\n\nCan the `TargetQueryInserter` be an unexpored interface? I don't think it adds value to the exported API.\n. Merged it anyway. Chances are that the dialects are moved to their own packages (#272) so the dialect interface (and friends) need to be exported anyway.\n. Thanks :+1: \n. This PR needs some work, but it's best to merge in at `v2-phase1` (see #270). Merging after phase2 will be a mess..\n. @umisama Please fix the failing tests and rebase this PR on the `master` branch (we've deprecated `develop`, sorry).\n. @umisama  Great! Thanks!\n. Hi @umisama \nThanks for making the changes!\nI want to give this a good test drive before merging. It seems time is a nasty subject (See #226),\nThanks again!\n. This might actually fix time scanning for other drivers too :+1: \n. Great, thanks!\n. Oh, yes you're right! I forgot to check if the PR was aimed at master..\nCould you maybe rebase this on master and open a new PR?\n. Thanks :+1: \n. This PR modifies a lot of code (move from gorp.go to schema.go), which will probably break a lot of other PR's.\n\nI've opened a discussion about how we approach the list of open PR's here: https://groups.google.com/forum/#!topic/gorp-dev/rEsu0efgUfw\n. Hey @rickb777,\n\nThanks for this PR!\nThe last commit (423a897) moves a lot of code from gorp.go to schema.go. I agree with the concept of splitting the code into multiple smaller files, but right now it will probably break a lot of open PR's. Can you undo the moving of code and squash/overwrite that commit? We've also deprecated the `develop` branch, but you should be able to rebase on `master` without any problems.\n\nWe will split the code in separate files once the open PR's are closed.\n. Hi @rickb777\nAny chance you can work a bit more on this so we can merge it into master?\n. This will need some work and manual merging before it can be added. Could be done in `v2-phase3` (see #270).\n. @ipartner Not that I am aware of. I haven't bumped into this issue myself yet, could you maybe share example code to reproduce the problem?\n. Please add test cases and re-open this PR on master branch (we've deprecated the `develop` branch)\n. @zallwu If you could add a testcase and docs, as well as rebase to master, then we could merge this at `v2-phase1` (see #270). Otherwise we'll have to postphone it to `v2.1`, at which point the codebase will have changed a lot.\n. Looked at the code again. I think it would be better to add default as a part of the db tag:\n`db:\"name, default:uuid()\"`\n. I'll merge and add open an issue so we can work it out in phase3.\n. Merged at 96583e83d36be671cc76657afdc7f61ba5986661\n. Actually added the default option to the db tag just now..\n. Would `InsertSelect` be a good feature? e.g.:\n\n```\nInsertSelect(&insertStruct, &selectStruct, \"returning stmt\")\n```\n\nSo @nelsam's example would become:\n\n``` go\nsomething := someType{Name: \"foobar\"}\nInsertSelect(&something,  someType{}, \"all, the, things\")\n```\n. Wouldn't it be better to merge gorp and modl? From what I can see so far they're largely the same, but modl is rewritten to use sqlx instead of database/sql.\nI think almost everyone would benefit if the two projects are merged.\n. I now also see that merging modl and gorp isn't as smart as I initially thought. Although gorp could possibly benefit from some improvements made in modl, I think the main/first goal for the go-gorp organization should be addressing the existing/open issues and PR's.\n\nI've asked @coopernurse to fork go-gorp/gorp back to coopernurse/gorp (if it gets moved), so existing users' code won't break. I've named the organization go-gorp so it is compatible with gopkg.in, but whether or not (and how) to use gopkg.in should first be discussed openly.\n. Also, to be clear: I don't plan to maintain gorp all by myself. I believe it would be best to have multiple maintainers in the go-gorp organization.\n. @begizi @benprew \nAre you still interested in helping with maintaining this project?\n. Great, I'll email you both.\n. We've moved the repository and new maintainers have been added.\nA development mailing list has been opened at https://groups.google.com/forum/#!forum/gorp-dev\n. @mhkt What do you mean? I just checked the audit logs for go-gorp and could not find any unintended invites.\n. Won't this break a lot of existing code out there which are expecting the automagic behavoiur?\n. Maybe we should add a warning message for people expecting the old behavior?\n. I think `readStructColumns` should return just one value. So the detection of the Version field can be removed all together. Also please update the README and add the migration guide.\n\nAnd the PR should be pointed at the `master` branch, not `develop`.\n. Any update on this? We can already merge it in master without affecting v1.\n. @nd2s note that master is unstable and can break your code! I think an option to disable the warning would be a better option. \nOr, (@sqdk), maybe we should fall back to the explicit logger set by `(*DbMap).TraceOn(..)`... \n. I have registered the channel #gorp at freenode. Which do we use?\n. Great\n. I think you shouldn't select a field if it's not going to be scanned into your struct.\nCan you give an example of a case where this problem happens, or maybe provide PR with a failing test case?\n. I'm adding tests about time, also added a parseTime=true run in the automated testing for mysql. #226\nCould you provide a failing test case for this with parseTime=true? \n. I'm not sure we should ignore unused values. There is an issue about generating a select statement with just the fields you need. See #133. Using `select *` is bad practice, especially when not reading all fields.. Furthermore, this PR now also contains `SelectMapCollection()` and other stuff, I guess that is because you used the master branch and added more commits to it for personal use. Do you think a solution for #133 would be sufficient for your use-case?\n. Merged through #277 \n. Hmm I don't think we should log to stdout because some programs use stdout for inter-process communication. Maybe use the Dbmap.logger for this?\n. Maybe it's better to create a migration guide/document where we note all breaking changes between v1 and v2. That way we don't interrupt v1 users, and they will have to go through such a guide anyway when migrating from v1 to v2.\n. Yes! Release as v1.7.1? (patch +1)\n. Created `v1` branch as `gopkg-in-releases` is a strange name. Tagged v1.7.1 which is now the latest v1: http://gopkg.in/gorp.v1\n. I think the `type Executor interface { ..` can be unexported. I don't see a need for this to be exported right now, and would like to keep the API clean.\n. Thanks!\n. I would actually be in favor of only supporting the last 2 minor releases, so 1.3.x and 1.4.x.\nMaybe we should open an issue for this to poll support?\n. Well if we merge this, then all other builds will fail and we'll have to manually inspect what fails.\nSo I'd rather see the travis config updated first to fix the build. I think we can drop support for 1.1 right now, and I'll open a poll issue about the policy.\n. I've changed the .travis.yml already in a different PR to do 1.2 (best effort), 1.3 and 1.4.\n\nI think this PR needs a rebase and squash, it's a bit dirty with all the merge commits.\n. Yes, lets merge it in when build succeeds :smile: \nWhat do you think about adding this functionality as a struct tag option too?\nI think it's good to have a consistent user experience to alter dbmapping options such as primary key and autoincrement and version..\n. Some backstory: this issue originates from #224, where @sqdk noticed that the go1.1 build fails because go-sql-driver/mysql uses a function introduced in go1.2.\n. This poll has been open long enough. I suggest we go ahead with implementing these changes. I'll open a PR.\n. PR is #234 (which is a pretty nice number since it's introducing travis checks for go 1.**2**, 1.**3** and 1.**4** :smile: )\n. gomysql fails when `?parseTime=true` is not set.\n\n```\n--- FAIL: TestDatesTypes (0.20s)\npanic: sql: Scan error on column index 0: unsupported driver -> Scan pair: []uint8 -> *time.Time [recovered]\n    panic: sql: Scan error on column index 0: unsupported driver -> Scan pair: []uint8 -> *time.Time\n```\n\nDoes this mean that, to work with time.Time values, gomysql should always be used with `?parseTime=true`? Or is this a bug on our side?\nI always have `parseTime` it enabled.\n. :+1: \nI suggest we start work on this once the majority of the PR's and issues have been merged and/or closed.\n. Thanks!\n. Thanks. Travis failed because go 1.1 isn't supported by go-mysql anymore (we're dropping support too).\n. You will need to manually format the dates as time.Time uses RFC 3339. Maybe if you wrap time.Time and provide a custom MarshalJSON() function it wlil work, but I have not tried that.\n\nUnrelated to gorp: if you don't want the accounts.json service to be read by javascript code served from servers other than your own (for instance becaues you do auth using basic auth or cookies/session on your web page, and the accounts.json should have access restricted to authenticated users), then don't send an array as root object in json.  Read http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/\n\nI assume this answers your question. If not: feel free to re-open the issue.\n. The tests failed with\n\n```\n--- FAIL: TestCrud (0.01s)\n\ngorp_test.go:1092: val.GetId() was not set on INSERT\n```\n\nAny thoughts why this happens?\n. @meetmauro Can you make the changes requested by @sqdk? If so we can still merge this in in at `v2-phase1` (see #270), otherwise it will be v2.1, and at that point the codebase will have changed a lot!\n. I'll merge right now.\n. Hmm, I think we should stick with the last minor versions for each major version.\nThe minor versions tend to only include bug and security fixes, which might affect us. I think developers should always update to the last minor version of the go major version they're developing for.\n. Sure, looks good! thx :smile: \n. Thanks!\n. @truongminh So you're saying that the returned error should be clearer? We could change this issue to be about that..\n. I agree with @nelsam. This is an implementation detail and might change. We could spec this though.. If we do, it might be best to add a getter method that takes an int and returns the field. It needs to be thought over though, because I wonder what the use case for this would be and it looks like it is adding to API bloat.\n. Note that this is not in the gopkg.in/gorp.v1 yet, we will probably release this in v2.\n. Great addition, thanks!\n. PR was merged via 27556ff8f1124b8aaa7926f11ac7ec2c4d62bf61\n. LGTM but I'm also very tired..\nMaybe squash the commits for a cleaner history?\nThanks @jsanc623!\n. Merged in 27556ff8f1124b8aaa7926f11ac7ec2c4d62bf61\n. Thanks for addressing this @qrawl.\n\nThe field tag is probably the right place to do this, yes. Although I'm thinking about what would happen when more options are added.\n\nWhat if we define the tag to be something like this:\n\n```\nTag = Name { ','  }\nOption = OptionKey [ ':' OptionValue ]\n```\n\nA valid `OptionKey` would be `size`. Code would look like this:\n\n``` go\ntype SomeTable struct {\n    Firstname string `db:\"firstname,size:1024\"`\n}\n```\n\nImplementation could be a simple `for _, option := range cArguments[1:]`, then split on \":\", then a `switch` on optionKey.\n\nWhat do you think @qrawl @nelsam ?\n. @qrawl, apologies for not looking at this, must've totally missed the notification.\nI have no knowledge of SQL Server at all, but since you wrote the dialect I trust the changes are good and will merge them now.\nWould you like to come on board as a collaborator to maintain the SQL Server part and, if you have time for it, more?\n. @qrawl  In issue #245 you wrote: \n\n```\nIt seems like you can't use a nvchar(max) field as primary key. Do you have such experience?\n```\n\nIs this relevant to this PR? Does this mean that it shouldn't return nvchar(max) when the field is used as primary key?\n. Ah okay, if behavior hasn't changed with this PR, then lets leave it this way.\nCould it be interesting to add in documentation?\n. I assume you mean the sql-server test hangs indefinitely on travis?\nCould we maybe use build flags to enable/disable sql-server in the tests?\n. @qrawl If you think this is still good to go, please go ahead and add it. Great to have sqlserver in automated tests!\n. It would be good to have this, it would help a lot with the testing of the upcoming changes and cleanup.\n. Agreed :+1:\n. So you're saying that older versions of go-sqlite3 returns the value as string instead of []byte?\nWith which versions do you encounter this behaviour?\n. Okay cool. We'll pull it up if it becomes an issue again.\n. @fbjork does nelsam's reply answer your question?\n. Looks good!\n. Good catch, thanks!\n. ping @TheInsideMan \n. Merged #264\n. Thanks :+1: \n. In MySQL, a varchar can't exceed 255 characters. That looks like your problem @furio. \n\n@cs2dsb you are having a different issue. Please open a new issue with a compiling example as @qrawl asked so we can reproduce and fix your problem.\n. @cs2dsb Thanks!\n\n@furio I misread, you're using sqlite3, not MySQL. And the table name is also wrong.. This really seems like an old version of gorp.. Is the binary built with the same `gopath` as where you run `go get -u`?\n. @furio I know what's going on. v1 doesn't have the size tag at all. It was added to the master branch recently and is scheduled to be released with v2. I wouldn't recommend using the master branch in production or any other software that should be stable. We're going to clean up the codebase and work towards v2 on the master branch. v1 won't change in the meantime.\n\nSqlite doesn't enforce the size set to varchar(N), according to the docs a varchar(50) could contain 10-milion chars. If you need enforced size, I suggest doing this manually at application level.\n\nI assume this answers your question. If you have any further questions please do no hesitate to re-open this issue again.\n. Thanks @cs2dsb for creating a detailed report\n. Oops! Well we did say master was the non-stable development branch.. \n. I've just assigned all open issues/pr's that are not a question to a milestone as defined above. All preparations are done, `v2-phase1` has started.\n. Phase 1 has been completed! :cake:\n. @fwang2002 could you please explain a bit more detailed what you mean by this? You want to set the auto-increment starting point on a table when it's created?\n. Right. Although I believe that reserving numbers for special users isn't really a good database design choice, I can see how it can be useful. I think a better example would be order numbers, where it would be nice if each number has the same length and so you start them at one million.\nI think this could be added to the autoincrement tag; `db:\"autoincrement:1000\"`.\nThis issue will come up again after v2 was released (see #270).\n. I totally agree! I dont care much for a stable master branch at this point because of the phase1.. But this should definitly happen in phase3, its essential for a stable v2 release. Maybe Ill just apply this now, still in phase1 (I dont see why not, but its late and I need sleep first).\n\nThere will be a lot more changes in phase3 regarding testing etc.\n. Fixes #218 \n. I've tried some strategies. gocheck seemed nice at first, with the builtin support to run the suite with different contexts. But I found that there is no convenient way to write to logs in which context the test failed.\n\ngoconvey doesn't support contexts out of the box, but it's very easy to add them manually. However, then also the context is not displayed in the `go test` results. Could be done by adding a prefix on each context that is used..\n\nSo, I'm still not really satisfied with either solution..\nWhat we could do too is using any of these above without requiring multiple contexts/dialects in the testing code. Then we'll add a tasks script (I like [slurp](https://github.com/omeid/slurp)) that runs the tests one time for each database we have. We'll need to be able to change the connection string for databases anyway, no-one has the same testing environment, so why bother with contexts IN the tests?\n\n((Sidenote: I would like to have a slurp tasks script anyway to setup and test with databases in docker containers. That should make it really easy to setup, test and destroy with most databases without installing them on the local machine.))\n\nI've created a tmp repo for these tryouts: https://github.com/GeertJohan/gorp-tests\n. Work in progress on shell script alternative, the `gorptool`: https://github.com/GeertJohan/gorp/tree/gorptool/gorptool\n\nAt this time, it can run tests for mysql and postgres and can set up docker containers for mysql and postgres. (`gorptool test all-docker`, run in github.com/go-gorp/gorp folder)\n. LGTM\n. Thanks @bhenderson :+1: \n. Thanks :+1: \n. I think this is best addressed when we have released v2 (https://github.com/go-gorp/gorp/issues/270).\nSadly, development on that has stalled a bit, I hope to find time to continue soon.\n. This PR is not building on travis... A rebase could work?\n. @vinceyuan \n. Sorry for the late late reply.\n\nIt looks like `github.com/mattn/go-sqlite3` dropped go1.2 support, as did we by the way.\nIf you could rebase on master, the tests on travis-ci will be without 1.2.\n. Thanks @vinceyuan !\n. @mauleyzaola Sorry for breaking your build. I hope most people have updated to the v1 on gopkg.in by now. I've actually manually contacted all public projects using gorp and asked them to update to gopkg.in, but I'm sure there are still some private projects using the master branch. I hope updating isn't too much of a problem for you. Cheers!\n. Fixed by #301 \n. Thanks for the feature!\n. Looks good, thanks!\n. I think we need to define what the default actually does. The behaviour for default in db is different from only setting the default in gorp inserts. I think we should just do one, not both.\n. Thanks!\n. ",
    "schmorrison": "I am new to Go and programming in general but could we, instead of defining an array column type, create a related table and include a reference key from the parent table. For example: \r\n\r\n```\r\nParent struct {\r\n  Id int\r\n  Name String\r\n  Children []Child\r\n}\r\n\r\nChild struct {\r\n  Id int\r\n  Name String\r\n}\r\n\r\ndbMap.AddTableWithName(Parent{}, \"parent\").SetKeys(true, \"Id\")\r\ndbMap.AddColMap(\"Id\")\r\ndbMap.AddColMap(\"Name\")\r\ndbMap.AddColMap(\"Children\").SetChild(true)\r\n\r\ndbMap.AddTableWithName(Child{}, \"child_of_parent\").SetParentStruct(true, \"parent\")\r\ndbMap.AddColMap(\"Id\")\r\ndbMap.AddColMap(\"Name\")\r\ndbMap.AddColMap(\"ParentRef\").SetParentRef(true)\r\n\r\nlist := &Parent{}\r\ndbMap.Select(list, \"select * from parent where Name = ?\", \"testParent\")\r\n```\r\n\r\nI dont know anything about the bolts underpinning gorp, but using the field names of the Parent structure, and just create a new table called child_of_parent with a column that has the reference id of the Parent. Whenever select parent is called gorp knows that the []child is fulfilled from the table child_of_parent.\r\n\r\nOr, optionally, because that would require each Child entry to be directly related to one Parent, including a matching parameter that pulls all children that have a value that matches in a particular column and fill the internal slice with that.\r\n\r\n```\r\nlist := &Parent{}\r\ndbMap.SetSelectChild(list.Children, \"select * from child_of_parent where Name = ?\", \"testChild\")\r\ndbMap.Select(list, \"select * from parent where Name = ?\", \"testParent\")\r\n```\r\nThough that would be quite like a normal two line anyway.\r\n\r\nNot sure how gorp would implement that idiomatically, just spit balling. Not very hard to write a helper to do that for me and just SetTransient(true) on the parent structure. \r\n\r\nschmorrison. I am new to Go and programming in general but could we, instead of defining an array column type, create a related table and include a reference key from the parent table. For example: \r\n\r\n```\r\nParent struct {\r\n  Id int\r\n  Name String\r\n  Children []Child\r\n}\r\n\r\nChild struct {\r\n  Id int\r\n  Name String\r\n}\r\n\r\ndbMap.AddTableWithName(Parent{}, \"parent\").SetKeys(true, \"Id\")\r\ndbMap.AddColMap(\"Id\")\r\ndbMap.AddColMap(\"Name\")\r\ndbMap.AddColMap(\"Children\").SetChild(true)\r\n\r\ndbMap.AddTableWithName(Child{}, \"child_of_parent\").SetParentStruct(true, \"parent\")\r\ndbMap.AddColMap(\"Id\")\r\ndbMap.AddColMap(\"Name\")\r\ndbMap.AddColMap(\"ParentRef\").SetParentRef(true)\r\n\r\nlist := &Parent{}\r\ndbMap.Select(list, \"select * from parent where Name = ?\", \"testParent\")\r\n```\r\n\r\nI dont know anything about the bolts underpinning gorp, but using the field names of the Parent structure, and just create a new table called child_of_parent with a column that has the reference id of the Parent. Whenever select parent is called gorp knows that the []child is fulfilled from the table child_of_parent.\r\n\r\nOr, optionally, because that would require each Child entry to be directly related to one Parent, including a matching parameter that pulls all children that have a value that matches in a particular column and fill the internal slice with that.\r\n\r\n```\r\nlist := &Parent{}\r\ndbMap.SetSelectChild(list.Children, \"select * from child_of_parent where Name = ?\", \"testChild\")\r\ndbMap.Select(list, \"select * from parent where Name = ?\", \"testParent\")\r\n```\r\nThough that would be quite like a normal two line anyway.\r\n\r\nNot sure how gorp would implement that idiomatically, just spit balling. Not very hard to write a helper to do that for me and just SetTransient(true) on the parent structure. \r\n\r\nschmorrison. ",
    "nelsam": "@schmorrison That's a different issue.  This issue is specifically about slices of database-supported values, which are generally accepted as SQL arrays.\r\n\r\nThe issue of supporting first-class joins is something I've implemented in a fork, but the code is very complex, and I don't trust directly merging it in.  I need to find some time to really sit down and work on it to make sure it's fully tested.. An empty string is not a null string - they are considered two different values in the database *and* in go, and plenty of code relies on checking for `null` as compared to an empty string.  `null` often means \"not yet assigned\", where empty string often means \"assigned as an empty string\".\r\n\r\nIf you just feel like `sql.NullString` is cumbersome, use `*string` (pointer to string).  The pointer will be `null` if the database value is null; if the value in the database is an empty string, then the pointer will be non-nil but the string value will be empty.\r\n\r\nIf you just don't like doing more than one comparison (which the pointer doesn't really solve), but empty string and null are equivalent in your database, you can implement `sql.Scanner` and `driver.Valuer` in a custom type to use in your struct fields; something like the following:\r\n\r\n```go\r\npackage foo\r\n\r\nimport (\r\n    \"database/sql\"\r\n    \"database/sql/driver\"\r\n)\r\n\r\ntype NullToEmptyString string\r\n\r\nfunc (n NullToEmptyString) Value() (driver.Value, error) {\r\n    return string(n), nil\r\n}\r\n\r\nfunc (n *NullToEmptyString) Scan(v interface{}) error {\r\n    if v == nil {\r\n        *n = \"\"\r\n        return nil\r\n    }\r\n    s, ok := v.(string)\r\n    if !ok {\r\n        return fmt.Errorf(\"Cannot scan value %v: expected string type, got %T\", v, v)\r\n    }\r\n    *n = NullToEmptyString(s)\r\n    return nil\r\n}\r\n```. @coopernurse did you get a chance to review this?  Is there something you'd like me to change about it?  Looking over the code with my slightly less rudimentary knowledge of Go, I can see where some performance improvements could be made (e.g. if no embedded struct has been found yet, there's no reason to loop through columns looking for values to overwrite), if that's the reason that this hasn't yet been merged.  I could set up some benchmarks and try to change the code to ensure that performance isn't affected unless fields are actually being overridden.\n\nI'm currently importing our forked version of gorp in our production code at Radiobox and I'd rather not keep doing that unless I absolutely have to, so let me know if I need to make any changes.\n. Will do.  Thanks!\n\nI'm struggling to remember where I'm using this, but I think I actually based the tests that I wrote on my production code, so if the tests pass, my production code should be working.  I'll pull it into my fork, though.\n. Everything's working fine here.  I remembered which models needed my patch and made sure to do some inserts and selects against them.  No issues so far.\n. https://groups.google.com/forum/#!topic/golang-dev/6RtCsSDdBzk\n\n^ Looks like you're right about them being from exp/sql.  I see no reason to keep them around unless you want to continue supporting Go versions <1.0.  And even then, I would think you could just make a go0 git tag (assuming this even worked prior to Go 1):\n\n\"When checking out or updating a package, get looks for a branch or tag that matches the locally installed version of Go. The most important rule is that if the local installation is running version \"go1\", get searches for a branch or tag named \"go1\". If no such version exists it retrieves the most recent version of the package.\"\n. In case it helps, I've got a [project (which I've named gorq)](https://github.com/nelsam/gorq), which imports and extends gorp's functionality with a query DSL.  It was built to handle some of these sorts of issues (the whole project stems from a function I wrote to generate column names for use in queries).  It's new, kind of complicated, doesn't have the most useful error messages, needs some cleanup, and the test coverage isn't very solid yet; but it's being used actively on at least four projects (all of which are using postgresql).\n\nThe basic syntax of queries becomes (as an example):\n\n``` go\ntype Foo struct {\n  ID int\n  Bar Bar `db:\"bar_id\"` // Bar.ID populated with bar_id using sql.Scanner or a TypeConverter\n  Baz string\n}\n\nfoos := []Foo{}\nref := Foo{}\nerr := dbMap.Query(&ref).\n  Where().\n  Equal(&ref.Baz, \"public\").\n  SelectToTarget(&foos)\n```\n\nIt uses references quite a bit for figuring out column names (for input values, it will usually use the column name of a field if the value is equal to a field's address), which isn't exactly ideal... but I couldn't think of anything better at the time.  Still, it's a start.\n\nMore complicated queries (e.g. needing `OR` in the where clause, or using joins) are supported, but the syntax isn't always as clean as the above.  For example:\n\n``` go\nfoos = []Foo{}\nerr = dbMap.Query(&ref).\n  Join(&ref.Bar).On().\n  Equal(&ref.Bar, &ref.Bar.ID).\n  Where().\n  Greater(&ref.Bar.Rank, 3).\n  SelectToTarget(&foos)\n\nfoos = []Foo{}\nfilter := filters.Or(filters.Equal(&ref.Bar, someAdminBarID), filters.Equal(&ref.Baz, \"public\"))\nerr = dbMap.Query(&ref).\n  Where(filter).\n  SelectToTarget(&foos)\n```\n\nI really wanted to have better test coverage before mentioning it to anyone else ... but I thought it might help anyone who's running in to this issue, and I can't hide forever.\n\nBy the way, my two cents, for what they're worth: `select *` is code smell, and discarding data (even via an option that defaults to off) is dangerous.  But my opinion's probably obvious from the fact that I wrote a pretty massive extension to gorp, in part to avoid using `select *`.\n. @recht fetching metadata is done through `select` statements in postgres.  There are shortcuts in the `psql` CLI, but they all run select statements under the covers.\r\n\r\nThat said, if/when I find time to actually work on a new version of gorp in the future, I wouldn't mind adding this as a specific flag you can pass to queries.  Something along the lines of the following might make sense:\r\n\r\n```\r\nres, err := dbmap.Statement(\"show slave status\")\r\nif err != nil {\r\n    // you know the drill\r\n}\r\nres.IgnoreMissing().Unmarshal(&slaveMeta)\r\n```\r\n\r\nWould that cover the edge case well enough for you?. Sorry for the long wait.  Merged.  Reopen if this needs anything else.\n. Looks like the build is only failing because of the problems solved by #154.  I ran the sqlite test (the one that failed) locally after fixing that issue (I'm not going to commit the code with that fix, for obvious reasons), and it all passed.\n. Awesome, thanks.\n. This might help you guys.  However, just wanted to mention, the `TypeDef` method implements an interface that I haven't quite made a PR for yet, but it's only used during a `CREATE TABLE` statement (or during automated migration, which is yet another PR I haven't made yet).  As long as your column is already defined properly, this _should_ work for `geography` types (I didn't feel like fiddling with `geometry` types, although I'm sure the solution is similar).\n\nhttps://github.com/nelsam/gorq/blob/master/extensions/postgis.go\n\nFeel free to copy whatever code you can make use of, or just import the package and use it from there.  If you want to import the package and use the query language I've implemented in my little extension, the syntax of querying using radius values is something like:\n\n``` go\ntype someModel struct {\n  SomeGeoField extensions.Geography\n}\n\ngorqMap := &gorq.DbMap{DbMap:*dbMap}\nm := someModel{}\ng := extensions.Geography{Lat: someLat, Lng: someLng}\nresults, err := gorqMap.Query(&someModel).\n  Where().\n  Filter(extensions.WithinMeters(&someModel.SomeGeoField, g, 50).\n  OrderBy(extensions.Distance(&someModel.SomeGeoField, g), \"ASC\").\n  Select()\n```\n. Another thing: the idiomatic thing for options seems to be that options _always_ follow a comma.  For example:\n\n``` go\ntype Foo struct {\n    Bar string `db:\",pkey,size:50\"`\n}\n```\n\nGenerally, it seems that the initial comma is required; should we be following that style?\n\nAlso, I'd like to consider an option registration framework ... actually, I'll just link to what I wrote for a different project: https://github.com/nelsam/requests/blob/master/tags.go\n\nIn that file, you can see how I allow users of the library to register their own options.  It allows for a _lot_ more flexibility, especially for situations where someone needs an option that the library won't support natively (for example, if someone needs an option that isn't useful in any database engine other than the one they're using, it might not be something we want to add to gorp directly).  It also just helps reduce code bloat as we add more options to the library.\n\nGranted, that may be something for another PR, later on.  Thoughts?\n. @qrawl Sure, make sense.\n\nAs to the third party library: I don't want to use a third party library to parse it, I was just linking the code as an example of how we might allow users of gorp to register their own options.  Obviously, our option function would have a different signature (maybe `func(value string, col *ColumnMap) error` - allow the option function to modify the column map as it needs to based on the value), but something _similar_ to the code I linked would be nice, for allowing users to register options that we don't support officially.\n. For the test, I tried using time.Time (since that was where my problem in my codebase is), but the \"mysql\" driver doesn't seem to like time.Time when running Get().  Every other driver (\"postgres\", \"gomysql\", \"sqlite\") works just fine, but \"mysql\" fails.  It creates the table with the right syntax, and insert seems to work, but Get() fails with `sql: Scan error on column index 1: unsupported driver -> Scan pair: []uint8 -> *time.Time` - even though the table is created with a column type of datetime.\n\nI tried using other types (int64, string, etc), but the drivers just silently converted those types back and forth, so the test would always succeed, even without the fix.\n\nBasically, the test I've included is the only test I tried that produces the error I was seeing without my fix, and is solved by my fix.  However, for it to pass, I have to skip it when the driver being used is \"mysql\" (\"gomysql\" works just fine).\n. @marconi Generally, `gorp` doesn't like to be a query generation library, so if you need something other than what gorp's `Insert` does, you can run something more like `results, err := gorp.Select(someType{}, \"insert into something (stuff) values (things) returning (all, the, things)\")`.\n\nAlternatively, if you'd like a library to generate queries, I've written an extension to gorp that has been used fairly thoroughly on a few projects (albeit only with postgres).  I don't think I've implemented `returning`, but it's a relatively simple update.  If you're interested in checking it out, it's currently [here](http://github.com/nelsam/gorq).\n. I agree with supporting the latest two versions.  Anything more than that is going to hit us with some pretty ugly limits in the future.\n. Alternatively:\n\n``` go\ntype someDialect struct {\n  // stuff\n}\n\nfunc SomeDialect() Dialect {\n  return someDialect{}\n}\n```\n. Not necessarily.  TableMap.Columns is a slice of all detected columns - typically in the order you would expect, but you shouldn't think of it as a 1-to-1 mapping.  For example:\n\n``` go\ntype Foo struct {\n    Bacon string // this is tableMap.Colums[0] for the Bar type\n    Eggs int64 // this is tableMap.Columns[1] for the Bar type\n}\n\ntype Bar struct {\n    Foo // this is reflect.TypeOf(Bar{}).Field(0)\n    Toast float32 // this is tableMap.Columns[2] and reflect.TypeOf(Bar{}).Field(1)\n}\n```\n\nI'm undecided on whether or not you should rely on the column order, so I guess (at least for now) I would say you should consider it an implementation detail.  @GeertJohan do you have any thoughts?\n. Quick thought: Could we maybe add a note about `Dialect.BindVar`?  Something like:\n\n`Alternatively, use dbMap.Dialect.BindVar(varIdx) to get the proper variable binding for your dialect.`\n. Cool, thanks.  This looks good to me; but I haven't had much sleep, so I don't want to merge it until I'm fully woken up.\n. @jsanc623 It looks like your squash didn't quite work - the history still contains all of the previous commits, as well.  Can you try again following [this guide](http://eli.thegreenplace.net/2014/02/19/squashing-github-pull-requests-into-a-single-commit)?\n. @GeertJohan I like your definition.  I use something sorta similar (something like `db:\"firstname,size=1024\"`) for some of my other code.  I also set my code to use `true` as the default value, e.g. `db:\"firstname,not-null\"` would parse the `not-null` option the same as if it were `not-null=true`.\n\nI think something similar would be good here (`:` works for me - it looks a little cleaner than `=`, anyway).\n. Hmm ... Honestly, I'm not sure if any of us use SQL Server.  I certainly don't - I only know the bare minimum required to convert SQL Server DBs to something else.\n\nIt's possible that all of us are waiting for someone else to handle the SQL Server tickets, because we all think one of the others knows SQL Server better than we do.\n. Yeah, I'm not saying anything against merging it, just trying to explain why it may be that none of us have gotten to it yet.  I'm not yet comfortable merging things that I have no knowledge of.  :)\n\n@GeertJohan I've got no issues with merging this.  What do you think?\n. You can implement [`\"database/sql\".Scanner`](http://golang.org/pkg/database/sql/#Scanner) and [`\"database/sql/driver\".Valuer`](http://golang.org/pkg/database/sql/driver/#Valuer) to create your own json type.  `Value()` should spit out the json string; `Scan()` should take the json string from the DB and unmarshal it to your type.\n. FYI, `BEGIN` opens a transaction, then `COMMIT` closes the transaction (which, I believe, closes the current \"session\", reverting that timeout) - you probably don't want that.  Furthermore, even if you set your session's `statement_timeout` outside of a transaction, Go's `database/sql` library uses a connection pool under the covers - meaning that the next SQL statement will most likely execute in a different connection (and, therefore, a different session which probably doesn't have the statement_timeout set).  What you probably want to do:\n\n``` go\n// Errors ignored for brevity; don't ignore the errors in production code\ntx, _ := dbmap.Begin() // A transaction is guaranteed to be run in the same session\n_, _ = tx.Exec(\"SET STATEMENT_TIMEOUT TO 1\")\nres, _ := tx.Get(new(Person{}), someID)\np := res.(*Person)\n```\n\nIf you wanted to set the timeout on the PreGet method (and ensure that a person is never loaded outside of a transaction):\n\n``` go\nfunc (p *Person) PreGet(exec gorp.SqlExecutor) error {\n    tx, ok := exec.(*gorp.Transaction)\n    if !ok {\n        return errors.New(\"Cannot get a Person outside of a transaction\")\n    }\n    if _, err := tx.Exec(\"SET SESSION STATEMENT_TIMEOUT TO 1\"); err != nil {\n        return err\n    }\n    return nil\n}\n```\n. @goors : Your update certainly works, and it's not a bad solution.  You could also make `helpers.New(tx *gorp.Transaction)` as a constructor for your helper type.\n\nHowever, remember that Go isn't an object-oriented language, so it doesn't _always_ make sense to make a type just for some methods.  For example, instead of your `GetUserById` logic being a method on a struct, it _might_ make sense to move it to a function:\n\n``` go\n//in helper\n// Note: \"tx *gorp.Transaction\" could be rewriten \"exec gorp.SqlExecutor\" if you don't need to\n// restrict UserById to execute only on transactions.\nfunc UserById(tx *gorp.Transaction, id int64) *models.User{\n    p, err := tx.Get(models.User{}, id)\n    if err != nil || p == nil {\n        return nil\n    }\n    return p.(*models.User)\n}\n//in controller\nreturn helpers.UserById(id)\n```\n\nHowever, I have no knowledge of other things your helper is doing, so I don't know if that's necessarily correct for your use case.\n. That sounds fine.  It's always a game of weighing lines of code against ease of understanding - do whatever reads easiest/cleanest to you.\n\nAs far as what reads cleanly to me (these are personal preferences, mostly, so I'm not trying to claim that you should follow them):\n1. `Get` is kinda unnecessary in the function/method name, to my mind.  It's implied by the fact that the function returns a value.\n   1. I like to look at the full function signature.  If the function name is repeating information I already know from the parameters or return values, it's not really necessary in the name.\n   2. There are exceptions.  For example, with `UserByID` and `UserByEmail`, they need to be named two different things.  So even though the function signature makes it obvious that they're querying by ID and email (respectively), it makes sense to include that in the function name, too.\n2. If you use `golint`, it will complain if you use `Id` instead of `ID`.\n3. I kinda like providing a \"constructor\", because `helpers.New(tx)` reads cleaner to me than `helpers.Helper{tx}`.\n\nI'm going to close this issue, since you've gotten your code working.\n. I think we all hit a bit of a busy time at once, and I'm indecisive.  I'll try to break free of that and get some work done on this (at least merge some PRs) soon, though.  I should check in on the gitter channel as well as IRC, see if anyone else has been active recently ... but if I can't get a hold of anyone in a short time, I'll just make some decisions.\n\nAfter all, we can just revert if I pull a dumb.\n. @djui I finally started on the tests/specs cleanup.  It's a pretty small start, but it's something.  I've got a presentation to give to some of the people at my work about ORMish libraries; if they decide to use `gorp`, then I'll have a lot more motivation (and probably time) to work on it.  If that's the case, I think we can get through the test cleanup pretty quickly.\n\nThere's a pretty big \"if\" in that statement, but that's just the way life's going for me, lately :)\n\nIf things don't go that way, I'll just keep trying to make my days longer.\n. @djui Do you mean mocking a `gorp.DbMap` in your codebase?  I would set up an interface type that contains exactly the methods you're using, then mock out just those methods (either manually or with something like [hel](https://github.com/nelsam/hel) or [counterfeiter](https://github.com/maxbrunsfeld/counterfeiter)).\n\nBut I'm not entirely sure I understand the question correctly.\n. That's wonderful.\n. `Get()` should _only_ care about fields that are mapped to a struct.  The select statement generated will handle all columns the struct defines, but no more.  If `Get()` is causing problems with new columns that aren't mapped yet, then that's a bug.\n\nFor `select *`, the bug is not in gorp, it's in `select *`.  Put simply, `select *` is code smell - don't do it.  Your code should be selecting columns explicitly, either directly via select strings or via some library that generates a select statement from your struct.\n\nFor generating a select statement, you can check out [gorq (I wrote it, so grain of salt and all that)](https://github.com/nelsam/gorq)(and I haven't gotten a chance to figure out why the build has started failing, but it is still working quite well for production code) or [squirrel](https://github.com/lann/squirrel), or just make use of `dbmap.TableFor` and `table.Columns` to add column names to your query.\n. When I say \"code smell,\" I don't mean inherently evil; it just _suggests_ that you'll have issues down the road.  So while I'm sure it's fine now, I still recommend doing your best to avoid it.  :)\n\nI contracted as a DBA for a while (and I've kept up with it, sorta - which is why I wrote gorq); in all of the cases that I've seen, `select *` is a bad idea in the long run.  It may not make a difference to you now, but having seen both applications that use `select *` and those that don't 10 years down the road (when they finally shell out for a DBA contractor), the ones that are more explicit about column mappings are much easier to maintain.\n\nIf you're happy with the solution you've found, please close the ticket.\n\n[edit] Also, if you're curious about gorq, follow it; I'm in a big update of the tests, and they should be sitting around 60-80% by the end of it.  It might take a couple weekends (I work on it on my free time), but I'm confident it'll be updated soon(tm)[/edit]\n. Your tests aren't passing on travis ... do you know why?\n\nSorry, I've been absent a lot lately due to my job having a lot of changes (new office, different hours, etc).  I'll check on it as soon as I get a chance.\n. Cool; thanks for all your work, @vinceyuan.  Again, sorry for the late response - I'll do my best to stay on top of _this_ PR, at least.\n. @vinceyuan Looks fine to me.  Let me check with the other maintainers, but my initial thought is to deprecate go 1.2.  That's pretty old at this point.\n. Yeah; we're supporting `gopkg.in` for backwards compatibility.  Anyone relying on master at this point should know that their code might break because of us.\n\nWe'll double check the documentation on merge, though.\n. I'd recommend writing a little helper to read the column names using `dbMap.TableFor` and parsing the columns, as a replacement for `select *`.  We should maybe add functionality for exactly that purpose.\n\nAs to the error: yeah, that should definitely be fixed.\n. Since there have been no comments, I'm going to assume we're good to go down this path.  I'll be fleshing this out a lot in the next few weeks; hopefully it gets us one step closer to v2.\n. Sorry about the long delay; I'm going to start going through pull requests gradually and hopefully get things moving toward v2 again.  The only thing I saw that I would prefer changed is the `GetTableName` method, looks good to merge otherwise.\n. I'll just swap the order post-merge :)\n\nI'm going over this one last time and am going to run tests locally.\n. This seems sane.  Merging.\n. Putting our tests in a separate package allows us to more accurately gauge how our library feels for clients. It helps us catch stutter like `mysql.NewMysqlDialect()` (as an example).  Also, if we need access to unexported code in order to prove that our library is correct, it implies that we're not exporting things that should be exported.\n\nAs a side note: putting tests in a test package doesn't prevent you from also putting tests in the non-test package.  I prefer to start with a test package and only add tests in the non-test package when I really need it. I've found that the only times I've needed access to unexported code were when I had poorly architected my system.\n. We would like to handle this first-class (in fact, I've done it once in a fork, but it was done quickly without testing because we needed it ASAP ... the logic is complex enough that just bringing it in is quite a bit of work), but for now, your best bet is probably to make a mapping struct to select join queries into:\r\n\r\n```go\r\ntype Foo struct {\r\n    ID int `db:\"id\"`\r\n}\r\n\r\ntype Bar struct {\r\n    ID int `db:\"id\"`\r\n    FooID int `db:\"foo_id\"`\r\n}\r\n\r\ntype FooBar struct {\r\n    Foo\r\n    BarID int `db:\"bar_id\"`\r\n}\r\n\r\nfunc FooBars() ([]FooBar, error) {\r\n    var results []FooBar\r\n    _, err := dbmap.Select(&results, \"select foo.id, bar.id as bar_id from foo left join bar on foo.id = bar.foo_id\")\r\n    return results, err\r\n}\r\n```. In postgres, `timestamp '<timestamp'` only works with literals and can't be used in prepared statements.  Try changing `timestamp $2` to `$2::timestamp`.. I'd like to move away from having special cases for types in the code - there are too many branching code paths, already.  Instead, consider using `sql.Scanner` and `driver.Valuer` here.\r\n\r\n```go\r\ntype JSONField struct {\r\n    Name string `json:\"name\"`\r\n    Age int `json:\"age\"`\r\n}\r\n\r\nfunc (f JSONField) Value() (driver.Value, error) {\r\n    return json.Marshal(f)\r\n}\r\n\r\nfunc (f *JSONField) Scan(v interface{}) error {\r\n    return json.Unmarshal(v.([]byte), f)\r\n}\r\n\r\ntype JSONRow struct {\r\n    ID int `db:\"id\"`\r\n    Data JSONField `db:\"data\"`\r\n}\r\n```\r\n\r\nFor the database type of the field, we do need to be adding an interface type to gorp, unfortunately.  We have `SqlTyper`, but it's not something we can use for generic data types - it's only allowed to return a `driver.Value`.. Apologies for the 6 month delay; this looks solid, I'm just going to try to make sure that it's tested in CI before merging. I'm working on it now; just need to figure out how to get travis to spin up a crate DB.. I added crate to the tests and it has been failing in a few ways.  The first was the quoted field problem, but even after solving that, [it had failures](https://travis-ci.org/go-gorp/gorp/jobs/290936839).\r\n\r\nI've pushed a commit to your fork that adds tests; can you work on getting the tests passing?\r\n\r\nedit: FYI, I did not update the unit tests for the crate dialect, so they'll be failing because I changed the quote characters for `QuoteField`.. @inge4pres yeah, feel free to update the  `.travis.yml` in whatever way is best.  I have no experience with crate, I just pulled the  PPA from the install script (https://install.crate.io).\r\n\r\nThere are currently no conflicts with master, but feel free to merge or rebase on top of master first and do what you need to.. It's fine to update the tests to skip testing index against crate. We've\r\nhad to do similar things with one of the mysql drivers.\r\n\r\nSee [here](https://github.com/go-gorp/gorp/blob/master/gorp_test.go#L738)\r\nfor an example.\r\n\r\nOn Oct 30, 2017 07:50, \"Francesco Gualazzi\" <notifications@github.com>\r\nwrote:\r\n\r\n> I went as far as making pass the majority of tests, but at a certain point\r\n> I'm facing that CrateDB has no INDEX statement available.\r\n>\r\n> \u2014\r\n> You are receiving this because you were mentioned.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/go-gorp/gorp/pull/342#issuecomment-340449358>, or mute\r\n> the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AA-QBGvLWRgY7gPNjn6wrYdSDft5Ww1Eks5sxdQOgaJpZM4L9HYk>\r\n> .\r\n>\r\n. d'oh, this is probably something I should have commented on.  There are no current plans, but feel free!  If you don't get to it, I'll keep it in mind for the rearch I've been working through.. I would currently choose #2. I have ideas to mess with the syntax to make\ngorp more flexible, but that'll be for later. For now, returning a new\nSqlExecutor that uses the context is probably the best choice.\n\nIn the distant future, I have a really vague thought of something like\n`dbmap.Query(someSQL, gorp.Args(arg1, arg2, arg3), gorp.WithContext(ctx),\ngorp.SomeOtherCoolOption()).Unmarshal(&foo,\ngorp.SomeCoolUnmarshalOption())`.\n\nBut for now, #2.\n\n\nOn Aug 30, 2017 18:46, \"Matthew Dolan\" <notifications@github.com> wrote:\n\nLooks like it might be pretty simple to pipe through.\n\nWhat are you thinking in terms of the change to the API?\n\n(1) Add new FooContext methods that copy the existing methods.\n\ntype SqlExecutor interface {\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\n\tGetContext(ctx context.Context, i interface{}, keys ...interface{})\n(interface{}, error)\n\t\n\tInsert(list ...interface{}) error\n\tInsertContext(ctx context.Context, list ...interface{}) error\n\t\n\tUpdate(list ...interface{}) (int64, error)\n\tUpdateContext(ctx context.Context, list ...interface{}) (int64, error)\n\t\n\tDelete(list ...interface{}) (int64, error)\n\tDeleteContext(ctx context.Context, list ...interface{}) (int64, error)\n\t\n\tExec(query string, args ...interface{}) (sql.Result, error)\n\tExecContext(ctx context.Context, query string, args ...interface{})\n(sql.Result, error)\n\t\n\t...\n}\n\n(2) Add a WithContext(ctx) which attaches the context to the dbMap.\n\ntype SqlExecutor interface {\n\tWithContext(ctx context.Context) SqlExecutor\n\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\n\tInsert(list ...interface{}) error\n\tUpdate(list ...interface{}) (int64, error)\n\tDelete(list ...interface{}) (int64, error)\n\tExec(query string, args ...interface{}) (sql.Result, error)\n\t...\n}\n\n(3) I guess it's possible to do something backward incompatible that forces\ncontext, but I assume that's not desirable.\n\n(1) is probably most similar to how go changed the underlying sql.Db, but\nit add the most new methods.\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\n<https://github.com/go-gorp/gorp/issues/344#issuecomment-326157816>, or mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/AA-QBDn3zi_so5fO7qxyjrXGvyTCrGZCks5sdgJ8gaJpZM4MLQAc>\n.\n. @soniabhishek yeah, the `WithContext` method on `SqlExecutor` is the desired approach.  @MatthewDolan is working on a solution in #352.. Sure thing, I'll do that a little bit later today (ideally). This seems reasonable.  Can you include a test that fails without these changes?. This seems like a bad idea, because it seems likely that a non-nil `err` will cause a nil `rows`.  I'd like to see a number of things before I consider merging this:\r\n\r\n1. Write a test that shows where there's a problem in the original code.  I want to see a test that proves that a non-nil `rows` is returned that is *not* closed.\r\n2. Prove that `rows == nil` is *never* `true`.  This may be possible by linking to code in `database/sql`, but I want tests that trigger every possible error from the underlying sql library.\r\n3. Show that this is a better solution than having SQL drivers (`lib/pq` et. al.) close `rows` if an error occurs.\r\n\r\nIt's also worth noting that [the examples in the docs](https://golang.org/pkg/database/sql/#DB.Query) check the error before deferring the call to `Close()`.. Closing for now.  Re-open if you still think there's a problem with the current code.. !go1.7 would make it only run on 1.6 and earlier. it should be +build\ngo1.8.  Other than that, yes - anything that requires 1.8 should be gated\non build tags in separate files.\n\nI think it's somewhere in the readme that we aim to support the two most\nrecent go versions. If I'm wrong about it being in the readme, well... I\nstill think supporting the two most recent versions is plenty.\n\nOn Aug 31, 2017 00:42, \"Stephan Renatus\" <notifications@github.com> wrote:\n\n> *@srenatus* approved this pull request.\n>\n> Thanks for picking up that context issue!\n>\n> Looks good to me -- but I, of course, can't help with the open questions.\n> No idea what compatibility gorp wants to provide.\n> ------------------------------\n>\n> In gorp_test.go\n> <https://github.com/go-gorp/gorp/pull/352#discussion_r136255399>:\n>\n> > @@ -2360,6 +2361,31 @@ func TestPrepare(t *testing.T) {\n>  \t}\n>  }\n>\n> +func TestWithCanceledContext(t *testing.T) {\n> +\tif _, driver := dialectAndDriver(); driver != \"mysql\" {\n> +\t\tt.Skip(\"Cancellation is not yet supported by all drivers. Known to be supported by mysql\")\n> +\t}\n> +\n> +\tdbmap := initDbMap()\n> +\tdefer dropAndClose(dbmap)\n> +\n> +\tctx, cancel := context.WithCancel(context.Background())\n> +\n> +\tdefer time.AfterFunc(100 * time.Millisecond, cancel).Stop()\n>\n> I suppose you did that on purpose, just wanted to point out that this is\n> equivalent to:\n>\n> ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)defer cancel()\n>\n> ------------------------------\n>\n> In gorp_test.go\n> <https://github.com/go-gorp/gorp/pull/352#discussion_r136256039>:\n>\n> > @@ -2360,6 +2361,31 @@ func TestPrepare(t *testing.T) {\n>  \t}\n>  }\n>\n> +func TestWithCanceledContext(t *testing.T) {\n>\n> (2) The Context API being added to db.Sql wasn't added until I think Go\n> 1.8. [...] but that will make the test I added fail unless I can exclude\n> that test for earlier versions.\n>\n> If you'd put that into its own file, you would be able to add // +build\n> !go1.7, I believe? To make these tests not run on 1.7? (not entirely sure\n> if it works like that, though)\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-gorp/gorp/pull/352#pullrequestreview-59766343>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AA-QBGNy7lnyVAm_GE5lh3n1RYmLx43rks5sdlXMgaJpZM4PITIB>\n> .\n>\n. I'll review this weekend.  I'm blocking out something on my schedule.. Yep, I'll check on it soon.  I've had a busy couple of days.. @MatthewDolan anything you want to add before merge? Otherwise, I can merge now.. Thanks for the submission!  I'm trying to be more active with `gorp`, but you know how life and work go.  Especially with `gorp` being something I no longer actively use.. One last request: can we do `log.Printf(\"Deprecation Warning:  update your SqlType methods to return a driver.Value\")` in the logic for legacySqlTyper?. awesome! I'll merge on the morrow.\n\nOn Oct 20, 2017 22:20, \"Ilia Choly\" <notifications@github.com> wrote:\n\n> @nelsam <https://github.com/nelsam> done and squashed.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-gorp/gorp/pull/355#issuecomment-338362768>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AA-QBFV6z9fYdDpKb6-2mYXlkDYeNon0ks5suXEMgaJpZM4P-DCw>\n> .\n>\n. Yeah.  We can maybe update our code to be more aware of how those types usually work, make our code more generic instead of checking the type name for everything, but we have no guarantee that it'll work for all use cases.\r\n\r\nBack when we were more active, we had plans to separate the database setup logic and make it a bit more explicit, but it's become difficult to put that much time in to gorp for most of us.. Can we get a test that would fail without this feature?. @schmorrison That's a different issue.  This issue is specifically about slices of database-supported values, which are generally accepted as SQL arrays.\r\n\r\nThe issue of supporting first-class joins is something I've implemented in a fork, but the code is very complex, and I don't trust directly merging it in.  I need to find some time to really sit down and work on it to make sure it's fully tested.. An empty string is not a null string - they are considered two different values in the database *and* in go, and plenty of code relies on checking for `null` as compared to an empty string.  `null` often means \"not yet assigned\", where empty string often means \"assigned as an empty string\".\r\n\r\nIf you just feel like `sql.NullString` is cumbersome, use `*string` (pointer to string).  The pointer will be `null` if the database value is null; if the value in the database is an empty string, then the pointer will be non-nil but the string value will be empty.\r\n\r\nIf you just don't like doing more than one comparison (which the pointer doesn't really solve), but empty string and null are equivalent in your database, you can implement `sql.Scanner` and `driver.Valuer` in a custom type to use in your struct fields; something like the following:\r\n\r\n```go\r\npackage foo\r\n\r\nimport (\r\n    \"database/sql\"\r\n    \"database/sql/driver\"\r\n)\r\n\r\ntype NullToEmptyString string\r\n\r\nfunc (n NullToEmptyString) Value() (driver.Value, error) {\r\n    return string(n), nil\r\n}\r\n\r\nfunc (n *NullToEmptyString) Scan(v interface{}) error {\r\n    if v == nil {\r\n        *n = \"\"\r\n        return nil\r\n    }\r\n    s, ok := v.(string)\r\n    if !ok {\r\n        return fmt.Errorf(\"Cannot scan value %v: expected string type, got %T\", v, v)\r\n    }\r\n    *n = NullToEmptyString(s)\r\n    return nil\r\n}\r\n```. @coopernurse did you get a chance to review this?  Is there something you'd like me to change about it?  Looking over the code with my slightly less rudimentary knowledge of Go, I can see where some performance improvements could be made (e.g. if no embedded struct has been found yet, there's no reason to loop through columns looking for values to overwrite), if that's the reason that this hasn't yet been merged.  I could set up some benchmarks and try to change the code to ensure that performance isn't affected unless fields are actually being overridden.\n\nI'm currently importing our forked version of gorp in our production code at Radiobox and I'd rather not keep doing that unless I absolutely have to, so let me know if I need to make any changes.\n. Will do.  Thanks!\n\nI'm struggling to remember where I'm using this, but I think I actually based the tests that I wrote on my production code, so if the tests pass, my production code should be working.  I'll pull it into my fork, though.\n. Everything's working fine here.  I remembered which models needed my patch and made sure to do some inserts and selects against them.  No issues so far.\n. https://groups.google.com/forum/#!topic/golang-dev/6RtCsSDdBzk\n\n^ Looks like you're right about them being from exp/sql.  I see no reason to keep them around unless you want to continue supporting Go versions <1.0.  And even then, I would think you could just make a go0 git tag (assuming this even worked prior to Go 1):\n\n\"When checking out or updating a package, get looks for a branch or tag that matches the locally installed version of Go. The most important rule is that if the local installation is running version \"go1\", get searches for a branch or tag named \"go1\". If no such version exists it retrieves the most recent version of the package.\"\n. In case it helps, I've got a [project (which I've named gorq)](https://github.com/nelsam/gorq), which imports and extends gorp's functionality with a query DSL.  It was built to handle some of these sorts of issues (the whole project stems from a function I wrote to generate column names for use in queries).  It's new, kind of complicated, doesn't have the most useful error messages, needs some cleanup, and the test coverage isn't very solid yet; but it's being used actively on at least four projects (all of which are using postgresql).\n\nThe basic syntax of queries becomes (as an example):\n\n``` go\ntype Foo struct {\n  ID int\n  Bar Bar `db:\"bar_id\"` // Bar.ID populated with bar_id using sql.Scanner or a TypeConverter\n  Baz string\n}\n\nfoos := []Foo{}\nref := Foo{}\nerr := dbMap.Query(&ref).\n  Where().\n  Equal(&ref.Baz, \"public\").\n  SelectToTarget(&foos)\n```\n\nIt uses references quite a bit for figuring out column names (for input values, it will usually use the column name of a field if the value is equal to a field's address), which isn't exactly ideal... but I couldn't think of anything better at the time.  Still, it's a start.\n\nMore complicated queries (e.g. needing `OR` in the where clause, or using joins) are supported, but the syntax isn't always as clean as the above.  For example:\n\n``` go\nfoos = []Foo{}\nerr = dbMap.Query(&ref).\n  Join(&ref.Bar).On().\n  Equal(&ref.Bar, &ref.Bar.ID).\n  Where().\n  Greater(&ref.Bar.Rank, 3).\n  SelectToTarget(&foos)\n\nfoos = []Foo{}\nfilter := filters.Or(filters.Equal(&ref.Bar, someAdminBarID), filters.Equal(&ref.Baz, \"public\"))\nerr = dbMap.Query(&ref).\n  Where(filter).\n  SelectToTarget(&foos)\n```\n\nI really wanted to have better test coverage before mentioning it to anyone else ... but I thought it might help anyone who's running in to this issue, and I can't hide forever.\n\nBy the way, my two cents, for what they're worth: `select *` is code smell, and discarding data (even via an option that defaults to off) is dangerous.  But my opinion's probably obvious from the fact that I wrote a pretty massive extension to gorp, in part to avoid using `select *`.\n. @recht fetching metadata is done through `select` statements in postgres.  There are shortcuts in the `psql` CLI, but they all run select statements under the covers.\r\n\r\nThat said, if/when I find time to actually work on a new version of gorp in the future, I wouldn't mind adding this as a specific flag you can pass to queries.  Something along the lines of the following might make sense:\r\n\r\n```\r\nres, err := dbmap.Statement(\"show slave status\")\r\nif err != nil {\r\n    // you know the drill\r\n}\r\nres.IgnoreMissing().Unmarshal(&slaveMeta)\r\n```\r\n\r\nWould that cover the edge case well enough for you?. Sorry for the long wait.  Merged.  Reopen if this needs anything else.\n. Looks like the build is only failing because of the problems solved by #154.  I ran the sqlite test (the one that failed) locally after fixing that issue (I'm not going to commit the code with that fix, for obvious reasons), and it all passed.\n. Awesome, thanks.\n. This might help you guys.  However, just wanted to mention, the `TypeDef` method implements an interface that I haven't quite made a PR for yet, but it's only used during a `CREATE TABLE` statement (or during automated migration, which is yet another PR I haven't made yet).  As long as your column is already defined properly, this _should_ work for `geography` types (I didn't feel like fiddling with `geometry` types, although I'm sure the solution is similar).\n\nhttps://github.com/nelsam/gorq/blob/master/extensions/postgis.go\n\nFeel free to copy whatever code you can make use of, or just import the package and use it from there.  If you want to import the package and use the query language I've implemented in my little extension, the syntax of querying using radius values is something like:\n\n``` go\ntype someModel struct {\n  SomeGeoField extensions.Geography\n}\n\ngorqMap := &gorq.DbMap{DbMap:*dbMap}\nm := someModel{}\ng := extensions.Geography{Lat: someLat, Lng: someLng}\nresults, err := gorqMap.Query(&someModel).\n  Where().\n  Filter(extensions.WithinMeters(&someModel.SomeGeoField, g, 50).\n  OrderBy(extensions.Distance(&someModel.SomeGeoField, g), \"ASC\").\n  Select()\n```\n. Another thing: the idiomatic thing for options seems to be that options _always_ follow a comma.  For example:\n\n``` go\ntype Foo struct {\n    Bar string `db:\",pkey,size:50\"`\n}\n```\n\nGenerally, it seems that the initial comma is required; should we be following that style?\n\nAlso, I'd like to consider an option registration framework ... actually, I'll just link to what I wrote for a different project: https://github.com/nelsam/requests/blob/master/tags.go\n\nIn that file, you can see how I allow users of the library to register their own options.  It allows for a _lot_ more flexibility, especially for situations where someone needs an option that the library won't support natively (for example, if someone needs an option that isn't useful in any database engine other than the one they're using, it might not be something we want to add to gorp directly).  It also just helps reduce code bloat as we add more options to the library.\n\nGranted, that may be something for another PR, later on.  Thoughts?\n. @qrawl Sure, make sense.\n\nAs to the third party library: I don't want to use a third party library to parse it, I was just linking the code as an example of how we might allow users of gorp to register their own options.  Obviously, our option function would have a different signature (maybe `func(value string, col *ColumnMap) error` - allow the option function to modify the column map as it needs to based on the value), but something _similar_ to the code I linked would be nice, for allowing users to register options that we don't support officially.\n. For the test, I tried using time.Time (since that was where my problem in my codebase is), but the \"mysql\" driver doesn't seem to like time.Time when running Get().  Every other driver (\"postgres\", \"gomysql\", \"sqlite\") works just fine, but \"mysql\" fails.  It creates the table with the right syntax, and insert seems to work, but Get() fails with `sql: Scan error on column index 1: unsupported driver -> Scan pair: []uint8 -> *time.Time` - even though the table is created with a column type of datetime.\n\nI tried using other types (int64, string, etc), but the drivers just silently converted those types back and forth, so the test would always succeed, even without the fix.\n\nBasically, the test I've included is the only test I tried that produces the error I was seeing without my fix, and is solved by my fix.  However, for it to pass, I have to skip it when the driver being used is \"mysql\" (\"gomysql\" works just fine).\n. @marconi Generally, `gorp` doesn't like to be a query generation library, so if you need something other than what gorp's `Insert` does, you can run something more like `results, err := gorp.Select(someType{}, \"insert into something (stuff) values (things) returning (all, the, things)\")`.\n\nAlternatively, if you'd like a library to generate queries, I've written an extension to gorp that has been used fairly thoroughly on a few projects (albeit only with postgres).  I don't think I've implemented `returning`, but it's a relatively simple update.  If you're interested in checking it out, it's currently [here](http://github.com/nelsam/gorq).\n. I agree with supporting the latest two versions.  Anything more than that is going to hit us with some pretty ugly limits in the future.\n. Alternatively:\n\n``` go\ntype someDialect struct {\n  // stuff\n}\n\nfunc SomeDialect() Dialect {\n  return someDialect{}\n}\n```\n. Not necessarily.  TableMap.Columns is a slice of all detected columns - typically in the order you would expect, but you shouldn't think of it as a 1-to-1 mapping.  For example:\n\n``` go\ntype Foo struct {\n    Bacon string // this is tableMap.Colums[0] for the Bar type\n    Eggs int64 // this is tableMap.Columns[1] for the Bar type\n}\n\ntype Bar struct {\n    Foo // this is reflect.TypeOf(Bar{}).Field(0)\n    Toast float32 // this is tableMap.Columns[2] and reflect.TypeOf(Bar{}).Field(1)\n}\n```\n\nI'm undecided on whether or not you should rely on the column order, so I guess (at least for now) I would say you should consider it an implementation detail.  @GeertJohan do you have any thoughts?\n. Quick thought: Could we maybe add a note about `Dialect.BindVar`?  Something like:\n\n`Alternatively, use dbMap.Dialect.BindVar(varIdx) to get the proper variable binding for your dialect.`\n. Cool, thanks.  This looks good to me; but I haven't had much sleep, so I don't want to merge it until I'm fully woken up.\n. @jsanc623 It looks like your squash didn't quite work - the history still contains all of the previous commits, as well.  Can you try again following [this guide](http://eli.thegreenplace.net/2014/02/19/squashing-github-pull-requests-into-a-single-commit)?\n. @GeertJohan I like your definition.  I use something sorta similar (something like `db:\"firstname,size=1024\"`) for some of my other code.  I also set my code to use `true` as the default value, e.g. `db:\"firstname,not-null\"` would parse the `not-null` option the same as if it were `not-null=true`.\n\nI think something similar would be good here (`:` works for me - it looks a little cleaner than `=`, anyway).\n. Hmm ... Honestly, I'm not sure if any of us use SQL Server.  I certainly don't - I only know the bare minimum required to convert SQL Server DBs to something else.\n\nIt's possible that all of us are waiting for someone else to handle the SQL Server tickets, because we all think one of the others knows SQL Server better than we do.\n. Yeah, I'm not saying anything against merging it, just trying to explain why it may be that none of us have gotten to it yet.  I'm not yet comfortable merging things that I have no knowledge of.  :)\n\n@GeertJohan I've got no issues with merging this.  What do you think?\n. You can implement [`\"database/sql\".Scanner`](http://golang.org/pkg/database/sql/#Scanner) and [`\"database/sql/driver\".Valuer`](http://golang.org/pkg/database/sql/driver/#Valuer) to create your own json type.  `Value()` should spit out the json string; `Scan()` should take the json string from the DB and unmarshal it to your type.\n. FYI, `BEGIN` opens a transaction, then `COMMIT` closes the transaction (which, I believe, closes the current \"session\", reverting that timeout) - you probably don't want that.  Furthermore, even if you set your session's `statement_timeout` outside of a transaction, Go's `database/sql` library uses a connection pool under the covers - meaning that the next SQL statement will most likely execute in a different connection (and, therefore, a different session which probably doesn't have the statement_timeout set).  What you probably want to do:\n\n``` go\n// Errors ignored for brevity; don't ignore the errors in production code\ntx, _ := dbmap.Begin() // A transaction is guaranteed to be run in the same session\n_, _ = tx.Exec(\"SET STATEMENT_TIMEOUT TO 1\")\nres, _ := tx.Get(new(Person{}), someID)\np := res.(*Person)\n```\n\nIf you wanted to set the timeout on the PreGet method (and ensure that a person is never loaded outside of a transaction):\n\n``` go\nfunc (p *Person) PreGet(exec gorp.SqlExecutor) error {\n    tx, ok := exec.(*gorp.Transaction)\n    if !ok {\n        return errors.New(\"Cannot get a Person outside of a transaction\")\n    }\n    if _, err := tx.Exec(\"SET SESSION STATEMENT_TIMEOUT TO 1\"); err != nil {\n        return err\n    }\n    return nil\n}\n```\n. @goors : Your update certainly works, and it's not a bad solution.  You could also make `helpers.New(tx *gorp.Transaction)` as a constructor for your helper type.\n\nHowever, remember that Go isn't an object-oriented language, so it doesn't _always_ make sense to make a type just for some methods.  For example, instead of your `GetUserById` logic being a method on a struct, it _might_ make sense to move it to a function:\n\n``` go\n//in helper\n// Note: \"tx *gorp.Transaction\" could be rewriten \"exec gorp.SqlExecutor\" if you don't need to\n// restrict UserById to execute only on transactions.\nfunc UserById(tx *gorp.Transaction, id int64) *models.User{\n    p, err := tx.Get(models.User{}, id)\n    if err != nil || p == nil {\n        return nil\n    }\n    return p.(*models.User)\n}\n//in controller\nreturn helpers.UserById(id)\n```\n\nHowever, I have no knowledge of other things your helper is doing, so I don't know if that's necessarily correct for your use case.\n. That sounds fine.  It's always a game of weighing lines of code against ease of understanding - do whatever reads easiest/cleanest to you.\n\nAs far as what reads cleanly to me (these are personal preferences, mostly, so I'm not trying to claim that you should follow them):\n1. `Get` is kinda unnecessary in the function/method name, to my mind.  It's implied by the fact that the function returns a value.\n   1. I like to look at the full function signature.  If the function name is repeating information I already know from the parameters or return values, it's not really necessary in the name.\n   2. There are exceptions.  For example, with `UserByID` and `UserByEmail`, they need to be named two different things.  So even though the function signature makes it obvious that they're querying by ID and email (respectively), it makes sense to include that in the function name, too.\n2. If you use `golint`, it will complain if you use `Id` instead of `ID`.\n3. I kinda like providing a \"constructor\", because `helpers.New(tx)` reads cleaner to me than `helpers.Helper{tx}`.\n\nI'm going to close this issue, since you've gotten your code working.\n. I think we all hit a bit of a busy time at once, and I'm indecisive.  I'll try to break free of that and get some work done on this (at least merge some PRs) soon, though.  I should check in on the gitter channel as well as IRC, see if anyone else has been active recently ... but if I can't get a hold of anyone in a short time, I'll just make some decisions.\n\nAfter all, we can just revert if I pull a dumb.\n. @djui I finally started on the tests/specs cleanup.  It's a pretty small start, but it's something.  I've got a presentation to give to some of the people at my work about ORMish libraries; if they decide to use `gorp`, then I'll have a lot more motivation (and probably time) to work on it.  If that's the case, I think we can get through the test cleanup pretty quickly.\n\nThere's a pretty big \"if\" in that statement, but that's just the way life's going for me, lately :)\n\nIf things don't go that way, I'll just keep trying to make my days longer.\n. @djui Do you mean mocking a `gorp.DbMap` in your codebase?  I would set up an interface type that contains exactly the methods you're using, then mock out just those methods (either manually or with something like [hel](https://github.com/nelsam/hel) or [counterfeiter](https://github.com/maxbrunsfeld/counterfeiter)).\n\nBut I'm not entirely sure I understand the question correctly.\n. That's wonderful.\n. `Get()` should _only_ care about fields that are mapped to a struct.  The select statement generated will handle all columns the struct defines, but no more.  If `Get()` is causing problems with new columns that aren't mapped yet, then that's a bug.\n\nFor `select *`, the bug is not in gorp, it's in `select *`.  Put simply, `select *` is code smell - don't do it.  Your code should be selecting columns explicitly, either directly via select strings or via some library that generates a select statement from your struct.\n\nFor generating a select statement, you can check out [gorq (I wrote it, so grain of salt and all that)](https://github.com/nelsam/gorq)(and I haven't gotten a chance to figure out why the build has started failing, but it is still working quite well for production code) or [squirrel](https://github.com/lann/squirrel), or just make use of `dbmap.TableFor` and `table.Columns` to add column names to your query.\n. When I say \"code smell,\" I don't mean inherently evil; it just _suggests_ that you'll have issues down the road.  So while I'm sure it's fine now, I still recommend doing your best to avoid it.  :)\n\nI contracted as a DBA for a while (and I've kept up with it, sorta - which is why I wrote gorq); in all of the cases that I've seen, `select *` is a bad idea in the long run.  It may not make a difference to you now, but having seen both applications that use `select *` and those that don't 10 years down the road (when they finally shell out for a DBA contractor), the ones that are more explicit about column mappings are much easier to maintain.\n\nIf you're happy with the solution you've found, please close the ticket.\n\n[edit] Also, if you're curious about gorq, follow it; I'm in a big update of the tests, and they should be sitting around 60-80% by the end of it.  It might take a couple weekends (I work on it on my free time), but I'm confident it'll be updated soon(tm)[/edit]\n. Your tests aren't passing on travis ... do you know why?\n\nSorry, I've been absent a lot lately due to my job having a lot of changes (new office, different hours, etc).  I'll check on it as soon as I get a chance.\n. Cool; thanks for all your work, @vinceyuan.  Again, sorry for the late response - I'll do my best to stay on top of _this_ PR, at least.\n. @vinceyuan Looks fine to me.  Let me check with the other maintainers, but my initial thought is to deprecate go 1.2.  That's pretty old at this point.\n. Yeah; we're supporting `gopkg.in` for backwards compatibility.  Anyone relying on master at this point should know that their code might break because of us.\n\nWe'll double check the documentation on merge, though.\n. I'd recommend writing a little helper to read the column names using `dbMap.TableFor` and parsing the columns, as a replacement for `select *`.  We should maybe add functionality for exactly that purpose.\n\nAs to the error: yeah, that should definitely be fixed.\n. Since there have been no comments, I'm going to assume we're good to go down this path.  I'll be fleshing this out a lot in the next few weeks; hopefully it gets us one step closer to v2.\n. Sorry about the long delay; I'm going to start going through pull requests gradually and hopefully get things moving toward v2 again.  The only thing I saw that I would prefer changed is the `GetTableName` method, looks good to merge otherwise.\n. I'll just swap the order post-merge :)\n\nI'm going over this one last time and am going to run tests locally.\n. This seems sane.  Merging.\n. Putting our tests in a separate package allows us to more accurately gauge how our library feels for clients. It helps us catch stutter like `mysql.NewMysqlDialect()` (as an example).  Also, if we need access to unexported code in order to prove that our library is correct, it implies that we're not exporting things that should be exported.\n\nAs a side note: putting tests in a test package doesn't prevent you from also putting tests in the non-test package.  I prefer to start with a test package and only add tests in the non-test package when I really need it. I've found that the only times I've needed access to unexported code were when I had poorly architected my system.\n. We would like to handle this first-class (in fact, I've done it once in a fork, but it was done quickly without testing because we needed it ASAP ... the logic is complex enough that just bringing it in is quite a bit of work), but for now, your best bet is probably to make a mapping struct to select join queries into:\r\n\r\n```go\r\ntype Foo struct {\r\n    ID int `db:\"id\"`\r\n}\r\n\r\ntype Bar struct {\r\n    ID int `db:\"id\"`\r\n    FooID int `db:\"foo_id\"`\r\n}\r\n\r\ntype FooBar struct {\r\n    Foo\r\n    BarID int `db:\"bar_id\"`\r\n}\r\n\r\nfunc FooBars() ([]FooBar, error) {\r\n    var results []FooBar\r\n    _, err := dbmap.Select(&results, \"select foo.id, bar.id as bar_id from foo left join bar on foo.id = bar.foo_id\")\r\n    return results, err\r\n}\r\n```. In postgres, `timestamp '<timestamp'` only works with literals and can't be used in prepared statements.  Try changing `timestamp $2` to `$2::timestamp`.. I'd like to move away from having special cases for types in the code - there are too many branching code paths, already.  Instead, consider using `sql.Scanner` and `driver.Valuer` here.\r\n\r\n```go\r\ntype JSONField struct {\r\n    Name string `json:\"name\"`\r\n    Age int `json:\"age\"`\r\n}\r\n\r\nfunc (f JSONField) Value() (driver.Value, error) {\r\n    return json.Marshal(f)\r\n}\r\n\r\nfunc (f *JSONField) Scan(v interface{}) error {\r\n    return json.Unmarshal(v.([]byte), f)\r\n}\r\n\r\ntype JSONRow struct {\r\n    ID int `db:\"id\"`\r\n    Data JSONField `db:\"data\"`\r\n}\r\n```\r\n\r\nFor the database type of the field, we do need to be adding an interface type to gorp, unfortunately.  We have `SqlTyper`, but it's not something we can use for generic data types - it's only allowed to return a `driver.Value`.. Apologies for the 6 month delay; this looks solid, I'm just going to try to make sure that it's tested in CI before merging. I'm working on it now; just need to figure out how to get travis to spin up a crate DB.. I added crate to the tests and it has been failing in a few ways.  The first was the quoted field problem, but even after solving that, [it had failures](https://travis-ci.org/go-gorp/gorp/jobs/290936839).\r\n\r\nI've pushed a commit to your fork that adds tests; can you work on getting the tests passing?\r\n\r\nedit: FYI, I did not update the unit tests for the crate dialect, so they'll be failing because I changed the quote characters for `QuoteField`.. @inge4pres yeah, feel free to update the  `.travis.yml` in whatever way is best.  I have no experience with crate, I just pulled the  PPA from the install script (https://install.crate.io).\r\n\r\nThere are currently no conflicts with master, but feel free to merge or rebase on top of master first and do what you need to.. It's fine to update the tests to skip testing index against crate. We've\r\nhad to do similar things with one of the mysql drivers.\r\n\r\nSee [here](https://github.com/go-gorp/gorp/blob/master/gorp_test.go#L738)\r\nfor an example.\r\n\r\nOn Oct 30, 2017 07:50, \"Francesco Gualazzi\" <notifications@github.com>\r\nwrote:\r\n\r\n> I went as far as making pass the majority of tests, but at a certain point\r\n> I'm facing that CrateDB has no INDEX statement available.\r\n>\r\n> \u2014\r\n> You are receiving this because you were mentioned.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/go-gorp/gorp/pull/342#issuecomment-340449358>, or mute\r\n> the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AA-QBGvLWRgY7gPNjn6wrYdSDft5Ww1Eks5sxdQOgaJpZM4L9HYk>\r\n> .\r\n>\r\n. d'oh, this is probably something I should have commented on.  There are no current plans, but feel free!  If you don't get to it, I'll keep it in mind for the rearch I've been working through.. I would currently choose #2. I have ideas to mess with the syntax to make\ngorp more flexible, but that'll be for later. For now, returning a new\nSqlExecutor that uses the context is probably the best choice.\n\nIn the distant future, I have a really vague thought of something like\n`dbmap.Query(someSQL, gorp.Args(arg1, arg2, arg3), gorp.WithContext(ctx),\ngorp.SomeOtherCoolOption()).Unmarshal(&foo,\ngorp.SomeCoolUnmarshalOption())`.\n\nBut for now, #2.\n\n\nOn Aug 30, 2017 18:46, \"Matthew Dolan\" <notifications@github.com> wrote:\n\nLooks like it might be pretty simple to pipe through.\n\nWhat are you thinking in terms of the change to the API?\n\n(1) Add new FooContext methods that copy the existing methods.\n\ntype SqlExecutor interface {\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\n\tGetContext(ctx context.Context, i interface{}, keys ...interface{})\n(interface{}, error)\n\t\n\tInsert(list ...interface{}) error\n\tInsertContext(ctx context.Context, list ...interface{}) error\n\t\n\tUpdate(list ...interface{}) (int64, error)\n\tUpdateContext(ctx context.Context, list ...interface{}) (int64, error)\n\t\n\tDelete(list ...interface{}) (int64, error)\n\tDeleteContext(ctx context.Context, list ...interface{}) (int64, error)\n\t\n\tExec(query string, args ...interface{}) (sql.Result, error)\n\tExecContext(ctx context.Context, query string, args ...interface{})\n(sql.Result, error)\n\t\n\t...\n}\n\n(2) Add a WithContext(ctx) which attaches the context to the dbMap.\n\ntype SqlExecutor interface {\n\tWithContext(ctx context.Context) SqlExecutor\n\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\n\tInsert(list ...interface{}) error\n\tUpdate(list ...interface{}) (int64, error)\n\tDelete(list ...interface{}) (int64, error)\n\tExec(query string, args ...interface{}) (sql.Result, error)\n\t...\n}\n\n(3) I guess it's possible to do something backward incompatible that forces\ncontext, but I assume that's not desirable.\n\n(1) is probably most similar to how go changed the underlying sql.Db, but\nit add the most new methods.\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\n<https://github.com/go-gorp/gorp/issues/344#issuecomment-326157816>, or mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/AA-QBDn3zi_so5fO7qxyjrXGvyTCrGZCks5sdgJ8gaJpZM4MLQAc>\n.\n. @soniabhishek yeah, the `WithContext` method on `SqlExecutor` is the desired approach.  @MatthewDolan is working on a solution in #352.. Sure thing, I'll do that a little bit later today (ideally). This seems reasonable.  Can you include a test that fails without these changes?. This seems like a bad idea, because it seems likely that a non-nil `err` will cause a nil `rows`.  I'd like to see a number of things before I consider merging this:\r\n\r\n1. Write a test that shows where there's a problem in the original code.  I want to see a test that proves that a non-nil `rows` is returned that is *not* closed.\r\n2. Prove that `rows == nil` is *never* `true`.  This may be possible by linking to code in `database/sql`, but I want tests that trigger every possible error from the underlying sql library.\r\n3. Show that this is a better solution than having SQL drivers (`lib/pq` et. al.) close `rows` if an error occurs.\r\n\r\nIt's also worth noting that [the examples in the docs](https://golang.org/pkg/database/sql/#DB.Query) check the error before deferring the call to `Close()`.. Closing for now.  Re-open if you still think there's a problem with the current code.. !go1.7 would make it only run on 1.6 and earlier. it should be +build\ngo1.8.  Other than that, yes - anything that requires 1.8 should be gated\non build tags in separate files.\n\nI think it's somewhere in the readme that we aim to support the two most\nrecent go versions. If I'm wrong about it being in the readme, well... I\nstill think supporting the two most recent versions is plenty.\n\nOn Aug 31, 2017 00:42, \"Stephan Renatus\" <notifications@github.com> wrote:\n\n> *@srenatus* approved this pull request.\n>\n> Thanks for picking up that context issue!\n>\n> Looks good to me -- but I, of course, can't help with the open questions.\n> No idea what compatibility gorp wants to provide.\n> ------------------------------\n>\n> In gorp_test.go\n> <https://github.com/go-gorp/gorp/pull/352#discussion_r136255399>:\n>\n> > @@ -2360,6 +2361,31 @@ func TestPrepare(t *testing.T) {\n>  \t}\n>  }\n>\n> +func TestWithCanceledContext(t *testing.T) {\n> +\tif _, driver := dialectAndDriver(); driver != \"mysql\" {\n> +\t\tt.Skip(\"Cancellation is not yet supported by all drivers. Known to be supported by mysql\")\n> +\t}\n> +\n> +\tdbmap := initDbMap()\n> +\tdefer dropAndClose(dbmap)\n> +\n> +\tctx, cancel := context.WithCancel(context.Background())\n> +\n> +\tdefer time.AfterFunc(100 * time.Millisecond, cancel).Stop()\n>\n> I suppose you did that on purpose, just wanted to point out that this is\n> equivalent to:\n>\n> ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)defer cancel()\n>\n> ------------------------------\n>\n> In gorp_test.go\n> <https://github.com/go-gorp/gorp/pull/352#discussion_r136256039>:\n>\n> > @@ -2360,6 +2361,31 @@ func TestPrepare(t *testing.T) {\n>  \t}\n>  }\n>\n> +func TestWithCanceledContext(t *testing.T) {\n>\n> (2) The Context API being added to db.Sql wasn't added until I think Go\n> 1.8. [...] but that will make the test I added fail unless I can exclude\n> that test for earlier versions.\n>\n> If you'd put that into its own file, you would be able to add // +build\n> !go1.7, I believe? To make these tests not run on 1.7? (not entirely sure\n> if it works like that, though)\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-gorp/gorp/pull/352#pullrequestreview-59766343>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AA-QBGNy7lnyVAm_GE5lh3n1RYmLx43rks5sdlXMgaJpZM4PITIB>\n> .\n>\n. I'll review this weekend.  I'm blocking out something on my schedule.. Yep, I'll check on it soon.  I've had a busy couple of days.. @MatthewDolan anything you want to add before merge? Otherwise, I can merge now.. Thanks for the submission!  I'm trying to be more active with `gorp`, but you know how life and work go.  Especially with `gorp` being something I no longer actively use.. One last request: can we do `log.Printf(\"Deprecation Warning:  update your SqlType methods to return a driver.Value\")` in the logic for legacySqlTyper?. awesome! I'll merge on the morrow.\n\nOn Oct 20, 2017 22:20, \"Ilia Choly\" <notifications@github.com> wrote:\n\n> @nelsam <https://github.com/nelsam> done and squashed.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/go-gorp/gorp/pull/355#issuecomment-338362768>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AA-QBFV6z9fYdDpKb6-2mYXlkDYeNon0ks5suXEMgaJpZM4P-DCw>\n> .\n>\n. Yeah.  We can maybe update our code to be more aware of how those types usually work, make our code more generic instead of checking the type name for everything, but we have no guarantee that it'll work for all use cases.\r\n\r\nBack when we were more active, we had plans to separate the database setup logic and make it a bit more explicit, but it's become difficult to put that much time in to gorp for most of us.. Can we get a test that would fail without this feature?. ",
    "mbustamanteo": "Thanks for your quick reply. I forgot completely about the err variable. I can confirm that now it works, i'm using mymysql and that's it. \n\nAbout \n\n```\np1 := &Sexo{Nombre:\"otro\"}\n```\n\ngo complains with \n\n```\n./orm.go:25: cannot use \"otro\" (type string) as type int64 in field value\n./orm.go:25: too few values in struct initializer\n```\n\nso i put a 0 just like you said.\n\nThanks!!!!!\n. Thanks for your quick reply. I forgot completely about the err variable. I can confirm that now it works, i'm using mymysql and that's it. \n\nAbout \n\n```\np1 := &Sexo{Nombre:\"otro\"}\n```\n\ngo complains with \n\n```\n./orm.go:25: cannot use \"otro\" (type string) as type int64 in field value\n./orm.go:25: too few values in struct initializer\n```\n\nso i put a 0 just like you said.\n\nThanks!!!!!\n. ",
    "nexneo": "I don't know how I can make this idiomatic go, I feel `for true` loop can be source of bugs.\n. I don't know how I can make this idiomatic go, I feel `for true` loop can be source of bugs.\n. ",
    "ottob": "+1\n. I would also find this really useful.\n. Yep. Same here: https://github.com/ottob/gorp/commit/e237b5367993f7503f342267c497490b1963827d\n. I missed the exec line in DropTables. I you want I can update the pull request.\n. Sorry about the noise, I'm a git newbie. But I think the next pull will finally be correct.\n. I'm restructuring my repo. Will reopen this soon.\n. I'm restructuring my repo. Will reopen this soon.\n. Like this?\nhttps://github.com/modcloth/gorp/commit/c33e46c8b123e8109975728f44271fd4c1133149\n. It's not my code, I just happened to find it while browsing the gorp network graph :)\n\nIt looks like it was authored by Jesse Szwedko.\n. Running 1.1 and Gorp here also. No problems.\n. SelectInto looks really nice. +1\n. Thanks!\n. Same here, I haven't even gotten around to upgrading to SelectOne yet. So changing the API is not a problem for me.\n. :+1: \n. +1\n. I would also find this really useful.\n. Yep. Same here: https://github.com/ottob/gorp/commit/e237b5367993f7503f342267c497490b1963827d\n. I missed the exec line in DropTables. I you want I can update the pull request.\n. Sorry about the noise, I'm a git newbie. But I think the next pull will finally be correct.\n. I'm restructuring my repo. Will reopen this soon.\n. I'm restructuring my repo. Will reopen this soon.\n. Like this?\nhttps://github.com/modcloth/gorp/commit/c33e46c8b123e8109975728f44271fd4c1133149\n. It's not my code, I just happened to find it while browsing the gorp network graph :)\n\nIt looks like it was authored by Jesse Szwedko.\n. Running 1.1 and Gorp here also. No problems.\n. SelectInto looks really nice. +1\n. Thanks!\n. Same here, I haven't even gotten around to upgrading to SelectOne yet. So changing the API is not a problem for me.\n. :+1: \n. ",
    "sqs": "FYI, I have submitted a pull request that implements support for embedded structs: https://github.com/coopernurse/gorp/pull/42\n. FWIW, I have been using the patch from above with success (with PostgreSQL).\n\n@coopernurse, adding this would be somewhat backwards incompatible (because CreateTables would use a different schema when people update gorp). Is that OK, or do you have any ideas on how to mitigate it?\n. BTW, for PostgreSQL, I would suggest mapping [`pq.NullTime`](http://godoc.org/github.com/lib/pq#NullTime) to `timestamp` as well:\n\nI.e.,\n\n``` diff\n--- a/dialect.go\n+++ b/dialect.go\n@@ -170,7 +170,7 @@ func (d PostgresDialect) ToSqlType(val reflect.Type, maxsize int, isAutoIncr boo\n                return \"smallint\"\n        case \"NullableBytes\":\n                return \"bytea\"\n+       case \"Time\", \"NullTime\":\n+                return \"timestamp\"\n        }\n```\n. +1 to using the same tag name, following the convention of `encoding/json` (which, by the way, has some unexported helper functions you could copy to parse the tag).\n. I can repro these build failures if I edit gorp_test.go as follows:\n1. remove the dot-import of gorp itself: `. \"github.com/coopernurse/gorp\"`\n2. change `package gorp_test` to `package gorp`\n\n@rickb777, is it possible that you somehow had a modified gorp_test.go with those change?\n. This patch fails the tests on PostgreSQL due to the use of the bind var `?`:\n\n```\n--- FAIL: TestHooks (0.34 seconds)\ngorptest: 16:04:15.413071 select * from person_test where id = ? [[1]]\npanic: pq: S:\"ERROR\" C:\"42601\" M:\"syntax error at end of input\" P:\"39\" F:\"scan.l\" L:\"994\" R:\"scanner_yyerror\" [recovered]\n    panic: pq: S:\"ERROR\" C:\"42601\" M:\"syntax error at end of input\" P:\"39\" F:\"scan.l\" L:\"994\" R:\"scanner_yyerror\"\n\ngoroutine 12 [running]:\ntesting.func\ufffd\ufffd004()\n    /home/sqs/src/go/src/pkg/testing/testing.go:348 +0xcd\ngorp._rawselect(0xc20012f720, 0x5cd140, 0xc200148f20, 0x6d7a70, 0x26, ...)\n    /home/sqs/src/gorp/gorp_test.go:961 +0xdf\ngorp.TestHooks(0xc20012cab0)\n    /home/sqs/src/gorp/gorp_test.go:438 +0x4e9\ntesting.tRunner(0xc20012cab0, 0xa05680)\n    /home/sqs/src/go/src/pkg/testing/testing.go:353 +0x8a\ncreated by testing.RunTests\n    /home/sqs/src/go/src/pkg/testing/testing.go:433 +0x86b\n```\n\nAfter applying this diff, it passes both the PostgreSQL and SQLite tests for me:\n\n``` diff\ndiff --git a/gorp_test.go b/gorp_test.go\nindex 63485dc..6ef3e2a 100644\n--- a/gorp_test.go\n+++ b/gorp_test.go\n@@ -435,7 +435,8 @@ func TestHooks(t *testing.T) {\n        }\n\n        var persons []*Person\n-       rawselect(dbmap, &persons, \"select * from person_test where id = ?\", p1.Id)\n+       bindVar := dbmap.Dialect.BindVar(0)\n+       rawselect(dbmap, &persons, \"select * from person_test where id = \"+bindVar, p1.Id)\n        if persons[0].LName != \"postget\" {\n                t.Errorf(\"p1.PostGet() didn't run after select: %v\", p1)\n        }\n```\n. If you try to select into `var foo []*MyType` instead of a `var foo *[]*MyType` (e.g., you forget the `&` in the arg), then you get an error message that is no longer applicable with this new feature:\n`gorp: Cannot SELECT into non-struct type: []*MyType`\n\nI think this error message should be updated in this PR.\n\nBTW, I've been using this new feature for a day and have simplified a bunch of my code. It's great! And it is working well.\n. I just tried to extend it further to support flattening nested fields in non-anoymous structs (e.g., `type A struct { X, Y SomeType}; type SomeType struct { Q, P string }` would yield a table for A with columns x_q, x_p, y_q, y_p). It looks a little bit tricky because it'll require passing around a struct containing the 3 different indices that might be needed (struct field index, field name, and index in columns array), but if anybody has thoughts on how to make it easier, I'd appreciate it.\n. Great. I rebased it against the latest coopernurse/master and tests still pass. I don't want to repush to this PR branch and clobber the PR history, but the rebase was easy.\n. @aktau no, unfortunately not. Sorry for the confusing title. It only works for embedded structs.\n\nThe comment above describes the difficulties I encountered trying to find a solution for struct-type fields (\"nested structs\"): https://github.com/coopernurse/gorp/pull/42#issuecomment-18317097.\n. I don't know. It might just be a stupid thing to worry about. :) I came across it when I was using a generic \"create or update\"/upsert function on an all-PK-column table. In that case, to ensure that triggers (of which gorp is unaware) are executed, the desired behavior would be to set one or all of the columns to their current value, I think.\n\nBut I don't think it's a very important issue and regret opening it in the first place.\n. Here's a repro I had made:\n\n``` diff\ndiff --git a/gorp_test.go b/gorp_test.go\nindex 88bb59e..a7f25e6 100644\n--- a/gorp_test.go\n+++ b/gorp_test.go\n@@ -62,6 +62,10 @@ type WithStringPk struct {\n        Desc string\n }\n\n+type WithOnlyPk struct {\n+       Id int64\n+}\n+\n type CustomStringType string\n\n type TypeConversionExample struct {\n@@ -667,6 +671,15 @@ func TestWithStringPk(t *testing.T) {\n        }\n }*/\n\n+func TestWithOnlyPk(t *testing.T) {\n+       dbmap := initDbMap()\n+       defer dbmap.DropTables()\n+\n+       r1 := &WithOnlyPk{-1}\n+       insert(dbmap, r1)\n+       update(dbmap, r1)\n+}\n+\n func BenchmarkNativeCrud(b *testing.B) {\n        b.StopTimer()\n        dbmap := initDbMapBench()\n@@ -777,6 +790,7 @@ func initDbMap() *DbMap {\n        dbmap.AddTableWithName(Person{}, \"person_test\").SetKeys(true, \"Id\")\n        dbmap.AddTableWithName(WithIgnoredColumn{}, \"ignored_column_test\").SetKeys(true, \"Id\")\n        dbmap.AddTableWithName(WithStringPk{}, \"string_pk_test\").SetKeys(false, \"Id\")\n+       dbmap.AddTableWithName(WithOnlyPk{}, \"only_pk_test\").SetKeys(false, \"Id\")\n        dbmap.AddTableWithName(TypeConversionExample{}, \"type_conv_test\").SetKeys(true, \"Id\")\n        dbmap.TypeConverter = testTypeConverter{}\n        err := dbmap.CreateTables()\n\n```\n. To be consistent with encoding/json's use of a similar tag (`omitempty`), I think that the behavior should be as follows:\n- `db:\"fieldname,transient\"` sets name = fieldname and transient = true\n- `db:\",transient\"` leaves name unchanged and sets transient = true\n- `db:\"transient\"` sets name = \"transient\"\n\nIf gorp implements more flags, it will become confusing if there are several \"special\" tags (such as `transient`) that are directives, not field names.\n. FYI, I have submitted a pull request that implements support for embedded structs: https://github.com/coopernurse/gorp/pull/42\n. FWIW, I have been using the patch from above with success (with PostgreSQL).\n\n@coopernurse, adding this would be somewhat backwards incompatible (because CreateTables would use a different schema when people update gorp). Is that OK, or do you have any ideas on how to mitigate it?\n. BTW, for PostgreSQL, I would suggest mapping [`pq.NullTime`](http://godoc.org/github.com/lib/pq#NullTime) to `timestamp` as well:\n\nI.e.,\n\n``` diff\n--- a/dialect.go\n+++ b/dialect.go\n@@ -170,7 +170,7 @@ func (d PostgresDialect) ToSqlType(val reflect.Type, maxsize int, isAutoIncr boo\n                return \"smallint\"\n        case \"NullableBytes\":\n                return \"bytea\"\n+       case \"Time\", \"NullTime\":\n+                return \"timestamp\"\n        }\n```\n. +1 to using the same tag name, following the convention of `encoding/json` (which, by the way, has some unexported helper functions you could copy to parse the tag).\n. I can repro these build failures if I edit gorp_test.go as follows:\n1. remove the dot-import of gorp itself: `. \"github.com/coopernurse/gorp\"`\n2. change `package gorp_test` to `package gorp`\n\n@rickb777, is it possible that you somehow had a modified gorp_test.go with those change?\n. This patch fails the tests on PostgreSQL due to the use of the bind var `?`:\n\n```\n--- FAIL: TestHooks (0.34 seconds)\ngorptest: 16:04:15.413071 select * from person_test where id = ? [[1]]\npanic: pq: S:\"ERROR\" C:\"42601\" M:\"syntax error at end of input\" P:\"39\" F:\"scan.l\" L:\"994\" R:\"scanner_yyerror\" [recovered]\n    panic: pq: S:\"ERROR\" C:\"42601\" M:\"syntax error at end of input\" P:\"39\" F:\"scan.l\" L:\"994\" R:\"scanner_yyerror\"\n\ngoroutine 12 [running]:\ntesting.func\ufffd\ufffd004()\n    /home/sqs/src/go/src/pkg/testing/testing.go:348 +0xcd\ngorp._rawselect(0xc20012f720, 0x5cd140, 0xc200148f20, 0x6d7a70, 0x26, ...)\n    /home/sqs/src/gorp/gorp_test.go:961 +0xdf\ngorp.TestHooks(0xc20012cab0)\n    /home/sqs/src/gorp/gorp_test.go:438 +0x4e9\ntesting.tRunner(0xc20012cab0, 0xa05680)\n    /home/sqs/src/go/src/pkg/testing/testing.go:353 +0x8a\ncreated by testing.RunTests\n    /home/sqs/src/go/src/pkg/testing/testing.go:433 +0x86b\n```\n\nAfter applying this diff, it passes both the PostgreSQL and SQLite tests for me:\n\n``` diff\ndiff --git a/gorp_test.go b/gorp_test.go\nindex 63485dc..6ef3e2a 100644\n--- a/gorp_test.go\n+++ b/gorp_test.go\n@@ -435,7 +435,8 @@ func TestHooks(t *testing.T) {\n        }\n\n        var persons []*Person\n-       rawselect(dbmap, &persons, \"select * from person_test where id = ?\", p1.Id)\n+       bindVar := dbmap.Dialect.BindVar(0)\n+       rawselect(dbmap, &persons, \"select * from person_test where id = \"+bindVar, p1.Id)\n        if persons[0].LName != \"postget\" {\n                t.Errorf(\"p1.PostGet() didn't run after select: %v\", p1)\n        }\n```\n. If you try to select into `var foo []*MyType` instead of a `var foo *[]*MyType` (e.g., you forget the `&` in the arg), then you get an error message that is no longer applicable with this new feature:\n`gorp: Cannot SELECT into non-struct type: []*MyType`\n\nI think this error message should be updated in this PR.\n\nBTW, I've been using this new feature for a day and have simplified a bunch of my code. It's great! And it is working well.\n. I just tried to extend it further to support flattening nested fields in non-anoymous structs (e.g., `type A struct { X, Y SomeType}; type SomeType struct { Q, P string }` would yield a table for A with columns x_q, x_p, y_q, y_p). It looks a little bit tricky because it'll require passing around a struct containing the 3 different indices that might be needed (struct field index, field name, and index in columns array), but if anybody has thoughts on how to make it easier, I'd appreciate it.\n. Great. I rebased it against the latest coopernurse/master and tests still pass. I don't want to repush to this PR branch and clobber the PR history, but the rebase was easy.\n. @aktau no, unfortunately not. Sorry for the confusing title. It only works for embedded structs.\n\nThe comment above describes the difficulties I encountered trying to find a solution for struct-type fields (\"nested structs\"): https://github.com/coopernurse/gorp/pull/42#issuecomment-18317097.\n. I don't know. It might just be a stupid thing to worry about. :) I came across it when I was using a generic \"create or update\"/upsert function on an all-PK-column table. In that case, to ensure that triggers (of which gorp is unaware) are executed, the desired behavior would be to set one or all of the columns to their current value, I think.\n\nBut I don't think it's a very important issue and regret opening it in the first place.\n. Here's a repro I had made:\n\n``` diff\ndiff --git a/gorp_test.go b/gorp_test.go\nindex 88bb59e..a7f25e6 100644\n--- a/gorp_test.go\n+++ b/gorp_test.go\n@@ -62,6 +62,10 @@ type WithStringPk struct {\n        Desc string\n }\n\n+type WithOnlyPk struct {\n+       Id int64\n+}\n+\n type CustomStringType string\n\n type TypeConversionExample struct {\n@@ -667,6 +671,15 @@ func TestWithStringPk(t *testing.T) {\n        }\n }*/\n\n+func TestWithOnlyPk(t *testing.T) {\n+       dbmap := initDbMap()\n+       defer dbmap.DropTables()\n+\n+       r1 := &WithOnlyPk{-1}\n+       insert(dbmap, r1)\n+       update(dbmap, r1)\n+}\n+\n func BenchmarkNativeCrud(b *testing.B) {\n        b.StopTimer()\n        dbmap := initDbMapBench()\n@@ -777,6 +790,7 @@ func initDbMap() *DbMap {\n        dbmap.AddTableWithName(Person{}, \"person_test\").SetKeys(true, \"Id\")\n        dbmap.AddTableWithName(WithIgnoredColumn{}, \"ignored_column_test\").SetKeys(true, \"Id\")\n        dbmap.AddTableWithName(WithStringPk{}, \"string_pk_test\").SetKeys(false, \"Id\")\n+       dbmap.AddTableWithName(WithOnlyPk{}, \"only_pk_test\").SetKeys(false, \"Id\")\n        dbmap.AddTableWithName(TypeConversionExample{}, \"type_conv_test\").SetKeys(true, \"Id\")\n        dbmap.TypeConverter = testTypeConverter{}\n        err := dbmap.CreateTables()\n\n```\n. To be consistent with encoding/json's use of a similar tag (`omitempty`), I think that the behavior should be as follows:\n- `db:\"fieldname,transient\"` sets name = fieldname and transient = true\n- `db:\",transient\"` leaves name unchanged and sets transient = true\n- `db:\"transient\"` sets name = \"transient\"\n\nIf gorp implements more flags, it will become confusing if there are several \"special\" tags (such as `transient`) that are directives, not field names.\n. ",
    "ghost": "Why not just follow the standard (ie: http://golang.org/pkg/encoding/json/#Marshal)\n\n```\n\ntype User struct {\n    Uid         int     `db:\"uid\"`\n    Name        string  `db:\"name\"`\n    Password    string  `db:\"password\"`\n    GroupUid    int     `db:\"group_uid\"`\n    SomeQuestion    bool    `db:\"-\"`\n}\n```\n\nThe hyphen for SomeQuestion means ignore\n. Thanks!\n\nOn Wed, Feb 26, 2014 at 3:33 PM, James Cooper notifications@github.comwrote:\n\n> This is in develop now. I'll merge to master later in the week as v1.5.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/coopernurse/gorp/pull/141#issuecomment-36191699\n> .\n. I didn't see a PreGet method listed for a hook but I tried:\n\n```\nfunc (p *Person) PreGet(s gorp.SqlExecutor) error {\n    log.Println(\"Resetting timeout...\")\n    if _, err := dbmap.Exec(\"BEGIN; SET SESSION STATEMENT_TIMEOUT TO 1; COMMIT;\"); err != nil {\n        log.Println(err)\n}\n    return nil\n}\n```\n\nbut it doesn't seem to execute ;(\n. Why not just follow the standard (ie: http://golang.org/pkg/encoding/json/#Marshal)\n\n```\n\ntype User struct {\n    Uid         int     `db:\"uid\"`\n    Name        string  `db:\"name\"`\n    Password    string  `db:\"password\"`\n    GroupUid    int     `db:\"group_uid\"`\n    SomeQuestion    bool    `db:\"-\"`\n}\n```\n\nThe hyphen for SomeQuestion means ignore\n. Thanks!\n\nOn Wed, Feb 26, 2014 at 3:33 PM, James Cooper notifications@github.comwrote:\n\n> This is in develop now. I'll merge to master later in the week as v1.5.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/coopernurse/gorp/pull/141#issuecomment-36191699\n> .\n. I didn't see a PreGet method listed for a hook but I tried:\n\n```\nfunc (p *Person) PreGet(s gorp.SqlExecutor) error {\n    log.Println(\"Resetting timeout...\")\n    if _, err := dbmap.Exec(\"BEGIN; SET SESSION STATEMENT_TIMEOUT TO 1; COMMIT;\"); err != nil {\n        log.Println(err)\n}\n    return nil\n}\n```\n\nbut it doesn't seem to execute ;(\n. ",
    "tmc": "@sadris we discussed that here https://github.com/traviscline/gorp/commit/891fec9580f65f08c7c1f6372fe81e7b9d03cc0e\nFWIW\n. closing, will open another with updated approach\n. Not too complicated. Would be nice to ship that mapper (not just the helper function). How about enabling a skip flag on ColumnMap or an additional return value to address that other issue?\n. +1\n. @sadris we discussed that here https://github.com/traviscline/gorp/commit/891fec9580f65f08c7c1f6372fe81e7b9d03cc0e\nFWIW\n. closing, will open another with updated approach\n. Not too complicated. Would be nice to ship that mapper (not just the helper function). How about enabling a skip flag on ColumnMap or an additional return value to address that other issue?\n. +1\n. ",
    "jaybill": "I really like this idea and I think having both a hook to add a mapper and having a couple of \"stock\" mappers you could plug into it should address every case I can come up with.\n. I really like this idea and I think having both a hook to add a mapper and having a couple of \"stock\" mappers you could plug into it should address every case I can come up with.\n. ",
    "multiplegeorges": ":+1:\n. Hi @rvenugopal, thanks for the tip.\nHowever, I am looking for the opposite.\n\nHere's an example struct and table schema.\n\n``` go\ntype Person struct {\n   Id int64 `db:\"id\"`\n   FirstName string `db:\"first_name\"`\n   LastName string `db:\"last_name\"`\n}\n```\n\n``` sql\nCREATE TABLE \"public\".\"people\" (\n    \"id\" int4 NOT NULL DEFAULT nextval('people_id_seq'::regclass),\n    \"first_name\" varchar(255),\n    \"last_name\" varchar(255),\n    \"email_address\" varchar(255),\n    \"lat\" numeric,\n    \"lng\" numeric\n)\n```\n\nThe application I am making only cares about first_name and last_name, but gorp doesn't allow a model struct to ignore email_address, lat, and lng. They _must_ be fields in the struct, per https://github.com/coopernurse/gorp/blob/develop/gorp.go#L1611\n. :+1:\n. Hi @rvenugopal, thanks for the tip.\nHowever, I am looking for the opposite.\n\nHere's an example struct and table schema.\n\n``` go\ntype Person struct {\n   Id int64 `db:\"id\"`\n   FirstName string `db:\"first_name\"`\n   LastName string `db:\"last_name\"`\n}\n```\n\n``` sql\nCREATE TABLE \"public\".\"people\" (\n    \"id\" int4 NOT NULL DEFAULT nextval('people_id_seq'::regclass),\n    \"first_name\" varchar(255),\n    \"last_name\" varchar(255),\n    \"email_address\" varchar(255),\n    \"lat\" numeric,\n    \"lng\" numeric\n)\n```\n\nThe application I am making only cares about first_name and last_name, but gorp doesn't allow a model struct to ignore email_address, lat, and lng. They _must_ be fields in the struct, per https://github.com/coopernurse/gorp/blob/develop/gorp.go#L1611\n. ",
    "robfig": "Woops, I apologize for the \"time\" import slipping in the go fmt commit.  I was also working on the time support and didn't mean to commit that part. \n. Yes, mysql supports it, but sqlite does not.  \n\nBefore opening this issue, I tried to create a patch to go-sqlite3 that could allow Scanning into a time.Time, but I found it was not possible because sqlite does not have a real datetime type.  When scanning, we only have the driver-provided type, which is one of the values you can see in sqlite3.h: (SQLITE_INTEGER, _FLOAT, _BLOB, _NULL, _TEXT).  At the driver level, it appeared to be impossible to conditionally produce a time.Time value only if the caller is scanning into a time.Time, and a string otherwise.  \n\nThis does seem like a case that applies to sqlite but not mysql, postgres, oracle, etc, so I'm not sure if you want to provide a fix in Gorp, but it could be useful since sqlite is pretty common.\n\nThe changes to support it in Gorp seem to be:\n- Using the \"datetime\" column type for time.Time struct fields.  (Which is a valid sqlite type even though it's just sugar for string, I think)\n- When scanning into struct fields, notice that the destination struct field is a time.Time and instead scan into a string, which you then time.Time.Parse() into the time.Time. \n\n(I believe that queries that pass a time.Time as an argument may already work)\n. Hm, I'm not sure that's relevant here -- the snippet you quote for MySQL seems like a detail of how the TIMESTAMP is stored.  For example it says that MySQL does the conversion on its end, not that the user has to.  For both TIMESTAMP and DATETIME, if you store a value and then read it back, you should read exactly what you wrote.  (That's what @coopernurse means about being symmetric).  \n\nAs to what the issue is, I don't have an idea just from reading this thread.  I would have guessed that it is an unwanted timezone conversion happening on the Go side in time.Time (I've used it a lot and still don't feel like I have a good grasp of how it handles timezones), but the Postgres test works properly, so I'm not sure.\n\nI can potentially debug it later this week (busy with the day job though)\n. This looks convenient.\n. It looks like the only way to read row data through a gorp Transaction is by using Select(), which selects it into a model.  I'm not sure how I could use that to read the result of my \"select count(*)..\" -- now that I think of it, I guess I could name the result and create a type with just that field to use as the receiver for the select. \n\nThat does seem quite cumbersome, and the example you gave would seem to handle it nicely.  I don't believe it is possible to implement the code snippet you quoted since []interface{} is not trivially convertable to a slice of any primitive type, though.  \n\nI only suggest making it possible to get the underlying sql.Transaction since that would be the easy way out -- kudos on trying to drive to a more comprehensive solution.\n. That looks very convenient!  Thank you\n. Ask and ye shall receive :)\n\nDoesn't look like the commit preserves backwards compatibility though (shouldn't be too hard to do...)\n. I'm back from vacation and happy to work on this.  I could take @ottob 's code and change it to be backwards compatible, if you'd like. \n. I've been using Go1.1 and Gorp works for me (OSX / Linux) \n. Thanks for testing it out @sqs !  I applied your patch.  Tests continue to pass on MySQL. \n. Looks like SelectInt now exists on Transaction, so that should handle this case. \nhttp://godoc.org/github.com/coopernurse/gorp#Transaction.SelectInt\n\n(I do agree overall that the best interface is passing a pointer to have the data written to rather than returning it as a return value)\n. If this sounds good, I could probably get a pull request together this week...\n. Hm, thinking about this again, that proposal transfers the concern from adding a column to the DB to adding a column to the struct.  I suppose in the struct you can at least make a new field un-exported, or add a db=\"-\" tag..\n\nWhat I've been doing is just explicitly writing out the fields, always, and it's not really so bad.  And it is the only way it could work when you select derived columns, anyway.  Maybe that is the thing that should be encouraged.. \n. It should work on anything that uses rawselect.  That being said, having some tests that it works for those methods wouldn't be terrible either \n. Ah, those use selectVal instead of rawselect.  I'll add a commit that includes support for values as well. \n. Added.. one complication was that I need the Dialect, but that is not available from the SqlExecutor.  Rather than adding a SqlDialect() method to the interface, I just do a type switch, but I'm happy to change that if you think that extra method makes sense. \n. At least in MySQL, parameters are sent separately from the query.  The client library does not do the escaping; the server does.\n. That does bring up the possibility of either:\n- Implementing sql escaping for strings \n- Limiting the IN (?) syntax to ids ints, which do not require escaping. \n. Your objections seem to be:\n1. The behavior would be surprising. \n2. Removes ability to use prepared statements\n3. Escaping in Go would be brittle and less efficient.\n\nI'm not sure if you object to the overall idea or only the implementation suggested by @purohit -- in any case, I think none of those objections apply to the suggestion as originally posed (which does not involve SQL escaping in Go).  I see no reason why the current behavior is less surprising than having IN (?) expand a slice parameter, there is no ability currently to use prepared statements (and Gorp could transparently add a prepared statement cache anyway), and the initial suggestion does not involve escaping in Go. \n. Sure, part of the Dialect makes sense.  I agree that expecting to manipulate the query in all cases is too challenging.  For example, in SQLite alone there appear to be 5 different types of placeholders: \nhttp://www.sqlite.org/c3ref/bind_blob.html\n\nOn the other side of the spectrum, MySQL just requires a sequence of '?' to be generated, which is absolutely trivial and which I could be pretty confident would not go wrong.\n\nWith respect to \"How do we know if it's meant to be a slice or a single valued []byte\", we could say that a list-valued parameter has to have a type marker wrapping, e.g.\n\n``` go\ntype List interface{}\n\ndbm.Select(&objs, \"select id, name from foo where id in (?)\", gorp.List(ids)) \n```\n\nShrug.  It may be too brittle to implement for more complicated placeholders.  On the other side, making everyone implement their own seems like a shame.\n. Very nice.  I'll give it a shot, thanks. \n. Sorry, you're completely right.  Not sure why I had that impression.  Thanks!\n. Yeah -- too bad since it seems like returning ErrNoRows could be helpful for SelectInt too, but I think that ship has sailed\n\nI think your bulleted plan is the right one.  It is explicit and roughly the smallest change possible.  I think that I or one of my colleagues can provide a fix before long\n. Woops, I apologize for the \"time\" import slipping in the go fmt commit.  I was also working on the time support and didn't mean to commit that part. \n. Yes, mysql supports it, but sqlite does not.  \n\nBefore opening this issue, I tried to create a patch to go-sqlite3 that could allow Scanning into a time.Time, but I found it was not possible because sqlite does not have a real datetime type.  When scanning, we only have the driver-provided type, which is one of the values you can see in sqlite3.h: (SQLITE_INTEGER, _FLOAT, _BLOB, _NULL, _TEXT).  At the driver level, it appeared to be impossible to conditionally produce a time.Time value only if the caller is scanning into a time.Time, and a string otherwise.  \n\nThis does seem like a case that applies to sqlite but not mysql, postgres, oracle, etc, so I'm not sure if you want to provide a fix in Gorp, but it could be useful since sqlite is pretty common.\n\nThe changes to support it in Gorp seem to be:\n- Using the \"datetime\" column type for time.Time struct fields.  (Which is a valid sqlite type even though it's just sugar for string, I think)\n- When scanning into struct fields, notice that the destination struct field is a time.Time and instead scan into a string, which you then time.Time.Parse() into the time.Time. \n\n(I believe that queries that pass a time.Time as an argument may already work)\n. Hm, I'm not sure that's relevant here -- the snippet you quote for MySQL seems like a detail of how the TIMESTAMP is stored.  For example it says that MySQL does the conversion on its end, not that the user has to.  For both TIMESTAMP and DATETIME, if you store a value and then read it back, you should read exactly what you wrote.  (That's what @coopernurse means about being symmetric).  \n\nAs to what the issue is, I don't have an idea just from reading this thread.  I would have guessed that it is an unwanted timezone conversion happening on the Go side in time.Time (I've used it a lot and still don't feel like I have a good grasp of how it handles timezones), but the Postgres test works properly, so I'm not sure.\n\nI can potentially debug it later this week (busy with the day job though)\n. This looks convenient.\n. It looks like the only way to read row data through a gorp Transaction is by using Select(), which selects it into a model.  I'm not sure how I could use that to read the result of my \"select count(*)..\" -- now that I think of it, I guess I could name the result and create a type with just that field to use as the receiver for the select. \n\nThat does seem quite cumbersome, and the example you gave would seem to handle it nicely.  I don't believe it is possible to implement the code snippet you quoted since []interface{} is not trivially convertable to a slice of any primitive type, though.  \n\nI only suggest making it possible to get the underlying sql.Transaction since that would be the easy way out -- kudos on trying to drive to a more comprehensive solution.\n. That looks very convenient!  Thank you\n. Ask and ye shall receive :)\n\nDoesn't look like the commit preserves backwards compatibility though (shouldn't be too hard to do...)\n. I'm back from vacation and happy to work on this.  I could take @ottob 's code and change it to be backwards compatible, if you'd like. \n. I've been using Go1.1 and Gorp works for me (OSX / Linux) \n. Thanks for testing it out @sqs !  I applied your patch.  Tests continue to pass on MySQL. \n. Looks like SelectInt now exists on Transaction, so that should handle this case. \nhttp://godoc.org/github.com/coopernurse/gorp#Transaction.SelectInt\n\n(I do agree overall that the best interface is passing a pointer to have the data written to rather than returning it as a return value)\n. If this sounds good, I could probably get a pull request together this week...\n. Hm, thinking about this again, that proposal transfers the concern from adding a column to the DB to adding a column to the struct.  I suppose in the struct you can at least make a new field un-exported, or add a db=\"-\" tag..\n\nWhat I've been doing is just explicitly writing out the fields, always, and it's not really so bad.  And it is the only way it could work when you select derived columns, anyway.  Maybe that is the thing that should be encouraged.. \n. It should work on anything that uses rawselect.  That being said, having some tests that it works for those methods wouldn't be terrible either \n. Ah, those use selectVal instead of rawselect.  I'll add a commit that includes support for values as well. \n. Added.. one complication was that I need the Dialect, but that is not available from the SqlExecutor.  Rather than adding a SqlDialect() method to the interface, I just do a type switch, but I'm happy to change that if you think that extra method makes sense. \n. At least in MySQL, parameters are sent separately from the query.  The client library does not do the escaping; the server does.\n. That does bring up the possibility of either:\n- Implementing sql escaping for strings \n- Limiting the IN (?) syntax to ids ints, which do not require escaping. \n. Your objections seem to be:\n1. The behavior would be surprising. \n2. Removes ability to use prepared statements\n3. Escaping in Go would be brittle and less efficient.\n\nI'm not sure if you object to the overall idea or only the implementation suggested by @purohit -- in any case, I think none of those objections apply to the suggestion as originally posed (which does not involve SQL escaping in Go).  I see no reason why the current behavior is less surprising than having IN (?) expand a slice parameter, there is no ability currently to use prepared statements (and Gorp could transparently add a prepared statement cache anyway), and the initial suggestion does not involve escaping in Go. \n. Sure, part of the Dialect makes sense.  I agree that expecting to manipulate the query in all cases is too challenging.  For example, in SQLite alone there appear to be 5 different types of placeholders: \nhttp://www.sqlite.org/c3ref/bind_blob.html\n\nOn the other side of the spectrum, MySQL just requires a sequence of '?' to be generated, which is absolutely trivial and which I could be pretty confident would not go wrong.\n\nWith respect to \"How do we know if it's meant to be a slice or a single valued []byte\", we could say that a list-valued parameter has to have a type marker wrapping, e.g.\n\n``` go\ntype List interface{}\n\ndbm.Select(&objs, \"select id, name from foo where id in (?)\", gorp.List(ids)) \n```\n\nShrug.  It may be too brittle to implement for more complicated placeholders.  On the other side, making everyone implement their own seems like a shame.\n. Very nice.  I'll give it a shot, thanks. \n. Sorry, you're completely right.  Not sure why I had that impression.  Thanks!\n. Yeah -- too bad since it seems like returning ErrNoRows could be helpful for SelectInt too, but I think that ship has sailed\n\nI think your bulleted plan is the right one.  It is explicit and roughly the smallest change possible.  I think that I or one of my colleagues can provide a fix before long\n. ",
    "chrisfarms": "The Postgres pq driver supports `time.Time` in `Scan` ... it would be a nice simple addition to the `PostgresDialect#ToSqlType` type switch statement to add something like:\n\n```\n    case \"Time\":\n        return \"timestamp\"\n```\n\nwhich should allow `CreateTables` to do it's thing\n. The Postgres pq driver supports `time.Time` in `Scan` ... it would be a nice simple addition to the `PostgresDialect#ToSqlType` type switch statement to add something like:\n\n```\n    case \"Time\":\n        return \"timestamp\"\n```\n\nwhich should allow `CreateTables` to do it's thing\n. ",
    "mikfoo": "I had the same issue, but with MySQL. Applying @chrisfarms' patch under the MySQLDialect solved it for me.\n\n**edit:** The fix only works with [MyMySQL](http://github.com/ziutek/mymysql/godrv) and not [Go-SQL-Driver](http://github.com/go-sql-driver/mysql), not sure why.\n**edit2:** This might be related? https://github.com/go-sql-driver/mysql#timetime-support\n. I had the same issue, but with MySQL. Applying @chrisfarms' patch under the MySQLDialect solved it for me.\n\n**edit:** The fix only works with [MyMySQL](http://github.com/ziutek/mymysql/godrv) and not [Go-SQL-Driver](http://github.com/go-sql-driver/mysql), not sure why.\n**edit2:** This might be related? https://github.com/go-sql-driver/mysql#timetime-support\n. ",
    "pix64": "\"MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as DATETIME.)\"\nhttp://dev.mysql.com/doc/refman/5.0/en/datetime.html\n\nYou want to use TIMESTAMP instead of DATETIME for MySQL.\n\nPostgresSQL should use \"timestamp with time zone\"\n\n\"For timestamp with time zone, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT)\"\nhttp://www.postgresql.org/docs/9.1/static/datatype-datetime.html\n. \"MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as DATETIME.)\"\nhttp://dev.mysql.com/doc/refman/5.0/en/datetime.html\n\nYou want to use TIMESTAMP instead of DATETIME for MySQL.\n\nPostgresSQL should use \"timestamp with time zone\"\n\n\"For timestamp with time zone, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT)\"\nhttp://www.postgresql.org/docs/9.1/static/datatype-datetime.html\n. ",
    "seehuhn": "Hi,\n\nNot sure if this is relevant (and my apologies if it is not), but just for the record: the first post here seems to indicate that sqlite3 is not able to store time.Time objects natively.  Did I understand this right?  If so, this problem seems to be fixed in the mean time.  The following program successfully stores a time.Time value in an sqlite3 database for me: https://gist.github.com/seehuhn/6197736 .\n\nTimezone information is lost (i.e. the result is always int UTC), but the result after retrieval denotes the same point in time, i.e. .UnixNano() returns the same value.\n\nAll the best,\nJochen\n. I have now updated the pull request to use \"timestamp with time zone\" as suggested by Joe Shaw.  Since I don't have a PostgreSQL installation around, I can't test the change.  Could somebody test the new pull request and see whether it all works as expected?\n. Hi,\n\nNot sure if this is relevant (and my apologies if it is not), but just for the record: the first post here seems to indicate that sqlite3 is not able to store time.Time objects natively.  Did I understand this right?  If so, this problem seems to be fixed in the mean time.  The following program successfully stores a time.Time value in an sqlite3 database for me: https://gist.github.com/seehuhn/6197736 .\n\nTimezone information is lost (i.e. the result is always int UTC), but the result after retrieval denotes the same point in time, i.e. .UnixNano() returns the same value.\n\nAll the best,\nJochen\n. I have now updated the pull request to use \"timestamp with time zone\" as suggested by Joe Shaw.  Since I don't have a PostgreSQL installation around, I can't test the change.  Could somebody test the new pull request and see whether it all works as expected?\n. ",
    "damoxc": "Added in quoting to all other cases I could see where a column name was being used in a SQL query.\n. Added in quoting to all other cases I could see where a column name was being used in a SQL query.\n. ",
    "FAQinghere": "The other thing good about this is that it would allow us to case our DB entities to match our Go structs.\n. The other thing good about this is that it would allow us to case our DB entities to match our Go structs.\n. ",
    "lionelbarrow": "Both those solutions would work -- you can wrap the INSERT and SELECT queries inside a transaction within gorp, or you can write an ExecAndReturnId method that runs an `INSERT ... RETURNING` query.\n\nWhen we wrote our internal hack, we tried out both and decided that the `INSERT .. RETURNING` query was much cleaner than using a transaction. I can see that it forces gorp's internal architecture to change quite a bit though.\n. Awesome.\n\nI agree that this could have been avoided if the sql package was more robust. For a sad time, look at the source code for the database/sql package and search for \"TODO\". http://golang.org/src/pkg/database/sql/sql.go\n. Great! I'll check it out this weekend.\n. Both those solutions would work -- you can wrap the INSERT and SELECT queries inside a transaction within gorp, or you can write an ExecAndReturnId method that runs an `INSERT ... RETURNING` query.\n\nWhen we wrote our internal hack, we tried out both and decided that the `INSERT .. RETURNING` query was much cleaner than using a transaction. I can see that it forces gorp's internal architecture to change quite a bit though.\n. Awesome.\n\nI agree that this could have been avoided if the sql package was more robust. For a sad time, look at the source code for the database/sql package and search for \"TODO\". http://golang.org/src/pkg/database/sql/sql.go\n. Great! I'll check it out this weekend.\n. ",
    "lukescott": "I would personally prefer \"name,autoincrement\" and \"name,primary\" over \"name,pk,autoincrement\" and \"name,pk\". In the case of \"autoincrement\", \"primary\" would naturally be assumed.\n. There needs to be more control over types. I made a suggestion in this issue here https://github.com/coopernurse/gorp/issues/58.\n\nMy biggest issue is some of my types need to be BINARY. For now I think I'm going to create tables manually.\n. The problem I have with `TypeConverter` is that it converts all types - It has to know about every type, and uses a switch-type to do the conversion. I was trying to figure out something more flexible. Something that would make each type modular and not have to be in the same package. Each type should know how to convert itself.\n\nWith `TypeCodec` I was thinking about encoding/json's Encode/Decode functions. The intent was you'd have a `TypeCodec` per type. But I thought about it more, and I like encoding/json's `type Marshaler interface` and `type Unmarshaler interface` better, so I updated the post above with that idea.\n. Yep, to maintain backwards compatibility. I changed `TypeCodec` to  `Marshaler` and `Unmarshaler` in the opening post to mimic encoding/json closer.\n\nAs far as the enum thing, I'm not too sure. Perhaps something along the lines of:\n\n`db:\",enum:'One';'Two';'Three'\"`\n\nBasically put the list where the length goes. That's how PHPMyAdmin does it (although I'm using `;` instead of `,` as a separator since `,` is spoke for).\n. I would personally prefer \"name,autoincrement\" and \"name,primary\" over \"name,pk,autoincrement\" and \"name,pk\". In the case of \"autoincrement\", \"primary\" would naturally be assumed.\n. There needs to be more control over types. I made a suggestion in this issue here https://github.com/coopernurse/gorp/issues/58.\n\nMy biggest issue is some of my types need to be BINARY. For now I think I'm going to create tables manually.\n. The problem I have with `TypeConverter` is that it converts all types - It has to know about every type, and uses a switch-type to do the conversion. I was trying to figure out something more flexible. Something that would make each type modular and not have to be in the same package. Each type should know how to convert itself.\n\nWith `TypeCodec` I was thinking about encoding/json's Encode/Decode functions. The intent was you'd have a `TypeCodec` per type. But I thought about it more, and I like encoding/json's `type Marshaler interface` and `type Unmarshaler interface` better, so I updated the post above with that idea.\n. Yep, to maintain backwards compatibility. I changed `TypeCodec` to  `Marshaler` and `Unmarshaler` in the opening post to mimic encoding/json closer.\n\nAs far as the enum thing, I'm not too sure. Perhaps something along the lines of:\n\n`db:\",enum:'One';'Two';'Three'\"`\n\nBasically put the list where the length goes. That's how PHPMyAdmin does it (although I'm using `;` instead of `,` as a separator since `,` is spoke for).\n. ",
    "insasho": "@lukescott auto-increment columns are not always primary keys.\n. -1. I'm new to gorp but I've written numerous database abstraction layers in the past. Rewriting the user-provided query string would violate expectations of any users expecting Gorp to behave like other ORMs or database libraries, and it could reduce efficiency due to the inability to reuse pre-existing prepared statements.  Implementing escaping in Go could also be less efficient and will result in challenges relating to character encodings. Using placeholders as they are designed to be used, and letting the underlying database libraries handle the details, will result in a cleaner and less surprising Gorp. \n. Objection #1 still applies to @coopernurse's idea as well as your original suggestion, but as I've thought about this more I'm thinking the productivity wins, sometimes-confusing error messages, and other minor issues would perhaps be worth it _if_ the manipulation is implemented in database-specific Dialects rather than on all operations.\n\nThe origin of my concern is that it requires Gorp to become confident in manipulating the query string provided by the user for the interpretation of the database. Not all query strings look like \"SQL\" -- for example, ODBC drivers support bizarre operations and syntaxes, complex statements like stored procedure definitions can contain ?s unsuitable for replacement, numbered placeholders, named placeholders, Postgres array notation, embedded scripting languages could use ? as an operator, etc -- but the majority of these could be addressed if Gorp only attempts to perform these operations when they are not likely to cause issues. Implementing them on Dialect might be the right place. Another benefit of adding it to Dialect is that it becomes user-configurable.\n\nAlso, the database/sql driver Valuer interface allows slices of bytes. It is thus reasonable to allow passing a slice of bytes as a query parameter when writing queries that touch blobs. There may be other cases like this that would require special treatment, so marking the slices to expand with a wrapper might be the safest thing to do.\n\nI agree that the prepared statement cache could be added safely later.\n. +1 to the List wrapper.\n\nAnother option would be to support Gorp-specific markup that isn't specific to any dialect but would let the developer register handlers for well-defined tags. Example:\n\n```\nSELECT id, name FROM foo WHERE id IN ({{list \"ids\"}})\n```\n\nor even:\n\n```\ndbm.Exec(\"INSERT INTO t1 (c1, c2, c3) VALUES\n  {{values t}}}\", [][]interface{}{{\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"}})\n```\n\n... which would prepare the following placeholder-applicable statement:\n\n```\nINSERT INTO t1 (c1, c2, c3) VALUES\n  (?, ?, ?),\n  (?, ?, ?);\n```\n\nThe template-based approach shifts the burden of syntactical correctness onto the developer, which might be less surprising and require less magic overall.\n. @lukescott auto-increment columns are not always primary keys.\n. -1. I'm new to gorp but I've written numerous database abstraction layers in the past. Rewriting the user-provided query string would violate expectations of any users expecting Gorp to behave like other ORMs or database libraries, and it could reduce efficiency due to the inability to reuse pre-existing prepared statements.  Implementing escaping in Go could also be less efficient and will result in challenges relating to character encodings. Using placeholders as they are designed to be used, and letting the underlying database libraries handle the details, will result in a cleaner and less surprising Gorp. \n. Objection #1 still applies to @coopernurse's idea as well as your original suggestion, but as I've thought about this more I'm thinking the productivity wins, sometimes-confusing error messages, and other minor issues would perhaps be worth it _if_ the manipulation is implemented in database-specific Dialects rather than on all operations.\n\nThe origin of my concern is that it requires Gorp to become confident in manipulating the query string provided by the user for the interpretation of the database. Not all query strings look like \"SQL\" -- for example, ODBC drivers support bizarre operations and syntaxes, complex statements like stored procedure definitions can contain ?s unsuitable for replacement, numbered placeholders, named placeholders, Postgres array notation, embedded scripting languages could use ? as an operator, etc -- but the majority of these could be addressed if Gorp only attempts to perform these operations when they are not likely to cause issues. Implementing them on Dialect might be the right place. Another benefit of adding it to Dialect is that it becomes user-configurable.\n\nAlso, the database/sql driver Valuer interface allows slices of bytes. It is thus reasonable to allow passing a slice of bytes as a query parameter when writing queries that touch blobs. There may be other cases like this that would require special treatment, so marking the slices to expand with a wrapper might be the safest thing to do.\n\nI agree that the prepared statement cache could be added safely later.\n. +1 to the List wrapper.\n\nAnother option would be to support Gorp-specific markup that isn't specific to any dialect but would let the developer register handlers for well-defined tags. Example:\n\n```\nSELECT id, name FROM foo WHERE id IN ({{list \"ids\"}})\n```\n\nor even:\n\n```\ndbm.Exec(\"INSERT INTO t1 (c1, c2, c3) VALUES\n  {{values t}}}\", [][]interface{}{{\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"}})\n```\n\n... which would prepare the following placeholder-applicable statement:\n\n```\nINSERT INTO t1 (c1, c2, c3) VALUES\n  (?, ?, ?),\n  (?, ?, ?);\n```\n\nThe template-based approach shifts the burden of syntactical correctness onto the developer, which might be less surprising and require less magic overall.\n. ",
    "meetmauro": "OK. Rebased and made suggested changes in a new PR.\n. Let me check. For the tests I did it seemed to behave.\n. OK :) forgot to add the autoincrement label in the tests, now it seems to be passing\n. OK. Rebased and made suggested changes in a new PR.\n. Let me check. For the tests I did it seemed to behave.\n. OK :) forgot to add the autoincrement label in the tests, now it seems to be passing\n. ",
    "cloudtrends": "Yes!  +1\n\nTo add text is very necessary!\n. Yes!  +1\n\nTo add text is very necessary!\n. ",
    "jamesaanderson": ":+1: \n. :+1: \n. ",
    "rvenugopal": "+1\n. Sorry about this.  After cleaning up and re-installing gorp on my computer this works now.\n. I think it would have to be the struct fields as unless I am writing the sql, I am not thinking in terms of columns but more about my model.\n\nI am not sure how reflection can be brought to play here.  I must admit I am fairly new to golang so I might be missing something which might be obvious to you.\n\nI know that mgo provides no type safety but that is to be expected as it is working against mongodb.  \n\nHere is how hibernate manages this (by setting annotation dynamic-update for the class)\nhttp://www.mkyong.com/hibernate/hibernate-dynamic-update-attribute-example/\n\nGorp could do something similar.  However, Hibernate has a level2 cache which can be used to compare which fields are dirty to generate this.  As gorp does not have a level2 cache, I can think of 2 approaches\n\na) Compare every field against default value for that type(0 for int, empty for string etc).  If it is NOT a default, then use the property while generating the sql.  Else ignore.  \n\nb) Pass an array of struct field names as either include/exclude list like I mentioned in the original issue description) containing which attributes need to be included/excluded in the update statement.\n. Thanks for the clarification\n. You can do this using  `db:\"-\"` \n\n```\ntype MyLargeModel struct {\n    Id              int64  `db:\"id\"`\n\n    PropertyTobeIgnoredByDatabase  bool   `db:\"-\"`\n\n}\n\n```\n. +1\n. Sorry about this.  After cleaning up and re-installing gorp on my computer this works now.\n. I think it would have to be the struct fields as unless I am writing the sql, I am not thinking in terms of columns but more about my model.\n\nI am not sure how reflection can be brought to play here.  I must admit I am fairly new to golang so I might be missing something which might be obvious to you.\n\nI know that mgo provides no type safety but that is to be expected as it is working against mongodb.  \n\nHere is how hibernate manages this (by setting annotation dynamic-update for the class)\nhttp://www.mkyong.com/hibernate/hibernate-dynamic-update-attribute-example/\n\nGorp could do something similar.  However, Hibernate has a level2 cache which can be used to compare which fields are dirty to generate this.  As gorp does not have a level2 cache, I can think of 2 approaches\n\na) Compare every field against default value for that type(0 for int, empty for string etc).  If it is NOT a default, then use the property while generating the sql.  Else ignore.  \n\nb) Pass an array of struct field names as either include/exclude list like I mentioned in the original issue description) containing which attributes need to be included/excluded in the update statement.\n. Thanks for the clarification\n. You can do this using  `db:\"-\"` \n\n```\ntype MyLargeModel struct {\n    Id              int64  `db:\"id\"`\n\n    PropertyTobeIgnoredByDatabase  bool   `db:\"-\"`\n\n}\n\n```\n. ",
    "mrwnmonm": "+1\n. +1\n. ",
    "anentropic": "seems an elementary feature... issue opened a year ago... no comment from project owner... doesn't look good?\n. seems an elementary feature... issue opened a year ago... no comment from project owner... doesn't look good?\n. ",
    "mauleyzaola": "I fully agree with the comments above. For me, working only with Postgresql databases it is impossible to take GORM seriously without this feature.\n. @vinceyuan No worries, it is doable and thanks for the info :+1: I was just little upset when I wrote that :smile: \n. I fully agree with the comments above. For me, working only with Postgresql databases it is impossible to take GORM seriously without this feature.\n. @vinceyuan No worries, it is doable and thanks for the info :+1: I was just little upset when I wrote that :smile: \n. ",
    "sinni800": "I think a really easy change would be to add a new attribute to ColumnMap to override the SQL type. Since TEXT, for example, can be used just like varchar anyway, that could work out in this case.\n\nI mean we can override the column size, so why not the column type, too?\n. I think a really easy change would be to add a new attribute to ColumnMap to override the SQL type. Since TEXT, for example, can be used just like varchar anyway, that could work out in this case.\n\nI mean we can override the column size, so why not the column type, too?\n. ",
    "rickb777": "Looks like the problem was with the package gorp_test.\n\nPerhaps Issue #41 can pick this topic up.\n. See also issue #30, of which this is probably a duplicate.\n. The problem seems to be caused by MySQLDialect.ToSqlType not including a more complete set of reflect.Kind cases.\n. Yes, I'll replay the same changes on the current development tip and commit as two separate PRs.\n. Is this merge going ahead? Looks like the PR hasn't gone in yet.\n. +1 useful\n. +1 sensible idea. It might be tricky to merge the two code-bases because I suspect there has been quite a lot of divergence.\n. Nope. Can't attach a patch file. How USELESS is Github. See the [gist](https://gist.github.com/rickb777/717239d1699e69b0724f) instead\n. A revised PR will replace this one.\n. Looks like the problem was with the package gorp_test.\n\nPerhaps Issue #41 can pick this topic up.\n. See also issue #30, of which this is probably a duplicate.\n. The problem seems to be caused by MySQLDialect.ToSqlType not including a more complete set of reflect.Kind cases.\n. Yes, I'll replay the same changes on the current development tip and commit as two separate PRs.\n. Is this merge going ahead? Looks like the PR hasn't gone in yet.\n. +1 useful\n. +1 sensible idea. It might be tricky to merge the two code-bases because I suspect there has been quite a lot of divergence.\n. Nope. Can't attach a patch file. How USELESS is Github. See the [gist](https://gist.github.com/rickb777/717239d1699e69b0724f) instead\n. A revised PR will replace this one.\n. ",
    "NoahShen": "no~ I means obj's VERSION column, not ID\n. no~ I means obj's VERSION column, not ID\n. ",
    "alexzorin": "~~I want to use this struct embedding to achieve some polymorphism in my database models.~~\n\n~~@sqs in the test you wrote as part of https://github.com/sqs/gorp/commit/17f13f466f11f3b7990691a64764d2ad8f9f25a6 you `SetKeys` on a non-embedded field in the `WithEmbeddedStruct` struct.~~\n\n~~Is is feasible in this feature to be able to use a field that is part of an embedded struct as the primary key? Or any reason why this is a wrong design?~~\n\n~~I suppose more generally `ColMap*` functions need to be able to deal with embedded fields, no?~~\n\nAh, it seems to work as long as I don't give names to the embedded structs. Good work otherwise!\n. ~~I want to use this struct embedding to achieve some polymorphism in my database models.~~\n\n~~@sqs in the test you wrote as part of https://github.com/sqs/gorp/commit/17f13f466f11f3b7990691a64764d2ad8f9f25a6 you `SetKeys` on a non-embedded field in the `WithEmbeddedStruct` struct.~~\n\n~~Is is feasible in this feature to be able to use a field that is part of an embedded struct as the primary key? Or any reason why this is a wrong design?~~\n\n~~I suppose more generally `ColMap*` functions need to be able to deal with embedded fields, no?~~\n\nAh, it seems to work as long as I don't give names to the embedded structs. Good work otherwise!\n. ",
    "sampepose": "What's happening with this PR? I wish I had seen this before I had written my own recursion solution :-).\n\nI need this to be merged in to make gorp usable. ETA? I see no activity in three weeks.\n. What's happening with this PR? I wish I had seen this before I had written my own recursion solution :-).\n\nI need this to be merged in to make gorp usable. ETA? I see no activity in three weeks.\n. ",
    "aktau": "Is this supposed to work with nested structs (as opposed to embedded structs, which are given no name? @sqs comment tells me that it should, but I'm noticing that it somehow (for me) isnt'. I get errors like this:\n\n```\nsql: converting Exec argument #2's type: unsupported type fquery.Exchange, a struct\n```\n\nMy struct looks like this:\n\n``` go\ntype Exchange struct {\n    Name  string /* eg.: Amsterdam */\n    Short string /* eg.: AS */\n}\n\ntype Range struct {\n    Low  float64\n    High float64\n}\n\nfunc (r Range) Diff() float64 {\n    return r.High - r.Low\n}\n\ntype Dividend struct {\n    PerShare float64   /* total (non-special) dividend payout / total amount of shares */\n    Yield    float64   /* annual div. per share / price per share */\n    ExDate   time.Time /* last dividend payout date */\n}\n\ntype Result struct {\n    Symbol   string /* e.g.: VEUR.AS, Vanguard dev. europe on Amsterdam */\n    Name     string\n    Exchange Exchange\n\n    /* last actualization of the results */\n    Update time.Time\n\n    /* volume */\n    Volume         int64 /* outstanding shares */\n    AvgDailyVolume int64 /* avg amount of shares traded */\n\n    /* dividend & related */\n    Dividend         Dividend\n    EarningsPerShare float64\n\n    /* price */\n    Bid            float64\n    Ask            float64\n    Open           float64\n    PreviousClose  float64\n    LastTradePrice float64\n\n    DayRange  Range\n    YearRange Range\n\n    Ma50  float64 /* 50-day moving average */\n    Ma200 float64 /* 200-day moving average */\n\n    /* derived from price */\n    Change        float64\n    ChangePercent float64\n}\n```\n\n**EDIT**: this is the schema that gorp creates:\n\n![screen shot 2014-01-24 at 00 49 38](https://f.cloud.github.com/assets/189413/1990694/1c05d05c-8489-11e3-8fb7-ab6929c6ab28.png)\n. @sqs no problem at all, I already flattened my struct to accomodate it gorp. The other advantages it brings are too great to ignore!\n. Is this supposed to work with nested structs (as opposed to embedded structs, which are given no name? @sqs comment tells me that it should, but I'm noticing that it somehow (for me) isnt'. I get errors like this:\n\n```\nsql: converting Exec argument #2's type: unsupported type fquery.Exchange, a struct\n```\n\nMy struct looks like this:\n\n``` go\ntype Exchange struct {\n    Name  string /* eg.: Amsterdam */\n    Short string /* eg.: AS */\n}\n\ntype Range struct {\n    Low  float64\n    High float64\n}\n\nfunc (r Range) Diff() float64 {\n    return r.High - r.Low\n}\n\ntype Dividend struct {\n    PerShare float64   /* total (non-special) dividend payout / total amount of shares */\n    Yield    float64   /* annual div. per share / price per share */\n    ExDate   time.Time /* last dividend payout date */\n}\n\ntype Result struct {\n    Symbol   string /* e.g.: VEUR.AS, Vanguard dev. europe on Amsterdam */\n    Name     string\n    Exchange Exchange\n\n    /* last actualization of the results */\n    Update time.Time\n\n    /* volume */\n    Volume         int64 /* outstanding shares */\n    AvgDailyVolume int64 /* avg amount of shares traded */\n\n    /* dividend & related */\n    Dividend         Dividend\n    EarningsPerShare float64\n\n    /* price */\n    Bid            float64\n    Ask            float64\n    Open           float64\n    PreviousClose  float64\n    LastTradePrice float64\n\n    DayRange  Range\n    YearRange Range\n\n    Ma50  float64 /* 50-day moving average */\n    Ma200 float64 /* 200-day moving average */\n\n    /* derived from price */\n    Change        float64\n    ChangePercent float64\n}\n```\n\n**EDIT**: this is the schema that gorp creates:\n\n![screen shot 2014-01-24 at 00 49 38](https://f.cloud.github.com/assets/189413/1990694/1c05d05c-8489-11e3-8fb7-ab6929c6ab28.png)\n. @sqs no problem at all, I already flattened my struct to accomodate it gorp. The other advantages it brings are too great to ignore!\n. ",
    "bhs": "(Sorry for the minimal fix... thought this would be an incremental improvement at least :)\n. (Sorry for the minimal fix... thought this would be an incremental improvement at least :)\n. ",
    "jamesharr": "+1 for SelectInto()\n. With `timestamp with time zone`, the patch works well. Small patch: jamesharr@6724b78be6a1f5fa1d2efdc0ac605b7101d080df\n\nReally, the option should be left up to the user, but Gorp's column mapping doesn't support that yet. Keeping the timezone in postgres works (and without timezone doesn't), so it's the safer option for the time being if you want Time object in Gorp.\n\nSome exploration of the underlying SQL drivers might be warranted as well, since there might be other intricacies that differ between SQL drivers. I know Go-SQL-Driver/MySQL has a location setting for timezones (and a pending pull request to correct conversions). Other drivers may behave differently, especially for MySQL.\n. +1 for SelectInto()\n. With `timestamp with time zone`, the patch works well. Small patch: jamesharr@6724b78be6a1f5fa1d2efdc0ac605b7101d080df\n\nReally, the option should be left up to the user, but Gorp's column mapping doesn't support that yet. Keeping the timezone in postgres works (and without timezone doesn't), so it's the safer option for the time being if you want Time object in Gorp.\n\nSome exploration of the underlying SQL drivers might be warranted as well, since there might be other intricacies that differ between SQL drivers. I know Go-SQL-Driver/MySQL has a location setting for timezones (and a pending pull request to correct conversions). Other drivers may behave differently, especially for MySQL.\n. ",
    "westmark": "Just realised that my second call to SetKeys might be erroneous. But removing it will not solve my original problem.\n. I implemented a quick fix here 5b591b5cb1055f9b6b9285669df1634ed392f784. Maybe it's not the best solution but it illustrates what I need. Basically \"nil\" is added to bindInstance.args if the column is marked as a foreign key and the value being set equals the provided default value.\n. No... curse my Go noobishness :) I was looking for a nullable int, but I never thought to look in the sql package. I'll check this out asap. Thanks!\n. I tried using sql.NullInt64, but I still get the same basic error:\n\n> 21:58:15.893670 [gorp 3] insert into \"activities\" (\"id\",\"parent_id\",\"name\",\"description\",\"o_id\",\"project_id\",\"customer_id\",\"st_id\") values (default,$1,$2,$3,$4,$5,$6,$7) returning id; [[0 Stuff Stuff 1 {0 false} {0 false} {2 true}]]\n\nYields\n\n> No serial value returned for insert\n\nAnd as you can see {0 false} is sent for both project_id and customer_id. Can this be a problem with my Postgres driver?\n. activities.id is indeed defined as serial: `id SERIAL PRIMARY KEY`. Before, when I used my forked repo, I got it working by explicitly appending `nil` instead of the zero-value `0` to the bindInstance.args slice for those columns that had not been set.\n\nI had a look at the tests, but I can't find any tests where NullInt64.Valid is actually set to false before an insert.\n. I just found the problem and it was one foreign key (have lots of them) that was still an `\u00ecnt``. Totally missed it. Got it working now. Really sorry about the mess :(\n. Just realised that my second call to SetKeys might be erroneous. But removing it will not solve my original problem.\n. I implemented a quick fix here 5b591b5cb1055f9b6b9285669df1634ed392f784. Maybe it's not the best solution but it illustrates what I need. Basically \"nil\" is added to bindInstance.args if the column is marked as a foreign key and the value being set equals the provided default value.\n. No... curse my Go noobishness :) I was looking for a nullable int, but I never thought to look in the sql package. I'll check this out asap. Thanks!\n. I tried using sql.NullInt64, but I still get the same basic error:\n\n> 21:58:15.893670 [gorp 3] insert into \"activities\" (\"id\",\"parent_id\",\"name\",\"description\",\"o_id\",\"project_id\",\"customer_id\",\"st_id\") values (default,$1,$2,$3,$4,$5,$6,$7) returning id; [[0 Stuff Stuff 1 {0 false} {0 false} {2 true}]]\n\nYields\n\n> No serial value returned for insert\n\nAnd as you can see {0 false} is sent for both project_id and customer_id. Can this be a problem with my Postgres driver?\n. activities.id is indeed defined as serial: `id SERIAL PRIMARY KEY`. Before, when I used my forked repo, I got it working by explicitly appending `nil` instead of the zero-value `0` to the bindInstance.args slice for those columns that had not been set.\n\nI had a look at the tests, but I can't find any tests where NullInt64.Valid is actually set to false before an insert.\n. I just found the problem and it was one foreign key (have lots of them) that was still an `\u00ecnt``. Totally missed it. Got it working now. Really sorry about the mess :(\n. ",
    "alecthomas": "Perhaps just supporting the [encoding.BinaryMarshaler](http://golang.org/pkg/encoding/#BinaryMarshaler) and unmarshaler interfaces would be sufficient?\n. I've been using your fork (with pg) and it's been excellent so far. Thanks!\n. I've been using your fork (with pg) and it's been excellent so far. Thanks!\n. Perhaps just supporting the [encoding.BinaryMarshaler](http://golang.org/pkg/encoding/#BinaryMarshaler) and unmarshaler interfaces would be sufficient?\n. I've been using your fork (with pg) and it's been excellent so far. Thanks!\n. I've been using your fork (with pg) and it's been excellent so far. Thanks!\n. ",
    "miketheprogrammer": "@lukescott is there capabilities now for enum ??? \n. @lukescott is there capabilities now for enum ??? \n. ",
    "cryptix": "For me transient tells gorp to hide fields from the database altogether.\nSo you can have the clear text password on a struct but only save the hashed one. Or load relations to fully loaded struct fields and just save the relationId on to the database.\n\n> On 02.11.2013, at 19:34, James Cooper notifications@github.com wrote:\n> \n> I think we should consider a name other than transient. Today setting transient=true on a field will exclude it from all generated INSERT/UPDATE/SELECT queries.\n> \n> It sounds like the goal here is to tell gorp to only use this column for SELECT statements. Is that right?\n> \n> If so, perhaps something like readonly or selectonly would be more descriptive?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. For me transient tells gorp to hide fields from the database altogether.\nSo you can have the clear text password on a struct but only save the hashed one. Or load relations to fully loaded struct fields and just save the relationId on to the database.\n\n> On 02.11.2013, at 19:34, James Cooper notifications@github.com wrote:\n> \n> I think we should consider a name other than transient. Today setting transient=true on a field will exclude it from all generated INSERT/UPDATE/SELECT queries.\n> \n> It sounds like the goal here is to tell gorp to only use this column for SELECT statements. Is that right?\n> \n> If so, perhaps something like readonly or selectonly would be more descriptive?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "phacops": "Is this still considered?\n\nI would be in favor of naming the tag selectonly, it would be clear on what the intention is (to use this field only on select queries).\n. How `transient` differentiate itselft from just ignoring the field (using `-`)?\n. I see. So I think we can just stick with the `-` tag (again, my understanding of transient is it will just ignore the field regarding of the query, correct me if I'm wrong) and we don't need `transient`.\n. I feel like I'm missing something. Either I understand the `transient` flag as the `selectonly` flag or I understand it like it's another `-` flag.\n\nI'll dig around the code.\n\nEdit: OK, I get it.\n. Could you add a little bit of documentation?\n\nI'm currently testing both flags, working as expected so far.\n. Is this still considered?\n\nI would be in favor of naming the tag selectonly, it would be clear on what the intention is (to use this field only on select queries).\n. How `transient` differentiate itselft from just ignoring the field (using `-`)?\n. I see. So I think we can just stick with the `-` tag (again, my understanding of transient is it will just ignore the field regarding of the query, correct me if I'm wrong) and we don't need `transient`.\n. I feel like I'm missing something. Either I understand the `transient` flag as the `selectonly` flag or I understand it like it's another `-` flag.\n\nI'll dig around the code.\n\nEdit: OK, I get it.\n. Could you add a little bit of documentation?\n\nI'm currently testing both flags, working as expected so far.\n. ",
    "jimtla": "Sorry for the slow response - \n\nI added support for `selectonly` and also added a separate tag for `transient`.\n\nI've also taken @sqs's suggestion to make it more consistent with go.\n. No difference - it seemed cleaner to give the option of specifying it with the `transient` flag, but since the json package just uses `-` I'd be open to removing the extra flag.\n. The current behavior of transient (which I have no intention to change) is that it will never be included in a _generated_ query, but if it is present in the query response then gorp will still bind it to the struct.\n\nWhich actually reminds me of the use case for the `transient` flag. You can give a field a reasonable name for binding purposes, but mark it as transient to keep it out of generated queries.\n. Thanks @begizi - I had lost track of this. I've rebased against master and updated the readme - let me know if you'd like me to add more extensive documentation.\n. Sorry for the slow response - \n\nI added support for `selectonly` and also added a separate tag for `transient`.\n\nI've also taken @sqs's suggestion to make it more consistent with go.\n. No difference - it seemed cleaner to give the option of specifying it with the `transient` flag, but since the json package just uses `-` I'd be open to removing the extra flag.\n. The current behavior of transient (which I have no intention to change) is that it will never be included in a _generated_ query, but if it is present in the query response then gorp will still bind it to the struct.\n\nWhich actually reminds me of the use case for the `transient` flag. You can give a field a reasonable name for binding purposes, but mark it as transient to keep it out of generated queries.\n. Thanks @begizi - I had lost track of this. I've rebased against master and updated the readme - let me know if you'd like me to add more extensive documentation.\n. ",
    "begizi": "+1 for this to be merged.\n. @jimtla Can you rebase this PR?\n. +1\n. @porjo I ended up just using postgres triggers to create the geometry column on insert/update. Did you find figure out a way to make this work for you?\n. Are you able to store the json data as a string in the db? If so then you can use gorp's TypeConverter interface to marshal and unmarshal the json to a string\n. @marconi Would using the 'selectonly' tag from PR #59 solve this issue?\n. I'm just a baby gopher, but I'd love to contribute to this project in any way I can.\n. @GeertJohan I'd love to help out in any way I can. As mentioned above, I am very new to go and have only been using it for a few months. I do love gorp though and have used it in a couple of my projects so I'm all for helping improve it with some needed bug fixes and enhancements.\n. :+1: Looks good @GeertJohan \n. :shipit: \n. +1 for this to be merged.\n. @jimtla Can you rebase this PR?\n. +1\n. @porjo I ended up just using postgres triggers to create the geometry column on insert/update. Did you find figure out a way to make this work for you?\n. Are you able to store the json data as a string in the db? If so then you can use gorp's TypeConverter interface to marshal and unmarshal the json to a string\n. @marconi Would using the 'selectonly' tag from PR #59 solve this issue?\n. I'm just a baby gopher, but I'd love to contribute to this project in any way I can.\n. @GeertJohan I'd love to help out in any way I can. As mentioned above, I am very new to go and have only been using it for a few months. I do love gorp though and have used it in a couple of my projects so I'm all for helping improve it with some needed bug fixes and enhancements.\n. :+1: Looks good @GeertJohan \n. :shipit: \n. ",
    "sourcegraphbot": "<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/ColumnMap/SelectOnly\">(gorp.ColumnMap).SelectOnly  bool</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code>func <a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/TestWithSelectOnlyColumn\">gorp.TestWithSelectOnlyColumn(t *testing.T)</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code>type <a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn\">gorp.WithSelectOnlyColumn  struct</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn/Created\">(gorp.WithSelectOnlyColumn).Created  int64</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn/Id\">(gorp.WithSelectOnlyColumn).Id  int64</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn/SelectOnly\">(gorp.WithSelectOnlyColumn).SelectOnly  *int64</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/changed.png\" />\n&nbsp;<code>type <a href=\"https://sourcegraph.com/github.com/coopernurse/gorp@5d19ebd22fdcf3b9fb1c8cbfcf1d4e78e102f1e0/.GoPackage/github.com/coopernurse/gorp/.def/ColumnMap\">gorp.ColumnMap  struct</a></code></p>\n\n<hr>\n\n<p><a href=\"https://sourcegraph.com/github.com/coopernurse/gorp/.pulls/59\">View the full smart diff on \u2731 <strong>sourcegraph.com</strong></a></p>\n\n<p><a href=\"https://sourcegraph.com/github.com/coopernurse/gorp/.settings\">Disable sourcegraphbot for this repository.</a></p>\n. <p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/ColumnMap/SelectOnly\">(gorp.ColumnMap).SelectOnly  bool</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code>func <a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/TestWithSelectOnlyColumn\">gorp.TestWithSelectOnlyColumn(t *testing.T)</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code>type <a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn\">gorp.WithSelectOnlyColumn  struct</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn/Created\">(gorp.WithSelectOnlyColumn).Created  int64</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn/Id\">(gorp.WithSelectOnlyColumn).Id  int64</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/added.png\" />\n&nbsp;<code><a href=\"https://sourcegraph.com/github.com/jimtla/gorp@c97fbece855b40aae35135ca9dc2d9ad15a7584f/.GoPackage/github.com/jimtla/gorp/.def/WithSelectOnlyColumn/SelectOnly\">(gorp.WithSelectOnlyColumn).SelectOnly  *int64</a></code></p>\n\n<p>\n<img src=\"https://s3-us-west-2.amazonaws.com/sourcegraph-assets/srcbot/changed.png\" />\n&nbsp;<code>type <a href=\"https://sourcegraph.com/github.com/coopernurse/gorp@5d19ebd22fdcf3b9fb1c8cbfcf1d4e78e102f1e0/.GoPackage/github.com/coopernurse/gorp/.def/ColumnMap\">gorp.ColumnMap  struct</a></code></p>\n\n<hr>\n\n<p><a href=\"https://sourcegraph.com/github.com/coopernurse/gorp/.pulls/59\">View the full smart diff on \u2731 <strong>sourcegraph.com</strong></a></p>\n\n<p><a href=\"https://sourcegraph.com/github.com/coopernurse/gorp/.settings\">Disable sourcegraphbot for this repository.</a></p>\n. ",
    "vadimg": "@coopernurse @robfig Why do you consider not returning an error if you don't have a place for a returned column \"bad\"? There's a very clear way to proceed if you have more columns than you need: just ignore the extra ones. I can only see one possible downside to this: It could potentially hide bugs in your code, during development. You might be wondering why a certain struct field is not being filled, and gorp would give you no reason as to why. In development, returning an error might be preferable. \n\nBut in production, returning an error (and halting the table mapping) is terrible! It means that if programmers aren't careful with every sql query they write, it could cause production downtime in between db migrations and code pushes. I think this is unacceptable, and I have a simple solution:\n\nFor the case of \"more columns than you need\", gorp would try to map the rest of the columns onto the struct and at the end, return a different type of error-implementing struct that could be checked in the application code and ignored if desired.\n. I created this pull request for this issue: https://github.com/go-gorp/gorp/pull/188\n. @coopernurse @robfig Why do you consider not returning an error if you don't have a place for a returned column \"bad\"? There's a very clear way to proceed if you have more columns than you need: just ignore the extra ones. I can only see one possible downside to this: It could potentially hide bugs in your code, during development. You might be wondering why a certain struct field is not being filled, and gorp would give you no reason as to why. In development, returning an error might be preferable. \n\nBut in production, returning an error (and halting the table mapping) is terrible! It means that if programmers aren't careful with every sql query they write, it could cause production downtime in between db migrations and code pushes. I think this is unacceptable, and I have a simple solution:\n\nFor the case of \"more columns than you need\", gorp would try to map the rest of the columns onto the struct and at the end, return a different type of error-implementing struct that could be checked in the application code and ignored if desired.\n. I created this pull request for this issue: https://github.com/go-gorp/gorp/pull/188\n. ",
    "ipartner": "Also. the db already exist.\nthe only way to use gorp is to create the db?\n. type ConfigClient struct {\n    client_id int64 `db:\"client_id\"`\n    revision int64 `db:\"revision\"`\n    configuration_content string `db:\"configuracion_content\"`\n    sleep_time int64 `db:\"sleep_time\"`\n    idx_table int64 `db:\"sleep_time\"`\n    stress int64 `db:\"stress\"`\n    schedule int64 `db:\"schedule\"`\n    dominio string `db:\"dominio\"`\n    json_config string `db:\"json_config\"`\n    umbral int64 `db:\"umbral\"`\n    alter_xml int64 `db:\"alter_xml\"`\n    enabled int64 `db:\"enabled\"`\n    idx int64 `db:\"idx\"`\n    nombre_prueba string `db:\"-\"`\n    tipo int64 `db:\"-\"`\n    acl_client int64 `db:\"-\"`\n    pasos int64 `db:\"pasos\"`\n    empresa int64 `db:\"empresa\"`\n    historial_granular int64 `db:\"historial_granular\"`\n}\n. the pre existent table that im trying to map\n\nCREATE TABLE config_clients (\n    client_id integer NOT NULL,\n    revision integer NOT NULL,\n    configuration_content character varying NOT NULL,\n    sleep_time integer NOT NULL,\n    idx_table integer,\n    stress integer,\n    schedule integer,\n    dominio character varying,\n    json_config character varying,\n    umbral integer,\n    alter_xml integer,\n    enabled integer,\n    idx integer NOT NULL,\n    nombre_prueba text,\n    type smallint,\n    acl_client smallint DEFAULT 1 NOT NULL,\n    pasos integer DEFAULT 1 NOT NULL,\n    empresa integer DEFAULT 1 NOT NULL,\n    historial_granular integer DEFAULT 31 NOT NULL\n);\n. Bingo.\nsorry . just starting with GO here.\ni appreciate your help\ngreat work with gorp :)\n. i have the same issue . is there a newer version of gorp with ths fixed?\n. Sorry looks like in the response to the client i was using fmt.Fprintf(w,bytes) insted of \n\nw.Write(bytes) directly and the Fprintf saw those %20 and tried to match it to in exsistant parameters so \nif you ask me close the issue\n. Also. the db already exist.\nthe only way to use gorp is to create the db?\n. type ConfigClient struct {\n    client_id int64 `db:\"client_id\"`\n    revision int64 `db:\"revision\"`\n    configuration_content string `db:\"configuracion_content\"`\n    sleep_time int64 `db:\"sleep_time\"`\n    idx_table int64 `db:\"sleep_time\"`\n    stress int64 `db:\"stress\"`\n    schedule int64 `db:\"schedule\"`\n    dominio string `db:\"dominio\"`\n    json_config string `db:\"json_config\"`\n    umbral int64 `db:\"umbral\"`\n    alter_xml int64 `db:\"alter_xml\"`\n    enabled int64 `db:\"enabled\"`\n    idx int64 `db:\"idx\"`\n    nombre_prueba string `db:\"-\"`\n    tipo int64 `db:\"-\"`\n    acl_client int64 `db:\"-\"`\n    pasos int64 `db:\"pasos\"`\n    empresa int64 `db:\"empresa\"`\n    historial_granular int64 `db:\"historial_granular\"`\n}\n. the pre existent table that im trying to map\n\nCREATE TABLE config_clients (\n    client_id integer NOT NULL,\n    revision integer NOT NULL,\n    configuration_content character varying NOT NULL,\n    sleep_time integer NOT NULL,\n    idx_table integer,\n    stress integer,\n    schedule integer,\n    dominio character varying,\n    json_config character varying,\n    umbral integer,\n    alter_xml integer,\n    enabled integer,\n    idx integer NOT NULL,\n    nombre_prueba text,\n    type smallint,\n    acl_client smallint DEFAULT 1 NOT NULL,\n    pasos integer DEFAULT 1 NOT NULL,\n    empresa integer DEFAULT 1 NOT NULL,\n    historial_granular integer DEFAULT 31 NOT NULL\n);\n. Bingo.\nsorry . just starting with GO here.\ni appreciate your help\ngreat work with gorp :)\n. i have the same issue . is there a newer version of gorp with ths fixed?\n. Sorry looks like in the response to the client i was using fmt.Fprintf(w,bytes) insted of \n\nw.Write(bytes) directly and the Fprintf saw those %20 and tried to match it to in exsistant parameters so \nif you ask me close the issue\n. ",
    "purohit": "Can you show us your ConfigClient{} struct definition?\n\n2013/7/29 Victor Lucero notifications@github.com\n\n> Also. the db already exist.\n> the only way to use gorp is to create the db?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/coopernurse/gorp/issues/66#issuecomment-21748351\n> .\n. Just a guess, but maybe you have to use exported fields (i.e., capitalize the first letter of the field) when reading into your struct?:\n\n``` go\ntype ConfigClient struct {\n    Client_id int64 db:\"client_id\"\n    Revision int64 db:\"revision\"\n    ...\n}\n```\n. +1, I'm currently using weird work-arounds for IN support, also. Curious -- why expand to `(?, ?, ?)` and renumber all parameters, instead of keeping the parameter number the same, and escaping each slice value in-place? With Postgres:\n\n``` go\nids := []int{4, 17, 3}\nname := \"Rob\"\nexecutor.Select(\"SELECT * FROM Users WHERE Id IN $1 AND Name = $2\", ids, name)\n// SELECT * FROM TABLE WHERE Id IN (4, 17, 3) AND Name = 'Rob';\n```\n. I tried to reference this issue in my pull request, but now you'll have to look at issue #99 to merge it, sorry!\n. I would run `go fmt` before submitting a pull request -- that'll get rid of all the formatting problems and keep the code base standard.\n. Nice. I can't speak for coopernurse, the owner of this codebase, but in my repo I would want the commits squashed. Otherwise there are like 3000 diff changes that exactly negate each other and just pollute the diff, and it's impossible to tell what actually changed and what didn't since everything's a whitespace change. Know what I mean?\n. I changed my mind, I was remembering my usage wrong. The catches I have around the zeroed structs are actually kind of heinous, I'd agree with sql.ErrNoRows. Oops.\n. Agreed. I for one am happy to update my code if you merge it.\n. @jackfranzen : yes\n. Have you tried using placeholders? I'm curious what happens.\n\n``` go\ndbmap.Exec(\"SELECT * FROM ?\", \"sch1.Table\") // (replace ? with $1 if using PostgreSQL)\n```\n. I have the same problem, an incredibly slow compile time because of the import. Did you ever end up finding out what the problem was?\n\nFor me, compilation is stuck on this line:\n\n```\ngcc -I . -fPIC -m64 -pthread -fmessage-length=0 -I \n   $WORK/_/home/devbox/gocode/src/github.com/mattn/go-sqlite3/_obj/ -g -O2 -I. -DSQLITE_ENABLE_RTREE -o \n   $WORK/_/home/devbox/gocode/src/github.com/mattn/go-sqlite3/_obj/sqlite3.o -c ./sqlite3.c\n```\n\n`go build -x  26.45s user 0.71s system 98% cpu 27.589 total`\n\nEek!\n. Ah, I see you did, and thanks for following-up with mattn. The solution you guys discussed here (https://github.com/mattn/go-sqlite3/issues/122) worked for me, too.\n. https://godoc.org/github.com/go-gorp/gorp#DbMap.Insert\n\n\"Any interface whose TableMap has an auto-increment primary key will have\nits last insert id bound to the PK field on the struct.\"\n. Can you show us your ConfigClient{} struct definition?\n\n2013/7/29 Victor Lucero notifications@github.com\n\n> Also. the db already exist.\n> the only way to use gorp is to create the db?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/coopernurse/gorp/issues/66#issuecomment-21748351\n> .\n. Just a guess, but maybe you have to use exported fields (i.e., capitalize the first letter of the field) when reading into your struct?:\n\n``` go\ntype ConfigClient struct {\n    Client_id int64 db:\"client_id\"\n    Revision int64 db:\"revision\"\n    ...\n}\n```\n. +1, I'm currently using weird work-arounds for IN support, also. Curious -- why expand to `(?, ?, ?)` and renumber all parameters, instead of keeping the parameter number the same, and escaping each slice value in-place? With Postgres:\n\n``` go\nids := []int{4, 17, 3}\nname := \"Rob\"\nexecutor.Select(\"SELECT * FROM Users WHERE Id IN $1 AND Name = $2\", ids, name)\n// SELECT * FROM TABLE WHERE Id IN (4, 17, 3) AND Name = 'Rob';\n```\n. I tried to reference this issue in my pull request, but now you'll have to look at issue #99 to merge it, sorry!\n. I would run `go fmt` before submitting a pull request -- that'll get rid of all the formatting problems and keep the code base standard.\n. Nice. I can't speak for coopernurse, the owner of this codebase, but in my repo I would want the commits squashed. Otherwise there are like 3000 diff changes that exactly negate each other and just pollute the diff, and it's impossible to tell what actually changed and what didn't since everything's a whitespace change. Know what I mean?\n. I changed my mind, I was remembering my usage wrong. The catches I have around the zeroed structs are actually kind of heinous, I'd agree with sql.ErrNoRows. Oops.\n. Agreed. I for one am happy to update my code if you merge it.\n. @jackfranzen : yes\n. Have you tried using placeholders? I'm curious what happens.\n\n``` go\ndbmap.Exec(\"SELECT * FROM ?\", \"sch1.Table\") // (replace ? with $1 if using PostgreSQL)\n```\n. I have the same problem, an incredibly slow compile time because of the import. Did you ever end up finding out what the problem was?\n\nFor me, compilation is stuck on this line:\n\n```\ngcc -I . -fPIC -m64 -pthread -fmessage-length=0 -I \n   $WORK/_/home/devbox/gocode/src/github.com/mattn/go-sqlite3/_obj/ -g -O2 -I. -DSQLITE_ENABLE_RTREE -o \n   $WORK/_/home/devbox/gocode/src/github.com/mattn/go-sqlite3/_obj/sqlite3.o -c ./sqlite3.c\n```\n\n`go build -x  26.45s user 0.71s system 98% cpu 27.589 total`\n\nEek!\n. Ah, I see you did, and thanks for following-up with mattn. The solution you guys discussed here (https://github.com/mattn/go-sqlite3/issues/122) worked for me, too.\n. https://godoc.org/github.com/go-gorp/gorp#DbMap.Insert\n\n\"Any interface whose TableMap has an auto-increment primary key will have\nits last insert id bound to the PK field on the struct.\"\n. ",
    "pettyjamesm": "At this point, gorp is already failing to handle time.Time types. I don't think it's worth holding up this pull request just to figure out the timezones problem. Users already have to work around Time compatibility on their own, they can figure out how to work around timezones if they need to.\n. At this point, gorp is already failing to handle time.Time types. I don't think it's worth holding up this pull request just to figure out the timezones problem. Users already have to work around Time compatibility on their own, they can figure out how to work around timezones if they need to.\n. ",
    "xiaoao": "ok,thank you!\n. ok,thank you!\n. ",
    "joeshaw": "Example usage:\n\n``` go\n    tmap := dbmap.AddTableWithName(dbUserType, \"user\")\n    tmap.SetKeys(false, \"Login\")\n\n    cmap := tmap.ColMap(\"Id\")\n    cmap.IsAutoIncr = true\n```\n. @GeertJohan I probably won't do it, I'm not using gorp actively at the moment.\n. Example usage:\n\n``` go\n    tmap := dbmap.AddTableWithName(dbUserType, \"user\")\n    tmap.SetKeys(false, \"Login\")\n\n    cmap := tmap.ColMap(\"Id\")\n    cmap.IsAutoIncr = true\n```\n. @GeertJohan I probably won't do it, I'm not using gorp actively at the moment.\n. ",
    "irlTopper": "Thanks for this - I hadn't seen \"sql.NullInt64\" etc before.\nTo help others, maybe you could update the readme to mention these. \n. Thanks for this - I hadn't seen \"sql.NullInt64\" etc before.\nTo help others, maybe you could update the readme to mention these. \n. ",
    "vinceyuan": "sql.NullString solves my problem. But it is not convenient.  Wonder why string can not be used directly for mapping. Is it not possible to assign an empty string when there is a null?\n. The table name of Postgres should not be forced to be lower case. \n\nAll my existing table names look like \"MyClasses\". Though I have called `dbmap.AddTableWithName(MyClass{}, \"MyClasses\")`, the table name is still changed to \"myclasses\" by this line https://github.com/go-gorp/gorp/blob/develop/dialect.go#L295\n\nCan I make a pull request to fix the table name?\n. Hello,\n\nThanks for all efforts on v2. What's the current progress of v2? I see issue #119 (the table name of Postgres should not be converted to lower case) is marked with v2-phase3. So I want to check the progress with you. If #119 is not fixed, will you accept a pull request? (I do see `At this time we won't accept new feature-related pull-requests because of changes to the codebase. Please create an issue for your feature and wait until v2.0 has been released.` in the README)\n\nUpdate: I made a pull request 293 to fix this bug. Please take a look.\n. @qrawl I suggest we modify the [Quickstart](https://github.com/go-gorp/gorp#quickstart), because new users like me do not know this rule. They just follow the steps in README but find the code does not work as expected. Thanks.\n. Any comments? \n. Any response?\n. @nelsam It's about the field name, e.g. `id` vs `Id`. Let me try to fix it.\n. Test is ok on my mac, but failed in Travis CI. I think it's because mysql's table name and column name are case insensitive on Mac. Let me revert my commit and find a new solution.\n. Reverted my previous commit ff249b53901546511b8acd33ca87568f91db1cdf. Fixed 3 test cases by using quoted column name and table name in the raw SQL. There will be a lot to fix. I will do it tomorrow (actually today. It's 3am now).\n. @nelsam Done. Don't know why test for go1.2 failed on Travis. Other tests are good.\n. @nelsam Great, thanks. This PR may break existing projects which use Postgres, because table name and column name are no longer lower case by default.\n\nTo use lower case table name in Postgres, do something like this: dbmap.AddTableWithName(Post{}, \"posts\")\n\nTo use lower case field name in Postgres, specify the field name in type definition: type Post struct { Title string `db:\"title\"` }\n\n I have a little to submit to make benchmark work for postgres. \n. @GeertJohan What do you mean? This PR passed Go:1.3/1.4/tip, but did not pass Go:1.2 on travis-ci.\n. Rebased. @GeertJohan Thanks!\n. @mauleyzaola This is the breaking change, which I believe will be included in v2.0. The current stable release is v1. (Use `import \"gopkg.in/gorp.v1\"` in the project)\n\nAs mentioned in the commit comment, \n\nTo use lower case table name in Postgres, do something like this: `dbmap.AddTableWithName(Post{}, \"posts\")`\nTo use lower case field name in Postgres, specify the field name in type definition: `type Post struct { Title string `db:\"title\"` }`\n\nBecause there are 1747 fields in your project, it will be labour intensive to modify the existing code. Sorry for it.\n. sql.NullString solves my problem. But it is not convenient.  Wonder why string can not be used directly for mapping. Is it not possible to assign an empty string when there is a null?\n. The table name of Postgres should not be forced to be lower case. \n\nAll my existing table names look like \"MyClasses\". Though I have called `dbmap.AddTableWithName(MyClass{}, \"MyClasses\")`, the table name is still changed to \"myclasses\" by this line https://github.com/go-gorp/gorp/blob/develop/dialect.go#L295\n\nCan I make a pull request to fix the table name?\n. Hello,\n\nThanks for all efforts on v2. What's the current progress of v2? I see issue #119 (the table name of Postgres should not be converted to lower case) is marked with v2-phase3. So I want to check the progress with you. If #119 is not fixed, will you accept a pull request? (I do see `At this time we won't accept new feature-related pull-requests because of changes to the codebase. Please create an issue for your feature and wait until v2.0 has been released.` in the README)\n\nUpdate: I made a pull request 293 to fix this bug. Please take a look.\n. @qrawl I suggest we modify the [Quickstart](https://github.com/go-gorp/gorp#quickstart), because new users like me do not know this rule. They just follow the steps in README but find the code does not work as expected. Thanks.\n. Any comments? \n. Any response?\n. @nelsam It's about the field name, e.g. `id` vs `Id`. Let me try to fix it.\n. Test is ok on my mac, but failed in Travis CI. I think it's because mysql's table name and column name are case insensitive on Mac. Let me revert my commit and find a new solution.\n. Reverted my previous commit ff249b53901546511b8acd33ca87568f91db1cdf. Fixed 3 test cases by using quoted column name and table name in the raw SQL. There will be a lot to fix. I will do it tomorrow (actually today. It's 3am now).\n. @nelsam Done. Don't know why test for go1.2 failed on Travis. Other tests are good.\n. @nelsam Great, thanks. This PR may break existing projects which use Postgres, because table name and column name are no longer lower case by default.\n\nTo use lower case table name in Postgres, do something like this: dbmap.AddTableWithName(Post{}, \"posts\")\n\nTo use lower case field name in Postgres, specify the field name in type definition: type Post struct { Title string `db:\"title\"` }\n\n I have a little to submit to make benchmark work for postgres. \n. @GeertJohan What do you mean? This PR passed Go:1.3/1.4/tip, but did not pass Go:1.2 on travis-ci.\n. Rebased. @GeertJohan Thanks!\n. @mauleyzaola This is the breaking change, which I believe will be included in v2.0. The current stable release is v1. (Use `import \"gopkg.in/gorp.v1\"` in the project)\n\nAs mentioned in the commit comment, \n\nTo use lower case table name in Postgres, do something like this: `dbmap.AddTableWithName(Post{}, \"posts\")`\nTo use lower case field name in Postgres, specify the field name in type definition: `type Post struct { Title string `db:\"title\"` }`\n\nBecause there are 1747 fields in your project, it will be labour intensive to modify the existing code. Sorry for it.\n. ",
    "msabramo": "Same question as @vinceyuan. Same question as @vinceyuan. ",
    "ckrissun": "```\n// #84 - ignore time.Time structs here - there may be a cleaner way to do this\ncase arg.Kind() == reflect.Struct && !(arg.Type().PkgPath() == \"time\" && arg.Type().Name() == \"Time\"):\n  return ...\n```\n\nor change it to this:\n\n```\nimport (\n ...\n \"time\"\n ...\n}\n...\n\ncase arg.Kind() == reflect.Struct:\n  if _, ok := arg.Interface().(time.Time); !ok {\n    return ...\n  }\n```\n\nor this:\n\n```\ncase arg.Kind() == reflect.Struct && arg.Type().String() != \"time.Time\":\n  return ...\n```\n. ```\n// #84 - ignore time.Time structs here - there may be a cleaner way to do this\ncase arg.Kind() == reflect.Struct && !(arg.Type().PkgPath() == \"time\" && arg.Type().Name() == \"Time\"):\n  return ...\n```\n\nor change it to this:\n\n```\nimport (\n ...\n \"time\"\n ...\n}\n...\n\ncase arg.Kind() == reflect.Struct:\n  if _, ok := arg.Interface().(time.Time); !ok {\n    return ...\n  }\n```\n\nor this:\n\n```\ncase arg.Kind() == reflect.Struct && arg.Type().String() != \"time.Time\":\n  return ...\n```\n. ",
    "joeblubaugh": "@GeertJohan yep, that seems to do it. :sheep: \n. @GeertJohan yep, that seems to do it. :sheep: \n. ",
    "clipperhouse": "I like the direction, nice and terse.\n\nPotentially a little confusing since the same function will populate single or multiple. Some might find it unexpected that some of the records returned are _not_ reflected in their result.\n\nMy solution would be that SelectOne is the one to use for single-row, and Select for *-row. This would be more idiomatic for Go: say exactly what you mean and error if it fails.\n. My two cents is that returning an error is preferable. Doing so is Go-ish, in the sense that the method implies a behavior, and if it can\u2019t be fulfilled, it doesn\u2019t try to do the \u201cnext best thing\u201d; it simply informs the caller that it can\u2019t do as requested.\n\nI understand the temptation of returning a zero-value. But it seems to be a sentinel for an error, where instead an explicit error would be less ambiguous.\n. I like the direction, nice and terse.\n\nPotentially a little confusing since the same function will populate single or multiple. Some might find it unexpected that some of the records returned are _not_ reflected in their result.\n\nMy solution would be that SelectOne is the one to use for single-row, and Select for *-row. This would be more idiomatic for Go: say exactly what you mean and error if it fails.\n. My two cents is that returning an error is preferable. Doing so is Go-ish, in the sense that the method implies a behavior, and if it can\u2019t be fulfilled, it doesn\u2019t try to do the \u201cnext best thing\u201d; it simply informs the caller that it can\u2019t do as requested.\n\nI understand the temptation of returning a zero-value. But it seems to be a sentinel for an error, where instead an explicit error would be less ambiguous.\n. ",
    "erthalion": "Thanks for reply! Is there any principal reason for the lack of the foreign key support? Can this feature be implemented?\n. Thanks for reply! Is there any principal reason for the lack of the foreign key support? Can this feature be implemented?\n. ",
    "shawnps": "Would also like to see this!\n. Would also like to see this!\n. ",
    "sym3tri": "+1\n. +1\n. ",
    "dmajere": "Good day, done with go fmt.\n. Good day, done with go fmt.\n. ",
    "mssola": "I think it really makes sense (although I may be biased since I'm the author of pull request #98 :P). SelectOne should return just one row, otherwise we're dealing with an error. Note that similar functions in the database/sql package have the same reasoning (e.g. http://golang.org/pkg/database/sql/#DB.QueryRow)\n. I think it really makes sense (although I may be biased since I'm the author of pull request #98 :P). SelectOne should return just one row, otherwise we're dealing with an error. Note that similar functions in the database/sql package have the same reasoning (e.g. http://golang.org/pkg/database/sql/#DB.QueryRow)\n. ",
    "phf": "I recently converted some MongoDB code to gorp and got bitten by this. The call in MongoDB returns an error in both cases (no \"row\" or more than one \"row\") and I ended up looking for that bug for a few minutes. An error is clearly preferable.\n. I recently converted some MongoDB code to gorp and got bitten by this. The call in MongoDB returns an error in both cases (no \"row\" or more than one \"row\") and I ended up looking for that bug for a few minutes. An error is clearly preferable.\n. ",
    "steakknife": ":+1:   Generating goose migrations would be great.\n. :+1:   Generating goose migrations would be great.\n. ",
    "rubenv": "I'll be implementing this soon, as I need it in a project.\n\nConceptually I'm thinking of borrowing the good ideas of goose: https://bitbucket.org/liamstask/goose\n. Hi all, it's done, I've built it as a separate module from Gorp because a) that's possible and b) it keeps Gorp clean and compact.\n\nHave a look at it over here: https://github.com/rubenv/sql-migrate\n. Anyone still working on this?\n\nIf not: since this is something I foresee we'll need: I'll happily pick this up and improve it if one of the maintainers (@GeertJohan?) is interested in seeing this go in.\n. Wrote this on a train whilst having forgotten that #124 existed. It's pretty much the same idea.\n. Rebased onto current master branch, to have a Travis config that works.\n. I'll be implementing this soon, as I need it in a project.\n\nConceptually I'm thinking of borrowing the good ideas of goose: https://bitbucket.org/liamstask/goose\n. Hi all, it's done, I've built it as a separate module from Gorp because a) that's possible and b) it keeps Gorp clean and compact.\n\nHave a look at it over here: https://github.com/rubenv/sql-migrate\n. Anyone still working on this?\n\nIf not: since this is something I foresee we'll need: I'll happily pick this up and improve it if one of the maintainers (@GeertJohan?) is interested in seeing this go in.\n. Wrote this on a train whilst having forgotten that #124 existed. It's pretty much the same idea.\n. Rebased onto current master branch, to have a Travis config that works.\n. ",
    "jackfranzen": "I'm sorry, just to make sure here. If we use \"?\" in the SQL and provide the strings as arguments in select, we're ok?\n. I'm sorry, just to make sure here. If we use \"?\" in the SQL and provide the strings as arguments in select, we're ok?\n. ",
    "chbrown": "I ran into the same problem, with pq's NullTime type. I second the optional \"omitempty\" tag. The Go (1.2) std. lib `json` implementation usage boils down to this snippet in the main `encode()` func:\n\n```\nif !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {\n  continue\n}\n```\n\nWith this `isEmptyValue` declaration:\n\n```\nfunc isEmptyValue(v reflect.Value) bool {\n  switch v.Kind() {\n  case reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n    return v.Len() == 0\n  case reflect.Bool:\n    return !v.Bool()\n  case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n    return v.Int() == 0\n  case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n    return v.Uint() == 0\n  case reflect.Float32, reflect.Float64:\n    return v.Float() == 0\n  case reflect.Interface, reflect.Ptr:\n    return v.IsNil()\n  }\n  return false\n}\n```\n\nI imagine much the same approach could be easily extending into the `bindInsert` and `bindUpdate` gorp methods, right alongside the `Transient` checks (just as json.decode cares not a blip about \"omitempty\", I don't believe it's relevant to bindGet, or bindDelete, for that matter).\n\nThe #92 functionality would be cool, but more complex than this particular problem calls for, and this issue has a clear precedent in the std. lib.\n. I haven't gotten back to my Go project that needed this since then.\n. I ran into the same problem, with pq's NullTime type. I second the optional \"omitempty\" tag. The Go (1.2) std. lib `json` implementation usage boils down to this snippet in the main `encode()` func:\n\n```\nif !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {\n  continue\n}\n```\n\nWith this `isEmptyValue` declaration:\n\n```\nfunc isEmptyValue(v reflect.Value) bool {\n  switch v.Kind() {\n  case reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n    return v.Len() == 0\n  case reflect.Bool:\n    return !v.Bool()\n  case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n    return v.Int() == 0\n  case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n    return v.Uint() == 0\n  case reflect.Float32, reflect.Float64:\n    return v.Float() == 0\n  case reflect.Interface, reflect.Ptr:\n    return v.IsNil()\n  }\n  return false\n}\n```\n\nI imagine much the same approach could be easily extending into the `bindInsert` and `bindUpdate` gorp methods, right alongside the `Transient` checks (just as json.decode cares not a blip about \"omitempty\", I don't believe it's relevant to bindGet, or bindDelete, for that matter).\n\nThe #92 functionality would be cool, but more complex than this particular problem calls for, and this issue has a clear precedent in the std. lib.\n. I haven't gotten back to my Go project that needed this since then.\n. ",
    "SellJamHere": "Has there been any work on the omitempty tag?\n. :+1:\n. Has there been any work on the omitempty tag?\n. :+1:\n. ",
    "mlb5000": "Looks like there is an invalid assumption about string quoting on line 329 of gorp.go.  Postgres table names do need to be quoted, but if there is a schema component only the table name should be quoted.  \n\nThe best way to handle this, however, isn't to break out the components of the table, but to delegate naming/quoting of tables names for queries to the dialect.  I'll look at it and see if I can extend the dialects to do this.\n. great, I figured you'd have to do something like that.  I'll change my fork to track develop.  I've been using this more and more, and am beginning to think that semantically what I did belongs on DbMap's logic instead of on the helper functions themselves.  Telling the DbMap that everything within it lives in a specific schema is potentially more powerful then specifying it everywhere you link up a struct.\n\nThe real hurdle is whether or not there is some way to allow gorp to modify table names in custom queries to put the schema in place.  Until we hit a maintainability issue though, I'll probably leave it the way it is.\n. Looks like there is an invalid assumption about string quoting on line 329 of gorp.go.  Postgres table names do need to be quoted, but if there is a schema component only the table name should be quoted.  \n\nThe best way to handle this, however, isn't to break out the components of the table, but to delegate naming/quoting of tables names for queries to the dialect.  I'll look at it and see if I can extend the dialects to do this.\n. great, I figured you'd have to do something like that.  I'll change my fork to track develop.  I've been using this more and more, and am beginning to think that semantically what I did belongs on DbMap's logic instead of on the helper functions themselves.  Telling the DbMap that everything within it lives in a specific schema is potentially more powerful then specifying it everywhere you link up a struct.\n\nThe real hurdle is whether or not there is some way to allow gorp to modify table names in custom queries to put the schema in place.  Until we hit a maintainability issue though, I'll probably leave it the way it is.\n. ",
    "sjhitchner": "Thanks, I took sometime today reviewing the GORP code. tried a few things but nothing worked.  I did notice there is a TypeConverter interface.  I implemented a basic TypeConverter to handle basic conversion from typed strings and ints to unblock my immediate needs.  \n\nWhen I have some time I will continue looking at the GORP code.\n\nCheers\n. Thanks, I took sometime today reviewing the GORP code. tried a few things but nothing worked.  I did notice there is a TypeConverter interface.  I implemented a basic TypeConverter to handle basic conversion from typed strings and ints to unblock my immediate needs.  \n\nWhen I have some time I will continue looking at the GORP code.\n\nCheers\n. ",
    "iwek": "I am getting a similar error with template.HTML, is that type supported?\n. I am getting a similar error with template.HTML, is that type supported?\n. ",
    "octopepper": "Hi !\n\nMaybe you need to implement the sql/driver Valuer interface on your type BlahId ?\nhttp://golang.org/pkg/database/sql/driver/#Valuer\n. Hi !\n\nMaybe you need to implement the sql/driver Valuer interface on your type BlahId ?\nhttp://golang.org/pkg/database/sql/driver/#Valuer\n. ",
    "guotie": "BUG:\n\nthe sql should NOT use \", use ` is correct!\n. yes, I use the gorp.MySQLDialect.\n\nbut the driver i used for mysql is https://github.com/go-sql-driver/mysql\n. ```\npackage main\n\nimport (\n\"database/sql\"\n\"github.com/coopernurse/gorp\"\n_ \"github.com/go-sql-driver/mysql\"\n\"log\"\n\"os\"\n\"testing\"\n)\n\ntype Post struct {\n// db tag lets you specify the column name if it differs\n// from the struct field\nId      int64  `db:\"id\"`\nCreated int64  `db:\"created\"`\nTitle   string `db:\"title\"`\nBody    string `db:\"body\"`\n}\n\nfunc openorm() (*gorp.DbMap, error) {\ndb, err := sql.Open(\"mysql\", \"root:xxxxxxx@/hello\")\nif err != nil {\n    return nil, err\n}\n\nreturn &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{}}, nil\n}\n\nfunc Test_MySQL(t *testing.T) {\nvar (\n    l  *log.Logger\n    db *gorp.DbMap\n)\n\nl = log.New(os.Stdout, \"gorp\", 0)\ndb, err := openorm()\nif err != nil {\n    t.Error(err.Error())\n    panic(\"orm failed\")\n}\n\ndb.TraceOn(\"db:\", l)\nerr = db.DropTablesIfExists()\nif err != nil {\n    t.Error(\"drop table if exists failed!\")\n}\ndb.AddTableWithName(Post{}, \"posts\").SetKeys(true, \"Id\")\nerr = db.CreateTablesIfNotExists()\nif err != nil {\n    t.Error(\"create table failed!\" + err.Error())\n}\n}\n```\n\ngorpdb: create table if not exists `posts` (`id` bigint not null primary key auto_increment, `created` bigint, `title` varchar(255), `body` varchar(255))  engine= charset=; [[]] --- FAIL: Test_MySQL (0.04 seconds)\n        myorm_test.go:51: create table failed!Error 1286: Unknown storage engine 'charset'\n. BUG:\n\nthe sql should NOT use \", use ` is correct!\n. yes, I use the gorp.MySQLDialect.\n\nbut the driver i used for mysql is https://github.com/go-sql-driver/mysql\n. ```\npackage main\n\nimport (\n\"database/sql\"\n\"github.com/coopernurse/gorp\"\n_ \"github.com/go-sql-driver/mysql\"\n\"log\"\n\"os\"\n\"testing\"\n)\n\ntype Post struct {\n// db tag lets you specify the column name if it differs\n// from the struct field\nId      int64  `db:\"id\"`\nCreated int64  `db:\"created\"`\nTitle   string `db:\"title\"`\nBody    string `db:\"body\"`\n}\n\nfunc openorm() (*gorp.DbMap, error) {\ndb, err := sql.Open(\"mysql\", \"root:xxxxxxx@/hello\")\nif err != nil {\n    return nil, err\n}\n\nreturn &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{}}, nil\n}\n\nfunc Test_MySQL(t *testing.T) {\nvar (\n    l  *log.Logger\n    db *gorp.DbMap\n)\n\nl = log.New(os.Stdout, \"gorp\", 0)\ndb, err := openorm()\nif err != nil {\n    t.Error(err.Error())\n    panic(\"orm failed\")\n}\n\ndb.TraceOn(\"db:\", l)\nerr = db.DropTablesIfExists()\nif err != nil {\n    t.Error(\"drop table if exists failed!\")\n}\ndb.AddTableWithName(Post{}, \"posts\").SetKeys(true, \"Id\")\nerr = db.CreateTablesIfNotExists()\nif err != nil {\n    t.Error(\"create table failed!\" + err.Error())\n}\n}\n```\n\ngorpdb: create table if not exists `posts` (`id` bigint not null primary key auto_increment, `created` bigint, `title` varchar(255), `body` varchar(255))  engine= charset=; [[]] --- FAIL: Test_MySQL (0.04 seconds)\n        myorm_test.go:51: create table failed!Error 1286: Unknown storage engine 'charset'\n. ",
    "mclark4386": "I'm fine with using this version over mine. This one seems to fall more in line with expectations of user (i.e. 0 = unlimited).\n. I'm fine with using this version over mine. This one seems to fall more in line with expectations of user (i.e. 0 = unlimited).\n. ",
    "joho": "@coopernurse just pinging to see if this can get merged so the godocs can be updated?\n. @coopernurse just pinging to see if this can get merged so the godocs can be updated?\n. ",
    "scottkf": "@coopernurse ToLower() makes it more difficult to setup structs with properly named fields, it's probably for the best\n. @coopernurse ToLower() makes it more difficult to setup structs with properly named fields, it's probably for the best\n. ",
    "PolluXxX": "I'm a postgres user, and name fields are all case-sensitive. This strings.ToLower should be removed, I think :)\n. I'm a postgres user, and name fields are all case-sensitive. This strings.ToLower should be removed, I think :)\n. ",
    "jordan-wright": "I would remove it: [http://www.postgresql.org/docs/8.0/static/sql-syntax.html#SQL-SYNTAX-IDENTIFIERS](http://www.postgresql.org/docs/8.0/static/sql-syntax.html#SQL-SYNTAX-IDENTIFIERS)\n\n> Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers FOO, foo, and \"foo\" are considered the same by PostgreSQL, but \"Foo\" and \"FOO\" are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, foo should be equivalent to \"FOO\" not \"foo\" according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)\n. I'm not a heavy PostgreSQL user, but it looks to me that we can either:\n- Continue quoting each field and know that they are case sensitive (remove the ToLower())\n- Stop quoting each field and they will be case insensitive.\n\nLeaving it how it is will likely continue to be a \"Gotcha\" for PostgreSQL user's of the library who choose to use case sensitive names, and will probably result in more issues later on down the road.\n. > If you want to run your own CREATE TABLE command as a db migration, just call Exec() with a hand written CREATE TABLE command.\n\nThis is what I wound up doing - thank you.\n. I would remove it: [http://www.postgresql.org/docs/8.0/static/sql-syntax.html#SQL-SYNTAX-IDENTIFIERS](http://www.postgresql.org/docs/8.0/static/sql-syntax.html#SQL-SYNTAX-IDENTIFIERS)\n\n> Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers FOO, foo, and \"foo\" are considered the same by PostgreSQL, but \"Foo\" and \"FOO\" are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, foo should be equivalent to \"FOO\" not \"foo\" according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)\n. I'm not a heavy PostgreSQL user, but it looks to me that we can either:\n- Continue quoting each field and know that they are case sensitive (remove the ToLower())\n- Stop quoting each field and they will be case insensitive.\n\nLeaving it how it is will likely continue to be a \"Gotcha\" for PostgreSQL user's of the library who choose to use case sensitive names, and will probably result in more issues later on down the road.\n. > If you want to run your own CREATE TABLE command as a db migration, just call Exec() with a hand written CREATE TABLE command.\n\nThis is what I wound up doing - thank you.\n. ",
    "chakrit": "I am a PostgreSQL user and I lowercase all my PostgreSQL table and field names by default without even thinking because of that auto-lowercasing rule. It can bites you in the back when you are not careful. I think it makes total sense to also lowercase it automatically in a library, even just for PostgreSQL dialect.\n\nAlthough quoting it would work, but then you'd have to be aware of the fact that when running normal SQL commands and writing SQL files by hand outside of gorp, you have to quote all the generated fields and table names too. IMHO, that's something a seasoned PostgreSQL user probably do not want to be doing.\n\nIt is not hard (quoting all names), but I think mapping field names to the underscore convention might be the better, if not the more common, approach.\n\ni.e. `helloWorld -> hello_world`\n\nalso feels much easier to type than a pair of quotes for me.\n. The SO question @coopernurse posted above has this very comment:\n\n> \"A good rule of thumb that I live by in the PG world is use underscores instead of camel case like you might do in Microsoft SQL Server. So do fast_table instead of \"FastTable\". I find extra quotes at the minimum to be annoying. Though others might find underscores to be the same. But I come from and Oracle background so I'm use to it.\"\n\nhttp://stackoverflow.com/questions/7262795/postgresql-table-name-schema-confusion#comment8755507_7262891\n\nAlso check other answers on that question besides the accepted one.\n. > Leaving it how it is will likely continue to be a \"Gotcha\"\n\nAgree\n\n@coopernurse @jordan-wright  After thinking about this for a few days, quoting is probably the best way for gorp (not necessarily the best for PG user, but we're all compromising anyway since this is a cross-db lib)\n. I am a PostgreSQL user and I lowercase all my PostgreSQL table and field names by default without even thinking because of that auto-lowercasing rule. It can bites you in the back when you are not careful. I think it makes total sense to also lowercase it automatically in a library, even just for PostgreSQL dialect.\n\nAlthough quoting it would work, but then you'd have to be aware of the fact that when running normal SQL commands and writing SQL files by hand outside of gorp, you have to quote all the generated fields and table names too. IMHO, that's something a seasoned PostgreSQL user probably do not want to be doing.\n\nIt is not hard (quoting all names), but I think mapping field names to the underscore convention might be the better, if not the more common, approach.\n\ni.e. `helloWorld -> hello_world`\n\nalso feels much easier to type than a pair of quotes for me.\n. The SO question @coopernurse posted above has this very comment:\n\n> \"A good rule of thumb that I live by in the PG world is use underscores instead of camel case like you might do in Microsoft SQL Server. So do fast_table instead of \"FastTable\". I find extra quotes at the minimum to be annoying. Though others might find underscores to be the same. But I come from and Oracle background so I'm use to it.\"\n\nhttp://stackoverflow.com/questions/7262795/postgresql-table-name-schema-confusion#comment8755507_7262891\n\nAlso check other answers on that question besides the accepted one.\n. > Leaving it how it is will likely continue to be a \"Gotcha\"\n\nAgree\n\n@coopernurse @jordan-wright  After thinking about this for a few days, quoting is probably the best way for gorp (not necessarily the best for PG user, but we're all compromising anyway since this is a cross-db lib)\n. ",
    "johto": "> - Continue quoting each field and know that they are case sensitive (remove the ToLower())\n> - Stop quoting each field and they will be case insensitive.\n\nThese are the two behaviours I've seen in the field the most.  What you currently have makes the least sense to me, since it completely prevents tables with upper-case characters from being used.  The first behaviour has in my experience been used the most, so my vote goes for that one.\n\nI also see other problems with the quoting:\n- Double quotes are not escaped correctly.  They should be escaped by doubling the quote character, e.g. this is what pq does: ``\"` + strings.Replace(name, `\"`, `\"\"`, -1) + `\"``.\n- In QuotedTableForQuery, the schema name should be quoted as well.  It is an identifier and follows the same rules as the table name.\n. Does this code intentionally use \"timestamp\" instead of \"timestamp with time zone\"?  In almost all cases that's a mistake.\n. > I didn't need the timezones, as I assume timestamps to be in the local\n> timezone.\n\nThat has a problem with the repeated hour at the DST boundary.\n. I find this interface a bit difficult to work with, personally.  The way I see it, I would have to:\n\n  1) Create two channels: one for communication, one for the data\n  2) Launch DbMap.Select() in a separate goroutine\n  3) Read results from the channel until the goroutine launched in the previous step either returns an error through the communication channel or closes the data channel (signifying that no more data is going to arrive)\n  4) Deal with the possible error returned via the communication channel\n\nIs that the intended interface?\n. > - Continue quoting each field and know that they are case sensitive (remove the ToLower())\n> - Stop quoting each field and they will be case insensitive.\n\nThese are the two behaviours I've seen in the field the most.  What you currently have makes the least sense to me, since it completely prevents tables with upper-case characters from being used.  The first behaviour has in my experience been used the most, so my vote goes for that one.\n\nI also see other problems with the quoting:\n- Double quotes are not escaped correctly.  They should be escaped by doubling the quote character, e.g. this is what pq does: ``\"` + strings.Replace(name, `\"`, `\"\"`, -1) + `\"``.\n- In QuotedTableForQuery, the schema name should be quoted as well.  It is an identifier and follows the same rules as the table name.\n. Does this code intentionally use \"timestamp\" instead of \"timestamp with time zone\"?  In almost all cases that's a mistake.\n. > I didn't need the timezones, as I assume timestamps to be in the local\n> timezone.\n\nThat has a problem with the repeated hour at the DST boundary.\n. I find this interface a bit difficult to work with, personally.  The way I see it, I would have to:\n\n  1) Create two channels: one for communication, one for the data\n  2) Launch DbMap.Select() in a separate goroutine\n  3) Read results from the channel until the goroutine launched in the previous step either returns an error through the communication channel or closes the data channel (signifying that no more data is going to arrive)\n  4) Deal with the possible error returned via the communication channel\n\nIs that the intended interface?\n. ",
    "keepzero": "bindUpdate method will cache query fields to t.updatePlan.query, so next time I run Update or UpdateWithSelector, the colSelector function will never be executed.\n. bindUpdate method will cache query fields to t.updatePlan.query, so next time I run Update or UpdateWithSelector, the colSelector function will never be executed.\n. ",
    "tquach": ":+1:\n. :+1:\n. ",
    "masom": ":+1: \n. :+1: \n. ",
    "vergult": "It is indeed a strict mapping. Another way to get around this is to explicitly tell which columns you want to fetch in your query. Compared to the first tip, it has the benefit to prevent you from editing your model each time a column is added to the corresponding table.\n. It is indeed a strict mapping. Another way to get around this is to explicitly tell which columns you want to fetch in your query. Compared to the first tip, it has the benefit to prevent you from editing your model each time a column is added to the corresponding table.\n. ",
    "logan": "As is, it's unsafe to use \"select *\" if you ever plan on rolling out changes to the DB schema without downtime.\n. As is, it's unsafe to use \"select *\" if you ever plan on rolling out changes to the DB schema without downtime.\n. ",
    "fzerorubigd": ":-1: \nPersonally, I prefer to use strict mapping, and prevent unpredictable behavior, like what you can see in language such as PHP.  \n. If the result is not exactly one row, then this is correct behavior. See https://godoc.org/gopkg.in/gorp.v1#SelectOne\n\nIf this is not what you want, then use Select. \n. What is the type of response.AppsData?\n. :-1: \nPersonally, I prefer to use strict mapping, and prevent unpredictable behavior, like what you can see in language such as PHP.  \n. If the result is not exactly one row, then this is correct behavior. See https://godoc.org/gopkg.in/gorp.v1#SelectOne\n\nIf this is not what you want, then use Select. \n. What is the type of response.AppsData?\n. ",
    "recht": "There is a very specific case where it would be nice if it was possible to ignore columns: when fetching database metadata where you don't have control of the output columns. For example, `show slave status` in mysql outputs a fairly long list of columns, and you can't limit the columns. You also don't quite know if a newer mysql version will add more columns to the output.. I know that postgresql uses regular selects for metadata. That's why I singled out mysql, which has custom statements for much of the metadata where you cannot control the output.\r\n\r\nAnyway, your suggestion would definitely work for me.. There is a very specific case where it would be nice if it was possible to ignore columns: when fetching database metadata where you don't have control of the output columns. For example, `show slave status` in mysql outputs a fairly long list of columns, and you can't limit the columns. You also don't quite know if a newer mysql version will add more columns to the output.. I know that postgresql uses regular selects for metadata. That's why I singled out mysql, which has custom statements for much of the metadata where you cannot control the output.\r\n\r\nAnyway, your suggestion would definitely work for me.. ",
    "notnil": "This looks really useful.  I was thinking about doing the same thing. \n. This looks really useful.  I was thinking about doing the same thing. \n. ",
    "spencerkimball": "I've added functionality for this specific to MySQL. See PR https://github.com/go-gorp/gorp/pull/174\n. The implementation here is somewhat problematic. Something I didn't realize when I submitted the patch is that the \"on duplicate key update\" directive in MySQL will update an existing tuple on any duplicate index, not just primary key. This seems very suspect and weird. I would have thought this would apply only to primary key. Now to be fair, there may not be a primary key for a table. Still, it's very counter intuitive that this updates an existing tuple on a non-primary index have a duplicate entry instead of returning an error.\n\nI realize it does have mysql-specific behavior, but I thought that's what the dialect code paths were for?\n\nI've had to revert to code which instead does a get for the tuple and then either an insert or update as appropriate. I needed the original value in any case, so it was a palatable solution. The upsert still seems like it has value however, and I'm continuing to use it in other places. I'm not sure about other ORMs, but the other pattern I have seen in code to handle the upsert case is to try an update then fall back to an insert.\n\nI think \"merge\" would be a bad name for what this is doing as the SQL ANSI merge details are very complex and over designed. This functionality would have to be modified from what's there now. \"Upsert\" seems to be a much more \"standardized\" term for this pattern.\n. I'm not currently working with gorp, so no immediate plans to add this feature.\n. I've added functionality for this specific to MySQL. See PR https://github.com/go-gorp/gorp/pull/174\n. The implementation here is somewhat problematic. Something I didn't realize when I submitted the patch is that the \"on duplicate key update\" directive in MySQL will update an existing tuple on any duplicate index, not just primary key. This seems very suspect and weird. I would have thought this would apply only to primary key. Now to be fair, there may not be a primary key for a table. Still, it's very counter intuitive that this updates an existing tuple on a non-primary index have a duplicate entry instead of returning an error.\n\nI realize it does have mysql-specific behavior, but I thought that's what the dialect code paths were for?\n\nI've had to revert to code which instead does a get for the tuple and then either an insert or update as appropriate. I needed the original value in any case, so it was a palatable solution. The upsert still seems like it has value however, and I'm continuing to use it in other places. I'm not sure about other ORMs, but the other pattern I have seen in code to handle the upsert case is to try an update then fall back to an insert.\n\nI think \"merge\" would be a bad name for what this is doing as the SQL ANSI merge details are very complex and over designed. This functionality would have to be modified from what's there now. \"Upsert\" seems to be a much more \"standardized\" term for this pattern.\n. I'm not currently working with gorp, so no immediate plans to add this feature.\n. ",
    "tobz": "That use case is fundamentally flawed, though.  You're adding unnecessary complexity by forming a composite key on the primary key and that client ID column.  You could do the RUD operations with just the primary key.  This would be a different story if you had a composite key on, say, client_id and name, but it makes no sense otherwise.\n. The one at the beginning of the \"Ad Hoc SQL\" section:\n\n`var post Post\nerr := dbmap.SelectOne(&post, \"select * from post where id=?\", id)`\n\nAlso note, I don't have a reproducible standalone testcase for this.  It was 100% reproducible in my codebase and switching to an initialized struct fixed the issue.  You can feel free to beat me with a shoe if my report isn't entirely accurate, though. :)\n. Hrmph.  Oh, so, see, here I go again, filing bad issues.  I was calling SelectOne in a transaction.\n\nAre you also testing with Go 1.2?  Maybe I _do_ need to whip up a standalone test case. :)\n. That use case is fundamentally flawed, though.  You're adding unnecessary complexity by forming a composite key on the primary key and that client ID column.  You could do the RUD operations with just the primary key.  This would be a different story if you had a composite key on, say, client_id and name, but it makes no sense otherwise.\n. The one at the beginning of the \"Ad Hoc SQL\" section:\n\n`var post Post\nerr := dbmap.SelectOne(&post, \"select * from post where id=?\", id)`\n\nAlso note, I don't have a reproducible standalone testcase for this.  It was 100% reproducible in my codebase and switching to an initialized struct fixed the issue.  You can feel free to beat me with a shoe if my report isn't entirely accurate, though. :)\n. Hrmph.  Oh, so, see, here I go again, filing bad issues.  I was calling SelectOne in a transaction.\n\nAre you also testing with Go 1.2?  Maybe I _do_ need to whip up a standalone test case. :)\n. ",
    "fwang2002": "Yes. It's for load balancing purpose. Used when splitting tables.\n. The auto-increment may start from a specified number, say 10000, thus reserved 9999 records for special use, which need the field to be set by application layer when inserting.\nFor example, the users table may reserve 10000 records which is for registering admin users, and the records starting from 10001 is for real end users.\n. If field `id` is an auto-increment field, and is starting by 10000. If the corresponding struct is \ntype User struct {\n    Id  int `db:\"id\"`\n    ...\n}\nThe following code can not run correctly.\ndbMap.AddTableWithName(User{}, \"users\").SetKeys(true, \"id\")\nvar user = &User{Id: 9000}\ndbMap.Insert(user)\nafter execution, the Id is reset to the value of database returned value. user.Id can not be set by application layer.\n. Yes. It's for load balancing purpose. Used when splitting tables.\n. The auto-increment may start from a specified number, say 10000, thus reserved 9999 records for special use, which need the field to be set by application layer when inserting.\nFor example, the users table may reserve 10000 records which is for registering admin users, and the records starting from 10001 is for real end users.\n. If field `id` is an auto-increment field, and is starting by 10000. If the corresponding struct is \ntype User struct {\n    Id  int `db:\"id\"`\n    ...\n}\nThe following code can not run correctly.\ndbMap.AddTableWithName(User{}, \"users\").SetKeys(true, \"id\")\nvar user = &User{Id: 9000}\ndbMap.Insert(user)\nafter execution, the Id is reset to the value of database returned value. user.Id can not be set by application layer.\n. ",
    "NickNeedsAName": "From my best understanding selectonly == autogenerate  yes.  \n\nI agree that it's likely that one would want UpdateOnUpdate if UpdateOnInsert already exists, but I'm not exactly sure of the most succinct way to express this.  It also has to be a Transient//Autogenerate//SelectOnly field.  I'm open to suggestions.\n. From my best understanding selectonly == autogenerate  yes.  \n\nI agree that it's likely that one would want UpdateOnUpdate if UpdateOnInsert already exists, but I'm not exactly sure of the most succinct way to express this.  It also has to be a Transient//Autogenerate//SelectOnly field.  I'm open to suggestions.\n. ",
    "kristian-puccio": "bump on this, just need a way to let the DB handle inserted and updated timestamps.\n\nCheers\n. bump on this, just need a way to let the DB handle inserted and updated timestamps.\n\nCheers\n. ",
    "porjo": "I've answered my own question. `gorp_test.go` demonstrates how this is done, it just took me some time to join the dots. For the benefit of others, I got it working by adding `typeConverter` which implements `gorp.TypeConverter` as follows:\n\n``` Go\ntype typeConverter struct{}\n\nfunc (t typeConverter) ToDb(val interface{}) (interface{}, error) {\n\n        switch t := val.(type) {\n        case TripData:\n                b, err := json.Marshal(t)\n                if err != nil {\n                        return \"\", err\n                }\n                return string(b), nil\n        }\n        return val, nil\n}\n\nfunc (t typeConverter) FromDb(target interface{}) (gorp.CustomScanner, bool) {\n\n        switch target.(type) {\n        case *TripData:\n                binder := func(holder, target interface{}) error {\n                        s, ok := holder.(*string)\n                        if !ok {\n                                return errors.New(\"FromDb: Unable to convert TripData entry to *string\")\n                        }\n                        b := []byte(*s)\n                        return json.Unmarshal(b, target)\n                }\n                return gorp.CustomScanner{new(string), target, binder}, true\n        }\n        return gorp.CustomScanner{}, false\n}\n```\n\nThen set dbmap `TypeConverter`:\n\n``` Go\ndbmap.TypeConverter = typeConverter{}\n```\n. I found the explantion for this here:\nhttps://groups.google.com/forum/#!topic/golang-nuts/RPMLsEkvY3E\n\nChanging the Errorf to use `%#v` instead of just `%v` reveals:\n\n```\n(time.Time) time.Time{sec:0, nsec:0, loc:(*time.Location)(nil)} != (time.Time) time.Time{sec:0, nsec:0, loc:(*time.Location)(0x785340)}\n```\n\nSo the `time.Location` field is different (albeit both UTC).\n\n```\n```\n. @begizi no, I'm just using raw SQL queries. I've not used triggers before, so I'd be interested to know how that works.\n. I've answered my own question. `gorp_test.go` demonstrates how this is done, it just took me some time to join the dots. For the benefit of others, I got it working by adding `typeConverter` which implements `gorp.TypeConverter` as follows:\n\n``` Go\ntype typeConverter struct{}\n\nfunc (t typeConverter) ToDb(val interface{}) (interface{}, error) {\n\n        switch t := val.(type) {\n        case TripData:\n                b, err := json.Marshal(t)\n                if err != nil {\n                        return \"\", err\n                }\n                return string(b), nil\n        }\n        return val, nil\n}\n\nfunc (t typeConverter) FromDb(target interface{}) (gorp.CustomScanner, bool) {\n\n        switch target.(type) {\n        case *TripData:\n                binder := func(holder, target interface{}) error {\n                        s, ok := holder.(*string)\n                        if !ok {\n                                return errors.New(\"FromDb: Unable to convert TripData entry to *string\")\n                        }\n                        b := []byte(*s)\n                        return json.Unmarshal(b, target)\n                }\n                return gorp.CustomScanner{new(string), target, binder}, true\n        }\n        return gorp.CustomScanner{}, false\n}\n```\n\nThen set dbmap `TypeConverter`:\n\n``` Go\ndbmap.TypeConverter = typeConverter{}\n```\n. I found the explantion for this here:\nhttps://groups.google.com/forum/#!topic/golang-nuts/RPMLsEkvY3E\n\nChanging the Errorf to use `%#v` instead of just `%v` reveals:\n\n```\n(time.Time) time.Time{sec:0, nsec:0, loc:(*time.Location)(nil)} != (time.Time) time.Time{sec:0, nsec:0, loc:(*time.Location)(0x785340)}\n```\n\nSo the `time.Location` field is different (albeit both UTC).\n\n```\n```\n. @begizi no, I'm just using raw SQL queries. I've not used triggers before, so I'd be interested to know how that works.\n. ",
    "ttacon": "Just bumping this, any comments on it?\n. Hi, I was just wondering if I could get some feedback on this pull request? Thanks in advance!\n. I agree, to me this seems at odds with Gorp's design. Normally when I use gorp I see it as \"I give you this information and I get this data back\" - this interface would imply extra infrastructure (as also mentioned by @johto) that I need to write to in order deal with pulling the data out myself. This leads to more cases to deal with rather than the simple, perceptually \"atomic\", here's my returned data and  any error that may have occurred.\n. Does gorp know about the database table that the Users struct corresponds to? e.g. do you call AddTable() or AddTableWithName() anywhere and pass Users in?\n. There aren't any errors trying to connect the second time or anything? If you could, could you post a little more of the actual code (as a gist or whatever)? As a quick note, are you sure you're adding the struct to the db map the second time you open the db connection (from your code you're not, you only call AddTableWithName() the first time, not the second).\n. Just bumping this, any comments on it?\n. Hi, I was just wondering if I could get some feedback on this pull request? Thanks in advance!\n. I agree, to me this seems at odds with Gorp's design. Normally when I use gorp I see it as \"I give you this information and I get this data back\" - this interface would imply extra infrastructure (as also mentioned by @johto) that I need to write to in order deal with pulling the data out myself. This leads to more cases to deal with rather than the simple, perceptually \"atomic\", here's my returned data and  any error that may have occurred.\n. Does gorp know about the database table that the Users struct corresponds to? e.g. do you call AddTable() or AddTableWithName() anywhere and pass Users in?\n. There aren't any errors trying to connect the second time or anything? If you could, could you post a little more of the actual code (as a gist or whatever)? As a quick note, are you sure you're adding the struct to the db map the second time you open the db connection (from your code you're not, you only call AddTableWithName() the first time, not the second).\n. ",
    "gwitmond": "On 03/06/14 10:18, Marko Tiikkaja wrote:\n\n> Does this code intentionally use \"timestamp\" instead of \"timestamp with\n> time zone\"? In almost all cases that's a mistake.\n\nI didn't need the timezones, as I assume timestamps to be in the local\ntimezone.\n\nFeel free to change it to include the time zone if that suits more\npeople better.\n. On 03/06/14 11:42, Marko Tiikkaja wrote:\n\n> ```\n> I didn't need the timezones, as I assume timestamps to be in the local\n> timezone.\n> ```\n> \n> That has a problem with the repeated hour at the DST boundary.\n\nI know the problem but didn't consider it a problem for my application.\n\nThis code started as an itch to scratch. I'm offering in the hope it can\nbe useful to others. And with timezome, as you mentioned, it gets even\nbetter.\n\nRegards, Guido.\n\n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/coopernurse/gorp/pull/145#issuecomment-36843606.\n. On 03/06/14 10:18, Marko Tiikkaja wrote:\n\n> Does this code intentionally use \"timestamp\" instead of \"timestamp with\n> time zone\"? In almost all cases that's a mistake.\n\nI didn't need the timezones, as I assume timestamps to be in the local\ntimezone.\n\nFeel free to change it to include the time zone if that suits more\npeople better.\n. On 03/06/14 11:42, Marko Tiikkaja wrote:\n\n> ```\n> I didn't need the timezones, as I assume timestamps to be in the local\n> timezone.\n> ```\n> \n> That has a problem with the repeated hour at the DST boundary.\n\nI know the problem but didn't consider it a problem for my application.\n\nThis code started as an itch to scratch. I'm offering in the hope it can\nbe useful to others. And with timezome, as you mentioned, it gets even\nbetter.\n\nRegards, Guido.\n\n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/coopernurse/gorp/pull/145#issuecomment-36843606.\n. ",
    "manugarri": "so Im using time.Time as a type on my model, but somehow when doing a dbmap.insert i get the error:\n\"Error inserting in Postgres db pq: invalid input syntax for type timestamp: \"1414101215\"\n\nis there any recommended way of dealing with timestamps?\n. so Im using time.Time as a type on my model, but somehow when doing a dbmap.insert i get the error:\n\"Error inserting in Postgres db pq: invalid input syntax for type timestamp: \"1414101215\"\n\nis there any recommended way of dealing with timestamps?\n. ",
    "zhengjia": "I like the solution, thanks for taking care of it.\n. I like the solution, thanks for taking care of it.\n. ",
    "seantalts": "is this fixed in the latest gorp?\n. is this fixed in the latest gorp?\n. ",
    "JonPulfer": "Sure I can write a test in the morning demonstrating the use case I created it for. \n\nBasically I needed to read through ~2 million rows in a mysql table, processing each row and inserting  them into elasticsearch with various changes to fields. Using the conventional DbMap.Select() method resulted in memory usage around 7.5Gb whereas by returning each row on the channel, memory usage sits around 180Mb. \n\nAlso this is in addition to the accepted result structures that DbMap.Select() accepts. It just means that it will identify a channel being passed in that meets the criteria which will then prompt a stream type response. If you pass in the pointer to a slice, it still writes to that entirely before completing, as it did before I added this.\n. This build is failing on the unique constraint tests. My test passes, let me know if it clears up the usage queries.\n\nKind regards,\nJon\n. Hi Geert-Johan,\n\nI found it useful for the task I created it for, I submitted the PR in case it was something others would find useful. I can look at creating a new PR from current develop branch if that would help?\n\nKind regards,\nJon\n\n> On 1 Jul 2015, at 15:29, Geert-Johan Riemer notifications@github.com wrote:\n> \n> @JonPulfer I'm very interested in this feature, but sadly the PR seems to be messed up a bit.\n> I think the feature could be best added in a new SelectFoobar method. \n> We're now cleaning up the issue and PR backlog (see #270), so I think this feature would best be added after we're done with that. I think it will require a new PR as at that point code will be separated into multiple files and more changes applied. Keeping this PR open so we will look at it again. Please let me know if you're still interested in seeing this merged.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Ok, I will watch out for that release.\n\nKind regards,\nJon\n\n> On 1 Jul 2015, at 22:07, Geert-Johan Riemer notifications@github.com wrote:\n> \n> We've stopped using the develop branch, all development now takes place at master. I think it would be best to wait until we have cleaned up the codebase and have released v2, that will also make development easier for you.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Sure I can write a test in the morning demonstrating the use case I created it for. \n\nBasically I needed to read through ~2 million rows in a mysql table, processing each row and inserting  them into elasticsearch with various changes to fields. Using the conventional DbMap.Select() method resulted in memory usage around 7.5Gb whereas by returning each row on the channel, memory usage sits around 180Mb. \n\nAlso this is in addition to the accepted result structures that DbMap.Select() accepts. It just means that it will identify a channel being passed in that meets the criteria which will then prompt a stream type response. If you pass in the pointer to a slice, it still writes to that entirely before completing, as it did before I added this.\n. This build is failing on the unique constraint tests. My test passes, let me know if it clears up the usage queries.\n\nKind regards,\nJon\n. Hi Geert-Johan,\n\nI found it useful for the task I created it for, I submitted the PR in case it was something others would find useful. I can look at creating a new PR from current develop branch if that would help?\n\nKind regards,\nJon\n\n> On 1 Jul 2015, at 15:29, Geert-Johan Riemer notifications@github.com wrote:\n> \n> @JonPulfer I'm very interested in this feature, but sadly the PR seems to be messed up a bit.\n> I think the feature could be best added in a new SelectFoobar method. \n> We're now cleaning up the issue and PR backlog (see #270), so I think this feature would best be added after we're done with that. I think it will require a new PR as at that point code will be separated into multiple files and more changes applied. Keeping this PR open so we will look at it again. Please let me know if you're still interested in seeing this merged.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Ok, I will watch out for that release.\n\nKind regards,\nJon\n\n> On 1 Jul 2015, at 22:07, Geert-Johan Riemer notifications@github.com wrote:\n> \n> We've stopped using the develop branch, all development now takes place at master. I think it would be best to wait until we have cleaned up the codebase and have released v2, that will also make development easier for you.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "bennyscetbun": "The idea was to avoid a single lock(in case that we ve got a lot of goroutine doing different things).\nBut yeah we could use your way. A single mutex would work :)\n. I think it must be before \n\n``` go\nif plan.query == \"\" {\n```\n\nThe racing condition was on plan.query ;)\n\nAnd that way we avoid to run twice the creation code.\n\nBy the way thanks for your lib!\n. The idea was to avoid a single lock(in case that we ve got a lot of goroutine doing different things).\nBut yeah we could use your way. A single mutex would work :)\n. I think it must be before \n\n``` go\nif plan.query == \"\" {\n```\n\nThe racing condition was on plan.query ;)\n\nAnd that way we avoid to run twice the creation code.\n\nBy the way thanks for your lib!\n. ",
    "kungfumike": "So, my brain is going to be a tiny bit slow to recall here, but yes.\n\nIf you run the test I checked in, without the patch, I do believe it\ngenerates invalid sql and blows up at the driver level. As a matter of fact\nI am almost positive.\n\nOn Wed, May 14, 2014 at 3:16 PM, James Cooper notifications@github.comwrote:\n\n> Apologies for the delay in reviewing this.\n> \n> I'm probably being dense, but what's the use case here? I see the failing\n> test, and I think your patch is safe, but the generated SQL will always\n> no-op right? Here's the generated SQL from the test:\n> \n> update \"single_column_table\" set \"SomeId\"=? where \"SomeId\"=?;\n>    [A Unique Id String A Unique Id String]\n> \n> Just to be clear - the goal is to avoid the invalid SQL statement\n> generated before the patch. Is that right? Or are there cases where this\n> patch would actually result in a productive (i.e. state mutating) update on\n> a table?\n> \n> thanks\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/coopernurse/gorp/pull/155#issuecomment-43144978\n> .\n\n## \n\n-Mike\n. Oh, and it was more then that. You can cause this error with anything where you declare a PK that is defined by you, not by the machine. If it is AutoIncrement, which is generated by the DB, then you are fine, but if you decided to use a string, like a UUID, as a PK? It is still a valid PK, but it is not AutoIncrementing. SO your code would skip over it.\n. So, my brain is going to be a tiny bit slow to recall here, but yes.\n\nIf you run the test I checked in, without the patch, I do believe it\ngenerates invalid sql and blows up at the driver level. As a matter of fact\nI am almost positive.\n\nOn Wed, May 14, 2014 at 3:16 PM, James Cooper notifications@github.comwrote:\n\n> Apologies for the delay in reviewing this.\n> \n> I'm probably being dense, but what's the use case here? I see the failing\n> test, and I think your patch is safe, but the generated SQL will always\n> no-op right? Here's the generated SQL from the test:\n> \n> update \"single_column_table\" set \"SomeId\"=? where \"SomeId\"=?;\n>    [A Unique Id String A Unique Id String]\n> \n> Just to be clear - the goal is to avoid the invalid SQL statement\n> generated before the patch. Is that right? Or are there cases where this\n> patch would actually result in a productive (i.e. state mutating) update on\n> a table?\n> \n> thanks\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/coopernurse/gorp/pull/155#issuecomment-43144978\n> .\n\n## \n\n-Mike\n. Oh, and it was more then that. You can cause this error with anything where you declare a PK that is defined by you, not by the machine. If it is AutoIncrement, which is generated by the DB, then you are fine, but if you decided to use a string, like a UUID, as a PK? It is still a valid PK, but it is not AutoIncrementing. SO your code would skip over it.\n. ",
    "shuhaowu": "+1 for this.\n. I can submit a PR with a fail case soon.\n. Oh, to clarify, the query returns `0|`. So the first is 0, the second is nil.\n. +1 for this.\n. I can submit a PR with a fail case soon.\n. Oh, to clarify, the query returns `0|`. So the first is 0, the second is nil.\n. ",
    "nobu-k": ":+1: I need this, too.\n. :+1: I need this, too.\n. ",
    "daemonfire300": "Imagine: I  call Select(User{}) this will call PostGet on the User, which will cal Select(Group{}) which will call PostGet on Group which will call Select(User{}), this can not be handled by the PostGet or Object itself, because the PostGet is called automatically when fetching the first object.\n. https://github.com/coopernurse/gorp/blob/develop/gorp.go#L1438-L1468 \nJust needs to use an internal map with pointers to the objects and a flag so it can check for circular references.\n. Any estimation on this problem?\n. Imagine: I  call Select(User{}) this will call PostGet on the User, which will cal Select(Group{}) which will call PostGet on Group which will call Select(User{}), this can not be handled by the PostGet or Object itself, because the PostGet is called automatically when fetching the first object.\n. https://github.com/coopernurse/gorp/blob/develop/gorp.go#L1438-L1468 \nJust needs to use an internal map with pointers to the objects and a flag so it can check for circular references.\n. Any estimation on this problem?\n. ",
    "randallsquared": "The SelectOne method on DbMap.  Here's the code that behaved that way:\n\n```\ntype Auth struct {\n    InHash     []byte `db:\"-\"`\n    Hash       []byte\n    Username   *string\n}\n\nfunc (a *Auth) GetWithUsername() error {\n    // inHash := a.InHash // commented out my workaround\n    err := dbmap.SelectOne(a, \"select * from auth where username = $1\", a.Username)\n    if err != nil {\n        return err \n    }\n    // at this point, a.InHash is zeroed\n    return bcrypt.CompareHashAndPassword(a.Hash, a.InHash) // inHash)\n}\n```\n\nOf course, it's possible I'm Doing It Wrong.  :)\n. The SelectOne method on DbMap.  Here's the code that behaved that way:\n\n```\ntype Auth struct {\n    InHash     []byte `db:\"-\"`\n    Hash       []byte\n    Username   *string\n}\n\nfunc (a *Auth) GetWithUsername() error {\n    // inHash := a.InHash // commented out my workaround\n    err := dbmap.SelectOne(a, \"select * from auth where username = $1\", a.Username)\n    if err != nil {\n        return err \n    }\n    // at this point, a.InHash is zeroed\n    return bcrypt.CompareHashAndPassword(a.Hash, a.InHash) // inHash)\n}\n```\n\nOf course, it's possible I'm Doing It Wrong.  :)\n. ",
    "pierreprinetti": "I felt like `github.com/denisenkom/go-mssqldb` was working good enough.\n\nPlease add\n\n```\nfunc (d SqlServerDialect) QuerySuffix() string { return \";\" }\n```\n\nto make SqlServerDialect compliant with the interface again\n. @DavsX This is precisely what I suggest in #246:\n\n``` Go\ntype Table struct {\n    SomeField String `db:\"size:30\"`\n}\n```\n. That's... one step further: have a look at qrawl@f7adc7a :)\n\nI'm just waiting for #246 to be pulled. With the new tag parsing, this one could be simple to add. And then you could be allowed to choose, say, a Date type over the datetime default for `time.Time` objects:\n\n``` Go\ntype Table struct {\n    SomeDateField time.Time `db:\"type:date\"`\n}\n```\n. By convention, we tend to let the tag keys be referenced from different packages. So for example you can save with gorp an unmarshaled JSON:\n\n``` Go\ntype Person struct {\n    Name     string    `db:\"name\"      json:\"client_name\"`\n    Birthday time.Time `db:\"type:date\" json:\"client_date_of_birth,omitempty\"`\n}\n```\n. @nelsam Honestly, I've only seen leading commas in tags when providing options while omitting a positional argument (as the field name for many parsers). My PR #246 lets you write tags in that way if you want to.\n\nRegarding the tag parsing logic: I am not really into using third party libraries for these simple tasks. Is it worth it? Maybe I could move the logic in a separate function in order to avoid bloating `readStructColumns`.\n. PR #246 \n. @ipartner Are you still experimenting the issue? Can you post an example code for us to see the problem?\n. @glycerine What about adding the (DB-dependant) index type to the `CreateIndexSuffix` function signature, freeing `gorp.go` from inspecting the dialect?\n\n``` Go\nfunc (d PostgresDialect) CreateIndexSuffix(indexType string) string {\n    return fmt.Sprint(\"using %s\", indexType)\n}\n```\n\nPS: with #246, indexes (as well as PKs) could be parsed from field tags.\n. Please add a comment here if you experience the problem again. In the meanwhile, I'm closing the issue.\n. This could be an easy task, but I hesitate to make a PR as there are so many PRs awaiting approval I fear that adding more could only lead to break each other.\n\nDo you guys plan to add new collaborators to maybe help the review process?\n. Thank you, I'm working on this.\n. Nice job. My attempt https://github.com/qrawl/gorp/blob/mssqlfix/dialect.go#L454 had some retrocompatibility added using a `Version` property on the dialect struct.\n. You are right. Nonetheless, Acces2007 reads a 255<nvarchar as \"memo\" field, thus limiting query capabilities, hence the check.\nI would assume that those who use mssql2005 in 2015 are likely to use Acces as well.\n. It seems like you can't use a `nvchar(max)` field as primary key. Do you have such experience?\n. Thank you, I learnt something new.\nI just wanted to point out that now a default value would be an invalid primary key. That said,\n\n> For gorp I think it is acceptable to have to specify a max string length if you want to index the field.\n\nSeems right.\n. PR #247 \n. Thank YOU :+1: \n. Conflicts with #233.\nIt's certainly true that PKs are better defined in the table schema, but field size can't go anywhere else. \n. Here it is.\nThe first argument key, if not recognized as a usable property and if provided without value, is assigned to `columnName`. If there's a `name` argument, the latter will prevail.\n\nI've used `:` for assignment. But isn't `=` more idiomatic?\n\nRegarding the use of `true` as the default value, I've come up thinking that it could be easily implemented as\n\n``` Go\nswitch argK {\n...\ncase \"omitempty\":\n    if argV == \"false\" {\n        break\n    }\n    someOmitEmptyVariable = true\n...\n}\n```\n. I've reverted the logic to the simplest case, as proposed by @GeertJohan:\n\n```\nTag = Name { ','  }\nOption = OptionKey [ ':' OptionValue ]\n```\n\nThere are many PRs out there that could benefit from a tag parsing like this one (thinking of `omitempty` or `type` for forcing DB-specific or optimized types).\n. u right.\n. Hey there.\nThis PR doesn't seem to break anything. Any advice from projects collaborators?\n. I use SQL Server at work.\nI wrote the dialect when the project was @coopernurse's (see the README... hey, I'm particularly proud of that! :).\nThe edits suggested by @FilipDeVos are a certain improvement over what I had written at first.\nI am actually using this PR in production. I hope to see the automated testing (#249) working soon, but until then I see no worries on merging this this PR as it is nothing but an improvement on the SQL Server syntax.\n. @nelsam @GeertJohan Guys, are you really taking into account PRs from non-collaborators?\n. @GeertJohan Would be glad to!\n. This problem was already present in the first version of the dialect: mssql won't accept PK fields longer than something like 255.\nGORP could check for PKs and automatically set the greater accepted length when `max` is specified. But wouldn't this be a little intrusive?\n. @GeertJohan Travis doesn't test SQL Server: I haven't touched `test_all.sh`, which is defined as the test script in `.travis.yml`.\nSQL Server hangs on Appveyor (see [here](https://ci.appveyor.com/project/qrawl/gorp/build/appveyor%20-%20101))...\n. It isn't working. This PR was in fact meant as a call for help :)\nI will get back on it as soon as I figure out a solution.\n. I suggest moving this to phase 3. Getting testing to work on Appveyor will imply some work on the test code, which we are planning to undergo some heavy maintenance soon.\n. Tell me if I am wrong, but isn't this an SQL question rather than a GORP question?\n. I've tested your code, it created me a table with this line:\n\n```\nCREATE TABLE \"posts\" (\"post_id\" integer not null primary key autoincrement, \"Created\" integer, \"Title\" varchar(50), \"article_body\" varchar(1024));\n```\n\nIt seems correct to me. You could be using an old version of Gorp, dating back to before the implementation of the `size` tag.\n\nHave you tried `go get -u gopkg.in/gorp.v1`? If so, please check the import in the go file as well, as it shouldn't be `import \"github.com/coopernurse/gorp\"`.\n\nDo you still experience the problem?\n. What platform do you experience the problem on? Can you please post the entire minimum compiling code to reproduce the issue? \n\n[This code](https://gist.github.com/qrawl/a081fdd931c8c6ccd14d) works for me, resulting in (sqlitebrowser screenshot):\n\n![sqlitebrowser screenshot](http://qrawl.net/gorpsizebug.png)\n. Match function at gorp.go:1852 doesn't take into account multiple tags. I'm on it\n. :+1: great job\n. Thank you for contributing.\nWhat about adding some actual error checking?\n`if err != nil {`...\n. @GeertJohan Looks good to me.\nThank you!\n. How do you import GORP in your code? Are you using `import \"gopkg.in/gorp.v1\"`?\nIt is possible that the `size` capability is only on the master branch. Try using `import \"github.com/go-gorp/gorp\"`, assuming you're aware that's an unsupported bleeding edge branch.\n. The `size` feature is only available on the development branch. If you feel adventurous, try\n\n```\nimport \"github.com/go-gorp/gorp\"\n```\n. You are right. This was meant to be a transitory condition. This should be addressed soon.\n. Thank you, I'm merging this: the README is already saying GORP supports Go 1.3+.\n. I felt like `github.com/denisenkom/go-mssqldb` was working good enough.\n\nPlease add\n\n```\nfunc (d SqlServerDialect) QuerySuffix() string { return \";\" }\n```\n\nto make SqlServerDialect compliant with the interface again\n. @DavsX This is precisely what I suggest in #246:\n\n``` Go\ntype Table struct {\n    SomeField String `db:\"size:30\"`\n}\n```\n. That's... one step further: have a look at qrawl@f7adc7a :)\n\nI'm just waiting for #246 to be pulled. With the new tag parsing, this one could be simple to add. And then you could be allowed to choose, say, a Date type over the datetime default for `time.Time` objects:\n\n``` Go\ntype Table struct {\n    SomeDateField time.Time `db:\"type:date\"`\n}\n```\n. By convention, we tend to let the tag keys be referenced from different packages. So for example you can save with gorp an unmarshaled JSON:\n\n``` Go\ntype Person struct {\n    Name     string    `db:\"name\"      json:\"client_name\"`\n    Birthday time.Time `db:\"type:date\" json:\"client_date_of_birth,omitempty\"`\n}\n```\n. @nelsam Honestly, I've only seen leading commas in tags when providing options while omitting a positional argument (as the field name for many parsers). My PR #246 lets you write tags in that way if you want to.\n\nRegarding the tag parsing logic: I am not really into using third party libraries for these simple tasks. Is it worth it? Maybe I could move the logic in a separate function in order to avoid bloating `readStructColumns`.\n. PR #246 \n. @ipartner Are you still experimenting the issue? Can you post an example code for us to see the problem?\n. @glycerine What about adding the (DB-dependant) index type to the `CreateIndexSuffix` function signature, freeing `gorp.go` from inspecting the dialect?\n\n``` Go\nfunc (d PostgresDialect) CreateIndexSuffix(indexType string) string {\n    return fmt.Sprint(\"using %s\", indexType)\n}\n```\n\nPS: with #246, indexes (as well as PKs) could be parsed from field tags.\n. Please add a comment here if you experience the problem again. In the meanwhile, I'm closing the issue.\n. This could be an easy task, but I hesitate to make a PR as there are so many PRs awaiting approval I fear that adding more could only lead to break each other.\n\nDo you guys plan to add new collaborators to maybe help the review process?\n. Thank you, I'm working on this.\n. Nice job. My attempt https://github.com/qrawl/gorp/blob/mssqlfix/dialect.go#L454 had some retrocompatibility added using a `Version` property on the dialect struct.\n. You are right. Nonetheless, Acces2007 reads a 255<nvarchar as \"memo\" field, thus limiting query capabilities, hence the check.\nI would assume that those who use mssql2005 in 2015 are likely to use Acces as well.\n. It seems like you can't use a `nvchar(max)` field as primary key. Do you have such experience?\n. Thank you, I learnt something new.\nI just wanted to point out that now a default value would be an invalid primary key. That said,\n\n> For gorp I think it is acceptable to have to specify a max string length if you want to index the field.\n\nSeems right.\n. PR #247 \n. Thank YOU :+1: \n. Conflicts with #233.\nIt's certainly true that PKs are better defined in the table schema, but field size can't go anywhere else. \n. Here it is.\nThe first argument key, if not recognized as a usable property and if provided without value, is assigned to `columnName`. If there's a `name` argument, the latter will prevail.\n\nI've used `:` for assignment. But isn't `=` more idiomatic?\n\nRegarding the use of `true` as the default value, I've come up thinking that it could be easily implemented as\n\n``` Go\nswitch argK {\n...\ncase \"omitempty\":\n    if argV == \"false\" {\n        break\n    }\n    someOmitEmptyVariable = true\n...\n}\n```\n. I've reverted the logic to the simplest case, as proposed by @GeertJohan:\n\n```\nTag = Name { ','  }\nOption = OptionKey [ ':' OptionValue ]\n```\n\nThere are many PRs out there that could benefit from a tag parsing like this one (thinking of `omitempty` or `type` for forcing DB-specific or optimized types).\n. u right.\n. Hey there.\nThis PR doesn't seem to break anything. Any advice from projects collaborators?\n. I use SQL Server at work.\nI wrote the dialect when the project was @coopernurse's (see the README... hey, I'm particularly proud of that! :).\nThe edits suggested by @FilipDeVos are a certain improvement over what I had written at first.\nI am actually using this PR in production. I hope to see the automated testing (#249) working soon, but until then I see no worries on merging this this PR as it is nothing but an improvement on the SQL Server syntax.\n. @nelsam @GeertJohan Guys, are you really taking into account PRs from non-collaborators?\n. @GeertJohan Would be glad to!\n. This problem was already present in the first version of the dialect: mssql won't accept PK fields longer than something like 255.\nGORP could check for PKs and automatically set the greater accepted length when `max` is specified. But wouldn't this be a little intrusive?\n. @GeertJohan Travis doesn't test SQL Server: I haven't touched `test_all.sh`, which is defined as the test script in `.travis.yml`.\nSQL Server hangs on Appveyor (see [here](https://ci.appveyor.com/project/qrawl/gorp/build/appveyor%20-%20101))...\n. It isn't working. This PR was in fact meant as a call for help :)\nI will get back on it as soon as I figure out a solution.\n. I suggest moving this to phase 3. Getting testing to work on Appveyor will imply some work on the test code, which we are planning to undergo some heavy maintenance soon.\n. Tell me if I am wrong, but isn't this an SQL question rather than a GORP question?\n. I've tested your code, it created me a table with this line:\n\n```\nCREATE TABLE \"posts\" (\"post_id\" integer not null primary key autoincrement, \"Created\" integer, \"Title\" varchar(50), \"article_body\" varchar(1024));\n```\n\nIt seems correct to me. You could be using an old version of Gorp, dating back to before the implementation of the `size` tag.\n\nHave you tried `go get -u gopkg.in/gorp.v1`? If so, please check the import in the go file as well, as it shouldn't be `import \"github.com/coopernurse/gorp\"`.\n\nDo you still experience the problem?\n. What platform do you experience the problem on? Can you please post the entire minimum compiling code to reproduce the issue? \n\n[This code](https://gist.github.com/qrawl/a081fdd931c8c6ccd14d) works for me, resulting in (sqlitebrowser screenshot):\n\n![sqlitebrowser screenshot](http://qrawl.net/gorpsizebug.png)\n. Match function at gorp.go:1852 doesn't take into account multiple tags. I'm on it\n. :+1: great job\n. Thank you for contributing.\nWhat about adding some actual error checking?\n`if err != nil {`...\n. @GeertJohan Looks good to me.\nThank you!\n. How do you import GORP in your code? Are you using `import \"gopkg.in/gorp.v1\"`?\nIt is possible that the `size` capability is only on the master branch. Try using `import \"github.com/go-gorp/gorp\"`, assuming you're aware that's an unsupported bleeding edge branch.\n. The `size` feature is only available on the development branch. If you feel adventurous, try\n\n```\nimport \"github.com/go-gorp/gorp\"\n```\n. You are right. This was meant to be a transitory condition. This should be addressed soon.\n. Thank you, I'm merging this: the README is already saying GORP supports Go 1.3+.\n. ",
    "ready4god2513": "Did you ever find an answer to this?  This is crucial to most apps.\n. @mrcwinn What I have found is you have to maintain two separate structs (models)- One has db annotations (without associations) and with your actual relationships.  Then it will take 2 queries and some manual merging of data.  Anyone able to give more insight on this?\n. Ah, that makes sense.  Thanks for that!  The other way that it could be done would be to use the `PostGet` hook.\n. Did you ever find an answer to this?  This is crucial to most apps.\n. @mrcwinn What I have found is you have to maintain two separate structs (models)- One has db annotations (without associations) and with your actual relationships.  Then it will take 2 queries and some manual merging of data.  Anyone able to give more insight on this?\n. Ah, that makes sense.  Thanks for that!  The other way that it could be done would be to use the `PostGet` hook.\n. ",
    "cjslep": "There are two problems, really:\n\nIn this example, a structure and field share the same name. Notice how the json is still generated correctly: http://play.golang.org/p/dIg2Cgm24C\n\nFrom my last tests in gorp (Aug 2014), this property did not hold. This fix seems straightforward, but it has been a while since I have looked at the particular part of code that was breaking.\n\nThe second problem is when two embedded structs have conflicting names. Notice how json will not return an error and will not serialize the conflicting names: http://play.golang.org/p/uvBhGEk2RJ\n\nThis problem could use some more thinking on; my gut instinct is to match the `encoding/json` package's behavior as it would follow the principle of least surprise.\n. There are two problems, really:\n\nIn this example, a structure and field share the same name. Notice how the json is still generated correctly: http://play.golang.org/p/dIg2Cgm24C\n\nFrom my last tests in gorp (Aug 2014), this property did not hold. This fix seems straightforward, but it has been a while since I have looked at the particular part of code that was breaking.\n\nThe second problem is when two embedded structs have conflicting names. Notice how json will not return an error and will not serialize the conflicting names: http://play.golang.org/p/uvBhGEk2RJ\n\nThis problem could use some more thinking on; my gut instinct is to match the `encoding/json` package's behavior as it would follow the principle of least surprise.\n. ",
    "tamasd": "I think this should be called merge, not upsert.\n. From what I have seen in other systems, they do a SELECT query, and then an INSERT or an UPDATE depending on the result.\n. I think this should be called merge, not upsert.\n. From what I have seen in other systems, they do a SELECT query, and then an INSERT or an UPDATE depending on the result.\n. ",
    "nd2s": "Can't get the `gorp_test.go` running on FreeBSD (some dependencies not compiling) - so can't give you a unit test unfortunately.\n\nThis simple program shows it, though:\n\n```\npackage main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"github.com/coopernurse/gorp\"\n    _ \"github.com/lib/pq\"\n    \"os\"\n)\n\ntype Foo struct {\n    Id     int64  `db:\"id\"`\n    Bar    int64  `db:\"-\"`\n    BarStr string `db:\"bar\"`\n}\n\nfunc main() {\n    dbRaw, err := sql.Open(\"postgres\", \"dbname=db user=user sslmode=disable\")\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    db := &gorp.DbMap{Db: dbRaw, Dialect: gorp.PostgresDialect{}}\n\n    db.AddTableWithName(Foo{}, \"foos\").SetKeys(true, \"id\")\n    err = db.CreateTablesIfNotExists()\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    // Insert Foo.\n    foo1 := &Foo{BarStr: \"some bar\"}\n    err = db.Insert(foo1)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    // Get foo.\n    foos := []*Foo{}\n    _, err = db.Select(&foos, \"SELECT * FROM foos LIMIT 1\")\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    fmt.Println(\"Result:\")\n    for _, foo := range foos {\n        fmt.Printf(\"\\t%#v\\n\", foo)\n    }\n}\n```\n\nOutput:\n\n```\n./testcase: gorp: No field bar in type Foo\n```\n\nProblem happens on `Select()` when a field is disabled with \"-\".\n. Seems to work - thank you very much!\n. Stupid question: I just got these deprecation warnings and added SetVersionCol() like so:\n\n```\ndb.AddTableWithName(User{}, \"users\").\n        SetKeys(true, \"id\").\n        SetVersionCol(\"version\")\n```\n\nThat doesn't get rid of them. How can I stop that? It's a bit annoying...\n. Thanks for the answer. I'm on v1.\n\nIn readStructColumns() I don't see an obvious way of checking if user set version col manually so I'll just change to master.\n. I don't really know the code: Maybe it would be possible to check on version column check if SetVersionCol() was used? So that the message is not printed on initialisation but on usage, and only when the problem actually exists.\n\nOnly logging with the explicit logger would defeat the purpose, I rarely ever use that. But always logging is bad, libraries shouldn't produce any output when used as intended.\n\nUpdate: Another possibility would be a \"DeprecationWarnings bool\" variable a user can set, but that is very ugly and once set the user wouldn't get any more notices. So not really an option.\n. Can't get the `gorp_test.go` running on FreeBSD (some dependencies not compiling) - so can't give you a unit test unfortunately.\n\nThis simple program shows it, though:\n\n```\npackage main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"github.com/coopernurse/gorp\"\n    _ \"github.com/lib/pq\"\n    \"os\"\n)\n\ntype Foo struct {\n    Id     int64  `db:\"id\"`\n    Bar    int64  `db:\"-\"`\n    BarStr string `db:\"bar\"`\n}\n\nfunc main() {\n    dbRaw, err := sql.Open(\"postgres\", \"dbname=db user=user sslmode=disable\")\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    db := &gorp.DbMap{Db: dbRaw, Dialect: gorp.PostgresDialect{}}\n\n    db.AddTableWithName(Foo{}, \"foos\").SetKeys(true, \"id\")\n    err = db.CreateTablesIfNotExists()\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    // Insert Foo.\n    foo1 := &Foo{BarStr: \"some bar\"}\n    err = db.Insert(foo1)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    // Get foo.\n    foos := []*Foo{}\n    _, err = db.Select(&foos, \"SELECT * FROM foos LIMIT 1\")\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %s\\n\", os.Args[0], err)\n        os.Exit(1)\n    }\n\n    fmt.Println(\"Result:\")\n    for _, foo := range foos {\n        fmt.Printf(\"\\t%#v\\n\", foo)\n    }\n}\n```\n\nOutput:\n\n```\n./testcase: gorp: No field bar in type Foo\n```\n\nProblem happens on `Select()` when a field is disabled with \"-\".\n. Seems to work - thank you very much!\n. Stupid question: I just got these deprecation warnings and added SetVersionCol() like so:\n\n```\ndb.AddTableWithName(User{}, \"users\").\n        SetKeys(true, \"id\").\n        SetVersionCol(\"version\")\n```\n\nThat doesn't get rid of them. How can I stop that? It's a bit annoying...\n. Thanks for the answer. I'm on v1.\n\nIn readStructColumns() I don't see an obvious way of checking if user set version col manually so I'll just change to master.\n. I don't really know the code: Maybe it would be possible to check on version column check if SetVersionCol() was used? So that the message is not printed on initialisation but on usage, and only when the problem actually exists.\n\nOnly logging with the explicit logger would defeat the purpose, I rarely ever use that. But always logging is bad, libraries shouldn't produce any output when used as intended.\n\nUpdate: Another possibility would be a \"DeprecationWarnings bool\" variable a user can set, but that is very ugly and once set the user wouldn't get any more notices. So not really an option.\n. ",
    "staunch": "It looks like this commit broke tags, not a Go 1.3 issue.\n\nhttps://github.com/coopernurse/gorp/commit/b5ce3b9a12a14e306c83e460200e003f66cf95f0\n\nIt looks like fieldName is no longer getting set to the tag value which is now in mappedFieldName?\n. Appreciate your work a lot. Thank you.\n. It looks like this commit broke tags, not a Go 1.3 issue.\n\nhttps://github.com/coopernurse/gorp/commit/b5ce3b9a12a14e306c83e460200e003f66cf95f0\n\nIt looks like fieldName is no longer getting set to the tag value which is now in mappedFieldName?\n. Appreciate your work a lot. Thank you.\n. ",
    "eastany": "+1\nI have to set column length...\n. +1\nI have to set column length...\n. ",
    "DavsX": "What about defining the column type (text in this case) via struct tag?\n. @qrawl True, but I was thinking more of an explicit type:text tag\n. Why nesting the tag? `db:\"type:date\"`? Go supports splitting them by space.\nYou could have:\n\n``` go\ntype MyStruct struct {\n   name string `db:\"db_name\" primary_key:\"true\" type:\"date\"`\n}\n```\n\nThen you could do:\n\n``` go\nf.Tag.Get(\"db\")\nf.Tag.Get(\"primary_key\")\nf.Tag.Get(\"type\")\n```\n\nI am new to golang, so please be patient :)\n. What about defining the column type (text in this case) via struct tag?\n. @qrawl True, but I was thinking more of an explicit type:text tag\n. Why nesting the tag? `db:\"type:date\"`? Go supports splitting them by space.\nYou could have:\n\n``` go\ntype MyStruct struct {\n   name string `db:\"db_name\" primary_key:\"true\" type:\"date\"`\n}\n```\n\nThen you could do:\n\n``` go\nf.Tag.Get(\"db\")\nf.Tag.Get(\"primary_key\")\nf.Tag.Get(\"type\")\n```\n\nI am new to golang, so please be patient :)\n. ",
    "CureGecko": "I would also like a field length specifier so I don't have to include a create table SQL for people. But then again, it's likely that I will have to so when I have updates I can include upgrade sql files.\n. I would also like a field length specifier so I don't have to include a create table SQL for people. But then again, it's likely that I will have to so when I have updates I can include upgrade sql files.\n. ",
    "chmac": "Were you able to make any progress with this? We're considering gorp and would like to use the JSON type in PostgreSQL.\n. Is modl actively developed and maintained? Looks like it's been quiet since late October last year. Otherwise, it certainly sounds like a sensible direction for gorp to me.\n. Were you able to make any progress with this? We're considering gorp and would like to use the JSON type in PostgreSQL.\n. Is modl actively developed and maintained? Looks like it's been quiet since late October last year. Otherwise, it certainly sounds like a sensible direction for gorp to me.\n. ",
    "honza": "Building with the `-v` flag reveals that most of the time is spent compiling `mattn/go-sqlite3`.\n. Building with the `-v` flag reveals that most of the time is spent compiling `mattn/go-sqlite3`.\n. ",
    "rajthilakmca": "  Ya, i already add these lines in my code \n    db, err := sql.Open(\"sqlite3\", \"./cloud.db\")\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}  \n    dbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")\n\nThe real problem is, i can open the database and  insert a data into it ONLY ONCE.\nwhen i wish to insert another data, it shows error.\n\n```\n Error :\n       No table found for type: Users\n\n code : \n      //first time open, create and insert table  \n     db, err := sql.Open(\"sqlite3\", \"./cloud.db\")\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}    \n    dbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")\n    dbmap.Insert(&user{})\n    defer dbmap.Db.Close()\n\n    // second time open and insert a data into existing table\n    db, err := sql.Open(\"sqlite3\", \"./cloud.db\")\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}    \n    dbmap.Insert(&user{})\n    defer dbmap.Db.Close()\n```\n. Seems to work - thank you very much!\n.   Ya, i already add these lines in my code \n    db, err := sql.Open(\"sqlite3\", \"./cloud.db\")\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}  \n    dbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")\n\nThe real problem is, i can open the database and  insert a data into it ONLY ONCE.\nwhen i wish to insert another data, it shows error.\n\n```\n Error :\n       No table found for type: Users\n\n code : \n      //first time open, create and insert table  \n     db, err := sql.Open(\"sqlite3\", \"./cloud.db\")\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}    \n    dbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")\n    dbmap.Insert(&user{})\n    defer dbmap.Db.Close()\n\n    // second time open and insert a data into existing table\n    db, err := sql.Open(\"sqlite3\", \"./cloud.db\")\n    dbmap := &gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}    \n    dbmap.Insert(&user{})\n    defer dbmap.Db.Close()\n```\n. Seems to work - thank you very much!\n. ",
    "indykish": "Cool. Nice to hear @rajthilakmca , So when a new connection is requested, the dbmap shall have the  `dbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")`\n. Cool. Nice to hear @rajthilakmca , So when a new connection is requested, the dbmap shall have the  `dbmap.AddTableWithName(Users{}, \"users\").SetKeys(true, \"UserId\")`\n. ",
    "andrei-m": "Thanks! We've been using the patch for a few weeks with no issues.\n. Always quoting makes sense, but lowering case seems like a setting that should be made configurable. Although lowercase identifiers are prevalent in the community, the Postgres documentation is not prescriptive about this. Mixed case identifiers can exist.\n\nI understand the convenience behind https://github.com/coopernurse/gorp/issues/21, but it breaks mixed-case identifiers. There's at least one example in the standard library that has taken the opposite approach: [encoding/json](http://golang.org/pkg/encoding/json/). Convential JSON property names are either camel case or lowercase with underscores. To get either of those from a struct with exported fields, an explicit `json:\"fieldName\"` or `json:\"field_name\"` tag must be added.\n\nAny other comments from Postgres users?\n. #190 made it into v1.7. Thanks!\n. I'm suspicious of the `values (?,?,?,?,?)`. With Postgres, the correct prepared statement syntax would be `values ($1, $2, $3, $4, $5)`. Are you sure you aren't inadvertently selecting the MySQL dialect in gorp?\n. Thanks! We've been using the patch for a few weeks with no issues.\n. Always quoting makes sense, but lowering case seems like a setting that should be made configurable. Although lowercase identifiers are prevalent in the community, the Postgres documentation is not prescriptive about this. Mixed case identifiers can exist.\n\nI understand the convenience behind https://github.com/coopernurse/gorp/issues/21, but it breaks mixed-case identifiers. There's at least one example in the standard library that has taken the opposite approach: [encoding/json](http://golang.org/pkg/encoding/json/). Convential JSON property names are either camel case or lowercase with underscores. To get either of those from a struct with exported fields, an explicit `json:\"fieldName\"` or `json:\"field_name\"` tag must be added.\n\nAny other comments from Postgres users?\n. #190 made it into v1.7. Thanks!\n. I'm suspicious of the `values (?,?,?,?,?)`. With Postgres, the correct prepared statement syntax would be `values ($1, $2, $3, $4, $5)`. Are you sure you aren't inadvertently selecting the MySQL dialect in gorp?\n. ",
    "billmccord": "I made the commit to add names params to Exec. After looking at the code it looks as though it already will work with SelectInt.\n. @coopernurse Have you had a chance to review this?\n. Hello new maintainers of Gorp! This should be an easy one, I wrote a test for it and everything! :smirk:  Thanks for taking over and looking forward to seeing the project move forward!\n. I couldn't figure out how to reassociate, so I created a new PR:\nhttps://github.com/go-gorp/gorp/pull/220\n. Agreed and changed.\n. I made the commit to add names params to Exec. After looking at the code it looks as though it already will work with SelectInt.\n. @coopernurse Have you had a chance to review this?\n. Hello new maintainers of Gorp! This should be an easy one, I wrote a test for it and everything! :smirk:  Thanks for taking over and looking forward to seeing the project move forward!\n. I couldn't figure out how to reassociate, so I created a new PR:\nhttps://github.com/go-gorp/gorp/pull/220\n. Agreed and changed.\n. ",
    "chadbay": ":+1:  for merging this one.\n. :+1:  for merging this one.\n. ",
    "kimxilxyong": "I tested quote inserting today (2015.05.30) with the latest master and everything works for me as expected.\nThe test has been done on postgres as the original post seems to refer to.\nFrom my point of view this issue can be closed.\n\nLog output:\n\n```\nD:/goworkspace/src/github.com/kimxilxyong/intogooglego/testgorp/testgorp.exe  [D:/goworkspace/src/github.com/kimxilxyong/intogooglego/testgorp]\ntestgorp:06:18:46.494531 [gorp] create table if not exists \"aliastransientfield\" (\"id\" bigserial not null primary key , \"bar\" text) ; [] (10.0006ms)\ntestgorp:06:18:46.499531 [gorp] insert into \"aliastransientfield\" (\"id\",\"bar\") values (default,$1) returning id; [1:\"Foo: some BarStr with 'quotes' in it\"] (2.0001ms)\ntestgorp:06:18:46.500531 [gorp] insert into aliastransientfield (\"id\", \"bar\") values(default, $1) [1:\"test insert \\\"double quote\\\", 'single quote', `backtick`\"] (1.0001ms)\ntestgorp:06:18:46.502531 [gorp] insert into aliastransientfield (\"id\", \"bar\") values(default, :barstring) [1:map[barstring:test named insert \"double quote\", 'single quote', `backtick`]] (2.0001ms)\n--------------- STARTING SELECT -----------------\ntestgorp:06:18:46.502531 [gorp] select * from AliasTransientField [] (0)\nID: 1, BarStr: Foo: some BarStr with 'quotes' in it\nID: 2, BarStr: test insert \"double quote\", 'single quote', `backtick`\nID: 3, BarStr: test named insert \"double quote\", 'single quote', `backtick`\nErfolg: Prozess beendet mit R\u00fcckgabewert 0.\n```\n\nTest code was:\n\n```\n    insertsql := `insert into aliastransientfield (\"id\", \"bar\") values(default, $1)`\n    _, err = dbmap.Exec(insertsql, \"test insert \\\"double quote\\\", 'single quote', `backtick`\")\n\n    insertsql = `insert into aliastransientfield (\"id\", \"bar\") values(default, :barstring)`\n    _, err = dbmap.Exec(insertsql, map[string]interface{}{\n        \"barstring\": \"test named insert \\\"double quote\\\", 'single quote', `backtick`\"})\n```\n. I tested quote inserting today (2015.05.30) with the latest master and everything works for me as expected.\nThe test has been done on postgres as the original post seems to refer to.\nFrom my point of view this issue can be closed.\n\nLog output:\n\n```\nD:/goworkspace/src/github.com/kimxilxyong/intogooglego/testgorp/testgorp.exe  [D:/goworkspace/src/github.com/kimxilxyong/intogooglego/testgorp]\ntestgorp:06:18:46.494531 [gorp] create table if not exists \"aliastransientfield\" (\"id\" bigserial not null primary key , \"bar\" text) ; [] (10.0006ms)\ntestgorp:06:18:46.499531 [gorp] insert into \"aliastransientfield\" (\"id\",\"bar\") values (default,$1) returning id; [1:\"Foo: some BarStr with 'quotes' in it\"] (2.0001ms)\ntestgorp:06:18:46.500531 [gorp] insert into aliastransientfield (\"id\", \"bar\") values(default, $1) [1:\"test insert \\\"double quote\\\", 'single quote', `backtick`\"] (1.0001ms)\ntestgorp:06:18:46.502531 [gorp] insert into aliastransientfield (\"id\", \"bar\") values(default, :barstring) [1:map[barstring:test named insert \"double quote\", 'single quote', `backtick`]] (2.0001ms)\n--------------- STARTING SELECT -----------------\ntestgorp:06:18:46.502531 [gorp] select * from AliasTransientField [] (0)\nID: 1, BarStr: Foo: some BarStr with 'quotes' in it\nID: 2, BarStr: test insert \"double quote\", 'single quote', `backtick`\nID: 3, BarStr: test named insert \"double quote\", 'single quote', `backtick`\nErfolg: Prozess beendet mit R\u00fcckgabewert 0.\n```\n\nTest code was:\n\n```\n    insertsql := `insert into aliastransientfield (\"id\", \"bar\") values(default, $1)`\n    _, err = dbmap.Exec(insertsql, \"test insert \\\"double quote\\\", 'single quote', `backtick`\")\n\n    insertsql = `insert into aliastransientfield (\"id\", \"bar\") values(default, :barstring)`\n    _, err = dbmap.Exec(insertsql, map[string]interface{}{\n        \"barstring\": \"test named insert \\\"double quote\\\", 'single quote', `backtick`\"})\n```\n. ",
    "peterbe": "Arg! I totally was. I had the SqliteDialect. Clumsy me. \nI had a select working earlier which was just luck I guess and that's why I didn't notice. \n. Arg! I totally was. I had the SqliteDialect. Clumsy me. \nI had a select working earlier which was just luck I guess and that's why I didn't notice. \n. ",
    "benprew": "@umisama Can you fix failing tests for this pull request?  \n\nhttps://travis-ci.org/go-gorp/gorp/jobs/38387723\n\n--- FAIL: TestNullTime (0.01 seconds)\n    gorp_test.go:1413: NullTime returns invalid but expected valid.\n    gorp_test.go:1416: expect %v but got %v. 0000-01-02 15:04:05 +0000 UTC 0001-01-01 00:00:00 +0000 UTC\n. If @jmoiron doesn't want to take over maintenance of this project, I'd be happy to\n. I use gorp at work too and would be happy to help maintain it.\n\nThanks\n\nOn Tue, Jan 27, 2015, 12:34 AM Geert-Johan Riemer notifications@github.com\nwrote:\n\n> @begizi https://github.com/begizi @benprew https://github.com/benprew\n> Are you still interested in helping with maintaining this project?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-gorp/gorp/issues/211#issuecomment-71609013.\n. #gorp sounds good, I'll update the PR and unregister the channel\n. I like that we're explicit about what we're supporting, copy looks good.\n. @umisama Can you fix failing tests for this pull request?  \n\nhttps://travis-ci.org/go-gorp/gorp/jobs/38387723\n\n--- FAIL: TestNullTime (0.01 seconds)\n    gorp_test.go:1413: NullTime returns invalid but expected valid.\n    gorp_test.go:1416: expect %v but got %v. 0000-01-02 15:04:05 +0000 UTC 0001-01-01 00:00:00 +0000 UTC\n. If @jmoiron doesn't want to take over maintenance of this project, I'd be happy to\n. I use gorp at work too and would be happy to help maintain it.\n\nThanks\n\nOn Tue, Jan 27, 2015, 12:34 AM Geert-Johan Riemer notifications@github.com\nwrote:\n\n> @begizi https://github.com/begizi @benprew https://github.com/benprew\n> Are you still interested in helping with maintaining this project?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-gorp/gorp/issues/211#issuecomment-71609013.\n. #gorp sounds good, I'll update the PR and unregister the channel\n. I like that we're explicit about what we're supporting, copy looks good.\n. ",
    "umisama": "Sorry, I have missed.  I'll fix this soon.\n. I fixed tests and rebase to master.(Travis show failed because I don't change .travis.yml.  Passing on tip)\nAnd, I \"rebase -i\" to some commit to fix tests.\n\nSorry, I kept you waiting too long.\n. Finally, test passed!  (without go1.1)\n. Sorry, you've merged to develop but it is must merged to master isn't it?\n. Sorry, I had been misunderstanding about PR system.  I create new PR. (see #237)\n. Sorry, I have missed.  I'll fix this soon.\n. I fixed tests and rebase to master.(Travis show failed because I don't change .travis.yml.  Passing on tip)\nAnd, I \"rebase -i\" to some commit to fix tests.\n\nSorry, I kept you waiting too long.\n. Finally, test passed!  (without go1.1)\n. Sorry, you've merged to develop but it is must merged to master isn't it?\n. Sorry, I had been misunderstanding about PR system.  I create new PR. (see #237)\n. ",
    "coveralls": "[![Coverage Status](https://coveralls.io/builds/8179026/badge)](https://coveralls.io/builds/8179026)\n\nChanges Unknown when pulling **d376e082fac9ea52cf1e2079e762225cc8427dd7 on umisama:develop-patch1** into *\\* on go-gorp:develop**.\n. [![Coverage Status](https://coveralls.io/builds/5514058/badge)](https://coveralls.io/builds/5514058)\n\nCoverage increased (+3.3%) to 64.213% when pulling **32f23ffcf911542bfb89f1545c3ea2d997ea4401 on RndmTsk:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6223586/badge)](https://coveralls.io/builds/6223586)\n\nCoverage decreased (-60.9%) to 0.0% when pulling **35e31ad6cf4b2fb0234750be2405b5442ec6894b on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6224064/badge)](https://coveralls.io/builds/6224064)\n\nCoverage decreased (-60.9%) to 0.0% when pulling **eddd970430fc5423d1902f00fa5c86850b91ee08 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6224264/badge)](https://coveralls.io/builds/6224264)\n\nCoverage increased (+5.5%) to 66.407% when pulling **c44bca114fa9ba39ede961014e3fb082f57af75f on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6256258/badge)](https://coveralls.io/builds/6256258)\n\nCoverage increased (+5.8%) to 66.731% when pulling **86fb555b65ac6e11ae7bfdff584b2fd4ada22a12 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6267508/badge)](https://coveralls.io/builds/6267508)\n\nCoverage increased (+5.8%) to 66.731% when pulling **bd2d2ba9227cddd48ebd052bb0a9b9365d596d11 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6850941/badge)](https://coveralls.io/builds/6850941)\n\nCoverage increased (+5.8%) to 66.731% when pulling **6c13097f2322a8c4ad78cd959208f76cd34b1231 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6917109/badge)](https://coveralls.io/builds/6917109)\n\nCoverage increased (+3.3%) to 64.242% when pulling **931e1509c7cf82483343dbfb0647bff06878e537 on eramus:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/7192486/badge)](https://coveralls.io/builds/7192486)\n\nCoverage remained the same at 66.635% when pulling **154ec5a891495dde526b6c0c88a507231a13534c on clyphub:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/7912161/badge)](https://coveralls.io/builds/7912161)\n\nCoverage increased (+0.05%) to 66.683% when pulling **63dd53fc8579501b5503a6b3ca6186e75135189c on rickb777:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/7912295/badge)](https://coveralls.io/builds/7912295)\n\nCoverage decreased (-0.2%) to 66.396% when pulling **6816f54c19e41a53735b2e7e15d71b5fb8247e49 on rickb777:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/8156430/badge)](https://coveralls.io/builds/8156430)\n\nCoverage increased (+0.5%) to 67.093% when pulling **9e3b10216811c7856d4586022dc3813cbf58b50f on hsinhoyeh:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/8164466/badge)](https://coveralls.io/builds/8164466)\n\nCoverage remained the same at 66.635% when pulling **252b0db2d2c8df9f3e1c65e2145bdbc919916fed on missinglink:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/8179026/badge)](https://coveralls.io/builds/8179026)\n\nChanges Unknown when pulling **d376e082fac9ea52cf1e2079e762225cc8427dd7 on umisama:develop-patch1** into *\\* on go-gorp:develop**.\n. [![Coverage Status](https://coveralls.io/builds/5514058/badge)](https://coveralls.io/builds/5514058)\n\nCoverage increased (+3.3%) to 64.213% when pulling **32f23ffcf911542bfb89f1545c3ea2d997ea4401 on RndmTsk:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6223586/badge)](https://coveralls.io/builds/6223586)\n\nCoverage decreased (-60.9%) to 0.0% when pulling **35e31ad6cf4b2fb0234750be2405b5442ec6894b on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6224064/badge)](https://coveralls.io/builds/6224064)\n\nCoverage decreased (-60.9%) to 0.0% when pulling **eddd970430fc5423d1902f00fa5c86850b91ee08 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6224264/badge)](https://coveralls.io/builds/6224264)\n\nCoverage increased (+5.5%) to 66.407% when pulling **c44bca114fa9ba39ede961014e3fb082f57af75f on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6256258/badge)](https://coveralls.io/builds/6256258)\n\nCoverage increased (+5.8%) to 66.731% when pulling **86fb555b65ac6e11ae7bfdff584b2fd4ada22a12 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6267508/badge)](https://coveralls.io/builds/6267508)\n\nCoverage increased (+5.8%) to 66.731% when pulling **bd2d2ba9227cddd48ebd052bb0a9b9365d596d11 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6850941/badge)](https://coveralls.io/builds/6850941)\n\nCoverage increased (+5.8%) to 66.731% when pulling **6c13097f2322a8c4ad78cd959208f76cd34b1231 on bkali:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/6917109/badge)](https://coveralls.io/builds/6917109)\n\nCoverage increased (+3.3%) to 64.242% when pulling **931e1509c7cf82483343dbfb0647bff06878e537 on eramus:master** into **6a3c8a87d0457cf700e57046c41e19b7cf3c44fa on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/7192486/badge)](https://coveralls.io/builds/7192486)\n\nCoverage remained the same at 66.635% when pulling **154ec5a891495dde526b6c0c88a507231a13534c on clyphub:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/7912161/badge)](https://coveralls.io/builds/7912161)\n\nCoverage increased (+0.05%) to 66.683% when pulling **63dd53fc8579501b5503a6b3ca6186e75135189c on rickb777:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/7912295/badge)](https://coveralls.io/builds/7912295)\n\nCoverage decreased (-0.2%) to 66.396% when pulling **6816f54c19e41a53735b2e7e15d71b5fb8247e49 on rickb777:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/8156430/badge)](https://coveralls.io/builds/8156430)\n\nCoverage increased (+0.5%) to 67.093% when pulling **9e3b10216811c7856d4586022dc3813cbf58b50f on hsinhoyeh:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. [![Coverage Status](https://coveralls.io/builds/8164466/badge)](https://coveralls.io/builds/8164466)\n\nCoverage remained the same at 66.635% when pulling **252b0db2d2c8df9f3e1c65e2145bdbc919916fed on missinglink:master** into **88f3ff2c0d5eb7b20af1b6b4d2051d7ddfffadb0 on go-gorp:master**.\n. ",
    "wzzhu": "This is not completed. Should add the patch below:\n\n--- a/table.go\n+++ b/table.go\n@@ -211,6 +211,9 @@ func (t *TableMap) SqlForCreate(ifNotExists bool) string {\n                        if col.Unique {\n                                s.WriteString(\" unique\")\n                        }\n-                       if col.DefaultValue != \"\" {\n-                               s.WriteString(fmt.Sprintf(\" default %s\", col.DefaultValue))\n-                       }\n                      if col.isAutoIncr {\n                              s.WriteString(fmt.Sprintf(\" %s\", dialect.AutoIncrStr()))\n                      }\n. For mysql, it is more native to use the DB's default as the definition. Insertion with default value doesn't seem to match normal expectation. Using DB's default is also consistent with other definitions like size/type fields. If it is for Insertion all, another function like SetDefaultInsertionValueForField would be more appropriate. Thanks.\n. This is not completed. Should add the patch below:\n\n--- a/table.go\n+++ b/table.go\n@@ -211,6 +211,9 @@ func (t *TableMap) SqlForCreate(ifNotExists bool) string {\n                        if col.Unique {\n                                s.WriteString(\" unique\")\n                        }\n-                       if col.DefaultValue != \"\" {\n-                               s.WriteString(fmt.Sprintf(\" default %s\", col.DefaultValue))\n-                       }\n                      if col.isAutoIncr {\n                              s.WriteString(fmt.Sprintf(\" %s\", dialect.AutoIncrStr()))\n                      }\n. For mysql, it is more native to use the DB's default as the definition. Insertion with default value doesn't seem to match normal expectation. Using DB's default is also consistent with other definitions like size/type fields. If it is for Insertion all, another function like SetDefaultInsertionValueForField would be more appropriate. Thanks.\n. ",
    "marconi": "@begizi unless I'm missing something it seems `selectonly` is only for custom sql queries where you can explicitly include a column to be readonly and mapped to a struct field. INSERT on the other hand is auto-generated and only returns the id form INSERT iirc, so it comes back to the same question of how can I include the extra columns that are readonly.\n\nThat extra SELECT just to update my struct after INSERT is what I'm trying to get away from. \n. @begizi unless I'm missing something it seems `selectonly` is only for custom sql queries where you can explicitly include a column to be readonly and mapped to a struct field. INSERT on the other hand is auto-generated and only returns the id form INSERT iirc, so it comes back to the same question of how can I include the extra columns that are readonly.\n\nThat extra SELECT just to update my struct after INSERT is what I'm trying to get away from. \n. ",
    "DeepAnchor": "[modl](https://github.com/jmoiron/modl) seems to be a nice fork of this project, from the same author as sqlx\n. [modl](https://github.com/jmoiron/modl) seems to be a nice fork of this project, from the same author as sqlx\n. ",
    "jmoiron": "I've been maintaining it when I have time.  There are a few open PRs that I'm going to take action on in the coming month.  I wouldn't mind adding official contributors to it (esp @sqs who has already contributed a lot), especially if the decision was made to mothball gorp.\n\nHowever, I have to warn upfront that although Modl is a fork of Gorp, it wasn't forked in order to continue maintenance on Gorp.  The main goals were a cleanup of Gorp's API and an internal rewrite to base some of its database code on sqlx instead.  Part of this was that Gorp's original CRUD API (before @robfig's changes) was somewhat un-go-like (no pointer passing, so lots of casting), and part was that I wanted to test an assumption I had which was that sqlx was suitable as a substrate for other ORM designers and could allow them to skip reinventing db<->struct serialization.\n\nSo, while modl maintains a lot of the feel and structure of gorp, it does dispense with a few things that gorp does and it behaves slightly differently out of the box.  For a project starting out there's almost no difference;  if you're running something large in production there are behavioral differences which the compiler will not notify you about, and some things (purposefully) missing from it that some Gorp users might potentially rely on. \n. I've been maintaining it when I have time.  There are a few open PRs that I'm going to take action on in the coming month.  I wouldn't mind adding official contributors to it (esp @sqs who has already contributed a lot), especially if the decision was made to mothball gorp.\n\nHowever, I have to warn upfront that although Modl is a fork of Gorp, it wasn't forked in order to continue maintenance on Gorp.  The main goals were a cleanup of Gorp's API and an internal rewrite to base some of its database code on sqlx instead.  Part of this was that Gorp's original CRUD API (before @robfig's changes) was somewhat un-go-like (no pointer passing, so lots of casting), and part was that I wanted to test an assumption I had which was that sqlx was suitable as a substrate for other ORM designers and could allow them to skip reinventing db<->struct serialization.\n\nSo, while modl maintains a lot of the feel and structure of gorp, it does dispense with a few things that gorp does and it behaves slightly differently out of the box.  For a project starting out there's almost no difference;  if you're running something large in production there are behavioral differences which the compiler will not notify you about, and some things (purposefully) missing from it that some Gorp users might potentially rely on. \n. ",
    "franklinwise": "Yeah, merging the two products doesn't seem like the right approach, since they are based on fundamentally different principles (and frameworks). Maybe move Gorp to an github organization, so coopernurse can control rights for commiters and admins? \n. Yeah, merging the two products doesn't seem like the right approach, since they are based on fundamentally different principles (and frameworks). Maybe move Gorp to an github organization, so coopernurse can control rights for commiters and admins? \n. ",
    "sqdk": "@GeertJohan I'm actively using gorp at work and would love to help maintain the project. I am not terribly experienced, but i'll be happy to help where ever i can.\n. Sounds like a good idea to warn people. It can be done in a way that only warns if the version column is found. I can make a PR for this and i think the warning should be merged into v1 as it won't break behaviour.\n\nThe fix should stay in the unstable branch and merged into v2 when time comes.\n. Made a PR to v1: https://github.com/go-gorp/gorp/pull/219\n. Should be all set now. All versions except 1.1 passes tests. It fails with an error in the mysql driver. Could be travis using a wrong version of the driver with 1.1. \n. Targetting wrong branch. PR will continue in https://github.com/go-gorp/gorp/pull/224\n. Are you on master (github) or on v1 (gopkg)? Master doesn't not output these warnings. V1 will however. There is currently not a way to disable these warnings. If you think this is a necessary feature, you can create an issue, or make a PR with the necessary changes.\n\nWarnings is outputted here: https://github.com/go-gorp/gorp/blob/v1/gorp.go#L780\n\nThe warnings gets printed because the automatic mapping happens in AddTableWithName() before you explicitly set it with SetVersionCol(). That was the default behaviour before. The only way to get around this would be to not use AddTableWithName (or any of the helper functions), and i am not sure how easy that is.\n. Using Dbmap.logger will only show the warning if the logger is explicitly enabled and it will generate a lot of text that might make it hard to see (like the query log).\n\nI can change output to std.err\n. That would probably compliment it very well.\n\nI still think a warning is justified in the current release version.\n. That's a nice way to do it. All good now?\n. Sounds good!\n. I think that the mysql driver is not compatible with Go 1.1, which is why Travis is failing.\n\nShould we deprecate support for 1.1?\n. Sure, sounds good. I'm not sure about the format, so could you create the poll?\n\nDo you think that this PR should just be merged and then we can update .travis.yml when we agree on what versions to support?\n. I have updated travis to only support the last 2 minor releases. When the poll is finished it should be ready to be merged.\n. I think that all should be good now. First time squashing and rebasing though. Please let me know if anything could be done in a better way.\n. That would be a very good idea! I can maybe take a look at it later today or tomorrow :smiley: \n. Sounds good to me!\n. This would conflict with changes made in PR #224, more specifically in readStructColumns(). I think reading tags should be kept in this function, and version should be added to tags through here as well. \n\nIf you could extend it to also read the version column from tags it should be pretty easy to merge.\n. What about the minor versions? \n. You should always pass a pointer. What kind of error are you getting?\n\nI think you are referring to an example where inv1 is already a pointer. Check the example just above it.\n\nNot using pointers and passing by value would result in all objects being copied and passed to the function, which is pretty bad for memory usage. When you are handling a significant amount of data, you should always pass a pointer.\n\nPassing pointers on inserts also allows gorp to set new auto increment id of the inserted object(s). \n. Closing issue\n. Like purohit says, if you mapped the auto increment ID with tableMap.SetKeys, the id field will be automatically set to the last insert id.\n\nThere is an example in the README.\n. No, inv1.id will contain the new ID:\n\n```\ninv1 := &Invoice{\"Welcome\", \"This is a welcome message\"}\n\nerr := dbmap.Insert(inv1)\n\nlast_insert_id := inv1.Id\n```\n\nJust as it says right here: https://github.com/go-gorp/gorp#insert in the README.\n. Thanks for contributing!\n. Looking good! Thanks!\n. @GeertJohan I'm actively using gorp at work and would love to help maintain the project. I am not terribly experienced, but i'll be happy to help where ever i can.\n. Sounds like a good idea to warn people. It can be done in a way that only warns if the version column is found. I can make a PR for this and i think the warning should be merged into v1 as it won't break behaviour.\n\nThe fix should stay in the unstable branch and merged into v2 when time comes.\n. Made a PR to v1: https://github.com/go-gorp/gorp/pull/219\n. Should be all set now. All versions except 1.1 passes tests. It fails with an error in the mysql driver. Could be travis using a wrong version of the driver with 1.1. \n. Targetting wrong branch. PR will continue in https://github.com/go-gorp/gorp/pull/224\n. Are you on master (github) or on v1 (gopkg)? Master doesn't not output these warnings. V1 will however. There is currently not a way to disable these warnings. If you think this is a necessary feature, you can create an issue, or make a PR with the necessary changes.\n\nWarnings is outputted here: https://github.com/go-gorp/gorp/blob/v1/gorp.go#L780\n\nThe warnings gets printed because the automatic mapping happens in AddTableWithName() before you explicitly set it with SetVersionCol(). That was the default behaviour before. The only way to get around this would be to not use AddTableWithName (or any of the helper functions), and i am not sure how easy that is.\n. Using Dbmap.logger will only show the warning if the logger is explicitly enabled and it will generate a lot of text that might make it hard to see (like the query log).\n\nI can change output to std.err\n. That would probably compliment it very well.\n\nI still think a warning is justified in the current release version.\n. That's a nice way to do it. All good now?\n. Sounds good!\n. I think that the mysql driver is not compatible with Go 1.1, which is why Travis is failing.\n\nShould we deprecate support for 1.1?\n. Sure, sounds good. I'm not sure about the format, so could you create the poll?\n\nDo you think that this PR should just be merged and then we can update .travis.yml when we agree on what versions to support?\n. I have updated travis to only support the last 2 minor releases. When the poll is finished it should be ready to be merged.\n. I think that all should be good now. First time squashing and rebasing though. Please let me know if anything could be done in a better way.\n. That would be a very good idea! I can maybe take a look at it later today or tomorrow :smiley: \n. Sounds good to me!\n. This would conflict with changes made in PR #224, more specifically in readStructColumns(). I think reading tags should be kept in this function, and version should be added to tags through here as well. \n\nIf you could extend it to also read the version column from tags it should be pretty easy to merge.\n. What about the minor versions? \n. You should always pass a pointer. What kind of error are you getting?\n\nI think you are referring to an example where inv1 is already a pointer. Check the example just above it.\n\nNot using pointers and passing by value would result in all objects being copied and passed to the function, which is pretty bad for memory usage. When you are handling a significant amount of data, you should always pass a pointer.\n\nPassing pointers on inserts also allows gorp to set new auto increment id of the inserted object(s). \n. Closing issue\n. Like purohit says, if you mapped the auto increment ID with tableMap.SetKeys, the id field will be automatically set to the last insert id.\n\nThere is an example in the README.\n. No, inv1.id will contain the new ID:\n\n```\ninv1 := &Invoice{\"Welcome\", \"This is a welcome message\"}\n\nerr := dbmap.Insert(inv1)\n\nlast_insert_id := inv1.Id\n```\n\nJust as it says right here: https://github.com/go-gorp/gorp#insert in the README.\n. Thanks for contributing!\n. Looking good! Thanks!\n. ",
    "mhkt": "i think you invited the wrong person.\n\nOn Sat, Jan 31, 2015 at 3:13 PM, Geert-Johan Riemer <\nnotifications@github.com> wrote:\n\n> Closed #211 https://github.com/go-gorp/gorp/issues/211.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-gorp/gorp/issues/211#event-228033428.\n\n## \n\nMatt Hartman | @matthartman http://twitter.com/matthartman\ndirector of seed investments\nbetaworks\n\n_...join openbeta http://www.betaworks.com/openbeta for early access to\nour newest products_\n. i think you invited the wrong person.\n\nOn Sat, Jan 31, 2015 at 3:13 PM, Geert-Johan Riemer <\nnotifications@github.com> wrote:\n\n> Closed #211 https://github.com/go-gorp/gorp/issues/211.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-gorp/gorp/issues/211#event-228033428.\n\n## \n\nMatt Hartman | @matthartman http://twitter.com/matthartman\ndirector of seed investments\nbetaworks\n\n_...join openbeta http://www.betaworks.com/openbeta for early access to\nour newest products_\n. ",
    "matthartman": "nevermind -- this is matt hartman (matt@betaworks.com now goes to me) but\nmatt hackett is working on changing the email i think.\n\nOn Mon, Feb 2, 2015 at 10:46 AM, Geert-Johan Riemer <\nnotifications@github.com> wrote:\n\n> @mhkt https://github.com/mhkt What do you mean? I just checked the\n> audit logs for go-gorp and could not find any unintended invites.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-gorp/gorp/issues/211#issuecomment-72479029.\n\n## \n\nMatt Hartman // @matthartman http://twitter.com/matthartman // blog at\nhrt.mn\n. nevermind -- this is matt hartman (matt@betaworks.com now goes to me) but\nmatt hackett is working on changing the email i think.\n\nOn Mon, Feb 2, 2015 at 10:46 AM, Geert-Johan Riemer <\nnotifications@github.com> wrote:\n\n> @mhkt https://github.com/mhkt What do you mean? I just checked the\n> audit logs for go-gorp and could not find any unintended invites.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/go-gorp/gorp/issues/211#issuecomment-72479029.\n\n## \n\nMatt Hartman // @matthartman http://twitter.com/matthartman // blog at\nhrt.mn\n. ",
    "d-g-laptev": "Sometimes easier to SELECT \\* (if we must select a lot of fields, except several)\nAnd if one of skipped fields will be DATETIME and parseTime is true, it will cause an error, because sql.RawBytes doesn't implemet Scanner interface\n. Sometimes easier to SELECT \\* (if we must select a lot of fields, except several)\nAnd if one of skipped fields will be DATETIME and parseTime is true, it will cause an error, because sql.RawBytes doesn't implemet Scanner interface\n. ",
    "stilldavid": "For the record, [lib/pq has the same](https://github.com/lib/pq/blob/master/encode.go#L488) that implements `Scan` and `Value` as well. This feature would be great to see in gorp!\n. For the record, [lib/pq has the same](https://github.com/lib/pq/blob/master/encode.go#L488) that implements `Scan` and `Value` as well. This feature would be great to see in gorp!\n. ",
    "terah": "Thanks a lot for the heads-up on that exploit!\n. Thanks a lot for the heads-up on that exploit!\n. ",
    "matejkramny": "Sorry, i completely forgot that Go copies all the values and just realised that i was passing `**obj` which throws `2015/02/28 11:29:48 No table found for type:`\n\n(it was pretty late, hmmm)\n. Sorry, i completely forgot that Go copies all the values and just realised that i was passing `**obj` which throws `2015/02/28 11:29:48 No table found for type:`\n\n(it was pretty late, hmmm)\n. ",
    "truongminh": "@fzerorubigd Thank for your reply.\nThe error caused by SelectOne could be (1) no row, (2) multiple rows or (3) database error.\nIt is problematic to find out the exact causes.\nI switch to the Select API, whose errors are clearer.\n. No, since SelectOne was designed to fail under these conditions.\n. thank @enahs \n. @fzerorubigd Thank for your reply.\nThe error caused by SelectOne could be (1) no row, (2) multiple rows or (3) database error.\nIt is problematic to find out the exact causes.\nI switch to the Select API, whose errors are clearer.\n. No, since SelectOne was designed to fail under these conditions.\n. thank @enahs \n. ",
    "enahs": "while not necessarily an issue, It would be a nice to have if you could start classifying these errors in the style of database/sql. For instance, gorp.multipleRowsErr ala sql.NoRowsErr and then you could check for: \n\n``` go\nif err == gorp.multipleRowsErr {\n // something unexpected probably caused you to get in this state - do whatever your app does to resolve that.\n}\n```\n. checkout [goose](https://bitbucket.org/liamstask/goose/) (bitbucket, i know.. smh) as I believe it does similar to what you're asking for. \n. while not necessarily an issue, It would be a nice to have if you could start classifying these errors in the style of database/sql. For instance, gorp.multipleRowsErr ala sql.NoRowsErr and then you could check for: \n\n``` go\nif err == gorp.multipleRowsErr {\n // something unexpected probably caused you to get in this state - do whatever your app does to resolve that.\n}\n```\n. checkout [goose](https://bitbucket.org/liamstask/goose/) (bitbucket, i know.. smh) as I believe it does similar to what you're asking for. \n. ",
    "mash": "thanks!\n. thanks!\n. ",
    "NathanArmstrong84": "I am sorry but  you didn't answer my question. I need it the last insert ID after I use Insert. Meaning, I want to know what was the value of the primary key after I inserted the latest row. The example below shows how to get the last insert id using db.Exec:\n\n```\npackage main\n\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"mysql\", \"user:pass@/dbname\")\n    if err != nil {\n        panic(\"Error opening DB:\", err.Error())\n    }\n    defer db.Close()\n\n    someParam := \"value\"\n\n    if res, err := db.Exec(`INSERT INTO foo VALUES(\"bar\", ?))`, someParam)\n    if err != nil {\n        println(\"Exec err:\", err.Error())\n    } else {\n        id, err := res.LastInsertId()\n        if err != nil {\n            println(\"LastInsertId:\", id)\n        } else {\n            println(\"Error:\", err.Error())\n        }\n    }\n} \n```\n\n**Is there a way to get the last insert id using gorp?**\n. @sqdk , @purohit \nYes. I mapped the auto increment ID with tableMap.SetKeys. So if I do this:\n\n```\ninv1 := &Invoice{\"Welcome\", \"This is a welcome message\"}\n\nerr := dbmap.Insert(inv1)\n\nlast_insert_id := dbmap.LastInsertId()  //Will this return the last insert id for the insert above?\n```\n\nCan I get the last insert id by doing dbmap.LastInsertId()? - _see code above_\n. Thank you @sqdk \nThat worked!\n. I am sorry but  you didn't answer my question. I need it the last insert ID after I use Insert. Meaning, I want to know what was the value of the primary key after I inserted the latest row. The example below shows how to get the last insert id using db.Exec:\n\n```\npackage main\n\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"mysql\", \"user:pass@/dbname\")\n    if err != nil {\n        panic(\"Error opening DB:\", err.Error())\n    }\n    defer db.Close()\n\n    someParam := \"value\"\n\n    if res, err := db.Exec(`INSERT INTO foo VALUES(\"bar\", ?))`, someParam)\n    if err != nil {\n        println(\"Exec err:\", err.Error())\n    } else {\n        id, err := res.LastInsertId()\n        if err != nil {\n            println(\"LastInsertId:\", id)\n        } else {\n            println(\"Error:\", err.Error())\n        }\n    }\n} \n```\n\n**Is there a way to get the last insert id using gorp?**\n. @sqdk , @purohit \nYes. I mapped the auto increment ID with tableMap.SetKeys. So if I do this:\n\n```\ninv1 := &Invoice{\"Welcome\", \"This is a welcome message\"}\n\nerr := dbmap.Insert(inv1)\n\nlast_insert_id := dbmap.LastInsertId()  //Will this return the last insert id for the insert above?\n```\n\nCan I get the last insert id by doing dbmap.LastInsertId()? - _see code above_\n. Thank you @sqdk \nThat worked!\n. ",
    "jsanc623": "Good call @nelsam. Updated with your note\n. not a problem @nelsam - do get some sleep :) thanks! :+1: \n. Thanks for the heads up on squash @GeertJohan - should be good now :+1: \n. Good call @nelsam. Updated with your note\n. not a problem @nelsam - do get some sleep :) thanks! :+1: \n. Thanks for the heads up on squash @GeertJohan - should be good now :+1: \n. ",
    "FilipDeVos": "I took a stab at it, but have not tested at all (I only have localdb on my pc atm which does not support tcp/ip connections)\n\nSee https://github.com/FilipDeVos/gorp/commit/0d3be59de0edc41351b99e251e91a799ebe1c1e6\n. You can remove the check for maxsize. SQL Server 2005 also supports NVARCHAR(max). \n\nif you want to limit, the maximum string lengh in a page on sql server is 4000 unicode characters.\n. Ok, I understand. That works for me. \n. This is correct for many reasons. For starters, a primary key constraint in SQL Server is implemented as an index and an index in SQL Server has a maximum of 900 bytes as the sum of the field lengths of the index. \n\nThe second reason is that an index in SQL Server is implemented as a B-Tree of data pages that can contain 8K of data each. An nvarchar(max) field can contain up to 1.2GB of data, which is realized as a separate linked list of data pages. So your \"field\" in the table is actually a pointer to another linked list.\n\nNow technically, it doesn't make much sense to index a long string blob. it makes a lot more sense to store a hash like sha1 generated from the string and index that. \n\nFor gorp I think it is acceptable to have to specify a max string length if you want to index the field. \n. Thanks for doing this. Works much better for me ;)\n. I took a stab at it, but have not tested at all (I only have localdb on my pc atm which does not support tcp/ip connections)\n\nSee https://github.com/FilipDeVos/gorp/commit/0d3be59de0edc41351b99e251e91a799ebe1c1e6\n. You can remove the check for maxsize. SQL Server 2005 also supports NVARCHAR(max). \n\nif you want to limit, the maximum string lengh in a page on sql server is 4000 unicode characters.\n. Ok, I understand. That works for me. \n. This is correct for many reasons. For starters, a primary key constraint in SQL Server is implemented as an index and an index in SQL Server has a maximum of 900 bytes as the sum of the field lengths of the index. \n\nThe second reason is that an index in SQL Server is implemented as a B-Tree of data pages that can contain 8K of data each. An nvarchar(max) field can contain up to 1.2GB of data, which is realized as a separate linked list of data pages. So your \"field\" in the table is actually a pointer to another linked list.\n\nNow technically, it doesn't make much sense to index a long string blob. it makes a lot more sense to store a hash like sha1 generated from the string and index that. \n\nFor gorp I think it is acceptable to have to specify a max string length if you want to index the field. \n. Thanks for doing this. Works much better for me ;)\n. ",
    "willnorris": "hmm, now I'm really wishing I had included more context when I first opened this pull request, because now I don't fully remember exactly what was happening :confused:  Since this seems to have been limited to older versions of go-sqlite3, I'm fine with closing this issue... it's certainly not blocking me any more.\n. hmm, now I'm really wishing I had included more context when I first opened this pull request, because now I don't fully remember exactly what was happening :confused:  Since this seems to have been limited to older versions of go-sqlite3, I'm fine with closing this issue... it's certainly not blocking me any more.\n. ",
    "jeromenerf": "TL;DR: \n- best pratice: `TypeConverter` or `Value() / Scan()` implementation in gorp?\n- how to deal with postgres specific `json` and `jsonb` features? using gorp?\n- what about documenting this trendy use case more thoroughly?\n\nThe documentation and tests presents different possible approaches to achieve this:\n1. \"TypeConverter\": https://github.com/go-gorp/gorp/blob/master/gorp_test.go#L285\n2. Valuer / Scan : https://github.com/go-gorp/gorp/blob/master/gorp_test.go#L127 although in this case, its just a matter of storing the `Person.Id` in the `Invoice` struct rather than the whole attributes.\n\nIn the first example, the `Person` struct is being converted in and out the database, using a `string` type transport (called `holder`) containing its JSON representation. \n\nHowever: \n- obviously, json encoding constraints apply, `map[int]xxx` is not supported for instance\n- the column type in the database is the dialect specific equivalent of \"string\" (`text` ...)\n- if using postgres, the column is not set to `json` of `jsonb`, making it less interesting than it could be (see http://www.postgresql.org/docs/9.4/static/datatype-json.html)\n- the type conversion might not work if the json-converted type is deeply nested in a join query\n\nPostgres JSON features are getting better and more popular with each release, from 9.3 to the latest 9.5.  In addition to being able to return a traditional dataset as a JSON representation using `row_as_json`, `json_obect_agg`, ... functions, it is also possible to store JSON as is, and yet be able to perform performant queries, such as `SELECT Id, PersonJSON->>'Fname' as Name FROM TypeConversionExample` if the `PersonJSON` column was set as `jsonb`.\n\n@jmoiron 's \"sqlx\" features a `JSONText` type to deal with this (https://github.com/jmoiron/sqlx/blob/master/types/types.go), with some upstream potential bugs however (see https://github.com/golang/go/issues/13905) and the same question as this one in its own issues: https://github.com/jmoiron/sqlx/issues/133\n\nAs a conclusion, a possible approach could be: \n1. write structs `People` and `TypeConversionExample` embedding `People`\n2. write typeconverters or value/scan functions, to convert People via a json.RawMessage derived struct\n3. create tables, either manually with SQL or via gorp then manually ALTER to specify the `person` column type as `json`(`b`)\n4. profit!\n. TL;DR: \n- best pratice: `TypeConverter` or `Value() / Scan()` implementation in gorp?\n- how to deal with postgres specific `json` and `jsonb` features? using gorp?\n- what about documenting this trendy use case more thoroughly?\n\nThe documentation and tests presents different possible approaches to achieve this:\n1. \"TypeConverter\": https://github.com/go-gorp/gorp/blob/master/gorp_test.go#L285\n2. Valuer / Scan : https://github.com/go-gorp/gorp/blob/master/gorp_test.go#L127 although in this case, its just a matter of storing the `Person.Id` in the `Invoice` struct rather than the whole attributes.\n\nIn the first example, the `Person` struct is being converted in and out the database, using a `string` type transport (called `holder`) containing its JSON representation. \n\nHowever: \n- obviously, json encoding constraints apply, `map[int]xxx` is not supported for instance\n- the column type in the database is the dialect specific equivalent of \"string\" (`text` ...)\n- if using postgres, the column is not set to `json` of `jsonb`, making it less interesting than it could be (see http://www.postgresql.org/docs/9.4/static/datatype-json.html)\n- the type conversion might not work if the json-converted type is deeply nested in a join query\n\nPostgres JSON features are getting better and more popular with each release, from 9.3 to the latest 9.5.  In addition to being able to return a traditional dataset as a JSON representation using `row_as_json`, `json_obect_agg`, ... functions, it is also possible to store JSON as is, and yet be able to perform performant queries, such as `SELECT Id, PersonJSON->>'Fname' as Name FROM TypeConversionExample` if the `PersonJSON` column was set as `jsonb`.\n\n@jmoiron 's \"sqlx\" features a `JSONText` type to deal with this (https://github.com/jmoiron/sqlx/blob/master/types/types.go), with some upstream potential bugs however (see https://github.com/golang/go/issues/13905) and the same question as this one in its own issues: https://github.com/jmoiron/sqlx/issues/133\n\nAs a conclusion, a possible approach could be: \n1. write structs `People` and `TypeConversionExample` embedding `People`\n2. write typeconverters or value/scan functions, to convert People via a json.RawMessage derived struct\n3. create tables, either manually with SQL or via gorp then manually ALTER to specify the `person` column type as `json`(`b`)\n4. profit!\n. ",
    "eBurns": "Was just working through the same issue - didn't find any more recent info than this thread unfortunately.  Really good ideas here but I just hated that I was required to go back and alter the table to set the column type to jsonb.\n\nMy solution was to use embedding to extend gorp.PostgresDialect as follows:\n\n```\n// PostgresJSONDialect adds the JSON data types to the PostgrestDialect\ntype PostgresJSONDialect struct {\n    gorp.PostgresDialect\n}\n\n// ToSqlType returns the SQL column type for the given Go type\nfunc (d PostgresJSONDialect) ToSqlType(val reflect.Type, maxsize int, isAutoIncr bool) string {\n    // Force JSONText to use sqlType: JSONB\n    if val == reflect.TypeOf(JSONText{}) {\n        return \"JSONB\"\n    }\n    return d.PostgresDialect.ToSqlType(val, maxsize, isAutoIncr)\n}\n```\n\nVery clean and I brought the JSONText struct over from @jmoiron 's \"sqlx\".  Haven't fully tested with that struct but once I get the other side of this project working, I'll decide if it meets the need or if I need to roll my own.  But - I love that this is a minor passthrough that lets \n\n```\nerr = Dbmap.CreateTablesIfNotExists()\n```\n\ndo what it needs to do without any post-creation cleanup.\n. Was just working through the same issue - didn't find any more recent info than this thread unfortunately.  Really good ideas here but I just hated that I was required to go back and alter the table to set the column type to jsonb.\n\nMy solution was to use embedding to extend gorp.PostgresDialect as follows:\n\n```\n// PostgresJSONDialect adds the JSON data types to the PostgrestDialect\ntype PostgresJSONDialect struct {\n    gorp.PostgresDialect\n}\n\n// ToSqlType returns the SQL column type for the given Go type\nfunc (d PostgresJSONDialect) ToSqlType(val reflect.Type, maxsize int, isAutoIncr bool) string {\n    // Force JSONText to use sqlType: JSONB\n    if val == reflect.TypeOf(JSONText{}) {\n        return \"JSONB\"\n    }\n    return d.PostgresDialect.ToSqlType(val, maxsize, isAutoIncr)\n}\n```\n\nVery clean and I brought the JSONText struct over from @jmoiron 's \"sqlx\".  Haven't fully tested with that struct but once I get the other side of this project working, I'll decide if it meets the need or if I need to roll my own.  But - I love that this is a minor passthrough that lets \n\n```\nerr = Dbmap.CreateTablesIfNotExists()\n```\n\ndo what it needs to do without any post-creation cleanup.\n. ",
    "YanhaoYang": "I just found this article, [Handling JSONB in Go Structs](http://coussej.github.io/2016/02/16/Handling-JSONB-in-Go-Structs/). Hope it is helpful if you are looking for a solution.. I just found this article, [Handling JSONB in Go Structs](http://coussej.github.io/2016/02/16/Handling-JSONB-in-Go-Structs/). Hope it is helpful if you are looking for a solution.. ",
    "TheInsideMan": "Well thats just it, when I run this query inside Sequel Pro it runs fine, ordering is as expected.... using gorp it runs, without errors but returns results unordered.\n. Well thats just it, when I run this query inside Sequel Pro it runs fine, ordering is as expected.... using gorp it runs, without errors but returns results unordered.\n. ",
    "goors": "I have in User helper multiple methods such as UserById, UserByEmail, Users, UpdateUser, DeleteUser\nand they all use struct Helper. Can you tell me if my approach is ok with multiple methods using same struct or?\n. You have mysql proxy for that. I do not see the point of having rw split in app.\n. I have in User helper multiple methods such as UserById, UserByEmail, Users, UpdateUser, DeleteUser\nand they all use struct Helper. Can you tell me if my approach is ok with multiple methods using same struct or?\n. You have mysql proxy for that. I do not see the point of having rw split in app.\n. ",
    "furio": "the import in my go file is \"gopkg.in/gorp.v1\". I'll retry\n. Ah, thank you that explains it. Anyway by using manual binding the correct size is sent, so i'm using that until v2 is out.\n. the import in my go file is \"gopkg.in/gorp.v1\". I'll retry\n. Ah, thank you that explains it. Anyway by using manual binding the correct size is sent, so i'm using that until v2 is out.\n. ",
    "cs2dsb": "I have a similar issue. \n\nI have the struct field \n\n```\nName        string  `db:\"name,size:50\"`\n```\n\nAnd when I run\n\n```\n_, err := dbmap.Select(&items, \"select * from item order by name\")\n```\n\nI get the error\n\n```\ngorp: No fields [name] in type Item\n```\n\nIf I take the size: tag off it works.\n\nI've tried both gopkg.in/gorp.v1 and github.com/go-gorp/gorp and I've run go get -u to make sure they are up to date.\n. I'm experiencing the issue on Windows. I've taken the code @qrawl posted and added a fetch after creating the database and i get the same error I was having \"no fields [...] in Post\" - the missing fields correspond to those with size: set.\n\nThe full code, the log and a screenshot of the database it created are [in this gist](https://gist.github.com/cs2dsb/5a0efee98e1725fd2723)\n\nI've was using postgres when I originally had the issue but this example is using sqllite for ease of sharing.\n. @GeertJohan Raised #266 to track my issue as requested\n. I have a similar issue. \n\nI have the struct field \n\n```\nName        string  `db:\"name,size:50\"`\n```\n\nAnd when I run\n\n```\n_, err := dbmap.Select(&items, \"select * from item order by name\")\n```\n\nI get the error\n\n```\ngorp: No fields [name] in type Item\n```\n\nIf I take the size: tag off it works.\n\nI've tried both gopkg.in/gorp.v1 and github.com/go-gorp/gorp and I've run go get -u to make sure they are up to date.\n. I'm experiencing the issue on Windows. I've taken the code @qrawl posted and added a fetch after creating the database and i get the same error I was having \"no fields [...] in Post\" - the missing fields correspond to those with size: set.\n\nThe full code, the log and a screenshot of the database it created are [in this gist](https://gist.github.com/cs2dsb/5a0efee98e1725fd2723)\n\nI've was using postgres when I originally had the issue but this example is using sqllite for ease of sharing.\n. @GeertJohan Raised #266 to track my issue as requested\n. ",
    "aleksandr-vin": "Thanks for your work.\nAny progress?\n. Thanks for your work.\nAny progress?\n. ",
    "djui": "Any progress? What's the current status?\n. Btw, what's the preferred way of mocking a GORP'd mapped db? Mock the dbMap interface?\n. @nelsam Thanks, (yes, I mean `gorp.DbMap` and sometimes `gorp.DbMap.Db`) I went with that exact idea.\n. Any progress? What's the current status?\n. Btw, what's the preferred way of mocking a GORP'd mapped db? Mock the dbMap interface?\n. @nelsam Thanks, (yes, I mean `gorp.DbMap` and sometimes `gorp.DbMap.Db`) I went with that exact idea.\n. ",
    "hibooboo2": "Has this been finished / sunsetted?\n. Has this been finished / sunsetted?\n. ",
    "avitex": "I too would like to know if this library is going to move forward\n. @smithwinston For the password handling, create a ignored field on the struct.\n\n``` go\ntype User struct {\n    // ...\n    Password     string  `db:\"-\"`\n    PasswordSafe string\n}\n\nfunc (u *User) SetPasswordSafe(newPassword string) {\n    // bcrypt, pbkdf2 password hasher\n    u.PasswordSafe = somehashfunction(newPassword)\n}\n\nfunc (u *User) PreInsert(s gorp.SqlExecutor) error {\n    if u.Password != \"\" {\n        u.SetPassword(u.Password)\n    }\n\n    return nil\n}\n```\n\nThis sort of pattern is similar to for example elixir's ecto library, where you would have a \"[virtual field](https://hexdocs.pm/ecto/Ecto.Schema.html)\".\n\n**Note:** It would [recommended](https://codahale.com/how-to-safely-store-a-password/) to use a one way hashing algorithm for storing passwords. Go's [crypto library](https://godoc.org/golang.org/x/crypto) has both [bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt) and [pbkdf2](https://godoc.org/golang.org/x/crypto/pbkdf2), two widely used algorithms.\n. I too would like to know if this library is going to move forward\n. @smithwinston For the password handling, create a ignored field on the struct.\n\n``` go\ntype User struct {\n    // ...\n    Password     string  `db:\"-\"`\n    PasswordSafe string\n}\n\nfunc (u *User) SetPasswordSafe(newPassword string) {\n    // bcrypt, pbkdf2 password hasher\n    u.PasswordSafe = somehashfunction(newPassword)\n}\n\nfunc (u *User) PreInsert(s gorp.SqlExecutor) error {\n    if u.Password != \"\" {\n        u.SetPassword(u.Password)\n    }\n\n    return nil\n}\n```\n\nThis sort of pattern is similar to for example elixir's ecto library, where you would have a \"[virtual field](https://hexdocs.pm/ecto/Ecto.Schema.html)\".\n\n**Note:** It would [recommended](https://codahale.com/how-to-safely-store-a-password/) to use a one way hashing algorithm for storing passwords. Go's [crypto library](https://godoc.org/golang.org/x/crypto) has both [bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt) and [pbkdf2](https://godoc.org/golang.org/x/crypto/pbkdf2), two widely used algorithms.\n. ",
    "a13xb": "@nelsam\n\n> `Get()` should only care about fields that are mapped to a struct.\n\nRight, I have probably misremembered.\n\n> Put simply, `select *` is code smell - don't do it.\n\nLet's agree to disagree here. I find it perfectly acceptable. From the perspective of my code, there is no practical difference between \"explicit list of all columns in a struct\" vs \"`*` + ignoring unknown columns\".\n\n> For generating a select statement, you can check out `gorq` [...]\n\nYes, failing build and a big warning on top doesn't fill me with confidence. :)\nIdeally, I'd prefer not to bring an extra 3rd party library, if possible, although I'm not completely against it, if there is no other alternative. Thanks for the suggestions.\n. `dbmap.TableFor` + `table.Columns` did the trick. :+1:\nCould be a candidate for a utility function, as it's mostly a just copy of [`bindGet`](https://github.com/go-gorp/gorp/blob/master/table_bindings.go#L267).\n. I think this code will likely be gone/replaced in 10 years, so I'm not terribly worried (famous last words).\n. @nelsam\n\n> `Get()` should only care about fields that are mapped to a struct.\n\nRight, I have probably misremembered.\n\n> Put simply, `select *` is code smell - don't do it.\n\nLet's agree to disagree here. I find it perfectly acceptable. From the perspective of my code, there is no practical difference between \"explicit list of all columns in a struct\" vs \"`*` + ignoring unknown columns\".\n\n> For generating a select statement, you can check out `gorq` [...]\n\nYes, failing build and a big warning on top doesn't fill me with confidence. :)\nIdeally, I'd prefer not to bring an extra 3rd party library, if possible, although I'm not completely against it, if there is no other alternative. Thanks for the suggestions.\n. `dbmap.TableFor` + `table.Columns` did the trick. :+1:\nCould be a candidate for a utility function, as it's mostly a just copy of [`bindGet`](https://github.com/go-gorp/gorp/blob/master/table_bindings.go#L267).\n. I think this code will likely be gone/replaced in 10 years, so I'm not terribly worried (famous last words).\n. ",
    "brucespang": "I've update the PR. I totally missed the `checkErr` calls in the previous examples, sorry.\n. I've update the PR. I totally missed the `checkErr` calls in the previous examples, sorry.\n. ",
    "justintv90": "Ok qrawl, i got it. Thanks so much for your help\n. Ok qrawl, i got it. Thanks so much for your help\n. ",
    "jmhodges": "So, this is because the note 1050 warning is always sent back as an error when strict mode is on even though the SQL works just fine. \n\nA fix would be to ignore to check if the error is of type [mysql.MySQLWarnings](https://godoc.org/github.com/go-sql-driver/mysql#MySQLWarnings), check if the only [mysql.MySQLWarning](https://godoc.org/github.com/go-sql-driver/mysql#MySQLWarning) inside has `Note == \"1050\"` and allow it.\n\nHowever, there is no dialect specific support for error checking like that in gorp. I'll just handle this in our code, but it would be nice if this could exist in gorp. I don't really expect this code to exist in gorp, however, as it involves making choices about the SQL driver libraries supported.\n. So, this is because the note 1050 warning is always sent back as an error when strict mode is on even though the SQL works just fine. \n\nA fix would be to ignore to check if the error is of type [mysql.MySQLWarnings](https://godoc.org/github.com/go-sql-driver/mysql#MySQLWarnings), check if the only [mysql.MySQLWarning](https://godoc.org/github.com/go-sql-driver/mysql#MySQLWarning) inside has `Note == \"1050\"` and allow it.\n\nHowever, there is no dialect specific support for error checking like that in gorp. I'll just handle this in our code, but it would be nice if this could exist in gorp. I don't really expect this code to exist in gorp, however, as it involves making choices about the SQL driver libraries supported.\n. ",
    "bhenderson": "note, I did not _add_ any tests.\n\nthanks,\n. note, I did not _add_ any tests.\n\nthanks,\n. ",
    "dlabey": "https://github.com/go-gorp/gorp/issues/85\n. https://github.com/go-gorp/gorp/issues/85\n. ",
    "pwaller": "Also, I want to mention that I have using this exact code with the race detector switched on many times daily for a month, and just now is the first time I saw it fire. I've been using the same pattern all over my code (Insert from goroutines handling web requests) for a year and I haven't seen it fire there either. So maybe  this is particularly hard for the race detector to spot for some reason?\n. I've tested this in my own codebase and it seems to do the trick.\n. Tests failed due to #302. Coverage went down!? Not sure I grok/believe that one.\n. Also, I want to mention that I have using this exact code with the race detector switched on many times daily for a month, and just now is the first time I saw it fire. I've been using the same pattern all over my code (Insert from goroutines handling web requests) for a year and I haven't seen it fire there either. So maybe  this is particularly hard for the race detector to spot for some reason?\n. I've tested this in my own codebase and it seems to do the trick.\n. Tests failed due to #302. Coverage went down!? Not sure I grok/believe that one.\n. ",
    "dencold": "I'm using goose in my current project & have found it to work really well. Just a note that you'll need to write direct SQL in order to update your schemas, but I generally prefer that over some magic in the ORM. ymmv. :+1: for @enahs recommendation!\n. I'm using goose in my current project & have found it to work really well. Just a note that you'll need to write direct SQL in order to update your schemas, but I generally prefer that over some magic in the ORM. ymmv. :+1: for @enahs recommendation!\n. ",
    "mashuai": "Gorp don't support it.\n. Gorp don't support it.\n. ",
    "jibuji": "Do we have any plan to support it?\n. Do we have any plan to support it?\n. ",
    "neelance": "Can this be backported to `v1`? We're currently running into this race condition, but updating to `master` is not recommended right now.\n. Can this be backported to `v1`? We're currently running into this race condition, but updating to `master` is not recommended right now.\n. ",
    "notzippy": "Any possibility of this getting merged ?. Any updates on this ? I have an application in need of this as well :-D. Any possibility of this getting merged ?. Any updates on this ? I have an application in need of this as well :-D. ",
    "bkali": "I see that the test coverage % has not passed. I can fix that. Please let me know if you have any other feedback. Thanks,\n\nBiju\n. I added some more test code to increase test coverage.  When I build on my dev machine I see 71% test coverage.  Coveralls is reporting 60.9% test coverage..  I am not sure which one to believe.. :-)\n\nPASS\ncoverage: 71.4% of statements\nok      github.com/bkali/gorp   103.338s\n. @stxml  : good catch :+1: It is an old habit of mine from C++ days (constants on the left of equality operator to avoid accidental assignment). \n. Thank you very much @nelsam !\n. I see that the test coverage % has not passed. I can fix that. Please let me know if you have any other feedback. Thanks,\n\nBiju\n. I added some more test code to increase test coverage.  When I build on my dev machine I see 71% test coverage.  Coveralls is reporting 60.9% test coverage..  I am not sure which one to believe.. :-)\n\nPASS\ncoverage: 71.4% of statements\nok      github.com/bkali/gorp   103.338s\n. @stxml  : good catch :+1: It is an old habit of mine from C++ days (constants on the left of equality operator to avoid accidental assignment). \n. Thank you very much @nelsam !\n. ",
    "stxml": "Weird style for \"if\" checks. It's the opposite of how standard Go and Gorp uses them, except when you check errors, then it's standard.\n\n```\nif nil != foo {\n...\n}\n\n```\n\n```\nif foo != nil {\n...\n}\n```\n. Weird style for \"if\" checks. It's the opposite of how standard Go and Gorp uses them, except when you check errors, then it's standard.\n\n```\nif nil != foo {\n...\n}\n\n```\n\n```\nif foo != nil {\n...\n}\n```\n. ",
    "pbberlin": "diff --git a/gorp_test.go b/gorp_test.go\nindex 98ea4d3..f73f55d 100644\n--- a/gorp_test.go\n+++ b/gorp_test.go\n@@ -1586,6 +1586,35 @@ func TestColumnFilter(t *testing.T) {\n        if inv2.IsPaid {\n                t.Error(\"IsPaid shouldn't have been updated\")\n        }\n-       inv1.Memo = \"d\"\n-       inv1.IsPaid = true\n-       _updateColumns(dbmap, func(col *gorp.ColumnMap) bool {\n-               return col.ColumnName == \"IsPaid\"\n-       }, inv1)\n  +\n-       inv3 := &Invoice{}\n-       inv3 = _get(dbmap, inv3, inv1.Id).(*Invoice)\n-       if inv3.Memo != \"c\" {\n-               t.Errorf(\"Expected column to be updated (%#v)\", inv3)\n-       }\n-       if !inv3.IsPaid {\n-               t.Error(\"IsPaid should now be updated\")\n-       }\n  +\n-       // classic update should work\n-       inv1.Memo = \"e\"\n-       inv1.IsPaid = false\n-       _update(dbmap, inv1)\n  +\n-       inv4 := &Invoice{}\n-       inv4 = _get(dbmap, inv4, inv1.Id).(*Invoice)\n-       if inv4.Memo != \"e\" {\n-               t.Errorf(\"Expected column to be updated (%#v)\", inv4)\n-       }\n-       if inv4.IsPaid {\n-               t.Error(\"IsPaid should be false again\")\n- ```\n    }\n  ```\n  \n  +\n  }\n  \n  func TestTypeConversionExample(t _testing.T) {\n  diff --git a/table.go b/table.go\n  index 5c51390..ae20dd0 100644\n  --- a/table.go\n  +++ b/table.go\n  @@ -26,12 +26,13 @@ type TableMap struct {\n      SchemaName     string\n      gotype         reflect.Type\n      Columns        []_ColumnMap\n-       keys           []*ColumnMap\n-       keys           []_ColumnMap // primary key column; can be autoIncrement\n      indexes        []_IndexMap\n      uniqueTogether [][]string\n      version        *ColumnMap\n      insertPlan     bindPlan\n      updatePlan     bindPlan\n- ```\n    colFilter      ColumnFilter // different column filters lead to different updatePlans\n  deletePlan     bindPlan\n  getPlan        bindPlan\n  dbmap          *DbMap\n  ```\n  \n  diff --git a/table_bindings.go b/table_bindings.go\n  index 5b049a3..34938e6 100644\n  --- a/table_bindings.go\n  +++ b/table_bindings.go\n  @@ -169,8 +169,17 @@ func (t *TableMap) bindInsert(elem reflect.Value) (bindInstance, error) {\n  }\n  \n  func (t *TableMap) bindUpdate(elem reflect.Value, colFilter ColumnFilter) (bindInstance, error) {\n  +\n-       // we distinguish mereley between\n      if colFilter == nil {\n-               if t.colFilter != nil {\n-                       t.updatePlan = bindPlan{}\n-               }\n-               t.colFilter = nil\n              colFilter = acceptAllFilter\n-       } else {\n-               t.updatePlan = bindPlan{} // a new bindPlan everytime; since we cannot compare colFilter funcs\n- ```\n            t.colFilter = colFilter\n  }\n  \n  plan := &t.updatePlan\n  ```\n. diff --git a/gorp_test.go b/gorp_test.go\nindex 98ea4d3..f73f55d 100644\n--- a/gorp_test.go\n+++ b/gorp_test.go\n@@ -1586,6 +1586,35 @@ func TestColumnFilter(t *testing.T) {\n        if inv2.IsPaid {\n                t.Error(\"IsPaid shouldn't have been updated\")\n        }\n-       inv1.Memo = \"d\"\n-       inv1.IsPaid = true\n-       _updateColumns(dbmap, func(col *gorp.ColumnMap) bool {\n-               return col.ColumnName == \"IsPaid\"\n-       }, inv1)\n  +\n-       inv3 := &Invoice{}\n-       inv3 = _get(dbmap, inv3, inv1.Id).(*Invoice)\n-       if inv3.Memo != \"c\" {\n-               t.Errorf(\"Expected column to be updated (%#v)\", inv3)\n-       }\n-       if !inv3.IsPaid {\n-               t.Error(\"IsPaid should now be updated\")\n-       }\n  +\n-       // classic update should work\n-       inv1.Memo = \"e\"\n-       inv1.IsPaid = false\n-       _update(dbmap, inv1)\n  +\n-       inv4 := &Invoice{}\n-       inv4 = _get(dbmap, inv4, inv1.Id).(*Invoice)\n-       if inv4.Memo != \"e\" {\n-               t.Errorf(\"Expected column to be updated (%#v)\", inv4)\n-       }\n-       if inv4.IsPaid {\n-               t.Error(\"IsPaid should be false again\")\n- ```\n    }\n  ```\n  \n  +\n  }\n  \n  func TestTypeConversionExample(t _testing.T) {\n  diff --git a/table.go b/table.go\n  index 5c51390..ae20dd0 100644\n  --- a/table.go\n  +++ b/table.go\n  @@ -26,12 +26,13 @@ type TableMap struct {\n      SchemaName     string\n      gotype         reflect.Type\n      Columns        []_ColumnMap\n-       keys           []*ColumnMap\n-       keys           []_ColumnMap // primary key column; can be autoIncrement\n      indexes        []_IndexMap\n      uniqueTogether [][]string\n      version        *ColumnMap\n      insertPlan     bindPlan\n      updatePlan     bindPlan\n- ```\n    colFilter      ColumnFilter // different column filters lead to different updatePlans\n  deletePlan     bindPlan\n  getPlan        bindPlan\n  dbmap          *DbMap\n  ```\n  \n  diff --git a/table_bindings.go b/table_bindings.go\n  index 5b049a3..34938e6 100644\n  --- a/table_bindings.go\n  +++ b/table_bindings.go\n  @@ -169,8 +169,17 @@ func (t *TableMap) bindInsert(elem reflect.Value) (bindInstance, error) {\n  }\n  \n  func (t *TableMap) bindUpdate(elem reflect.Value, colFilter ColumnFilter) (bindInstance, error) {\n  +\n-       // we distinguish mereley between\n      if colFilter == nil {\n-               if t.colFilter != nil {\n-                       t.updatePlan = bindPlan{}\n-               }\n-               t.colFilter = nil\n              colFilter = acceptAllFilter\n-       } else {\n-               t.updatePlan = bindPlan{} // a new bindPlan everytime; since we cannot compare colFilter funcs\n- ```\n            t.colFilter = colFilter\n  }\n  \n  plan := &t.updatePlan\n  ```\n. ",
    "tvmaly": "If possible, would I be able to take a look at that forked code ?. If possible, would I be able to take a look at that forked code ?. ",
    "Cubixmeister": "Travis is failing because of old MySQL version without JSON type support :(. Travis is failing because of old MySQL version without JSON type support :(. ",
    "keitaj": "I used gorp.PostgresDialect{}. I used gorp.PostgresDialect{}. ",
    "deepakverma256": "Apologise for opening this issue.\r\n\r\nI found that that the problem was in the query. the sub query was returning multiple records which I didnt check properly.. Apologise for opening this issue.\r\n\r\nI found that that the problem was in the query. the sub query was returning multiple records which I didnt check properly.. ",
    "inge4pres": "Hi :) no worries at all! Thank you for getting in touch. Hi @nelsam as this PR is 7 months old, I will reset my dev environment.\r\nI tihnk I should also pull latest changes from master to consitently release the feature to add support for Crate.\r\n\r\nFrom `travis.yml` I can see Crate is installed using the deprecated PPA installation: this forces use of 2.0.x, while a more recent version is available through adding repositories to have 2.1.x and higher, see [install-cratedb-from-ppa-legacy](https://crate.io/docs/crate/guide/en/latest/getting_started/install/local/linux.html#install-cratedb-from-ppa-legacy) and [install-from-deb-repo](https://crate.io/docs/crate/guide/en/latest/getting_started/install/local/linux.html#install-from-deb-repo).. I went as far as making pass the majority of tests, but at a certain point I'm facing that CrateDB has no INDEX statement available.\r\n. Hi :) no worries at all! Thank you for getting in touch. Hi @nelsam as this PR is 7 months old, I will reset my dev environment.\r\nI tihnk I should also pull latest changes from master to consitently release the feature to add support for Crate.\r\n\r\nFrom `travis.yml` I can see Crate is installed using the deprecated PPA installation: this forces use of 2.0.x, while a more recent version is available through adding repositories to have 2.1.x and higher, see [install-cratedb-from-ppa-legacy](https://crate.io/docs/crate/guide/en/latest/getting_started/install/local/linux.html#install-cratedb-from-ppa-legacy) and [install-from-deb-repo](https://crate.io/docs/crate/guide/en/latest/getting_started/install/local/linux.html#install-from-deb-repo).. I went as far as making pass the majority of tests, but at a certain point I'm facing that CrateDB has no INDEX statement available.\r\n. ",
    "srenatus": "@soniabhishek Heya -- any updates on this? I think it would be nice to have that.. @soniabhishek Heya -- any updates on this? I think it would be nice to have that.. ",
    "bryanpaluch": "I'm also interested in this as I've just started using tracing libraries. If I had some guidance on the desired API, I may be able to take a swing at it. . Hi @MatthewDolan I think you need to add support in a few more places. QueryRow -> QueryRowContext, Query -> QueryContext, Prepare -> PrepareContext, and pretty much any other time there is an alternative Context function call with *sql.DB. . I'm also interested in this as I've just started using tracing libraries. If I had some guidance on the desired API, I may be able to take a swing at it. . Hi @MatthewDolan I think you need to add support in a few more places. QueryRow -> QueryRowContext, Query -> QueryContext, Prepare -> PrepareContext, and pretty much any other time there is an alternative Context function call with *sql.DB. . ",
    "MatthewDolan": "Looks like it might be pretty simple to pipe through.\r\n\r\nWhat are you thinking in terms of the change to the API?\r\n\r\n(1) Add new `FooContext` methods that copy the existing methods.\r\n\r\n```\r\ntype SqlExecutor interface {\r\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\r\n\tGetContext(ctx context.Context, i interface{}, keys ...interface{}) (interface{}, error)\r\n\t\r\n\tInsert(list ...interface{}) error\r\n\tInsertContext(ctx context.Context, list ...interface{}) error\r\n\t\r\n\tUpdate(list ...interface{}) (int64, error)\r\n\tUpdateContext(ctx context.Context, list ...interface{}) (int64, error)\r\n\t\r\n\tDelete(list ...interface{}) (int64, error)\r\n\tDeleteContext(ctx context.Context, list ...interface{}) (int64, error)\r\n\t\r\n\tExec(query string, args ...interface{}) (sql.Result, error)\r\n\tExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\r\n\t\r\n\t...\r\n}\r\n```\r\n\r\n(2) Add a `WithContext(ctx)` which attaches the context to the dbMap.\r\n\r\n```\r\ntype SqlExecutor interface {\r\n\tWithContext(ctx context.Context) SqlExecutor\r\n\r\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\r\n\tInsert(list ...interface{}) error\r\n\tUpdate(list ...interface{}) (int64, error)\r\n\tDelete(list ...interface{}) (int64, error)\r\n\tExec(query string, args ...interface{}) (sql.Result, error)\r\n\t...\r\n}\r\n```\r\n\r\n(3) I guess it's possible to do something backward incompatible that forces context, but I assume that's not desirable.\r\n\r\n(1) is probably most similar to how go changed the underlying sql.Db, but it add the most new methods.. This is merged.\r\n\r\n@nelsam would it be possible to get a new release (2.1.0) associated with this? . Couple of problems I just noticed with the build.\r\n\r\n(1) The \"context\" package was added with Go 1.7 so adding it to the API would break compatibility with Go 1.6. Is that an issue? I guess I could copy it's definition into gorp, but that seems like it would break going forward.\r\n\r\n(2) The Context API being added to db.Sql wasn't added until I think Go 1.8. I changed it so it will degrade gracefully to not passing on the context in earlier versions, but that will make the test I added fail unless I can exclude that test for earlier versions.. Thanks for the comments @srenatus and @nelsam.\r\n\r\nI removed 1.6 as a supported version for travis and added 1.8 and 1.9.\r\n\r\nAnd I moved the cancelation test into a new file that only runs on 1.8 and above.\r\n\r\nThe tests are passing now for 1.7, 1.8, and 1.9.. @bryanpaluch Oh you are totally right. Let me take another look.. @bryanpaluch Thanks. I updated the PR to add the other calls.\r\n\r\nBuild is passing for 1.7, 1.8, and 1.9.. @nelsam Just in-case you missed my comment inline, I added an exclusion list instead of an inclusion list like you suggested.\r\n\r\nLet me know if there is anything else I need to update.\r\n\r\nThanks for taking a look.. Everything looks good to me. Feel free to merge.\r\n\r\nThanks for looking through this.. Looks like it might be pretty simple to pipe through.\r\n\r\nWhat are you thinking in terms of the change to the API?\r\n\r\n(1) Add new `FooContext` methods that copy the existing methods.\r\n\r\n```\r\ntype SqlExecutor interface {\r\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\r\n\tGetContext(ctx context.Context, i interface{}, keys ...interface{}) (interface{}, error)\r\n\t\r\n\tInsert(list ...interface{}) error\r\n\tInsertContext(ctx context.Context, list ...interface{}) error\r\n\t\r\n\tUpdate(list ...interface{}) (int64, error)\r\n\tUpdateContext(ctx context.Context, list ...interface{}) (int64, error)\r\n\t\r\n\tDelete(list ...interface{}) (int64, error)\r\n\tDeleteContext(ctx context.Context, list ...interface{}) (int64, error)\r\n\t\r\n\tExec(query string, args ...interface{}) (sql.Result, error)\r\n\tExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\r\n\t\r\n\t...\r\n}\r\n```\r\n\r\n(2) Add a `WithContext(ctx)` which attaches the context to the dbMap.\r\n\r\n```\r\ntype SqlExecutor interface {\r\n\tWithContext(ctx context.Context) SqlExecutor\r\n\r\n\tGet(i interface{}, keys ...interface{}) (interface{}, error)\r\n\tInsert(list ...interface{}) error\r\n\tUpdate(list ...interface{}) (int64, error)\r\n\tDelete(list ...interface{}) (int64, error)\r\n\tExec(query string, args ...interface{}) (sql.Result, error)\r\n\t...\r\n}\r\n```\r\n\r\n(3) I guess it's possible to do something backward incompatible that forces context, but I assume that's not desirable.\r\n\r\n(1) is probably most similar to how go changed the underlying sql.Db, but it add the most new methods.. This is merged.\r\n\r\n@nelsam would it be possible to get a new release (2.1.0) associated with this? . Couple of problems I just noticed with the build.\r\n\r\n(1) The \"context\" package was added with Go 1.7 so adding it to the API would break compatibility with Go 1.6. Is that an issue? I guess I could copy it's definition into gorp, but that seems like it would break going forward.\r\n\r\n(2) The Context API being added to db.Sql wasn't added until I think Go 1.8. I changed it so it will degrade gracefully to not passing on the context in earlier versions, but that will make the test I added fail unless I can exclude that test for earlier versions.. Thanks for the comments @srenatus and @nelsam.\r\n\r\nI removed 1.6 as a supported version for travis and added 1.8 and 1.9.\r\n\r\nAnd I moved the cancelation test into a new file that only runs on 1.8 and above.\r\n\r\nThe tests are passing now for 1.7, 1.8, and 1.9.. @bryanpaluch Oh you are totally right. Let me take another look.. @bryanpaluch Thanks. I updated the PR to add the other calls.\r\n\r\nBuild is passing for 1.7, 1.8, and 1.9.. @nelsam Just in-case you missed my comment inline, I added an exclusion list instead of an inclusion list like you suggested.\r\n\r\nLet me know if there is anything else I need to update.\r\n\r\nThanks for taking a look.. Everything looks good to me. Feel free to merge.\r\n\r\nThanks for looking through this.. ",
    "soniabhishek": "@srenatus @nelsam I would like to work over this, just wanted to confirm that above-mentioned approach (i.e. 2) is what needs to be implemented . @srenatus @nelsam I would like to work over this, just wanted to confirm that above-mentioned approach (i.e. 2) is what needs to be implemented . ",
    "nvcnvn": "Travis, check this for me!. So strange since my fork travis run all test success. Closed PR and fixing. I updated with new PR here https://github.com/go-gorp/gorp/pull/347. Travis, check this for me!. So strange since my fork travis run all test success. Closed PR and fixing. I updated with new PR here https://github.com/go-gorp/gorp/pull/347. ",
    "solcates": "Added \"Date\" type for mysql as well. Added \"unique\" reflection support to create unique columns i.e. email etc.... Sure will add that sometime this week. Added \"Date\" type for mysql as well. Added \"unique\" reflection support to create unique columns i.e. email etc.... Sure will add that sometime this week. ",
    "icholy": "I just found `SqlTyper`. @nelsam done and squashed.. Messed up the rebase, fixed now.. In regards to changing the null types, I think that will break compatibility with `sql.Null<Name>` types.. I just found `SqlTyper`. @nelsam done and squashed.. Messed up the rebase, fixed now.. In regards to changing the null types, I think that will break compatibility with `sql.Null<Name>` types.. ",
    "aclindsa": "@nelsam Sure! I went ahead and added unit tests for most of the Postgres dialect to this PR while I was at it. In particular, check out the section starting at https://github.com/go-gorp/gorp/pull/360/commits/4735379e1f46302b58b985d8172a53988aad93b4#diff-789f76b9887a0368e5cd3200b57cb6a1R129 for the tests covering this new lowercase field behavior.\r\n\r\nI'm a little bit confused at the moment because the tests on travis seem to be inconsistently failing, but I can't get them to fail when running locally.. @nelsam Sure! I went ahead and added unit tests for most of the Postgres dialect to this PR while I was at it. In particular, check out the section starting at https://github.com/go-gorp/gorp/pull/360/commits/4735379e1f46302b58b985d8172a53988aad93b4#diff-789f76b9887a0368e5cd3200b57cb6a1R129 for the tests covering this new lowercase field behavior.\r\n\r\nI'm a little bit confused at the moment because the tests on travis seem to be inconsistently failing, but I can't get them to fail when running locally.. "
}